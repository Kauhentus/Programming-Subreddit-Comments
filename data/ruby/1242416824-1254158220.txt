I think the problem with it in my mind is that I tend to view links as a way to pay some respect to content creators, and this sort of inverts that relationship. For those who do not attach that social value to links, it probably does sound like a big fuss over nothing. But we're all bothered by different things, I guess. 
Great point, but about.com seems to be using the regular, proper URL as the destination within the code. It's just they're catching the clickthrough with JavaScript and then piping it through their framer. So you still get the search engine juice but JavaScript-equipped browsers get sent through an alternative mechanism. At least, that's how it looked to me. I could be wrong and definitely would accept correction if so :) In any case, yes, I certainly believe in linking to the correct URLs for the social (and technical!) value of links.
Yeah, I think as far as search engine juice is concerned, they may be passing it through. But that's actually really sad, I saw only 23 in-visits from there. :) But my comment was primarily about the social value. The technical issue is a whole other can of worms.
Yes, jRuby has pthreads, yet it possible to have concurrency even with a GIL. Consider the reactor pattern. In Ruby, there is Event Machine and Revactor. In Python, there is Twisted. Both languages' C implementation has a GIL. Basically, there is a very fast C loop, which you can attach events to. You can even defer work when there is a response on a socket. This is similar to how microcontrollers work (usually a global loop and interrupts).
This seems to work by extracting the files to a temporary directory. I'd prefer exerb if possible.
It would be great if it extracted the files to it's own directory and possibly make the directory hidden. That way every invocation would not trigger a expansion and extraction.
Robert Klemme ponders why we see catch ... throw so rarely in Ruby, among other things.
by concurrency do you mean utilization of multiple cores?
I read the whole thing hoping for some insight. Turns out, the guy just didn't know what he was talking about. Quite literally. 
Funny I have been looking for a site like this for a while; however, now that I see this site I feel that I am likely to only check out the most popular gem or maybe even the second most popular gem listed by the site. It would be helpful if information about when the compared projects were first introduced to have perspective of the the rate of popularity growth. I suppose this metric may be established after Ruby Toolbox follows the projects for a while. A project that has been around for a year is likely to have more watchers than a project released a couple weeks ago.
Topped up to make $314.15 http://imgur.com/wefna.png The gauntlet has been laid. Let's geek this system
Application framework which uses Actor model
Change vm_opts.h: #define OPT_TRACE_INSTRUCTION 0 #define OPT_TAILCALL_OPTIMIZATION 1 ... and recompile. Also see http://redmine.ruby-lang.org/issues/show/1256
An example (really lispy): # Tail recursive factorial def factorial n def factorial1 n, acc return acc if n.zero? factorial1(n.pred, acc * n) end factorial1(n, 1) end factorial 10000 This finishes with fine with TCO enabled, and of course it explodes without it, or on 1.8.x
The article is a year old and this is the quote &gt;Current Ruby 1.9 (trunk) is not enabled this optimization. If you want to try this, please re-write that option in "vm_opts.h" (OPT_TAILCALL_OPTIMIZATION) and re-compile that. I think release version of Ruby 1.9 is enabled this optimization. I need more comments of it. Please teach me if you find out some critical problem. Does this mean it's there now and enabled?
No it's disabled by default. /* Compile options. * You can change these options at runtime by VM::CompileOption. * Following definitions are default values. */ #define OPT_TRACE_INSTRUCTION 1 #define OPT_TAILCALL_OPTIMIZATION 0 #define OPT_PEEPHOLE_OPTIMIZATION 1 #define OPT_SPECIALISED_INSTRUCTION 1 #define OPT_INLINE_CONST_CACHE 1 This comment says we can toggle these at runtime to turn it on, but I don't seem to have a VM constant to do so. I'm looking into it now. __Edit:__ The option is actually RubyVM::InstructionSequence.compile_option, where you can check if this is enabled. The bottom of [this](http://redmine.ruby-lang.org/issues/show/1256) page shows how you can enable it at runtime, but it is directly instantiating a new bytecode compiler. It would be nice if you could provide a flag to the ruby binary or something.
That nested method definition doesn't do what you think. It's defining the method on the same level as `factorial` everytime you run it, so you actually end up with both `factorial` and `factorial1` on self.
It does do what I think it does, you just assumed I didn't know that. :)
Oh, well. It is a common mistake (especially for those coming from the Lisp-community), and in this case it just doesn't make any sense to use it :)
Ruby doesn't have inner methods, so I fail to see why you did that. Also, why not just use: &gt; def factoral(n, acc = 1) Edit: Why am I getting downvoted? I pointed out ruby doesn't have inner methods and then provided a way to implement it only using one method by using a default argument...
I thought it was cute to make it look like Lisp, that is all. I realize there is no inner scope for methods like that. I should have known that when posting it here that people would point that out.
You could implement it as a lambda. def factorial(n) fac1 = lambda {|n, acc|} { return acc if n.zero?; fac1.call(n.pred, acc * n) } fac1.call(n, 1) end That works, but I'm not sure if it optimizes.
Proc#call should optimize, right?
For some reason, this explodes: irb(main):008:0* l = lambda{ l.call } =&gt; #&lt;Proc:0x13edcc@(irb):8 (lambda)&gt; irb(main):009:0&gt; l.call SystemStackError: stack level too deep from (irb):8:in `call' ... ... but this works: irb(main):010:0&gt; def a irb(main):011:1&gt; a irb(main):012:1&gt; end =&gt; nil irb(main):013:0&gt; a And goes 100% CPU and makes you kill -9 it as it is turned into a tight loop.
I'm just going to take this in a silly direction and post some funny code I've been playing with. #!/usr/bin/env ruby class Array def car raise if self.empty? self.first end def cdr raise if self.empty? dup = self.dup dup.shift dup end end def reverse_list list, acc = [] return acc if list.empty? reverse_list(list.cdr, acc.unshift(list.car)) end list = (0..100_000).to_a if ARGV.first == 'builtin' # Normal way list.reverse elsif ARGV.first == 'iterator' # iterator result = [] list.each do |elem| result.unshift elem end else # Silly way with TCO/Data copying reverse_list list end Time for builtin reverse: real 0m0.036s user 0m0.022s sys 0m0.009s Time for Iterator version: real 0m3.608s user 0m3.398s sys 0m0.033s Time for pretend functional TCO version: real 0m3.713s user 0m3.510s sys 0m0.033s 
And you did test this on a version with TCO enabled at compile-time, right? :)
I've been using it for a couple weeks now, and have one website using it live in a production environment. It's very awesome, I must say. It gets out of the way of your main Rails cod and provides a very easy to use CMS for both the developer and the client. I think it has catapulted itself to the head of the Rails CMS' pack.
Yes.
Yes, but how many people have experienced what it's like to go against the grain of the "Rails Way"?
Github has done more damage than good for the ruby community. Too many forks of everything, almost all of them not maintained anymore, almost all of them forked to solve one problem or another, almost none of them have pushed their changes back to the origin (because the origin isn't being maintained anymore and the author doesn't give a shit). 
Looks like it hasn't been touched in a long time. No blog entries. Scant documentation. Interesting project but I guess there wasn't enough interest.
This too could be a useful metric for determining the weight of a given tool within the community no?
This claim is absolute bullshit, based on a confusing tweet by my friend Pete Forde in Canada. Tools and Techniques are only one aspect of RMM and Ruby Toolbox, while a great tool, is really an apples and oranges comparison to RMM.
I don't see this technique as going against the Rails Way. I think of it more as not using the Rails Way. This will not conflict with Rails so long as you continue to use this technique.
Rails seriously needs to refactor its RJS and ajax helpers and become more jQuery friendly. I try to use the RJS and ajax helpers as little as possible because I feel a little dirty every time I do. I'm hoping Rails 3 will adopt unobtrusive javascript and maybe give a jQuery option.
rails 3 will be JS agnostic and heavily focused on unobstrusive JS. look into the Railsconf keynote by DHH or check out Yehuda's talk tomorrow "What to Expect in Rails 3.0" http://www.oreillynet.com/pub/e/1338
Every time I start to think I'm getting really good at Ruby/Rails I read a post like this that reminds me that I know nothing.
I disagree. If anything it represents the brokenness of the code. People would not fork the code if it didn't work or wasn't abandoned. chances are the code is forked because somebody wanted to make a change and was not able to contact the author or convince the author to accept his patch. 
This is part one of a forthcoming series about ruby - and why I love it. This first episode focuses on general ideas, concepts and philosophy about ruby and a gentle introduction to its class system.
I guess because it works only with ruby 1.9 and it hasn't been adopted yet widely.
This just seriously pushed me over my- do i wanna learn ruby state. too much to learn this summer.
Tony stopped work on this a while back. He's putting his efforts into [reia](http://wiki.reia-lang.org) which is a ruby like language based on the erlang VM.
Which one of these books should I read next?
I just bought both about two weeks ago. Everyone learns differently of course but imo the well-grounded rubyist is perfect for learning the language and the "pickaxe book" is an excellent language reference book to have in front of me while i code. 
It doesn't really matter. You won't have finished learning Ruby after reading either.
It seems to me the efforts would be better spent on 1.9. 
Why even bother complaining about things that are being addressed already?
I'm glad to hear this :) Thanks for the positive feedback and stay tuned for more posts about ruby :)
Depends on the kind of person you are but more and more I am finding the idea of buying programming books kind of useless. You pay a lot of money and the information goes out of date quick. All the information you need is on the web so why buy a book. Yes there is some value in reading a book on the can but hey I can take my laptop to the can too. 
&gt; It’s best described as: the ability to take a function that accepts n parameters and generate from it one of more functions with some parameter values already filled in. Isn't that partial application? I thought currying was taking a n-ary function and producing an equivalent n-1-ary function? Have I got it the wrong way around?
Tried to watch a couple and the sound is horrible. 
I'm pretty sure you're right. That said, the actual `curry` method in Ruby 1.9 is correctly named because it applies the transformation without fixing any of the arguments. The article just seems to have that one definition wrong.
Figured you guys would be interested in this, it's an awesome editor and mostly written in ruby, win all around!
Thanks for notifying me guys, i have updated the post to show the diff.
Sounds cool, do you think it would be possible to compile this in windows? (it's GTK+Ruby after all)
This is the mosyt god-awful way to generate a mandelbrot set. I know it's only an example about inject, but really, don't use inject like this! If you have to make an array of the same element repeated many times just so you can get inject to do the calculation you require, you're doing something wrong! And using ruby for generating fractals? At least use Java if you're not going to do it in C. Please :-)
In theory, yes. However there is a world of pain some plucky soul will have to take on to get from here to there.
Theoretically there should be no problems, but the build system probably doesn't work so you'd have to write your own and go through hell. Doesn't seem like there's any unix-specific code in there though.
I've been following this. It really looks promising. I watch all the Railscasts episodes, and having an editor that works almost exactly like Textmate would be so nice in gnu/linux. Plus with this release, it looks like the Railscasts Textmate theme is included. Great work!
What are the chances MacRuby (0.5) will be the ruby implementation shipped with Snow Leopard?
@onbears probably very small. I have not idea when Snow Leopard will be shipped but I guess it will be ready before MacRuby 0.5. However, because you can bundle macruby in your app, it really doesn't matter much.
The article points out ruby1.9 supports currying/partial evaluation, which I thought was interesting. plus = lambda{|a,b| a + b } plus_one = plus.curry.(1) plus_one.(5) =&gt; 6 I've also seen someone implement function composition: class Proc def self.compose(f, g) lambda {|*args| f.call(g.call(*args)) } end def *(g) Proc.compose(self, g) end end inc = lambda {|x| x + 1} twice = lambda {|x| x * 2} twice_of_inc = twice * inc twice_of_inc.call(4) =&gt; 10 I found that last example [here](http://blog.moertel.com/articles/2006/04/07/composing-functions-in-ruby)
Doubly, I have been told by reliable sources that Apple has internal apps that depend on 1.8.6. Apple tends to ship their OS with many of the things they need to run their internal apps. A good example of this is some of the obscure gems bundled with Leopard. The point being that Apple probably has quite a bit of work to do to ensure the compatibility of their internal apps before MacRuby can be the default Ruby implementation OS X ships with.
They really need to give up this schtick and just get some real funding.
This is pretty neat, thanks postmodern.
Wow! I'll be doing some code-reading tonight, I think. This is going to be very useful, I feel. Very Smalltalk-ish. 
OK this fooled me for a bit. It's not [live-coding](http://www.toplap.org/) .. it's a repl. Still cool - especially if you use a shell-based editor such as vim anyway.
This is plain awesome.
Before anyone complains that it's a blatant ripoff of isitruby19, read this (tip: yes, it is ;-) ):http://bit.ly/aKyNl 
I've been conditioned to think any website with a URL like that will consist of a giant "NO" on a white background.
Just tried it. Works great. So, awesome.
eponymous.
This looks pretty cool.
ActiveSupport-JCache is a jRuby gem that lets you use Rails.cache in a jRuby on Rails on Google App Engine application. 
I'm so glad you shortened that URL.
so.. what you're trying to say is that you're a dick?
That's an interesting idea, but failing the build seems kind of dramatic -- sometimes you need code that doesn't fit nicely into quality metrics (like you really need the tiny increase in speed you get from unrolling a loop in some critical function), or you just need to check in a temporary fix that's not pretty, but needed asap and with minimal changes to the code base. Seems like the best place for these tools would be in the commit or code-review process, where you as a human can decide if the results of the metrics are appropriate for the changed code.
"Go have a good hard look at yourself in the mirror and consider if you really want to be a professional software developer or not." Jesus, seriously... what a dick.
I am learning Ruby and am loving every minute of it. I learned the basics of the language, understand most of the concepts and have played around with the library for quite sometime. I ported a lot of my algorithms into ruby and am getting a hang of the language. What is the next logical step for me? How do go on to get more knowledge and nuances of the language? What were the books that helped you? It would be great if somebody could make a learning path like *Pick Axe-&gt; X -&gt; X* for newbies like us . I have to add that I am not really interested in programming in Rails. Thanks a lot.
I just picked up "The Well-Grounded Rubyist" by David Black and it's great so far...
I always recommend to read "The Ruby Way" over the Pick Axe. You can still benefit from reading "The Ruby Way", but if you feel you have a good grounding in Ruby then I would say for the time being just get out and start coding. You'll quickly realize where your strengths and weaknesses lie. Then you can work on those. If you feel the need to memorize any one aspect of Ruby then I would say that you should have the Ennumerable module memorized. It is probably the most important library you'll be using.
I concur on learning Enumerable well, but I'll respectfully disagree on *The Ruby Way*. *The Ruby Way* was a great book in 2006, but things have changed, and some of the code in there looks old now. I'd recommend *The Well-Grounded Rubyist* or *Ruby Best Practices* for a next step. *The Ruby Programming Language* is good once you have a handle on things and want to know everything deeper. Reading through the standard library (while it has its low parts) has a lot of wonderfully instructive code.
I say just start coding...once you've got the basics down, the best way to learn is through doing...also browsing some source code and googling any idioms you don't get will make you a far better coder in the long run.
It's likely that Ruby isn't your first language, so take some utility or application from some other language, and port it to Ruby. Or, you know, use it to solve some new problem that doesn't have a sufficient solution already. (I'm assuming you're not just collecting languages, you're actually trying to apply them to something.) 
s/changing/fragmenting/ Woo hoo; just what we need.
Learn about rspec or something similar, join the ruby-talk mailing list (if you haven't already done so yet), read code, write code.
Browse github and read code for things that look interesting. 
Why's Poignant Guide to Ruby... you need a break from reading dry explanations. Plus, it has cartoon foxes and explains some actually pretty advanced ruby concepts: http://poignantguide.net/ruby/ Oh, also, write some code to do something you need or want to do.
Read "Design patterns in Ruby" by Russ Olsen. It's brilliantly written and very informative. Definitely one of the best programming textbooks I've read.
Completely agree. On a related topic, what's the verdict on TaskLibs? They seem opaque and unextensible to me, but perhaps I missed something.
Have any of you actually used this? The docs show you how to set it up and open files, but having done that, nothing seems to be going on. I've manually had to load my modules, and the changes aren't being picked up. Need better docs and perhaps an irb listing from a sample session.
The Ruby Programming Language is awesome when you want to take your understanding of the language to the next level.
(Oh my!)
Here's the link to the original article: http://august.lilleaas.net/procs_and_blocks_and_anonymous_functions Is this site pretending to have written the post when it's fact by someone else i.e. "by Rails Fire"? They put someone else's article completely inline and only link to it at the end. Wtf? Seems pretty scummy to me.
Do you have an example? I've not heard of these.
Pretty good idea, but it only works for server-side applications. Instead of trying to maintain a version 'number' for development builds of my software I just use the git commit-ish, the first 4 to 8 characters are usually unique and are no more troublesome to use.
although they are not in a sequenced order, so it's difficult to communicate a meaningful version number to clients.
Woo, anything to make releasing a gem easier.
I mostly publish gems off github anymore, but this looks like a nice way to give a little love back to RubyForge... now that they have made their system auto-approve new repos, it's time to give them a comeback.
I'll have to try this out, publishing to RubyForge and GitHub breaks DRY and is a PITA
Development versions don't need to be in a sequenced order, the important part is knowing exactly what commit was built. When I release I of course give it a 'real' version.
cool to see a simple creator gem built around thor, but no github support + no tests are turnoffs
&gt; Building a massively scaled, fault tolerant web service isn't easy, but it's definitely easier if you know which architectures work and which don't. In this talk we'll survey the architecture and complexities of a scalable web service including edgeware, middleware, message systems, load balancing, cache hierarchies, queueing theory, coordination primitives for distributed computation, designing for latency, inter-process communication, load balancing versus locality, write versus read throughput, non-relational datastores, database replication topologies, logging distributed computations, fault tolerance, deployment at scale, forensics, and the merits of suicide.
You'll notice the quiet omission of Matt Aimonetti's talk in the 'archives'. Although the liveblog entry is still up. http://pivotallabs.com/users/rdy/blog/articles/801-gogaruco-09-couchdb-ruby-perform-like-a-pr0n-star-matt-aimonetti
I think [jeweler](http://github.com/technicalpickles/jeweler/tree/master) also aims to tackle this problem.
Joe's code resides on GitHub, but apart from that I don't know what kind of GitHub support you are expecting from it. About the tests: Joe is a script that packages your gem and releases it to RubyForge. It provides helpful error messages in case anything fails, and it is in use by the Citrusbyte crew. I guess a lot of people (you included) can profit from it, and the fact that it doesn't include tests is because its development wasn't test driven and it's so minimal that it worked on the first pass. Anyway, as it resides on GitHub, you are free to fork it and add your own tests. What I find amusing is that none of your scripts and Thor tasks in GitHub have tests, so I guess your own code is no more than a big turnoff for you.
I think the comments were pretty bad all round, from the ruby, java and python guys. There were one or two good comments, but everyone else came across as clueless zealots for their respective programming language. I suppose that is the problem with small comparisons like this, it doesn't really give you any indication as to the quality of the framework, but it is enough for the zealots to sink their teeth into.
I'm surprised that you're comparing my random github scripts to a gem that's being promoted. Personally, if someone puts up their gem and wants to promote it, I expect there to be some kind of tests. Apparently that's not an expectation we share.
It's not a gem, it's just a script. You can profit from it or you can ignore it, it's your call and you won't hurt anyone. I mentioned your scripts because I noticed you have a blog post about building gems with Thor and Jeweler, where you point to a Thor file of yours that has no tests. That didn't stop you from promoting it and that's perfectly fine to me, because the code is short and clear and you are trying to help others, something I value a lot. What we are doing with Joe is exactly the same: trying to help others with something that gave us great results so far.
Uhh... IO#readpartial?, IO#read(length)? IO#gets(separator)? The same code can be accomplished with "IO#each('~'){|line|}" Somebody just got too used to IO#gets(). Probably should use IO#each\_char() as well, if you want to be 1.9 compatible; you can just "alias\_method :each\_char, :each\_byte unless method\_defined?(:each_char)" if you need to be 1.8.6 compatible as well.
This is the most poorly done article on IO in ruby I have ever seen. In 1.8 his each_byte code is going to run slower than crap, and on 1.9 it is still slower than it should be. Not to mention his lack of awareness for stuff like IO#read.
Rake::TaskLib is the superclass of things like Rake::TestTask. Beyond that, the rubydoc is no help at all. I was hoping for nice ways to wrap provided functionality with my own (a gazillion people have asked "how do I redirect the output of my tests", for example). I resorted to cloning the library tasks in my own Rakefile/libs. Worth the effort, because Rake is still great!
I started Ruby a little over a year ago, and my first exposure was: http://tryruby.hobix.com/ which is a VERY nice tutorial that you can try Ruby within your browser. It was awesome, and got me hooked on the language. That's probably not your next step, but I just wanted to comment on your comment of not being interested in programming in Rails. See, back when I started Ruby, I was just interested in trying a new language too. I had heard buzz about Rails, but was not interested one bit. Then, a couple months ago at my current job, we started to try Rails on top of our Java web app, to build out new features and products but integrate with our existing Java app. I can say that after delving into Rails... it is just as awesome as Ruby is. You probably will ignore this comment... I know I ignored similar comments when I was at that stage... and you are probably right to. Having a good foundation in Ruby made jumping into Rails VERY easy. If you have any interest in web development, I would highly recommend giving Rails a whirl in a few months, after you feel very comfortable in Ruby (assuming you continue to enjoy the language of course).
Yes, Hoe and Jeweler tackle this problem but the approach is different: they need some setup in order to generate the gemspec. In the end, it feels like writing the gemspec but in a different file. Think of Joe as a lightweight approach to the problem: instead of setting up Hoe or Jeweler, you only need to write the gemspec. Many developers already do this, because it's the only requirement for releasing a gem to GitHub. For those people, there's no extra work involved.
Clever! I never knew about pbpaste and its ilk. Very useful.
Thanks for the explanation!
*Ruby Best Practices* was written to be complimentary to *The Ruby Programming Language*. So if you are looking for both a solid reference and some higher level problem solving techniques, picking up both might be a good way to go. That having been said, WGR or the Pickaxe 3 are also good choices.
&gt; "you only need to write the gemspec" Writing and maintain a gemspec is a serious PITA. Especially once you have many gems to maintain. Especially once you have many more releases to deal with. 5011 commits, 89 products (not all released, _yet_), 291 releases, 201 of which were with hoe. Compare: Hoe.spec "hoe" do developer "Ryan Davis", "ryand-ruby@zenspider.com" self.rubyforge_name = "seattlerb" end vs: Gem::Specification.new do |s| s.name = %q{hoe} s.version = "2.0.0" s.required_rubygems_version = Gem::Requirement.new("&gt;= 1.3.1") if s.respond_to? :required_rubygems_version= s.authors = ["Ryan Davis"] s.cert_chain = ["/Users/ryan/.gem/gem-public_cert.pem"] s.date = %q{2009-06-07} s.default_executable = %q{sow} s.description = %q{... very long string ...} s.email = ["ryand-ruby@zenspider.com"] s.executables = ["sow"] s.extra_rdoc_files = ["History.txt", "Manifest.txt", "README.txt"] s.files = ["History.txt", "Manifest.txt", "README.txt", "Rakefile", "bin/sow", "lib/hoe.rb", "lib/hoe/clean.rb", "lib/hoe/debug.rb", "lib/hoe/deps.rb", "lib/hoe/flay.rb", "lib/hoe/flog.rb", "lib/hoe/inline.rb", "lib/hoe/package.rb", "lib/hoe/publish.rb", "lib/hoe/rake.rb", "lib/hoe/rcov.rb", "lib/hoe/signing.rb", "lib/hoe/test.rb", "template/.autotest.erb", "template/History.txt.erb", "template/Manifest.txt.erb", "template/README.txt.erb", "template/Rakefile.erb", "template/bin/file_name.erb", "template/lib/file_name.rb.erb", "template/test/test_file_name.rb.erb", "test/test_hoe.rb"] s.homepage = %q{http://rubyforge.org/projects/seattlerb/} s.rdoc_options = ["--main", "README.txt"] s.require_paths = ["lib"] s.rubyforge_project = %q{seattlerb} s.rubygems_version = %q{1.3.4} s.signing_key = %q{/Users/ryan/.gem/gem-private_key.pem} s.summary = %q{Hoe is a rake/rubygems helper for project Rakefiles} s.test_files = ["test/test_hoe.rb"] if s.respond_to? :specification_version then current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION s.specification_version = 3 if Gem::Version.new(Gem::RubyGemsVersion) &gt;= Gem::Version.new('1.2.0') then s.add_runtime_dependency(%q&lt;rubyforge&gt;, ["&gt;= 1.0.3"]) s.add_runtime_dependency(%q&lt;rake&gt;, ["&gt;= 0.8.7"]) else s.add_dependency(%q&lt;rubyforge&gt;, ["&gt;= 1.0.3"]) s.add_dependency(%q&lt;rake&gt;, ["&gt;= 0.8.7"]) end else s.add_dependency(%q&lt;rubyforge&gt;, ["&gt;= 1.0.3"]) s.add_dependency(%q&lt;rake&gt;, ["&gt;= 0.8.7"]) end end 
Right, a single MRI process cannot access multiple cores. However, you can achieve multi-core concurrency using separate processes and communicate using sockets. Of course, you don't get the benefits of shared memory (everything is message passing), but there are services such as memcached which can help.
Hey zenspider, thanks for chipping in. I can play this game too: I took Gruff as an example of what you have to do in order to release a gem with Hoe. First, you have to write this in your Rakefile: require 'rubygems' require 'hoe' $:.unshift(File.dirname(__FILE__) + "/lib") require 'gruff' Hoe.new('Gruff', Gruff::VERSION) do |p| p.name = "gruff" p.author = "Geoffrey Grosenbach" p.description = "Beautiful graphs for one or multiple datasets. Can be used on websites or in documents." p.email = 'boss@topfunky.com' p.summary = "Beautiful graphs for one or multiple datasets." p.url = "http://nubyonrails.com/pages/gruff" p.clean_globs = ['test/output/*.png'] p.changes = p.paragraphs_of('CHANGELOG', 0..1).join("\n\n") p.remote_rdoc_dir = '' # Release to root end desc "Simple require on packaged files to make sure they are all there" task :verify =&gt; :package do # An error message will be displayed if files are missing if system %(ruby -e "require 'pkg/gruff-#{Gruff::VERSION}/lib/gruff'") puts "\nThe library files are present" end raise "\n*** Gruff::Base::DEBUG must be set to false for releases ***\n\n" if Gruff::Base::DEBUG end task :release =&gt; :verify Then you have to maintain a Manifest.txt with a list of files: History.txt Manifest.txt README.txt Rakefile bin/flog gem_updater.rb lib/flog.rb lib/flog_task.rb lib/gauntlet_flog.rb unpack.rb update_scores.rb spec_fixtures/collection/bigger_example/acts/date_range.rb spec_fixtures/collection/bigger_example/acts/range.rb spec_fixtures/collection/bigger_example/association_extensions/date_ranged.rb spec_fixtures/collection/bigger_example/association_extensions/ranged.rb spec_fixtures/collection/bigger_example/reflection_extensions/ranged.rb spec_fixtures/directory/bot_filter.rb spec_fixtures/directory/bot_parser.rb spec_fixtures/directory/bot_parser_format.rb spec_fixtures/directory/bot_sender.rb spec_fixtures/empty/empty.rb spec_fixtures/simple/simple.rb test/test_flog.rb test/test_flog_command.rb test/test_flog_integration.rb test/test_helper.rb At last, you need to add your version in yet another file: module Gruff VERSION = '0.3.6' end Sorry if there are extra steps I'm not aware of. Now, take a look at one of my gemspecs: Gem::Specification.new do |s| s.name = 'spawn' s.version = '0.0.9' s.date = %q{2008-12-18} s.summary = %{Simple fixtures replacement for Sequel, ActiveRecord, Ohm and probably many other ORMs} s.email = "michel@soveran.com" s.author = "Michel Martens" s.homepage = "http://github.com/soveran/spawn" s.specification_version = 2 if s.respond_to? :specification_version= s.files = &lt;%= Dir['lib/**/*.rb', 'README*', 'LICENSE', 'Rakefile', 'test/**/*.*'].inspect %&gt; s.require_paths = ['lib'] s.has_rdoc = false end That's it. I can deploy my gems to both GitHub and RubyForge with these 12 lines. In any case, your Hoe example was the shortest I have seen (I looked at some of your projects and all occurrences I've found were larger) and you elided the fact that you need to maintain a couple of extra files. I invite you to check all my gemspecs: you'll see they are all lean and easy to maintain. Another point is that not all the people want their gemspec generated by Hoe. That's a reason why GitHub now serves more gems than RubyForge, even if name-grabbing in RubyForge is way more tempting. Now all that people that feel comfortable building their gemspecs can profit from Joe and release to RubyForge with one command.
And a good game you did play at that! you chose something that hasn't seen a release in almost a year. Interesting. All that is needed in gruff's rakefile is a call to developer and anything extra he wants to add (clean_globs, remote_rdoc_dir). I've taken ONE additional leap of switching it to Hoe.spec which also removes the require line: require 'rubygems' require 'hoe' Hoe.spec 'Gruff' do developer "Geoffrey Grosenbach", 'boss@topfunky.com' clean_globs &lt;&lt; 'test/output/*.png' self.remote_rdoc_dir = '' # Release to root end The verify step is wholly unnecessary. That is what manifests and tests are for. YES... hoe works by maintaining other files, as you pointed out. But they're files you are going to have and maintain anyways (or should... I sure hope you do): readme, changelog. Hoe grabs the description, summary, and urls from the readme and grabs the latest changes from the changelog. It actually looks based on your glob that you're not maintaining a changelog. You're adding a redundant version and release date to your spec as a result. DRY much? And having to remember crap like the following is EXACTLY why I find writing gemspecs to be a PITA: s.specification_version = 2 if s.respond_to? :specification_version= and as I said on my blog: s.has_rdoc = false == jackass 
I picked Gruff because it was mentioned in http://nubyonrails.com/articles/tutorial-publishing-rubygems-with-hoe, which is the first hit if you search for "hoe rubygems". I wasn't aware it hasn't been updated in a while, sorry for that. I looked at some other examples, and they are seven lines long in average (not counting the requires), five lines shorter than my gemspec and I don't need CHANGELOG, README, Manifest.txt and Hoe.spec to maintain it. I do keep a README, but I'm not tying it to the gemspec. Also, I don't have to remember stuff either: when I start a new project, I can copy a gemspec template from another project and modify as needed. I don't know how widespread practice it is, but it has been very easy for me to do so far. About my has_rdoc = false: I don't provide a RDOC for that project because it has two methods that I explain in the README. The whole library is 14 lines long. As for the insults: the only point you are proving is that you are pissed off.
wrt geoffrey's blog post: june 2007... c'mon. rational people know better. wrt copying gemspecs as if it were maintainable: remember. I was up to 90 releases before I wrote and released hoe. maintaining gemspecs is a PITA, plain and simple. I'm totally fine with your anti-hoe stance and couldn't care less, but to pretend that "you only need to write the gemspec" is a feature is a joke. At 291 releases, I know what I'm talking about here. I'm also not comparing apples to oranges like you are. the above hoe spec and the above gem spec are for the EXACT SAME PRODUCT. They're entirely equivalent. You're gemspecs don't even remotely approach a comparable example. Get back to me when you've added dependencies, executables, extra_rdoc_files, rdoc options (oh wait... you don't _do_ rdoc), gem signatures, etc. wrt rdoc: no... your sample spec file that you encourage others to copy as a template has the same anti-rdoc jackassery. you're encouraging a world w/o rdoc, w/o ri, and w/o googleability. that's a disservice to everyone.
Chef is a idiot's version of Puppet: http://reductivelabs.com/products/puppet/ Chef requires you to fiddle with details of execution order, in Puppet you define the configuration you want (e.g. package x should be installed, configuration file y should have so-and-so contents, and service z, which uses config file y, should be runnning) and Puppet computes the correct execution order. I've been using Puppet for a year now to manage a heterogeneous network of Linux and FreeBSD machines running a huge variety of services and it's simply excellent: I maintain a git-version-controlled description of what I want running and puppet makes sure that the servers always match my desired configuration. Strongly recommended.
 % cd spawn-0.0.9 ./spawn-0.0.9 % ls LICENSE README.markdown Rakefile lib test You've got a gem you ship without a gemspec. You know what that means? It means that if someone wanted to test out a change on your gem by tweaking it and installing it (ie: gem unpack spawn; make changes; rake install) well then they can't. No gemspec means no packaging. You also suspiciously forgot to add that you have a LOT in your rakefile you're not mentioning. All those tasks? Yeah, they're in hoe. All that duplicated code across your projects? Yeah... they're in hoe. DRY, much? % cat Rakefile require 'rake' require 'rake/gempackagetask' require 'rake/testtask' require 'rake/clean' gem_spec_file = 'spawner.gemspec' gem_spec = eval(File.read(gem_spec_file)) rescue nil task :default =&gt; :test Rake::TestTask.new(:test) do |t| t.pattern = 'test/**/*_test.rb' t.verbose = false end Rake::GemPackageTask.new(gem_spec) do |pkg| pkg.need_zip = false pkg.need_tar = false rm_f FileList['pkg/**/*.*'] end if gem_spec desc "Builds and installs the gem." task :install =&gt; :repackage do `sudo gem install pkg/#{gem_spec.name}-#{gem_spec.version}.gem` end Hoe even has a smaller rakefile than you do: % wc -l Rakefile 26 Rakefile % wc -l ~/Work/p4/zss/src/hoe/dev/Rakefile 24 /Users/ryan/Work/p4/zss/src/hoe/dev/Rakefile So. now... we're starting to compare apples to apples. I know that nothing I say could possibly change your mind. It isn't even my goal. But you're (possibly unintentionally) spreading disinformation that I intend to correct.
&gt; Also, I don't have to remember stuff either: when I start a new project, I can copy a gemspec template from another project and modify as needed. I don't know how widespread practice it is, but it has been very easy for me to do so far. I've seen many a release in the wild that has a wrong or broken information in a gemspec because somebody was using copy/paste coding. Usually I cry. The repository is a database of ruby software, please try to keep it clean. I still don't see how you're releasing software or testing software on "just a gemspec", those features aren't in RubyGems, for sure. It seems disingenuous that you're hiding the bulk of your code behind smoke and mirrors. Also, #has_rdoc= doesn't do anything for RubyGems 1.3.4+, so get off your ass and put docs in the right spots so the community can read them with ri.
Hey, &gt; I still don't see how you're releasing software or testing software on "just a gemspec", those features aren't in RubyGems, for sure. It seems disingenuous that you're hiding the bulk of your code behind smoke and mirrors. I'm not sure I follow. I'm testing with Test::Unit and releasing with Joe, a simple wrapper around `gem build` and `rubyforge`. I'm surely missing something because I don't see where the smoke is? &gt; Also, #has_rdoc= doesn't do anything for RubyGems 1.3.4+, so get off your ass and put docs in the right spots so the community can read them with ri. Thanks, I didn't know that. I usually don't use RDoc because I rely more on online documentation in other formats, and I never use `ri`. But I'm not against it. I don't discourage its use. The sample is there just so that you don't have to Google it and copy the first one you find on GitHub. It's not even generating one for you, so you have to go through the step of copy/paste and see what's in there.
&gt; wrt rdoc: no... your sample spec file that you encourage others to copy as a template has the same anti-rdoc jackassery. you're encouraging a world w/o rdoc, w/o ri, and w/o googleability. that's a disservice to everyone. As I said above I'm not against RDoc or `ri`, I just don't use it myself. I'm not discouraging its use by including a sample file in a repository (as I mentioned it's not generating the code for you so you're in charge of copying/pasting and looking at what you're doing). Oh, and I'm sure I'm not breaking googleability by not producing RDoc. We just found that Hoe didn't suit our needs and that it hindered more than it helped. And that many people are simply releasing to GitHub because it's as easy as it should be. So we wrote a small script to help ourselves publish to RubyForge as well with no extra steps and without invading the code. (I do have gemspecs with `executables`, `add_dependency`, `extra_rdoc_files`, etc. and haven't found it hard to maintain. But I surely can't claim to have the amount of releases you have. That doesn't mean a simpler tool can't help mortals like us who only have a handful of smaller gems.)
You've been claiming (in this thread) that Hoe is more code than just a gemspec without mentioning all the rest of the code you're using. You actively discourage ri usage by having has_rdoc = false for users of RubyGems 1.3.3 and earlier. People on these versions cannot build rdoc or ri when has_rdoc is false. Not even by shipping a broken example will you get people to actually think before they act. People do not read, developers included, so having them fill out a gemspec only leads to crap in the RubyForge repository. Gem::Specification#validate is an attempt to flush out crap, there's still loads of stuff that gets by. Automatically pulling from a readme, a history file and source code makes it easier for developers to do the thing they seem to care least about, getting software out to others. I released lots of software before using Hoe, and I usually did something wrong somewhere, often it was the simplest things like updating the version.
Thanks for the tips. I removed all those legacy rake tasks, they are from a pre-Joe era. I left the test task, I think it makes sense. I also updated the gemspec so it now includes itself. I did that because I see what you described as a possible use case. My workflow for development is different, though: I think I've never had the urge to unpack a gem, tweak it, generate a gem and install it in order to test something. I usually clone the repository and work from there, and I find it easier that way because I can try whatever I want and send patches. My new Rakefile looks like this: require 'rake/testtask' task :default =&gt; :test Rake::TestTask.new(:test) do |t| t.pattern = 'test/**/*_test.rb' t.verbose = false end
I'm sorry if I embarrassed you by showing how Hoe looked like back in 2007 :-) I don't have an anti-hoe stance. I didn't like the fact that in the past it added itself as a dependency, which forced me to install it in order to use other gems. Other than that, I'm perfectly fine with people using it. The template gemspec we released has some basic options. You may be right that I should have included all 23 specification options in case people don't know where to find a gemspec reference (hint: it's available at http://rubygems.org). About the RDoc: I'm trying to provide a blank slate gemspec. I'm not assuming people will write rdocs or tests. I'm glad if they do, but I don't want to force them. In the end, I prefer to have a project with tests and documentation the way the author intended, and not an empty test file and autogenerated documentation that only reproduces the code. If a gem author is going to write RDocs, then he will of course turn the has_rdoc option on. 
i second this. Puppet is an amazing bit of work. If you set it up decently, when you need a new server it's simply a matter of installing a base system, installing puppet, and telling the puppet server what type of server you want the machine to be. Web server died? don't install from backup, just use puppet to build another one. Want to regig your setup to have clustered web servers behind a load balancer? change the configuration and you're done.
&gt; You've been claiming (in this thread) that Hoe is more code than just a gemspec without mentioning all the rest of the code you're using. What "rest of the code" are you referring to? &gt; You actively discourage ri usage by having hasrdoc = false for users of RubyGems 1.3.3 and earlier. People on these versions cannot build rdoc or ri when hasrdoc is false. This is from the gemspec reference: has_rdoc Type: boolean; Optional; default = false Description Indicates whether the code in the gem has been commented with RDoc in mind. Usage spec.has_rdoc = true Notes This attribute has an advisory role only. Any gem can be submitted for RDoc processing. It seems we are just stating the default in the template. But even if we weren't, that's besides the point: Joe doesn't ship with a default gemspec template. &gt; Not even by shipping a broken example will you get people to actually think before they act. Same thing: `has_rdoc` default value is false. Nothing you said so far deals with Joe, but with a gemspec template that's not even installed when you install Joe as a Thor script. &gt; People do not read, developers included, so having them fill out a gemspec only leads to crap in the RubyForge repository. Gem::Specification#validate is an attempt to flush out crap, there's still loads of stuff that gets by. What a brave generalization. I think you can write a bad gemspec the same way you can write a bad Rake task, a bad Hoe spec, a bad Manifest, etc. In any case, I had no troubles so far writing my gemspecs and I think the fact that GitHub now serves more gems than RubyForge somehow proves my point. &gt; Automatically pulling from a readme, a history file and source code makes it easier for developers to do the thing they seem to care least about, getting software out to others. It's fine if this works for you. I usually write the gemspec for the first release. From then on, the only thing I modify is the version number and I occasionally add or remove some file. I fail to see the pain in doing what I just described. &gt; I released lots of software before using Hoe, and I usually did something wrong somewhere, often it was the simplest things like updating the version. So far, I've never failed to update the version number. GitHub has also trained me to do it, because otherwise the new gem doesn't build. 
Quack Attack? wtf?
I asked myself that when I used that title. But if you are commenting on it because you can't make sense of it, and not just because of its extreme lameness, it's a reference to Duck Typing. http://en.wikipedia.org/wiki/Duck_Typing
Both. Thanks for clearing that up though.
&gt; What "rest of the code" are you referring to? So you didn't actually read what I wrote. &gt; This is from the gemspec reference: Which is out of date. Try `ri Gem::Specification` using the latest RubyGems where it notes that it defaults to true and is deprecated such that setting it does nothing. &gt; Same thing: has_rdoc default value is false. No, it isn't. I know this because I changed the default for 1.3.4 and documented it in the [release notes](http://rubyforge.org/frs/shownotes.php?group_id=126&amp;release_id=35061). &gt; What a brave generalization. Since you didn't bother to read the documentation from the latest release of RubyGems, it remains accurate.
&gt;&gt; What "rest of the code" are you referring to? &gt; So you didn't actually read what I wrote. I did, but I still don't know what other code you are talking about. &gt; Which is out of date. Try ri Gem::Specification using the latest RubyGems where it notes that it defaults to true and is deprecated such that setting it does nothing. I didn't have the latest version installed, so I was using the information I had before talking to you. &gt; No, it isn't. I know this because I changed the default for 1.3.4 and documented it in the release notes. I just found what you said in the release notes for 1.3.3. I think I can safely remove the has_rdoc = false from my gemspecs. 
Erm, 1.9.1 isn't safe. [snuxoll@miyuki ~] irb1.9 irb(main):001:0&gt; require 'bigdecimal' irb(main):007:0&gt; ((BigDecimal.new("10") ** 1000) ** 10000).to_s "F" zsh: segmentation fault irb1.9
Basic non-security guy question: Am I correct to assume that even if you don't use the BigDecimal class in your applications ever that your application would still be vulnerable somehow? In the case of a Rails application, can someone give me an idea of how or in what situation someone could exploit this vulnerability?
Wtf. Seems like I need some kind of copyright statement on my webpage. Not that it helps, though, I guess..
The site is some kind of RSS aggregation site. Not that obvious, though, especially not when they repost their aggregations to reddit.
For me it seems to be safe: $ uname -s -r -v -o Linux 2.6.29-ARCH #1 SMP PREEMPT Wed May 20 07:06:02 UTC 2009 GNU/Linux $ ruby-1.9 --version ruby 1.9.1p0 (2009-01-30 revision 21907) [i686-linux] $ irb-1.9 --version irb 0.9.5(05/04/13) $ irb-1.9 irb(main):001:0&gt; require 'bigdecimal' =&gt; true irb(main):002:0&gt; ((BigDecimal.new("10") ** 1000) ** 10000).to_s "F" &lt;lots of output&gt; 
Bah, what the hell, I have 1.9.0 installed on my VPS. I could have sworn I built from source but it seems I just used the packages in the repos. My bad!
..and a few more... Here's an old blog post about a few ruby segfaults. The first few examples still crash 1.8.7 &gt; sean:~/code/ruby$ irb &gt; eval("[]"*10000) &gt; Segmentation fault Everything listed there has already been reported to the Ruby developers. [BPS Labs Blog](http://www.breakingpointsystems.com/community/blog/ruby-vulns.odt)
Ruby converts all numbers that don't fit in a Fixnum into BigDecimal objects. This affects stuff like #to_i as well. For example: &gt; "1234".to_i.class # =&gt; Fixnum &gt; "999999999999999999".to_i.class # =&gt; BigDecimal &gt; &gt; i = (2 ** 30 - 1) &gt; i.class # =&gt; Fixnum &gt; i = i + 1 &gt; i.class # =&gt; Bignum So if there are any places in your application in which you accept arbitrary user input and convert it to an integer, then you are vulnerable.
&gt; Ruby converts all numbers that don't fit in a Fixnum into BigDecimal objects. No, it converts them into Bignums. Your second example even shows this. Didn't you try your first example in irb? BigDecimal isn't an Integer datatype, it's a drop in replacemet for Floats if you want to avoid the typical round/display bugs (in prices, etc.) of floating point numbers. If you don't use BigDecimals your apps should be safe.
&gt; In the case of a Rails application, can someone give me an idea of how or in what situation someone could exploit this vulnerability? Rails seems to map some database column types to BigDecimal, so if someone manages to get a big enough number into this database column and can create an object from this table row later this bug could be triggered.
Oops, my bad, I confused the two.
Did the []-one ever work? I don't remember a time when Ruby didn't require at least one argument for Array indices. If you evaluate unchecked user input in eval you're always in big trouble, even if it doesn't crash the interpreter. You can do similar things in python: $ python Python 2.5.4 (r254:67916, May 4 2009, 19:15:41) [GCC 4.1.2 (Gentoo 4.1.2 p1.0.2)] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; eval("()" * 100000) Segmentation fault Or in perl: $ perl -e 'sub f { 0 } eval("+f()" x 1000000 )' Segmentation fault There's a reason why people proposed to rename eval to evil in ruby.
I'm a windows user and seem to have plenty of issues getting the latest versions of things or translating peoples non-windows commands into windowsable language. I'm not aversed to changing OS as I intend to get an eee PC to code on, but what do you guys recommend? Also, I've been looking into hosting and it seems nowhere provides sqlite hosting, or is it a given and they just don't mention it? (or do they even need to mention it?) Cheers Ant
I typically use mac at home and linux at work. Right now I work at home, so I am using mac at work. Default mac ruby install sucks. Doing something more sensible is easily possible, but a bit of a pain. Same thing on debian, actually. Installing to /usr/local is truly the ruby way. I don't know anything about using sqlite in production (although I don't see any reason not to), but sqlite databases can be created and used and destroyed willy nilly as long as the sqlite packages are available. Most hosts will either have them or allow you to install them in some way or another if you try, or ask, or ask and then try. 
SQLite will choke hard if you need concurrent writes. Allegedly it can handle ~100k hits a day, but I would imagine that most hosts just throw MySQL up as it's easier for them. As for what OS I use? OS X &amp; to a lesser extent Linux. I've always deployed to Linux for Rails apps (which I'm guessing is what you are talking about based on your SQLite question).
OS: mostly linux or OS X. With linux the distro is really up to you, but ubuntu is great for the desktop. Hosting: The standard is to get a VPS from slicehost, linode or prgmr. It's definitely nice to have the freedom to just install whatever you want in a standard way. As for shared hosts, I don't know about any others, but I just checked dreamhost and sqlite3 is installed.
I used to have to use a Windows box for ruby and rails development (because I also wore the Flash developer hat in Flash 8 days), and using ruby in Windows was kind of a hassle. It seems like all the gem authors develop on Mac and deploy on linux so those OSes work pretty well. Nowadays I develop on a gentoo linux box and have no complaints.
I use Linux/x86/Ruby for all of my development machines. At work some of our products run Linux/PPC/Ruby.
The only experienced developers using windows for ruby development are forced to do so by their employers. Most people I know use Linux (mainly ubuntu and arch) or the OS X. You can find tons of tutorials on thet net teaching how to set up a Ruby/Rails development environment on Ubuntu. 
I realize that Rails != Ruby, but FWIW it looked like 90% of the laptops at RailsConf this year were Macs (running OS X). I even saw a couple of hackintosh netbooks. Personally, it didn't take too long after getting into Ruby (/Rails) development to see that Windows is the worst platform for it. I begged and pleaded at work until I got the first and only Mac in the building.
&gt; I begged and pleaded at work until I got the first and only Mac in the building. Way to fight the good fight. I wish more companies would use a "buy whatever" policy with a helpdesk for support. Google has something like this. Employees there can buy whatever system/laptop they want. If they have a problem with it... they can bring it to a helpdesk (similar to a Mac Genius Bar). 
Mac OS X for development. I deploy to either Linux or Open Solaris. A few years ago when I was still doing mostly Java work, I developed on Windows. So my early Ruby experience was on that OS. Even then, I tended to rely on cygwin a lot.
OSX at work. Ubuntu at home, and whenever I can at work :-)
Do a lot of Windows users just go with a VirtualBox or VMWare instance running linux? I imagine that would be the easiest way to work with RoR in a supportive OS... if you were required to use Windows at work.
OSX is actually a subpar development environment imho, but it's *passable*. Since I work out of a laptop it makes up for it in every other way, but still.
I wish! I'm really locked down at work. I've basically nagged my employer to the point that he lets me bring in my Macbook. I'd rather not, but it's better than having to put up not only with Windows, but the lousy P4 they give us that's always on the verge of dying.
I just take my second monitor and make it a full sized terminal. It is as close as I can get at home to a real computer.
OS X (mainly because I like TextMate). But I like Ubuntu as well.
Most of us use OS X, I use Ubuntu myself though.
Speaking of TextMate, for any envious Windows users: http://www.e-texteditor.com/ When I was stuck on Windows I used that for code editing and a Linux VM for everything else. Since that time, Netbeans has become a very nice option, too.
Used to use OS X with textmate Right now I'm giving ubuntu a shot with gedit configured to act like textmate. Ubunut is pretty nice, but if you've got the money go with the mac.
For development I would recommend PostgreSQL, it is the strictest of the three which means SQL written for it is much easier to port to the others than vice versa (especially from sqlite which does barely any type checking,... at all).
I second Gentoo Linux for any kind of development. As a source based distro the distro developers ensure that all the major programming language environments just work.
When I was at Google there were like 4 laptops to choose from. MBP and 3 Thinkpads. Still awesome, but not quite "buy whatever."
E is still quite a long way from TextMate in my opinion. They claim to be Windows' TextMate, but that's quite an overstatement to me.
Mysql's niche is rapidly contracting. SQLite works extremely well (and is very convenient) for simple things, and Postgres is beats the pants off Mysql for 'serious' database work. Plus who knows what Oracle are going to do with it now they've got their hands on it ;)
Linux with Emacs.
linux. 
Agreed, but it's the closest you can get on Windows. And it can do one cool little trick that I've never seen in another editor, including TM: non-contiguous multi-selection and editing.
I use both Linux (by choice) and OS X (at work). My preference is for Linux because things generally just work. Software and libraries are just an apt-get away. Regardless of whether you choose 32 or 64 bit, everything will be compiled for a single architecture. On OS X, on the other hand, there's a big gulf between the built-in software and what you can get through MacPorts. port install takes a long time as it compiles from scratch, and compiling all the dependencies can be painful. And some software in Leopard is 32 bit, some is 64, and some is fat binaries that contain both. Installing Ruby + MySQL is far harder than it should be. However, both work several orders of magnitude better than Windows. The final thing is that you can get a lot of good software for free on Linux, but you have to pay on OS X. That's offset by the fact that some of the OS X software is really excellent. (Though some of the most expensive software, like that from Adobe, is merely mediocre.)
linux, arch at home, ubuntu at work
If you don't mind, i'd really interested by feedback for open solaris. What kind of weakness or advantage did you get ?
OS X + vim with Ruby support + GNU screen + autotest = happy me. And to blatantly start a flame war, would one of you Linux losers explain to me why OS X is supposedly sub-par as a dev environment? / Question is serious, tone is tongue-in-cheek. 
I don't know what most Rubyists use, but I run Fedora Linux with GVim. I've found that Fedora has somewhat better Ruby support, than Debian based distros.
I have no problem with people using OS X or Windows as their dev environments, but I couldn't resist nibbling at this troll bait: * Lacks a decent package manager (Fink or Darwin Ports are _alright_ I suppose, but yum/apt/portage are nicer). * Costs money. * Will only run on specific hardware. * Difficult (but not impossible) to run in a VM. Other than those issues it's good enough. Round 2. Fight!
They'd both probably regret it in the morning?
Was my environment as well, just for Python. But to be humble, the price for hardware is ridiculous and most of the functionality I need I get on Windows and Linux as well.
Well, some details of the setup are on [my blog](http://www.cubiclemuses.com/cm/articles/2009/04/09/rails-passenger-open-solaris-ec2/). My initial impressions with Solaris and Open Solaris come from doing deployments on Joyent and with some of the infrastructure over at Apache. I like ZSF and having dtrace available and those were major factors for me. The thing that has bothered me most about open solaris is the state of packaging. There are multiple competing package systems and repositories and IMHO it makes a mess of things. I think Open Solaris could have taken the world by storm, but Sun mismanaged it and didn't involve the community as much as it should have. All that said, I still enjoy using it as a deployment environment and the latest 2009.6 release looks promising.
OSX is not sub par. It will run a VM that can host linux very easily, then we can install our dev environment on the linux VM. OSX is great!
OS X as a "dumb terminal". I run Safari, Firefox, Omnigraffle and iTerm. I don't particularly care about my desktop OS as long as it's not Windows, but I'd really miss OmniGraffle if I were to run Linux on my laptop again. Apart from that I run practically everything on a Linux box via ssh. If it can't run under screen via ssh I have no interest. A lot of my work is on servers on the wrong side of the Atlantic. 
debian &amp; vim for both development &amp; deployment.
OSX at home, Windows at work, deploying mainly to linux. My experience with Mac has been a good one, but I'll take any *nix type OS over Windows now if I have the choice. Shell scripting in Windows is not as fun as linux IMHO 
Ubuntu Linux with gedit. Previously used Aptana RadRails but it froze up all the time.
OSX or Linux
Ubuntu. Switched from OS X. Honestly, I like it better. My OS lifecycle kinda looks like this... Windows -&gt; Linux -&gt; OS X -&gt; Linux ... oh god I hope my next step isn't back to Windows!!!
Yes I work with a stick and some poop because it's cheaper and the right tools for the job are a waste of resources.
I'm an actual ruby hacker; I get paid to hack into systems, and I use ruby for all coding. My favorite tool, Metasploit, is written in ruby. And I absolutely use Linux, as does pretty much everyone in my industry. Ubuntu, personally.
Except the VM is slow due to disk I/O and general lack of resources.
Darwin Ports is horrible. apt-get is light years ahead. I also prefer Gnome's UI to the OSX UI, due to better shortcuts.
Mac OS X, but only because I work with Cocoa as well; otherwise, any other UNIX or UNIX-like system will work since they all have Vim.
I think the benefit of allowing employees to work with the OS they are most comfortable with would increase their productivity and efficiency and the benefit it provides cancels out, or provides more value than, the cost of hiring a help desk.
I really haven't done much in Ruby and am still trying to learn it but I use OS X. I occasionally SSH into my desktop that runs Ubuntu and will run something from there and edit files in Vim. Most of the time I just use Smultron on OS X.
What kind of things make it subpar?
I use both OS X and Linux (Ubuntu or Debian), but I'll phase out OS X and go back to strictly using Linux soon.
Ya. Good point. SQLite doesn't give a shit about what you put into it. E.g. you can have an int column and put a string in iirc. It doesn't care. I don't know enough (or care enough) about sqlite to know if there is some kind of strict mode or something that prevents this kind of crap, but I would imagine there isn't. On the other hand, sqlite is completely local and requires as close to 0 admin as you can get so for development it's not a huge deal (especially if you are using an ORM, which, based on this guys question I believe is the case).
OSX. I have Ubuntu running under VMWare, but I still haven't found an editor that I like as much as TextMate so use OS X most of the time. 
Very nice.
Ubuntu.
Ubuntu, with gedit. gedit has lots of plugins and snippets...there are packages of gedit extras specifically for Ruby/Rails development; I use lexrupy's gmate: http://github.com/lexrupy/gmate/tree/master
Maybe the sweet siren song of Windows 7 will pull you back in! Hah! Why Ubuntu over OS X, though? I've seen people use Ubuntu and other flavors of Linux for various things, including web development, but I always wonder why. I'm sure personal preference factors heavily into this, but what does Ubuntu offer that OS X does not? What are OS X users missing out on? 
I use Debian Linux. Though I have not been using Ruby much recently, I did some Ruby education at OpenWeekend student conference in 2002, I also had created text mode user interface in Ruby back then (it is on sourceforge as JTTUI).
Lack of package manager, based off BSD coreutils (personal preference, ofcourse), until recently the standard editors lacked native polish (albeit I will say that MacVim is nicer than gvim), plus all the little ways the Finder will pretend that there isn't a root directory structure with stuff like /tmp. Really, the lack of a package manager is the biggest issue. Fink and ports are *passable*, but they pale in comparison to the Debian repositories.
I develop on a windows box that has Ubuntu running as a virtual machine with Sun VirtualBox. And various tools to access the Ubuntu filesystem. I use e-texteditor which is a textmate like editor that supports textmates bundles.
I have never worked in an environment you describe. And I hope to the FSM I never do.
I've been pretty satisfied with 'e'.
Thanks for the response. The lack of package manager is a bum deal (I'm used to Archlinux where I get endlessly spoiled). So far, ports has been good enough for what I've wanted. And it's really too bad Apple decided to abstract the filesystem but I don't work with files a whole lot outside the terminal anyway.
My favourite example on this is http://diveintomark.org/archives/2007/11/11/installing-mysql-on-ubuntu
You can get pretty much the same experience with the default gnome texteditor (gedit) and some plugins. I use a MacBook and run gedit on my netbook and it's pretty I've configures it to work pretty much the same on both systems :)
actually for me it was developing with ruby that made me switch to linux permanently, I looked up and I realized all of my little tools and apps were trying to simulate a linux box.(cygwin,putty, pageant, etc) so i just made the switch to ubuntu and i saw that it was good. (w/netbeans and sometimes gedit)
Didn't work for me! ------------------- DHJMacPro:/Users/dhj # gem install rip Bulk updating Gem source index for: http://gems.rubyforge.org Building native extensions. This could take a while... ERROR: Error installing rip: ERROR: Failed to build gem native extension. /opt/local/bin/ruby extconf.rb install rip rip: installing library files rip: installing rip binary rip: setting up ripenv rip: please create one of these startup scripts in $HOME: /opt/local/lib/ruby/gems/1.8/gems/rip-0.0.1/lib/rip/setup.rb:91:in `setup_startup_script': undefined local variable or method `startup_scripts' for main:Object (NameError) from /opt/local/lib/ruby/gems/1.8/gems/rip-0.0.1/lib/rip/setup.rb:38:in `install' from /opt/local/lib/ruby/gems/1.8/gems/rip-0.0.1/ext/../setup.rb:26 from extconf.rb:11:in `require' from extconf.rb:11 Gem files will remain installed in /opt/local/lib/ruby/gems/1.8/gems/rip-0.0.1 for inspection. Results logged to /opt/local/lib/ruby/gems/1.8/gems/rip-0.0.1/ext/gem_make.out 
heh. I like how you're install a rubygem replacement using a rubygem.
What's interesting about this is that a fellow coder and I actually implemented an almost identical library a couple months ago for a project. In fact.... almost verbatim. Even uses trollop. Kinda creepy.
Do a git pull, I filed a patch to fix that error. The problem is it's looking for .bashrc/.zshprofile files, and it couldn't find one of the bash/zsh regulars. The patch should at least give you a better error message. Perhaps you should add your startup filenames to the list? http://github.com/defunkt/rip/commit/b13f3685bd658379d0e8dc822816a483d1d5e86c http://github.com/defunkt/rip/commit/054f8de849451aa1735da7060f4de845fd45da53
You can install it setup.rb from the git repo if you like...
very nice "how to" resource
Should have been called `jobs.empty?`. Or `jobs.any?` but that would require - *horror!* - `activesupport`.
`Enumerable#any?` is in the stdlib. no need for activesupport.
Doh. `jobs.many?`.
bootstrapping, baby!
&gt; And we don't need any magical require statements to use them! What's magical abut `require`? What's the effect of Rip on manually-installed/package-manager installed libraries?
Some take-away points: &gt; Our experience selling Ruby work is that using a dynamic language like Ruby fits in well with our overall appeal. Our strength is that we hire highly talented people who are difficult to attract to the typical IT organization. Ruby has a philosophy of an environment that gives a talented developer more leverage, rather than trying to protect a less talented developer from errors. An environment like Ruby thus gives our developers more ability to produce their true value. ... &gt; Our history, however, is that the most important experience here is that of dynamic languages that support the kinds of meta-programming features that Ruby does, rather than specifically Ruby experience. As Scott Conley puts it: the difference is between efficiency risk and delivery risk. A team with dynamic language experience but little Ruby experience will be slower initially (efficiency risk) but a team without any dynamic language experience can get produce a knotty code base that could risk the overall delivery. 
I wasn't being sarcastic! I think it's a great idea - everyone's already got gem installed, right?
I wish I would have known about this before!
There are lighter-weight alternatives to Hoe (I don't know things have changed in Hoe 2.0.0 but hoe projects typically have hoe as a dependency) that are less prescriptive in how you should structure your project. You might want to try out [gem-this](http://github.com/lazyatom/gem-this/tree/master). The are others. 
ubuntu at home/work did winXp back 2 years ago, never look back after ubuntu. Windows is just pain for serious development if you're not doing any m$ stuffs (.NET etc) any *nix with emacs will do
Seconded. Hoe adds a load of dependencies that aren't needed by end users of the gem. This is just bloat. I cry when I see this: - [I] image_science - [I] RubyInline &gt; 0.0.0 - [I] ZenTest - [I] hoe &gt;= 1.2.1 - [I] rubyforge &gt;= 1.0.3 - [R] rake &gt;= 0.8.4 I don't need hoe, or rubyforge, (or ZenTest for that matter) to run the project. Why must I install them? gem-this is pretty nice for turning existing projects into gems. I used it recently to remove the Hoe dependency from a gem I was using. [Jeweler](http://technicalpickles.com/posts/craft-the-perfect-gem-with-jeweler) also looks good as an alternative.
Sure, but rip is still alpha, so you'll probably want to wait or install it from the git repo frequently.
From the RubyGems docs: The Future The need to preload the RubyGems software is one of the biggest drawbacks to RubyGems’ versioned software approach. The RubyGems team is investigating ways of making this issue much less onerous. There is a lots of different ways you can make working sets of libraries available for import. In Python, tools have sprung up to support a lot of different approaches: - install globally (python setup.py install, same as ruby setup.rb install) - setting up dependencies using an API in code (setuptools, similar approach as RubyGems) - Multiple library locations, active location is controlled via PATH modifications (VirutalEnv + pip, similar to rip) - Script generation (buildout w/ zc.recipe.egg, Ruby does not have a tool that uses this approach AFAIK) In Python, script generation is my preferred approach to library management. You can declare in setup.py, "This package should provide command-line scripts named 'foo' and 'bar', these scripts depend upon pacakges X,Y and Z." Then buildout can auto-generate the all of the command-line scripts. These command-line scripts just call into the packages command-line "entry points", and do hard-coded PATH manipulations so that the desired working set of packages can be successfully imported. This approach has the advantage over the RubyGems technique in that you can easily override the versions of the packages that are selected based on a particular installation instance of that package. When you use 'require' statements directly in a script, you're embedding specific information about the working set required for that script in a place where it can't be read by tools, nor can that information be overridden. e.g. one install may want to select development versions of the package that have been pulled straight form version control, or just use newer or older versions of a package for whatever reason. Buildout provides similar functionality to rip's freeze command, except w/ rip (or pip) you run a series of imperative commands to first achieve a working set of libraries, then run a command to capture a declarative version of that working set. In Buildout you first provide a buildout.cfg with the working set provided declaratively, and then install a working set from that blueprint. Script generation has the advantage over the Rip approach to installation in that you can install multiple packages into a project's sandbox and each script can use different working sets of libraries. For example, if you have a web site compromised of a Plone instance for the CMSish portion of the site, and a Django app for a custom app part of the site, you can install those two frameworks side-by-side into the same sandbox and each web app can pull in whatever libs it needs without worrying about conflicts w/ the other app. 
I'd recommend using xsel instead of xclip on linux: def copy(str) IO.popen('xsel -b', 'w') { |f| f &lt;&lt; str.to_s } end def paste `xsel -o` end That makes sure copying goes into the main clipboard and not the middle-click, X clipboard.
Interesting article. &gt; Controlling Gems &gt; &gt; Ruby includes a package-management system, Ruby Gems, that makes it easy to install and upgrade third-party libraries. Rails also has plugins that carry out a similar task for rails. These are good tools, but it's easy for teams to get in a tangle if different machines are set up with different versions of different libraries. &gt; &gt; There's a couple of ways to handle this. The first approach involves taking a copy of the source code for all third-party libraries and checking that into source control. This way a simple checkout will get you all the right version of all the libraries. A second approach is to use a script that downloads and activates the correct versions of all libraries. This script needs to be kept in source control. Copying all third-party source into version control is a very cumbersome solution to the problem. Writing scripts to set-up a project's dependencies is better, but it's horribly non-DRY. The elegant solution is to declare a list of dependencies, and declare what recipe should be used to install each dependency. Each recipe is then packaged seperately, and re-used between all projects. This is what we do in Python with Buildout, but we go beyond just managing working sets of library dependencies, but also automate the setup of a project's complete development environment, including any non-library bits (databases, ldap servers, small amounts of C or C++ code, BASH scripts, config files, web servers, process monitors, etc). Especially in conjunction with the statement, "With the rise of support for these languages on the JVM and CLR, we see more opportunities to intermix different languages with different strengths - an approach Neal Ford refers to as Polyglot Programming.", it makes a lot of sense to use a "package management" tool which can help assemble the libraries for multiple languages, as well as any other bits required that might tie those parts together - in a repeatable fashion! (and you don't really need JVM or CLR to take a polyglot approach, UNIX pipes will let different languages talk to each other well enough) 
I deploy to Linux. Just recently tried to switch from OSX back to Linux for deveopment, but MacBook runs too hot w/ too little battery life under Ubuntu. So I'm back to OSX. All the tools I use are available for both, so not that big of a deal.
As you probably know, there are quite a few game libraries available for Ruby. I've been playing with RubySFML for a few days, which is nice but a little outdated now and unfortunately the author of the bindings isn't working on them anymore. I've also read about the others (the ones I mentioned in the title) on their websites. I'm just looking for some input on which to use, really. The best choice for me, would be the one that has a decent community, is actively developed, performs well etc. The thing that puts me off about RubyGame is the apparent lack of a community. Gosu doesn't look too bad and you can plug Chipmunk into it quite easy, apparently, which is cool. It is also being actively developed. My experience with RubySFML hasn't been bad at all but I'm not going to use it because it's been abandoned (and no-one else seems to use it). ... and Ruby/SDL? Well I don't know anything about that to be honest. Help!
I've only played with Gosu, and haven't done much with it beyond the tutorial, but it gets my vote. Actively developed and the folk in #gosu are extremely helpful. Also not too difficult to get a game goin'.
Me too. I have 2 minigames not really finished, but so far Gosu has been rather easy to learn and use. Documentation looks scarce but it's enough.
What platform are you on? Ruby/SDL and RubyGame both use SDL and getting the latest DLLs for SDL and all the optional add-ons is kind of a pain in the ass on Windows. At least it was a year or so ago when I played around with it. At the same time I checked out Gosu and tried to integrate Chipmunk on Windows and failed. It didn't build out of the box and I couldn't fix it and I couldn't find precompiled DLLs.
go for gosu
i use rubygame (not for games, though -- mostly for visualization), and i like it a lot. 
Used only gosu, and liked it alot (except the need of having window reference literally everywhere).
Gosu us amazingly easy to get into, great tutorials, great community, and code that (generally) "makes sense". I've also used RubyGame, and I suspect that it's perfectly good (especially if you know your way around PyGame), but it just didn't stick for me.
I'm on Windows, you're right about it being a pain...
http://www.archlinux.org/ Their is simply nothing that beets Arch.. I really appreciate what Ubuntu has done for Linux but I find it too heavy for my liking. I prefer the straight forward text configuration files that Arch offers as well as their amazing pacman(yaourt) package manager.. I have high performance rigs with very small OS footprints that simply scream. 
Still no PGP signing? :( 
I suggest you talk to the creators of Rip - considering it's far away from 1.0, now's the best time to suggest features.
or pull requests!
OS X for development, deploying to OpenSolaris
switch to emacs
linux + emacs + ruby
After reading, I don't see any benefit over testing with rails functional tests. Can someone enlighten me?
Two things seal the deal for me: a good package manager (ports doesn't count) and a good window manager. Transparency in the development process and the lack of "Apple knows best, so no you can't have what you want" sweetens the pot considerably. If you haven't tried it because you got burned by editing your XFree86 config files a few years ago, you should give it another look; I haven't had to manually edit a config file to get stuff working in years.
[Edited out blatant falsehoods] Edit: it appears I haven't kept up on Hoe. You're right, I just checked and it isn't loading Hoe when i require a Hoe-based gem. Awesome!
that's simply not true and hasn't been for over a year.
I cheated and made a singleton which wraps most of that stuff. Since it's not recommended that you have more than one window anyways, it seems fine.
I'd give Gosu a shot. Here's a game I made for it, it's not fun and it's a little rough around the edges, but it illustrates one way to build a game with Gosu. http://github.com/adamsanderson/flourish
I would *love* to see the day when we don't need such cards any more. The mere fact that this sort of thing is still going in the tech community is a giant "made of fail" moment. I'm just waiting for the tech community's [Tailhook incident](http://en.wikipedia.org/wiki/Tailhook_scandal) to happen. 
I have no idea where you got that but it hasn't added runtime dependencies to hoe for over a year now: s.add_runtime_dependency(%q&lt;RubyInline&gt;, ["&gt;= 0"]) s.add_development_dependency(%q&lt;hoe&gt;, ["&gt;= 2.1.0"]) 
Actually things changed over a year ago.
mind sharing some examples?
@crispee - Good question, I should probably have mentioned that. They're more similar to Rails integration tests – you can use them to test the behaviour of multiple controllers at once, while functional tests are limited to a single controller. Because they're framework agnostic you could also refactor part of your app, re-implementing it on another platform (e.g. Sinatra) and keep the same tests. See this article for an example of the kind of thing I mean: http://m.onkey.org/2008/11/10/rails-meets-sinatra
Because not everybody uses Rails, eh?
Well, it's great that it's not doing that any more. However, there are still plenty of libraries that haven't been updated since the change. That dependency graph is from a new project on a machine that's only a few weeks old, so the problem obviously persists, and will do until such time as every project that uses hoe is updated to remove the runtime dependency.
I just updated the article to expand on my previous comment. Scroll down to the "Why Bother?" section near the bottom...
This is awesome and exactly why I wrote RubyInline. so cool.
Nice post, but seriously... why not use a font that is actually easier on the eyes :) ? (especially on high resolutions)
I did exactly the same, but anyway don't like it.
We don't. That's why we're proposing that we put it in Enumerable instead.
Shouldn't lib/tasks/rack-test.task file be called lib/tasks/rack-test.rake? 
can you point me to a real example of using buildout? preferably one of yours?
Looks fine to me, but I'm looking at it from a lower resolution netbook. Had to upvote you for a valid (and amicably stated) opinion.
what exactly is thrust? (didn't find anything immediately on google)
I used a 1900x1299 @ 15,4" Notebook Display. It reminded me of [this](http://icanhascheezburger.com/2007/12/26/funny-pictures-ur-flavr-it-hurtz-me/)
Awesome!
I found a [http://code.google.com/p/thrust/](link to Thrust) in an older blog post. From the site: &gt; Thrust is a CUDA library of parallel algorithms with an interface resembling the C++ Standard Template Library (STL). Thrust provides a flexible high-level interface for GPU programming that greatly enhances developer productivity. Develop high-performance applications rapidly with Thrust! 
Thanks for taking note guys. As I said on the page itself, I know that this isn't exactly an apples-to-apples comparison, and that the choice of algorithm is always far more important than micro-optimizations. I just thought it would be fun to see how quickly and easily I could get Thrust into my Ruby programs. Instead of doing all the hard work myself, I decided to go the route of RubyInline, which made the task far, far too easy. Then I just decided to see if the thing actually worked. Seems like it does!
Would you mind sending me a screen-shot of how the font looks in your browser? It looks fine in mine, which is why I was using it.
Just opened in WinXP/Firefox and it looked TOTALLY different from Linux/Opera. I'll post screens when I get home (and don't forget it) edit: looks different on Opera 9.64 Fedora 7 @ http://browsershots.org/http://coreyhoffstein.com/?p=126 too, might be my system :)
Who knew it would be so easy?
Wouldn't RubyGems need to enter the enterprise first?
Wooooosh
Yeah.. didn't even read tfa before commenting. lol
I'm disappointed. When I think about something "being ready for the Enterprise", my immediate reaction is "They didn't have this problem on *Star Trek*."
Excellent! Now we can finally use Ruby at work!
star trek had much more xml. we're catching up.
Ok, you did it for one reason only -- getting away with the string "sexml" in your code. Seriously :)
they are mostly useless without whatever data i'm visualizing atm :) here's a visualizer for 2004 icfp contest task: http://pastie.org/516852
That's kind of funny, I actually just finished building a tool that lets you perform queries against the ruby AST. You can pattern match and process S-Expressions. It still needs a bit of polish, but it's pretty neat. Check it out: [SexpPath](https://github.com/adamsanderson/sexp_path/tree)
Engage.
That is really cool. I've been talking with a friend about doing something like that. But since I am a stupid perfectionist who also want to reinvent regexps it never went anywhere.
Tenderlove is one sick fuck, and I'm saying that with the utmost admiration (and upvote). I'm just waiting for the class from recruiters asking if I can write Ruby in XML to start. 
Luckily I'm a sloppy pragmatist. So it's not perfect, but someone awesome like you could probably help fix it.
For ruby, C++, Java I use the same setup Fedora 11 - Used Ubuntu for a few years, but I find RPMs much easier to create and maintain. All of our work is turned into packages and distributed to our servers, which run Centos/RHEL Emacs - cedet - ecb (leftright2 layout) - rinari - emacs-goodies-el (there is a cvs repo for this) - rhtml 
Well I'm not really a rubyist so I probably wouldn't be much good at fixing it. But I wouldn't mind criticising it :p Here are my first impressions. First thing the synthax and integration into ruby seems nice (pretty readable). Except for the all keyword, I think it's kinda misleading. If 'and' wasn't a keyword I would have recommended using it. Second, you don't seem to have the equivalent of the * character in regexps, to repeat a pattern. Or maybe it isn't useful here ? Third, it's hard because you need to know the way the AST is to do a query. But well I'm not sure you can do something here. It's the price you have to pay for using a language more readable than lisp.
&gt;sharding All I can think of is Phillip Seymour Hoffman Sharting in "Along Came Polly". 
NetBeans
vim
vim
emacs
Specifically, I used [Rinari](http://rinari.rubyforge.org/) and [yasnippet](http://code.google.com/p/yasnippet/) to further customize my ruby mode.
gedit
Rinari is nice, and I have found that I don't like snippets as much as I thought that I did. It looks cool in a screencast, but in my personal workflow, my muscle memory just starts to type. I suppose I would need to relearn a little bit. I have become accustomed to rails mode, C-c C-c g [c, m, g, j ...] (List Controllers, Models, Migrations, Javascript etc...). It is a long incantation, but it becomes second nature. My coworker uses gedit, and always make fun of emacs "shortcuts". Which is fair, but once you learn it, it is hard to unlearn.
You can redo the keybinding for rinari to match rails-mode. I had a snippet of elisp to do that somewhere, but can't find it right now.
textmate (macosx) / rinari + yasnippet (linux)
vim, damnit
Textmate!
&gt; I still find it absurd that you should have to learn commands to use a freaking text editor. Remember: If you don't learn anything new, you can't do anything new. Additionally, vim has one killer feature that no GUI text editor can really compete with: You can ssh into a server and edit stuff on the server directly in the same window you're using for shell commands.
Vim!
I'm not sure that's a big win when GUI editors can edit over SSH... (e.g. Kate via KIOSlaves and the fish:// protocol). What's so killer about doing it in the same window?
emacs has trampmode which does the same thing.
ultraedit
I love vim, but sshfs makes you capable of editing files on remote servers with any editor. Vim's killer feature is it's speed + the insane level of customization possible.
I used to feel this way until I realized that my livelyhood is based on editing text, so it's silly not to invest time learning how to do it more efficiently.
vim, e-texteditor
Basically the same thing which makes CLIs "special" over GUIs: they are a highly-productive, no-distraction and homogeneous environment. 
+1 for NetBeans. Used to use Textmate on Mac, but NetBeans wins now because it does better code completion. I also could never get the TM+RubyAMP bundle to do the switching between a class and its related test; NetBeans does this out of the box. The only downside is bigger memory usage.
vim!
recently vim, specifically MacVim, compiled from source with a few extra flags, nerdtree, fuzzyfinder_textmate, tComment and other plugins. often textmate, too. Emacs is awesome, but I've never gotten into it.
Your comments point me towards two possible conclusions: * You make heavy use of the mouse for selecting, copying, pasting, etc. If this is the case, then the main benefit Vim has over TextMate is less context-switching (keyboard to mouse &amp; vice versa) in your editor. * You use TextMate and make use of it's very large selection of keyboard shortcuts to speed up your workflow. If this is the case, then there really is no compelling argument to switch to Vim, unless you want more keyboard shortcuts &amp; customizability. Heck, you could port the TM key mappings to Vim quite easily if you wanted to. All text editors and IDEs have their good sides and bad sides. Saying that one holistically is better than the other is equivalent to stating that violet is better than yellow. [edit: formatting]
vim 
Netbeans for rails. Gedit or geany for one off scripts.
I thought this was common knowledge. Ruby coders exclusively use TextMate on Macbooks and only in their nearest Starbucks.
emacs + autotest.el + toggle.el (find them on emacswiki) I don't use rinari or rails mode. They just get in the way.
Pff, that's bollocks. Everyone knows yellow is better.
Redcar :) (I wrote it)
Statistically speaking, yellow is one of the worst colors.
Loving redcar so far, although a lot of the time I get annoyed at the UI (it's just barebones right now). Keep up the good work, maybe I'll actually hack at the source myself one of these days :)
It's more hip to eat at a local coffee shop.
rubymine 
Textmate
http://github.com/technomancy/emacs-starter-kit/tree
Notepad++
BBEdit is my favorite editor, although it's still a bit lacking as a ruby editor. Still, I (usually) stick with BBEdit when I write non-rails ruby code. EDIT: What's with the downvote? 
vi. Anything else is a crutch. 
rubymine is pretty damn nice.
vim 
RubyMine, with TextMate coming in second place
Is 0.3 coming out soon?
I used to use vim but since taking an interest in Haskell and Erlang emacs just makes more sense.
I remember reading something about how redcar handled syntax highlighting differently but I can't find it. I don't use redcar but it interests me. Where is a list of features?
Being able to split your window is a life-changing feature. Especially if you hack rails, where you want to see a model/view/controller in one window.
cool, I did not know tComment, thanks :) I must point out rails.vim, if you are doing rails work, it is just plain wonderful
http://redcareditor.com/
the idea of Rails sharting in my database just makes me giggle.
When I use vim, I find myself hitting escape/i all the time to switch context. I mean, no editor that ever existed required more context-switching than vim. So I must question your first point.
Rubymine looked interesting until I noticed the 'Buy Now'. Netbeans.
Your supposed to vote up the first submission of your favorite editor, not repost it. 
Wow someone came in and voted every instance of Vim down.
Did you use ruby? Make it grow a horn or something.
Make it, Thrust.
Rubymine did not impress me nearly enough to pay for it. I still think Netbeans is the best IDE for Ruby.
Been busy with songkick.com relaunch and only just started work again this weekend. We'll see how it goes.
a look of disapproval
&gt; Did you use ruby? look again.
A GUI interface in VB to track an IP address?
Narwhals? Wolves?
kwrite
A body? Legs?
Emacs
Did DaVinci make a Mona Lisa v2.0 ?? I think not! You just ship that masterpiece off to the Turing Hall of Fame and rest on your laurels for the remainder of your career. 
Where's its horn?
Is this titled "OMG Ponies!" or "Sarah Jessica Parker?"
Apologies for posting "vim" myself. I missed the procedural request, probably because the answer was so easy that I spent about 2.7 seconds replying. I'll delete that post.
I thought it very daunting once... but then I sat down with vimtutor for 10 minutes and went on my way. vim is easy, and incredibly powerful. :sp and :vsp (split screen and vertical split screen) are killer app for me. That and the sheer power of modal editing. vim is wonderful.
I like your program and would like to subscribe to be notified for future versions. I am using Microsoft Horses Pro right now, but am willing to make a switch as soon as your software is ready for he desktop. Also, your open source model greatly pleases our in-house Horse Related Software Development team.
More ayes? Neigh!
But is it worse than violet?
You should port it from ruby to a real language, I bet if you wrote a C version it would be 100x faster!
Oh hai!
Hello?
Very cool
I don't think so. According to the pragprog Agile Web Development book, from page 231 (second edition) – "These tasks are Ruby code, but they need to be placed into ﬁles with the extension .rake."
I'm not trolling here - I'm simply curious why or why not it's bad practice? Same with NilClass.to_i returning 0 instead of nil... Why is that a bad habit? Most of the time, when you get a NilClass can't convert to string error, you probably really wanted the string, and have to add a if !(obj.nil?) annoyingly at the end of the line... 
Hey thanks for the critique ;) * As far as the 'all'/'and' you can actually do 'criteria1 &amp; criteria2', all lets you do 'all(criteria1, criteria2, criteria3)'. * You're right there is no * for repeating patterns, though there is '_' for a single wildcard. I haven't actually come across a need for regexp style '*' yet though. Which actually doesn't mean anything ;) * On the third point, I was thinking it would be possible to layer macro patterns on for matching some known things (totally possible right now).
my issue with it is that you never know where that is going to cause an error. say, for example, you have a piece of information that is an integer and required for creating a particular new object. when gathering that piece of information, a nil is formed, and now this important piece of information is mistakenly 0. It would be very handy in a lot of cases. The times when it is bad, it can be really bad. edit: not only in your own code, but in external libraries as well. 
Short version: 1) There is legacy code out there that, potentially, expects different behavior. 2) It will, potentially, cause a great deal of pain to a future maintainer of that code, who expects different behavior and doesn't realize you monkeypatched NilClass. What is the use-case? I'm almost certain there's a cleaner solution, such as using foo.blank? or "#{foo}" . And kudos to you for considering "convention over consideration" instead of just going ahead and altering a core class.
But, it's already what to_s do on a nil object !
I definitely see the idea of making a library not overload it... I see the value in coding properly and not overloading it in a way... Just curious how catastrophic it could be. Definitely makes your code less friendly to other developers. Okay, how do you feel about something less intrusive, like taking the to_date method from the Time library and making it public? ( I don't get why it's private in the first place)
Hmm... No... I get this error annoyingly too common: &gt;can't convert nil into String Or are you making a funny that it's overloaded in some of your code already?
I think it may depend on the ruby version. In my 1.8.6 (REE) and ruby 1.9.1, it does return a blank string. mb:~ jeff$ ruby -v ruby 1.8.6 (2008-08-11 patchlevel 287) [i686-darwin9.6.0] Ruby Enterprise Edition 20090421 mb:~ jeff$ ruby -e "p nil.to_s" ""
So how do you feel about the less invasive thing I did to turn Time.to_date public? My only fear is that it may not be forward compatible with future versions of ruby-core...
&gt; I definitely see the idea of making a library not overload it well, the problem is that code extentions are not namespaced in ruby. So if you give nil.to_i a meaning, there is no telling what that will do in code that you are using but did not write. &gt; how do you feel about something less intrusive, like taking the to_date method from the Time library and making it public? I think that is fine. I think a lot of things are fine. Modifying how nil works, though, could potentially throw off error checking in someone else's code in a serious way. 
Yeah, and they also tend to have free wifi.
changing protection is fine. I almost always do this for tests, but I don't see a problem for impl. As far as future versions of ruby... it isn't a problem until it is a problem. Deal with it then. Write good tests and run them all the time.
You get that when you do things like "str" + nil_var. First off, don't do that. String#+ is generally the worst thing you can choose. Second, #to_s doesn't get called in those situations and as you can see above, NilClass#to_s already returns ''. Third, I'm beginning to sniff a bad smell in your design with the above comment. So, at this point, I'd say you should probably write a test that illustrates your problem. You can either share it here or just dig in and try to make it pass.
We're on the same version :) It actually has to do with "string" + nil [costas@rainman ~]$ ruby --version ruby 1.8.6 (2008-08-11 patchlevel 287) [i386-linux] irb(main):001:0&gt; "string" + nil TypeError: can't convert nil into String from (irb):1:in `+' from (irb):1 irb(main):002:0&gt; 
You've made the incorrect assumption that all developers everywhere will always want the integer representation of NilClass to be 0. What if they wanted it to -1? Or better yet.... nil.
&gt;String#+ is generally the worst thing you can choose. So better off is "string #{var}" ? 
Such overload is a bad practice simply because there's something wrong with your code when string is expected, but nil is given. And all code behind yours thinks approximately the same.
Right on, I look forward to it. I consider myself a beginner ruby programmer, and want to learn how complex ruby apps work in a unix based or unix like operating systems. I figured that I would try to understand how Redcar works and maybe if my confidence rises, contribute back to it. 
There is also telegraph is you want to roll your own with asterisk.
The examples seem like bad design, not a specific problem with REST. REST doesn't force you to make spamminess a child resource of comment. Comments can still have attributes, and those attributes can be modified.
Amazing. So you're saying the cause of the problem was some third-party code you included without reading or understanding beforehand?
In ruby, nil is anything but "an as yet undefined value". Nor do we have Null.
much better. Another alternative, depending on what you're doing: arrayofstuff.compact.join 
Only you can update your comment. But anyone can flag it as spam, a la craigslist. If you don't want to get into something like attribute-level permissioning, separate controllers and actions are the way to go. I think his examples are valid, and I struggle with this issue. There's some discussion on this very issue in RESTful Web Services. I mostly fall on the side of "making all things REST" -- because of the flexibility it gives you later in the project.
I being of the human race, only have 2 hands to type. If I have to take one or both of my hands off of the keyboard to make a click then I am effectively losing speed which directly equates to a loss in productivity... Ironically, the time it took me to pen this response would provide me more than enough time make up for it... ohh.. the irony... Excuse me while I remove one hand to click the "save" button. 
It's easy enough to add it to the CommentsController with this bit: map.resources :bookmarks do |bookmarks| bookmarks.resources :comments member =&gt; { :spam_score =&gt; :any } end You get a separate action in your controller. Yes this means you need to be careful about your authorization code, but it's not difficult. I prefer this approach to a proliferation of resources.
True, but it does violate REST design principles. I make exceptions, too. 
As developers, we tend to err on the side of "making it flexible" at the cost of "keeping it simple." If you need it to be flexible, add it later. But don't try to anticipate the need, and introduce the complexity now. Honestly, most the time you won't need it. Speaking as a complete hypocrite, I struggle with keeping my designs simple and straight-forward. Of course, this joke tells the story much better than I could: http://www.ariel.com.au/jokes/The_Evolution_of_a_Programmer.html
No it doesn't. Which REST principle does it violate? - You have an addressable resource: http://example.com/bookmarks/1/comments/2/spam_score - I can GET that resource to discover its value - I could PUT a value to that resource to update it In fact, it's _more_ RESTful than the standard way Rails abuses PUT/POST requests as PUTs should _replace_ the resource, not merely update it, so technically you should send the entire state of the resource model back to the server on a PUT instead of just the parts you want to change. Does it go against some Rails conventions? Maybe. I think that's even a shaky argument. But even if it did, Rails conventions are not REST design principles.
For the impatient, the code listing is at the end of the article: [pastie](http://pastie.org/516915)
Yes, the wonderfully inflammatory title would have you believe that this has something to do with Rails itself. Even so the automagitasticality of Rails is often the cause of issues. 
I think we agree.
If SpamScore is a resource, then we agree. If spam_score is an action on a Comment resource, then we don't. I think the best illustration is in the RESTful web services book: Here's a link to [page 109](http://books.google.com/books?id=XUaErakHsoAC&amp;lpg=PP1&amp;dq=restful web services&amp;pg=PA109) 
I agree but this isn't magic: http://github.com/rails/acts_as_list/blob/8771a632dc26a7782800347993869c964133ea29/lib/active_record/acts/list.rb#L126
It doesn't matter whether you implement it with an action or a separate resource controller. As far as REST goes, all that matters is the _interface_: the URLs (resources) and the http methods which you use for those resources. If those URLs follow the intended usage (as described in the HTTP specification and books like RESTful Web Services) then it doesn't matter if you implement it with a Rails controller action, a Rails resource controller, or a Perl CGI script. The implementation doesn't matter. The interface does.
We've only discussed the urls as this point, but the payload/body/content of the PUTs or POSTs should be significantly different depending on whether or not we did a spam resource or a comment action, and that's part of the interface too. 
vvlist, if you want complex + linux, look no further than [Metasploit](http://www.metasploit.com).
Hey, look, they make [vim](http://macvim.org/OSX/index.php) for Macs, too!
fixed. I did 26 releases today, including image_science. Full 1.9 compatibility where possible.
I use Ruby for almost all my sysadmin scripts these days, among other things. Ruby works beautifully as a Better Bash (in non-interactive mode; I wouldn't use Ruby as a shell).
I just wanted chime in and mention that a lot of people are moving to [AuthLogic](http://github.com/binarylogic/authlogic/tree/master), due to it being much more flexible. Restful\_authentication is good, too, but AuthLogic gives you a bit more fine-grained control. It even has some stuff to convert things from restful\_auth to its system.
&gt; While that's fine and dandy for open source fans, the developer poll also indicates commercial SQL databases are two and a half times more likely to be used as a primary database than open source SQL databases. Wow. Either this is indicative of a shift away from relational databases far earlier than I could have hoped, or it's that most people are far stupider than I thought.
Getting started with authlogic would be good too ^^
Or you could get crazy with it and use Rack::Auth stuff
+1 for AuthLogic, very easy to use
I haven't even looked into that. I'll put it on my list, thanks.
The railscast is a good start if you haven't seen it yet: http://railscasts.com/episodes/160-authlogic
I love REST. I love it because it makes writing cross-site request forgery exploits easy as &lt;img&gt;! /hacker
We used restful auth for a very long time. It is a fantastic plugin (thanks Rick), however we needed something simpler and more flexible for a project and used authlogic. We have since used it exclusively.
I disagree. You're defining context switching as switching modes in Vim. Suppose we said you were "switching modes" every time you touched the mouse, or weren't entering text. Would you be "switching modes" more or less than Vim? My guess is perhaps slightly more, or maybe just as much.
I'd love to hear ideas on how to improve hoe (esp through plugins).
Great in combination with acl9 for light-to-medium roles management.
I really think it's like, the way of the future, man. Although AuthLogic seems to be rack-based at the core. I think I tend to go with the simple solution until I see how it's not going to work.
Scite then Netbeans... I can't help it but I hate macs. Vista 4 Life!
And for those who don't want to mess around with configs ever, there's "Config vars and Seppuku."
/bows
I'd recommend skipping Restful Authentication and going straight to AuthLogic instead. Restful Authentication is crap. It's the kind of thing that gives Rails generators a bad name. What do I mean by that? The generators that come with Rails are (IMHO) good. They generate a very minimalistic skeletal structure. What they generate is small, easily understood, and easy added to/replaced by *your own* code as you go. All the complex gnarly pieces are in the Rails libraries, where they belong, not in the generated code. Restful Authentication, on the other hand, comes with generators that spew out massive amounts of generated code that's hard to work with and hard to maintain. Functionality that should be in a nice library where it can be easily upgrade with each new version of the framework is instead spewed out in generated model and controller code where it'll end up intermixed with your code. It's not scaffolding, it's a mass one way dump of autogenerated code. Stay away... stay far away....
Great news - I think it would work better if they realeased either before of after the Christmas period though. The last release seemed a bit low profile as everyone was on holiday at the time. Just thinking it would be good to get some real Internet buzz going and motivation to fix the gems that're broke so people switch over. 
Didn't someone get the memo about Rails and Merb "merging"? Yeah, yeah, there's still meant to be one more point release before all that ;-)
It's going to be hard to get the broken gems fixed. Either the gems are no longer being maintained or the author has had no time. I do wish someone would make soap4r compliant though..... 
Or does it? [rush](http://rush.heroku.com/)
Oh great... links to railsenvy. Call me once they kicked out the commercial stuff
What's wrong with offering commercial content? Anyway, it's not like railsenvy doesn't also produce a lot of quality free content.
Yes they do, but I'd like some sort of filter (haven't seen one yet, haven't looked all that long though). I don't want to click though the results and check for each of them
It makes perfect sense to charge for quality tutorials and documentation, but somehow it still feels dirty to me. I can't explain it.
Oh great.. another communist who doesn't believe people should be able to make a living from their work.
You should ask james_britt in irc://irc.freenode.net/#ruby-lang
Who came up with the idea that videos were the most effective and efficient means of conveying programming-related content?
They really should remove casts you can't watch without paying. It just clutters up the list.
Well, 1.8.7 is the latest mature pre-1.9 version. Time to upgrade? http://www.ruby-doc.org/core-1.8.7/index.html
Matz usually [release Rubies at Christmas](http://www.rubyist.net/~matz/20041225.html#p02): * ruby-1.0-971225 (1997-12-25) * ruby-1.1b3 (1997-12-25) * ruby-1.2 (1998-12-25) * ruby-1.3 (1998-12-24) * ruby-1.4.3 (1999-12-08) * ruby-1.6.2 (2000-12-25) * ruby-1.6.6 (2001-12-26) * ruby-1.6.8 (2002-12-24) * ruby-1.8.1 (2003-12-25) * ruby-1.8.2 (2004-12-25) * ruby-1.8.4 (2005-12-24) * ruby-1.9.0 (2007-12-25) 
umm ... where is the link?
you should update the post with a more descriptive title so it can show up in google search results for stuff that other devs might search on ... like "before_save firing before_destroy on delete" etc
Haha, never realised that - can't argue with that kind of consistency :) 
Looks like its here: http://github.com/Adman65/Snapshot/tree/master
You, my friend, are in luck! I found the source code for you: http://dev.ctor.org/soap4r/browser/trunk. I don't know how comprehensive their test suite is, but I bet you could bang this puppy into shape in a few days easily.
Update: emailed James Britt, got the answer: &gt; I regenerated the rdocs yesterday. Apparently something is very wrong. 
I don't necessarily think anyone has expressed that videos are the most effective and efficient means of conveying programming-related content. However, many of the videos indexed at RubyTu.be are conference videos that organizers have graciously published for those unable to attend. And the quick 5-10 minute Railscasts videos are great for a quick introduction to a given feature or plugin.
Any video that is a paid screencast will be tagged with "paid" in the future so you can simply avoid these. And if enough paid screencasts get into the list, a filter may be introduced.
The ASCIIcast is a even better start if you're not such a fan of code in video: http://asciicasts.com/episodes/160-authlogic
Now when the hell can we get this in MRI, having to mess with spawning child processes just to get true concurrency is annoying.
I believe it's a compile option on the 1.9 MRI. Also rubinious and jruby have it too. Since rubinious is the next version of ruby soon all versions of ruby will have native threading. That's awesome.
Guh? Rubinius is the next ruby? I'm pretty sure Rubinius isn't going to become official... maybe you're thinking of the rubyspec project? What's more, Rubinius still has the GIL for the time being.
&gt;Guh? Rubinius is the next ruby? Yup. Rubinius is going to be ruby 2.0. It's been announced. &gt;What's more, Rubinius still has the GIL for the time being. Last I checked they were getting rid of it. I haven't checked it recently so I can't tell you whether they have done it yet or not.
Macruby has made some amazing advances, LLVM, removal of the GIL, ahead-of-time compilation. 
check out http://www.ruby-doc.org/core/classes/File.html - It's only documentation for ftools.
Might want to re-read that announcement, or link it here for all to see so we can point out how you misread it.
malcontent, I don't know where you read that, but I'm sorry to inform you that you are wrong. Koichi did mention that he thinks that the future of the Ruby VM will be Rubinius or something like Rubinius but there isn't any plans to make rbx the official implementation as of now. Having multiple implementations is actually great for the Ruby community.
I'm wondering if MacRuby is gonna make use of Snow Leopard technologies such as Grand Central and OpenCL. That would rock!
A chain of "yarly/nuh-uh" replies can be cut short nicely with a citation :)
if you check the mailing list you will see the it's in the plan but will be available as a separate API. The nice thing with that is that once someone will take the time to compile MacRuby on Linux everything will still work fine even without Grand Central.
There was talk of a "PosixRuby" project to do just that I heard about at railsconf. Haven't seen anything about it since though.
I don't know shit about the internals of SOAP. I doubt that library is for the casual ruby programmer.
Thanks. That would be helpful.
What about "rubygame" and "gosu" ?
Looks like he wants a true 3D game.
It's not easy without own c-extensions
how do you cite the lack of something?
That's what I was thinking. I was hoping I was just missing something. I do have experience wrapping C libraries, so I can do that if that's really what is required. I'm not wanting to reinvent the wheel if I can avoid it. 
What about JRuby and [JMonkeyEngine](http://www.jmonkeyengine.com/) or other 3D java game library? If that works it seems like a faster path to your goal than wrapping a bunch of c libs. 
This looks pretty useful for development stuff... thanks for creating
Another one? Httpclient, httpparty, net::http. When is it going to stop?
An admission that you have no sources, then, or a link to whatever caused the misunderstanding :)
This is cool. We love Haml at my workplace. Haml is just the tip of it though. Sass is where it shines. Defining variables and mixins for css makes your life so much easier as a web developer.
I'd like to see some performance benchmarks comparing it to the others.
markaby, remarkably, erector, builder, and now parkaby. They all do the same thing more or less. 
I'm actually surprised people don't pimp Sass more often. Haml's a lot nicer than ERB, but it's not a game changer. Sass on the other hand saves you orders of magnitude of effort. It has a much greater impact on your productivity. That said, I think this Markaby business is interesting. I think the forced indentation is a good idea but I hate the indentation errors; I'd have to try it extensively but it seems like it might be just a bit nicer to wrap things in curly brackets instead.
I agree with you regarding the forced indentation. Let's face it if I liked forced indentation I'd be programming in python. For me the worst thing about it is refactoring your views. 
Too late.
Sass has a new website now too: http://sass-lang.com
Very nice. Thanks for your work on compass, BTW.
No point in doing 3d graphics in Ruby, it would be insanely slow.
I had never heard of this. I like it. Python-style css.
I know I am late to the party but.... I have been reading the mail exchanges between the two projects and it seems like chef is targeted towards the ruby programmer who wants a bit more flexibility than puppet can offer. If I know ruby is puppet still a better choice than chef?
upon reading this review I biked down to my local bookstore (powells technical books) and picked up a copy. I was pleased to see it has a sweet crab on the cover 1 chapter in, so far so good. seems right up my alley (burgeoning rubyist)
this is a very nice read. I found it informative. Its nice in hard cover as well
GO check this out LOVE CALCULATOR.http://www.mylovecal.com. Surely, you're guaranteed a more romantic life than you have now.. Ruby romance is sure to be better with this.
RubyMine
I've used and contributed to Acl9, it's a great fit for small-to-medium role management requirements. I like to use this in conjunction with Authlogic, which is a really nice gem for managing authentication: http://github.com/binarylogic/authlogic/tree/master
fail. you meant to link here: http://www.railsenvy.com/2009/7/8/rails-envy-podcast-episode-086-07-08-2009 not to self
Heh. Nice catch, semanticart. Yes, that link, instead. ;) Gregg fail.
+1 for Authlogic. :)
Fascinating project - I had never heard of Cassandra before... Is it specific for storing Hashes only? It looks like MongoDB is good for storing JSON or YAML serialized objects... Just curious when you'd use which... I'd personally prefer to serialize my objects than have to created key=&gt;value pairs for everything, although I see value in both engines...
hmm, I just posted an early release of my plugin here: http://github.com/Adman65/AccessControl/tree/master I'll have to look at their implementation.
Hi! Your best bet is to attend a Seattle.rb meeting. We meet every Tuesday at 7pm. Many skilled engineers attend, so you should be able to find someone. Here is the info: http://www.seattlerb.org/ Ask for Eric or Ryan when you get there. I'll be on vacation for the next two weeks, so I can't attend. :-)
I'll second Aaron's recommendation of seattle.rb - I don't get to attend every week, but it's a great place to meet Ruby/Rails developers. Or, you can save the trouble and contact me directly! I've been doing Rails for a couple of years now, and I'd be happy to discuss your project! Email me at john (at) mentalvelocity (dot) com, or call the phone number on my website (mentalvelocity.com)! - John
Using method\_missing for delegation? Ruby has at least 2 delegation libraries as part of the standard library and he's recommending method\_missing?! Pathetic. Poor. Very bad advice. After seeing a slew of books from people who appear to have used Ruby for a grand total of about 3 months, I should publish my own so people don't follow the type of horseshit advice I'm seeing in some of these books.
An underscore (\_) is used to start italic like * is. Eg \_this\_ comes out as _this_. You should escape underscore with a backslash. Eg \\\_this\\\_ comes out as \_this\_. Also, for code backticks are really good, eg `method_missing` comes out as `method_missing`. For larger code blocks start every line with four spaces.
If it's anything like DCRUG (my local one), you'll meet Rubyists. Ask if you can announce, briefly, that you're looking for a Rails developer and your contact information. US unemployment is at 9.5%, so I guarantee you will find someone -- or someone who knows someone -- looking for a new gig. Good luck.
Thanks, fixed.
needs more rockstars
I still think of the Pickaxe as the standard book on Ruby.
needs more rock lobsters
I'm working on integrating these two at the moment. They seem to work well together. Do you know of any caveats I should watch for?
This is the first time I've _ever_ heard of any other book referred to as the standard. By anyone.
Devver is a nice idea, but until they support running selenium tests for at minimum our Javascript suite, it's a no-go.
We don't have support for selenium planned anytime soon. Check out SauceLabs for distributed selenium. What do use for your javascript suite?
We've got ~1500 Screw.Unit tests right now which runs under thin/selenium. I actually looked at you guys yesterday as we're migrating from a subversion repository into git and I was thinking it might be a good time to look into outsourcing our CI.
It is the O'Reilly hype machine. The same one that brought you web 2.0
Nope, no caveats I know of.
Thanks, sometimes when things seem too easy I start to get apprehensive.
Its "standard" in the sense that its written by the creator of the language and so occupies the same position as the "standard" text by stroustrup on C++. Personally I like both this one and the Pickaxe but for different reasons.
Figured I would post this here and implore Ruby folks not to engage in the discussion. It, as you would expect, has drifted into a Python vs Ruby debate. I for one would be happy to see Rails implemented in Python, the more options the better to my mind. 
What is wrong with [django](http://www.djangoproject.com/)? I have not used it, but I thought that was a python MVC framework. 
Merb - a framework that won't be existing for too long as it's being merged into Rails anyway, so you're wasting your time if you're developing for it... 
Django is MTV not MVC (and apparently MTV is what the "kids" are grooving to these days with their "music videos" and their "boom boxes").
We (and be we I mean "some sub-set of the python web crowd") use metaprogramming to support declarative syntax in web frameworks, e.g.: class Foo(object): implements(IFoo) But as Yehuda points out, this style of programming has language support in Ruby. You can easily mess with a class during creation in Ruby (for better or worse). To do this in Python you need to use functions "for internal and specialized purposes only" (sys._getframe) and temporary metaclasses. Ruby also has language design support for this, e.g. Matz designed Ruby like this on purpose. Guido has commented off-hand in response to this style of programming in Python, "Your framework is full of hacks", since it does require messing more deeply with internals in Python. 
&gt; I for one would be happy to see Rails implemented in Python, the more options the better to my mind. Of course, the python community is very resistant to most anything from Ruby because it's not pythonic (pylons and some of its components face this criticism) and it's also largely resistant (and when not resistant, ambivalent) to a lot of the more experimental stuff in the Ruby world (eg, GHRML in Python vs HAML in Ruby).
I don't think there is anything wrong with it, the stack overflow post is just posing the question why hasn't someone done all the automagic and cool routing stuff from Rails in Python. Or at least that was my impression. mr katz points out that Ruby is just better at creating DSLs which is what makes many of the bits and pieces of a rails project painless. 
I found this post a bit odd. Django is well-known enough and is roughly equivalent to Rails. It differs more in style than capability (opinionated vs. pythonic if you want to use the buzzwords).
Very simply, because Ruby on Rails exists and is reasonably mature. As is Django. And Catalyst. And even various PHP frameworks. You *could* rebuild Rails on Python, but it would be a pointless waste of time. And - in general - getting comfortable with a new programming language is a better idea than translating a program.
&gt; You can easily mess with a class during creation in Ruby (for better or worse). Python 3 has a `metaclass.__prepare__` method which allow you to do a lot of crazy things to your class. For example, you can replace the class dictionary with an odict, so that the order that you declare class members in is preserved.
Yehuda makes an excellent case for the syntactic elegance of Ruby with respect to metaprogramming. Many features of Rails take advantage of this to add dynamic behavior to classes. While I'm sure that Rails could be implemented in its entirety in Python, I doubt it could be done with the same level of conciseness.
I looked at django, but I couldn't stand the templating language. I think you can use haml now, though, so maybe I'll look at it again.
Wow, that is a crazy-obscure feature.
I work with django daily, and I still hate the templating language. Worst part of the system as far as I am concerned. The rest of django makes up for it nicely though.
Back when I had to use django I hacked a python haml implementation in a day. Python's "we won't give you real blocks, but try this and this and this and also this" were somehow good enough. I'm back to Rails now.
When Net::HTTP is dead and buried once and for all and we've all gotten over the traumatic experience of dealing with it (i.e. probably never) 
I don't know... I use it. I don't find it all that offensive.
I commented on site but the comment is probably held in moderation. I love ruby because of this flexibility, but in all fairness such syntax hacks never really succeed, as they interact with each other in bad ways, are hard to debug and mantain and usually incur a large performance hit. As an example, his code breaks normal ruby compat $ irb --simple-prompt -r decorators.rb &gt;&gt; c= Class.new =&gt; #&lt;Class:0x8dce8&gt; &gt;&gt; d= Class.new { extend MethodDecorators } =&gt; #&lt;Class:0x87b04&gt; &gt;&gt; c.foo NoMethodError: undefined method `foo' for #&lt;Class:0x8dce8&gt; from (irb):3 from :0 &gt;&gt; d.foo NameError: wrong constant name foo from ./decorators.rb:9:in `const_defined?' from ./decorators.rb:9:in `method_missing' from (irb):4 from :0 &gt;&gt; c.Foo NoMethodError: undefined method `Foo' for #&lt;Class:0x8dce8&gt; from (irb):5 from :0 &gt;&gt; d.Foo NoMethodError: undefined method `key?' for nil:NilClass from ./decorators.rb:11:in `method_missing' from (irb):6 from :0 
oops, hit save too soon.. ... anyway they are nice to experiment, but I believe the only one that stuck, among the various syntaxes for, e.g. types checking, interfaces, DBC, multimethods, named args and language level support for FSA was Symbol#to_proc. Not much really. 
&gt; oops, hit save too soon.. Just so you know, you can edit your posts.
&gt; **\* full mode:** no full ruby spec support, no runtime code generation, no LLVM. (”very light application and/or if the environment does not support runtime code generation” *(hint-hint)*) So it will be possible in the future to write iPhone apps in Ruby? Maybe fast enough for simple apps. But ~13 MB size, hm...
full mode apps won't be 13MB. Actually, my example was compiled using the normal mode meant for desktop/server apps. Furthermore, even the normal mode will generate smaller files. - Matt
yeah I didn't want that "backtracking opinions" feeling though :)
Then again, you could let people have their anonymity. Just because it's ruby you don't have to be a giant idiot.
While I am extremely curious about the life of _why, if he has chosen not to share it with the intertubes, we have to respect that. Whatever his reasons are, he has every right to use a pen name and we should not poke. I'm slightly disgusted by this.
ParseTree does not work in Ruby 1.9.1, which means this project won't upgrade. You'll have to rip it out once you make the move. [ParseTree EOL](http://blog.zenspider.com/2009/04/parsetree-eol.html) 
Agreed. Although I admire your sluething skills, this is like pulling the curtain back on the Wizard of Oz. 
awesome (but i'd never use it in an app for work due to readability concerns)
Easy to miss the link to the article of the talk at the bottom of the page, which is: http://martinfowler.com/articles/rubyAtThoughtWorks.html
Will there be porn at any of these?
But style and a certain kind of elegance is what makes Rails Rails. There are a dozen "roughly equivilent" fameworks, but Rails is still unique (as is Django). One thing that keeps me using Rails are really clever and convenient things like association extensions. The first time you see them, the look like magic ex: class User &lt; ActiveRecord::Base has_many :posts, :order =&gt; 'created_at desc' do def hidden @hidden_posts ||= find(:all, :conditions =&gt; "state = 1") end end end Note that the call to find in the new "hidden" method magically inherits the :order parameter from the parent has_many association. Every association extension you define builds on the parent's parameters. And it only makes one SQL query! Obviously you could theoretically provide the equivient somesuer.posts().hidden() in Python, but coudl it possibly be that elegant? 
all porn. all the time.
Dick move dude.
Awesome, I worked with the post's author Alex Chee at ELC two years ago. Smart guy. 
You really need a strong java background to appreciate the greatness of ruby.
Word... another ELC alumni? 
I find it ironic that you have an anonymous username, and unattributed blog, that you created for this purpose alone. So, you feel the need to tell everyone _why's real name, yet are too cowardly to identify yourself?
Anyone who uses "smackdown" when they mean "showdown" watches too much professional wrestling. Before you say "Well, it really did smack down the other IDEs...", read the part where he talks about the "smackdown scenario". This isn't a wrestling match, it's an IDE comparison. One could question the use of the word "great" as well. In what universe is a test of one feature in three IDEs "great" in any way? A more accurate title would be something like "Comparing out-of-the-box semantic code analysis and navigation in a few Ruby IDEs", but I guess that doesn't grab the kind of blog traffic that a silly overblown headline does.
IDEs seem like complete overkill for Ruby, Vim works just fine.
Yes and no. There's some nice features of NetBeans and Ruby. ActiveState Komodo is really good too - and there's a free light version where it's more like a syntax highlighter. But I just like vim or gedit myself too. Depends on what mood I'm in :)
There's a Ruby wrapper for Ogre3d. http://ogrerb.rubyforge.org/
It's not even a matter of "overkill." But yeah, I use vim for all of my... everything. Including Ruby.
yep, still doing ruby/rails?
It would be cool to gemify this if it could detect windows systems and also do it in a windows compatible way. Perhaps, we will make some time to get Avdi on that... haha
RubyMine, according to its own site, is a "Ruby on Rails IDE". I don't want a Rails IDE. I want a Ruby IDE. So I'm not interested, even if it has one (horribly oversold) feature NetBeans lacks.
rails has conventions that can be exploited to make development faster, the IDE could make you faster, in theory.
Tried RubyMine today. IDEs need about 1/4 of the features and to make the ones they leave obvious and intuitive.
Yes sir; looks like you are too? What's up with queri.ac - I thought that was Zeke's project? One of these days I'll make it to the [Gainesville meetup](http://www.meetup.com/gainesville-ruby-users/)
cool, didn't even realize we had one, i'll try to make it out there as well, queri.ac is his project, i added a whole slew of features to it last year
I will use it at work, because it's a nice solution to a problem that happens fairly often. It's way more elegant than saving state in an extra variable.
Better or worse than _Why's book?
The windows version would basically just remove a step. The Windows shell always reads character-by-character, so there's no need for the Termios stuff.
Yeah you were saying that is easier... Looks like one person commented on the article about wanting windows... having it auto detect and switch between methods would be pretty cool. Then again I hope to not be on windows much anymore.
[A link to the book](http://www.pragprog.com/titles/ppmetr/metaprogramming-ruby).
Good book, btw
I currently use Net::HTTP - why would i use Curb or Patron instead?
Any benchmarks?
"Do you belive in magic?" http://www.youtube.com/watch?v=TRfSbtCFKQ4 "Do you belive in magic? Yeah. Believe in the magic in a young girl's soul believe in the magic of rock n roll Believe in the magic that can set you free Ohhhh, talkin' bout magic" 
The process used in the code is called a [Hidden Markov model](http://en.wikipedia.org/wiki/Hidden_Markov_model). The open-source fantasy game [The Battle for Wesnoth](http://www.wesnoth.org/) uses a similar implementation in C++ to generate several of the character's names.
I love how people say they agree with Giles about something, but hate how he communicates his points, as if they're two disparate, unrelated things. How Giles writes is his style, and I believe it helps me understand his points, especially when you see how passionate he is about his work. This article is part of a long, intense undercurrent that a lot of programmers don't care about or don't care to admit: that computer science and programming have a history with incredible depth, and that we are where we are now because people largely ignore that history, or consider it beyond their understanding, or 'magic'. To have someone point out that no, it's not magic, and no, it's been understood for a very long time, and yes, you should understand it if you want to become good at what you do... it's refreshing. And it's certainly not snide at all, at least not coming from Giles. It's realistic and it's on the level.
hey dude, thanks. totally what I was trying to say.
I think when Pythonistas say "magic" what the really mean is "indirect". This is one of the fundamental differences in the philosophy of Ruby vs. Python. Pythonistas prefer things to be explicit, Rubyists prefer to create abstractions for things, even at the expense of being explicit. This balance between explicit vs. abstract is a fine line that you have to walk and it's hard and people fuck it up (or they see code where someone else fucked it up) and then they blame Ruby. To those people, I say read [this article](http://www.vanderburg.org/Blog/Software/Development/sharp_and_blunt.rdoc). Specifically: &gt; Weak developers will move heaven and earth to do the wrong thing. You can’t limit the damage they do by locking up the sharp tools. They’ll just swing the blunt tools harder. 
"Magic", in this context, has nothing to do with superstition. It has to do with the obfuscation of cause and effect. It's hard to follow underlying logic, and easy to subtly violate tacit conventions. Partly, that goes with the territory of working at a higher level of abstraction, the benefits of which actually far outweigh the downsides. And partly, it is due to poor tool support, which is coming along, slowly. But I think the word "magic" is fair. Writing a Rails app is more about knowing the right magic incantations than working things out with logic. It saves you from a lot of rote plumbing work, but subjects you to a lot of rote memorization. And this is why I often ask people what they mean by a word they're using. 
Magic means "This framework does not force me to type enough. I don't like frameworks what do things I haven't typed. I prefer django which forces me to tell it every little thing like all the fields in my table, which table etc". Of course rails will LET YOU TYPE ALL THAT if you want. It just doesn't force you and that really seems to freak a lot of people out. &gt;It saves you from a lot of rote plumbing work, but subjects you to a lot of rote memorization. Yea. Learning the framework is important. As I said though. Rails does not prevent you from typing. Type all you want. Rails doesn't mind. You want to specify the name of the table in your model? Go right ahead. You want to specify the primary key by hand? Go to it!. You want to type every single finder and the full SQL for each one? Just do it!. You can type all day long and pretend you are using django.
&gt; But who says that needs to be much larger to get those features?" Erm, the first is 86 characters, the second is 444.. It's the same number of lines, but a lot of those are several lines (separated by `;`), and it's partially obfuscated.. The fancier version is actually nearer 20 lines: require 'readline' require 'rubygems' require 'bond' require 'bond/completion' history_file = File.join(ENV["HOME"], '.mini_irb_history') if File.exists?(history_file) IO.readlines(history_file).each {|e| Readline::HISTORY &lt;&lt; e.chomp } end while (input = Readline.readline('&gt;&gt; ', true)) != 'exit' begin puts "=&gt; #{eval(input).inspect}" rescue Exception puts "Error: #{$!}" end end File.open(history_file, 'w'){|f| f.write Readline::HISTORY.to_a.join("\n") }
With that definition of the word "magic", I agree with you completely. It still seems to me that by insisting on your own definitions, you are generating controversy... Well, it's a good propaganda technique. But I already conceded that the upsides outweigh the downsides, so I guess I'm just one of those dangerously pragmatic guys that uses what works and fails to propagandize. Sorry. I love Rails, but it isn't perfect. I'm unqualified to comment on Django since I've never used it. 
&gt;With that definition of the word "magic", I agree with you completely. It's not my definition, it's theirs. They are saying "this framework magically knows what table is and what the fields are in the database". Obviously it's "magic" because the programmer didn't specify it in an XML file or in the classes themselves. I am merely pointing out that you can type all day long in rails. you can tell rails what table the model is using, you can tell it all about the primary key, you can specify how the models hook up using what fields etc. Furthermore you can write a "find_by_some_field" instead of relying on the rails magic. Yes rails makes a ton of decisions for you but you don't have to accept them. You can spend three weeks typing in the minutia and the SQL statements if you want to. The people bitching about magic seem to be unaware of that. 
If you are programming and you think it might be a good idea to call what you are working on "magic," put down the keyboard and walk away! Go find a programmer who understands the problem domain well enough that it doesn't seem magical to him. "Magic" is code for "I have no idea what's going on."
Their definition of "magic": &gt; important things that are happening "behind the curtain" so to speak Your definition of "magic": &gt; This framework does not force me to type enough. I'll concede that these might sound equivalent in some circumstances. You can choose to do it the dumb explicit way if you want, for yourself, theoretically. But as soon as you have to work on a team, or work with existing code, or have your code reviewed, or just want to take pride in your work and feel good about your work... you really do have to know the idioms and conventions and incantations. This choice of which you speak is an illusion, in the sleight-of-hand portion of the Rails magic show. As a practical matter, you _cannot_ type all day long in Rails, for all the reasons I listed, not just because you _prefer_ the shorthand. The people defending Rails magic (and those who are busy creating new magic) don't seem to want to admit that any trade-offs have been made, rather than arguing the point that the trade-offs have been mostly good. I want to see Rails get popular, but I think this denial is a bad sign. 
You're missing the point. Whether it's 7 or 20 lines made easier for you to read, the line count is still 1/10 the size of irb for what I consider most of its functionality. Hopefully, this makes people wake up and realize they don't have to use something that's poorly documented, minimally tested and bloated just because it's always been there.
&gt;I'll concede that these might sound equivalent in some circumstances. They are completely equivalent. Once again YOU DON"T HAVE TO ACCEPT THE RAILS CONVENTIONS. You can type and type and type all day long if you want. you don't like "magic" finders? Write your own. You don't like magic table names? write them down. &gt;But as soon as you have to work on a team, or work with existing code, or have your code reviewed, or just want to take pride in your work and feel good about your work... you really do have to know the idioms and conventions and incantations. Yes. You really do have to know your framework in order to wield it. Is there some framework out there you can use without knowing it? &gt;As a practical matter, you cannot type all day long in Rails, for all the reasons I listed, not just because you prefer the shorthand. You did not list one reason telling me what is preventing me from explicitly declaring every table, every join, every field, every finder. &gt;I want to see Rails get popular, but I think this denial is a bad sign. Rails hatred is a disease.
Looks interesting, but for now I'm staying with nanoc
and i with webby
Haml would be good if you web page contained more markup than text. If it was mostly text it would be a pain to keep indentation straight.
Rails is a ghetto, full of arrogant blowhards who do not suffer fools gladly.
i hate projects that reinvent the wheel. scratch your own itch, sure, but at least try to collaborate with an existing project first instead of uselessly replicating functionality and trying to be a rockstar developer who 'started a successful project'
Interesting, but I kind of winced a bit when the author mentioned using a God script to keep the worker alive.
ugh. i remember that crap from java. didn't realize i had to do it in ruby too :-( thanks.
I didn't realize it until recently, when I found all sorts of duplicates in my set.
Here is a demonstration as to how this fails: With the class: class MyClass def initialize() @this = "hello" @that = 4 end end In irb: $ MyClass.new.hash == MyClass.new.hash =&gt; false $ MyClass.new.eql?(MyClass.new) =&gt; false Both hash and eql are giving different results even for identical objects (this is because the Object definition eql and hash only return the same value for the same object). Although I find this definition stupid. We have an immense amount of introspection and control over ruby object, why don't we have a definition of eql? and hash that uses that to have good defaults for 99% of the time? For example, a (imo) better definition of eql?: class MyObject def eql?(other) return false unless other.class == self.class return false unless other.instance_variables == self.instance_variables self.instance_variables.each do |var| self_var = self.instance_variable_get(var) other_var = other.instance_variable_get(var) return false unless self_var.eql?(other_var) end true; end end class MyClass &lt; MyObject def initialize(x) @x = x @var = "var" end end $a = MyClass.new(1) $b = MyClass.new(1) $c = MyClass.new(2) In irb: IRB$ $a.eql?($b) =&gt; true IRB$ $a.eql?($c) =&gt; false 
We do have a definition of eql? and hash that use good defaults 99% of the time, do you actually construct copies of objects just to find them that often? By default they are based on the object id, which has worked so far for me without problem.
We have equal? to find two references to the same object, eql? is meant for finding objects that are identical (even if they are a copies of each other). The current definition if eql? is wrong in some cases in most classes. My solution is correct in most classes. I think correctness should beat simplicity.
It's going to be interesting to see what role EngineYard is going to take on in the future. Today, Ruby is a very community driven project, with no big name backing it. I reckon that EngineYard could help to strengthen Ruby in the enterprise.
great article. Wish I was there
I'm curious what real world applications would benefit from having a CouchDB backend rather than a traditional relational database. I've read up on CouchDB and it looks neat but don't know where it would be appropriate to use. Anyone have any examples?
It doesn't seem to limit how fast it crawls pages. This is the first thing you should do when writing a crawler.
I don't know about "important" but jruby does rock. Once they get nailgun polished up I think it's going to be my primary platform.
Have you tried submitting your .eql? method as a patch to the standard library? I've found that the ruby core team is very open in this regard.
The main problem is if a class depends on the old default definition (ie `eql?` behaving like `equal?`), then the change would break that code. It is probably too hard to change now, unfortunately.
FUD FUD FUD
I don't program in Java, and I understood about five words of that article.
I am curios to know why you think that limiting the crawl speed would be so important?
Because almost all sites will ban your crawler if you crawl a site as fast as you can. It can put an enormous strain on a site if you have your distributed crawler pulling pages on a site without a pause. There is a reasons why it was added to the robots.txt spec.
You're missing the point. I can make all of irb 10 lines long if the width doesn't matter. Nothing is wrong with saying mini-irb in 20 (well-formatted) lines.
Actually, == is the standard thing to override if you want a custom coarser-grained-than-instance-identity equivalence relation. eql? has just one special purpose, which is to be used by the hashing implementation to distinguish objects which have the same .hash. One would think this wouldn't be necessary, you could just use == to do this. But, while it's desirable that .hash always respects ==, ie a == b implies that a.hash == b.hash, there are a few exceptions to this in the stdlib. And these exceptions are what force ruby to require implementation of another special equality method (eql?) which always respects the semantics of .hash, for the hash algorithms to use. Eg in ruby 1.8.6, Hash#hash is actually funny like this: &gt;&gt; {} == {} =&gt; true &gt;&gt; {}.hash == {}.hash =&gt; false &gt;&gt; {}.eql?({}) =&gt; false The only other instance I know of is Float vs Fixnum: &gt;&gt; 1 == 1.0 =&gt; true &gt;&gt; 1.hash == 1.0.hash =&gt; false &gt;&gt; 1.eql?(1.0) =&gt; false I'd say for user-defined classes, == should always respect .hash, and eql? should always be the same as ==. Hopefully the weird cases in the stdlib have gone with 1.9. I think your suggested version of ==/eql? based on instance_variables is a bad suggestion. It adds a lot of overhead to a very common operation (== is used implicitly and explicitly all over the place) for little benefit in general. What's more it may cope poorly with cyclic references. Chances are if I do want some kind of coarser-grained equivalence relation on instances of my class, it'll be based on some identifier which is a subset of my instance variables, not the exact values of all instance variables, some of which may be cached method results, lists of observers, other implementation artefacts...
I agree width matters. I don't agree with your comparision: reducing 5000+ lines to 10 isn't similar to reducing 20 to 7.
Ahhh, that actually makes a lot of sense. I might take a look at the robots.txt spec that you mention. Plus it gives me a whole new direction to think about regarding scheduling crawls etc, even though my crawler is not really intended or designed to run in a distributed fashion. Like I said, there were dimensions to this thing that I didn't even think about :). Thanks for the info, much appreciated.
HAML for the skeleton, markdown for the content might be a nice way to go.
Well [when you look at the code](http://rb-gsl.rubyforge.org/svn/trunk/rb-gsl/lib/gsl/oper.rb) no wonder why calculation are slow, overriding basic operators like this, i really wonder what the guy that implemented that were thinking. Anyway, ruby cannot be a good choice if you want performance from numerical calculations.
Is this suggesting that ANALYZE TABLE should be run on each table on a schedule during offpeak hours?
Cool to see someone doing something physics related with ruby. But title is misleading since it doesn't mention any of its relation to Feynman-like diagrams.
From the article's comments: &gt; Peter, &gt; &gt; I would recommend against putting ANALYZE TABLE or any other admin statements on a regular schedule. I would suggest running this only if you have concerns about the consistency of the statistics. 
More like "Installing multiple versions of a package can cause confusing errors". [This can happen with anything, not just ruby.](http://en.wikipedia.org/wiki/Dependency_hell)
Yeah, /usr/local/bin/ is single-version only (e.g. one "/usr/local/bin/ruby"). I'd wager that most people dumping stuff into /usr/local/ would be better off using something such as ~/sw/someapp-someversion/, where multiple versions of software can peacefully co-exist side-by-side. /usr/local/ is also for root installs (typically if multiple users require the sw, or sysadmins might use this in a production server). If you are installing sw as a developer, then you don't need to install as root, so install into your home dir and avoid the evils of using 'sudo'. 
So where's the link?
Boo. No oxford comma!
It is too bad almost no one can USE the current version of Ruby because of all the incompatible gems/extensions. Am I wrong about this? There is so much awesome in Ruby 1.9, it makes me sad that I still cannot reliably use it in a professional setting. If you are using Ruby 1.9 professionally somehow, especially for Rails, are you manually patching extensions, or what? Mongrel for instance. Does anyone consider manually patching things safe in a professional setting? Every time I start playing with 1.9 and Rails I run into problems that I may be able to fix but, I think to myself, that I cannot possibly in good conscience use this for a client's website. Sorry for the somewhat off topic comment, but I love Ruby, and I constantly hear about improvements and so on in 1.9, and I honestly wonder when I will get to use it without a lot of hassle.
&gt;It is too bad almost no one can USE the current version of Ruby because of all the incompatible gems/extensions. Am I wrong about this? Some libraries are not compatible, most are. I guess it depends on what you need. &gt;If you are using Ruby 1.9 professionally somehow, especially for Rails, are you manually patching extensions, or what? Rails has been 1.9 compatible for a while now. What extension are you using that is not compatible? &gt;Sorry for the somewhat off topic comment, but I love Ruby, and I constantly hear about improvements and so on in 1.9, and I honestly wonder when I will get to use it without a lot of hassle. I use it all the time. In fact I use for all my new projects (I can't be bothered to even test my old ones, they are running just fine). 
It's sounds like you are just unlucky, to me. I have not run into any 1.9 compatibility issues for a while now.
It's a disappointing interview. On the one hand I think it's great there are so many implementions of ruby around but on the other hand I read that he doesn't have time to test and experiment with the optimizations. Maybe it's an inefficient to have so many people working on so many implementations. 
Of course, for an older project an upgrade will be more involved, but Rails works, passenger works, all the gems I'm currently using work (a couple stragglers like shoulda have been updated in recent weeks). Compatibility is well past the halfway point. For my company, the only thing that notably doesn't work in 1.9 is Merb. You do need to usually have the latest version of gems and plugins you are using. If you have something that is still incompatible, then you can often find a fork on github with the necessary changes or you can fork it yourself and update it.
I don't use it, but there is an active network on github: http://github.com/ruport/ruport/network You could also try hitting up [Gregory Brown](http://blog.majesticseacreature.com/) if he doesn't respond here. Depending on what you are using it for, there might be other libraries on github.
The Pickaxe was most Rubyist's introduction to Ruby (at least before Rails got big), and for many years was the &lt;em&gt;only&lt;/em&gt; comprehensive English-language guide to the language. Up until The Ruby Programming Language came out, if you asked "what paper book should I get on Ruby" on the ruby-talk mailing list, "The Pickaxe" is the reply you'd get. Heck, you might still get that reply depending on who's answering.
Kind of offtopic but.... What does it mean to have an active network on github? Obviously this means there are some (many) forks but what good is that? To me the important thing is not that there are a half a dozen forks the important thing is that those forks are being merged with master on a timely basis. Sometimes the presence of many forks means the maintainer isn't interested in the project anymore and the only way to move forward is to maintain your own branch. Many times you have three of four forks each with it's own feature set in various degrees of "done-ness". All in all I think github is quickly becoming a mess. gem search -b actionwebservice actionwebservice (1.2.6) datanoise-actionwebservice (2.3.2) davidsmalley-actionwebservice (2.3.1) dougbarth-actionwebservice (2.1.1) GavinJoyce-actionwebservice (2.2.3) mozy-actionwebservice (2.3.2) nmeans-actionwebservice (2.1.1) So which one would you install and why? Why is it such a great thing to have this many forks of actionwebservice? How come none of them are in decent shape?
I think you all should take a look at http://github.com/sandrods/odf-report/tree/master You can create .odf documents easily, using a previouslly created .odt template. You can use OppenOffice as you report designer!! How cool is that?
I think forking a gem/plugin is a sane thing to do before using it in your app. Otherwise, if you need to patch it, it's a total pain in the ass to switch submodule repositories, and there's always that risk of a "git submodule update" bringing down unwanted changes on master. A preemptive fork eliminates all this, but clutters up github with your fork that often doesn't have any unique content. 
Why not git clone blah git checkout -b my branch That would accomplish the same thing without cluttering the gems list. Never mind. I know the answer. It's because the maintainer of the software doesn't care anymore and will not give you commit rights or accept your changes. 
How is this different from rupert and documatic? Documatic is pretty nice. It lets you write up your odt file as if it was an ERB template. It also supports partials. 
&gt; Many times you have three of four forks each with it's own feature set in various degrees of "done-ness". And that's a pity, but it doesn't affect the state of the original version. You can always just ignore the existence of the rest, and your world will be pretty much the same as without all of those forks. &gt; All in all I think github is quickly becoming a mess. Github is just showing you repositories that would previously have been inaccessible to you, on private servers. &gt; Why is it such a great thing to have this many forks of actionwebservice? What is "great" is having access to the forks, rather than be stuck with only the original and no access to any improvements that other people may have made to solve their own issues with the original. What is "great" is that the setup allows someone else to take on the mantle and merge in the available changes if someone cares enough about it. It'd be even greater if the master was being reliably updated and having useful changes merge back to it, yes. You can't always have what you want. 
&gt;And that's a pity, but it doesn't affect the state of the original version. My point is that the forks exist mostly because the original version is unusable or broken in some way. Take actionwebservice for example. The original version (one that is mentioned in the docs) doesn't work with the latest version of rails. It's author (DHH) won't even touch it and won't give anybody commit rights. So datanoise forked it and changed it just enough to make it work with rails. Other people forked it from them to add features they wanted but those changes didn't make it back to the datanoise branch. It's a big clusterfuck. &gt;Github is just showing you repositories that would previously have been inaccessible to you, on private servers. There is value in having an "official" version of a gem. The current situation is messy and confusing to newbies. Hell it's confusing to everybody. &gt;What is "great" is having access to the forks, rather than be stuck with only the original and no access to any improvements that other people may have made to solve their own issues with the original. I guess I disagree. While it's great that those sources are out there they should not be "polluting" the gem searches. If they provide any value they should at least update their README file so you know why they exist. 
It's called HoboFields, installable as gem or plugin. The best thing is that it generates a regular migration that you can edit at will before applying. And, unless you choose to use the extra "rich type" stuff, you can stop using the plugin at any time. Just remove the "fields do" blocks. Your migrations are still there, your tables are left intact, no harm done, no lockin. Seems much better than what I was using before: hand-rolled migrations and un-DRY annotate_models plugin so that I wouldn't have to refer back to the database all the time just to look at the schema. It's very similar to DataMapper Properties, although it seems that DataMapper doesn't generate migrations. You either let it change the schema directly when you change the properties listed in the models, or create migrations from scratch (http://geek.susanpotter.net/2008/09/datamapper-does-have-migrations.html). I like this intermediate step where HoboFields generates a migration and then you can edit it before applying.
&gt; what good is that? Lots of activity means lots of contributions, more than if it development was restricted by a monolithic development structure. When you are using an open source library of code it's an alternative to writing it yourself. It's somewhat strange to use code in a project without having some familiarity with the code, so it doesn't make any sense to be adverse to taking a few minutes to go through the network and see what people have done. It's not uncommon to find a fork with some customizations that are more suited for your particular use case yet wouldn't make sense to be merged into a main repo. Forks are a good thing.
I think you're blaming GitHub for a poorly maintained project. It's not GitHub's fault that the project is completely dysfunctional. In fact, without GitHub, your only choice would be the 'official' version that doesn't work at all. If you don't want GitHub polluting your gem searches, don't add them as a source. (Or remove them as a gem source, if it's there already.) You can always manually specify that you want to search GitHub. All of your problems can be attributed to the maintainers of the project in question, it seems.
If you do git clone (on a library), their crap will get mixed up in your crap. And later, if you want to use the same library in another project, you're going to wish you used a submodule.
Lets start off with what you are currently making?
This doesn't answer your question, but could help you on your move to the new location. It calculates the minimum wage you need to make in an area. We wrote it, and it's in Rails! http://www.livingwage.geog.psu.edu 
I dunno.... I like migrations. Being able rename columns and tables, significantly update to your data model (ideally) without losing production data is pretty nice.
I fail to see how writing fields do title :string body :text timestamps end In your model is any better than writing them in your migrations. I personally prefer to have boilerplate code nice and tucked away where I don't have to see it every time I want to update my model class.
I can see a plus side being that all your documentation for the model is in one place.
This helps document the code in its entirety and alleviates the need for plugins like annontate_models. Without something like this your model really provides no indication as to its attributes. ' DataMapper does this already. It's definitely a perk I miss when I'm using AR.
This seems like more work than typing script/generate model thingy title:string body:text into the command line (which generates your migration automatically). Plus this makes no mention of how it handles changes to the schema.
$24,662 to live in NY? You must be joking.
He makes software.
Very interesting, I could use this to access PHP APIs for a legacy PHP application that is being ported to Ruby on Rails page by page. Unfortunatley there's no way for a PHP app to access Ruby APIs? Oh well, JSON web services are simple enough.
blasphemy.
WHY?
Compiling PHP in so it can be embedded was very difficult on OS X last time I checked. This could be a very useful project.
I'm curious if you had to make significant changes to your app? Would you still have coded your app in Ruby knowing how it runs now? Just curious before I continue my Ruby learning. Reddit hive mind seems to like Python.
The app in question needed no changes to run on 1.9. I haven't had to make any changes for any apps, except where SQL is concerned. SQL selects in 1.9 return arrays of arrays in cases where only arrays were returned in 1.8. I've programmed extensively in perl, python, and ruby. I love love love ruby. Python is a big improvement over perl, but ruby really is an ideal programming language, in my opinion. Now, mind you, I'm talking about the language, not the interpreters. It's well-known that the current stable ruby interpreters are not the fastest. But I was able to *code* this app fast in ruby and make it do *exactly* what I want, with no frustration! That is quite unusual among programming languages, in my experience ;-) I told my boss that if he really needs to boost the speed, we can reimplement it in C, but that would take a lot of development hours.
nice to hear :)
&gt; My company is relocating to SF. rake db:migrate
Unfortunately, [this](http://www.indeed.com/salary?q1=ruby&amp;l1=san+francisco%2C+ca) only has one data point.
&gt;Without something like this your model really provides no indication as to its attributes. ' That's the case with most ORMs though. Normally you set up an XML file someplace. Personally I prefer migrations because it keeps a history and allows you to modify data if you need it. 
That's a *really* neat web app idea. Unfortunately, it just doesn't seem realistic. I looked up my area, and while the numbers might seem to add up, I could never tell someone that you could live on that amount with a straight face. It's way low.
Ewwww, never, *ever*, use migrations for data. Set up rake tasks for that. Migrations are never a reliable source when a new developer comes halfway through the project's life and needs to setup the database from scratch. The ideal solution (and the one recommended by rails-core) is to use the `db/schema.rb` for this, and rake tasks for data. For example, what happens when you delete a model along the way in a refactor, but you have a migration that accesses the model (not only the schema), say, to insert rows, or to move data from one table to another? **BOOM** That's what happens :P
As I mentioned here http://www.reddit.com/r/ruby/comments/971zh/rails_migrations_done_right_autogenerated_from/c0bnibt, this doesn't exclude migrations. When you change something in your model files, it generates a normal migration, which you can then read and maybe change before running. The standard migration mechanisms stay there, this is just something *on top* of it.
That generates only new stuff, but doesn't handle renaming and excluding columns and tables, for example. Indeed, I'm not sure how it would behave if I created a migration on my own, without annotating the model, and ran it.
This also keeps history. Every time you change a field, a standard migration file is generated.
According to the benchmarks in the shootout ruby 1.9 is about as fast as pyhon, certainly within a few percentage points. Don't mind what the reddit hivemind says. They hate any language that's popular except languages made by microsoft and python. Anybody who takes advice about programming languages from the reddit hivemind is insane. 
Everybody know ruby on windows is much slower than ruby on linux. It doesn't help that he is using an ancient one click installer for the test either. This benchmark needs to be redone.
+1 They're a strangely rabid bunch.
It is quite easy to extend Ruby with C libraries, so reimplementing only parts of any application in C should be trivial.
+1 for insanity.
If you start your own business, you could make $75/hr pretty easily here in SF.
You mean rake hr:migrate
100k is a good estimate for what a competent developer makes.
And it's only going to get better. (Edit: Note that i'm not just saying it's only going to get better for Ruby, but that [dynamic languages in general have a bright future ahead of them](http://www.youtube.com/watch?v=tz-Bb-D6teE).)
Yes, this is a good point. Run some code evaluation to figure out where most of the time is spent, then rewrite that in C. Get most of the speedup of a reimplimentation with a slice of the work. (Or at least, that often works.)
Why? Why not implement Ruby in PHP?
here is why I used it that way. If you are using postgres and modify a table to add a table with a default value the records that already exist in the table don't have that default value in them. That's a shitty for postgres to do BTW. Most of the time you want to create a NOT NULL constraint with a default value. Postgres won't let you do that if you have records in the table. The only way to get around this is by creating the field, updating the data, and then adding the not null constraint. Sucks that postgres makes you do that but it's awesome that rails migrations lets you get around this behavior.
&gt; It doesn't help that he is using an ancient one click installer for the test either. The ancient one click installer is virtually used by everyone on Windows. &gt; This benchmark needs to be redone. I made [a follow up post](http://antoniocangiano.com/2009/08/04/a-faster-ruby-on-windows-is-possible/) that benchmarks Ruby 1.8 (mswin32 and mingw32) and Ruby 1.9 (mwin32 and mingw32).
&gt;The ancient one click installer is virtually used by everyone on Windows. Nonsense. &gt;I made a follow up post that benchmarks Ruby 1.8 (mswin32 and mingw32) and Ruby 1.9 (mwin32 and mingw32). Good. Are you going to compare ruby on linux too? Ruby on windows is less than half the speed of ruby on linux. If you compile your own ruby linux (as opposed to the one included in the packages) you speed up by 100% again. while you are at it also check against jruby. Most people on windows use jruby because it doesn't suffer from the performance problems of ruby on windows. I also noted you are using ruby 1.8.6. 
Then yeah, it sounds like the average programmer is going to be looking at more work to accomplish the same stuff. Nice concept, but the execution is kinda lacking.
RubyInline http://www.zenspider.com/ZSS/Products/Download.html
&gt; They hate any language that's popular except languages made by microsoft and python. 'Cept Clojure and, perhaps, Scala. Might wanna throw in Factor, too. Ocaml and D get a fair bit of love. Oh, can't forget Scheme! Common Lisp has adherents. And for some reason I get upvoted whenever I mention [Inform 7](http://inform7.com/). Other than that, though, yeah.
I'll gie this a shot, i've been wanting to learn how to make a UI
just to add to this I've also significant speed improvements ranging from nothing (using a linear algebra library written in C -- so no suprise there) to about a factor of 8 for some html processing code.
&gt;'Cept Clojure and, perhaps, Scala. Might wanna throw in Factor, too. Ocaml and D get a fair bit of love. None of them are popular. Did you read my post. They hate any language that's popular except for python and microsoft products. Those popular languages they love. 
There is a simple way around that - if you use any models in your migration, simply declare them in your migration.
Seconded. Ruby Inline is awesome. I did a good chunk of my MSc work in Ruby. Some of it I had to rewrite more or less wholesale in C++ to get the performance I needed (some very memory and CPU intensive image manipulation and bitset clustering that took days of runtime even in the rewritten version, so no real surprise - I expected to have to rewrite from the start, but still wanted to prototype in a nicer language). But for a lot of the other stuff I got away with replacing small chunks (like a function calculating Levenshtein distance) using Ruby Inline. It saved a *lot* of annoying C/C++ coding that I instead used on researching more algorithms to test. 
Ruport isn't dead, it's stable. But my maintenance of it has been very poor lately. That having been said, there are no major patches to be merged that anyone has asked me to review, and no severe bug reports to address. The only somewhat major thing is that Ruport unnecessarily locks to FasterCSV 1.2.3, something I should get a fix out for, but just haven't had the time to do. For what it's worth, I think Ruport is showing signs of age. If I did it over again, there are many things I'd do differently. But it's still useful for many, so I definitely wouldn't call it dead. Lacking of new innovation? Maybe. But maybe it's someone else's turn to hold the torch. If someone starts doing major work on Ruport and wants me to review it, I will. I'd even name a new maintainer if there was an obvious candidate. There isn't one right now. 
Common lisp is sooooooooo 2 years ago. 
Sure. Just hope you don't mind the 2 hour commute on the LIRR in order to not hand over 60% of your salary in rent.
Always useful to see other people's deployments. A++++ would click again.
i'm not sure why anyone would downmod either of these remarks. i've restored you both to 1 point with my magic clicking thing. 
ha!
Thanks. I'm actually busy writing custom rake and cap tasks today, so it's very apropos. I tried to get a 'rake hr:promote' task added in to promote myself, but they caught it in code review. :(
After setting up users and disabling the root account, I usually set up public key authentication and disable password logins. It's convenient AND secure (OpenSSL bugs aside).
I used throw catch one time. It seemed to be a relatively elegant way to solve my problem. I only used it once because most of the time raising errors is sufficient but sometimes it's a good idea.
He should have used something like puppet so he can repeat this process on any server. 
Ok, I thought you used migrations for seed data from your original comment. Sorry for the misunderstanding :)
Another use case is to use migrations to switch from using a legacy md5-style id column to a normal auto incrementing primary key, updating all involved tables at the same time. Something like this in MySQL: ALTER TABLE users ADD id INT UNSIGNED NOT NULL auto_increment PRIMARY KEY; ALTER TABLE permissions RENAME user_id TO legacy_user_id; ALTER TABLE permissions ADD user_id INT UNSIGNED NOT NULL; UPDATE permissions p INNER JOIN users u ON(p.legacy_user_id=u.user_id) SET p.user_id=u.id; ALTER TABLE permissions DROP legacy_user_id; ALTER TABLE users DROP user_id; At work I've written a whole bunch of manual migrations recently and I've used raise ActiveRecord::IrreversibleMigration in many of them so I can see the benefit of doing auto-migrations but there are pros &amp; cons to both alternatives. I guess since hobo generates migrations it's possible to do both at the same time. Also I see in another comment that Datamapper (which uses auto-migrations by default) also has manual migrations so I guess you're free to use the best of both worlds.
If your interested in baseball statistics and Ruby programming, you'll love this post.
Good post. It surely doesn't take 100 minutes to read. Maybe if you interactively program while reading.
Table layout: I don't actually know what I'm doing. 
Yeah, it would definitely take you less than 100 minutes just reading on your own -- probably more like 20-30. This tutorial comes from my Ruby Jumpstart class last weekend where we, as a small group, were working through all the examples together. It's not meant to make you a Ruby expert, but just understand enough that you can dive into some code.
I honestly can't believe someone wrote a blog post in 2009 using tables for layout... I understand the guy's a Rails developer not a frontend developer (I am too) but seriously, if you're going to post an article about adding a better design to your site you need to move out of the 90s!
So according to the results of this and the previous article Ruby on Linux is 70% faster than Ruby on mingw32 which in turn is 70% faster than Microsoft's compilers. Are Microsoft's compilers just that shitty (something I wouldn't put beyond them considering how much trouble they cause in our cross-platform C++ projects at work) or is there something else going on?
Two posts ago Luis Lavena said: ["You’re comparing IronRuby performance with a 12 years old compiler (VC6) which is the one used by official One-Click Installer."](http://antoniocangiano.com/2009/08/03/performance-of-ironruby-ruby-on-windows/) It's not so much that Microsoft's compilers are that bad, just that compiler technology rapidly improves.
MSVC is actually widely considered best in class for C/C++ performance. (GCC has gotten a lot better since v4.1 though!) The problem here is that the Windows version was compiled against MVSC 6, released in *1998*. So there's your problem :)
So why is anyone using compilers that old at all? 
I like rufus-scheduler better. The cron syntax rules.
Seems like a pointless comparison. First of all, the real performance improvements have been implemented after version 1.8. Furthermore, Linux usually runs 64b versions, while there are no well supported 64b windows Ruby versions.
It's called closed source. Improvements are driven by product cycles.
i used to do this manually ( before paperclip existed ) and the resulting image files were too big to be practical what does this produce?
it decreases the image size a bit - updated the article with a example ( http://imgur.com/QRORX.png ) from the project.
Why does he keep testing 1.8.6? Why not 1.8.7?
That's it for me. No more about.com. Too much advertising around too few content. Seriously, that's just not ok. Even if I used an ad-blocker I would have to click eight times on next to read an 16 paragraph article.
I had hoped to pass this on to an intern where I work but it requires RubyMine :(
Well, it's written to use RubyMine, but doesn't "require" it. RubyMine is a nice platform for beginners and they have a 30-day free trial: http://www.jetbrains.com/ruby/download/ If you don't want to use RubyMine, the only thing that's substantially different is running the program. Open a Terminal, CD to the directory where your .rb file is located, and enter "ruby jstwitter.rb" and it should run.
Yea rufus kicks ass.
If you want to read this on an iPhone/iPod, try out Stanza -- it works great and the mag formatting looks very good.
Tenderlove has some of the best gems on github. You should check out his enterprise library.
The sub is the man who wrote said gem. :) Also: DEAR GOD WHY. I mean really.
Ya, I probably shouldn't post my own stuff. But I thought everyone would get a laugh. :-) I wrote it to make you smile and cringe at the same time. ;-)
&gt; Ya, I probably shouldn't post my own stuff. Why would you stop doing something if it works?
rufus is awesome. I used it to build a mini scheduler "framework", http://www.github.com/jcapote/theman
Looks like shit in Firefox and Chrome. Explicitly setting fonts for web pages is usually a bad idea. 
Because the installer available at http://rubyinstaller.org/downloads is for 1.8.6. That's why.
So is bcrypt supposed to be more secure than SHA*? Otherwise why not just throw a sleep(1) between login attempts? Or lock out an account after 5 bad attempts?
If an attacker gets hold of your database, he can use a modest GPU to crack SHA1 at about 70 million hashes per second. I'm not aware of any GPU bcrypt crackers; he might manage a few hundred per second with the same resources, and even if he has an FPGA to play with he's not going to do much better than that. Sure, you can make the login delays fake, but why deliberately pick the solution that's a million times weaker for a similar amount of implementation effort? [scrypt](http://www.tarsnap.com/scrypt/) is an even more secure alternative, since it's not just processing-hard, but memory-hard, thus eating up even more gates on an FPGA and limiting possible concurrency on a GPU (if you can even implement it there).
That makes more sense now.
and the cool thing is even if such a GPU based attack is found you can change some values and maker bcrypt require N times more work, as it is adaptive!
&gt; The Ruby community, according to some data I am making up, has the strongest test-driven development attitude. If we're just making things up...
&gt; No static analysis Ding ding ding! We have a winner!
Python is the same in that regard, but doesn't seem to have the same.. obsessive testing habits.. Not to say Python projects don't do testing, it just doesn't seem as prevalent..
&gt; The Ruby community, according to some data I am making up, has the strongest test-driven development attitude. Uh. While I love Ruby, and applaud the community's dedication to testing.. I have a bit of a problem with that statement. The Perl community has had a "culture of testing" that stretches back way before Ruby or TDD were fashionable. The majority of code on CPAN comes with a decent test suite, and every upload is automatically smoke-tested for you on a variety of platforms and Perl versions (you even get an email to chastise you if you fail to include tests ;)). And I'm sure Perl isn't the only community with a similar culture. So, Ruby is great, testing is great, but I have trouble believing the Ruby community are any better at it than others..
&gt; No static analysis 20% this &gt; Culture 80% this 
Did you miss the part where he says "according to some data I am making up"? Why does proggit lose all sense of humor when they see the word "ruby"?
Fair point. It's something that bugs me, and I have no problem admitting that I tend to lose my sense of humour on the subject ;) The Perl community have been through this process before, and learnt a lot, so I find the "we invented testing!"* attitude risks repeating the mistakes of those that have gone before. [This guy](http://video.google.com/videoplay?docid=2820655318133882347&amp;ei=o_5mSqKHHpz4rALY-Oj9Cw) has the right idea. \* I am aware that's a bit of an exaggeration :)
Rubyist are also the best lovers. True story.
Meh, Windows-centric. For mac, I've customized my keybindings to mimic the RubyAMP TextMate bundle shortcuts. I've then used the same bindings on my Windows machine at work for consistency. 
I'm of the opinion the ruby community has one of the strongest testing cultures of all programming languages. The wealth of material available as books, screencasts, conference videos, and articles is considerable given that in comparison to other languages its only reached widespread adoption relatively recently. I believe it's a result of Ruby's pattern of adoption - the migration of Java, Smalltalk, and Perl developers to the language bringing the strong heritages of good practice including testing with them. 
I don't like customizing the shortcuts you use. If you do a lot of pairing or simply spend a lot of time working on different machines, you have to remap every time you switch machines, which is not normally possible and also inconvenient to those you work with. Remapping shortcuts to the way you like only works you always use the same machine. I like to learn the default shortcuts of every IDE, program that way you're always at home and productive no matter what machine you're on.
Rhodes is great and all but it costs an arm and a leg if you are not doing open source development.
Unless of course all the customizations, including shortcuts, color schemes and even additional functionality, are easily stored in a single, simple text file that can be loaded at any time and only hangs around for the remainder of the session unless you explicitly have it be loaded at startup...
There's nothing stopping you from selling something that you've open sourced. Sounds strange but I've seen it done. You provide the source free for download, for the other 99% of people they have the option of buying it as normal. As far as I can tell from [this chart](http://rhomobile.com/products/licensing) the Rhodes licensing allows this. If I were to do this I'd still donate some money to Rhomobile because they're doing amazing work.
Yes, and if that simple text file is source controlled, otherwise you have to remember to carry it around with you all the time, and if for some reason you forget it's a little annoying. 
All valid points. If/when I switch editors again, I'll probably keep the default shortcuts. Netbeans is doing a pretty good job though, so it probably won't happen soon unless TextMate 2 is stupendous.
Also, the inclusion of a testing library in the standard library. I probably wouldn't do much testing if that were not the case.
Awesome, I was afraid I had to use Objective C for my app, but it seems you can use ruby on the iPhone.
shooes link is broke?
It's too bad it won't be Ruby 1.9.1 compatible. 
why must be having server issues. It looks like all his sites are timing out.
Why not? Shoes is reasonably straightforward, and showing a color picker probably has an example in the docs.
@msghmr - It is not about setting fonts in browsers like firefox and chrom, this post covers some discussion about enabling subdomain when you host your web application, and i shared some code and solution to make the development on local environment easier. 
I don't know. I don't have that much faith in humanity.
I understand that sentiment, and it's correct. Let's channel it, though: instead of "humanity sucks, so we must all start out sucking", perhaps "humanity sucks, so we must be doing things wrong that crush human potential." If it's the second option, assuming you have less soul-crushing tools like Ruby and Shoes (or plt scheme, in some rarified cases) pretty much any kid can pick up programming.
The change is actually very trivial. The only new piece of information required is the existance of the `ask_color` method, which is the 3rd hit when searching for color in the Shoes manual. The docs also had an example usage. In all, only 3 lines needed to be added, and one changed in order to add a color picker: Shoes.app :title =&gt; "My awesome application" do def periwinkle rgb(180,170,205) end background periwinkle # these 3 lines are new, and based off # the code in step 7: # button "Change the text" do # @headline.text = "I'm changed!" # end button "Choose Color" do @color = ask_color("Pick a color for the line") end animate do previous_left = @left previous_top = @top @button, @left, @top = self.mouse unless @button == 0 # added , :stroke =&gt; @color # same as for the para section below # (using @color instead of saddlebrown though) line previous_left, previous_top, @left, @top, :stroke =&gt; @color end end @headline = para "Draw!", :align =&gt; "center", :size =&gt; "xx-large", :stroke =&gt; saddlebrown end The `ask_color` docs had the example: backcolor = ask_color("Pick a background") Shoes.app do background backcolor end The docs even have a "Run this" button, which runs the example code when clicked. Shoes really is an amazing learning to program environment. 
&gt; GetSET is pretty awesome, though their website is horrible. Pot, meet kettle. 
I helped teach a Shoes class this year, and the students were mostly non-CS college kids, but there were a couple younger kids as well. Anyway, Shoes has a music player thinger, and by the end of the class, one of the 13 year olds had implemented the Mario theme -- all without any prior exposure to Shoes (but probably some programming experience, this kid was pretty nerdy). Anyway, Shoes is cool like that. Also, the link is usually broken. Curse Why. 
Programming in ruby enlarges your penis. I should know, I've been trying to get customer satisfaction to explain why it hasn't happened to me for the past 4 years.
Just pointing it out! It was annoying enough for me to just not read the article. 
Nice introduction, but why did you decide to leave out block arguments and hashmaps from the article? They are both very often used in Ruby, so you'll have to relate to them early on.
They are, but they are also a little more advanced, and I didn't want to overload with too much info, hashmaps and blocks would probably make a nice article on their own.
What an incredibly awkward website. Between the glitchy nav menu roll down that I accidentally triggered and obscured the top of the article, and the over use of `letter-spacing` and `word-spacing` styles.. yecch
Great stuff, I had no idea that could be done. Thanks!
about.com yuck. -1
I don't enjoy that site so much either. But its about the article not the site.
cool prizes this year http://blog.railsrumble.com/prizes
I am. My idea is much too ambitious and I'm planning on treading into some unknown territory, so it should be wonderfully disastrous. But I'm doing this for fun and the challenge of it anyway.
250 registered teams. Not gonna be easy to win those.
I had a team registered but I had to give it up because me and my teammate won tickets to Blizzcon LOL.
... Hello bulibuta. I've stopped submitting my articles here because of this reaction. People see the ads and don't bother looking at the content.
It was only a matter of time before the mothership came to reclaim him.
Actually we only ended up with 215 or so. We had 225 spots but a few pulled out too late for us to give them away. For those of you competing, make sure you check out the irc chan - #railsrumble on freenode
Why did he go? I hope he's alright.
Wonder when someone is going to track down the real owner of http://whoiswhytheluckystiff.wordpress.com
I think there is a very minimal subset of "not alright" that involves deleting your online accounts..
It would be poetic justice.
Some of his recent tweets were saying things like "programming is a thankless task" and that if you want your programming work to have any longevity you should write a game; because people rewrite architectures to keep games alive.
I am.
He's probably trying to prove a point based on that. Let's hope he hasn't gone apeshit or something. I don't get terribly excited about ruby, but I do &lt;3 _why. That sounds unnecessarily negative about ruby, but I'm just implying that he has a certain power over fun programming.
Guido is behind this, I'm sure of it.
Apparently someone outed his identity :(
:-(
:(
I was thinking about it but maybe next year. 
that was the hardest part of the project by far
I wonder, who registered http://whoiswhytheluckystiff.wordpress.com/
Time to register http://whoiswhoiswhytheluckystiff.wordpress.com/
who cares?
Oh yeah, completely psyched! I have a title to defend :)
That's brilliant. Games even live on without the source.
Well said. I also think this rampant speculation about what happened to _why is probably something he wouldn't appreciate. Give the man some peace; "If you love something set it free" and all that.
And honestly I think he's enjoying it. I'm a little sad that "try ruby" and a lot of his other great content is down now. But you know what they say "die young" and _why did. :)
It reminds me of how Ze Frank's The Show went out while on top... except that you can still watch all the episodes and Ze made his plan public from the start. But it still reminds me of it. Fond memories of a great thing.
One minute, Robert Paulson was the warm center that the life of the world crowded around, and the next moment, Robert Paulson was an object.
Who cares? We lov him any way...
Apparently it destroys the server. From Cache: ------------- **@object.destroy doesn’t work like you think it does** Whats wrong with this: if @object.destroy flash[:notice] = "Object successfully deleted" redirect_to objects_path else flash[:notice] = "Could not delete object" redirect_to object_path(@object) end Well every rails developer I’ve asked so far says “nothing, thats the way I’ve always done it”. Not one of them spotted the fact that the ActiveRecord::Base.destroy method always returns a frozen object therefore the if statement always evaluates to true and the user sees the “Object successfully deleted” message every time. For the expected behaviour need to check in the database that the object has truely been deleted. @object.destroy if Object.exists?(@object) flash[:notice] = "Object successfully deleted" redirect_to objects_path else flash[:notice] = "Could not delete object" redirect_to object_path(@object) end This most likely explains the addition of the new destroyed? method in edge rails. For more information abouts whats new in edge read [What’s New in Edge Rails: The BugMash Edition](http://weblog.rubyonrails.org/2009/8/13/what-s-new-in-edge-rails-the-bugmash-edition) ---------- 
riddley is so right. about.com sucks ass so hard. making a user page through seven pages for such a wee draught of information is retarded. the actual payload per page is about 5% of the total page mass. this is whats wrong with sucky sites, and about.com sucks it harder than most. aside from that, it's an ok article on haml, but you be better off just looking at [hampton's abstract](http://haml-lang.com/tutorial.html) which is ALL ON ONE PAGE. what a concept.
I would love a "Try R" if you could make it happen. As for the Ruby lessons, the one thing that sticks in my mind from the original is the string["substring"] = "replacement" trick. 
I don't remember the exact lessons, but I think it went in the order of simple math -&gt; a little harder math -&gt; strings -&gt; built-in methods -&gt; writing your own methods. It's been a long while since I used it though, so I could be skipping a few.
I was just on tryruby.hobix.com a day before it went down. I can only tell you bits and pieces I remember in the early chapters. *basic arithmetic (e.g., 2+2 =&gt; 4) *string concatenation *using reverse, length on strings (e.g., "Jimmy".reverse) *basic arrays *a bit of HTML (e.g., using h1)
I'd be all over that like oprah on a bundt cake.
There also was some book rating-thingy with hashes.
first things first, and then I'll be right on it. In college I majored in computer science with an emphasis on scientific computing. This is just fun and games to me. :-) Good on everyone who can remember parts and pieces. Right now this thing depends on a patched c ruby interpretor. I am going to try to switch this over to jruby. When I get that done, anything that can be ran within the jvm should be fair game. Can R be ran in the jvm or is this the sound of a new project. I don't know a whole lot about R, but I do know that I want to and this would be the perfect excuse to learn. EDIT: http://rubyforge.org/projects/rsruby/ it looks like someone wrote a R bridge for ruby. So yes, tentatively, you can count on having lessons plans where you are coding some ruby and then it goes into doing R from with inside ruby! :-) happy developer is happy :-D
by the way anyone interested, my github account is sophrinix. When I get this thing stable and fairly secure, a running version will be at tryruby.sophrinix.com look for it in a few days.
While I cannot say I remember the lessons I'd be more than happy to help work on some new ones. The loss of tryruby was a great one for newcomers, so I am happy to see someone bringing it back.
I've managed to recover all the text from all the tryruby lessons! The way the tryruby interpreter worked was it loaded the tutorial text from a html page. Luckily, the wayback machine cached this page [here](http://web.archive.org/web/20071008160926/tryruby.hobix.com/tutorials/intro.html). The original try ruby page is also [accessible from wayback](http://web.archive.org/web/20080123140927/http://tryruby.hobix.com/), and it partly works. You could look through the javascript files using view source (the wayback machine caches javascript files). Also, thank you for working on this, it was a great introduction to ruby while it existed.
Thanks! it shall rise again. Yeah that's how I got most of the javascript back. It doesn't help me when he converted it to jquery. However, once i get it working, I will upgrade it to jquery. What is sad is that we don't have 100% code coverage, but there is enough that I am able to fill in the gaps. His sandbox is rather odd. it requires that I build ruby-1.8.5 or 6 from source with his special patch on error.c He left very little code on how to interface sandbox to the web. I have my own ideas on how to pull that off, so its all good.
With a little extra sugar this could really help with efforts to build a Ruby-based shell.
Rio has been around for years... has it been updated, or are you just drawing more attention to it?
I found it recently and it had not been posted to reddit before.
http://www.reddit.com/r/ruby/comments/9dge7/rush_rush_is_a_replacement_for_the_unix_shell/
this is one of the sickest things i have come across in 09. much love for rush. wow.
I feel that the syntax is a bit too verbose (processes.filter(**:cmdline =&gt; /mongrel_rails/**) really?), but it's an excellent start.
http://github.com/hayeah/rubish/tree/master is another good ruby shell
Adding good tab completion could be done easily with bond, http://github.com/cldwalker/bond/tree/master
(I'm thinking: `ps["mongrel_rails"].kill`, for instance. It even keeps your expectations in line with your regular bash/coreutils install. Tho part of me still wants to be sending signals to processes directly. `kill ps["mongrel_rails"]`, maybe?)
I agree. We need to figure out a better way to pass named arguments into functions. I dislike passing in hashes but positional arguments are even worse. I wonder if some guru could figure out how to make a getopt type of thing for function params so you can do process.filter -c /mongrel_rails process.filter --command /mongrel/rails or something like that. it might be a pain to write the functions though... 
What can it do that irb or rubish can't already?
Thor, http://github.com/wycats/thor , has a sweet option parser that could this. I wrote about how to customize it awhile ago, http://tagaholic.me/2009/02/23/quicker-options-for-irb-methods.html
Yea. That's exactly it. It might be interesting to use that in a more general matter within your ordinary functions.
There is just more syntax here than zsh, or even bash has. 
Hm. Assuming Thor uses ARGV, there's no reason you can't do some foul things to method_missing and make it happen.
&gt;Once in the shell, there is no concept of current working directory. Pass.
But if you already know Ruby syntax, there's less *new* syntax to learn.
&gt;We need to figure out a better way to pass named arguments into functions. I hate to say this but I liked the way VB handled it where you could either pass a key value pair to a method call or use ordinal positions for method calls. Why can't ruby allow key-value pairs in method calls like: def myFunction (param1, parma2, param3, param4) and you call that with myFunction(param1="foo", param3="bar") Or alternatively: myFunction("foo",nil,"bar") (and yes I know the brackets aren't needed) 
You can't ever replace my Rush. http://www.youtube.com/watch?v=z31Uk9BQJus
The Pickaxe is not on this list. And of course he includes his own book.
I explained in the comments the reasons why I didn't include the Pickaxe. It used to be there, but it's now been replaced by alternatives. And my book is included because it's good and useful for Windows users. I wouldn't include it if it wasn't for that point. There is nothing underhanded about my doing so. I made it very clear that it's my book, so that if you feel that its inclusion is biased, you can buy something else.
I do own the 1.9 edition of the Pickaxe. It's basically the 1.8 edition with the 1.9 stuff added in and notated with a 1.9 marker. It clearly explains what no longer works with Ruby 1.9. It's a wonderful book. As for the inclusion of your own book, I did see that you marked it as your own. However, I personally don't like when authors of lists like that include their own stuff. I prefer when someone else adds it. If it was in the comments first, and then you added it to the list, I would be more forgiving. Otherwise, the list is great.
interesting
That's the way most languages do it. 
Except Ruby ^_^ 
Good article.
&gt; Unlike Java annotations, which must be run at compile-time, Ruby class bodies can take runtime information into consideration, such as dynamically supplied options or the results of evaluating other code. That's just flat-out wrong. Java's annotations can be processed either at runtime or compile-time. Otherwise good article - I do both Java and JRuby development on a daily basis for work, and I agree with the rest of it.
Lack of self-criticism.
I have seen a lot of languages try this (outside of sh) and they have all pretty much failed due to constraints of the syntax. This could be a nice replacement for a shell environment. /bin/sh was a pain in the ass years ago, and there has been enough added in /bin/bash to make it a joy to use. Rush (or something like it) would just have to evolve a bit. If it could work in PATH, external processes, and pipes, it would be a lot better to work with. Bourne scripting is nice for very small tasks, but I always find myself working around its limitations.
Ummm... it's a list of his _favorite_ things about Ruby. If I asked you to write me a list of your favourite foods, would you tell me about all the food you hate eating too?
Just curious - am I getting downmodded because I said something nice about Java?
Sadly, I wasn't as clear as I should have been. Java annotations take a compile-time structure and make it available at runtime. This is not equivalent to having those annotations be runtime expressions with a proper self et al, but I could have been clearer. fwiw, I modded you up :)
Ahh - I see what you're getting at! Thanks for clarifying!
Dynamic typing, "duck typing" etc. come at a price. Even when listing your favourite features, some people would consider putting them into context and comparing them with competing solutions. This is even more true if the author isn't just some random hacker kid who just learned to know ruby a week ago.
Use asynchronous tasks when indexing, use delta often, merge sometimes or when required. Because indexing is fast, deltas don't have that much of a cost I'd say.
I know ruby syntax, but I'm even more comfortable with zsh/bash/sh syntax from the last 15 years
The fact of the matter is that he's discussing things he _likes_. Why is an opinion piece about things he _likes_ not "valid" because it doesn't include a whole bunch of things he _doesn't like_, too? Seems to me you've missed the point of the article. It's not meant to be a balanced comparison of Ruby to the multitude of other languages out there. It's just a list of things that a guy (in this case, Yehuda Katz) likes about Ruby. For all we know, he could later write out a whole list of things he doesn't like about Ruby. I would not expect that article to be "balanced" with things that he likes about Ruby. Also, "self-criticism" would mean the author criticizing himself, not criticizing Ruby. "Yehuda Katz" != "Ruby". If you disagree with something he has said; that is, if you really feel that one of his favourite features is actually an incredibly bad thing, feel free to draw that particular point out for debate. But just saying "lacking in self-criticism" contributes absolutely _nothing_.
Okay, let's cut it short: I find that article uninspiring and pointless. Reading it IMHO is a waste of time. And I personally cannot think of a reason why a seasoned, well-known, talented ruby developer would care to write it.
Another great Wayne Sequin work.
Coding in Ruby is a highly pleasurable experience for me and I think that Yehuda has managed to put into words some of the things about the language that make me feel that way. Yes, Ruby's extensive meta-programming features and fast-and-loose type system come with certain trade-offs. But Rubyists still love using the language, and Yehuda has stated some of the reasons for that. In that sense, I think the article has value.
Ow! I guess I consider my blog to be a place where I can express my thoughts about various topics. In this case, I was interested in getting into words some of the things that make Ruby a joy to use every day. Sorry if you found it uninspiring (that's a personal feeling), but I'd think the fact that many people found it interesting gives it some point, no?
Wow, only two downvotes! I guess the anti-Haskell trolls on /r/programming and /r/haskell didn't think to look in /r/ruby :)
The link for shoes? http://github.com/shoes/shoes is the new repo.
http://github.com/shoes/shoes
Oooh! I like this. My only complaint about Ruby is that it adopted Perl's "there's too many ways to do it" (TMTOWTDI) philosophy. Anything to make Ruby more predictable is good, in my book.
While I agree with Obfuscated's comment that ruby went the direction of perl's design philosophy, it did it in a purely OO (and strongly typed) manner, meaning that while there may be multiple ways to do something, it is still scoped to a particular class (eg, String#scan vs String#split) and as a result, it isn't nearly as overwhelming as pouring over 500 functions looking for the right one. I don't think that options are a bad thing, unless they're all thrown into one pile in the middle of the room. My initial thoughts looking at Pedant is "if you think you need this, you're using the wrong language". It really really wants the assurances of a statically typed system in a language that is _so elegant_ precisely because it is dynamically typed.
Funny but facepalm.
Uh the difference between Perl and Ruby goes much beyond their way (function vs class) of doing timtoady. The problem with Perl is that Larry Wall as someone who had a linguist background (instead of a CS one) thought it was nice to design a language that did lots of things depending on the context. The result is that it is nearly impossible to create a new Perl 5 interpreter. People have tried and failed the hard way. Ruby is predictable enough that people could create JRuby and IronRuby and make them work with real world apps. Perl is not, you probably would spend all of your life if you tried to describe the mysterious and shady ways of the Perl 5 interpreter. 
&gt; Ruby is predictable enough that people could create JRuby and IronRuby and make them work with real world apps. Parsing Ruby is still painful enough to make a grown man want to cry... The grammar is not exactly well defined, and is full of special cases. Quite possible that Perl 5 is worse, but if Ruby is better in that respect I get the distinct feeling it's more by accident than by design. I still love Ruby - I just wish the grammar had been designed by someone who cared about keeping it clean; many of the murky corners couldn't been cleaned up with nearly no impact to developers (how many times do you see people use whitespace quoted strings like this for example: "% 5 " results in the string "5" unless preceded by an expression in which case it's the format/modulo operator. Why, oh why? Even linefeed can be use instead of a quote: % puts :test The above returns the string "puts :test", and side effect free. Want to bet how many Ruby programmers would guess that without running it or resort to a manual? 
Downvoted for the shittiest color scheme ever!
This is a sort of DBC, right? Some languages have this type of feature builtin, e.g. Fortress. Kinda cool. Maybe.
You say "The problem with Perl" as if there is one, or as if there is ONE huge one that shadows the rest. Dude. There are so many problems with perl there is no one place to start listing them. Ruby is **just barely** predictable enough. There is a lot of data being passed back and forth between the parser and the lexer. The lexing nightmares that rubygeek mentions are just the start of it. Check out my blog post: http://blog.zenspider.com/2008/10/im-in-lexer-hell.html where I say: "There are 28 cases of my lexer checking lexstate and 63 cases where the lexer is setting lexstate. That by itself is absolutely fine. It is the additional 17 cases where the parser TELLS the lexer what the lexer state is that absolutely terrifies me." and don't even get me started on heredocs...
Useful reference -- I've bookmarked it -- but I agree that small, dark grey text on a black background is a poor design decision.
Well perl has a strict mode and a warn mode as well as a nice taint system. That's something ruby can add those. It's a shame they didn't.
this is interesting, i never thought about rake in this way
ruby has taint ruby has warn ruby doesn't need a strict mode because it isn't 1/10th as sloppy about scoping as perl.
yes, the classic example being eiffel.
rubies taint isn't the same as perl's. Read the documentation. They do completely different things. As for strict I disagree. Ruby needs it. At a minimum it would eliminate simple typing mistakes.
Thanks; will need this when my Snow Leopard dvd comes.
Site looks down, you might want to check http://weblog.rubyonrails.org/2009/8/30/upgrading-to-snow-leopard in the meantime.
He went away. Now leave him alone. 
Sure does. I liked it!
Thanks, this is most useful. 
he now calls himself _where? 
This is a stupid idiom IMHO. &gt; Why? Firstly, you avoid the common bug of forgetting to return the object you are creating How about some discipline in your programming instead? Tests maybe? &gt; Second, in methods like this as you read from top to bottom you are declaring what the method returns right up front: Not necessarily. You could declare "returning Person.new(params.merge(:registered =&gt; true))" but there's no guarantee that the actual returned object hasn't been significantly modified (or replaced entirely) by code inside the block. This whole 'returning' thing is useless sugar and clouds the code IMO. 
This seems like a pretty good idea, tests are not run that frequently but when you do run them you want them to run fast. Perfect for building a hosted service. They run on Amazon EC2 so they should have no problems adapting &amp; scaling to the current load.
Really helpful, thanks!
One of our goals at Devver is to make it convenient to run your tests more frequently. 
what do you mean "piecemeal fashion"? it's all there in the ruby docs....
true, but i think he's pointing out that when you consider *all* iteration-like behaviour, it's not all in one place. "one place" being approximately one page, as opposed to "planet earth" being "one place".
&gt;When I use your library, deploy your app, or run your tests I may not want to use rubygems. When you require 'rubygems' Then don't use my library! Seriously, it's a trivial library that doesn't use a lot of resources. If you don't like it, go sit in the corner and have a temper tantrum. The rest of us will require rubygems to be able to use libraries delivered as rubygems. It's a minor, trivial issue you're ranting about. 
Seems silly. No I am not going to use an environment variable or pass a command line parameter to ruby. I write a script I expect it to run on any machine with ruby and the gems I need on them. Having said that I frequently unpack the gems and explicitly require them from my "gems" subdirectory. That way if the machine has ruby the script runs.
&gt; it's a trivial library that doesn't use a lot of resources actually the difference in memory usage in a simple "puts 'test'" script with and without rubygems is: +4341 kb
I think a lot of people are saying the point made in this article is silly, yes you may still want to use other libraries delivered as gems, and THAT'S OKAY. The point of this article is that LIBRARIES THEMSELVES should *NOT* require rubygems anywhere as someone may wish to bundle the library with their application and not want the overhead or potential compatibility issues that gems may introduce tl;dr Applications using rubygems is fine and dandy, libraries should never require "rubygems" themselves and leave this choice up to the application
_where the lucky stiff?
I _miss him.
Yeah, because 4MB on a machine with 4GB of RAM... Well it's like throwing a pebble into the ocean... Unless you're doing embedded development this is a non issue. 
It's not sandboxed very well... you get privileges of www-data and write access to the webroot. I hope it lasts longer than tonight! Edit: removed link to junk
He tweeted about it. It's been fixed, and everyone who did that got omgwtfbanned.
"&gt;&gt; 1 + 1 We will be back in a few hours. Someone discovered a security hole. They reported it, but not until someone else thought it would be cute to drop a rootkit in."
I don't think you get it. Reread the article and/or read snuxoll's comment.
Egh. Lame. Well, not unexpected.
&gt; I cannot unrequire rubygems, but you can not require it in the first place. grep/sed much? Presumably nobody bothers to obfuscate the reqs.
Direct link: http://tryruby.sophrinix.com/ edit: seems to be down now edit2: it's back
yeah there have been a lot of lessons learned. It will be back up today stronger and better.
Hey guys. Nothing too huge or revolutionary going on here; but we've fixed up Hackety to work with the latest shoes. There's still a lot of work to be done, and it's not easy to use right this second, but I figured someone might be interested.
Who cares if it's not huge or revolutionary? It's a great project that I'm glad to see in capable hands. Good luck and keep up the good work!
You can follow the status of this on my twitter account: http://twitter.com/Sophrinix
Thanks. :)
Hackety Hack is one of _why's projects. It's intended to be a nice, easy way to learn programming. He wrote two essays, [The Little Coder's Predicament](http://wiki.github.com/steveklabnik/hacketyhack/the-little-coders-predicament) and then [The Hackety Manifesto](http://wiki.github.com/steveklabnik/hacketyhack/the-hackety-manifesto) that do a good job of explaining his motivations. Oh yeah, and see his recent [Art and Code presentation on Hackety Hack](http://www.vimeo.com/5047563). Now that he's gone, I and others are moving the project forward.
Seems like you just proved Ryan's point with your final sentence :) Freezing gems is problematic when the frozen gems try to force rubygems, or try to load incompatible versions of libs that you've frozen. I've personally run into a lot of issues with gem freezing. One prime example is trying to freeze the correct version of DataMapper and its dependent gems when Heroku has a slightly older version packaged up.
Its awesome to see you guys are working on this! I had plans of using the project with my kids when they were a little older and was saddened to see it disappear. Thank you!
Thanks. I hope it'll be useful for you... if you ever have any suggestions, I'd love to hear them.
Related Posts: http://steveklabnik.github.com/2009/09/01/welcome-to-hackety.html gives a 404-lookin error. Just FYI.
Thank you. The real link is [http://steveklabnik.github.com/hacketyhack/2009/09/01/welcome-to-hackety.html](http://steveklabnik.github.com/hacketyhack/2009/09/01/welcome-to-hackety.html). The problem is in the way that jekyll makes it's urls; since this is a sub-project, it's in it's own little folder. I sent mojombo a message about it, but haven't yet heard back. I think it's probably some kind of configuration screw up on my part; this is the first time I've had a gh-page for a sub-project. Know anything about jekyll? Lol.
of _course you do
That's no moon.
&gt;Seems like you just proved Ryan's point with your final sentence :) F Not really. He is saying if you are using the gems that are installed on the machine you should use a command line parameter or an environment variable in order to require them. I am saying that most of the scripts I write have to run on a variety of machines and I can't be guaranteed the gem I need is installed on them. Two very different scenarios. &gt;Freezing gems is problematic when the frozen gems try to force rubygems, or try to load incompatible versions of libs that you've frozen. I suppose that could be a problem but so far I haven't run into it. 
Keep up the good work. That's an awesome project and I am happy to see that it's being kept alive.
Too bad ruby doesn't have good tools to analyze bloat AFAIK. Ok jruby does: http://www.eclipse.org/mat/
When I was 5 years old I would lie in bed, look at the radio, and I wanted to be on the radio. I don`t know why. 
&gt; Then don't use my library! Odds are, if you didn't understand the point of the article, there will be quite a number of other reasons not to use your library.
Neat idea. What platforms has it been tested on?
So far, just 1.8.7. It should probably work fine 1.8.6 - 1.9.1 though.
This is a pretty slick idea. Does this preclude one from overriding/re-opening the re-implemented parts as needed? Or does it just mean that by doing so you lose the benefits from the "patching" for those particular parts?
Not a bad idea. I'd like to see some benchmarks compared to other implementations of Ruby such as JRuby or IronRuby.
The whole thing is basically implemented as one gigantic monkeypatch. The default activesupport methods are shadowed by my C versions. If you want to tweak the behaviour of a method, you can just override it again, but you'll lose the performance benefit.
The only good excuse for eval being evil is that you're hiding the method definition from being easily searched, but the submitted Method.new alternate solution is isomorphic to the eval'ed code, i.e. equally opaque. I'd say it comes down to establishing conventions in your code.
eval is the GOTO of the php generation.
And, its author is a super nice guy.
I used it on a couple of projects and really liked it but the mailing list seems to be dead. 
This seems pretty old and dated. I would recommend Chef, Moonshine, or Puppet before this project.
I haven't used moonshine (got a link? I can't seem to be able to find it via googling) but the other two are client server protocols. Automateit is very handy if you are shipping an app and you need to make sure certain things are set before the app can run. You can call out to your automated script before your app starts to make sure everything is hunky dory.
What would the goal of the classes be? I'm a Ruby programmer but overall I think Scheme or Lisp are better learning languages (if the goal is simply to teach the students programming concepts).
Contact Douglas Putnam, Professor of Computer Science at the City College of San Francisco - http://www.ccsf.edu/ - He teaches Ruby as an introductory programming course at CCSF and could have some good academic and experienced based advice for you. I don't want to put his e-mail on here but his blog is at http://hackingthevalley.blogspot.com/ and his Twitter is http://twitter.com/douglasputnam
It seems like you could fit Ruby into the Fundamental Concepts of Programming class.
The best class I took in University was an assembler class. This took my low level knowledge of some of the big "why"s from vague to awesome. I haven't programmed a line (byte?) of ASM since then, but having the core knowledge of pointers, strings, null termination, and binary math honestly made me a better programmer when dealing with the higher level languages. Sadly it seems that ASM classes (at my old uni anyway) are a thing of the past, replaced by VB and Java classes.
Please keep me informed of what you learn on the topic. As the maintainer of Hackety Hack, I'm always curious as to how people are learning Ruby.