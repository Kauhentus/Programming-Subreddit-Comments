That said it is "newer" than bcrypt and has not had as many man-hours applied to shaking out weaknesses. I do agree that it has had researchers in the field looking at it and appears to have a strong start -- but like all things crypto/security many times it makes sense to ba a slow adopter to allow more "break it" time. 
This is not really about argon2"y" way of doing it, it appears that you have taken code from an unrelated hash implementation and poorly wrapped it around argon without understanding why things were done in certain ways. This is pretty bad form and you would do yourself and others (who may find your github project without understanding the issue) a service to fix the issues noted above. crypto and security are highly nuanced in execution and implementation -- without detailed understanding of what you are implementing and why it becomes running around the pool with scissors quickly. 
https://github.com/P-H-C/phc-winner-argon2 recommends salt length to be &lt; 16. Devise's salt &amp; a strong pepper will exceed that. Do you see any security issues with my implementation?
Do you understand that crypto is extremely nuanced and things that seem highly intuitive to add security/robustness such as wrapping/layring encryption types on a plaintext actually can cause loss of security/secrecy? Argon2 is still fairly new and you are choosing to utilize it in a way that is not recommended nor standard. This means the man hours being spent (and already spent) to investigate weaknesses and strengths may not apply to the hybrid that you are constructing. This is not worth the time to argue about. As it stands I would highly recommend not using this gem for any production site and note that the gem as it stands cargo cults code from other implementation utilizing salt and pepper as a random concat on the plaintext instead of utilizing standard crypto terms as they are widely understood to be utilized in effect. Good day.
Yeah I was just giving some options, never hurts to know this stuff exists.
If you are a terminal person, you could use a bash function like this to replace gtimelog: # File: $HOME/scripts/bash_functions.sh # Put this in ~/.bashrc `source $HOME/scripts/bash_functions.sh` # Usage: # log time # $ gl browsing redding again # $ gl finished Hugo recipe for zammu.in # # check log # $ gl # # check last 2 logs # $ gl t -n2 # # edit the timelog file # $ gl e function gl() { gtimelog=~/timelog.txt [ $# -eq 0 ] &amp;&amp; tail $gtimelog $2 &amp;&amp; return case $1 in t|c) tail $gtimelog $2 ;; a) echo "$(date "+%Y-%m-%d %H:%M"): $(tail -1 $gtimelog | sed -e 's/^[0-9 :-]*//g')" &gt;&gt; $gtimelog ;; e) vi $gtimelog ;; *) echo "$(date "+%Y-%m-%d %H:%M"): ${@/jj/**}" &gt;&gt; $gtimelog ;; esac } 
Good variable names are important. What is "it" supposed to be? The answer is a better name choice. This might help - can you describe how you do this by yourself? How you figure out "123" is one hundred twenty three? If you can, see if you can make your function match that process. It's almost backwards right now. - well, not backwards. But overly complicated maybe.
Also, have you read Practical Object Oriented Design in Ruby? It's highly recommended.
Hi! I had to solve the same problem recently, here is my version: https://gist.github.com/mindplace/3c46cb1eba69479af805 One suggestion would be to notice that on the bottom of your code, the if-then loops that check the hundreds place, thousands place, and so on--you could refactor this out into a separate method that you could feed the appropriate range, number, and number name to. Something like this: def checker(it, range, max, place, place_name) answer = "" if (range).include?(max) break_down = (it / place) answer &lt;&lt; place_name if break_down != 0 end answer end
5 params is a smell. gross. 
Why not use humanize gem? https://github.com/radar/humanize Best way to refactor is to not need to write it at all, right? :D Example: Input: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 =&gt; nine hundred and ninety nine quinquagintillion, nine hundred and ninety nine novenquadragintillion, nine hundred and ninety nine octoquadragintillion, nine hundred and ninety nine septenquadragintillion, nine hundred and ninety nine sesquadragintillion, nine hundred and ninety nine quinquadragintillion, nine hundred and ninety nine quattuorquadragintillion, nine hundred and ninety nine trequadragintillion, nine hundred and ninety nine duoquadragintillion, nine hundred and ninety nine unquadragintillion, nine hundred and ninety nine quadragintillion, nine hundred and ninety nine novemtrigintillion, nine hundred and ninety nine octotrigintillion, nine hundred and ninety nine septentrigintillion, nine hundred and ninety nine sextrigintillion, nine hundred and ninety nine quintrigintillion, nine hundred and ninety nine quattuortrigintillion, nine hundred and ninety nine trestrigintillion, nine hundred and ninety nine duotrigintillion, nine hundred and ninety nine untrigintillion, nine hundred and ninety nine trigintillion, nine hundred and ninety nine novemvigintillion, nine hundred and ninety nine octovigintillion, nine hundred and ninety nine septenvigintillion, nine hundred and ninety nine sexvigintillion, nine hundred and ninety nine quinvigintillion, nine hundred and ninety nine quattuortillion, nine hundred and ninety nine trevigintillion, nine hundred and ninety nine duovigintillion, nine hundred and ninety nine unvigintillion, nine hundred and ninety nine vigintillion, nine hundred and ninety nine novemdecillion, nine hundred and ninety nine octodecillion, nine hundred and ninety nine septendecillion, nine hundred and ninety nine sexdecillion, nine hundred and ninety nine quindecillion, nine hundred and ninety nine quattuordecillion, nine hundred and ninety nine tredecillion, nine hundred and ninety nine duodecillion, nine hundred and ninety nine undecillion, nine hundred and ninety nine decillion, nine hundred and ninety nine nonillion, nine hundred and ninety nine octillion, nine hundred and ninety nine septillion, nine hundred and ninety nine sextillion, nine hundred and ninety nine quintrillion, nine hundred and ninety nine quadrillion, nine hundred and ninety nine trillion, nine hundred and ninety nine billion, nine hundred and ninety nine million, nine hundred and ninety nine thousand nine hundred and ninety nine `
Its refreshing to see that ruby is doing so well. Great write up.
Looks great! I typically put a bunch of puts statements in blocks while developing. How does this interact with that? I assume it conflicts and any prints get cleared with the next iteration.
Looks pretty awesome, but do you know about [ruby-progressbar?](https://github.com/jfelchner/ruby-progressbar) It's been my goto for a few years and it kicks ass
cool!
You should be able to run the above by saving it to `test.rb` and doing `ruby test.rb` from the command line. CodeClimate is a third-party service that provides static analysis for code and is free for open source projects. It basically just tells you what code is complex/duplicated/etc. Here's an example of a report from one of my repos: https://codeclimate.com/github/jbodah/spy_rb You can set it up by simply creating an account on their site and adding your repository
Neato, didn't think about that. 
[i thought rails was dead](https://assets.infinum.co/attachments/b0d6b8ca2a26ec49c8629fd58c6a1b4bbfa3b08f/store/limit/1000/1000/b05b1b17048b9d770a01a58f5a8d6ce983327df8d6bb8b6828216f60c759/Rails+downloads+by+version+%282%29.png) /s
the params() method just returns a hash of the keys from an instance of OpenSSL::PKey::RSA, doesn't look like I can set those params individually :( 
&gt; Thread safety is broken when state is shared across threads in a non-atomic fashion without locks intervening. Nope. If you do: 1. Wrap code loading with a mutex, so only one thread at a given tim can write configuration settings. 2. Freeze the configuration 3. Start the server and then start to accept requests. At this point, because we guarantee that the configuration won't change anymore, there is no need to wrap access via a mutex. Synchronized access (mutex) is only needed when a shared value may change during the time I'm reading it. That's why immutability is so relevant for thread-safe software. &gt; since the threads don't actually need to interact If they all need to access the same resource (eg. `Lotus::Controller.configuration`), they are indirectly interacting. That's why we won't make that value to change. &gt; when objects must be shared across threads, there is a different set of design considerations in play. Right ;)
/u/disclosure5 this was the answer to my problem: https://github.com/racker/ruby-1.9.3-lucid/blob/master/test/openssl/test_pkey_rsa.rb#L82
&gt; pretty much incompatible with ActiveRecord Explain?
Just as a point of comparison, express, the web framework for Node.js, was downloaded 3.9m times in the last month. Roughly 3x. https://www.npmjs.com/package/express Make of that what you will.
I agree ruby-progressbar is basically the gold standard for features, and powerbar has every formatting option imaginable. But, as a sign of how lazy I'm getting, I admired tqdm in Python for getting instant output after wrapping one object. All the other gems seem to require calling `#increment` on a secondary object you have to maintain yourself.
Well, I was missing an extra qualifier. Thread safety is broken when state that needs to change is shared across threads in a non-atomic fashion without locks intervening. When state doesn't need to change, you don't need locks, but that's not really an interesting problem. What you've got is a solution that works nicely when your threads don't need to interact at all - aka the most trivial case of using threads. Again, that's fine when you are just using threads to allow separate processes to share the runtime environment. I have written a fair amount of parallel computing code using threads, and that's where my critique comes from. Don't share your objects between threads! Connect them together using queues where possible; pipelines are the most straightforward type of parallel system to build. I think there's a lot of value in your article, but my quibble is that changing how we write code in general -- when that code isn't even meant to collaborate with other therads -- to be "more threadsafe" doesn't make sense. Avoiding global state is important to ensure that code can run nicely *within* threads, but that's not the same thing as avoiding mutable state, which is not a beneficial universal rule to follow in ruby.
Is it really coming from the author of rack-fiber_pool? There are no well maintained non-blocking database adapters and due to the way ActiveRecord works (e.g. query cache acquires a connection very early in request processing) it's hard to create one.
EM is used for the listening socket. Thin runs the request within EM's thread pool. https://github.com/macournoyer/thin/blob/master/lib/thin/connection.rb#L50
Is this a homework assignment?
Although not tied to ruby, I'm pretty sure this is a JavaScript recursion issue. See this link for a similar error http://stackoverflow.com/questions/16694209/jquery-uncaught-rangeerror-maximum-call-stack-size-exceeded
Express, unlike Rails, is in package.json of other projects, e.g. https://github.com/ember-cli/ember-cli/blob/master/package.json#L78 So, if someone downloads ember-cli, they also download Express. ¯\_(ツ)_/¯
lame you got a down vote without a comment on why. While wget to create a cached site is non-standard, it's an interesting solution to some.
&gt; I've found thin the most sane solution for Heroku, which doesn't support(ed) nginx proxying to shield Unicorn from Slowloris attacks. Last time I checked, Thin didn't fully shield you from Slowloris attacks. It shields you from clients that slowly send requests, but does (did?) not shield you from clients that slowly receive responses. Passenger fully shields your app from Slowloris attacks, both ways: http://www.rubyraptor.org/how-we-made-raptor-up-to-4x-faster-than-unicorn-and-up-to-2x-faster-than-puma-torquebox/#slow_client_problem Passenger is a perfect fit for Heroku. The latest version supports configuration through environment variables, which is completely in line with 12-factor. It gives you easy access to Nginx on Heroku, giving you a powerful yet easy-to-install toolkit. And it comes with [extremely comprehensive documentation](https://www.phusionpassenger.com/library), something which is rare in the open source world. &gt; Passenger find a crapware as without warning installs/compiles other dependencies when used and free version has limited use of threads. Not forgetting obtrusive form of its propagation(da). What kind of "other dependencies" do you mean? Passenger [does not have any required dependencies besides Rake and Rack](https://github.com/phusion/passenger/blob/stable-5.0/passenger.gemspec#L17-L18). Passenger has a bunch of _optional_ dependencies, such as a performance-optimizing native support library, and Apache/Nginx, but Passenger works fine without them so you don't have to install them. I can't comment on what you think about the way we communicate. I just know that we have a ton of happy users.
AFAIK it allows it to deal with slow clients better. EM handles the socket read. The request doesn't take a Thread until it is completely received.
Every. New. Server. 
The Ruby style guide suggests that methods that end in a question mark should return a boolean value. (Not just one that is truthy or falsey) https://github.com/bbatsov/ruby-style-guide#bool-methods-qmark 
Fyi, there's a learnruby subreddit :)
Definitely agree with the advice to learn Sinatra and Ruby first over Rails. I started on Rails, but I had the benefit of being mentored by great senior developers that were very strict on code quality. 
The lack of a ++ operator is a little odd, admittedly. However, you'll soon appreciate not having to write (or, forget to write!) semicolons at the end of each line. 
Or do Hartl's Ruby on Rails tutorial...
Ruby does not have a `++` postfix operator. It's just not part of the ruby language. I don't find it particularly odd. The way the postfix increment operator ends up working in other languages [can be awfully weird](http://www.rizzoweb.com/java/postfixIncrement.html). Now _that's_ the kind of semantics you might need to be chemically altered to understand. Might as well skip it. No problem. Don't use semi-colons to terminate lines. 
Yes. And I like Rails okay. But it's not a good way to learn programming or web development, you need to come to it with both. 
Anyone here ever tried using [treat](https://github.com/louismullie/treat)? Never works. 
You're probably right. I never realized this behavior. I thought `h[:a] = h` would just be the same as `h = {a: {a: 2} }` What is the name for this? Thanks for looking!
&gt;&gt; I'm using bundler but I don't have a Bundler.require &gt; Then you aren't using bundler, your app isn't using the gems defined in your Gemfile. Eh, that's not true, it's actually totally acceptable to not use `Bundler.require`, and use `Bundler.setup` instead (equivalent of a `bundle exec` on the command line, but triggered without `bundle exec` having to be on the command line; you could also just always execute with `bundle exec` I suppose!) and just require gems manually -- generally requiring them in files that depend upon them, the way ruby require was intended. There are even some [good arguments _against_ using Bundler.require](http://myronmars.to/n/dev-blog/2012/12/5-reasons-to-avoid-bundler-require). Everything works fine if you don't use Bundler.require -- you just need to require your dependencies. In this case, it turns out OP didn't have mysql in the Gemfile, `Bundle.require` wouldn't have helped, and once added, Bundle.require still isn't neccesary. You might need to manually `require "mysql"` somewhere, but I suspect (in part based on the error message) that Sequel will do that for you. OP's errors when he _does_ try `Bundle.require`, however, are alarming, and mean something ain't right and you should probably fix it (until Bundle.require works, then feel free to remove it again), cause it'll end up biting you later. You might want to stop using a vendor/cache directory. 
&gt; Yes. No. `IO#gets` returns `nil` at end of file: File.open("/dev/null") do |f| p f.gets # =&gt; nil end 
Will likely want `require_relative`instead (http://ruby-doc.org/core-2.1.2/Kernel.html#method-i-require_relative). 
That's great news. The Ruby community historically has been fantastic, but it's good to know that should something ever come up, there's going to be an unambiguous set of procedures documenting what is and isn't acceptable and how to handle situations where people behave unacceptably. 
So, no. Firm no.
I did, and I agree with aharpole.
8 different huge ruby project maintainers want it, randos don't. Hmmmmmmmmmmm...
&gt; 8 different huge ruby project maintainers want it, randos don't. Matz wasn't satisfied with the originally proposed CoC, not just randoms. Choosing a CoC based on the particular characteristics of the community in question seems like a much better idea than dealing with all the controversy and somewhat political nature of the Contributor Covenant.
&gt; This is about Ruby and not other communities How in the world is any of the listed people not "Ruby"? &gt; Matz has made the valid point that banning doesn't really work on the Internet, never has and likely never will, specially if the subject is ill-intentioned Banning is as much a solution as any other tool. Apathy towards toxicity is the only thing that has proven to never work.
That's terrible. All this is going to do is to push people out of the project because they are afraid they are going to be smeared with unwarranted accusations of being "transphobic". If there is going to be a code of conduct it must state what the punishment is going to be for people who bully and harass others with silly accusations of racism, homophobia etc. It should also ban any mention of words like "cis" or "privilege"
&gt; So who didn't pay attention? /u/aharpole clearly didn't. They said that there are going to be "unambiguous rules", while the discussion does not point to that yet, and contains indications from Matz that it might not be the case. Something that is completely orthogonal to the point you are making about whether it is desirable or not.
That's because they will get special treatment and will be immune from the persecution under the COC. Steve made a girl cry once by insulting her code rudely but he won't be challenged on it because he is famous(ish)
Is there going to be punishment for calling people "cis"? I don't identify as "cis" and I am offended by the word.
&gt; How in the world is any of the listed people not "Ruby"? You didn't just list Ruby people, you listed other communities. &gt; Banning is as much a solution as any other tool. It is one of the solutions outlined in the CC, and if it isn't desired then adopting the CC unchanged isn't feasible.
Steve publicly apologized. 
Is MINASWAN not a moral imperative?
The COC the toxic individual is pushing would have resulted in him being banned from the community. If applied to linux it would ban Linus. When you give the easily offended power to ban people you are dooming yourself.
Can't say you've given me much to reply to, but I'll back up my points (even if with anecdotal evidence): &gt; There's nothing wrong with the Ruby community &gt; nobody is ever told anything harsh and unproductive I've posted a few gems here, some of which were genuinely useless outside of an academic exercise, but only received constructive criticism (especially about OD'ing on comments in RDoc), and the `#rails` IRC is usually a decent place to get help if you've got a while to wait for an answer. Even when I read the few issues on bugs.ruby-lang.org, the people involved just want to make sure the implementation is right, no matter which type of meat-based organism presented them. &gt; Coraline is a hugely successful software developer. What are you even talking about? Maybe they are, but I don't know this person's work outside of attempting to promote this CoC. Probably just run in two different circles, who knows? Anyway, I'm not trying to change anybody's view, but that's my opinion.
A code of conduct doesn't give anyone any power they didn't already have. The risks you describe are all imaginary.
No one ever said the Contributor Covenant had to be adopted unchanged. Coraline was clear that it is meant to be a starting point.
One of the things a code of conduct can do is advertise that harassment won't be tolerated. "Cis" is a latin root meaning "on the near side", which makes it a natural complement to "trans", the latin root meaning "on the far side". It's used this way in chemistry as well as gender theory. It's not a slur. Seems like you're the one who's easily offended.
That's because when you do `class &lt;&lt; self` you are actually writing to the object's eigenclass (singleton class) which is a new class in it's self and therefore doesn't know about constants defined outside of it. Here is a [link to StackOverflow](http://stackoverflow.com/questions/5304162/missing-constant-and-const-missing-inside-class-self-definition) about that matter. The eigenclass is mostly used for metaprogramming as it holds methods and variables defined on an instance of an object. But it can be used to create singleton methods on class objects as they are instances also. Hope this helps. If you find it confusing try googling Ruby eigenclass or ruby metaprogramming. 
It's slightly more verbose, but I've warmed up to this pattern: class SomeClass module ClassMethods def foo end end extend ClassMethods end This way if you want subclasses to have the same class methods, you can just put another `extend` in the `inherited` hook.
Right; let me ask this of the people who've commented thus far: &gt; How many of you are *not* white/East Asian, straight, cis, males from a middle-class-or-higher family? I am one; I've spent four years trying to put together a Ruby startup in a (rather different) monoculture, and I've failed. This is the fifth startup I've done in my career (going back to 1979); three of those five have at least launched their promised product, and two of them are now brands I'm reasonably certain that any of you with more than five years' exposure to the industry have not merely heard of, but used. Monocultures make it *harder* to build and ship product. Monocultures make it harder for anyone *not* of the monoculture to participate. And before anyone screams "meritocracy!", I'd not only remind you that the word was coined as the punch line to a French comedy (look it up); it's been proven, academically and experientially, to be the *single most effective means yet developed* to reinforce *existing* power structures. Which for those of us in software, means those made up of straight, white/East Asian, cis, males from middle-class or higher families. Which limits the available "talent" pool to something like 0.6%-0.8% of the planet. Is that sustainable? Hardly. Is that being defended tooth-and-claw by its most immediately short-term beneficiaries? Take a look around. Another thing that killed this startup was that, for a Lemony Snicket-worthy series of unfortunate reasons, it's been marooned in one of the three or four most authoritarian countries in the world, and one of the current two most faithful to Mussolini's original definition of fascism ("the fusion of State and corporate power".) The ruling cabal have been absolutely consistent in their policy that they would much rather have 100% control, from the top down, of the existing pie than risk having "only" 70% control of one fifty times larger. Never mind that that would put *more* money into the pockets of a dynastic ruling clique widely derided by their subjects as being "money-faced"; they've had multiple, explicit opportunities to choose between overwhelming control of a far more authentically wealthy country, or absolute control of a country wholly dependent on rent-seeking, and they have consistently, deliberately, and explicitly chosen the latter. They maintain control by appealing to the carefully-maintained and even more carefully-controlled monoculture, of course. Whenever I hear anyone railing against legitimate efforts to create a more *authentically* level playing field, I'm reminded of this place. As I've been telling my co-founder, an MIT grad with amazing experience in everything from startups to Big Six consulting firms, "any Americans who don't understand what being outside the mainstream does to you should come here and live *as a local* for a few years. They'll *permanently* change their tune." I sincerely hope it doesn't take a chunk of your life being marooned in a fascist kleptocracy to teach that lesson. Apparently, though, that's being rather too optimistic.
&gt;One of the things a code of conduct can do is advertise that harassment won't be tolerated. But the author is famous for using the COC to harass people. &gt;"Cis" is a latin root meaning "on the near side", which makes it a natural complement to "trans", the latin root meaning "on the far side" I don't care. I don't self identify as "cis" and I find the term offensive. &gt; It's used this way in chemistry as well as gender theory. It's not a slur If you referred to Coraline as a "he" "she" would be offended even though "he" is not a slur. "she is offended because "she" doesn't self identify as a "he". In the same way I as a heterosexual don't self identify as a "cis" and I take offense at being called that. &gt;Seems like you're the one who's easily offended. Yes I am, now you have to deal with me. Why do you hate heterosexuals so much? I won't take this kind of oppression from the likes of you. I think you should be banned from reddit.
&gt;"He" obviously is a slur if you use it to refer to a woman. And "cis" is obviously a slur if I don't self identify as one. &gt;I hope someday you are able to learn empathy without having to experience personal tragedy. I don't see why I should have empathy towards people who use slurs against me. &gt;But you're clearly an incurious individual, so I won't hold my breath. Is this an example of the sympathy you are talking about?
Curious, what do you like about this pattern?
So now you want everyone to pass all their communication with a community through a filter? Do I need to print out the code of conduct for every community, framework, project, repository, and gathering I want to interact with to make sure my comment, blog post, code, patch notes, and the words that come out of my mouth don't break some rule? Is there a way for me to be notified when the rules change? Will I have to pay to get a coc license in the future to show people so they know I'm not a horrible human being? Who enforces the code of conduct? It can't be one person, they would have too much power. So there needs to be a Conduct and Accountability board to make sure nobody breaks the rules. How are the rules enforced? Are people completely prevented from interacting with the community of they break the rules? Now that's the definition of inclusive. What if someone disagrees with the code of conduct enforcers? What if the enforcers just don't like that person? That sort of thing already happens. Who do they turn to then? If Mussolini is fascism with the right hand, this is fascism with the left. Having a code of conduct won't prevent racism or any of the other social ills that plague these communities. If someone wants to ignore you because of who you are they will. If the community wants to do so, they will. Do some people need a code of conduct? Yes. Some people and communities are shitty, but I don't think these codes are going to change them. Who do the codes effect then? If somebody is being shitty to you, speak up! Right in their face! Don't retreat into yourself at the first sign of perceived insult. And don't give up; find other people like you(they're out there) and create your own community. This reminds me of Juan Williams being scared to get on a plane because he saw some Muslims boarding with him. Juan Williams being exclusive instead of walking up, introducing himself, saying "hello", and talking with them. Don't be a pussy Juan Williams.
I want to add to this. The author of the issue in the OP, who's also the author of the "Contributor Convenant", happened to talk about this in #ruby-offtopic few days ago. It was quite interesting to get first hand experience not only from a general supporter of CoCs, but to get 'insight' into one of *the* CoC writers. That discussion only lead me to further believe that CoCs, or at least the "Contributor Convenant", are toxic. 1. We already have MINASWAN, replacing that with the next sheet of rule sets is a fix for a bug which does not exist. 2. This person is also the author of this issue: https://github.com/opal/opal/issues/941 Looking at the linked tweet https://twitter.com/krainboltgreene/status/611569515315507200 shows me that this person is offended by literally anything. In such mind, thought crime is real. I have no context on the tweet, nor do I care about personal beliefs of other people. You might ask "but what does this have to do with the CoC?". My answer is that incidents like this shows that the CoC **will** be used to kill off people you don't like for any reason. 3. Adding to the last point, but furthering this thought: People say that you should show rules before stuff happens, in the believe that anyone could be a *bad person*. I think it's ironic this comes from person(s) like this CoCs author who tried to use it as a weapon. 4. "But she [Note, the CoCs author is a she] is a really reowned programmer!!" That's nice for her, I don't know her and frankly, I don't care. This point adds nothing to the discussion, but is generally brought up. This point is nil. 5. People are trying to use this to hide from what they think are bad people. I'm using this wording because of the Opal incident above. I'm not saying there are no bad people on the internet (ahahaha), but that there are better ways to deal with them. It is quite common, and welcomed by me, that *disrupters* (as in *bad people*) are removed (*kicked*) from discussion forums, chat rooms, etc. This system has worked for decades just fine. 6. Combined with the above, the only organization which can help you is your local police. A bad person will do shitty things. But it's wrong to think that, if the perpetrator lives in the same country as you do, is outside the law just because s/he's doing it over the internet. People are constantly sued for things they did or said on Facebook for example. And no, on FB you don't have to use your real name, still it's possible to sue these people. 7. The mental issue. I mean the victims, or those who think are victims, should also seek professional help. Police, psychologists, etc. DO NOT take this out of context! There **are** people who are target of real malicious violence, including mental ones. Some people however are falling into the victim scheme after the first (real?) incident, and then claim they're attacked by anything. 8. Another common scheme is blowing things out of proportion. The Opal incident was called *Opalgate* [sic!] by the CoCs author in her own blog: http://where.coraline.codes/blog/on-opalgate/ (Sidenote, dear Coraline, please change your blog design. This one is unreadable.) And if *everything* is the biggest incident ever, then *nothing* is. You're thus devaluing the real victims, those who were attacked, but no one will believe those. It's like the boy and the wolf. STOP HURTING THE REAL VICTIMS for christs sake! 9. It is irrelevant to the discussion if someone is a "white male" or "blue green neanderthal". I'm soooo sick of this what people out of the authors corner claim to be an important argument. The issue is not only that it's no argument whatsoever, no, the CoCs author also started questioning participants in the IRC discussion this to prove her point. This is also nil, and if you do that, you immediately land on my *ignore forever* list. This is also a huge part in the victim scheme. To me, it's a scam. And you're still hurting the real victims. See above. This is bad and yes, you should feel bad about it. 10. Do you want to live in a society where all of your actions are always judged on the basis of some random projects CoC, put under the microscope? So you actually have a political discussion on your private twitter account. You happen to have a POV which does not align with some other random person. Is it now fair to whine to every project those people found with Google to have you removed because by their definition, you did wrong? CoCs are a powerful weapon and must not be used by the wrong people. As the internet is open to everyone, it **will** be used by those wrong people, and there are many known incidents where stuff like this happened, where people lost their jobs because some friends felt the need to destroy someones life to make them feel better and mass-called the 'offending' persons boss about how it's a bad person. Are you fucking kidding me? And I'm fucking sick of this shit too :)
The negative connotation comes from people saying things like "cis males should all be killed". I understand that a minority community needs to push hard to be heard, recognized, and treated as equals, but sometimes they go a little too far and push away people who would otherwise love to help them. 
First of all i wanna thanks you the quick reply, a hours later i posted this i realized my mistake. 
Rails is a household name. It's not going anywhere. Implying that it is dead or dying is silly.
"Cis" isn't used predominantly in that context. It's predominantly used when trying to explain trans and trans issues. The fact that people like myringotomy fake offense when they read it is itself a trans issue because it creates a barrier to dealing with real issues. Labels suck, but they are necessary for communication.
Excited to see new content! FYI, subscribing does not close the subscribe window / give success feedback
Try it: https://repl.it/BgAh
&gt; I see cis scum way more often. May I humbly suggest that you seek out some different voices? The wikipedia article on cisgender manages to completely avoid "cis scum" despite using "cis" over 50 times. I'm sure a little google searching will yield many more examples. &gt; Nobody claims the word faggot means a bundle of sticks anymore. True, but there are still words for gay people and straight people that are not considered derogatory. Multiple alternatives, even. There's no real alternative to "cis".
it's not in scope cos it's not in the lexical environment
Ah ok. It's a third party blog service but I'll send them on the problem 😌
Meh. Being a mere Ruby user, I don't have a stake in this as long as it doesn't get in the way of development. I know that people get tired of the pushback on these things, but dissent is needed imho; without pushback, you get the situation that exists on college campuses around Western society, where students demand to be protected from things they find offensive. Now, if I were a developer, I would only have misgivings about &gt; Our open source community prioritizes marginalized people’s safety over privileged people’s comfort. We will not act on complaints regarding: &gt; * **‘Reverse’ -isms, including ‘reverse racism,’ ‘reverse sexism,’ and ‘cisphobia’** &gt; * Reasonable communication of boundaries, such as “leave me alone,” “go away,” or “I’m not discussing this with you” &gt; * Refusal to explain or debate social justice concepts &gt; * Communicating in a ‘tone’ you don’t find congenial &gt; * Criticizing racist, sexist, cissexist, or otherwise oppressive behavior or assumptions Emphasis on the first one, because I agree it's not an issue: reverse racism does not exist. It's just racism. If Ruby adopted such a policy and I were thinking of contributing to the language proper, I didn't know much about Matz, and saw where he was from, I would probably start with the assumption that I'd be working in a hostile environment. And cultural differences. One thing I learned when I went to uni is that different cultures interpret things differently, and different cultures get offended at things differently. I used to have this nervous habit of scratching my chin. After a tense confrontation with an Italian, I worked on it...but it was a completely benign habit on my part. Cognitive dissonance is bad enough when people all speak the same language, and it gets worse when you're dealing with an international effort, as many popular open source projects are. EDIT: My apologies, I was looking at the old Github policy, but iirc the proposed CoC isn't much different. Aside from that...again, meh, as long as it doesn't get in the way. If you can't discuss things without being verbally abusive, go away and let the grownups get some work done.
Can you explain exactly what that means, please? Is it because we don't explicitly state that Foo inherits from Subclass?
My guess is the AIX compiler can't handle the code. I haven't used AIX in 20 years but is a modern gcc version an option?
Thanks. Part of this I've already understood from code. The questions remains, though: what is, for ex., stopwords?.. What is their role and what should be there?.. And the same question for abbreviations. (Contractions are understandable from English example.)
Go read the thread, specifically the last 10 posts and tell me there's nothing wrong.
She's risking harassment and now impersonation/character assassination to bring a bit of certainty to the community. That's not apathy.
I believe the comment was about her (alleged) toxicity, not her apathy.
&gt;No one ever said the Contributor Covenant had to be adopted unchanged. If you look at this [earlier comment by /u/danielkza](https://www.reddit.com/r/ruby/comments/4246fz/rubys_turn_for_the_coc_pushers/cz7krwm), you'll find that you might be largely agreeing: &gt;Choosing a CoC based on the particular characteristics of the community in question seems like a much better idea
It is asking for the nth prime number so I'll go back and re-attack these steps, thanks! 
Ah yeah, see I thought by subtracting 1 from the max number it would account for the zero-based index value. I think I'm actually tackling it wrong and not asking for the nth prime number, instead asking for the nth prime factor of that number. Thanks for your help!
Great news. +1 on a (more) unique name. It's so much easier to find relevant discussions when you don't have to wade through tons of irrelevant pages/tweets/etc and makes SEO trivial.
[Beautiful name.](http://blog.neo-amusement.com/wp-content/uploads/2013/04/Hanami.jpg)
I still think extracting so much stuff to rack middleware was one of the worst architectural decisions Rails has made. 
Foo does not inherit from Subclass, implicitly or explicitly. Foo is a class inside of Subclass. If these were modules, I think it would work. You can read more here: http://cirw.in/blog/constant-lookup.html
At least they are mostly orthogonal and self-contained. The "callbacks and concerns everywhere" implementation is unreadable to me. This is ridiculous, e.g.: https://github.com/rails/rails/blob/master/activejob/lib/active_job/base.rb#L57
&gt; At least they are mostly orthogonal and self-contained. Sometimes. Sort of. Another way to look at it is that there's no way to tell where one depends on the API of another, the only way they are coupled (sometimes quite tightly) is via writing and reading a giant flat (usually!) ball of keys and values called `env`. Have you looked at Warden, and the things that depend upon it? Geesh. Or what you need to do to customize error handling in Rails to be reasonable, in a reliable way. It's all in middleware. But middleware doesn't actually have access to what it actually needs to make decisions about error handling, it's not the right level of abstraction in the first place. I mean, [check it out](https://github.com/rails/rails/blob/v4.2.5/actionpack/lib/action_dispatch/middleware/debug_exceptions.rb), `env['action_dispatch.logger']`, `env['action_dispatch.show_exceptions']`, `env['action_dispatch.show_detailed_exceptions']`, that's reasonable API, just pass everything as magic token keys in a giant hash, who knows who set it where calculated according to what, or who else modified it overwriting what someone else set, or what exactly it means? That's tightly coupled code without a clear contract, not orthogonal and self-contained code. It's like the freaking Windows Registry in web app land. And since it all depends on Rack API, Rack 2.0 is going to mean a big cross-cut of code that actually has little to do with HTTP request/response handling (error logging? What's that got to do with HTTP request/response? Why it should be intimately familiar with Rack in the first place?) have to be rewritten, when they shouldn't have been concerned with Rack API in the first place. And the code that has to be rewritten all has unclear contracts and dependencies with other cooperating middleware. 
She is now trying to split the community. She has proposed that Matz be the "technical leader" and somebody else be elected the "community leader". The reason of course is that Matz isn't going to adopt her insane COC.
&gt;What do you think the meaning of that word is? What do you think the meaning of "he" is? If Coraline can take insult at being called a "he" why am I not allowed to take insult at being called a "cis" which I consider to be an ugly hateful term and don't identify with. 
.
Looking forward to the mass search + replace. This is where I find out the hard way I had a class called PilotUsername or something like that 
That's a troll account, pay attention.
Uh, yes I would? Why are you so sure you know how I'll avoid following the thing I'm advocating for? I'm not like you, don't project.
[**@jennschiffer**](https://twitter.com/jennschiffer/) &gt; [2016-01-22 22:01 UTC](https://twitter.com/jennschiffer/status/690655550393208837) &gt; everyone knows how I feel about codes of conduct. but most people don't know that someone tried to use one against me! and i survived! ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt;Uh, yes I would? Uh no you wouldn't, or rather the community wouldn't. The COC sets up a two tier system where it's only enforced against the lesser known and marginalized people in the community. Nobody is going to ban Steve or Aaron or Matz from the community even if they did say something the SJWs are offended by. &gt;I'm not like you, don't project. There is no reason to be hostile and toxic. Stop trying to bully people. I am offended by your accusation.
Tbh, the old name made me think of Lotus Notes
I said nothing of rails.
Yeah, Foo inherits from Object. Defining a class inside another only changes how the class is looked up (e.g. `Subclass::Foo`) it doesn't create any inheritance relationship. The singleton class is the one you open with `class &lt;&lt; self`. It actually has its own ancestor chain separate from `Subclass`, but that's where it gets a bit mind-bending and confusing. Try messing around with `Subclass.singleton_class.ancestors` if you're interested.
&gt;A male. False. &gt;So what is the meaning of "cis"? it's a derogatory term for heterosexuals.
Interesting. I started dipping into Ruby and Rails a year or two ago, and made good progress with Daniel Kehoe's "Learn Ruby on Rails". But I've sorta hit a wall, and I haven't looked at my project in months. I'd love to try the Sinatra approach, but I just can't think of anything to build without a database. What would that even be? :-)
Great article :)
One suggestion that I originally had in the article but cut for length: start with a version of what you want to build with just mockup/static data. Doing so will force you to make a bunch of hard decisions about your UI/page layouts/route names/etc. Then you can go through and replace the prototype text with dynamic/database-backed content. I personally also do light styling during that prototype phase, because I like seeing it all come together at once, but it's all completely up to you!
"Cis" doesn't mean "heterosexual". A person can be one, the other, both, or neither.
Modules just make everything better.
Summing every version?
I've started using tap to add logging to single line methods. Usually if you start with something like... def foo bar + baz / 12 end You would have to add logging by first saving off the result, logging it and then returning it. def foo result = bar + baz / 12 logger.debug { "[foo] result = #{result}" } result end I prefer this.... def foo (bar + baz / 12).tap do |value| logger.debug { "[foo] result=#{value}" } end end 
Again, that's a pretty good idea too. I'm very much the type to stop myself before I even begin, because I want it to be perfect, and I realise that I can't make it perfect.
[tap tap taparoo](https://www.youtube.com/watch?v=-br7JKuaZHQ)
No, 10 is too lenient. 5 is about right. It's hard to do too much in 5 lines, but that is the point. You need to get better at extracting responsibilities. 
I'd counter by saying that if you start extracting simply to satisfy Rubocop you're going about it the wrong way. Absolutely there are times you should, but there are also times you shouldn't.
No, just don't complain in /r/IBM. They can't do anything about it.
Do you think that increasing diversity is an worthy goal?
I think that's pretty harsh. Seeing how iterating over an Enumerable is going to be 3 lines very often, it seems like you'd run out of lines pretty quickly. You also would never be able to write an if with an elsif and an else. 
I think that decreasing identity-based discrimination is a worthy goal.
While I'm not a functional programming zealot, avoiding side effects in code is a Good Thing, `#tap` seems made for that.
What about case statements? What if you are simply matching a long list of things? Case statements are used when you have a bunch of conditions to check, so an if/elseif isn't appropriate. If you limited yourself to 5 lines, you would essentially never be able to use case statements.
Tap is useful for many things. But for communicating intent on the return value of method - an explicit return statement is much more clear.
&gt; Have you ever seen a codebase that suffers from this effect? (I don't think you ever will.) Yes, I absolutely have and they are a nightmare to work on. 
It's just a good gut check. When you see the warning, take a minute to think about refactoring. If nothing jumps out at you, toss some ignore comments around the method (maybe leave a comment about your thoughts for the next person) and move on.
As others have said, use it as a guideline rather than a strict rule. If you can genuinely look at a 30-line method and say, "Yeah, that needs to be 30 lines," then why beat yourself up about it? The idea is to be generally conscious of code quality, not to follow some arbitrary rule *just because*.
It's because the backspace is a character for the console, so it works right. Sublime is not a true console (i.e. how you don't have STDIN), so the backspace doesn't work properly in its output.
I completely agree. I like style guides because they help make the codebase consistant, but I do like a little flexibility when appropriate.I can rely that my team is going to _mostly_ be disciplined and the really egregious stuff would be found during code review.
&gt; Have you ever seen a codebase that suffers from this effect? (I don't think you ever will.) I work in one every day, and it is supremely frustrating.
&gt; Have you ever seen a codebase that suffers from this effect? Yes. The codebase seems neat and tidy at first, but once you need to actually comprehend the logic hidden behind tons of little methods trying to make some arbitrary LOC measurement it's a serious struggle.
I have too, though I wouldn't say they are any worse than codebases with insufficient abstraction. In fact, I bet it's the same proficiency of programmer in both cases; the short method mess probably just has a programmer applying a constraint without thought behind it.
It's actually really cool that it highlights special characters like that. I remember spending a morning tracking down a vertical tab that was breaking a csv parser I was working on way back in the day. You may say to yourself "wtf is a vertical tab, and what devil would concoct such an abomination?" That's surely what I was thinking at the time. I think it might be one of the obsolete control codes that was used on teletype machines. But those predate my time so I've never had the inclination to learn much about their operation. 
Y'all should use an aspect.
Here's how I tweaked the corresponding Rubocop rule: Metrics/MethodLength: Description: Normally methods should have less than 10-20 lines of code. But this one has more than 30. StyleGuide: https://github.com/bbatsov/ruby-style-guide#short-methods Enabled: true CountComments: false Max: 30 Makes for a relaxed, zen style that is not too hard on junior devs. No need to be a 5-line zealot at all costs.
&gt; I am in complete agreement (though I think it's Sandi Metz, not Matz). Fixed, thanks. &gt; However, I think there's a Phase 5 - when you design your code to be amenable to human cognition first and foremost, using design theory as guidance. We're on the same page there, I think that is a better description for what I think of as the post 'design pattern all the things' phase. &gt; Now, regarding your rebuttal.. I'll just say this. If there aren't abstractions, then it doesn't matter if the code is grouped into one big method or split into many. Well, here is something that I think gets missed in the context of 'make all the methods 5 lines long'. When you do that to inevitably create abstractions, there really isn't a way around it. Each method is an abstraction of some sort, i.e. it's a named black box with some input and some output. Once you have those abstractions I find that people are less likely to change them, so things get built on top of crap abstractions which eventually ends up with a 5k line PR from me to replace the abstraction with something that makes more sense. On the other hand, if I run into a 1k line method it's usually trivially easy to break it into a few sensible abstractions without too many actual code changes. re: Understandable code: absolutely, this is why Ruby is my go to language as I find it allows creating the most readable and understandable constructs. 
That's exactly how i understand it as well. A carriage return takes the typewriter all the way to the left; new line goes down one character (Microsoft does \r\n because it's historically correct. Unix said who gives a...); horizontal tabs replaced series of spaces with mechanical 'tab stops'; so, a vertical tab must have been a replacement of line feeds with another system of mechanism stops.
&gt;Where? If they never attempt to discredit her based upon something other than her workthen there's no violation of that policy. It's in the COC. If anybody is offended by something you say you can be banned. &gt;You can say the policy is inadequate in various areas - such as dispute arbitration techniques I have already said that. If somebody makes an accusation that somebody else is transphobic or racist or whatever there should be a burden of proof on the accuser and a presumption of innocence on the accused. If it turns out that it was a false accusation the accuser should be banned from the community. &gt;It seems like the point of the policy in question is to ensure nobody has to use either term in a negative context; her using your skin colour, gender, or gender identity to discredit your view would be a violation, Well I object to being called "cis". I find the term offensive. &gt;I dunno, it just sort of seems like the thing you're afraid of is the thing the policy is designed to prevent. No I am afraid that the toxic people will launch a twitter lynchmob every time anybody says anything which they find even remotely "triggering". If I say "many this thing is a pain in the ass" maybe that will trigger her and then she will get her lynch mob to hassle me for weeks. She intends to put everybody on eggshells so she can pounce on the slightest bit of perceived offense in order to get attention for herself and her cause. She can't be trusted. She is toxic. She is not a nice person. She craves attention. She is destructive. I would never go to any event where she was going to be present for fear that she is going to overhear something I say, get triggered and then raise a public stink. Fuck her and her desire for a trigger free safe space. Leave the community to the adults. Aside from that she has already proposed to split the community. She wants to have a "technical community" and a "social community" I guess she finally realized she can't be a leader in the technical community of ruby.
&gt;I never called you cis, I only challenged the misinformation you're spreading about the word. There is no misinformation. Just as there is no misinformation about what "he" means. If "he" is offensive then "cis" is just as offensive and you should stop using it. &gt; Is there a word meaning "same gender as assigned at birth" that you would prefer people to use? I'd prefer that you refered to my gender explicitly as defined by my genetics. 
The fundamentals haven't changed, so you should be good. 
And the conditional if/else thingy is only one part of reducing into a single line... while at it, avoid `do ... end ` blocks and use `{ ... }` syntax. Can be paired with lots of dots and parentheses and for method chaining. ;-) I wonder why anybody linked Sandy Metz already: https://robots.thoughtbot.com/sandi-metz-rules-for-developers
What about when implementing algorithms? The reason that this topic surfaced in the first place was because I'm implementing a lot of well known algorithms for fun and profit. Do you think that decomposing merge sort into an object hierarchy is helpful to its implementation?
&gt;&gt; Is there a word meaning "same gender as assigned at birth" that you would prefer people to use? &gt;I'd prefer that you refered to my gender explicitly as defined by my genetics. So, no, there's no such word you'll ever be satisfied with, you just want to stifle discussion of the topic. I guess we're done then.
Really useful and informational blog post. I saw Mike Perham writing about it before (and maybe someone else as well), but I was always wondering if someone was ever bit by Timeout in the "real world". Thanks for sharing!
Not every problem should be solved with OOP. This is why Ruby supports multiple paradigms. Trying to shoehorn everything into an OO model just creates a mess.
Can't you just use a `rescue` in addition to the `ensure`? It might create some minimal duplicate code, but wouldn't it work?
Would you mind putting up a gist with what such code would look like?
Probably not the best way of doing this, but [here](https://gist.github.com/rivertam/8182e72ebe76153c1799) is something I'm imagining. Concessions: 1. It could be the case that the error gets thrown between the print and the variable setting so re-trying might do the `puts` twice. 2. It's annoying to have to specify a flag for each action. I think these are taken care of when you consider real examples don't generally have negative consequences if you do them twice (if you're careful about it). So, for example, just check to see if the db connection is actually open before closing it. You should be doing this anyways, and doing it twice has no negative consequences. That said, I've only been programming Ruby for about 6 months, and I haven't done anything multi-threaded in years, so I could very well be off on a lot of this.
Not unless you monkey patch every outside dependency that may execute inside a `Timeout` block. You can use `Timeout` safely but it requires either using only your own code in the block (and being very careful) or auditing every outside dependency you use to ensure that no wonky state occurs due to a random exception. In both cases keep in mind the semantics of 'safety' can vary with which interpreter your using. The issues for jRuby may not be the same as for MRI. 
A) that has nothing to do with what I said and B) that's completely backwards. Writing procedural code in the middle of an OO app is almost guaranteed to make a mess. Fat controllers are a direct consequence of this sort of thinking. 
It was pretty clearly inferred that OOP was the 'assumption' rather than an option, unless you had some alternative meaning. As for B, you'll have to demonstrate that. I'm not going to bother with a laundry list of situations where OO code doesn't fit, it's been beat to death. 
Thanks for taking the time to write up a gist. You're right in that the example I gave would indeed work just fine with your approach. However, as /u/moomaka states below, sometimes you're going to be in a situation where the cleanup is actually done by a call to a 3rd party library that you may not have any control over. Basically it all comes down to whether you are entirely certain the cleanup code is not dependent on any state and is safe to retry. In my article I go into some detail regarding my experiences with the curb http client. I think that we both would like for there to be a way to make subsequent calls to this client be idempotent. However, as I demonstrate in the article, this is not the case with the current version of this client. So I was left with two options: a) I can either start rewriting/monkeypatching the http client myself (the code of which is extremely complex as it deals with a Ruby extension in C) b) realise that all my pain is being caused by the timeout method, and do my best to get rid of this
Thanks :)
Thanks for subscribing!
I read [this](http://headius.blogspot.com.au/2008/02/rubys-threadraise-threadkill-timeoutrb.html) blog post a couple of years ago which gives some great examples.
Meh. This is true any time you abort a thread from outside that thread. Perhaps the issue is that Timeout hides the multithreaded nature of its operation, leading new developers to use it incorrectly. 
You can try to benchmark them. They are in different syntax so I am not sure how meaningful that benchmark would be.
For the most part, that's in fact a reason never to abort a thread from outside that thread, like Timeout does. 
Intoduction*** edit: there are actually tons of typos in this. Maybe do a little proofreading?
It doesn't cover `Thread.handle_interrupt` or `Thread.pending_interrupt?` which allow you to interrupt safely with proper cleanup.
I'm down, let's do it. 
I resent being called cis and you should be ashamed for continuing to insist that the abusive term be used against me. 
Sure, I'm down.
Please join this chatroom if you want to talk more about this. https://gitter.im/srinath-v/chronic_fork/~chat#share
Still not explaining why it needs a rewrite.
That's interesting. I'm curious how OSX developers created progress bars and tui interfaces without being able to use '\r' to overwrite the current line. Strange.
Wow thanks for lucidly clearing that up. I've tried getting in touch with the owner of the repo and failed. My major concern is if I can maintain the quality if code, the tests and other stuff. I don't think I can. I guess all this energy could be devoted towards an active gem.
Brilliant comment! I had no idea this existed. This will be material for a follow-up post!
Yeah, timeout is pretty horrible. It also turns out that it can't handle certain situations of network timeouts. Unfortunately, lots of Ruby HTTP libraries rely on `Timeout` even though Ruby is capable to handle all kinds of network timeouts propery with non-blocking IO. [Excon](https://github.com/excon/excon) does it right with TCP sockets but strangely uses `Timeout` for Unix sockets.
I'm definitely interested in helping out. I've joined the gitter.im chat.
You maybe should note that: * "the orginal author" is not some lone weirdo which created this one library and then just abandoned it. It's [Tom Preston-Werner](https://en.wikipedia.org/wiki/Tom_Preston-Werner), former creator/CEO of GitHub and author of many useful OSS projects; * his GitHub [profile](https://github.com/mojombo) doesn't look like he became inactive and abandoned his work on open source projects; maybe you have contacted him through wrong email/didn't wait long enough for answer or something like this? * from Chronic's [commit log](https://github.com/mojombo/chronic/commits/master) it seems at least GitHub user [davispuh](https://github.com/davispuh) also have maintenance rights, have you tried to contact him?
Here is davispuh's [comment of interest](https://github.com/mojombo/chronic/issues/303) &gt; Don't worry about fixing, there's ongoing rewrite of large part of Chronic and I know how big mess current code is. Also actually this is fixed in my rewrite branch. Though, latest commit on [named branch](https://github.com/davispuh/chronic/tree/rewrite) is of 2014 :( He also seems to be on reddit: /u/davispuh
15 of 19 open PRs are more than a year old. GitHub reports 341 forks as I write this, of which numerous are apparently single-issue fixes over and above the open PRs or, in several cases, duplicating them. If anyone feels strongly about this and has some time to spend on it, a fork that attempts to address the existing forks (starting with open PRs) would be Helpful. As I recall, this is the sort of situation that led from [CanCan](https://github.com/ryanb/cancan) to [CanCanCan](https://github.com/CanCanCommunity/cancancan).
Or just use [pry](https://github.com/pry/pry) and [pry-byebug](https://github.com/deivid-rodriguez/pry-byebug). Does about all the things but you don't have to edit your source files when you're debugging.
I blame twitter on this as I didn't received any notification to email and I rarely check Twitter but I just saw it :P So anyway actual current Chronic maintainer is https://github.com/leejarvis but I haven't seen him responding on GitHub/Chronic for quite big while, no idea why, see https://github.com/mojombo/chronic/issues/316. But when he was responding he did merge and comment on my PRs and eventually he did gave me commit rights on that repo so I can easily push/merge PRs but I didn't really wanted to without his input but I guess currently it looks like he doesn't really care so I might go ahead :D Basically I was working on rewrite https://github.com/mojombo/chronic/pull/278 which fixed a lot of issues and would fix all but sadly I got carried away with doing other things and so haven't gotten time to start working again on it but it is still in my long TODO list. I'll try now to prioritize this and start working as soon as I can as I really want and need to finish this. Only I don't really remember what was left to do so I'll need to investigate that... From few things I remember is that Chronic for parsing timezone abbreviations like "today at 15:00 EST" used builtin Ruby Date parsing which is very limited (contains very few abbreviations) so in my rewrite branch I switched to using a proper timezone parsing library (https://github.com/davispuh/TimezoneParser) which supports all abbreviations and timezone names from [Unicode CLDR](http://cldr.unicode.org/) in all those languages. Only downside is that currently this adds quite big startup time because it loads it all in memory so basically need to improve TimezoneParser so that it uses Sqlite with data rather than Ruby hashes in memory, but I guess this can wait and first finish Chronic. Also will need to disable this functionally by default in Chronic and add option so that only users who need it can enable as it's not really needed for most users. PS. You can get emails from git log 
They're not always available, I work on lots of open source and don't want a dirty Gemfile on each of them to stash and un-stash all the time. For me it's faster for me to use Ruby's built in introspection. Most of the time that i'm debugging a full on breakpoint would be overkill and even with a debugger, this info can be useful. It's a little different if you spend most of your time on one app, and can modify the Gemfile and commit at will. Even so it never hurts to have a few different ways to debug up your sleeve. 
If you are fine with your employer doing MITM you can just add their CA cert so OpenSSL will trust the generated certificate.
&gt; I'm curious how OSX developers Not OSX, it was Mac OS 9, before OSX, that used just `\r` as a newline in files. There wasn't a lot of terminal use on OS9, there was no terminal built in, it was not unix. There probably weren't any text console progress bars etc. There were telnet apps for OS9, `\r` worked how you expected in the terminal, as the remote server was handling it (or at any rate, it worked how you expected, I may not be able to explain why, heh. But I'm sure it works how you expect in an ssh session on Windows too). 
great hack!
That was the problem.
Not sure why my opinion should be so easily dismissed. I've spent probably 70 days in the area. 
It depends on why and how it's being killed. You probably want to use [`Signal.trap`](http://ruby-doc.org/core-2.3.0/Signal.html). If all you're trying to do is "restart" the script, you may want to just ignore the appropriate signals completely and allow your process to keep running instead, rather than executing something to restart it or launch another duplicate process before exit. Be careful with this sorta thing though, if you trap all the signals you'd normally use to gracefully shutdown, you might have a more difficult time stopping your processes when you do want to kill them.
Would this work if the script was being terminated due to lack of RAM?
I'm only seeing 8 from today. Are there really 9?
I also only saw 8, but I'm going off what Aaron Patterson said on Twitter: https://twitter.com/tenderlove/status/691707624761356289 One of the threads has 2 posts under it, so maybe that's what he's referring to: https://groups.google.com/forum/#!topic/rubyonrails-security/uh--W4TDwmI
yup. there was no tui in OS9 pretty much, so not an issue. 
As shocking as it may sound: re-write/adjust your script so it doesn't use as much RAM memory. There are many things that could be changed, based on the current description you gave there's very little to go on.
What kind of description might be useful? 
Some things that might make it easier for people to help you: * The code in question * The intent of it * Statistics of how it currently performs
`grep` should probably just be used to search. I'd rather chain together lazy enumerables to perform searching and transforming in one operation.
&gt; They're not always available, I work on lots of open source and don't want a dirty Gemfile on each of them to stash and un-stash all the time. You don't need to touch the Gemfile, just install them globally. 
Here are a few problems I've found with performance tests: * They require custom CI infrastructure. You can't use Travis, Circle, Codeship or whatever other testing service; You won't get anything resembling consistent enough performance to see anything other than drastic changes which usually get caught elsewhere. * Many performance issues only appear under load, e.g. changes that increase GC pressure often don't appear as issues in micro-benchmarks, it takes time under production load for their impact to be seen. * Many performance issues only appear with production sized data sets. A change that introduces an N+1 query or has a missing index likely won't appear in these small tests. In general I would recommend setting up your deployment infrastructure such that you can do partial roll outs. e.g. deploy to 10% of traffic and have the monitoring infrastructure to alert you to any issues that appear.
http://i.imgur.com/OpNPtaJ.jpg
Gg, how is that different to just plain equivalent getter/setter methods defined at the toplevel ? Fondness in upper cases and that fancy dollar sign ? ;-)
That. Btw. unless the foreign code *declares* awareness/safe handling of timeout exceptions, its auditing is just a waste of time.
How would you copy the semantics of [`$COUNTER`](https://github.com/0x0dea/viva/blob/master/examples/counter.rb) without Viva?
&gt; focuses on Ruby's ability to introspect it's own code. **its**
Ah, but "global-like" doesn't cut it; the point is to be a globally accessible (read and write) value that auto-increments every time it's referenced. That's obviously not a very good idea, but it's something that can't be done in Ruby without this silly library. We can get [pretty close](https://eval.in/507878), but the necessary `self.` is a misnomer.
Can you be a bit more specific why toplevel Object instance method is not enough global ? It is accessible from everywhere since point of definition.
&gt; Your approach only works at the top level (by dint of Object being the default definee) The toplevel binding Object instance is accessible from *any* other object. If you need access across namespaces, just define it as instance method, not a singleton: def set_counter(n) define_method(:counter, -&gt; { n += 1 }) end set_counter(-1) module M1 p counter # 0 module M2 def self.foo p counter end class C1 class C2 p counter # 1 def bar p counter end end end end end M1::M2.foo # 2 M1::M2::C1::C2.new.bar # 3 &gt; It breaks if you try to refer to the counter (without setting it) from within a class that isn't Object Missing initialization is not a counter-example and has nothing to do with compared methods. Uninitialized $COUNTER also has no sense. So far it looks like you are only trying reinvent a wheel …
Something similar but about profiling, esp. 3rd party ruby code and extensions ? Tracking memory leaks seems like a tough task but I'd say more common then debugging own code.
http://devopsreactions.tumblr.com/post/135701476645/looking-for-someone-to-assign-the-bug-to
Some questions you'll need to answer: - Are you loading a lot of things from a db? - Are you storing a lot of stuff in a 'persistent' object? Large Hash, Array, etc. - Are you constructing a lot of strings/rendering templates? - Do you use a lot of frameworks and gems (do you really need to load your whole rails stack) - Etc.
A related question for everyone, what methods do you use to track your server stats and usage?
&gt; Fixed Versions: 4.2.5.1, 4.1.14.1 Rails has adopted a policy of fourth dot in version numbers for security-only patches, then? Is this announced/explained/documented anywhere? All of these CVE's are a bit overwhelming, it's hard to tell how severe they really are, and what version of Rails patches them (especially since a few are in Rails dependencies). Will upgrading to 4.2.5.1 or 4.1.14.1 be sufficient to patch? Are there some second-level dependencies which one also need to be sure to update?
&gt; Rails has adopted a policy of fourth dot in version numbers for security-only patches, then? This is the first time I've seen it, too... I guess the rationale behind it is that these security updates needed to be released *immediately*; meanwhile since there is no change whatsoever to the interface, it doesn't really warrant a micro version bump. However, I still would have just gone with the previous version style to avoid confusion - i.e. release 4.2.6 and 4.1.15 (Or *maybe* because these patches felt a bit rushed, this should be deemed more like a "beta fix" - so we'll be seeing a more "formal" release of v4.2.6 etc in a few days?.....)
The problem you're solving is very niche to begin with: def download language_code = params[:code] send_file( "#{Rails.root}/config/locales/#{language_code}.yml", filename: "#{language_code}.yml", type: "application/yml" ) end Depending on the specific use cases for this method, why not just do something like: unless language_code.length == 2 # Handle the error somehow... flash[:error] = "INVALID LANGUAGE CODE" # ... end (If the `language_code` is only 2 characters long, then you don't need to care about sanitising it!) *In general*, you shouldn't damage the user experience by only allowing white-listed characters (or disallowing black-listed characters). You should aim to have no restriction on the file name (other than perhaps its extension); it's what you **do** with that "dangerous" user-supplied data that's important.
&gt; other [data types] include numbers into their encoded structure to represent their length For those who don't know, this is called [TLV (Type-Length-Value)](https://en.wikipedia.org/wiki/Type-length-value) format, and is a common protocol for low-level data storage. (I'm surprised there was no mention of this acronym anywhere in the article!) Excellent write up, it's really interesting to dig into the implementation details about these things every now and then :)
Indeed.
&gt; meanwhile since there is no change whatsoever to the interface, it doesn't really warrant a micro version bump. Bumping the patch (what you call micro) version is for backwards-compatible bug-fixes. Changes to (public) interfaces would require the major version to be bumped. At least when using semver.
Can you send me a PR?
Great ideas, keep 'em coming.
I absolutely will not! No way! Omg. 
Really good write-up on [CVE-2016-0752](https://nvisium.com/blog/2016/01/26/rails-dynamic-render-to-rce-cve-2016-0752/). The implications of 0752 are under-emphasized related to the severity.
http://lmgtfy.com/?q=connection+reset+by+peer 
For the most part, yeah, I do that, and have been doing it since I first started in ruby, before I had ever heard of Metz. Sure, if you really have a tight loop where performance matters, use the iVar directly. I can't recall the last time I had an iVar, rather than a local var, in a tight loop, though. 
Do you have local Code for America brigade? You can create a data visualization application for local police budgets or something.
http://memestorage.com/_nw/61/68138992.jpg
Yes, you should. And no, it's not a big deal if you don't.
Why the heck was file system root on the template lookup paths? Is that what the Rails patch fixed?
How about an app that collects ideas for beginner projects, then presents them to the next person who comes along asking this question.
ah, that it respects a leading `/`in a filepath when it shoudln't? Is that how he inserted root into the lookup string? 
What a beautiful site!
&gt; When writting small libraries, you often see a lot of projects having benchmarks folders such as RSpec itself. These metrics ensure that certain methods perform at expected level of speed and subsequent releases don't degrade the performance. Absolutely and I encourage that. But you'll note that they are almost never included as part of the core test suite, largely because of my first point. I'd also encourage reading up on `benchmark-ips`.
Mmm, I'm not convinced. From a YAGNI standpoint, mainly. Why add complexity to your code that you don't know you need yet? That said, I'd say it's pretty negligible either way. I would allow either one in a code review.
I've noticed that leaks occur when a background job errors out (throws an exception). If a bunch of jobs throw errors, you can quickly run out of connections.
Ugh at weird operators. This code may be more readable to Haskell folks but I guarantee it's less readable to your average Rubyist reviewing the code. When in Rome!
The main advantage of wrapping is that it future-proofs the code in case you ever want to change the instance variable into something more complicated (a calculation, a variable from some other context, etc.). Now the real debate is whether such future-proofing is something you should *always* be doing. It seems like a bit of a drag in a language as simple and elegant as Ruby. I certainly don't do it all the time, but I think it's worth thinking about every time you use an instance variable.
Feed reader.
&gt; "Cleaner Ruby validations" Actually it looks like you puked all over your text editor...
The most concerning thing in this article is the use of `rescue` to swallow exceptions and discard any information that would help debug a real problem. 
I am not using rails. Can I edit this another way? 
While I used Either for multistep validation, it's still a foreign concept to Ruby programmers and most of them would have hard time figuring out what the hell is going on, especially when weird operators are used. It's much more at home in languages with more focus on functional programming like Scala. Compare Ruby code with this one object AvatarValidator { def validate(file: File) : \/[String, File] = for { properSize &lt;- checkSize(file) properType &lt;- checkType(properSize) properDim &lt;- checkDim(properType) } yield properDim def checkSize(file: File) = if(file.length() &gt; 5 * 1000 * 1000) file.right[String] else "too large".left[File] def checkType(file:File) = { if(Seq("png$", "jpg$", "gif$").forall(file.getName.matches)) file.right[String] else "invalid type".left[File] } def checkDim(file: File): \/[String, File] = ??? } The main method is very clean and uses the same syntax as the list comprehension.
Typos in ivars will silently evaluate to nil, making it more difficult to trace them. A NoMethodError tells you exactly where it came from.
I don't want to be a jerk here, but probably you will get more answers in StackOverflow than in this subreddit. And tbh, without **any** code example, all answers you will get are wild guesses. A timeout can occur because of the pooling, because the code is not optimized, because a random error that doesn't let go of the connection, because the planets aligned, because obama... get the picture?
Why not just use this? attr_reader :stuff private attr_reader :private_stuff
I guess the focus is exactly the reason for specific syntax being a part of the language e.g. Microsoft introduced LINQ syntax alongside the libraries that use FP-idioms.
&gt;If you have references to an instance variable sprinkled around your class and later change the variable to a method (because you add a calculation to it for example) you'll have to manage these dependencies by changing your code in multiple locations. Rubymine handles this for me but so would a simple search and replace in most cases. It's not like your classes are going to be huge.
That's only one place to make the mistake though, instead of every occurrence.
Reddit clone
Or just do file caching in development and delete the cache directory when you want to refresh the cache.
It seems like we agree that decreasing identity-based discrimination is a good thing. I'm unsure what your position is on whether diversity should always be increased, no matter the situation. I do not think that, though I think there are *many* situations in our culture where it has been depressed for bad reasons. I'm unsure what your position is on using codes of conduct as a Trojan horse method of "punishing" people who are part of a software project community, via community means (rather than individual choices), based on personal behavior outside the project scope. I'm uncomfortable with that, and I have a hard time deciding where those lines should be drawn. 
You didn't include any info about what doesn't work.
I got this: NoMethodError: undefined method `first' for "cheese":String from (irb):64:in `block in remove_unwanted_duplicates' from (irb):64:in `map' from (irb):64:in `remove_unwanted_duplicates' from (irb):12:in `create_list' from (irb):88 from /Users/jeffmo/.rvm/rubies/ruby-2.1.2/bin/irb:11:in `&lt;main&gt;' It looks to me like you don't actually have a list of pairs in @pairs_array, in this line of code: @pairs_array.map{ |pair| pair.first } Also, that line of code would have no effect, anyway, since Array#map doesn't change the receiver (@pairs_array). It just returns another array, based on the block, and you're not using the return value for anything.
Thanks for the feedback. I've included the error that it was raising in the original post and I'll look into the puts thing. The thing is that I knew that error was happening but I have no idea how to fix it.
That's the same error I saw, already discussed [here](https://www.reddit.com/r/ruby/comments/42xtnw/ive_fubard_up_my_code_please_help/czdw0hb). That line simply doesn't do anything useful, so you could try taking it out. However, I think you're going to want to try to validate the assumptions you're making. For example, you probably think `@pairs_array` should have a certain structure. Try outputting it, just after you've calculated it, like so: puts @pairs_array.inspect If it has the right value, then the problem is probably after that in your flow. If it has the wrong value, look for problems in the calculation of the variable. Repeating this procedure for each step in the process will probably go a long way to illustrating where your errors are.
I see what you mean. Is this where I'd place that line of code? def remove_unwanted_duplicates @pairs_array.map{ |pair| pair.first } puts @pairs_array.inspect duplicate_sequences = identify_duplicate_sequences @pairs_array.reject! do |sequence, original| duplicate_sequences.include? sequence end end
Can you explain why it is not possible currently with rails 4?
Nitpicking here, but GoF is not a taxonomy for architecture, it's a taxonomy for object oriented design. A proxy object doesn't need to represent a "distant" one necessarily, but it does need to implement the same interface.
No, that's *after* the error. I would do this: def create_list @pairs_array = create_sequence_word_pairs puts @pairs_array.inspect @pairs_array = remove_unwanted_duplicates @pairs_array = alphabetize_pairs_by_sequence output_to_file end There are lots of these debugging techniques; this is just one that's easy to explain. You could also use irb, and just try running "pieces" of your code there, just like you are doing in your run.rb file. You'd type lines like this: require_relative 'processor' processor = Processor.new("dictionary.txt", "sequence_list.txt") processor.create_sequence_word_pairs That way, you're just testing that one small piece of your code, to see if it works right. 
There's a lot wrong with this code where best practices are concerned, but the quickest changes you can make to get it working are: Change your `create_list` method to def create_list create_sequence_word_pairs remove_unwanted_duplicates alphabetize_pairs_by_sequence output_to_file end And change the `sort_by` in the `alphabetize_pairs_by_sequence` method to `sort_by!` so it modifies the receiver.
Also, as [mentioned by /u/JeffMo](https://www.reddit.com/r/ruby/comments/42xtnw/ive_fubard_up_my_code_please_help/czdw0hb), the line `@pairs_array.map{ |pair| pair.first }` doesn't actually do anything because the return value isn't stored.
omfg you are a godsend! i'm definitely gonna keep learning but thanks so much!!
good god can you tell me how you figured that out?
The link doesn't have any benchmarks so I'm not sure how they are saying whether or not Ruby 2.3 is faster. Object allocation in Ruby isn't inherently bad and when you have nested loops that's going to happen. If you're seriously worried about allocating too many objects in nested "bad" iterators then you can implement them yourself and just reuse the object you've allocated from your outer loop. That being said this is one of those micro optimizations you wouldn't do unless you were auditing your code and found a specific case where this was actually an issue. It's worth noting - I have the book referenced in the article and I think it's pretty solid. I was just disappointed by the blog post talking about performance without any benchmarks.
&gt; I'm unsure what your position is on whether diversity should always be increased, no matter the situation. I can accept the possibility that there is a situation where diversity shouldn't be increased, but it's difficult for me to imagine one, especially in this context. Have you encountered such situations in OSS? &gt; I'm unsure what your position is on using codes of conduct as a Trojan horse method of "punishing" people who are part of a software project community, via community means (rather than individual choices), based on personal behavior outside the project scope. I'm uncomfortable with that, and I have a hard time deciding where those lines should be drawn. The concepts of "personal behavior" and "project scope" aren't easily separated in OSS because OSS developers very often build their personal identities around their projects and then don't clearly state the separation between the two. I'm not sure what you're referring to in the first part of that paragraph. Are you thinking of a particular event? Asking people to make their own values public and also act on them doesn't match my idea of a Trojan horse. It's confrontational in a way many people aren't used to, but it's not inherently hostile or malicious, and there's nothing sneaky about it.
The word "worker" is incredibly vague and overused too. Trust me, I know.
As the book says, one of the largest problems with ruby performance is garbage collection. Therefore, he is going from the Axiom ("proven" previously in the book) that garbage collection is bad and using that to "prove" object allocation is bad (since any object allocated is one that needs to be collected). 
Quick benchmarks using the second code example between 2.2.4 and 2.3.0: ruby 2.3.0p0 264.206 (±36.3%) i/s - 1.144k ruby 2.2.4p230 185.468 (± 9.7%) i/s - 936.000
Please format your code so that it's readable, or post it into a gist on GitHub.
The Trojan horse comment meant to describe a situation where people advocate for codes, get them adopted by arguments like "how can anyone be FOR harassment?", and then use the code to agitate for the community taking action way outside the scope that most people had in mind when it was adopted.
&gt; Have you encountered such situations in OSS? As I said, "I think there are many situations in our culture where [diversity] has been depressed for bad reasons." But I was speaking categorically, when I wrote the portion you are now questioning. I think it's important to remember that the goal in ALL of these efforts is to enhance personal choice of endeavor, and to minimize, as far as is practical, barriers to those personal choices that are not rationally based. Or at least I think that's what the goal should be. The direct answer to your question is "no," but I have experienced similar cases where people were agitating for diversity increase, even if that meant choosing an unqualified candidate over a qualified one. There are better and worse ways to *implement* diversity increase, in my view, and I also think one has to be cognizant that calculating the "right" demographics is more complicated than most people give it credit for being.
Concur, format your code better. For something possibly useful, look into Nokogiri or Mechanize to do the web scraping for you. Also, you appear to be mixing global scope variables, those starting with $, with local scope variables, those without the $. You actually use $distance_2 without ever defining it. You defined distance_2. $distance_2 != distance_2 And every value after is local scoped in the xpath gunk, but in the CSV a global variable is used. You don't have to go to // for every single xpath query. You can go the largest common denominator and then go down further. base_1 = @driver.find_element(:xpath, "//div[@id='group_0_0']/div/div/div[3]/div") ext_1 = base_1.find_element(:xpath, "tail of chain for this piece") blah_1 = base_1.find_element(:xpath, "tail of the chain for this piece") That should help you clean up this code to a more readable state.
It's hard to take that tactic seriously because I don't see how it could pose a risk in practice. If the project leader agrees that the proposed action aligns with the code, then that interpretation was what the project leader intended all along. The agendas were aligned from the start. If the project leader disagrees, then there's an opportunity to clarify the code or its interpretation, but they're not under any obligation to take the proposed action based on (in their view) a misinterpretation. The agendas were different, but the agenda of the project leader takes precedence.
Fair enough, but I think you're assuming unified leadership. Some of the cases that I've seen seem to be cases where the person pushing codes wants to assert/usurp leadership, but maybe that's a problem in and of itself.
sounds like a bug in rufus scheduler not checking AR db connections back in in an ensure. 
I'm not seeing this being too useful, with hard-coded wall clock time limits. The actual time something takes will depend on the machine it's run on, as well as what else is going on on that machine at the time. On a PaaS CI like travis, I think they're going to be all over the place. Especially for micro-benchmarking like this gem encourages. I think it will vary too much to make this kind of approach useful. Although I'd be interested to hear from someone who has found this approach actually useful. Thinking about it, a more useful approach might be to profile a test run and record the time it took, adding to a stored series somewhere, so you can see performance difference over time. And then it could warn you (I still don't think I'd want a spec failure) if, say, the current iteration was more than 10% higher than the median time in last 10 iterations or something. 
I don't necessarily directly disagree with you, but I *will* sarcastically say "oh wow, utilizing one of the most popular browsers with the most popular web tech, such cumber"
There's a subtle but meaning difference between background jobs and message queue. The former implies a single app, the latter implies communication between different apps (often maintained by different teams). The fact that jobs use a queue data structure just confuses things even more.
I don't think that's a valuable distinction at the level of discussing the technology itself. Certainly a queuing library like Sidekiq whose API binds to classes instead of message schemas (e.g. `Foo.perform` vs. `queue.write "Foo"`) is attempting to enable a different usage pattern, but ultimately a background job library is just turning `Foo.perform` into a standard schema anyways. We have one application at my job, but we write messages to queues to coordinate different service interactions. The underlying technology is not much different to something like Sidekiq. I'll concede that it's possible that the distinction is valuable to a lot of users because they perceive a queue as being more elaborate or cumbersome (and it often is, in practice). But then again I've worked with a lot of programmers who don't realize the implications of distributed messaging inherent in `Foo.perform` (eventual consistency, delivery guarantees, ordering, etc.). So from my view, I feel like calling it by what it *is* rather than by how it's *used* would be helpful to keep programmers mindful about the underlying traits. Okay, I think I'm just rambling now. Cheers!
If there was a way to totally replace the node runtime in electron with ruby, that would be the way to do it. Otherwise, you might as well be writing the electron app in js. Packaging an app with Chromium and Node.js is already fat enough; adding ruby to the mix is unnecessary. 
qt-bindings is only using Qt4.8, and is not really ruby-ish (if that is a concern), but it works good enough. 
Did I missed something or is the "issue" implementation specific and need not apply to JRuby, Opal or some forthcoming CRuby version, for example ? Btw. is not to be expected `Enumerable#each_with_index` would require creation of two objects anyway ? Copy of an element as it may be mutated in the block, and the fixnum index obviously …
I see no reason why you couldn't just paste that code into a Rails 4 app, and use the same app server mentioned in the article. It depends on the app server restarting when you create a file called restart.txt and not anything new in Rails.
jruby
Go here https://github.com/antirez/lamernews fork the project. Refactor it to have a nicer gui. 
Yes, it's definitely implementation specific. My guess is that it's easier to pass index to a block if it's stored in a Ruby object. I have no idea how JRuby works in this case. It's been several years since I seriously looked at it. 
 File.read('words.txt') .split .flat_map{ |str| str.chars.each_cons(4).map(&amp;:join).uniq.zip [str].cycle } .sort_by{ |sequence, _| sequence.downcase } .map{ |sequence, word| "#{sequence} #{word}" } .join(?\n) .display 
In one word: libraries. Python isn't too different from Ruby as a language, and even inferior in many regards, but it has the relevant libraries, and that makes all the difference.
There's an excellent post from Toby Clemson on Martin Fowler's page about testing strategies when using external services: http://martinfowler.com/articles/microservice-testing/
So the real answer, as others have said, is "there aren't the ML libraries available." As to why they aren't available, a huge reason is that ruby is just too slow. Numpy solves this problem for python, and Java is just plain fast. I did some messing around with the Java libraries via JRuby a few years back and found it to be a pretty good experience. I'd try that route.
Yeah, and I'll note that earlier in the discussion, we were talking about some various options: * Adopting a code unchanged. * Selecting from among various codes. (some overlap with the first) * Rolling your own code. You correctly noted that doing something entirely on your own has risks, and I also asserted that adopting someone else's code wholesale has risks. It seems like we might agree that careful consideration of the code in question (before adoption) is a good thing, perhaps by the BFDL. Gathering opinions and discussing with at least some key members of the community seems like it would be beneficial, as well. And there's another option here: tweaking an existing code, if there are certain provisions that don't fit the community or the BDFL's vision. I think my biggest "fear" when it comes to these things is that adoption of a code might lead to too much focus on code-related disputes, as opposed to the community's core mission. One way to minimize this is to make sure whatever code you adopt, create, or modify for your purpose isn't going to lead to unnecessary strife. I think it's a good thing that people are talking about this, and publishing both prospective codes and various accounts of community experience with them. But there are also downsides to consider, related to adopting any code at all ("if it ain't broke, don't fix it") or to adopting a code that has flaws that will lead to energy wasted on correcting them. I am glad that the discussion is ongoing, however.
Hope [SciRuby](http://sciruby.com/) would solve this problem for Ruby in the near future …
Python can handle primitive types much better than ruby can at the moment. And has much less of an overhead, compared to ruby where almost everything is a FixNum etc, where Python can see the actual integer or float and calculations can run at close to C++ speeds. When you factor this into a ML program why use a language that's going to be significantly slower than the other? I love ruby but some things are better done in another language. 
Not necessarily true and lets talk about why. First of all, Java and Python are both used more academically. Why? Both are pretty good examples of functional object oriented languages that don't have a whole lot of frills (as far as the language itself is concerned) and are closer to the true aim of CS courses, learning C/C++. Machine learning, (at least right now) is mostly an academic pursuit, and so those students writing ML code are writing it in these languages. Second, Java and Python have massive speed to Ruby. However, people don't program in Ruby for speed, they do it for a combination of maintainability and syntax power. Is Ruby inherently bad at machine learning? I'd disagree. You can write neural networks, just not amazingly fast neural networks. I'd make the argument that Ruby is actually better for writing machine learning because you can wrap all the machine learning code in a DSL and be able to write any neural network you can imagine much easier. In the coming year for ruby there is a lot of talks about a faster MRI and some independent Ruby interpreter projects that are aiming to speed things up. 
I shared most of these ideas with my class. It went to a vote and we chose the following projects to build: * Foosball Leaderboard and Matchmaking APP (we play a lot of foosball) * Sports Jagron Generator for Uninitiated Girlfriends * Card Game Rule Generator * Where Should I Eat App * Break Up App (Sends emails and SMS to break up with someone) We have another project next week which will be more complex. More ideas are great. I'll post links when they are done. 
Since this post, [dry-validations has added localisation](https://github.com/dryrb/dry-validation/blob/44cc0a2ec340536e80d4c47322534947ec7e2fa1/lib/dry/validation/messages/abstract.rb#L16). Here are [some examples of error messages](https://github.com/dryrb/dry-validation/wiki/Error-Messages). As for how to implement this yourself, I think you're on the right track. I sort-of have an implementation, but it lacks localisation and I don't know how well it will work when validation fails deep within a nested structure. I'm using it to validate form data in a Rails app, which is usually pretty flat, so I haven't hit that hurdle yet. I think the way to go is for the validation library to return an array of _symbolic_ errors – each error being something like: { key_path: [:user, :password], reason: :too_short, validator: LengthValidator, args: { min: 6, max: 64 } } And the view layer is responsible for converting this into something human-readable, including localisation, like: "Password must be 6 characters or more" ActiveModel::Validations and dry-validations both do this by looking up a list of paths in a YAML file, and taking the first one that is found. So the paths might be: user.password.too_short password.too_short length_validator.too_short With a default YAML file like: en: length_validator: too_short: "#{key_path.last} must be #{args.min} characters or more" As you can see from the `key_path.last`, it's not ideal for nested data structures, but I haven't fully figured that part out yet. The error messages are way more difficult than the actual validation! 
Cool! Thanks for the info.
It's pretty simple. Every method you call is received by some object. The object receiving the method call is the receiver. If you mention the object in the call, that's 'explicit'. If you call a method in the same object as the context without mentioning 'self', that's 'implicit'. class Foo def foo "foo" end def bar self.foo #explicit receiver, `self` foo # calls the same method on the same object but with implicit receiver since we don't mention it explicitly end end obj = Foo.new obj.foo # explicit receiver, `obj` That's it, no big deal. An implicit receiver in ruby is always "self", so it could just be called "implicit self" too. 
 &gt;If you call a method in the same object as the context without mentioning 'self', that's ~~explicit~~ implicit*. Great reply otherwise. 
Other than readability, how is Python2 or 3 inferior to Ruby? 
As far as the syntax, `before_action` is just a class method that the BlogsController class has. It has it because it's a subclass of ApplicationController, which in a Rails app is a sub-class of `ActionController::Base`, which defines the `before_action` method. In ruby, you can execute code in the class body itself, and you can call any methods that are available in that context. You can simulate this yourself, it's no big deal: class MySuperClass def self.do_something(argument) puts "You just called me with #{argument}!" end end class MySubClass &lt; MySuperClass do_something "YES" # Parens are optional in ruby for method calls, so same thing: # do_something("YES") def more_methods "whatever" end end With that simulation, at the point `MySubClass` is loaded by ruby, it'll print out ""You just called me with YES!" Our example "do_something" class method isn't very useful. Rails defines a `before_action` method that does something more useful -- it takes the name of a method, and calls that method before any Rails controller action, or before only certain Rails controller actions as in you case with the `only` argument. But the useful things it does aren't about syntax, and aren't built into ruby, it's just a method that Rails defines. We don't really need to know _how_ Rails implements it to use it, just what it does. If we were curious, we could try to find it in the Rails source code, which may or may not be easy to follow for this particular method. (With just a bit of looking, I wasn't able to find it in Rails, it's defined in some clever meta-programming way probably, as Rails sometimes does). Syntactically, all that's going on there is you're calling a class method. &gt; Are the edit and show methods symbols? Indeed they are. Rails `before_action` takes method names as symbols. Symbols are the standard way to "talk about" methods, to refer to methods by name in code. But they're just symbols, it's up to the implementation of the Rails `before_action` method to do something useful with them, like interpret them as the name of methods and make things work. &gt; why does only have a colon after it? Ah. This is just a syntactical shortcut Ruby provides for supplying Hashes as arguments in methods, as the last argument position. All of these are equivalent in ruby: method_name(first_argument, { :key =&gt; :value }) method_name(first_argument, key: :value) method_name first_argument, {:key =&gt; :value} method_name first_argument, :key =&gt; :value method_name first_argument key: :value All of those are identical: We are calling a method `method_name`, and passing it two arguments. The first is a variable `first_argument`, the second is a Hash, with one key, the symbol `:key`, pointing to a value, the symbol `:value`. Ruby doesn't require parens on method calls. And when the _last_ argument to a method call is a Hash, ruby a) let's you leave off the `{` and `}` markers usually used for a Hash literal, and b) for symbol keys, let's you do `symbol_name: value` instead of `:symbol_name =&gt; value`. Just some syntactical shortcuts to make method calls read more naturally. A final Hash argument with Symbol keys is commonly used to pass in named parameters to a Ruby method, so it's nice to make them read nicer. (In recent Ruby versions there's actually built-in support for named arguments to a method, but it's based on the previous conventions of using a Hash as a final argument, so before we even talk or look at that, it's good to understand the basic Hash stuff) 
I cant respect anyone who doesn't limit their lines to 80 characters unless there is a very good reason. 
&gt; How many of those 13,000 are solo projects [Like this one?](https://github.com/rubyforcats/r4c_projects_and_todos) 
[This kind of sucks that i can't use gems yet :(](https://github.com/jruby/jruby/wiki/Truffle), but I'm excited for the future &gt;JRuby+Truffle does not support RubyGems yet...
It does not suck, it's Kind of implicit. RubyGems support will have to work in order to support the full Rails Stack, so its just a matter of when. &gt; We're starting to be at the stage where simple gems and applications that don't have native code and don't use some parts of the standard library like openssl may be able to run. Gems like Webrick, Sinatra and Active Support already work. During 2016 we'll be getting the rest of the Rails stack working more or less, and we'll be testing other important gems.
Ruby is not considered bad for ML. There are also good tutorials and libraries. Python might happen to have more, but that doesn't make it *better for ML*. Also, with JRuby you can use any and all Java libraries. Educate yourself a bit more before saying X is bad for Y. 
i'm assuming you meant to reply to me. I should have said that "this sucks for now" or "can't wait" so people don't think i'm being hostile or something. Thats why i said i'm excited for the future. I know they are going to add rubygems integration.
Just a quick warning that you're not writing ruby here -- you're writing rails. `before_action` is an ApplicationController thing, as is calling `#find` right on a class (which you can set up in regular ruby, but isn't idiomatic outside of ActiveRecord classes). I've found it useful to think of Rails as a "Ruby-inspired" language, since obviously most stuff is the same, but the idioms are different and Rails [monkey-patches so much stuff](http://edgeguides.rubyonrails.org/active_support_core_extensions.html) that it can be confusing.
I hope more people would take this advice to heart. Changing state through `model.valid?` is just insane. ActiveRecord mutating the `errors` attribute after calls to `valid?` is already a terrible design, no need to make our lives even harder.
&gt; But the article does not propose to never use before_validation. It discusses a very specific situation, which your described problem does not fit. I get that; I was just pointing out a simple common scenario where using a `before_validation` hook **is** a good idea. I don't want beginners to get an impression like "don't use this method" when we are only discussing one particular use case.
I think the idea with Volt is stay light and modular. Let other pieces or gems take up the room or a stdlib so the framework itself can be light and flexible. That said, I have no special insight into the project, it's just what i would do.
WebSockets alone don't provide all of Volt's benefits. Check out this video [from RubyConf 2014](https://youtu.be/7i6AL7Walc4) about Volt. I think he does a great job of explaining the main problem (which is also arguably its biggest benefit) of the client/server disconnect. You just have duplicate so many decisions and code on both sides. So, until you don't have to do that, I think there is a valid reason to try out a Volt-like architecture (I think MeteorJS is a very similar idea?) I still start new apps with Rails. Don't get me wrong. But Volt is very interesting to me, I'm keeping my eye on it.
Totally agreed. But it seems to me the front-back end synchonicity coudl be gemmed up from Volt, then you get all the connectivity and features of rails without having to build them for volt. I guess the thing I could be overlooking is that what volt 'does' is fundamentally incompatible with rails.
Does anyone have recommendations for a static site builder that's friendly to non-devs? I like the simplicity and security of static sites, but I have content producers that need to add/modify the site without having to know ruby or html or markdown (i.e. they want a wysiwyg)
You can use the best of both worlds e.g. use WordPress for your client and than export to a static site or sync to git (many tools exist already). Or just use WordPress (nothing wrong) ;-) Cheers. PS: Another option is using content editors for Jekyll (GitHub) e.g. MeetHyde, Utterson, etc. 
Knowledge of Ruby, interest in mentoring students, desire to improve tools for doing science in Ruby.
Ah. I think I'm getting it. So explicit receivers will always be an instance of a Class object? And implicit receivers was always be the Class object itself? class Person @@count = 0 def initialize(name) @name = name end private def self.current_count @@count end end bill = Person.new('Bill') bill.current_count #would return NoMethodError: private method `current_count' called for #&lt;Person:0x007fca7f19d4e8 @name="Bill"&gt; Person.current_count #would work though. ________________ class Person @@count = 0 attr_accessor :count def initialize(name) @name = name end def instance_count current_count end private def current_count @@count end end [1] pry(main)&gt; bill = Person.new('Bill') =&gt; #&lt;Person:0x007f83471b5068 @name="Bill"&gt; [2] pry(main)&gt; bill.instance_count =&gt; 0 Why does this work though? Aren't private methods only callable by explicit receivers? I thought `bill` being an instance of a Class object would be considered an explicit receiver but it's able to indirectly call on the private `current_count` method through `instance_count` method.
http://www.sinatrarb.com/intro.html should be all you need.
I'm still confused tbh. I think I may be lacking context or something. Thanks for the help though. I'm gonna try reading some more StackOverflow threads and see if this will click for me. There's also some Ruby books I want to eventually go through. Yeah, I don't have a good understanding of `self` or OO in general, that's probably why this isn't really clicking for me.
http://shop.oreilly.com/product/mobile/0636920019664.do It's a pretty good book. I enjoyed it. But, as others have mentioned, Sinatra hasn't changed much over the years and their website and tutorials found around online are sufficient for most. You could also look at volt if you're interested in Ruby web frameworks.
What is it you actually would like to know? As others have mentioned, Sinatra hasn't changed that much, so most resources should be more or less up-to-date. And you can find a lot of useful information on the homepage. My advice would be to pick a small project and try to realize it with Sinatra. If any specific questions come up, feel free to ask. ;)
I suspect the author would contend that he isn't sharing state between his tests simply because each test uses a different variable, but he's playing with fire. He's working around a deliberate feature of RSpec, and of every other testing framework I'm familiar with, which purposefully tears down application state between tests. This feature is a good thing because it reduces the likelihood of having tests interfere with each other; causing false negatives and, worse, false positives. 
I'm a seasoned .NET developer who works mostly on Linux but find as great as .NET is (and no haters here please, both .NET and Mono runtimes are highly performant and great pieces of engineering) there are better alternatives for knocking out things quickly. I thought Volt might do the trick but I've switched to Rails because at the end of the day there's something to be said for the tried and tested. I tried Volt over a year ago but it was clear it was nowhere near ready for building production apps and we're still here a year later and you can still only run apps on Mongo. I think the problem Volt is trying to solve is a worthy one - allow developers to create truly isomorphic apps - but it's just not there yet.
It's OK if they're a bit old, sinatra hasn't changed all that much in quite a long time. That's not to say that it's abandoned or anything, but tutorials from probably 5 years ago might still be fine. Especially for basic usage.
No need for a dedicated mentor... You have the community! Hit us up, here or stack overflow.
Thanks dude, this community is awesome. are you a rails developer ? I have a question, The hole purpose of learning ruby is to learn rails easier. Should I first know ruby 100% before moving to rails ?
i dont go on skype, but you can email me if you want at nameless.identity1@gmail.com i remember when I was beginning Ruby I felt the same way about wanting a mentor, just to understand hard bits of code here and there. You really should get the basics of Ruby down before learning Rails. There are a lot of tutorials that teach you the "bare minimum" Ruby and then go right into Rails. This is fine but keep in mind that writing Rails is really writing Ruby, and you're not going to be able to do that well if you don't have the fundamentals down. That being said I dont recommend focusing too much on algorithms or brain-teaser coding challenges. Get the fundamentals down (which you already have done if you've completed Learn Ruby the Hard Way) and then move on to Rails or Sinatra. I actually recommend Sinatra first because it is easier. Rails is like a more complex version of Sinatra. also, don't be scared of documentation. It's a scary word, but often times they include high quality "getting started" guides. 
Evan Phoenix created it, Engine Yard paid him to work on it. He left Engine Yard in 2013 and they stopped contributing to the project. It has been maintained by the community since then. http://rubinius.com/2016/01/07/rubinius-3-0-the-third-epoch/ https://github.com/rubinius/rubinius/releases
Check out the comments to the article. `[]=` used to be an alias for `write_attribute` in Rails at some point, but it is now recommended to just use `super`. &gt; putting a view layer concern in your domain As I mentioned at the bottom, I usually do it in Form/Command object, not the ActiveRecord model itself.
Exactly. No issues with Evan.
Single threaded? Wait... wasn't rbx all about allowing **more** threads and parallelism without the GIL?
Definitely, but we were comparing how well would run *our* application with rubinius and possibly rewrite to utilize multiple threads. Not all program's logic can benefit from parallel processing and some parts run in one thread despite you like it or not. When the performance of rbx was about 40% worse we lost an interest in another effort even if multithreaded code would outweight the loss in single-threaded. Btw. even with CRuby, I/O bound code and extensions may run without GIL, so this is a case specific.
See rubinius blog and his twitter profile.
puma is indeed great. 
&gt; At last count there are over 13,000 projects on Github that have adopted it. mmh, think most of them doesn't know that they have one, since bundler does add it on bundle gem
I think you should have a solid understanding. It makes everything less magical. You should also have a solid understanding of HTML and CSS and a little JavaScript.
I think rethink was ryan's next target, but when he started (2013 I think?) mongo probably seemed a more stable/mature target.
There was work started last I checked to move mongo specific code behind an adapter that many/any db's could be used with, but sounds like that still hasn't been completed.
Ruby is the language. Rails is the framework. Rails is a toolbox filled with things that make developing websites easier. Rails will do stuff that seems magical... It's not though, it's just very 'name-y'. Look for patterns and it will start to make sense. Welcome to the game. Have fun with it! 
Brixen is abrasive, and I am not a user of rbx for primarily that reason, but I don't see any evidence he is deluded. It's worrisome to me, though, how quickly the ruby community that prides itself on being "nice" ostracizes and dehumanizes those it doesn't like.
I would strongly recommend against inventing your own authentication system. It's far too easy to get something catastrophically wrong. You can use `devise` or `sorcery` and authenticate against `ldap` quite easily. 
I won't be inventing my own authentication system. The authenticators will most likely end up as wrappers around an existing auth systems. I haven't figured out the next step yet.
`code` would be an array. The two dot notation is a range (like 1..5 is similar to a list of those numbers) . In Ruby when using array indexes you can use negative values to go backwards from the end. All together it takes a part of the array starting from position `i` up to the last element of the array.
Meh, writing your own crypto? Yes, you're gonna die. Your own auth using existing crypto? Not so much.
Depends on what the auth does. I've seen plenty of attempts at 'remember me' functionality that had blatant security flaws despite using off the shelf crypto. Same goes for confirmation emails, forgot your password systems, etc. 
Not all instances of the application are going to use the same setup. Some may use LDAP, some may use username/password. All of them will use some combination of firstname, lastname, and social security number for authenticating customers. I'm trying to come up with a modular way all of these scenarios can work in the same codebase.
The normal way to handle that is to have multiple `User` models which are configured to use different auth methods. e.g. `AdminUser` vs `CustomerUser`.
How will that solve my problem? `AdminUser`s and `CustomerUser`s can still have different authentication methods depending on what server they're on.
It's really hard to answer that question without knowing why or how your creating this segmentation. Are you running entirely separate instance of the application, e.g. with it's own database and everything isolated or are you talking about different app servers using the same datastores with configuration per user or node (for some reason) ?
Well, a simple example using `devise` might look like: class AdminUser devise Config[:auth_method] if Config[:omniauth_enabled] devise :omniauthable, omniauth_providers: Config[:omniauth_providers] end end Config is just some global config object you load from `yml` or the ENV during start up. It would contain something like: { auth_method: :database_authenticatable, ( or :ldap_authenticatable or some other custom auth method) omniauth_enabled: true, omniauth_providers: [:google_oauth2] } There are other ways to do this of course, e.g. you could `class_eval` the config into the user model in an initializer. In practice I would probably wrap the situations up in concerns and include those conditionally into the user model to keep them separated and because you will need extra code in the model for some auth methods, e.g. `google_oauth2` needs a `self.find_for_google_oauth2` method defined. 
Since others answered correctly, I'll just say that it's one of those frustrating Ruby idioms that are hard to Google. So, don't feel bad. 
yay, im not so stupid after all
Thanks! It was important to see it well enough (currently 85% upvoted) received. I've started on my next refactoring yesterday. Do you think it makes sense to post it here once I've finished it?
I've made several bots for different subreddits. Recently I've uploaded it to GitHub: https://github.com/Nakilon/reddit_bot and published as a gem: https://rubygems.org/gems/reddit_bot
What you have shown us looks fine. How you determine which authenticator to use will be the interesting bit.
That's fair, I'm sure you have a much more informed assessment than I do :)
What you've shown looks pretty normal. Dependency injection's a fairly accepted pattern.
&gt;We want the users of our gem to be able to do something like this: `Ravelry.configure { |config| config.secret_key = ... }` Well, I don't want that. It prevents me from configuring the gem in different ways in the same app. E.g. if I have two accounts at an external service (and therefore different secret keys). And reconfiguring it every time I want to use it, isn't really an option because I might run into race conditions. I have no idea why this became common practice in the first place. Changing state of some global constant is seldom acceptable. So, please just provide something like `Ravelry.new(secret_key: 'foo')` and let the user assign the result to a constant if he wants to have global access to it.
How do you know it's a slice when you're seeing it for the first time?
Just the thought of ssn mixed with authentication makes the hair stand up on the back of my neck...do you really need to use it?
You're not stupid *at all*. Unfamiliarity is not stupidity. In fact, you asked a good question in the right forum, which is like the best definition of good judgement.
Followed! Thanks Andy :) 
Sorry about the signup form (not my idea). Just fill it out with any old data (but a real e-mail address) and you'll immediately get a link to view the recorded webcast via e-mail. It's a lightning tour of the Ruby language, its core classes, its standard library, and third party Ruby gems. If you're on the fence about learning Ruby, this will give you an idea of what the language can do for you!
A very good question, I might benchmark Erubis and my own Erbse implementation. Are you interested in helping?
How? 
Yeah this is mainly what I thought the reason was. Besides poor memory performance something else I heard is to do with multi-threading or parallelism? Is this true?
I'm not sure I ever really feel comfortable with sharing variables across tests, even if they are rebuilt between test runs. It's far better to create an abstraction that returns the value you need that's common across several tests, and use that abstraction in each test, in my view: specify "my test" do foo = SomethingThatReturnsAFoo.get # end Is better than: let :foo do ... end specify "my test" do foo # end You should never have to look far to find the different dependencies in play for a given test.
&gt; Well, I don't want that. It prevents me from configuring the gem in different ways in the same app. It's trivial to support both approaches and many gems do. &gt; I have no idea why this became common practice in the first place. Changing state of some global constant is seldom acceptable. It became common because it's the best solution in the majority of cases. I have never seen a non-trivial application that didn't have singletons, there is absolutely no reason to be scared of them, they are extremely useful. 
If your concern is performance then there is a much more important point missing in this post: # Don't write to the database. None of the tests used as examples in this post needed to write to the database at all. 
&gt; It's trivial to support both approaches and many gems do. Yeah, many do, but there is still the occasional gem which doesn't. So I think it's worth raising that concern. E.g. Airbrake seems to only support `Airbrake.configure`. &gt; there is absolutely no reason to be scared of them I don't buy that. Testability and extensibility suffer. They are super convenient in a small code base, though.
Check out this site...I use it when I have to write some regex. http://rubular.com/
Self plug: I wrote a gem to do exactly this a while back - https://github.com/markrebec/canfig It's super flexible, and allows for global or class/instance configuration as discussed in the threads here. PRs and contributions are always welcome!
Yep, awesome tool! Highly recommend donating - I've definitely gotten my money's worth. 
Add and rss feed and I will read it.
I honestly don't know the current state. I've used `sorcery` in the past in production apps without issue. It's an attempt to make a simpler auth system than `device` but most of my work recently has been complicated enough to warrant `devise` anyway. 
I'm sorry, Nick. I'm out. Instead of reform, I'm moving to active model and virtus. Too much unexpected behavior with reform.
Thank you so much! this helps a lot :)
Very awesome! Thanks for helping a redditor out :)
Ruby has [an alternative syntax](https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#The_.25_Notation) for Regexps that is especially useful when dealing with patterns containing forward slashes. /\/\/.*|\/\*.*?\*\// is equivalent to %r{//.*|/\*.*?\*/} because the pattern is now contained within `{}` instead of `//`, the forward slashes that are part of the pattern don't have to be escaped.
Assume that - code is an array containing ['a', 'b', 'c', 'd', 'e'] - i = 3 Then - code[i..-1] == code[3..-1] - code[3..-1] == the elements of the array from position 3 to the end - == [code[3], code[4]] (array indexes begin at 0) - == [ 'd' , 'e' ] thus: chunk = code[i..-1] means that: chunk = ['d', 'e']
Not at all, I'm glad you found them useful and hope it solves your problem! One note: it looks like your limit [operation takes 6 or so round trips](https://github.com/mwpastore/dalli-rate_limiter/blob/master/lib/dalli/rate_limiter.rb#L122) in the worst case? You should look into Dalli::Client's `multi` method to optimize away much of the network latency. Sidekiq::Limiter never takes more than one round trip since it can leverage Lua within Redis.
Best case, two; worst case, eight (two no-ops). I've thought about using a single serialized data structure instead of two separate keys, and `#cas` instead `#incr`/`#decr`. That would probably get it down to one and four, respectively. I saw `#multi` in the doc but couldn't find any examples... is it as simple as this? dc.multi do dc.set 'foo', .. dc.add 'bar', .. end
Why not just put a binding after your puts statement?
Thanks for this! Are you settled on the usage pattern? I'm looking at mperham's rate limiter that he posted about, and I'm really liking the use of blocks to pass in tasks: ERP_THROTTLE = Sidekiq::Limiter.concurrent('erp', 50, wait_timeout: 5, lock_timeout: 30) def perform(...) ERP_THROTTLE.within_limit do # call ERP end end I'd be super happy if you switched to that notation. It will likely boost adoption of your gem as well if it maintains a similar use pattern as mperham's gem.
Thanks, the biggest difference is data flow between jobs, see: https://github.com/chaps-io/gush#pipelining
Yeah, it's that simple but multi only supports a few commands. I'm not sure it supports all the ones you need. PDI. Ultimately memcached is designed to be a cache server. It has a few other commands, like cas and incr, that enable a few use cases but it's a very poor man's Redis when it comes to building functionality with all the structures that Redis offers.
Congratulations to the Jekyll team and GitHub. Great news. If anyone is interested in learning more about Jekyll I've put together a link collection called [Awesome Jekyll](https://github.com/planetjekyll/awesome-jekyll) @ Planet Jekyll - it also includes a section on the history (evolution) of GitHub Pages. Cheers.
Thanks, I've been meaning to take a look, now you've provided a great set of links so I have no more excuses.
Jekyll is great. So are winter Smith and Hugo. There's no excuse to be using a cms for ninety nine percent of blogs anymore. WordPress must die.
Think it's fair to say if Active Model and Virtus work for you, without having to add much (if any) complexity to your form model objects, then removing any excess gems is probably a great idea. The longer I use form objects, the more I am finding there is a market for a something to support the gap that these gems don't address, as I find myself solving the same problem repeatedly. Not sure if that's reform or not, but look forward to weighing it up as an option.
I love currying, but the square bracket notation for invoking procs is kind of obscure to most rubyists. Anticipate your coworkers being displeased if you use currying in Ruby.
&gt; but the square bracket notation for invoking procs is kind of obscure to most rubyists I like `Proc#[]` reflecting `Hash#[]` because `Hash` is just a specialized function - only allowing one input parameter instead of arbitrarily many.
Features: Syntax highlighting / On / Off Head /Tail functionality Tail follow like tail -f Support for multiple input for files / wildcards Ability to Skip lines and line ranges and blank lines Quiet mode for exporting large files Countlines in a file Grep functionality Search &amp; Replace in a file Turn off line numbers Debugging mode Turn off line numbers 
The original has a speed boost vs the enumerator because while doesn't need to create and pass blocks around like prison wenches.
That's not quite what I was thinking. Maybe a for do/loop? I guess it would depend on what URL is.
clearly the while loop is __not__ replaced
Oh, OK. So that whole rant was yet more crazy from brixen? *sigh*
Feel free to give me a shout out on twitter @yatish27
&gt; The big news is that Action Cable no longer depends on Celluloid, Redis, or even EventMachine! We've doubled down on concurrent-ruby, added a PostgreSQL alternative adapter to Redis for pubsub, YES! That's the right way to do it. Hooray. &gt; added a PostgreSQL alternative adapter to Redis for pubsub Oh hell yeah. 
Also, starting with 5.0.0.beta2, you can use Rails's development code reloading in multithreaded systems. This means you can use puma and sidekiq without having to restart them after every edit.
LRTHW is an okay resource for quick examples, but not all that pedagogically sound nor useful. Typos like the one you've found happen in any text of moderate length (for example, "Practical Object Oriented Design in Ruby" by Sandi Metz -- one of my absolute favorite programming texts -- has several errata), especially those produced without someone to act as editor. My students use Chris Pine's Ruby text, among others. Even though it's someone dated, the writing is clear and crisp and well-done. The recommendations u/lyspr made are also excellent.
I could/can see this type of refactor making sense if you were structuring for an extendable verification where you want to cherry pick layers (but even then it seems stinky). IMHO this specific example is silly as the verification you are performing seem like they would probably be used in all cases -- which I would much rather prefer having all of them in one succinct place that is much easier to see the whole scope at once. Overall this seems to stink like javascript or lisp over constructed bloat.
Nice! Do you have any links or information about how this was accomplished?
I twoot'd it. https://twitter.com/mperham/status/694563556574887936
[**@mperham**](https://twitter.com/mperham/) &gt; [2016-02-02 16:50 UTC](https://twitter.com/mperham/status/694563556574887936) &gt; Sidekiq will support @Rails 5's new live code reloading, no more restarting Sidekiq in dev mode!!! PR here: https://github.com/mperham/sidekiq/pull/2457 ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Guess that makes you the minority. Dragging his own personal dirty laundry through the blog of an open source project is not appropriate. Code of conducts are a separate discussion, but someone so spiteful shouldn't be making them. Blog post is far from excellent.
&gt; &gt; added a PostgreSQL alternative adapter to Redis for pubsub &gt; Oh hell yeah. keep in mind that PostgreSQL connections are much more expensive than redis connections. By default, you can only have 100 concurrent postgres connections and raising that limit requires a database restart (also on the slaves), some ram and some System V IPC semaphores (which might be limited and require root to tune in sysctl.conf) Plus, I don't know how ruby's postgres gem accesses the database and NOTIFY/LISTEN in specific. If they are using libpq, you will actually be polling to check whether an event has happened or not (because that's what libpq does internally) So if you want to handle 1000s of web sockets / long polling connections, just relying on PostgreSQL for pubsub will not be viable. LISTEN/NOTIFY as it stands now was built for an era where you had 10-20 client applications logged into a central database (possibly using different database users). This was never intended for today's web applications with 1000s of clients.
You can do this with the [Net::FTP](http://ruby-doc.org/stdlib-2.0.0/libdoc/net/ftp/rdoc/Net/FTP.html) library using the `nlst` (list files) and `mtime` (get last modified date) ftp = Net::FTP.new('ftp.isi.edu') ftp.login files = ftp.nlst('atomic-doc/*.*') most_recent = files.sort_by { |filename| ftp.mtime(filename) }.last This isn't the most efficient way, because Ruby makes a request per file to get the modification time. I think a more efficient (but more complex approach) would be trying to parse the output of `list` method (which is similar to doing `ls -l` in your terminal)
It has better performance. Even Sidekiq moved everything to CR. The problem with Celluloid is the fat dependency list. 
Why do you feel it's a step in the wrong direction? 
I am reading The Ruby Programming Language by David Flanagan and Yukihiro Matsumoto. Its good.. But have to read few topics more than twice or thrice.. 
Any code will look ugly in any language if you put 3 statements on the same line.
Could PgBouncer help with at all?
The API docs are your friend http://ruby-doc.org/core-2.1.5/Hash.html#method-i-to_a
Hash#to_a h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300 } h.to_a #=&gt; [["c", 300], ["a", 100], ["d", 400]] 
thanks. i did reference that but the problem is when i do that, it becomes: [["string1", ["string2"]], ["string3", ["string4"]], ["string5", ["string6"]], ["string7", ["string8"]]]
The API configuration style and whether it's global singleton or contextual are separate and independent factors. If you support something like `ravelry = Ravelry.new(secret_key: foo)` then you can easily support the 'block' configuration style, say: ravelry = Ravelry.new_configure do |config| config.secret_key = .... end Global config is easier to design and maintain; I agree that non-global config allowing you to configure in different ways in different parts of the same app is preferable. It's also a lot harder to design architecturally, especially to keep a convenient API, once you have an at all non-trivial object graph in your architecture. I don't agree from my experience it's trivial to support both local and global config, although I do agree that local config is better. (I mean, global state is always a 'smell'. Damn, I hate that word 'smell', I need to come up with something better). Once you have an architectural design that supports local config, then adding global is relatively trivial, it's the local that's challenging. Using a block style config or not is comparatively trivial, and can be done with either global or local config. They're independent choices. The block style config is indeed trivial, whether global or local. 
That is from my command prompt, executing in IRB. It does what it shows, because that is literally the output of IRB.
I believe that's part of the problem statement. /u/longwastheyear is asking how to convert that hash. The code needs to flatten the array like in this comment https://www.reddit.com/r/ruby/comments/43zmlu/n00b_having_trouble_with_hash_to_array_conversion/czm7bbe
i do need them unfortunately. [ [a, "foo"], [b, ["bar", "baz"] ] is basically what i'm trying to do
&gt; {"string1"=&gt;["string2"], "string3"=&gt;["string4"], "string5"=&gt;["string6"], "string7"=&gt;["string8"]} Yeah, fuck, I accidentally altered my initial hash without noticing.
thanks!
`to_a` is nice, but you won't get the exact results you are looking for This is more roundabout, but the only solution I can think of. Curious what other people have.. hsh = {"string1"=&gt;["string2"], "string3"=&gt;["string4"], "string5"=&gt;["string6"], "string7"=&gt;["string8"]} arr = [] hsh.each { |k, v| arr.push([k, v.join]) } p arr #=&gt; [["string1", "string2"], ["string3", "string4"], ["string5", "string6"], ["string7", "string8"]]
`each` will do something for each item and return the original enumerable. `map` will do something for each item and return a new enumerable. If you look at the docs that /u/IUseRhetoric posted (http://ruby-doc.org/core-2.1.5/Hash.html#method-i-to_a) you'll see the `to_a` method but along the left there's a list of "Included Modules". Sometimes it can be hard to read docs and understand what's going on, but that list shows you other places you can look to find behavior that Hash (or some other class) will have. Enumerable is listed and it implements methods like `map` where you can see http://ruby-doc.org/core-2.1.5/Enumerable.html#method-i-map that it "Returns a new array with the results of running block once for every element in enum" whereas Hash implements each but it unfortunately doesn't say explicitly that it returns the original hash.
If you know that the values are always one-element Arrays, you can also do this: {"string1"=&gt;["string2"], "string3"=&gt;["string4"], "string5"=&gt;["string6"], "string7"=&gt;["string8"]}.map {|k,v| [k, v.first] } If you want to allow the values to be arbitrary-length Arrays, then you need to specify what you want the behavior to be in such cases. /u/saturnflyer [already gave a good solution for flattening the resulting output Arrays](https://www.reddit.com/r/ruby/comments/43zmlu/n00b_having_trouble_with_hash_to_array_conversion/czm7bbe). Here's another way to do the same thing: input_hash = {"string1"=&gt;["string2"], "string3"=&gt;["string4"], "string5"=&gt;["string6", "string7", "string8"], "string9"=&gt;["string10", "string11"]} input_hash.map {|k,v| v.unshift(k) } =&gt; [["string1", "string2"], ["string3", "string4"], ["string5", "string6", "string7", "string8"], ["string9", "string10", "string11"]] Edit: I just saw [this](https://www.reddit.com/r/ruby/comments/43zmlu/n00b_having_trouble_with_hash_to_array_conversion/czm7fo5). If you mean that you want a result where single-element Array values are no longer Arrays, but where multi-element Array values are still Arrays... input_hash = {"string1"=&gt;["string2"], "string3"=&gt;["string4"], "string5"=&gt;["string6", "string7", "string8"], "string9"=&gt;["string10", "string11"]} input_hash.map {|k,v| [k, (v.length == 1) ? v.first : v] } =&gt; [["string1", "string2"], ["string3", "string4"], ["string5", ["string6", "string7", "string8"]], ["string9", ["string10", "string11"]]] 
&gt;its only a problem if the number of ferries gets too high. I assume you meant "the number of retries," and I concur. This is a good pattern for this kind of thing, assuming that you use a retry counter and test your code well (with fake exceptions, if necessary). And if you have a metric reporting or monitoring system, you can send data separately about the routine retries and the times when your retry limit is reached and you raise a real exception.
Not related to Regexps, but I love the similar syntax for strings that have lots of interior quotation marks: %Q[My "string" doesn't really "need" to be "escaped" now.]
thank you so much! i'll try to learn as much for this as possible. what a display. i'm not trying to keep the multi-element arrays but i'll try to learn from that too!
I learned well from this course to work with the Powershell, text editor, run programs in a terminal - it's great starter point for a novice. It did get difficult too fast though (where once I was learning loops and suddenly I should write a game engine).
That's the key of your Hash, an array. What else would you expect it to transform to? You can easily transform it again... but what will you do if there is more than one element in the original Array? But here's a solution that just throws out all but the first one. h.to_a.collect {|one, two| [one, two.first] }
Well concurrent-ruby is just a bunch of classes that should have been part of the Ruby standard library. It explicitly has no opinion about what constitutes a proper way of doing concurrency in Ruby, it simply implements all the primitives. The result is that the Ruby community will remain divided on what is idiomatic multithreaded Ruby. Personally I feel the actor model fits Ruby perfectly. If celluloid really is so slow and bloated then I understand to maybe move away from it, but I would have really liked it if they somehow made communicating actors an integrated part of action cable. I don't know why celluloid is so bloated, perhaps it can be slimmed down or whatever.
They'd break 90% of sites if Liquid highlighting didn't work anymore. That's a non-starter.
Now try [this one](https://glot.io/snippets/ebl1f1lh6t)! It computes the inverse Hamming distance of two fixed-width integers using only `Proc`s. That is, you can use the lambda calculus to perform the same operation as the following Ruby code: def inverse_hamming_distance a, b, width width.times.count { |i| a[i] == b[i] } end p inverse_hamming_distance 17, 10, 8 # =&gt; 4 Of course, you can use the lambda calculus to compute anything that's computable.
The idea is to separate two things: Exception Tracker &amp; measure frequency of exception rate. Measuring frequency doesn't have to swallow exception but exception tracker might have a rule to ignore certain exceptions.
Succinct, if not a little light on details.
I think the vast majority of Ruby and Rails devs use just a (not so) simple text editor, like [Sublime Text](https://www.sublimetext.com/), [Text Mate](https://macromates.com/), [Atom](https://atom.io/), [vim](http://www.vim.org/) or [emacs](https://www.gnu.org/software/emacs/). As far as IDE options go, I believe [RubyMine](https://www.jetbrains.com/ruby/) is the only one more or less kept-up-to-date (I cannot tell, I'm using Sublime 3 for years now). You may find this article interesting: [Which IDEs do Rubyists Use?](http://www.sitepoint.com/ides-rubyists-use/)
That's because there are lots of plugins [enabled by default.](http://screenshot.su/img/95/e0/bb/95e0bb0643840b3e1fd76ffe5e690520.jpg)
Rubymine is a great IDE, I hope that more people will discover and use it. It has a built-in debugger(biggest advantage) and it's rails support is very good
Nice one!
Not for the listen/notify situation. The bouncer can help to reduce peak connection count when there are many short-lived connections. But in case of LISTEN, there will be many long-lived ones. You might be able to write your own evented proxy that opens one connection and listens on many events. But at that point, why not just use redis which was *made* for this purpose?
As indicated by others, RubyMine is pretty great. Aptana's and Komodo's products are pretty good too: http://www.aptana.com/products/radrails.html http://komodoide.com/ 
I love Atom. It's unfortunate that its startup is painfully slow, though. If I'm on linux though, I like gedit even better (well, maybe I like it the same, but it starts up much faster).
Vim
Pretty version? '='*100
really, you think it's not a little light on details?
I'm going to second Cloud9, simply because this combined with a chat app can really bolster your learning if you work in a project with a friend or someone else who can help teach you. Especially if you want to learn Rails, as wrapping your head around MVC concepts is much easier when explained live by a real human.
Yea, but that's no fun. :)
I get what you're saying. I was attempting to make the ugliest Ruby possible hence making it one line. I wasn't really attempting anything profound here...
I'll add my vote for RubyMine, but for a feature nobody has mentioned yet: It reads the DB and prints your model attributes *right in the file browser* Saves you all that time looking in the DB or schema because you can't remember whether it's .title or .name I'll also give a shout out to the Railways plugin - live filterable route listings.
Since you are just starting, RubyMine (by far the best Ruby IDE) makes most sense. Make sure to focus on Ruby, not on editor/IDE though. When you get a bit more advanced and will have 50+ spare hours of time, it's worth giving vim a shot.
If you have time to learn key bindings, go for vim. 
Personally I use Rubymine but I only use it as a text editor / code navigator, I don't use any of the more heavy IDE features of it. i.e. I don't use it to run/debug code, execute tests, or any of the other things it tries to do. The reason I use it is that Sublime Text and any other lighter editor I've used get syntax highlighting very wrong, largely this is because they use regexes to attempt to classify Ruby constructs, which is very difficult if not impossible. Rubymine actually parses your code which makes it much better at syntax highlighting and generally makes it better at navigating code, e.g. it's way better than sublime code intel at 'go to definition' types of operations. 
&gt; but it's super heavy. It's really not. 
After years of using TextMate, Sublime Text or other text editors, I switched to RubyMine 18 months ago and haven't looked back. It's good. 
Click in the gutter on the left to set break points. Then right click on the test you want to debug and hit Debug. As long as you don't use Zeus or another preloader, it's pretty straightforward. If you do, you have to mess with the configs, and launch your preloader in debug mode. 
No, a 0 won't work. In this case `-1` means "the last index of the array". It must be -1 or a number bigger than the first number in the range. Here are some examples: my_array = [:a, :b, :c, :d, :e] =&gt; [:a, :b, :c, :d, :e] my_array[0..2] =&gt; [:a, :b, :c] my_array[1..4] =&gt; [:b, :c, :d, :e] my_array[2..-1] =&gt; [:c, :d, :e] my_array[2..0] =&gt; [] my_array[2..1] =&gt; [] 
two flatiron school grads http://vaidehijoshi.github.io/ http://eewang.github.io/
pretty neat
I used it for 6 months and that's how I felt. Maybe your RM is different?
is it free?
How about Atom?
Yep, I am eyeing Atom editor because currently I don't have the money to buy RubyMine, so I'll stick with an editor. I'll look at VS Code too.
Great, thanks for that article. Is VS Code any good? Considering that it's new. Edit: Wow, a lot of people are not using any IDE.
&gt; Every time you change languages, you have to find a new IDE, and learn a new way of working. Unless you're in the [Jetbrains ecosystem](https://www.jetbrains.com/products.html).
I started off with Sublime Text, but slowly made my way over to RubyMine and haven't looked back since. I don't use all the features RM has to offer, but CMD + click on a method to take you to the declaration comes in handy (I dare say you can do that in other editors too).
I can't obtain a license now coz of financial troubles. But will definitely try RubyMine in the future. As of now, I'll use Atom Text Editor.
I don't know if it's a right direction or not, but there's one thing I don't like about concurrent-ruby - it doesn't have any language level support so composing the primitives looks ugly. C#, Scala and Haskell have syntactic sugar for monads that allows to write very clean code (LINQ, for-comprehensions, do-notation) while in Ruby all you have is `map` and `flat_map`.
I really like this feature in Scala. Arrays, maps, sets can be coerced to functions and can be supplied as arguments like this val visited = Set(1,2,3) val xs = Seq(1,2,3,4,5) filter { x =&gt; visited(x) } 
Thank you for your detailed explanation, you make good points. I don't really disagree with you that picking Celluloid for ActionCable was probably a bad choice, you are correct about the pre-1.0. A technical correction though: When a class does "include Celluloid" it is then an actor. You can also tell that the code uses actors by the fact that to reimplement it in concurrent-ruby it needed 70% more code (going from 40 to 70 lines) to deal with concurrency concerns. From my perspective Rails is an opinionated framework, and also one that always preferred programmer comfort over performance. So even if celluloid is big and perhaps not the fastest solution in any situation the fact that it moves from users to know what a 'ThreadPoolExecutor' is and that you should make accessors that are accessed by its fibers 'thread_mattr_accessor' because if you don't they will silently behave in unexpected ways in production to "include Celluloid" and your code will be safe, asynchronous and distributed over a thread pool makes it very attractive. Anyway, the pull request you linked is just the internal protocol implementation, it's not exposed to users and does not really affect them in their choice for using concurrent-ruby primitives or celluloid. What I really would like to see if that ActionCable::Channel extenders would do `include Celluloid`. I haven't tried it yet, but I don't think that's now less attractive, you just have to explicitly add Celluloid to your Gemfile. Another minor nitpick: Futures/Promises do not actually solve any concurrency concerns, they are just a way to manage control flow. When you use them you still have to chose an underlying concurrency style (i.e. I use futures and promises on Celluloid as well). Javascript programmers love them because it matches really well to their concurrency model which is a single threaded reactor which makes all variable access immediately concurrency safe, and the fact that all their I/O is done with callbacks. If you use futures/promises with concurrent-ruby you will still also have to choose whether you have state in thread_mattr_accessor or in message channels or in your callbacks.
cool :) Have you applied it to anything interesting yet?
Tried to use it to recognize mouse drawn digits but it didn't generalize and I can't build a dataset large enough. I tried a few ways to generalize the training data but wasn't getting anywhere. I am thinking I have to build a convolutional net to help generalize the mnist dataset. If that fails, I guess a svm or knn is the way to go.
I use Future in concurrent-ruby like this: result = Concurrent::Future.execute { do_something } # do_something is now executing async in another thread # when I want to block on the result... result.value I didn't need to choose anything. They use threads. I don't know why I'd ever deal with "state in thread_mattr_accessor" or "message channels in my callbacks". The only thing I (occasionally) need to choose is the parameters of the ThreadPool backing the futures, if the default pool isn't suitable for me. 
Here's a refactoring I'd do to modify your code in some obvious ways. More could be done. https://gist.github.com/jrochkind/0e48758031011e542f8f check out the diff: https://gist.github.com/jrochkind/0e48758031011e542f8f/revisions It's also good practice to write some tests for it, just using MiniTest is simple and fine. One thing writing tests does is force (or at least encourage) you to think about how objects of your class will be used, what the methods should return to be useful. I'd recommend: http://www.poodr.com/
This is the shortest and most descriptive solution.
I use IntelliJ with the Ruby plugin, which is pretty much RubyMine.
Wouldn't your important? and urgent? methods use .include? rather than === ? I guess I don't know what === does to a Range. In fact, I've never seen === in Ruby before. I'll go look it up. EDIT: TIL! I have to admit I find that confusing. I tend to think (perhaps wrongly) of '===' as "even more equal than ==" but I guess that's wrong.
If you are working on an open source project or a student you can get it a big discount or perhaps free.
Thanks Joe. I'll fix and resubmit.
Thanks, I appreciate it. I am new to Ruby and was looking in all the wrong places.
For my computer, I use Sublime Text 3, which I love. If you are looking for a Web IDE(which also has a computer app), I would reccommend either Cloud9 or Nitrous. Though it costs a little money, I very highly reccommend Nitrous. It is the best and most modern online IDE I have ever used and has amazing Ruby integration. Good luck in your search!!
You can use their EAP version. They also provide free license for students 
Working on these when I get free time. REST API is not done yet. https://github.com/butchmarshall/active_record_survey https://github.com/butchmarshall/active_record_survey_api
I love [regexcrossword.com](https://regexcrossword.com).
https://regexcrossword.com/ is good fun. For me though, mostly just by using them a lot.
Some resources: [*Bastard's Book of Regular Expressions*](http://regex.bastardsbook.com/) [RegExOne tutorial](http://regexone.com/) ["You Don't Know Anything About Regular Expressions: A Complete Guide"](http://code.tutsplus.com/tutorials/you-dont-know-anything-about-regular-expressions--net-7869) The one I personally found really helpful was [Ruby Koan's](http://rubykoans.com/) regexp portion. Just what you're asking for: practice problems, with rspec tests to check your answers. Definitely recommended. 
VSCode looks surprisingly good being from Microsoft - open souce, runs cross-platform, supports several languages, has git integration by defaut even. I wish it had tabs, but the sidebar is really useful. Incidentally, it visually looks almost identical to how my Atom is set up with a couple extensions. It's not that fast though... It opens in about 3 seconds, Atom opens in about 4 seconds. In comparison, Geany (a full IDE), opens in a half second and gedit is practically instantaneous - a fraction under even a half second. I tried all these on both Windows and Ubuntu with identical performance. It's something I'll keep my eye on though.
I think it would be confusing to put anything that doesn't inherit from ActiveRecord in app/models. I sometimes put them in app/entities. 
As far as I can tell then, Passenger only serves rack apps from the document root. Is it possible to serve multiple apps from a single document root, possibly using htaccess files? I found references to htaccess file configuration but couldn't get anything to work.
I don't know that I could readily draw a distinction between a model and an entity and the persistence mechanism doesn't seem to be a solid differentiator. With rom-rb, and using a data mapper like pattern, it seems the distinction would be more nebulous.
Huge tutorial covering pretty much every subtopic [here](http://www.regular-expressions.info) Although, the part that really got things working for me is to think of regexes &amp; matching in terms of how the [engine](http://www.regular-expressions.info/engine.html) works. While not ruby-specific, the concepts are applicable.
Very nice! Short and sweet. One note, Array#map is actually Enumerable#map and if you call `map` on a Hash object, it'll return an array. It's a quirk of Ruby and I think one of the more annoying ones, but it does make your presentation slightly dissonant in the beginning.
And there's the part where Ruby's principle of least surprise fails and leads to confusing conversation; I'm sorry about this. While you never claimed that `Hash#map` would return a Hash, you claim that `Array#map` is a monad, when in fact `Hash#map` and `Array#map` are the same method, both coming from the `Enumerable` module, so... Hmm... I guess in the strict context of the `Array` object, you're right, it's monadic. I think it's just misleading to see `Array#map` when, well, .... Wait... Actually it looks like `Array#map` ACTIVELY IS A DIFFERENT METHOD. Okay Ruby, you've got me beat on this one. Maybe it's just a performance optimization, but you win, I take it back, `Array#map` is a legitimate way to think about it! And as far as operating on Hash monadically... You can kinda-sorta do it with things like `hash.each_with_object({}) { |hash, key, value| }` which uses a new Hash object. I'm not sure which monad it would be, as I'm still quite new to that world and I don't know many monads yet.
That's a metaphor, not an analogy :P
&gt;And as far as operating on Hash monadically... You can kinda-sorta do it with things like `hash.each_with_object({}) { |hash, key, value| }` which uses a new Hash object. If we want to be a little cheaty, we can call [`BasicObject#instance_eval`](http://ruby-doc.org/core-2.3.0/BasicObject.html#method-i-instance_eval) and promise to only use blocks that return hashes. `instance_eval` just yields self to the block, and returns whatever the block returns. {a: 2, b: 3}.instance_eval do |h| {a: h[:a] + 1, b: h[:b] + 1} end =&gt; {:a=&gt;3, :b=&gt;4} # and of course, we can chain it. {a: 2, b: 3}.instance_eval do |h| {a: h[:a] + 1, b: h[:b] + 1} end.instance_eval do |h| {a: h[:a] + 1, b: h[:b] + 1} end =&gt; {:a=&gt;4, :b=&gt;5} Unfortunately, this way, we aren't treating the list of pairs as a list, but as a whole collection.
Expensive indeed and I can't afford it. Haha, anyway I am using Atom and I love it.
Yep, tabs would be very useful in VSCode. Oh, I haven't tried geany yet.
I decided to use a text editor, Atom to be exact. And I'm currently having fun. I love it.
I am honestly not fond of web IDEs. But I'll still look into it. Thanks!
I've been using a multi-server deploy with capistrano for years. Not really that hard to set up. 
This isn't a “quirk”, it's perfectly reasonable. It doesn't make sense to have `Hash#map` return a Hash. Since `map` transmutes the data, each key-value pair could be mapped to an arbitrary data type. I suppose you could conceive of a `map_values` method, that would keep all of the keys the same and only modify the values, and that might be useful in some instances. But you can fake it pretty easily with something like `Hash[hsh.map{ |k,v| [k, v.foo]}]`.
I learned about finite state machines. I like the visuals.
`Array#map` isn't a monad, its a `Functor`. `Functor` apply a function to their contents in some fashion and wrap the result for you. So the function you pass to `map` doesn't return an `Array` of arrays but rather a new value for that index in the array. So, [1, 2, 3].map { |x| x * 2 } =&gt; [2, 4, 6] [1, 2, 3].map { |x| Array.new(x) } =&gt; [[nil], [nil, nil], [nil, nil, nil]] `Array#flat_map` is an a `Monad` which take a function which takes the inner container item and returns a new container. The monad then applies that to each element, then flattens the results of that passed in function. It does so by using the results and joining them all together in one new `Monad`. For `Array` it looks like this `Array#map.flatten` more conviently `Array#flat_map`. Some examples here: # ruby is untyped and will flatten x*2 to the same result which is valid because all Monads are Functors [1, 2, 3].flat_map { |x| [x * 2] } =&gt; [2, 4, 6] [1, 2, 3].flat_map{ |x| Array.new(x) } =&gt; [ nil, nil, nil, nil, nil, nil ] Here are some examples of other monads in action: `Option` Option.new( 'foo.txt' ).map { |f| f.gsub('.txt', '') } =&gt; Option { 'foo' } Option.new( nil ).map { |f| f.gsub('.txt', '') } =&gt; Option { nil } # assume File.read returns an Option containing nil or the file contents Option.new('foo.txt').map { |f| Option.new(File.read(f)) } =&gt; Options { Option { 'file contents' } } # hmmm #map is awkward now I have two of these Option thingies # lets try flat_map Option.new('foo.txt').flat_map { |f| Option.new(File.read(f)) } =&gt; Option { 'file contents' } # much better now their's only one level of option, I can keep # chaining #map or #flat_map to my hearts content without having to juggle Option nesting Option.new(nil).flat_map { |f| File.read(f) } =&gt; Option { nil } Option.new('foo.txt').flat_map { |f| File.read(f) } # assume File.read returns Option.new(nil) =&gt; Option { nil } class Option def map @inner = yield @inner unless @inner.nil? self end def flat_map yield @inner unless @inner.nil? end end `Promise` Promise.new(3).map { |f| f*3 } =&gt; Promise { 9 } # read_from_db takes a query string and returns a promise of a result of the query in an array read_from_db(query).map { |result| result[0] } # When map runs it waits for the result of the promise then applies the function to the result =&gt; { column1: 'a', column2: 'b', ... } # read_file returns a promise with the contents of the file read_from_db(query).flat_map { |result| read_file(other_query(result[0][:column1]) } } =&gt; Promise { Promise { 'file contents' } } # now I have two promises I need to wait on, let's bring in #flat_map read_from_db(query).flat_map { |result| read_file(other_query(result[0][:column1]) } # when flat_map is called it waits for the result of the promise, then feeds that value to a function that returns a new promise, then it waits on the result of that promise =&gt; Promise { 'file contents' } class Promise def map inner = wait(@inner) @inner = yield @inner self end def flat_map inner = wait(@inner) yield @inner end end Edit: Formatting and include `Option#map`, `Option#flat_map`, `Promise.map`, and `Promise#flat_map` and some examples of why `#flat_map` is useful with its additional flattening operation.
What is it that makes these examples monads? I thought monads were generally expected to have either `join` (in addition to `map`/`fmap`) or `bind`, but I see neither here. I'm not a math guy, but aren't the examples here more functor-y than monad-y?
Deploying multiple apps is simply following the deployment instructions multiple times, each time for one app. I'd like to document that explicitly some time but following the same instructions multiple times is all there is to it. Sub-URI deployment instructions can be found in section Deployment -&gt; Deploying an application -&gt; [Deploying an app to a sub-URI](https://www.phusionpassenger.com/library/deploy/nginx/deploy/ruby/#deploying-an-app-to-a-sub-uri). The old method of simply using a symlink is still supported, but it is no longer the recommended way because we've found that a lot of people found that approach to be confusing. We've found that "paste this in your config, just make sure all the paths are correct" is something which people understand a lot better.
Yes you can, https://www.phusionpassenger.com/library/deploy/apache/deploy/ruby/#deploying-an-app-to-a-sub-uri It is possible to do this from .htaccess, but you will need to have the necessary 'AllowOverride' options set in your Apache config.
[Oh?](https://gist.github.com/domgetter/7cfed4e1938de458e153)
I started with web applications and later (with quite a bit of experience) did various CLI tools. And I have to say while I could generally use my Ruby knowledge I had a hard time wrapping my head around stuff like daemons, forking and threading. It's a whole different world. I wasn't thinking about the Ruby part that long but structuring and designing the internals. Do you want to get better at Ruby in general (in a particular field like websites) or do you want to extend your horizon in advanced techniques which are for the most part language independent? I wouldn't consider myself creative (I usually have no ideas what to do which doesn't exist already) but I made tools which made my life easier and didn't exist (in that form). Maybe you can get some inspiration from tools I chose to made (some way more complex than others). * I wrote a somewhat simplistic tool to [edit file structures in my text editor](https://github.com/2called-chaos/dle) * A tool to [classify bounce emails](https://github.com/2called-chaos/bouncefetch) involved IMAP communication and a lot of text parsing. * A [script which wraps an external server process](https://mcl.breitzeit.de/) to send STDIN inputs based on STDOUT output. Actually it's a little framework to easily extend the whole thing (responders or just timed events). This was the most complex project so far I would say. Websites are pretty easy (logic wise) compared to a threaded tool with features like on-the-fly reloading of handlers and a "ticking loop". The framework was one thing, the buildin handlers I wrote for it a whole different thing: calculations with 3d coordinates (I suck at math). * Based on the server wrapper I wrote [daemonizable bots for Teamspeak3](https://github.com/2called-chaos/ts3r) (via API) and Telegram Messenger (via API) with a similar "framework" to extend functionality in a plugin like fashion.
Yeah, really. How would this piece of code look in Ruby? val (mx, my, mz) = (Some(1), Some(2), Some(3)) msum = for { x &lt;- mx y &lt;- my z &lt;- mz } yield x + y + z 
Trivial to add in ruby: https://github.com/beezee/kleisli-run
Isn't the fact that most things are mutable kind of a problem though? If I wrap a string, and yield some modified version of it to a block (like in your [example](https://gist.github.com/domgetter/7cfed4e1938de458e153), that object is modified for everyone. You would have to duplicate or decorate it whenever you yield it if you wish to enrich it. That seems cumbersome for complex objects.
What does that code do, so that I may rewrite it in Ruby? Also, what language is it? Third, what are my restrictions for rewriting it? I presume that if that results in the addition of 1, 2, and 3, that it would be "cheating" for me to write `1 + 2 + 3`.
Capistrano once set up for any project is usually usable in much of the projects you would work on . Been using it in multi-server multi-stage deploys for years. 
It was just a question, I'm not really trying to argue anything haha I use Ruby at work, and while monads seem instinctively attractive to me, I feel like many errors would arise from hidden mutability. The thing with array is, we're all already used to it, and have even (ab)used the fact that its elements are mutable. I fear with monad it seems to imply you get a new reference every time, which isn't necessarily true. I would say when wrapping a value, dupping it might not be a bad idea, though I'm not sure about the performance issues for complex objects.
Okay I have a new counter-argument. I said "without analogies", not "without at least one analogy".
It's certainly not a `Maybe` monad because it doesn't handle the absent value case. Here's an implementation and an example https://gist.github.com/anonymous/673348c38a84ee06cc7f
If elastic beanstalk or another paas gives you what you need, why bother writing code to deal with infrastructure? The purpose of eb is to take that off your plate so that you can focus on your app. Also, I know some paas let you build pull requests which Capistrano would not do cleanly.
why not mina-deploy https://github.com/mina-deploy/mina
I understand that. What I am suggesting is separating the data and persistence layer so that your business logic isn't dependent on ActiveRecord. When I have PORO entities with business logic and ActiveRecord models for persistence, I think they need to live in different place. And I'm not the [only one](https://www.youtube.com/watch?v=WpkDN78P884). 
Agreed. Here's a slightly cleaner example: hash.values.each {|v| assert_kind_of Array, v}
Can you provide or link to an example of the old symlink method? I think it would be a good fit for the OP's use case, where he wants multiple users to be able to just upload an app to a location on disk, ideally without having to edit web server config files. Personally, I liked the symlink method a lot, but have stopped using it since it stopped being recommended in docs, or even doc'd at all. I think it'd be great if the docs provided an example of it too. 
wow, blew my mind! thank you so much, fuck, just smh over here on myself.
I've made a few changes to the Passenger Library today which should hopefully make it easier for you. The front page now prominently links to the configuration reference. The Passenger support page now also links to the configuration reference directly. In the next few days, we'll introduce search filtering, so that when you use the search bar you will only see Apache-specific and Ruby-specific results.
It's true that the principle of least surprise can only go so far. There's no way to make everything completely consistent, there's always more than one aspect/axis to be consistent on, with conflicts. It's still a good aspiration, i think. 
It's easy to write a simple POC of non-mutable Array (or any other data structures) in ruby. It's possible to write more sophisticated and complete implementation: https://github.com/hamstergem/hamster But you're right that when the stdlib and the open source eco-system is built upon mutable data structures, just because the language supports it doesn't mean it's something you'd want to do, you'd have to re-invent too many wheels at present. Ruby as a language can do it fine, but was not originally designed to encourage it, and the ecosystem has grown without it. But Hamster is still super useful for special-purpose relatively isolated contexts where you really want/need immutability, and it's worth it to shoehorn it in. Hamster is neat. 
A to-do list and blackjack both sound fairly fun actually. I might go for that. Thanks! Unfortunately there are very few CLI programs I really need. Linux providing me all I want, but I spose I could recreate a few. If you've any other ideas lemmi know!
Just for clarity, this is metaprogramming 2nd edition. Not a sequel to the original book. I haven't read this but I finished the original and it definitely changed my perspective on how to read and write ruby code. 
PassengerSubURI is, and has always been, required.
I'll second this post. It's very readable for a book on such a complex topic. The perspective of the reader is one of a new dev pairing with with more experienced dev which was an enjoyable change from textbook prose. Even if you are not of a medium to advanced level in your development, still pick it up. Give it a read, absorb what you can, and repeat every 6 to 9 months till you feel solid. While you're at it, do the same with POODR. Metaprogramming is not the solution for every problem (the complexity is far too high) but sometimes there is no other way and can be just the silver bullet needed.
"2" as in Ruby 2.0+, that is the idea. He writes that he updated the book to 2.0 features and as of that time, 2.1 was already out so he also mentions some 2.1 updates and it follows that they didn't want to say "2.0".
[Source code](https://github.com/DiegoSalazar/gifantry)
&gt; Monads are functors, specifically endofunctors. Sure, but e.g. in Haskell `Monad` and `Functor` are different. Closely related, but different nonetheless. The former offers `return` and bind (`&gt;&gt;=`), and the latter `fmap`. `Functor`s in Haskell don't offer the same 'chaining' ability you're demonstrating here, obviously, because `fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b`, and there's no room for that function argument to e.g. choose whether it returns `Just x` or `Nothing`. However, in Haskell `&gt;&gt;=` generally gets used like so (pls excuse the dumb example): add3 a b c = do x &lt;- a y &lt;- b z &lt;- c return $ x + y + z Which, of course, is the same as this: add3' a b c = a &gt;&gt;= (\x -&gt; b &gt;&gt;= (\y -&gt; c &gt;&gt;= (\z -&gt; return $ x + y + z))) And so: *Main&gt; add3 (Just 3) (Just 10) (Just 7) Just 20 *Main&gt; add3 (Just 3) Nothing (Just 7) Nothing *Main&gt; add3' (Just 3) (Just 10) (Just 7) Just 20 *Main&gt; add3' (Just 3) Nothing (Just 7) Nothing `do`-notation aside, I think you can do the same with your implementation of `bind` above (pls excuse the lazy presentation): irb(main):040:0&gt; Maybe.unit(3).bind(-&gt; x { Maybe.unit(10).bind(-&gt; y { Maybe.unit(7).bind(-&gt; z { Maybe.unit(x + y + z )}) }) }) =&gt; #&lt;Maybe:0x00000000fffdc0 @value=20&gt; irb(main):041:0&gt; Maybe.unit(3).bind(-&gt; x { Maybe.unit(10).bind(-&gt; y { Maybe.unit(nil).bind(-&gt; z { Maybe.unit(x + y + z )}) }) }) =&gt; nil But in your original implementation without `bind`, how do you do that? To my morning brain, it seems like `map` alone is not enough. edit: By "that" I mean successively "binding" variables to our monadic values, such that they stay in scope for the remainder of the computation. Or something like that. edit edit: Also, strictly speaking, shouldn't the `nil` return in your `bind` function actually be something more like `self`? So that the result of the computation is a `Maybe`: irb(main):070:0&gt; Maybe.unit(3).bind(-&gt; x { Maybe.unit(10).bind(-&gt; y { Maybe.unit(nil).bind(-&gt; z { Maybe.unit(x + y + z )}) }) }) =&gt; #&lt;Maybe:0x000000011714b0 @value=nil&gt;
Well... I know what I'm doing this weekend.
Per your second edit, yes. Check this gist for the more correct version of Maybe: https://gist.github.com/domgetter/015f48c990adff85958a
I'd rather add an `app/tables` directory and put the activerecord subclasses there than to misappropriate the term "model" to mean "ORM."
yea, I think that's a good idea. IMO, anything to separate application-specific code from non-application-specific business logic is a big plus. I didn't mean to suggest that we should conflate ORM and model. The problem I am trying to solve when I put POROs with business logic in app/entities is 'how can I create business logic that is reusable and keep the Rails-y stuff in the place that people expect it to be?'. Someone new to my project should be able to easily find the things that derive from ActiveRecord (and any other application-specific logic). They should also be able to figure out where the non-application-specific business-logic is. 
Explain heavy. If you mean that it loads slower than a text editor, then yes. But the improvements to your productivity far outweigh the .5 to 3 second boot time.
&gt; There isn't a monad in here. [Au contraire](https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#fmap_and_join). From the link: &gt; It is also possible to define a monad in terms of `return` and two other operations, `join` and `fmap`. In my slides, `return` is `new`, and `map` is `flip fmap`. While I didn't define `join`, you could get it from a `Maybe` with `.instance_variable_get(:@value)`, or just class Maybe def join @value end end In Haskell: let map m f = m &gt;&gt;= (return . f) let join m = m &gt;&gt;= id :t map map :: Monad m =&gt; m a -&gt; (a -&gt; b) -&gt; m b map [3, 4] (\x -&gt; [2*x]) [[6], [8]] join (map [3, 4] (\x -&gt; [2*x])) [6, 8] map [3, 4] (\x -&gt; 2*x) [6, 8] As you can see, for aesthetic purposes, I chose to take that last version and Ruby-fy it, i.e. make `map` a method call with `m a` as `self` and the function as a block. I baked what `bind` does into `map`, so it looks like it isn't there, but here is a more explicit version: class Maybe def initialize(value) @value = value end def self.return(value) new(value) end def bind(f) if @value.nil? self else f.call(@value) end end def map(&amp;block) Maybe.return(bind(block)) # m &gt;&gt;= (return . f) end def join bind(:itself.to_proc) # m &gt;&gt;= id end end # let map m f = m &gt;&gt;= (return . f) # let join = m &gt;&gt;= id # join (map (Just 3) (\x -&gt; Just (2*x))) Maybe.return(3).map {|n| Maybe.return(2*n)}.join All you need in order to be a monad is to "wrap" values somehow, "call" functions/methods on wrapped values (or not at all), and always return an instance of itself.
I don't have access on my school email now, how sad. :(
I'm not sure this clicks for me. The wiki examples show derivation of bind from join and fmap. The Maybe you define doesn't have something like Just or Nothing, and you end up using a magic value (nil) to short circuit. It still feels half baked to me and it doesn't call out the largest practical application of a monad which is to abstract and encapsulate control flow while allow the caller to impact the context. In your examples, mapped operations are unable to interact with the context and by highlighting ony Map in the presentation it reads as a Functor def to me. EDIT - clarity
Problem Solved! puts array[2][/\d+/]
That's what I mean. With bind on a true Maybe you have Just or Nothing, where Nothing is the _loose_ equivalent of your nil treatment, at least so far as producing no-ops for remaining operations. So here I short circuit by returning nil from a mapped fn, vs bind I would return M[A] instead of A (nil) and represent that as Nothing. If you try to do Either this way I think it becomes much more apparent, you'll find you need more than initialize and map.
Yes. The first two elements in the array are just useless metadata that the program tosses into the CSV I'm reading from.
 puts array[2][/\d(.)(.)*/] Because boobs. But seriously your example gives the *third* element of the array's first contiguous run of digits. If the value is "JohnDoe 12345 67890" the match of `/\d+/` is still "12345".
I mistyped. "JohnDoe 12345" IS the third element. The first two arent relevant. I also can't just split it by whitespace and read the second element (....Of the third element) because the person in question may have two names...or one...or three. Example, I might have: Doe John 12345 John Dee Doe 12345 JohnDoe 12345 The person who added these people into the program was...inconsistent. 
https://media.giphy.com/media/Aff4ryYiacUO4/giphy.gif
Yes - I'm talking about when you make a pull request for your application that is being hosted on elastic beanstalk or whatever paas. If you're using heroku, for example, and someone makes a pull request, you can make a deployment of that branch into a heroku instance and look around before the merge is finalized. If you were using capistrano, you'd need to know about what infrastructure is available and then it becomes unnecessarily complicated to accomplish the same thing.
I'd save that gif for the recursive version that respects the nil case: https://gist.github.com/domgetter/015f48c990adff85958a
Weird. I downloaded it in under a minute. Maybe it was just bad timing on a single threaded machine? Or bad connection.
Rubular is a great one, as well.
Yeah, one of the bass notes is too high. Other than that it seems a pretty good transcription. (Although that bassline is super prominent and that wrong note gets repeated the whole time.) The bassline in the song is, to my ear: B A B F# G E The bassline in this video is, to my ear: B A B F# A F# EDIT: Whoopsie dasies, no the original bassline does *not* feature a tritone
I do this when I can. Raising is much faster than pry when reloading a rails stack
There's a gem that keeps the whole stack loaded
For people unfamiliar with regex: \d = a single digit . = any single character () = capturing group. + = 1 or more of the preceding token. (Greedy) So \d+ means "one or more digits, matching as many as possible" And \d(.) means "a digit, then capture the next character in a capture group." Which means it matches two character, and captures one. 
[Byebug](https://github.com/deivid-rodriguez/byebug) or something else? I find byebug valuable when debugging tests (paired with RSpec's `focus`).
&gt; The perspective of the reader is one of a new dev pairing with with more experienced dev which was an enjoyable change from textbook prose Well, tastes differ. I would say this is what I least like about the book - the stupid "Bill and you" talk. But this only shows how good the book is. Despite of that little annoyance, I feel the value of every page and it can't put me off so easily. Glad if you like it of course.
Thanks a lot :) It's really a treat to eyes. 
What are some real debuggers available for Ruby which you would reccomend? 
oh man, I haven't literally lol'd in awhile, thank you.
[byebug](https://github.com/deivid-rodriguez/byebug) [pry](https://github.com/pry/pry/wiki/Runtime-invocation#Invoke_on_binding)
No one will take it seriously because of the title of the blog and the domain in the URL.
Rubular.com is your friend for all regex stuff. Play about with it until it is right then copy into your code. 
I'm sorry, I mistyped. In [this comment](https://www.reddit.com/r/ruby/comments/448b62/teaching_monads_to_rubyists_without_analogies/czp7yun) I meant `Maybe.new(nil).map {|n| n*2}`, not `Maybe.new(nil).bind {|n| n*2}`. I'll edit it to be correct. You are correct that passing bind a block that doesn't return an instance of the monad is wrong of me.
Mate, do you have any idea who tenderlove is?
Layer is worth checking out as well. Recently did an integration with Layer and it was pretty straightforward. https://layer.com/ (I've only used Twilio for SMS type stuff - which it was great at). Good to know it does chat type stuff now.
Could you paste exact files like you did with spec_helper and environment.rb? Model and spec for it. We need precision here!
You're describing the *instance method* "Student#first_five", but in your test, you're specifying the *class method* Student::first_five. Notice how the exception is complaining that you're calling a missing method on a *Class* instance, not a missing method on a *Student* instance. Change "::first_five" to "#first_five", and see if that helps. Edit: response to this comment led me to clarify- it's not the rspec description- it's probably the case that you're attempting to call the "first_five" method on the Student class itself, rather than on an instance of the Student class.
I'm not sure if this is just a typo, but class names need to be a constant in Ruby. If you have named your class student then you will need to rename it to Student.
This will work as long as the name is guaranteed to never have a numeric digit in it. You could also solve this same problem by using `String#split` and keying on the space between the name and id number: puts array[2].split(' ').last
I am not a puts debugger, I use byebug -- but this article isn't really about puts debugging, almost all of these techniques are useful with a ruby debugger too. Some of them I already knew about and use, some of them I didn't and look really useful. 
You're not missing much it just automated the features you have to do like, if you add to your gem file it pop up a little thing to click for it fun bundle install. I have it because it's free from my school but I use Atom instead.
Atom? Slow? It starts up instantly 
I use byebug and it's slow to recover after a debugger statement
Uppercase Student in your model
It would be nice if you could search for gifs without having to sign in/sign up. 
He probably means if OP has written it wrong in the describe he's probably written it wrong in the test too. 
correct, at least I've always had to manually create them, I'm not aware of any ways of having puma automatically doing it.
Thanks, maybe Capistrano is a way. I'll inspect it. Now I'm just adding `FileUtils.mkdir_p` on the top of `puma.rb` to ensure folders are exist, not elegant but does the trick.
When you run `cap deploy:setup` it creates the tmp, pids and sockets directories.
I've been very happy with byebug, although I still do puts-debugging every now and then :)
Why not add creating the folders to your puma configuration? It is just ruby being executed here, right? http://stackoverflow.com/a/12617369/1236035
https://gist.github.com/scottrobertson/16d76742580f82a6eb11 That could work. If you are sure they have the same amount of elements in each array.
&gt; https://gist.github.com/scottrobertson/16d76742580f82a6eb11 I'm gonna give that a try, thanks! Each array will always have the same amount of elements each time.
Assuming this is an array of equal sized tuples you can call .transpose [[a, b, c], [1, 2, 3], [4, 5, 6]].transpose =&gt; [[a, 1, 4], [b, 2, 5], [c, 3, 6]]
Thanks, I guess for now I'm setting it up with the Sub-URI config. I have to modify the Apache config for every new app, but realistically I don't expect them to be creating new apps very often.
ok, so here's what I did. First off, thanks for the suggestions, I really appreciate it! def writeDirection(array_1, array_2, array_3, array_4, array_5) for index in 0 ... street.size CSV.open("directions_data.csv", "ab") do |csv| csv &lt;&lt; [array_1[index], array_2[index], array_3[index], array_4[index], array_5[index]] end end end now, one more question, if I want to first ensure the file has no contents if it does exist, or overwrite it every time what would I do? I tried changing "ab" to "w" but that only writes the last value of each array to the file giving me 1 line.
It was a typo! I also added the spec code since posters were asking for that too.
type of the post. I corrected and added the spec code
posted. (added to the original post)
that worked perfectly! just ran into a case where I may not have tuples of the same size every time so I think I've gotta stick with this for now.
`letters.zip(numbers, numbers_2)` `#zip` is specifically designed for this
Hey, if you really need an improvement to your keyboards, I would suggest switching to some version of the ergodox! It’s an amazing keyboard and if you have big hands it will be even better. It’s really worth the cost. A nicer keyboard is an investment into your career.
Man, I wanna be more various.
&gt; lp = Bundler::LockfileParser.new(File.read('Gemfile.lock')) &gt; puts JSON.pretty_generate( &gt; source: lp.sources, &gt; dependencies: lp.dependencies, &gt; specs: lp.specs, &gt; platforms: lp.platforms, &gt; bundler_version: lp.bundler_version &gt; ) Running that on [this Gemfile.lock](https://github.com/jules2689/website/blob/master/Gemfile.lock) generates [this json](https://gist.github.com/jules2689/998ae2b4da17877bd9d2) FWIW Edit: This is a direct json from the object, it doesn't take into account anything custom. E.g. you can call `latest_version?` on each of those dependencies as well as `groups`, `platforms`, `requirement` (which can be snaked down into `version`)
You should cross-post this to /r/MechanicalKeyboards 
Yes, I'm creating folders in puma.rb now
The main issue with Elastic Beanstalk is that it makes some assumptions about your architecture. You get more flexibility if you go with a customised solution. But Beanstalk takes a lot of the pain away that comes with scaling up a web application. I personally use Elastic Beanstalk in a project with tens of thousands of requests per minute. Managing the infrastructure now is as easy as it was when we had a tenth of the traffic. For most cases, I would say that Elastic Beanstalk is easier to maintain in the long run.
You still haven't told us what kind of tasks those programs do. Without knowing this key information, it is impossible to give you an idea about what short of GUI is better. My suspicion is that your best option is creating a web app so your coworkers can use it like any other web application (and you don't have to install &amp; maintain ruby in all their machines - just on the server). But it really depends on what kind of tasks these programs do.
ah nice, I was one of the people before massdrop started selling them, so I had to build it all myself. It's a mess.
Couldn't agree more. I regret not purchasing a good mechanical keyboard earlier in my career. If you're going to spend all day typing, you should really own a nice keyboard and ErgoDox keyboards are *great*!
There's been a lot of effort recently to get Ruby running on Windows and it's a lot easier than it used to be. I've not toyed with it but Ruby Shoes uses Java (I think) and Java has always had first class Windows support so this might be the way to go. Also if you're any good with Python that also has excellent Windows support and is another option if you want to stay away from the .NET framework.
Look at it this way. Electricians use Fluke or Klein tools. A keyboard, shell, and editor are the programmer's tools. Why would you use shit ones?
Easier, sure, but easy enough for people who refer to Windows and Office interchangeably? I think they are already confused when they see an installer.
There are a few ways to do this. I created a benchmark helper class to show the ways and how they compare: class BenchmarkHelper require 'benchmark' def self.extract_digits_gsub(str = "Lorem 123 ipsum 456 879") str.gsub(/[^\d]/, '') end def self.extract_digits_select(str = "Lorem 123 ipsum 456 879") str.split.select { |ch| ch =~ /[\d]+/ }.join.to_s end def self.extract_digits_delete(str = "Lorem 123 ipsum 456 879") str.delete('^0-9') end def self.run(m, arg) 10000.times do self.send(m, arg) end end end # This is an example of testing which method oh extracting digits is best. Benchmark.bmbm do |x| x.report('Extract digits by gsub') { BenchmarkHelper.run(:extract_digits_gsub,"Lorem 123 ipsum 456 879") } x.report('Extract digits by select') { BenchmarkHelper.run(:extract_digits_select,"Lorem 123 ipsum 456 879") } x.report('Extract digits by delete') { BenchmarkHelper.run(:extract_digits_delete,"Lorem 123 ipsum 456 879") } end # # user system total real # Extract digits by gsub 0.031000 0.000000 0.031000 ( 0.039004) # Extract digits by select 0.031000 0.000000 0.031000 ( 0.036004) # Extract digits by delete 0.016000 0.000000 0.016000 ( 0.007000) 
This is so funny, do your research please
I actually started with a crappy little $10 soldering iron, but then almost immediately went on amazon and bought a proper nice one. Not a gun, but it's really excellent with variable temp settings. I was also using non-leaded solder, which is just way way more difficult to use. I actually just built a planck also! I'm using it as my daily driver right now just because I barely have to move my fingers at all. 
yep that's definitely it. People just don't realize that there is a world of better keyboards out there. I mean it's just like that for anything really. Out there are people who are crazy about better headphones, speakers, vape pens, computers, wallets, razors, etc. I just assume now that anything I use is most likely not the best, but when I do want to get the best I know that there is somewhere I can go and find out how much I've been missing out on. 
As others have said, Rails is what you want. You get to stick with Ruby (which I'm sure you have reasons for preferring over other OO languages) and you can put it on the web. Get a free OpenShift account (cloud hosting) and bam, you're up and running.
I don't get the reason you direct devs to use prod instead of a proper QA stage. If done correctly the QA stage is just Prod but with different passwords+higher level of debug logging and in the best cases a pulldown of the prod DB that has been sanitized. It reflects prod as close as possible but definitely has its own "stage" and up/down actions beyond "env" in all but the most simple environments. 
I didn't even know you could get a gun to replace the iron. I've got a Hakko too! Maybe I should do that..
cross-post https://www.reddit.com/r/MechanicalKeyboards/comments/44t9gn/ergonomics_and_faster_typing_practices_for_web/
If by selects you mean `.find` then yes. Also, using `ActiveRecord.select` works as well: 2.1.0 :001 &gt; User.create(first_name: 'foo', last_name: 'bar') =&gt; #&lt;User id: 1, first_name: "foo", last_name: "bar", email: nil, created_at: "2016-02-08 23:15:49", updated_at: "2016-02-08 23:15:49"&gt; psql=# alter table users drop column email; ALTER TABLE 2.1.0 :004 &gt; User.select('first_name').last =&gt; #&lt;User id: nil, first_name: "foo"&gt; 2.1.0 :006 &gt; User.find(1) =&gt; #&lt;User id: 1, first_name: "foo", last_name: "bar", created_at: "2016-02-08 23:15:49", updated_at: "2016-02-08 23:15:49"&gt; Basically the rule is: Unless you reference the column, most things should be fine. 
Unfortunately though if you have prepared statements enabled you have to disable that before you can do a zero downtime deploy.
Here are some other options I didn't see anyone else bring up. *https://github.com/maccman/bowline *http://www.ruby-reactive.org/ *http://zachcapalbo.com/projects/flammarion.html
Agreed ruby is not the best option but if OP really want to use it look at jrubyfx https://brakemanpro.com/blog/jrubyfx/2015/09/05/what-is-jrubyfx/ which was used to create brakeman-pro and apparently has a packaging system included.
No, your 30's is not too late to move into programming from sysadmining. I'm not a fan of the "ruby koans" stuff, but it works for some. 
I guess not many fans of of Octopress v3.0 (the "classic" version, that is, v2.0 used to be quite popular ). What static site generator or themes are you using nowadays? 
Thank you very much! I will look into that for sure. I wanted to get into rails also. I've noticed that there were a lot of openings nation wide for rails developers and I would like to get to that point where I can apply for one of those positions and actually get it lol.
+1 !!!!!
I'm sorry but this is just over sensationalized clickbait. Get rid of the oj gem because json is in the stdlib? How about not, because oj is much much faster/lighter on resources. Rewrite what a gem does to save a dependency? How about not, i'm writing code for a business and they don't pay me to reinvent the wheel. It makes sense for rails to try to lower its number of dependencies since so many people use it, but for most people it doesn't make sense to bother until they run into some kind of problem(too much memory usage, dependencies getting hard to handle, whatever). Over optimization and all that. Very glad there are people out there trying to make sure that often used libraries like rails have less dependencies though. Definitely a good thing. Thanks for the hard work! 
Surprised there is no mention of the .tap() method. Seems like a perfect place to discuss it.
I'm not sure about `net/http` though, it uses `Timeout` module instead of non-blocking socket for opening the connection.
It's ok in that case. Timeout is bad for coarse-grained usage, ok for single socket operations. Unfortunately that's a distinction lost on most.
this was totally easy to follow (save for the n00b code knowledge i have) and i did not expect at all that you were typing on a smartphone haha. thanks for the response! i think i get it. but in order to apply i probably have to get better at ruby to know what things should be seen and what shouldn't. thanks a lot though!
Interestingly enough, after establishing the connection it uses non-blocking reads. Ruby is weird.
Thanks! `joins` in B isn't a typo. I just checked it again and it works.
Nice! But I must say, this is where I'd start looking if I was hunting for new Ruby/Rails html injection vulnerabilities :)
Okay, well joins vs includes is a different separate question than whether to use `"personalities.name ..."` vs `personalities: {name ...`. You can mix and match either decision on both questions. They do slightly different things, it gets confusing, google around. But it's not a style issue, they do slightly different things. 
I haven't looked, but I would guess there's probably already a pretty comprehensive test suite around html escaping in the rails repo. Wouldn't make sense for them to allow such a change without tests proving it still works.
This would be a great point to add to [your earlier post about Timeout](http://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/), which is #4 on a google search for "ruby timeout".
If you are interested in trying, then it is not too late! My advice: forget about rails, use it as a bash (or whatever) replacement. You just have to start your scripts with #/usr/bin/env ruby instead of #/bin/sh.
This is something I struggle with, internally. I'm quite familiar with Rails at this point, and it really is the fastest way for me to go from idea to product in a scary amount of time. But having done it for so long, I see the cracks, the shortcomings, and the future pitfalls of writing an app the Rails Way. And there's so much cool new stuff out there every day, it's a challenge to decide how to spend my time. While Rails might not be the Cool New Thing any more, I'm happy that the ecosystems around it continue to thrive. Honestly, it's okay if it's boring now. I need a boring, proven tool to get my work done.
the other guy did a good job at what, so I'll have a stab at why... imagine a village where everyone has access to free building materials and labor to build anything they want, at any time. at first you think that village would be pretty neat. Then you start thinking about the crazy guy on the corner... and the helicopter moms that don't want cars near their paths where they walk with their babies in strollers. Also some guy is building advertizements for donald trump EVERYWHERE. Soon your village is in complete chaos as everyone builds things on top of other things.. Code is like that. Building stuff only costs you the time to figure out what you want to build and where, so people tend to build according to their own head a lot, and things get messy fast without commonly agreed upon rules. A sort of gentlemans agreement to only write "Clean Code" encapsulation is one of those rules. If you build your complex machine with EVERYHING important on the outside, people will eventually touch something sensitive and break it. if instead you build your machine inside a big box with only an ON button on the outside, you can be sure others will at worst turn it on very often. classes can be like that. if the public methods of a class are simple to use, and all of the complex machinery in private methods, you gain two advantages. First off, people won't misuse your machine. the on button is hard use the wrong way. Second, if you want to change HOW your class does it's thing, noone will care! As long as the public methods retain their functions, everyone are happy. Over the years you've swapped the insides like 5 times, but you always kept that on button working, and noone of the people depending on your machine ever had to care. In contrast, a class with many and complex methods invite to "Coupling", meaning that classes know a lot about, and make use of each others inner workings. Suddenly you can't change one class without tinkering with the other, and the third. Your user can't have it's first_name and last_name data fields changed into a more odd-name-accepting and simple "name" field, because someone else was using that first_name method to stich the name up himself! You can't change the inner workings of the class either, because every bit of logic in it is exposed in public methods and used everywhere, so if you change anything, you'll break code elsewhere. Don't be that guy. Keep classes small and encapsulated, and you'll thank yourself down the road. Or your coworker will.
other cross-post https://www.reddit.com/r/programming/comments/44o91c/ergonomics_and_faster_typing_practices_for_web/
How is it for Photoshop etc shortcuts? I do both programming and graphics. 
&gt; Every dependency in your application has the potential to bloat your app, to destabilize your app, Well, every line of code written locally has that potential too, to be buggy, right? Is a bug more likely in code I write myself, or in code from a dependency? * On the one hand, code in a heavily-used dependency is seen by more eyes, perhaps (not necessarily) written by more-experienced (at least in the domain) developers than me. A bug in a very heavily-used dependency can still exist, is in the mime-type case. But -- someone who wasn't me found and fixed that bug, eventually. Nobody who's not me or my team is finding and fixing bugs in code written locally. * On the other hand, the dependency is likely to be _more complicated_ than code I'd write locally. It is not focused on the use case I actually need but is often meant to be more general-purpose and flexible or configurable, and thus may have many more lines of code than the thing I'd write locally -- more lines of code and more complex means more potential for bugs. It's a trade-off. Like nearly everything in development. I do think many Rails apps are much more dependency heavy than they need to be. But if you ruthlessly try to eliminate any dependency you possibly can, the pendulum will swing the other direction. It's a judgement call on a variety of considerations. It is one you should consider when adding a dependency, sure, and part of that consideration should be looking at the source code, and the total dependency tree the gem brings in. &gt; Avoid gems which pull in more dependencies than their value warrants. Example of a bad gem: the fog gem which pulls in 39 gems, more dependencies than rails itself and most of which are unnecessary. I think that's a good example. fog drives me crazy. &gt; So many gems declare a dependency on json, oj, multi_json, or yajl-ruby.... Agree on that too. The original author of `multi_json` even tried to kill it (can't find the thread now), but the community insisted on keeping it on life support! I don't know why. The only code of mine that has `multi_json` in it is old code I haven't had the time or inclination to go rip it out of yet. But I ripped it out of any _gems_ I publish, for sure, to not inflict it downstream. &gt; A Rubygem should never use anything but Net::HTTP internally! Well, if only Net::HTTP didn't have such a horrible horrible API. I wish the stdlib gave us an http library with a higher-level abstracted API. But it doesn't. If I'm doing something with non-trivial HTTP needed, even in a gem, I consider something with a better API worth it. I like HTTPClient a lot, and wish it would catch on more. (HTTParty, on the other hand, is quite popular, and honestly pretty terrible). It would be awfully nice if the stdlib would include an adequate HTTP gem, and then all of your dependencies could just use it, not bring in various choices for HTTP library, and all of your dependencies could actually _work together_ composably well all using the same HTTP library. Alas, we have the stdlib we have, not the one we want. &gt; I’d love to drop Nokogiri, it’s such a huge dependency with a massive native extension component, but there are some non-trivial dependencies on it. Oga is a nice, simpler alternative. I too would love to drop Nokogiri. It is indeed ridiculously heavy. But it turns out good XML processing is hard. I spent some time with Oga, but it just doesn't have the funtionality I need (particularly around namespaces). But Rails didn't even include Nokogiri until 4.2, via the new HTML sanitizer. I groaned when I saw it had been added as a dependency. Whatever was wrong with the old html sanitizer, did it really need nokogiri to fix it? Once it's been added, others will think, gee, if Nokogiri is already there anyway (and I'm paying the crazy 30-150 second gem install time already anyway), I might as well just use it. Doh. 
`yajl-ruby` does streamed JSON parsing though (which is what I use it for); I don't think the stdlib `json` gem does that.
&gt; Well, if only Net::HTTP didn't have such a horrible horrible API. Right. 8 years using ruby and I have to look it up every fucking time I want to do a simple HTTP call.
It's not just that it's confusing, it's that it _doesn't do what I need_. It's too low-level. I could build what I need on top of it, but why would I do that in every project instead of using a gem that does? 
Especially ironic since this is the same person who wrote [The Ruby Stdlib is a Ghetto](http://www.mikeperham.com/2010/11/22/the-ruby-stdlib-is-a-ghetto/).
If you're very early days (as you've mentioned) and only dealing with fairly simple apps, I'd go with Sinatra over Rails for the moment. Should do what you need and not have much of a learning curve. Push to heroku, job done. They have guides available on how to set it all up.
Doesn't Rails use erubis?
Just FYI really, but Puppet is a configuration management tool, not a provisioning tool. You should still learn to use it though.
erubis has essentially the same html escaping function written in Ruby
Just write the second where clause out as SQL. I'd show you what I mean but I'm on my phone and it's too hard.
&gt; The mime-types gem recently optimized its memory usage and saved megabytes of RAM. Somehow, the take-away from this is that you shouldn't be depending on other gems. But if I'd hand-rolled my own mime-type code inside my application, I'm pretty sure no stranger would appear to optimize its memory usage for free. If you need some functionality, you need it. Killing a dependency doesn't kill the requirement. It just means you depend or your future or former self. Sometimes those people will do a better job than a third party. If nothing else, they know your requirements pretty well. But, often, they're lazy or busy or error-prone and will cobble together something worse than the leading external package.
As a sysadmin, my life changed when I made this switch. May I never write a bash script again! If you're looking at taking this approach, I highly recommend [Build Awesome Command Line Applications in Ruby](https://pragprog.com/book/dccar2/build-awesome-command-line-applications-in-ruby-2). It was my favourite learning resource.
you can use both Integer and Kernel::Float to parse your string into a number, (eg. Integer('my integer string') or Kernel::Float('my float string')) depending on what type of number you want it to become. the benefit here being that each of these will raise an exception if the string that is passed in can not logically be parsed, giving you the opportunity to give feedback to the user.
If you just try running reservations.where(checkin: booking_times) you'll see that the output SQL is something like SELECT "reservations".* FROM "reservations" where (checkin BETWEEN '2016-02-10' AND '2016-02-09') (For example purposes, I made date1 today and date2 yesterday). &amp;nbsp; So, the string interpolation version should look like reservations.where('checkin BETWEEN ? AND ?', date1.to_date, date2.to_date) &amp;nbsp; Your final code then looks like conflicting_reservations = reservations.where(status: :accepted).where('(checkin BETWEEN ? AND ?) OR (checkout BETWEEN ? AND ?)', date1.to_date, date2.to_date, date1.to_date, date2.to_date) &amp;nbsp; If you don't like the repeating args, you could choose to turn your range into an array of arguments and splat it. booking_times = [date1.to_date, date2.to_date] conflicting_reservations = reservations.where(status: :accepted).where('(checkin BETWEEN ? AND ?) OR (checkout BETWEEN ? AND ?)', *booking_times, *booking_times)
I'm aware of the ability to require different parts of activesupport, and use it fairly frequently. I was just bemoaning the lack of ability to say, install (not require, gem/bundle install) just concerns. But its not really that big an issue, and there are reasons not to even do it
In which part of the article the author says that? O_o
The difference between "joins" and "includes" is that "joins" generate "INNER JOIN" sql query when "includes" generate "LEFT OUTER JOIN".
It's the best choice for a Rubyist, that's for sure, as it's the only online tester that I know of that runs Oniguruma. 
Ruby `Regexp` class documentation is also quite important as Ruby's regexp dialect differs from most other common tools with regexps. 
I guess that's the intended meaning, but I thought he meant a timeout in the underlying socket (`IO.select` or whatever). "Lower level" may be subject to interpretation, but "remove any usage of Timeout" is pretty clear. [Here's the same conversation playing out again.](https://github.com/mperham/sidekiq/issues/862#issuecomment-76982399)
As a new dev, this is slightly discouraging. Could you elaborate on the cracks/shortcomings/future pitfalls that you see? Say I'm your eager younger brother: Would you steer me in a different direction, or encourage the rails path?
While I appreciate the simplicity of this example, if you're doing any loading of yaml/env files into your ruby environment, [dotenv](https://github.com/bkeepers/dotenv) is widely used and pretty much the defacto standard these days.
Gah, I hate internet forums sometimes. Everyone has to poke a hole in a suggestion, taking it to an extreme. OP is making the point that you shouldn't go whilly-nilly with dependencies. Adding a dependency does come at a cost. Only making a single HTTP GET request? Maybe just use `net/http` instead of requiring a whole convenience gem. OP isn't advocating not using gems. OP isn't advocating re-writing everything yourself all the time. Dependency bloat *is* a problem in the rubygems ecosystem. Some of it is needed. Not all of it is.
Did you read the post? Your suggestion is linked there... And the point is exactly avoiding another gem, which I appreciate.
I think a lot of people here are missing the point. If I'm shipping a gem then I should attempt to minimize transitive dependencies. &gt;A Rubygem should never use anything but Net::HTTP internally! He's basically reiterating the criticism launched against Rails 5 and now being attacked for it. Seems bizarre...
Right now it's usually done with Arel tables, but Rails 5 will finally introduce the Or query. 
Usually to avoid pulling in more dependencies and have a lot of dead code lying around. This is probably a bad example since dotenv doesn't have dependencies. But just a few days ago I needed some latitude to meters conversion and to avoid pulling in all of geokit (which is big and brings lots of dependencies) I tried using geo-distance. But that one also has a bunch of dependencies and even broke after an update. All I wanted could be done in under 10 lines of code. So I implemented it on my own. You need to be mindful of your dependencies, your app will grow a LOT if you don't pay attention. Memory is not as big an issue as it was years ago, but I know of rails apps that need to be regularly restarted cause of memory bloat. And yes, I know for certain many of its dependencies could be slashed.
Someone backported rails 5's OR query as a gem for rails 4: https://github.com/Eric-Guo/where-or That might be useful.
If you find yourself debugging magic programming, this post may help http://www.schneems.com/2016/01/25/ruby-debugging-magic-cheat-sheet.html
I guess I glossed over the little 'many gems' link in the intro sentence. Fair point.
Cannot up vote this enough! Must be great living in a black and white world. The rest of us though live in the enormous grey bit in the middle.
How are you adding a lab to the Grad? The after_add callback is supposed to trigger only if you do something like this `grad.labs &lt;&lt; lab`
Thank you! Not sure how I missed that online guide right from the website, lol. That Practical Object-Oriented Design in Ruby book looks great; I'll check it out!
Oh, good! I was afraid 1.x (and part of 2.x) being taken completely out of support may have meant there was a big shift in the way the language works or something. I'll check them out. Thanks!
I've found [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104) by Russ Olsen to be extremely helpful in explaining Ruby's idiosyncracies, and he covers advanced topics. I also highly recommend Avdi Grimm's screencasts called [Ruby Tapas](http://www.rubytapas.com), which are short, useful lessons in advanced Ruby
Don't bother reading a book, just read the specification online.
I would recommend to always keep code in Ruby when you can, and use SQL strings only when you need to. So I would recommend these: 1. `all.order(name: :desc)` 2. `includes(people: :personalities).where(personalities: {name: "Laid Back"})` 3. `laid_back.merge(energetic)` In the last example I've used `ActiveRecord::Relation#merge`, which can make an intersection between two relations, and this results into a single query instead of three queries. When using Ruby things like automatic qualifying is automatically taken care of. For example, if you would use `order('name DESC')`, that could cause errors when joining with another table, since the "name" column isn't qualified with the name of the table.
I do more node than anything and I really hate the dev-shaming that goes on for not using the latest fad in the JS community. 
This is the book I would second for someone switching languages. It will also take a lot of the magic out of something like Rails, should you go that route.
To be fair, some of the stuff mentioned in the older books is *still* how it's done and there's no guarantee it'll be mentioned in the newer books. Not terribly difficult to pick up the new features if you understand the older stuff, though I'd probably not bother reading anything that doesn't go at least as far as 1.9. I particularly recall a quick resolution to a few problems I had trying to get a particular Ruby script to work as-written on both my Windows and Linux boots thanks to information in RPL. Encoding related issues, basically. Sometimes you need books that club you over the head with implementation details. A lot of Ruby books try to be cool, cute or clever in favor of just bludgeoning you with the information you need.
&gt; but the latest one has been updated over 5 yrs ago. Does it still work or did Skype change it's API? Because you can kinda use Skype (mostly) with client versions that are way older than 5 years.
To add to that, the problem is that all the alternatives are fragmented, isolated and consequently very poor in their documentation, availability of tutorials and community built knowledge base. I think I've tried them all so far, trying to fall in love with each of them, but I only grew up more frustrated. These are the solution I tried, in chronological order, starting about 6-7 years ago: - RubyQT: was not working, had to deeply mess with gems. When in the end it was working, I thought "what's this?? That's not Ruby". - Ruby-Shoes: I don't know if it got any better now, but when I tried, all you could do was ugly designed buttons, with a somewhat blocking feeling (it was shoes 2 or 3 and I believe it had some non existing GUI thread architecture, probably was all running in one thread, current shoes 4 uses JRuby, perhaps is better, but I wouldn't bet on it and it's not feature complete) - Ruby-TK: what's this? It's 2010 already. Also very limited with what you can do with it. Maybe only good for a little old-fashioned X useless app. - JRuby with SWT, AWT, SWING and whatnot: couldn't not move past the initial steps, because if you wanted to leverage those libs, you had to study JAVA and SWT or AWT or SWING and adapt them to Ruby, which I was totally not capable of and reluctant to. - WideStudio http://www.widestudio.org/EE/wsinfo.html yes I even ended up stumbling on that "dark thing". It kinda worked but... well.. look at the screenshots. It ended up being totally unmaintained too. - RubyProcessing: yes, even that. I saw it could do 2D graphics and sound, so I thought why not use it as a GUI. But it felt just wrong and weird. - IronRuby: not exactly a GUI toolkit but you know why I am listing it here and you know what happened to it. - JRubyFX: got problems with app packaging, eventually fixed and contributed to the repository too, but.. I ended up with having to acquire so much Java related knowledge, that it deviated me to focusing on my project. Added bonus in using that is I was able to compile my ruby code to java bytecode, achieving some amount of obfuscation, but in the end, as I said, the lack of tutorials or people sharing the same experience made me feel as I was constantly working in an unsafe zone, where there are no established good practices and guidelines that give you that confidence that you are progressing good. It's as if you are lost in a maze, and then at some point you start to think, damn, why can't I code in a .NET sized world? - Opal: That's good, design interface in html, code in Ruby. Except some stuff you are forced to use JS anyway (although I admit it's constantly getting better) but again, makes more sense when used within a client-server architecture (which is cumbersome when trying to code a desktop app) because you can't do much client side when browser is limiting access to O.S. Also I wanted the ability to.. draw to canvas.. and you can, sure, but in JS. -.- Totally defeats the point. I know about https://github.com/orbitalimpact/opal-pixi (draw to canvas using Ruby through Opal) and https://github.com/orbitalimpact/opal-phaser (a Opal port of the Phaser.io JS game engine), but how many people are using it? What if I want to do something with the canvas that the opal-pixi doesn't wrap around to yet? Should I open and inspect the library myself? I was not supposed to focus on this! - Integrating Ruby code in a Java graphical app built with Eclipse : I thought, maybe I could build the graphical framework of my application completely in a Java environment using a nice IDE with ready to go graphical-app templates, and then throw in some Ruby code at it for the fun parts. Result? I got sucked in Java graphical libraries issues and their concurrency patterns and GUI main thread and worker thread and whatnot Delegate and &lt;what&gt;(crazySyntax) Factory.Interface = Something.Crazy . In the end I did it. I built a little something but man, integrating Ruby with Java gave me another of those "you are among the only 3 people in the world doing this at the moment" feeling, and at the end of the day (week), most of the code was Java. Which my brain totally refused to store anywhere. Still sometime I go back to it in awe, because it was a little prime numbers visualization engine, and I really liked it. So I want to go back to it, but I don't :\ = frustration. Some others I tried in the very earlier days which led me nowhere at all and which I don't remember anything about (found about them in my email box, searching for GUI ruby): - http://wxruby.rubyforge.org - https://fr.osdn.jp/projects/sfnet_ruby-fltk/ - http://zerocaffe.in/2008/05/14/multiuser-chat-using-flex-and-ruby/ So, pretty nice journey, isn't it? In the end, recently I installed Visual Studio and made a C# graphic thing just to feel how it feels to work in that world... why can't we have that for Ruby? Now I think Flammarion? Well given it's resting on Electron development, which seems active and rocking, wouldn't this be the worst evil at the moment? The only working alternatives I feel to recommend are Opal and JRubyFX or integrating Ruby code in an Eclipse built graphical app...
Yeah, I thought the "tweet this" pull quotes were really presumptuous and off-putting.
That. I didn't comment on the article itself, though. Because there's no "magic" in programming: either you know and understand what something does behind the scenes, either you don't and are happy to use it without understanding it. That's not magic.
I would agree, that is not acceptable. Neither are all those unnecessary code-convoluting dots. `Post.where('owned_posts OR public_posts')` :) At some point you realize that you can't sell indirection as invention. RoR devs SQL-phobia has done enormous harm to the ecosystem and the community. - http://zedshaw.com/archive/indirection-is-not-abstraction/
I think you'll have to download and install PhantomJS from http://phantomjs.org/
An important step after the regular installation is adding PhantomJS to the PATH. It means you'll be able to use it as `phantomjs` in the command prompt on Windows, which is something the Gem you used requires. I'm not really familiar with how it works on Windows though, but Google pointed to http://www.joecolantonio.com/2014/10/14/how-to-install-phantomjs/
Yes you are right!!! I want to be that good.. someday.
Case and point. We probably wouldn't get along, as I'm know to have written 200 line scripts of pure SQL that runs in only a few minutes and can transform more that 2 million records in a batch.
Depends where you put it. If you put it in a model, or controller!!!!, then yeah, we won't get on. If you encapsulate it in a query object or maybe even a view model then we might remain friends. 
Agreed. Never seen that either.
Yeah, I also disagree with point three. That usage is highly idiosyncratic, to say the least, and I'd definitely challenge its inclusion alongside more canonical uses of the bang.
I agree with you, but if you tell me you refuse to learn SQL and are afraid of it [embedded in strings], I won't get along with you. Hard facts. Sidenote: What is with the downvote obsession? It is not a I think you disagree with me button (when I agree). This is a constructive conversation, thus not criteria for down vote.
&gt; Sidenote: What is with the downvote obsession? I would assume it's because you keep bringing up how either all RoR devs or the specific person you're replying to is afraid to use SQL. If you look back, no one has actually mentioned "not learning SQL" except for you. The original discussion was about ActiveRecord vs. Arel.
Not wanting to tackle complex SQL, or complex code in general, is very different from not wanting to learn the technology.
What is `YagniJsonEncoder#jsonify` used for? It seems completely unnecessary and penalizes performance significantly.
But that communicates nothing about the method. If I'm programming along and I see two methods "doThing", "doThing!", which both appear to do exactly the same thing and most examples are using either one or the other, why would I decide "You know, this bit of code needs 'doThing!'". To me, that is a bad method name. If you have two methods and one does more than the other then they should be named completely differently, not just differently by a bang. Something like "doThingAndUpdateCache" vs "doThing" and a separate "updateCache" method.
AREL was not developed because developers won't learn SQL. It was created to provide an efficient and standard interface to build valid SQL queries. Before AREL Rails' SQL builder was a hacky ball of mud. You're not even supposed to use it, it's considered a private API in Rails. 
Why advice the cumbersome Rails when he just need to compare a couple of uploaded CSV? Maybe what he wants is just Opal, and do everything on the client side. Easiest solution.
Strange how nobody yet has recommended new Flammarion: https://github.com/zach-capalbo/flammarion . Still early stages ok, but from the readme on their github it seems perfectly suited for your use case: "Flammarion is an easy-to-use library for displaying information that you might normally display to the command line in a slightly easier-to-access way. It is not intended to be a full fledged application development toolkit. It is intended instead for small scripts where you just want to show some information or buttons without going through too much trouble". This description may even sound a bit diminishing, because of course application wise you can do much more than "just show some information or buttons", that is, you can, obviously, process your data with other Ruby code. The devs here just wanted to point out that the Flammarion GUI itself hasn't got many different widgets and functionalities yet, but I think that GUI wise it has all you might need. If not, check out Opal (if your app can do everything it needs client side), and finally, if everything else doesn't fit, go with JRubyFX, which might give you the most polished outcome (in terms of graphics) but I'd say it's a bit too big given what you need to do. 
With the exception of Flammarion which may be a good suggestion and has just been released, but... Bowline? Seriously? It has been last worked on 5 years ago. And Ruby Reactive is even older, if it ever was a thing (I guess it has been nothing more than vaporware)! How do you think these are going to help OP? 
And I have absolutely no clue what you are talking about. Did you misreply? My code does exactly the same thing as the message I responded to.
It's also a common idiom. Chill. Are the expression police in town?
Any particular examples?
Just mentally interpret symbols as strings, does this make sense to you: &lt;%= f.label "title" %&gt; That's basically all it is. That string might be used by the label method to reference the name of a variable elsewhere, but it's not magic in itself. 
I have access to a RubyMine student license, any tips on setting it up perfectly? mind sharing your setup?
Yeah, I also noticed that almost all authentication framework are Rails and ActiveRecord specific, I recently tweeted about it. Then I found out about [rodauth](https://github.com/jeremyevans/rodauth), a relatively new authentication framework created by the author of Sequel. Rodauth is designed to ship with maximal security by default, featuring really advanced concepts like keeping password hashes in a separate table for which the main database user doesn't have read access to (so they cannot leak). It says that it's using Roda, Sequel and PostgreSQL, but none of these are actually required. Roda and Sequel are just an implementation detail, you can still use it with ActiveRecord and/or Rails. I haven't started implementing it yet, but I find it really promising as it does not tie you to a web framework or an ORM, making it usable for a bigger audience. And the author seems to really know security.
A symbol is basically an interned string. Useful for things you'd use an immutable string for. Labels etc.
In the context of `form_for` that will typically be used to represent an object, and those symbols will represent attributes of the model. It's all part of the 'conventions over configuration' mantra of Rails.
save vs save! Not everyone checks the return value of save. And imo, its better for your app to fail loudly than to fail silently and cause data inconsistencies.
Thank you for pointing me to this, looks very well thought out. It's not clear for me on how to plug it into a rails app so if you successfully do that, I'd appreciate an example. 
https://github.com/jeremyevans/rodauth#with-other-web-frameworks So just `config.use` it as a middleware in config/application.rb, it should work. I'm not entirely sure if this will make all your routes require authentication, or there is a way that you can choose which routes to authenticate. And also I don't know about templates, but I'm pretty sure that it should be easy now when Rails allows you to render templates outside of controllers. Yeah, Jeremy Evans is the developer I really trust, each of his projects is so well thought through.
Yeah, I agree with something along these lines too. It's always bugged me how `save` can silently fail; it's very easy to forget the need for an `!` in the code (or an `if object.save ....`), especially when quickly doing something in the console. I'd prefer: * `save` to behave like `save!` * `save!` is deprecated; temporarily aliased to `save` * Add a new method, e.g. `try_save`, to replicate the current behaviour of `save`. Or, maybe just insist people use `if valid? then save` * The behaviour of `save(validate: false)` remains unchanged (I think...)
Yeah, that is true. Outer Joins can still be a bit complicated to write in Arel, but [arel-helpers](https://github.com/camertron/arel-helpers) provides some nicer API around it. One goodie that it also has is that instead of `Post.arel_table[:id]` you can write `Post[:id]`, which can get rid of all the `arel_table` helper methods that you have.
My mistake. Thanks for the tip
Crazy right? Did you know in Ruby you can if something do_something end And it works without a comparator!? How is this valid code? /s It's generally appreciated when the point of a discussion is the conversation not some irrelevant detail.
I have no idea what you are talking about, I suspect you don't either, and you are being a very unpleasant person. 
I agree - this made me facepalm in the original article: &gt;&gt; The bang (!) does not mean "destructive" nor lack of it mean non destructive either. The bang sign means "the bang version is more dangerous than its non bang counterpart; handle with care". "Bang means side effects" or "bang means destructive operation" is simple and easy to understand. "Bang means less-safe version of another method which already exists and works differently" is a terrible rule, as its meaning and existence is inherently conditional on the existence of other methods (which you may or may not know or care about when trying to remember whether a method has a bang, or decide whether your new method needs to be named with one). And who's to necessarily say what "dangerous" means anyway? Is throwing an obvious, hard-to-miss error more dangerous, or failing silently and returning an error condition that may or may not be checked and handled appropriately by calling code? And as you point out, it's also horrible for consistency and future-proofing. It just reeks of creating potential future mysql_real_escape_string() situations.
That. As for the "too magical" for a newcomer, I'd say that the tutorial/teaching method fails at explaning the concepts behind Rails. The video course from the Pragmatic Studio, typically, demystify this pseudo-magic by explaining what Rails does behind the scenes.
I have not down-voted any of your comments, well, except [this one comment](https://www.reddit.com/r/ruby/comments/4585y7/why_do_you_need_arel/czx8lxv). All the rest were someone else. I can go and add my downvotes to all of them if you'd like me to. I have been doing SQL for 15 years and ruby for 7. I have never seen bare words like that in SQL. I did test it in postgres, and it does work so long as the column type is `boolean`. (I would not call it "truthiness", it's very much _not_ like what happens in ruby -- it only works on postgres 'boolean' columns, in fact if you try it on another column type, the postgres error tells you you can only do it on boolean columns). Learn something new every day, although I surmised that might the case like four posts ago. I still suspect it's not actually part of the SQL spec, but something some dbs allow anyway. Your suggested code simply does not do what the AR code you were suggesting it was a better replacement for... does. The AR code is not simply checking a boolean db column. You are a bitter and mean person. That's why other people, not me, are downvoting you. 
It may not only be me, but *reasons* why Crystal are very unconvincing. If any language/platform should take some serious attention of devs working in a well established ones, it has to be **magnitude** better to overweight transition costs, not just better. This is a general principle how market works. Great help would be full compatibility with existing codebase, with optional type definition and inference, but Crystal does not offer this. Ruby-like language is a very weak argument, when is not backed with even roughly comparable ecosystem. In many deployments existing Ruby code performance is not an issue, so argue in this area may not be so appealing as you may imagine. Also found funny the fibonacci example demonstrating performance boost, when rewritten in a sane non-recursive version is even faster in CRuby then the same produced by Crystal compiler. There was a thread about it not so long ago here on Reddit. Not saying this is doomed to failure but it need mature a lot. There is now so large competition in programming languages and their implementations, only stellar with unparalleled inventions may succeed. Not the same situation like ten years ago.
I'd turn it around -- what is the goal of _using_ a gem for simple code without any real gotchas that you can write in a dozen lines? Serious question. What is the goal?
&gt; by virtue of the fact that it can throw a runtime exception makes it inherently more dangerous than save. It's actually the other way around. Just imagine this: ActiveRecord::Base.transaction do foo.save bar.save end It looks like `foo` and `bar` are saved atomically, but that's not the case. If `foo` fails to validate `bar` is still saved, rendering the use of a transaction completely useless.
For your reference: http://stackoverflow.com/questions/12221211/how-does-string-truthiness-work-in-mysql As for the rest of your arrogant, condescending nonsense - you have shown yourself to be hardly a bastion of positivity, and rude as well being unable to discuss points without falling into tangential wells of irrelevant criticism. I've repeated this in every response to you, but you refuse to let it go. mysql&gt; CREATE TABLE test (id INT primary key); Query OK, 0 rows affected (0.03 sec) mysql&gt; SELECT * FROM test WHERE "10"; Empty set (0.00 sec) mysql&gt; SELECT * FROM test WHERE "asdf"; Empty set, 1 warning (0.00 sec) mysql&gt; SELECT "DROP MIC";
Elastic Beanstalk drove me crazy. I went with Amazon Opsworks. It is Chef based and works pretty well I think. A minimal amount of surprises. Only some stuff you have to add to their JSON for Postgres. You can easily add packages too to the machines.
I'm so confused! I've been using the [link you posted](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html) as a resource, specifically the section called Associated callbacks. There it says: &gt;Possible callbacks are: before_add, after_add, before_remove and after_remove. Those will not break my code, but will not work either. Then [here in the documentation](http://edgeguides.rubyonrails.org/active_record_callbacks.html) it lists a separate 22 possible callbacks in Sections 3.1 - 3.3. If I try to use any of those the break my code with an error listing still another set of callbacks: .rvm/gems/ruby-2.2.2/gems/activesupport-4.2.0/lib/active_support/core_ext/hash/keys.rb:75:in `block in assert_valid_keys': Unknown key: :before_ad. Valid keys are: :class_name, :class, :foreign_key, :validate, :autosave, :table_name, :before_add, :after_add, :before_remove, :after_remove, :extend, :primary_key, :dependent, :as, :through, :source, :source_type, :inverse_of, :counter_cache, :join_table, :foreign_type (ArgumentError) I've been all over the docs and the internet on this one and can't figure it out. To test, I'm using the .create method (I'm not sure if that answers your question): it 'changes user ta status' do expect(user.ta?).to eq(false) lab = Lab.create(seciton: 1, ta: user) expect(user.reload.ta?).to eq(true) I'm excited to get to the bottom of this! EDIT: reading more closely I was able to get the functionality working using a 'before_save do' block on Lab and calling a method in ta that accomplished my end. But I still feel like I missed the lesson here about using validation or association callbacks :(
I have no idea what that latest example -- which you have not repeated in every repsonse, it's the first time you've provided it -- has to do with the case we are discussing. Which is that Post.where('owned_posts OR public_posts') is in no way, shape, or form, an equivalent replacement to: Post.where(owned_posts).or(public_posts) And on the version of postgres I have at least, your version will cause Postgres to error unless `owned_posts` and `public_posts` are the name of columns defined as `boolean`, and it makes no sense for them to be with the domain/schema suggested by that example, your example makes no sense. That's what we've been talking about, right? That's what I was talking about anyway. I'm not sure what you consider a tangential well of irrelevant criticism. Dude, there's a reason everyone's arguing with you, calling you a jerk, and downvoting you, but if you get your rocks by being an asshole on reddit that's cool. Or maybe you're right, and it's really the entire rest of /r/ruby that's an asshole. Perhaps you'd like to find somewhere else to go with fewer assholes. 
While a valid question, this is a burden of proof fallacy. That being said, remember that a dozen lines of code also needs to be properly tested and all of the things that come along with adding code to your production environment.
An even cooler way to do this in Ruby is to implement your main function with the name "call". Then you can pass your class instance into anything that expects a proc. It quacks like a Method or a Proc but it's actually a class behind the scenes.
Didn't know of arel-helpers. I'll definitely look at it. Thank you.
I don't know what the goal is, which is why I asked originally. :) Wasn't implying that not using a gem was worse/better.
They do not do the same thing. When you do this: validate :paid_with_card? I would not expect it to do anything you want with the implementation of `paid_with_card?` you provide. If you provide a method name to plain `validate`, that method needs to "fail" by adding an object onto `errors`. It is in the Rails Guide here: http://guides.rubyonrails.org/active_record_validations.html#custom-methods You are doing that -- but do you really want to fail validation for any record unless it's paid with a card? You want to prevent any record from being saved unless it has paid with a card? If you did, the second example is on the right path, but that probably doesn't make sense. Your first example, `validates :card_number, presence: true, if: :paid_with_card?` I would expect to work the same way you do, I'm not sure why it's not from the code you are providing, I'd think it should. And indeed your example is _straight_ out of the Rails documentaton. http://guides.rubyonrails.org/active_record_validations.html#using-a-symbol-with-if-and-unless If it's failing to work correctly, it must be because of something in your code you have not shown us. Wait, double-check: What I'd expect the first example to do, is, *if* the user has `paid_with_card?` (that is, their `payment_type == 'card'`), *then* the `card` attribute needs to be filled out. If they have paid with card, and their card attribute is blank, validation fails. Any other situation (they haven't paid with a card, or the card attribute is not blank), validation does not fail. Is that what you are expecting to happen? That's what it should do. It validates the *presence* of the `card` attribute only *if* `paid_with_card?` -- in this case the source code line reads pretty much what it will do. 
I totally agree, if you write Ruby programs just like you would write them on Java don't waste your time.
Screw you, buddy. 
I also added a lot more information to the original post
Maybe, but uses POSIX RegExp 😉
I know it's annoying without the actual code. I apologize for that. Luckily so far it hasn't hindered our dialogue at all, since I think we're understanding each other perfectly. Your understanding of the 'validates , presence: , if:' setup aligns with mine. &gt;And it won't error. But it won't do anything either. validate :method_name, the only way the method has to indicate an error is by modifying the errors object -- returning false does nothing here. Doesn't the doc's example make it seem otherwise! Their example returns false, and is given as an example of validation. How is that not the most confusing thing in the world? It's true then that it still creates the object, which defeats its purpose as a validation technique. It doesn't prevent the object creation or trip the .to_not be_invalid spec. It doesn't invalidate. When you say it does nothing, it literally doesn't do anything at all. That's the behavior I observed but not the one I could expect given the documentation which has it verbatim as an example of a validation technique. Does my confusion make sense now? It's not even intuitive. The last thing is, given your example: validates :card_number, presence: true validate: :big_card_number? def big_card_number? card_number &amp;&amp; card_number &gt; 1 end The first line 'validates :card_number, presence: true' validates and ensures the presence of a card number, both that it is there, and that it is not nil (that is the very first thing put forth in the docs). Then, redundantly, you still have to have to verify that card_number is not nil as the first thing done in your method. What's that about? You see where I'm coming from on this? EDIT Also in a scenario where card_number is nil, won't your code fail anyway? EDIT EDIT What it comes down to is that any time you use 'validates' or 'validates_presence_of', you should be validating that something is not only there, it is there as not nil. But then when you move to the very next line and use 'validate' to call a method for the purposes of further validation, you have to again confirm that the thing is not nil, as if the previous line doesn't exist... The very crucial strange behavior I've noticed is that when you do that, not only does the more complex validation fail (validate :method), so does the one that was previously working just before you added it ('validates :value'). EDIT EDIT EDIT It's as if the 'validate :method' syntax gets called first, ahead of 'validates :value', which just doesn't make any sense.
[removed]
The docs don't make it seem otherwise to me, but I promise, that's what it does. I think you are looking at the example of a method passed to `if: method_name`, but thinking it's an example for `validate :method_name`. It is not. The method in the `if` determines _whether it runs the validation at all_. That's what the `if` is, whether to run the validation otherwise specified previously, not the rules for the validation itself. In your latest code example, the first line `validates :card_number, presence: true` says the attribute `card_number` must be present -- non-nil, and not the empty string. For all records, since you didn't provide an `if`. The second line `validate: :big_card_number?` will do nothing. Because the method you give to it, `big_card_number?`, just returns true or false. The method you give to `validate :method_name`, which doesn't usually end in a quesiton mark, needs to add to the `errors` list if it wants to invalidate. That's how it works. i've said that three times now, right? Sorry, I guess I'm not being clear, but I don't know how else to say it. You do **not** need that second line -- because in fact it does nothing. Again, I keep asking you **what do you want to do**, and you keep not saying. If you want to make sure the `card_number` attribute is there, all you need is the first line. If you want to make sure the `card_number` attribute is there, *but only for cards which have certain ohter conditions, like payment type is 'card'*, then you need to add on an `if`. You don't need the `validate :method_name` line unless you want to do something else. Anyway, hope that helps, good luck. 
`validates_presence_of :name` and `validates :name, presence: true` both do the same thing. They validate the "presence" of the `name` attribute, using the built-in validation rule for "presence". In Rails `present?` means non-nil and non-empty-string, for Strings anyway. So they are both saying that the `name` attribute must be "present" -- `name` must NOT be nil, and NOT be the empty string -- or else the record is not valid. If `name` is nil, or `name` is the empty string, then the record is not valid. They will both run on every record, unless you provide an `if` saying to only run on some records. Asking `valid?` means asking if all defined validations passed. In that example, the `Person` class is defined to validate the presence of `name`. The first line has a `name`, so it is a valid record. The second line has a `nil` `name`, so it is not a valid record. I think that's exactly what the docs show, I'm not sure what you think contradicts what. 
&gt; It's because I'm specifically using presence: :true, isn't it!?!? You are right. `validates_presence_of :name` or `validates :attribute, presence: name` both say "Use the 'presence' validator on the `name` attribute. That's just one of many built-in validators, or you can always write your own. &gt; Is there a built-in that checks not only for presence, but for the presence of a nonempty, non-nil value. Yes, it's "presence". The built-in "presence" validator says that the attribute mentioned has to be "present". An attribute being "present" means it has to be defined (can't be nil), and if it's a String, it can't be the empty string. I feel like I just keep saying the same thing over and over in slightly different words. If you are using the Rails Guides to figure out how things work, I suggest starting at the beginning of the particular Guide, and ideally understanding each section before moving on to the next. If you start with the advanced features before you understand the basic features, yeah, it's going to be confusing. Or find another source than the Rails Guides, they are generally written for a non-basic level of developer, who understands the basics of programming, ruby, and web development, but needs an overview of how Rails works. 
It seems like the better idea for a preloader would be to just preload all the gem dependencies, and boot rails fresh each time.
Easier thought then done, when so many things keep things in global state. 
I PMed you some code
It does when they are modified, don't recall if it does when new ones are added. 
Am I missing something, the whole thing was an introduction/overview, didnt see a lesson
This is valid Oniguruma (i.e. Ruby 1.9+), but not POSIX: `/(?&lt;paren&gt;\(\g&lt;paren&gt;*\))/`.
&gt; It gets worse when you have a LOT of gems If that's your case then I recommend https://github.com/byroot/bootscale It can provide nice boot speedup if you cross the 100 gems mark. Your mileage may vary though.
&gt; What the OP is trying to do doesn't even require a server side so It doesn't *require* a server, but I've discussed with the author that it is *desirable* to have a server so that his users doesn't have to bother with installing software.
If you want your gem to be able to take advantage of oj, there isn't anything wrong with that. The right thing to do is to use oj if it's there, but fall back to the ruby json library if it isn't. The wrong thing to do is to add a hard runtime dependency on oj.
Still that server could simply serve a simple one page app (Opal)... Much swifter.. and no need to learn a new framework..
Throw (not to be confused with C++ throw), give, produce are other words that might fit yield. yield in Ruby simply calls the block that is provided to a function. For example: def test yield "a" puts "b" yield "c" end test do |str| puts str end This program should output: a b c 
Yield means "to give over." In the context of Ruby, it means "give control flow over to the block." That is basically the definition of "calling" a function, so you can think of `yield` as a function call. In fact, these two methods are identical: def mr_yield yield 5 end def mr_call(&amp;block) block.call(5) end So yielding to a block, and calling a block, are the same thing. Yielding has slightly better performance, though.
I meant using the generated methods explained at the top of the document. Because you declare `belongs_to :ta` you get methods like `build_ta(ta_attributes)`and `ta=(ta)` added to instances of Lab. So something like: lab = Lab.new(section: 1) lab.ta = user Does that work? Edit: checking out the rails source, it looks like `ta=()` should be called in your example using create: https://github.com/rails/rails/blob/4-2-stable/activerecord/lib/active_record/attribute_assignment.rb#L53 `Unknown key: :before_ad.` is a typo :)
http://guides.rubyonrails.org/form_helpers.html#binding-a-form-to-an-object There are really several styles or ways to building forms in Rails. The one you have shown is described in more detail in other parts of the Rails guides, as I linked above. This style assumes that most of your form fields are going to be related to attributes on a primary object. In this case, the primary object is denoted by `:article`. You can read more about some differences in using a symbol or string vs. an actual object as the argument to `form_for` [here](http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_for). Later, when you have things like `&lt;%= f.text_field :title %&gt;` in your form, the `f` means you're reusing the same context created by the original `form_for` method (i.e. the `:article` object). And the `text_field` method can also accept a symbol, like `:title`. This means it will assume that you want to show and edit the `title` attribute on the article that you're using to build the form.
Thanks for pointing this out. Also using Sequel with rails, I'm writing user auth with [shield](https://github.com/Copywright/shield) &amp; was about to write basically all the features of rodauth. I saw this, but didn't think it'd be compatible with Rails.
Why the difference in performance?
I ended up getting around it with a method in Grad and this syntax in the Lab model: before_save do Grad.update_ta_status(1) end It works, but it's always only a half victory when you don't understand why you had to abandon the thing you are working around. I'm not sure if it would work with an arg either, since it has to be converted to a symbol. For instance, :update_ta_status(1) would be strange right?
Are you using a ruby manager like rbenv or rvm? If not you need sudo to work with system in my guess in this case. 
You must not be `require`ing the file that contains that code when you require the gem. Perhaps you need to put a `require` at the top of the main gem file (probably in './lib/name_of_gem.rb`?) that requires that source file? Or maybe you have an old version of the gem installed on your system, that didn't include the right code? Uninstall and reinstall?
I didn't think my gem file required anything (my gem file IS the file above) - I thought I just had to require my gem in my test file? Here is my test file (test.rb) - colorizr.rb is the code above: require 'colorizr' puts "John".red puts "Paul".green puts "George".blue puts "Ringo".yellow p String.colors String.sample_colors
yeah, don't use the system ruby for anything.... you'll be much better off using rbenv or rvm.
The gem is just one file containing all the code in my initial post - it is in a lib directory (lib/colorizr.rb). I created a gemspec and put that in the same folder as the lib folder then I used 'gem install colorizr-0.0.2.gem' to install the gem. I did all of this manually, but copied some of the gemspec code from my class directions - the install was succesful!
I suppose! How do I remedy this?
I'd recommend making sure you understand what the code you're copying is doing. It's just ordinary ruby, nothing tricky. You couldn't find an answer googling because this isn't really a feature of optparse or anything, it's just writing ruby code. Well, actually, the only slightly tricky thing, which is a feature of optparse (which I had to look up myself), is that printing the `opts` OptionParser object will print a usage message generated by the OptionParser object. 
1. uninstall the gem `gem uninstall colorizer` 2. run `gem list` and make sure there is no colorizer gem installed. 3. in your test.rb do a `require 'full_path_to_colorizer.rb'` Can you get this to work? Once you have this working and fixed any bugs, install the gem and replace the require with only the gem name and test again. Alternatively; you can also do the following; `gem contents colorizr` to find out where your gem is installed. Look at the installed source code to see if it is the correct version. You can make changes to the files directly where they are installed and test. 
Excellent. I'm glad it worked out.
Why not use one argument to hold the travel method? ``` $ ruby flyordrive.rb --method fly ```
I would say that option 2 would be the best bet. On the server that doesn't have internet connectivity, simply change the gem sources list to include only your private gem server on the same network as the gem server.
I'll be looking into the gem server setup later today. I think that is likely the best solution. Thanks.
im actually still having issues! i want to try this: https://github.com/alexch/learn_ruby im getting the same issues as this person: http://stackoverflow.com/questions/24441640/how-to-downgrade-rspec-3-0-0-to-rspec-2 but im not sure how they initialized the rspec. when i run this in the directory, I get this name error: rspec_config.rb:1:in `&lt;main&gt;': uninitialized constant RSpec (NameError)
I disagree. I think pattern matching is a damn fine thing to implement in Ruby. It's one of those things I find myself reaching for every now and then and realizing it isn't there.
For writing Ruby this way I was a fan of this gem - https://github.com/jdantonio/functional-ruby. I'm not so sure it's worth the cost though, you end up with some weird behavior when things go wrong.
Tough call on this one. There are people who have written "Haskell-style" type systems with contract.rb ... It's not Ruby, but it's an idea. Ruby is open. I might never use this in production code.. But I think it's great if it can be done.
For me, it's that you are going to end up handling a lot of different exceptions in the rescue block - not only related to opening the file. For example, you assume that the file is a correct CSV file and perform processing. Suddenly, CSV::MalformedCSVError appears and you handle it in the same place where you are handling non-existing file, unaccessible filesystem or permission problem.
I also like Elixir, and I've done [a different kind of experiment](https://github.com/alehander42/matchete) to try to use pattern matching in ruby(ok for overloading methods)
You can always add multiple `rescue ErrorType =&gt; e` blocks and handle each error you are interested in, while leaving an empty one for "others".
This is pretty cool, man! ;)
But this is no different to you counter-example, with binary result ok/error. You'd also need to condition *error reason* to handle a specific failure. As the user [otikik](https://www.reddit.com/r/ruby/comments/45te5p/my_quest_for_having_patternmatching_in_ruby_is_it/d00ihww) already responded, you may yet to discover full potential of exception handling mechanism in Ruby.
If you have had a java background, its kind of like saying Enumerators are objects which "extend" the enumerator super class and "implement" another object's (the object you are enumerating) iterator as the basis of the enumeration. I don't know if that is helpful, but it still seems more clear that whatever you posed, pretty poorly written imo. Its not wrong per-say just really awkward to read. 
BTW, *per se* is Latin, so it's spelled like that.
That's because super is a special case and implicitly passes along the original parameters. If you want the parameterless call you'll want to use super()
&gt;Enumerator objects are Enumerable objects `Enumerable` is a module that provides the ability to enumerate. `Enumerator` is a class, so it's possible to build objects that are `Enumerator` instances, which you can't do directly with `Enumerable`. &gt;with an each method That means you can call `#each` on `Enumerator` instances. &gt;that's based on some other iterator method of some other object /u/sac_boy gave you [some examples in an earlier comment](https://www.reddit.com/r/ruby/comments/45w0zm/can_somebody_explain_this/d00kkme). In one of his examples, `[1, 2, 3, 4, 5].each` returns an Enumerator object, which he uses later to actually perform the enumeration. And how it works is based on how `#each` would work on the original Array.
If you look at how [Enumerators are created](http://ruby-doc.org/core-2.3.0/Enumerator.html) you will notice that an Enumerator basically stores a method call which is executed later. It will contain * the receiver * the method to invoke * a (potentially empty) list of arguments to pass to that method The method (with arguments) will be invoked once you invoke the Enumerator's method *each*. irb(main):001:0&gt; class Foo; def plus(a, b) yield a+b end end =&gt; :plus irb(main):002:0&gt; f = Foo.new =&gt; #&lt;Foo:0x00000600086988&gt; irb(main):003:0&gt; f.plus(2, 3) {|x| p x} 5 =&gt; 5 irb(main):004:0&gt; e = f.to_enum :plus, 9, 5 =&gt; #&lt;Enumerator: #&lt;Foo:0x00000600086988&gt;:plus(9, 5)&gt; irb(main):005:0&gt; e.each {|x| p x} 14 =&gt; 14 irb(main):006:0&gt; e.map {|x| x*10} =&gt; [140] irb(main):007:0&gt; e.class =&gt; Enumerator Hope that helps.
Yep, I'm pretty sure that's exactly the problem. You won't encounter the issue unless working with a pretty big test suite though. 
Yeah, I should have said that better. Thanks. `Enumerable` relies on a provided `#each`, which can come from other classes (not necessarily, but including, `Enumerator`).
Maybe you just missed it? From the page: &gt; Another difference between procs and lambdas is how they react to a return statement. A lambda will return normally, like a regular method. But a proc will try to return from the current context.
If you return a binding from a method, is there an easier way to access the variables in that binding other than `Binding#eval`? For example, could I merge the currently-executing binding and some other binding together, then just access all the variables directly?
You're right, i missed it :) I'll amend my previous comment!
You could use `Binding#local_variable_set`/`Binding#local_variable_get`, but this requires you to know the names of the variables you want to set/merge. What are you trying to accomplish?
WTF is that from?
I actually prefer http://localhost:3000/rails/info/routes
Thanks.
http://shop.oreilly.com/product/9780596516178.do
Reminds me of [this](http://brewhouse.io/blog/2014/04/30/gourmet-service-objects.html)
There's also [`super &amp;nil`](https://eval.in/519185) for when you don't want to pass along your block.
Thanks for that! Tried Googling for a while but found nothing helpful. Probably would have been easier if I had known what stack backtrace limit was.
I typed User.find(3) into the rails console and got all that. All I needed was the first line to know that there is no user with id=3. The rest of the output is a waste of space and makes using the command line much less pleasant.
name='commit' is a Rails convention where the value of the button clicked is passed in via params[:commit], just FYI, so in this case that's why it's unneeded
Also useful: ctrl-l That's 'control-L', a quick &amp; easy way to clear the terminal to make the trace just go away.
(Shameless self-promotion) I've once tried to imagine how pattern-matching _could_ look the Ruby way: http://zverok.github.io/blog/2015-07-18-matchish.html It almost seems useful for some tasks (like very liberal input acceptance), but final conclusion was sad: pattern-matching either should be part of the language, or it's just a toy. Ruby has its own (imperfect though useful) matching, and its only as far as we can get.
Using `pg_search` "raw" like that will work at the beginning, when you have a few registers in your table. When you reach 10k it stops being enough, and you have to add a column to cache the tsvector calculations. That is trickier than it seems. Ping me if you need help!
Its from the book 'The Ruby Programming Language' and it confused me too. so asked the explanation here 
Thanks a lot.. The example referring helped 
The current MRI ruby is faster than jruby even after JIT kicking in. For my simple CRUD script, the MRI ruby is consistently faster compared to the jruby when benchmarked.. MRI JRUBY 1.005024939 6.396620273000735 1.01994629 2.9825048270013212 1.000836561 2.202381801998854 1.01609624 1.9242104969998763 1.066627389 1.914059388998794 (JIT) 1.012485406 1.715996187998826 1.063379629 1.7128156079998007 1.029687341 1.7107112009998673 1.023099508 1.6651686868634429 1.069038478 1.645765251998455 Perhaps the real power of JRuby's JIT would be useful in dealing with large concurrent operations.. 
Why is error handling in Go ridiculous?
[PDF Toolkit](https://www.pdflabs.com/tools/pdftk-server/) (pdftk on command line and `aptitude install pdftk` on Debian/Ubuntu) will probably do everything you need.
Was bored so gave this a quick go. Installing firebird-dev seems to fix the problem.
`combine_pdf` gem worked really well for me.
Not using exceptions for flow control is a general principle across all programming languages. Exceptions as flow control is the same code smell as `goto`; it bypasses the execution flow of the program entirely, leading to nondeterminism and confusion. In no programming language is it "idiomatic."
Good write-up. Concurrent::Future is worth looking at, but won't get you out of needing to do AR connection management, each Future body will still need to be wrapped in a `with_connection`. 
That may be the case here, but sometimes, the real problem can only be determined by something way up the stack trace. 
It's not This code (BTW it's `next` not `take`) require 'thread' xs = (1..1_000_000).to_a.to_enum threads = (1..25).map do Thread.new do begin while x = xs.next x+=1 end rescue StopIteration end end end threads.each(&amp;:join) fails with various errors. Thread-safety doesn't only mean "no sharing violation", it also means that operations from different threads won't mess object's internal state, and that's definitely not the case regardless of the interpreter implementation.
When testing and only using `Concurrent::Future`, I did not see the same connection consumption. However, when using `Concurrent::FixedThreadPool` and the executor pattern, I saw the same problem.
Yes, you are right. My fault for not checking `to_enum`.
The prawn gem is a pure Ruby implementation of PDF and works great for a lot of use cases. Not sure, though, if it can concatenate existing Documents.
I guess `User.where(id: valid_users.map(&amp;:id)).update_all(valid: true)` will do the trick.
Exactly right.
Nice! An [alternate approach](https://eval.in/519901) is to hook `#method_added` so that you can trace methods which are defined after you've already started tracing. Also, you can avoid the need to muck with method aliasing and `#send` by using `Module#prepend` to put your tracer at the front of the ancestor chain and then use `super` to invoke the original behavior.
Cool. I still think it's worth mentioning ruby-concurrent in your 'Alternatives' section, it's a great library, and using either ThreadPool or Future from there has a number of advantages over writing threads yourself manually -- it just doesn't save you from having to do AR connection management. 
This would probably be something like this: `break if VALID_CHOICES.include? choice` immediately after input. You often see guard clauses as one of the first lines of a method, where they'll raise an exception (or return some specific value) if the arguments provided are invalid.
I understand that's a possibility, but if he had looked at the link he would have realised that's not the case here. He also came across as condescending. 
Thanks, will give it a try. Unfortunately, I'm tied to firebird 1.5.6 and the PPAs are all for 2.x, so I'm not sure if this will lead me in the right direction or not. Worth a shot, though :)
Very cool. Nice stuff.
Reading up on module#prepend is one of those times where I quietly thank everybody for being cool for once and adopting a language this fun.
Ruby has a pretty nice tracing functionality built in. http://apidock.com/ruby/Kernel/set_trace_func
the pattern is something we can agree upon, just needs proper coding 
15 minutes for all rspec tests, java unit tests, python tests, javascript tests, and packaging put together. We have a Jenkins master with 80 worker nodes. Each build consists of ~25 jobs, about ~20 of which can be run in parallel. edit: Ruby project is 32k lines code and 30k lines tests. Java projects are 228k lines (code and tests together).
If anyone's interested in this kind of programming style, then it's worth researching the Aspect Oriented Programming topics.
Very nice! Thank you for sharing.
33k LOC Ruby project + 30k LOC specs: 15-20min\* on CI, I never ran it locally. Long test suite runs don't bother me much as long as individual unit tests are snappy and don't load dozens of gems and the entire rails stack... (so, almost none because people insist on using `blank?` or `try?` everywhere and consider `require` statements ugly... :( ) So, considering the code size and keeping in mind that it's Ruby I'm actually quite satisfied. The 2-3 randomly failing integration tests we learnt to ignore and the 20 line setup including several SOAP stubs and database inserts required to get the dashboard working are another story... \* This includes some Java and Rust tests as well, but they both run in under 10s.
We were using Ruby 1.8 almost a year ago and it took 25 minutes to run 2k tests (over 250 models and 300 controllers, poor test coverage though). After updating to Ruby 2.3 it runs in 5 minutes max. 46k LOC Ruby + 12k LOC specs
&gt; The 2-3 randomly failing integration tests we learnt to ignore For my own question, I have been wondering how common this is, if you're lucky just to have 2 or 3 even. I think it may actually be pretty common. 
Holy crap, I was coming to bitch about our project. Rails app at 8k LoC in Ruby, with parallel_tests specs run in about 6 minutes on CI. 100% code coverage, 96% unit test coverage.
The solution to prevent slow test suites is simple: design your code to be isolated, and you'll never have to invoke those slow dependencies. You should be averaging over 1000 tests/second using traditional unit testing frameworks. Make sure you don't use mocking libraries to achieve your desired test speed. You can arrive at a really fast, larger test suite without using a single mock or stub if you understand design patterns and how to substitute slow dependencies.
I'm under the impression that rspec is really slow compared to minitest. Not sure if I'm right though. Maybe some minitest users with large test suites can weight in? Integration/acceptance testing (capybara/poltergeist) will always be slow of course, but these can easily be split into a seperate rake task.
Largest Rails app: 35k loc, 22k loc(tests), ~3000 tests. 5.5m for full run on travis, under 5 locally.
We're using minitest. I think at our scale the difference is negligible. Our issue has more to do with callbacks, factories, hitting multiple databases during test runs, lots of tests that should be considered integration tests as unit tests, and global setup/teardown debt Right now I'm thinking the best first step is what you said: separate the slow stuff to at least get more cross cutting smoke testing
The pattern, in general, is to use a test double. Stubs are actually okay, but I am taking issue with common mocking libraries for ruby that allow for on-the-fly monkeypatching of objects. For instance, `stub(SomeSlowDependency).any_instance`.
Test suite?
Seems like we use slightly different terminology: http://martinfowler.com/articles/mocksArentStubs.html I would call `double(value: 20)` a stub.
Right, the distinction I'm making is whether you are passing in a substitute for the dependency, or whether you are modifying the dependency externally from the test. There is more to it than this, actually it is a much bigger topic.
I disagree, I think splitting out the slow stuff is actually very easy. We built out a gem for tagging in minitest and can record the test time easily with a reporter. Then we can just record everything to a file and tag based on the time to run the "fast" stuff or "slow" stuff. Can also add some warnings if something is improperly tagged
While understanding that communities are often exclusionary, I'm unconvinced all this COC stuff is a good idea. Or at least I have yet to see one that is going to do little more than make a few people feel smug and just generally irritate most everyone else. Honestly, it just looks like some strangers trying to force their ideal community on every other stranger. My response is always a mix of, "they did NOT tailor this to their audience, the wording is going to grate most" and "where do randoms get off trying to dictate how everyone else is supposed to conduct themselves? Where do they think they get the authority?" *Edit: Ditch the authoritative nature and rename this to Guidelines for Conduct (not as nice I admit) and I bet people would swallow this fine.
Couldn't oppose this any harder. It's absolutely critical to have an unobstructed narrative. If people get offended, let them. I don't plan to participate or abide by this CoC, and I ***hope*** I offend someone as I continue to use Ruby. It's shit like this that ultimately leads to Orwellian communities. Policing other people's speech or thoughts or opinions, removing the aspect of the individual from the narrative, etc. 
While I respect and applaud the desire to have people treat each other with respect, I really don't feel like this accomplishes anything. Being able to point to a list of items that should be common sense provides no real value, IMHO.
[And if all else fails](https://en.wikipedia.org/wiki/MINSWAN)
Bob Martin has some really good ideas in [here](https://www.youtube.com/watch?v=WpkDN78P884). TL;DR: decouple your Rails application from your business logic. Many of your tests will target POROs, so tests should run much faster than if they have to load up a Rails application and access a database. 
Actually, no - we have no ActiveRecord models. It's all API models. One of my older projects had a lot more in AR and it was running with factory_girl though. Our unit tests are fast, the feature specs (which account for the majority of them) are the big time sucker. I spent a day recently cutting the time on these to drop us from 10 to 6 minutes by cutting out a lot of stupid things (GTM, New Relic, etc were all always being added and hitting the live sites. Blacklisting them in our Capybara config cut 2 minutes off our runs). Didn't mention, but we're running 4 processes for our specs on CI, and this is Ruby 2.0.0
Nice!
For what it's worth I agree. I modded you up and now you are at -2. The 'assume good intentions' stuff is naive and only lets people with bad intentions cause more harm. Look at the nastiness that scared off all the good wikipedia editors.
Truthfully I think most people either just accept flaky tests or don't have integration tests in the first place. We have been having tons of problems with our feature tests + angularjs app (some of the problems due to the way the angularjs app was written) since the beginning, and have largely found little help.
Or... You could just try not being an asshole. All this thought police nonsense makes ya'll sound like petulant children being told they can't make fun of the other kids on the playground.
80 worker nodes. Hot damn. 
Nice you even got tagging. Can you calculate total test coverage or did that break?
Well, you're an asshole for disagreeing with me. Why don't _you_ try not being such an asshole, you ludicrously horrific asshole?
I'm a hobbyist programmer, working on my Series 7 right now to change industries, got an offer from a firm here in NYC. So now you, probably make a salary and work in a cubicle? Wow cool. /s
I disagree. I think "too magical" implementations are harder for advanced users, and easier for beginner users. Beginners have no concept of what a "normal" interface looks like. They don't care how arguments are passed or how methods are defined. They will blindly follow tutorials and trial-and-error their programs until they work. I've been writing Ruby since 2007, and I want is a clean well defined interface, I want sane docs. If I have to guess-and-check around your library it's not helping. If I typo something and your library fail silently that's not helping me. If there's no docs on how to use a feature, that's not helping. If you use eval and method missing all over the place and make it impossible to debug http://www.schneems.com/2016/01/25/ruby-debugging-magic-cheat-sheet.html that's not helping. "Too magical" programming hurts advanced users the most. 
Got it. Someone who doesn't have a clue how professionals behave and succeed.
At my former employer, we had 100k+ LOC, 5k+ unit tests, and 3k+ end to end tests in cucumber. Full run was 2.5 hours. Of which the unit tests were &lt; 10 minutes. The cucumber tests were meant to take a long time. They did a full end to end using capybara, selenium-webdriver, etc, etc. I was the QA lead, so I put a large amount of time in to create a sub-suite that hit all the functionality but didn't run every permutation. That was &lt; 45 minutes if I recall correctly. Between that and the unit tests, we could have a fairly reliable quality during development. And we'd run the full suite before pushing a newly merged master branch. Also, this was Jruby ~1.7 i think. So we were equivalent to MRI ruby 1.8.? i think.
&gt; You could just try not being an asshole. .. &gt; Let me guess. You're either a student, low level code-monkey What's wrong with lower tier workers? Everyone has to start somewhere...
So... by your example here, professionals should behave in ways that include sassing their assumption of someone else's professionalism, on the basis of Internet disagreements? Who's the asshole here then?
Thanks for the confirmation. I've got a giant novel of a blog post coming for you soon, although it doesn't offer any magic bullets. My conclusion is basically that feature tests on heavy front-end JS are best avoided, although there are some things you can do to try and increase reliability. 
It sounds like people here are saying to avoid factories and mock data like Faker for example. But then how do you test your business logic? Or is it implied that minitest and fixtures are faster?
We don't really keep track of it. We have so many tests and the testing culture here is good enough that it's really not important
~11K RSpec specs with parallel_tests in JRuby across 2 threads in about 3 minutes ~100 Capybara specs single threaded in JRuby in about 8 minutes (parallelized these for a while, but they were super flakey so I'm still working on that) The latest version of rubocop uses caching so that's &lt;15 seconds We also precompile everything with every deployment, which I parallelized across 8 threads to run in &lt;2 minutes
I feel like leading by example, and effectively self promoting that, would be more effective than just asserting everything has to be doing a thing now. Also, I've never seen MINASWAN mentioned before. That's nice, thanks.
Yeah, i've written that functionality myself in a couple places but we consider it a temporary measure. 
- who represents *we* from the preamble ? Not signed by an author of these words. - are there some serious cases in the recent past which did harmed Ruby developers collaboration ? How should this CoC fix the cause ? - how could Ruby development reach current popularity and widespread without prior existence of such rules ? How could went so many meetings, conferences, workshops ? Many dev-groups originated ? I like Ruby didn't get soiled too much from politics and would prefer if this would stay as it is.
Millionaires?!?! OMG I'm sorry sir. I didn't know you dealt with millionaires. If you *really* want to have a dick waving competition about careers we can. I've been a developer for 25 years building everything from the first online services to robotic factories. I'm sure your limited schooling and experience will hold up. "Deals bigger than what you make in a year" what kind of yardstick is that? I know, it's the kind of yardstick someone with not experience uses.
You're railing against the entire community because a few had a good natured idea but delivered it terribly with false authority. You alienate everyone across the board except other like-minded reactionaries. This is the response they engender by being pushy. In the end, everyone loses. Mostly the rest of us in the middle. 
You know what I'm learning? It's that fucking losers talk a lot, and then scurry to the bank to scoop up the scraps of their poor choices. 
Keep projecting son.
Nice. It's just 4 bullet points. I'd like to see those bullet points up under the title, and then an 'About the Code of Conduct' underneath with those few details ('based on the pgsql one'; 'ruby-related communities like conferences can pick their own'; 'applies to collaborative spaces like mailing lists, patches, issue comments'). Ie, calling out **loud and clear** to everyone that it's just these 4 simple points.
&gt; I think the secret lies in how mongoid-sadstory requires mongoid (which potentially ensure mongoid is loaded first?) but I have been unsuccessful finding information on this and testing locally. Any ideas? that's it. It's just monkey patching it.
You really can't see how not being a dick to people you work with is a bad thing? REALLY? 
Actually, let me tell you a story. I worked the hardest job in the country once, as a wee lad. Canvassing. You know those guys on the street that ask for money or time and then pitch you on some organization? Sounds easy, right? Far from it. It's demoralizing to stand out there all day and try and get 'stops' as they're called, throwing out your lines and jokes to try and stop people to deliver a pitch. The pitch is usually like fucking ENGINEERED to perfect so that the person is interested and you memorize it before you go out. Anyways, it's fucking demoralizing. What sounds like a pretty simple, easy side-gig turned into standing on the street for ten hours a day while people walk past you and call you names, tell you to 'get a real job' or to fuck off. Someone in your shoes right now would complain about people 'being dicks' or harrassment or whatever. In reality, canvassers serve a critical role for some organizations like Amnesty, Greenpeace, et al, and without that street-level meatspace presence people wouldn't even think about some of these organizations out there making positive change. After the first few days, you just tough up. There's nothing you do or can do to change the way that people act, and that's OK. It's just like a zen thing, people are rude and move on. You can lay there like a fucking fish, flopping around and flailing about in the name of MINASWAN or good intentions or whatever you want, but it doesn't change anything. I canvassed every single day for more than 3 months before I found something else. Over 90 days in a job where half of the candidates never come back after the first day, and I'd estimate around 90-95% don't come back after the first paycheck. So no, being a dick isn't a bad thing. You'll get over it, or you won't. I don't blame people for being rude to me and I have too many goals to stop and consider the feelings of everybody I meet and police my every word. I do sort of play a character when I talk about these things, because it's relevant to what it's actually about. Of course if I was working with a guy doing like pair exercises or whatever and he fucked up, I wouldn't look at him and say "ah you fawking moron, you fawked it all up" I wouldn't even acknowledge it. He'd fix it or I would or whatever, and we move on with our lives. 
I was gonna post it to /r/rails, since it's rails specific -- but /r/rails also seems to be mostly newbie questions. Maybe I should just put it here?
No, you're wrong. So there. 
Wait, which part do you plan to violate? You plan to be intolerant of opposing views? You plan to use lots of personal attacks and personally disparaging remarks? 
As much as possible, but if there was a part that I PARTICULARLY intended to violate it's that anti-harassment portion.
Physical theft (and even digital "theft") is a different issue from verbal insults. I'd even argue that stealing things from other people is a natural thing to do in certain situations, for survival purposes. There's never any point where insulting someone on a mailing list is going to save your life.
So you plan to be intolerant of opposing views, use lots of personal attacks and personally disparaging remarks, and do lots of things which can be reasonably considered harassment.... why? And why would you think anyone else would want to have anything to do with you behaving like such an asshole? 
I don't. I expect them to tough up and realize that not everything goes their way and no matter what rules they make, it's just not how life works.
No one wants to hear "fucking relax, you're off the mark a fair bit". They'ed all rather just yell over each other. 
So, it will likely be just how life works for you that nobody really wants to work with you or talk to you, right? 
So you told me a story about a non-professional job as a way to prove you know how professionals act? I'm sorry people were mean to you in your shitty job. That doesn't give you license to be a douche to your co-workers. 
The issue is the modern definition of harassment that has come out of Tumblr and Twitter. Simply disagreeing with a minority can be construed as harassment now in the wrong crowd. We can't say "this is bad code" any more because it might hurt someone's feelings.
&gt;Wait, which part do you plan to violate? Are you serious, man? Surely you can imagine a situation wherein you'd oppose a legal ban on x, even if you don't do x yourself. &gt;You plan to be intolerant of opposing views? You plan to use lots of personal attacks and personally disparaging remarks? Perhaps his concern is not the letter of the law but who's interpreting it and with what boundaries on interpretation. 
Yeah, no mention of those things that don't need to be said, but whose ever lingering threat of being accused of doing is used to enact authoriatian measures and create persona-non-grata against people for doing things like, say, being for freedom of expression. 
The idea is that, ostensibly, the community is disinviting to X minority because there are not explicit rules to not contribute to their oppression/not to sexually harass people. Given that these people believe we live in a cis, white, hetero patriarchy where toxic masculinity rules supreme, rules that are not in place to explicitly combat this contribute to the status quo. 
That was years ago, as you might actually read. Perhaps I'm only douche-y to you?
Wait, how many innocent doe-eyed fluffy little puppies are you planning to strangle?
http://www.ashedryden.com/blog/codes-of-conduct-101-faq
Interesting, and thank you for the detailed reply. The rspec and unit tests--how did you split those across workers? We have parallel_tests going on and it's one machine, one Jenkins node, one job gobbling lots of cpu. Also, who manages this sort of infrastructure? Do you have dedicated build engineers or is it a shared responsibility between IT/ops and devs?
&gt; I don't know what I was thinking engaging in this discussion though. My guess is some Phelpsian argument of the form "everyone who opposes this Good is either a Bad, or a Bad Enabler".
Stuff likes this make me realise I should write more blog posts :). For rspec tests parallelization there are two ways you can go: distribute tests across machines or distribute test files across machines. I'm just gonna talk about the latter, as it's way shorter to explain. Each of the 5 rspec-test-machines calls a rake task with 2 numbers: - the first number (let's call it 'index') ranges from 0 up to and including 4 - the second number (let's call it 'nb_groups') will be 5, as there are 5 rspec-test-machines The rake task then executes the following pseudo-code: # grab all the rspec files we want to be executed by a machine with a given index files = Dir.glob("#{rails_dir}/**/*_spec.rb").sort.shuffle(:random =&gt; Random.new(1)).in_groups(nb_groups, false)[index] # start a child process that runs these rspec tests by executing bundle exec rspec &lt;files[0] files[1] files[2] ...&gt; We use Gradle for our Java unit tests. One way of splitting unit tests is to have each unit-test-machine call a rake task that causes Gradle to list all its projects in alphabetical order. The index number passed to the task decides which projects that machine will be responsible for testing. That's one way of doing it. We've taken this approach a step further and have assigned weights to each of our +20 java projects (weights are calculated by timing how long a given project takes to test on a dev machine). Our approach then uses these weights to make sure that each unit-test-machine gets a workload that is roughly equal to all other workloads. The CI/CD infrastructure, as well as the tools to deploy to the in-house stack are managed by DevOps. CI/CD architecture, tools, error response, best practices evangelization, etc...) are managed by the Automation Team.
Not OP, but this may be helping, at least for controllers. http://ruby-performance-book.com/blog/2016/02/is-ruby-2-3-faster-rails-erb-template-rendering-performance.html
Finally some sense. I've been shitposting these threads all day
yeap, totally agree with you … would only add one thing to point 3: "…, cause most people are not native Englishs" ;)
The idea that passing one time in 5 or 10 is considered 'passing' is based on the assumption that the race condition is only in your test infrastructure, and not in the real app. Otherwise, it would be a disaster of false negatives, right? I _guess_ that's a safe assumption in a Rails app? Especially when feature tests are so darn flaky and it's due to test infrastructure?
What directions are you following exactly? How did you setup Postgres? What's the content of config/database.yml?
Which Orwellian communities began with CoCs?
Nice. Well written, tested, and documented. Consider writing your errors to *stderr* instead of *stdout* if you'd like to keep with UNIXy tradition. Although I can't imagine anyone piping 'inspect' into another process. ;)
And I've met programmers who decided to drop out of events because the event had a CoC which either framed the environment as a wanton pit of harassment or didn't appreciate the atmosmphere of 'never showing sexual imagery'. 
Originally our unit test suite was 3-5 minutes and then our regression tests were 25 minutes (essentially integration tests putting through real data and making sure the response doesn't change). I got them down to 1 minute for the unit test suite and 4-5 minutes for the regression tests. Not too painful now at least.
Nor do you have any right to be involved in any open source projects or file any issues on them or for that matter attend any conference or meetings, if the people organizing them think you're an asshole and would rather not deal with you. shrug. It's not "coercing" for people to say "Unless you can not be an asshole, we don't want to hang out with you, because you drive away other people we find it more productive and rewarding to hang out with." That's pretty much what the policy says. Where's the coercion? You can't coerce anyone into wanting to hang out with you despite being an asshole. 
&gt; I've met programmers who decided to drop out of events because the event had a CoC which either framed the environment as a wanton pit of harassment or didn't appreciate the atmosmphere of 'never showing sexual imagery'. And yet people still say that CoC's aren't an effective deterrent.
These were all women, but okay there bud. 
You have to work really hard at it, and largely ignore the capabilities the language provides.
https://i.imgur.com/T8I86.gif
Our experience having converted from RSpec to MiniTest is that individual tests run *much* faster, typically 8-10x faster than often directly-ported-from RSpec specs. MiniTest has also helped us do faster tests by pointing out any disparity between number of *examples* and number of *expectations*. You want to keep that pretty close to 1:1, generally. RSpec lets you get away with *amazing*-in-hindsight slop.
Yup, I missed that.
What the fuck are you on about? I wish there was a popular distinction between like "active exclusion" (people being dicks) and "passive exclusion" (where no one is really doing anything wrong but the environment **may** be a little intimidating to &lt;group&gt; because &lt;reasons&gt;). Should we fall over ourselves to worry about this passive exclusion? No. Make some tweaks in your own life **if** you see the need, when/where you can. You should also recycle where/when you can. If everyone was just a little less quick to jump to screaming "fuck off" at people, maybe we'd make progress a lot faster. Get some sex bots to market.
mv minaswan coc
&gt;(where no one is really doing anything wrong but the environment may be a little intimidating to &lt;group&gt; because &lt;reasons&gt; Ever stop to think that those reasons may be integral to the group success? Clearly Linux is doing *so* poorly with Torvald's abrasiveness. Many of us turned to Open-Source precisely *because* we were tired of walking on eggshells in sterile, corporate hellholes--and no, I am not condoning people wantonly calling each other nigger faggots, before you go there--you know, the type that gets people fired for saying a fucking dongle pun. Do you really think people are being 'quick' to say 'fuck off', or do you think it's a remote possibility that they've seen what happens when they don't? Again, Torvalds did, and look at what happened with Sarah Sharp. 
I'm not sure I understand. What do factories have to do with business logic? I believe that the problem with factories is the write to the database as well as triggering who knows how many callbacks that you don't need every test. I view it as more of ActiveRecord pain that some projects dig themselves into
That's what I mean, although I might've mangled the term "business logic." To put it simply, I'm curious as to how people test their models and other associated functionality without using factories, fixtures, etc. Like I said, it might be the implication might be that minitest and fixtures are faster than factories like those in factory_girl, but to me it sounded like a warning to avoid all of these things where possible.
Thank you for your feedback! Great suggestion, I will create an issue and start working on it! :)
The one thing we can learn from this discussion is that apparently trolling, anti-semitism, doxing, pretending to be others, and general negativity is the way to get Ruby's authors to make changes (instead of meaningful dialogue). This "CoC" comes across as an excuse for inaction. It doesn't specify what to do in case of harassment, who to contact, what information to provide, etc. This document is also ripe with vague terms: &gt; Participants will be tolerant of opposing views. Opposing views? Does that mean if somebody calls me a fag I should just accept that because that view opposes mine? If somebody spews anti-semitism do I just have to accept that? It certainly seems that way based on the above line. &gt; Participants must ensure that their language and actions are free of personal attacks and disparaging personal remarks. OK so I'm not allowed to say "You're bad because your code is bad", but I am allowed to say "Death to all jews"? Interesting. &gt; When interpreting the words and actions of others, participants should always assume good intentions. I don't think I can really assume good intentions when the above examples occur. More importantly it's extreme naive to always assume good intentions by default, at best one should be neutral/somewhat sceptical unless good (or bad) intent is very obviously noticeable. &gt; Behaviour which can be reasonably considered harassment will not be tolerated. OK but in what way? Will Matz write a comment saying "You're a baddie"? Will the authors of Ruby actually _do_ something or will they tell us to ["get back to actual work"](https://twitter.com/yukihiro_matz/status/699974899041832961)? Who do we contact when bad things happen? People will hate me for it, but so be it: this whole "adventure" shows how little the Ruby authors actually care and that they'd rather agree with a few random anonymous internet "heroes" (read: trolls) instead of the dozens if not hundreds if not thousands of people that actually contribute something meaningful to Ruby.
That's kind of the point. A lot of what's done is so baked into the society/industry/community at this point that it's not "explicitly and self-aware[ly]" done; it's just "the way we've always done things". That, if anything, makes it much worse. It's one thing to want to improve yourself and the world around you, and fail; it's quite another to decide it can't or shouldn't be done because it never has been done before. Nobody "gets" to "claim" anything; we open our eyes and do everything in our power to leave our little piece of the world better than when we found ourselves in it. That was once called the Boy Scout Rule; then the "red pill"; now it's derided as "hopeless" and "the work of SJWs". Every religious person I have ever known, and every atheist as well, has stated that s/he believed that social justice and making the world a better place were Important Things. It's about time we come off our privileged high horse and just do what's right. I've been in this craft for well over 35 years now. I've seen times when we've been open and progressive; I've seen times when we might as well have been ten-year-old boys in a treehouse with a big sign saying "Only Us Allowed Inside". The last few years, based on personal experience and observation (and remember, I'm a straight cis white male here, so it's not like I'm pounding on the tree trunk shouting "let me in"), it's at least as bad as it's ever been and it makes me ashamed to be part of it. I love this craft; it has been my hobby for a lifetime; it has put food on my table and bought me nice toys to play with, including what I'm using to type this now. I just wish far too many of its self-appointed leaders would just *grow the fuck up.*
There are more types of asynchronous behavior than race conditions. I guess you could call it a race condition between your test suite and your application. This is the only situation where this would be acceptable to me. I generally view the test as being created such that it polls the application, waiting for some state to become true; throwing a false if it does not become true after a certain number of tries. So it isn't a false negative or a race condition in my mind. But I can see how that is a result of a frame of thought more than being objectively true.
Yeah, you can be certain. I don't just throw results in an anticipate block unless I have evaluated that it is needed. So I can manually execute the test, observe a non-deterministic delay, then I put it in a anticipate block. This had more to do with being in an event driven architecture than it did being in rails. Rails was a component, it served the api, but there were a lot of moving parts in the backend. All of which were meant to serve extremely large scale of document ingestion. The only thing that was designed to be served synchronously was search results and document requests. Edit: Just to be clear I am talking about end-to-end full stack tests here, not unit tests of components.
Haha yeah, wow - I think you're right.... This just goes to show how bizarre it is when `ActiveSupport` implements things which should be in core ruby. (Or, things which shouldn't be built into the language at all!) * `Object#try!` should have been in ruby core, and has now been made redundant due to the safe navigation (`&amp;.`) operator. * `Object#in?` should be in ruby core, or perhaps re-implemented by use of the `in` reserved word (i.e. not a method call at all). * `Object#present?` and `Object#blank?` should be in ruby core. * `String#at`, `String#from` and`String#to` are pointless in my opinion, and should just be removed. Referencing by index, e.g. `"test"[1]`, is perfectly fine. * ...... This obsession with monkey-patching core classes with hundreds of helper methods that "the author found useful, once", has resulted in a ridiculously long list of built-in Rails methods. I'd be surprised if people *weren't* duplicating existing method functionality by accident! 
That actually won't leak, the GC will automatically close the file when collecting the object, which will be collected almost immediately here since there is no reference to it. &gt; Ruby doesn't help you in any way to prevent these resource leaks and I don't know a language which does. The GC handles it, but most resource handles in Ruby are provided in block form to allow faster cleanup. e.g. `File.open('test') { |f| whatever }`. Python has `with` for the same reason, Java has `try-with-resource`, etc. Like I said, you have to do something dumb to leak resources in most high level languages. 
Having followed the rubinious development for many years I don't find Brian Shirai deluded, egotistical, crazy or any other of arbitrary adjectives he's been labeled here. I couldn't say the same about Charles Nutter. 
It says the opposite, it lays a standard that all Ruby-affiliated groups should follow. &gt; This document provides community guidelines for a safe, respectful, productive, and collaborative place for any person who is willing to contribute to the Ruby community. It applies to all “collaborative space”, which is defined as community communications channels (such as mailing lists, submitted patches, commit comments, etc.). If you'd have actually read the fucking thing, you'd notice that above that it also says: &gt; We have picked the following conduct guideline based on an early draft of the PostgreSQL CoC, for Ruby developers community for safe, productive collaboration. Each Ruby related community (conference etc.) may pick their own Code of Conduct. Which means that any individual community can choose to disregard the CoC, which is what I'm doing. 
I like the new addition to #pluck change. It's a much nicer method than using map, but since map uses caches while pluck would always re-query the database, it was the preferred option. Another thing to look forward to
Since you want to capture the output of multiple external calls I would probably do this externally to the script: The simplest to get both console and log output is probably: `ruby my_thing.rb 2&gt;&amp;1 | tee /path/to/log.log` But you could also send the output into whatever syslog your system has if you want more structured/tagged logging.
So nobody yet put any real incidents on the table, something what would justify the very existence of the problem. I'd just suggest ignore this proposal and ignore any attempts escalate the situation. It did remind me one unfortunate case from PyCon. Just do not repeat the same mistakes as Python people.
That's what I've done, a wrapper method. I think that Capistrano and maybe rake too both include such wrapper methods?
&gt; cis, white, hetero The real question is, why aren't CoCs explicitly excluding these people? I hardly see the point of even trying to build an accepting community when this particular group of people has a track record of destroying everything they touch. It's no wonder that women (for example) are finding it nearly impossible to enter this industry when they are inundated with sexist sentiment. 
Holy shit you're fucking serious. Saving this comment so people can view just how toxic those who want CoCs are. 
And one would expect that developers would already be using [symbols](http://www.reactive.io/tips/2009/01/11/the-difference-between-ruby-symbols-and-strings/) as literal identifiers wherever possible.
It went up by a factor that will shock you, just from using this one simple trick?
Most applications don't use a ton of string literals anyways. Frozen `String` objects would probably show a lot more difference in performance. Although, many apps would need to be completely rewritten to handle immutable `String` objects.
Counterpoint: 30% speed up https://github.com/Invoca/magic_frozen_string_literal/issues/8#issuecomment-185744739
Great article. 
And, actually, it's not really a valid principle for C either. It's been debunked over the years many times. It was thought that having a single exit makes code easier to understand. Yet looking at your original example, it's clear that the version that exits in three places is nonetheless easier to understand. The pattern of checking for exceptional conditions before performing a task is so common that we have trained ourselves to quickly recognize it as something not necessary to understand the operation that's about to be carried out. And the code that comes after it tends to be more concise because of the guard clause (lower cyclomatic complexity).
I really hope there's more data like this before MRI decides to make string literals frozen always in a future version. I have always been skeptical about the strength of the benefit it would provide, as well as the cost to both backwards-compat and developer mental modelling (one more thing to know about). 
/r/ClickBaitTitle
https://bibwild.wordpress.com/2016/02/18/struggling-towards-reliable-capybara-javascript-testing/
This is going to vary from app to app. I like the idea of this series of 2.3 performance stuff, but I think most of them have been too unscientific to actually care about the results. This is basically the same as what Schneems did with frozen strings in Rack that had a 5% reduction in memory. This can have a nice boost, but one single test like this isn't going to be relevant. 
Python developers *hate* him!
&gt; Under every reasonable definition, harassment also includes denigrating comments directed toward a group said with the intent of dehumanizing them. Would you mind linking to a resource that specifies that harassment includes comments towards a group? I'm having a hard time finding a third party resource that verifies your interpretation. [Wikipedia describes online harassment](https://en.wikipedia.org/wiki/Harassment) as: &gt; Harassment directs obscenities and derogatory comments at _specific individuals_ focusing for example on race, religion, nationality, sexual orientation. [According to haltabuse.org](http://www.haltabuse.org/help/isit.shtml), Black's Law Dictionary describes harassment as: &gt; A course of conduct directed at a specific person that causes substantial emotional distress The Pew Research Center doesn't specifically consider denigrating comments towards a group to be harassment [according to this article](http://www.pewinternet.org/2014/10/22/online-harassment/). I agree that denigrating comments toward a group is rude, and doesn't have place in official Ruby developer channels. My issue is that the code of conduct only covers personal remarks and, in my interpretation, still allows general hate speech. If the intention of the code of conduct is to disallow hate speech, I think the document should make that clear.
Those who want CoCs? You mean the people who *aren't* actively excluding minority groups from their projects?
Sure unless you need to test integration. And until a product grows for 5 years or more adding constantly more features and all isolation ends up in is yet another layer on top connecting isolated components for another cool feature no one ever thought of before ^^
Love react. I mean it. But what does it have to do with ruby? Migrating an old code base that uses form builder with jQuery on top is hell. I am doing that at work right now, no fun at all since back in the old days you never built a rails app with just a json API. Anyhow if you start new and wanted to use react, why would you use rails or Sinatra right away? In my experience you can draft well with react, and plugging something more lightweight behind react is what I would do at the beginning. Building rails apps today is the art of isolating your code from rails so to me starting out with rails and react makes no sense whatsoever. Not to mention that I may have skipped the part in the article about rails or ruby :)
Rails is already pretty optimized to use `.freeze` in all the hotspots. How do I know? I did a bunch of it, using real world apps and got saw a significant improvement. https://engineering.heroku.com/blogs/2015-08-06-patching-rails-performance/ It would be interesting to programmatically strip every `.freeze` call out and repeat the benchmark. To see what that delta would be. 
It's good to know your solution to these problems is to look the other way. I'm sure that's a productive approach to solving problems.
i dont really understand what this gem does...is it similar to pry or does it do something else?
This is a great write-up! I've faced many of these problems myself in the past on a rails/jquery/ember.js website. Here's a few things I did to improve stability. - dump Poltergeist and PhantomJS. I am sorry, but I have yet to work with anything more buggy than these two. Try using [selenium-webdriver](https://rubygems.org/gems/selenium-webdriver/versions/2.51.0) with [curb](https://github.com/taf2/curb) instead. Note that curb has problems with the [Timeout::timeout method](http://ruby-doc.org/stdlib-2.1.1/libdoc/timeout/rdoc/Timeout.html#method-c-timeout), so be sure to avoid that method at all costs. - represent every page you're testing as a page object. Use [site prism](https://github.com/natritmeyer/site_prism) to help you with this. - monkeypatch capybara and site prism such that every method that tries to access a page element (e.g. a button), executes a [check_page_has_loaded? method](https://gist.github.com/anonymous/2c1b240c560c07899f80) before trying to locate the page element. - even with all this in place, you can still encounter weird js behaviour if your tests try to interact with the page before the javascript has had time to add callbacks to buttons and the like. This should happen very infrequently though. One way of dealing with this is to make a list of these occurrences, and have the UI peeps modify their js code slightly for just these troublesome elements. Ask them to have the js add a specific data-attribute to an element once the callbacks have been affixed. Your code can then check for the presence of this attribute. Site prism makes this trivial.
I'm running tmux2 just fine with tmuxinator.
I think you've made your point. Thank you for your criticism and you enjoy the rest of your day.
Yup, although we use chromedriver to get it to work with Chrome instead. We've had some bad experiences with only certain version of Firefox playing nice with Selenium. And yeah, it will steal your screen focus. It's so worth it to just automate this entire process and have it run automatically on some (cloud) servers instead with an xvfb session.
Frozen string literals probably also helps you catch bugs.
You as well! Take care. 
fair enough
Say you want to make a CLI to do something, You additionally want it to be a REPL so that you have more expressive control (able to use Ruby). You can use this as a starter for the CLI and just plug in your additional methods.
`selenium-webdriver` just talks to a selenium server, which can talk to any browser that has a driver, which is pretty much all of them. On most systems it defaults to firefox. `poltergeist` is just a capybara api wrapper for `phantomjs`, which is the actual browser and quite frankly, it's a steaming pile of shit that has been the cause of more wasted time in my life than anything else testing related. I've removed it's use from all of our projects. `capybara-webkit` is another headless browser option, it's developed by the same group as `capybara`. We use `capybara-webkit` for Rails testing and a selenium based setup for pure JS testing. 
&gt; he should be removed She should be removed. She is a toxic entity in the community. 
&gt;A lot of what's done is so baked into the society/industry/community at this point that it's not "explicitly and self-aware[ly]" Then why did you make the accusation? &gt;I just wish far too many of its self-appointed leaders would just grow the fuck up. You have offended me. Why are you actively excluding me by using sexual language? Are you a white cis scum rapist or something? Maybe we should actively exclude people who make false accusations.
&gt;Wait, which part do you plan to violate? You plan to be intolerant of opposing views? I for one certainly will not be tolerant of opposing views. I will not be tolerant of people claiming otherkin affiliation, I will not be tolerant of religious fundamentalists asking special dispensation for their ancient religious rites, I will not be tolerant of people espousing facist ideologies etc. &gt;You plan to use lots of personal attacks and personally disparaging remarks? If called for yes absolutely. If you call me cis for example I will absolutely call you names in return. The way I see it one demeaning remark deserves another.
I think this should be done at the interpreter level, otherwise every single app has to do this with a bunch of .freeze
Our so called tech lead thinks tests will hold him back. He is a smart guy, but thinks his code is God's gift to humanity. Have mercy on my soul. I need to stay in this job for other reasons, but I really need to leave.
At some point, everyone has wondered if they were incapable of programming. Especially if you only see the successes of others near your experience level. But seriously. At some point, or many points, everybody has a moment where they think "I bet I could at least feed myself if I switched to painting houses."
I think I'll write one more post on the state of frozen string literals support and porting. I agree that it's indeed one more thing to think about. Let's say that you see "str.upcase!". It's so tempting to just substitute it with str.upcase, but that may increase memory usage. So you do need to find the place where str is originally constructed and make it mutable there. Fortunately, Ruby tells you about that place. It's just not always easy to change it. It might not be even your code. 
She should fork the language and form her own community. She can call it otherkin.
The use of the word bro is sexist and derogatory. You have violated the code of conduct.
I talked about the topic of starting a Rails app and whether to isolate from the beginning or not: http://blog.arkency.com/2016/02/where-and-why-im-still-using-rails/ http://blog.arkency.com/2016/02/rails-mvp-vs-prototype/ TLDR: (assuming time-to-market matters) If you're as fast with React/API from the beginning, then go there from the start. If not, then starting full-Rails and then refactoring may have a bigger market impact. 
Do you by any chance have an example setup for this? 
bad code doesn't imply bad coder.
Don't be so butthurt. I'm on your side in this but your mistakes were pretty funny. 
He is saying that using the phrase "bad code" is a personal attack so he disagrees with you. He is likely to bring up charges against people who use the phrase because he thinks it violates the code of conduct.
&gt; There's nothing concrete to be done with the statement "your code is bad." oh my god. do you live on the moon? at my workplace when we say "this is bad code", that means exactly what it says: this code is really bad objectively (according to predefined code quality requirements and common sense, and possibly from perspective of the algorithm/optimization), and could be improved. then we improve bad code and make it better. suddenly you can say "it's good code" and move on. is it really that hard to grasp? or are you just waiting to be insulted? if you explicitly declare "this code is bad, because you are a bad coder" - well that's another talk.
We all hit a blockade from time to time. Best to step back from the problem, do something else and come back to it. I wrote a dissertation at university on creativity, or the psychological phenomena thereabouts. You might be surprised by the capabilities of the unconscious mind. Sometimes thinking about or dwelling on a problem is the worst thing to do. Sometimes solutions come to us more easily when we stop thinking about the problem. Funny thing, the mind. :) Keep at it, but don't strain yourself. I'm sure you'll figure it out.
She was extremely slimy and dishonest in the discussions about the CoC. She is just a very bad person, a complete asshole.
&gt;There are gems I absolutely cannot be productive without. Wish the author listed those. 
Of course, this is Ruby, so `Secret` is a `Person.public_constant` (it's not even a private method!) away from being exposed once again. Internally, MRI gets to cheat by naming "constants" however it pleases: Complex.constants false # =&gt; [:compatible, :I] You can still get hold of it (this is still Ruby :P), but neither `Complex::compatible` nor `#const_get` is sufficient, so consider writing your implementation detail classes as C extensions for extra secrecy.
[Something like this](https://eval.in/521769), but probably better to just pretend you didn't see that.
Can't disagree with that.
&gt; How do I test the private class though? A private class is often just an implementation detail, so you don't.
https://www.ruby-toolbox.com/categories/pdf_generation
Call Person.public_constant :Secret Then `Person::Secret` is accessible. or use `const_get` to side step in just one place: secret = Person.const_get(:Secret).new
Thanks, schneems. I'll repeat my benchmark with an app that heavily uses routes and activerecord. The one I benchmarked doesn't, so it did not benefit from frozen string optimization at all.