Will pythonmonk kickstart as well? :) 
Have you tried "Learn Ruby the Hard Way"?
Well, to be honest, I monitor https://github.com/trending?l=ruby every day and found several interesting projects there that I'd not stumble upon otherwise (despite regularly reading /r/ruby, RubyNewsWeekly and RubyFlow). Yes, some of the "trending" projects are in fact some students' bootcamp, or some site/blog, others are obvious (rubocop-ruby-rails-vagrant-jekyll), but I don't think the top is absolutely useless. PS: And I must say, the article (written by me), was initially written in Russian to encourage our students trying new things, not to criticize GitHub top or praise my "library".
Not a tutorial per se, but have you tried Programming Ruby 1.9. If i's only to get you started the book gives really valuable tips
I don't think anyone was assuming you were criticizing anything. Nor was I, for that matter. The Ruby trending list on GitHub isn't very representative simply because of an overall lack of new Ruby projects, so random stuff like lists of engineering blogs or React Native links end up in Ruby's list. The JavaScript, Go and Python lists are more representative of those communities simply because they're more active. It's no-one's fault, I'm just recognizing that the Ruby world's velocity is somewhat lower nowadays.
That's true :( I still have some hopes, though -- and I am relying those hopes more on new, for Ruby, areas (like what SciRuby tries to do), than "new shiny Rails plugin".
I can't specifically answer your question, but there is a lot of help about text encodings in the Ruby docs for CSV. Of course, you'll want to check the docs that match whatever Ruby version you're using. Example: https://ruby-doc.org/stdlib-2.4.0/libdoc/csv/rdoc/CSV.html
Your link URL includes a couple extra characters that break it.
Welcome feature! &gt; In order to identify whether autoscaling is appropriate for your environment we recommend that you load test prior to implementing autoscaling in production, and use Threshold Alerting to monitor your p95 response times and error rates. If you plan to conduct significant load testing, please notify Heroku Support in advance. It's very un-heroku-like to require manual communication (notification, or [another heroku doc](https://devcenter.heroku.com/articles/scaling#known-issues-limitations) actually says 'written consent' for an activity heroku recommends you do. There's not really a way to know what counts as 'significant' load testing. Not the kind of seamless and BS-free UX I have learned to expect from heroku. I hope they fix this soon, perhaps a button in the dashboard to say "Yes, I am doing load testing", with date range and IP addresses entered. (Load testing is also good to determine the proper number of puma workers and threads to max out the dyno without going over, under load). 
This Reddit is not the best place for feature proposals, the right one is https://bugs.ruby-lang.org/ ...where it was already proposed and discussed multiple times: https://bugs.ruby-lang.org/issues/12578 Matz's own opinion: https://bugs.ruby-lang.org/issues/8563#note-3
Cool feedback. Thanks.
I had never heard of it either, I may have just made it up! But I'm assuming heroku wants to be contacted to avoid triggering automated defenses, and I don't see why that couldn't be automated too! Which seems like the heroku way to do it. Is there a more official place I could make the feature suggestion to get attention to it? I've done load testing on small sites without ever having a problem too -- but reading the docs for auto-scaling was the first time I ever noticed that heroku was asking you to get 'written consent' in advance, it never occurred to me. Now that I've seen it, I'll never be able to do load testing without worrying about it again. :) It's easy to miss in the docs, if there was a dashboard button, I wonder if whatever message you get when you've been blocked could even include a URL to the dashboard button "You may have been doing load testing and forgot to notify us, please go here." That would be the kind of thing I have learned to expect and appreciate from heroku. 
Wow, that was a really good read. I was definitely surprised by how simple it was, but also gained a deeper appreciation for Rails and all the features it offers.
Wow, you are a very nice and helpful person. After some study, I think I understand basically everything. You did something Code Academy hasn't done good enough on, which is explain *why* things work and therefore *why* we're writing the code we're writing. I'm floored that you took the time to write this, so thank you. It was a great crash course. 
i know and I think what it should be is : &lt;%= CSV.generate_line([@users.find(entry_data[0]).full_name, @users.find(entry_data[0]).number, @clients.find(entry_data[1]).name, @projects.find(entry_data[2]).name, sum_hours.to_f], encoding: 'utf-8') -%&gt; but looking at the csv it generates in textedit or excel I still get this funky characters like Children&amp;##39;s Aid Society instead of Children's Aid Society encoding is frustrating
&gt;Pretty useful nonetheless, but it's pretty straight-forward and uninteresting really If I were the author of the code, I would feel slightly insulted, and have literally nothing constructive to do with this... fortunately for me, I'm not the author :P 
&gt; write
Who uses ruby gnome? Who enjoys it?
Thank you!
Not in the world of text editors ;)
Try Googling 'ruby string interpolation'. The top results will lead you to the solution.
I'd love to have autoscaling sidekiq
 ruby build_my_house_and_stuff.rb
 puts "%02x %03d %08b" % ([num]*3)
Thank you for your hard work.
Thank you. Most of these tutorials say they have the full list of formatting types and they just don't. It's odd. Good tutorial. Thanks for the link.
Thank you. That is cleaner and more concise. Now I will go about trying to figure out what is going on with that `([num] * 3)`
who care ?
I learned a really cool trick in Ruby. I thought it was worth sharing. But if you really hate it, there's no reason to get mad. That's what the down vote button is for. :)
People who are curious about Ruby gnome... 
IMHO, when someone ask who could use or enjoy this open-source project, it looks more like a troll than like a curious user.
I use RSVG2 and it's great. Thanks :)
You're right that `%`, like virtually all of the traditional "operators", is secretly [a method call](https://eval.in/726052) in Ruby, but the permitted heterogeneity of arrays doesn't have much of anything to do with string formatting. `String#%` simply attempts to call [the appropriate method(s)](https://eval.in/726053) on the provided `Object`(s). It could've been written to take multiple arguments, but then you'd *have* to explicitly invoke it in order to pass them (`'%d %d'.%(1, 2)`), and that's kind of ugly. As for `Array`/`String#*`, multiplication is just repeated addition, and `Array`/`String#+` being concatenation makes perfect sense, so it's really all the other languages that don't support these operations that need their senses and sensibilities questioned.
Even disregarding that, it is not as if enumerator has existed always. You *definitely* could not do that back in 1.8.7 days.
You won't believe the top answer!
I talk about how to offer a commercial license here: http://www.mikeperham.com/2015/11/23/how-to-charge-for-your-open-source/
It was. Thanks for sharing. 
I saw one tutorial series years ago where the instructor began by expressing every concept in "pure" ruby notation: &gt;&gt; 2.+(2) =&gt; 4 And after awhile, he revealed that you didn't need to do that, because ruby has "syntactic sugar" to make it clearer and easier to use. But if you know that structure and that EVERYTHING is an object and all of the "operators" are methods... It's good to know the "pure" structure when things start to get complicated in terms of order of operation. I like the way you explain things. Thanks, again.
You are welcome!
How did Python ever even take off? Semi-serious question, actually. Also, the reddit gods demand that I wish you a happy pizza day, so happy pizza day.
Your while is isn't evaluating a variable, it's evaluating "true" which is always truthy. You would get the same result if you wrote "while 1" or "while 'astring'" Try evaluating the value of number in your while statement. 
There is no overarching state of a script which is either 'true' or 'false'. Your 'while true' will *always* evaluate to true and keep looping, because true... is always true. When you say 'if number == 2000 then false', you are again not setting anything *to* the value 'false', so the statement is meaningless. You either need to set some variable to have the initial value 'true', set that same variable to have the value 'false' when number gets to 2000, and use that variable instead of the constant 'true' in your while; or (the simpler option) just change your 'while true' to 'while number &lt;= 2000'. Then you don't need to have a separate Boolean (true/false) variable, because the statement the while is using to determine if it should loop (number &lt;= 2000) will itself return a true/false result, and will be re-evaluated every time the loop tries to repeat.
You are correct that it doesn't work that way. It doesn't matter what the code in the block evaluates to - that is irrelevant. It's what the expression immediately after 'while' evaluates to. Your expression immediately after the while always evaluates to true (as it is literally true), so it will always loop. (Another way of exiting the loop would be to say 'break' instead of 'false', which breaks out of the inner most loop.)
An easier way to do this without having to worry about an extra conditional variable would be while number &lt; 2000 puts "#{number}" number = number + 1 end
 `then false` doesn't get assigned to anything that the loop is looking at. You could do a break statement or `return false` but `then` doesn't evaluate in the higher loop level at all.
off by one.
The other explanations are correct, but the ruby way of doing a specific number count, is do something like: 2000.times do |i| puts i + 1 # iterator starts at 0 end
You're overthinking this. The way that makes sense would be your third option: if success stats[:success] += 1 else stats[:fail] += 1 end That last one should burn in a fire.
How? Because it's good for data related stuff, stable/decent for web and much more. Not a big fan of a Python but it's not too bad. I wish the community would come together and stop being split by the two versions.
How about stats[success ? :success : :fail] += 1 Or the simple if/else. It's usually better to keep it simple.
The loop logic doesn't work the way you think it works. true is always going to be true. You have to explicitly break out of the loop if the condition you are testing for is hit.
Easy solution is to replace "return true" with "break." Your issue is that while doesn't loop until the block returns a non-true value, it loops until the condition returns a non-true value. Keep in mind that the first expression after while/true is the conditional, and in this case, it's just the value `true`, which is, of course, never going to change.
Really, Python's a fine language. The rules are simple, it's clear, everything seems pretty rationally designed. That said it feels almost stiflingly tough to modify. Ruby feels much more extensible, concise, and fluid. Although Python can still be concise, the Ruby is just more... I don't know... fun? Nothing's cooler than require 'sinatra' get '/' do "Hello world!" end as a hello world. Flask *approaches* that level of brevity but it can't quite make it that simple. This also makes tools like Rake feel a lot more friendly than the closest Python equivalents (e.g. invoke).
Thank you for your thoughtful response. edit: Bummer, that guy deleted his comment. Hope you didn't think this was sarcasm? Maybe you thought it was a bad talking point? Anyway, I did in fact appreciate your note!
Why did you switch to `#each`? I would strongly advise taking the time to become deeply aware of how and why it's not synonymous with `#map`.
is it that #each returns original array whereas #map returns a new array? 
Yup. Each is for side effects, map is for transforms Incidentally you can also chain maps, so File.open("name") do |f| times = f.readlines .map do |str| str.to_i end .map do |num| Time.at num end # times is now [Time] end # file closes here
#each will return a new array, whereas #map will mutate the array it is operating on. 
When making a post on StackOverflow, try to give a [Minimal, Complete and Verifiable Example](http://stackoverflow.com/help/mcve). Can you give a *minimal* example of an input file, to *recreate* the problem? Can you give a *verifiable* actual vs expected output, from your given input? With your question as it currently stands, we are forced to make a guess at what could have caused your issue - and your vague responses like *"illegal quoting in ln 2 error"* and *"good_rows output isn't listing 12 rows"* are equally incomplete. **Could you supply a much shorter (&lt; 10 lines) input CSV file, the expected output and the actual output of your script?**
One thing that came immediately to mind, if you are dealing with large files, why read the whole thing and then process? Use `CSV.foreach` process a row at a time and minimize the amount of rows that are in memory at any given moment. Keep only the rows that are in your range, throw everything else away, then sort. Take a look at [these benchmarks](http://dalibornasevic.com/posts/68-processing-large-csv-files-with-ruby) and see how much smaller the memory footprint is using CSV.foreach vs. CSV.read. this trades run performance for a smaller memory footprint. But if you are dealing with huge files, memory is probably the larger concern.
I am not a fan either, I find it confusing. 
Yeah, a simple `foo.render` method would be much cleaner, and is what 90% of the rest of the ecosystem uses.
`.()` is just a shortcut for `.call()` and I don't really have a problem with a `call` method, although, sure, synonym at `render` might make sense. But i'd rather call it as `call` than `.()`. 
Well why not just `#call` then? Why the encouragement to use a weird new syntax to call a function?
If you ever want to do a `while true do … end` loop, you should actually use `loop` instead and then `break` whenever you need to leave the loop: loop do break if something end But I agree with /u/agmcleod, use `2000.times do … end` when counting.
I'm surprised you'd need auto-scaling with only a single profesional 1x dyno ($25/month). I mean, if it auto-scales to 3 dynos, that's as much as $75/month already, so you aren't exactly in a "$25/month tier" anymore. Is that your use case, you have a single 1x dyno, but would like it to be able to autoscale to 2 or 3 for occasional short bursts?
Code aesthetics are so funny to me. I think it's beautiful. Who is right? No one.
Once you get comfortable, it's not weird anymore.
In addition to Ruby? Or in place of? 
I hear ya. I'm not sure how auto-scaling would work out if you have budget limits. Perhaps heroku will eventually open it up to 'standard' size dynos and you can find out. But note that if you notice a reddit spike, you can manually scale your dynos however you want now. Heroku charges are prorated to the second, so you'll only pay for those extra dynos as long as you are using them. But yeah, you'd have to manually scale them back when you are done. Also, I wouldn't trust someone elses benchmarking for anything but general order of magnitude at best. How much traffic your app can handle depends on your specific app. "Concurrent users" may not mean what you think for a web app. It's quite possible what you've got now could handle a lot more traffic than you think, with some response time slowdown. For many apps, reasonable caching can also go a _long_ way to handling a spike like that. Cloudflare will do quite a bit of caching for free. But even RackCache (along with a reddis or memcache you prob don't want to pay for) can go far for this kind of spike handling. 
stdin and arguments are not really related, so it sounds like you have some mixing of those concepts here (but I haven't looked at the exercise). I can, however, tell you that plain `gets` *calls* `$stdin.gets`: $stdin = Class.new { def gets; "hello world"; end }.new gets # =&gt; "hello world" It's arguably clearer (and more OO) to explicitly state where you want to get the line from, but they're ultimately interchangeable.
[From the exercise 14](http://www.mkltesthead.com/2011/11/exercise-14-prompting-and-passing-learn.html), that I think you are referring to: &gt; OK, first thing (notice this from yesterday?), here's a change-up. gets.chomp() is represented as STDIN.gets.chomp(). Why? Because ARGV is being used. the default gets method will look in ARGV and try to read from the first variable. getting input straight from the keyboard (user input) is referred to in computer parlance as STDIN. So to read the users input, when ARGV is used, STDIN.gets is used. &gt; the default gets method will look in ARGV and try to read from the first variable That's news to me, but then, I don't write a lot of stuff that uses command line arguments and user input in the same program. You will note the link I used is using `STDIN.gets.chomp`. `STDIN` is an alias for `$stdin`.
&gt;Fresno Yeah it's cheap, but then you'd have to live in Fresno...
yep, tell them to get with the times and learn basic git
and probably consider using a concurrent-ruby approach over using threads directly. 
the normal way would be they learn git. They don't really need to know anything about heroku. but wait, in your solution they sftp into the virtualbox image, and... change the styles in the deployed app? (Deployed in dev mode I guess?) And then, what, you ssh in and commit their changes? I mean... I guess that'll work. **edit** if the question is "How does someone who isn't a developer at all and has no idea how to run a rails app make changes and see their changes live" -- I'm actually not sure of a great answer. I think it's probably either teaching them how to install and run a rails app themselves locally, or something like what you've done. With what you've done, I'd still teach them how to commit their own changes though. The designers at the small firm I work at know enough 'developer' to install and run a Rails app. They occasionally run into things not working right trying to run the app, and ask a developer to help them fix it. 
Nope only Fresno. So I have absolutely no frame of reference. 
Thanks for the tip! I definitely will.
Thanks, will do. For now I'm going to broaden my horizons and learn from more sources to get a more complete understanding.
How many hours do you think you spend in your car, in an average week?
Michigan is nice.
I'm also a Rubyist in SF and interested what people have to say on this. I looked in Austin when I was last on the market about a year ago, but the employers seemed a lot less desperate, even when I was willing to take half my bay area salary. It seemed like they were used to having most of the power in the employer/employee relationship.
I thought about that, I am gonna ask my boss to work remotely but anyway I think it's more secure to live close to a city where you can always find another job.
Even nicer if you're a .NETist rather than a Rubyist. That being said, we :had: a fairly health Ruby users group in Grand Rapids in previous years.
I've been avoiding the `.()` syntax because it looks "ugly" or "weird" (which, by the way, is not at all an objective truth, just an opinion). But I've recently started to see why it might be a good idea. When you're working with a lot of functional objects, your code has `x.call` `y.call` `z.call``a.call``b.call` everywhere, which is a lot of unnecessary noise. Ideally, I wish I could write `x()` and treat the `x` variable like a function, but that's not possible in Ruby. The `.()` syntax is just one little period away from my ideal, so now I'm thinking it's probably close enough.
I notice that the view objects have a "context", but how do per-request template vars (e.g. CSRF token) make their way into the context before rendering? When I was trying to implement a simple view layer from scratch, this was one of the tricker aspects. For things like CSRF tokens, they aren't globals so they have to be passed in as template args, but it's too annoying to pass the same args into every single render call. I'm hoping you have found a nice solution that doesn't involve making everything global like Rails does.
I work in Beverly Hills. 15 hours a week in my car just commuting.
And what are some io operations? DB access, web services, sending responses to clients, even pushing messages to rabbit... There are all kinds of cool things you could do with this particularly as real time has impact with things like Heroku timeouts and such. Neat.
The title is clickbaity but it's actually a defense of the language.
You could argue that Ruby threads are scheduled by the Ruby process in user space because all threads wait on the GIL, and then the Ruby process decides when to release the GIL and to let one other thread run. So there's no pre-emption of Ruby threads, and the single scheduling decision of deciding to yield or not is being made in user-space.
Not clickbaity but rather provocative 
Fair bit of Ruby stuff in Texas. Ft Worth and Austin are nice.
In dry-web apps we use the idea of a Page object, which sets up context common for all templates. It takes care of setting things like CSRF token, metatag and tag, so they are available in your templates. This is outside of the dry-view lib itself. This is something we can provide by default in dry-web library, as it's pretty much the same in all apps. There are many things that can be done to automate what's common, but dry-view is meant to stay as simple as possible and focus purely on template rendering.
This is 4 years old. 
Thanks for the thoughtful feedback, this is much appreciated! We'll take a good look into this approach :)
For what it's worth, I've been a professional ruby developer for years and I *very rarely* use `gets` in any "real" code. Input almost always comes via a command line, or HTTP parameters, or some other API. I don't think I've *ever* written/worked on a program that uses both command line arguments and STDIN - so this is an interesting gotcha to be aware of, but not one that you're likely to encounter in the real world.
Because you can do concurrent IO simply by using threads to very good effect, as described in the OP, without having to rewrite all your code to be non-blocking and evented (and it's not just _your_ code, eg ActiveRecord or Sequel aren't evented). Basically, the whole approach described by the OP became possible to good effect. At first it was thought that 1.8 and previous 'green threads' would be preferable for some of the reasons you hint at -- that's why they were the original implementation. But that's not really a debate anymore. Anyone who was around trying to do any concurrency in 1.8 and previous days and went through to 1.9 recognized the benefit of the change, I don't think anyone regrets it. Evented programming was all the rage in rubyland a few years ago, and ruby introduced Fibers (a form of cooperative multi-tasked 'green threads' basically) on that wave. There are Reasons evented programming hasn't really caught on in a mass way in ruby (despite fibers), although it is used to good effect in some specialized and black-boxed places, like certain parts of Puma or Passenger (although those parts of Passenger may no longer be in ruby in recent versions, not sure). 
Austin's tech scene is somewhat insular. When you get connected the jobs are pretty easy to come by. I don't know what your expectations of pay for a job outside SF are, but feel free to reply or DM and I can tell you what I'm seeing.
this. if it's a young dev, tell them all the cool kids use git. if it's a an old dev, tell them all the employable kids use git. 
I don't mean the Ruby programmer writing async IO code. I mean the Ruby VM doing the async IO code for you. When you make an IO call it does it as async and doesn't continue to run your Ruby thread until it has finished. It would have an event loop to decide which Ruby thread to run next. The Ruby program wouldn't need to be any different. The interpreter would simply stop at the instruction which does the IO, and the stack would be moved off to the side until the thread is running again. You mention fibres and they do this without having to modify your Ruby program don't they?
&gt; I mean the Ruby VM doing the async IO code for you. That's an idea, but not something the Ruby VM has ever done, it's a new proposal? &gt; You mention fibres and they do this without having to modify your Ruby program don't they? No, not really. In the sense that all the libraries you are using need to be using evented fiber-based logic, and the existing libraries are not. When people first got excited about evented fiber-based, that's what they ran into -- they want to use ActiveRecord (or Sequel), but those libraries are not written using evented fiber-based logic, so won't work in an evented context. Some people tried to make a fork of AR (or the relevant parts, maybe just drivers?) that would work in an evented way. It didn't take off. But code changes were certainly needed. I couldn't even find that fork easily on google anymore, it didn't reach susintaible use. But more info in /u/mperham's 2010 blog post here: http://www.mikeperham.com/2010/03/30/using-activerecord-with-eventmachine/ I don't think it ever even made it to Rails3. Really, even in general, using fibers at all of course requires you to modify your ruby program -- to use fibers, and to `yield` at appropriate times. You may have a proposal for a different way to make a platform work, and a way that ruby conceivably could or could have worked -- but it's now ruby was done. It would probably have it's own trade-offs. Compare to Node, which was indeed written ground-up assuming an evented async model, and whose ecosystem was written to do that. Ruby could have been that, but was and is not. 
And accessing remote HTTP APIs! If you can do that all in bg threads, that's better. But whether you can or not, if you have to do multiple of these that can be done independently, MRI threaded concurrency can speed up your wall clock time for the operations a LOT. 
I don't entirely understand, you want to provide a component that can be mounted in someone _elses_ web app? If that someone elses web app is going to be Rails, then a Rails engine is the most straightforward way to go, that's what it's for, yep. Sinatra is still pretty popular second choice to Rails, still not nearly as popular as Rails. There are a couple other newer contenders. I don't completely understand your requirements/goals. 
Yes. The thing is that we need to provide a simple way to any 3rd party Ruby shop a way to integrate with our server. We need to have some gem that can be baked into some other Ruby app and thalk to our server over HTTP (post redirect etc.) I would like to use Rails Engines since they seem simpler. I am not a Ruby dev so I don't know what is popular but it needs to be simple to implement even if the 3rd party that wants to integrate with us has non-Rails app. I actually managed to do this with Rack. From what I understand a Rack middleware works both under a Rails app and a Sinatra app (probably under any other Ruby web app)
Rails Engine works fine, that's what it's for, but will of course only work with Rails apps. I think that's probably reasonable -- but if it's a requirement to work if the 3rd party has a non-Rails app, that won't work. Maybe someone else will have advice. I guess you can just write a straight Rack app? Yes, it will be more work, or at least require more gluing together of pieces. But yes, if you can do it that way, that's the way. I'd try looking around for another existing service that does this, and see how they do it. 
It takes a while. If it's your first language it can take many years. Second language? 6 months if you work with it every day.
It would be really interested to know what you're seeing!
The benchmark in the article might be misleading. It measures time costs of `Hash#keys` and `Hash#values`, which scans the entries. While improvements on these methods are important, most programmers are interested in the performance of `Hash#[]` and `Hash#[]=`. 
For anyone interested in the details of why/how this change made it into ruby see: https://bugs.ruby-lang.org/issues/12142. There were actually 2 implementations fighting to get into main Ruby... Let's just say that things got emotional :p
Cool stuff! I have a few questions: * are mime-type-based engines supported, like, say, templates for json? Is this using Tilt in the back? * why using slim templates in the examples? I was expecting erb. There's hasn't been an healthy discussion about template engines in a while, and I might not know what's the state of the art and why. 
&gt; But when a thread context-switch does happen, it's still the OS making the decision of what threads gets switched in and out. Not really. There are basically checkpoints throughout the internals of MRI and at each one the current thread checks a flag to see if it should yield the GIL, the runtime sets this flag when it decides another thread should have some GIL time. In other words the MRI runtime does handle scheduling thread access to the GIL. It's also true that the OS may pause a thread to schedule another, or move a thread between cores, etc. But this is entirely transparent to Ruby code and has no impact on which thread gets the GIL next.
Thanks for the interest! Yes, we're using Tilt, so you can use any engine that it supports. We rely on Tilt's auto-detection for the engine based on the file extension. I picked Slim for the blog post examples because it's IMO the clearest, most beautiful template language for HTML. Purely a personal preference! ERB will work just fine too :) 
Is Fresno worse than Bakersfield? I always get the 2 confused geographically in my mind. 
I think it depends on the build, in the pthread implementation: https://github.com/ruby/ruby/blob/trunk/thread_pthread.c It looks to me like `pthread_cond_signal` is what will choose the next thread to run based on the scheduling policy set. Been awhile since I've dove into such things but I think it's FIFO + priority.
Yeah :D . The guy who proposed alternative implementation was too much emotional 
Ruby can already handle integers of any length. Is there a practical reason to re-invent this particular wheel, or is this just an academic exercise to show one way you could do it? I don't see any mention of the built-in BigNum functionality in your paper. Without even addressing its existence and why you would want to re-implement it, I'm just not quite sure what the point is.
Anyone else having trouble running code on the site?
Unless your coming in as the CTO with the responsibility of addressing pain points, probably best to observe, learn the realities of the environment and offer solutions when the team encounters pain points, otherwise you may come off as the new know it all that thinks his way is better. P.S nothing wrong with MiniTest, rspec is unpleasant for me :) 
You can always use git as an svn client. That way you get a lot of git's benefits without having to get the whole team to switch. 
Run.
Please correct me if my assumption is wrong but I find it even more surprising that you took on the job without knowing the details of this project...seems like you forgot to ask some questions before accepting the job?
&gt; In that situation I have an expectation the machines they are running on and the DB software in use is probably unpatched. You may also not have backups. Indeed, these are more important topics at the moment, I still need to investigate on that.
Honestly, I think Atlassian has the best overall resources for learning git. They have a few great sections on how ideas translate from other systems, and have a ton of general use examples from scratch that really helps a team start to use git. Spend some time through their docs digging up training material-- you'll find a ton of gems. This is by far my favorite page in the tutorials. Specifically it helps "if you're coming from SVN and want to use git like you use version control, here's how: it's dead easy" https://www.atlassian.com/git/tutorials/comparing-workflows Good luck!
Interesting Idea, however, Ruby already has a BigNum class that can hold a number as large as you want (or at least until memory runs out)
&gt; P.S nothing wrong with MiniTest, rspec is unpleasant for me :) Came here to say this. I learnt Rails in the Hartl guide, and multiple attempts to learn rspec have sent me back to minispec. 
It's very easy to get trapped in an echo chamber of reading about modern tooling and startups. Wait until you see a financial company running on a Microsoft Access database with half a million lines of VB6 macros, 0 tests, and a deployment strategy that involves walking around to 200+ desktops and copying it manually onto every one of them.
http://lmgtfy.com/?q=ruby+ORM I think that you are looking for [Sequel](https://github.com/jeremyevans/sequel) or even pull in ActiveRecord without Rails. 
Well, it is finally back online. Looks like all those issues mentioned have been resolved
Ok. Thank you for the info!
This is giving me PTSD.
I use this at my current job and the one before that (before they switched to git) and it works great. But always remember to rebase your changes on the changes on the server and merge your changes to the master. That will solve most issues. master &gt; git svn rebase master &gt; git checkout working-branch working-branch &gt; git rebase master working-branch &gt; git checkout master master &gt; git merge working-branch master &gt; git svn dcommit Done! Of course you could just work on master and do: `git svn rebase &amp;&amp; git svn dcommit`. But that would defeat using git.
So would it be ok if y'all used branches for SVN?
no troll, I want serious answers, I'm looking for example projects.
Did you write this blog post?
You're not wrong. You asked the important questions - What you are talking about here are just procedures and tools - If the culture is good and you approach it the right way, you can make positive change. Think about the flip-side, you vetted their awesome stack and not their terrible culture. Thats a much worse situation to be in.
I have the same issue, don't worry you are not the only one. 
Haha: C:\Users\Ignurant\Dev\ ----------------------------------- Name Modified Project\ Init. Project - Copy\ That time we thought we'd break it Project - Copy (2)\ That one day Project - Copy (3)\ A bit ago Project - Copy (4)\ A short while ago Project - Copy (5)\ Recently 
At first I was thinking "Wow, this is neat. But it would probably make it too easy for people to run expensive queries and kill the server if it wasn't tuned for BI reporting." Then I saw the note about caching, and decided that I'm interested again in at least giving it a glance. Thanks for sharing.
Thanks :) I think that will be very helpful considering I'll probably be the one teaching Git to everyone. I can make that and the interactive Git tutorial required reading before taking my class xD
It's not 100% best practices but it doesn't sound too bad. The showstopper is if the organization does not recognize the need for annual upgrades and paying down tech debt. 1. You'll never regret putting effort into expanding your test coverage to 80-90%. Beyond that is diminishing returns but having good tests gives you confidence to change almost everything else. 2. Moving to git is ok but moving to a workflow around pull requests + peer review would give you the biggest benefit IMO. Documenting the logical changes to the system (i.e. a PR) is worth its weight in gold. 3. Being on Ruby 2.0 is far, far better than Ruby 1.8. The upgrade from 2.0 to 2.4 isn't bad at all.
Same thing happen a few days ago, I tweeted and they fixed it: https://twitter.com/rubymonk/status/825595898294054912
Quite true, therein is the answer, probably. I had a classic application and the file was read and parsed on top level, e.g. $file = JSON.parse(File.read(...)) So it was read and parsed once, when Sinatra was initialized. I moved this into an actual request handler now so it should be done every time the request is processed. We'll see how it goes. 
I guess it's this, thanks for thinking along. https://www.reddit.com/r/ruby/comments/5riktt/phusion_passenger_apache_sinatra_file_cache/dd873i1/
Just a heads-up that calculating file hashes by reading the file off the disk can be an unexpectedly expensive process. We added something like this to our application that would read the file, calculate a checksum, and serve a cached version. The checksum calculation caused memory usage to increase on the requests and cpu usage to increase. This was noticable even when running some requests in about 10 browser tabs. There's unfortunately something else going on in our system that may be the cause, but i advise doing some load testing, especially of memory overhead, before rolling this out. Calculating the MTIME may have no visible overhead though.
Well my thoughts were along these lines: the external entity who updates the file will calculate the checksum and record it, so there will be file.json and file.md5. Now the web app stores it's own copy of last known file.md5. The web app never calculates the hash, it will just read the file.md5 and compare it to it's own "last known file.md5". If the hash hasn't changed, it will not parse the file, if it has, it will. Again, the web app is never actually calculating the checksum. Just a method to do it without relying on the OS/FS specific MTIME, for example, you could use this on FAT file system or when the system clock cannot be trusted. This is just a stupid thought experiment, I am not saying it would be practical in any sensible real life scenario :)
I can't possibly write code for this without more specific details - such as the database structure, and the desired input/output. But this sounds like it could be solved fairly simply with an Object Relational Mapper (ORM) - such as `ActiveRecord` or `Sequel`. You could also solve this in other ways, or with other languages. But as an example, your solution could look *something vaguely like* this: record = Record.find(id) children = record.children # Returns a collection of Record objects (may be empty) parent = record.parent # Returns a single Record object, or nil puts "Children: #{children.map(&amp;:name).join(", ")}" puts "Parent: #{parent.nil? ? "n/a" : parent.name}" 
No, I don't consider anything wrong with that. Writing methods like is effectively like name-spacing them, which can sometimes be useful in e.g. a gem that shouldn't be polluting the global name-space. So long as your code is easy to read, test, maintain etc. then I see nothing wrong with having [more than one way to solve a problem](https://en.wikipedia.org/wiki/There's_more_than_one_way_to_do_it). If you have *lots* of `self.` methods within a module, then a clever way to write this instead is to instead use `extend self`: module Foo extend self def bar # ... end def baz # ... end end Foo.bar Foo.baz This can also be used as a clever way to create a "fake `Singleton` class". [This blog post](http://ozmm.org/posts/singin_singletons.html) demonstrates this in a little more detail.
Well, what you are doing there is defining a global function. Inside a global namespace, but that is what it is. If it's a pure function (it only uses its params, it doesn't access anything else in the global scope) and you have thought about it and think that a global function is really what you need there, then I'd say it is fine. On the other hand, if this method is doing something with some global state, and especially if you have deluded yourself thinking something along the lines of "These 100 things are not global functions, those are bad. Mine are inside a module so they are not global, so they are good", then you should definitively stop doing that.
First, is like to say thanks for suggesting this gem; it's interesting and I hope you play around with it soon. I do have a suggestion for you: the next time you recommend a gem, I would beef up the action/example section. In this particular post, all you really do is show how to install it and the most basic use case of producing a graph. You didn't really show how the gem is better than options out there, or a great use case that only blazer could adequately solve. You really only tell us it's great before that. As you continue to write, make sure that your blog posts "show" as much as our even more than they tell, especially in you action/example section. Otherwise, solid article.
Agree!
The warning about possibly having two uses is important. It _could_ become confusing if you create class level and instance level use case defining instance methods and using `extend self`. I'm surprised nobody yet mentioned `module_function` which would allow you to make instance methods, turn them into private methods, and define them as methods on the module itself. I threw together this gist https://gist.github.com/saturnflyer/882e9e24525cb7e5dda8bfb06840c64a which shows that you can alter method definitions and in the case of `extend self` you can alter them later and the class method is also altered, whereas using `module_function :bar` defines a new method on the singleton object (at the class level) and would not be altered.
Thanks :) but the scripts are not running still
So, this behaves different in &lt;2.4 and 2.4. In which ruby is this meant to be done? My guess is &lt;2.4 right?
Does it? My "solution", such as it is, works on 2.3, 2.4, and 2.5. I get a slew of method redefinition warnings on 2.4, but there doesn't appear to be any consequential impact on the program's behavior.
No need to prepend. Just fire away at it with suitable method names.
It may well be that I've vastly overthought the thing, but is your solution probabilistic? Something like `send methods.sample rescue nil until defined? foo` only gets there a handful of times out of a hundred.
Step 1: Don't
Yeah, why would one do this? Broker goes down, your whole system goes down 
What would you recommend instead?
If a microservice needs to send a message to another microservice, it should do so by addressing that other service directly.
Woah, that's awesome. That's way better than what I've been doing. That fits much more nicely with our internal guidelines too. Thanks for educating me!
Because you can have teams of engineers focused on components in the system rather than all contributing to a single monolith. Separate code bases and deployments
Well yeah, I get that. But why should services talk to each other through the broker? They should all just talk to each other directly. You're losing the benefit of a distributed system. 
Weird. Still not working for me.
Clearly you have never dealt with massive IT organizations with 1000+ engineers. This is incredibly common in organizations with hundreds of systems that need to harmonize in some way for the business to work. 
I can get it to succeed most of the time. However, if the first `define_method` call is on `:to_s` or `:inspect` then MRI ruby appears to just ignore it, so I'm not sure if it is possible to solve those edge cases. That resulted in a success rate of 54 / 56 = 96.4% due to there being 56 methods defined on the main object, which I confirmed with a test script that counted failures out of 1000 runs. Update: Figured out a way that avoids that problem and seems to get it 100% of the time
are you sold on this OP? It doesn't consider syntax or development speed which are two of Ruby's biggest strengths. 
i recall it taking a few months. Keep in mind that your websites will necessarily look janky unless you invest decent time into learning CSS or use templates. If you want to make websites, learn Sinatra before Rails - you can thank me later. Some good beginner projects are chat bots (IRC, maybe facebook or even reddit) and web scrapers. 
added a link!
- Rails 3 (specifically 3.2) is not that old and should be pretty easy to upgrade. - Easy enough to plug simplecov and see what's up. Although coverage doesn't mean anything. - I hate RSpec and properly structured minitest is the way to do. Rails has gigantic testsuite and they don't need RSpec. - I remember SVN being a massive pain. Isn't git a standard for like 10 years now? SVN had advantage if you needed to commit large files, but you can do that with git (in github) now. - Error tracking is easy to set up. Errbit immediately comes to mind. - Manual deploy is just sad and scary Good thing there's a lot of things to do here.
Heres is my opinion. In last 6 month: * I've been subscribed on upcase for 3 months - finished all trails and seen all interesting to me weekly iterations (it's not weekly now) spending 1h 3-4 days every week. * watched RubyTapas and some videos show you some deep things, like difference between || and or. How to work with low level things and so on. * watched almost all Sandi Metz videos from conferences, few from Katrina Owen and few from Robert Martin * read Code Complete, POODR, 99 bottles of OOP. The greatest ideas for how to design and write code I've get from Sandi Metz videos and books. From upcase I've increased my productivity by deeper learning vim and tmux. Filled some gaps of knowledge of Rails and ActiveRecord query interface. Learn some nice things from RubyTapas. And everyday practise on my hobby project where I can apply all new knowledge. But about the deal 400$. I think you can spend 1-2 month on upcase, get RubyTapas for 6 month and it will be 30 * 2 + 18 * 6 = 168$, buy few books and it will about 200$ - twice cheaper. Please note, it's only my opinion.
That's a good point, they said you can DL material, so I doubt I really need a year. &gt; like difference between || and or This is what I was worried about, stuff like that is not what I would call advanced. More in the intermediate/good to know pile, but unlikely to make you a substantially better developer. So it sounds like there is *some* benefit. If have read POODR and loved it, that was actually about 2 years ago now, so maybe it's time for a reread. What other Sandi Metz stuff would you recommend? I loved her video on testing, and what not to test and POODR, but I think that's all i've seen/read from her.
That special casing doesn't seem to help. It just makes it so Object#methods doesn't return :inspect or :to_s and Object#method says the method is undefined even after define_method is called to define those methods.
right, sorry about that
When you launch irb, is there a warning printed out about not having readline available? If so, you'll need to follow the directions and reinstall or recompile Ruby with readline support.
Nope no warning :(
In cases like this you want to use instance_of? expect(some_var.instance_of?(Big decimal)) (Not an expected user, so someone please correct me if there is a better way)
Would a downside be that you'd have to create a no-op function in the special case class for every class method in the object's parent class?
Here's my take on Avdi (7+ years in Ruby/Rails): * he has design ideas worth considering * he shows you the edges of the language, which I have found influence my day-to-day far more than I would have expected * he's the opposite of Railscasts...he doesn't care about the latest gem; it's all about code structure, maintainability, readability, etc. He toggles between big picture ideas and nuances, both helpful All in all, I've found my subscription very valuable and thought-provoking.
I would never spend $400 on online tutorials, but I already know ruby and Rails and have for years, so I dunno. 
https://github.com/banister/binding_of_caller/blob/master/ext/binding_of_caller/binding_of_caller.c It mucks around in core Ruby code. Kinda scary for production use. But I guess if you're modifying the language you've already set sail for treacherous territory.
The issue is that the `grocerylist` method does not have access to the `grocerylist_hash` variable. It's out of scope, and you'll have to pass it in as an argument. Try something like `def grocerylist(grocerylist_hash)` when defining the method.
It could easily break in future ruby releases, and requires implementing custom code for each ruby platform (mri, rbx, jruby). I would think that's why the author says not to use it in production code, but why not try asking the person that wrote that?
Yeah this is correct
In short because Ruby is not Javascript. Basically inside the function you have a separate local context, and variables defined outside aren't in it.
Any C extension mucks around in core Ruby code though.
Yeah, uh, clearly.
I think that coding is like writing, woodworking, machining, or any other creative profession. The money should flow to the person who is writing code, not away from the person who is writing code. Learn on the job. If you are new to coding, your salary should be smaller, but still &gt; 0.
I've been a RubyTapas subscriber for over 2 years (and a Ruby developer for over 5 years), and I found it really valuable to my Ruby knowledge. I love that I learn so many useful details about the Ruby language that I didn't know about, and that episodes really show great uses cases for these features, and I used many of these at work. Learned about many lesser-known Enumerable methods, Null Object pattern, Tempfiles, composition over inheritance and similar. There are also really advanced multiparters showcasing concurrency constructs in Ruby (seriously, there is so much to know), implementing the "tail" command, every possible use case of splats (I used many of them), coercion and conversion functions, `logger` standard library, many useful things about spawning subprocesses etc. What I like the most about RubyTapas is that it teaches me general knowledge and patterns about programming in Ruby that I can apply in any environment. On the other hand, Upcase is probably more Rails-oriented, which for me personally this isn't useful because I program in other Ruby web frameworks, but it might be great for Rails developers. One other screencast where I felt a level-up was "Destroy All Software" by Gary Bernhardt, especially my testing workflow.
Author here - &lt;= ruby 1.9.3 `binding_of_caller` worked by digging deep into MRI internals, however since ruby 2.0 there is supported C API in MRI that is used instead. It's called the MRI `DebugInspector`API and i wrote a Ruby wrapper for it here: https://github.com/banister/debug_inspector (which boc uses). There's no real reason not to use it in production in Ruby &gt; 2.0, so long as you only care about MRI (since `DebugInspector` is only an MRI API). However, you have to beware that building binding objects, especially multiple binding objects from stack frames is a pretty slow process, so check carefully that you're not going to be negatively impacting performance of client applications. 
Also, I noticed recently #dig does a lot of what I want from the Clojure side, and this library, destruct ( https://github.com/LendingHome/destruct ) does a lot of what I want, however of course in order to get the local binding w/o changing the language it becomes repetitive.
When I was learning I was able to write scripts to help at work. I automated things like disk cleanup on servers.
Umm... CSV. open("output.csv", "w") { |csv| csv &lt;&lt; column_names; all.each {lr| csv &lt;&lt; r.attributes.values }}
&gt; I get .each parses the items in the array What resource(s) are you using to learn Ruby? I ask because you're kinda just throwing a bunch of tangentially related words together and ultimately not making a great deal of sense, but that could well be the fault of some extremely undisciplined teaching material.
I knew I'd get shit for saying "parses." I don't mean parses in the programming sense. Shouldn't have used that term. Not the fault of the material (learnrubythehardway), my fault. 
Thank you. Added "end" with an edit. So, to give a little bit more context, I have working code. It's doing exactly what I want it to. I just don't understand why. Here's my actual code (it's a simple grocery list that you can add to and delete from): GROCERIES = [] def display_list puts "Here is your current list: " puts "-" * 10 GROCERIES.each do |groceries| puts groceries end puts "-" * 10 prompt end What I don't get is what |groceries| is "doing." I'm saying, "OK program, *do* |x|," but I have no idea what the value between the pipes represents, therefore I have no idea what it's "doing." Can I put anything between the pipes? What is "groceries" being assigned to here? 
Not really. You're taking a block (basically a function, or series of operations) and executing it on each element of the array. The thing between the bars ("items" in your example) is a single element of the array. If you imagine your array is three elements long, writing `puts array[0]; puts array[1]; puts array[2]` would be equivalent. As a matter of fact, I think the way you're naming shows a misunderstanding. It's only one thing. So, if you had an array called "groceries" like in the other example you wrote, you might write `groceries.each { |grocery| puts grocery }` to more accurately reflect what's going on.
|groceries| is just a variable representing the current item from your array. You can call it whatever you want. Normally you'd try to give it some context like the following: people = ['James', 'Steve', 'Roger'] people.each do |person| puts "Hi, my name is" + person end Outputs: Hi, my name is James Hi, my name is Steve Hi, my name is Roger Giving the variable context makes your code easier to read - which is really important for your sanity. Naming the variable 'groceries' is a little misleading because it refers to a single item in that array, but you've used a plural. It would read better if you used a singular variable name like 'item'.
Ahhhh, this helps a lot. Thank you. 
What you're dealing with is called a *block*. Blocks are chunks of code that get passed around in Ruby. This chunk of code is getting passed to `each` called on an instance of `Array`. The `items` part inside the `|` bars is an argument to the block. If you squint real hard, it sort of looks like a method. E.g. def do_thing(items) puts items end would be the named version of what your block is doing. `each` takes your (unnamed) block of code and runs it for every item inside the array. It passes the array value into the block (which gets assigned to `items`). Your code prints to the screen. What the code inside `Array#each` is doing is basically: l = array.length i = 0 while i &lt; l yield array[i] i += 1 end You can even [see the source code on the ruby/ruby repo](https://github.com/ruby/ruby/blob/v2_4_0/array.c#L1817-L1827). Keep in mind, blocks are nothing special. You don't have to just use them only for loops. Try this out: def yield_stuff yield 'a', 123 yield 'b', 456 yield 'c', 123 + 456 end yield_stuff do |char, num| puts "#{char} and #{num}" end will output a and 123 b and 456 c and 579 It's no magic - under it all is just Ruby. And under Ruby is just C.
Understood. Thanks. Yes, I have a "add_item" function defined elsewhere that gets items from the user, populating the list. 
oh, I think I understand, thanks!
&gt; blocks are nothing special Burn the heretic!
Take it as a sign to do [the Koans](http://rubykoans.com/) instead.
Thank you for the suggestion.
Don't worry about it too much. Programming vocabulary is difficult to learn, and everyone struggles with it in the beginning (I've written a bit about it [here](http://www.programmingforbeginnersbook.com/blog/expand_your_programming_vocabulary/)). The term you're looking for is probably "iterate" or "loop over".
the "block" you're be passing in is essentially a method that is itself being called by the each method for each item in the collection. That name in pipes is just the name of the parameter for that method so it's only for your own use. I recommend implementing the each method as an exercise to get a better grasp of what "yield" does.
Post you routes.rb file
&gt; (Could you be more specific about the failure? What does ./configure do? What is the error message?) I could, the exact error is checking direct.h presence... yes configure: WARNING: direct.h: present but cannot be compiled configure: WARNING: direct.h: check for missing prerequisite headers? configure: WARNING: direct.h: see the Autoconf documentation configure: WARNING: direct.h: section "Present But Cannot Be Compiled" configure: WARNING: direct.h: proceeding with the compiler's result Complete output including the invocation from rake is here http://pastebin.com/fmtFBNni PS: the example in my OP was just to ilustrate the difference, actual `./configure` is try to cross compile ruby for windows This works: sh( "#{src_path(:ruby) + '/configure'} debugflags='' --prefix=#{install_path :ruby} --build=x86_64-pc-linux-gnu --host=#{ARCHS[ARCH][:host]} --enable-shared --disable-install-doc --enable-install-static-library --with-winnt-ver=0x0501" ) and this doesn't: sh( src_path(:ruby) + '/configure', "debugflags=''", "--prefix=#{install_path :ruby}", "--build=x86_64-pc-linux-gnu", "--host=#{ARCHS[ARCH][:host]}", "--enable-shared", "--disable-install-doc", "--enable-install-static-library", "--with-winnt-ver=0x0501", ) did I miss something?
If you want something a bit more flexible, I suggest you take a look at `open3`. w.r.t. your question, I usually prefer separate arguments, especially when user input is given. For example, sh "ls #{dir}" But what happens if `dir = "; rm -rf ~/"`?
&gt; I usually prefer separate arguments, but my issue is that with separate arguments it doesn't work :/
The first form in your examples spawns a shell to execute the command, but the second doesn't. The first form is similar to running the special case in the following implementation: def system *args if args.count == 1 fork_and_execve("sh", "-c", args.first) else fork_and_execve(*args) end end 
the important parts of the routes are here: (removed a lot of the jsonapi resource routes to save space) Rails.application.routes.draw do mount RailsAdmin::Engine =&gt; '/admin', as: 'rails_admin' root to: 'home#index' end
Seem to be some problems with `relative_url_root` in active admin: https://github.com/activeadmin/activeadmin/issues/101
The typical way to copy an instance of an object to a new object is [Object#dup](http://ruby-doc.org/core-2.4.0/Object.html#method-i-dup). array1 = [1,2,3] array2 = array1.dup array2.delete(2) p array1 =&gt; [1, 2, 3] p array2 =&gt; [1, 3] The more Ruby-ish way to do this would be to use some Enumerable method to produce a new output array based on a transformation of the input: array1 = [1, 2, 3] # Reject iterates each element of the array and returns a new array consisting of the elements # which are not rejected by the test in the block array2 = array1.reject {|e| e == 2 } p array1 =&gt; [1, 2, 3] p array2 =&gt; [1, 3] 
&gt; ... which will parse out the different parameters ... and do file name expansion etc. along the way.
great, thank you! is there a version of reject that removes an element based off of its index? say array1 = [1, 2, 3, 2] and i want a new array2 = [1, 3, 2] is there something like array2 = array1.reject_byindex(1)?
The docs almost seem to imply that the multi-argument form will be escaped, while the single argument form won't.
This person provided a great answer, but since they mentioned Ruby's enumerable methods without linking it, I wanted to drop [a link to the docs](http://ruby-doc.org/core-2.4.0/Enumerable.html) in here. Enumerables make Ruby fun and elegant; idiomatic Ruby makes good use of the interface, particularly `each`, `map`, `select`, `reject`, etc. Welcome aboard! I also thought it was neat that you got a response from tenderlove, he's famous in rubyland.
Actually `system('printenv')` has no special characters, so it will bypass the shell, despite being a single string (see the documentation of [Kernel::exec](https://ruby-doc.org/core-2.4.0/Kernel.html#method-i-exec)). So you should compare `system('printenv')` with `system('printenv;')` 
To expand on this, you basically opened 3 methods and only the third one is closed because of the 'end' directly after it. Which is why you get "unexpected end-of-input, **expecting keyword_end**"
What the fuck is this dumpster fire of an .rb file. You need to forget everything you've learned. Pick up a book and start over. The other commenters are indulging you but seriously you will only find yourself frustrated and confused if you keep going like this.
&gt; (n.b., strings will be made immutable as of Ruby 3.0) Maybe, maybe not. The decision is not yet made for sure, it's something being considered. &gt; First there was a Q&amp;A session with Matz and the other core committers. There’s clearly a large desire to learn from Python and be careful not to create the kind of split seen between Python 2 and 3. Part of that means freezing strings by default probably won’t make it into Ruby 3. https://aaronlasseigne.com/2016/09/15/rubykaigi-2016/
Threads were invented and added to OS's for computers that mostly only had one CPU. As were processes,the first form of multi-tasking. Threads were invented as 'light-weight processes'. The main reason to use threads in MRI (with the GIL) is for IO-bound work. Threads spending a lot of time waiting on IO (a database, a file system, a remote network service) can be switched in and out, and achieve their tasks in much less 'wall clock time' than if they had been run serially, even with the GIL limitation on one thread active on a CPU at a time. 
It's worth mentioning that concurrency is only possible if the I/O method explicitly unlocks the GIL before it blocks. All of the built in methods do this, but it's possible that some poorly made gems won't.
Hello, Thanks to [Andy Allan](https://blog.gravitystorm.co.uk/2017/01/31/upgrading-the-osm-blogs-aggregator/) for moving the [OpenStreetMap Blogs](https://blogs.openstreetmap.org/) from the classic Planet Planet (in Python) to the modern (Planet) Pluto (in Ruby). See the [new planet setup](https://github.com/gravitystorm/blogs.osm.org) on Github. Cheers. PS: What's Pluto!? A Free Planet (Static) Site Generator - Auto-Build Web Pages From Published Web Feeds -&gt; [feedreader.github.io](http://feedreader.github.io)
Seeing this blogpost reminded me of a infrastructure consequence of using PStore. We've used it in one app some years ago. Last months, we've been trying to change the infrastructure to run the app on more nodes. ... and PStore is a potential problem here. We no longer have the luxury of sharing the same file system. Also not all cloud providers do give access to file systems. While I still like PStore, this is something worth keeping in mind. The whole story is here: http://blog.arkency.com/2017/02/a-potential-problem-with-pstore-and-rails/
Even if you had the same file system on multiple workers, I would _not_ assume pstore is concurrency-safe between multiple processes. It might be. 
we have a winner, this is the issue :) thank you so much!
Well, quite some things to be fixed, but a good start. First of all there is no then after if :) I can probably write some more tomorrow when at my computer 
Nice :) There's obviously a lot to improve there, but without changing too much your original approach. You should avoid using `then` in multiline `if`s. [link](https://github.com/bbatsov/ruby-style-guide#no-then) Try using guard clauses to simplify your code. [link](https://github.com/bbatsov/ruby-style-guide#no-nested-conditionals) # Instead of if answer_game.downcase == "yes" # Lots of (unindented) code else puts "I hope to play sometime" end # It could be if answer_game.downcase != "yes" puts "I hope to play sometime" exit # Would use return instead of exit if inside a method end # Rest of the code here # Or even better unless answer_game.downcase == "yes" puts "I hope to play sometime" exit end # Rest of the code here `If`s an `switch`es always return a value, so you can abuse this computer_pick = if rpsv == 0 "rock" elsif rpsv == 1 "scissors" elsif rpsv == 2 "paper" end # Or using a switch computer_pick = case rpsv when 0 then "rock" when 1 then "scissors" when 2 then "paper" end Like I said, there's a lot you could improve on (Eg using `Array#sample` to get your computer pick `computer_pick = %w[rock paper scissors].sample`), but you'll start getting better as you keep using the language, so keep on practicing. :)
Thanks, documentation is very important to me so I'm glad it's clear.
Looks like RubyMine.
so ``` @new_existing_rows.last ``` returned a Hash then u called `issue` on it. Thats essentially whats going on. it seems that u expected `@new_existing_rows.last` to return some object that responds to `issue`
That last frame. Lol
Because `@new_existing_rows.last` returned a hash, I could not call my method `issue` on it. I looked at that documentation and changed my expect to this: `expect(@new_existing_rows.last.fetch(:issue)).to eql(true)` It works :)
This is awesome!!!! I just finished my fist ever project of a simple tic tac toe game. People were not adequately excited about it. You built a game of rock, paper, scissors OUT OF NOTHING! I'm very impressed :)
Well, I started golfing your answer, I'd argue that the first two lines are really unnecessary since, if I didn't want to play a game, I would just not play the game. Also, the asxsignment of the hash to `game` as one line (lines 4-8), they're only written this way for readability. So, I'm calling this 4 logical lines. puts 'Would you like to play a game?' abort 'I hope to play sometime' unless gets.chomp.downcase =~ /y(es)?/ puts 'rock, paper or scissors?' game = { 'rock' =&gt; { 'paper' =&gt; false, 'scissors' =&gt; true }, 'paper' =&gt; { 'rock' =&gt; true, 'scissors' =&gt; false }, 'scissors' =&gt;{ 'rock' =&gt; false, 'paper' =&gt; true } } puts game[%w(rock paper scissors).sample][gets.chomp.downcase] ? 'Computer Wins :(' : 'You Win!' Here it is in one line: puts'Would you like to play a game?';abort'I hope to play sometime' unless gets.chomp.downcase =~ /y(es)?/;puts'rock, paper or scissors?';game = {'rock'=&gt;{'paper'=&gt;false,'scissors'=&gt;1},'paper'=&gt;{'rock'=&gt;1,'scissors'=&gt;false},'scissors'=&gt;{'rock'=&gt;false,'paper'=&gt;1}};puts game[%w(rock paper scissors).sample][gets.chomp.downcase] ? 'Computer Wins :(' : 'You Win!' Then I tried to accept 'r' 'p' or 's' inputs, but couldn't get this to work and it's really late... puts 'Would you like to play a game?' abort 'I hope to play sometime' unless gets.chomp.downcase =~ /y(es)?/ puts 'rock, paper or scissors?' game = { 'rock' =&gt; { 'paper' =&gt; false, 'scissors' =&gt; true }, 'paper' =&gt; { 'rock' =&gt; true, 'scissors' =&gt; false }, 'scissors' =&gt;{ 'rock' =&gt; false, 'paper' =&gt; true } } answer = { 'rock' =&gt; %r{r(ock)?}, 'paper' =&gt; %r{p(aper)?}, 'scissors' =&gt; %r{scissors} } cmp_answer = %w(rock paper scissors).sample user_answer = answer.find{ |k, rx| gets.chomp.downcase =~ rx } puts game[cmp_answer][user_answer] ? 'Computer Wins :(' : 'You Win!'
It's an important point, yes. PStore has the concept of transactions. You wrap the writes into it. It doesn't save the concurrency problem (especially in high-traffic situations), but at least they let you know when the transaction failed.
`butt` is the only test data worth using
Today Rock Paper Scissors in RubyMine In a year fully TDD on vim. 
first, you should know something you did right: you got it working before worrying about your coding style!! now, rewrite the code from the feedback you got here. then, try to break it into smaller methods. we can give suggestions on that if that confuses you. 
PStore's transactions are definitely concurrency-safe between multiple processes, they use the file system in a concurrency-safe way somehow? (lockfile of some kind?) Looking at the Pstore docs, I think it maybe sort of suggests this, but like much of the stdlib docs it could def be more clear. It also warns: &gt; By default, file integrity is only ensured as long as the operating system (and the underlying hardware) doesn’t raise any unexpected I/O errors. If an I/O error occurs while PStore is writing to its file, then the file will become corrupted. &gt; You can prevent this by setting pstore.ultra_safe = true. However, this results in a minor performance loss, and only works on platforms that support atomic file renames. Please consult the documentation for ultra_safe for details. Still curious about the nature of the concurrency contract of PStore, if multiple processes (not just threads using the same global PStore in-memory objects) try to write simultaneously, does one block? Does one "win" and one may have it's changes thrown out even if they didn't conflict with the other? Etc. The note about 'atomic file renames' (at least when `ultra_safe = true`) suggests an approach that we could guess the consequences of, but we end up making a lot of presumptions. Not that it's your job to explain all this, just wondering, and reminding folks to consider such things in their designs, choices, and documentation writing. :)
 GESTURES = ['rock', 'paper', 'scissors'] RESULTS = ["It's a draw.", 'You win!', 'You lose.'] puts "Rock, paper, or scissors?" input = gets.chomp.downcase human = GESTURES.index(input) or abort("I don't understand #{input}") computer = Random.rand(3) puts "You chose #{GESTURES[human]}, computer chose #{GESTURES[computer]}. #{RESULTS[(human - computer + 3) % 3]}"
I'd argue that the false values in the hash are unneccessary because a non-existent key will just return a `nil` :) With a little string concatenation trick, I've managed to compress yours down to: puts 'Would you like to play a game?' abort 'I hope to play sometime' unless gets.chomp.downcase =~ /y(es)?/ puts 'rock, paper or scissors?' puts ({'rockpaper'=&gt;1,'paperrock'=&gt;1,'scissorsrock'=&gt;1})[%w(rock paper scissors).sample+gets.chomp.downcase] ? 'Computer Wins :(' : 'You Win!' In one line (277 characters): puts'Would you like to play a game?';abort'I hope to play sometime'unless gets.chomp.downcase=~/y(es)?/;puts'rock, paper or scissors?';puts ({'rockpaper'=&gt;1,'paperrock'=&gt;1,'scissorsrock'=&gt;1})[%w(rock paper scissors).sample+gets.chomp.downcase] ? 'Computer Wins :(' : 'You Win!' 
If you DID want to call dot methods, you could use OpenStruct.
This is pretty critical advice. I have wasted a ton of time trying to do something "right" the first time instead of just getting the code functional, then refactoring.
Rake is an extremely powerful task execution tool. I've seen projects done in ruby just so they could use rake. I personally, would do it all in rake, you can make your rake test command dependent on the commands that spin up your docker image, fiddle with your knobs, and then run tests, but then you also have those commands available for use independent of your rspec tests as well.
As a new programmer, my question is: is self just a shorthand way to refer to the value/class/etc above it? 
Disagreeing with menge101work, I don't think rake is all that powerful (I think maybe those people just wanted to use _ruby_ but didn't realize it), but the fact that it doesn't actually do much means there aren't many downsides to using it either. It's basically just a framework that allows you to easily write commands that are executed like `rake name_of_command`, as well as have individual commands that can be executed alone or in combination like `rake one_command another_command third_command`, as well as have commands (or "tasks" as rake calls them) express 'dependencies' on other tasks, so running `some_command` will automatically cause `prereq_command` to run first (where `prereq_command` can also be run independently). That's for the most part all there is to rake. If those seem like useful features or a useful way to structure your app, then it's for you. If they seem like they _could_ be useful in the future and rake doesn't really get in the way, then no reason not to use it. Otherwise, you can just write plain old ruby scripts, which is fine too. The main advantage of plain old ruby scripts is more flexibility in argument parsing, allowing you to write code to parse ordinary unix-like arguments (eg `-a something` or `--something` or whatever). Which rake doesn't really get along with. But ordinary ruby scripts it's going to be a pain to get rake's features (having multiple commands easily available from the command line in a project directory, running more than one at once, dependencies). I don't really know about "rspec hooks" as an alternative. I think of `rake` and "an ordinary ruby script" as being alternatives, rspec hooks seem like something else. rspec hooks (you mean like `before(:suite)` hooks?) will run _every time_ you run rspec without having to run a 'setup' command but whether you like it or not, which could be a blessing or a curse, and will probably result in fighting with rspec. There's also of course the standard `spec_helper.rb` file which most rspec suites include, for before-suite setup. Which is fine for things you really want to happen every single time you run rspec. Starting a docker image and fiddling with server settings are probably not such things. A `spec_helper.rb` (or `before(:suite)` hooks, often set up in a `spec_helper.rb`) is ordinarily used for configuring internal in-memory things -- for things that really are _invariant_ and definitely need to be done _every single time_ before running any tests. Not things which rely on state external to the ruby process, and depend on the nature of that state. 
There are other uses, devops is a key one which comes to mind, chef, puppet. But as a compsci student, it is nice to have a broad knowledge base in many languages. But that aside I think there are better languages to focus on other than Ruby, like Python. 
Depends on what you want to do. For a desktop or mobile app? No, ruby is not a great choice. What do you want to do with it that isn't web? Whatever the old answers were, they are probably still valid. 
I think Ruby is a good language to study because it incorporates patterns, architectures, and conventions from other languages. Ruby is a derivative, and it's very inclusive. If you know Ruby inside and out, you probably know a lot about programming in general and where the concepts came from.
I'm currently reimplementing a ruby script which will replace a set of tools which analyze a source code control system and feed a database which data will eventually end up in a web application. It was originally done using shell scripts, awk, perl and unix tools. I use Sequel for the database operations, Sinatra for the web presentation, the ldap gem to access ActiveDirectory.
non web tools based on Ruby I know of: - Chef - SonicPi
and the down votes begin, with not one response as to why :)
or fluentd
Ruby works great for all the stuff Perl used to be used for, which is why devops tools like Chef and Puppet are written in Ruby. Anything you would use a scripting language for, Ruby is perfectly suited for.
Well, thank you all for your amazing answers o/ ! Currently, I don't know why I will be using Ruby (except for a project in RPGMaker) for but I will stick with C++ and Java for software development. And still use Ruby to create little programms. ( I'm currently trying to create a Vigenere Encipher ).
[Vagrant](https://www.vagrantup.com/), [Capistrano](http://capistranorb.com/), [Chef](https://www.chef.io/) and [Puppet](https://puppet.com/) are some DevOps applications that use Ruby. For writing cross-platform apps you have [RubyMotion](http://www.rubymotion.com/), and for 2D game development [Gosu](https://www.libgosu.org/). [Game Development + Ruby = Happiness (talk on RubyKaigi 2016)](http://rubykaigi.org/2016/presentations/amirrajan.html) It's also very good for scripting.
if you want to play it safe, then i'd recommend Javascript or python. but if programming is a passion, i'd encourage you to learn a language as diametrically opposed to your prior languages as possible. ruby is certainly further afield from your past than, say, python, but i'd encourage you to look even further. perhaps a more functional language like haskell, elixir, and so on. you won't get such an opportunity to learn whatever you want for quite some time, so go crazy. it will add a whole new brain to tackle a functional language, and that experience will last you longer than a mainstream flavor-of-the-day language. 
Since this is -apparently- part of a series, you could link them all together in each one.
This makes sense. Thank you :) 
Thank you for sharing this, this is an excellent use of `Open3.popen3`! The more I'm learning about executing shell commands and handling IO of all sorts, to more I continue to love Ruby. I think it's great that `Kernel#spawn` is so versatile, and that Ruby has a convenient wrapper round it, the `Open3` standard library. I first used `Open3` when rewriting MiniMagick. Previously, MiniMagick used a library which couldn't distinguish between stdout and stderr, you would just get a string back where both are combined. Then I learned about `Open3.capture3` (simpler version of `Open3.popen3`), which gave me exactly what I needed – two strings, one stdout, and the other stderr. But using `Open3.popen3` as a way of feeding input console is a completely new usage of Open3 to me! It's great when developing open source projects teaches you deep Ruby knowledge like that, you probably wouldn't have learned about that if you weren't persistent on doing it the right way ;)
Yes, Hanami leveled up my Ruby skills. That's why I'm sharing this stuff: I hope it can be useful for other people too.
Kind of. Self is a way to refer to the context in which the current code is running. Depending on where you use it, that could be a class, an instance of a class, or some other object. Hope this helps! 
Feelsgoodman.
I didn't realize it wasn't 'piece of shit' until I saw your comment
What you did is 75% of business software development. Congrats!
Congratulations! I recently had to do this (using Padrino) with a modern system that still uses SOAP. Heaven forbid Microsoft use a standards-compliant web communication method in software released this year *headdesk*
Yep, we pretty much summed it up [here](https://www.reddit.com/r/ruby/comments/3341zm/require_best_practices/) :P
Is there any way I could participate remotely? I live outside USA but I would love to join you guys on one of these projects.
Me too. I'm from China, Is there one remote participating way for me?
POS software is mostly managed by sales people. I can assure you that you'll be a golden resource in less than 1 year :)
Check in on github and slack, many projects kicked off at R4G keep running year round.
I think, it worked untill Ruby 1.9
This is awesome - a chance to do some tangible good, and it sounds like a lot of fun too! I lurk this sub because I'm trying to learn Ruby (I've dipped my toe in before and I'm getting ready to dive in!), so the idea of going to something like this in one or two years is a big motivator for me. Keep up the good work and I'll see you then!
Oh wow this is great. Too late for me to plan this for this year I think but I'll count on it for 2018.
Right, but will that allow the wrapper gem to make calls to the authentication gem. I'm fine with making it a requirement that apps need to list both gems but I just want to ensure that the two gems can talk to each other. Thank you!
`puts` automatically adds a newline at the end of the string. Try using `print`.
Read the book 'Metaprogramming in Ruby'. You mentioned computer science, so live up to that claim. Learn programming paradigms and learn how interpreters and VMs work. You gotta know machine architecture, OS and C first of course. Don't just be that asshole debating over which langue has which value, knowing nothing to little about any of them. Knowledge is power, not the monkey-see-monkey-do scripts in any particular language.
You should come this year! We have a wide range of attendees from newbies all the way up to people who've written ruby programming books!
I share your frustration. I'm sure there are lots very well written Rails apps out there. Unfortunately most are written for businesses, so aren't open source. If you're an Upcase member, you get access to the full source code which runs the site. It doesn't completely follow POODR style, but it's a great example of a large Rails app written by expert-level developers. I've learned a lot from reading that code.
My pet project (not a Rails app) is something I've worked on polishing and where I've tried to bring all the best concepts I could. It... Might be useful? https://github.com/trevoke/sgfparser
The beauty of dealing with Ruby and not, say, PHP, is that you don't have magical interpreters looking for anything that might be code and running it. Heck it's totally safe letting people upload .rb files so long as you just save it, as opposed to executing it. So your issue becomes, what business rules do you have around this? I would like to say "whitelist .jpg and .png extensions only" but I don't know if you're actually dealing with image uploads. If you can expand your requirements a bit more we could discuss them further. Do uploaded files go to a public download folder?
Thank you, I'll check out the upcase code. 
This has definitely been my experience working on Rails apps, but I wanted to fix that in the projects I work on at least :)
Alas, the talk was yesterday - but you can still watch the video of it via that twitch link!
I have a [pet project](https://github.com/skyderby/skyderby), but it follows ideas partially. Basically I've started it 3 years ago and read the book half year ago. So new code is following ideas and I'm rewriting old code.
[Rubyland](http://rubyland.news/) has a pretty long list of sources they're aggregating. 
I have found it pretty easy to maintain higher standards of organization than what is described by POODR. I have not published any OSS example programs.
&gt; now that github pages adopted them Isn't that how Jekyll started? 
it looks like it was created by github's co-founder, but I don't think its directly related to Github itself.
So much this, thanks for posting! Edit: Although I think this would work better with Sequel instead of ActiveRecord :) Edit 2: Here's the [Sequel](http://sequel.jeremyevans.net/) version (couldn't resist :) class ProgressBusinessObject def self.weight_graph_data(user_id, category) # express logic in 4GL language # easy to reason about # easy to change and adjust # return results as an array of objects for the rest of application to seamlessly use DB[&lt;&lt;~SQL, user_id: user_id, category: category].map { |i| WeightGraphItem.new(i) } SELECT Date(logged_at), Max(logged_weight) AS weight, workout_items.unit, workout_set_groups.set_group_name AS category FROM workout_items JOIN workout_set_groups ON workout_set_groups.id = workout_items.set_group_id WHERE user_id = :user_id AND logged = true AND workout_set_groups.set_group_name = :category GROUP BY Date(logged_at), workout_set_groups.set_group_name, workout_items.unit ORDER BY Date(logged_at) SQL end end 
Keep in mind that until relatively recently, people simply didn't write automated tests, yet still managed to build complex, successful systems. I suspect that in those situations, developers wrote more simple, modular code. Think of Unix where it's composed of many individual tools, which can be combined in powerful ways. Whereas if you have a test suite, you can write endlessly complicated spaghetti code, with the security blanket of tests to catch it when you mess up.
You can use thread pools and forks to achieve quick and dirty parallelism in MRI. Threads on their own don't give you multi-core parallelism though.
&gt; team-built You are not a team. Individuals can keep code clean and consistent. Less so when 5-10 people are all contributing.
A lot of people share their latest posts and projects onto http://www.rubyflow.com/
Because you said I, not we. And I don't think our statements are mutually exclusive. Me: Apps maintained by teams will be harder to keep consistent vs individuals. You: I've had success as a team maintaining an app with clean code. Cool.
But you said "impossible," not "harder." I agree, excellent results are much harder to achieve than mediocre ones.
Here are some good general resources on securing file uploads: * [OWASP: Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload) * [Nvisium: Secure File Uploads](https://nvisium.com/blog/2015/10/13/secure-file-uploads/) * [AppSec: 8 Basic Rules to Implement Secure File Uploads](https://software-security.sans.org/blog/2009/12/28/8-basic-rules-to-implement-secure-file-uploads/) Even if you think that you "just want to do something simple", I would still recommend using a file upload library like [Shrine](https://github.com/janko-m/shrine), because handling file uploads properly is always more involved than it first appears, so it's handy to have library which already incorporates or guides on best practices in terms of security, performance and user experience. My personal summary of common security things to ensure: * Validate MIME type against a whitelist. Make sure you're actually extracting MIME type from file contents and not just reading it from the `Content-Type` request header (`determine_mime_type` feature in Shrine). * Validate maximum filesize. If you're accepting multiple file uploads simultaneously, limit maximum number of files, and also it's good to validate a minimum filesize for each file as well. * If you're uploading images, validate the dimensions *in addition to* the filesize. And make sure you're using [FastImage](https://github.com/sdsykes/fastimage) for extracting dimensions to guard yourself from [image bombs](https://www.bamsoftware.com/hacks/deflate.html) (`store_dimensions` Shrine feature uses Fastimage). * Don't store files on locations derived from the original filename – it's a pain to sanitize, and people can send malicious filenames – just generate your own unique IDs (Shrine does that automatically). * Never load whole files into memory, only chunks at a time.
I have coded in a multitude of languages, but Ruby is just beautiful to work in. I think it is the most perfect and practical of the object oriented languages. &amp;nbsp; I think Elixir is the same for functional languages. &amp;nbsp; I think Javascript would be a very worthwhile thing as well.
Thanks for keeping RubyFlow running and (updated) all those year and thanks for putting the [webfeed e.g. rubyflow.com/rss](http://www.rubyflow.com/rss) on the front page.
Thanks! The real credit goes to people who post to it every day. I had to plug away at it for a few weeks at the start but it's been amazing how everyone else has basically taken over :) (Like here too, I guess.)
[removed]
On our rubyforgood.org website we have a sponsor page. Or feel free to get in touch with me at myusername @ gmail.
The main benefit is to get recent Ruby versions. Debian stable ships with 2.1 and CentOS with 2.0. It's also useful if you need support for features not compiled by default.
That is a false dichotomy, from source and base repo are not your only options. Compiling Ruby on your servers has a rather nasty side effect of causing a massive amount of load for many minutes every time you upgrade your Ruby version. 
As noted in my other comment, compiling on the server has some major drawbacks. There are two simple solutions: 1) Use brightbox PPA 2) Compile once packaged as a deb and distribute to your servers.
The problem with Brightbox is they only support Ubuntu. Perhaps I should turn this repo into a list of `.deb` and `.rpm` packages instead of `.sh` scripts... I'm surprised nobody has done that already.
&gt; I'm surprised nobody has done that already. A number of people do. brightbox provides a PPA, on the RPM side there are a few options such as https://github.com/feedforce/ruby-rpm/releases
Nice! Thanks for sharing. This is better than nothing but I reckon we'd really need proper APT/RPM repositories to get updates automatically.
I don't fully understand the GIL, but it _is_ possible to run _multiple things at once_ using threads, which has obvious utility (background jobs, long-running methods, etc): Thread.new { loop { puts "thread"; sleep 1 } } loop { puts "no thread"; sleep 1 } This will print both strings on one second intervals. So it's not like threads don't work. As I understand it, Ruby Threads are built with _blocking calls_ in mind. So whether or not it uses all the cores in your computer, it's still useful. 
also keep in mind that compilers are a great way to get backdoored. build an artifact, push it to a repo, install via package manager. don't compile on production machines.
rbenv doesn't install anything. It relies on ruby-build for that. The distinction is important because you can use ruby-build without rbenv and avoid all the headaches rbenv can introduce in a server environment.
I've found using ruby-build all on its own is a good compromise. We switched to that from RVM for the [rubber project](https://github.com/rubber/rubber). You get all the various build scripts but don't have to deal with managing the manager in your server environment.
external asset pipeline is the biggest change.. that will definitely break everything 
We just build a deb and install that on servers
This. I can write stuff in Ruby/Rails with very little thinking about **how** it build it, way more **what** it want to build.
Curious as to your thoughts on Django vs Rails. I've tried both and felt mostly similar about them both. Any particular reasons that you liked or were more productive with Rails?
I think it's a question of experience. I learned Rails while I was still in school and using Windows, like... &gt; 7 years ago. I feel like I know my way around Rails - Django always feels like black magic to me. So much stuff happening somehow behind the scenes - and not in the good way like with Rails. A lot of small things just feel right, like the ActiveSupport stuff: user.created_at &gt; 7.days.ago This just says it all in a concise way. Slow to run, but concise and beautiful. 
If you want to target the financial institutions I would learn Java. Generally speak I would say RoR is more portable. 
Love it. Especially the part about performance. I'm missing one important part though. Sure, Rails is boring and throwing some standard components together gets you online in a few weekends. Shipping before your competitors do so, is *the* most important thing, right? Wrong. *The ability to keep shipping fast* is. You can only remain relevant when you can continue at the initial pace: being able to adapt to changes in the market in a weekend is *just* as important as being able to ship your first product in a weekend. Getting the first €100 in is important. But growing that and assuring that it keeps coming in is important too. Hence it is a bad idea to quickly and randomly throw some "lego" together and ship that. * Ensure the gems you choose it come with a clean architecture, none- or hardly any dependencies. * Avoid gems when Rails core does it too (you don't need device, Rails core has login/user management too) * Test. Don't skip unit-tests or integration-tests or both. Implement both. After some TDD experience, you'll find that even that first "one weekeind shipping" goes faster when you're working fully TDD. * Keep refactoring. Technical debt will come back at you. And it hardly ever comes back at you when you have time, and budget to spare: it will cause missed deadlines, failed market opportunities and competitors moving fast than you. I've worked in a team where the whole company was stalled, grinded to a halt, because of "Picking the wrong Lego-blocks". We were working our asses off just to keep ourselves floating: 3+ fulltime developers, lots of overtime, continuously requiring *grand refactorings* or even complete rewrites. All because the team started off way too fast, cut way too many corners and made a series of horrible choices. So yes. Choose boring technology. Ship fast. And keep a keen eye out for slow-downs of development. If anything, over time you should should not only grow in userbase, features and visitors, but also the per-developer pace of develoment should go up.
Rails is really good for taking off the shelf libraries of questionable quality and stapling them together quickly, i.e. rapid prototyping.
Thanks! You are totally right - accumulating a metric ton of technical debt is no fun. Been there, don't want to be there again. I would still make the point that for building a first prototype of ones idea one can go the dirty way and still come out OK. I am not 100% convinced that all the proper engineering has to take place for the first trial of a product idea. I will now continue hoping that [our product](https://dropshare.cloud) will be a success and I can justify spending time on rewriting it :D 
Finally, I've benchmarked Plezi. Very impressive! But there was something strange with multi-process usage, see https://github.com/anycable/anycable/blob/master/benchmarks/2017-02-12.md. 
There's tons of reasons why you want to use Devise for user authentication. 
It's a simple script that installs and configures ruby environments for a user. What issues could you have that RBENV caused? I use it on my servers. 
Magic is generally just a lack of understanding, when it comes to.open source software. 
Yeah, like that, but less focused on _just_ files.
True. Also tons of reasons not to. 
I agree with that assessment.
I think this the best advice in the thread. Also note that if you have little to no experience it is going to be difficult to secure remote work.
You have a point. But isn't it nice to have alternatives? And maybe pry could learn a trick or two from this...
Thanks for exposing this issue (as well as for performing the benchmarks)! I'm not sure how scaling broke down, but I am now replicating this issue on my system and patching up a fix (the fix should be released within the hour) 👍🏻 I'm assuming you set the Redis server using the `PL_REDIS_URL` and added the `redis` gem to the benchmarking application. When I release version 0.14.4 (which should be soon), it will work correctly. Again, Thanks!
Done! ✅ The fix was pushed and the new version was released. Again, thank you for exposing the issue. I should probably point out that since message broadcasting is asynchronous, the addition of the Redis layer might mean that some messages are delivered later than normal\*. This "slowdown" allows the application to remain responsive while the server is under heavier load. It probably isn't good for benchmarks, but I hope it isn't so extreme as to effect the benchmarking tool. 👍🏻 --- \* This is especially true when there's connection lock contention between Redis and any waiting broadcasts. It's because Plezi uses the `iodine` server, where Websocket events and broadcasts are only concurrent between different connections - the same connection is mostly prevented from performing more than a single action at a time, helping connections to maintain their data integrity and message processing order. 
I think `7.days.ago` is a bit over the top in terms of syntactic sugar, but relatively harmless in terms of potential to interact unexpectedly with other things. What I find much scarier are libraries that reach into and monkey-patch wrappers into existing methods of other libraries.
All great points. Also read [Choose Boring Technology](http://mcfunley.com/choose-boring-technology). Same idea, just not focused on Ruby. I think about it often.
But binary files... And you won't need 98% of git features.
I find **magic** very often means "we made this extra complicated because it's more fun to write it that way"
&gt; But binary files... What about binary files? You can store binary files if you like. You could even integrate with git annex. It's probably more efficient than traditional socket based database servers too! Since you could in theory use sendfile directly from the disk (although that's a long way off right now). &gt; Won't need 98% of git features? Relaxo uses: commits, trees, objects (oids), refs, and a ton of other stuff. The git command line can be used to manipulate the database, replicate it, merge it, branch it, etc. Definitely use more than 2% of git features.
Rails has `has_secure_password` built in, which does the heavy lifting of password hashing. You can see it in use in the [Rails Tutorial](https://railstutorial.org).
I explain this in a section of my Ruby API guide [C in Ruby Threads](https://silverhammermba.github.io/emberb/c/#c-in-ruby-threads). You can't do it in Ruby alone; you need access to the underlying VM API because unlocking the GIL is only safe if your code isn't going to touch any Ruby objects. The classic use case would be code that runs a slow system call.
Devise doesn't have support for JSON APIs ([discussion](https://github.com/plataformatec/devise/issues/4275)), so if you want to add authentication and account management to your JSON API, you cannot use Devise. That's a big limitation, because JSON APIs are becoming increasingly popular, and you still need all the same features that you need in a full-stack app. (Spoiler alert: [Rodauth](https://github.com/jeremyevans/rodauth) has JSON API support.)
I assume you mean the .ruby-version file? If you're doing it in your Gemfile, you're already too late. But in either case, that only helps you in a single directory root. If you want to use Ruby anywhere else on your server (e.g., as part of a cronjob -- I use fog for backups to S3) that's not really going to work. And I don't think that really works for things like Passenger, where the daemon is running before the app is deployed. Don't get me wrong. I love rbenv on my development machines. But I've been burned way too many times by ruby version managers on servers. And since the entire thing can be essentially be managed with the 4 lines of code I linked above while integrating more cleanly with the rest of the distribution that way, that's my vote. Put another way, I think rbenv was designed for a different use case than what my server environments call for. If it's working out for you, great -- I'm not trying to convince you it isn't.
ok, but what is the benefit of unlocking the GIL when making a slow system call? Doesn't it work even if you don't?
Yup, and I find rails's code to be pretty amazing, and it's a great example of how good ruby code can look. Unfortunately, ruby's code is write in C, so the individual lines don't look nice but the overall code is pretty good. Anyway, I might do it on discourse too if I get bored of rails's code :) https://github.com/discourse/discourse
To be fair, the PHP frameworks are improving a lot since WordPress took over the market ... There were tonnes of [new features](http://php.net/manual/en/migration70.new-features.php) and improvements to PHP v7, and there are [a](http://www.codeigniter.com/) [few](https://symfony.com/) [good](https://cakephp.org/) [frameworks](https://laravel.com/) that make working in the language much, much better than it was 10 years ago. However, with that said, it's fair to say that many companies are still running on old, badly written "legacy" PHP code. (Or, as you say, WordPress.) It can be very hit-and-miss, especially since the internet is [flooded](http://stackoverflow.com/questions/tagged/php) with newbie PHP developers copy+pasting code off StackOverflow.
* Too much dependencies. e.g. it adds it's own offbeat "formatting" gem `responders`. Which is easy to get wrong, and with which it is easy to open up security issues (make your app respond to formats you never intended it to). * Too much code. Even in places where simplicity and the ability to reason about code, is needed for security. There is a lot of cruft to work around a large array of Rails and ruby versions. e.g. a lot of code to either take Rails' `secure_token` or else fall back on some own. You really don't want complex logic in something like a `secure_token`. What happens when you set both? * If your app is API-only, you are not using anything from Devise, that Rails does not offer OOTB. * Quite often the amount of code to override all the defaults in Devise is bigger than the amount of code you would've needed had you used Rails' core features. * It is hard to test. * It breaks SRP very badly: it convolutes your `User` with a lot of stuff that would be much better off in a poro `ResetPassword`, `Session`, `Registration` and so. * Once you have Devise, it is hard to remove or replace, because of above-mentioned architectural shortcomings. That said. It is perfect for a rapid POC (that you guarantuee to throw away). It is very handy when you need multiple-simultanous-sessions (it uses Warden instead of Rails's simplistic sessions). And if you are sure your user-manangement will never gain much business-logic (in an HTML based application) and the business has little demands about the mails going out and the workflows around registration and login, then Devise is a good shot.
I use devise and json api
 rvm implode Then look up ruby-install and chruby by postmodern on GitHub. 
**fast_attributes** ([Repository](https://github.com/applift/fast_attributes)) ([Rubygems](https://rubygems.org/gems/fast_attributes)) **Stars** 255 - **Language** Ruby - **License** MIT - **Release** 0.9.0 *(5 months ago)* Fast attributes with data types *** ^(BETA | by /u/AtroxDev |) [^(Telegram Bot)](http://t.me/LibrariesBot) ^| [^(Something went wrong)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Something%20went%20wrong) ^| [^(Suggestions/Thoughts)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Suggestions/Thoughts)
**dry-initializer** ([Repository](https://github.com/dryrb/dry-initializer)) ([Rubygems](https://rubygems.org/gems/dry-initializer)) **Stars** 28 - **Language** Ruby - **License** MIT - **Release** 1.1.2 *(6 days ago)* DSL for declaring params and options of the initializer *** ^(BETA | by /u/AtroxDev |) [^(Telegram Bot)](http://t.me/LibrariesBot) ^| [^(Something went wrong)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Something%20went%20wrong) ^| [^(Suggestions/Thoughts)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Suggestions/Thoughts)
May also want to consider a `gem update --system` in your scripts.
But then you need to do all the password reset and emailing stuff. On my newer projects, I just use auth0, cause I hate dealing with auth.
This is what I've done with devise: https://github.com/NullVoxPopuli/aeonvera/tree/master/app/resources/api/users Not at all non-trivial. Auth0 ftw
Even outside of a gem, I think the conventions in the rubygems guide, [found here](http://guides.rubygems.org/patterns/) are good to stick to. The gem part is really just a packaging for distribution, you don't have to use it. `bundler gem GEM_NAME` will also [scaffold the gem](http://bundler.io/v1.14/man/bundle-gem.1.html) structure for you.
To me it usually means "I decided to optimize LoC *in one spot* as hard as I possibly can". Sometimes, I would hazard to say "rarely", it turns out to be a win.
Less dependency. Simplicity. I've rolled out a custom authentication with [oauth](https://github.com/intridea/oauth2) gem. It does the job of what I want from a JSON API.
Thanks for sharing this. I checked the dry-initializer and it seems to be even faster than fast_attributes https://github.com/dry-rb/dry-initializer/wiki/Comparison-to-Other-Gems Probably when I will see more problems with API then I will deeply investigate that and maybe move out completely from virtus.
It looks like you're trying to run `rbenv` and `rvm` at the same time. My understanding is that you Shouldn't Do That. One of them totally borked up your environment variables. I'd try to re-source your .bash_profile and .bashrc (or just open up a new terminal) and see if that helps. And then I, too, would suggest you switch to `chruby`, although I prefer to install rubies with `ruby-build`. 
Just use something like Sinatra instead of Rails. I would be relatively straight forward to set up a few routes that integrate with the script you've already written. Throw it up on Heroku and you'll be good to go … to the store.
In my opinion one of the most annoying things about maintaining a rails app is failure to document param and return types. But I'm kind of coming to the conclusion I just don't like scripting languages that much. 
I should clarify that coercions in dry-types are not an equivalent of what virtus is doing. This means that ie `Types::Coercible::Float`isn't the same as using `Float` in virtus, as it simply uses `Kernel.Float`, whereas virtus tries to handle ANY input and coerce it into a float (which is one of the reasons why it's much slower). In dry-types you need to pick types depending on your use case. If you want to coerce values from a web form, then you want `Types::Form::Float`, if it's JSON, then ie `Types::JSON::Date` and so on. With dry-(types,struct) I didn't want to build "a better virtus", but a better abstraction, which works differently and is not bloated and confusing. Moving away from virtus to dry-types/struct doesn't mean using a slightly different API, it means changing the way you think about handling data in your system. ie personally I no longer use "models" with coercible attributes, instead I use validation schemas that *try* to coerce and validate values, and "models" are treated as pure data structures without complex behaviors like coercions.
WGR was my first Ruby book — I'd highly recommend it. It can be a little verbose at times (that said, Ruby is not my first programming language), but it tends to do a good job of explaining how the language works. Following WGR, I'd echo the suggestions of Eloquent Ruby, followed by POODR, if you really want to learn how to write idiomatic Ruby and practice good object oriented design. In addition, I'd also suggest trying your skills on www.exercism.io, as I've found that trying to write elegant solutions for simple problems can teach you an awful lot about the language. I've learned a tonne from checking out people's solutions on there. Finally, Sandi Metz and Katrina Owen (authors of POODR and exercism.io respectively) have written what seems to be a great book on object oriented design called "99 bottles of OOP", I've personally not read it (as funds are a bit tight right now), but I've heard great things. Looking forward to reading it once I have some spare cash.
Interesting article. Does anyone have examples of code that would actually be in one of those files? Eg. `Payments/process.rb`... would it basically be what `Payment#process()` would be defined as in a normal/fat-model architecture? It sounds kind of like that, but with a bit more of a functional approach to it instead of OOP. Please correct me if I misunderstood. I've been using service workers for a lot of things and don't really see the difference.
Because it's lightweight and will allow you to create a web server in a single file, as opposed to having to set up routes, controllers, etc. in Rails. Rails is just a bloated choice for something so simple. I love Rails, but pick the right tool for the job. :)
you need to override a lot of actions (calling super, of course), but it works!
This is what I try to stick with, and 9/10 of my apps are not rails... most use active_record or some other ORM, but not the rest... this dir structure has served me well.
Probably I should mention that in the article to avoid confusion. Thanks for the clarification and great work on those projects.
I see. The design where you have `gem_name.rb `inside `lib` folder that require all the files in `lib/gem_name` feels a bit off for me. But your probably right and I can live with that :)
these two go well together: https://github.com/NullVoxPopuli/drawers and https://github.com/NullVoxPopuli/skinny_controllers
Very interesting, especially skinny_controllers. A bit too magick-y for my taste, TBH, but a neat idea.
This is the answer.
Drawers is less magic. Also, for others, magic is 'programatically enforced conventions'. I don't want people to be afraid to look at the code behind the 'magic'. Just as in the real world, 'magic is something we don't yet know the science behind' - same with programming. Magic is a programmatically enforced convention or abstraction not yet fully understood. But anywho (enough about my opinions), the point of skinny controllers is really just organizing business / controller logic. You can achieve the same goal with poros.
Well explained, thanks!
1.0 beta! This is really exciting for Hanami. Congrats to them for reaching this milestone.
Interesting that it went with the data-mapper pattern instead of active-record.
If it's an app itself, not a dependency, there's really no reason to do that, although it won't hurt. If you don't do that, then every source file just needs to `require` exactly the other source files it needs. This is absolutely fine to do, and probably preferred. Just don't do the `app_name.rb` file that requires all the other files, if it feels off, and you want to explicitly require the exact source file dependencies of each source file. This is fine, and even preferable. The single file that requires all the other files is a short cut, less thinking, less control over exactly what you require. It's also fine. Even for gems, although for gems you need to think more carefully about how it effects your API and what users of the gem are going to need to do -- but there's no rule that a gem has to `require` 100% of itself on load, gems can also let the consuming app `require` exactly what they need when they need it instead. 
Thanks Mike!
cool stuff, congrats!
https://github.com/rake-compiler/rake-compiler
Congrats, y'all!
I'm really looking forward to giving Hanami another try soon. The thing with the Unmutable entities was too complicated for me to handle, and some of the things Hanami advocates just go way over my head. I'm hoping for more docs!
Hi! I'm here to listen. Which topics do you want to see covered by new docs? Thanks.
The philosophy of Hanami seems to be all about keeping all the components as independent as possible, so I think being opinionated here is different from DHH being opinionated on Rails' use of ActiveRecord (where convenience is more important than purity)
Yes, I went have with removing the `gemspec` file, and instead of having a folder with the gem name inside lib, I just put all my ruby files inside the lib folder (without the `app_name.rb` and the folder with the app name). I actually prefer requiring everything my classes uses on top. As I'm not the only one working on that code, for new-comer - it's help understand what this class is all about ("Oh, Capybara is required? I guess some Web driver is at work here" etc..).
Thank you for the answer. Will definitely check it out :)
RoR uses a gem called i18n for this. See [here](http://guides.rubyonrails.org/i18n.html)
yep, nothing wrong with that. 
 [Ahead](https://blog.pyston.org/2017/01/31/pyston-0-6-1-released-and-future-plans/) of Python's JIT then :-)
That's awesome to hear. One caveat is if you want to use anything from stdlib, you need to set the "home" directory (search for "-Xhome" in [our SVM docs](https://github.com/graalvm/truffleruby/blob/master/doc/user/svm.md)). We're looking to simplify this is the future, but there were some eleventh hour issues with packaging.
Non-ascii hostnames are kind of tricky before it even gets to rails. They are supported only in some hacky and confusing ways by the legacy internet infrastructure (mainly DNS). https://en.wikipedia.org/wiki/Internationalized_domain_name I don't _think_ Rails should have any special problems with it. You could try googling for "Rails IDN" to see what experiences others have had with it. Rails might not convert the hostname from 'punycode' to UTF8 internally; for may Rails uses, you won't need it to or notice. If it doesn't and you want it to, it would be relatively easy to do in a `before_action`, perhaps using this gem https://github.com/deepfryed/idn-ruby
I'm not sure which docs you're referring to. Did you see our [setup docs](https://github.com/graalvm/truffleruby/blob/master/doc/user/svm.md) in the TruffleRuby repo? If so, please let me know which part wasn't clear -- I'd love to get that fixed. Unfortunately, getting started does require some elbow grease: 1. [Download GraalVM](http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html) from OTN. Note, this requires a free Oracle account, so you may have an extra step here. 2. Build the ruby binary. What we're shipping is the compiler, not the final product. You can do that with `./bin/aot-image --ruby` from the exploded tarball in step 1. 3. Run `./ruby` to run the built binary. Due to a packaging issue we're going to fix, you do need to manually point at a checkout of stdlib if you want to use stdlib. We ship one with GraalVM. Assuming you're still in the GraalVM exploded tarball, that would look like `./ruby -Xhome=$PWD/language/ruby` We realize this isn't ideal and we're looking to improve it, including better integration with Ruby managers. But we wanted to get the release out there for people to play with. NB: this release does have all the other limitations of TruffleRuby. Primarily we don't support things like OpenSSL or Nokogiri yet. Pure Ruby should run fine, however.
I'm sorry about this. Now that the code is done and I'm receiving more and more feedback like yours my attention is shifted towards the communication. Please keep ask again in case you need more informations, I'll be more than happy to help.
And yet the Devise README still says: &gt; If you are building your first Rails application, we recommend you do not use Devise. Devise requires a good understanding of the Rails Framework. In such cases, we advise you to start a simple authentication system from scratch. Sounds like this is not in fact what Devise maintainers (or most other people?) recommend?
Thank you, no fluff, just stuff!
Got it working, exciting! First problem: $ bundle Fetching gem metadata from https://rubygems.org/......... Fetching version metadata from https://rubygems.org/.. Fetching dependency metadata from https://rubygems.org/. rack-2.0.1 requires ruby version &gt;= 2.2.2, which is incompatible with the current version, ruby 2.0.0p648 Ruby 2.0 has been EOL for a year now.
At 54:50 (edit: it's 49:25), Kenneth says that `a |= 2` will assign to a if a is unassigned/`None`. I don't know what he was thinking of, but that doesn't work. It's just inplace or:`operator.ior(a, 2)`.
This is not a good idea. Database errors == ruby exceptions, you do not want to treat exceptions as a way to validate data. A constraint violation is an exception, and it should be fixed, rather than rescued and turned into a user-facing validation message. The linked article explains it in a good way.
Yeah, it would need to have db-specific code, and you're right, the fact that most db's will only report a single one means it can't be a good replacement for validation altogether with still a good UX. Thinking about it, I actually can't think of any common use cases that really need this _except_ for uniqueness -- and there's a gem for that, nice, thanks! 
A gem is a way of packaging up code to share with other people. It's essentially a zip file with a few extra specially structured files. Some gems hook into Ruby (or Rails), and do feel like extensions to the language, but most don't – they simply provide a library of behaviour. The way you use a gem would usually be to require it from within your code (although Rails does this automatically), and then call its methods. For example, if you wanted to parse XML, you would install the Nokogiri gem, then write `require 'nokogiri'`. You would then have a class called `Nokogiri` available to you. 
&gt; Methods aren't first class objects like they are in Python which is the point of that little dialog http://ruby-doc.org/core-2.2.0/Method.html They are. The point you make about *syntax* is accurate, since you do need to use `.method` to get a method reference, but Methods are still first-class objects. This is slightly pedantic, because your point about the two languages using them very differently is accurate. 
Ahh so to use the camping gem to create a web application I simple put- require 'camping' -at the beginning of my program for it to use the camping library (or any other gems library)? Wow that's simple, and strangely fascinating. 
Great, thanks.
Koichi Sasada said on RubyConfBy that Matz wants to finish it by 2020. But he also mentioned that there is no milestone set for that. https://youtu.be/CQNlP78j1SQ?t=40m24s
It's nothing revolutionary but since taking the site over I'm trying to make it more community-focused than it has been in the past. If any of you have ideas or advice on how to make it a better tool to help good Rubyists find good Ruby gigs, let me know.
There is another gap between db exceptions and app responsibility. Because AR validations are about interface, you could, and possibly should, deliberately keep some attributes not covered by validators. For example, this concerns attributes the application generates authomatically. In such a case you treet db exception as a marker of some bug in the app's logics. It is a developer's, not a user'r responcibility to deal with such an error. If AR have rescued that exceptions and converted them to validation errors, the user would receive a message that makes no practical sense to him. In turn the developer won't see the error as fast as he could.
Are you not understanding what I'm saying? Even if the user is responsible for providing an appropriate value, an AR constraint _is not sufficient_ to provide an error message, because of race conditions. You need the db constraint _in addition_, for the exact same cases, in case another process/user chose the same value at just the right/wrong time to create the race condition (in between when the AR validation checked, and when the DB commit actually happened). When that race condition happens, an exception will be raised -- but it makes a lot of sense to provide the same feedback to the user as the validation error. It's the _same circumstance_, just a question of whether the other user (or automated process) committed the conflicting value miliseconds before the AR validation check, or miliseconds after. This timing difference reasonably may not effect what you want the UX to be. I don't understand if you are ignoring what I'm saying, not understanding what I'm saying, or actually disagreeing with me. 
Tried running it with the --insecure and -k flags but it seems to be running across the same issue. No idea how to proceed?
Nevermind the time was wrong on the box
Oops, I messed up the timestamp. It's at 49:25. This link should play at the correct point: https://overcast.fm/+B1fWZaymc/49:25
I don't know the fine semantics of Python, but this is true in the case of Ruby's `||=` operator. `||` isn't a method call in Ruby, unlike most other operators, because it short circuits, which is the behaviour they're talking about here. If they're wrong then it's probably because they're confusing it with Ruby.
If the problem isn't DNS it's usually NTP. 
My machines get their NTP servers from DHCP and NTP is part of our golden image, so...
Ah thanks for clarification. This makes perfect sense. Maybe adding a small "?" icon with an on-hover tip explaining this in one sentence would be helpful :) Good to see this site going back to life!
Yeah, I get it. It's probably not all db exceptions that should be turned into validation errors. I think the uniqueness one prob should be though. If I want a uniqueness validation error if some other process commits a conflict 2ms before AR's validation check, I really want the same error when it does it 2ms after (but before my commit) instead too. Of the common things you use validations for, most of em probably not. Any other ones that are there to do something an AR validation can't do alone because of race conditions -- I think I'd still want it turned into a validation error. Most of those are going to be custom db triggers/constraints though, and they're rare. So in common use, just uniqueness I guess. 
OP should be clear that when they write `ä`, they are writing it as two unicode codepoints: codepoint 0061 `LATIN SMALL LETTER A` followed by codepoint 0308 `COMBINING DIAERESIS` You can also represent a `ä` in unicode as a single unicode codepoint 00E4 `LATIN SMALL LETTER A WITH DIAERESIS`. If you do this, I think most of those unexpected/beware tests now work as expected, even though it's still more than one byte in UTF-8 (but 2 now, instead of 3): irb(main):004:0&gt; "ä".codepoints =&gt; [228] irb(main):005:0&gt; "ä".bytes =&gt; [195, 164] irb(main):006:0&gt; "ä".chars =&gt; ["ä"] irb(main):007:0&gt; "ä"[0] =&gt; "ä" irb(main):008:0&gt; "ä" =~ /a./ =&gt; nil irb(main):009:0&gt; "ä".count("a") =&gt; 0 irb(main):010:0&gt; "ä".delete("a") =&gt; "ä" irb(main):011:0&gt; "ä".each_char.to_a =&gt; ["ä"] irb(main):012:0&gt; "ä".insert(1, "u") =&gt; "äu" irb(main):013:0&gt; "ä".length =&gt; 1 irb(main):014:0&gt; "ä".next =&gt; "å" irb(main):015:0&gt; "händ".reverse =&gt; "dnäh" irb(main):016:0&gt; "ä".size =&gt; 1 Unicode is confusing! (But that's because the domain is confusing, unicode is actually an _amazingly_ well-designed standard). I highly recommend anyone working with unicode spend some reading [UAX#15 Unicode Normalization Forms](http://unicode.org/reports/tr15/) until they understand it -- it's actually very clearly written, although the concepts can be confusing. (Other important point about unicode -- it's NOT just a list of codepoints and encodings, it's also some _algorithms_ to do pretty sweet things with unicode, such as those normalization form algorithms. Spend some time with the unicode Reports. Some of the algorithms are in stdlib, many other useful ones can be found in the very useful [twitter-cldr](https://github.com/twitter/twitter-cldr-rb) gem... some remain unimplemented in ruby.) So, I'm not sure if ruby should or reasonably could do the 'right' thing in the OP's cases using a decomposed form of `ä`, with two codepoints. i'd have to think about it more. But, really, as a developer, your best bet is always to put your unicode strings into NFC normalization before doing operations on them. And then the unicode operations in the OP will largely work as expected. irb(main):019:0&gt; decomposed_form = "ä" =&gt; "ä" irb(main):020:0&gt; decomposed_form.codepoints =&gt; [97, 776] irb(main):022:0&gt; nfc_form = decomposed_form.unicode_normalize(:nfc) =&gt; "ä" irb(main):023:0&gt; nfc_form.codepoints =&gt; [228] I haven't investigated or wrapped my head around the 'beware' examples from OP that aren't about `ä`, they may be more clear stdlib bugs. Incidentally, on MacOS, if you use the keyboard shortcuts many people know to write these accented chars on a US-English keyboard layout, you _do_ get the NFC composed form. 'option+u' followed by 'a' on a US-English MacOS keyboard gets you the kind of ä that's a single codepoint -- the kind that will perform correctly under OP's tests. But yeah, with input over the web or from any external source, who knows -- which is why you should always normalize into NFC before trying to do manipulations like that. (In fact, i wonder if Rails really oughta by default do this for you in some cases.. but it gets tricky)
Do you think you'll ever need password-based authentication? If yes, how do you think you'd approach this?
There are 3 jobs on the whole site?
It's been neglected for a while. :-)
Just curious, why can't you write the file to disc?
`Enumerator#lazy` allows for streaming through Enumerators. If you want to work with IO pipes you can do it as well. I'm not familiar with streaming support for S3 libraries Depending on what your interface is with S3 I would assume you could do something like the following. This of course assumes that your S3 library (and your code) are both thread safe. If not, I would probably do it all via processes. (NOTE: this still has the potential to blow up as it doesn't have back-pressure) class MyTransformer def start(in, out) @thread = Thread.new do run(in, out) end end def run(in, out) msg = in.deq out.enq process(msg) end end receive_queue = Queue.new send_queue = Queue.new MyTransformer.start(receive_queue, send_queue) Thread.new do YourS3Lib.streaming_download do |bytes| receive_queue.enq(bytes) end end Thread.new do loop do msg = send_queue.deq YourS3Lib.some_upload_function(msg) end end
Not sure if you've tackled this yet but it doesn't display any differently on mobile than on desktop and that makes it [unusable](http://i.imgur.com/aLPXV7X.png) on mobile.
Am I understanding correctly that you'd create an Oauth warden strategy?
 class Counter def initialize(n) @counter = n end def next @counter += 1 end end ???
You want some kind of external lock or leader election process. Sidekiq Enterprise comes with [periodic jobs](https://github.com/mperham/sidekiq/wiki/Ent-Periodic-Jobs) and [leadership election](https://github.com/mperham/sidekiq/wiki/Ent-Leader-Election) (and $1950/yr price point).
I watched a talk where he said by Tokyo Olympics (2020).
I mention that as an approach in the post. The point is not to find a solution for a counter, but to show how Fibers work and a use case they can have (e.g. yielding from an infinite loop)
Couldn't agree more
`Queue` and, specifically, `SizedQueue` (to provide back pressure in case data is coming in faster than it can be processed and uploaded) in Ruby's standard library may be of help here as well. From `SizedQueue` [documentation page](https://ruby-doc.org/core-2.3.3/SizedQueue.html): &gt; This class represents queues of specified size capacity. The push operation may be blocked if the capacity is full. Here is an example using a plain `Queue`: require 'thread' queue = Queue.new downloader = Thread.new do loop do puts queue.size sleep 1 queue.push(Object.new) end end uploader = Thread.new do loop do sleep 5 queue.pop end end uploader.join downloader.join The output is as follows (notice how the queue size keeps growing, because data is coming into the queue faster than it's coming out): 0 1 2 3 4 4 5 6 7 8 8 9 10 Changing `queue = Queue.new` to `queue = SizedQueue.new(3)` with all the rest of the code remaining the same, produces the following result (note that the size of the queue reaches the maximum of 3, then the consumer (downloader) thread blocks automatically until at least one item is popped from the queue): 0 1 2 3 3 3 3 3 3 Hope this helps :)
Didn't you get the memo? Any particular code example is either trivial enough that it can be torn to shreds out of context, or it's so elaborate that no one invests the time to understand it.
Uh, well I'm asking because one of the central concerns of concurrency is whether you're accessing stale data - so when you write concurrent code, you need to made sure the data is updated and propagated. As it stands right now, if you were to have some set of processes running concurrently and using this counter, they would be getting back old data. I get the point of your post, it's just incorrect.
Aha! I knew there were other Unicode normalization nerds around.
Ahh, looks like I missed that. I'll update the post. 
interesting. Do you think unicode normalization is just intrinsically slow cause of the algorithm, or ought the MRI stdlib to be faster? I think twitter_cldr also has normalization (from before it was in the stdlib), but it's a pure ruby implementation so I doubt it'll be faster. There are some other implementations (including C extensions) from before stdlib supported normalization (or at least all forms of normalization), but I suspect the C extension ones won't work in modern MRIs. Oh, look at that, googling, I find _my own post_ from 2013, apparently I benchmarked some of the options, haha. https://bibwild.wordpress.com/2013/11/19/benchmarking-ruby-unicode-normalization-alternatives/ That was with 2013 versions of those gems of course -- I believe twitter_cldr has improved their performance since then. But prob less attention since it's in stdlib now. Sadly, the `unf` gem that was by far the fastest in 2013 seems to have been abandoned. Don't know if `unf` still works on MRI 2.3 or 2.4. Would be interesting to see if there are any alternate implementations that outperform the stdlib. But I'm not sure I've ever done anything where the unicode normalization was a significant portion of cpu time for the whole operation, even when I was writing ETL type stuff.
Normalization is definitely complex, since it involves a bunch of mapping between semantically similar things. Whereas testing for normalization is almost surely simpler, since you can guess based on whether certain decomposed or composed pieces are present. I'm curious to read your post.
Neat, I'll have to take a peek!
Automated testing: Cucumber's ruby implementation is very popular in my market and has better community support than other implementations. 
It looks like something like https://github.com/JuliaLang/utf8proc might have all the C goodness we'd need (maybe not the fast-testing) while still being maintained and current to Unicode 9.0. I'd just have to write a wrapper around it like `unf`. Maybe something to procrastinate on more later on today :)
Heh, I like that. Thanks for the laugh.
I agree that meta-programming is used far too often when a non-meta-programming solution will suffice. On the first example, if you want to avoid meta-programming, I think you can go even simpler and just use an if statement. def pdf_of_kind(kind) if kind == :normal normal_pdf else zebra_pdf end end I think it is a lot easier to understand for only two code paths. 
It's certainly not what Ruby was *meant* to do, but that doesn't mean we *can't* ;)
I'm baffled why you picked a `Square` as an example of `Polygon[5]`..
So I like the article but your newsletter pop up on mobile clipped the close button off the top inside Reddit's iPhone app's browser. Almost made me not read. Thought you should know.
That is called a control parameter and generally thought of as a code smell
Holy cow that's a lot of work. Not sure I see the benefit here.
Some re-writes of the first function that don't make me think "what the literal fuck" and "I would so reject this PR" or "why is this so complicated for no benefit – if it's going to be complicated, get some benefit!": # use a case statement. everyone who has ever programmed will grok it immediately # falls down from readability when there are a lot of different things to switch on class Ticket def pdf_of_kind(kind) case kind when :normal then normal_pdf when :zebra then zebra_pdf else raise ArgumentError.new("don't know how to make that kind of PDF") end end end # define a custom error class because that is really handy when you're debugging and your # exception tracker will track it specially and it doesn't look like a syntax/logic bug # also use #public_send because it's probably what you want here class Ticket UndefinedPDFKind = Class.new(ArgumentError) def pdf_of_kind(kind) raise UndefinedPDFKind.new(kind) unless [:normal, :zebra].include?(kind) public_send("#{kind}_pdf") end end # define a whitelist of PDF kinds we want as a constant, flip some logic around from # the last example just because if+exclude is more readable for some than unless+include class Ticket DefinedPDFKinds = [:normal, :zebra] def pdf_of_kind(kind) raise ArgumentError.new("that pdf kind is not allowed") if DefinedPDFKinds.exclude?(kind) public_send("#{kind}_pdf") end end # back to our case statement, but this time offloading PDF generation to service classes # still raising a useful error that we can debug rather than a fucking fetch miss on a hash # lucifer save us all class Ticket def pdf_of_kind(kind) generator = case kind when :normal then NormalPDFGenerator when :zebra then ZebraPDFGenerator else raise ArgumentError.new("that pdf kind is not allowed") end generator.new(self).generate end end ---- For the second one, I think the code arrived at is actually sort of reasonable. Given mappers tend to spiral out of control in their numbers and types, a generic setter in a base class is reasonable. That said, i think the explanation was weak, and if one is going for simplification, the author didn't do it justice. # more straightforward and anyone who has ever programmed will # understand it. Will get awkward when you are inevitably writing # your 100th custom mapper except *this one* has a difference in # the 15th, 17th, and 40th data points. class Salesforce::AccountMapper &lt; Salesforce::Mapper def map(data) { 'User_ID__c' =&gt; data['user_id'], 'Phone' =&gt; data['phone'], 'Email__c' =&gt; data['email'], 'IBAN__c', =&gt; data['iban'], 'CurrencyIsoCode' =&gt; data['currency_iso_code'], 'Company_VAT_Number__c' =&gt; data['company_vat_number'], ) end end Another idea that I haven't thought through for this specific case but have used in the past… # Another approach is probably to just derive the base mapper from # the Hash class. There are some cases where I think this would work well. # Specifically if the mappers remain thin and relatively light of additional logic # around data coercion/correctness. The AccountMapper class remains the same in this. class Salesforce::Mapper &lt; Hash private def fill_keys_with_values(keys, data) keys.each do |salesforce_key, our_key| self[salesforce_key] = data[our_key] end self end end Alternately with a base class of Hash you could pull of this simpler thing: class Salesforce::Mapper &lt; Hash end class Salesforce::AccountMapper &lt; Salesforce::Mapper def map(data) self["User_ID__C"] = data["user_id"] self["Phone"] = data['phone'] self["Email__c"] = data['email'] self["IBAN__c"] = data['iban'] self["CurrencyIsoCode"] = data['currency_iso_code'] self["Company_VAT_Number__c"] = data['company_vat_number'] self end end
That's, like, back to zero with gems, no?
Subclassing from a parent as you are is generally poor form. For example, Texty::String::String is now a thing. If you _need_ to share behaviour with that kind of hierarchy, consider using a separate module to include in both. If you want a code example, reply, and I'll get back to you when I'm not on my phone. Also, if you can expand your example to actually make use of something from the parent class as a concrete example that would help.
Yes, but I can't realistically compile 16 different packages like they say and besides I needed a java sql libraries.
Oh man... I've been battling using npm packages with sprockets for multiple dayss now with browserify rails. Not certain a better solution in the long run. Everything is moving towards webpack.
Works fine local. Breaks on deploy. Requires mixed with imports. Globals and locals modules. Total nightmare, even on rails 5.0.1
KEYS = { ... }.freeze depending on your Ruby version I'd say
If you want to show an example of how fibers can be used, okay, your code works. However, for real world code you would probably never do something so easy in such a complicated way. Zatherz's solution is much better in every regard, including memory consumption since a fiber uses about 1K of RAM. If you really want to use fibers, the easiest way I can think of to implement a counter like this would be: counter = (1..Float::INFINITY).each counter.next # =&gt; 1 counter.next # =&gt; 2
One thing that webpack suffers from is configuration over convention, rather than the Rails way of convention over configuration. Having said that, once you have a convention established, such as the one I have outlined in my article, it's really easy to roll out to new projects.
That wastefulness of the "good" solutions put me off as well. These Hashes should not be created inside the method because the are static by their nature. We could go one step further and completely remove the PDF conversion from the Ticket class. Then we could have a Hash as constant in the class or outside which contains lambdas or more complex instances (i.e. depending on the complexity of the PDF conversion process) that do the full conversion.
But the `kind` depends on external input (for example button pressed) so on some layer you need to decide whether you would use `NormalScenario` or `ZebraScenario` and now you need same mapping (`normal: NormalScenario`) but on different layer, don't you?
This looks more like the bare minimum to get started with webpack. What part do you think is overengineered? You probably don't need ES6/babel, but other than that it looks totally fine.
The original map function returns a hash unless I am miss me something. I trie to qualify that example but perhaps didn't do the best job. In this situation I am just dealing with returning a specific hash from a function and without seeing any other functions why not just let the object be the store of the data, too? There is a nice functional purity to the original and I think I went too far either the Hash thing, despite using it successfully in projects before 😸 Thanks for calling me out on it!
On my screen (a few minutes ago, so I assume the new one) which admittedly is low res by todays standards, it covers up half the blog post and has no close button. I think it's clipped off the top. I came here to make a suggestion to add 'newsletter popups that prevent visitors reading my content' to code that you no longer write, but it looks like someone already did ;) EDIT: On the bright side if anyone does want to read the post, it looks like if you refresh it doesn't come back
&gt; The original map function returns a hash unless I am miss me something. It should, but sadly it doesn't: irb(main):001:0&gt; {}.map { |x| x } =&gt; []
`Array#exclude` is activesupport, so, yeah, not gonna do that.
in addition to making something available to`require`, many gems (rake, rack, rails, etc) come with system executables. That's why you can call `rails` from your shell. Typical computer users download doubleclick executables. Programmers often use tools like `apt-get` (linux) or `brew` (mac). `gem install` offers a software distribution platform in the same way. The majority of gems are used to aid in writing code (load them with `require`). Some offer non-programming related functionality too, like CLI email clients and news readers. I didn't study programming in college, but from what I've heard there's a lot of focus on underlying ('low level') concepts - teaching you to build things from scratch. This is surely a good still regardless of what you're doing, but in practice programmers aren't always so disciplined. A lot of times people prefer to avoid doing things from scratch if possible, and to do so they take advantage of their programming langauge's package manager. With python there's a parallel tool called _pip_, and with javascript there's _npm_. The gem repo has a website, `rubygems.org`, which Gemfiles are usually specified to load from. 
Doesn't fit on a OnePlus 3T which has a massive screen... You should probably just not pop an interstitial if the viewport is too small to fit it
Thanks. 
That's a nice feature. Found more info on it here: https://infinum.co/the-capsized-eight/multiline-strings-ruby-2-3-0-the-squiggly-heredoc
Thank you for such a comprehensive article about this topic!
Warden strategy is simply auth_token_strategy. Warden doesn't have to know anything about Oauth.
Such examples are called *toy problems*, a very condensed and often silly version of real world issues. A good way to explain concepts and patterns. E.g to avoid spending ages getting the HTTP stack to properly symbolize some header-key, when all you care about is a null-pattern. The patterns you missed: * null pattern, * view/template with adapters or DI Problems you left in: * srp * magic numbers Also note that defining a class is no more than two extremely simple lines of Ruby, you should never be afraid of them. So, yes, in this toy problem, your oneliner is probably easier, but you missed the chance to learn about avoiding such problems in your next debt-ridden-rails app. Editie: debt, not depth
Your example is good but your conclusion is not. You touched the issue yourself. Five lines should be the default and you'd need to pass a higher bar to break the rules. Sort of a subtle difference. 
People love to use binary search when arguing for longer methods.
Your hashes are defined just before you use them, but there is no reason for them not to be defined earlier. Memoization is only useful if it is expensive to initialize the object, and there are public methods you could call on the class that don't make use of it. Neither are the case here, so I would initialize them in an initialize method. In fact, you could go further and assign them to constants as they don't even depend on the state of anything else in the class. In general, I think code is easier to reason about if you try to avoid modifying state as much as possible, so the earlier you can define it the better. Saying all that, I don't think you need the hashes at all. You've essentially just got a case statement, so you could implement it like this: def container(count) case count when 0 then "no more bottles" when 1 then "1 bottle" when 6 then "1 six-pack" else "#{count} bottles" end end I've not read the book, so I can't comment on their solution compared to yours, but one thing I would say is that yours isn't very object orientated. Its essentially a procedural program wrapped in a class. That's not necessarily a bad thing, but the book does have OOP in the title. A few of things I would suggest are: - You've used `99` in two places. I would make this an instance variable on the class. - You could store the verses in an array as an instance variable on the class instead of just returning strings everywhere. - You could use a `.to_s` method to return the string representation of the song. - You could extract the logic for verses out into a `Verse` class.
Style guides are just that -- guides. Not doctrine. Bend the rules, but only when it is justifiable. 
Amen. The idea that 5 lines should be a rule (even if it's allowed to be broken) is arbitrary and silly. I can see that it likely was a wise choice for the team she was working with in San Fransisco. The right number of lines of code for a particular method is, well, _the right number of lines of code for that method_. You know it when you see it.
You mean they use binary search for arguments? ;-)
Hey I didn't know of this. Thanks!
Did you finish the book, or give up on it at the beginning? Just curious if this review comes from going through the whole book, or just the first few pages. 
Here's what happened. I read the intro, did the exercise, read the 4 potential solutions, and read the critiques of them and why the authors picked the solution that was the best to use as a basis for the rest of the book. That's roughly the first half of the book. Then, the authors propose a change in requirements - handling 6 bottles as a six-pack - and state that their solution needs heavy refactoring before that change can be made. My initial 30-minute solution, although admittedly not perfect OO, only required the addition of a single line of code to handle the change in requirements. So, the book started to lose me at that point. I skimmed the refactoring chapters, but I really think the book would've held my interest more if I didn't do the coding exercise. The solution they chose needed obvious refactoring. However, if someone was paying me to build this, I couldn't justify spending more time on my initial class unless the requirements were changed. I'm not knocking the book. It's probably a great resource for refactoring. I would recommend skipping the code exercise unless you're a beginner. Then, it will be easier to to "buy in" to their solution as a starting point for the second half of the book. 
Post your code.
I added the code to the post, if its the error you said how would I go about fixing it? 
For me the key was really getting thrown into the deep end. I had done a couple tutorials but then had to complete an app in rails at work. Figure out something nifty that you want to make then figure out how to make it.
Answer questions here in the subreddit. Actually don't just answer them, proof them out and share code. I've learned a lot in other language subreddits by doing similar both by figuring something new out and by other people critiquing (or one-upping) my answers.
Great, but you messed up the formatting. Disentangling garbled code (e.g. `current_line + 1 print_a_line(`... looks nonsensical) is tedious. Before you copy the text to be pasted over here in your text editor, indent everything 4 spaces to the right. Follow the links in 'formatting help' to find out why. I suspect the problem is with the text file you're using as input and the `print_a_line` that is failing is the first of the three, but because of the broken formatting, I can't see which of them is actually on line 28. Posting the input and the full output, properly formatted, would have helped there. For longer scripts, you should consider two more things: Firstly, try to boil it down to a minimal example that does just enough to reproduce your problem. Often this will lead you to a solution before you even have to ask for help. Secondly, if it's still a little long, use a paste-bin that has ruby syntax-highlighting and line numbers. When you put in that little effort to get the basics right, more people will be willing to help.
I think the Dreyfus model kind of shows that "cargo culting" is a _necessary_ stage of the learning process. You can get a lot of education value from strictly adhering to rules. Sure, you have to move past it eventually, but there is no shame in using it as a learning tool. 
The best way to learn is by studying the code and habits of fellow engineers at work. If they are not available, study the code and habits of some of your favorite open source coders. Start reading gem source code and understanding how it works. Install Rubocop and follow all its rules.
I used data mapper for my first Sinatra project about 6 years ago. At this point I pretty much know nobody using it. Id highly recommend ActiveRecord instead, there's adapters to use it with sinatra and not Rails. And you're more likely to find help online more easily. Good luck! 
That's a change that would merit design and refactoring. I'll post a repo link when I start working on it. 
Thank you!! That was the problem, I assumed it was a error in the code that I couldnt find, but adding more lines fixed it.
You can checkout r/hanamirb for more info
I would highly recommend going with [Sequel](https://github.com/jeremyevans/sequel), if you want an ORM similar to ActiveRecord. It has superb documentation, a low-level query DSL for building SQL queries in Ruby without models (should you want it), advanced Postgres support, everything that you can think of, and it's very lightweight. I [wrote](https://twin.github.io/ode-to-sequel/) about Sequel's advantages over ActiveRecord.
With respect to his ["Further reading: Mathematical limits to software estimation"](http://scribblethink.org/Work/Softestim/softestim.html) I find the data point [The 8000th Busy Beaver number eludes ZF set theory:](http://www.scottaaronson.com/blog/?p=2725) utterly compelling.
These are some rally interesting things, some of them looks useful! Thanks for sharing :) 
Design Patterns in Ruby is another great book I recommend, especially if you don't have much experience with the classical Design Patterns by the infamous GoF yet. 
r/forhire. 
&gt; More terrifyingly, Regexp#=~ can be (ab)used to introduce actual local variables I hate you for teaching me about this, for now I fear I may not be able to resist using it.
&gt; How does one best install ruby on a unix server? I'm using ruby 2.3 from debain/testing and it seems to work just fine.
So Heroku docs actually _recommend_ using Rack::Timeout. Puma is recommended for Rails/ruby apps, and in the heroku puma docs: &gt; To avoid clogging your processing ability we recommend using Rack::Timeout to terminate long running requests and locate their source. https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#timeout Also mentioned as an option in passing, with less explicit recommendation, in another heroku doc: &gt; In addition to server level timeouts you can use other request timeout libraries. One example is using Ruby’s rack-timeout gem and setting the timeout value to lower than the router’s 30 second timeout, such as 15 seconds. https://devcenter.heroku.com/articles/request-timeout /u/schneems, do you think this is bad advice, and Rack::Timeout should be avoided? Those race condition errors such as leaking db connections seem kind of disastrous. Is there any other solution to the case it's being recommended for in the puma docs? Sounds like not. Should the heroku docs be changed to not recommend Rack::Timeout? Or at least link to your blog with the warning that it might be the lesser evil but it's gonna cause problems?
Rack::Timeout is still a valid and useful tool. The case where requests backup and make your whole app un-usable is catastrophic. Losing 1 database connection every hour or so __might__ be catastrophic, but it will happen slower. The weird thing is that not every app sees this problem. I don't know why. Maybe it's some apps have lots of extra capacity so they don't care if they lose a few threads. Maybe it's because they don't timeout that many requests. I honestly don't know. So having Rack::Timeout will not guarantee that your app is put in a bad state. The reason i wrote this is we're seeing more and more customers grow with us and increasingly this is becoming a more common problem. Currently the best "fix" we can suggest is to find out what requests are taking longer than others and speed them up. Sometimes that's adding caching, or pushing work to a background worker like sidekiq. If none of your requests take longer than a few hundred miliseconds, then the domino effect of backed up requests doesn't really happen. The best practice would be to do the timeouts at the connection level instead of the code level, but this is hard too. It also doesn't handle cases where code is the reason a request is slow instead of an API call etc. That type of performance work takes specialization and either lots of time or lots of money. Even then, how do you know you won't accidentally re-introduce slow requests, or that there isn't a hidden endpoint out there that will crash your app and you can't find it until the day before your big sale (or whatever). My opinion is that it's still best practice to use `Rack::Timeout` (or slowpoke) but be mindful that it's not without drawbacks. If you start hitting them you need to take steps to mitigate it. Ideally you would be able to have your timeouts and eat them too, but I don't think we can do that without a change in the MRI API. 
Also I had an idea to handle this in puma directly. Unicorn doesn't have this problem or need rack/timeout since killing a worker is safe (compared to killing a thread). We could do something where when a request goes over the limit, we cut off additional requests to the puma worker so the other threads drain, we then kill that worker and spawn a new one. Maybe make it configurable whether or not we spin up a new worker before or after we kill the first. I think it would work, but it seems janky to kill a whole worker just because one request took too much time. I can also see a scenario where your server is thrashing because every worker is constantly being killed and re-booted. 
Are your servers using the same setup? Same OS, same environment, etc? If so that'll make deployment easier. I uninstalled whatever default system ruby there was and then simply installed RVM to manage my ruby installations. Set the default ruby (using RVM) to whatever you've been using on your system thus far in ruby scripts and use other ruby versions for each respective application along with app-specific gemsets. There is no 'downtime' when managing ruby versions in RVM; you can install the next ruby version you want while your app runs as-is in its own ruby version and when all of your servers have the next version of ruby installed along with your global gems you can deploy your updated applications that now use the most recent version of ruby. You can declare which version of ruby and rvm gemset you want to use on a per-app basis with `.ruby-version` and `.ruby-gemset` files. There's a lot of missing information in your post with regards to your current development/deployment process so here's mine (all of this is done in a safe development environment, not on production server): 1) Use version control; I use Bitbucket/Github depending on the project. The first thing I'd do is create a branch off of my most stable development branch (or production, depending on your situation) and label it something obvious like "Rails_5". 2) Use RVM to install the latest stable version of Ruby (2.4.0 at this time). 3) Install any global gems such as passenger or bundler into the global gemset 4) Update `.ruby-version` in the app's root directory to use 2.4.0. 5) If you haven't made `.ruby-gemset`, make one. I do app-specific gemsets. So `.ruby-gemset` would contain`pos` for my point of sale application. 6) `cd` into (or out and then back into) your app's directory so that RVM knows to use the specified Ruby version and gemset. In my example the version/gemset combo would look like `ruby-2.4.0@pos`. 7) Run `bundle install` to install all the necessary app gems under ruby 2.4.0 in the `pos` gemset. 8) Upgrade the rest of your application to accommodate the change to Rails 5 and Ruby 2.4. Once complete, push those changes to version control's master branch. 9) There are automated methods for deploying such as Capistrano, but I found that sometimes new gemsets just don't install correctly the 1st time on a major update like this (new ruby version especially) so what I will do is SSH into the production boxes and manually update that box's RVM ruby to the version I want and install my global gems just like how I did in development. This way I'll know that my next deployment to production will go smoothly and the biggest difference between a regular deployment and this update will be the time it will take to install all of the gems instead of just some. You'll notice that using this method there really isn't any downtime to speak of considering Capistrano takes care of that side of things. If the deployment goes well, Capistrano will tell the production boxes to start using the most recent deployment. If it fails, no harm no foul, nothing changes. You'll just have to make sure that if your app makes changes such as migrations that they can be rolled back upon failure because you don't want to be stuck in some mid-way point figuring out what to do next.
I'm getting caught up in thinking about Thread.handle_interrupt which was the relevant thing I was trying to remember, I think. Have you looked at/played with that at all? I'm not sure if there's a way for puma to use that effectively. Alternately, it's possible that for the most common problem cases here, it's _Rails_ that needs to be using handle_interrupt properly. The new Executor architecture in Rails5 centralizes some resource reclamation stuff such that there might be a good place to make use of `Thread.handle_interrupt`, not sure if it already does, if not possibly should. 
This is a good comment. I think that `Thread.handle_interrupt` gives us something we could use today, the downside is that ALL code needs to be aware of it being run inside of a thread (I think). I.e. if you have a third party gem that is taking a connection out of a pool manually and manipulating it, I think it would need to either be aware of how to use this API, or it would have to use an approved "safe" API provided by Active Record. This doesn't work for interrupting arbitrary code i.e. the case of using `Timeout`. Maybe that's fine. I did some digging and in Java you cannot put a timeout around arbitrary code. You can send interrupts but if you have an infinite loop, Java can't get out of it. The Julia Evans post I linked to goes into this a bit in different languages. So I should perhaps kick this can down the road a bit. 
I mention this on Twitter, but... There's some good research on killing threads. Short answer is that if there are resources that need cleanup, you provably can't do it particularly well :-( Same kind of problem as undecideability (halting problem.) Basically you can't be sure that a given thread has or hasn't cleaned up if you can "hostilely" kill it, but if you wait for it to voluntarily self-clean, it's literally the halting problem to decide if it'll ever get to the cleanup code executing. There are some cases where timeouts are workable in Ruby, but the builtin Timeout lib is (for the reason above) completely unfixable. Here's a GitHub repo of folks cataloging how to do it right in various gems: https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts 
The price of giving away content for free. If no one reads it I don't write it. Click the "x" at the top and it goes away forever. Also to be clear that's not an ad, that's a link to subscribe to my mailing list, which sends about 2 emails a month when I post new articles on Ruby. 
What screen are you on? Do you have the dimensions? If there's a problem with the popup I would like to fix it. It works fine on my mobile, but that's all i've tested it on. Here's what it should look like https://www.dropbox.com/s/ms3xpom5jdu6xfq/Screenshot%202017-02-21%2014.12.50.png?dl=0 
Did you chose to not read the post you commented on, or did you somehow read it and write that anyway? Where to start... A) it's not an ad B) you're welcome for the free content C) If you click on it once, ever, it goes away. D) If you've got problems with the way it looks, maybe you could follow the instructions of the post YOU LITERALLY RESPONDED TO and give me your screen dimensions and I can try to make it better. 
I'm not the other guy lol, chill
Walk the list by pairs, swap if they're in the wrong order, repeat until no swaps happen. I get that these sorts of interview questions are bad but come on. 
I knew when i wrote the response. My response still stands.
Object oriented design isn't that important tbh. It can be a very helpful tool but getting intimate with basic data-structures and algorithms is far more important when you start out. Hackerrank is great for this and I think your are doing exactly what you need to do to 'Git Gud'! If you ever get stuck, read someone else's solution. It might help you pick up new paradigms and pattern to use. Object oriented programming starts to shine once you get a feel for the primitive data-structures and their interfaces, especially when your codebases start to grow. I did come up with a solution for the posted problem. let me try and explain my thought process: The anagram problem seems to map really well to a [Symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) of two sets. Lets try its: def test_set # Set up the sets for the test a = Set[*%w(b a r)] b = Set[*%w(b a z)] # Get the symetric difference result = a ^ b assert_equal Set["z","r"], a ^ b # Returns true in true, WIN! end Seems to work pretty well! Lets try another case: def test_set_with_duplicates a = Set[*%w(q u x)] b = Set[*%w(q u u x)] result = a ^ b # &lt;Set:{}&gt; assert_equal Set['u'], result # ....Whoops! end Thats not what we want. This doesn't work when we need to keep track of multiple occurrences of an item in a set. A set demands that an item either IS or ISN'T a member. We can't have an more then one item of the same identity in the set. ## Lets clarify: def test_set_equality_with_duplicates a = Set[*%w(q u x)] b = Set[*%w(q u u x)] assert_equal a, b end We can look for an a [multiset or bag](https://en.wikipedia.org/wiki/Multiset) implementation but since its not available in the std-lib that not an option on hackerank. We can do two things from this point on: - Roll out a class that represents a multiset. - Build a function to do the job. Since we only need one function I think we can do without a class. Arrays can serve as our underlying abstraction as long as we can ignore the order. def multiset_symetric_difference(a, b) (a|b).flat_map do |item| [item]*[ a.count(item) - b.count(item), b.count(item) - a.count(item)].max end end def test_multiset_symetric_difference result = symetric_difference(%w(b a z), %w(b a a z)) assert_equal ['a'], result end We'll put it in a module for now. Now all you have to to is count the outcome! #!/bin/ruby module Multiset def self.symetric_difference(a, b) (a|b).flat_map do |item| [item]*[ a.count(item) - b.count(item), b.count(item) - a.count(item)].max end end end a = gets.strip.split('') b = gets.strip.split('') puts Multiset.symetric_difference(a, b).count Try and poke around in the code a little bit. Try and figure out the part you don't understand. Feel free to ask questions if you have any. edit: [gist](https://gitlab.com/snippets/1620490)
&gt; puma already provides support to some timeouts I maintain puma, its timeouts aren't nearly good enough for an app level developer. They make sure that the workers are operational, not whether they're responding quickly. Even if you did move the timeouts into puma, it doesn't change the underlying problem that the only method it has of terminating your app's code is to essentially raise an exception on the thread. I have another comment on a way you could do it on the worker level, but it seem kludgy so i've never bothered to implement it. Moving timeouts to the connection level is the right direction, however, It has problems too. If you're hitting an expensive SQL query in a loop 1000 times in a row, you have to wait until that query times out 1000 times before the request would terminate. It will help the situation, but not totally solve it.
Some people are passionate, honest, knowledgeable and invaluable local mechanics. Others built the Pagani Huayra.
What?
If they are bad questions, why should I bother memorizing their solutions? I primarily work with web apps. Sorting, trees, and other popular algorithms/data structures are usually obfuscated by frameworks, if used at all. I am familiar with the algorithms and data structures, and their use cases. I know how to look them up if I need them. Memorizing them offers no tangible benefit in my daily work. 
&gt; Been coding for 15 years ... &gt; Would probably fail fizz buzz also No, you almost certainly wouldn't if you've really been coding for 15 years. The difference is that bubble sort is kind of a well-known simple algorithm that people might (or might not) learn in school. FizzBuzz is not something that *anyone* would learn in school. If a potential employer asks you to write FizzBuzz you can totally say, "I don't know what fizz buzz is." They'll explain what it is, then you implement it. Not knowing what it is is not disqualifying, but not being able to implement it is. FizzBuzz is simply a first line of defense against wasting time on applicants who can't really write code. It's not some fancy algorithm from a text book that you might learn in a computer science program. "Write a program that prints the numbers from 1 to 100. But for multiples of three print 'Fizz' instead of the number and for multiples of five print 'Buzz'. For numbers which are multiples of both three *and* five print 'FizzBuzz'." That's it. It's a made-up interview question that has absolutely zero relevance to real-world situations. There are people who apply for programming jobs who can't do it though, and they're the reason why the question exists.
Agreed with this. Fizzbuzz is a question that involves knowing basic control flow, conditionals, how comparison and integer math works in your language of choice. All pretty reasonable stuff. Bubble sort presupposes you have *some* knowledge of algos and even know the basic structure of how sorting a set works. I say this as someone who mainly posts on /r/cscareerquestions and studies 3-4hrs a day for the interviews that *do* ask you about sorting algos. It's not necessary, and it doesn't prove that you're good at building and shipping actual stuff, but it is what it is.
**Here's a sneak peek of [/r/cscareerquestions](https://np.reddit.com/r/cscareerquestions) using the [top posts](https://np.reddit.com/r/cscareerquestions/top/?sort=top&amp;t=year) of the year!** \#1: [No, Palantir. Your internships are not worth 5 months, 8 interviews, dozens of emails, a flight to New York, and a drive down to Palo Alto. Get over yourself before you drain the company of all its tech talent.](https://np.reddit.com/r/cscareerquestions/comments/5ncqti/no_palantir_your_internships_are_not_worth_5/) \#2: [For the love of god please stop Peeing in the talent pool!](https://np.reddit.com/r/cscareerquestions/comments/4xfkc7/for_the_love_of_god_please_stop_peeing_in_the/) \#3: [I don't want to be a rockstar coder. When 5PM hits, I want to go home, and not think of a single line of code. Is that too much to ask for?](https://np.reddit.com/r/cscareerquestions/comments/4xashc/i_dont_want_to_be_a_rockstar_coder_when_5pm_hits/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Ok. Let's get your parents and your high school girlfriend in the room, over complicate the explanation and tell you that your future as a software engineer depends on you being able to solve it. Ps: anyone who can quickly and easily write out a fizz buzz algorithm isn't necessarily the same person who can handle intricate string manipulation with regex at speed during database operations. So success is only meaningful if you're asking if they can write a modulus if statement. 
Should've made it the Pagani Zonda HH.
A better interview exercise. "A bubble sort algorithm walks a list by pairs, swaps items if they're in the wrong order, and repeat until no swaps happen. Implement it in ruby." You don't want to know if the candidate has stored the bubble sort algorithm in their inventory. You want to know if they can translate it into working code without difficulty.
What? /s Hahaha.
https://pics.onsizzle.com/but-without-human-sacrifice-concl-encl-who-will-feed-the-1184405.png
White boarding in an interview is great if you want to see how someone handles high stress situations while out of their element. I made it to round 3 and bombed the white board because I was too overwhelmed by the environment and the audience (CEO who sold a company to google). That being said, I was able to sneak in a joke "should I indent using tabs or spaces?"
If its any consolation I would have stopped the interview right there and offered you the position
White board interviews shouldn't be about how much of the problem the candidate happens to have memorized going into it. A whiteboard problem is about presenting a challenging problem to a candidate and watching how they go about reasoning about it and trying to solve it. Seeing that they think about a problem logically, break something too large to reason about all at once into smaller parts. Many interviewers don't realize this and instead use it as a opportunity to see how close the candidate gets to the "best" answer to the problem. The problem is that there are usually multiple solutions, and finding the best one is often times determined by luck. So it shouldn't be about seeing whether the candidate gets the an answer, but seeing the process the candidate goes about trying to find an answer. Many interviewees don't realize this either, and so think of whiteboard problems as the interviewer simply asking "do you happen to still have this random algorithm memorized from your algorithms class". I think if more interviewerees realized that isn't the intention of the question there would be less hate for whiteboard questions. If the interviewer starts giving evidence they are just looking for you to recite the textbook answer to the question, then they aren't a good interviewer.
Oh damn, I look back on it now and think "geez, I was really rambling on there" and thought about deleting it. I'm glad you enjoyed though!
I don't know why but my mind associates white-boarding with water-boarding. I don't know which is worse.
&gt;todowill1.rb:25: syntax error, unexpected tGVAR, expecting keyword_do or '{' or '(' sentence.sub! -i $tasks ('d' '$TODOWILL1') ^ &gt;&gt;todowill1.rb:25: syntax error, unexpected ')', expecting keyword_end &gt;&gt;&gt;todowill1.rb:34: syntax error, unexpected tSTRING_BEG, expecting keyword_do or '{' or '(' cat -n '$TODOWILL1' ^ &gt;&gt;&gt;&gt;todowill1.rb:46: syntax error, unexpected end-of-input, expecting keyword_end 
i hate interviewing as much as the next cat (and I'm not good at them!). But just to inject a little realism here, these are typically positions the generate _a lot_ of demand. Yes, it's insular to some degree, like a law grad (who we make more than?) has to do the LSAT. But it's not just the prerogative of the interviewer, since they were hired on the same merit. It's a structural relic of when web developers were less common and would have more likely had a CS degree. Regardless, that's where the money's at. From personal experience, the most likely company to forego the algorithm puzzles are the early-stage startups, and there is perhaps a tie-in between their idealism and their instability. In other words, it's kind of a big problem that will be slow to change.
waterboarding is worse
fizz buzz isn't an algorithm
Does that tell you if they can code though? If they can problem solve?
Everyone complains about this but no one ever seems to give a satisfying answer as to what the interview should be. 
How is it possible that most devs hate the interviewing practices used to hire devs? Do the then hired devs suddenly start loving these same practices and don't mind using them on others? Doesn't make sense to me and would like to hear from people who got hired in such companies. Do you not try to address the issue?
Specifically with line 26, &gt;todowill1.rb:26: syntax error, unexpected tGVAR, expecting keyword_do or '{' or '(' sentence.sub! -i $tasks ('d' '$TODOWILL1') ^ &gt;&gt;todowill1.rb:26: syntax error, unexpected ')', expecting keyword_end 
&gt;todowill1.rb:26: syntax error, unexpected tGVAR, expecting keyword_do or '{' or '(' sentence.sub! -i $tasks ('d' '$TODOWILL1') ^ &gt;&gt;todowill1.rb:26: syntax error, unexpected ')', expecting keyword_end 
Modulo is one of those things *most people* are taught, but not the name of. 4th grade math. Its called "division with remainders." If they taught what it was actually called, I suspect there would be a lot less confusion
Interesting, so if you're using one of many common gems then your `at_exit` may not work. Can't say I've ever noticed this, but it seems the proof is there
Here's a high-level explanation of associations: The most fundamental concept is a _foreign key_. This points to another table's id. From this you can craft any of the relationships. Remember that the table with the foreign key is "owned" by the other. Example: # User(:id) and Post(:id, :user_id) # User belongs_to :post # Post has_one :user has_many :users has_many_through is a useful concept as well which involves three tables, so if you add # Comment(:id, :post_id) # Post has_many :comments # User has_many :comments, through: :posts # Comment belongs_to :post has_one :user, through: :post You can learn the basic concepts of SQL by going through the Datamapper docs. There is sometimes a 1-1 mapping of SQL to Datamapper methods. After getting your practice app done you should move on to ActiveRecord, which is very similar to Datamapper but a little meatier. 
If they lie about that at interview I'd sack them on the first day when we find out anyway, it's fraudulent misrepresentation. I've always got something someone can do within a day. Another side point is that I've hired people knowing they cannot code and delivered projects that within year 1 took startups to their first million revenue, so "being able to code" the way the world teaches might not always be as useful for me. To comment on their quality of work the UK GDS just released a blog about UI checkboxes and radio buttons in 2016 that took one of these non-expert, non-professionals 1 hour in 2014. He'd been learning to code since June or July 2013, had delivered 4 major projects without knowing how to code (in fact never having had a job before)
If every interview you've been a part of as a candidate has been shitty, how do you know how a good interview looks like when you get to hold interviews yourself? Some are proactive and may research it, but in my experience that's really rare. 
This is actually a very significant release, with regards to adding ruby `v2.4` support across projects, as it has a cascading effect throughout dependencies! For example: * Rails 5.0+ *requires ruby v2.2.2+* - so open source libraries are currently unlikely to *depend* on anything from the 5.0 branch yet. * Rails 4.2.7 depended on `json v1.8.x`, which [does not compile](https://github.com/flori/json/issues/303#issuecomment-269209406) on ruby v2.4+. * This means that any project depending on `ActiveSupport`, until now, could not easily support ruby `v1.9.3 - v2.2.1` *and* `v2.4.0+`. tl;dr: This is very good news for removing `Fixnum`/`Bignum`deprecation warnings in ruby 2.4 projects :) Edit: Actually, it looks like (after some resistance) the ruby 2.4 fix [*was* backported](https://github.com/flori/json/commit/953f474b7e19e748990cef3b26525846b7d4d6c2#diff-b24ca9830076d9fdf8877cc16664960d) to the JSON 1.8.x branch ... But I'm sure there will be plenty of other such dependency problems like this!
Moonlighting is an issue. Also, work authorization can be a problem too - especially if you're moving somewhere to take the new job.
This whole thing really needs to be refactored.
I agree with DHH on this one, last week I went to an interview expecting them to make me solve some crappy sort or some other algorithm but they instead explained me a situation that they had at the office some weeks ago and made me build a _prototype_ of a slackbot to solve it and they were working on other stuff near me so we could joke around and talk about it. It was pretty neat
The problem is having the algo memorized gives you a huge advantage whether the interviewer is looking for process or answer. If you must give a test better to give someone a computer with internet access and ask them to write some code for a simple but non trivial open ended problem (simulate an elevator or generate a support rota). Make it clear that you do not expect them to finish you just want them to start and then discuss it. Leave them for 30-45 minutes then chat about what they've done and would plan to do. Better still assume that if they've shown you some work on github explained anything you've asked them to and have been gainfully employed as a developer for 10+ years they might actually know how to code.
If you must give a test better to give someone a computer with internet access and ask them to write some code for a simple but non trivial open ended problem (simulate an elevator or generate a support rota). Make it clear that you do not expect them to finish you just want them to start and then discuss it. Leave them for 30-45 minutes then chat about what they've done and would plan to do. Better still assume that if they've shown you some work on github explained anything you've asked them to and have been gainfully employed as a developer for 10+ years they might actually know how to code. 
It's hazing. You went through it and hated it, so it's only "fair" if everyone below you has to go through it as well when it's their turn. 
So you ask the interviewer "Remind me which one is bubble sort again?", and they give you a two-sentence summary.
The lack of an alternative. I've taken to asking people if they'd prefer a loaner laptop. Most people prefer the white board
In the whiteboard interviews I've been in, they wouldn't answer this question.
The question isn't asked because they really need someone to implement bubble sort. The question is asked because they want to see whether or not you are capable of solving an extremely basic algorithmic question. Asking standard questions is a good way to rank applicants. If your answer to "please implement a sorting algorithm" is "I would never need to", then I'm afraid you fail to understand the point of interviewing. You *would* need to write code that solves problems. Sorting algorithms is a standard example of such code. Why does it matter if they ask you to implement a sort or a vowel finding functions?
I'm not a fan of this whole hating on white boarding kick. The most important skill in a programmer is the ability to learn to work with new logical systems. White boarding is a pretty good test of that ability. With a little bit of practice time, a smart motivated programmer can master the skill easily. If you know that's what you'll be doing in your interviews and you still can't manage to be good enough at it to whiteboard out bubble sort then I can draw one of two conclusions. Either you're really just not very good at or don't enjoy learning or you really don't care much about getting the job, usually because you're ambivalent about either the specific job, or about software engineering. Either conclusion is a huge red flag. If DHH can't whiteboard bubble sort, it's because he doesn't care to - which is fine, he doesn't need a job. But the fact that he couldn't do it, doesn't mean it's a bad filter.
I think the problem is the interviewer tends to have the mindset of "what would I find difficult to do or know" as a a bar for these types of interviews. The net product many times is a request that strokes the interviewers ego instead of actually testing the abilities of the candidate. In my opinion open ended questions that explore the candidate's thought process and ability to suss out relevant information are much more valuable than asking them to code some algorithm by rote. For actually testing the candidates coding abilities send them home with a 24 hour turn around paid assignment and then have them defend their work and reasoning after the fact.
The best interviewers don't look for the "best" answer, but instead pay close attention to how the candidate thinks through complex problems, asks questions, considers indirect or non intuitive complexities. I for one would much rather have 1 candidate that shows an advanced ability to see the big picture, break down problems and come up with creative solutions than 10 that are able to remember a "best answer" by rote. If I wanted a developer that was specialized in coding to a highly detailed spec with little thought I would be communicating with an offshore. 
Yes. It's less the *concept* of modulo, and more the modulo remainder. When I was teaching myself programming in high school I ended up creating a remainder method which would divide and then floor, then take that value and multiply it by the divisor before subtracting that from the original number... and there's the remainder. You know, how a human might do it. Example: 14 % 3? Well 14/3 = 4.xxx or just 4. And 4*3 is 12. So return 14-12 or 2. If you know that 14 % 3 (or in some cases 14 mod 3) exists in your language it's a hell of a lot easier. I wouldn't be annoyed if someone didn't know that, because as an application programmer I almost never use it.
what are you talking about? 
I'd guess his point was more about just observing the persons behavior in the situation more so than evaluating them on their solution. On one extreme the person might just break down and can't work the problem at all, and on the other they'd remain calm and collected and able to communicate their thoughts well(regardless of whether they actually get the "right" solution). Dunno if that's how things could play out(I've only ever been on the one side of whiteboard interviews), but that was what came to mind from his post.
If someone asked me to come up with a sorting algo right now I could do it but chances are I'm not going to come up with a perfect implementation of quicksort. If I've memorised quicksort though I have enough experience and CS knowledge that I could explain the principles and reasoning. So if I memorize algos I'm at an advantage. The better process is having an interview process where memorization of things which are (largely) useless in the day to day wouldn't materially affect the outcome of the interview. 
Is that a common played out joke or should I remember it for my eventual interviews?
There's 2 things that try to trick you with the question: 1\. The modulus operator like you said. You simply don't use it in real world web app coding, so a lot of people have forgotten it exists. 2\. The wording is meant to trick your brain. The first part is straightforward, the last part where you don't print a number but you do print fizz and buzz does something nasty in the brain. It's like those old school train problems in math "Train A leaves Chicago at 5:34pm. Train B leaves Miami at 7:36pm. Assuming a 15 minute break every two hours...". It's not mathematically horrible, but it hits something in the brain that just HATES it. Here's the problem: &gt; "Write a program that prints the numbers from 1 to 100. But for multiples of three print 'Fizz' instead of the number and for multiples of five print 'Buzz'. For numbers which are multiples of both three and five print 'FizzBuzz'." The difficulty in the problem is getting a grasp on it, and knowing about the modulus operator, not in actually writing the solution. If you took out the last part of "For numbers which are multiples of both three and five print 'FizzBuzz'" it would be an easy solution, but that last part is nasty on the brain.
&gt; What screen are you on? Do you have the dimensions? sure, 720x720 EDIT: not sure what the phone actually reportsto the browser, if I recall correctly some (most) phone reports scaled dimensions in order to adjust for DPI? I think I read somthing like that somewhere. But physical resolution is 720x720 px. &gt; https://www.dropbox.com/s/ms3xpom5jdu6xfq/Screenshot%202017-02-21%2014.12.50.png?dl=0 Welp, on my phone it looks like just the lower half. I have the gray background the popup has over full screen, I see the "Join my ..." header but the 'x' is not there. Probably issue with 1:1 screens.
I mean did you say "Do you want to use the whiteboard? (big grin) Or a loaner laptop? (tone that says that's bad)". 50% of the interview is whether the interviewer feels good afterwards, most people will go with whatever the interviewer implies they should go with. I personally might have chosen the whiteboard the first few times to, now I'd choose the laptop after the experience of trying to do a problem on a whiteboard.
It's called Amazon Product Advertising API. Here's a GEM: https://github.com/hakanensari/vacuum Like any API you'll need a key from the source, in this case Amazon, to authenticate. Also, like any API it's just CURL calls, and JSON responses. Nothing tricky. http://docs.aws.amazon.com/AWSECommerceService/latest/DG/CHAP_ApiReference.html You'll probably want to save/cache results from the API from a background process. Calling in real time is kinda slow and resource intensive. FYI, before you get a affiliate code, (not the API access) Amazon needs to approve your website. You'll need the certain amount of quality content to get an affiliate code. So don't invest too much time in setting up the API only to be denied an affiliate code. 
We email them to ask for their preference when setting up the interview
so I checked whatismyscreenresolution.com and it reports 347x347
&gt; How does white board coding "make sense" more than having someone program on a computer in an IDE? Well, in all honesty I prefer having interview candidates code on a computer than on a whiteboard. I was using 'white boarding" as a stand in for the algorithm heavy interview approach. That said, I think it really shouldn't make a big difference. The work should be happening in the candidate's head, not on a screen or white board. A good candidate should spend most of the time talking through a good solution before touching a marker or keyboard. Once he's done that, it really shouldn't matter what particular form the final output takes - the hard part is already done. The candidate who starts writing on the white board or typing on the computer before thinking through a solution is rarely a hire.
Thats what I meant. If they told 4th graders that they were doing "modulo division," it wouldn't be such a scary concept later in life. Because its name makes it sound way more intimidating to a new programmer than it actually is
I'm sorry, it wasn't very helpful but you have provided a screenshot of code the like I have never seen before. I honestly don't know how your code has got to that line. If you want to PM me your code, from the beginning, then I could walk you through a bit of it. But I am very busy with my own stuff. Do you not have a template from which to work? I mean, there must be lots of TODO examples out there.
&gt; The best interviewers don't look for the "best" answer, but instead pay close attention to how the candidate thinks through complex problems, asks questions, considers indirect or non intuitive complexities. But the reality is that none of the people running the interview have any experience in judging which ways of thinking are productive or aren't. Like a lot of people, my approach to more complicated problems is often to sit down and read them, then reread them, then let my brain process for a while, and my brain comes up with the answer. That doesn't lend itself to putting on a performance. It's "sales" vs "engineering". The sales people always come off looking better, despite that they just made 15 promises no one can actually keep. 
That's the issue right there, i'll clean this up https://www.dropbox.com/s/govmimbfrwldexs/Screenshot%202017-02-22%2012.10.36.png?dl=0 That's a great resource for these kinds off issues. I'll be sure to use that in the future.
I disagree, your point may be true for specific teams that are highly siloed, but most of my experience leading dev teams requires much more of a collaboration between developers than running off to a corner somewhere to take a task on by yourself. Complex software has too much overlapping surface area to have a team all solving problems in dramatically different modes. There is obviously a time and place for head down development, but working through a problem with a peer should not be a deal breaker for a decent developer. Your interviewer is also a developer and understands the 15 promises are "sales" -- whereas being able to talk through the problem space, ask questions, talk about solutions and non-intuitive complexities exposes differences between a developer that can be counted on to SE copypasta through code and one that is able to add high value thought.
That's precisely why they do it. In fact, they will often also put rugs on the stage floor so they can't hear your shoes when you walk out on stage. Although there are multiple stages to each audition, and usually for the final round they will take down the screen and they'll be able to see you.
This is very helpful. Thank you! Do you know what Amazon's definition for "quality" content might be? I have an idea for an app, but its not like I'll have blog posts or something like that. Without giving away my idea, there is a function for the app to do and the content I receive from Amazon would make it easy for me to have access to the names of many games. The fact that I could make money off Amazon is kind of a happy accident, I'm using this to teach myself how to use APIs and Ember. 
There are a lot of problems with this code, but thats ok :D First step to being able to write beautiful code is to write shit code and figure out why its shit. As far as the line in question, what are you trying to do? There are definitely syntactic problems, but it's hard to say what the cure is without knowing what you're trying to do here. What is -i? what $tasks is isn't clear, it seems to just be a range of integers. what is ('d' '$TODOWILL1') supposed to be? Where is sentence defined?
I'm not really going to continue that debate. Again, agree to disagree I guess. That said, just for giggles since you mentioned it, while most solutions to "detect X in Y" involve a loop and an if, and indeed that's what's going on under the hood anyway, my usual way of solving that problem is closer to (we'll use JS for example, but it applies to other languages): `Array.from("Aha, this is a pretty rad string".toLowerCase()).filter(x =&gt; ['a', 'e', 'i', 'o', 'u'].includes(x)).length // =&gt; 8` Interviewers looking to get a `for+if` clause out of me aren't going to be terribly happy, I guess.
&gt; You simply don't use it in real world web app coding, so a lot of people have forgotten it exists. Until you need to determine if a number is even, or to break a number of seconds into a timestamp or human-readable duration
&gt; Until you need to determine if a number is even I've not needed to do that ever. I might have run across older code that did, when people wanted to put alternating lines on a spreadsheet, but I have no needed it in 10 years. &gt; or to break a number of seconds into a timestamp or human-readable duration I would say a better solution is doing that with a library rather than hand coding a local solution yourself. My point isn't whether one could think up an unlikely but plausible example out there somewhere, my point is about whether it's common to use it. 
Not OP, but what do you mean by this? How is OOP the solution here?
&gt;&gt;Do you know what Amazon's definition for "quality" content might be? Well, just go ahead and submit your site and see if you get an affiliate code. If you're planning on making a catalog site where the content is what's pulled from Amazon, they will say no. They don't want competitor sites. 
hey! i asked for your explanation on hackerrank lol, didn't think to check the question again! Thank you very much for this. Edit: I'm confused by the (a|b) syntax. could you explain what it represents?
I wrote a few tutorials using Amazon for getting book info, that might be helpful to you. Here's the first: http://www.lugolabs.com/articles/75-building-a-ruby-on-rails-app-part-1-the-app
This is the second tome I've seen this picture of Roy Underhill this week. What's up with Roy?
Can you send it or paste it in full? It looks like you're confusing Bash and Ruby to me. 
Yeah. I am pretty pumped to get a performance boost without rewriting anything in a different language. Fingers crossed!
Dear every project manager...
Honestly, I think it would be best to treat each potential input and therefore task as an object. Create a task object, that has a string, due date, whatever you want. You can ask someone for input, and then create a new instance of a class based on that. You can save your tasks by writing them to a text file in such a way that you can also read them again - or just use a database, or even sqlite if you want to branch into that.
I couldn't figure it out so i swapped the pop up box for a static mailing list form. I'll give this a few weeks and see how it compares signup wise. The old one wasn't great at less than 1 percent conversion rate, so crossing my fingers that this one isn't somehow worse. 
&gt; Well, in all honesty I prefer having interview candidates code on a computer than on a whiteboard. I was using 'white boarding" as a stand in for the algorithm heavy interview approach. That's cool. &gt; That said, I think it really shouldn't make a big difference. The work should be happening in the candidate's head, not on a screen or white board. **A good candidate should spend most of the time talking through a good solution before touching a marker or keyboard.** Once he's done that, it really shouldn't matter what particular form the final output takes - the hard part is already done. The candidate who starts writing on the white board or typing on the computer before thinking through a solution is rarely a hire. That's the kind of thinking you have when you're a new, inexperienced college grad who's used to writing tests on paper. After years of burning myself with that mentality, I realized how stupid it is. It's faster, easier, and less aggravating to jump into the IDE. It's not a college test where you only get one shot. On the job no one cares if it "looked cool" solving it. Actually I take that back, your manager is going to like you more if you solve it in a predictable step by step timeframe. It's better to reliably do something in 3 days than it is to do it in 1-6 days, depending on how well you were able to think it out - and it's a lot more predictable for me to do a "implement/test, implement/test" series of phases than thinking it out in my head and implementing it last. I speak from both personal experience, and seeing the "oh I can do it all in my head" hotshots burn themselves on it. And most web dev problems are not even theoretically solvable in your head anyways. Staying in your head isn't going to tell you if that new javascript widget is going to work reliably in ie8, you have to test it. It's not going to tell you if spring mvc will correctly map out your complicated url pattern that uses special features, you have to try it. Even problems that are theoretically solvable in your head like database schemas, if you have any experience at all, you know that it's not done until it's actually working on the computer. We've all thought we solved the problem because of some brilliant idea, only to find it doesn't actually work in practice. I'll give you an example of how I'd write something based off a question I got in an interview. Problem: Write a function that takes 2 string parameters. One is "ABCDEFG", the other is "123456789". Combine the string together by taking 2 letters from the first string, then 1 letter from the second string, over and over again until you reach the end of either string. Steps I take to solve it that mirror how I've found most effective to work: 1\. Write out a quick crappy solution to the problem that's probably horrible. By end of this, I fully understand the problem. Delete this "solution". 2\. Write a simple version of the problem - combine both strings every other character. 3\. Test it. 4\. Add in the more complex step of taking 2 characters at a time. (It's more complex because you don't want to go past the end of the string). 5\. Test it. 6\. Add in error handling to check that the params coming in are valid (are they null?). 7\. Go back over the problem and look for edge cases, gotchas, ambiguously worded requirements, etc. This is MUCH easier to do in an IDE, where inserting lines in the middle is trivial, compared to a whiteboard. Is this a "sexy" solution? No. It's goal is to break the problem into small easy, absolutely braindead steps. But that works much better for both real world problems where I'm often interupted, and interview problems where it's socially super awkward to just sit looking at the problem not saying anything for a minute or two. And this isn't even getting into - I'd rather see code from another developer be more verbose, than see the "clever" code some people come up with that's unreliable, they didn't test it, and it doesn't handle errors well. 
The way I look at it sometimes is that you may naturally know an answer to a whiteboard problem or may have seen it before and therefore can figure it out. The former is great. The latter may not be as great but it shows an initiative to want to pass the interview. You put time in reviewing the fundamentals, algorithms, data structures to try and land a job. I view that as a sign that they'd probably be able to function in an actual work place. Also the majority of people aren't going to solve some of those problems in 40 minutes having never seen anything like that before.
&gt; My point isn't whether one could think up an unlikely but plausible example out there somewhere, my point is about whether it's common to use it. 
Hello again! There's nothing wrong with sticking to hard rules as an experiment. It's a good way to learn the pros and cons. It only becomes a problem if you stop viewing it as an experiment, and start viewing it as the only correct way to write code. Anyway, it sounds like you're already on the right track. 
maybe the op should wait a litle bit, rubytruffle will be there in couple of years, also I do think that jruby they can use graal also, and sulong :)
According to the project's README they can run Rails. So I suppose they have overcome most obstacles? (Since Rails makes heavy use of meta-programming, I assume there are not many, if any, restrictions. But i guess i could be wrong)
I would agree with apart from having first hand experience of being asked to implement specific sorting algorithms on a whiteboard in an interview situation. I'd wager I'm not the only one either.
What exactly are you analysing for? "Static analysis" usually talks about finding security issues and bugs, and it sounds like you already know the biggest one :)
Nice find. Similarly would have liked more Ruby-specific pointers, but I'm thinking this is a space to try to fill in. Rails+Postgres is a kicker baseline for projects - anything we can get that makes better use of Postgres is a plus.
There is no restriction for metaprogramming. You can use everything, including eval, binding, ObjectSpace, etc. The only known limitations are fork when running on the JVM and continuations. Metaprogramming is even pretty fast in common cases: http://rubykaigi.org/2015/presentations/nirvdrum
Meta-programming is TruffleRuby's strongest point! We can do a lot that other implementations can't in this area - such as inlining eval and send.
Ah you can pick and choose to update just the things you want, right.
&gt; That's the kind of thinking you have when you're a new, inexperienced college grad who's used to writing tests on paper. I'd point out I've been out of college for 15 years and am writing from direct experience both as a software engineer and interviewing candidate software engineers. Anyway, the overall tone of your reply seems to assume that whiteboarding is all about finding "brilliant", "clever" or "sexy" solutions, and that really couldn't be further from the truth. What you're looking for usually is the candidate who can come up with the bog standard obvious solution to a simple problem quickly and easily. If they can't talk out a good solution to a simple problem, that's a serious problem on a bunch of fronts. &gt; It's better to reliably do something in 3 days than it is to do it in 1-6 days, depending on how well you were able to think it out I'm really confused as to how you think spending 10-15 minutes thinking can turn a definite 3 day project into a maybe 1-6 day project. In my experience a little bit of thinking makes a problem clearer and makes my estimates *more* accurate while reducing the time needed to solve the problem, often by stopping me from spending days going down unproductive paths.
Her hair?
Ok, now I'm *really* excited.
yup and also the fact that you are actually doing something with the guys from that company ( even if they are not coding but just there doing something else ) helped me not to feel like im being judged but more like im on my day to day work
With Oracle fully behind this, this is the new jruby. From what I'm hearing in posts from Chris Seaton, etc., they seem to be the biggest corporate ruby employer around right now. 
Not really looking forward to move to America, for many reasons. But ok, I'll bite :P What makes you say Python (as a language, if we are talking about ecosystem I would have to agree, given its wide use on data science and ML, for example ) is objectively better?
That's the purpose of what I'm seeing in current efforts /u/headius. TruffleRuby should, from what I understand, soon overcome that issue once the current efforts noted are completed. But hey, I'm just reading and listening to what's going on, maybe you know more about the current intention of TruffleRuby since, I thought, you've been closer to the work? I had thought this was ultimately the next generation of JRuby with Oracle throwing so much weight behind it and things that have been stated here and there...
&gt; TruffleRuby should, from what I understand, soon overcome that issue once the current efforts noted are completed. I can't comment on the amount of work remaining in TruffleRuby, but this is true of every project. We also believe we can be competitive on performance in JRuby by utilizing Graal, but there are "current efforts" we have to complete too. There was never any plan to replace JRuby with TruffleRuby. We co-developed in the same repository after we worked with Oracle to open-source TruffleRuby. When it became clear that their goals were different than ours, they moved to their own repository. JRuby is the premier JVM Ruby and will remain so for a long time.
Good to know! Thanks for sharing your goal there!
#[Installing gems](https://github.com/graalvm/truffleruby/blob/master/doc/user/installing-gems.md) (Updated 39 minutes ago)
I actually don't want to get into a language pissing match, not least because the gap is fairly small. In short: Ruby is better at DSLs; Python is more consistent, has fewer warts, discourages DSLs. Also, you can't necessarily separate execution machinery out, because most people use the reference implementations. 
Mayon-egg
Oh I gotcha. That makes a lot of sense. I would probably structure this like that as well.
Hey there! Admittedly I'm a Reddit newbie. Were you trying to offer suggestions on making hiring posts...?
I'd be more excited if Oracle wasn't involved.
You can do this as well with a git alias in ~/.gitconfig. I just re-installed or I'd paste what I have, but I just made it "git cb" (for clean branches)
Quality metrics, like rubocop, reek,metric_fu
same
 undefined method `hp=' for #&lt;Survivor:0x007ffb40c3fd00 @hp=115, @dmg=4&gt; That's telling you not that you can't modify the object, but that there's no survivor.hp method. How did you define Survivor? Did you create a class variable for hp and define accessors for it?
Code for the Survivor class: class Survivor attr_reader :hp, :dmg, :lvl def initialize(hp = 95, dmg = 3, lvl = 1) @hp = hp + (5 * lvl) @dmg = dmg + lvl end end EDIT: I just realized my mistake when posting my code. I need to have it as attr_accessor instead of attr_reader.
Good idea! Gonna add it on my post giving you the credits :)
Plenty of companies using Python. It's New York. Everything is here.
&gt; Is there a way to inspect the values of the `:opt` and `:keyopt` [parameters] without running the whole method? It's just `:key`, but [yes](https://eval.in/742117).
I think elixir for Rubyists would be TruffleRuby in a the near future. Many already consider current CRuby/JRuby as their programmer's elixir ;-)
Awesome! It does discount the fact that default arguments can do arbitrary computation, but it isn't often you do that.
why?
Really? I've come across some 2 companies that use python as their main language here. That's very much borne out by what's being advertised for here. 
Looking at the example, it seems harder to read/use than say HAML or Slim.
huh?!
I have to ask: d'you actually have a use case for wanting to get at that sort of information? You mentioned an aversion to string extraction, but then how else would you hold a reference to the unevaluated computation? You could probably get hold of the underlying `RubyVM::InstructionSequence`, but that's only slightly less opaque than, say, a `Proc`.
I agree that those look pretty nice. From my view, the main advantage of those template languages for readability is their use of indentation for nesting (similar to Python.) The html gem does not define a new language. People who know Ruby don't need to learn a new syntax to write HTML. Especially, they don't need to learn how to integrate loops or other control constructs into the template language as there is no other language to integrate those constructs into. But using plain Ruby comes at the cost of having to use Ruby syntax, including curly braces (or keywords) for blocks.
I'm not aware of any specific terminology for it.
How is it different from markaby?
Is that why it looks like Markaby? https://github.com/whymirror/markaby
I would call it the main file but i think it doesn't matter to much. btw, I'd love to see the guide. Give me a PM if you need someone to review it!
I was trying to formulate a witty argument about OOP not being a silver bullet when it dawned on me... How can one write a decent todo in ruby without an object oriented approach. This got me an idea for a project: An un-object oriented todolist in Ruby. Thanks for the idea! 
I like the idea. Might be a good idea to offer compiled templates, which would work with a bit of metaprogramming: template = HTML::Template.new do |some_value, other_value=nil| html do title { } body do div do text some_value text other_value if other_value end end end end template.render(some_value: "hello", other_value: "world!")
So tl;dr out with jQuery, in with yarn and webpack, and a uniformed form_with to replace form_for and form_tag? Nice.
I figured it must be something like that. You might've noticed that `#signature` isn't really the best name for what the method actually does in the aforelinked snippet. I pared it down for the sake of directly answering your question, but `JohnHancock` is a WIP that expects to find default arguments of such forms as `[String | Symbol]` in order to facilitate method overloading and/or some rough approximation of static typing in Ruby. I grant that it's probably something of a fool's errand, but it's a fun and interesting exercise all the same.
You could argue that Fixnums and some Floats are passed by value, but there's not really any difference in the semantics.
Ironically RailsConf 2017 will take place in Phoenix (Arizona) :trollface:
You are loading all the other data on the page through server-side rendering (ERB) tags. You can use these to build the options tag, too: &lt;% @things.each do |thing %&gt; &lt;option value="&lt;%= thing.name %&gt;"&gt; &lt;%= thing.name %&gt; &lt;/option&gt; &lt;% end %&gt; By the way, you should use slim if you're not already, you won't ever want to write ERB tags again. Anyway, there isn't as much Rails magic when it comes to client-side programming, so if you have that expectation you have to let go it at some point. There is this concept of "unobtrusive javascript", but still, client-side code is a different beast so you will have to get your hands dirty at some point. Of course, you can use a front-end framework, and that's probably a good investment if the project is growing to medium size or larger. 
Yep, since thy are immutable, it does not matter.
I (not a frequent Rubyist) totally forgot about Markaby. It is similar in spirit, and I will look at its documentation to check for differences. Thanks for the pointer!
Thanks, I didn't know that CGI includes HTML generation. From the docs I gather that CGI uses the result string of the block for children while I use the effect of possibly many statements in the blocks. I need to check, how CGI would handle something like ul { (1..3).each { |i| li { text i } } } and if one should use 'collect' instead of 'each' to generate all three items. 
Good question. After looking at the docs, here are differences that came to mind: Markaby is more mature and well integrated into common web frameworks. Markaby has a shortcut for using a single string as child text. I am tempted to implement something similar, so one can write head { title "Hello" } instead of head { title { text "Hello" } } Markaby has special treatment of 'class' and 'id' attributes which can be written as method calls on the element name. In my gem, there is no such treatment. One writes those attributes like all others: img(class: 'poster', src: 'html.png') Markaby has optional validation of output. Markaby distinguishes escaped and unescaped text by whether it is passed in a block or as string argument. My gem currently does not support passing strings directly or in a block but uses methods 'text' for escaped text and 'inline' for unescaped text. Markaby has 'automatic stringyfication' that lets you use the result of elements as string. In the beginning I had something similar but then dropped it to simplify the implementation. To summarize, Markaby is more powerful and if there is an advantage to using my gem at all it might be that there is less to learn about it.
Interesting thought. I assume you expect a compiled template to be more efficient than a function like def template some_value, other_value = nil HTML.doc { title { text "Hello" } body { div { text some_value text other_value if other_value } } } end that can already be defined now. Presumably, the efficiency would come from evaluating static parts of the definition which do not depend on arguments, so these parts would not have to be evaluated each time when rendering the template multiple times. But as the methods generate a single string, including the arguments passed when rendering, it is unclear to me how to incorporate such precompilation. But I am not a frequent Rubyist and might be missing something. How would a bit of metaprogramming help with precompilation?
Another big win is database transactions just working™ inside Capybara feature specs now without having to set up external transaction management (e.g. with database_cleaner) with Rails's new "system test" support: http://weblog.rubyonrails.org/2017/2/23/Rails-5-1-beta1/#system-tests That has traditionally always been a big headache.
Is this going to work nicely with RSpec too or is it just for native Ruby testing framework or Minitest? 
have you tried reaching out to the folks at watir? Perhaps open an issue and see if they have ideas. https://github.com/watir/watir
If you're interested in Rails (which I'm guessing you are if you're getting into Ruby) then this is good too: http://railsforzombies.org/
I'm a bit of a book person when I want to really focus on learning something new. If that applies to you, I'd recommend Manning's The Well-Grounded Rubyist.
Check out this link: http://stackoverflow.com/a/30142317 You should be able to the same thing using the ruby bindings in selenium. Once you create the desired capabilities object you can create your browser instance using Watir. We do this to enable geolocation and other settings depending on the browser. I'm on mobile but I can post example code later if you're confused. Edit Something similar to this, you might need to use `Options` instead of `Capabilities`: caps = Selenium::WebDriver::Remote::Capabilities.firefox(:webdriver_accept_untrusted_certs =&gt; true, :accept_ssl_certs =&gt; true, :marionette =&gt; false ) $browser = Watir::Browser.new(:firefox, :desired_capabilities =&gt; caps) 
Eloquent Ruby. It's intended for experienced devs and explains how to write idiomatic Ruby. I'd also recommend some of Jesse Stormier's stuff for working with low-level IPC interfaces Other than that - I'd say just read the Ruby docs for the main classes. Object, Class, Module, Enumerable, Enumerator, Kernel should give you 90% of what you need. The Rails Guides are also very good
In Rails 5.1, that's `rails new foobar --webpack=react`. ;) Also supports Angular and Vue. 
Buy the books "The Well Grounded Rubyist" by David Black and "Practical Object Oriented Programming in Ruby" by Sandi Metz. Do some Koans and some CodeWars in Ruby. 
I'm going to post this link every time somebody asks! http://upskillcourses.com is a free and excellent resource which is where I got started.
Easy fix just running bundle update then the original command and it works. Still annoying getting a loop like that. 
He mentions one of the problems with ensuring all commands in an ensure are ran before raising an exception would create the need to check up the potentially nested methods to see if we are truly finished with an ensure, but why is that necessary? Wouldn't each ensure block just handle it's own completion before raising to the previous block, and if there's no ensure there, it just raises the error, and if there is an ensure block, it ensures all ensure code is executed before passing up the tree. Why check all the way up? Each ensure block should be responsible for its own code execution before passing the error. The problem I see is if it's going to execute code after an error is raised, what do we do when multiple errors exist?
IIRC you can do `bundle update nokogiri mime-types` Too lazy to test it to confirm, though =)
For this reason the http.rb gem uses asynchronous I/O to implement timeouts: https://github.com/httprb/http The Socketry gem provides high-level socket APIs with thread safe timeouts based on async I/O: https://github.com/socketry/socketry
Earlier discussion with more comments (5 days ago) in /r/ruby: https://www.reddit.com/r/ruby/comments/5vbybi/the_oldest_bug_in_ruby_why_racktimeout_might_hose/
I see. Instead of memoizing everything, it would be simpler (on the implementation side) to allow users to memoize critical parts selectively. I think I would use something like: class MemoProc &lt; Proc def initialize &amp;block @cache = {} super(&amp;block) end def call args = {} if @cache[args].nil? then @cache[args] = super args end return @cache[args] end end This is independent of HTML templating, but can be used to define HTML templates. This approach is not as fine-grained as you describe but still useful to speed up the generation of parameterized HTML fragments that are rendered multiple times.
Taste the rainbow!
Minor comment: chaining AR scopes **is not composition**. It's, well, chaining. Building up a query step-by-step. Relation composition is the idea that relations are 1st class, composable objects. The only thing that comes to mind that works as relation composition is using AR's methods for eager-loading associations. ie `User.includes(:lessons)`, because under the hood it composes "users" relation with "lessons". Chaining scopes that sets WHERE conditions, adds JOINS etc. is a different concept - it's just building a query.
I would argue that they are composition as internally you are building object from a previous object. So it's the similar thing as passing one instance to another to another =&gt; therefore composition. The only difference is that Rails chose this DSL suggar around it is method chaining. But in reality you are instantiating new object from previous object passed as an argument. &gt; it's just building a query. yes but via composed objects :)
&gt; I honestly don't like doing processing work inside the initializer. Maybe it's a holdover from other languages (like C++) where that was a bigger no-no, but it just feels messy to me. It prevents you from composing objects and doing any kind of dependency injection. To be fair you could hack around that in Ruby since classes are objects too, but passing classes around only works as long as the object you want to construct doesn't need to be configured.
Discovered it through [The Odin Project](http://www.theodinproject.com/) and it's been really helpful. I think it could be added to the "Learning Ruby?" section of the sidebar.
DHH mostly rants about complexity of js ecosystem, not one library in particular.
Exactly, you have to tell Bundler to update them at the same time.
There is a good section in `Ruby under the microscope` which explains tokenisation and AST in regards to how ruby passes through code. http://patshaughnessy.net/ruby-under-a-microscope
Wow, thanks for pointing this book out. I've only read a few pages from the Amazon sample page and there are a lot of things standing out as "Oh man! I've seen that! So THAT'S what you are! Friends like `tINTEGER`, `tIDENTIFIER`, `KEYWORD_DO`." They generically make sense. But now I actually know where these scribbles are coming from. Thanks for the suggestion, I'm curious to dive in more.
You might try writing a method on users called permisison_for_league used like this: current_user.permission_for_league(@league) It would search through current_user's associated league_users, find which one is associated with league, and then grab that league_user's associated permission. As for minimizing database hits, look up [eager loading](http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations).
lol
I would put this view logic in a possible helper.
A question worth asking: why not just call this an "object?" I've found that many people get tripped up by this whole "service objects" movement. They generally aren't sure if they're actually "doing it right," but the term itself is so vague that it's impossible to say what it even is, or how it differs from plain objects. Thought experiment: suppose you titled this post, "Objects in rails - am I do it right?" How would the responses differ? It's all just programming. Programming in an OOP language like ruby usually involves writing objects.
I read it as object composition, and understood what you meant. I call this composition as well, and have seen other people discuss ARel that way. 
It's too soon to extract a (service) object. This might be the wrong abstraction. I would do this: class SpreadsheetsController &lt; ApplicationController API_KEY = ENV.fetch('GOOGLE_API_KEY') URL_PREFIX = 'https://sheets.googleapis.com/v4/spreadsheets' def show spreadsheet = if request.origin open("#{URL_PREFIX}/#{params[:s_id]}/values/#{params[:range]}?key=#{API_KEY}").read end render json: spreadsheet || '' end end If you find yourself doing something similar elsewhere, then consider an abstraction. Keep in mind that once you create an object with methods, they become part of the public API of your code. And that's something you have to support.
Ruby generally does not ignore line breaks. Otherwise f g would be the same as `f g` whereas in reality it's the same as `f; g;`. That is Ruby usually inserts `;`s at the end of each line to make them optional in most cases. However there are cases where it does not insert them and that's what OP is asking about. And on a note unrelated to this the OP's question: even spaces aren't always ignored by Ruby. `f - x` is `f() - x` (assuming that `f` is a method and `x` is not), but `f -x` is `f(-x)`.
Not sure why I'm down-voted. Just offering my point of view. Anyways... It's certainly ok to violate the "rules", as long as you understand the trade-offs. Having a single responsibility is great. That's the ultimate goal. It's just that at this point you may not have enough information to know if a SpreadsheetService is the right abstraction. It'll become more clear what abstraction you need as new requirements come along and/or this functionality becomes duplicated elsewhere. Your solution isn't "wrong" as much as mine is "right". I just wanted you to think about the pros/cons. It's good you're thinking about good code design! :) Take a look at "Go Ahead, Make a Mess" and "The Wrong Abstraction" by Sandi Metz. https://speakerdeck.com/skmetz/go-ahead-make-a-mess https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction
Is it obvious that it's insecure? Have there been security incidents? Is swapping out something that has been working worth the time, effort, money, and unsurprisingly, possible new security risks? I wouldn't change that if it hasn't been a problem.
Completely agree. There's too much concern with "what 'type' of object should I create? Service, Value, etc."
Write tests around the auth parts. Remove old auth, implement devise or whatever, fix until tests pass.
&gt; Obviously this isn't secure This is a bad premise to start on. What leads you to believe it's not secure? Just because something isn't using Devise doesn't mean it's automatically insecure. You should do some research and see if the system in place is actually insecure. If it is, see how much work it will be to make it secure. Tearing out the auth system for a heavily used app should not be taken lightly.
This is another reason why git-over-ssh based deployments are problematic. I prefer to package my ruby applications as `.deb` packages for this reason. I can just mark the debian package as being dependent on the version of ruby I want to deploy with. This allows me to leverage tooling that is already there -- in fact, if package based deployments were the norm, there are a good amount of bundler/rubygems features that wouldn't have to exist. I don't ever specify the ruby version in my Gemfile. I don't even (generally) include a `.ruby-version` file in my projects. Never had a problem keeping a team coordinated. EDIT: I should mention that one bundler feature I think more people should be using is `--standalone`. I've observed it to not work well with rails, but that hasn't been a hurdle for any of my projects. I tend to deploy my rails frontend servers the way rails expects to be deployed.
I ended up removing the pop up in favor of a static form. It's really hard to know about statistical significance with this stuff, but it looks like signups are doing slightly better. Maybe because more people can actually READ the article. Thanks for taking the time to let me know and giving me info to reproduce. 
I'm obviously partial to the git-over-ssh deployments ;) I was around many many years ago when Heroku (Terence) was deciding on how to specify what Ruby version your app used. Historically Heroku has had a bad time of making new specifications and driving them across the market, for example before bundler they had a "gems" file that never really caught on (for good reason). His main concern was using community infrastructure instead of rolling our own. At the time there was a `.ruby-version` file but it didn't work because it didn't allow us to specify jruby engine version separately (or something like that). It was also problematic in that it required the ruby version manager to check for development correctness if someone was using system or a lightweight client then it didn't check. We (he) decided to go with Bundler because it was already required to run on Heroku and was consistently adopted throughout the ecosystem. There are good things about specifying the Ruby version in the Gemfile. It is unambiguous and strict, if you get a new person on the team or a contractor, there is no question that they will be running a different Ruby version. Most of the time this doesn't come into play, however if you're trying to use a newer feature such as the lonely operator or "json style hashes" on an older version of Ruby, I want that to blow up for me in development instead of production. If you're on a small team and don't get new devs, this is less of an issue. Many Rubyists switch between many different projects and it is a problem All-in-all i'm pretty happy with the decision to specify Ruby version in Gemfile. I do wish it had better integration with tools like rbenv (that i don't use) since I find people doing weird hacks like `File.read(".ruby-version").gsub(#whatever)`. I think that this behavior I described in the post is surprising, once it becomes the new norm then it will be fine. It's partially why I decided to write it, to get the word out that Gemfile.lock is your canonical source of Ruby version info now. I actually wrote the post a long time ago and it didn't get published for whatever reason. 
Thanks for the thoughtful response. I, too, have experienced the downsides of `.ruby-version` :) Our perspectives are going to be inherently different -- y'all are reasoning about consistent, one-button deployments for the whole ruby ecosystem, with particular care given to grease the most commonly used grooves. On the other hand, I've been in position to set up deployments for individual teams, with deliberate care and full control over the process soup-to-nuts. I have preferred working with package based deployment systems, but I also acknowledge they aren't easily to generalize (if a generalization is even possible). Anyway, on teams that I've managed, we'd standardize on both language features and ruby versions. Keeping everyone running compatible versions of ruby can be solved by team coordination. Package based deployments also introduce the notion of a "build phase" where the software can be tested against the version of ruby used in production -- so it is, in effect, impossible to deploy code with the lonely operator to a production system that is on an older version of ruby. In general, the amount of awareness about the surrounding environment that has to be kept in version control of a ruby project is a lot higher with git based deployments than I'm comfortable with. Bundler and rubygems should be there to fetch bits and place them in ruby's load path. In my view, that's their "single responsibility," if you will. At some point during the deployment process, the ruby version _should_ be checked against the code -- I just prefer that the version check occur when running the test suite (and before packaging/deploy). Heroku serves a certain market very, very well. I am concerned by the extent to which ruby dependency management tooling makes assumptions about the surrounding deployment approach. This is where convention over configuration can bite teams that want to use the same software in different ways. Of course, I digress :) Cheers!
What about bashing your keyboard with a ball-peen hammer? Did you try that?
I'm glad that I don't need to use Bundler or `Gemfile`s :)
When developing libraries, I try to use only gems that follow the traditional versioning scheme of MAJOR.MINOR.TEENY. And that are maintained properly. This avoids many problems (and I have been bitten by them in the past) and allows me to avoid using yet another tool, ie. bundler. Additionally, I don't see any need for a `Gemfile` or bundler when developing a library. It's certainly different when developing applications, especially Rails applications.
I don't understand how only using gems that use proper semver (which is I think what you mean), and are maintained properly, obviates the need for bundler. How do you ensure the same versions of all gem dependencies are used accross all dev and production machines? Including when setting up a new dev or production machine? Including when you need to upgrade a particular dependency version? I remember the pre-bundler days, I wouldn't want to go back. And I don't really understand how you do without it! 
&gt; Obviously this isn't secure As others here are mentioning, just because the authentication code is custom doesn't necessarily make it insecure. You may have some unusual business logic that doesn't really fit well with devise or another gem solution. &gt; it's only a matter of time before the system eventually gets compromised. How? Focus on figuring out what in your system can be compromised. It is important to evaluate the holes that you have in order to make a proper decision on how to proceed.
Howdy folks, I'm a Python dev transitioning into Ruby (Rails) for a new assignment. Ruby has some stuff I really like, but I'm still kind of struggling with some of the idioms. I REALLY appreciate Raymond Hettinger's talk on idiomatic Python and I return to it regularly even for my Python work. Is there anything like this (preferably in a similar format) that covers common mistakes and idiomatic improvements for Ruby? I really, really like how Raymond goes into some of the history of the language development in the video because it gives me some context to understand all of the variations I see when reading other peoples' code.
I would recommend that you take a look at the source code of the Rails authentication libraries, and see what are some the high-level differences in the flows between them and your application. By reading the source code and looking at `git blame` you can learn a good deal about some of the best practices. But I think you have every right to be concerned about a custom authentication system, there are so many little things that can compromise the security. For example, take a look at [Jose Valim's analysis](https://github.com/plataformatec/devise/issues/3475#issuecomment-121414206) on all the security issues that one custom implementation had, just by looking at it for 20 minutes.
Eloquent Ruby by Russ Olsen is an excellent read on this subject.
I think the point of turbolinks is to speed up the server rendered rails app experience to the point of making a rich client-side spa structure unnecessary. 
Avdi Grimm's RubyTapas videos are good. His book Confident Ruby is maybe a bit iconoclastic, but also very solid.
Nice, I like the collections concept and use of DI to modify the behaviour.
&gt; There is no better way to learn to write secure code than to write and learn from insecure code. If you just always plug in someone else's gem and never take the time to learn how to do these things yourself, you're a much less valuable developer than the ones who can do this stuff, and who more importantly, understand it. Using a library doesn't have to mean that you don't understand its implementation. You can both use an authentication framework, and understand what it does under-the-hood, and it's even mandatory when you need to customize the flow. &gt; What happens when you have to write an authentication system in a framework that doesn't have a devise handy? For other Ruby web frameworks (and for Rails as well) there is [Rodauth](https://github.com/jeremyevans/rodauth), which I think is even better than Devise. &gt; Or you have to interface with a legacy system that doesn't lend itself to devise's design? Well, as I see it, the authentication framework should be customizable enough that you can deviate from the norms, as long as you still need to implement the same common features (registration, login, logout, password update &amp; reset, 2FA etc). &gt; Or when you need to explain to your boss why practice X is insecure and shouldn't be done? I don't really understand how you'd know why practice X is insecure better if you implement your own authentication system than if you used an authentication library. &gt; The worst developers are the ones who just play LEGOs with others' code and never learn to do it themselves. As you put it, anyone who just wants to avoid reinventing the wheel is just mindlessly playing with LEGOs. I usually need to understand how a library I'm using works anyway in order to be able to use it properly.
If you're talking about an experiment where an overlooked detail has no consequence, I can get behind you on this. Learning is always a good idea. But to run something in production with first-time home-grown authentication? Let me know what sites this has been done on so I can avoid using them. There is simply no reason to take that risk.
This is excellent, thanks for sharing.
I normally just `require` since I choose my dependencies with care, if I have to use dependencies at all. If you look at kramdown, for example, you will find that it has no hard dependencies. It certainly *can* use some other libraries like `rouge` or `coderay` but those are listed as development dependencies with versions that I found work.
There's also https://ruby-doc.org/stdlib-2.4.0/libdoc/observer/rdoc/Observable.html
you're complaining about people using `bundle gem whatever` to make that directory structure, and don't "get" why people would do that, but do "get" why people would use `hoe`? Really? Okay, everyone's got the process that works for them, that's cool, I guess we don't need to "get" each other. 
The difference, in my opionion, is that `hoe` is a tool built for the task and does this well. But you are right: to everyone his/her tools. I prefer to use as few dependencies as possible.
sounds like fake news to me. with turbolinks, you still render server side. this means your adding html, duplicating data when you need it for presentation, and otherwise creating more data that need to hit the wire. with an SPA, you're just hitting a json endpoint and passing data over the wire. additionally, it's very easy to cache in the client so that you show the new route to the user then update the page when the xhr request returns. you just can't match that with turbolinks.
I don't know ... First, SPA's aren't a "gargantuan effort" IMO. It might be a new technology if you haven't build one yet but Ember is like Rails in the front end so you've got convention over configuration if you want it. But, the overall effort isn't any greater. You just move your app logic into the front-end and your server becomes a much simpler API. Then, you can do really cool things like updating the front-end app without re-deploying your API (check out lightning deploy from the ember folks). Second, I work on apps with millions of users if not orders of magnitude more. When each one of those users brings there own hardware and I just get to serve a simple API, my AWS bill is _much_ lower. Last, I'm refactoring an endpoint from server rendered to SPA right now. It's a very well factored bit of code where all of the complexity that the developer needs to worry about is isolated in a presenter. And that's a problem from a computational complexity point of view. The view is hitting the data base (proxied through the presenter) all over the place. There's also a lot of extra bits on the wire because of the html that's getting sent over. I'm basically getting a _huge_ performance win by hitting this endpoint via ajax and getting json back simply because it's obvious what data I want so I hit the db once and send normalized data over the wire. But, the biggest point is pushing the computation off of servers that you pay for. That's my #1 reason for moving to the front-end.
This might not be a good idea but you can disable verification OpenSSL::SSL::VERIFY_PEER = OpenSSL::SSL::VERIFY_NONE I have a post about it http://www.seanbehan.com/turn-off-ssl-verification-in-ruby/ 
Noel Rappin mentioned he's working on a Rails 5 update of that: https://twitter.com/noelrap/status/834975262223794176 And Pragmatic Programmers will often give free or discounted updates for ebooks. Other titles I'd recommend: * Everyday Rails Testing with RSpec by Aaron Sumner https://leanpub.com/everydayrailsrspec * Testing Rails by thoughtbot https://gumroad.com/l/OWvLJ
As well as a fair number of Gems out there like [Wisper](https://github.com/krisleech/wisper) and [Faye](http://faye.jcoglan.com/ruby.html). I've used Wisper on several projects and it Just Works. Faye is in a lot of big projects and is also what you want if you want to share pub/sub between back and front ends.
Well, It's a setup that programmers load on their own private machine to run tests, so I'm not sure Travis CI/Jenkins is a good call here. Unless of-course the tests will run exclusively on a CI env, and then Travis CI is indeed a better solution :)
Speaking as the author of Rails 4 Test Prescriptions, I'd say that the advice in the book is not outdated (for the most part), but some of the specific comments about tools will have changed. (Really the biggest change will probably be to the JavaScript section). Rails 5 Test Prescriptions is in progress, we're hoping to have a beta in a few months, but I just started, and we're a little beholden to Rails release schedule. In the meantime, might I suggest https://www.rubytapas.com/testingjournal/ for some other testing thoughts.
Wow... SO much THIS. Even when I don't have a problem to solve, I read the docs... Read the [Enumerator](http://ruby-doc.org/core-2.4.0/Enumerable.html) / [Array](http://ruby-doc.org/core-2.4.0/Array.html) docs at least once a month I give them a go just to keep what closure methods exist. &amp;nbsp; If you are a noob, learn how to use .map / .inject / .include? then start checking out the things above and below it... I swear you won't be sorry. &amp;nbsp; not just for ruby &amp;nbsp; EDIT: format
[Yeah](https://motherboard.vice.com/en_us/article/bored-hacker-steals-subreddit-reddit-security), [and this time also](https://news.ycombinator.com/item?id=46406) 
Thank you so much for taking the time to review, I really appreciate it. If I'm understanding you, you'd rather the breaker be wrapped around a client or service rather than a method. Is that right? I'm not sure what an abstraction / pattern might look like for that but let me think on it. 
 loop do puts 'type something' input = gets.chomp break if input == ':q' end
Ruby lets you shoot yourself in the foot in interesting and varied ways. Python lets you shoot yourself in the foot in a very elegant, easy to understand way. FWIW, Ruby is my preferred scripting language. Python is great, and so is Powershell/bash/zsh, but most of the time I prefer working in Ruby. It's a *nice* language to work in, which is a hard thing to quantify.
1. Python is better for science/data mining. Ruby is better for web dev. By better I mean more popular, and with better tooling. 2. Rails is healthy. I beleive it's losing market share, as all languages are, but that's because new languages are entering. I beleive total use is expanding. The downside I see is that ever "Zero to Hero is 1 week" code camp is usually taught on Rails, so there are a LOT of bad to mediocre rails devs. 3. Can't say I've done much except backend, and some basic scripts, but like Python, Ruby has a huge user base, so there's likely a tool for what you want to do. Although just because there's a tool, doesn't mean it's the best, or that there aren't alternatives.
He's quite off though. £5-10K? Maybe for a junior/mid role. Day rates are typically about 60-70% what he said.
What game are you talking about? And does the message need to be visible to just you, or the internet? Ruby doesn't necessarily plug into any arbitrary program on your computer.
So lets take it a step farther, say your CEO needs a quick excel file to analyze something to show the board: You can mixin map_by to a module that has a method like `to_csv_string`. It would then look like: ```def records_to_csv_string(records, *attribute_names) attribute_names = records.first.class.attribute_names if attribute_names.flatten.blank? attribute_names = attribute_names.flatten.map(&amp;:to_s) csv_string = CSV.generate do |csv| csv &lt;&lt; attribute_names values = [] records.each do |record| attribute_names csv &lt;&lt; attribute_names.each_with_object([]) { |attribute, array| array &lt;&lt; record.instance_eval(attribute) } end end puts csv_string csv_string end``` and then you could create a method like Array::to_csv_string. And then you can do stuff like SomeClass.where(id: [1,3,5,7]).to_csv_string(:id, 'created_at.strftime("%c").in_time_zone("Eastern Time (US &amp; Canada)")') and it will eval every instance of SomeClass formatted in whatever time zone.
Wouldn't the time difference be a problem?
New windowses "freeze" the partition when they use it, so no other system can use it, unless it closes properly. Fortunately I managed to generate pdf on another machine, so I'm saved, but the problem still exists. And I have way too slow machine to run vm. 
I think that you could use this as a replacement: https://fonts.google.com/specimen/Archivo+Narrow According to the code, it falls back to Segoe if Archivo Narrow is not present, I think, and being a Google Font, it's free.
don't tell me there is no way to mount even not-closed partition (whatever it means on technical level) from linux? from quick google search it seems that it will suffice to mount it read-only, which should be enough for your use case (extracting the font file). EDIT: take a look here: http://askubuntu.com/questions/145902/unable-to-mount-windows-ntfs-filesystem-due-to-hibernation
i see the partition but if I want to mount it it says "disk is not available", I never could acces the drive when windows crashed. I always had to boot windows and close it properly
Why not just put them in your `~/.bash_profile` and access them in `ENV` like normal unix? Any reason that doesn't work for you?
Hm, if there's a recently disclosed vulnerability in nokogiri, why is it not listed on rubysec.com? Is rubysec.com (or the sources it feeds from) not so good at keeping up with vulnerabilities anymore?
1. The biggest difference I see between Python &amp; Ruby is Ruby's blocks. They're hugely powerful and ttbomk Python has nothing like that. The second biggest difference I see is the approach to OO. Ruby is IMO *more* OO. I'm (perhaps wrongly) basing that on things like Python's "len()" method rather than having arrays/lists have their own method that describes how many members they have. In general, I think Ruby makes OO design make more sense. It's easy to write crappy procedural perl-like Ruby or Python, but it's a lot easier to write awesome smalltalk-like Ruby than Python. 1. I use Sinatra (and occasionally Roda) exclusively and have a mostly good time. The biggest downside to not using Rails is that everyone writes their gems with Rails in mind and other frameworks are second-class citizens as you elude to in your question. 1. I had the need to implement 'column -t' in python as a one-liner and it was a nightmare. The same functionality in Ruby was easy to write and read.
Isn't python's form a little more similar to Javascript, where's there's not the distinction between method and proc?
League of Legends. Computer is too slow, in this game you call dibs on the team position you want or know how to do, my computer takes too long to load the screen to do so. I like the idea of it "plugging in" but I'd already assumed I'd have to work along with something that records mouse/keyboard movements. At first I had the idea of using the automation software to rapidly click on the space a text field would appear and (hoping) ruby would have a way to determine when a text field was selected by the mouse and puts the text I want and enter. Then I realized that wouldn't help as my computer loads the game too slowly. (though, I'd give this a try if there was no alternative.) Is something like this possible? Yeah, I'm *that* new to programming. I don't know what I can do with what I know but I want to imagine I can lol.
- I use fish shell, and switch back to bash sometimes - This is a shell-independent solution - Only programs that read `~/.env` will have the variables in memory (e.g. otherwise any random program leak would leak my private keys, (some bug reporting tools, etc)) - It makes a lot of sense to me as `.env` in a Rails project is the config for the Rails project, and `~/.env` is the `HOME_ENV` :)
it's kind of a stretch to be honest. You could probably find some way to click at an X,Y coordinate on the screen and you can make a program to type keys for you, but it'd be really hard to know exactly when to do it since LoL is handling all that behind the scenes. All that being said, there probably are programs out there that will help with this. I just really think that trying to build your own is not the way to go. No language is not like a skeleton key that lets you program anything anywhere. 
do you mention pry in your new book? i've found it very useful for dealing with failed tests, specifically `pry-rescue` that can drop you directly into failed test context automatically on failure
The "mathy" part of bundler is great -- meaning, where it calculates the best combination of versions of dependencies based on the criteria specified in the `Gemfile`. The CLI could use a lot of improvement, and frankly I wish it made a lot fewer assumptions about usage patterns. Remembered options is a great example -- in five decades of UNIX, nothing similar has ever been necessary. Not sure why bundler went with that approach TBQH. When I use `apt` or `yum`, the packages get resolved, fetched, and placed onto my system. I love that, it's great. When I run programs downloaded by the package manager, I don't need to invoke them via `apt`. The way bundler expects to hook into the runtime environment is very unfortunate, IMO. I'm glad that can be overridden by `--standalone` :)
you need to think harder, there are tons of good beginner projects. Don't rush it, wait for the inspiration to strike. 
My personal preference is to use Slimer with Phantom. But they dropped coffeescript support so now you have to write js or compile :/ Capybara is also really nice. I use it everyday at work. We use the WebKit driver for CI and it works pretty well. But I always have issues running it locally ( CI server is Linux local is Mac) so I use the selenium-chrome driver for local dev. It's also nice because you can see what the browser is doing, drop in a binding.pry then open chrome's dev tools to poke around. Capybara has a 'js: true' option that you'll need to use for the Vue stuff. The only real problem there is xhr. You'll never really know when a site has finished an xhr request so you wind up waiting for things which makes tests slow to fail. We implement a server side counter for xhr and have a helper for capybara so that we can be explicit about xhr finishing and fail fast if the result is wrong. But you need tight integration and control of client and server to make that happen. This is why I like phantom better: it is the browser so you know when an xhr request returns. 
Yes it was a lot of fun! Thank you for your kind words :)
RE import lines - you probably need to install the sass package for sublime to get syntax highlighting: https://packagecontrol.io/packages/Sass If you've restarted your webserver ("rails s") after bundle install, you might want to view source of the page and click the application.css file to see what content is in there... 
Ah, I see. Not even automated, just know what gems you need and type that in on the console? Personally, I would never want to go back to the days of not being sure if the gem dependency in production is the same as the one I have in development when debugging. But if it works for you, that's cool. (If you have more than one production machine, you just don't worry about them maybe not having the same versions of dependencies even amongst each other? If it works for you, good for you, but yeah, we must have very different sorts of things we work on) 
Interesting, but a bit sparse. I could stand to read more on the subject.
It's going to be hell no matter what, in my experience with Capybara. You are right that the Capybara::Rack driver will not run javascript. You can use phantomjs via Capybara with `poltergeist`. That's what I tend to do, but I'm writing specs for my own app, not testing external sites. I think a look at non-ruby JS options would be worthwhile, but I'm not familiar with them. 
Actually I wrote about that :) http://doma.io/2017/02/27/the-story-behind-safe-bundle-update.html Basically running tests between each update to make sure it really works
You can download the fonts and use fontconfig to install/use them. There is some helpful info here: https://wiki.archlinux.org/index.php/Microsoft_fonts
Any recommended resources to learn how to do this? 
Thanks.
That doesn't tell me what you're trying to do. What's your goal? What was the last thing you did before it broke? 
Thank you! This is very helpful start.
Yeah, I added it to the README and some explanations about what it after your comment, thanks :)
There's more in the Extension issue of RubyLetter here: http://www.rubyletter.com/newsletter/2017/03/03/extension.html
Much better, thanks!
Any performance improvements or benchmarks?
Thank you! Yes, it does. All public methods are used in view, in every number, every chart line view send message to this class. But private methods - I agree, fetching points from database and trimming dataset can be extracted into its own class or classes. I was also thinking about to extract part of public methods into separate class and to use delegation. About dependency injection - if I'll extract things to separate classes I'll need to inject: * Dataset that I can query for points * Units convertor that instance will send messages about to convert and present (decorate?) speeds, distances, altitudes, glide ratios * Class that will be responsible for numbers at the top of page (totals) Is it ok to inject 3 or more dependencies?
After you follow some of the excellent advice in this thread, I suggest installing Rubocop linter and following all of its rules. It will teach you some of the more nitty-gritty refactoring techniques.
You may have intended to reply to the OP but you replied to a comment, so it might be worth it to mention to OP that your comment exists or they might miss it.
Are you on Windows? I had the same issue, one time I'd hit the windows path length limit, the other time I followed the below instructions [from a user here]( http://stackoverflow.com/questions/28421547/rails-execjsprogramerror-in-pageshome) &gt;coffee-script source &gt;= 1.9.0 don't work properly under Windows. You can do this: gem 'coffee-script-source', '1.8.0' to force 1.8.0 and then issue bundle update coffee-script-source 
I think you have several ideas posted here now. One last thing I want to add is: think about objects not classes . Classes are just illusion 
Cheers bro I'll check when I get home! Thanks so much! 
I just tried running this on a medium-sized rails project, with limited success... The big issue is that due to gem dependencies, running `bundle update &lt;gemname&gt;` often results in nothing actually being updated! Your gem does not handle this gracefully, since it does not detect the fact that no gems were actually updated, re-runs the tests anyway, then "fails" at the command `git commit -m "Updating &lt;gemname&gt;"` because no files have been changed (and therefore nothing is staged for the commit). A simple improvement would be to detect when the `bundle update &lt;gemname&gt;` didn't update anything and handle the scenario gracefully. A full solution would presumably require resolving the dependency tree and actually determining a valid (incremental) sequence of steps to perform the upgrade ... but that could get very complicated! Also worth noting since I ran into this issue at first is that there was apparently [a bug in bundler](https://github.com/bundler/bundler/issues/4979) recently, whereby running `bundle outdated` was missing most gems from the list. If you hit this same issue, simply update your `bundler` gem before using this tool.
Related https://www.reddit.com/r/ruby/comments/5untux/ruby_code_i_no_longer_write/ ;)
I'd probably use a map for this, something like: class JSONHandler class StringHandler def call(value) # handle string end end class ArrayHandler def call(value) # handle array end end class HashHandler def call(value) # handle hash end end class GenericHandler def call(value) # handle other values end end TYPE_MAP = { String =&gt; StringHandler.new, Array =&gt; ArrayHandler.new, Hash =&gt; HashHandler.new }.freeze DEFAULT_HANDLER = GenericHandler.new def call(input) TYPE_MAP.fetch(input.class, DEFAULT_HANDLER).call(input) end end Also, you should prefer `public_send` over `send` when you know the method visibility will be public. [ROM](http://rom-rb.org)'s schemas could be useful here along with the [rom-json](https://github.com/rom-rb/rom-json) gem.
lol looks interesting :D but probably should be in /r/vim and not /r/ruby
That's just one course?
No, there are 5 different courses in there
Nice! Thanks a lot for the `gem update bundle`, I now have many more gems listed. Also, about `bundle update foo` not updating anything, I detect changes with `git status` (yes it's a quick hack), but in my case it worked and went from gem to gem much faster. My way to run it is to do a copy of the source's directory, change the database in the config/database.yml and let it run for hours, then look at the commits it produce, be impressed sometimes, put that in a pull request, get the CI's green checkmark, get it merged, smile :).
... and then people just "solve" the problem by not indenting at all. Seriously though, it's super hard to avoid deeply-indented code in some languages (cough Java, JavaScript). 
Not a problem in Python, I suppose. OR YOU'RE DOING IT WRONG, YOU NON-PYTHONIC MONSTER! Seriously though, I could see the justification for buying a super wide monitor just for J* coding...
Udemy is just the website with the courses
eh updating bundler seems to have done the trick
Ha, nice. I made something similar for performance shaming in Rails: https://github.com/foraker/look_of_performance I like the idea of a development environment that judges you at every opportunity.
nevermind, still failing when doing a deploy, heeeeelp
I would smack a coworker if they ever argued there was a reason to indent Ruby that much. Javascript on the other hand...
Not many people use them, but you could refine each of those objects. Per the [docs](https://docs.ruby-lang.org/en/2.4.0/syntax/refinements_rdoc.html): module ToJSON refine Integer do def to_json to_s end end refine Array do def to_json "[" + map { |i| i.to_json }.join(",") + "]" end end refine Hash do def to_json "{" + map { |k, v| k.to_s.dump + ":" + v.to_json }.join(",") + "}" end end end using ToJSON 
I think you can generally solve deeply indented code with more functions, even in Java, i.e. from if (foo) { if (bar) { do; some; stuff } } else { do; more; stuff } to if (foo) trueSide(bar) else falseSide() I am not sure it generally makes code more readable though. 
I don't see what the issue is. Each of these control blocks can and should go into separate functions. And that for loop shouldn't exist. 
Thank you for the comment, it sure is and I will add it to the list after reviewing it :)
Maybe don't test the implementation (websockets, ajax, etc.), test the result (something changes on the page): https://github.com/teamcapybara/capybara#asynchronous-javascript-ajax-and-friends If you really want to test if websockets work, you probably want to look into js unit testing (not rails/capybara).
If rubytogether's budget is paying the hosting costs for rubygems.org (I _think_ it is), then it is clear to me that it _ought_ to be part of their mission, if it's not it's a bug in their mission. (the fact I'm not sure says that rubytogether should advertise it better, if they _are_ paying for that. or what those hosting costs are hosting, in any event) I feel similarly about writing documentation and reports which help the ruby community understand what's going on and build shared understanding. I understand that management, bookkeeping, governance, and fundraising is not 'program costs'. But many of these things (especially bookkeeping) are necessarily a larger % for a small budget. It's just how it is. Those costs don't look unreasonable to me, is my whole point here. :) . But yeah, we only have broad categories, not details. I like your idea of including in the report what was accomplished in those 'overhead' areas too -- but my point is also that, assuming someone is getting paid to do that rather than volunteering, it actually _adds_ to overhead costs to make that reporting better. It might still be budget well spent. I'm not sure "% on program costs" is a valid metric in this case. 
Uhm there is something wrong in Italy...
&gt; If rubytogether's budget is paying the hosting costs for rubygems.org It does not. This was discussed in the update: &gt; First, the Bundler post-install message was unfortunately misleading some people into thinking that Ruby Together pays for the RubyGems.org servers, when that is not the case. Whether or not there's a single program expenses ratio which is appropriate for all nonprofits is pretty controversial, but 75% on program expenses is usually a good number. In any case, I think RubyTogether should talk about it's non-program expenses and justify them to the people paying for them.
This is awesome, thanks. Any reason it can't be made to work with any encoding ruby supports, not just unicode encodings?
To be honest my only experience of this is that every company I worked for in the bay area offered roughly 10% over my previous salary, which I gave them at their request, and nearly all of the companies I worked for discussed what could and couldn't be asked while checking references, and verifying previous salary could be asked. I have never been in the position of verifying a previous salary, because I don't work in HR or management, I'm an engineer.
Thanks! It could totally work with other encodings. And it should! I haven't done much research about other encodings, but I am curious to learn more about them. If someone wants to contribute one (or provide good instructions of how it works), I am happy to add it to the library.
Paraphrasing: &gt; best devs in the world make around, lead huge teams, take shit from senior executives You're describing a senior executive. If you're leading a huge team you don't have time to be a developer. In this position it is impossible to meet the needs of your people and have time to program. &gt; lead a large team, take shit from executives You're describing a manager to senior manager. It is unlikely you can meet the needs of your people and have time to program. &gt; leading a small team, take shit from executives This is a manager. It is possible you can meet the needs of your people and have time to program. I work for a San Francisco company and make more than your description of a manager (up to $180,000) and I am primarily a developer. I have 15 years of professional experience with ruby. I have dabbled in technical leadership wherein I don't deal with schedules or deciding deliverables outside their feasibility.
You should **never** volunteer your previous salary unless it's your dream job and there's absolutely no way around it. The only thing a potential employer is going to use it for is to figure out how little they can get away with paying you. There's no benefit to you from revealing this information. There's only two possible outcomes: 1. You make less than they think you're worth, so now they know they can get away with a lower offer and you'll probably still be happy. 2. You make more than they think your worth, in which case they are not hiring you because they don't think you'll be happy with what they can pay. It can be a really difficult question to dodge - recruiters have a lot of practice trying to extract this information from you. I usually go with something like, (as politely as a I can) "I fail to see why that's necessary, but my salary requirements are a fair market rate commensurate with my level of experience."
Yeah, this isn't true. I work with many engineers who make over $400k across salary, bonus, stock. I also make that much (but am a product manager). Those guys are not rails developers, though - most of them have PhDs from top programs and other impressive credentials plus plenty of experience building and launching incredibly impactful stuff.
I just added your binding.pry mapping to my vimrc, thanks. 
Definitely not average - but there are plenty. I find salary to be quite misleading in some of these things, since (for example) my stock is directly convertible into cash immediately. Therefore, it's max real take home pay per year. A top tier PhD also doesn't guarantee you high pay - a guy who sits near me probably nets 200 total with a UCLA PhD, but he hasn't had as much success as some other academics who are more suited to industry.
&gt; I find salary to be quite misleading in some of these things, since (for example) my stock is directly convertible into cash immediately. I'm assuming you work at Google, based on this detail. Maybe I'm wrong, but I wouldn't take that for the average. A lot of students/programmers want to work at Google. Most never even get an interview. So when assessing the salary that OP can expect or bargain for, I hardly think that is a good starting point.
yep, seems to be true, I was mistaken!
You're right, and I agree with you that it might not be a good starting point. However, the number is definitely much greater than 10-100 engineers. I also know that comp levels are similar at other top-tier companies for greater-than-sr-engineer types. Cheers!
He does bi weekly 1v1s and delegates code reviews to the app and web team leads. It works well IMO.
Hi! Thank you for your response! We have a lot of classes under modules, but our client doesn't want to use our classes with a lot of modules at the beginning. He wants to do: require "cherry/sdk/high_level" user = CherryUser.new (not Cherry::SDK::CherryUser.new) Also he doesn't want to use "include". So we can't offer him to use the following: require "cherry/sdk" include Cherry::SDK::HighLevel user = CherryUser.new card = CherryCard.new 
Beginner here. Why is it considered not good to use a debugger? I'm starting to become accustomed to using binding.pry and it's helping me a lot to understand what's failing.
I don't think you're doing anything wrong. A Ruby and Tk program shouldn't ever cause a segmentation fault like that, no matter how badly it is written. There is more likely some problem with your setup or how Ruby or Tk has been built or installed. Maybe run in a debugger (`lldb ~/.rbenv/versions/2.4.0/bin/ruby test.rb` and then `run`). But you'll get a native stack trace and if you aren't used to native code that might not help you.
 $ lldb ./ruby /tmp/test.rb (lldb) target create "./ruby" Current executable set to './ruby' (x86_64). (lldb) settings set -- target.run-args "/tmp/test.rb" (lldb) run Process 10228 launched: './ruby' (x86_64) Process 10228 stopped * thread #3: tid = 10232, 0x0000555555668a1f ruby`ruby__sfvwrite(fp=0x00007ffff307f730, uio=0x00007ffff307f110) + 15 at sprintf.c:1308, name = 'tk.rb:1243', stop reason = signal SIGSEGV: address access protected (fault address: 0x7ffff307eff8) frame #0: 0x0000555555668a1f ruby`ruby__sfvwrite(fp=0x00007ffff307f730, uio=0x00007ffff307f110) + 15 at sprintf.c:1308 1305 1306 static int 1307 ruby__sfvwrite(register rb_printf_buffer *fp, register struct __suio *uio) -&gt; 1308 { 1309 struct __siov *iov; 1310 VALUE result = (VALUE)fp-&gt;_bf._base; 1311 char *buf = (char*)fp-&gt;_p; Well... no idea what to do :D 
Can you get a backtrace (`bt`)? And at that point I'd say open a bug against MRI or the Tk gem - probably the Tk gem and they can redirect you to MRI if they're sure it's not their fault.
Why not?
Thank you for your suggestion. Could you please describe a little bit more. Will be nice to see execution flow on very simple example. Like getting glide_ratio chart line: presenter = TrackPresenter.new(track, range, units_converter) presenter.glide_ratio_chart_line -&gt; points (query points, additional processing, memorize) -&gt; map points to array of [time, value] I'm worry about Sandi Metz's guideline that controller should share no more than 1 ivar, Law of Demeter (if I'll use delegation I'll simply hide violation of this)
Yeah... you don't have to be so nice to me ;) I have pretty thick skin. &amp;nbsp; I am thinking in terms of Sandi Metz' restatement of "A class should do the smallest possible useful thing." &amp;nbsp; "Tightly Coupled" has bitten me many times as well... your code is good looking code that uses the core of ruby better than most, but it requires the reader to keep quite a bit in their mind at one time. The maxim Sandi talks about here addresses that. &amp;nbsp; If you are doing the refactor because you are just wanting to get better at refactoring, I would [refresh on this.](https://gist.github.com/speric/31ae0987d21eac1d4f87) &amp;nbsp; If you are the only one looking at the code, and it works well, and you are unlikely going to need to change it... I would leave it.
You're in some kind of infinite trying to handle an exception. Could be an MRI bug then yes, since I don't see any Tk C frames.
petit - a simple, fast, rack-based url shortening server en_route - A a small off-side langauge that compiles into the routes.rb file for Rails 3 The rest of the words in the title are up for grabs... except Ruby.
(Software Engineer in test for 15+ years now) I personally would write test automation code in ruby for everything given the other factors fell into place. First I'm assuming that your web testing is of RESTful web services. I would ask how much the application developers will be contributing to the end-to-end test suite. If you don't have a solid promise that developers will be the ones writing the tests and you'll be doing the work to support and enhance the test automation framework, I don't see any reason that the application code would dictate the end-to-end framework's language. An advantage that is not capitalized on is not an advantage. Except if the end-to-end suite was going to be embedded in the project. I had this with a ruby on rails application I worked on, it was amazing to have application code, unit tests, and end-to-end tests all together in the same branch. It really made for a smooth feature development cycle. So if you are going to do everything in the same language, everything in the same repo, then it may be worth the language change. Ruby is very fast to develop code in. Add in that test code rarely has performance requirements that exceed Ruby's abilities and you have a good match between time to create and time to execute. Also, being interpreted means you can break right where an error occurs in a test and you can then use pry or various interactive debugging tools to play with the problem right there where it is happening. There may be tools to do such a thing in the java world, but it's part of Ruby's nature, it's not something being strapped in.
The only thing u can do in this case is create the classes he wants and include the modules for him. So he can use the top level classes only 
I'm doing refactoring because I've faced difficulties on extending this class and classes that inherited from it. I've deferred this refactoring long time and live with "F" on only this file https://codeclimate.com/github/skyderby/skyderby/app/models/tracks/base_presenter.rb And as I needed to change it once again I decided to make it extendable in the future. Link is very useful. Thank you.
Than. 10k deduction.
I'm not sure on how exactly they source their database. :/ I know they're looking at OSVDB, but I'm not sure where else. I also don't think they're actively researching for new vulns. In this case, that's how the vuln was discovered: the research team at Snyk discovered and disclosed the issue to the Nokogiri maintainers. 
Do you think I have to pass points array to MaxGlideRatioPresenter, do max_by within MaxGlideRatioPresenter and format result? I'm not sure about it, but I do not see where to put finding max glide ratio
If you think of it as: class RunPresenter def initialize(track, metrics) # stuff here end def max_glide_ratio MaxGlideRatioPresenter.new.call(@points) end end I think it's reasonable to do the max_by inside the glide ratio presenter since that's part of the name... :)
 def myfunction(a) a&gt;4 end or even def myfunction(a) a&gt;4 end This works because `a&gt;4` evaluates to `true` or `false`, the `if` statement is therefore redundant. It does assume that the person marking the question understands Ruby fairly well, and isn't just comparing your answer to a pre-written one.
Your answer is basically accurate (and certainly should be accurate enough for a customer service position). Angular is a client side framework, and is well suited for developing Single Page Apps, the classic example of which is usually something like GMail. One of the most common ways Angular gets its data is in the form of JSON files, so an application could be set up to use Rails on the back end to talk to a relational database and do nothing more than serve JSON data to an Angular app which is driving the front end.
I love it when y'all do homework for folks.
Bit is language agnostic, and uses drivers to work with different languages. We wrote the JS ourselves, and now thinking of Ruby..
Very nice write up. The fact that rails has acknowledged the JavaScript's Magic Bullet world really makes me think if i should just already face the 'thing' already and get it over with because in a sink or swim scenario, if you (or i) don't you will sink.
What do you mean? 
Eat the F'ing JS fatigue pill and buy into the npm/webpack/react/4millonOtherLibraries story
That ship sailed a long time ago. There's no getting around it in modern development. Learn JS properly first. It'll take you far. I recommend the You Don't know JS series. 
Why do you think I only ask one question in an interview? 
Look I've interviewed 200+ candidates over my career and hired 30 or so. And I have tried many approaches. There is no one way to interview people, but some methods give better results. Many places like Google, Amazon, etc. use this style of interviewing because it works. People can disagree, but unless they have done much interviewing they do not really know. &gt; Here's a coding problem, talk me through the approach you'd take to solving it. Just roughly, I want to get a sense of your logistical skills here. How do you attack it? What if I gave this problem? Write a function that repeatedly steps through a list, compares each pair of adjacent items and swaps them if they are in the wrong order. Repeat until no swaps are needed. That is dead simple. It is taught in high school classes. It is bubble sort. I think a junior programmer should be able to do that and many cannot. If someone can't do this or doesn't want to, that is fine. Someone may hire them, but it won't be Pied Piper. The interview is not nearly as dramatic as you make it out to be. It is two people in a room talking about code. Asking someone to write code is a reasonable thing to do. Interviewing is stressful, but most people loose their jitters, once they start talking about something that interests them. Being interviewed is a skill. It can be practiced and if someone is overcome with anxiety about it, they may want to talk to a professional about it. There are techniques and medications which can help. Btw. I didn't downvote. I welcome the comments. 
The first advice is to use @instance variables directly as opposed to using methods defined with `attr_*`. This is the exact opposite of what Sandi Metz insists on in POODR. I'm a bit torn between the two alternatives. On the one hand, using `attr_reader` increases the object's public interface, and they are a pain (see the Note below) to make private (as the article demonstrates, `ruby -w` will even give you a warning if you try to make these private). So, I'm all for the *"...beautiful and minimal simplicity in using ivars directly..."* as the author puts it. On the other hand, Sandi Metz make some pretty strong points for what she calls "hiding data" (even from the class itself), of which using `attr_reader` in favor of ivars is one of the techniques. What do you think? [Note] What I mean is that to make them private, you would usually want to move `attr_reader` to the bottom of the class, below `private`. I like how in recent Ruby you can do `private def`, but you still cannot do `private attr_reader`, bummer.
I don't think, and did not suggest, that bubble-sort needs to be broken into chunks. Reading comprehension. I said that logisitics-communication-performance-drawing-algorithms-coding-coping-with-stress should be broken into chunks. Absolutely have them implement bubble sort. Absolutely have them draw on a whiteboard. Absolutely talk to them and gauge their level of basic clue and problem-solving skills. I'm just suggesting that those should be separate activities, so that you can assess them independently, and so that the generally stressful nature of interview conditions doesn't impact the whole stack together. 
Bubble-sort is too small and simple for that to be a good test at the vague-outlining level - that's why you'd inversely scale the size to the specificity. I'd start with something a fair bit chunkier with the just-talking step, a moderately-complex one for diagramming, and sure, bubble-sort, why not, for the actual coding part - but in a sane coding environment, without someone breathing down their neck. It absolutely is dead-simple, and any coder (assuming they know what it is) should be able to whip it up in a few minutes. However, testing it under artificially-difficult conditions is doing three or four tests at once; the fact that someone produces [JobInterviewQuickSort()](https://xkcd.com/1185/) on a whiteboard while being stared at says very close to fuck-all about their actual ability. 
People looking at me is fine; people staring at me while I'm trying to concentrate on details is going to be supremely unhelpful, especially in the rather hostile context of a job interview. And I'd expect that for how-to-attack-problems phase, you'd want a problem in more parts than that - there's barely enough to talk about there. &gt; Well, I'd gets() a line from stdin, chomp the trailing newline, split it on whitespace, map to to_i, getting me an array of ints. &gt; Then I'd iterate - starting at 1 so we have an offset - up to the length of the array, compare arr[i] with arr[i-1]. &gt; If they're out of order, I set a flag to true, (which I'd cleared at the start of the loop) and swap the two values. &gt;I wrap that loop in a do..while(flag) loop, and that's pretty much it. Uhhh... obviously trap errors like non-numeric values when you map them to int, &lt;2 items, etc. There's just not enough to go on there, at that level of complexity; the interviewee is going to have to pad with a bunch of useless details (like splitting and chomping) just to have something to say. At that level, I'd want something bigger-picture with several subtasks, to see if they can break it into manageable chunks. And like I say, I do want to see if they can code to a given algorithm, but that's a separate question. 
What are the benefits of this over say Github gists? 
I've got question according to webpack and react if now its supported by new rails is it worth to use react_on_rails gem? What's the difference?
May I ask you one more question? I've recently read about facade pattern and I think it can be useful for such cases where I need to fetch additional info, do some calculations and so on. And using this approach presenters will be responsible for formatting and presenting. As a drawback I see one more layer of abstraction, but my hobby project grew enough for it (as I think). What you think about it?
There is a good chance that you can actually have both: use [JRuby](http://jruby.org/). That way you can access all Java code, Java frameworks, execute JUnit tests etc., have real concurrent threads and can keep Ruby for your everyday and / or gluing code work.
I feel like that use case presented in the beginning would benefit way more from default values in the constructor than a messy prototyping system.
&gt; RubyForge Could Not Connect to Database: 
Check out [Shoes](http://shoesrb.com).
I think trying to apply two patterns at the same time is probably going to lead to problems long term. It's more important to figure out what API (public methods) you want for the object and see if that means you need multiple objects or not.
&gt; !p that's cool, now I'm interested too, I hope someone will post something
Pull requests accepted!
The default values differ as well and are dynamic.
That's not even half a year then. TK is old. Not much to change?
Oh i get it. I assume that all helpers to use in views are available too?
Hear, hear. What makes it worse is that companies frequently install "hands-off" managers that sort of just drive the bus. They believe this will make the programmers happy, i.e. "I'll stay out of your way and let you do what you do best." No real professional development happens in that kind of structure. I want my annual performance review to be given by someone who was qualified to set up a plan for how I am to grow as an individual contributor. I want to learn new things and be mentored, even though I've been doing this professionally for over a decade.
There's been some talks about ruby trivia on Berlin's ruby usergroup from sferik. Find the slides here: https://speakerdeck.com/sferik/ruby-trivia
Also: http://www.codequizzes.com/ruby
Micro optimizations does not worth it, since they are always dependent on particular ruby version. Often it's better to chose readable code, than fast one.
I wouldn't consider it dead, but a pain to work with. For me, I compile Ruby from source, despite what everyone says about using rbenv, or rvm, or chruby, or uru or .... One of the pains I discovered in my travels was that ruby's support for tk depended upon ActiveTCL beign installed on the system. Windows comes with it pre-bundled together, God bless them. However, on Linux, by default without modifying a bunch of stuff, need ActiveTCL installed and in your path so that the compilation process could link those headers. 
Yeah, pry-byebug uses byebug as it's debugger, while still having the awesome repl-stuff from pry itself. That can of course be a part of what his `binding.pry` does in the article, just meant to point out that just pry is not really a debugger.
i don't mean to be a PC police but this is a rather loaded question you're asking. I've seen someone break into tears when her teacher asked her if she was a good writer, because the implication of that question was that she wasn't. You say the interviewer should be communicative and open to answer questions, but that 1 to 2 sentences is all it should take to explain bubble sort. Realistically, if they're at this level then they can already do a whole slew of algorithms. So bubble sort is being used as a metaphor for a whole algorithm curriculum. There is a broad consensus that this stuff isn't used much on the job. I don't mean creative problem solving or communication or whatever; I mean the specific problems like bubble sort. When there's this whole curriculum that's not really used in practice, it feels like a standardized test. By the way, like I said bubble sort is being used as a metaphor. So to say "oh but bubble sort is so easy" is missing the point. If they expect the candidate to solve the problem after 1-2 sentences of instruction, then they are actually not being a helpful interviewer. If they gave pseudocode for bubble sort, that'd be a different story, but I suspect that might not appease the puzzlemaster spirit of some interviewers. 
You can reuse Bit component across repos. No copy-pasting. Also, it takes care of management (versioning, dependencies etc) and even CI. It allows you to extract components with very low overhead (configs etc) and use it anywhere.
&gt; at the very least, RubyTogether could dedicate a section of their monthly report to what spending in these categories actually accomplished, like they do for each OSS project they work on. This is a great idea.
Nice one. My observations are that many ruby devs see Elixir as the next step of their professional development.
got dammit. i knew pied piper was from silicon valley i just assumed it was based on this guys company or something. i was gonna say something but thought that would be too low of a blow. ffs, talk about uncanny parody. 
You clearly have not watched Silicon Valley or you would have known my question was sarcastic. u/jaredcwhite seems to have difficulty understanding what I am saying. I am not sure how I could be much clearer. And I am probably wasting my time, but here is summation: r/ruby: but I don't need to know how to program bubble sort to do my job me: yes, I know. I am asking about bubble sort b/c it is a good way to see if you can write simple code u/jaredcwhite: but I don't need to know how to program bubble sort to do my job me: [facepalm] reading comprehension?
Give me a job
I used SDL once and wrote everything I needed from scratch after trying tk and shoes, but that was for a game, and ruby bindings for SDL are also very outdated. Isn't there some kind of html-based UI building tool?
&gt;The whiteboard hate is bit silly. Most companies use whiteboards. You can use it to brainstorm, design systems, write code, make lists. It is a blank slate. We designed our “middle-out compression” algo on one. If the thought of standing in front of your peers and putting things on a whiteboard freaks you out, get over yourself. Even shy Richard can do it. Buy a whiteboard and practice. Why ask me to write out code on whiteboard when you could ask me to write it on a laptop instead? I don't get this interviewer fetish with having people write out lines of code and syntax using a tool uniquely unsuited to that task. I don't give a fuck about people seeing me write code and I'm happy to talk through each line as a write it, but why the fuck with a marker on a whiteboard?
If you are using https://github.com/rubyide/vscode-ruby then look at the autocomplete instructions. gem install rcodetools 
Is there any way to figure out how to use libui-ruby, without learning C and learning libui in C first?
Yes, not using ivars directly has many benefits, but increasing the API surface area of a class is the price you pay. This may make refactoring *harder* since now you have to make sure no other classes use the accessors you want to change, since they are public by default. And making them private is not pretty. Therein lies my [dilemma](https://en.wikipedia.org/wiki/Dilemma).
Thanks for the link to the feature request. It looks like the discussion got side-tracked into supporting array argument to `private`, and then ended up going nowhere. It's been 2 years since, so it's unlikely we'll ever get this feature. This is very unfortunate, because as it stands, Ruby is not consistent and violates its own principle of least surprise: defining methods using `def` returns a symbol that can be passed to `private`, but defining methods with `attr_*` returns `nil`. All I can say to that, is WTF! In what universe does that make any sense? This is a bug in Ruby, and it should be fixed.
Yes and no. There are two Ruby examples, and you can see that the Ruby binding is quite a direct translation from the C library. Given that direct correspondence, you should be able to read the C examples as well and translate them to Ruby without needing to actually know C. On the other hand, it would help if you'd have done something similar before. I was eying this library to create another, more Rubyesque layer on top of it. But I haven't had the time yet. Too many projects :-)
Probably, yes. However, building that abstraction layer yourself is a great way to construct (literally! :-) your understanding of the underlying library. I like to use it as a learning strategy, but the output might be less suited for consumption than a set of well worked-out examples and references.
Pretty nice to see a common use case cause change in a language. I intuitively .map most calls that return arrays to do whatever mutation I likely need on the spot if possible, but this is a good change.
&gt; Why take risks with open source Ruby and community support? 😒
Isn't that kind of an anti-pattern in the ruby community? It seems like there is a lot of emphasis to stay uptodate with current libs.
More ammo is exactly what I need :-) Thanks for the constructive and detailed reply sn1de. I wasn't aware Groovy has smaller community. I was sure it's pretty popular. Also - I was hopping the syntax is close enough to not be divergent from the develop team? Well, it's -almost- a green field decision. Because the technology changes so dramatically (and the type of tests) - that most of the stack will have to be written with a fresh set of tools. But indeed the biggest issue is to train a team of Ruby developers to write "proper" Groovy/Java/Scala code. If I had problems to do the switch from C# to Ruby, I guess the other way around is also quite painful (if not more). Your final sentence really hit the mark. The reason management want everyone to use the same language is collaboration, or mainly because there currently there is not much of collaboration. Much as you, I doubt it will chance. People that want and enjoy solving problems, will do so whatever the language is Ruby or not. In you own opinion, is there any "technical" reason why to stay with Ruby? (like meta-programming for example). 
Got it. That's an interesting one...
It is so that when your manager says: "You can't use open source language x to develop the system because there is no support" you can answer that you can buy support. From ActiveState. 
Yes and no. Making them private is currently cumbersome and/or not DRY. I like my code DRY and not cumbersome. Also, making them private generates a warning from Ruby. I treat warnings as errors in my code, so that's unacceptable.
How are they not DRY and cumbersome? 
100% agreed. I used to *love* Komodo. 10+ years ago, if you wanted a nice IDE for Perl, Python, Ruby and a few other languages, they had zero competition. I used Komodo on Windows, Solaris and Linux and it was solid. Fast forward to a 2014 or so. . . I downloaded Komodo but found it to be much more jenky than I'd remembered and I finally gave up when I couldn't get my non-default (emacs) key bindings to work. I've always used emacs for small stuff but not I use the IntelliJ stack for my IDE needs - I've used it with Java, Ruby, Python and Go and it's great.
Yes, it's a real turn-off, what happened to them?
This is true. And you know what, it's not wrong for management to want that, either. If a company puts months or years or people-hours into an application, that is easily hundreds of thousands of dollars worth investment. It is right for them to want some kind of assurance there, even if it seems a little silly to us developers.
I'm sorry but how is putting them in a private section cumbersome? I thought you had some arguments, but it seems to me like you have too much free time on your hands and spend it on whining on the internet. 
Hello, This is how I would write it, if you have any question don't hesitate. # Use constants instead of instance variables VOWELS = %w(a e i o u) CONSONANTS = ('a'..'z').to_a - VOWELS def next_letter(letter) letter_group = VOWELS.include?(letter) ? VOWELS : CONSONANTS letter_group[(letter_group.index(letter) + 1) % letter_group.size] end def transform_name(name) name.chars.map { |char| next_letter(char) }.join.capitalize end def alias_manager(full_name) full_name .downcase .split(' ') .map { |name| transform_name(name) } .join(' ') end 
Man... this is 100 times cleaner and better, idk how I would've come up with it on my own. Much appreciated though! 
"Miles O'Brian" Ruby has a lot of functions built into the array and string classes - rotate would work and 'aeiou' becomes 'eioua' ... also as I mention, be careful about sloppy understanding regarding requirements...
rotate - https://ruby-doc.org/core-2.2.0/Array.html#method-i-rotate
The vowels and consonants variables should be Constants (not instance variables), as they do not change while the program is executing. Check out Statyx's answer for reference. 
I have come up with something like this. Maybe someone will like it more. example = "Felicia Torres" names = example.downcase.split(' ').reverse names.each do |name| name.tr!('aeiou', 'eioua') name.gsub!(/[^aeiou]/) do |c| loop do c.next! break c if c =~ /[^aeiou]/ end end end puts names.map(&amp;:capitalize).join(' ')
Did you forget to swap first and last name or am I missing something? I think you need a .reverse before the .join at the end.
I would add as a specific first step, start looking at "while" as a code smell (when used as in this example). There's almost always something more elegant you could do with an [Enumerable](http://apidock.com/ruby/Enumerable) method like #map, #reduce, #inject, etc.
I'm not disagreeing with you but learning not to re-implement the wheel is an important part of learning how to program as well. 
Reading ops message and all the comments has been very instructive. I wish there were more posts like this.
http://www.fxruby.org/downloads.html
Sure, I'm not saying they don't have a business case, they do, but I found the language somehow abrasive, it rubbed me the wrong way, that's all.
Ahh, I see, you're just here to offend, welcome!
Hey I recognize that problem! How's phase 0 going? Anyways, here's how I did it. # Fake name function: # Get real name # Split by first and last name # Translate vowels to next vowel # Translate consonants to next consonant # Return new name def fake_name(name) name = name.split.rotate name.map! do |n| n.downcase! vowels = 'aeiou' vowels_shifted = vowels.split('').rotate.join consonants = 'bcdfghjklmnpqrstvwxyz' consonants_shifted = consonants.split('').rotate.join n.tr!(vowels, vowels_shifted) n.tr!(consonants, consonants_shifted) n = n.split('') n[0] = n[0].upcase n = n.join end name = name.join(' ') end # puts "Felicia Torres is #{fake_name('Felicia Torres')}" input = '' names = [] puts "What name would you like to decode? Enter 'quit' to exit" while input = gets.chomp do break if input == 'quit' secret = { decoded_name: input, encoded_name: fake_name(input) } names.push(secret) end names.each do |name| puts "#{name[:encoded_name]} is actually #{name[:decoded_name]}" end
&gt; Julia Torres Can you explain ?a..?z. Does this avoid instantiating the 'a' and 'z' string objects? 
Read up on functional programming, that's what most of this solution is
I also recommend giving elixir a try. It forces you to think functionally and that translates well to other languages.
Instead of `letter_group[(letter_group.index(letter) + 1) % letter_group.size]` you can use `letter_group.rotate[letter_group.index(letter)]` :)
 class String VOWELS = %w(a e i o u).freeze CONSONANTS = (('a'..'z').to_a - VOWELS).freeze def to_spy self.downcase.split(' ').reverse.map(&amp;:fakeify).join(' ') end def fakeify self.chars.map(&amp;:next).join.capitalize end def capitalize head, *tail = self.chars (tail.unshift head.upcase).join end def next if VOWELS.include? self VOWELS[(VOWELS.index(self) + 1) % VOWELS.length] elsif CONSONANTS.include? self CONSONANTS[(CONSONANTS.index(self) + 1) % CONSONANTS.length] end end end 'Felicia Torres'.to_spy 
?a is identical to 'a', no advantage really. I have a tendency to use it to signal that I'm dealing with single characters, but there is no performance gain or anything.
TIL rotate, thanks
 def alias_manager(full_name) build_char_map unless @char_map full_name.chars.map { |c| @char_map.fetch(c, c) }.join end def add_to_map(arr) arr.each do |k ,v| @char_map[k] = v @char_map[k.upcase] = v.upcase end end def build_char_map @char_map = {} add_to_map CONSONANTS.zip(CONSONANTS.rotate) add_to_map VOWELS.zip(VOWELS.rotate) end
Well, in this case: CHAR_MAP = CONSONANTS.zip(CONSONANTS.rotate).to_h.merge(VOWELS.zip(VOWELS.rotate).to_h) 
That emphasis is in part _because_ older versions are not supported, the ruby community has chosen to prioritize innovation over backwards compat, requiring lots of treadmill time to stay up to date lest you be left behind. I would still see this as a last resort, but I've been in situations where it was really infeasible to get off the old versions of ruby/rails any time soon, and perhaps the last resort would be helpful. 
&gt; First, let’s discuss the five practical Ruby on Rails projects you’ll ever be tasked to build ...because all SaaS projects are essentially exactly the same thing. Check.
&gt; Is there any difference between the two except that JRuby runs on JVM? JRuby uses real native threads and does not have GIL. Of course there are other differences as well, but I am not a good source of a comprehensive list. &gt; can you still use REPLS like pry and such on run-time? I'd guess so but haven't done myself.
this is literally the worst thing I've seen submitted to this sub ever. 
Well, presuming that you're going to be adding arguments indefinitely is a mistake. Be economical with method arguments -- the more you need, the more cumbersome the method is to use (and the more likely that your design is off). Consider, also, with a double splat, an argument error will not be raised if an argument name has changed or was misspelled. That's just setting yourself up for a nasty debugging session.
Thank you, will do some more self research about it soon :)
First off, thank you for introducing the concept of keyword arguments to me! I've been doing this for over a year now, and somehow am only hearing about them just now? Now, let me address your point: &gt; Let's say I have a class A that instantiates another class B... However imagine that there's new requirements and there's a need for more arguments... We would now need to change B as well. Writing classes that depend so heavily on each other's implementation is a sign of a poor grasp of OOP. Sandi Metz explains this in remarkably accessible terms in her book, _Practical Object-Oriented Design in Ruby,_ and I strongly recommend you add it to the top of your current reading list. In it, her introductory argument echoes the concern you've expressed – that it's not really so hard to create an application that meets your needs today, but making software that you can maintain and evolve for your future needs takes a ton of insight and strong design principles. This is the fundamental value proposition of OOP and the central problem that it was introduced to solve. To fulfill this potential, you must design objects that are small and uncomplicated and know as little about each other as possible. Read it! It will change the way you understand the programs you create, and help you spot poor design in other people's programs that you might otherwise simply not understand and then mistakenly emulate.
I gave a talk about this subject at the last rubyconf: https://www.youtube.com/watch?v=4e-_bbFjPRg There is a great deal to say about this — more than you probably think right now.
Nope, code smell. None of these are better than any of the others, at least not how you're doing it. Keyword args have nothing to do with why you would use a splat operator, and if you have a problem that makes you think they do it means you're structuring something wrong. Keyword args compete with named args. I think they're overkill but in the specific case where it would be easy to confuse the order of entering the args they can save some careless errors. But otherwise named args are a lot simpler to me, and out of order args is almost never the source of a bug for me. And double splat compete with an options hash. And quite frankly the double splat is only useful because of Rails. Because when you're metaprogramming classes you have a ton of methods def foo(*args) options = extract_options(args) #... end vs def foo(*args, **options) #... end It just saves some boilerplate, which is useful since metaprogramming is one of Ruby's big advantages. And "programmer happiness" is a core motivator for Ruby development, so even though it would normally be overkill it's a good idea for this case. Based on what you're describing you shouldn't have methods or classes which require an ever expanding list of args. People definitely cargo cult about Sandi Metz, but this sounds like a classic case for her. Try to limit yourself to 4 arguments, keyword or otherwise, and options in an options hash are arguments. If you cant instantiate your class with 4 args chances are your class is doing too many things and should be two separate classes. By forcing yourself to adhere to this plus the 5 lines limits your classes will be forced to be more single purpose, and methods clearer. I see some of this you've addressed to someone else "sometimes the world is not perfect and we really do need a dependency." I've been there many times, but if you're at the stage where you're posting on reddit asking advice on the number of args to use you're not facing a problem of sufficient complexity to require that. Put in the work, you'll see that the problem you think requires this is actually composed of a few smaller problems. And learning how to decompose your problem into smaller ones will make you a better programmer.
AWESOME... I would just add &amp;nbsp; original = "aeioubcdfghjklmnpqrstvwxyzAEIOUBCDFGHJKLMNPQRSTVWXYZ" &amp;nbsp; replaced = original.split('').rotate.join &amp;nbsp; as a way to DRY up the code a bit... personally... I like just using the strings as you did, but some would prefer this... 
Maybe start by writing some tests that describe the behavior you're looking for.
Hi, I've found the problem. abunds.combination(2) {|x| ab_sums &lt;&lt; x.inject(0){|sum, num| sum+num}} It does not return every possible sum. What you are doing abunds array is, you take every pair of two and add them and add them to ab_sumbs. What you should be doing: abunds.each do |ab| abunds.each do |ab2| ab_sums &lt;&lt; ab + ab2 end end You need every scenario, that means add first with 3rd abund number, etc. You may also want to change your code like that, so you are sure there are no duplicate elements. (That's not the case in this example anyway.) non_abs = (1..28123).to_a - ab_sums.uniq!
I don't really get this. Maybe mrjargo, or maybe other people who upvoted this post, can explain it to me. Ok, I get microservices. I kind of get this function-as-a-service approach too, and making microservices as small as a single function. I also get the value of hosting code for you. But StdLib seems to be some kind of code network (not sure if that's the right name) which allows you to easily call other pieces of code by name and maybe version number. StdLib also provides a platform for distributing pieces of code. What exactly is the value of this? Do people write actual apps this way? I thought the idea behind microservices is to split code up in multiple teams. Each team has ownership on their set of microservices, and can write their services in whatever language/framework/approach they want, so that dev teams in big organizations don't all contend in a single monolithic codebase written in a single language. This means that different services can have different access methods (although in practice it's mostly HTTP). StdLib seems to go against this idea by standardizing on the access method, as well as standardizing on the execution environment (instead of letting devs pick whatever framework they like). I am also confused about the performance characteristics. Theoretically, splitting up code in as many pieces as possible in a horizontal manner, and scaling each one individually, is good for scalability. But if you have *too many* pieces that interact with each other over the network (as opposed to a local, in-memory procedure call) then that introduces a very large constant overhead for each call. So there is such a thing as having too many microservices. It seems that with StdLib you turn each and every function call into a remote procedure call. Do people not see the problem with this? Anyway, my intention is not to criticize StdLib. I sincerely hope that someone can explain to me what I'm overlooking.
Security is one of the few areas where its important to vet the qualifications of the gem author and definitely avoid code by randos. So who are you and why should we trust your code?
And that's fair, but talking about the alternatives as though they're worlds away from that is hyperbolic. Just do this: class Foo private attr_accessor :private_data public ... end Yeah, you have to put it on another line, and that's a *tiny* bit of a pain. You're not wrong, you're just being over the top about it.
Also, if you think it's something that deserves to be considered more fully, then push for that to happen. Moaning about it on reddit is purely negative. [Here's the pull request](https://github.com/ruby/ruby/pull/517) from a few years ago. I don't know enough C to be useful, but you could at the very least add a comment requesting that the change be implemented.
I think at its heart, the idea is a good one. It allows microservices to be thought of in a way that is similar computer chips -- need an accounting system? Download a microservice and deploy it in your infrastructure, or integrate your code with a component already hosted elsewhere. It's not unlike pulling the source code for an ethernet chipset from opencores.org. I haven't looked too deeply yet at Stdlibs, but I sense the problem with this particular implementation is that it presumes that HTTP APIs are the interchange format between the microservice and the rest of the world. This brings two yuge downsides: 1. HTTP calls can fail. Thus, you have to handle failure all over the place. 2. You can't easily merge its authoritative data with all of _your_ data you have associated with it, so writing queries for displaying data becomes problematic. You have to perform HTTP queries to get the data, and then "mesh" it with the rest of your data manually. Service boundaries drawn with HTTP APIs always have these problems. What I think would be a lot _more_ valuable is a collection of microservices with more loosely coupled interfaces. For instance, a microservice could receive command messages over a queue (i.e. "deposit $100 into account 123), and emit events over a pub/sub system (i.e. "for anyone interested, $100 was just deposited into account 123"). This kind of messaging can be a lot more durable than HTTP, which solves the first problem. It also solves the second problem as those events can be easily consumed by a subscriber and used to update a view database that may also include data sourced from your own services or other components. I'm biased, of course. I am a huge fan of evented microservice architectures, to the point that I'm preparing training materials &amp; conference talks that educate and advocate for the approach.
What'd you move to?
`thin` and not (yet) looked back
A good example of when "parameter objects" starts to make sense: a gateway object that interacts with a remote HTTP service, whose web request requires 25 different values to be POSTed. You will want to define a data structure to contain all the data. You can't reduce the amount of data that has to enter the gateway object because you don't control the API. Also, I agree about using positional arguments for required values, and keyword arguments for optional ones.
Hello! Thank you for the help, that was where the problem was. Unfortunately those loops were taking too long to run. I eventually figured out a way. This is what I did: abunds.repeated_combination(2) {|x| ab_sums &lt;&lt; x.inject(:+)} By using repeated_combination, it also gave me 1+1, 2+2, and so on. Thanks again! 
No one is excited about this? I'm excited about this.
Great post. I spend a lot of time polishing my own projects. Usually it's: 1. Have an idea, or why doesn't this exist, or shouldn't this work better? 2. Spike! 3. Did I get the big idea right? 4. Refactor: Keep it light, minimal, composable, and reusable 5. Polish In terms of commit count, (5) tends to be 75% or so.
Wow. That's cool! I was looking for some method like #repeated_combination, but couldn't find it at that time. Glad you did it :) 
https://bugs.ruby-lang.org/issues/9453 has been rejected for no good reason as far as I can tell, hence my "outrage". I have added my comment there in support of that issue. On a "meta" level, I must note that I am not "moaning", "whining" or whatever else I have been called in this thread for supporting a potentially easier way to create private accessors without having to jump through hoops (a way that preserves locality, is more friendly to git merging/rebasing, consistent with the changes that have been made to `def` in Ruby 2.1, etc.) Honestly it's become tiresome posting here with all the patronizing. (Is this entitlement to patronize by default because of the influx of new people? I have been doing Ruby professionally for over 12 years, so believe me, I know every way to make a `private` method, I don't need to be taught the trivia of the language, and then told to stop bitching about it in so many words). It's sad, really.
Not sure if this existed before -- haven't checked in a while. Anyone using this already? I'm curious if they support multiple processes (e.g., web + worker) and so on that we've grown accustomed to from Heroku and the like.
&gt; Now, I will say this — if you goal is to provide absolutely unbreakable encryption, then this gem is likely not for you. This seems rather incongruous with bragging about using "the cipher used by the US Government". But given their current state, perhaps that's meant as a warning :) I expect ActiveSupport::MessageEncryptor will be your first choice, since it doesn't require any extra dependencies. As a demo of using it with AES-128-GCM, [this Rails merge is an example of real world use](https://github.com/rails/rails/pull/28139/commits/6aa6f9ae44ed999e972a58f729bdc5b2fcdc127b#diff-bd3587684013cd6ff722fc8118d4bc22). Another thing I noticed is that you're using `Timeout`. [Try very hard not to do that](https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts), because it's [awful](http://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/).
Thank you, that was a great hint! I will look into this lib and see if I can default to it, and yet offer a choice to the user which cipher to use. What's funny is that the author of the C-version is Daniel Bornstein, who I remember very very well from my days building one of the largest email delivery systems in the world. We used *qmail* — another project he wrote, which was completely unreadable code. Possibly deliberately, but we never found out. We meticulously split it up into small libraries, but that experience left a sour taste in my mouth, so to speak. I still have enormous respect for the guy, though. K
All great advice — adding to the issues on github. Thanks so much!
I've used app engine heavily, but not heroku, so I don't know what you mean by "multiple processes". App Engine will auto scale your ruby app to many processes, and you can run background tasks on these processes, does that cover the use case you were thinking of? Edit: btw, this ruby runtime just came out of beta so I haven't used it before, but i've used many of the other runtimes. My company doesn't let us use anything that is in beta, but we will certainly start using it now. 
i was thinking more in terms of launch two different applications (web app + worker app) on the same instance. Heroku offers you to specify your processes in a `Procfile`. I was wondering if the yaml file that google app engine expects allows for the same.
you can create a different module (that's an app engine term, not a ruby module) that has different code (even a different language), but app engine is about running HTTP services so I haven't had too many cases where I'd want to split it out into two different apps. I'm still not sure if I'm understanding the heroku use case. What do you use it for?
got it -- thanks!
i'm almost dead from holding my breath until AWS Lambda supports Ruby.
Thanks for the reply. So you are making it easier to write microservices by giving developers a framework that more resembles how monoliths work, right? This idea makes sense, but I'm curious: does it solve a pain point that people actually have? I know that microservices are so hot these days that a lot of people are starting their projects with a microservices architecture, instead of starting with a monolith and splitting it up later. Are you targeting primarily these people? How much demand is there for something like this? Your DNA sequencing parallelization example is a good case study. The algorithm has many obvious points that are eligible for parallelization, and parallelizing them over a cluster of computers makes a lot of sense. Setting up something like Hadoop for map-reduce sounds a lot more complicated than just provisioning a bunch of FaaS servers, upload your code to the FaaS cluster and have the parallelization done "automatically" for you. This is obviously a good use case, but I'm not worried about cases like these. I'm worried about people taking the FaaS concept too far, thinking that "more functions over the network = good" while underestimating network overhead, network failures etc, or without taking into account whether *their* algorithm is parallizable. Granted, mistakes like this can occur with any development framework, but I wonder whether a microservices FaaS would be more likely to be perceived as a "holy grail" sort of thing (because microservices themselves are being hyped), making mistakes like this more likely. Maybe 5 years down the road, the monolith concept will be resurrected under a different name and then people will talk about how microservices are the source of all the slowness and how keeping computing local is the holy grail to performance. This is not a criticism of StdLib, but I am curious about your thoughts on this because it seems you have way more experience than I do on this topic.
No one is necessarily on Heroku ;)
Does not Google Cloud Functions replace AWS Lambda?
HERE HERE... yes... it is possible, via an image, but not natively... that is exactly what I was thinking when I heard this from a friend who went to SF last week for the conference... said most of the other stuff was pretty bland, but this was awesome.
Where single byte means that it's only using the ASCII part of UTF-8, not literally strings consisting of only one byte (which for some bizarre reason I initially thought when reading the title)
I'm not sure if it's true anymore, but previously a requirement was that 1 rails server needed to be able serve two requests simultaneously. I.e. you make the original HTTP request and then it gets upgraded to a websocket. This means it can't work on webrick or thin. The original design didn't play well with multi-worker only (i think) like Unicorn however it now works. The free version of passenger doesn't have threads so it is worker only, that only left one webserver that can handle concurrency via requests. I'm hazy on the history as I didn't work on the feature. Puma also has other benefits, such as protection from slow client attacks without needing to be proxied behind nginx. I did my own testing with the slowloris client and it was still protected even when only using 1 thread. I think I also tested with 1 thread and 1 process, but I can't remember it was years ago. Puma has a reactor that it uses to accept connections that is independent from how it parses the requests. This is what gives it protection. 
Two options that I know of are [Executing Ruby code in AWS Lambda](https://pprakash.me/tech/2015/11/29/executing-ruby-code-in-aws-lambda/) OR you could use [Node.js](http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html) using the [OPAL](http://opalrb.org/)
what, why does `any?` do a `count(*)` if a faster 'select 1` suffices to answer the exact same question and is preferable?
I'm curious what lead you to Google App Engine for Ruby apps and if there's any pain points you're having with them? 
My talk from Next demo'd an App Engine Rails App: https://www.youtube.com/watch?v=U6weNkNmC7s The focus of the talk was on Stackdriver for logging, monitoring, and diagnostics but the app was written in Ruby.
There's a Ruby App Engine [tutorial that uses a Procfile](https://cloud.google.com/ruby/getting-started/using-pub-sub#the_worker) Yes, App Engine supports multiple Services. For example, if you want to deploy both a Rails frontend and a background worker, that is possible from within the same App Engine application! Actually, the second service doesn't even need to be Ruby! Here is a small example with documentation: https://gist.github.com/remi/7c7f39d0d0d4db7d0b7457d432a3804a
I'm happy to see they clarified the relationship between RubyGems and Ruby Together. I was not aware that Ruby Together only funded future development of RubyGems. I assumed it was also paying for the operation costs.
Every time I hear a discussion of Ruby Together vs Ruby Central I'm reminded of this classic Life of Brian bit: &gt; We are the People's Front of Judea! The only people we hate more than the Romans are the Judean People's Front! https://youtu.be/WboggjN_G-4?t=25s
&gt; I guess there could be other one-byte encodings that aren't ascii? Yes, ASCII-8BIT and ISO-8859-1 and others. "\xFF".force_encoding("US-ASCII").valid_encoding? # =&gt; false "\xFF".force_encoding("ASCII-8BIT").valid_encoding? # =&gt; true "\xFF".force_encoding("ISO-8859-1").valid_encoding? # =&gt; true "\xFF".force_encoding("US-ASCII").ascii_only? # =&gt; false "\xFF".force_encoding("ASCII-8BIT").ascii_only? # =&gt; false "\xFF".force_encoding("ISO-8859-1").ascii_only? # =&gt; false "\xFF".force_encoding("US-ASCII").encode("UTF-8") # Encoding::InvalidByteSequenceError "\xFF".force_encoding("ASCII-8BIT").encode("UTF-8") # Encoding::UndefinedConversionError "\xFF".force_encoding("ISO-8859-1").encode("UTF-8") # =&gt; "\u00FF" 
I believe this was fixed in ActiveRecord 5.1.
You know, they don't state it clearly up front, but I believe there is a certain free usage level: https://cloud.google.com/free/docs/always-free-usage-limits Would greatly appreciate if someone who's used it (and didn't fall under the 12 months free trial) would comment on it.
My team works on a lot of apps, most of them aren't ruby, so it wasn't a ruby specific decision. We liked the PaaS / serverless nature of App Engine, Big Query, Datastore, Cloud ML, etc. For the 80% or so of apps/services that can be built entirely on those it's an amazing platform. We write our app code, push a button to deploy it, and we don't have to think about infrastructure at all. My team is roughly 70 developers and that's not counting the tech ops team (which isn't under me). Prior to app engine there was a very real and large cost (in terms of peoples time) that had to be spent managing infrastructure including my team writing all of the chef/dev ops code. With app engine we were able to shift a lot of that time away from dev ops and towards adding real business value through app code. 
Or at least Python 3. So sick of 2.7 I'd kill for a version of ruby though (supported without hax)
Pry is mentioned in the existing book and the new version will update anything that needs updating.
As the author, I have nothing to do with that decision, it's up to Pragmatic.
I thought it was a pun on NodeJS, so maybe just roll with it ;)
Nuts! Thanks for looking, and thanks for letting me know!
Well, I love you. Don't let hate eat you up. I'm curious about people who are so opposed to advocating for basic human decency. How do you feel about depending on the open source software for a living, written by those people you hate? What made you detest humanity so much to take this position? 
If I remember correctly after the great security scare a few years ago Ruby Central hired a full time (or at least part time) ops person. I don't know if they're still employed. Evan Phoenix would probably be the person to ask re: staffing and pay. Also FWIW Heroku has previously offered to host RubyGems.org for free in the past. BTW, are you going to RailsConf in Arizona? I'll be there and so will Evan, so you could ask him in person. 
"ASCII-8BIT" doesn't really count, it's really the "null encoding", not an encoding at all, which is why it's other name is "binary". There's no way to get `false` from `valid_encoding?` on `ASCII-8BIT`, it's just a bunch of bytes, no encoding. It's got the confusing "ASCII-8BIT" name because ruby can (conveniently!) treat it _as if_ it were ascii encoding in some cases. But ISO-8859-1 is a good example! Your example doesn't neceessarily prove ISO-8859-1 is a one-byte encoding, but it's wikipedia page confirms it indeed is! 
Not this year, hope to in the future! (I went to one RailsConf some years ago in Baltimore, it was great). Obviously "find Evan at RailsConf and ask him" is not a transparency solution, but I recognize and commend that this announcement (or especially promissed subsequent announcmeent about Infrastructure Team) is a step forward in transparency! Great!
In fact that feature is tied into something I wanted to learn lately. I've done front end and back end web development but I have no experience with workers and tasks. This strikes me as something that would be done on a once in a while basis (pulling their karma profile from Reddit APIs). If I have some free time and get around to learning how to do that, I might make something quick, throw it on GitHub and send you a link to look at. :) Good luck with the rest of the site.
I've used Heroku but it's been many years since I last used it. At the time it was really expensive to connect a database while google data store is very cheap to start with. You also get all the non PaaS stuff when you pick Amazon, MS, or Google. 
Yes, it is a buffer for incoming requests, not outgoing requests. If you're running on Heroku, the router will buffer up to 1mb of responses per dyno. So you can get a little bit more wiggle room by using something like a gzip middleware to compress your responses. If you're not running on Heroku, you're probably running behind something like nginx and hopefully it buffers responses. 
&gt; I'm curious about people who are so opposed to advocating for basic human decency. I think the issues lot of people have with SJWs are a bit more complicated than that. I'm all for basic human decency, hell, I'm even for equality (of opportunities, not results), but [bullshit like this](http://dailycaller.com/2016/10/24/safe-spaces-not-cutting-it-berkeley-students-demand-spaces-of-color-video/) is crazy (and my guess is that they would label themselves as SJWs).
This is how I look at it: there are problems in the world. We should fix those problems. When I see something that absolutely totally does not make sense to me, I have to ask myself...maybe it's not for me. What problem are they trying to solve? What is the history here? I'll give you an example, someone was whining on twitter about "people can't be bothered to press two buttons" in reference to a tweet about Amazon Echo. The idea of the echo to them seems, in your words "crazy". It makes no sense to them. I have a child and I cook, and sometimes i'm holding my child while I cook and don't have access to press buttons, so the Echo is a great tool for me. There are also people who can't use their hands due to disability, Echo might be great for them. I pointed out these two use cases and suddenly the product made sense. It's still not for them, but it's a clear problem with a clear solution. For the example you've brought up. I think it's fine to be opposed to an idea, however I think we need to be careful what we label as beyond discussion or comprehension. If you can't comprehend it, maybe you're missing some context and can spend some time getting the history of the problem in line. Once you've got the clear problem statement and the clear history of what lead to the suggested solution you can still be against it. You can be against the solution, in which case you can engage and suggest other solutions. Alternatively you can be against the idea that the problem even needs to be solved. In this case maybe it's "minority students don't feel safe on campus", I think if that's the case we should invest in solving it. Let's look at the suggested solution: I think the basic need to feel safe is present in all of us. I think the term "safe space" has become an attack instead of an idea. A church is a safe space where you can talk about your religion, your friend's house is a safe space where you can talk about your day, a sports bar is a safe space where you can complain about &lt;team&gt;. It's not inherently such a weird ask to want a place where you can speak freely about a topic or experience. So I can comprehend both the problem and the suggested solution. I'm not advocating for or against that link you posted, but this is how I try to approach issues I find incomprehensible. 
&gt; maybe it's "minority students don't feel safe on campus", I think if that's the case we should invest in solving it Sure, but creating space from which white people is banned is NOT the solution to this problem. And than there is always matter of defining who is "colored" enough to be let into the "colored space". My point is that in lot of cases SJWs are demanding treatment of symptoms instead of the issues. &gt; Once you've got the clear problem statement and the clear history of what lead to the suggested solution you can still be against it. You can be against the solution, in which case you can engage and suggest other solutions. Alternatively you can be against the idea that the problem even needs to be solved Sure. This sounds completely reasonable. But lot of people is not so open minded as you to allow me to disagree with them.
&gt; But lot of people is not so open minded as you to allow me to disagree with them. I think that america &amp; the world has lost the ability to debate and have conversations with those that we disagree with. The purpose of a debate is to strengthen an argument, not to "win". We've lost that skill and need to re-learn it. The first tenant of debating an issue is to be educated on the issue, so I think the 0-th step is to try to do your homework. For me, I try to follow people on social media who aren't like me. Who don't think or dress, or look like me. It gives me a wide variety of perspectives. It's extremely helpful. If you come across a thing you disagree with out of your gut, try hunting for comments with the opposite view as your own. Look at the people who replied to the article's tweet, etc. Try to get a full picture of what they're like, what they're actually arguing for/against and understand they're a human. After you do that you can try to engage in a conversation and your success largely depends on how you disagree with them. Here's a great TED talk as a primer https://www.ted.com/talks/megan_phelps_roper_i_grew_up_in_the_westboro_baptist_church_here_s_why_i_left. Start out by expressing sincerity. It sounds silly but a simple "I'm being sincere" at the beginning of your statement, especially if it's to strangers or online where things can be taken out of context. You also have to live up to the statement. Don't escalate or drag the conversation down to name calling or yelling. If you're yelling AT someone, you're not talking WITH them. You also have to realize that not everyone else is invested in you. Not everyone else you meet online cares what you think and they're most likely not playing by the same rules. Starting with a statement of sincerity and asking them they are willing or have time to talk about a subject is huge. It saves you and them time. If they don't want to talk, find someone else. Maybe they've had a busy day, maybe you're the 100th person to ask them, let it go and find someone else. Next step is optional but helps, find common ground. If you say "I agree with your cause" in this case "i agree minority students shouldn't feel harassed on campus", then you are expressing that you're not arguing against their goal, but instead their methods. Keep in mind that this case of "for the goal, against the methods" is also a common tactic used against protestors and much of the civil rights causes. So you might need to do some extra leg work here to truly express solidarity with the cause. As I mentioned in the last post, there is a huge amount of history that needs to be comprehended before we can start understanding each other. If you disagree with the goal, then own up to it. This might be extremely hard to have a "reasoned" conversation, but again express sincerity and desire to talk. If you persist long enough hopefully you'll find someone to invest some time in you. But you need to realize that it's an investment and demands equal time/respect from you. ## Best Advice Don't speak, listen. Spend a long time listening. Until you can argue violently for and against the same idea (think: what would a debate captain do), you probably don't understand it well enough to debate another human. This next advice I say with hesitation: find someone who you can feel safe debating instead of a stranger. This is hard because you don't want to ruin relationships you already have. You also don't want to alienate or burden minorities that you know "hey you're a woman, come argue with me about woman stuff for an hour" - not everyone wants to do that. After that, feel free to engage people. Again there's a ton of books written about debating and arguing. I recommend "How to Argue and Win Every Time", also check out that TED talk I posted earlier. &gt; My point is that in lot of cases SJWs are demanding treatment of symptoms instead of the issues. There's a few things to unpack here. People fighting for a cause usually only have the option of addressing symptoms for many reasons. If you could do a "don't harass minorities" rally and it worked and you never had to do another one again, then we wouldn't be having this conversation and you wouldn't even know the term "SJW". Such a magic solution does not exist. So then what are the options? Either give up and do nothing, or pick a symptom and try to make it better. Look at black lives matter here. They started with not really any goals other than "make police stop shooting black people disproportionally compared to other ethnic groups". That's the goal. How would you achieve it? For awhile they advocated for body cameras and for databases tracking police shootings. These are not the things they want, but they are addressing symptoms of accountability and tracking. They have these things now, but their goals are not met. Now they're calling for indictments and investigations on cops who shoot people. Is this what they want? More cops in prison? No. They want fewer blacks to be shot by police. Until they've reached their goal, they have to work on smaller problems, even if they're only "symptoms". Until an ultimate solution is known, you can really only address the symptoms. It doesn't mean that you're not making progress. When it looks like someone is doing something "that won't help at all", maybe it's because they've run out of other things to try, but the problem still persists. The "I agree with your cause but disagree how you're fighting for it" is basically the oldest trick/lie in the book. If you're spending more time condemning how someone is fighting for a cause rather than using a method you approve to fight for the same cause then you are part of the opposition.
It's all volunteer at present, nobody does it on company time? And wait, so Ruby Together _has_ paid for people's ops time in the past, not just development time? I thought so, but that's not the message of the OP! I'm getting more confused before I get more clear! Suggest you address these questions in subsequent promissed "Infrastructure Team announcement". 
No intent to imply hatred, I assure you, just funny having two completely different groups with very similar goals.
Personally I'm a big fan of people who treat other people with respect. You're the man, schneems.
:) cool. given the slightly touchy nature of all of this, wanted to make it 100% clear. no worries.
I do not want equality of outcome. I worked very hard to become a legal immigrant and social justice warriors tend to believe that my hard work can be substituted by breaking the law. I run a successful business. I pull all-nighters often, particularly when I am helping with product launches and put a lot of dedication towards my work. I do this because I want a better life for myself and my family, and financial security. People in favor of social justice tend to believe I should be taxed at a higher rate because somehow I am privileged. They tend to generalize between me and those who are born into wealth. This is disgusting. I have lived a life of all sorts of circumstances - from depression, personal tragedy, heartbreak, homelessness, to happiness and fulfillment. I have also seen others like me slip back into a dangerous cycle of depression because they do not pull themselves out of it by their bootstraps, and develop a sense of entitlement as if society owes them something. Society must offer people who are willing to work hard, the opportunity to work hard. I am a person of color. In the past 30+ years as an adult I have never seen any group of people being as openly and shamelessly mocked, derided and shamed as white people, as if this is somehow socially acceptable. Racial equality has always been a difficult subject due to widespread ignorance and intolerance, but there is absolutely no shame in groups like Black Lives matter who openly advocate violence against law enforcement officers simply due to the actions of a few bad apples. They are guilty of the very thing they advocate against. I am sorry but this is not social justice, it is injustice. I am constantly amazed at the sheer blindness of those who claim to be social justice warriors, to the disgusting cultures many of us have escaped to make a new life for ourselves. Preaching tolerance and multiculturalism for the brutes in the hell holes we have managed to flee from is dangerous and misguided. There are dangerous ideologies in the world, some of which masquerade as religious beliefs, and it is dishonest not to call them what they are - totalitarianism. There are only two genders. One can self identify as a 300 year old dragon, but nobody is compelled to put up with that kind of nonsense in their lives. Social justice warriors tend to believe that society is obligated to accommodate this sort of madness. This sort of fascism will be defeated - nobody ought to be compelled to use specific words or phrases in a free country with individual liberty. I will work with anyone on open source projects, regardless of their beliefs. I am under absolutely no obligation to respect their worldviews or lifestyle choices. The only area of intersection between my life and theirs is the work. The work is completely unrelated to these other issues. I will accept a pull request from a 300 year old dragon - disagreeing with someone's worldview and hating everything that they stand for does not mean we cannot work towards a common goal. The code we write will be equally accessible to people all over the world - there is no affirmative action to make more code available to special categories of people. 
Came here looking for the DevOps, still under development 
&gt; I will work with anyone on open source projects, regardless of their beliefs. I am under absolutely no obligation to respect their worldviews or lifestyle choices. Actually if you're contributing to projects with a code of conduct, you are https://github.com/rails/rails/blob/master/CODE_OF_CONDUCT.md 