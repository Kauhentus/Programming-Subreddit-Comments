Just leave the code in the half-finished gem, declare it in the `Gemfile`, and point it at the git repo. If you were putting it in the app, I'd consider it a model though. 
Unfortunately, I was having some issues with that. It was causing my app not to be able to load.
yep, i was just showing the part that is most interested. not executable code. :)
I don't get the whole obsession with factory girl. Personally I think it is a shit ton of dependencies when most people just use it for object creation. I must roll my own creation methods in the support file. 
I'm going to give you my perspective as someone who's in my 12th and final week of an immersive ruby/javascript bootcamp. Prior to coming here, I had to do all of codeacademy ruby and javascript, a bunch of codeschool, and a bunch of exercises they created. It was a lot of work. Sadly, when I got into the program, I realized that stuff doesn't really teach you to code. Sure, it can help you learn the difference between a class variable and an instance variable, but it sort of misleads you into thinking that you know more than you do. That being said, I'm a strong proponent of tutorials, however, not to just watch and follow along. Echoing what a lot of people are saying here, building something is what will teach you. So, figure out a project you want to build and watch some tutorials that specifically address techniques and issues that you will face. While you aren't likely to find a tutorial that answers every question for you, that's actually a good thing. As an example, I had to build an app in rails with a really complex set of nested forms. I watched a railscasts tutorial on building these types of forms. Of course, it wasn't exactly what I needed, but it gave me a better idea of what I needed to do and then the rest is trial and error. Second thing, learn testing (I use RSpec, but others are good). Learn the shit out of IRB or even better, install Pry and use that. They will be your best friend when testing shit out. So basically, watch enough tutorials so that you aren't lost figuring out just how to approach a problem for hours, but also don't just copy because I guarantee you won't learn that way. Also, as far as the tutorial sites go, each one has their pros and cons. Code school doesn't have you build anything, but definitely introduces interesting concepts. Unfortunately, they commonly lack a lot of context. Lynda doesn't have much ruby, but the ruby essentials course will teach you a lot more than CodeAcademy. It's not interactive so, you will have to follow along on your own. I did a treehouse rails thing once and found it good, but the problem is, their approach was so specific that it's hard to really apply to other things. What I learned the most from it (which was also the point), was better methods of testing rails apps. Lastly, learn the shit out of hashes. You will use hashes all the time. They are simply the most versatile data structure and codeacademy doesn't even scratch the surface. Good luck!
I honestly don't, the last time I owned a windows computer was Windows 98, and it was my brothers. That was also before I coded at all. I've had two windows netbooks, but I pretty much immediately put linux on them, and my desktop at home is a mac. 
I especially like it for writing html/css on my Chromebook, but it has ruby syntax highlighting, and I love the color scheme. super handy little app. 
Debugging is a great way to develop your understanding of ruby and Rails -- that is, figuring out what was causing the issues you were having, why the app was not loading. The contrary practice of just randomly trying different approaches until one seems to work, without understanding what was not working with the other approaches, is sometimes derisively called 'bit twiddling'. If you'd like help figuring out what issues were causing your app not to load, you could try posting more details, and maybe someone will be able to help you figure it out. 
I totally agree with you, unfortunately, this is just more an issue of time than anything else. Otherwise, I'm of the mindset of always just figuring out what's going on.
How is managing project files in Drive? Can you just open them in Chrome for preview? From the perspective of someone who's file manager is Bash, this is weird, in a good and interesting way.
I hear ya, sometimes you have to get it done, but you haven't provided enough information for anyone to really give you any further help. One good approach is to describe what you tried to do, what you expected to happen, what happened instead (like the nature of the error message), and what, if anything, you've tried already to resolve it. Alternately, perhaps someone will feel like just downloading your app and figuring out what you were trying to do and then make it work, and then give it back to you (I'm not being sarcastic, someone might! But not me, at the moment anyway.). It can definitely be challenging getting modern Rails apps to work without first developing a foundation in ruby, and Rails. Good luck! 
Thanks for the kind words. I think I'm going to take one more stab at it but simply recreating a new gem using bundler and then adding my code. It might be something as simple as I just entered something wrong somewhere.
Another approach would be giving up on the Gem entirely, and just move the files into your app, until a later time when you extract it into a Gem again. It sounds like you were considering this approach anyway. It would let you get out of figuring out 'how do Gems work anyway' in order to meet your deadline -- there's no getting out of figuring out how Rails apps work to some extent, since you're building a Rails app, you've got to do that anyway. If you put the code in some subfolder of "./app", it should probably just work, and if it doesn't you'll have more specific questions to ask. I think you can make your own subfolder of "./app" even, and Rails should be happy to auto-load anything in `./app`, but this gets confusing for me too, and I think has changed between Rails versions. Or try putting it in `./app/models`, if that seems at least vaguely potentially appropriate. This is advice targetted at "Just get it working somehow, because I have a deadline, plan on spending time later refactoring and moving code around to be in more consistent and easier to maintain places." 
 ['one', 'two'].index_by(&amp;:to_sym) =&gt; {:one=&gt;"one", :two=&gt;"two"}
If it's a gem that's basically only useful for this particular project I just put it in a subfolder of the root of the project, eg `/gems/gemname`, and then in my project Gemfile I use the path specifier pointing it to the same location as earlier
/lib/gems/your_gem
It's sort of a pain, because of the way Drive is, chrome can't really do anything with it. But you can sync files so they're in Drive and offline on the chromebook, which allows you to edit them and open them from anywhere. Usually, though, for code at least, I do all my work locally on the chromebook and only move it to drive when I want to switch computers. 
You can send keystrokes to an X11 window via Xlib in C/C++ (see ~~[this](http://www.doctort.org/adam/nerd-notes/x11-fake-keypress-event.html)~~ EDIT: seems to be dead now - future readers try [this link](http://rosettacode.org/wiki/Simulate_input/Keyboard#C)). This can easily be compiled into a C-extension for Ruby in several ways. If you are interested in this endeavor, let me know and I can help you.
&gt; bit twiddling is bit twiddling good or bad?
What are you trying to accomplish? If it's a login action or something try mechanize.
As you can already see, there is sadly no established convention for this. I (and others) use /lib for code that could be abstracted beyond the current rails project, but is too trivial or isn't ready to be gemified. I'd do something like /lib/gemname/ 
Hey, thank you for your help. You helped me think it through and I solved the issue. I put a longer explanation in the original post.
THANKS!!!!!!! I kept having to do this while debugging it and it was driving me crazy!
In this context, of "just change things I don't understand until it seems to work", it is considered bad.
If you really want to control a browser, use selenium-webdriver. If you want to automate web actions, mechanize could work as well. If you literally just want to send keystrokes, and don't care about reading the state of the document or anything, you can make a c extension for the x11 bindings. Selenium-webdriver would also let you send arbitrary javascript pretty easily, though that sounds like its not needed.
😎
Code looks ok, except for a few long-ish methods (when you want to comment a block of code, extract it into a method/class and name it so that the comment isn't needed) and redundant comments/documentation (read_token: Reads the next token in the stream). Only I can't imagine anyone wanting to use it - writing `Foo.exec(sqlish_query) vs Foo.search(keyword, search_engine)`. I guess you just wanted to write an SQL-ish parser as an exercise/homework.
Once you have some free time, learn how to write tests. Would've saved you a lot of time, considering the amount of exclamation marks.
Generally, I know how to write tests. Unfortunately, I am only now learning how to do it with API calls.
I'm pretty new to coding (11 weeks), so any suggestions you have on getting better at writing and implementing tests would be greatly appreciated.
VCR is alright, for simple API calls/gems I use webmock, though. Managing the recorded cassettes can get pretty annoying sometimes and webmock lets you easily fiddle with different parameters without editing a yml file or recording a different request.
Cool. Thanks. I will definitely start checking out the spec files of other gems.
I'm lazier. irb(main):001:0&gt; require 'prime.rb' true irb(main):002:0&gt; 31.prime? true irb(main):003:0&gt; 121.prime? false 
That first tweet at the top of the article tells it all. This guy is writing bad — read: overly complicated — code. The generally write one [happy path](http://en.wikipedia.org/wiki/Happy_path) test, one sad path test, and one unpredictable input test for each method of my units tests — pass an integer instead of a string, or an array instead of a hash. I would do the same for any language. These are not the troubles of Ruby. These are the troubles of bad code. 
I'm not claiming it's some absolute truth but I've been taught that testable code isn't something you receive by choosing a particular language but something you create by organizing your code according to the language/platform you're working with.
This was already posted on Monday.
I'm not OP but this sounds interesting. Link is dead for me.
I liked the concept of "power" of high, higher, and highest level languages the writer linked below: http://www.paulgraham.com/avg.html This letter may be a bit dated, as in 2001, and it praises Lisp and 'macros' as the top of the power pyramid. On the other hand, maybe little has changed in either philosophy or 'power' since 2001. So what are the top 5 'power languages' today in terms of the criteria outlined in that 2001 letter (mainly language expressiveness, I take it)? I assume Haskell, Lisps, Erlangs, and ML's (in various flavors) are still the highest level power languages? Here is a nice follow-up opinion in 2009 of moving from Lisp to Haskell: http://newartisans.com/2009/03/hello-haskell-goodbye-lisp/
Okay [here](http://rosettacode.org/wiki/Simulate_input/Keyboard#C) are a few more code examples that could start you off. And I found out there is a CLI tool (see [here](http://www.semicomplete.com/projects/xdotool/) or [here](https://github.com/jordansissel/xdotool)) that wraps up the functionality quite nicely. Could just call that from Ruby with one of these methods: [system](http://apidock.com/ruby/Kernel/system), [exec](http://apidock.com/ruby/Kernel/exec) or %x(...) aka \`...\` Hope that helps :)
Report: Previous discussion http://www.reddit.com/r/ruby/comments/28yxnw/simplify_your_ruby_code_with_the_robustness/
Just pretend it's there if you want your code to look pretty?
hmm
You can't use duck typing if one of the returned types doesn't implement the method you want to call. &gt; Your current_user method returns a User, except when there is no user and it returns nil. A search method returns an Array of results, unless there’s only one result, and it returns just that result instead. Seems reasonable, right? Maybe even convenient! Both of these examples break duck typing. You can't call `name` on `current_user` or `first` on `search`.
Great! The important thing is that you got it working. I am of the opinion that `require_relative` is almost always the wrong solution -- you should have your load paths set up properly instead. But that can admittedly get confusing in Rails, especially since Rails and bundler both have changed their behavior related to load paths and auto-requiring over various versions. But ideally, you have your code set up using folder names that match package names, with the top level on the load path: * widget.rb / widget * foo.rb * bar.rb / some_part * baz.rb You make sure the top level dir (what the first widget.rb is in) is in the ruby load path. If it's a gem, this should happen automatically. If it's in a Rails app's `./lib`, that's already in the load path. For other circumstances, you may need to take steps to make sure it gets added in the load path. Then you can just `require 'widget'` to load `widget.rb`, or `require 'widget/foo.rb'` or `require 'widget/some_part/baz'` These require statements are valid anywhere -- you might want to have `widget.rb` require `widget/foo.rb`, if you want foo to be loaded when widget gets loaded. No need for require_relative. 
I think ruby isn't actually defined by a formal grammar. Can someone confirm or deny this? If there were a formal grammar, it would be easier to say exactly what ways you'd need to change it in order to have significant whitespace, and, what I think you're asking is, make `end` optional (or non-existent?). Without a formal grammar, it's harder to say. No doubt you could come up with something that's very much like ruby but has the syntactical changes you want. How many edge case differences would there be? It's hard to say. It looks like you found someone doing just that already, so it looks like you already have an answer? Yes, it would seem to be a toy project, as indicated by the README saying "Should this ever see widespread use? I don't know. But it's pretty fun!" I'm not sure why you'd want to do this. If you plan on inter-operating with ruby (combining 'real' ruby code and 'seamless' code in one project), you've got another layer of things that can go wrong, and you've got to understand both languages (albeit similar languages). If you plan on using only seamless and not using ruby libraries... I doubt you'd want to give up on use of the ruby ecosystem and have to create it all again just for this minor syntactical change. But then, I never understood the attraction of haml either. But it's still a much simpler thing to replace some static html template files in your project, compared to replacing actual logic with another language. I guess that applies to coffeescript too. I admit I think coffeescript is a terrible idea. It's not that I am neccesarily opposed to whitespace-significant languages, I'm just opposed to adding that extra level of complexity and cognitive burden just to compile to an already existing language from one without whitespace. You still need to understand HTML and JS to use haml and coffeescript, you've just got to understand haml and coffeescript now too, plus understand the compilation step, plus deal with the possibility of bugs in the compiler, plus be always translating one to the other in your head when debugging. (On the other hand, I, like everyone else, love SCSS, because it adds really important functionality not just syntactic sugar, and in the SCSS variant that has become the popular one, does it while staying as close as possible to the CSS you already have to understand anyway already). 
Assuming this is the first of many posts comparing the two then it is a start (There are hints that this is the case). If it is a one-off then it is so superficial as to be pointless.
Holy. Shit.
What just happened here?
Thanks! Learning programming is really funny. As I said before, I only started programming about three months ago. Even looking back at my code from a month ago that I was so proud of produces a face palm. I'm sure I will feel the same way about this. But, that's learning. And honestly, I love doing this, so it's always good to learn more. Thanks for the tips!
Logstash and Sumologic already do exactly this; I'm sure there are other competitors out there. (And Airbrake and Sentry and some others for the related case of "if an exception or error is raised, send that off to a service that provides a nice UI".)
Sooo... just like Python? 
Hey, thank you! This is what I ended up using. 
Actually I started to use mechanize today for a little script. I was trying to recreate a bot for a game.
Thank you!
Excellent post. We are currently in the process of doing this at my company as well, and it is beginning to pay off. The key is that each service can be deployed independently, and a failure in one, shouldn't bring the whole ship down. It also allows for easier failovers to alternate data centers. Probably the biggest win though is that code paths are very clean in this paradigm. Code is far less tangled, and much easier to debug/unit test. Integration tests are difficult however. 
no, just no
All good, but can't you accomplish the same thing with defining an enumerator and a yielder? It's a lot more flexible too... a = Enumerator.new do |e| a = 4 loop do e.yield a + 1 a += 1 end end p a.take(3) #=&gt; [5,6,7] 
You didn't mention you're primary trying to control a browser. It's always best to ask these kind of questions as precise as possible :) For web related stuff Selenium is probably the better alternative. Although I would recommend looking into http://phantomjs.org/ instead if you just want to accomplish scripting and don't actually need the visual rendering of the browser. It's much faster and, at least in my opinion, more fault tolerant. There is a Ruby wrapper gem as well: https://github.com/colszowka/phantomjs-gem If you don't even need JS support in the websites you want to script, you could also check out https://github.com/sparklemotion/mechanize. I did some really cool stuff with this in a matter of minutes before.
You're completely right. I'll take that in mind next time. This is reaaally useful for me, since I'll probably keep doing this kind of stuff. I'll check all of them out, thank you so much!
Similarly, when I was looking for a more purely object-oriented tools language to use after being a Perl hacker for years, I stayed away from Python and went to Ruby for this same reason. 
Howdy, First of all, nice job! The only thing you might want to consider is the way you sort by title and rating. def sort_by_title @books.sort_by { |book| puts book.title } end def sort_by_rating @rate_array.sort { |book| puts book.title } end I tried the above in irb and I don't think it does what you are expecting it to do. def sort_by_title @books.sort_by { |book| book.title } end def sort_by_rating @books.sort_by { |book| book.rating } end
I like significant whitespace for a variety of reasons, and use Python heavily. I won't go into all those reasons, but I'll say why the space/tab thing is not an issue. 1. If your code mixes spaces and tabs, it's going to look really fucked up either way, when you paste it elsewhere or transfer it to another machine that's using a different tab width. 2. Any good text editor lets you convert tabs to spaces automatically. 3. You arguably shouldn't be using tabs at all in the first place, again due to the tab width inconsistency issue. I like the fact that Python warns me about it. In fact, [YAML completely disallows tabs](http://www.yaml.org/faq.html), which I like even more. Compile-time checking of code formatting is nice. There is really no reason why anyone's code should mix tabs and spaces. Show me any professional project out there that mixes them.
I think if you need microservices to properly build boundaries I think the problem lies in your design process. 
Things I use all the time: # Save yourself the pain of watching big assignments print out with "and nil", which has lower precedence than "=" big_data_structure = (1..1e6).to_a and nil #----------------------------------------------------------------- module Enumerable def inner_inject(default = :not_used, &amp;block) map { |object| default == :not_used ? object.inject(&amp;block) : object.inject(default, &amp;block) } end end # Where the implementation of inner_map is an exercise to the reader :) [[1, 2], [3, 4]].inner_map(&amp;:to_f).inner_inject(&amp;:/) #=&gt; [0.5, 0.75] #----------------------------------------------------------------- class Object def as(&amp;block) yield self end end # Contrived, but useful in a similar fashion as Object.tap when you'd like to bind an object similar to let without variable assignment. I tend to prefer this more functional Lisp style to the more conventional variable assignment with "=", and this allows me to keep blocks on a single line, which is nice when working in the REPL. [{ a: 1 }, { a: 2 }, { a: 3 }].map { |hash| hash[:a].as { |count| "Up we go--%d!" % count } } #=&gt; ["Up we go--1!", "Up we go--2!", "Up we go--3!"] #----------------------------------------------------------------- class Array def at_indexes(*list) # (?a..?e).to_a.at_indexes(1, 3) #=&gt; ["b", "d"] list.flatten.map { |i| self[i] } end end (?a..?z).to_a.at_indexes(4, 21, 0, 13).join #=&gt; "evan" 
I disagree. I don't think significant whitespace adds any real value to a language. All it really does is add another "gotcha" which can be difficult to spot. There's a fine line between being elegant, and just being irritating. Significant whitespace crosses that line in my opinion.
Well, obviously there are a lot of developers out there who disagree. I think that there are way more gotchas in whitespace insignificant languages resulting from an implicit contract between indentation and actual codeblocks; see Apple's `goto fail` bug. Humans naturally expect an indented block of code to be a logical block of code. The inverse (all logical blocks should be indented blocks) is not always true, but the non-inverse form of that contract is what whitespace significant languages enforce before any program is executed. And in the cases where the inverse is true, languages like Python will allow for that, for example with 1-line `if` statements. All potential "gotchas" with whitespace-significant languages will be caught pre-compilation/interpretation if the interpreter is good enough. The only real downside is that copying and pasting code can be irritating if the indentation gets mangled, but this isn't a real issue for serious programs. It's only an issue when you want to run something you see in a blog post really quickly...and even then, using `&lt;pre&gt;` or `&lt;code&gt;` tags fixes that.
You're welcome :) PM me if you need some help somewhere.
Don't do this. Use a different database number for each of your applications: http://www.rediscookbook.org/multiple_databases.html
Bootstrap 2 or 3? Where are you keeping your source code? You have requirements? Where and how are these published?
Got it. I would definitely recommend: 1. Open up a private repository on a site like GitHub to allow access to your source code and collaborate with one or more contractors. You're going to want to know who changed what and when... in regard to anything, even just a bootstrap theme. 2. Write the requirements down, preferably as an individual issue per use case in your github project. I've seen long and detailed specifications cause some designers and developers to accidentally omit important details as their attention spans run out. There's a lot more reasoning behind those two suggestions, but paraphrasing the line in the movie Contact, "We can think of 1,000 reasons why you'll need this, but mostly it's for the reasons we can't." That all being said, if you do post it on GitHub and setup a "team" I'd be happy to look at what you've got.
Cool. I think Rails in this area (and especially the rails/bundler/rubygems combo) is actually a good bit more confusing than it needs to or would optimally be, in part for historical reasons. And yeah, as you've probably already discovered, you'll probably be looking back on the majority of what you did a year ago and thinking you'd have done it differently... at any given time for your entire career. That's how it goes. 
As an addendum to the above, you can simplify more if you'd like: def sort_by_title @books.sort_by(&amp;:title) end def sort_by_rating @books.sort_by(&amp;:rating) end Also if you don't want it sorting every time you call the method you can memo-ize it: def sort_by_title @title_sort ||= @books.sort_by(&amp;:title) end def sort_by_rating @rating_sort ||= @books.sort_by(&amp;:rating) end
Why would someone want to do this? If they're independent applications each with their own Sidekiq deployment, why are they sharing the same redis instance? It's an unnecessary single point of failure. If they're not independent, then why not use a single sidekiq instance and use multiple queues within that sidekiq deployment?
Depending on how often you expect to be checking if a book is in the library, you could turn `@books` into a hash with `title.downcase` as the key. `select_book` becomes much faster that way. 
This!
Glorious!
Hmmm. Not convinced. 1. Complaining about how awful something is as you storm off is childish and petulant. It makes more sense to show us the better way rather than complain about how it's all too hard. 2. Mutability is only a problem if your code is bad. Learn functional programming (the Wizard book, etc.), come back to Ruby and you'll write better code. If you insist, over-ride the assignment method (#=) so it will only work once per object at initialisation and will raise an error when used at any other time. Congratulations: you just made your Ruby environment one that forces more maintainable code. Ruby doesn't do it by default because Ruby is not Erlang. :-) 3. Dynamic typing is not a problem when you start to realise the problem is poorly written dynamic assignment. In fact, it allows you to write considerably less code, and makes things less error-prone when put in the hands of somebody who knows what they're doing at the design stage 4. OOP is only hard if you learned bad coding from bad people and want to write your code in a highly sequential manner rather than understanding state and interaction in a more abstract way. Thinking of each object as having its own API with the rest of the World of your programme helps clarify what methods should be there and how they should interact with each other. 5. All of the problems identified with Ruby are actually problems with how people are taught to program and their expectations of a programming language. If we taught everybody Lisp first, then OOP, and then said "Here's Ruby where everything is an object, but your methods can be more Lisp like", everybody would get it. Instead we have schools of people who learned statically typed languages and cool tricks with infix operators and high levels of mutability who think Ruby is too chaotic and weird. The problem is not Ruby. There is something deeply broken about how we teach and think about programming, so it's no surprise people storm off when they meet concepts that challenge preconceived notions of how a language should behave. It is fixable though.
Oh yeah, because this: begin User.find( some_id ) rescue ActiveRecord::ActiveRecordError =&gt; e nil rescue NoMethodError =&gt; e nil rescue ArgumentError =&gt; e nil rescue RuntimeError =&gt; e nil end is *so* much better? How about: *use the right tool for the job?* If hiding all errors is what you want, inline rescue is the right tool for the job.
Thanks. I always feel like when I run into an issue like this I should be able to solve it within a short amount of time. When it takes longer than expected I feel like I'm not as qualified as I thought. When I do eventually solve it I feel like a god. I guess this is just the life of a developer.
Thank you for the response. I definitely think I should look into modules so I can stop repeating so much code!
I've never quite understood the difference between require and require_relative. I'm sure some Googling will help me out. Also, I required mechanize in the Gemfile so I could run bundle on it, but maybe I don't really need to do that...
I don't think what you have there is what the person really wanted. I suspect the `rescue` was intended to catch only the unfound record. There aren't many circumstances where you would want to catch all errors thrown.
It really is. I'm self taught. The first few years of professional work I did was all freelance. I used to get so frustrated and depressed when I had a problem like the one you just solved. I thought "I'm kidding myself - I'm too dumb to do this kind of work"! Eventually when I was good enough, I got a full time gig at a company. Immediately I realized, all programmers have the same problems. It's just what we do. 
So, this is a thing... Neat.
Well you watch a video. You don't really watch the Soundcloud player...
And here we observe the debt to be paid for not having a static type system
Awesome, this is pretty good. Is Ruby your first language?
I'm glad to know it. I'm self taught as well. I'm coming off of being a photographer and running a photography business for 10 years. I'm 32 now and dabbled in web design and programming in my late teens. I'm making a big step in taking on a career change in my 30s. Lucky for me, I have a supportive wife. All I want is to make this work. It's snags like these that make me doubt so knowing I'm in the same boat enables me to see past issues like this.
lolwut?
In book.rb you have that #info method. You might consider making that .to_h and returning a hash. This would leave the display up to the classes consumer so that anyone who uses your class can choose how to display it however they want.
what bootcamp are you participating in? Also, I get that building something will really test our knowledge and help us advance but did you just decide you were going to build some nested forms app or was this an assignment part of your bootcamp?
Ah, well my first career (and education) were in music. And I started learning programming at 30, so you're right on track in my book.
`require` is what you want to use. It goes all the way back in Ruby versions. `require_relative` is available since Ruby 1.9.2, I think. It's fine if you're grabbing a bunch of stuff in an IRB session. 
well i lol'd
I do, if I'm looking for related songs, songs by the same artist, or other relevant things on the page.
Did this really require a gem???
I am still a bit fuzzy on how the ||= conditional works. But, i though the &amp; was used for passing only blocs, these work on symbols to?
great idea, i can't beleive i didn't think of this before.
||= is assign variable, unless it has already been assigned: x = nil x ||= 6 x ||= 7 puts x =&gt; 6 The `&amp;:symbol` is shorthand for passing a method to the sort by block as a proc. This stack overflow answer is better worded than I would write, so I suggest you check it out: http://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby
How does the API respond? JSON hopefully. Have a read about parsing JSON/XML 
I'm searching the Sunlight Foundation Influence Explorer API. It's returning different JSON objects based on parameters. Right now, I have a politicians view and controller and that's about it. For the rest of the information, like on earmarks, I don't need to store it in my db. 
Is there already an SDK/ruby library for this API or are you wrapping the raw endpoints and requests/responses? Do you have some existing code (in a github/bitbucket repo?) you can show us? It'll be easier to explain given the framework of what already exists and will allow me to judge your familiarity with certain concepts.
I created a gem to wrap the API in. Here's a gist of some of the code. https://gist.github.com/gbcosgrove/500e9f994681bf29983c
Great, thanks. Now can you give me an example of the feature you'd like to implement. Walk me through it from a user's perspective. Let's choose one about earmarks (since you've already talked about how that doesn't need to be stored in the DB) 
The earmark search has the following parameters (but only 1 is required to search): - amount - bill - city - description - member - member_party - member_state - recipient - year So, I want to encapsulate some of the parameters into a search form. Say, city, member, member_state, member_party, and year. Some would be text fields like member, whereas others would be dropdown like member_party. Based on the search parameters entered, I would like to construct an api call, get back the information and populate a search results page.
&gt; Does that help? Yes. Very much so. Thank you.
http://i.imgur.com/qrLEV.gif
That was a pretty pragmatic list.
Rather than curses, use "io/wait". You can then get function and arrow keys using "$stdin.getc". For a full example, see this file navigator, cetus. https://github.com/rkumar/cetus
Most of railers really lack math basics, which 10 years old kids learn at school. Maybe railers are 9 years old?
Never heard of or used metacasts, i'll ch-ch-check it out.
I was hoping so. 
ruby is dead
yup, ruby is dead, you're language is first
Darn, i expected a much more interesting article somehow relating the idea of integration from calculus with function composition.
Not first class, but using [funkify](https://github.com/banister/funkify) You could write perform as: (store * monthcount * of_month * identified_as).(serialized_sym) You could even express it point-free as just: def perform store * monthcount * of_month * identified_as end So long as you remember to invoke it as: `perform.(serialized_sym)` 
To take this one opinion at a time - 1) Testing - I'll disagree with your statement about not testing it at all - this seems like the ideal place to write one, true integration/acceptance test and be done with it. Will it break if you change the implementation of say, MonthCount? Yeah, sure, but that seems important enough to have my tests flag, even if the result is just me re-writing the test. 2) Composition - Personally, I find the composition of your "perform" method to be exceptionally confusing, although I like that you've split the component parts into separate methods. At the very least, I feel like parentheses make that style of composition a lot more clear.
Thanks for your thoughts. I tend to write integration tests in a pretty black box style, so it would only catch a change in MonthCount's interface, not implementation. And my contract + collaboration unit tests hould pick that up anyways. As for composition... yeah, kind of a bold step there. I'm not sure I like it, either, I had to stop and remember that Ruby would right-associate.
The thing you're describing is extracting methods. Functional composition means you take a function `f(x)` and a function `g(x)` and return a function `h(x)`. `h` will be equivalent to doing `h(x) = g(f(x))`. What you're doing is `h = g(f(x))`, i.e. it's not a function.
Love these kind of guides, well written with the WHY. I am especially curious about the "warningfree" repo. A while ago I decided to start squashing warnings in libraries that I used and met active resistance from some maintainers because squashing some warnings mean making the code less "pretty". I have basically given up on the idea of being able to run my test suite without a massive waterfall of warnings.
 store monthcount of_month identified_as serialized_sym Ugh! DSL nightmare of the week. It really feels like everything is done backwards. I suspect that dependency injection isn't being used to it's fullest e.g I'd have expected the perform method to read more along the lines of: def perform(serialized_sym) sym = serialized_sym.deserialize sym.store unless sym.nil? end I suspect an intrinsic mis-attribution of responsibilities at some level of abstraction is what is making your tests (and code) so painful hence I'd look at a broader refactor (and more DI) maybe injecting the backing store if necessary: sym.store(MonthCountRepo) unless sym.nil? ... just looking at that made me go "Ugh" though, hence I'd probably use a symbol to flag that its the month_count that should be stored and a factory in the store method to obtain the backing store. sym.store(:month_count) unless sym.nil?
Is this a good course? www.udemy.com/learn-ruby-before-rails/ Its free for first 100 Students. So Please Suggest!
Function composition isn't a haskell-only feature, it's common in many languages. While i agree that it's very undiomatic ruby, it's surprising how quickly you can adjust to something, especially when the rewards (in terms of expressivity and concision) are high. I was also just responding to the OPs desire to write this with function composition and point-free syntax; whether or not you'd actually use it in production is a different matter.
1. do ".map &amp;:first" instead of ".map{ |i| i[0] }" 2. use spaces, since Ruby allows "f1 f2 f3 f4 arg" instead of ")))" 3. erase this video, don't convert Internet into trashcan, since this is enough: http://www.ruby-doc.org/stdlib-2.1.0/libdoc/yaml/rdoc/YAML.html 4. don't forget to downvote me for being that clever
You're not reading the code very closely. He has this: `store monthcount of_month identified_as serialized_sym` Which is equivalent to this: `f(g(h(k(serialized_sym)))` Which you can rewrite (using composition notation) as `(f . g . h . k)(serialized_sym)`. So, (assuming ruby supported this style of programming) you could express `perform` in point-free notation as just: `f . g . h . k`
So in short: if one of the operands is a Float, the result will be a Float. It doesn't matter which one.
Yes, either the method in Fixnum does the right thing, or the method in Float does.
Visual Paradigm is actually quite good, even the community version. These days I tend to use UML for 3 purposes: sketching high level design, ironing out detail at complex junctions, and communicating ideas. It *can* prevent mistakes in terms of making one consider the design at a deeper level but many people consider it not worth it for the time invested. 
UML is a particular approach to diagramming systems in a relatively detailed way. There is information elsewhere about how it works, and I am not an expert in using it, so I can't tell you about where to get software and stuff for it. However, I will say that I *very* often use diagramming, flow charts, and other sketches (though significantly less formal than UML) to gain an understanding of a system. In particular, Entity-relationship Diagrams are *really* helpful to me. These diagrams examine and represent each *entity* in the system as nodes in a graph, and connect them via edges representing HAS_A, HAS_MANY, and IS_A relationships. In particular, this sort of graph is useful when trying to get a sense of the 'as-built' status of a project, so that you can identify painpoints likely to require change. I guess my answer to your question is simply, "Yes." But it's important to remember that there are a lot of different approaches for graphical assistance, and I would be surprised to hear of any coder (experienced or otherwise) using none of them. As far as tooling, I like pencil and paper (I got a 2 1/2 foot wide roll of paper from ikea, it's pretty awesome for sketching stuff), but `dia` is a FOSS diagramming/visualization tool a la Omnigraffle or Visio, and is what I use when I need to turn a paper diagram into a computer diagram.
The only issue you would face is if you somehow a nil value (0.0 is fine), as you cannot coerce nil into a float type.
Are there other topics that you think would be worth while to cover that aren't?
Perhaps I misunderstand, but as far as I can tell there are no new functions or function-like objects being created. It's just a chain of method calls. I can see how it's similar to functional composition, but to call it functional composition would be incorrect.
AFAIK he was saying it really is function composition it's just there's no way of concisely expressing that in plain old ruby. But conceptually, it is function composition: `f(g(h(x))` =&gt; `(f.g.h)(x)` and based on that realization his conclusions (right or wrong) followed.
In my work before coding we have to do Entity-Relationship and Activity diagrams. The ER diagram helps you see the data model at all times, and complex functionality, api connections or even your main page should be modeled in activity diagrams.
+1 for paper/pencil or whiteboards and +1 for heavily relaxed "UML-like" diagrams. Particularly in agile, diagrams are supposed to be quick things used for better understanding, not golden sacrosanct artifacts. Drawing them up via software is far too time consuming to be useful, using "perfect UML" is too restricting to be fast, and all of it makes you feel like "I spent so much time on this, it can never change". I will also add that I like making "UML-like/lite" [sequence diagrams](http://www.ibm.com/developerworks/rational/library/3101.html) which are really just diagrams to show how one method executes and what its collaborators are and how it interacts with them. 
mmm i not know if you mean this, but i just install Ruby using [chruby](https://github.com/postmodern/chruby) and [Ruby install](https://github.com/postmodern/ruby-install) I have a [guide](http://blog.jam.net.ve/2014/04/19/instalando-chruby/) but is in Spanish.
At our company, we just install [RVM](https://rvm.io/) on any production box, and let it get the ruby version we are currently wedded to. That followed by gem install bundler is all you need to have a pretty much universal platform on any OS. We have that running on CentOS, Debian, Gentoo in prod, and Mac OSx 10.6 to 10.9 and Cygwin for Windows in development with no material difference after that.
&gt; This statement is meaningless. The word "coupled" seems fashionable nowadays but it seems like its loaded to turn off the reader's critical thinking. Actually, [Coupling](http://en.wikipedia.org/wiki/Coupling_%28computer_programming%29#Object-oriented_programming) is a well defined term. There are many good [books](http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley-ebook/dp/B0096BYG7C/ref=sr_1_1?ie=UTF8&amp;qid=1404938553&amp;sr=8-1&amp;keywords=sandi+metz+practical+object+oriented) which describe strategies and design patterns to avoid coupling. &gt; Even better, let's have the compiler enforce these contracts for us and even infer them so that we need not type them. Type systems and compilers are not a silver bullet. The compiler can only infer so much about how the program will run.
This. Forget about rvm, docker, vagrant and other stuff, you most probably won't need that. After you install chruby you don't even need to install bundler as root.
[Auto-switching in chruby](https://github.com/postmodern/chruby#auto-switching) is pretty easy to do (if that's what you meant).
Note this is a Rails (ActiveRecord) thing, not a Ruby stdlib thing.
Thanks for the feedback! Several of those I know very little about :/ Last thing I'd want to do it present something that wasn't very trustworthy. Totally agree there's more that could be included. Just tried to focus on the areas that I could really add value.
What is your logon to check if that user has rvm/ruby.
if you see in my blog, i tested rvm, rbenv and chruby. chruby is now my favorite. ruby run most faster that using rbenv. maybe you need read [this](http://rakeroutes.com/blog/how-to-use-bundler-instead-of-rvm-gemsets/) for understand how to using correctly
I've always used rvm, but in honesty rarely use it for the environment management side. It's hard to beat a one liner for RoR though: \curl -sSL https://get.rvm.io | bash -s stable --rails I'm also lazy, and resent typing rvm use ruby whenever I load up a shell, so in it goes to .bashrc!
I almost always diagram my projects out on many levels before starting. I usually sketch out some rough ideas as to what I want the interface of my application (if it's a website) to look like, and then I draw diagrams of the interactions between the different parts of the database, or the different classes that will exist in my project. Diagramming in general, whether you conform strictly to UML or you devise your own diagramming strategy, is extremely helpful. If you whiteboard it, you can take a picture and come back later, and you can add and remove features of your program simply by erasing part of your diagram. Then, you get a pretty accurate idea of what you're up against, what you're going to have to do to break down your task, etc. Whether or not you use software to diagram, it is a valuable skill and will likely improve your work a lot.
https://gorails.com/setup/ubuntu/14.04
Just an FYI /u/avdi is writing a book specifically on rake. 
Yep I've been following his screencasts. He's been doing a good job covering the lesser known features.
I have seen blog posts and screencasts on all of the listed topics. If you're going to be charging for a book, you have to go above and beyond the existing free content.
I could have thought about anybody else but you, why are you using `--deployment` instead of `chgems`? I found it quite ok. Bundler still has its issues with downloading versions at will unless explicitly specified in `Gemfile` (not `.lock`).
`--deployment` dumps all the gems into `vendor/bundle` and Phusion Passenger automatically handles the `bundle exec`. The fewer layers/moving-parts in production, the better. `chgems` was more intended for development, for when you need to isolate a project's gems from `~/.gem/`. Of course there are [issues](https://github.com/postmodern/chgems/issues/13) with `chgems` spawning sub-shells and chruby's aggressive auto-switching clobbering the custom `GEM_HOME`/`GEM_PATH`. I'm now working on an in-shell function called [gem_path](https://github.com/postmodern/gem_path#readme) for doing additional `GEM_PATH` manipulation.
Check out RVM. It takes care of just about everything (I think), although you'll definitely need to install the database stuff (postgres, mysql, whatever you're using) 
http://docs.railsbridge.org/installfest/
I've actually used this twice this week. Total lifesaver.
`s/months/years/`. The Table of Contents has to promise more than the basics which can easily be found using Google. Buyers are going to make a value judgment between pay for the book or just Google the topics.
Why forget RVM? I love RVM and use it frequently moving between programs.
I maintain http://github.com/thoughtbot/laptop . We don't specifically support crunchbang, but it's a debian derivative, so I'd probably accept a PR. It may just work out of the box with few modifications. We install rbenv and ruby-install, along with ruby-ish debian dependencies. We prefer packages from apt-get, with an unprivileged user managed ruby environment.
Not this. rvm is great. It has always gotten the job done, and still the canonical way I tell people to get multiple rubies easily on their system. 
oh neat! though i feel like that could have issues in partial application. i havent seen currying used with either of these functions in ruby (edit: actually, thinking again, could that even be done?), but i am in part thinking of [scoreunder](https://github.com/bahmutov/scoreunder) in js. having arguments second makes it easier to do partial application.
Eh, I guess for some. I could give a shit about somethings source code as long as it works for my needs and it's efficient. Unless I have to contribute to it, then it can be as ugly as it wants.
First of all, what error do you get when you try to install rspec 2.0? The command `gem install rspec -v'=2.0.0'` should work, but you probably should use `gem install rspec -v'=2.14.1'` instead as it's a much newer compatible version of rspec.
You want all that from a recent graduate? OK.... Not impossible but a narrow field. Now put up the salary range and you might stop getting downvoted. ( I am thinking that all those skills + "recent graduate" = vastly underpaid job, I doubt I am alone in that thought which is probably triggering down votes)
Sure, but for a lot of people that value judgement is going to be "will having this all collated in one place rather than trawling through unstructured blog posts save me enough time to justify the purchase". So I don't think it's really fair to imply that for a book to have value it has to cover topics not covered by any freely available material. On that basis essentially all Rails and Ruby books are obsolete since if you're prepared to put in a huge amount of time scouring and filtering blog posts, it's probably out there in some form already. 
*sigh* Fuku? Really?
Do most people really only ever have one version of Ruby on their computer? I couldn't even imagine. Also, you can use gemsets along side bundler... Being able to instantaneously switch from production gemset to an experimental gemset can be very useful.
Ah, I see. The problem is that it runs rspec with bundler, but bundler thinks it can safely use rspec 3. Change the line 'gem "rspec", "&gt;= 2.0"' in the Gemfile to 'gem "rspec", "~&gt; 2.0"' then run bundle install. It should work after that. ~&gt; 2.0 means &gt;= 2.0, but &lt; 3.x; it's very useful to prevent compatibility problems
I run many different versions of ruby locally..definitely not overkill. 
The price is $65, but that's a problem and you PM me, I can give you a code for $15 off. Or, consider participating in our [scholarship program](https://docs.google.com/forms/d/1cObMCml_x5lUOOaM3rqdO6skgUY6S4yXuEcKYv2Bc-A/viewform).
Fukuzatsu. Which is the Japanese word for complexity.
I like using this gem: https://github.com/railsware/rspec-example_steps To "spell out" my steps, rather than creating methods for it. Another benefit is it will break down where the failures are in the output; for example if the failure is in the "given" block (for whatever reason) that block will show as red in the output. Just a little nicety. Only slightly annoying thing is I contributed to it a little while ago; but instead of merging my pull request, they just made the changes themselves... no attribution :( I don't get a chance to contribute to open-source projects often, so having my effort go unnoted was a sour point. 
Thanks for sharing, I hadn't seen example_steps before. I do like how our approach keeps the story together in one block making it easier to read. By nesting the block within lines from the story example_steps looks a bit harder to scan. I've have seen the [Rspec given gem](https://github.com/jimweirich/rspec-given) which again is a bit similar, improving the readability of rspec specs. :-( Sorry to hear that your contribution wasn't recognised.
I'll be there - and I here I might be MCing the lightning talks :)
Why the sigh?
Saikuro is ancient and I don't think it even works with 1.9 much less 2+. Tried to run it in Ruby 2.1.2 and it errors out. I hadn't tried `flog` in forever but just gave it a shot and it was able to analyze my Rails model directory using Ruby 2.1.2, so `flog` is still an option. 
maybe OP thought it was pronounced differently... "fuk-u"? (* edit: should clarify I'm not making a joke here, I'm saying that would be a likely explanation for the *sigh*)
I don't use gemsets so I don't see what the problem is. I suppose I must be missing something.
Hello, I think you're combining two concepts. Consider this simple hash {"x" =&gt; 10} We created a string object with everything that entails, but we don't have to. {x: 10} In this case use of a symbol saves memory. As of ruby 2.1 when you define a method it returns a symbol. So in ruby 2.1 you can do the following: x = def hello puts "Hello" end x will receive a symbol from the return value of the definition. Which means you can do Object.send(x) Instead of Object.send(:hello) The send method is really for metaprogramming, which is a very powerful concept. If you want to learn more, I highly recommend Metaprogramming Ruby in the sidebar.
:x and :name symbols are not created when you define the variables 'x' and 'name'. :print_hello is not created when you define the function print_hello, either. You can pass the function name as a string to Object.send and you will receive the same result as using the symbol. def print_hello puts "howdy" end Object.send(:print_hello) =&gt; "howdy" Object.send("print_hello") =&gt; "howdy" name = "David" puts name =&gt; "David" puts :name =&gt; "name" 
I really enjoyed it ;)
https://platform.pokitdok.com/#/
I am new to ruby and my tests feel pretty spread out, even though testing in ruby seems INCREDIBLY easier and more pleasant. This method does read very well, I should try it. :)
I now get this error: C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core/option_parse r.rb:18:in `parse!': invalid option: --warnings (OptionParser::InvalidOption) from C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core /option_parser.rb:4:in `parse!' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core /configuration_options.rb:77:in `parse_options_file' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core /configuration_options.rb:73:in `parse_global_options' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core /configuration_options.rb:47:in `parse_options' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core /runner.rb:41:in `run' from C:/Ruby193/lib/ruby/gems/1.9.1/gems/rspec-core-2.0.0/lib/rspec/core /runner.rb:10:in `block in autorun' rake aborted! ruby -S bundle exec rspec -Ic:/learnRuby/00_hello -Ic:/learnRuby/00_hello/soluti on -f documentation -r ./rspec_config "c:/learnRuby/00_hello/hello_spec.rb" fail ed Tasks: TOP =&gt; default =&gt; spec (See full trace by running task with --trace)
So the symbol hasn't necessarily been created yet but the ability to call that function using the symbol is there at that time. Correct?
I like it. Have you thought of using spec helpers like: it ... given_there_is_a :course ... end def given_there_is_a(subject) FactoryGirl.create(subject) end To make each of the tests a little more reusable and get rid of some of the boilerplate? With the added benefit of helping to prevent function names from being out of date with what they are actually doing.
I recommend to check [Metaprogramming Ruby](http://pragprog.com/book/ppmetr/metaprogramming-ruby) book. It goes through advanced features of Ruby and it well help you to get on higher level.
try this: http://exercism.io/
That means that rspec 2.0 is too old, which I sort of expected because it's old. Try running `bundle update` and then try again. `bundle install` will take any version of a gem that satisfies the constraints and will not try to install newer versions of gems you already had installed (unless there already is a Gemfile.lock, then it will take exactly the versions as you specified them). `bundle update` will try to find the newest versions of all gems that satisfy all constraints (including all the constraints the gems have themselves) and update Gemfile.lock to fixate those new versions.
I'm sorry my readme is insufficient. I will see about expanding it. I do indeed use curry, which you would see if you read the code. (So yes, I am aware of it. ;)) My point in showing inject with curry is to demonstrate how the argument order for inject is better suited to curry, than the new Ruby method each_with_object.
This is what you are looking for: [How can I save an object to a file? -&gt; Marshal, YAML](http://stackoverflow.com/q/4310217/322020)
I am not the owner of this repo. Just found it worth spreading. If you want to suggest sth then do a pull request.
Is this some kind of social experiment to find out how willing people are to relinquish access to their github, through the use of a recognizable logo?
Well… https://www.ruby-toolbox.com/
Sure. A symbol is just like a 'token'. You don't really need to worry about when it's created. Symbols are for fixed tokens representing a certain thing (like a method), Strings are for data, such as user input, or other textual (or byte, really) data. 
huh? :) Yeah, you really need to expand the readme, i only understood a couple of things you said ;)
I wrote a partial application gem here: [funkify](https://github.com/banister/funkify)
The way symbols are used like Object.send(:symbol) led me to believe that these symbols have some kind of "magical" property. And I think that's why they were so confusing.
There is a way to run Cucumber features through RSpec itself, using [turnip](https://github.com/jnicklas/turnip) gem from the creator of Capybara. I used it on one of my projects and it worked out great.
I kind of like the Table of Contents style over www.ruby-toolbox.com. Much cleaner and easier to search.
Cool. I don't know if I'll wind up getting that specific book (which is out of print) but I'll look into getting something about metaprogramming. Thanks for the suggestion.
I will check it out. Thanks for the link.
Thanks for the reference.
Won't work: https://github.com/alexch/learn_ruby/pull/20 Of course there is a pull request to make it work: https://github.com/alexch/learn_ruby/pull/21
&gt; Symbols are used like strings for developers to read I think this is the best one-line definition of Ruby symbols I've seen.
It just means Twitter *started* with Rails 0.8. They're probably on a much newer version now but never bothered to delete that autogenerated file.
Yes. This is a tongue in cheek post.
Missed a golden chance to call it AWESOM-O.
Alright so I keep thinking "I get it now" and then I see something like this. $count = 0 describe "let!" do invocation_order = [] let!(:count) do invocation_order &lt;&lt; :let! $count += 1 end it "calls the helper method in a before hook" do invocation_order &lt;&lt; :example invocation_order.should == [:let!, :example] count.should == 1 end end And I'm just like....huh? Where I get confused is at the let! call and then I get REALLY confused in the "calls the helper method in a before hook" it block in the first 2 lines. I hate to be a pain sorry.
I would not call some of these projects awesome. Besides they should just pick one in each category.
Bingo. If you need microservices as training wheels for encapsulation, then you've already lost. With good encapsulation, they wouldn't even be necessary. Sometimes, it's beneficial to extract services. Usually, however, it is not.
This might help? https://www.relishapp.com/rspec/rspec-core/docs/helper-methods/let-and-let 
If I were ever to work at Twitter that would be my very first commit: "Hey guys, Rails 4 doesn't use dispatch.cgi anymore, right? DELETE!"
Thank you I think I've got it now. At the end invocation_order == [:let!,:example] and not ["let!", "example"] right? Because they have to be explicitly converted to strings?
HELP
please paste all code into a gist that formats well for ruby, the code you posted is unreadable: https://gist.github.com/ 
try https://github.com/troessner/has_uuid
I thought they moved away from ruby as soon as the thing started getting huge.
The [omniauth wiki](https://github.com/intridea/omniauth/wiki) does a pretty solid job explaining how you can add a few lines of code to an app to get it working. I know it's not a demo rails app but hopefully it will get you started. If you want to see how that it works in a real life rails app I use omniauth + twitter / facebook login for my project called [lists](https://github.com/jordanbyron/lists). Keep in mind there are a lot of other moving parts which might make it a less than ideal example. Good luck!
Please work on your formatting as well as posing a question. Using all caps will more than likely keep people from helping you.
Thanks for your feedback. You are right: you can schedule builds based on time/date intervals. I started this project for myself but some friends told me to publish here and make it public. I agree with you and will make some changes as soon as possible. You are welcome to join development if you want. I am not a web designer so visual result (including the not-at-all-obvious GitHub link) may not be okay. :) Tks once again.
https://github.com/nycda has a bunch of test omniauth integrations including GitHub, Facebook, and Twitter
https://github.com/ihorsavka/issue_tracker-master here it is
A the risk of being "that guy," I'd suggest cross posting to /r/rails for an audience more focused on the segment of the Ruby world you're working with. :)
They never moved away from Rails completely. They have a lot of backend services in JVM languages, but large parts of the frontend is still Rails.
i don't know any apps, but this seems helpful: http://sourcey.com/rails-4-omniauth-using-devise-with-twitter-facebook-and-linkedin/
Coderwall.com uses OAuth through Github, Facebook, and Linkedin. It's open source at https://github.com/assemblymade/coderwall. The implementation is dated but still a good example of real production OAuth. If anyone wants to take a crack at modernizing the implementation they're welcome to create a bounty and start getting a piece of the revenue. :)
I'm one of the contributors to the warningfree repo. Most of the library authors I submitted patches to seemed grateful for them, even if the changes were a bit invasive.
What the hell? Why not just inject it manually with `House.new(window, door)` Your gratuitous "DSL" seems silly, overcomplicated and a waste of time.
For the house example, you're definitely right. An inversion of control container is overkill. When you're dealing with a large app where each dependency has its own set of dependencies and so on, an inversion of control container become a whole lot more useful. 
I'll describe what is -- in my view -- the main drawback of IoC containers from the context of your post. You talk about two "piles" of code: one that contains the business logic, and the other that orchestrates, assembles, and wires up the objects. Quoting: &gt; *The other pile is what bootstraps our application. It’s the code that calls new and creates all our classes. This code is also responsible for giving each of our classes their dependencies.* The problem is that there are two kinds of dependencies: framework level services like loggers, redis, database connections, etc., and domain specific dependencies. Projects that use IoC containers almost have a manifest destiny to start seriously confusing the two, and introducing constructors that take in way too many dependencies. The domain specific dependencies are always best managed explicitly, without the help of any tooling. Here's how I manage those pesky framework level dependencies, which often prove the most annoying to our tests: module MyComponent extend self attr_accessor :redis attr_accessor :logger class ClassA def initialize(dep_a, dep_b) @dep_a, @dep_b = dep_a, dep_b end # implementation end class ClassB # implementation end end Here's some tests: class MyComponent::ClassATest &lt; Minitest::Test def setup MyComponent.redis = @redis = RedisDouble.new MyComponent.logger = @logger = StringIO.new end def test_writes_something_to_redis # Interact with ClassA in a way that I expect will shovel something # into redis ClassA.new(dep_a: ClassB.new("hey"), dep_b: OpenStruct.new).foo # In practice a meaningful assertion would go here assert_equal 1, @redis.size end end If `MyComponent` shows up frequently in enough tests, I might even extract out its' setup to a subclass of `Minitest::Test` or a mixin that handles the setup for me. The key is to make it easy to inject doubles such as `RedisDouble` -- I have a snippet of code I copy paste from project to project that implements this, it's quite simple. **Big caveat** While these days I don't advocate dependency injection frameworks for general purpose, a nearly identical approach be very helpful for building abstract factories. Say I've got a few objects that represent coupon codes for pizza delivery orders: class BuyOneGetOneFree &lt; CouponCode def initialize(pizza_a, pizza_b) ... end def valid? assert pizza_b.cost &lt; pizza_a.cost end end class BirthdayPizza &lt; CouponCode def initialize(pizza, user) ... end def valid? assert Date.today == user.birthday end end You can imagine many coupon codes that all accept different pieces of data. In this case, you want an abstract factory that can build any kind of `CouponCode`. You need it to do three things to accomplish this: 1. manage an internal manifest of objects that any `CouponCode` *might need* 2. introspect `CouponCode#initialize`for the objects it depends on 3. inject those objects into a new'ed up `CouponCode` subclass. This tends to look a lot like an IoC container, and I employ this approach from time to time. [ruse](https://github.com/joshuaflanagan/ruse) is an excellent choice for this, in my experience. Being able to implement the individual objects as POROs is a huge win. **Shameless plug** I have written a gem, [invokr](https://github.com/ntl/invokr), which provides an abstraction layer for invoking methods that allows you to easily introspect required/optional parameters. They make it really easy to build both abstract factories and IoC containers. 
So why not use an event listener pattern for framework level services took hook in and do their thing, and then do dependency injection with actual domain level services.
For larger apps, it becomes even *more* important to isolate dependencies of various components. IoC containers make it fairly painless (upfront) to invite the entire universe to every party, leading to a system with a ton of dependencies. And of course the only remedy to all the edge cases and toe stubbings that come with e.g. nuanced object lifecycle management is to make the IoC container smarter and smarter.
DI in a dynamically typed language like ruby is a given that comes at no additional cost. Just inject your classes into the constructor and have them walk and talk like ducks. Most Ruby guides tell you to avoid newing objects in constructors and suggests injectiong instead. There is no XML file (spring uses annotations nowadays btw) to handle class selection for constructor injection? You want something to create your classes automatically and inject the right type?
I would speculate that it's a little harder to, for example, extract a component out of your codebase and into a gem, if it's coupled to an event listener framework that's present in the application. To be honest, the way I've been managing framework dependencies (`attr_accessor` at the module level) has been incredibly simple and portable. What advantage does the event listener pattern have? No setup required for tests? The reason I don't mind explicit setup in tests is that I'm usually making assertions on their state change anyways. If I have a ton of components that all have a bunch of "bare metal" dependencies like db connections, redis, loggers, etc., I might build some tooling to inject config into all of them at startup time when actually deploying the app in production mode. (I may be misunderstanding what you're saying, as well)
Why would I use `Global` when `Gon` (https://github.com/gazay/gon) exists, which has much more activity surrounding it?
I'm never a big fan of implicit dependency resolution. Someone who comes to look at the app later on usually has to dig through and work out where things are resolved and how it knows what to use. I'm a big fan of how Zend does it, because whenever you have to resolve you'll be calling a service locator.
 class House def initialize(window, door) [:open, :close, :break] .reject { |m| window.respond_to? m } .each { |m| raise TypeError, "#{window}#{m} not implemented" } "etc" end end 
In 2005, we made the switch from Java to Ruby to for once be free of this mindset so that we could just write code. Dont spoil our happy place with all the annoying stuff we do at our day jobs like DI. What is next? Home and remote interfaces for controllers?
hmm... maybe all these reply's are an extreme pile-on to somebody with enthusiasm and a great, giving attitude. Sorry for the overly critical nature of the subject... people are obviously scarred. I know I've been one to look for the most extensible (SOLID for life!) solution. see also: http://www.joelonsoftware.com/items/2009/09/23.html
This is severely misinformed. Dependency injection is used all. the. time. in Ruby, so much so that Ruby programmers do it without knowing it's called dependency injection. I'm unsure where the idea that dependency injection does not happen in Ruby. IoC containers, on the other hand, are *method of using DI* that is really really overwrought and overcomplicated for Ruby. 
At the rate we're going, I expect it'll be the elimination of mutability and coercion. Unrubify: coming to a GitHub repo near you. Hate the flexibility of Ruby? Then you'll love our explicit type conversions, grumpy 1950s static typing system, immutability, mandatory IoC, significant whitespace, and surplus of parens! 
You are probably going to need to use a headless browser, similar to capybara webkit. https://github.com/thoughtbot/capybara-webkit
Why? Ruby can work through any web browser.
because you want to simulate clicking a link/form in a browser, you need a browser to use. A headless browser gives the least overhead, and is fair easy to use with ruby code.
Can you gist the error and test code? Worst case at least the error
Post the code. What you've said is hard to follow. Even the use case of what you're trying to explain is difficult. Perhaps if you post your code, and try to explain in simple "When I do this, this should happen" terms it would help. Right now you have a lot of "Here's a bunch of stuff I want, and side effects", I don't really get what you're trying to do.
I am an intern and I am not sure if it is allowed to post any code online. What exactly would you like to see in the code? Here is the error: http://paste2.org/A0UkzBgh In the error above you can see that it starts to appear only after a test fails. And other scenarios (features) not related to this module that I am testing work fine. Here is an example of my Gherkin: http://paste2.org/UdvtxXfn 
It doesn't sound like Ruby is the right tool for what you are trying to do. What you are describing sounds like it could be accomplished very easily with JavaScript.
I know JS can be used server side, but I thought that that is the main thing Ruby is used for?
Sure. I'm virtually certain it isn't actually GC though. Someone might be using a global, or caching things somewhere that persists between tests, but that would be 'bad' user code persisting things that maybe shouldn't be, not the interpreter failing to free something. And the biggest clue to that, aside from the locations given in the trace, is that that is not an embedded error message in ruby or cucumber... likely not watir either. I'd be shocked if that wasn't an error custom to your company's usage of the framework-- meaning troubleshooting w/o source is basically a nonstarter. Start by finding out where the error comes from. Verify that it is that error causing the tests to abort, that no code after the error gets run (either ever, or after the failure.) Then figure out why it's getting called multiple times, if it should or shouldn't be, or why it might only be getting reloaded after failures.
Alright, I will start by looking in to my code first and then env setup files. Sorry, I couldn't share any code. I am not sure if I, as an intern, am allowed to do so. Thank you for the inputs.
Am I missing something, or this thing is useless if you commit your schema.rb / structure.sql?
Are you talking about rendering an html file/ code using Ruby? I've never had to do that outside of Rails, which is as simple as calling `render`. I'm pretty sure [redcarpet](https://github.com/vmg/redcarpet) does that. Maybe Nokogiri, but I've only used that to parse not write.
I see kind of what you want now from your other comments. Id suggest you would either look at ruby on rails or sinatra. I personally favor rails, but Ill leave that up to you. I am still a bit confused by your request though. If you could clarify exactly what you want to do a bit more, perhaps show us some code, give examples, I could help you better.
The Truffle runtime of JRuby is an experimental implementation of an interpreter for JRuby using the Truffle AST interpreting framework and the Graal compiler. It’s a potential alternative to the current AST interpreter, the bytecode backend, and the new IR. The goal is to be both significantly faster and simpler than other high performance implementations of Ruby. 
Gon shares variables to javascript, whereas Global provides interface for configuration data and as additional option it shares this configuration to frontend. So that you have very similar interface to this data on backend and frontend. 
Can you explain how having significant white space is against DRY?
Looking at it this compresses old migrations, its basically creating a db/schema.rb for a set point in the database history and then deleting all the migrations prior to that. Working on the principle that I don't need all my applications migrations from 2011 but I might still want a way of creating the database from 2011. Its not entirely necessary if you are using version control as you could just use your version control to get a copy of schema.rb as at the given commit.
Very cool
see [Truffle FAQ](https://wiki.openjdk.java.net/display/Graal/Truffle+FAQ+and+Guidelines)
Err, just use the schema? `rake db:schema:load`
It sounds like you are trying to monitor a click event and append the user input to the list of comments. You can do this 2 ways: 1) POST a form to the server, save the comment, and re-render the page. 2) Use JavaScript to send an Ajax request to the sever and append the new comment to the page. Please tell me what you do not understand so I can clarify. 
Thanks ! :)
Ok, so if I understand this correctly, truffle could potentially become the thing that converts the ruby code into javabytecode like how MRI has YARV and rubinius has LLVM or something?
sweet! Thanks for this. 
i went to app academy. the numbers they state on their website are very accurate. i had a job within 2 months after finishing. 
I guess I'm still skeptical of the performance of a JRuby app. Are there any known apps that have been built with JRuby? I'd just like to be able to compare how they stack up against other apps.
I graduated from a RoR bootcamp about 2 months ago and I'm still looking for a job. I'm waiting to hear back from a few interviews, so if all goes well I'll let you know. Commenting to remind myself.
Thank you, and good luck!
I just did, I think. On every single line you are repeating to your language what block level you are in. In Ruby, indentation is a matter of good practice and clean code. In Python, it is functionally significant that you have the same number of unprintable characters leading every line. Fundamentally you are repeating yourself to your language, over and over again. Each press of tab that has functional impact is an unnecessary repetition, in my opinion. Consider if you had a language where you did this: block = Block.new Block.add_statement(print "I'm a block") Block.add_statement(print "I'm still a block") Block.add_statement(print "I'm ending my existence as a block") Compared to ruby's block syntax: lambda do print "I'm a block" print "I'm still a block" print "I'm ending my existence as a block" end The do and the end state to your language once what you mean and prettification can be done automatically with zero effort. Block.add_statement is repeated code ad nauseum. Just because your editor writes it for you and it is unprintable does *not* mean that it isn't now functional code. 
I suggest you learn to program on codeschool.com or a similar site, i think you currently have a lot of confused ideas that those sites will help you straighten out.
for those who are curious, here's [DHH's thoughts on dependency injection](http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html)
The people I keep in touch with from my program are in the 70-80k range with no previous programming experience/degrees. Fresh grads I know are in the 80-90k range so we're essentially paying 10k to get more handholding and on the job training a CS student wouldn't need.
爽! круто! Cool indeed :D
Checkout [MakerSquare's prework](http://learn.makersquare.com). It's a great way to go from 0-40 and it's also the pre-req for their immersive full-time software dev class. * Free * Structured 
This is just my experience but the CS majors I know didn't really get "experience" until their sophomore summer. Remember that ~2 of those 4 undergrad years are GE classes. Additionally bootcamps tend to have students graduating with projects under their belt to compensate (as much as they can) for lake of previous intern experience.
Dpkg-reconfigure doesn't have to be set to "dialogue"
1) Is what I was thinking. I don't know how to connect the two forms to the Ruby script. Like take what is in a text field and put it into a Ruby scripts variable.
Looks fun. I'll sprinkle some popular ruby idioms in places where they seem appropriate and send a pull request as BinaryPaean on GitHub. edit: First up, test.rb refers to a file you don't have in the repo: '../../FileOut.html'. I suggest moving both that file and test.rb into a "test" folder. edit2: For a learning project I like your approach, but if you want to get funky with common Ruby libraries, here is [Treetop](https://github.com/cjheath/treetop) to consider.
Actually using Readline with injected history already, for the tool I'm developing and it's good. I wanted to see if I could add the additional visual feedback. 
Wouldn't location be a big factor in your salary? You'll get much less in Chattanooga, TN vs San Francisco, I imagine.
did you run generate first? rails g controller Post user_id:integer title_id:integer:index story:text tags:string eol:datetime In my case I was using sqlite3. Afterwards the database was unrecoverable with a "ArgumentError: Missing :controller key on routes definition, please check your routes."
Yes, I get that error as well. The problem is that bad routes are created in the routes file. I don't know why this is, but your database should be fine. Simply remove the routes from the routes file and everything should work as expected. You may want to open an issue with Rails about this. 
Not directly related to the article (which is worth a read) but the following might also be worth looking at: https://github.com/ruby-concurrency/thread_safe - Thread safe collections (Which would have fixed the array &lt;&lt; problem mentioned in the article) https://github.com/ruby-concurrency/concurrent-ruby - Concurrency toolbox. This might be something covered in future parts of the article. 
I'm confused. Judging from responses you've got a broken route and calling it an 'unrecoverable db', and an infinite loop and calling it a hang.
Watch out guys we have a hacker/cracker here! lul :)
there were several cs majors in my bootcamp class. I would say that web development is a tiny subset of CS with the unfortunate inclusion of CSS. A lot of the bootcamps do pair programming, which while not exactly being a ideal representation of a web dev workplace, does force you to get really really good at explaining code and also turning instructions into code. Also university system notoriously bad at training people for real jobs.
If you love infinite loops, you'll love this one: fork while fork
You can have the best of both worlds. You can always have an application with, say, a command line interface. Then you might like to add an interactive interface to your data and internal API as a separate option. These are not tied together. Underlying both interfaces would be your API which can be scriptable. Basically, if you don't tie the interface into the API then you can have any number of interfaces, including a GUI one if ever needed.
In irb or pry. class Object; def !@; self; end; end 
As far as "[1,2].cycle.count" I do not consider this the same as "loop { puts 'hi' }". Since the loop is intentional by the one writing the code in "puts 'hi'", but on the cycle the developer either intended the quantity of things cycled over, or the number of itterations completed up until now. That should be how count works on the cycle Enumerator.
Although this does seem to fit the criteria, it doesn't seem like it makes Ruby hang (since in irb; the prompt still accepting entries; is an illusion of progress). It does nullify anything from being a proper object. Cool trick `^_^`
This goes beyond just hanging Ruby and freezes the system.
I've called it a hang because in the instances I first discovered them I could no longer continue. It was stuck. I had to `CTRL-Z` out and then `ps -A` kill the process `kill -p PID`. I was unable to kill the process of the rails command one. I had to reboot the system. When I say HANG I mean ruby is still a running process, but nothing further can be done.
Enumerable#count returns the number of elements enumerated by the enumerator. Array#cycle, when called without a block and without specifying n, returns an infinite enumerable. Of course trying to count an infinite enumerable results in an infinite list. You need to read the API of the language of you want to understand what is going on. Had you done that, you would not surprised by the result. 
Great list! I was unfamiliar with several of your resources. Thanks for the info! Several of your links aren't working though. Looks like a few of them have your blog URL prepended. For example, Code School links to &lt;http://jocellyn.cz/2014/07/09/www.codeschool.com&gt;.
&gt; Of course trying to count an infinite enumerable results in an infinite list. *infinite loop
I know what are you thinking. Try out [ruby on rails guide](http://guides.rubyonrails.org/getting_started.html). You will create basic blogging application in Rails.
Yay for grammatical errors. Thank you!
You were right. Some flag was not being set in one of the Cucumber hooks. Thanks for your help.
This is a nice list. But these lists are frustrating. It's because learning rails is frustrating. I'm being subjective by the way... this is only how I perceive it. I don't know how everyone does so I can't make objective claims. A list like this is like "Wanna make cookies and lasagna? You're going to need flour, eggs, tomatoes, chocolate chips, water, and baking soda". It's overwhelming! :) There's so many ruby on rail components that complete, overlap, replace, upgrade... someone show me just one way to do it without giving me options! 
Over use of Mixins essentially like doing mutiple inheritance in C++. In other words avoid it. Focus on the Solid Principles. Read this book. http://www.poodr.com/
To give a little more context, a lot of rubyists that used to write code like this: # in app/models/blog_post.rb class BlogPost &lt; ActiveRecord::Base include ActsAsTaggable end # in app/controllers/tags_controller.rb class TagsController &lt; ApplicationController def create @blog_post = BlogPost.find params[:blog_post_id] @tag = @blog_post.tag! params[:tag_name] end end The tagging behavior gets sort of "glommed" onto the `BlogPost`. Many rubyists don't like this, because they don't like working with objects that perform too many roles. Instead, they *decompose* the objects into smaller ones: class BlogPost &lt; ActiveRecord::Base # The ActsAsTaggable mixin is no longer used end class TagBlogPost def initialize(blog_post, tag_name) @blog_post, @tag_name = blog_post, tag_name end def perform Tag.where(name: @tag_name).find_or_create_by(taggable: @blog_post) end end # in app/controllers/tags_controller.rb class TagsController &lt; ApplicationController def create @blog_post = BlogPost.find params[:blog_post_id] @tag = TagBlogPost.new(@blog_post, params[:tag_name]).perform end end It's worth noting that many rubyists don't like this second approach. They'd prefer to have fewer classes that do more. If you're a fan of the "few classes, many mixins" approach you may end up with highly coupled "God objects." If you're a fan of SOLID/POODR, you may wind up with a messy jumble of many objects with an incomprehensible network of internal relationships. For that reason, I choose neither approach -- or both at the same time, depending on your perspective. The remedy to the "many objects" approach is to shore them up behind a smart interface object that serves as a "captain of the ship" of sorts. That object ends up feeling as powerful as a "God object" with a zillion mix ins, but it actually just delegates down to an ecosystem of objects instead of having the behavior live internally. The principles behind SOLID begin at the class level, but they must be rolled up into larger units. And in those broader interfaces, the rules of SOLID apply yet again, but within a higher level of abstraction. **TL;DR** There's a lot of historical baggage when you address mixins/modules among rubyists. Today, there is a strong movement towards traditional OOP practices. However, broader design is far more important, and often overlooked. SOLID is, in my view, a better starting point than mixins.
This CLI utility is a UI to an API, the menu is shown to display potential options from the service. At the moment It's currently shown with numbers, the response is managed by Readline. I inject the options into the Readline history, and it's possible to scroll through them, I just want to provide interactive display of the options, to assist users who aren't so comfortable in the CLI. (Note: it will never be necessary to add a further external interface to this, really, never. It's part of a suite of git/issue tracker workflow tools for command line happy devs) Edit: note, it would probably work well through a zsh completion helper, I don't want to exclude people who are using Bash though.
Cool list, thanks! I have a list of "How I stay up to date on Rails" here: https://www.codefellows.org/blog/how-i-stay-up-to-date-on-rails
these are great Zack! I am following along with your Game of Thrones program and altering as we go. Look forward to more ASAP! 
I'm a bit confused, I'm currently reading through the poodr book and I'm thinking mixins/modules and duck typing a big part of it with the focus on messaging? Am I combining some topics without realizing it?
&gt; It's because learning rails is frustrating. It is extremely opinionated, and the second you go off the "Rails Way" everything proceeds to yell at you without you realizing you are having issues not because of bad logic, but because you are violating some of the Rails Way conventions. My suggestion for those learning Rails is to instead go the Sinatra -&gt; RoR route, meaning get Sinatra first and start doing some super basic web site. From there, start adding in things like authentication, databases, templating, an asset pipeline, etc. Then, once you reach a point where RoR makes sense for a complex project, not only do you know how things work together, you also know why they exist and what their function is.
Can you link us to the pull request? 
Check out the devise sources. Great example of a gem decomposed into multiple modules while providing flexibility to the programmer to mix in the modules he or she wants.
Another suggestion: if all you want are server names separated by spaces, you can use `&lt;%= @params[:server_aliases].join(' ') %&gt;` instead of the loop.
Design principles: * Small code base that is easily understandable, hackable and embeddable * No dependencies except what is in the Ruby Standard Lib * Backward compatibility to older Ruby versions * Ease of use / Some minor resemblance to Sinatra, hence the name * It's not meant as a complete web framework but concentrates on the basics
&gt; So no rack? Can I embed it into other Rack-based apps? I guess you could make this work without depending on Rack. Exactly, no Rack unfortunately. Why Webrick is in the Stdlib and Rack isn't is beyond me. How would you go about making it work without Rack? Where would you suggest to start reading? I'd definitely love to get Rack compatibility! Any help appreciated! &gt; You could pull the parts before the comments into private methods to get rid of some of the noise. Fair point. The problem lies within lines [17](https://github.com/pachacamac/busker/blob/02c5d921853194db27e7ddb6432f7830ad6fc205/lib/busker.rb#L17) and [20](https://github.com/pachacamac/busker/blob/02c5d921853194db27e7ddb6432f7830ad6fc205/lib/busker.rb#L20) though. $~ in line 20 refers to the match from line 17. So far I found no cleaner way of achieving what it does and extracting line 18, 19 and 20 into methods would hide this unfortunate relationship even more.
&gt; How would you go about making it work without Rack? I don't have much experience with Rack, but the last time I looked into it, it was basically just a convention on what to expect as input and what to return (e.g. implement `call`, return an array of size 3 with status, headers and content).
Line 18 is easy to read. It parses the params and builds a hash out of them. There's even a comment to that effect. Line 20, which I guess is part of the same expression, is a bit of a doozy, however.
If the results for Go are on the order of 10,000 req/sec, the results are wrong (probably benchmark tool is maxing out before the server) or it was run on old hardware. For competing frameworks you'd expect around 100k req/sec on decent hardware if your benchmarks are good. Finally, Hello World is exactly the wrong benchmark for Ruby. Ruby's fundamental performance weakness is message passing and lack of language level concurrency. Those will have a much much bigger impact once you start doing *any* work in the application.
 lappy :: sandbox/ruby/concurrency &gt; ruby producer_consumer_threads.rb is that even valid Ruby?
Which program and how long is it? 
[Dev Bootcamp](http://devbootcamp.com), in total it's 21 weeks. 12 of those are preparatory at-home work (no more than 10-15 hours per week), and the remaining 9 are actual in-classroom.
I think because of the $~ right? This is the last regexp match (from line 17). It's used to get all the named capture groups. Like when you define a route such as `/item/:id` this would result in a regexp to match that route (see line 31) which looks like this `\A\/item\/(?&lt;id&gt;\w+)\Z`. As you can see it has a named capture group. Line 20 makes these available within the params Hash.
A mistery? 
&gt;as continuation loops don’t work correctly inside irb. Just put that example on one line in irb and it works just fine. &gt; require 'continuation' =&gt; true &gt; cont = callcc {|c| c}; p "hello"; cont.call(cont) "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" . . .
There is also [Lotus](http://lotusrb.org/). Which aims to be a small OOP based web framework. As opposed to Rails being a DSL based web framework =)
Heard about it but had no opportunity to check it out yet.
Intuitively count should not loop ever.
Adding adapters onto the domain layer from controllers is IMHO a step in the wrong direction. Essentially you're moving domain logic out of the domain and into a procedural layer that sits between the controller and domain model. There's a big downside to this approach, you're leaking implementation details. With the original api, blog_post.tag!, you're free to refactor within the domain layer without breaking your clients (the controller in this case). If you have to start using a separate object to organise the tagging you're going to have to modify every client. God objects can be a problem but there's many ways to tackle it in the DOM without effecting any clients. Here's an example of using composition to extract the tagging functionality: class BlogPost &lt; ActiveRecord::Base delegate :tag! =&gt; :tagger private def tagger @tagger ||= Tagger.new(self) end end class Tagger &lt; Struct.new(:taggable) def tag!(name) Tag.where(name: @tag_name).find_or_create_by(taggable: taggable) end end # in app/controllers/tags_controller.rb class TagsController &lt; ApplicationController def create @blog_post = BlogPost.find params[:blog_post_id] @tag = @blog_post.tag! params[:tag_name] end end Now there's a separate object that's responsible for the tagging but the api to BlogPost hasn't changed at all. Potentially this could be wrapped up to be used like ActsAsTaggable. This would allow you the succinctness of the first example (which is certainly something to be valued) but still allow you to keep the functionality isolated from the BlogPost. class BlogPost &lt; ActiveRecord::Base acts_as_taggable # adds delegation, creation of tagger object etc. end class TagsController &lt; ApplicationController def create @blog_post = BlogPost.find params[:blog_post_id] @tag = @blog_post.tag! params[:tag_name] end end 
That's a console command that starts the example.
I believe ruby has more readable versions of global variables. For example, `$LOAD_PATH` vs. `$:`. I would look for something similar for `$~`. With regex matching I usually do this: /match (?&lt;my_var&gt;group)/ =~ my_str # now my_var holds the first capture.
Seen [cuba](https://github.com/soveran/cuba) ?
Yes but I need a hash/array of all the named capture groups so I can merge it to the params hash. It's unknown beforehand how these will be called since you can define the routes as you like.
Added a link to Ruby Weekly - great newsletter
Some comments: - Treat your code like it is going to be read by a someone with only a basic understanding of the language principles if you have a design goal of "easy understandability". Prefer verbosity over ingenuity and document, comment and comment. Then comment some more. - $~ ... @_ etc. prefer the English names, Ruby is not Perl and if you want it to be "easily understandable" stay away from cryptic shorthand/golf. - Either be prepared to give up some level of comprehensibility or some degree of size and admit to the trade off depending upon your priorities. - Robustness is a rather "basic" design principle, sadly webrick isn't. - inline rescue ... don't. It will come back to bite you. There's some clever code in there but it really does not mesh with your design goals. Small does not have to mean "tiny". 
Textile is a plaintext format intended for conversion to HTML. RedCloth is a converter to take a Textile document/string and convert it into HTML. You don't need RedCloth to view a Textile document, any editor will work – you just need to understand the syntax. However if you had a Textile string and you wanted to test the output a quick way to do this would be to load the interactive Ruby interpreter (irb), load the RedCloth gem (require 'RedCloth'), and then test (ex: RedCloth.new("Some text").to_html) the HTML output. 
Cool. I haven't gotten it working just yet, but my friend has Alfred (spotlight replacement/extension) and Dash on his mac; you can hit option-space followed by "dash print" and it'll tell you the documentation for the method print (as an example.)
Chicago. They also have a New York City office too. I don't know about DBC SF, but from what I've heard the dev community here is a bit more chill than in SF. EDIT: to clarify, that's in the respect of finding jobs, at least.
That's pretty neat.
One issue you have to think about if the fact that the minimal frameworks lack things like sessions, security, and other crucial rack middleware.
"Supports Python, Go, Node.js, and ~~Ruby~~."!
Very impressive!
Nice, thanks 
For some applications, you don't need sessions or rack-protection, so it's good to benchmark the routing alone. For those benchmarks, a lot of middlewares were removed from Rails in order to make a fair comparison: https://github.com/madebymarket/ruby-web-benchmark/blob/c3a682e9bb7bad23e544f90902f09ab44f06ade5/rails.ru#L18-L27 But even without those middlewares, Rails was very slow.
I don't completely buy that argument. Saying it does more to output "Hello World" should bring up the question "why is it doing all this extra stuff and what if I don't want it to?" When I tested rack-protection on Cuba in another benchmark, it didn't make that much of a difference. I think it was 10% or less. My feeling is on Sinatra or Rails the internals are a lot slower than people realize. There might be good reasons for it, but I'd like to know what they are beyond "it's doing more, so it's slow".
I ran rake middleware on a freshly minted rails 4 app use Rack::Sendfile use ActionDispatch::Static use Rack::Lock use#&lt;ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x007fe964741828&gt; use Rack::Runtime use Rack::MethodOverride use ActionDispatch::RequestId use Rails::Rack::Logger use ActionDispatch::ShowExceptions use ActionDispatch::DebugExceptions use BetterErrors::Middleware use ActionDispatch::RemoteIp use ActionDispatch::Reloader use ActionDispatch::Callbacks use ActiveRecord::Migration::CheckPending use ActiveRecord::ConnectionAdapters::ConnectionManagement use ActiveRecord::QueryCache use ActionDispatch::Cookies use ActionDispatch::Session::CookieStore use ActionDispatch::Flash use ActionDispatch::ParamsParser use Rack::Head use Rack::ConditionalGet use Rack::ETag use Warden::Manager use OmniAuth::Strategies::Facebook run MyApp::Application.routes I think any moderately complex app is going to need most of those sooner or later. I wonder if he ran them in production mode? Maybe they are reloading constantly. 
Well that does seem odd then. 
I think is well written, the topic doesn't let you write much more. Following you!
Looks really good, keep writing!
Nice, I hadn't known about concurrent-ruby! Are you involved with that? It's got a lot of stuff that's neat, but I'd be interested in some more things ported from java.util.concurrent that it's missing, specifically the variety of thread-safe Queue types. It's got a PriorityQueue, but I've never actually needed that one, but do need features in other java.util.concurrent queues, which the ruby stdlib Queue does not have. 
Judging from the comments at http://www.reddit.com/r/ruby/comments/2aw839/live_searchable_usage_examples_for_ruby_and_rails/, it seems people found the videos of Sourcegraph's Ruby code search and examples compelling. Sorry if anyone's offended by my posting the announcement blog post, which we just put up, today. It has a lot more info and ways you can help us make it even better for y'all. 
Not bad. I think your 2nd example might be overkill, and if your method really is that simple I don't know that you'd be repeatedly using those values enough times to need to assign them to named variables. If you're only using them once or twice in a short method, a quick comment explaining them would be fine. e.g. if username.length &gt;= 5 # min. username length is 5 chars. I'd also use names like "MIN_LETTERS", "MAX_LETTERS" and "VALID_CHARS" so they wouldn't be quite so painful to type out. :p And yes, I know most editors have typing suggestions that autocomplete for you. Good post though, it is important to define such variables at the begining of big classes or methods so you only have to change something in one place to update the code. 
A nice example of what I'd call self documenting code. bad code: if name.length &lt; 5 better: # is name length less than min length (business rule no. 432) if name.length &lt; 5 Best: if name.length &lt; rules.min_user_name_length
&gt; $~ ... @_ etc. prefer the English names, Ruby is not Perl and if you want it to be "easily understandable" stay away from cryptic shorthand/golf. What is the English name for the $~ variable? If a full name-variant exists for it, I'm not aware of it. And I decided to put all instance variables that Busker uses into the @_ Hash so it's unlikely that a user of the library would unintentionally overwrite something like @server when trying to assign a variable for use within a template. &gt; Either be prepared to give up some level of comprehensibility or some degree of size and admit to the trade off depending upon your priorities. Really trying to find a middle ground here ;) &gt; Robustness is a rather "basic" design principle, sadly webrick isn't. Can you elaborate please? What makes a bad case for Webrick? Any other idea considering it has to be within the StdLib? &gt; inline rescue ... don't. It will come back to bite you. You mean in [line 36?](https://github.com/pachacamac/busker/blob/master/lib/busker.rb#L36) Yes good point. I threw in the template functionality in a rush. Will fix that definitely when I expand it to allow yield within templates. &gt; There's some clever code in there Thanks a lot! :) &gt; but it really does not mesh with your design goals. Small does not have to mean "tiny". Hope I could give an explanation for some of the points you made though. And you're right: Small does not have to mean tiny and I am not afraid to expand it a little bit for the sake of matching my overall design goals better. Keep in mind this is more or less the first draft I pushed to GitHub and I appreciate all the feedback I got here!
Its unviewable in Firefox on my Android. Only the background appears. 
Is there a reason you're doing a range.to_a.sample? Couldn't you do (for integer ranges): rand(MIN_LETTERS..MAX_LETTERS).times...
Yes, I think it's an extreme point of view that helps to illustrate something. I have know C++ programmers that could whip out an entire service in under a month, just hacking it out and the abstractions were actually quite awesome and useful. That was after 20 years of C++ experience though. Part of growing as a developer/programmer is converging on the balance between duct tape and frameworks for everything.
Oh ok thanks.
&gt; That was after 20 years of C++ experience though. It *takes* twenty years to get enough experience to use C++ wisely, which is why *everybody's* code before about ten years ago was such utter crap: not only didn't we know what we didn't know yet, we didn't know what parts of C++ we (thought we) knew should be left on the shelf when cranking out our latest magnum oopus. (That includes the compiler vendors and library writers as well as us mere developers.) It's easily the hardest language I've ever used to do *well*. The only serious contenders for that title IME are Java and PL/I. I *much* prefer languages I can wrap my head around in a week and grok in reasonable fullness in a month or two. I get paid to ship products, not to play with new toys. :-D
Noooooooooooo, not part of this, I wouldn't understand half of what is going on in there. I first came across it from watching http://www.confreaks.com/videos/2872-rubyconf2013-advanced-concurrent-programming-in-ruby
I would recommend fixing the code so that it does actually run just in case users want to follow along by typing it. For instance, change method_name to validate, pass in the username as an argument, and return a bool. Just a thought. 
`return a if disabled?` and `return a unless enabled?` read equally well for me. As long as there's no double negative going on, I can just read it like an ordinary English sentence. For me the most common mistake is using/abusing ActiveRecord's callbacks. I can refactor large methods/views easily, because everything is in one spot. But wrapping my mind around the side effects which are caused by seven `after_save` callbacks on `User` which then trigger callbacks from other models which then at some point send invitation emails to 60 users, is nearly impossible.
&gt; What is the English name for the $~ variable? http://ruby-doc.org/stdlib-2.0.0/libdoc/English/rdoc/English.html &gt; uses into the @_ Hash so Personally I'd separate more of the implementation into classes and provide minimal and well documenting interfaces but that's me. At the very minimum comment on what @_ is since it is unconventional. &gt; Can you elaborate please? What makes a bad case for Webrick? It's slow, there are several DOS vulnerabilities (which I *believe* are still unpatched) and its a lot easier to crash than, for example, thin. I've seen more than a few bugs "magically" resolve themselves simply by switching from webrick to thin. &gt; Thanks a lot! :) It wasn't a complement ;)
I read the title and did not know what you were referring to - they are classically referred to as magic 'numbers', not 'values', although I may have missed a memo somewhere...
&gt; http://ruby-doc.org/stdlib-2.0.0/libdoc/English/rdoc/English.html Thanks for the link &gt; Thin Is not in the StdLib &gt; It wasn't a complement ;) ... "compliment" ...
Cheers!
http://tablecat.ipyo.heliohost.org/guestbook/ Like that but written in Ruby. I'm trying to learn Ruby itself, everyone tells me not to go the wrong route like so many people have and learn Rails/Sinatra but not Ruby. Using one of those seems like calling a physicist when all you need is a carpenter.
Basically this http://tablecat.ipyo.heliohost.org/guestbook/ but written in Ruby. Using one of those seems like calling a physicist when all you need is a carpenter.
Well, here is one: [Ruby MVC framework From Scratch](http://courses.tutsplus.com/courses/ruby-mvc-framework-from-scratch). Also, do have a look at the source of very small ones like [Busker](https://github.com/pachacamac/busker). Bunch of them are also listed [here](http://www.sitepoint.com/ruby-microframeworks-round/). Do, post if anyone else knows better resources, I am also hunting for these.
Sorry, I guess I should have been more clear about my purpose. I'm not trying to build a framework that anyone else will use. It is simply for my own education. I've built a few small rails apps, but I sometimes feel that I don't fully understand what the framework is doing behind the scenes. I'd like to build something from scratch just for my own learning.
Ah, I hadn't seen the tuts+ course - looks like exactly what I need. thanks!
I am with very similar motivation! Cheers pal!
Its a great one; looking to learn from it soon.
Rebuilding Rails is okay. The first few chapters are great. It goes into a decent amount of detail regarding controllers, routing, and basic models (not database-backed). But as the topics get more complex (advanced routing, sqlite models, etc...), the book fails to explain a lot of what's going on in the methods. Rails is much much much much more complex than what a 140 page book can explain, but the book gives a decent introduction to how Rails works. If it were a little less expensive, maybe $20, I'd say it's worth it. A great starting point would be to learn about Rack and how you can use rackup with only a config.ru file to create a simple webpage.
Not using `self` also breaks the symmetry to using setters since you can't omit the `self` in `self.a = b`. 
Interesting assessment, thanks. Do you recommend any particular resources for learning rack?
Relatedly, a mistake I see quite often is this: foo( bar ) rescue SomeError This almost certainly doesn't do what you meant.
Wow. The app I inherited literally does 9 out of those 10 (and it drives me crazy), and its only not 10 out of 10 because we dont have tests. :(
No problem. [This](http://meaganwaller.com/blog/ruby-on-rack) is a pretty concise explanation. I also recommend building a simple web server from the tutorial [here](http://macournoyer.com/blog/). Just click on the right side where it says Rebuilding a Web Server and sign up. From what I remember, it's roughly an hour long video but I learned quite a bit from it.
Maybe not a huge mistake, but certainly an annoyance: creating bang methods without also creating a non-destructive version of the method.
I wouldn't really call the 5 here a magic number. It isn't a word, but that's OK. The conditional itself explains what the meaning of the number is. A magic number is more along the lines of strange return values or where the number has some meaning *beyond* merely being a quantity. I recently worked with a system that had 3 numeric flags on a God-object. The state was a combination of the values of all 3 flags. The code was chock full of magic number checking: if status &gt; 2 &amp;&amp; blocking == 4 || status == 4 &amp;&amp; blocking = 2 Those are magic numbers. Since they have no direct meaning - you're meant to infer a meaning from them. That was eventually re-written so that the status method would return a symbol denoting its intent: def status case self.status when 1 then :active when 2 then :paused # ... end Combined with a few methods describing what the checks are actually checking, the conditional became much more meaningful: if active_account? &amp;&amp; non_demo? In general though checking that a length meets certain criteria isn't *always* a magic number -- it really depends on the context.
no offence, why you hate a language because of the IDE, or public-private-protected?
Most Ruby programmers don't use IDEs; Vim, SublimeText, and Emacs are the big three editors I've come across (I use Emacs personally, but many of my friends swear by the other two and seem quite productive with them). Different programmers always have different ways of using documentation. The [online docs for Ruby](http://ruby-doc.org/) are very good, as is the ri utility which is roughly analogous to the man pages for the C standard library available on most Unix systems. I find myself leaning more on ri than the online docs these days, but I still use both quite frequently. If you're just starting out with Ruby I recommend [Programming Ruby](http://ruby-doc.com/docs/ProgrammingRuby/) and [Dave Thomas's series of screencasts on the Ruby object model](http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming). That should give you the fundamentals you need to start thinking in Ruby. I'm no expert in C#, but I have needed to work with it a few times and from my limited experiences, it is much closer to other very class/hierarchy focused languages like Java, whereas Ruby's OOP influence comes more by way of languages like Smalltalk. If you try to mentally translate concepts from C# directly into Ruby you will probably end up very frustrated. But once you understand Ruby's very elegant object model and the important ways in which it differs from C# you will probably have a better time. I've used Dashing a number of times in the past for internal company tools and found it quite useful; I'm by no means an expert, but if you have any specific questions about the framework I'm happy to answer as best I can.
TBH, it is because it ruins all of my views on what and how programming should be done. I never really hated a language before, but I assume I dislike it because it is different and makes me feel dumb. i.e. not being able to get simple tasks done in Ruby. I went in with a positive attitude and I cannot get a solid grasp of it due to the large changes. I am trying to recognize the problem of why I dislike it and deconstruct it into resolvable bits. Every language has it's faults, but no language just plain sucks, besides MUMPS. So, I really do need help because google is failing me big time here (~3 days wasted at work) when just trying to work with one small framework which is leading me into a ton of areas I have not discovered. Maybe I am in the wrong subreddit but I am basically making a plea for some guidance on the language and maybe I am overlooking something to filter this massive list of IntelliSense down, that would be a HUGE help.
&gt;If you try to mentally translate concepts from C# directly into Ruby you will probably end up very frustrated. I believe this is what is happening and why I wanna just punch my monitor. If it was my first language it would be easy, but it is unlike every other language I've encountered. On Dashing, there is one issue I am having and until recently (because I just went with the assumption ruby is a crazy mess) I have recognized the ruby-like syntax in the coffeescript files is not some ERB type of construct, but rather just plain old coffeescript. I still treated it as just coffeescript before and hoped that it was that (without knowing coffeescript mind you). I took a small glance at coffeescript and did not recognize any @symbols. I now know they represent the 'this' operator. Hence why I thought it was some ruby-instance variable. Anyway, down to the problem: ---- I am trying to modify the original graph widget to just display a number that gets it's data from a database and refreshes every half hour while displaying the time on the bottom of the graph. I do not know how this coffeescript file and ruby interact with each other. I don't have a hard time figuring out javascript\coffeescript (slowly albeit), but I am at a lost to how they interact. How the heck is it getting it's data? I understand it somehow get's its data from the 'send_event' command, but I am not sure exactly which of the many gems that framework derives from or exactly how it can feed data into the graph. Explaining that to me would be of insurmountable help.
That actually helps a lot. I knew some of the things you posted about, but the way you explained how they worked together helped. I am still having problems with the axis displaying correctly, but that was a big help. Thank you!
&gt; How the heck is it getting it's data? i havent used dashing (which looks like a mess) but, it looks like it uses batman.js to label content so that it gets updated using 'jobs'. These jobs get run by rufus which populates the content. It looks like you need to give rufus the information so it can update content. You probably need a [model](http://recipes.sinatrarb.com/p/models) object that gets data and include it in the rufus scheduler. 
So your advice is give up? 
I use Nano to code. I've never used an IDE.
Thought it would be a well thought out list of the actual problems that one might encounter, not bogans left through the code by previously inexperienced programmers. Not too surprised though, it is a svbtle blog, so it was bound to be shitty
I taught a Rails class last year and to primer the class, I went through (although briefly) doing HTTP via sockets, GServer, CGI, Rack, and Sinatra. I think going through those lower layers helps you understand and appreciate all the work that Rack and Rails does for you. It also wouldn't hurt to take a look at the source for one of the app servers. I've spent a bunch of time pouring over Thin's source (partially trying to learn eventmachine) and found it to be pretty informative. These guys do some work before requests ever get handed over to Rack and after responses get handled by Rack.
Find a good book that dives into the object model, and you'll fall in love. I recommend http://pragprog.com/book/ppmetr2/metaprogramming-ruby-2 but there are plenty of other great books for beginners through advanced users. Because of the flexible object model and the way ancestry, inheritance, and extending functionality with modules works, you can literally think about and solve problems **however you want**. Also, I know people love RubyMine and other IDEs, but for me nothing beats vim with a few plugins.
It's a different paradigm for coding than C#. I coded in VB then moved to VB.NET 1.0 and quickly transferred to C# and did that until late 2010. You're not going to find that fully-integrated-experience-in-a-box that you're used to with VS.NET. Start small, read the source. Use Sublime or similar and don't expect the same tooling you got with .NET. I eat and breath Ruby everyday and it's very different but once you get muscle memory you'll look back on C# and shudder. Let go of the old way. Don't get angry, just accept that you're learning and try to have fun. :)
Honestly, the best thing for you would be to pair with someone who knows ruby really well. My development environment is essentially vim+tmux+bash. Everything flows through the command line; automated tests, ctags for finding methods quickly, etc. This is very different from a Windows based C# development set up. I've never done any C# programming, but I'm pretty sure I'd be going through what you're going through now. &gt; I am still willing (and forced) to keep from trying to hate it because it is making me miserable The conditions around your experience seem unreasonable. Being forced to learn a new tool when the one you have works fine sucks. This does not even seem like a technical problem to me. If you were actually *inspired* to learn ruby, I bet your feelings would be different.
Sounds great - could you share any of the resources that you used for your class, or recommend any online resources or books?
You bet. I still have my slides for all of the classes posted on heroku--here are the sections I think are relevant: * http://geekwise-ror.herokuapp.com/d4#34 * http://geekwise-ror.herokuapp.com/d5#13 * http://geekwise-ror.herokuapp.com/d11#13 (I used the Kaffeesatz font in all of the slide, which if you really want, you can get [here](http://www.yanone.de/typedesign/kaffeesatz/).) Some related books, which I can't recall if any of these really pull off this info together: * [*Working With TCP Sockets* by Jesse Storimer](http://www.jstorimer.com/products/working-with-tcp-sockets) * [Socket Appendix from PragProg's *Programming Ruby*](http://media.pragprog.com/titles/ruby3/app_socket.pdf) GServer infos: * http://www.aimred.com/news/developers/2010/01/16/rediscovering_ruby_gserver/ * http://ruby-doc.org/stdlib-2.1.2/libdoc/gserver/rdoc/GServer.html
If understanding is more important than time, I'd suggest a gradual approach. Try codecademy to get some basics on Ruby. Then try writing some simple command line apps, googling all the way. Then move to web apps, perhaps using Sinatra to begin with. Next, make a web app that used a DB. Then make the jump to Rails.
Your before_save is only setting an instance variable on the instance that's being saved, and that instance variable isn't being stored anywhere. Your Pick#available_players_working method is doing a find and creating a brand new instance of a Draft object, on which save has never been called so the available_players instance variable is never initialized.
Thank you so much for your reply. I got rid of the find inside Pick.rb and I am using the 'draft' association now. As for the instance variables, I guess I thought the instance variables would be stored somewhere after the instance had been created. How do I store the instance variables? 
&gt; It gives me a ginormous list of functions, how is that useful to me? It seems you aren't really accustomed to dynamic languages. RubyMine and any other Ruby IDE can only make educated guesses about the likely types of variables, and they actually do a good job at it. They will list you methods ordered by class hierarchy and/or alphabetically, just like Visual Studio does for C#, whenever they can, but sometimes they simply don't have enough information for that. It's both a benefit and pitfall of dynamic typing, specially of languages that rely on duck typing like Ruby or Python. RubyMine is actually pretty good as an IDE overall. I don't know if you familiarized yourself with some of it's features and hotkeys, but it has a lot of nice ones: * Full-name search for method completion * Block insertion after functor-like method calls * Shows documentation for completions or calls with Ctrl+Q * Expansion of common idioms/constructs (e.g. type `while` followed by a Tab) * Navigation to symbols by name/relationship (check the Navigate menu and the respective shortcuts) * Some nice refactorings and scaffolding (obviously not as great as statically-typed language equivalents, unfortunately)
Hey thanks for even mentioning [Busker](https://github.com/pachacamac/busker). I have no idea why this small thing got so much interest all of a sudden O.o
Well, the readme that says its under 50 lines of code just stuck into me deep. I feel I can open it and actually learn before being distracted off in a plethora of classes/helpers/organisations. Not disregarding any of them, but for someone to learn the fundamentals, I feel such a bare bones approach is essential. Kudos for creating it.
You could make it a has_and_belongs_to_many association.
"The best frameworks are abstractions, not inventions". - DHH (I think). If I were to try and create a framework from scratch, I would take the a minimal set of tools and build a simple web app. As the app gets more and more complicated, start abstracting away all the repeated code. Rinse and repeat. Having never done this, I can't vouch for its efficacy in practice, but it's the route I would take were I to try.
I am learning Ruby currently, and this is the path I have taken: 1.) Codecademy 2.) RubyMonk (Primer) 3.) The Ruby Programming Language - Matsumoto and Flanagan 4.) RubyMonk (Ascent) 5.) Ruby Under a Microscope - Shaughnessy 6.) Then probably a lot of tinkering, testing, and playing with the language Currently I am on #3. And even if you don't get all the answers correct on RubyMonk, I would say continue through it and finish it regardless. Matz' (Matsumoto's) book explains everything that made you go "Wha!?" when doing RubyMonk's Primer. I think Codecademy was a great place to starts seeing how much they hold your hand through the fundamentals. I've finally started to feel like I have a fair grasp on the basics of Ruby, which is nice to finally have after many nights of banging my head against a wall screaming "WHY WON'T IT FUCKING WORK!?" Also, I am trying to enroll in a full stack immersive bootcamp in 2015, hence why I'm trying to get as up-to-speed as possible. Anywho, I've read quite a bit about how beneficial mentorship is through learning to code, and so I personally just joined my local Ruby Group on Meetup.com. I'll be going to my first meeting in August.
You could probably be inspired by similar open source libraries. I have contributed to one myself: https://github.com/ahmetabdi/themoviedb, but there are many others like https://github.com/Sija/garb or https://github.com/hexgnu/linkedin. If you really want tutorials I have found a couple: * http://gregmoreno.wordpress.com/2012/06/07/how-to-create-a-wrapper-gem-for-service-apis-part-1/ * http://code.tutsplus.com/articles/writing-an-api-wrapper-in-ruby-with-tdd--net-23875 What you are trying to accomplish is called API wrapper because you are somehow wrapping the API with another layer in a new language, you can probably find more resources with that term. Good luck!
That's helpful, thanks. Searching for "REST API library Ruby" did not yield what I needed. I knew I'd seen some stuff out there but couldn't find it. For some reason, writing the API seems to be less tricky than making a clean library. I'll poke those links tomorrow. 
I suspect Almost Sinatra to be the same ~~long~~ short and even more powerful when unobfuscated.
http://hawkins.io/2012/07/rack_from_the_beginning/
Ah, that's a very good point. Thank you very much for your help! 
Just confused why you ask, because your question is the answer to your question: "Use 'an' _if_ next _var_ _starts_with?_ a vowel" can be translated to "Use 'an' _if_ next _var_ _starts_with?_ _any?_ of the _vowels_" (or something like this) can be translated to "an" if VOWELS.map { |v| var.starts_with? v }.any? ... which is _almost_ the solution you're searching for! ... What I want to say: Ruby is great. EDIT: Formatting.
I agree. I suppose it was because it was a little too early in the morning but because of that I think it was my last sentence that clouded my question. I was mainly looking to see if there was a gem that I could utilize to handle this. I understand that my logic in the helper could be as simple as you write above or as the top commenter posted as well. This being the case I typically try and limit the amount of in-line logic when it comes to string manipulation as it usually makes the code very un-readable. After the top commenter brought up the rule to english that I forgot (that this includes the first letter(s) pronunciation sounding like a vowel) I realized that it might just be better to word the string like 'Upload #{document}' because attempting to enforce this rule would be too much 'forcing' if that makes sense? 
There is a gem: http://rubygems.org/gems/indefinite_article
A minor correction: type "irb" to get to a ruby console. Typing "ruby" will get you a ruby interpreter which is reading its input from stdin, which means that you have to type in everything and you won't get any output until you close stdin (with Control-D on Unix, for example).
Beginning Ruby by Peter Cooper is really good. It's a massive book that walks you through all the core concepts and several projects. I recommend it because it is often very helpful to have a consistent voice and planned curriculum, as I personally found that hopping between different tutorials with different styles was a nightmare. This book is also good because the projects he has you build are really good for hacking on top of. As in, once you finish the book you'll have several small Ruby apps that you could add features to. Learn Ruby by Chris Pine was my intro. It's shorter, though the difficulty levels of the problems vary wildly (like, early chapters have absurdly difficult problems, so, uh, dont feel discouraged by roman numerals or beers on the wall or anything) Hartl is the way to go for Rails as tehmoonrulz said . Do it twice because the first time will be overwhelming. Don't copy and paste, type out every single line. The second time you do it, read the Rails docs and make sure you understand what every method is doing, conceptually and literally. SQLzoo is really good for helping you understand what Active Record is up to, and I'd recommend doing that between Hartl runs. After that, just make a Rails app that does...anything...and keep adding features to it, do a JS frontend, etc. Codeacademy is nice to build up confidence and get a general idea of the language, but don't spend too much time on it. 
Off-topic: Is there a reason those slides are hosted in Heroku? Would a static site, perhaps hosted in even Github pages serve the need?
Is there any chance your classes are available as videos?
Yes, thanks for catching that. Got lost my translation from the rails process to the pure ruby process.
Hi! I wrote Rebuilding Rails, and this is a pretty spot-on assessment :-) As the book goes on, you get less hand-holding and more pointers into the Ruby on Rails source code. The framework you build, called "Rulers" in the book, *does* work like a mini-Rails. But for the most complicated systems, you're clearly building something much simpler than Rails. And as I go on, I try to lean less on "here's how everything works" in the text and more on "here are exercises and pointers into the Rails source code to go explore." That can be very valuable or it can be a bad idea, depending on what you're looking for. It's exactly how I like to learn. Rebuilding Rails is the book I really wish I had had when I got started on Rails. It may or may not be what you're looking for.
Isn't the simplest solution to leave off the a/an? * Upload dog * Upload apple I know it reads more like something a computer would generate, but failing to handle exceptions looks worse: * Upload an ukulele 
After some ungodly number of hours without sleep and slowly pouring through examples and the java libs... I now have the start of a functional wrapper. Thanks again for the pointers. The right search terms and lots of code sifting got me where I needed to be. Now maybe I can sleep...
This post is several months old, but good. The singleton interface pattern is a nice way to get functional style statelessness -- since the instance gets garbage collected after `.call` is finished, the state used during the service object's lifecycle becomes irrelevant to the system as a whole. One nitpick: the copious use of `private` for all the methods other than `call` seems like unnecessary friction. A class method, `.call` is already a level of abstraction above the instance method `#call`. So, you're not really running the risk of people coupling to the instance methods of the service object. When I want to interact with an instance of a service object, be that in `pry`, a test, or even new code, I want to directly call methods like `#send_notification_to_inviter`. At the level of abstraction of a service object's *instance*, this is really a public concern. The barrier between `.call` and `#call` is a more appropriate public/private delineation. You're essentially creating two layers of encapsulation with the iceberg class.
I built the slides using the [parade gem](https://github.com/burtlo/parade), which lets you write your slides in Markdown, then serves them up with Sinatra. This seemed like a fun way for me to end up with actual slides that had some bells and whistles (transitions, etc). Is there a way to do something similar with GH pages? Seems like you'd have to do a little more work, no? Edit: ...and if, for some reason, you want to see the source for the slides, that's on GH [here](https://github.com/turboladen/ror_class).
Unfortunately, no. The class was a 6-week (twice a week), on-site class (not online), and while I think the plan was to record the class, they didn't for some reason.
Oh thats sad! Wish to hear those topics.
Yeah, no server-side requirements, so static stuff would be cool. I'll check out Slidedown next time I do this. Thanks for the recommend. On the flip-side, running the heroku app is, of course, free and easy. As far as my workflow goes, it's not really any different than what I imagine would be pushing files to a static site. What do you see as a negative in using the heroku route?
I think Heroku instance can die off in case of zero activity for a period of time? Also incase of a traffic surge it can break, right? Plus, static route is hack proof and as fast as it can be.
..
Haha, well I think it's funny. Apparently this is what it means: http://answerparty.com/question/answer/what-does-rvm-stand-for-on-coke-bottles
I'm not sure I really understand this pattern. Why do you need to create an object just to invoke a single method and then have it die? Could this: class AcceptInvite def self.call(*args) new(*args).call end ... def call #do stuff end end not just be this: def accept_invite(args*) #do stuff end
ba-dump, pssshhhhhh!
well, I'll be damned... ruby really has a gem for just about everything. 
I want to say I've commented on this before, but don't just name all of your service object methods `call`. It's not like this is rack and has no good reason for all of them to respond to call. SendTestNewsletter.call or TestNewsletter.send There's countless of examples where a named function sounds a lot better. That's not even including the situations where your Service object is instantiated instead of being just class methods. An even better name that still works and ties in with the example would be `NewsletterSender.deliver`. Need more than one type of Newletter? Pass it in!
swap elements 1 and 2 in your yield call? 
I believe the point is to be mindful of what you're exposing to other users of your code base. It's just a form of encapsulation. The idea of a service object is that it represents a process that the caller treats as a black box. The caller doesn't need or want to know about the instance variables or methods that represent the individual pieces of the process. Indeed, exposing those can cause problems in some cases. Imagine a process that requires coordinating the local server with an external one, say an API gem that gives Rails programmers access to a hosted service you run. The service object would logically separate the creation and persistence of local models into one method and external API calls into another. Do you trust the user to call #create_model and #call_API in the right order with the right parameters, or do you just give them a .call method on the LinkToExternalService class? The latter lets you extend your gem to support multiple external services or change implementation details (what if you decide to start shipping an "on prem" version of your service that the user installs as a Rails Engine?) without changing the interface beyond maybe accepting some new parameters (with defaults set to ensure backwards compatibility!) to your .call method.
Well technically there is [some minor DSL magic happening](https://github.com/pachacamac/busker/blob/master/lib/busker.rb#L10) in Busker. But I hope the convenience/understandability ratio is in balance :)
The front-end related examples in this seem kind of weird since they have their own questionable inners. Examples: odd location for a font-family in css, using document ready in js if unnecessary. Most this advice is decent and definitely well intentioned but, especially if you're new don't feel like you have to hold up to this 100%
Learn Rack if you're not familiar. A big part of what people lean on Rails for that is kind of 'magical' is routing and its middleware stack. Maybe worth looking at the Rails middleware stack while you are at it (it's in actionpack/lib/action_dispatch/middleware) Check out the source for Cuba if you haven't before (https://github.com/soveran/cuba). Sinatra is cool but, it's much more dense, and also has a bunch of semi-confusing magic in it to deal with 'classical' mode where you don't define App classes but just use toplevel methods like `get`. Cuba is something like ~300 lines *including* whitespace and comments.
I've just ran into an interesting use of Class.new while writing a game using the Java library libGDX and JRuby. Many of the UI elements can have listeners added to them to respond to input events, and the standard way of overriding the listener's methods on the fly in Java looks like this: craftablesRightArrowButton.addListener( new ChangeListener() { @Override public void changed(InputEvent event, Actor actor) { changeNumOfCraftables(1) return true; } } ); To accurately mimic this with Ruby, I've used Class.new: @craftables_right_arrow_button.add_listener( Class.new(ChangeListener) do def initialize(actions) super() @actions = actions end def changed(event, actor) @actions.change_num_of_craftables(1) true end end.new(self)) Since Ruby does not embed the anonymous class within the class it is being created within the way Java does, I needed to pass in a reference to the outside class to be able to reach it from the listener's method. I think the Ruby way is safer, but it meant I couldn't just create the class using the normal Ruby .new method, but Class.new worked perfectly.
Your issue is that you compare index +1 without checking if that is actually in the array. array[3] (fourth element) will be nil. I.e at the end of the array you compare the last element.to_s with nil.to_s. "" (nil.to_s) is gonna be shorter, so if you sort large to small, it's ok. if you sort small to large, you will bubble an infinite number of "" upwards into the array. so what you need to do is first to stop doing to_s on your elements.You can expect your strings to be strings. If you can't, you've done something wrong elsewhere and need to fix that, not call to_s. Then you change your if to something like if element_2 &amp;&amp; yield... (in the if statement, a nil object counts as false)
And to add some info, logical statements are evaluated left to right(with some exceptions to priority levels) , so if the x statement in a x &amp;&amp; y situation is false, the y statement will never execute.
I know I am not helping but here is an implementation of the [random sort algorithm](https://gist.github.com/mess110/fd6133ee1a142944a895)
Yep, ultimately this will be the approach I will take.
What! The score uses ruby that is awesome 
Have you figured out how to decrypt the files yet?
What exactly makes it awesome?
Just because you can, doesn't mean you should.
Likewise, just because you shouldn't, doesn't mean someone hasn't. can't see why someone would want to, but... i too, want to find out if someone has done this intentionally.
The problem is that the listener's are Java code from a large library, libGDX. So the management of the listeners is already taken care of there. I have to work with that system. I've spent some time on the Ruby forum asking about this problem, and everyone usually suggests a block-related solution similar to yours, but we've never been able to make it work right with the Java classes and the JRuby interface. One problem is that the listener's often have more than one method that needs to be overriden. I've come to think this is uncommon from a lot of the reactions I've got, but nonetheless, that is how it's written. If you have a suggestion for how to do it with those restrictions in mind, I'd definitely be interested to hear it. I've been tossing around this problem for a while now.
/r/shittyprogramming 
I'd design a class using method missing to metaprogram around it, honestly, instead of having class.new all over the place :) But that's just my way - your way isn't wrong, it's just strange to see in ruby code.
I can I think imagine situations where you might want to do this. The most obvious one that occurs to me is that you want to model the SQL null. Another one would be doing a non-standard logic — fuzzy logic is probably the most well-known example. But if it doesn't carry through to other logical operations, it would be of limited use, I think.
OH MY GOD you made my day.
 class Object include Sartre That makes me sad :( Just include Sartre on the classes you want this behavior on, no need to globally change the behavior or every single object. 
There's a difference between "you should" and "anyone ever should". When a language designer adds a feature to the language (in this case, the ability to override the unary NOT operator), they presume at least someone, sometime would want it. If nobody could ever conceivably want it, why was it added to the language in the first place?
Null Object pattern would indeed be useful, often it's more reliable and convenient than having to do nil checks everywhere. But you can't expect all users of your library to know that you overrode the unary NOT, and explicitly call '!obj' to check for whether it's a Null Object (which they are forced to do based on how the unary NOT override works currently). Most of the time, developers would just call 'if obj', not 'if !obj == false'. So as you said, without it carrying over to the other logical operators (most importantly, making 'if obj' implicitly act as 'if !obj == false' in case the unary NOT was overridden), it's a crippled feature using which would produce inconsistent and contradictory behavior.
Continuing though on null objects, instead of allowing to override unary NOT (as Ruby currently does), I'd prefer a more explicit 'to_bool' method for implicit boolean conversion. Ruby already has magic 'to_str' and 'to_ary' methods for *implicit* conversions (not to be confused with the more commonly used 'to_s' and 'to_a' used for *explicit* conversions. Implicit conversions are used in things like equality comparison between a string and an object that responds to 'to_str'. That's why you can do stuff like: Pathname.new('/somewhere') == '/somewhere' =&gt; true In this spirit, if someone defined 'to_bool' on their object, Ruby could do implicit conversion in syntactical existence checks like if-else statements. Example: class NullObject def to_bool false end end puts 'ok' if NullObject.new =&gt; nil puts 'ok' if !NullObject.new =&gt; 'ok' # works automatically without having to override unary NOT puts 'ok' if not NullObject.new =&gt; 'ok' puts 'ok' unless NullObject.new =&gt; 'ok' puts NullObject.new.class.name =&gt; 'NullObject' # can call methods on null object as any other object The above behavior (consistent in all use cases) would actually make sense in a Null Object pattern. It can still be easily abused for wrong reasons, but at least it has uses *somewhere*, as opposed to current unary NOT override which just seems broken. The biggest issue with above proposal (other than potential confusion and backwards compatibility with existing code which for some reason already defined 'to_bool' somewhere, and wouldn't expect this change) is performance. If-else evaluation is supposed to be very fast, much faster than method calls, and doing this check on the object (as well as any parent classes/mixins which may have defined it) could just be prohibitively expensive, especially if having to check this on *all* objects and their ancestors (in order to determine whether 'to_bool' was defined or not), slowing down all objects instead of only ones using this feature. Perhaps instead of 'to_bool' being a method, it could be special language construct like class-level 'falsy' statement which marks object as falsy for if-else comparison purposes, without respecting inheritance or anything else that would require method calls. Currently only 'nil' and 'false' are hardcoded to act as 'falsy' for this purpose.
Good call. I gotta see whether the method_missing override will still work if I just include the method in.
 class Integer def !@ self &lt;= 1 ? 1 : self * !(self-1) end end 
Command line arguments and stdin are different things and have nothing to do with Ruby -- google them rather in Wikipedia, than Ruby tutorials (or someone would even look for them in Rails books, lol, sad but true). The only tricky thing here is that when you call `ruby my.rb my.txt`, Ruby interpreter not only passes the text file filename to the `ARGV` but also allows to read it via stding -- you can assume, that it convets `ruby my.rb my.txt` into `ruby my.rb &lt; my.txt` -- and this would again have nothing to do with Ruby.
`Class.new` and `class X` are NOT functionally equivalent. `class` reopens the class if it exists, but assigning a new class to a constant just overwrites it. Also with the `class` keyword the class exists instantly, with the constant already having a reference to it. This means you can use the constant inside the class definition itself, but an even higher impact of it is that constant lookup will work differently. In Ruby, constants are looked up in the following order: First, all objects in `Module.nesting` are checked to see whether they contain a constant with the name we're requesting. `Module.nesting` is just the lexical scope, meaning every open `class X` and `module Y` instruction we are in the middle of, in outward going order. Then, if the constant is not found, the interpreter goes through `Module.nesting.first.ancestors` if `Module.nesting.first` is not nil (meaning we are not in the top level lexical scope), and if it still does not find the constant it looks for it in `Object.ancestors` if `Module.nesting.first` is a Module or nil. It fails if it doesn't find the constant in any of those either. `Module.ancestors` is the list of all, well, ancestors and included modules by the way. But what happens if we use `Class.new`? The class we're just in the middle of creating is not in `Module.nesting`, since it does not exist yet. So if we included a module on it, we won't see the constants defined in that module, because the interpreter won't look for it in the current class' ancestors! Example: module M X = 2 end C = Class.new do include M puts X end We get a `NameError: uninitialized constant X` for that. And since `Module.nesting` only contains the lexical scope, it won't help us either if we only access X from within a method. What's even more confusing is that method lookup is done differently than constant lookup (I won't detail that but it does look up the ancestors of the current class). This means that if we include a module in `Class.new`, we still get access to its methods as we would normally. There are definitely use cases for the `Class.new` and `Struct.new(...).new` forms with a block too (one being that when you use `class X &lt; Struct.new(...)` you're creating a throwaway class just to inherit from, and if you want to reload the same code it will fail because it will try to inherit a different throwaway class), but be careful about these things.
`STDIN` (or `$stdin`) is the input to the program given at the console. It may be typed in: % ruby -e 'p STDIN.read' This is me typing ^D "This is me typing\n" Piped in from another program (using the shell): % echo "stuff from echo" | ruby -e 'p STDIN.read' "stuff from echo\n" % echo -n "stuff from echo" | ruby -e 'p STDIN.read' "stuff from echo" Or piped from a file by the shell % ruby -e 'p STDIN.read' &lt; /etc/manpaths "/usr/share/man\n/usr/local/share/man\n" Inside of your ruby program, those are pretty indistinguishable. All you really see is an IO stream of data. (insert 733t hacker demonstrating otherwise). Advanced users may use `IO#reopen` to change what `STDIN` points to, but that's rare. `ARGV` is the array arguments given to the ruby program at the command line: % ruby -e 'p ARGV' first second third fourth ["first", "second", "third", "fourth"] Most shells separate arguments to programs by spaces, but you can usually use quotes to disable that. % ruby -e 'p ARGV' "first argument" 'second argument' "third \"arg\" (for short)" ["first argument", "second argument", "third \"arg\" (for short)"] `ARGV` is a normal `Array`, and can (and is) be manipulated using `Array#shift`, `Array#pop` and the like. `ARGV` and `STDIN` interact in the IO stream `ARGF` which contains * the concatenated contents of each of the files given in `ARGV` (it assumes they're all files) * or the contents of `STDIN` if `ARGV` is empty For example: % echo "from echo" | ruby -e 'p ARGV; p ARGF.read; p ARGV' /etc/manpaths /etc/nanorc ["/etc/manpaths", "/etc/nanorc"] "/usr/share/man\n/usr/local/share/man\nset nowrap\n" [] % echo "from echo" | ruby -e 'p ARGV; p ARGF.read; p ARGV' [] "from echo\n" [] Note that using `ARGF` empties out `ARGV`. It normally does so only on demand: % echo "from echo" | ruby -e 'p ARGV; p ARGF.gets; p ARGV' /etc/manpaths /etc/nanorc ["/etc/manpaths", "/etc/nanorc"] "/usr/share/man\n" ["/etc/nanorc"] It's useful if you want to give users a choice between passing input to your program as a file or piping it in from another process.
Very cool!
Yes, please read above. The same concepts (stdin, command line arguments) are part and parcel of most all command line programs. You would find discussion of these topics in other languages such as Bourne Shell, cmd.exe (Batch language), Visual Basic, C, C++ etc. I think you should look there, adjust you mind to not thinking about Ruby in particular for a bit, then revisit this as part of your Ruby studies.
Interesting post! Creating a `get_binding` method has one interesting effect that you also could have mentioned. Since methods can receive blocks, you can yield from your template to the block passed to the `get_binding` method, thus recreating Rails' yield magic. require "erb" class Controller TEMPLATE = ERB.new("Hello &lt;%= @someone %&gt;\n\n&lt;%= yield %&gt;") def initialize(someone) @someone = someone end def render TEMPLATE.result(get_binding { "I'm Jack" }) end def get_binding binding end end puts Controller.new("World").render # =&gt; Hello World I'm Jack I'm doing [just that](https://github.com/whitesmith/rubycritic/blob/master/lib/rubycritic/report_generators/base.rb) in my gem [RubyCritic](https://github.com/whitesmith/rubycritic). You should all give it a spin! ^(*cough* shameless advertising *cough*) Also, you should fix your code highlighting. All underscores are missing, making it pretty hard to read the code.
&gt; Using Query Methods Outside Models Really? In any non-trivial application, requirements change with time. Suddenly you need to test or check additional conditions and / or systems for a workflow action. Putting this logic into a model leads to fat models which know about other models and can likely no longer be tested in isolation. Far better to create an object which knows how to combine various models into the desired result, which means that it's the single object responsible for tying that particular process together and the model merely needs to know about itself and its own business functions.
Most of these are terrible. It's just a grab-bag of messy untested code. [Use rails helpers in the controller](http://www.csnipp.com/s/622/-Use-rails-helper-in-the-controler) is terrible style. You shouldn't have your controller logic and view concerns so tightly coupled. Split them out more cleanly, or use a presenter, or decorate your object with a [draper](https://github.com/drapergem/draper) decorator. [Dealing with rest API](http://www.csnipp.com/s/615/-Dealing-with-REST-API) just demonstrates how awkward and incomplete Net::HTTP actually is. Use [HTTParty](https://github.com/jnunemaker/httparty) or [Faraday](https://github.com/lostisland/faraday) or something. Same with [Upload file to server](http://www.csnipp.com/s/612/-Upload-a-file-to-server). Why would you hand roll interpolated string? You can upload a file in a single line with something like MyWebService.post('/path', the_file: File.new('file.txt')) That's just the first page. There are others with URL encoded SQL in a string in a webservice call, half implemented API examples for gems that have good documentation elsewhere, incomplete regexes to do things that are handled in ruby library methods or in ActiveSupport. Don't use this stuff. If there is something you need done look for a gem that can help you, one that has good docs and tests. Learn how to do it properly.
I would agree and say that is true. But true is false now so I can't.
Nice, thanks for the cuba link.
There is a popular tab there, you can find a better collection under that.
The number one snippet under "popular" is: Model.order('RANDOM()').limit(count) WTF no, don't do that. That does a full table scan every single time because it has to call `RANDOM()` for each row, sort them in memory without an index, and then pick the first `n` of them. These are nasty snippets that teach you bad style and are completely untested.
Interesting, though I would really love the ability to "zoom in".
http://ruby-doc.org/core-1.9.3/Complex.html#method-i-conjugate Numeric subclasses have real implementations of the method. Having it on the superclass, even if it doesn't do anything, means you can call it without having to know specifically which type of number you're dealing with.
Ah, that makes sense - cheers!
I don't buy the argument that clone and dup should be used to minimize side effects. Since you only get a shallow copy, there is a good chance you'll have to dup more than once unless you're dealing with something simple, like an array. It seems better to find other ways of writing side effect free code, such as constructing a completely separate hash from the options hash. To illustrate why dup and clone are bad, it is easy to show that they themselves are not free from nasty bugs. Consider a Hash-like object that contains an instance variable of a 'Metadata' object. The metadata object keeps track of the size and some other information about the Hash-like object. When you make a shallow copy of this object, the metadata pointed to by both Hash-like objects is the same. Deleting a key for one will cause inconsistent metadata in the other. For this reason, dup is dangerous to use unless you have a lot of knowledge about the implementation, which is bad programming practice and goes against duck-typing. 
ahm. which Active Record version are u using? The query generated would be like this "select * from models order by RANDOM() limit 1" so the command is offloaded to the database RANDOM function which is optimized for picking a random row and the limit 1 in query would ensure that it doesn't go wild. 
In the post I mention preferring methods like `merge` to create new copies. I also mention that `dup` is shallow. I don't want anyone thinking it's a magic bullet. It can however be useful in some circumstances. I often see people just take objects and start mutating them with no real consideration of other places that might use the original object. As for your example, I would expect the object to know how to properly copy itself. In the example you give I would consider that a bug in the object. I would say the purpose of `dup` and `clone` is to avoid having to understand the implementation of the object in order to copy it.
This is just flat out wrong. ActiveRecord version doesn't matter. Yes it offloads the randomization to the DB. But assuming you're talking about MySQL doing `ORDER BY RANDOM()` creates a temporary table in memory and queries from that. It is terribly slow and is not a scalable solution.
I agree to this. The snippets there are not the best way to implement the said items. Though I would say if something simple can be implemented by core libraries of ruby try to go with it, instead using a gem. Using gem could lead to unnecessary dependencies. 
Then what would be a better query to get a random value from the table?
I use the Class.new approach when defining different error classes. Since they often inherit from StandardError, you can do stuff like this: InvalidParamtetersError = Class.new(StandardError) IncorrectWhateverError = Class.new(StandardError) Cleaner than having semi colons all over the place...
Hi. You're a lot more likely to get help if you: * Format your code better, or perhaps put it in a [gist](https://gist.github.com/). * Tell us what is happening, and what you would like to happen. Are you getting any errors? Perhaps it's returning the wrong number? Setting you computer on fire?
Why not remove a layer and go straight for Google Compute Engine and run whatever Ruby version you want?
Looks cool! Something like jsfiddle for ruby/python/r, but I can't find any case to use it, sorry. Mostly github gist and pastebin cover all my needs. UPD: An idea about sharing scripts to less-techinical stuff is great, but there is a lot of questions about security and sharing limit. 
This is beautiful. I just submitted code for a coding interview for blackjack last week. Wish I'd known about this.
Thanks!
This was a simple version, but the code is set up so I can easily add features like that. I'll be sure to put that in the next version!
Some properties: 1. It's shareable between multiple 'it' statements. 2. It's lazily evaluated first time each test calls it (use let!(...) if you want eager evaluation) 3. It's value is cached if called multiple times in same spec (but not between specs) Example: let(:some_name) { SomeClass.some_expensive_method } it { puts some_name.object_id; puts some_name.object_id } =&gt; 12345 =&gt; 12345 it { puts some_name.object_id } =&gt; 67890 To get identical behavior, you'd have to do: def some_name # `@some_name ||= SomeClass.some_expensive_method` # is not equivalent because it'll recalculate methods that return `false` or `nil` if defined?(@some_name) @some_name else @some_name = SomeClass.some_expensive_method end end Note that just using 'before' syntax is not equivalent because it's not lazily evaluated. One way where lazy evaluation comes in handy is when your 'let' statement depends on a variable (or another 'let' statement) you set later or in a nested context, e.g.: let(:account) { user.account } context "for regular user" let(:user) { users(:user) } it "should not have an admin" expect(account).to have_admin end end context "for admin user" let(:user) { users(:admin) } it "should have an admin" expect(account).to_not have_admin end end This syntax also flows nicely with RSpec's idea of behavior-driven development, where you extract out environment/setup variables from main test in a mathematical-like definition, for a clear separation between things you *start* with in order for your test to be possible, and things *you actually want to test*. Some people love this style (myself included), and others hate it, usually because they think it over-abstracts specs which are supposed to be very simple). DHH (creator of Ruby on Rails), for example, falls into the last category. :-)
I do for a couple of reasons. The big one that comes to mind is, it is only invoked when used. So you can have a before block in the parent that uses the value from let: describe User do let(:user_params) { first_name: "bob"} before do foo = User.new(user_params) end context "with invalid user" do let(:user_params) {first_name: 123123} it should_not be valid? end context "a valid first_name" do it should be valid? end end Could you just create a local variable, sure. But because of how nesting works, you can do some more complex things by changing one variable in let and let nesting do the rest.
It's probably a good thing you just implemented your own solution from scratch. I'm sure that would have defeated the point of the interview assignment if you just imported a gem that does most of the heavy lifting.
Yup good idea, I need to check if that's authorized by the client. Edit: It's not, for security reasons.
No choice here on the hosting provider. Google Compute Engine might be a better option as /u/danielkza wrote.
Ты вообще охуел, на испанском писать?
I'm not sure why in your example `login_user` is written in context-level instead of example-level. In all my tests logging in a user is always done before each test, using `before` statement (which defaults to `before :each`). `let` (as well as `let!`) statements re-evaluate between `it` examples and should therefore be fresh instances. So they work well when combined with `before` (each). Not so well if you are using context-level setups or `before :all`, but the latter has so much problems with concurrency, race conditions, etc. that I never use it anyways, even if it ostensibly can save you time on setup.
* Doesn't pop of MutableStack need to return the popped item instead of @store? If so, then the implementation of ImmutableStack would also need to change. * ImmutableStack needs attr_reader for :head and :tail.
You're right, it should not return @store, but self, rather, fixed this. As for returning a popped item instead of self, you're right too, it was just easier to implement. When popping off the immutable stack, it should return a new instance, that's why I chose the self return rather than the item. So that popping should be: stack =stack.pop head = stack.peek 
I thought pop should return the last value (as Array#pop does). But that would make immutable stacks impossible (well, except for multiple return values or some other solution). So I guess I'm wrong and one would always need to peek to get the value and then pop to get a new stack?
That's right. Immutable data structure should always return itself when performing destructive operations, so the interface requires getting used to.
Ok, thanks. And now you have a new feed subscriber :)
I wouldn't call jruby or google app engine "super niche" 
You should ask this on the jruby email list.
That is a very smart idea sir ... I always forget these lists...
This article explains how you can have user uploaded images automatically moderated by human expert moderators to make sure that only appropriate content is shown to your users. Integration code samples are available for Ruby. Disclaimer: I'm one of the co-founders of Cloudinary.
TBH, if someone was resourceful enough to find a gem that did most of the work for them -- that's the sort of person I'm interested in hiring.
What if you just want the indecent pictures? Say for example a community for nudists and you have rules that say that all pictures must be of naked people. Surely a common thing to want! :)
You know, when Sandy Metz proposed this I am rather certain it was to see how many idiots would jump on the bandwagon ... Sorry to violate the MINASWAN rule but as developer, let alone as an engineer, I find shit like this is just plain insulting since it presupposes that one cannot review code without dis-engaging higher brain functions. &gt;&gt; If this is all that a UserCreator has to do then Users can create themselves for now. Or one could be anticipating change to the creation function or additional responsibilities for the class in the future. &gt;&gt; Looking at this rather large method disguised as a class I don't really have to squint to detect cyclomatic complexity. &gt;&gt; but when I start having to write a stack trace on my arm to remember where I came from Again, whats wrong with reading the code? What about where the class is called from? If this is part of a class using the command pattern perhaps this makes perfect sense. Context! &gt;&gt; But by the time you get to the 6th level Seriously? &gt;&gt; Clarificatory comments, thumbs up! Code that requires an accompanying multi-chapter essay to understand, thumbs down. Ahh, a member of the anti-documentation squad; well that one is a matter of opinion but again, why the hell do I need less than 20/20 vision to gain this valuable insight? &gt;&gt; If a method needs 8 arguments in order to know what job to do And someone didn't get a clue at the 7th argument that they needed to refactor? I really hope for a wireless future since I fear that the first person who I come across squinting at code and commenting on it is going to end up throttled with their keyboard cord. 
then just deny everything webpurify approves :)
`rescue Object` is pointless, `rescue Exception` will always be sufficient. EDIT: re the rest of the code. IDK, for what it does `Main` seems way, way over complicated with what appears to be gratuitous use of metaprogramming. But it's a fun read :)
Yeah I know what you mean, I've only started scratching the surface. It seems like the Rails of command line apps.
he said **local variable** you're using an instance variable in your examples. A local variable **is** sharable between different `it` blocks. The only downside of a local is that it's evaluated at the point it's defined, but from then on it's not re-evaluated (afaict).
Cloudinary can actually work with you on creating your own moderation rules, making sure your photos adhere to your specific specs - no competing brands, face included in the photos, mandatory nudity, etc ;)
So? You will still be learning ruby if you use sinatra. I do not recommend you trying to reimplement Rails or Sinatra from scratch.
One of its uses. But you are thinking if you just have a ruby file sitting on a web server, and gets executed by the server.. (like php)... this is not how ruby web apps are structured. 
Are you familiar with the 'hub' gem? It adda github specific commands to git, and may include what you've implemented here. Not that there isn't room for competition, of course!
Is let! really eager? I thought the point of that one was that it was evaluated once and then reused, while normal let will be reevaluated for each it statement.
Hub does some of the same things like being able to add a Github remote locally. Fast Github however, will first check to see if there a local git repository already made. If not, it will create a new one then it will create your Github repo, make an initial commit, and push it to Github all with one command. I don't know how many times I've had to do that process so I figured making this gem would be a nice timesaver. 
Very neat.
Woah, okay, I did not actually understand that. I had no idea. Why is that? I can do that in other languages.
TBH I can't think of anything specific gem wise but hopefully someone can be more helpful. It's not quite "off the shelf" but if you're happy with a web interface, Rails is ideal for this (and TBH almost any gem is probably going to end up having a DSL that has learning curve). If you wanted a text or graphical UI it's as much down to just selecting a DBI/ORM (e.g. sequel, activerecord) and UI tools (Shoes/QT/readline) and writing something. Of course if you're talking about something for a online store there are many e-commerce engines out there...
Nice list, some ones in here I never knew / forgot about. One correction: your return for `.lstrip` also removed the trailing whitespace: * ' roomy in here '.lstrip # 'roomy in here' 
Check out the guard gem. There are some live reload plugins for it.
Why shouldn't you update prod data with migrations? Should you use rake tasks instead?
Sorry but that doesn't look clean.
preach it. The important parts of testing you can print on a piece of paper - adding more complexity doesn't assist at all with the definition of problems which is the core difficulty. As if anything needs more accidental difficulty :)
Shouldnt `s.Month.split("/")[0].split("(")[0].strip` be replaced with `s[%r'\A[^(/]*'].strip`
Do not know if my regexp work, but this is a wat to make it a bit more readable: def index date_from_text =&gt; x { DateTime.strptime("2000, #{x.Month[/(\w+)/]}, 01", "%Y, %B, %d")} @schedules1 = Schedule.where(location: params[:location]) @schedules = @schedules1.sort_by(&amp;date_from_text) end
And this logic should be in the model, not controller. Example code for the controller: def index @schedules = Schedule.for_location(params[:locale]).sort_by_something end
Some good points, some opinionated points. 'Using Query Methods Outside Models' - This is completely situational. If a query is only used once in relation to a model, then why add it to a scope? It just means I need to switch between my controller and model to understand what's going on when it's completely unnecessary. Concise code is great, but don't sacrifice readability for it. 'Using Unless Or Negative Expressions On Conditionals' - I don't think using negative conditions is a bad thing. It just requires a minor amount of additional brainpower - I find it good to flex my brain once in a while when programming.
We use binscripts at work
I really think you're reading this post too literally. Coming at this article without any baggage, I read it as a pretty clear "here's some stuff you can see at a glance before digging into the details" kind of post. And as for this &gt;Or one could be anticipating change to the creation function or additional responsibilities for the class in the future. and this &gt;Again, whats wrong with reading the code? What about where the class is called from? If this is part of a class using the command pattern perhaps this makes perfect sense. Context! You're presupposing that the only reason to call something out in a review is because it's very definitely wrong. It's equally valid to call something out simply because you want to know the author's justification for doing things that way. Maybe the "smelly" way to do things was the right one in context, but if that's the case then the author should be able to (and should be *expected* to) defend the choice.
This is perhaps not the answer you have been looking for, but have you considered Vagrant+Virtualbox? It will eliminate most pain points for developing in Windows in the same manner as Nitrous did, but with superior performance of course.
&gt; Now that I've got this, are there any other known "gotchas" that may affect me when trying to develop on a windows machine? Your development environment should be as close as possible to the environment you are deploying to in order to avoid unexpected behavior - both configuration and runtime bugs. In other words, Windows is viable if you're developing ruby apps to be run on Windows machines; for most ruby web apps you'll be deploying to Linux servers so you should either be developing on a Linux machine or a Linux virtual machine via Vagrant/VirtualBox/VMWare/cloud VM. (Fun fact: as I'm typing this response on a Windows 7 machine, one of the monitors is a Lubuntu VirtualBox VM in fullscreen where I'm also playing around with a simple Sinatra app) As for cloud IDEs, [Codio](https://codio.com) seems to be a lot faster than Nitrous.io though I've never really used both for that long to give a good performance assessment.
That's a good point. I will probably go the way of vagrant, although Codio looks promising - I will check into that as well. Thanks.
I will try creating a new box and see if that helps.
I would say spool up a Digital Ocean instance, SSH into it with puTTy and learn tmux and vim. Trust me, you will thank me later.
How are you testing that the values are not being saved? It is possible the underlying dbm library is not immediately syncing the changes to the file and may be waiting until the database is closed to do so. To answer your question more directly, you can use your original approach, but you have to ensure the database gets closed properly. This is the same as most of Ruby's file operations. The block forms close things for you, and the non-block forms do not.
I honestly need to write myself up and give myself bad marks for not documenting my experience. However, when I was attempting to create a development environment in windows using Ruby, I encountered many issues. The first one is, it's difficult to work with multiple rubies in Windows. Not impossible thanks to pik and/or custom solutions involving environment variables, switching your path, and NTFS junctions. You may still run into issues between 32 bit and 64 bit rubies and various gems when trying to get things working. I believe nokogiri was one gem that loves to barf on my while trying to make things work in windows. There was also a particular component in rails that seemed to hate me. Vagrant does work small wonders, but, because of it's inability to do certain port forwarding configurations, it ends up not being as practical as simply installing virtualbox and managing everything yourself. But, that also requires a bit of knowledge and know how to accomplish. This is the biggest one in which I hate myself for not documenting, but, I encountered an issue where I couldn't route requests to my rails app while it was running in Vagrant but, I could manually set things up with Virtualbox, yet, having forgotten the original issue, it's completely possible there's now a valid solution, or even there was one that always existed I was simply not aware of it. In general though, my experience has lead me to believe that the number of hoops I'd jump through to acquire a linux or mac based ruby development environment are preferable to attempting to coerce Windows into being a happy camper.
I 2nd Codio. I started on Nitrous and the terminal window was constantly locking up if you didn't use it for a few seconds. I have yet to see this on Codio. Also Codio seems more lenient with what you are allowed to install. Plus, there IDE window panelling works much better.
I will also vouch for a VM. I use VMware Player, and it works phenomenally. Usually. The performance is great, everything's awesome. Only complaint is that the pause feature is unreliable, and things get even worse if my computer goes to sleep while the VM is running. YMMV though; most people don't have these issues, and I still use a VM because it's amazing. Especially with 2 monitors, I usually run Chrome in left monitor and the VM with source code/terminal/etc in the right one.
Nokogiri is a pain in the ass on Linux too. I'm so intimately familiar with the dependencies and debugging it because it is so difficult to set up. Things are a bit better now that the gem includes libxml2/libxslt, but even today I spent an hour debugging my gemfile because nokogiri decided to stop building.
Assuming this is regular SQL, then to comment out the rest of a line add a "--" (two dashes) at the beginning of the part of the line you don't want. Prefixing a part with "/*" and ending it with "*/" will comment out a specific section (without the quotes). Note: this isn't really a ruby thing unless I read you're question wrong and it really shouldn't be posted in /r/ruby to get the most help. 
I'm using SQL in my RUBY.
Try setting up an environment in virtual box with your favorite linux distro. It's not all that difficult and you shouldn't run into an odd problems like you do with windows. That is how I have been developing with ruby and it has worked great.
In a way, I'm happy to hear I'm not the only one that has struggled with it, yet, I also sympathize.
Can you include the ruby code that is calling this SQL query? I think it would help if we had a bit more context. I'm guessing the string containing your SQL query either does not have line breaks or they're getting stripped somewhere, causing the rest of the line to be commented out instead of just the comment. Also, Rails (edit: specifically ActiveRecord) is the most popular way to talk to a SQL database from Ruby. It might be overkill for what you need, though. If you're using Rails already, then you should ideally use the Rails query framework instead of writing your own raw SQL. You also might have better luck posting in /r/rails, even if you're not actually using rails, since they're used to working with SQL from within Ruby. If you're not already, you could try using a here-doc for the SQL query, that might fix it, here-docs are great for preformatted text: sql = &lt;&lt;-END_SQL select * from employee where emp_id = '123' --comment and where city = 'SEATLE' --comment END_SQL Employee.connection.execute(sql)
**Code**: http://pastebin.com/ejPxnbcD **Full output**: http://pastebin.com/5HgSYB4c
I would guess that it's due to `Integer#succ` being the same as `x + 1`, but implemented in the underlying C. Toggle the source on [`Integer#succ`](http://www.ruby-doc.org/core-2.1.2/Integer.html#method-i-succ) to see.
First of, your benchmarking code is rather flawed. For example, it doesn't perform any warmups nor does it present the standard deviation. I highly suggest using https://github.com/evanphx/benchmark-ips for your benchmarking needs. To answer your question, `Fixnum#succ` isn't really faster than using `x = x + y` or `x += y`. Some of the numbers sometimes differ but the difference isn't really big enough to give any solid conclusions. Consider the following benchmark: # gem install benchmark-ips require 'benchmark/ips' number1 = 0 number2 = 0 number3 = 0 Benchmark.ips do |bench| bench.report 'assign' do number1 = number1 + 1 end bench.report 'plus assign' do number2 += 1 end bench.report 'Fixnum#succ' do number3 = number2.succ end bench.compare! end The results of this benchmark on MRI 2.1.2, Rubinius Git and JRuby 1.7.12 are as following: ## MRI $ ruby --version ruby 2.1.2p95 (2014-05-08 revision 45877) [x86_64-linux] $ ruby /tmp/bench.rb Calculating ------------------------------------- assign 157393 i/100ms plus assign 160474 i/100ms Fixnum#succ 160860 i/100ms ------------------------------------------------- assign 9168220.1 (±2.6%) i/s - 45801363 in 5.000026s plus assign 9021198.0 (±3.6%) i/s - 45093194 in 5.006689s Fixnum#succ 9304395.4 (±1.7%) i/s - 46649400 in 5.015444s Comparison: Fixnum#succ: 9304395.4 i/s assign: 9168220.1 i/s - 1.01x slower plus assign: 9021198.0 i/s - 1.03x slower ## Rubinius $ ruby --version rurubinius 2.2.10.n196 (2.1.0 58d39773 2014-07-15 JI) [x86_64-linux-gnu] $ ruby /tmp/bench.rb Calculating ------------------------------------- assign 193446 i/100ms plus assign 253741 i/100ms Fixnum#succ 270561 i/100ms ------------------------------------------------- assign 4680120.3 (±0.9%) i/s - 23406966 in 5.001808s plus assign 4027277.7 (±0.9%) i/s - 20299280 in 5.040840s Fixnum#succ 4669710.2 (±1.0%) i/s - 23538807 in 5.041234s Comparison: assign: 4680120.3 i/s Fixnum#succ: 4669710.2 i/s - 1.00x slower plus assign: 4027277.7 i/s - 1.16x slower ## JRuby $ ruby --version jruby 1.7.12 (1.9.3p392) 2014-04-15 643e292 on OpenJDK 64-Bit Server VM 1.7.0_65-b32 [linux-amd64] $ ruby /tmp/bench.rb Calculating ------------------------------------- assign 205102 i/100ms plus assign 268191 i/100ms Fixnum#succ 263914 i/100ms ------------------------------------------------- assign 14741193.9 (±23.8%) i/s - 67683660 in 4.996000s plus assign 15249764.0 (±22.0%) i/s - 70266042 in 4.988999s Fixnum#succ 13996758.2 (±20.9%) i/s - 65714586 in 5.008000s Comparison: plus assign: 15249764.0 i/s assign: 14741193.9 i/s - 1.03x slower Fixnum#succ: 13996758.2 i/s - 1.09x slower ## JRuby 2.0 mode $ ruby --version jruby 1.7.12 (2.0.0p195) 2014-04-15 643e292 on OpenJDK 64-Bit Server VM 1.7.0_65-b32 [linux-amd64] $ ruby /tmp/bench.rb Calculating ------------------------------------- assign 176983 i/100ms plus assign 247946 i/100ms Numeric#succ 240175 i/100ms ------------------------------------------------- assign 13575743.0 (±25.8%) i/s - 61767067 in 5.000999s plus assign 15248272.3 (±15.6%) i/s - 73392016 in 4.990000s Numeric#succ 13989059.9 (±18.9%) i/s - 66288300 in 5.007000s Comparison: plus assign: 15248272.3 i/s Numeric#succ: 13989059.9 i/s - 1.09x slower assign: 13575743.0 i/s - 1.12x slower The standard deviation being pretty high on JRuby is certainly interesting, not sure what's causing that. If we look at the C code used for `Fixnum#succ` in MRI it's not entirely surprising to see why it more or less performs the same: static VALUE fix_succ(VALUE num) { long i = FIX2LONG(num) + 1; return LONG2NUM(i); } This converts a Ruby Fixnum into a `long`, adds `1` to it and then converts it back to a Fixnum. In Rubinius the same is done but in pure Ruby: &lt;https://github.com/rubinius/rubinius/blob/master/kernel/common/integer.rb#L165-L167&gt;. For both Rubinius and JRuby you could probably get better results by pre-configuring certain VM settings (e.g. the amount of method calls required before the JIT optimizes a method) but I haven't bothered with that for these benchmarks.
What about the fact that `x = x + 1` performs a type check and calls `FIX2LONG` twice, while `x = x.succ` only calls `FIX2LONG` once, and doesn't have a type check? In `Fixnum#+`: if (FIXNUM_P(y)) { long a, b, c; VALUE r; a = FIX2LONG(x); b = FIX2LONG(y); c = a + b; r = LONG2NUM(c); return r; ... In `Fixnum#succ`: long i = FIX2LONG(num) + 1; return LONG2NUM(i); I originally thought that was the reason, it doesn't come into play?
this is what I do whenever I have performance issues on my nitrous box
You won't need Rails to interface with your DB, just an ORM (in default Rails case, that being ActiveRecord). That said, I'd suggest taking a look at Sequel over AR. https://github.com/jeremyevans/sequel 
Integer#+ is implemented in C, too.
I'm working on something similar with a friend of mine. It's not ready for prime time, but if you're interested we'll let you know when we get closer to releasing the code.
Standard deviation on JRuby may be down to warm up times, JIT threshold, and garbage collection pauses (off the top of my head).
he is just trying to do a sarcasm
While I find this academically interesting, I think I would neck-punch a developer using this "optimization". 
I think the speedup is just not as significant as OP thought. Probably anywhere that you can use a static rather than dynamic method in any language would result in a slight speedup. ++ to benchmark-ips! Just saw tenderlove's keynote where he used it and was like :O i have been lied to this whole time
FIX2LONG and LONG2NUM should be basically free, since most ruby interpreters use tagged pointers as their basic data type. This means that the fixnum data is stored *in* the VALUE pointer, and the conversions are just bit shifts. There's no case in a reasonable ruby program where these macros getting called a couple more times will be your bottleneck.
What terminal is this?
It's this theme with zsh: https://github.com/itsthatguy/itg.zsh-theme He also makes a killer sublime text theme that I use: https://github.com/itsthatguy/theme-itg-flat
The macro `FIXNUM_P` merely checks for a certain bit in the value, thus the overnead is next to zero. `FIX2LONG` also performs a bit operation on the value in order to get the raw C `long` / `int` out of the Ruby object, thus again the overhead is should be very small. In other words, it *could* be the case but I doubt there's actually any substantial difference. It certainly wouldn't be something that would be worth optimizing for the average application.
These should all be taken care of by the warmup cycle of the benchmark. I also doubt it's the JIT as I'm pretty sure the addition of values is performed in constant time, even when the methods involved are not optimized. The GC however could certainly be a factor.
&gt; `MyCustomGoodError = Class.new(StandardError)` &gt; Not only cleaner syntax but also saving garbage collector work by storing error in a constant rather than creating object every time when raised. Huh? :)
In other languages, there is a "handler".. for example a commonly used language, php uses a module for the web server(ex: mod_php w/ Apache) or CGI/FastCGI to handle the requests to interpret the PHP. This is the magic behind the scenes that allows you to execute a .php file on your web server.. If you had no module to handle *how* the PHP is interpreted then you won't be able to just execute the PHP.. the web server won't know it needs to do anything special to these .php files. You actually *can* run Ruby this way on Apache with mod_ruby, but mod_ruby is old unused.. mostly because the applications are designed in a different way than executing a bunch of scripts.. such as Rails and other MVC frameworks. I hope this makes sense!
I'd never thought of using `rand` on a range of dates before. Nice!
What exactly is 'hidden' about any of those? Maybe some are not well known, but they're all documented, are they not?
Thanks for spotting. It was a mistake. Removed.
Only allowing a specific set of operators is called an *object invariant* of `Operation`. So, `initialize` is indeed the only place to make sure the object's invariant is satisfied.
It does make sense. So what makes a framework any different? Also what does and admin do if say they... have an entire static HTML site being served by apache or nginx or what have you, and then they want run a Ruby program, like a wiki or textboard or blog?
rails
knew them all except `zero?` and `nonzero?` (which i still don't see the point of! why return `self`?) and 'better errors' (what difference?)
Most of these are well known to anyone who is at least a bit interested in knowing the language they are working with, but then again this sub is full of beginners and mediocre nonbeginners.
Ya that actually is bad. any method that ends in `?` i think should return a bool
Useful for when you want to treat 0 as a falsey value, as in some languages and contexts. error = sys_call_return.nonzero? if error # do stuff based on error code end
As far as I know, 30.days.ago is not available in standard Ruby, it's an active_support core extension.
As long as it's enumerable (i.e. a date range, not a time range), you should be able to just `.sample` the range.
Yeah, pretty sure this is absolutely correct. Although, I guess he never states he's sticking with the stdlib... :)
Some of them are a **little** bit obscure, but the vast majority are methods or techniques that I'd think most of us picked up very early on and are used almost daily.
... and which category do you fall into?
Yeah, that's definitely the expectation. I'd have no issues with the way this method works if it didn't have the ? on the end.
that's a gem. the post is about the parts of the ruby stdlib.
Every one of these shows off inline rescue, and the comments of every one of these needs somebody to point out that inline rescue is considered harmful. I guess I'm that somebody this time.
Every time in see something like this I can't help but think "what could someone clever enough to do this have created if they spent their time on actually useful things."
Wow, the story of my life. I guess I'm just getting old, but I have never been so frustrated as I have been in the recent past just trying to set up any environment to be able to try to learn to code in. The other day I decided to try to use grunt.js to create a new environment to build wordpress websites in, I opened virtual box, downloaded ubuntu to my 64 bit system, started to install it, and received an error stating that I was trying to run a 64 bit operating system on a 32 bit machine. That's right, I didn't even get to the point of using the command line in a system I'm not familiar with at all, I couldn't even install the damned thing. The same thing has happened trying to create a ruby environment like you're doing. It's been a very long-term frustration that I come back to every now and then to make another stab at only to be stymied one more time. Sorry for the rant, but maybe persistence pays off in the end, I'm just not so sure.
But it breaks the contract of the ?. The standard ruby convention is that any method with a ? will return a boolean value. By returning self or nil this completely breaks that contract and is unexpected. This is a valid case but the method should not have a ? if it does not explicitly return a boolean. Your example would be the same if nonzero? returned a boolean like it should if it followed convention. I assume the implementor had some reason for breaking convention but I am not aware of what that reason is.
I would expect "ffi" to be up there, too. ruby 1.9.3 introduced "io/wait" which should be getting used more with console/CLI apps. Perhaps, its too early for it to show up in such results.
I'm glad someone said this.
This just smells like a homework assignment. If you are truly having a problem understanding you will get a whole lot further if you show some code with expected and actual output. 
Hey, thanks for your reply. I actually should have realized something else was up... looking at the db file shows a bunch of binary goop, but it definitely had some of the keys that I had initialized. The library only allows for strings to be used for keys, I guess, and I was trying to do something like @db['hash_key'][hash_value], which is evaluating as @db.fetch('hash_key') and then trying to index whatever gets returned. So if you or anyone else has any ideas on how it might be possible to access these elements I would be elated... Otherwise, I guess I'll just build my structure first and then save it. Oh well, questions for tomorrow. Cheers
Then your expectation is wrong. The correct expectation should be that it returns a truish value if the condition is true, and a falsey value if not.
Just don't try to traverse a range of dates and you'll be fine :)
It's really annoying when people don't know the difference between Ruby and Rails. And there are too many of those people.
In general, `+=` not only reassign a value to the variable, but also re-declares the variable *itself* in the lexical scope, while method calls such as `.succ` do not. If working with "real" (mutable) objects like String, the biggest difference is that `+=` will create a new String while calling a method like `.concat` will not, obviously making a performance difference both time and memory wise. Integers are immutable singletons (and probably stored directly as value instead of creating pointer to reference) so `+=` vs `.succ` will not have all of the issues compared to `+=` vs `.concat` for String. However, there is still the issue of lexical scope of re-declaring a variable - the work the `binding` which keeps track of variables themselves (rather than their values) has to do when a variable is assigned or reassigned a value using the `=` (or `+=`) syntax. Because `.succ` does not re-declare the variable (and `binding` only has to resolve it's location to send it the message, as opposed to reassign it) it may be quicker.
It supports docker now.
You can take a look at the source code [here.](https://github.com/ruby/ruby/blob/trunk/lib/csv.rb)
Because that's free for their client.
&gt; @db['hash_key'][hash_value] Honest question: why would you do that? Setting a value should look like: @db['some_key'] = value And fetching a value should look like: value = @db['some_key'] The advantage of using YAML::DBM is that it will convert the value to a YAML string, and then back again when you retrieve the value. This is because DBM only allows string keys and values. Try using YAML::DBM to store simple values and see if you can get that working first.
I did play around in pry until I got it working with simple values. The problem is that I wanted to store a hash of hashes and access them individually during runtime directly from the database. What I had before and what I guess I need to do is just do a full load of data before execution and a full save of the entire hash after. I don't really know why I wanted to stray from this paradigm. Oh well, thanks a lot for your help.
Gotcha, that makes sense. There is definitely nothing in the language that says "?" must return this type or "!" must throw an exception, these concepts are just general style decisions that the community comes together on but certainly nothing stops someone from breaking those paradigms. Personally, I think that breaking it is worse than the utility of returning a truthy or falsey value. Also it seems that this causes that variable to effectively be re-named and then used later which imo doesn't provide a lot of benefit over just checking and then using the original var either branch. I realize this is very much a personal opinion.
I ported this code to a gist in case someone wants to try it out but is too lazy to code it up: https://gist.github.com/udit99/569f990b91a06494be38
You proxy it over to a ruby application server OR use Phusion Passenger for apache/nginx. Most(atleast all *modern* ones do) ruby web frameworks use rack, which provides an interface between your code and the web server, which get served by the application server and proxied to nginx/apache.
 0 8 * * * /usr/bin/ruby /home/pi/Facebook/facebook.rb My ruby is located via /usr/bin
I changed the root cronjob because I had it under a user so the cronjobs were different. I will see what happens tomorrow.
Thanks for this detailed response. I think cross-platform support is very important too. I think the ruby community would grow as a whole if dev environments were friendly across the board.
http://ruby-doc.com/stdlib-2.0/libdoc/csv/rdoc/CSV.html
Isn't this exactly what code climate does?
Author here! I was planning on posting this later but oh well, the cat's been out of the bag for a while now :D I built this gem for my Master's thesis so, as you can imagine, I'm mostly looking for feedback at this point. I know that people want features done (as do I!) but I have my thesis to write so development will be slow in the next month. I plan on having a chapter on open-source and what effects (if any) my gem had on the Ruby community. Tell me what you think is good and bad about the gem and how it should be improved. Tell me if you find it useful at all or if you'd just rather use the core gems (Reek, Flog, etc) separately. And are you **not** using Code Climate? Why? Are you using something else? Describing the setup of your continuous integration and deploy process would also be extremely helpful.
I'd say my favorite part of the Ruby Standard Library is [Pathname](http://www.ruby-doc.org/stdlib-2.1.2/libdoc/pathname/rdoc/Pathname.html). It's just amazing. I took every opportunity I could to use it in my gem [RubyCritic](https://github.com/whitesmith/rubycritic). You have a path to a file. Want the path to its directory? `pathname.dirname` Want the file's name? `pathname.basename` Want the file's name without the extension? `pathname.basename.sub_ext("")` Check how easy it is to do convert something like `"stylesheets/application.css"` to `"../../../assets/stylesheets/application.css"` with pathnames. Here's the test: https://github.com/whitesmith/rubycritic/blob/d85f40648e421398cd509e50f16824fa9b199bc3/test/lib/rubycritic/report_generators/view_helpers_test.rb#L75-L76 And here's part of the implementation: https://github.com/whitesmith/rubycritic/blob/d85f40648e421398cd509e50f16824fa9b199bc3/lib/rubycritic/report_generators/view_helpers.rb#L31 `relative_path_from` is pure magic.
https://weworkremotely.com/ would be a great place to poke around.
This might sound like a strange question, but what timeline are you in? I've had stuff break at 8pm local because it was midnight UTC.
PayPal has offices in Omaha, I'm not sure what their framework is. LinkedIn and Google have a presence as well but they're both Java/Python shops. I'm in San Francisco but would love to move back to the Midwest if it wasn't a .Net backwater.
I wish I could move but have roots here I can't leave at the moment. The Midwest definitely is stale for tech as far as languages and cutting edge goes. 
If you're in the Lincoln area, PM me. I might be able to help.
I live in the Eastern time zone!
String and symbol. 
I've been working really on hard on this gem for the passed 4 months. It has made me very productive at work and I really want to share it with the world. 
IIRC only rails uses the "!" for exception-throwing versions of methods, in the standard lib it usually means you're modifying an instance in-place.
My company's Ruby devs are spread out all over the US. 100% remote and we need more (ideally mid to sr. level). PM me if you're curious.
&gt; Detects security issues (which means it integrates the Brakeman gem) &gt; Shows test coverage. You still have simplecov for that, but it would be nice if RubyCritic had that. Unified interface and all that. Are you planning to intergrate Brakeman and simplecov into RubyCritic? :)
That would be the plan, yes :D
Faggot.
Haven't really read "Core Python Applications Programming" but you might want to check out Hal Fulton's The Ruby way for lots of example code around most of the standard library. For exercises, the best way is to take each sample, try to add a few features to it, add some tests to it, document it, and then try to post it to blogs/reddit for feedback etc. That is not just the best way to learn, imho, but the only real way to learn.
Right. There are many methods that do not follow that convention. For example Array#insert or String#Insert will modify the calling object but do not have a !. I think the following statement from the creator himself described the bang method well: &gt; The bang (!) does not mean "destructive" nor lack of it mean non destructive either. The bang sign means "the bang version is more dangerous than its non bang counterpart; handle with care". Since Ruby has a lot of "destructive" methods, if bang signs follow your opinion, every Ruby program would be full of bangs, thus ugly. [1] These conventions are just that. Sometimes they are followed sometimes they are not. [1] https://www.ruby-forum.com/topic/176830#773946 
Sounds like a push in the right direction. Thanks a lot. 
Great, thanks!
Copying my response from the last time you posted this: In the post I mention preferring methods like merge to create new copies. I also mention that dup is shallow. I don't want anyone thinking it's a magic bullet. It can however be useful in some circumstances. I often see people just take objects and start mutating them with no real consideration of other places that might use the original object. As for your example, I would expect the object to know how to properly copy itself. In the example you give I would consider that a bug in the object. I would say the purpose of dup and clone is to avoid having to understand the implementation of the object in order to copy it. 
&gt; Oh, Hey guise we have a company developer blog!1~!1! we give it a fancy name, a fancy design, and have absolutely nothing interesting on it! We're an awesome company, oh and **buy our product** cos we're hip developers, just like you!
Metaprogrammnig Ruby goes over some useful nuts and bolts in the first half, then examines how those techniques are used in ActiveRecord - it's a great book, highly recommend.
http://railscasts.com
http://rubytapas.com
I have nothing planned for Chef. But I'd love to integrate Rubocop. The UI will have to evolve a bit to allow it but yeah, that's on the roadmap for sure.
"Eloquent Ruby" by Russ Olsen
Well Grounded Rubyist
I'm studying Python. This post is a win!
http://confreaks.com/ for thousands of talks
That too from /r/ruby ;)
I know there are many. Was hoping for a curated collection.
It's good for rubyists to know about `#clone` and `#dup`, but in practice, I'd say it's something that should be used rarely. I use `#freeze` much more frequently to avoid side effects. And, in general, I reduce the number of instance variables I use -- I almost always avoid defining instance variables outside of constructors.
Sorry I had posted just before heading out - my other suggestion would have been to check permissions/environment for the account that was running the cron job. Its unlikely to be time related if the script runs normally when run from the command line.
I think the idea of a must watch list is rather pointless, because what will be interesting to you highly depends on what you want to do with Ruby. Why don't you check the lists of Ruby conferences, look at their schedules and pick the talks that interest you. Most of them are on Youtube or Vimeo. [RubyConferences.org](http://rubyconferences.org/) &amp; [Ruby Conferences listed on Lanyrd](http://lanyrd.com/topics/ruby/)
There's a growing tech community in Cincinnati working with a variety of languages &amp; frameworks. If you're in the Cincinnati area, networking is your best vehicle into the market. The dev community here is helpful &amp; welcoming beyond measure.
This thread has been linked to from elsewhere on reddit. - [/r/NoviceCoder] [Ruby video collection? (xpost /r/ruby)](http://np.reddit.com/r/NoviceCoder/comments/2bv1is/ruby_video_collection_xpost_rruby/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
It's a shame there hasn't been any updates from Ryan for nearly a year
I personally have always used Heroku (Not exactly sure what your client has against it, might be worth discussing), but I've heard many great things about Engine Yard from some of my friends.
[Ninefold.com](http://ninefold.com/) Also, what do they have against Heroku?
If you don't say why they don't like Heroku, it's hard to suggest an alternative.
He doesn't like the pricing factor. He thinks it's absurd to pay 50$ for a dyno and database when there's hosts out there that do it for less - I know, I tried to convince him. No luck sadly.
He's cheaping out late in the game and doesn't like the pricing :/ that's for suggestion I'll look!
This looks pretty promising thanks for the suggestion. 
Thanks for the heads up, unfortunately I'm in Lincoln, NE. 
Summarizing what I've seen in this thread, if the client has issue with the pricing of Heroku, I think any PaaS is going to be a problem. Heroku is one of the cheapest in my experience, and completely awesome. I'd throw them at a VPS solution that you configure and either walk completely away from, or charge a monthly maintenance fee. Digital Ocean has a 1-click Rails setup that should work pretty well for you on Sinatra (but not really 1-click). Linode also would work. They'll be in the $10-$20/month range when it's all said and done, and you'll have to handle the deployment. Capistrano may be your friend here. Don't forget to add backup. 
I've done more research. Seems I'll convince him to use Digital Ocean or Heroku. Heroku is awesome. I love it, I'll just have to convince him to love it. If all else fails I'll just get a VPS and set it up but I wanted to avoid that because thats pretty time consuming on my end.
If he thinks Heroku is expensive, he's not going to like Engineyard. They're easily 5x more.
[Ruby Cookbook](http://shop.oreilly.com/product/9780596523695.do) covers very practical things (like working with your filesystem) and has step-by-step examples while covering a little theory in each section. I consider this to be the best Ruby book I ever bought. The downside: it is very outdated and covers some gems that don't exist anymore. The Python book you're describing sounds wonderful and I wish there was a direct Ruby analogue. 
there are cheaper options for the hosting itself, but he probably doesn't want to hire a sysadmin for the inevitable server problems.
Yup thats how I'm going to pitch it to him. I'm capable of managing it but I dont want to, I just want to be responsible for the app itself.
You could also consider Dokku on a DigitalOcean server. It's essentially a version of Heroku that runs on your own server, and they even have a one-click image for it. Setup takes 5 minutes, and then you can deploy with a simple git push instead of the whole Capistrano song and dance.
Check out cloud 66 https://www.cloud66.com. I setup a previous client of mine with them and it was super easy to get up and running. We used digital ocean for the servers and cloud 66 did the provisioning and setup for deployments. 
https://learn.thoughtbot.com/trails
I deal with a lot of clients who always want to host on the cheap. What I usually discuss with them is that they can go with a VPS, which is almost always the cheapest option, but my fees go way up when I have to become a sysadmin who will potentially be taking calls in the middle of the night for downed servers; not to mention the other day-to-day work that you need to do as a sysadmin.
I like Cloud66 + Linode if not using Heroku. Digital Ocean's performance wasn't nearly as good as Linode :(
Heroku gives you so much for so little. Their operations staff, their database servers, all of it takes a ton of maintenance and when it really matters in an emergency. They're better then you can afford for your own servers. Nobody is perfect, but for a little site like yours, if you want it to keep running years from now without issue, you want heroku.
You're correct about what the Dict.new method is doing. It's not a particularly idiomatic example of ruby though. def Dict.new(num_buckets=256) # Initializes a Dict with the given number of buckets. # As far as i can tell for this bit of code is that it creates an array called aDicts what will store 255 separate arrays # and each time a new Dict is inialized it will create an array that holds 255 arrays aDict = [] (0...num_buckets).each do |i| aDict.push([]) end return aDict end written more idiomatically would look like: def self.new(num_buckets=256) (0...num_buckets).map do |i| [] end end Note: * self.new instead of Dict.new - means exactly the same thing but makes it easier to rename the class * no explicit return statement - return is usually only used if you're returning from a method early * use of map instead of each - this means you don't have to create aDict and push the arrays on In actual fact the code is pretty redundant because ruby provides an array constructor that does it for you: def Dict.new(num_buckets=256) Array.new(num_buckets, []) end
Thanks for the answer. You have given me a push to look into Lua. Certainly, I too feel that picking up something in a day would be enough to do some basic requirements. Let me see. Cheer!
Okay, thats a good one. Let me see.
Nit: The final function you provided is incorrect AFAICT. `Array.new(x, y)` will make an Array of size `x`, with all elements initialized to `y`: irb(main):003:0&gt; q = Array.new(5,[]) =&gt; [[], [], [], [], []] irb(main):004:0&gt; q[0].push(5) =&gt; [5] irb(main):005:0&gt; q =&gt; [[5], [5], [5], [5], [5]] You can use a block if you want different lists: irb(main):008:0&gt; q = Array.new(5) { [] } =&gt; [[], [], [], [], []] irb(main):009:0&gt; q[0].push(1) =&gt; [1] irb(main):010:0&gt; q =&gt; [[1], [], [], [], []]
That is very tricky. I did not and probably would not have caught that.
This is amazing, but I own a nook.
Heroku costs a little bit more because they host on Amazon. The reason you would pick Heroku is to not have to manage/setup the OS, and for the very easy deploys.
Please share your reasons why you love Ruby framework(s) over the numerous Python frameworks for freelance web development if you are given the freedom to choose your platform. Is it because Ruby is new and fun to you, while Python has gotten rote and boring? Or are there other reasons for say Ruby + Sinatra over Python + Flask or likewise the heavier frameworks up against Rails?
Confreaks !
Can I PM you too ?
Add gorails.com also !
I'm pretty new to the idea of mocking and stubs and all that but I'm really excited to take a look at this it looks really amazing from what I can see so far. A very sincere thank you for the time and effort you have put into this project!
If you are junior, Stackoverflow is your best friend.
anyone else creeped out by this dude's website?
Stackoverflow and just generally googling the error. Goggle has been my bestfriend since I started coding.
There is a great developer group in HK. Join [codeaholics.hk](http://codeaholics.hk) It grew out of the HK ruby meetup, so there are lots of ruby experts willing to help out. [meetup.com/Codeaholics](http://meetup.com/Codeaholics) The meetup last month had ~70 people They are also organising a one day code conf.[codeconf.codeaholics.hk] (http://codeconf.codeaholics.hk)
For more recent videos check out Gorails.com
Start looking for another job. Seriously. That company doesn't understand software development and they'll blame you if things go tits up.
I haven't used much Rails. Haven't had the need for it yet. I still develop my large scale projects with Symfony (PHP). Ruby itself.. grew on me. I just love how well put together and useful it feels when it comes to the syntax. I love my Python yes, its what I started with a decade ago. But lately I've had Ruby related projects come my way and its given me a chance to really use it and its refreshing. &gt; Ruby + Sinatra over Python + Flask Well, no point comparing. They both do their jobs well.. its simply a combination of my current work and syntax of Ruby thats making me enjoy it and the experience.
EDIT: Holy crap, I posted everything below and I just reread your question. Here's a better suited response. &gt; I was hired as a junior web developer in my company without mentorship since I am the only developer. Jr developer positions exist so that you CAN be mentored. If they hired you as a Jr developer without any other members on your team, they literally hired you as cheap labor that they can fire when anything goes wrong. This environment is toxic, you should find another position on a real team ASAP. In the interim, use StackOverflow and Google as much as you can. Try looking for a local developer group, or a good IRC channel (#ruby-lang on Freenode, maybe) to ask questions needing some more back and forth than a SO question provides. [StackOverflow Chat](http://chat.stackoverflow.com/) may be helpful as well. Codementor and AskADev from my old response still apply here, probably moreso since you have no other team to pair with, but start with SO and IRC first. PRE-EDIT: &gt; I am feeling stressed from being unable to find solutions. What should I do to improve my situation? Stop getting stressed. As a Junior you aren't typically expected to be able to work alone on many problems, the entire reason these roles developed was to allow young engineers a chance to gain experience while still having the safety of a mentor to help develop their abilities. I am assuming that since you are a Jr, you have intermediate and Sr developers on your team. TALK TO THEM, especially the Sr developers. Does your team have time dedicated to pair program? I have a feeling they don't based on your post, so you may want to ask for some time each week to work with one of your Sr developers and pair up. Take turns at the wheel, watch your partner work and ASK QUESTIONS about their process and when you are unsure why they did something a way you don't understand. When it's your turn to drive, EXPLAIN your thoughts, when you hit a roadblock ALERT your partner so they can provide guidance or be a sounding board. If your team doesn't allow Jr developers to work like this then you are working in a toxic environment and I'm afraid there isn't much you can do about it. As always, there is Google and StackOverflow, but it sounds like you are having trouble stepping through a problem and having problems figuring out how to search for a solution in the first place. If you are willing to pay, there is also [codementor](https://www.codementor.io/), where you can get 1:1 time with experienced developers for any reason you can think of (help debugging a problem, pair programming time, tutoring). Another similar site is [askadev](http://www.askadev.com/) which will be free, but they won't launch for another month or so according to my last email from them.
Rubber duck debugging. It sounds corny, but it works.
&gt; I don't understand the Ruby community's sense of entitlement in terms of junior positions. They're often filled by people that aren't ready for them but even if that's not the case is it too much to ask that a developer has an interest in their own professional development? I know many of us are autodidacts, but many developers need to be mentored through their Jr years to grow and gain the experience to work independently. OP wouldn't be posting if he wasn't interested in developing himself. The company should have never hired a Jr developer if they didn't have anyone to mentor him.
[Engine Yard](http://www.engineyard.com/trial) is great for hosting Ruby/Sinatra apps. It's a bit more high-end than other solutions and has a proven track record.
I have a few fairly low traffic production sites running on WebFaction. I've been happy with the service.
Stress is a part of learning in this field. You will spend hours, days, or weeks trying to solve simple problems. This is how you learn. If your employer doesnt understand this, you should find another job.
My first role as a ruby developer was working with code someone else had written. My general workflow when assigned a task was to ask another developer, politely, where should I start looking. This is a sane question because I was new to the project and at least having some file or class to begin looking at for the task gave me somewhere to begin. This was especially helpful on broad classes or on tasks where the wording in the task didn't make it explicit where the work was to take place. Usually from here, even if the suggested place to look wasn't right, you're learning your codebase. So do the reading of the code, when you see something that's an object or a method, find out what it does. If you finish reading the file and can't seem to find something that relates to the task, or you haven't crawled your way to where you need to be to solve the task, ask again, but present your findings. IE: I looked through frumpdring.rb and sure we've defined the class there, but, the behavior that the task describes doesn't appear to be there, the task is #239 on Quackunote. Do you have any other suggestions for where I could look? If they do, great, repeat! Also make use of tools at your disposal, you know that the problem likely relates to that particular class, use grep -rn keyword * or something similar to find all occurrences of that object. Make note of what files that object appears in, investigate those. This is what the majority of my day was in my first role, just tracking down the chains of thought in the existing app until I could figure out where things were going wrong. So, I've been typing this up when I re-read your comment and realise you said without mentorship :| That part sucks, a lot. This advice -may- still help if there's anyone that knows the project. If not, then it falls solely on what I said about reading the code. 
I hesitantly support this, but not for the reason listed. SO + Google are your friends but not a replacement for a good mentor. You are doing yourself a disservice if you teach yourself everything. It's going to take much longer and the results will be inconsistent. I'm **NOT** saying it can't be done (I did it, for instance). But you'll be better off finding somewhere that provides you guidance. 
&gt; My main problem with Heroku is once you start adding any kind of real work it gets expensive real fast. You can do your best to make the most of it (puma or unicorn running at say 5 instances per dyno), but even the simplest application will incur a bunch of costs. Maybe for toys, yes. For revenue-producing apps though, we've got apps deployed for around $100/mo. Not too shabby for a business. &gt; Want background processing? Well you'll need something like sidekiq and redis. Need to access that redis instance from your web apps? Better add on a paid tier because you are going to run into connection issues. You might want to check out sucker_punch, it was developed for this exact issue. Runs on your existing dynos, does not need redis. &gt; Then there's that annoying dyno spinning down problem which really sucks. If your site is popular this really isn't a problem, but if your app ever takes a nap, that first user is going to have a poo experience. This does not happen outside of the free tier. &gt; In terms of servers, it's low maintenance. But there's other problems that I've encountered with it such as logging. Being able to shell into a box to grab the logs has been pretty helpful. Yes, that's a pain in the ass. My use case doesn't really need to have long-term persistent logs, so I've been able to get by with the free version of the "Logentries" plugin. You can also live-tail your logs without any plugins. 
I agree 100%. There's no substitute for mentoring from a senior dev. I just wanted to point out that he's working for idiots.
&gt; I honestly don't have the time to mess with Passenger and apache configs. So ten to fifteen minutes is too much time for a professional job?
If anyone see a way to can make the read me or the work follow better/more understandable, let me know. I am open to feature requests and actively looking beta testers and contributors. 
I have had numerous issues with this unprofessional client. The app is done, approved and working. I honestly just want to get the job out the door, so in this case yes, its too much time to spend on such a client. A normal client, I'd gladly spend 10, 20, 30 minutes setting this up.
This could have the potential to be the ActiveAdmin of APIs, considering there's out of the box filters and pagination. I'm not 100% if I like the ActiveRecord extensions they have here though, and it would be interesting to see there could be a path for dedicated classes that sit on top of the models as needed. I can also see how the close-coupling having performance benefits though, like exploiting database level JSON-serializers offered by Postgres. 
I think this may be one of the most helpful solutions in this thread. Being able to talk out my problems has helped me on so many occasions (speaking as a fellow Jr. learning ruby). I wish I could offer my time to help! Another thing to consider with debugging is [RubyMine](http://www.jetbrains.com/ruby/). There is a free 30 day trial, and may help you. Anyone else have experience with this? I am not sure what the learning curve might be.
I should problem clarify that I need help understanding what the lines of code are doing rather than refactoring the code. The exact exercise that i need help understanding can be found at the link above. Thanks for your time though.
&gt; plan on not putting this one on yr resume I think that depends if its the only thing on your resume. Shitty experience is better than no experience in a job hunt. If asked why you left I'd even use your phrasing "The hired me as a junior dev, but they didn't have any senior devs." Better than saying, nope never worked before.
i would personally worry about potential employers looking at that as "this person had no idea what they were getting into, how are they gonna scope out work?" But, yeah getting out ASAP would alleviate that concern.
Yeah there are some great screencasts that Ryan has done
Giles Bowkett has been taking up this "Rails is bad at *blah-blah-blah*, Rails is slow at *blah-blah-blah*, Rails doesn't have good libraries for *blah-blah-blah*" battle for at least three years. He makes a bunch of claims, people respond with counterexamples, he ignores criticism [or has a hissy fit for bonus points](https://twitter.com/wagenet/status/309543954838347776), and repeats a few months later. He seems like a frustrating person to talk to.
It works great! For the outsiders lurking: rubber duck debugging is when you explain your problems to a rubber duck. (Or any dumb object). When you explain your problem out loud, different parts of your brain have to fire up to get the words out. That different part of your brain very often has a better grasp of the problem than your internal voice. It's like how some stroke victims can't talk, but they can sing. You're doing the same thing, forcing some different part of your brain to do the lifting. Maybe it's dumber, maybe it's stronger, but it's different and that's all that counts.
I really neat site on ranking programming skills.. Look linkedin?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Law of Demeter**](https://en.wikipedia.org/wiki/Law%20of%20Demeter): [](#sfw) --- &gt; &gt;The __Law of Demeter__ (__LoD__) or __principle of least knowledge__ is a design guideline for developing [software](https://en.wikipedia.org/wiki/Software), particularly [object-oriented programs](https://en.wikipedia.org/wiki/Object-oriented_programming). In its general form, the LoD is a specific case of [loose coupling](https://en.wikipedia.org/wiki/Loose_coupling). The guideline was proposed at [Northeastern University](https://en.wikipedia.org/wiki/Northeastern_University_(Boston,_Massachusetts\)) towards the end of 1987, and can be succinctly summarized in one of the following ways: &gt; &gt;* Each unit should have only limited knowledge about other units: only units "closely" related to the current unit. &gt;* Each unit should only talk to its friends; don't talk to strangers. &gt;* Only talk to your immediate friends. &gt;The fundamental notion is that a given object should assume as little as possible about the structure or properties of anything else (including its subcomponents), in accordance with the principle of "[information hiding](https://en.wikipedia.org/wiki/Information_hiding)". &gt;It is so named for its origin in the Demeter Project, an adaptive programming and [aspect-oriented programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming) effort. The project was named in honor of [Demeter](https://en.wikipedia.org/wiki/Demeter), “distribution-mother” and the Greek [goddess](https://en.wikipedia.org/wiki/Goddess) of [agriculture](https://en.wikipedia.org/wiki/Agriculture), to signify a bottom-up philosophy of programming which is also embodied in the law itself. &gt; --- ^Interesting: [^Demeter's ^Manual ^of ^Parliamentary ^Law ^and ^Procedure](https://en.wikipedia.org/wiki/Demeter%27s_Manual_of_Parliamentary_Law_and_Procedure) ^| [^Demeter](https://en.wikipedia.org/wiki/Demeter) ^| [^George ^Demeter](https://en.wikipedia.org/wiki/George_Demeter) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjaqnju) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjaqnju)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thanks! That's high praise. There's still a lot of work to be done. Ideally MySQL and SQLite3 support, tests, and some additional optimizations (in terms of result parsing). We'll see what makes the most sense in terms of code structure --- ActiveRecord::Base extensions seemed logical upon first pass.
The first ruby conference I went to, not knowing anyone and hanging out alone at the bar, Gilles walks up and introduces himself and proceeds to get to know me. Super nice guy irl.
While it's true that people aren't using rails a la carte the modularisation did provide a lot of value for rails plugins/gems. Prior to the merge the plugins were a bunch of monkey patches and hacks that would regularly break on a point release. The modularisation provided stable extension points that could be built on with confidence. In addition it made it far easier for gems to replace parts of rails, Giles mentions a mongo backend for instance. On another note, why would you want a version of rails with bits missing? There's few apps that don't need everything rails provides out of the box (and usually a long list of gems is added as well). When you're starting a new project the overhead of the bits you don't use is so irrelevant it's not even worth taking the time to think about it. 
&gt; Or any dumb object Personally I find it works best with something I can anthropomorphize to some extent, such as a stuffed toy. I use a Sweep glove puppet.
As far as I know the Gnuplot gem is just a wrapper around the gnuplot executable, so you won't be able to share memory directly.
That's a horrible example. The problem/code is too simple to illustrate any benefits using SRP (or any other design principle). The result (from a mainainter's perspective) is not better (not more readable, not faster, not using less memory). You can't really improve code as simple as this: class User def self.to_csv_io tmp = Tempfile.new csv = CSV.new tmp find_each do |user| csv &lt;&lt; ... end tmp end end Mail.deliver do from 'jjbohn@gmail.com' to 'jill@example.com' subject 'Your report' add_file User.logged_in_this_week.to_csv_io end
The code is pretty bad (super long methods + manual SQL sanitization + no tests), I hope nobody is using this in production.
I took a look at this: https://github.com/rdp/ruby_gnuplot/blob/master/lib/gnuplot.rb I don't get it actually: def Gnuplot.open( persist=true ) cmd = Gnuplot.gnuplot( persist ) IO::popen( cmd, "w+") { |io| yield io io.close_write @output = io.read } return @output end If gnuplot writes the PNG to stdout, then @output should contain it right? And gnuplod does this, if you do "set terminal png" but omit any further "set output ..."; So, when not setting gnuplot "output" parameter, should the PNG not be in the @output. 
oh sorry, **it works!** All I needed to to was to capture the output of Gnuplot::open into a variable :) o=Gnuplot.open do |gp| Gnuplot::Plot.new( gp ) do |plot| plot.terminal "png" plot.xrange "[-10:10]" plot.title "Sin Wave Example" plot.ylabel "x" plot.xlabel "sin(x)" plot.data &lt;&lt; Gnuplot::DataSet.new( "sin(x)" ) do |ds| ds.with = "lines" ds.linewidth = 4 end end end File.write "o.png", o
The last time I wrote a rake task? Yesterday. I don't care for the tone of this blog post. 
I've written a decently sized Thor CLI app and the number one thing I learned is that Thor has lots of bugs/oddities and appears effectively abandoned. Would not use again. 
What are these tasks doing? Anything in our system that is not a once-off job (db migration) goes into a service and is called either directly via HTTP or asynchronously via JMS. These routes are then continuously regression tested via our CI environment. 
Official docs: http://www.ruby-doc.org/core-2.1.2/IO.html#method-i-gets http://ruby-doc.org/core-2.0/String.html#method-i-chomp
You're welcome to contribute! There are a lot of things to do. :)
Memoization is also a great way to accumulate tons of state in your objects :) I've seen systems where the same data is memoized in multiple places because the developers memoized all the things. Be cautious. One thing I started trying out is to never define an instance variable outside a constructor. It's not a general practice I'd recommend, but it's a fun thing to try that will bend the way you write code and give you a new set of tools.
I wish Ruby had a built-in memoization pattern that checked on whether variable was previously initialized, rather than whether it's truthy: # Will call method every time if it returns `nil` or `false`: @obj ||= some_expensive_method() # Proposed new syntax, will only call method if `@obj` was never initialized: @obj ?= some_expensive_method() Right now to get this behavior, need to write: if defined?(@obj) @obj else @obj = some_expensive_method() end Because above syntax is clunky, people tend not to use it, with the less efficient `||=` being far more common. Hence the suggestion for alternative `?=` syntax. As well, `?=` should be context-sensitive to builtin types: some_hash[:some_member] ?= 'some_value' Should check for `some_hash.key?(:some_member)` Which will be assigned if the key does not exist at all, but not be assigned if the key exists but has `false` or `nil` value (another difference with the `||=` pattern). Syntax-wise, in case `?=` is not preferred, an alternative is using `:=` syntax, which is used in other languages for "initial assignment".
The article is basically "RAKE BAD, THOR GOOD!" but doesn't go deep enough in to anything to really showcase any virtues thor may have. I don't know if using thor over rake has merit or not, but I do know this article does very little to help me develop an informed opinion.
I don't think the site is fully finished, but seemed very neat.
'gets' reads from '$stdin' by default, so '$stdin.gets' and 'gets' will return the same value, newline and all. '$stdin.gets.chomp' and 'gets.chomp' will return those values with newline removed
You'll still want to back up those claims with benchmarks, especially when claiming it's potentially 10 times faster than a naive JOIN.
Totally agree! You can also go way overboard and memoize things that run so fast you're not getting any real improvement anyway. Or my favorite, memoizing methods that are only ever called once. Now, I avoid memoization for my first few iterations, and only add it in if there's a clear, visible performance problem that it would help out with. I also love the idea of using constraints and experiments to learn new ways to write code. It's a lot of fun, and can force you to come up with really creative solutions.
Yeah. It's interesting that Hash has `fetch`, which acts kind of like the ?= operator would, but there's no built-in support for that for other objects in the language.
You could have left off your first sentence with no loss of content. I agree the example went from something easy to understand to something overly complex. I would have left it at the first edit and only added the additional flexibility when needed. There is nothing wrong with mixing concerns in a simple solution and refactoring when needed. As to your example: * do you you want your User model talking to Tempfile and CSV? * where does the Mail.deliver ... code reside? Probably not the User class. 
 Indent with 4 spaces to get a fixed width font.
You should be using rake tasks that invoke part of your application.
There's a nice explanation and example [here](http://ruby-doc.org/core-2.1.2/String.html#method-i-chomp). Basically, **gets()** reads input. It knows where to stop when it runs into the record separator. By default, this separator is whitespace. The method **chomp()** returns a string with the separator removed from the end. Try them out in the interactive mode to see. An example without the default settings might be easier to follow: irb(main):001:0&gt; gets("|") ## user enters input... one with a separator|one without a separator| ## return value comes back: gets() read up to ## the | and returned it with along with the input "one with a separator|" ## call gets() again, this time with chomp() irb(main):002:0&gt; gets("|").chomp("|") ## the rest of the input is read, this time ## the | got chomped off "one without a separator" ## chomp() just strips a given string off the end irb(main):003:0&gt; "Hello World!".chomp("!") "Hello World"
Check this out also http://www.launchcode.org/
A small correction: the default separator for gets is a newline (not whitespace). Whitespace includes space, tab, newline, line feed, and perhaps a few more characters (Unicode, perhaps?)
I typically restrict memoization to value objects
nooooooooooooo
Have you considered using Delayed Job or Sidekiq to queue each of thee thousands of items individually? It would be trivial to write code then that measured each one, and then estimate from there.
I'd rather see an OIIO wrapper
Isn't this related to the halting problem haha
You could do the sidekiq thing if that makes sense, but if you're just doing runs that loop 300,000 times, you might try using the benchmark module to measure the average time per loop and extrapolate from that to calculate the total estimated time.
Add a progress bar. https://github.com/jfelchner/ruby-progressbar
Great list!! Forgot about fat free crm! I need that!!
Quick answer: [It depends on your algorithm.](http://en.wikipedia.org/wiki/Analysis_of_algorithms) Longer Answer: [It depends on your algorithm.](http://en.wikipedia.org/wiki/Analysis_of_algorithms)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Analysis of algorithms**](https://en.wikipedia.org/wiki/Analysis%20of%20algorithms): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), the __analysis of algorithms__ is the determination of the amount of resources (such as time and storage) necessary to [execute them](https://en.wikipedia.org/wiki/Computation). Most [algorithms](https://en.wikipedia.org/wiki/Algorithm) are designed to work with inputs of arbitrary length. Usually, the efficiency or running time of an algorithm is stated as a function relating the input length to the number of steps ([time complexity](https://en.wikipedia.org/wiki/Time_complexity)) or storage locations ([space complexity](https://en.wikipedia.org/wiki/Space_complexity)). &gt;Algorithm analysis is an important part of a broader [computational complexity theory](https://en.wikipedia.org/wiki/Computational_complexity_theory), which provides theoretical estimates for the resources needed by any algorithm which solves a given [computational problem](https://en.wikipedia.org/wiki/Computational_problem). These estimates provide an insight into reasonable directions of search for [efficient algorithms](https://en.wikipedia.org/wiki/Algorithmic_efficiency). &gt;In theoretical analysis of algorithms it is common to estimate their complexity in the asymptotic sense, i.e., to estimate the complexity function for arbitrarily large input. [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation), [Big-omega notation](https://en.wikipedia.org/wiki/Big-omega_notation) and [Big-theta notation](https://en.wikipedia.org/wiki/Big-theta_notation) are used to this end. For instance, [binary search](https://en.wikipedia.org/wiki/Binary_search) is said to run in a number of steps proportional to the logarithm of the length of the list being searched, or in O(log(n)), colloquially "in [logarithmic time](https://en.wikipedia.org/wiki/Logarithmic_time)". Usually [asymptotic](https://en.wikipedia.org/wiki/Asymptotic_analysis) estimates are used because different [implementations](https://en.wikipedia.org/wiki/Implementation) of the same algorithm may differ in efficiency. However the efficiencies of any two "reasonable" implementations of a given algorithm are related by a constant multiplicative factor called a *hidden constant*. &gt; --- ^Interesting: [^Probabilistic ^analysis ^of ^algorithms](https://en.wikipedia.org/wiki/Probabilistic_analysis_of_algorithms) ^| [^Computational ^complexity ^theory](https://en.wikipedia.org/wiki/Computational_complexity_theory) ^| [^Algorithm](https://en.wikipedia.org/wiki/Algorithm) ^| [^Computer ^science](https://en.wikipedia.org/wiki/Computer_science) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjbnhnq) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjbnhnq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I know them, but wish there was some sort of a curated list.
Well, Devise's team actually recommend against using Devise if you're still beginning with Rails. Quote from their github page: &gt;If you are building your first Rails application, we recommend you to not use Devise. Devise requires a good understanding of the Rails Framework. And I actually agree with this.
Even if the decision is to EOL the RMagick gem, it still needs to have some attention from the maintainer to do this. Right now, installing the gem is hit or miss on some platforms. If you are starting from scratch and just need basic image operations, I'd suggest you try out RubyVIPS.
Why would you issue a pull request and ask that it not be merged?
Tracking is a big one, maybe you want people to have a look and leave comments of a work in progess, PRs are the easiest way to do that on Github. Maybe you want it to run on a CI system or some other external service that only triggers on PRs being created / updated.
Ah, that makes sense. (As you can probably tell, I am not an open source dev.)
I use this one all the time for long-running scripts - http://0xcc.net/ruby-progressbar/index.html.en
Yeah but what isn't taken into account is the number of those PRs with a later comment that says "okay, good to merge." Submitting an incomplete PR is a fairly normal thing to do, especially by project owners who may have larger submissions and want feedback before progressing. Also some CI tools, such as Travis, are configured to automatically pick up PRs and execute tests. It's nice to know how screwed by Ruby 1.8.7 you are if you're working in 2+ and aren't using tools like rvm or rbenv.
&gt; On another note, why would you want a version of rails with bits missing? One example, if you're building a JSON API only, it's useful to strip out ActionViews.
The fork should just rebrand themselves with a different name that says "hey I'm the competitor to RMagik!", everyone will realize it's "the new hotness", and life continues on.
Party Boy - last commit 3 years ago.
I'm sorry, did a blog post written in 2014 just refer to **rubyforge**? rubygems.org has been the official public gem repository for years now. Also: have you tried out [mini_magick](https://github.com/minimagick/minimagick) It doesn't cover the full range of features, but it's at least in active development
Upvote because mini_magick is the way forward for a lot of things
:shipit:
Ok that makes sense. Thank you for looking it over. I'm glad to know I'm going in the right direction. :)
Looking pretty good. I'd factor out the pitch=Pitch.new statements everywhere by starting with describe Pitch do let(:pitch) { Pitch.new } Also, according to http://betterspecs.org/ the use of "should" in you descriptions is discouraged, so rewrite: it "should have 100% confidence in its frequency" do to it "has 100% confidence in its frequency" do 
I would recommend you create a "*methods*" folder, where you will be storing all the methods. So, let's now assume you are working in *~/projects/browser/* We will add a methods folder, so we now have *~/projects/browser/methods* Inside the methods directory, let's first add a new directory called */functions/* This directory is where we will place all of our methods Now, let's add a file inside */methods/* and call it "*load_methods.rb*", which will look like the following: METHODS = './methods' FUNCTIONS = '/functions/' Dir["#{METHODS}#{FUNCTIONS}*.rb"].each do |file| # Iterate each ruby file in ./methods/functions load file # we will load the file instead of require end Now, let's go back to your script, and add this line: require_relative 'methods/load_methods.rb' Right after: require 'pry' There isn't going to be a good solution from stopping you from calling another method. You will either have to call that method, or add the code directly to the method in use instead. The above code should allow you to make your program less 'bloated', so that you don't have tons of methods all on one page. I hope this sort of helps If you want to see a more advanced way I used this in my Ruby IRC bot, check out my github: https://github.com/Ninjex/Confabulation/tree/master/methods The difference here, is that I allow multiple levels or access as well, and that I call each function when the user enters it in IRC with the send method. https://github.com/Ninjex/Confabulation/blob/master/methods/functions/check_command.rb Maybe overlooking my setup can also help you gain insight on ways to mitigate your problem at hand.
As it's the thing the spec is testing subject would be more appropriate in this case describe Pitch do subject(:pitch) { Pitch.new }
I often create a PR as soon as I start working on something if it's to be merged with someone elses in-progress work. Travis kicks back to me when either one of us makes changes that causes conflicts. It's very handy.
 context "when it doesn't put the lotion on its skin" do it "gets the hose again" do; end end
[r/rails is this way](http://www.reddit.com/r/rails)
ruby-progressbar is a general solution for iterative tasks. It can compute ETA. sometimes, when task reads its input from some file it's easier just to read from "pv file" istead of file itself. http://linux.die.net/man/1/pv
Unfortunately mini_magick shells out rather than interacting directly with the ImageMagick libraries. This is a big no-no in many production environments since it can produce a large memory footprint.
These tests aren't really testing what you think they are and are giving false positives as side effects based on what I can see from the actually library code. For instance if we take the first spec of "it should have a frequency of the concert pitch" that test is probably passing but it is completely by change and doesnt have anything to do with what your "concert_pitch" variable is set to. Your initializer in the Pitch class happens to default to class variable value of 440 if no pitch is provided to the 'new' call. You arent passing in concert_pitch to the new call and just happen to be getting the test to pass because the `@@pitch_standard` class variable is also 440. This is a side effect and as a result your test isnt that great.
You're a pedantic jerk, but I like your style. Upvoted.
If you can separate some domain models so that they don't relate too much, then multiple active record connections isn't too bad. Just don't expect belongs_to to work for you. Personally nosql dbs have always resulted in a mess and I avoid them like the plague if you want to do anything to get you actually paid. Can't comment on the gem approach sadly. But really, unless you are instagram etc, just throw some hardware at it and save yourself and your sysadmins the hassle
Thank you for the site to look at; that looks like a lot of good information, and most of them even have discussions! Does the let(:pitch) bit happen before every it block?
You've failed to see my example and how I'm trying to show you why the test isn't great. I'm reading your spec file and the actual Pitch class file at https://github.com/RSMP/juicy/blob/master/lib/juicy/pitch.rb. If what you said above is correct, then you have structured your code wrong in other places. With your spec code, `pitch.frequency` is only equal to `concert_pitch` because you set `concert_pitch = 440` and since your call of `pitch = Pitch.new` doesnt pass in any params, your `initialize` method in your `Pitch` class defaults the `@frequency` attribute to be `@@pitch_standard` which is also 440.0 by default. 
If you simply wanted to test that it was set to the class variable by default you could have done this as `expect(pitch.frequency).to eq(440)` or even `expect(pitch.frequency).to eq Pitch::PITCH_STANDARD` where you change `@@pitch_standard` to a class constant instead of a class variable. It doesnt really seem like a variable anyways, and more of a constant.
Great, thanks for this. I will take a look at the github links when I get home this evening. Appreciate the help!
&gt; expect(pitch.frequency).to eq(Pitch::PITCH_STANDARD) This is probably the closest to what my code should read, but I do want pitch_standard to remain a class variable. The reason is that historically concert pitch has changed, but when a concert pitch is used, it is chosen and used for an entire piece. So if my program is making a song, one could alter the concert pitch, and everything would be sharper or flatter, but still in tune relative to one another. So, I should set up a getter for the class variable, and have the test look like this: expect(pitch.frequency).to eq Pitch.concert_pitch Thank you for looking this stuff over :)
let creates a method, which is lazily evaluated only when it is needed, and whose value is cached, but only within each example. Betterspecs also talks about it: http://betterspecs.org/#let
or maybe I just did not check if there was a /r/rails since it's like my 2nd or 3rd post on Reddit and not used to it ? so thanks for the link
NoSQL DBs are quite unclear waters still. thanks still !
My wife fell into a situation just like this. Let me be the first to tell you, she is rocking it right now. Almost 8 months in with no assistance from another dev. She knows she has many short comings and may be slower than a senior level dev, however the one thing that gets her and every other dev I have known throufh their daily tasks is this: Focus on one problem at a time. Break that one problem into smaller problems. Then focus down to one of those and work your way i to understanding the problem. You'd be amazed how far this can take you. As a junior dev to another, it's tough.
&gt;I write desktop applications in Ruby Which GUI framework do you use? 
~~Hi I'm a noob, who are you and what's your greatest contribution to the Ruby community?~~
~~PDT not PST~~ (post was updated)
Ah, but mini_magick was created specifically to address *RMagick's* large memory footprint. Round and round and round we go!
Have you checked out MySQL cluster or Postgresql? I'm not sure if the native database partitioning schemes will be sufficient, but before working on sharding at the application level, see what you can do at the db level. Good Luck.
What single feature of the language or the VM seen in other languages do you think should be added to Ruby?
The perennial question: when are we losing the GIL (Global Interpreter Lock) ?
How important is performance for the Ruby core? Can developers expect big performance improvements in the near future?
I work at Shopify (first video you linked). &gt; what happens when a model need to cross the sharding line one way or the other As explained in the video we made the decision to disallow it. For us it's not much of a problem because our dataset is sharded by nature. Everything belongs to a shop, so it's simple. In the end some schema are easily shardable others are not. &gt; any feedback on real world use of Octopus or another sharding gem available We started with DbCharmer to finally get rid of it because we were barely using 10% of it, and it complicated things. We roll out own sharding code. Let me know if you have more specific questions.
Non ruby question... What is your favorite dish to cook?
Of all the people using Ruby, who has made you the most excited, who has made you the most proud, and who has disappointed you the most?
What are your top 5 favorite Ruby language features?
Title should say for "Ruby on Rails". For people working on ruby on the command line there are great gems such as : highline, thor/main, nokogiri to name a few See also https://www.ruby-toolbox.com/ (also mentioned in linked article)
when can we have Struct#new take arguments by named parameters ? :)
errr, did you even google? there's even a book called: [Service-Oriented Design with Ruby and Rails](http://www.amazon.com/Service-Oriented-Design-Addison-Wesley-Professional-Series/dp/0321659368)
Are there any plans to expand stdlib for MRuby (via mrbgems to maintain minimalism)?
* Do you ever see ruby moving to a spec-based implementation language instead of using MRI as a reference implementation? * Is there a reason that MRI is using a modified version of SemVer instead of following the SemVer spec?
You can easily return JSON in your controller: def show @post = Post.find(params[:id]) respond_to do |format| format.html # show.html.erb, or show.html.haml, or... format.json { render :json =&gt; @post } end You can see the output with `foo.bar/post/42.json`. If you want to do anything else with the json, like renaming, restructuring, etc. I would recommend [JBuilder](https://github.com/rails/jbuilder). Rails could work, I would recommend trying it out. But since you didn't provide any additional information it's hard to guess. I wouldn't recommend stuffing to many gems into your application. Do it like you do in JS: Small stuff, that you can easily write yourself, do it yourself. Anything bigger, include it from a gem. And read [this](https://stackoverflow.com/questions/14824551/rendering-json-in-controller), could be helpful.
How do you feel about JavaScript becoming the dominant language of the enterprise?
What would a perfect Ruby look like to you?
What programming language, other than Ruby, excites you and why?
When you have a sausage sandwich, do you have A) red sauce, B) brown sauce, or C) no sauce at all?
Questions: - How does matz see mruby going to compete with lua, in particular because lua has a headstart in regards to minimal/embedded systems? - What will come for Ruby 3.0? - How does matz get new ideas for ruby? (This one is difficult; I mean how does he manage to get new ideas and whether to reject it or not.) - When will the stdlib become gemified? - Why did he not provide something like gems from the beginning? - Are there any ruby libraries not in ruby stdlib that matz sometes uses for his own stuff? (For instance, I use prawn a lot but I wonder if matz uses any ruby libraries/gems not in stdlib)
Nobody uses either of these two.
sushi!!!
matz is a positive guy, why would he refer to "disappointed"? Let me formulate that question differently: "Of all the people using Ruby, who has surprised you the most (e. g. with code he/she has written and similar)."
I understand Ruby was created partly due to a frustration with Python. But Python has come a long way since then - it's replacing Java in teaching, is the main language for Linux and its web frameworks are at least as good as anything Ruby has to offer. Why do you think someone should learn Ruby instead of Python?
It does? I didn't know that. Perhaps time for someone to get their hands dirty with FFI (not me though). I'm fairly sure rmagick predates FFI
What you think about Swift lang? 
Matz's opinion on gemifying stdlib was the first question that sprung to my mind.
Since YARV is mature enough, do you think that ruby should have a mechanism to store/dump yarv bytecode of the program and run it back, in order to save parsing phase ? 
Ok thanks
Are we gonna get rid of GIL ? Otherwise there is no point of having native threads . :(
Would you suggest a programmer to stick to one language or be a polyglot?
Will ruby ever get true functional? With functions, being first class citizens, nested functions, tco? Or do we have to stick with lambdas forever?
What do you feel about node.js, will it be the next PHP or rails ;)?
Is the success of Ruby dependent of to the success of Rails?
A word on Opal (http://opalrb.org) would be interesting too :) 
I heard Matz created Ruby because he didn't think Python had sufficient OO capabilities. Is this not true?
That's the first time I hear about it. But now that I'm doing research, I find [an interview](http://www.linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html) that explains that. Still, he ran into Python before its 1.0 release. 
How do you see Ruby in 5 years? Is there an attempt to make it as exciting as it was 5 years ago (still is) and will it be able to compete with other newer languages (go, swift), or will it join Java and .Net in retirement?
For many people Ruby the language has become synonymous with Rails the framework (or with web development in general). Do you see this association as a positive thing for increasing the appeal of the language and enlarging the community or as something less desirable that has forestalled the growth of libraries for a wider variety of applications (like the Python environment and NLP, SciKit, etc.)?
This gives you lots of info about doing that: https://www.codeschool.com/courses/surviving-apis-with-rails It assumes some knowledge of ruby and rails.
What does your job as Software Architect look like? Are you just telling people all day what to do? Are your still coding for Heroku?
If you look at your work week. How much of it approximately in percent is consulting work and how much is programming work? And do your code in your free time?
There are several ways to do this, and none of them are really all that great. 1. Write several gems that are included together. 2. Write several Rack apps that can be mounted together in routes.rb. 3. Write several Rails/Sinatra projects that communicate with each other using HTTP or some other protocol. (1) slows down development and usually requires some kind of private gem server. (2) complicates your app directory structure. (3) requires serialization and (possibly slow) chatter. So like I said, there's no good framework or convention, but there are ways to do it. I haven't read the book(s) on this subject but this is advice from working in the field.
If you could tell somebody learning ruby for the first time, what would you tell them?
In 2009, you declared Ruby to be [The 0.8 True Language](http://confreaks.com/videos/159-rubyconf2009-keynote-address). Now that a few years have passed, what do you see as the borderline applications of Ruby that can fall on either side of "Yes, Ruby should be used here" and "No, Ruby should not be used here"?
Your co-worker doesn't know what he's talking about.
Go with javascript and nodejs :) Seriously, if you can't determine whether ruby is a dying language or not, maybe it is better for everyone of you will become a nodejs developer.
why would nodejs be better suited? Javascript has serious language and syntax issues. 
You should probably break this up so people can upvote a single item.
Is he offering to help you learn it? Take him up on his offer if he is. Javascript is always useful to know, and hey, it couldn't hurt to learn Node too. If he's just making an off-hand gibe at Ruby, don't pay him any attention. Ruby is here to stay.
It sounds like you just need a [form](http://guides.rubyonrails.org/form_helpers.html#dealing-with-basic-forms) to send text to a [controller](http://guides.rubyonrails.org/action_controller_overview.html#parameters).
I didn't say JS is better. What I said is, it is better if someone who doesn't have the common sense to answer this question(Is ruby dead?), goes with nodejs and leaves the ruby community for the smarter ones. I mean no disrespect, but if you go to the official ruby website and look at the releases, go to github look at the number of ruby projects, look at the number of books published about Ruby/Rails lately, you should see it is far from dying. It might be not compelling to everyone, but that doesn't mean it is dying.
[Node.js is surging in popularity at Ruby's expense](http://redmonk.com/dberkholz/2014/05/02/github-language-trends-and-the-fragmenting-landscape/), as Ruby once did at the expense of PHP, Python and Perl. None of those languages are now 'dead', but many people who enjoy using the current flavour-of-the-month languages/libraries/tools have moved on, and those who actually enjoy building things that people use, are still actively using them. I suggest you try both, see which you enjoy using more and continue with that.
oh sorry, I read that differently.
https://github.com/lgierth/promise.rb https://github.com/jclem/q-defer
Thanks for your input but why so passive aggressive? I did state I am a beginner..
http://rubyspec.org/
Neither .net or Java are in retirement. Ruby, Java, .Net, and any other established languages usually don't add anything exciting to the language itself but rather improve the garbage collection or vm speeds.
Have you ever looked at the [Potion language](http://perl11.org/potion/)? If so, what are your thoughts on it?
Have you considered making OpenStruct recursive when doing OpenStruct.new(some_nested_hash) ?
Wow.
Do NOT use that article to draw general conclusions. It is incredibly misleading and just plain wrong. The problem is that red monk has in the past and continues in this article to try and draw generalized conclusions about programming language use and adoption from github data, and that is fundamentally flawed because github and git itself is still in rapid adoption mode and their language composition is rapidly changing because git and github are under rapid adoption expansion, and this ‘noise’ vastly outweighs any true underlying trend in language adoption. They put in caveats, but still draw conclusions like "they’re comparable in terms of thinking about different measurements of developer interest in a given language during the same timeframe” … which is simply not true because the underlying adoption and composition if github in no way reflects the true trends of language adoption and usage. Take a look at the tiobe index for a more realistic view of language usage and trending (http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) and note that C and C++ rank #1 and #4 respectively, but are laggards on github. Both in the title of the article and the concluding paragraph are trying to draw general conclusions from the github data. If the article was just talking about github trends and limited it’s conclusions to that, if would be very interesting and a great story, but they are trying to tie it into underlying language adoption trends and that is where they are way off base. There are also many people who have stepped forward and noted that their repositories are being mis-classified as Javascript projects when they only have a very small amount of Javascript. So, even the data it is based on is wrong.
... Was not created by MRI and is not the gold standard for Ruby. It was created later on, as a secondary reference for all new Ruby implementations. 
Are there any books that you read that influenced your views on development?
* What languages are you looking at for inspiration? * What books are reading? * Outside of Ruby, what are your hobbies?
Ruby is not a dying language. Your co-worker is correct in that Javascript in ascending due to the rise of server side capability and frameworks. In our organization it is 80% Java, 10% Ruby/Rails and 10% other stuff. Java and Ruby/Rails are vetted and approved choices and the 'other' is experimental technologies that are not approved for production deployments (internal tools, prototypes, utilities, proof of concepts). Of that 10%, node and Javascript UI frameworks like AngularJS are getting a *lot* of attention and honestly the developers are turning out some pretty cool work in a very short time, so I'm not trying to be dismissive of Javascript or node. However, I'm a Ruby/Rails advocate and I don't see anything compelling *to me* in the node/Javascript ecosystem that I don't get in the Ruby/Rails world either more or better. If anything I cringe at the amount of work the developers are doing to get to anything that even approaches the complete framework of Rails. When I talk with them about why they are choosing to use node/Javascript instead of Rails, it inevitably boils down to having worked with Javascript off and on over the years and so it is compelling to them to be able to use one language at all tiers of their application. My problem is that I don't think Javascript is fundamentally a good language, so I would rather confine it's use to where I have to use it (in-browser DOM manipulation) and I don't want to use it any more than I have to, and even then I'm planning to learn Coffeescript so I don't have to deal with Javascript's shortcomings as a language. So for me, an inferior and immature framework and a second rate language is not where I'm planning to invest my time, but I can understand why it is getting so much attention and will likely continue to expand going forward. For your situation, I think Ruby is a better first language for learning programming than Javascript, so if that is where you at, I don't think you are on the wrong track. If you are just trying to learn something to open up Job opportunities then it is hard to say right now which is better, but over the long term I expect that Javascript will be a stronger resume 'checkbox' than ruby. When we interview developers we always ask what new languages or technologies they are looking at, and if they are just plugging away with Java and haven't looked at anything else then we usually don't end up hiring them. So we obviously feel that learning a new language, even if you never progress to mastery or commercial application is time well spent. And truly, only you can decide what one works best for you. There is a greater amount of subjectivity and fashion involved in these kinds of 'technical' decisions that anyone wants to admit. Node is very fashionable right now, but it's too soon to know where it's ends up long term.
[Matz tweeted this.](https://twitter.com/yukihiro_matz/status/493351425183711233)
Depends on whether you see Matz as "designer of Ruby" or "lead developer of MRI". In the former case, JRuby is relevant, because you can write Ruby without running into the GIL.
Node.js is not without it's problems. A major member of their community is moving away from it. Read TJ Holowaychuk's [Farewell Node.js](https://medium.com/code-adventures/farewell-node-js-4ba9e7f3e52b) post. The question is why are you learning Ruby? Why are you learning a new language? What are you hoping to gain from it? Personal growth? Future employment?
Thanks for your response. I am looking for future employment opportunities. 
Will Ruby ever fix the concurrency problem?
You can use emoji in variable and function names already. This is valid ruby: 😄 = 42
And I would respect him not answering the last part. He is a very positive and polite guy. However, with some of the crap that goes on in this community I still think its a worthy question.
I don't doubt that the linked article isn't 100% accurate but what is? TIOBE is also hugely flawed: &gt; Since there are many questions about the way the TIOBE index is assembled, a special page is devoted to its definition. Basically the calculation comes down to counting hits for the search query &gt; +"&lt;language&gt; programming" Github is the most popular code host in the world; it's as good a place as any to find data for making broad generalisations about programming trends. Of course some platforms/languages will be under-represented purely by the fact that git is more *nix and Free Software-orientated.
How much Japanese influence did the initial version of Ruby have ?
Why is the debugger in Ruby so lame? It such a great language, but it seems the core team has let the debugging facility languish. Any chance this will change?
There are definitely jobs available coding Ruby. Given the number of companies that use it and the fact that new companies are still choosing it I think there will be jobs for a while. If you're strictly looking for employment you might consider Java (if you don't already know it). Java is widely used and will have jobs around for a very long time to come. Additionally you can transition into other languages like Clojure or Scala which run on the JVM and leverage Java libraries.
No one listen to him ^
What is the benefit of this over something like sidekiq? 
http://www.reddit.com/r/ruby/comments/2c80zl/suggestions_for_an_api_that_outputs_json_im_a/cjdc8lo
What does this have to do with ruby?
I've mostly used Qt, GTK and lately JRuby + Swing. Qt is a pleasure to use, but it has some rough edges since its Ruby bindings get little-to-no maintenance work; GTK I haven't used in quite some time so I can't really comment on it that much (besides that it apparently [has actively maintained bindings](https://github.com/mvz/ruby-gir-ffi)), and JRuby + Swing is probably the most stable, easily deployed and least buggy of them all, but, well, Swing is a Java library so it's kinda crap.
Do you think that Ruby has peaked and already is past its prime time? Sorry for sad question.
https://github.com/jdantonio/functional-ruby
Not here in Nashville. There is so much new ruby work it is crazy! 
https://github.com/jdantonio/functional-ruby
Also check out Elixir!
www.rubymonk.com
You can't use a hammer for everything!
http://ruby.learncodethehardway.org/
What Ruby projects are you currently keeping an eye on?
What do you think are the most underused/underrated features of Ruby/features that you're surprised people don't take more advantage of?
Hmm. That is a solid distinction. I think he is both, though.
Unfortunately Opal is not usable with AngularJS, which is a very major downside (they both patch some core classes, in specifc case ARRAY)
Or my favorite language on the JVM, JRuby.
Here's the direct link if you don't want your details in salesforce/don't want to enter invalid details: https://www.youtube.com/watch?v=36ehjLIHcyc
so... is this thing happening?
&gt; What does this have to do with ruby? Sorry, the article is about general programming concepts. In the following articles I will try to write the same code in several programming languages, including Ruby. Sorry, maybe it is spam, I did't know about the "spam rules".
Gracias, I always thought the ruby QT bindings were dead and didn't really work. Do you package up your stuff into executables? Of so what do you use? 
streaming live now
Try the sys-filesystem gem. https://github.com/djberg96/sys-filesystem
Do you work for Ninefold?
Yes. I take care of the online marketing.
Just a note for your current solution: the output of `df` is not guaranteed to be stable unless you enable POSIX mode (with the `-P` switch for the GNU version, or setting the `POSIXLY_CORRECT` environment variable).
I think you messed up your link a bit.
Thanks. I think I'll learn some Ruby + Rails, and then give it a go.
anybody recorded it?
So what happened?
Shit.
Video is broken for me
it's a live a streaming video... we need a recorded one
Figure it out for yourself. IMHO, Ruby syntax is head and shoulders better than Javascript syntax.
This was already submitted here on this subreddit [5 days ago](http://www.reddit.com/r/ruby/comments/2bsttx/understanding_timeouts_in_cruby/)
this is not the recorded one. this was a live streaming video. and we just missed it. When you miss a streaming video, but the streaming was ended from the source, the video will be broken, just like that. for example: it's just the same like railsconf 2014 live streaming video at justin.tv you miss the live streaming, the video just broke like that. additional comment: the video at that youtube link you saw, i think that it was actually after the show was over.
The key question: where can I see if there were any answers to these questions
Probably nothing, lol. Before the version 1.0 of Ruby was even released Matz already had implemented the vast majority of what Ruby is today.
yeah, I googled it too and I got an answer, but I'm being debated. This is why I said, "it's my understanding".
No. These are awful questions. I don't need developers who have memorised arcane knowledge you will never use (hint: you ever write code like that hello world proc and I will fire your ass), because they will always have API docs with them. This is about showing how clever you are. What I want is devs who are clever about thinking through a problem and producing a maintainable solution.
I just built 2.1 following this ... http://bunkernetz.com/2014/05/23/building-ruby-2-1-x64-on-windows-8/ I did get errors when I ran nmake test although IRB.exe and Ruby.exe both work with no immediate problems noticeable.
Thank you so much!
It's been extracted, but not by MRI Core team: https://github.com/rubysl
Exactly, I usually like to ask more architectural problems
I think the sort string keys one isn't terrible, but the rest of them are pretty much testing your knowledge of arcane ruby edge cases. The only one of these that seems like it might be of use is the one on the difference between and and &amp; as that's something that could bite you in code. But not if you stick to the 'always use &amp;' strategy :)
&gt; you ever write code like that hello world proc and I will fire your ass Yes, when one of the biggest strengths of ruby is its readibility, why the fuck would you write purposely unreadible code?
Apparently, there will be a RubyInstaller release following Ruby 2.1.3: https://groups.google.com/d/msg/rubyinstaller/8Je3OEbtb3w/zqL8UNovPQoJ
Thanks for the info. I kinda hate my version approach. sys-filesystem still needs to be told about the mount points. 
[bundler](http://bundler.io/): gem 'foo', path: '../foo'
Seems like a convoluted way to get access to a Graphics API. Shoes could just use SDL (what Gosu uses), Clutter, Qt, Java AWT (via JRuby) or even Unity. There's no shortage of portable Graphics libraries.
Additionally, it's worth checking out [DataMapper](http://datamapper.org/) for mapping in legacy schemas.
This was really helpful and I would not have known what to google to find this. Thank you. Did you just google "rubyinstaller"?
Good work, but three things to consider: 1. Use [Gitian](http://gitian.org/) for reproducible/deterministic builds. That way we can verify that the binaries are backdoored. 2. The binaries are not tied to rbenv, so they can be extracted into `~/.rubies` or `/opt/rubies` (chruby), or even `~/.rvm/rubies/` (RVM). Consider making the page and instructions more generic. 3. If you have an automated script that builds, packages and uploads new binaries, try convincing [ruby-core](https://bugs.ruby-lang.org/issues/9006) to integrate it into their release process.
cuba, grape, sinatra. 
[**@yukihiro_matz**](https://twitter.com/yukihiro_matz): &gt;[2014-08-01 14:49:27 UTC](https://twitter.com/yukihiro_matz/status/495219763883163648) &gt;My vague plan for Ruby GIL is 1) add more abstract concurrency e.g. actors 2) add warning when using threads directly 3) then remove GIL ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2cdcwg%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
1. Thanks! I will take a look at Gitian. 2. Yes, these builds should also be compatible with other methods of installing Ruby. If not, please let me know! 3. I do have them and I'll make them available. I'm currently in discussion with the ruby-build maintainers to integrate this into the default ruby-build/rbenv install command. One step further would be to suggest Ruby Core on using it. Thanks for your suggestions!
Also, if you are using `ruby-build` make sure you are compiling against [_all_ of the libraries which MRI links against](https://github.com/postmodern/ruby-install/blob/master/share/ruby-install/ruby/dependencies.txt).
I have, but I'm trying to stick with vanilla Ruby.
Fantastic!
I love github, but I have nothing against this attitude. Github is not the only place OSS can or should exist. In fact, it's always seemed to me that a central entity for git projects was a bit antithetical to a distributed SCM... Maybe someone needs to work on a pretty project management system that gets stored inside the git repo itself, if that hasn't been thought of already...
Sinatra is pretty awesome! Plus you can pull in whatever you would like to use if you need persistence. Awesome for small and large projects where the overhead of rails is too much. We frequently use it, if you want some tips let me know.
Do you have a couple of favorite questions then?
"Tell me about the best project you've ever worked on"
That's pretty good. How do you follow up? I always wonder about answers to questions like that. My personal "best project" gets top billing because of emotional/sentimental reasons, since it was made for family. It's not something that would really demonstrate any real ability on my part though.
Does Sinatra use an MVC framework?
In that case, have a look at the Sinatra source code.
Sure, but you have to understand that, in trading convenience for principles, you're alienating a bunch of potential contributors. That may be fine (see Linus' opinion on c++), but you should at least be aware.
It CAN but it's totally optional. We integrate the haml gem for views and data mapper for our models but the options are totally dependent on the gems you choose.
Sinatra is vanilla Ruby... Do you not use libraries at all because they are abstractions built over "vanilla ruby"? Do you not want to use a rack server? 
&gt; Maybe someone needs to work on a pretty project management system that gets stored inside the git repo itself You might be interested in [Fossil](http://www.fossil-scm.org/index.html/doc/tip/www/index.wiki). It isn't based off of `git`, but it does the project management stuff all as part of the same distributed repo.
Oops, looks like we had some issues when jdickey visited us and for that I apologize sincerely! I believe we have gotten those issues resolved, but I know first impressions can never be remade, so we are going to work hard to improve our grade and hopefully win jdickey over in the long run. 
Not wanting to use github is fine, but being an angry child about it is ridiculous. Is there a single person who is strongly for free software who is also capable of communicating like a normal adult?
The command pattern is a hack for languages that don't support first class functions. 
&gt; In fact, it's always seemed to me that a central entity for git projects was a bit antithetical to a distributed SCM... ...which makes the aversion to GitHub even sillier when you consider git IS distributed, and the canonical repo can live anywhere. Maintaining a mirror on GitHub isn't going to kill anyone.
it's definitely not the leanest option, but one could always include a sqlite to back a gitlab (open source github-like thing that you can run on your own server) in the repo. users who were interested in the PMy stuff could install gitlab on localhost and use / modify the db and push out changes as commits that change the db. much more simply, the project owner(s) could just host a gitlab instance on their own publicly accessible server. i know both of those options involve a server and browser, but gitlab is a pretty mature product, and web interfaces are comparably pretty user-friendly. i'm also not necessarily trying to promote gitlab in particular, there are plenty of similar options (gitorious, etc.).
Comes with the territory I think. It comes across that they don't live in the real world. I wonder how they pay for groceries. 
Now I am curious. Are you specifically trying to avoid MVC? If so, why?
I'm sure the harddrives, cpus, video cards, etc of his computers are all built on FOSS too. Purity is impossible. 
Cryptocurrencies, I would expect. Before that they bartered with hairs from RMS' beard.
You could try warble. That's the only one I know of that could remotely compile a ruby file. Still, you may need jruby installed. Not sure. Check out https://www.ruby-toolbox.com/categories/packaging_to_executables
Hi.
Ruby does have support for first class functions, just not convenient syntax sugar. The tradeoff was made between that and sugar around calling functions.
ABLOOBLOOBLOO THE FREE SERVICE I USE WAS TRYING TO MAKE MONEY OFF OF ME
Hey guys, just wrote this project over the past couple of days (been working on a Rails app for a while now and wanted to take a quick break). Hopefully you guys think this project is as neat as I do. I built it to show off how it easy it is to architect very extensible software in Ruby for a friend who just started learning CS in college. I provide 2 classes, Provider and Solver, which can provide sudoku boards and solve sudoku puzzles, respectively. Included in the project is a FileProvider, which provides a board from a file path, and a BacktrackingSolver, which solves the board using a backtracking algorithm. If you think its cool, fork it and add a Provider or Solver =) Hopefully you guys like it.
Github is not git. It's perfectly possible to use git without ever using github. There are alternatives providing similar services out there for free, and a plethora of options to host your own. You can even do them all, thanks to the distributed nature of git. I could probably find a premade project that could keep a github and bit bucket repo synced, or build one in a short time. It's not a trying task. Refusing to provide convenience to people who want to contribute to the project is certainly his choice to make, but it's a bad one. 
RMS Syndrome? 
Read the footer of the unicorn website for even more: &gt; We love to hear from you! Email patches (with git send-email), pull requests, questions, bug reports, suggestions, etc. to us publically at: unicorn-public@bogomips.org This is a public-inbox with no sign up required. Please Cc: all recipients on replies, as not everybody subscribes with ssoma. See http://bogomips.org/unicorn-public/ for archives and more information. Do not waste bandwidth with HTML, HTML mail will not be read. Quote only parts you're responding to and do not top post. For sensitive topics, email us privately at: unicorn@bogomips.org
If you don't pay anything for a service, you are the commodity. If you don't like that, never use anything that doesn't have an explicit dollar cost attached to it. I'm not being snarky or sarcastic, either - but that's really what it comes down to. If you don't like being the good that is bought and sold, then you shouldnt use free online services.
You're probably looking for something like [ocra](https://github.com/larsch/ocra). It packages a whole Ruby distro with the executable (obviously, to be able to run the script), but it provides a one-click runnable for the script that you can redistribute.
hmm
except when you treat github as the centralized source a la subversion.
While I personally don't use (let alone contribute to) Unicorn, I wonder why they don't go with something like Gitlab. The community edition is open source, free and self hosted. It also has stuff like issues and other collaboration stuff, and projects can be public. It's probably not worth it (at least in his eyes), when a basic repo and mailing list setup works fine for them, possibly a 'if they don't want to put forward the effort use this setup maybe we don't want their contributions' stance.
Here it is: https://www.youtube.com/watch?v=VOpEA9FCL9A&amp;list=UUw6mUFp6_utmc1p0y30Pw1A
I don't think he sounded like an angry child.
Thank you for asking the question. This is his perennial answer, but if we stop asking...
Disagree, Epic Wong was dead on
Right. Which is why he's not using Github now.
Check out [awesome-ruby](https://github.com/markets/awesome-ruby)