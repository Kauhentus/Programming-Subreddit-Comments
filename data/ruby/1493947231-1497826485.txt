&gt; I didn't switch to Sequel because of AR's poor pool implementation but because of its poor API. It wasn't on day one, but it was in the first week :) I already knew Sequel when I created this Rails app and liked it a lot already, but I wanted to try to stick with Rails default stack if possible. I liked Sequel because it was lazily evaluated. But just before I created this Rails app, ActiveRecord introduced lazy evaluation through Arel and I decided to give it a try since I thought that both AR and Sequel would be similar to each other after Arel was introduced in AR. Man, I was wrong and I realized this a few days later and replaced my models with Sequel in the very early stage. For me it was the same. I was even in an advantage because I first started learning with Sinatra, so Sequel was the natural choice. But then I quickly moved to Rails because all the community was there, and I didn't really have an opinion. I asked my brother [Mislav](https://github.com/mislav), who introduced me to Ruby, what's the difference between Sequel and ActiveRecord, and he said either one is fine. But it took me probably two years to realize that they're not the same (by sheer luck I was just reading up on Sequel again). He *was* right, though, they're both fine, but I would rather invest my time in a library that will "get the job done" even when the job involves working with tables with 15 million records. &gt; I consider replacing Rails with Roda a minor upgrade. When I moved from Grails to the Ruby land it has way more impact in the development pace. Or when I moved from MySql to PostgreSQL. Moving from Rails to Roda will basically save me some time I'd spend when upgrading Rails and having to fight some issues that would force me to dig into Rails source, besides giving me more flexibility to do what I want much more quickly and to more precisely estimate some tasks. But I wouldn't call it a really big deal, as if suddenly everything got much better because I left Rails. For me the biggest advantage of discovering Roda was the impact it had on my open source work (I use Roda in Shrine and tus-ruby-server), and it gave me better appreciation for many Ruby libraries that otherwise wouldn't have caught my attention. I started appreciating minimalism and lightweightness (but not "micromalism", I still like that libraries are featureful). It also motivated me to learn Rack itself, and how it all works, whereas with Rails I didn't feel like I had to know much about Rack.
Not sure if this actually works, but maybe something like this? module Hp def self.included(base) base.extend ClassMethods end def hp self.class.hp end module ClassMethods attr_reader :hp def has_hp(hp) @hp = hp end end end class SomethingWithHp include Hp has_hp 100 end
That won't work because has_hp is a class function so when it does "@hp = hp" it will set a class instance variable to the amount of hp when it should really be setting a regular instance variable to the amount at initialization. I would like to use modules because it seems like a cleaner way. I believe it will be possible to use modules, but I want to make sure I don't have to both "include Hp" and do "has_hp" because that's a tad redundant.
When I say whole framework I'm talking about Action view. What I'm trying to say is that `require 'action_view'` doesn't require the entire framework (or component). It doesn't load support for the full Action View component either. I just load the common dependencies of the framework (or component). What you want, is exactly what it does now. You can say that Rails is forcing you to write one more line of code, but saying that you can't require only part of the framework (or component as you call) is wrong. You can, and it is exactly what happens today.
Currently, yes. Any suggestions?
I can probably make the program download arbitrary videos, assuming the user points directly to the video file on a webserver If the video file itself isn't specified, such as in the case of a youtube URL, each video hosting site will have its own procedure like youtube does for locating the file. As you can imagine, adding rules for every video hosting site out there would be quite an undertaking. That's not to say with some moderate Ruby skills, you couldn't adapt my program to use with specific sites that you personally are targeting...
Maybe I'm misunderstanding, but it sounds like you want a nice interface for defining a default hp for a class with the ability to change it per instance? module Hp def self.included(base) base.extend ClassMethods end attr_writer :hp def hp @hp ||= self.class.hp end module ClassMethods attr_reader :hp def has_hp(hp) @hp = hp end end end class SomethingWithHp include Hp has_hp 100 end SomethingWithHp.hp # -&gt; 100 instance = SomethingWithHp.new instance.hp # -&gt; 100 instance.hp = 200 # -&gt; 200 SomethingWithHp.hp # -&gt; 100 Edit: And to solve the redundancy issue you're talking about you could make this `Hp` module a bit more generic and add all sorts of configuration methods. 
youtube-dl supports more than just YouTube, and since you're directly using it via a system command I would think your tool supports anything youtube-dl supports.
Sorry, but this website looks like total shit on mobile. 
We've been developing Messenger bot in Hanami for about six months now. We wanted to use the Bot in recruitment process, so the MVP included searching through our job offers from Workable and few secondary features. It's live, working &amp; you can check it here: https://www.m.me/elpi.bot :) We used Wit.ai NLP platform (with https://github.com/wit-ai/wit-ruby gem) to recognise user inputs. Messenger webhooks are covered with https://github.com/hyperoslo/facebook-messenger. I didn't have much problems with Hanami framework during development, but the app is rather small and most of its logic is written in Ruby. Although, I really like Hanami architecture - it helps keep code clean. It is also much smaller than Rails, but still it fulfils its role in one hundred percent! :) 
At the moment I'm trying to wrap my head around how definitions are generated and I must say, it's not going very well (⁄ ⁄•⁄ω⁄•⁄ ⁄)
The process up to 5GB of memory after 3 hours of running, after which there is no free memory left on the machine and the process is killed by the OOM killer and exits with status 137. Assuming RUBY_GC_MALLOC_LIMIT is supposed to be a shell variable, it didn't change anything.
&gt; I asked my brother Mislav I guessed you were close to each other, maybe cousins or brothers, since Marohnić is not a very common last name I guess ;) It's not common at all where I come from for sure at least :) I use both rbenv and ruby-build in our environments (both development and production) which your brother maintains, so please thank him for me :) &gt; I would rather invest my time in a library that will "get the job done" even when the job involves working with tables with 15 million records It wasn't an scalability problem in my case. It's just that we use some quite sophisticated queries, like two joins involving the same table with separate alias and other even more complicated that ActiveRecord simply doesn't support (unless ARel is used, but then you're on your own since they are considered as an implementation detail and shouldn't be considered public API and could change without further notice). If I used ActiveSupport I would have to write a lot of custom raw SQL statements and handle all escaping by myself. I don't need to resort to raw SQL for most queries I do with Sequel. 
Is Discourse the same or similar to [Dischord](https://discordapp.com/) ?
Which caching do you mean? * Depending of the complexity of the payload, it might cost you more to fetch some cached payload from the network cache store then to just generate it. And there are many cache store implementations around, including one that you can attach as a rack middleware * conditional GET is already implemented as rack middleware in rails, and most frameworks (roda included) support it in the same way * Sequel is more performant, more feature-rich, and more flexible. AR is not an advantage of rails, it IS rails. * ActionMailer is beyond the scope of a JSON API, and you can hack something even with ruby stdlib. * configuration is a feature of any framework, and one could say that there's less cognitive overhead outside rails: no complicated after/before initialize/require/whatever. Sinatra has `register`, Roda has `plugin`. * logging can be and is usually implemented as a rack middleware * can't think of a use case helped by rails instrumentation that can't be solved in another way in another framework. Maybe you can give me some? Familiarity is the only advantage I can think of. 
Yeah looking at it closer, youtube-dl [supports quite a few sites](https://github.com/rg3/youtube-dl/blob/master/docs/supportedsites.md). I only personally needed this for yt so I hadn't even looked. I may need to make some small changes in order to support that but it should be doable. There may be some youtube-dl configuration required for some sites, like for authentication but I suppose that's not a problem
Class methods like your `has_hp(...)` can certainly be useful. For example, I use a [`define_field`](https://github.com/gettalong/hexapdf/blob/master/lib/hexapdf/dictionary.rb#L90) method for defining fields of a PDF dictionary that provide certain attributes for all instances ([here is an example](https://github.com/gettalong/hexapdf/blob/master/lib/hexapdf/type/catalog.rb#L49)). However, I would avoid pouring to much "magic" into the implementation, for example, your custom version of `Class.new`. This makes it harder to track down problems and is not really needed.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [gettalong/hexapdf/.../**dictionary.rb#L90** (master → 93febe6)](https://github.com/gettalong/hexapdf/blob/93febe64ec3ce204b681b67c4f5c88aa24996765/lib/hexapdf/dictionary.rb#L90) * [gettalong/hexapdf/.../**catalog.rb#L49** (master → 93febe6)](https://github.com/gettalong/hexapdf/blob/93febe64ec3ce204b681b67c4f5c88aa24996765/lib/hexapdf/type/catalog.rb#L49) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dh67ihw.)^.
I have never needed instrumentation for test setup. What are the situations where something like this is useful?
This is a very good solution. As long as I can find a way to do the same thing without the include Hp line that's the way I'll go.
That is my PR and subsequent ticket. I was in the process of building a gem but ran into that problem. The only way to gemify properly (i.e. maintain modularity and allow people to pick and choose components, use SASS configuration a d overrides etc) would be to rename all the JS files to get rid of the extra dots in the extensions. That would require updating all references in the code as well and also mean having to redo it for every new version of foundation Far too much hassle for me personally
Nice article but that's a naive Redis implementation. Good for a prototype but don't put it into production. **Never, ever use KEYS in production. Period.** Add a secondary data structure that contains the IPs, like a ZSET or plain old SET. You can SCAN through the structure's contents, making the iteration through IPs much more scalable.
Hey Mike, Thanks so much for the comment (and all the other awesome stuff you do, happy Sidekiq users here) Currently Rack::Attack sets different IPs as top level keys, so that sounds like a great change we could propose upstream. In the meantime, is there a better way we could scan thru the keys at a top level?
You can use SCAN but scanning the entire keyspace is sub-optimal unless the database is dedicated to Rack-Attack: https://redis.io/commands/scan Imagine Redis with 1,000,000 cache keys and 10 Rack-Attack keys. That's a lot of scanning to find 10 keys. Better to put 10 entries in a SET and use SSCAN on it.
o/ These are my slides. The rubby thing, is as most things, just a joke that got way out of hand. At this point, it's just a habit, but also it's my research so if I feel like adding some humour to it, I feel like I probably can. re postmodern's point, a lot of what I've stumbled upon probably could be fixed, but a bunch of it is just like.. really baffling things that occur for valid-ish-seeming reasons if you dig far enough. Part of the joy of writing a programming language is having people get confused or upset about the constructions of your primitives being super confusing and weird :) This research wasn't meant to be particularly condescending toward rubby, it was mostly to point that obfuscating rubby is a fool's errand is you still plan to use a canonical VM (MRI, rubinius, jrubby) and show off some funny things I found while building a constructive proof of that.
My primary use case was to find out which factories are the slowest and improve the overall performance of our test suite. This resulted in 25% reduction in rspec execution time. My other use case was to debug inconsistencies in the factories, and to quickly glance over what is happening behind the scenes. When you have a bigger rails app, this can help a lot.
Thanks, makes sense.
With respect to ActiveSupport, I feel the same. Every gem that uses ActiveSupport is a gem I won't install or use if there is another way. It's just not worth the risk, with ActiveSupport messing up everything. However, I don't think that the monkey-patch culture is deeply rooted. In my experience, there is quite a learning curve concerning the powerful features of Ruby, like meta programming or monkey-patching. First they look too powerful to use, then with more experience they are used everywhere because "cool" and after that comes the phase where you appreciate the features Ruby gives you, without abusing them.
Great feedback! The alternative set data structure seems ideal given the constraints you raised. To take things in a slightly different direction, assuming we're living in a world with top level keys (as `Rack::Attack` currently implements), an alternative approach to the business problem of wanting folks to be able to remove IP's from the ban list, would be to have an input box where staff could input a target IP and the server could attempt to `DEL` that key (we'd have to assume we know the format of the key). If the key exists and is removed, a success message could be returned. Perhaps the above idea is not an ideal UX experience for staff but it would remove the issue you raised of iterating over the whole keyspace.
You should use the OS's temporary directory and not assume `/tmp` as that might not be the correct directory for any operating system. require 'tmpdir' Dir.tmpdir [tmpdir](http://ruby-doc.org/stdlib-2.4.0/libdoc/tmpdir/rdoc/Dir.html#method-c-tmpdir)
Good one, updated
What is the output of `rvm notes`? [source](https://rvm.io/rvm/install#3-reload-shell-configuration-amp-test)
Can you give a quick summary of the talk?
Yes. Well, it doesn't run unless rvm is running. I have it running, and notes just looks like version notes. I ran `rvm requirements` and it did *something.* I am not sure what. I ended up just forcing a run by commenting out all the source lines and ALL of the path lines from .profile and .bash_profile. Even the path line in .bashrc was unnecessary. All that's left is the source line in .bashrc. All of the paths are included from somewhere else (I have no idea where... they don't seem to be in /etc/profile. Thanks for the suggestion!
Just saw this further down the sub, wonder if the techniques here wouldn't help you track it down https://www.schneems.com/2017/05/01/the-fastest-way-to-generate-a-heap-dump-on-heroku/
My first gem. Feedback welcome.
May I suggest [rbenv](https://github.com/rbenv/rbenv) as an alternative?
Because codemonkeys call themselves engineers while they are really not.
To add another one: I use [chruby](https://github.com/postmodern/chruby). As minimal as possible but does everything I want it to do. Combine with [ruby-install](https://github.com/postmodern/ruby-install) to install rubies.
Have you seen that in most developed countries there's a whole set of jobs that people will not accept doing? Why is that? Because once you try something better, it's so much hard to go back! This is true for everything. Habits, food, technology, everything. The analogy I want to make is with Ruby. When I came back to the world of software development, it was after I had stopped coding for long. The reason I had parted from programming is that I came to hate it. I was not a guru by any means, but I thought it **had** to be more fun than what it seemed (I was doing C at that time, with the typical dream to code a game). Then life struck and I had to start addressing a lot of other problems (family, relationship, financial...) so I really had no time to waste on having to learn all about the hardware, the algorithms and the math you need to know to make a game. I kind of lost hope and this explains why I left the programming world. Fast forward 5-6 years later, and I googled: "programming language love". What I was looking for was a language that could make me love to program again. Ruby popped up. And I was slowly dragged in again to the point that I started learning again, this time with an attitude more oriented at work. And that's how I ended up learning Rails and web development and how I begun to getting jobs in this field again. I also started learning a lot more about math, because it was fun as I was now learning by doing rather than learning by pulling hair/pointers! You can clearly see that I am one of those few developers that did not go to Ruby because of Rails, but it's the other way around. I was really really loving Ruby, and it felt natural to learn Rails and add it to my knowledge box. I do also have a lot of problems with Ruby, which are really frustrating: another dream I've always had is to be able to deploy graphical cross platform apps, without the user needing to install a whole Ruby environment, a Ruby devkit, ecc... I just wanted to be able to ship my self-contained compiled file. This is a mess with Ruby nowadays. So, after feeling the frustration of being bound to be a Ruby developer, I started climbing down the Ruby mountain and exploring around. I went to Java, C#, Javascript, and many more. I spent days researching for an optimal solution for my requirements (those I said above). These are the results: - Java: so much verbose. Got a small Android app done with it, but man, what's this FactoryFactory mess? - C#: better than I thought. - Javascript: hell. The point I wanna make it's that once you have tried a language that puts less stress on you, it's so hard to like something different! I swear, I tried so bad to like Javascript. Last attempt was for Electron (as it fulfills my desire to have the same code base and UI working on major OS'es). I forced myself to learn the basis but then I found out that everything else was a completely fragmented ground with so many different APIs, so many UI frameworks, and every one of them was doing things differently, using different sets of Javascript features, and telling me to worry about Polyfills. Polyfills? Why would I care about Polyfills?? I wanted to code because I loved doing it, and Ruby restored my love in it. The closest I could come to was C# and it gives me all I wanted. Good language, portability, a RAD for UI with a consensus and big community around it. My conclusion: I tried so hard to climb down the Ruby/Rails mountain and explore the surroundings, and I've partially succeded at that, but the theory around the fact that once you try a cherry you won't go back eating rotten cherries is something real. Currently I am keeping my Ruby skills sharp, but at the same time I am poking with .Net again. I have read that there are high chances that .Net will end up compiling to WebAssembly. And that would be the day when me and thousands of Ruby devs will be finally free from the guilt of not liking Javascript. I know some of this does not make complete sense, but please try to read between the lines. I am not an English native speaker so try to connect the dots when you see things that apparently unrelated. Thank you for your understanding!
Excellent, this is totally a topic I've been thinking about lately, I appreciate this guy's ideas. 
Yep, I'd at a minimum still have it `extend` a module that _adds_ these commands like `can_move`. (Or `include` a module that is `ActiveSupport::Concern`, that makes `include` do thing you normally need `extend` for). At that point, I think it _can_ be an appropriate design. Whether it's "better" or not just depends, I think. But I'd never add methods like `has_hp` or `can_move` magically to `Object` or anything else -- I know lots of AR plugins do this, or used to do it, I don't think it's good, and I think fewer do now. At least have an explicit module include/extend to add those methods. So adding a module is adding some behavior to the class. At that point, you just need to decide -- is the behavior I'm adding the _ability_ to call `can_move` and `has_hp`? Or is the behavior I'm adding something that is so simple it can just be automatically added by extending/including the module? What is the API that makes sense to the caller, will be easiest and most clear to readers?
In a web app you need JavaScript to do things on the front end, so you should care about Polyfills if you need something to work in an older browser so you don't lose potential users and the chance to monetize them. Ruby is great, but it isn't practical to just decide one language is great and you don't want to use anything else. I have to use JavaScript so it makes more sense to get good at it, rather than be anguished about it. I need to write code that runs in browsers now, not at some point when we have WebAssembly and nobody uses outdated browsers that don't support it.
Try Go and Elm.
&gt; FactoryFactory mess First you need AbstractNounGoesHereFactoryServiceProvider
Your question is ambiguous, you mention both Ruby and Rails, so is your question, "why is Ruby so popular" or "why is Rails so popular". The answer to these is vastly different though I am sure Ruby's popularity was partly behind DHH's choices to use the language for Rails. 
I don't think ruby was very popular (esp outside of japan) before rails. 
I think ruby is mostly popular today because of rails, and rails was made possible because ruby style metaprogramming makes creating frameworks and dsls a breeze. Other areas whrere ruby really shines (rspec, chef) also rely heavily on the language facility for metaprogramming. Said facility also can make trying to understand a large ruby project a bit complicated.
Why do you hate it? What poorly structured code are you referring to? What is your reference point (what language do you *like* to use?)? 
Thanks for the advice... can you make cross platfrom GUI apps with those? 
Elm is just a really amazing front end language Go has the ability to cross compile to different OS and architectures, and there are [qt bindings](https://github.com/therecipe/qt) if you want to make a GUI app
&gt; 1) Is it normal to hate this fucking language in the beginning? No. What is your background? &gt; 2) God damnit why is it so popular? Popular compared to what? According to [TIOBE](https://www.tiobe.com/tiobe-index/) and [PYPL](http://pypl.github.io/PYPL.html) it's behind a lot of languages that are more difficult to work with. Expressive syntax and ease of meta-programming is my short answer as to why people like it. Rails is my answer as to why it has the popularity it has.
TBF he reads more like a basic troll than a shitposter.
For someone whom is just getting into the basics you seem to have formed a very strong opinion. Perhaps instead of throwing a tantrum you should ask for help on the bits you don't understand, many people here are happy to help. 
What is your background? What languages do you already know? Is Ruby your first scripting language? 
What's wrong with the `include Hp` line? Without that, you HAVE to either monkey patch Class or Object, or inherit from something, at least as far as I know... and maybe those solutions are OK too, but... maybe you want more of a DSL and want to implement it in Ruby, but have your code responsible for loading the files so you can do whatever you want? It seems really unclear what your objections, goals and design priorities are.
&gt; I wanna put my effort and passion around my product, not around the nuances of the tool (the browser) needed to deliver it. The delivery of a product is in many cases as important as the product itself. 
I would want to inherit something. There is nothing terrible about "include Hp" but to me the best syntax is just has_hp 100" as it clearly states that instances of that class have 100 hp. Saying "include Hp" and then "has_hp 100" is redundant. So I could add the functions onto a GameObject class to avoid messing with the core classes. It's a minor point and there's nothing wrong with doing it with modules. I just don't see the advantage of modules when they have worse syntax.
You should be able to make a cross app with electron : https://github.com/electron/electron And then you can write ruby if you want with Opal : http://opalrb.org/ Think of opal as Ruby with webassembly before it is there :) 
It's easy to read, making it maintainable. It's fun to code in, increasing productivity. Besides speed, which isn't even a huge problem, there's nothing really all-to-shitty about rails
1. This was a very eloquent post which could be useful for many. Please consider turning it into a blog. Medium.com could be an easy way to start one. 2. I looked at C# and .net but found a lot of verbosity and boilerplate. You don't seem to have an issue with that... or maybe you have found a way to reduce it?
A very good point! 
1) it's normal to feel discouraged when learning something new, especially if it's against your will (i.e. your company / team lead is making you do it) or something​. We'd have to know what you hate about it to give targeted advice/suggestions. 2) Rails is one of the many reasons it got popular, but one of the reasons it remains popular is the relatively happy and supportive community. A handy but wacky acronym for this is MINSWAN (matz is nice so we are nice), the point being the Ruby community should aspire to be friendly and helpful. There are definitely things I don't like about Ruby, but developing with it has generally been a pleasant experience. With more details about your personal issues with the language, we can probably help you deal with your frustrations with the hope of improving your outlook. I used to think I hated JavaScript, but ES6/ES7 has made it pretty fun. 
Of course it is. But so is division of labour!
I think you hit the nail on the head..
Thanks for the vote-of-confidence. I've been studying it every day for a month (but a lot: like...I've put in maybe 100 hours and have hundreds of commits so far). Sometimes it feels like the backing code was written by twenty different people in twenty different ways with no standardization. Maybe that's its power? 
I don't completely hate it (right now). It just feels very unstandardized. I get "surprised" by things all the time. 1) "Oh fuck, okay, that returns nil, glad I checked." 2) "Oh fuck, okay that's destructive, glad I checked." 3) " ... not destructive ..."
I'm just studying it every day to move beyond bash and java. The docs and backing language seem a bit wild-westy...but I think I'll be alright. And yes the syntax is feisty at times.
Interesting. I don't hate it.
Yeah, you did hit the nail on the head. I know bash and java, but I'm trying to take Ruby seriously. It's coming a long well. I think it's just I'm not used to such a crazy flexible syntax. 
TIL that expressing an unpopular opinion is considered shitposting. I mean, yes, his tone is a little aggressive, but unless the definition changed in the last three years, this is far from shitposting. If someone makes a post simply saying "Ruby is amazing, I love this fucking language, why isn't it more popular? ", nobody's gonna call that shitposting. 
Jesus Dude. Give some EXAMPLES. We don't know what you are talking about.
[OP's response to /u/whalesalad](https://www.reddit.com/r/ruby/comments/69m3iw/someone_please_convince_me_why_ruby_is_so_popular/dh86g1q/)
&gt; seems to be a double edged sword ["Ruby includes a lot of sharp knives in its drawer of features. Not by accident, but by design." - DHH](https://m.signalvnoise.com/provide-sharp-knives-cc0a22bf7934) Edit: FYI, DHH is the creator of Ruby on Rails.
What resources are you using to learn it? I didn't find it's syntax very crazy or unpredictable, but I learned it in 1.8 days, it's possible it's gotten crazier to a newcomer since then. You already know Java, so you already know OO. The key to ruby is remembering that _everything_ is just methods called on objects. Like, everything. Sure, method calls can have parens, or not. But it's all just methods called on objects (or "messages sent to objects", as the smalltalkers would say, and is actually more accurate in rubyland as well). A block is nothing but a special kind of argument sent to a method call on an object. 
The standard for destructive or not is to put a '!' in the method name. I'd really like to see some actual code to try and help you with. Are you using irb at all? Java9 has a repl now, but Ruby was born with a repl.
ah yeah. if you're coming from a java background you're probably thinking "but i thought i knew OOP, and this sure doesn't look like OOP to me!" it's a different kind of OOP and arguably one that's truer to the roots of Alan Kay's original vision. stick with it and i think you'll find it mind expanding. i recommend the pickaxe book "Programming Ruby" from pragprog.com as the best guidebook. i think it will clarify a lot of things for you.
You're talking to coders. Write a line or two that confuses you and you'll be told why it is that way. Ruby was *very* confusing to me coming from Java. But once I understood why it does what it does, I can't ever go back.
If you can give any examples, people will be able to explain why it is the way it is. Just gotta give examples. Ruby has a much more consistent design than some other languages, but without telling us what you're struggling with, we can't help.
Don't forget your Beans!
Ruby became popular because of Rails. Rails was popular because it popularized a new paradigm. That has been succeeded by Angular et al, so Ruby has settled down to a much healthier place. The reason Ruby was popular is a historical question, and mostly irrelevant to whether it's the language you should learn and use right now.
Well, composing existing tools is a great thing to do ;) But it would be interesting if the library would stream downloaded videos directly into ffmpeg, something like: require "open3" Open3.popen2("youtube-dl http://example.org/video.mp4 -o -") do |y_stdin, y_stdout| Open3.popen2("ffmpeg ... -i pipe:0") do |f_stdin, f_stdout| IO.copy_stream(y_stdout, f_stdin) end end
That definitely sounds like a leak. I would want to know what `GC.stat` reports after an hour or so. 90% probability the leak is in curb (does the leak go away if you use net-http as the adapter) because c-extensions are usually leaky.
I upvoted you. The amount of actual science that goes on in your typical software "engineering" organization is negligible. Instead, everyone's preferences are governed by the same part of our brain that recognizes and adapts to fashion trends. It's no wonder we disagree all the time, we don't even have the basic stuff that actual agreements are made of.
Thanks, interesting you brought this up. I opted for temp files/discrete steps at least to get off the ground. But this did occur to me and might give a bit of a performance boost Any other big advantages as you see it? Maybe I'll try it in the next couple of days. Thank you for the snippet (or feel encouraged to do a pull request if you'd like) 
Uuuu, now that's more interesting. :)
Just an FYI: Go's cross compiling is better than Crystal's. Go does not depend on **anything** from Linux except the kernel whereas Crystal binaries depend on libc so must be recompiled for flavors with different libc versions. A single Golang 64-bit Linux binary can truly run on any 64 bit Linux install.
looks to me like the script should be file size agnostic. do you get the normal output in the terminal about decoded data blocks?
It might make more sense to at least link to [the changelog](https://github.com/sinatra/sinatra/blob/v2.0.0/CHANGELOG.md#200--2017-04-10) rather than just the repo/README :)
That's good, but if it used keyword arguments it'd be great. E.g.: `876.543.floor(precision: -2)`
This is what ```GC.stat``` says after half an hour and 35k requests: {:count=&gt;156, :heap_allocated_pages=&gt;132, :heap_sorted_length=&gt;133, :heap_allocatable_pages=&gt;0, :heap_available_slots=&gt;53801, :heap_live_slots=&gt;52942, :heap_free_slots=&gt;859, :heap_final_slots=&gt;0, :heap_marked_slots=&gt;25344, :heap_swept_slots=&gt;13869, :heap_eden_pages=&gt;132, :heap_tomb_pages=&gt;0, :total_allocated_pages=&gt;132, :total_freed_pages=&gt;0, :total_allocated_objects=&gt;4149704, :total_freed_objects=&gt;4096762, :malloc_increase_bytes=&gt;31896, :malloc_increase_bytes_limit=&gt;16777216, :minor_gc_count=&gt;151, :major_gc_count=&gt;5, :remembered_wb_unprotected_objects=&gt;475, :remembered_wb_unprotected_objects_limit=&gt;950, :old_objects=&gt;24532, :old_objects_limit=&gt;49042, :oldmalloc_increase_bytes=&gt;5002776, :oldmalloc_increase_bytes_limit=&gt;19737900} The leak goes away even with curb, if I don't use authentication.
Thanks for the response. The script gets "hung up" http://imgur.com/w2q4TSq. the little white line below after I execute just blinks. And a csv is produce in the working directory, but the csv is empty. When it runs successfully with a smaller file it returns a csv with the parsed data, and in the command line it says success, read X amount of blocks... 
A gem is correct here. You can include any kind of file you want with it. Also, remember that gRPC doesn't guarantee message delivery, and that synchronous requests (in particular queries) pave the road to a distributed monolith :-)
Not that I love the idea either, but the directory structure of the gemspec's `files` attribute is preserved. So your microservice code could be in `lib` and your protobuf files could be in `proto`, and they'd both be located in the same parent directory. So I think you are going to need relative links from the lib directory to the `proto` directory. One thing to consider is that you can view your projects (i.e. git repositories) as _components_, not services. Services can then be deployed by simply pulling in one or more components via rubygems. This can be combined with `bundle --standalone` to produce packages that can run in production without rubygems at all (i.e. `ruby --disable-gems`). There are a couple of benefits: 1. Teams that treat every project as a service end up with hundreds of services, but substantially fewer areas of concern. Separating services from components on the other hand allows for another degree of depth in your topology. That means you might have, say, four more or less independent components related to inventory, which might be called an "inventory service." 2. When you use `bundle --standalone` you end up with a directory structure that has all the dependencies locally. This means it can be packaged up and deployed properly (i.e. without git over SSH). If you use something like `fpm` to create a `.deb` package this gives you a really great deployment story. All you need to do is untether the 1:1 relationship rubyists have come to expect between a git repository and a deployment unit. Okay, way off topic here, sorry :-)
I loved Ruby when I started with it, because it had the power and Object-elegance of Smalltalk (well, some of it) with the ease of a scripting language. But it is slow, and not as elegant as I first thought. So, I'm going back to Smalltalk. But, I still love irb for a terminal calculator.
Sorry, I don't, at least not based on personal experience.
On the contrary - I'm really interested to see how this handled by other teams. I'll remind that the Microservice I'm speaking with is written in JAVA not RUBY, so the Gem will hold just the Proto files, the `lib` folder will be empty. It's basically a Gem that his only purpose is to share proto file for Other micro-services that going to talk with this Java Microservice. So yes - the original idea was to figure at runtime where the gem with the protobuff is installed. For example in my case that would be `~/.rbenv/versions/2.2.4/lib/ruby/gems/2.2.0/gems/my_protobuff`, and then as you mentioned - generate local Ruby code using `grpc_tool` and state `~/.rbenv/versions/2.2.4/lib/ruby/gems/2.2.0/gems/my_protobuff/lib/proto` as input. But what you suggested is far more interesting. I wasn't aware of the `standalone` flag. I probably don't need ALL my gems to be installed locally under where the Gemfile is, so I'll have a look. Perhaps I can selectively mark a Gem in the Gemfile, so only my Proto gem will be saved locally and the other gems will be extracted normally to the RUBY_GEM folder. EDIT: Nope. Doesn't seems possible. `--standalone` basically bypass the gem mechanism, so there is not option just to have a single gem installed locally. I'm thinking perhaps instead of bundling just the `.proto` file in a gem, I should share the generated code itself in a gem. That way I can just use the gem normally. The bad side of it - is that if for example I generated the Proto ruby code on on machine with Ruby 2.2 and bundle it into a gem, there is a change it won't be running against Microservice that runs Ruby 1.9 for example(rare, but you got the idea). It's almost always better to generate the `proto` in the context of your micro-service.
See the above 'EDIT', I was done with it when you posted your comment :) I'm not sure what do you mean by 'Ruby Client Library'?'
I'd recommend profiling it, but just a guess: You're doing several things in your read loop that cause sys-calls which are rather slow: 1) Calling `File.size()` in your while loop. This requires a `stat` sys-call which is rather slow. Request the file size once and store it's value. 2) Calling `#seek` multiple times per loop followed by `#read` of a very small amount of data. This also results in an `lseek` sys-call which is also not terribly fast (how slow depends on the OS and file system) followed by a tiny read. You're probably better off using using `sysread` and `sysseek` using a relative offset and only doing this once per data block at most. In other words your probably better off fully parsing each block and throwing away the bits you don't want than you are trying to parse only the bits you need by seeking around in the file, the CPU time for parsing the block is very cheap in comparison to the IO time to move around in the file. Note that you may not even need to seek in this case after skipping the header. For best performance you probably want to read blocks in batches. You're also storing all the data in memory as you go which may use a lot of RAM for larger input, if you want to just write this out to a CSV you should do this as you go rather than accumulating it all in RAM. 
That's very interesting! Thanks for sharing this info. Going back to UI though, as soon as you bring in a Go binding for a C/C++ UI toolkit (and the toolkit itself), then aren't you again depending on libc on the target system? (forcing you to recompile for, say, different Linux 64 bit flavors?)
 &gt; Stop wasting your time and energy with version managers, dependency managers, environment setup, and infrastructure configuration and management. Have you measured how much time and energy is spent on those line items? In my case at least, it's not a lot. I suspect it's not a lot for most ruby devs, too.
 With pipe: 0.010000 0.010000 1.360000 ( 2.326080) With file: 0.000000 0.000000 3.110000 ( 2.622392) There is a complication though. I may need to use *ffprobe* after processing in order to ascertain what type of file the resulting video should be. This would probably still be more performant but does add some complexity to the program. I'll mull it over a little more
I feel like my comprehension would have been higher if I knew what DDD stood for.
It's very standardized if one takes the time to learn the standards. Did you take the time to learn the standards?
Stoked for this! When I was first learning, Sinatra was the framework I cut my teeth on for creating an application. Cool to see it still in development.
Multiple threads can't interpret ruby code simultaneously. However, if a thread is blocked on something like waiting for an HTTP response, other threads can get work done in the meantime. Sounds like your work is largely IO bound; I'd guess you wouldn't gain much by switching to process parallelism.
Using processes instead of threads means you can't just share variables between your workers since they each have their own memory spaces. You gain all parallelism all the time, but you have to use message queue objects to communicate. Edit: looks like IO::Pipe is the standard inter-process communication channel for Ruby. I've honestly only ever dealt with process parallelism in Python, but the trade-offs are very similar.
Yup. https://github.com/karafka/karafka
Thanks! Wow, this project seems fairly mature. Not sure if I'm a fan of the heavy, Rails-like API, but certainly worth looking into before I go off the deep end rolling my own.
Forking is more expensive than creating a new thread, this is part of the reason why sidekiq is faster than resque. Also there's no real analogue of a threadpool for forking. And you generally want to avoid mixing forking and threads (e.g. http://www.evanjones.ca/fork-is-dangerous.html).
Yeah but threads don't run in parallel, so while it is higher memory to use forks, wouldn't it be significantly faster? At least for certain processes?
Yes, those certain processes being ones that are CPU-bound. Your threads all share the CPU (at least in Ruby), so if they're all mostly using that, then you won't see significant speedup. However, if your work is mostly IO-bound, then Ruby can do work on a different thread while one is waiting for IO to come back (in your case, a web request to finish). I would guess the work you're doing is IO-bound (waiting for the websites you're scraping to get back to you) so I don't think you'd see massive speedups by forking. You also have the forking disadvantages mentioned above.
I actually built one as a long-running rake task. Works really well. Just use the native kafka connection message loop and roll with it. About the only thing you'd need to figure out is launching a few in a single instance.
Most of this comes out of the box with Kafka, you just define a consumer group and spawn multiple processes that connect to topics using that consumer group, kafka will make sure to balance your consumers over the available partitions and to only connect one consumer per topic etc. Is there anything you're specifically wondering about?
Done
Take the full list: https://gist.github.com/tadas-subonis/03d96821d8575f6ba632efe2bb386f5d :)
Just bumping because I'd like to know, too. I've seen them used and as a terse way to do attribute accessors via inheritance, but when I started showing code where I did this, I started to get a lot of recommendations not to do this. Not sure why.
I use them for classes where the only methods are the accessors. As soon as I start adding other methods, I write out a full class.
Oh, I see what you mean now. Another interesting approach, so it will basically look like so? require 'helloworld_protp' def hello_world stub = Helloworld::Greeter::Stub.new('localhost:50051', :this_channel_is_insecure) stub.say_hello(Helloworld::HelloRequest.new(name: user)).message end But it means that: 1. It's a bit of a thin layer. A wrapper around something that already is pretty basic. 2. In case `say_hello` is being updated to `say_hi` in the proto file, I will only be able to pick it's broken when trying to use the gem. So it's like creating another dependency in the middle that someone need to take care of. Not sure that will work on basic micro-services.
Thanks! I'm curious how you compiled the original list. What sources did you use? 
MRI ruby has a thing called the Global Interpreter Lock that only allows one thread cpu access at a time regardless of the number of cpus/cores that you have. Jruby has native OS threads and does not have the GIL. If you really need the parallellism, then you might want to consider jruby.
You can also add this one https://drivy.engineering/
While this looks like a good idea, I think in it's current form it's kinda half-baked. You should pick what is important to you and do one of: 1) accept numbers in `+()` def +(other) other = other.value if Distance === other raise ArgumentError, "Distance must be &gt;0." if other &lt; 0 Distance.new(value + other) end 2) change distance initialization to require unit module Units KM = 1000 end def initialize(value, unit) if value &lt; 0 raise ArgumentError, "A distance must be positive" end @value = value * unit end class Integer def km Distance.new(self.to_i, Units::KM) end end My point being is that you either want to keep it easy to use (first variant) or hard to break and make mistakes (second variant). I personally would probably go with second variant most of the time. Opinions? DISCLAMER: I'm new to ruby, so my example code might suck hard. But the general idea should hold (imho). 
Hey, thanks for reading and sharing! New requirements like supporting units may require refactoring, you're right. Since they weren't in the original specs, I didn't wanted to go that deep. Accepting integers and validates that they are &gt; 0 seems doable. It leaves too much room for implicitness IMHO and I prefer the second approach you mentioned. I think a value object could _hide_ a simple primitive value such as a Numeric and still increase reader's understanding. Do you think we need a unit to make it worth? I clearly agree that a distance make more sense with an unit, but I can live with having an implicit unit, like meters. Of course, as soon as it become an issue, I would need to refactor this the way you proposed.
Accidentally I've made some web scraping in Ruby too, not long ago ;) Try to run it with JRuby to get some rough idea if threads may be performance limiters. Before some dedicated profiling. In our specific case it led to significant runtime speed gain, however there was CRuby requirement in deployment conditions. I had to split data munging code into multiple processes and it really did fixed the gap. Memory footprint has increased, of course, but still within margins at target dynos. CoW reduces costs of forking a lot. I'd also recommend take a look at [parallel](https://github.com/grosser/parallel) gem, which may come handy for similar tasks and find it enough mature. 
ah sorry one more update: * 2017-05-09 added section "Domain logic not CRUD" 
Thanks
Feel free to play with this new feature. It is NOT ready for prime time yet. 
&gt; with having an implicit unit, like meters Yep, exactly. But in the case you have implicit unit anyway, it makes no sense to not allow integers as well. At least to me.
I have a somewhat related post: http://ragmaanir.mypresident.de/2016/12/07/problem-graphs.html
what do you mean 'rusty' gem? there's no information on what you mean on either the link you give or the 'homepage' link from that link
I just write the gemspec by hand (or starting from another one I've got handy). It's not like it's all that complicated.
I think tables and indexes are count differently in postgresql Not sure about mysql
It's a breath of fresh air to work with systems that store their transactional state in streams, and update a separate relational database over pub/sub for UI queries.
https://github.com/flajann2/juwelier/blob/feature/rusty/README.org#rusty-gems-support-highly-experimental I re-released this, because I forgot to merge the feature branch back into the master. Sorry about that. Rusty gem is a Ruby gem with Rust as an extension (as opposed to C). Yes, for sure you can create your own gemspec by hand. And yes, Juwelier is a fork of Jeweler. I maintain both, now. 
The task of wrapping MediaWiki (wikipedia, wikidata, wiktionary, wikia.com....) API is pretty interesting, because of two facts: 1. its [API structure](https://en.wikipedia.org/w/api.php) is really far from any other API (REST or not) 2. there are lot of different installations, with different modules and features enabled. I believe that MediaWiktory is **the first** MediaWiki API client that handles (almost) all the quirks gracefully, is well-documented and clear.
Well, I personally prefer to do it all by hands, just like you, but in fact every new Gem skeleton is not just `.gemspec`. What `bundle gem` does is: create foobar/Gemfile create foobar/.gitignore create foobar/lib/foobar.rb create foobar/lib/foobar/version.rb create foobar/foobar.gemspec create foobar/Rakefile create foobar/README.md create foobar/bin/console create foobar/bin/setup create foobar/.travis.yml create foobar/.rspec create foobar/spec/spec_helper.rb create foobar/spec/foobar_spec.rb create foobar/LICENSE.txt Most of it you'll need anyways. And also probably something like `rubygems-tasks` (which provide commands like `rake release` -- tag the git repo with version, create the gem in `pkg` and publish the gem), and probably some `.yardopts` and so on... So, despite all my hate to code generators, I should say that at least `bundle gem` COULD be useful. Though, I still do everything by hands :)
Thanks for considering Karafka. We aim to deliver a good development experience when working with Kafka, without having to dig into Kafka details. We put a lot of effort to keep it clean and well written. It's good to know, that some people see that :)
Neat. Looks like it might be more for dealing with the data than, say [reality](https://github.com/molybdenum-99/reality), which is more for getting human-usable information
Couldn't fit it into 7 lines but I don't think it's that bad (whole app apart from settings - settings logic used): ENV['KARAFKA_ENV'] ||= 'development' Bundler.require(:default, ENV['KARAFKA_ENV']) Karafka::Loader.new.load(Karafka::App.root) class NewDataProcessor &lt; Karafka::BaseController def perform # Do something here with params end end class App &lt; Karafka::App setup do |config| config.kafka.hosts = ::Settings.kafka.hosts config.redis = Settings.redis.to_h.symbolize_keys config.name = ::Settings.name config.inline_mode = true end routes.draw do topic :new_data_source { controller NewDataProcessor } end end App.boot! Redis is going to be removed soon as a dependency (you can use karafka without sidekiq and redis at all). So 1 less config option for setup ;) Also, for any lib you will have to provide kafka details + the name so, apart from loaders, etc - I think it is not way more complicated than what you aim for.
Well, my real use case is data extraction (it is lowest level of work underneath [reality](https://github.com/molybdenum-99/reality), so I need to be comfortable making complex queries to several different MediaWiki installations (wikipedia, wikidata, wiktionary, wikia, wikivoyage, you name it). But when I've understood I dislike all existing clients, and started to study how the MediaWiki API structured and works, it looked for me like a really interesting challenge to design _full_ wrapper. Answering the particular question: &gt; how, or why would you edit pages through the API? The main use case is bots. There are tons of useful bots and even bot frameworks for Wikipedia and other wikis, that, for example, add auto-categories, check links and add notices like "it was dead at #{Time.now}", add notices about quality, auto-link concepts and so on.
I just created this gem I needed for myself and I thought I'd share it with you. I hope you find it useful! 
I'd at least NFC passwords. If someone's using non-ascii in their passwords, and on one OS/browser/keyboard locale it assembles the codepoints one way and on another it does another, it's gonna be awfully confusing why they can't get in. But yeah, NFKC would potentially reduce the entropy of the password. It might not matter realistically. I guess NFC kind of reduces entropy too, but you might as well advocate that users be allowed to store passwords in the encoding of their choice -- UTF8 or UTF16, hey, why stop at unicode, go for with Shift-JIS or IBM852, and just rely on the browser somehow assembling the bytes properly for whatever they meant in their 'original' encoding. It would be madness. 
&gt; The canonical way to do such thing is to use the base character and the applicable combining marks. What makes you think this is 'canonical'? I would say unicode establishes NFC normalization as 'canonical', which composes things that can be composed, the opposite of your suggestion that decomposing them is 'canonical'. In most programming libraries, if you just ask for unicode 'normalization' without specifying a normalization form, you get NFC. Of course, if you want to treat decomposed as 'canonical', you can always use NFD normalization. One could perhaps argue they are both equally 'canonical' normalizations, both normalization forms are available (along with 'compatibility' versions of both, which actually convert graphemes to more common ones considered semantically equivalent, and are definitely not 'canonical', but are super useful for sorting and ensuring equivalent retrieval). But if you're going to pick one of them to call 'canonical', I'd say it's definitely NFC, not NFD. [UAX#15](http://unicode.org/reports/tr15/) on Unicode Normalization Forms is very well-written, it's a quite readable explanation of some confusing concepts. I highly recommend reading that original unicode report to anyone that runs into unicode encoding issues. Get your basic understanding of what's going on set. 
I just use Lita since it makes it easier to port the bot between services. My company has gone from Campfire to HipChat to Slack and it's been pretty painless to port the bot between services with Lita.
Ugh, agreed. Hey, let's introduce some backwards compatibility while we're at it, you know, just to get the 'buzz', everyone will have to talk about it since it'll be a pain to deal with! 
Well, from my very limited experience with both gems, it appears this is more useful if you want to, say, build an edit-watcher or the like, while reality is more useful if you want to, say, provide wiki lookups in an application (a-la google knowledge graph) Either way, both are awesome gems
I resolved my issue, I added ":header_converters =&gt; :symbol" to my CSV object which converts the headers in advance. I then don't lose the first key/value pair when I row.to_hash.
Thanks :) TBH, in my head currently `reality` is just a "cool demo". But next release (that I am promising everyone for last 4 months) _will_ be a useful thing (and not limited to Wikipedia/Wikidata anymore). Dreams, sweet dreams.
Also with the pivot being selected as the left most item it could sort poorly in O(n^2) if the list is in reverse sort order. 
Where I work, the dev laptops are so different from the production environment that the code no longer works on the laptops. It's not even enough that you have the same Ruby Gems as are running on the production servers. You also have to have all the same external services. I have to run Postgres, Redis, Rabbit-MQ, *and* Cassandra and keep them working, but even that's no longer enough. You also have to have all the cloud services that your app depends on to run it locally, and you need a separate configuration so that the app uses the local versions when run locally, but the real versions when run in production. The setup is really brittle and breaks all the time. 
they run some kind of actions in parallel threads
RFC 3454 has been superseded by [RFC 7564](https://tools.ietf.org/html/rfc7564) which recommends NFC (i.e. composed form), as do [RFC 5198](https://tools.ietf.org/html/rfc5198) and [RFC 7613](https://tools.ietf.org/html/rfc7613) (deals with usernames and passwords, probably the most common place for this stuff to come into play). The NIST says to use compatibility normalization for passwords (not quite sure why), [but doesn't give a preference between NFKC (composed) and NFKD (decomposed)](https://pages.nist.gov/800-63-3/sp800-63b.html#sec5). Those sources are probably about as canonical (in the sense you are using it) as you can get. As far as segmentation goes, in Ruby 2.0+ you can use `\X` in regular expressions to match a grapheme cluster (i.e. it is an implementation of that particular algorithm). For example, `str.scan /\X/` will split your string up into an array of "user-perceived characters" whether they're in a composed form or not. Unfortunately this functionality isn't very well-known.
Check my other comment, stringprep is obsolete and the current advice is to default to NFC (unless you listen to NIST). However there is [an RFC](https://tools.ietf.org/html/rfc7700) that says to use NFKC for chat nicknames and such (essentially, identifiers that will be displayed to other people), which makes sense.
It seems to be so for this use case. Alas, using NFKC everywhere to get something that is easier to work with is not always possible, as stated in UAX15: "Normalization Forms KC and KD must *not* be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets, and unless supplanted by formatting markup, they may remove distinctions that are important to the semantics of the text. It is best to think of these Normalization Forms as being like uppercase or lowercase mappings: useful in certain contexts for identifying core meanings, but also performing modifications to the text that may not always be appropriate. " 
Well finally :) This has been requested for years, and it seems that the only thing blocking it has always been that they weren't sure what to name the method.
Most of the time I've used refinements for that, to be honest. I defined my own `Object#derp` method (looks dumb enough, and resembles `tap`) and went with it (though, nobody loves refinements)
That's an interesting idea. It would be cool to represent my docs as a graph.
Any idea why not implemented simply as an optional block to existing [`Object#itself`](https://ruby-doc.org/core-2.2.0/Object.html#method-i-itself) ? Something like class Object def itself block_given? ? yield(self) : self end end Also can't see why it has to be defined in `Kernel` instead of `Object` directly. Reuse existing method instead of inventing yet another silly one. 
There's the lesscode community too, #lesscode on Freenode, or https://www.reddit.com/r/lesscode. It was created by soveran I think, the creator of the Cuba framework. 
I did not see your article, but I really want to read it now. Any possibility of a link?
&gt; Where I work, the dev laptops are so different from the production environment that the code no longer works on the laptops. That's a code problem.
Great to know! Is there any sort of related discussion mailing list?
Recently, I've been using an implementation of the actor model that I wrote: https://github.com/ntl/actor
I understand your point of view and non web developers are welcomed to the discussion as well as I noted in the welcome message. However you can't compare this to some sort of logging library community from my point of view. Ruby web developers share a lot of problems to solve, such as: - integrating NewRelic (or some other performance service); - supporting websockets; - managing static resources/assets; - managing analytics; And so on. There are many other parts that would be shared across non web developers too of course, I'm just warning that those people may not enjoy the discussions over the problems that are only shared among web developers. If they are fine with that, then they would benefit from such mailing list. Otherwise they would know beforehand that such subjects will probably be discussed in the list and maybe they would decide not to subscribe. I'm just trying to give a better feeling on what it would be mostly about. However, if there are many non web Ruby developers interested in discussing such subjects we can surely reword its goals and make it broader. I'm open to suggestions, whatever the community thinks would work best for us.
I got the same impression this time as in your previous message :) I completely agree with you that this is mostly about programming, not something specific to web programming. I'm not proposing a discussion group focused on web frameworks development. It's mostly about applications. As I said, non web programmers are welcomed in the discussion as well. I'm just warning that it's very likely that we would be discussing about several tools that may only make sense in web development. But how I said in my previous comment, we could just drop the "web" from the group description if we decide it makes more sense.
What would be a useful case for this? Seems like the examples could just be: "Hi, #{user.name.upcase!}" or user.male? ? "Mr. #{user.name}" : "Ms. #{user.name}" Seems like those just obscure conditionals or variable assignment.
this and tap both seem to me like syntactic sugar, or maybe it's better to say they support more terse/idiomatic code, for example: obj = {a: b} obj.delete :a puts obj vs puts {a: 1}.tap { |obj| obj.delete :a } Since hashes are mutable, both produce the same result, but compare the results of tap vs. yield_itself here: 1.tap { |num| num + 1 } # =&gt; 1 1.yield_itself { |num| num + 1 } # =&gt; 2 There are probably not many situations which really scream "I want `tap` or `yield_itself`", but I feel that using these methods leads to a more functional style.
Thanks for the explanation. You're right, it does feel much more functional. `tap` seems to lend itself towards "fire and forget" where you don't care about the return value. `yield_self` in the case you described could probably just be isolated to a function, no? def add_one(n) n + 1 end def times_two(n) n * 2 end times_two(add_one(1)) But in Ruby, calling functions serially is not as pretty as in, say, Elixir: 1 |&gt; add_one |&gt; times_two etc. So with `yield_self` maybe it's easier to chain functions together. 1.yield_self {|i| i + 1}.yield_self{|i| i * 2} But... I dunno. I think it'd be sweet if we could write it as: def add_one(n) n + 1 end def times_two(n) n * 2 end 1.(&amp;:add_one).(&amp;:times_two) 
Besides, the first solution was not working. I have no idea why anyone would post such underdeveloped article. I even doubt he read that after writing. 
I'm a ruby hobbyist. And when I first started learning ruby, everything seemed to be revolving around rails. You could painfully say, rails is the language.... I wanted to learn ruby not rails. Thanks for starting this. Though I personally dislike Google groups.... Why not another subreddit? 
Because of the GIL, as flashbck pointed out, MRI Ruby can only take advantage of a single core. Forking, on the other hand, will allow you to take advantage of multiple cores, even with MRI Ruby. Yes, yes, forks are more "expensive", but if you organize everything right, you can certainly glean extra performance from it. Basically, you want to avoid doing a lot of forks. You want to arrange your code with a "worker" model, and you initially fork off a set number of workers, and have them pull work from a common queue, such as RabbitMQ. How many forks you should have depends on the task at hand, but I would recommend 2X the number of cores. If your operations have exceptional latency, maybe 3X cores, but I would not do anything higher than that. You can leverage both threading and forking, and I would strongly encourage this, despite the difficulty in programming for that. So I would say the optimal would be 2X forks per core, and judicious use of threading in each fork. If you are not good at threading, then keep it simple and just have a single thread per fork.
Imagine this: url = construct_url(**params) body = HTTPClient.get(url) parsed = JSON.parse(body) raise if parsed['error'] parsed Now look at this: construct_url(**params) .yield_self { |url| HTTPClient.get(url) } .yield_self { |body| JSON.parse(body) } .tap { |parsed| raise if parsed['error'] } Why is the latter better? Because it shows exact _flow_ of data, and with short-living, block-local variables is easier to read and understand (in not-so-simple code with complicated statements, it is not always clear, what was the purpose of generating `url` -- just to use it in the next line, or it is necessary for several more statements, or the variable is not necessary itself, and you are just catching side effects...) Yes, the second example is "the same" as first: the way in which `map` is "the same" as `for(i= 0; i &lt; array.size; ++i) ...` (you can say that `map` is "syntactic sugar" over "plain ol' cycle"). The other ways to dislike `yield_self`, if you want to: * you just don't like how it looks (I am working with a guy who hates `tap`) * it could be slower (block creation and calling overhead), but it could be crytical only in a rarest situations.
looks really interesting, but I can't help but wonder if (possible less powerfull) think could be achieved with just a bit smaller amount of dependencies. I mean, why exactly it does need pry and pry-doc? Could you make them optional with runtime checks for what features as supported?
Huh, thanks for the links. I did missed this option was already discussed. Still can't get what is *confusing* or *ambiguous* about this solution and why adding new core method is necessary. It seems keeping internal consistency of an existing language while adding new features is a much more challenging task then inventing a brand new one.. 
Ok got it. Thanks for explanation :).
Well, by Matz's reaction (or rather lack of it) to this method proposal, neither he nor any of top core-devs truly love the idea. So, they response was rather like "ok, you ask, we did it, but let's use an obscure long name and never think about it again".
You could also just add blank lines: url = construct_url(**params) body = HTTPClient.get(url) parsed = JSON.parse(body) raise if parsed['error'] parsed Chaining together `yield_self` and `tap` is manifestly less legible. The important parts of the lines of code get buried inside blocks. The only line that doesn't start with indentation is the first one, which says `construct_url`, which suggests the four lines of code are _about_ a URL. So I don't see it proving generally useful. I'll add the caveat that I suspect there are valuable patterns out there that call for `yield_self`. For instance: def some_method &amp;block if some_calculation(a, b, c) yield_self &amp;block end end `yield_self` would allow the block passed in to also serve as the return value at the method callsite: return_value = some_method do :foo end In that example, `return_value` would be `:foo` if the block got called, but `nil` if it didn't. So you could encapsulate a conditional expression pretty nicely.
I see that your biggest motivation is to "erradicate" activesupport, and I feel divided. I know where you're coming from, but let's agree that "open for modification" is (whether we like it or not) a feature in ruby. Monkey-patching is a feature. Refinements are controlled monkey-patching, but they are monkey-patching. Creating a community around the goal of not using core philosophy and language features, when looked upon from this perspective, doesn't seem like a good idea. You'd be better off using a more minimalistic approach like Go has. I'm all for dropping activesupport, not necessarily because of monkey-patching core classes, but because it provides a context-less bundle of language extensions. Some of the number/time extensions are very helpful. But I have to throw all the rest with it. Some stuff, like the Symbol#to_proc thing, came from activesupport. Some of these things end up (again, whether we like it or not) in the standard library. Javascript is also "open for modification", but adopts a more minimalistic approach, by distributing those extensions as mini-packages. Is it controversial to say that this practice actually helped javascript thrive? How about dropping rack? For all the slack that rails gets these days, I'd say that rack has aged less gracefully. 
Neat, could be useful in a project I currently have, but I wonder, whats the value proposition of this over say, the Attributes API?
it's used by `faye_websocket`, which is a gem to use with rack/sinatra apps. 
I like and support monkeypatching as a feature but it shouldn't be used by gems, just apps where you the developer control everything. Gems should be predictable, well-behaved citizens within the system.
&gt; It turns out to be a matter of taste, all in all. &gt; It will end up as "you see this, I see that." Well, it began with you asserting that the second of two functionally equivalent code snippets was better than the first. If you already know we're going to end with two equally valid opinions, then isn't it fair to question your assertion that one was _better_ than the other? At one time I felt very strongly about avoiding local variables in my code. After reading a lot of it, both with and without, I eventually fell on the side of avoiding long chains of block methods. The reader benefits greatly from the break that occurs between statements, even if there's a bit of context maintained in between in the form of local variables. The indented ` .next_method(...)` always tricks the reader into thinking that this statement is _subordinate_ to the original non-indented line, and that the entire chain needs to be understood together. That's a lot _more_ context that has to be loaded into the brain than a local variable or two. "Agree to disagree" is reasonable here, but in that case I don't buy the assertion that one is better.
Hey, I started this about a month ago, it's already being used by some companies, but it really needs a lot of work. https://github.com/dansteele/retro-ken
I'm curious, what's the rate of adoption of refinements? Where did you see it? How do you measure it? I have never been interested in refinements myself, but I'm still curious. Ruby supports symbols, which in my opinion only serve to add confusion to the language when you want to access a hash by its key. If a symbol was just another way to write a frozen string I'd be good with it. However, the existence of symbols is not a reason why I'd replace Ruby with some other languages. No languages I know would make me a 100% happy, so we have to live with that and just choose the best tool for the job, which usually means Ruby for me for most cases, despite the existence of symbols. On the other side, I do like the ability of monkey patching provided by Ruby. I remember when I first read about it I was both excited and afraid. As you said "if something can be done, it will be done". That's why people will abuse macros and use goto in C or inline assembly and so on. However, some features exist to provide a solution for some specific cases, not to be just generally used. Monkey patches is a feature like this for me. For example, my AutoReloader library provides transparent automatic code reloading and this is only possible because Ruby allows me to wrap `require` and `require_relative` through monkey patches and this is awesome, otherwise I wouldn't be able to create such solution. AutoReloader is usually used only in development mode, since it's transparent and doesn't require any changes to the code. So basically it's activated only in development environments and those methods are not overridden in test and production environments. Anyway, if ActiveSupport was all about adding such extensions to core classes I wouldn't be advocating against it. It's just that I don't think libraries should depend on its core extensions. It's fine for the final application to depend on such libraries though, like Mike mentioned. It's perfectly fine to me if someone wants to add methods to core Ruby classes in their final application. It's even fine if you want to create a library whose goals are to add such methods. You only add that library if you agree with those monkey patches. ActiveSupport provides a lot of features that are not related to each other, so that's basically what I dislike in it. You don't have a gem such as activesupport_notifications or activesupport_dependencies for example. It's all bundled in a single gem. However, let's suppose it would be all about adding core extensions to numeric classes in order to support 1.year.ago. It would be fine if it was a dependency of the final application. My real problem is that FactoryGirl depends on ActiveSupport. FactoryGirl's goals is to provide an object factory and it shouldn't change core classes while doing so. It's not something they really require to reach their goals. The same is valid for a web framework such as Rails. Why should Rails leak a lot of changes to core Ruby classes? This is what I really think is a bad practice. The feature of monkey patching is powerful and it's great if used to achieve things such as AutoReloader, however it can be also abused just like C macros and goto instructions. A web framework certainly doesn't require core Ruby classes to be changed. Or an object factory library.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [flajann2/attr_pow/.../**attr_pow.gemspec#L45** (master → c580286)](https://github.com/flajann2/attr_pow/blob/c5802869d8de10f89ecf6bb84f5c3d1eb479e127/attr_pow.gemspec#L45) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhiv6su.)^.
Just to complement my previous comments, just compare to the JavaScript community. JavaScript also allows one to change existing objects but you don't usually see libraries doing that. Prototype.js tried that approach and didn't get much acceptance. Usually this is done by specific libraries such as shim libraries but they are usually included only by applications and not by other libraries... So, I don't buy the argument that just because something is allowed in some language that we shouldn't fear it and just accept them as regular good practice. Maybe we should just use "eval" for everything since all interpreted languages implement it?
GitLab is pretty big open source Rails project if you like Rails. It's a very open project for community involvement. 
Fair judgement
I've been working on [this one](https://github.com/mapFactory/Github-Map) for a few months. I suspect there are some edge cases that need to be ironed out. Feel free to play with it.
https://github.com/NullVoxPopuli/aeonvera https://github.com/NullVoxPopuli/action_cable_client https://github.com/NullVoxPopuli/meshchat-core https://github.com/rails-api/active_model_serializers 
No love for IronRuby? =(
It's been abandoned afaik?
I can't give you much but there is an important part about jruby you should know. Ruby has multi threading in design but most implementations don't feature real parallel threads. Based on your JVM jruby can have parallel threads. For this reason racks / thins preferred implementation is jruby. If you are developing with less access to the machine jruby works without native compilation and can be potable in theory. The real world process is a little tricky though.
It looks like you're right. =(
This is really cool. Makes the whole process a lot easier. Thanks for sharing.
You only need to go through the list once. You just go through and record what the four largest you have currently seen are and by the end of the list you've seen all of them. This is O(n). Sorting is O(n*log n). In fact any comparison based sorting is provably at least O(n log n). It is not necessary to sort. If you wanted to find the largest element in a list would be O(n). Same for the 2 largest, 3 largest, and 4 largest. 
I thought Rubinius also has real parallel threads. That was one of its main selling points. 
This is more elaborate about that topic than I can be. http://stackoverflow.com/questions/56087/does-ruby-have-real-multithreading Just saw it's a tad old. You get the idea but there's probably some changes now.
&gt; I'm curious, what's the rate of adoption of refinements? I'm mostly basing on a few posts I've read and [this talk](https://www.youtube.com/watch?v=qXC9Gk4dCEw). To be honest, there are some limitations in it's practical use (you can't refine modules nor singleton methods) which hamper adoption. &gt; Ruby supports symbols, which in my opinion only serve to add confusion to the language when you want to access a hash by its key. Symbol is just an atom. Would you still be confused between `hash[1]` and `hash["1".freeze]`? I think that your problem might be the `HashWithIndifferentAccess`thing, and I'm not a fan of it either. Or maybe you're confused with the different syntaxes for setting hash with symbols and non-symbols as keys, and kwargs, and that'll be a completely different (and no less interesting :) ) discussion. &gt; It's all bundled in a single gem. I agree it's a downside, read my first comment. I kind of implied that the javascript micro-library design works better for this sort of thing. But the way this all started, activesupport was just extensions for rails internal use. It was packaged separately, and the community apparently adopted it massively at some point. But it's still tailored for rails internal use. Maybe someone can take the time to separate activesupport into micro-packages and integrate them back into it? Maybe the rails team is not interested in it, but the community is? There might be a precedent I'm not aware of. &gt; let's suppose it would be all about adding core extensions to numeric classes in order to support 1.year.ago. This seems like the use case for which refinements were made in the first place. You could extend integers in your library, and the user code would remain safe. &gt; A web framework certainly doesn't require core Ruby classes to be changed. Or an object factory library. Maybe it doesn't. But that's the same as saying that no web framework requires class-based inheritance, when composition is clearly the better abstraction. Or that functional approach is better than OO. And so on. The feature is there, the libraries are there, and the decision is from the maintainer to use, and from the developer to adopt the library, or choose smth else (or roll his own). Maybe your problem is not FactoryGirl adopting activesupport, but that there's no proper alternative for the factory problem which is freedom-patch-free? &gt; JavaScript also allows one to change existing objects but you don't usually see libraries doing that. Depends of what you mean by that. Javascript has first-class function support, ruby does not. Most libraries distribute functions, not objects. However, think of express middlewares. Most of them are distributed as libraries. Like the authentication ones. And all of them mutate the request object, where you can magically do `req.user` in your handlers. Just an example. &gt; Maybe we should just use "eval" for everything Oh you did not bring eval to this discussion :) Again, I mostly agree with the main topic, not relying or abolishing activesupport from the dep tree, etc. But ruby is a very permissive language. The more I try to segregate my object's API, there comes a new included module, or a new method (like `yield_self`) gets added to Object, or a monkey-patch. Or worse, a C-extension. If limitations aren't enforced by the environment, a community around ideas will lead to endless discussion and division about core principles. Take Go. It's known to have a very simple spec. Doesn't support generics. Devs want it. They implement their own version of it. Argue about what's the better way to implement it for Go. But the discussion is contextually limited to the libraries, not the language. So in the end, it doesn't matter. Always-on monkey-patching is ruby. I certainly don't fully endorse it, I might be paranoid at times because of it, and I can try to defend myself against it. But it's still there. 
No release since 2011 if I'm right.
&gt; If you already know we're going to end with two equally valid opinions, then isn't it fair to question your assertion that one was better than the other? Fair enough. We probably can't convince each other, but the third reader could have two different positions to choose from :) &gt; The indented .next_method(...) always tricks the reader into thinking that this statement is subordinate to the original non-indented line, and that the entire chain needs to be understood together. Yes, understanding the whole sequence together is what I love about the chains. ¯\\\_(ツ)_/¯ &gt; "Agree to disagree" is reasonable here, but in that case I don't buy the assertion that one is better. Well, "I love the second one much more, and find it more readable" would be more honest statement, probably.
I didn't watch that video but it seems you're suggesting nobody is using it which I'd agree. I already knew I wouldn't probably use it myself when that feature was being discussed in Ruby's Redmine. If I remember correctly Charles Nutter was also sceptical about it. So, it's not a surprise to me if no one is using it. When I first read your comment about it I was curious if you were suggesting that it's being largely adopted in the community. &gt; Symbol is just an atom. Let's make this definition a bit more complete: "Symbol is just an atom, very often used as hash keys, just like strings are, but they are different things". In other words: hash[:id] != hash['id']. This is enough to create a nightmare when developing Ruby applications and you don't know where your keys come from and you always have to check whether they are strings or symbols in order to use them. People are often just looking for an identifier they can use to store and fetch information, they don't really care whether if's a string or a symbol, they read the same to them. That's why HWIA is so popular in the first place. Because people simply don't care. So, we know that the existence of symbols create confusion. Now I just need to understand what benefits symbols are providing us in real applications. Hash['1'] is a different thing. It's probably an application bug because someone forgot to convert it to a number. You're usually either using numbers as keys or text identifiers as keys. I still didn't see an actual hash which would be mixing numbers and text as keys. Maybe some full-text search implementation might do something like that, but for that purpose '1' should be treated just like a regular text being searched. &gt; I think that your problem might be the HashWithIndifferentAccessthing, and I'm not a fan of it either. If symbols and strings will keep being different things I'd actually probably be a fan of HWIA as long as Ruby's core Hash would act like HWIA itself. I don't want to have to call a method to transform a regular hash so that it behaves like HWIA. I wanted all hashes would work this way by pointing to the same value when accessed by symbols or strings. &gt; Maybe someone can take the time to separate activesupport into micro-packages and integrate them back into it? I doubt this will ever happen. It's not usually how the Rails mindset works, but the opposite. They bundle all those gems in a single repository and they all share the same version number. They can't evolve in their own pace as separate pieces with separate communities, maintainers and independent releases. &gt; This seems like the use case for which refinements were made in the first place. You could extend integers in your library, and the user code would remain safe. But then you'd be missing the main point. If someone is willing to add support for 1.year.ago through some library it's very likely they'd prefer the monkey patch approach rather than using the refinements everywhere. I was just saying that the decision about touching core Ruby classes should be left to the final application developers not by gem authors. What you're suggesting makes sense in case Rails itself would like to use such extensions internally so they would be using refinements so that those extensions would only be available in Rails internal code. But Rails provides such extensions mostly for end user developers rather than for internal purposes. &gt; But that's the same as saying that no web framework requires class-based inheritance, when composition is clearly the better abstraction. It is not. This is about design decisions. Whatever design the framework adopts won't change core Ruby classes, so it won't leak to other domains. &gt; Maybe your problem is not FactoryGirl adopting activesupport, but that there's no proper alternative for the factory problem which is freedom-patch-free There actually is. Just an hour after I created an issue on FactoryGirl asking them to remove ActiveSupport I had already moved to Fabrication which is just as great and is monkey-patch free. I didn't really understand what you said about the current situation with middlewares. It's common for middlewares to modify the environment passed to the application from the web server and I don't see any problems with it. Warden (and Devise) will add some keys to env as many other middlewares will do. I just don't understand how this would be related to monkey patching core Ruby classes. I'm not against mutating objects. I'm not discussing OO vs functional programming. I'm just saying that changing core classes or objects in any language should be considered a bad practice by library authors. &gt; If limitations aren't enforced by the environment, a community around ideas will lead to endless discussion and division about core principles. This is why I say this is all about taste in the end. I'm not saying that everyone should share the same mindset as me. But I think there are basically 3 set of users: 1 - those that think it's fine to monkey patch core classes and are actively doing that; 2 - those who think it's a bad practice because such approach may lead to conflicts when two separate libraries are adding the same method to core classes but with different implementations, for example; 3 - those who just don't care about the subject and are only interested on using libraries to get work done with as little effort as possible. I'd say DHH belongs to 1, I belong to 2 and most devs would probably belong to 3. I'm just trying to find who else is in group 2 so that we could build a stronger community around it in such a way that the process of getting monkey-patch free applications would be somewhat easier if we can quickly find out which libraries would be considered good citizens accordingly to our mindset. I find it great that Ruby allow all those communities and mindset to exist. I'm all for a diverse ecosystem. There's a lot those 3 groups share in common. Basically groups 1 and 3 can both benefit from all gems created by group 2. So, there's no need to use another language just because your mindset is different. &gt; Always-on monkey-patching is ruby. And I find it great that Ruby provides us the possibility of monkey patch just like I find it great that C allows us to use goto and there are very specific cases where labels and goto can be exactly the elegant solution to some problems. I take advantage of monkey patches myself. Without monkey patches I wouldn't be able to create AutoReloader and provide a transparent auto-reloading feature without forcing people to use another method to require their dependencies. They can simply use require and require_relative, which means there's no overhead at all in production and test environments. Even more importantly, there's another very common case for monkey patching which is very frequent in our community. Suppose you find a bug in a gem you use that affects your application but may not affect most applications. So, the maintainer might not think it requires an urgent fix or might even discuss whether or not it's an actual bug. There are basically two options if you decide to keep with the library and can't think of another work-around. You could fork the library and point to your fork in the Gemfile but then you'd have to make additional effort as the time goes to make sure you keep up with recent changes in the main library's sources, rebasing your patch with the fix. The other possible approach is to simply monkey patch some buggy method and fix it until it's fixed mainstream. What I mean is that for my own mindset I prefer languages to be as flexible as possible even if they allow programmers to hit themselves in their feet. It's up to the developers to decide which tools to use. It's just like real life. We are allowed to kill people, we have this free choice to make. It's not enforced by the "system". It's up to us to decide whether or not it's a good idea to kill people.
A few corrections: **MRI** - Matz's Ruby Interpreter not Matz's Reference Implementation. YARV isn't a Ruby implementation, it's just the VM and doesn't really belong in this list. It became the VM for MRI in 1.9, not 2.0 **mruby** - An implementation of most of the ANSI Ruby spec, it's not a toy nor is it a place to experiment with the language. It's intended for embedding in other applications in a similar vein as lua is often used. e.g. write your game engine in C++ but the gameplay logic in ruby. **Rubinius** - Your description is pretty far off. Rubinius core feature is a fairly generic JIT VM, like the JVM. Uses LLVM for JIT compilation. It contains many Ruby implementations of stdlib functions, not to avoid C, but because the JIT allows doing so without sacrificing performance. The same is true of JRuby. **RubyMotion** - Implements a dialect of Ruby 1.9, runs on the objective-C runtime via macruby for iOS. Not sure what they use for running on android, probably use jruby AST code for static compilation to java bytecode. And ones to add: **TruffleRuby** - Ruby implementation using Truffle/GraalVM which are new approaches to running arbitrary languages on the JVM. Probably the most promising approach to a high performance Ruby implementation with MRI compatibility. **Opal** - Ruby to javascript transpiler for writing frontend code in Ruby and wraps browser javascript APIs. ## What This All Means **MRI** - The reference implementation, by far the most used. **JRuby, Rubinius, TruffleRuby** - Generally faster than MRI and support parallel thread execution but have some tradeoffs. **mruby** - For embedding ruby as a scripting language within other applications **RubyMotion** - For writing iOS/Android apps in Ruby **Opal** - Write Ruby instead of Javascript for your frontend 
Did you just tell the Sidekiq maintainer that Sidekiq dropped EventMachine?
Sidekiq never used EM, it used Celluloid. Sidekiq uses raw threading now, concurrent-ruby is only used here (https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/processor.rb#L206-L223)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mperham/sidekiq/.../**processor.rb#L206-L223** (master → e2f588d)](https://github.com/mperham/sidekiq/blob/e2f588d8bd66481e9fb2f7a7fd1378344c4709a9/lib/sidekiq/processor.rb#L206-L223) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhjojxh.)^.
When I'm making shitty Rails apps, this kind of problem is not something I would ever want to deal with. This looks like several days of work. 
I used jeweler before but now it's all about gem-release: https://github.com/svenfuchs/gem-release $ gem version bump $ gem release --tag And it's done
&gt; Rubinius core feature is a fairly generic JIT VM, like the JVM. Uses LLVM for JIT compilation. Unfortunately Rubinius doesn't use LLVM, or have any kind of JIT, any more.
Or just don't make apps with JRuby. Every time I've done JRuby it's been much more painful than MRI Ruby. There are technical tradeoffs. But if I'm making an app that doesn't need to scale I'm choosing MRI Ruby. 
i should really pay attention to usernames. thanks!
Rewrite your app on Java EE or rails. Jruby just hasn't gotten a mature enough community yet which is too bad. 
Been working on [this](https://www.youtube.com/watch?v=dQw4w9WgXcQ) for a while and could use some help.
That probably means you updated a whole bunch of gems. 
So, Ruby, as of version 2.4.1, uses bytecode internally?
&gt; I will disagree with you in this. It is mostly used as key to hashes, and so on, but that is because historically it has been a clearer (and more efficient) identifier. But it hasn't been confused with strings, except in the, very very often, HashWithIndifferentAccess case, and mostly because rails tutorials teach you to fetch query and form params by symbol. When someone's focus is to write efficient and fast code they shouldn't choose Ruby in the first place. If you ask Matz you'll see that performance concerns were not the reason why he introduced symbols to the language. And even when it performed significantly better I don't really think they would cause any noticeable changes to requests time for regular web applications for example. If you count all conversions that have to take place when you want to access a value from a hash and you're not sure if it's indexed by strings or symbols, then performance actually gets worse because of this mess. I'm not saying that it's confusing because the differences of symbols and strings are hard to understand. It's pretty easy. The confusion happens because you often get a hash from some API and you have to check whether its keys are symbols or strings... But specially, I don't think there are any real applications that would be storing some object in hash[:key] and another object in hash['key'] on purpose. Usually you're just interested in a text identification and 'key' or :key shouldn't matter in the end. And it gets worse. Suppose you want to cache some database query results. Then you use Sequel to fetch some records and it returns a hash indexed by symbols. You would then store such hash in Redis for caching purposes. The logic would be, get the hash from Redis and if there isn't one fetch them from the database using Sequel. There's a difference though. Redis won't store symbols but strings and you'd end up with different hashes. So you're forced to either use something like HWIA in these cases or convert the keys from one of those objects to make them compatible between each other. This is exactly the kind of confusion that shouldn't exist in the first place. Ruby's supposed to make developers happy. This is the opposite of making them happy. I still don't understand what symbols are adding to the table. We'd be just fine if we only had strings, like most languages out there. &gt; My example was how express.js middlewares work. Oh, that's why I didn't get it. I have no experiences with writing the backend of a web application in JavaScript so far. But I wouldn't say this is the same kind of monkey patching I'm referring to. I'm basically concerned about monkey patching core objects/classes, provided by the interpreter itself. &gt; What if you produce a very clean, good-citizen library, but have to "digbug" an issue from a user which in the end comes from a monkey patch in a 3rd party lib in his bundle? That's why I'm interested in such group in the first place. I want my full application to be build only by pieces written by other people in the same group so that my application would be monkey patch free, regarding core Ruby classes. &gt; By now, everybody agrees that one should extend what needs to be extended at boot time. You might be interested in Jeremy's ruby-refrigerator: https://github.com/jeremyevans/ruby-refrigerator &gt; Take a look at how the roda/sequel plugin modules work... In the end, it's monkey-patching. It's the same as in the Express.js example. I wouldn't call composition monkey patching. It's how Ruby's supposed to work by design in common cases. It's an easy and maintainable approach for extending a class behavior by composing it with multiple modules. I don't see anything wrong with Roda's plugin's approach. Even though Roda's plugin will modify a Roda application, they won't touch anything from Fabrication and the opposite is also true. When you monkey patch core classes, then you're changing the interpreter and its stdlib, which means possibly affecting all libraries.
&gt; or rails How does that make sense? Plenty of jRuby users.. are running Rails.
Good open source projects, huh? Check out [dry-rb](https://github.com/dry-rb) and [rom-rb](https://github.com/rom-rb/) as well as [Hanami](https://github.com/hanami). There are issues labelled `Help wanted`, might wanna try those out
I actually liked Alt.ruby and I have nothing against .NET by the way since I never actually used it :) I sent your suggestion to the group: https://groups.google.com/forum/#!topic/alt-ruby/vBqevZFSqdM
I'm not sure I got it. It's pretty simple to add the context to some decorator when required, without adding any extra dependencies.
Is it just me, or is that a lot to spend per hour on development hours? I work as a dev in Europe, and I'd say I make less than 20% of that per hour. 
$150/hour is not at all unreasonable in the US for skilled ruby/Rails devs, especially if they are freelancers paying their own employment taxes and health insurance out of that. 
Of course you can just compile MRI into your C application, it's just source code after all. &gt; Only limitation I found is that you can only use it from single thread. Last I knew the GC would break if you started MRI anywhere but the main thread. This limitation alone makes it useless for many applications. MRI is just C, so you can hack it in to anything that will communicate with C, but I wouldn't really consider it a supported use case. 
Agreed, as a contractor rate, this doesn't seem too high. However, if this were a full time salary, I think that it would be fairly high.
Yeah, if you take a full-time salary of 100K (which is not unreasonable for a skilled ruby/rails developer in the US, although some make less, some make a lot more), you'd get around $50/hour compensation -- but that doesn't include your health insurance (oh you lucky people in Europe) or other benefits, or the _rent_ on your office, your equipment, etc. Contractor rates don't work that way, because contractors have to pay all that overhead out of their 'hourly' rate -- plus the employer's share of income taxes, payroll services and other cost-centers, etc. (If you're paying your own health insurance in the US, it can _easily_ be $500/month and up if you have kids). Towards which end is more appropriate for the people ruby together is paying, I have no idea, it depends on their circumstance I guess. But $150/hour is not an unreasonable contractor rate in the US for skilled ruby/rails dev. $200/hour is not unheard of to pay a highly competent rails contracting firm (obviously the employees see only a fraction of that as their actual pay). 
Not really. The scope of `dry-view` is smaller. We want to have data-driven templates, and we're trying to implement bare minimum to achieve that.
Cool!, but I think some of them might be too obscure even for seasoned ruby devs.
&gt; Just for serialization purposes, This is quite the issue in a lot of languages. It's difficult because most libs try to keep a clean API, but most serialization brokers only deal with so-called primitive types and nowadays json, and it gets limiting. I'd guess that sidekiq users (albeit rarely) experience this as well, and even the rails globalid has a few edge-cases regarding this. But I agree, maybe libs should go the way of forcing us users to explicitly pass a serializable payload to them. &gt; Don't you remember Prototype.js? Dude, you went to Ancient Egypt :D &gt; Maybe we could have some underscore library for Ruby too ... This would be an interesting project to replace parts of activesupport. &gt; at least we both seem to agree that the plugin system works pretty well :) Totally :) Even the railtie system of rails is solid nowadays, no more alias_method_chain'ing FTW. 
Like these: &gt; What is the difference between a lambda, a block and a proc &gt; Explain what singleton methods are, what is Eigenclass in Ruby Like, get out of here. Who ever goes: "Oh, I wonder should I use a lambda, a block or a proc here? And what about that Eigenclass"
I think these are cool questions if you want to quiz yourself on your knowledge of Ruby, or maybe find gaps in your knowledge. I don't think they are particularly useful as job interview questions. I interview people all the time and I'm usually more interested in someone's ability to think through a problem than wether or not they know 3 different ways of defining a method.
I'm not arguing that everybody knows and does metaprogramming with Ruby, but if you do even a small amount of it, you run into the eigenclass. It's not an obscure feature. I definitely agree that it doesn't ensure seniority tho, questions like these only test how well you know (and memorized parts of) the languge. For instance I work with Ruby for 5+ years and on interviews I constantly failed the "what's the difference between including and extending a module" simply because I've never used mixins. Never got rejected because I still could proove I was a competent dev. 
They're bad for interviews, but might be good for interview prep. Interviewers don't always ask good questions.
I would think it'd be their loss if they were so upset that they would go and write their own clone. It's not like the example is forcing you to embed hookers into your own code
I still don't understand. Sequel implements Active Record but unless you use an specific plugin it doesn't implement ActiveModel. I don't really understand why implementing Active Record or ActiveModel interface would make things easier with Rails. Would you mind providing an example? I didn't use several features from Rails such as mass assignments, strong parameters, REST and many more. I didn't use Devise either or ActiveAdmin or RailsAdmin. So maybe you're talking about the ecosystem (Rails engines/gems)? I can't really see how using Rails controllers and views would depend on the ORM, maybe because I never attached such things. They all seemed completely independent from each other in the application I maintain.
I highly recommend you https://pragmaticstudio.com/
I've been programming ruby nearly daily for the past 6 years and I've never seen the word "Eigenclass" in my entire life.
&gt; I know you mention it as a good thing, but I'm not sure this is indeed a good thing in several cases. Sometimes it's helpful to test decorators in isolation, so the ability of passing a double as the context may make it easier to test it in isolation. I agree :) So while the creation of the view parts is automatic and handled by `Dry::View::Controller` during typical view rendering, these parts can also be instantiated directly for purposes like testing: context = double("context") renderer = double("renderer") user_value = OpenStruct.new(foo: "bar") part = Dry::View::Part.new(:user, user_value, context: context, renderer: renderer) This sort of thing I could see us offering a few test helpers for too, just to streamline that process. &gt; In most cases we wouldn't pass the global (parent view) context to all inner views because it's usually much easier to read and understand them when we only pass the subset of the context the inner views would be interested at. I understand this is usually simpler to achieve with JavaScript than with Ruby This is actually something where dry-view may help, because it builds a view template’s scope out of a couple of different layers: - User-provided data - The context object So if you have a view controller with exposures like this (more typical for a server-rendered app than an SPA): expose :featured_products expose :articles Both `featured_products` and `articles` would be accessible from the template’s scope, as well as all the methods on the context object (context objects are things where you typically want to keep the small number of “view global” things, like HTTP request information, access to static assets URLs, etc.). Then from within your main template you can render a partial and narrow the scope, just like you hinted at: == render :featured_articles, articles: articles Or because `articles` is a view part, you get encapsulated rendering of a partial with that narrowed scope: == articles.render :featured_articles These both give you the same effect: the `_featured_articles` partial template is rendered with _only_ `articles` as the user-provided data in the scope. The same context object is passed through, though, so you have a consistent baseline for template rendering. I’d say it’s in the interplay of these things through which dry-view brings its benefits: template scope can be managed explicitly, the context object provides a consistent baseline, _and_ view parts now combine the context object, partial rendering with your application’s values so you have an appropriate place to hang your more complex view logic, even when it is doing “template-style” things. I said I’d give more examples in follow-up blog posts, but here’s one place where it really helps us: we use a custom decorator that detects rom-rb results objects and automatically wraps them in `PaginatedResults` and `Pager` view parts, the latter of which retains pagination-related metadata, and allows a method like this: class PaginatedResults &lt; Dry::View::Part # ... def pagination(locals: {}, **options) pager.with(**options).render(:pagination, **locals) end end So from within any template where we’re working with an array of database results, we can just do this: - articles.each do |article| / show article == articles.pagination Tidily encapsulated partial rendering. We can use this entirely throughout our app without having to have details of the implementation spread everywhere. And because of the way dry-view partial lookups work (see “Template lookup” on http://dry-rb.org/gems/dry-view/templates/), if we ever wanted to customise the appearance of the pagination, we could just drop a special `_pagination.html.slim` in the right place to be looked up for whatever template we required. So we get a ton of powerful view behaviour, but with all of it provided via independent objects, coupled minimally, which we can still access and test independently. Hopefully that gives you a better idea of the dry-view story :)
These are only good if you practice or at least remind yourself of the answers regularly. Not a bad thing, though I prefer learning by practicing concepts with problems.
i'm sorry, I have no idea what you're talking about. 
&gt; I bet crystal would be faster though. As would plenty of other languages. I don't know about you but I'm interested in hearing about Ruby in /r/ruby. 
I've resorted to using and incorporating semver, and with that tool: semver inc patch And when you do rake release the tagging is automatic. 
Let me know how that goes, as I have not tested this with Rails at all. Though I intended this to be non-Rails, I want it to work in that context as well.
Have you been metaprogramming tho? That was my point. 
JSON parsing speed (or lack thereof regardless of the implementation) is the reason we have started to abandon ruby. Nevermind business logic. We spent around 70% of active CPU time parsing JSON. Sure, we can do things to work around it, but should we have to? That's untenable for a single-threaded blocking language.
crystal is a compiled language how does this matter here?
Is it like that even with [Oj](https://github.com/ohler55/oj)?
When you're talking about Route helpers I guess you're talking about restful routes, right? Maybe that's the reason why I didn't notice anything related to ActiveModel. All our routes were custom ones without any sort of resource routes. For non restful routes it doesn't really matter what ORM solution one is using since it has nothing to do with ORM in the first place. We also didn't use simple_form, devise, paperclip and carrierwave, but in that case I think that you might be out of luck with whatever ORM solution which is not ActiveRecord itself. Devise doesn't support Sequel either for example. We didn't use generators either. Maybe that's the reason I didn't notice any changes in the productivity although I'm not sure it's as much affected as you think. I tried to use Devise for a while and it would have been much simpler if I just had built our custom authentication solution from the beggining. It was a nightmare when I needed to understand Devise's code in order to implement our custom strategies anyway. I guess the same is true for whatever gems you add to the application. It might seem like you're saving work but it's not always true. You end up having to deal with upgrade breaks for such libraries or incompatibilities with new Rails releases and so on. I didn't find it took a long time to write our forms without something like simple_form. Actually, even the built-in form helpers wouldn't save me that much time but I confess we don't have many forms generated in the back-end so an application which uses tons of complex forms may have its productivity affected by such things. Nothing prevents one to use something like dry-view with Rails for example, so if one is not happy with Rails' way of dealing with views they could just easily replace it with something like dry-view or cells. Or they could even create their own helpers. I mean, if you keep with the minimal web frameworks usually provide, which is extracting params from requests, processing them in a non-web-framework related code and then rendering the results to some view or serializing it to JSON for example, then you can still be productive with Rails, just like you'd be with whatever other web framework. I've been working like this for a long time and never felt our productivity to be affected. If your application has to deal with lots of CRUD or RESTful resources that behave mostly about the same, with lots of similar forms, then I guess you might see some boost in the productivity as long as you stick to Rails conventions... It has never been the case for the application we maintain though. I just think that it's generally wrong to say that you can't be productive with Rails if you are not using an ORM implementing the Active Record pattern or the ActiveModel interface... You certainly won't be able to stick with the Rails Way, but it doesn't necessarily means you can't be productive with Rails in lots of applications domains.
Yes, I did take all the Ruby and Ruby on Rails. I can't recommend it enough 
I don't understand your code. what's the relation between the code before and after the "at the moment I use" line? Are you just looking for if something # one thing elsif curses_have_key?(ch) # something else # something else end
hm, that does look better, thanks
&gt; single-threaded blocking language Single-threaded *runtime*. Nothing in the *language* requires single-threaded execution.
Thanks, that example clarifies it. I can't think of any great way to do it. This would work, but seems a bit too tricky/clever to me. case ch when Curses::Key::LEFT # when # etc # when lambda { |ch| curses_key_have_key?(ch) } # else # end That works because the `case` statement actually calls `orig_arg === when_arg` on each `when`, and lambda's alias `===` to `call`. `===` is a weird operator in ruby, it's just convention so classes _can_ define it however they want. But with my understanding of how ruby intends it to be used, I think of `===` as meaning "member of the set defined by". `arg === SomeClass` means "instance of SomeClass" (ie in the set of objects that are instances of that class). `arg === regexp` means "Matches regexp" (ie, in the set of strings matched by regexp). There's probably a way to design your own classes to use here that respond to `===` in custom ways to make it _look_ better, but be even trickier/cleverer. I don't know if I'd do any of this in real code -- I'd probably just use the if/elsif. 
That looks nice! Wouldn't probably put it in production code, but in this toy project why not. Thanks :) EDIT: and thank you for the explanation of `===`
You can do it like this as well. Just create a list of all keys with `.map` and use it in a when with the splat operator `*` def all_curses_keys Curses::Key.constants.map { |c| Curses::Key.const_get(c) } end case ch when Curses::Key::LEFT # when Curses::Key::RIGHT # when # etc # when *all_curses_keys # else # end 
I like this.
Ruby's built in parsing is indeed p shitty. As /u/janko-m points out, Oj works very well though. Basically it's a mistake to use the built in json library. That said, once you start processing those objects, you're back in ruby land.
Right, but every active user has to have their own thread to guarantee responsiveness (huge arrays of deeply nested JSON objects). This becomes very expensive to scale. I'm not saying poor decisions weren't made in the design (polling the entire array and merging on the client), and we're still using ruby on a couple layers.
... and in fact JRuby proves that.
While I wasn't the one to do the perf testing (VP of engineering), he saw apparently only small improvements with Oj. It comes down to the fact that we have a lot of technical debt and it was cheaper to rewrite the backend in Golang (again, not my decision, though I do enjoy go) than fix the inherent design issues (polling entire resource collections, insanely complex business logic handled in memory rather than handing the request off to the DB, etc.)
Also inline is very inefficient as it does the same work over and over again. I'd rather do ALL_CURSES_KEYS = lambda {|c| Curses::Key.constants.find_index(c)} ... case ch ... when ALL_CURSES_KEYS log "unexpected key" This still does some redundant work in *Curses::Key.constants* so if you are sure that the list of constants does not change you could do ALL_CURSES_KEYS = Curses::Key.constants def ALL_CURSES_KEYS.===(x) find_index(x) end And then *case* as above. :-)
There is no"MySQL database file", you have to dump your db on vm1, transfer file on vm2 then restore on vm2
It is not. MySQL runs as a separate process, and keeps it's files in it's own places (more than one file). You can not just copy MySQL on-disk files, you need to use mysql tools to do an export/import. 
https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html Have fun.
it's not particulary well coded, but your issue is that you use constant `A` instead of string `"A"`. Try the if like this: ` == "A"`.
http://learnxinyminutes.com/docs/ruby/ will help you a lot.
This is the result in 40 seconds or so.. http://imgur.com/a/6ocDY
You're missing my point. If you wrote Ruby that often called out to C code you'd know how that's done. If you work on code that uses threads you know how that's done etc. Just because not every Rails project uses threads it doesn't mean it's some obscure feature of the language. 
&gt; for i in 0..40 threads[i] = Thread.new { scanhost() } end can be 41.times do |i| threads[i] = Thread.new { scanhost } end or even 41.times { |i| threads[i] = Thread.new { scanhost } } likewise &gt; for x in 0..40 threads[x].join end 41.times do |x| threads[x].join end or 41.times { |x| threads[x].join }
A few things that specifically stand out in terms of style: - Use 2 spaces for indentation, not tabs. - Omit pretty much all of your `return` - You're never assigning `$REMOTE_PORT`. You should make it a constant rather than a global variable. - Lines 13-16 could be condensed into one. `socket.connect_nonblock(remote_addr) rescue Errno::EINPROGRESS` - I think you probably meant to actually rescue a specific error kind here or something? Your rescue branch isn't actually doing anything and could just be empty. - `if sockets; true; else; false` can just be `sockets` - `.to_s` instead of `.to_s()` - `while TRUE do` could be `loop do` - `for x in 0..40` is normally written as `(0..40).each do |x|` (this isn't just preference, `for..in` has gotchas) - You should look into the enumerable module (or streams from Java). Your code at the end would usually be written as: `(0..40).map { Thread.new { scanhost } }.each(&amp;:join)` Note: these are all just style nits, not really anything about the code itself. Here's how I'd write the same code (functionally equivalent, only style differences) https://gist.github.com/sgrif/e745897335f06cce2aaae1aea73e35ca
Downvotin' the new guy. Stay classy /r/ruby/ 
&gt; It comes down to the fact that we have a lot of technical debt and it was cheaper to rewrite the backend...than fix the inherent design issues I hate to be a dick, but I have literally never seen this "solution" work out in practice. These are process and people problems, not tool problems. Chances are good that the rewrite will get bogged down in reimplementing the thicket of edge cases and special behavior you're also dealing with. Good luck with it, I hope you can be an exception to what I've experienced. 
I think that can be further simplified to: 40.times .map { Thread.new { scanhost } } .each(&amp;:join) Though, unless I'm missing something, it looks like the threads will never terminate as `scanhost` is an infinite loop.
I don't know the library but you're not calling: &gt; Curses::Key.const_get Is your code equivalent to the original?
Good advice! &gt; `if sockets; true; else; false` can just be `sockets` Not quite, `!!sockets` would be correct. 
Oh, it did get bogged down. It took most of the engineering team 6 months. As we continued to add new features. We've ended up with over 2 orders of magnitude improvement. And that's per process, which makes this much more vertically scalable.
I found the full list fascinating: https://www.techempower.com/benchmarks/#section=data-r14&amp;hw=ph&amp;test=fortune Main take aways: - Wheres Windows?! ;) - PG over MySql for performance - I should have never quit writing C++ WebCGI apps! - There are always different trade offs; pick your poison and take a chance!
Right, but since you seemed to care about style only I wanted to point out the change in behavior.
&gt; 40.times { |_| threads &lt;&lt; Thread.new{ scanhost } } You don't need that placeholder param at all. 40.times { threads &lt;&lt; Thread.new{ scanhost } }
Cool cool. Like another poster said, there are some aspects of your program that can be improved and explained, including why you got the error, so feel free to ask about that as well.
Ok. Thank you. Yeah I'm trying to improve it. I deleted a lot of my committed out code so it looks a bit cleaner. Still wondering what I did wrong to get this error undefined method `*' for nil:NilClass (repl):48:in `&lt;main&gt;'
Ok. Thank you. Another user is helping me and he showed me how to use cases. I'm trying now to use an accumulator ,but it seems that I'm not doing it right or Ruby doesn't support it 
don't listen to the other guy, you could totally do this. as an example, you could write a Rust-based JSON parser and hook it up with [helix](https://github.com/tildeio/helix).
Rust can be compiled into a library that can be loaded by the ruby runtime. Elixir cannot.
Performance comments: The way you're using `Socket#connect_nonblock` and `IO.select` is basically just mimicking a blocking call to `Socket#connect` so it's not helping and why you're needing to spawn a bunch of threads to get decent performance. What you want to do is call `Socket#connect_nonblock` on a ton of addresses and call `IO.select` to collect results as it goes. Assuming you're using MRI the network IO happens off GIL anyway so no real need for application threads here at all, better off running `n` separate processes where `n` is the # of CPU cores you have, although I would guess you'll hit file descriptor limits before the CPU load is a problem.
I would take a look at running Rubocop regularly on your code. I use atom and run Rubocop live via the linter extension and also have a git hook to run Rubocop on any Ruby code I try to commit. Here's what Rubocop says about this code using my usual settings interspersed with a few comments. I've removed the warnings about indentation and tabs, because as others have mentioned, Rubyists generally use two spaces. Inspecting 1 file W Offenses: file.rb:2:1: C: Missing space after #. #author: PLAGUEz ^^^^^^^^^^^^^^^^ file.rb:3:1: C: Missing space after #. #date: 12th May 2017 ^^^^^^^^^^^^^^^^^^^^ file.rb:7:1: C: Do not introduce global variables. $REMOTE_PORT = 80 ^^^^^^^^^^^^ This is a fairly good one, as globals are generally discouraged for all of the usual reasons. Now and again they can be useful (often you'll see things like the `$redis` global in Rails projects, for instance), but generally you don't really want to introduce globals. One fairly unintuitive reason -- Ruby silently returns `nil` on uninitialized global names, and this can lead to errors arising from typos, for instance. A simple typo like `$REMOET` would have silently returned a `nil` in your case, for instance, while using a constant would have likely raised a `NameError` exception. file.rb:12:35: C: Space inside parentheses detected. remote_addr = Socket.sockaddr_in( $REMOTE_PORT , host) ^ file.rb:12:36: C: Do not introduce global variables. remote_addr = Socket.sockaddr_in( $REMOTE_PORT , host) ^^^^^^^^^^^^ file.rb:12:48: C: Space found before comma. remote_addr = Socket.sockaddr_in( $REMOTE_PORT , host) ^ file.rb:13:1: C: Tab detected. begin socket.connect_nonblock(remote_addr) file.rb:18:14: C: Do not use trailing _s in parallel assignment. Prefer _, sockets, = IO.select(nil, [socket], nil, 2). _, sockets, _ = IO.select(nil, [socket], nil, 2) ^^ That's a new one for me, and I'm not sure that I like it. :/ file.rb:19:2: C: Use a guard clause instead of wrapping the code inside a conditional expression. if sockets ^^ It's considered more idiomatic to do return true if sockets Rather than have an `if/else`, as there's no reason to have the `else` in this case if you can just bail early and save yourself the indentation. file.rb:29:2: C: Redundant return detected. return octet.to_s() ^^^^^^ Since Ruby always returns the return value of the last statement in a block, method, etc., the `return` keyword is unnecessary here. file.rb:29:19: C: Do not use parentheses for method calls with no arguments. return octet.to_s() ^ file.rb:32:1: C: Extra blank line detected. file.rb:34:39: C: Do not introduce global variables. puts "[FOUND]: '" + target + "': " + $REMOTE_PORT.to_s() ^^^^^^^^^^^^ file.rb:34:56: C: Do not use parentheses for method calls with no arguments. puts "[FOUND]: '" + target + "': " + $REMOTE_PORT.to_s() I'd recommend either using string interpolation here. For instance: puts "[FOUND]: '#{target}': #{$REMOTE_PORT}" This to me is more readable. You can also remove the call to `#to_s` in this case, as `#to_s` is implicit when using string interpolation. file.rb:38:1: C: Extra blank line detected. file.rb:39:1: C: Use empty lines between method definitions. def scanhost() ^^^ file.rb:39:13: C: Omit the parentheses in defs when the method doesn't accept any arguments. def scanhost() ^ file.rb:40:13: C: Do not use do with multi-line while. while TRUE do ^^ You don't often see the `do` keyword used in cases like this. file.rb:41:32: C: Prefer single-quoted strings when you don't need string interpolation or special symbols. target = getoctet(1 , 191) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) ^^^ Single quoted strings are more performant in Ruby as they do not require using string interpolation and whatnot. In this case, though, I might just use the `Array#join` method, i.e. target = [getoctet(1 , 191), getoctet(1 , 254), getoctet(1 , 254), getoctet(1 , 254)].join('.') file.rb:41:48: C: Space found before comma. target = getoctet(1 , 191) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) ^ file.rb:41:58: C: Prefer single-quoted strings when you don't need string interpolation or special symbols. target = getoctet(1 , 191) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) ^^^ file.rb:41:74: C: Space found before comma. target = getoctet(1 , 191) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) ^ file.rb:41:84: C: Prefer single-quoted strings when you don't need string interpolation or special symbols. target = getoctet(1 , 191) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) ^^^ file.rb:41:100: C: Space found before comma. target = getoctet(1 , 191) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) + "." + getoctet(1 , 254) ^ file.rb:42:24: C: Do not use then for multi-line if. if scanport(target) then ^^^^ You don't see the `then` keyword used too often. file.rb:44:4: C: Redundant else-clause. else ^^^^ file.rb:52:1: C: Prefer each over for. for i in 0..40 ^^^ `for` should generally be avoided as others have mentioned because it has awkward semantics in Ruby -- it will actually overwrite any local variables of the same name when the loop is finished, which can lead to some unexpected logic errors. For instance: i = 'foo' for i in 0..40 # ... end puts i #=&gt; 40 Not good. 1 file inspected, 74 offenses detected So, I'd recommend getting into an automated workflow on this -- have Rubocop teach you what others generally consider to be best practices in Ruby and as you learn Ruby you can start to hone in on your own Rubocop configuration for your own general workflow. My general Rubocop config is generally close to the one shipped with Rubocop itself with a few rules tweaked for my own style, but generally speaking I try to keep things clean unless I disagree with the rationale for a particular guideline, which isn't too often but it does happen. I take the same approach with all of the languages I use -- I'm a big fan of static analysis as an early warning system to clean up my code so that others don't have to when it comes to pull requests, merges, and general team coding guidelines.
Ah, I see why, thanks.
Bump! Very interested in this answer. Haven't found much in the way of bluetooth support in ruby other than by automating commandline tools. 
It sounds like what you're trying to do is assign a value to a variable? Just like you use variables in math/algebra you can do the same in most all programming languages including ruby. If I understand correctly what you're going for is something like: def my_friends(first, second) total = first + second return total end my_friends(1, 2) You can try using this online code editor too for ruby: [repl.it](https://repl.it/languages/ruby) 
good catch, yeah. 
Not strictly an answer to your question, but here is a *much* shorter implementation to solve the same problem :) def every_other_letter(string) string.gsub(/(.)./, '\1') end
A slightly clearer implementation: def skip_letters(word, chars_to_skip) iterator = 0.step(word.size, chars_to_skip) chosen_chars = iterator.map { |i| string [i] } chosen_chars.join.strip end The two subtractions in the previous implementation are superfluous as far as I can tell. I can't see a reason to bother with them. 0.step creates an iterator starting at 0 and incrementing by chars_to_skip. \#.map runs a given function on each element of an iterable
It's a game changer.
i think that could very well be one-liner string.chars.select.with_index { |_, i| i.even? }.join is imho clear enough
PM me with some contact info and when to contact you tomorrow. I'm EST so I have to sleep but I should be up/available around 9:30
Thank you for your response. 
I don't think it's right for App Academy to set people's expectations so high with their JumpStart program. It looks like the only people they admit to their 12-week program are those with a solid foundation in programming. Claiming that JumpStart will take you there from zero coding experience is pretty much B.S. I would take good notes, learn as much as you can without stressing about it too much (12 hrs of cramming a day is too much), and see how you do on the test. If you haven't become a master coder in 2 weeks then do what everyone else who doesn't become a master coder in 2 weeks does: read a book and practice some more. I wouldn't let this crash course experience ruin coding for you and I wouldn't quit if you're enjoying it. With your background I have no doubt you could be an excellent programmer, you just have to give yourself some time to wrap your head around it. Good luck; Don't give up
I think everyone else has hit the nail on the head but I just want to reiterate. From your post, it sounds like you only have been programming for a week (correct me if I'm wrong) and that's nowhere near enough time to even get the basics down 100% if you're completely new. Programming has a lot to it with new technologies coming out all the time, so you can expect to not know a lot of things for a very long time. I went to school with programmers who didn't have the basics down after 4 years of programming in school but are doing well today. I have also worked along coworkers who were considered senior but didn't have some basics down. It really depends on a lot of factors. From personal experience, when I got my first real job after graduating from school, I came home with a headache every day for **months.** And I love programming and had a full education in it. You're coming from a non-computer background and cramming as much info into your head in the shortest amount of time possible, so I would consider you some sort of genius if you *were* comfortable within a week. **tl;dr programming is hard and there's lots to learn. If you enjoy it, keep at it (at your own pace) and it'll all click. Don't care about others who seem to be doing better than you. It doesn't mean anything.**
Thank you so much.
Thank you.
I'm going to buck the trend here a bit and say that *programming isn't for everyone*. I had a roommate in college who took intro to CS 4 times. He failed it 3 times, then literally jumped out a window one day (second story only, so he just busted an ankle) and then dropped out of school. I should mention, this was Stanford, so just by being there, he was not a dumb guy. And I tutored him the last 2 attempts. Yikes. What stopped him was abstraction. He could follow things along OK, but he couldn't wrap his mind around the difference between a variable, and what that variable contained. He couldn't figure out functions ("methods" in Ruby). He just was too literally minded to deal with the recursive, abstract, nested-turtles worldview required to program. If you're frustrated because your progress is slow, listen to the other folks here, and keep with it if you really love it. But if you're struggling to understand the core abstractions of programming - variables vs values, how functions work, classes vs instances of those classes - then it may just be that your mind works in a way that doesn't fit with programming. Which is totally ok! More reading: [Goats vs Sheep](https://blog.codinghorror.com/separating-programming-sheep-from-non-programming-goats/)
This is a good point too. Programming, just like everything else, isn't right for everyone. Even if you can be good at it, you might hate your job for large portions of it. I love programming but sometimes I hate large parts of my job because I have to do something a specific way, meet tight deadlines, or get woken up at 3am to fix a large issue. That being said, I think /u/Meithras has the right idea. If you *know* it's not right for you, probably better to get out sooner than later. But at least give it a fair try before you give up (which /u/zaphnod mentioned, is perfectly OK). :)
As a UX Designer I'm interested to hear what other devs think about this. Will definitely be sharing with our dev team for thoughts. I know feature changes are a huge burden to our devs but is also a huge expectation not of just bad clients but actual iterative changes informed by user testing, analytics and new-biz needs.
I haven't used ActiveRecord in a while, but if I were to, I would definitely look at this library. Could the approach be ported to Sequel?
I'm not sure if your question is implying that you think because this article was just written that I was unaware of preferring composition over inheritance. Or why it would matter if I did just discover it. I've written about that before, after talking with Lynn Stein about it https://www.saturnflyer.com/blog/delegation-is-everything-and-inheritance-does-not-exist
Maybe, not really sure. What made it relatively smooth was the ActiveModel::Type stuff that sgrif added in Rails5. I would not be surprised if Sequel was already always based on a similar design. I do love sequel, but am not as familiar with it's internals, and much of my day-to-day work requires ActiveRecord, including the bundle of use cases that inspired this experiment. Thanks for the comment though! I was expecting this to be more interesting to people! 
&gt; I do love sequel, but am not as familiar with it's internals, and much of my day-to-day work requires ActiveRecord, including the bundle of use cases that inspired this experiment. Makes total sense. I have used Sequel to update a relational database from event streams, and have often wanted a means of leveraging jsonb columns more easily. In those contexts, I would prefer to use ActiveRecord, but I don't care for bringing in ActiveSupport along with it. ActiveRecord has superior support for grouping tables together as a single aggregate through associations. &gt; Thanks for the comment though! I was expecting this to be more interesting to people! I know that feel! I've submitted libraries I was super excited about having written and... received crickets.
The behavior necessary is maintained closest to it's use. When you add a feature, keep the behavior with it. You could take those modules and include them in whatever classes play those roles and the API for objects of that class would grow and grow as you add features. Those added methods are available at any time and it makes it much easier to introduce dependencies on them in other areas of your system.
Ah. Because you can't unextend without patching Ruby. You can `uncast` an object. Sorry, I didn't realize the difference in your sample code above.
The examples seem rather contrived - I know its often difficult to come up with succinct ones but these abstrations possibly don't help make the point. For example, the object comparison argument just leaves me wanting to scream 'But the User is not the Account!'. After reading the piece I'm left simply thinking that it doesn't really matter how the code is organized or what technical mechanisms you use (sorry, there are no magic bullets) if the underlying ~~design~~model is flawed.
Open up command prompt and run your script from there, cd to your dir, then type ruby myfile.rb it should stay open 
Thanks for bringing up this comparison, /u/jrochkind, it's a fair question to ask! I've made a note about adding some comparisons to other view systems in the docs: https://github.com/dry-rb/dry-view/issues/38
Thanks guys for the insight great points! there's hope for us all haha 
One of the things I love about Ruby is it's REPL interface. Spend some time just messing around with some examples or "manual programming". Take your assignment and try to analyze what steps you need to take, then play around with the command line and just do things. "what happens if I add 13 to this char", "if I was on X how would I wrap around?". Think of it as a scratch pad, but for programming and with history. Really try to break it down into steps, like if you were explaining it to a young child how would you break it up step by step. 
Read the question again.
&gt; exclude every too big number Who said none of the integers can be negative? &gt; get every possible combination This *works*, but this is really an optimisation question. It is possible to do this in O(n), but your answer is O(n^2 ). If the array contained, say, 1000000 items then this approach would be ridiculously slow.
I'm not sure if this is a spoiler considering you asked the solution for the question, but this is best done using a hash in O(n) time. As you're iterating through the array, keep the keys of the hash to the sum (s) - current number (n) and value to the current number. Now if the current number exists in the hash, you'll know the corresponding number in the hash the value, to make the two sum. Sorry if this is unclear, I'm on mobile. Here's some quick pseudocode: Hash={} Arr.each do |num| If hash[num] return num, hash[num] Else hash[sum - num] = num
 def two_sum(array, target) needed_number = {} array.each do |n| difference = target-n if needed_number[difference] return true end needed_number[n] = difference end return false end 
With plain ruby-kafka, you can simply do: require "kafka" kafka = Kafka.new(seed_brokers: ["my-kafka"]) consumer = kafka.consumer(group_id: "my-consumer") consumer.subscribe("some-topic") trap("QUIT") { consumer.stop } consumer.each_message {|message| puts message.value } It's pretty basic.
He could have used [`Enumerable#detect`](https://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-detect) to make it a bit cleaner and to remove the explicit returns. def curses_key_have_key? ch Curses::Key.constants.detect(false) do |c| Curses::Key.const_get(c) == ch end end
I remember being in the same position. The thing that completely changed the world of software development for me was "Test Driven Development" I learned to break problems down into pieces using this approach. By writing tests first, it forced me to break the problem down into testable units. I rarely write code without tests, although I don't strictly follow TDD anymore.
IMO, you need to study some OO design. As you are seeing, it is a different ballgame than just knowing the programming language.
Yeah sure, but then you're just trading time complexity for space complexity. Depends on your needs, but in most scenarios, memory is cheap so this would be a reasonable solution. 
If you're going to access Curses::Key.constants anyways, why do you want to iterate over them instead of calling #include? ? Edit: what i'm missing really, is what is the need to go through .const_get when you already have it in c ? Can you enlighten me ? Edit 2: yeah, they're not the same thing, dumbass me just figured.
You could try [memory-profiler](https://github.com/SamSaffron/memory_profiler), which uses newer Ruby 2.1+ APIs. Blog post, [here](https://samsaffron.com/archive/2015/03/31/debugging-memory-leaks-in-ruby).
Why not use something like https://github.com/Casecommons/pg_search instead of bringing in yet another service to manage? `"%#{query.strip}%"` is slow as balls. But setting up tsearch would take no time and would be a simple change. I guess it won't have some features like suggesting, but who needs that.
Ohh I missed that. Makes sense. I've used both MongoDB text search and Elasticsearch. If you've got the expertise to do Elasticsearch right, it's a really nice, powerful search engine. Way better than an SQL LIKE, where you've got the matches, but you have no idea how strongly each one matches and no idea how to sort them. The search results make a lot of sense. NPM uses it right now.
Since I don't have any issues with stateful programming and love OO and Ruby, I guess that would be the reason why I'd prefer another API ;) &gt; so a rename of an exposure will require you to make that same renaming everywhere you refer to it You didn't get the kind of problem I had antecipated, so let me give you an example, but it's not about renaming an exposure, but adding a new exposure: class MyViewController &lt; BaseViewController expose :some do |input| do_something end # Then, in another moment you introduce a new exposure: expose :input do |data| end # With that change the previous exposure will now behave differently even though it was not touched end In an unrelated note, I find it interesting how what seems the same concept to me is called different in different libraries. I believe a view controller in dry-view is about the same as the view-model in the Knockout.js MVVM approach :)
Going to hijack this to ask - how does one estimate how much RAM and cpu elastic search will need for data? I've been reading documents which seem to assume that it's a common use-case to need 16gb ram for just ES. I have a database of about 200k records across a few tables. I'd like to get autocomplete for it. 
Best practice for ES is to give it half your RAM up to 32GB. Elastic doesn't recommend that you give any single instance more than 32GB. They always recommend at least 3 nodes. That said 200k is small for elastic. You can definitely get away with an instance with 16GB of RAM and be plenty fast.
Hello, For another real-world live example, see the Vienna.rb site / blog - To add JSON Feed: Step 1: Copy the feed.json template file. That's it ;-) Source: [vienna-rb/new-blog/feed.json](https://github.com/vienna-rb/new-blog/blob/master/feed.json) Live: [feed.json](http://www.vienna-rb.at/new-blog/feed.json). Happy publishing with Jekyll n friends. Cheers.
that is sexy. I love ruby.
I prefer Thinking Sphinx. Pat is the man
Actually you can implement suggestions using trigrams and thesauruses. I think there's even Levenshtein distance module that plays in concert with tsearch. Updating indexes is where the performance devil lied last time I had to work with tsearch.
Hm, I wonder why ruby doesn't do this by default (like python does with it's `.pyc` files).
Is it just me or does this seem like a terribly convoluted way to achieve some fairly basic things. What about using `Module#prepend` so that super still works rather than dynamically building modules? What about performance? Each extra module adds a layer of indirection in the method lookup, surely that can't be good?
I don't really see what `Module#prepend` has to do with it. The point is to have configurable modules which can be overridden. Prepending a module doesn't (in itself) make it configurable. Also, I would strongly argue that subclassing Module is *not* convoluted at all, not nearly as convoluted as the alternative described in the post. Regarding performance, it really depends on the case. The example of AttributeMethods in the post does not add *any* additional indirection, since regardless you to iterate through a set of matchers, so the only difference here is that you replace the iterators (which are instances of classes) with instantiated modules. The number of objects is the same, and the number of conditionals is the same.
I like this pattern save for your interceptor design, but only on preference. Ruby's regex engine is pretty slow, so the more complex and nested your logic is the more expensive resolution becomes. That being said, you can easily make another module that could be responsible for performing this validation/mapping step without invoking the regex engine (e.g. check array membership) -- which I guess is the whole point of the pattern. Nice post :)
Hello, To read feeds in the new [JSON Feed](https://jsonfeed.org) format in - surprise, surprise - JSON nothing changes ;-) Use it like: require 'open-uri' require 'feedparser' txt = open( https://jsonfeed.org/feed.json ).read feed = FeedParser::Parser.parse( txt ) pp feed Enjoy. Cheers.
This is legit. I ran some tests and it saved nearly a whole second on bundle install.
For debugging here's a few extras: wtf? - last exception backtrace (it's actually wtf but adding extra ?'s you get to see more backtrace) \_ex\_ - last exception as variable !!! - think force quit, really useful if you don't want any further code run or if you were calling pry in a loop and don't need to see the extra iterations
An excellent introduction to a type of testing known as "Gold Master" that can save your bacon when working with legacy applications.
 Pry is great but I still haven't been able to work out how to get it to display long lists in multiple columns across the screen. Anyone know how?
It's also aliased to $ in Pry : )
I am relatively new to reddit; should the guy who has no idea what he's doing get more points? :O
Kind of highlights the inflexibility and problems with cancan's design. https://github.com/elabs/pundit 
It does. I built this as a code quality tool for existing projects: some people are so locked in to their implementation (or, it works for them) where they can't justify tearing cancan out, but they can justify a small refactor. 
I learned something from that, thanks.
Agreed, sequel uses stuff like this all over the place, including [runtime-extend (pagination plugin)](https://github.com/jeremyevans/sequel/blob/master/lib/sequel/extensions/pagination.rb#L19), and it still gets away performance-wise overall. Also, in some cases the performance regressions are ruby-flavour dependent: jruby regressions don't translate to YARV, and vice-versa, and are just one fix-release away from being irrelevant. One should tend to optimize code maintainability, and your article does reflect that. Thx for the article, it is very insightful. 
I'll bite :) (dry-rb developer here) When you mention "dry-rb coding style," are you referring to the style in which the gems themselves are written, or the style a developer would use when they're building an app _with_ the gems? If it's the former, then I'm willing to take the hit, because the gems do a lot of work to try and make things nice for the users. We're also not asking everyone to contribute to the gems. However, if it's the _latter_, then I'd really like to know, so we can look at ways of improving our developer experience. In my experience, an app developed with the dry-rb gems is actually _easier_ to reason about because you can so clearly trace the flow of execution from input to output and you don't have to worry about mutable state anywhere along the way.
It's
/r/learnruby
His question suggests that he didn't do his research. Usually in my environment person is required to show the minimum involvement before asking the question. That's why you respect other people and their time. This guy literally just threw a question about MySQL database file in Rails. This proves he has no idea what's he doing, and he didn't even manage to google what is MySQL or how does MySQL work. This DESERVES downvotes. 
I wonder if we could get /r/learnruby listed in the sidebar? Has anyone had any success communicating with /r/ruby moderators on anything, or know how to get in touch with them? I have not. 
&gt; it can't be accessed externally at all both of them return 'BMW' if I do `Car.name`
I'm the same way, if I don't enjoy my job I end up being miserable until there's a change in my life. Thankfully, I'm in a somewhat good position in my life where I only have a few financial responsibilities &amp; don't have anyone dependent on me. Sitting at a computer doesn't bother me, I have a bit of experience working at call centers so the physical act of not being physical didn't bother me. I took crossfit at the same time. I'm definitely of the analytical, critical thinking, mindset that loves methodology and studying why things are the way they are. I'm doing what research I can into the working environment of the Mined Minds crew but so far they seem like really good people to work for. Thank you for the response, your words make me feel a lot more confident about making this change!
While we're nit picking the title, 'Abstract Data Types' is misused, Redis provides a set of concrete data structures.
I'm a Mined Minds apprentice right now working on the Clendenin office! Graduated in January from a 16week bootcamp and now getting paid to learn even more. You definitely made a great choice to learn with them and will be on a whirlwind adventure. PM me for more details
What you end up doing in your job as a software engineer depends largely on what company you work for. Do you want to be a consultant? Do you want to work on company products? Do you want to work with a team? Do you want to work alone? Do you want to own your own business? Do you want to work in a megacorp? All of these things I have done, and they all have pluses and minuses. Largely you'll be communicating with people about what to do next and trying to find a semi-optimal path to get there. In some roles you'll have a huge degree of freedom and in some not very much at all. The good news is that in a lot of companies that can change a lot in a given role and you can change positions to things you like. To talk more specifically about now: a typical day for me is reading some email for a bit and responding to anything I need to, writing a bit of code, running some tests, writing code, running test, etc., and hitting lunch, and starting the email/code/test train again after lunch. Some days are taken up entirely by emergency ops work, and some days are taken up entirely by talking through product direction, and some days are taken up entirely by arguing the finer technical points of some solution.
Good explanation, but the BlogService class still has multiple reasons for potential changes: The postfixed "/posts" on the URL The attribute mapping The classes used for config, request handling, and response handling. I think you're on the right track, and you might be able to expand on this example as you work through the other principles. 
No problem. I would still put posts on the end of the actual URL strings though. That's not the type of duplication that needs to be avoided. If you add a new blog source that ends in /blog or /blog_posts instead, you'll have to open the class. Anyway, post again if you write about the other principles!
http://imgur.com/Br00TCn But really, I'm curious if this is a common enough use case. If you really wanted you could monkey-patch Hash and add a method to do it. It's also extremely confusing that the value is on the left side of the backrocket.
Why?
Because I just encountered a situation where it would have been helpful. Also, why not?
I highly recommend using Ruby's excellent FFI and wrapping a native extension if the functionality isn't already built. A good example, but not related to your problem, is how `pocketsphinx-ruby` wraps the native PocketSphinx extension. 
Good points. What do you think of this comment from /u/u4bu8s4z9ne4y8uze? https://www.reddit.com/r/ruby/comments/6cuxs7/i_think_ruby_should_have_this_syntax_to_add_the/dhxn0jy/
I certainly like it more, since it seems to avoid the confusing syntax. Still, I'd come down on the YAGNI side of the debate. Admittedly, I have some minimalist tendencies.
Doesn't CircleCI do this too?
Because the syntax of a language should be optimized for COMMON cases. This is not a common case, how many times have you or anyone else needed to do this on a regular basis?
Do you actually want it to reflect in the hash's structure though? For example, let's say we have a hash called `info`. Now, I get wanting to set multiple keys in `info` to the same value. But would that have to mutate the structure of the hash itself? This is what I mean: info[:key0, :key1] = "Whatever" That, if your idea becomes reality, should SET the value of the two keys. The hash itself, however, should not look any different from other hashes with two keys that have the same value: { key1: "Whatever", key2: "Whatever" } 
You realize you can just do this right? hash = {} hash[:a] = hash[:b] = hash[:c] = 56
An incompetent rip-off of https://www.engineyard.com/articles/rails-server, which is itself 4 years old.
That works in simple cases, but when you're editing a large hash of config values, it's better to have an in-place solution.
[removed]
I suspect that's what it's using underneath.
Give the man what he wants: class MyHash &lt; Hash def []=(*key,val) if key.is_a? Array key.each { |k| super(k, val) } else super(key,val) end end end h = MyHash.new h['key1'] = "value" h['key2', 'key3', 'key4'] = "value2" ;)
Is there any way to make it work this way? myhash = { :key1, :key2 =&gt; 'value' }
I see them as a sign of life. When people stop asking, it really is dying.
No. but if you wanted a one-liner that works just like Hash[] : class MyHash &lt; Hash def self.[](*key, val) hash = {} if key.size &gt; 0 if key.first.size &lt; 2 hash = super(key.first, val) else key.flatten.each { |k| hash[k] = val } end else val.each do |v| if v.size &gt; 2 hash = hash.merge(self[v[0..v.size-2], v.last]) else hash[v[0]] = v[1] end end end hash end end MyHash['key','value'] MyHash[[['key','value'], ['key2','value2']]] MyHash[[['key1','value'],['key2','key3','key4','value2']]] :| not very pretty at all..... {"key1"=&gt;"value", "key2"=&gt;"value2", "key3"=&gt;"value2", "key4"=&gt;"value2"}
Oh okay I see what you mean. That would be very useful when you have a lot of integer values that start at 0.
So the answer is the latter?
Ruby needs to continue improving it's speed but it also eventually has to adopt some sort of optional typing to stay relevant. In the meantime there is crystal I guess.
No it doesn't. 
can you edit / merge text like pdflib or something like that? 
I've been in the Ruby community just over 5 years, so I don't know how it was like 10 years ago, but I'm still constantly discovering new things in the Ruby ecosystem, so even if there are less new things coming out than there were before, I don't imagine I will get bored anytime soon. I like that we finally seem to be moving away from creating Rails-specific libraries, and instead creating and improving libraries that all of us can use. This is mostly because more people are finding success in other web frameworks like Roda and Hanami. There is [Rodauth](https://github.com/jeremyevans/rodauth), the next-generation Rack-based authentication library which excels Devise in design, features and security. [Sequel](https://github.com/jeremyevans/sequel) has been gaining more traction, and Jeremy is doing craploads of new performance optimizations, as if Sequel wasn't [fast enough](http://www.railsmine.net/2015/09/sequel-vs-active-record-orm-benchmark-postgresql.html) already. [Dry-validation](http://dry-rb.org/gems/dry-validation/) has gained wide adoption, with people making blog posts how they happily ditched ActiveModel::Validations. [ROM](http://rom-rb.org/) is providing a nice alternative to the Active Record pattern. I'm (hopefully) still improving the file upload scene with [Shrine](https://github.com/janko-m/shrine) (including [resumable uploads](https://twin.github.io/resumable-file-uploads-in-ruby/)), and I haven't been able to find something like Shrine in other languages. People are finding [elegant alternatives to Spring](https://rosenfeld.herokuapp.com/en/articles/ruby-rails/2016-07-27-introducing-racktoolkit-a-fast-server-and-dsl-designed-to-test-rack-apps). Maybe it might not be much for other people, but for me there are still so many things going on in the Ruby ecosystem. Even if we all eventually move to "serverless rust and storing our data in hypercubes", as someone humorously put it, I think there are many Ruby projects to which other language ecosystems can look up to when creating their counterparts.
[The Odin Project](http://www.theodinproject.com) if you are interested in web development. Also [codewars.com](https://www.codewars.com) and [exercism.io](http://www.exercism.io/).
Take a nice break. Reflect on life.
Parallel Tests works great locally or in in-house CI, but not so in hosted CI environment, where resources are typically boxed around a single CPU. In hosted CI, parallelization needs to evenly distribute tests across different boxes/nodes. That's what Boosters make easy.
&gt; People are finding elegant alternatives to Spring. ...whereas other people are finding out that Spring is not really needed. Why do we need spring (or spring-like gems)? Because booting entire rails environment is dead slow. How it manifests itself? When we run rake tasks, start the console or run any script which "needs" the whole rails environment. Now here's an alternative: build apps in a way that they consist of separate components that can be loaded and started in isolation, where the minimum amount of code is `require`-ed. This way start up time is usually sub-second. This is what we've achieved with dry-system and dry-web apps which are based on it. We can build apps that are composed of smaller sub systems, and sub systems are composed of smaller components, and components require various libraries (either your own or 3rd-party). We don't use `Bundler.require`, only `Bundler.setup`, we explicitly require files that we need, and even a huge app boots in ~2.5-3 seconds, and there's still room for optimization to make it faster. Now, in such a setup, rake tasks or CLI commands (that I personally prefer over rake tasks), loads minimum amount of code, which means that typically a rake task or CLI command loads in less than a second. The beauty of it is that this is really only a fantastic side-effect of a better architectural design. We use things that are typically "hated" in our community, like isolating global state in a single application container, all object dependencies are treated explicitly and we use DI to make them easily available. 
The daily programmer subreddit
Hope you don't type off-key code too often! :D
Coming back to this again - do not start trying learn another language now. Spend some time honing your skills in Ruby first, no sense in bouncing around unnecessarily.
And its not particularly difficult to do yourself. There's an [excellent gem](https://github.com/grosser/parallel_tests) that works well
People constantly keep asking if Smalltalk has died. Would you be happy if Ruby went the same way Smalltalk did?
There's nothing great I know about. ActiveModel::Serializers is a popular thing in this area, especially for people using Rails, but it's had a _lot_ of API churn, still is only released as 0.x (despite being widely used in production, in several incompatible versions), and has unclear current maintenance status. Turns out figuring out a good general-purpose API and architecture for this stuff is hard, I guess! 
it seems like [Reference#initialize](http://www.rubydoc.info/github/sandal/prawn/Prawn%2FCore%2FReference:initialize) and [Desitnations#add_dest](http://www.rubydoc.info/github/sandal/prawn/Prawn/Core/Destinations#add_dest-instance_method) are possibly the solution. Still looking into it. And if anyone has and help / advise, I'm still totally open to it.
Bravo. I cracked up at "whoops!"
This is really helpful thanks!
Thanks for the reply, I'm gonna stick with Ruby and Python and C/C++ for now, this changed my perspective. Glad there's people like you involved with Ruby, friendly programmers are what keeps the hobby/career a great place to be in.
Didn't downvote. Hype dies down, people flock to the shiny new things and write articles about how the last shiny thing is dead/dying/terrible (as you can see in many previous threads), but Ruby isn't going anywhere.
Well... GutHub seems to think Ruby is here to stay, Since they are Ruby based. IMHO: even if Ruby went completely out of style and everyone that started a new project would choose another language (and I really doubt it), it will probably still survive for another 10 years just by virtue of existing platforms that still use it and need either patching, maintenance or new features.
Well not web development, Web application/application development. I know it seems like the same, but it's definitely different, webapp people mainly deal with java, ruby, python, rather than js,node.js [At least according to big companies like RedHat] I can check out PHP if I get bored of Ruby, I think I'm gonna stick with it for awhile. And even though webapp is different, I do realize I'll have to use JS soon, but I just don't want to use it as a main thing; and doing backend will really help with that :P Thanks!
Alright, sorry, I assumed since you were first reply, but assumptions make an ass out of you and me :P Thanks for the replies, I understand your point
As awful as Pry is, the alternatives are even worse. How can you even get by without it? 
I've been using [Yaks](https://github.com/plexus/yaks) some time ago, but I don't remember know whether it has what you're looking for. At our work we are using our own PORO serializer classes, and we have a classes for each context like `AccountPublicPresenter`, `AccountPrivatePresenter` which display less information or more information. It works for us because we don't need to make it so dynamic.
&gt;Speed improvement is one of the goals of Ruby 3, but not sure a type system - optional or otherwise - is necessary to stay 'relevant'. I disagree and I am pretty sure a huge percentage of ruby programmers would agree with me. Even PHP has optional typing by now. &gt;The moments when duck typing saves the day, or at least makes coding simpler, are far more common. A typing system could be based on method calls alone as in "you tried to make a call to which would not be supported by the element you passed into the function" &gt;Ruby's type system - or lack thereof - is possibly why Rubyists are so test-infected, but I don't see that as a bad thing. :) I do. If we can eliminate 80% of the tests we write our test suites would run a lot faster.
This better be about the real [chef](http://www.dangermouse.net/esoteric/chef.html)...
[removed]
The problem you described with your worker setup is a perfect example why being explicit about dependencies and using DI is a great way of organizing code. You simply cannot have this problem in our dry-system world because you *declare* what a given object needs, which is `require`-ed automatically for you.
That sounds a bit... off. A popular approach with web apps these days is to use Node.js for the back end and a framework like React or Angular in the browser client code so that it's completely JavaScript on both sides. We're actually starting to see trends with big companies leaving Java and PHP for Node.js for certain parts of their web apps. p.s. I was a big JavaScript hater but after being nudged into learning it (for both server and web browser client), I've come to really appreciate it. The latest version of it is a lot cleaner and the virtual machine itself is an absolute beast in terms of performance.
One of the exciting things about Ruby 3 is that they're rethinking concurrent programming to help Ruby actually do it. Right now, Ruby supports using threads, but only one thread will be executing at a time. Instead of programming the language to allow concurrency, they just locked it up to stay on the safe side. It's important to realize that there's no such thing as threads. They're abstractions, giving you a metaphor to use as you code and wrap your mind around different paths in your code running at the same time. Threads are only there because they were implemented at a lower level, with assembly, etc. Ruby 3 is building another abstraction later on top of threads they're calling "guilds". It's cutting edge stuff, so there aren't many details available yet. But if it makes it to Ruby 3, it'll definitely be something new and exciting about the language. The only other language I know rethinking concurrency is Go, with its "channels".
Ruby is a great language, and I think it has some constructs that other languages can learn from. The reason why you heard that Rails is only good for quick projects because stories like Twitter, that started with Rails backend, crashed so many times (see [Fail Whale](https://www.theatlantic.com/technology/archive/2015/01/the-story-behind-twitters-fail-whale/384313/)), that they had to ditch Rails completely, and redesign their architecture to accommodate the traffic. Rails is good, but perhaps it's simply not designed for a service like Twitter.
First of all, don't rely on monkey-patches provided by 3rd party gems. Just stop doing it. Secondly, even IF you have code that relies on AS (or other) monkey-patches, make it a habit that you require files from the 3rd party gem which provides monkey-patches that you need (it's a PITA but only initially, you'll get used to it). Monkey-patches are dependencies, no matter how you want to look at that, they are dependencies. If you don't `require` them, then you make an implicit assumption that they are always there, in case of a typical Rails app, you basically make an assumption that "everything is always available". I can understand that it's convenient, but then you end up with problems like yours. Not to mention that relying on `Bundle.require` (again, relying on "everything is always available") simply makes booting slower AND it also makes it **very difficult** to figure out which gems are used where (it's a major problem in huge projects, especially when it comes to upgrading things, you can't easily tell where certain gems are needed). It needs quite a bit of experience though. There are various stdlib extensions that you simply need to memorize and remember to require them (`date`, `json` like you mentioned, but also `set` and many more). Anyhow, it's worth the effort (and it's not a big effort). The same goes with libraries, personally I've made it obligatory in all my gems that every file must require everything that it needs. The goal is to always be able to require any given file from a gem and it will provide the API that you need, without the need to load the whole gem. There are of course exceptions to this rule, but in most cases it can and should work like that. Not only does it make gems easier to maintain and possibly slice into pieces in the future w/o going nuts, but it also makes loading code **faster** which is always a good thing. I should mention that Ruby really needs a better mechanism for loading code. I believe Rails made it look like a non-issue with its auto-loading craziness and making people used to `Bundler.require` but in reality this is a problem that can be solved in a better way. Improving `require` would be the first step, Python and now "even" JavaScript got it right, I've no idea why Ruby is so primitive when it comes to code loading, and it's 2017 (I blame Rails, as I mentioned). Let's also kill auto-load, it's evil.
I'm bullish on Ruby continuing to be a great way to (1) express fickle business logic and (2) making DSLs. Its inherent architecture (garbage collection, threading) means it's not a good choice for systems programming. mruby is interesting.
compare to rails 5.1 encrypted secrets.yml http://blog.michelada.io/whats-new-in-rails-51
X-Post referenced from [/r/clojure](http://np.reddit.com/r/clojure) by /u/MrDallOca [Simple Ain't Easy, but Hard Ain't Simple: Leaving Clojure for Ruby](http://np.reddit.com/r/Clojure/comments/6d0zw6/simple_aint_easy_but_hard_aint_simple_leaving/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
This was submitted to r/Clojure, following up to the author's previous writings and speakings. I'm curious what r/Ruby thinks of it from the other side.
Apologies in advance for the huge wall of text. I also posted this in /r/clojure. I've never programmed in clojure. The parens always scared me off. That said, a few points jumped out at me: &gt; "If you’re starting a project where you’re really pressed for time, you should be biased towards tools you know really well. If you have a startup, you’re supposed to be solving a business problem. Don’t make your life harder than it has to be by also having to learn new tools." There is part truth, part myth to this. On one hand, the author makes a valid point: you don't want to waste months learning new tools just to get started on their project. On the other hand, you don't want to skew the design of tools just to optimize the first phase of a project, i.e. the greenfield. Even if you spend a week fiddling with tools, the greenfield phase is always going to feel productive and energizing. Tools aside, our goal should be to ensure that subsequent phases of development experience _increases_ in productivity and energy, not decreases. This is rare, but I've seen it happen when what you've built before works well and can be leveraged for bigger/better things that would be impossible just starting out. This is a philosophical disagreement, but it will color my analysis of the rest of this article. &gt; "Avoid building a distributed system for as long as you can. They introduce a lot of expensive complexity that is hard for small teams to pay. Micro services are useful for larger teams, but the way you code and deploy your apps should be a reflection of your team’s organization and ability to coordinate." There must be a reason this meme about microservices has spread like wildfire. You don't try to "game" Conway's law with microservices -- that's backwards. Organizations will be punished by this approach because their organizational structure drew up their service boundaries. There are far more important technical considerations for service boundaries that you ignore at your peril. If an organization builds a microservices architecture deliberately and thoughtfully, the organization will be rewarded with the _ability_ to divide up teams along service boundaries after the fact. As for avoiding building distributed systems, I'll only say this: avoid distributed objects. Distributed messaging is fine for teams that have developed a proficiency for dealing with the realities of at-least-once messaging. &gt; "I personally found it really hard to get into Clojure. I got the sense that Clojure as a community doesn’t value “developer happiness”, and I think it should! Tools should try to make your life easier at every opportunity." I can't speak to the first part, but I certainly don't agree with the latter. Tools that go too far trying to trivialize the operations they carry out are generally laden with pitfalls. A good example is bundler's "remembered options." By going too far to model the usage patterns of its end users, bundler has put a serious roadblock in the way of automation (not to mention end users with different usage patterns). A little dessert is fine, but it shouldn't make up a balanced diet. &gt; "... and though it may have been written by an incompetent and mean jerk, it makes some good points." Huh? Statements like this make the author look like an incompetent and mean jerk. (**EDIT** whups, this was wrong, just read the footnote) &gt; (On Rich Hickey's _Simple Made Easy_ talk) "By separating “simplicity” from “ease of use”, and then establishing the primacy of simplicity, it gives people an ideological out to discount improving the user interface of our tools and artifacts." What? No it doesn't! Perhaps a lot of clojure programmers have taken Rich Hickey's talk to mean that they are somehow supposed to build interfaces that are cumbersome. That wouldn't be clojure's problem. Nor is it Rich Hickey's. If you're claiming that the clojure community has made a mess out of good principles, then stay tuned, because ruby isn't exactly "batting 1000" here... &gt; "Establishing this narrow view of “simplicity” as wholly separate from “easy to use” prevents us from being able to optimize for ease-of-use, aka developer experience." In ruby, I can add convenience methods and class macros on top of a properly designed implementation. I suspect the same can be done in clojure. The end result of this kind of approach is the best of both worlds -- an easy to use interface without sacrificing design goals. In practice, most ruby libraries that use metaprogramming lack any proper interface behind it. Instead of the convenience layer being a thin veneer on top of a proper API, everything becomes a giant pile of unintelligible goop. Don't believe me? Open up ActiveRecord's codebase sometime. This is not an _inherent_ problem with ruby, just something that often occurs in the wild because of the predispositions of the majority of the community. Rather than pack our bags and move to a new community, we can always try to influence the one we're in! &gt; "But here is the rub: Ruby’s tooling is terrible. The interpreter is slow and finicky and it used to leak memory like a sieve. There is no static introspection, the meta programming features are basic and slow and it is trivially easy to bleed state and complect the hell out of your programs. It was great compared to Java or PHP in 2004. In 2017, the world is different." The ruby interpreter is not _supposed_ to offer static introspection of types. It does offer static introspection of classes, methods, etc., though the source code itself can't be introspected easily. Anyways, the interpreter ain't particularly finicky, and it doesn't leak memory anymore, by your own admission. The "meta programming features" aren't slow, and it's just as trivially easy to metaprogram in a way that _doesn't_ "complect the hell out of your programs." And the overall performance of ruby is a great way to indicate that you don't grasp Rich Hickey's talk. Rails apps are often slow because each request/response performs vastly more computations than are needed. Just look at the translation layer from ruby to SQL (i.e. ActiveRecord). Even then, rails is often fast enough for most organizations. I get that the larger point is that you'll choose ruby in spite of all those perceived disadvantages because of the commitment to your happiness. I'm suggesting that your analysis isn't oriented around facts, but rather beliefs/opinions. &gt; "All programming languages should strive to be fun and make programmers happy." Perhaps this is a laudable goal. But focusing on fun/happiness in the context of standing up new projects is very limited. I don't care how nice ruby's tools are, if you end up with a mess, it's not going to end up being all that fun anymore. I realize I'm coming down kind of hard here, but "I'm leaving language X for language Y" type posts seem to stir up lots of attention focused on things that don't really matter, and they aim straight for our personal identities. "I'm a clojure developer so I need to refute this guy who left for ruby," etc. I'm a programmer _before_ I'm a ruby programmer, or a web programmer, or a "full stack" developer (ugh), or any other label we qualify ourselves with. This kind of article doesn't help improve anybody's actual programming.
It seems like this gem should be named `dotenv_sekrets_rails`. https://github.com/mikamai/dotenv_sekrets/blob/master/dotenv_sekrets.gemspec#L28
Ever since I saw someone recommend just dropping the `f` from `shift` and `unshift`, it has been really easy to remember exactly which each one does.
Ok, the C10k issue boils down to the computational cost of each page request. Dynamic frameworks like Rails, Sinatra, etc, are often the costly part of each request as they have to fetch data and generate responses, etc etc. So, the secret to handling C10k levels of traffic is caching. A very basic example is to store a copy of each page on the hard drive and then have the web server serve those files instead of Ruby doing it. Serving cached content is always faster than dynamic content, so by reducing the cost of each request to the lowest possible you can serve even more. 
Yeah I know it's becoming popular, but, as you know, not every company uses node.js. Companies like Redhat, which deal with opensource linux applications and recently getting into containers and such pretty much have to use other languages besides js for backend. That's the type of company I want to work for, a company that uses the right tool for each job, not just what's popular. But I do understand that js is becoming popular and the uses are growing, but that doesn't mean it's going to be the one-all language for web applications.
Awesome thanks for the round up! Any idea when the next puma release will be with that fix?
Thanks! That's the other issue I forgot to mention. The process that is writing to this file isn't detected by kqueue/inotify or anything else that would be built in watching the file. I've tried both guard and listen. 
As soon as this is solved https://github.com/puma/puma/issues/1292 
Here is one crazy idea, use `tail -f` and pipe the result into a Ruby pipe: read_pipe, write_pipe = IO.pipe spawn "tail -f File.txt", out: write_pipe thread = Thread.new do loop do read_pipe.readpartial(1000) # reads at most 1000 bytes, blocks only when there is no content available end end In your thread you can now call some callback with the returned content, which should always contain only the changed set of `x/y` pair of values. At first I thought that `tail -f` works only for content that is appended, but apparently it outputs any file changes as well, as the code below proves: File.write("File.txt", "x=10\ny=13") # create the file read_pipe, write_pipe = IO.pipe spawn "tail -f File.txt", out: write_pipe p read_pipe.readpartial(1000) File.write("File.txt", "x=20\ny=23") # overwrite the file p read_pipe.readpartial(1000) # outputs: # "x=10\ny=13" # "x=20\ny=23"
Loved that performance panel! 
Great stuff. Already trying to apply a few things to an existing app. 
And just to add a small peep to this point -- even if you took the time to learn it, and it went out of style -- regardless of how long it survives, you will have learned some really great, transferrable skills along the way. I struggled with .net MVC until I learned Rails. Suddenly an awful lot of things in other languages that borrow similar concepts made an awful lot more sense even just after six months of Rails study. Programming is programming. The language does not matter. It is a craft that gets honed regardless of the tool at hand.
It should work and it's tested on travis on that version of Ruby. What's your `ulimit` for open file descriptors? Calling wait doesn't block - it yields that fiber until the task counting the number of connections completes. Once that task completes (also operating asynchronously as it calls `sleep`), all the server connections are allowed to continue.
I'll give that a whirl! Thanks!
So, two things: first, whenever debugging a loop, it's useful to step through the code and view the values of your parameters at each step. You can do this using a debugger, or by pen and paper if you want. Second: initialize doesn't work like that. So initialize is a constructor, a special method used to create new instances of an object. You can pass parameters to the initialize method, and it'll use them to create the instance. But you can't use this back and forth user input and output within initialize - that's not how it works. Plus, in general, you don't want to hide input and output for an instance inside of a method - you want that you just be a method in and of itself. In this case, you'd want a top level function that runs your gets.chomp methods and passes the parameters to Object.new to create the new instance. I suspect the infinite loop occurs because of method scope for initialize and gets.chomp, but I'm not one hundred percent sure.
I checked the code in irb and it works as you would expect. I don't have any experience with Visual Studio or Windows, so I'm not sure how to get that working for you. Normally for what you are doing I would type the program up in my text editor then run `ruby person.rb` on the console. In terms of running simple ruby programs on the web for learning programming, I suggest trying [repl.it](https://repl.it/languages/ruby).
&gt;Does Python offer something that Ruby is missing? *Performance* Python has a reputation for efficiency. Data mining tasks can be very demanding of the CPU *Readability* Python is one of the most readable languages to non-programmers. A lot of people driving data mining are math or statistics academics, who only want to pick up the minimal amount of programming to get by, so Python's easy syntax appeals. *Historical/Community Reasons* Python and Ruby got popular around the same time. Ruby's 'killer app' (so to speak) was Rails, so a big web dev community evolved, and a lot of nice libraries were developed for that. Python's 'killer apps' were scientific libraries like NumPy. Around when Python got big, the other options for data science (C, FORTRAN, MATLAB... etc) were harder to learn or not as general purpose. Also, Google was doing lots of development in Python, and everyone wanted to be like Google. That said, you can totally use Ruby to tackle whatever problems you are working with. Depending on your project, you may want to learn some performance-enhancing options up front. Alternatively, on smaller projects, you can basically write Ruby until performance becomes an issue, and refactor to address this problem later. *Some options* * [WEKA](https://weka.wikispaces.com/) - A pretty easy Java-based data suite. Maybe avoid this one if you don't like the GUI of SSIS. I've only used the GUI, which is honestly pretty user-friendly, but there is always the option of doing all the same stuff in straight Java code. * [R](https://www.r-project.org/) - A statistical language with a lot of nice libraries for easy data-mining/machine learning. Where R really shines for me is with some of its graphing libraries. Makes visualization a breeze. * [Crystal](https://crystal-lang.org/) - Ruby-like syntax in an extremely fast, compiled language. * [Golang](https://golang.org/) - I'm seeing Go start to enter the mainstream. I haven't used it personally, but I read a few papers recently whose authors used it for NLP and loved it. Worth looking into. * [Ruby with C extensions](https://silverhammermba.github.io/emberb/extend/) - Do all your business logic in nice clean Ruby, and tie in C code for the CPU-intensive parts. This is what I would go with if you are already strong in both Ruby and C. 
I don't think there's actually a problem with his code, I think that he juste doesn't know how to run it in a console that supports input.
&gt; We talk with Aaron Patterson about Ruby and Rails upgrades, and the goal of making Ruby 3 three times faster than Ruby 2. http://bikeshed.fm/111
If it was me I would set @name to a blank string, then call another method that did the user interaction and updated @name.
I'm the interviewee, happy to answer any questions about the topic. 
fuck I love that guy
I assume you're using the gem 'ripl-readline-em'? If not, what are you using? I'm not a Rails person, so I don't know if there's standard gems for using Readline. I'm also not super familiar with Readline. One thought is that your extra `\n` is causing the handler to run an extra time. So what you're getting from STDIN is: hello # Blank line Then `line = nil` because it's being fed a blank line when the handler function is run a second time ("The handler function receives the text of the line as an argument." http://cnswww.cns.cwru.edu/php/chet/readline/readline.html#SEC41). `line` is being pulled from the larger scope. `l` would be meaningless outside of that block, but `line` should equal the last value assigned. I'm guessing the handler is being run an extra time and it's assigning `nil` because of an empty line. 
**Fun Way:** Set Ruby and Rails versions to `2.4` and `~&gt; 5.1` respectively, then (manfully) run `bundle update rails` while you sing _"Ave Maria"_ and slap your dick on the table. **Less Fun Way:** We followed this method in a previous job for our upgrade from Rails 2 to 5: 1. Write a test suite for your entire app. 2. Start upgrading one version at a time (e.g. `4.0` =&gt; `4.1`). 3. Stop and fix when stuff breaks. There exists no magic bullet for a Rails upgrade, because each app is different. You can only increment, test and fix until you reach the desired version. Our biggest problems were: 1. Ruby version. We encountered significant breakage going from `1.8.7` to `2.3.2`. 1. The model and controller layers. The original developer had a fetish for premature optimization. First, he put model validations into controllers, and then used custom SQL to call records. It was a nightmare rat's nest. If your app follows best practices and doesn't engage in stupid shit with custom queries, you shouldn't experience too much pain. Tests are critical because they permit you to see breakages and variances in output.
Another thing to consider is the other gems you have dependencies on. If they weren't updated for newer versions of ruby or relied on functionality no longer in rails you'll either need to find a suitable replacement or write your own. 
I've been through migrating a big app from 3-4 and am now starting 4-5. Just upgraded all our smaller apps to 5.1. For us the change from 1.9.3 to 2.2.3 wasn't huge, I guess we were lucky. I'm trying out 2.4.1 right now, and it's been no trouble as long as 2.4 compatible gems are available. So you might want to go all the way to 2.4 (I figure if you're in upgrade hell for a while anyway, get farther ahead) I would start with the ruby upgrade. This will probably necessitate some gem upgrades to get to versions compatible with 2.x The usual recommendation is to go point-release by point-release, incrementally fixing. The advantage is that you stay closer to a working system with each step, so it is easier to it back to working after each change. Even though it will take a while for you it will help you stay focused on a smaller number of problems. The two most painful parts I've found are 1) gem version compatibility issues. Just fighting your way through the gemfile to get everything upgraded in the right order. and 2) 'rake rails:update' replaces your /environments/* files each time and you have to re-merge your changes for each one after every upgrade. Making sure you didn't lose a specific setting is a pain. Good luck! Embrace the suck!
Finally someone mentions Rodauth. I find reading authentication libraries to be the most important of these 4 points, exactly for the reasons already given in the blog post: &gt; [...] the more you know about how other popular authentication frameworks approach authentication and the steps they take to avoid being vulnerable to attack, the more confident you can be in assessing the security of your own authentication set up.
Completely forgot about gems. Thank you.
Thank you for this. I have a pretty thorough understanding of the app and have been able to debug efficiently because of it. I'll be doing the upgrading on a VM so at least if anything breaks, I can always restart :).
As I was one that recommend that so I'll chime in. If you don't mind many incremental steps then something like: * 1.9.3 -&gt; 2.1 * 2.1 -&gt; 2.2 Is probably better, but it depends. These are the points where GC changed significantly which can have unexpected impact on memory use, both good and bad, depending on usage (especially 2.1 -&gt; 2.2). If this app is under light load, it's highly unlikely to matter. 1.9.3 -&gt; 2.0 is mostly a trivial change, there are some new features that may impact gem compatibility and performance (new regex engine, keyword args, module prepend, default UTF-8 encoding of source code). But these changes won't effect many applications and few gems made use of them immediately to maintain backward compat.
I second this: we skipped 3 entirely 
Good to know, will look into this!
&gt; The second is a global variablr Global variables in Ruby are prefixed with a dollar sign.
Also, if anyone knows of any workarounds to the command line approach, I beg you to clue me in.
Actually, do instances have an unique ID? And maybe somehow access to them that way? Like when creating one taking its ID and saving it to a Hash related to the `@name` and then changing through it? Maybe not super safe but if it could work I could toy around with that.
You need a reference to the other object. In a real system you'd probably be using a database, so you could do something like Person.find_by_name("John Smith") or Person.find_by_account_number(123).
You could do something like: class Bank def initialize(people) @people = people end def lookup(name) # assuming the Person class has a `name` method @people.find { |person| person.name == name } end end You'd then initialize it with: person_one = Person.new("Bob", 1234) person_two = Person.new("Alex", 4321) bank = Bank.new([person_one, person_two]) and find a person with: person = bank.lookup("Bob")
It's called "sanitizing". There's a gem called [Zaru](https://github.com/madrobby/zaru) that does the trick.
As far as I know, there are two ways of shielding yourself from remote shell execution attacks. The most straightforward way for your example is using the `shellwords` Ruby standard library to escape the filename: require "shellwords" `HandBrakeCLI -bunch -of -options -i #{Shellwords.escape(filename)}` Another way requires you to use `Kernel#system`, `Open3.capture`, or any other command that uses `Kernel#spawn` under the hood. The most common way to use these commands is to give them a command string, which is given to the underlying shell, so it still leaves you vulnerable to remote shell execution. However, if you pass arguments as *multiple* strings, Ruby then avoids the shell and passes the command directly to the operating system: #=== using Kernel#system (if you don't need the output) # bad, vulnerable to remote shell execution system "HandBrakeCLI -bunch -of -options -i #{filename}" # good, bypasses the shell system "HandBrakeCLI", "-bunch", "-of", "-options", "-i", "#{filename}" # good, equivalent to the above, but using Ruby's `%W[...]` for less typing work system *%W[HandBrakeCLI -bunch -of -options -i #{filename}] #=== using Open3#capture3 (if you need the output) require "open3" # bad, vulnerable to remote shell execution stdout, stderr, status = Open3.capture3("HandBrakeCLI -bunch -of -options -i #{filename}") # good, bypasses the shell stdout, stderr, status = Open3.capture3("HandBrakeCLI", "-bunch", "-of", "-options", "-i", "#{filename}") # good, equivalent to the above, but using Ruby's `%W[...]` for less typing work stdout, stderr, status = Open3.capture3(*%W[HandBrakeCLI -bunch -of -options -i #{filename}]) Note that when you're executing many shell commands that take up memory, you might experience `Errno::ENOMEM: out of memory` errors being thrown. This happens because `Kernel#spawn` uses `fork(2)`, which requires your server to always have more than 50% of free memory (roughly). In that case you might want to consider using [`posix-spawn`](https://github.com/rtomayko/posix-spawn), which mimics the same interface of Ruby's `Kernel#spawn` family of methods, but uses the `posix_spawn()` system call under the hood. You can just `include POSIX::Spawn`, and use "`` `...` ``", `system` or `spawn` the same way you would use the Ruby ones.
Ah, the perennial song of Rubyist's everywhere. &lt;3
I implemented the fix qumo posted by editing androidcommon.rb, and it got me much further, but now I'm getting a different error: C:/RhoMobileSuite5.4.0/ruby/lib/ruby/gems/1.9.1/gems/rhodes-5.4.0/platform/android/../../platform/shared/ruby/file.c:2884: error: undefined reference to 'endpwent' C:/RhoMobileSuite5.4.0/ruby/lib/ruby/gems/1.9.1/gems/rhodes-5.4.0/platform/android/../../platform/shared/ruby/file.c:2890: error: undefined reference to 'endpwent' C:/RhoMobileSuite5.4.0/ruby/lib/ruby/gems/1.9.1/gems/rhodes-5.4.0/platform/android/../../platform/shared/ruby/process.c:4324: error: undefined reference to 'issetugid' collect2.exe: error: ld returned 1 exit status rake aborted! Build failed: rhodes Tasks: TOP =&gt; device:android:production =&gt; package:android =&gt; build:android:all =&gt; build:android:rhodes =&gt; build:android:librhodes Edit: I also got this error: C:/RhoMobileSuite5.4.0/ruby/lib/ruby/gems/1.9.1/gems/rhodes-5.4.0/platform/android/../../platform/android/Rhodes/jni/src/MethodResultJni.cpp:360:13: warning: shadowed declaration is here [-Wshado w-compatible-local] JNIEnv* env = result.m_env; ^ rake aborted! Linking library failed: C:/Users/[username]/workspace/Storemanager/bin/target/android/debug/librhodes/lib/armeabi/librhodes.so Tasks: TOP =&gt; link:arm =&gt; C:/Users/[username]/workspace/Storemanager/bin/target/android/debug/librhodes/lib/armeabi/librhodes.so (See full trace by running task with --trace)
It's a terrible idea, but you could totally do this: class Person attr_reader :name attr_accessor :balance def self.who(name) ObjectSpace.each_object(self) { |person| return person if person.name == name } nil end def initialize(name, initial_deposit = 0) @name = name @balance = initial_deposit end def gift(giftee_name, amount) if giftee = self.class.who(giftee_name) self.balance -= amount giftee.balance += amount puts "You gifted #{giftee_name} the amount of #{amount}!" end end end
Update: I resolved the issues in the other comment, here's where I'm currently stuck: C:\RhoMobileSuite5.4.0\ruby\lib\ruby\gems\1.9.1\gems\rhodes-5.4.0\lib\commonAPI\coreapi\ext\platform\android\src\com\rho\notification\NotificationSingleton.java:23: error: cannot find symbol import android.support.v4.app.NotificationCompat; ^ symbol: class NotificationCompat location: package android.support.v4.app C:\RhoMobileSuite5.4.0\ruby\lib\ruby\gems\1.9.1\gems\rhodes-5.4.0\lib\commonAPI\coreapi\ext\platform\android\src\com\rho\notification\Notification.java:18: error: cannot find symbol import android.support.v4.app.NotificationCompat; ^ symbol: class NotificationCompat location: package android.support.v4.app C:\RhoMobileSuite5.4.0\ruby\lib\ruby\gems\1.9.1\gems\rhodes-5.4.0\lib\commonAPI\coreapi\ext\platform\android\src\com\rho\notification\Notification.java:281: error: package NotificationCompat does not exist NotificationCompat.Builder builder = new NotificationCompat.Builder(ctx); ^ C:\RhoMobileSuite5.4.0\ruby\lib\ruby\gems\1.9.1\gems\rhodes-5.4.0\lib\commonAPI\coreapi\ext\platform\android\src\com\rho\notification\Notification.java:281: error: package NotificationCompat does not exist NotificationCompat.Builder builder = new NotificationCompat.Builder(ctx); ^ Note: C:\RhoMobileSuite5.4.0\ruby\lib\ruby\gems\1.9.1\gems\rhodes-5.4.0\lib\commonAPI\coreapi\ext\platform\android\src\com\rho\notification\NotificationSingleton.java uses or overrides a deprecated API. Note: Recompile with -Xlint:deprecation for details. Note: Some input files use unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 4 errors rake aborted! Error compiling java code The general consensus online is that these are things from a file called "android-support-v4.jar" and apparently I need to put that file in some magic place but I can't figure out where.
Use a temporary filename. Rename files to/from known names, such as abcd.mp4, before passing to external processes. 
`"#{filename}"` is more idiomatically written either as `filename` or `filename.to_s`
&gt; I figure I'm not the first person to ever think about this and there's probably a standard way to do this. Good on you for realizing this and doing the proper research / posting here. Too many beginners don't do that. 
EDIT: Output should be like this: my name is slim shady 
I think the problem with exec is that it doesn't let you continue to run your ruby script afterwards. I'm doing a `Dir.glob("**/*")` and need to run the command for every file.
Follow the repo and get involved? Love to have you on board.
Huh? That is in fact what it expands to, and the RI article says the same.
Thanks for pointing it out, I must have overlooked this egdecase which is pretty clear. I'll probably update the article and use better words for that. BTW. nothing has been changed in the article, you quoted two different parts and they are both still present. 
Not really, the quoted fragments are two different parts from the article, they are both still present, but just the different paragraphs.
Hey! It would not, it doesn't support all the logical operations, but otherwise, it SHOULD support everything the original did. :) It has a lot of tests, like over 90% coverage, and they all still pass nicely. :) As for the syscall with safe, yes. I would things so, if they want things to be kept secure. :) OR they have their own sandbox and white-list strategy. SAFE=4 would be easier though. Also, thanks very much. :) Glad you liked it!
Nice post. (☞ﾟヮﾟ)☞ 🔥🔥🔥
I'm not sure what you mean quotes are stripped? Can you explain? method(array) # "hello" Array(['hello', 'hi']) # ["hello", "hi"] method(array) === array[0] # true 
No. Don't use them. They replicate implementation details and defeat the while point of testing in the process. An MD5 hash over your code is as effective as double book keeping tests.
If you have custom validations, or validations with complex arguments (like an :if condition), then you should make tests for those. But you should not test built-in validations. That's what the rails tests are for.
That's a really interesting way to think about it, haha. 
It me
Another good explanation. Thanks for sharing. My only criticism is that you didn't need the part about inheritance. In Ruby, any class that implements a send method that accepts a user and message will work with your example. Looking forward to your Liskov example!
I built a simple front-end to convert HTML/ERB to SLIM or HAML on top of the the usual gems. I welcome any constructive criticism.
Not clear on what basis he made such a conclusion.
Wrong Ruby. 
And to avoid using it, I've accidentally used `array.insert('foo')` only to realize it does nothing in ruby &lt;= 2.4.1. No errors, nothing. 
this is already on the front page of /r/ruby
So you don't test validations directly, only through integration tests?
X-Post referenced from [/r/rails](http://np.reddit.com/r/rails) by /u/ShoeBearZ [Thy will be done, on Rails as it is in Basecamp](http://np.reddit.com/r/rails/comments/6e78n1/thy_will_be_done_on_rails_as_it_is_in_basecamp/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Thanks for your comment. I'm not a big fan of inheritance as well. We can rely on polymorphism for all those classes, for sure. So each sender should just implement `send` method and it would work. But if we have more than one method that should be implemented for each sender, I would prefer to have one class that describes all required methods, the interface of a sender. Besides that basic description of Open/Closed principle relies on inheritance, so I decided to mention that in article as well. But I agree that for some cases it can be omitted.
Only if the business requirement is that a field be required. If you start from the perspective of writing tests against code, you have the wrong perspective. Write tests against what it should do, not what it is. The rabbit should hop. Not the rabbit should have big white exactly 4 inch long ears. If my rabbit evolves into a kangaroo my test should still pass.
 def print_table(array, cols=3, col_padding=2) col_width = array.max_by(&amp;:length).length + col_padding array.each_slice(cols) { |row| puts row.map{|e| '%*s' % [-col_width, e]}.join } end Should cover the basics, if you wanted to really match what `ls` does you'd have to automatically determine the number of columns to use based on the array content and the terminal width. I don't know if there is a standard way to get the terminal width cross platform, but with `zsh` on OSX it's available as `ENV['COLUMNS']`
the comics on this are great. couple questions: - is this a way to do a pipe using a special syntax? - has the parser been extracted into a gem? 
You've saved my ass in two jobs. &lt;3
Hey mate! I'm not sure I understand your first question. Which pipe are you referring too? I'm guessing not IO.pipe. ☺️ It has not been extracted as it's tightly coupled to jsonpath and its inherent functionality. As it only parses things like ?(@.price == 20). Also, thanks a lot! ☺️
fair enough! I suppose you could just put in some javascript to do it with `window.location` if `http`, but kinda hacky. It's not really something that's gonna be a jekyl plugin I don't think, nor DNS, it's something you'd ordinarily want to do at the web server level, whatever is hosting the static content, if you can just tell it to redirect all http to https. Although the http response headers suggest your pages are being served by Webrick, which I didn't expect. so maybe I'm wrong about jekyl being a static content generator, I dunno what's going on. (You're using the jekyl development server in production, is that what's going on? I mean, I guess it's working, so okay then!)
i mean like unix pipe or i guess the correct term would be prefix notation
Your blog is awesome. You're awesome. Could you perhaps, in the future, write a blog post explaining how do you come up with blog post ideas? I really want to start writing more for my blog, but every little topic that I think might be interesting or good enough for a blog post is already covered somewhere else or I feel like I don't have enough experience or technical knowledge to be writing about it :\ 
Thanks for the link, the article was very useful. BTW, great book!
It's amazing the lengths we'll go to in order to undo the boundaries drawn by object oriented programming.
It looks like there's a forked buildpack which does support that: https://github.com/keepworks/heroku-buildpack-static/commit/4ab70a256d58ff15e96049ec80f8598c0c3c81a1 Sadly, it doesn't look like they submitted a PR to the Heroku buildpack, but it looks like it'd do exactly what you need. 
Solarized dark is good, solarized light strains my eyes a little.
If that's the case then a DNS CNAME should work as you're covered with both HTTP and HTTPS traffic by having that cert!
I like base 16 darktooth in vim 
My problem is that there are different URL representations of the same content. I want them all to be using the exact same protocol and sub domain. That's what this thread is about. I've got the protocol (SSL) redirect working but not the subdomain redirect. 
I went to try TruffleRuby today, and hit the "sign up to download graalvm under the oracle license" page. I was under the impression that the graalvm was gpl/lgpl. Is there a page that clarifies what the license terms are for each piece (i.e. substratevm, graal, truffle)? Also, is there a download page where I can fetch the code that is covered under the GPL? The actual project seems really cool, looking forward to tinkering with it more. I was able to get an example microservice I've got lying around to to run without too much trouble, though I haven't yet tested it terribly thoroughly.
nice!
Tomorrow Light all day. Actually I dislike dark themes. 
In general, I think turning hashes into value objects (e.g. `Struct`s) is not a bad idea. What worries me about this is that `Struct` classes are being created and garbage collected at runtime, which (I think) invalidates all the [method caches](https://github.com/charliesome/charlie.bz/blob/master/posts/things-that-clear-rubys-method-cache.md). The more frequently it's called, the more it's going to impact performance. Then there's also the monkey patching. It would be safer as something like `ToStruct[x]` instead of `x.to_struct`.
I think the approach Mike commented is more efficient, and it creates a kind of "logical contexts" between the app and the gem in Redis. Moreover, it could be sped up by using a Bloom filter (or a multilevel structure) in order to avoid looking for not banned ip addresses.
On vim, I use LuciusDark for everything. It's great. 
In my experience the performance hit of such approaches are not worth the perceived benefits.
railscasts: https://github.com/jpo/vim-railscasts-theme/blob/master/README.md#screenshots
👉
you left out the case where your company forks a few gems to add custom logic but never goes and updates either the original gem or the forked, even when known security issues.
In that case simplest in your situation I can think of is put it behind Cloudflare and have page rule that does the redirect for you. Unless you've access to whatever webserver your running on (like nginx) but I think you said it's on heroku? I've a single rule to redirect www.ukulesa.com to ukulesa.com for example with Cloudflare going to heroku app.
&gt; Unless you've access to whatever webserver your running on (like nginx) but I think you said it's on heroku? I'm already running behind nginx on Heroku. I've got this. Don't worry about it ;) 
I was super-hesitant about that
Then this does shallow `to_struct` instead of a deep `to_struct` (e.g. only the first level is converted
Except we have `Hash[x]` and `Array[x]`, this is pretty much ruby-esque.
&gt; How is a a breaking change not just a breaking change? A breaking change that's a rewrite generally requires much more severe changes. Renaming a method is generally a quick fix. They're both two varieties of breaking changes with different characteristics and impacts. &gt; I think the idea is that you should try not to introduce frequent breaking changes, you should probably get used to a major update (that is any breaking change) being quite likely to include a bunch, and involve some work to update. If it's not, then... the maintainers should just find a way not to introduce a breaking change. This philosophy seems to lead to problems in practice. Avoiding breaking changes is harmful to the project itself. When possible improvements with breaking changes are discovered, breaking changes get batched up into big releases, like rspec 2 -&gt; 3. This leads to deprecations and the extra maintenance cost thereof. In general, teams should update their dependencies all the time, with the _exception_ that you'd want to hold off on major rewrites or product generations. The nature of that kind of release is that it's not incremental. Now, that's an opinion of mine. But as an end user, I want to be able to allow incremental breaking changes to automatically get pulled in, without having to also accept every product generation release automatically. With semver, I don't have that choice -- that's the flaw. With the approach I described, I can choose to pin against the product generation or the latest major version.
Reviewing the comments here, I'm not sure anyone gave the radical answer of ... have you considered a rewrite? If it's a really large app, then of course you would want to upgrade, but for a smaller app that didn't use best practices, a rewrite might actually take less time. You could write a set of feature tests on the old app, and then take those same tests to the new app. When you get all those tests working, you are done. Just a thought. If not, then /u/annoyed_freelancer has some of the best advice.
Vim / dynamic based on my wallpaper using: * https://github.com/dylanaraps/wal - to generate colors from my wallpaper * vim plugin `Plug 'dylanaraps/wal'` + `colorscheme wal` .vimrc setting Couple of quick examples: [here](http://imgur.com/a/7MJC6)
Then it should be `Struct[x]`?
&gt; If you write a library for free that users depend on for their business, you have no responsibility to maintain it for them. If you abandon the project, they are welcome to add their own patches and make it compatible with current code. Context matters. This story plays out often: someone writes a library for free, they promote the hell out of it, it gets popular, the author leverages the popularity and goes on the speaking circuit, levels up their career, abandons the library when they switch languages, and leaves their users in the dust. There is a lot of work done on open source software that is paid in community points instead of money. If I know that a library author feels no obligation to their end users, I'm not going to use their library. Period. I've been burned way too many times. I don't really understand your beef, either. My post was a suggestion that people bear this in mind. They are free to take it or leave it. If someone wants to throw up a ruby gem and a github repository in case anyone _might_ be interested, that's a wholly different context. They're not out trying to promote it to gain users, they're not leveraging it to improve their standing in the community, etc. Perhaps I should have distinguished these two contexts, but honestly this is a bit of a tangent from the general aim of my comment.
If you're using a newer distro that uses systemd running any arbitrary executable or script is as easy as creating a unit file with about 3-6 lines of text in it.
Sunburst: http://colorsublime.com/theme/Sunburst
With systemd, you need something like this, *circulo.service* file: [Unit] Description=Circulo Script [Service] SyslogIdentifier=circulo-app User=circulo PIDFile=/home/circulo/circulo_service/circulo-app.pid WorkingDirectory=/home/circulo/circulo_service ExecStart=/home/circulo/circulo_service/circulo.sh ExecReload=/home/circulo/circulo_service/circulo.sh ExecStop=/bin/kill -s QUIT $MAINPID Restart=always [Install] WantedBy=multi-user.target circulo.sh contains: RAILS_ENV=production /home/circulo/circulo_api/bin/bundle exec puma -C /home/circulo/circulo_api/config/puma.rb -e production 
Check out foreman gem. If I remember correctly you can export the start script with it 
Really comes down to what you define as 'a Linux service'... As others stated is mostly comes down to a unit/task/script for your operating systems init system. There are multiple. To aid with the mess that distros and their choice of init systems are, I'd also recommend the [foreman gem](https://rubygems.org/gems/foreman). It comes with the need to define a `Procfile` for your app, but from that allows exporting, see: http://ddollar.github.io/foreman/#EXPORT-FORMATS If you are also talking about building your software into a installable .deb package, check out the [fpm gem](https://rubygems.org/gems/fpm). My recommendation here is to build you app as a gem with a well defined bin stub anyway, and then at 'compile time' run fpm to build your .gem to a .deb. But that's up to you, fpm allows basically everything to be packaged. Interesting here are the handful of init script parameters: --deb-init FILEPATH (deb only) Add FILEPATH as an init script --deb-default FILEPATH (deb only) Add FILEPATH as /etc/default configuration --deb-upstart FILEPATH (deb only) Add FILEPATH as an upstart script --deb-systemd FILEPATH (deb only) Add FILEPATH as a systemd script which would take the the path to the outputs of the `foreman export` command. If you are deploying via capistrano, there are also gems that make the use of foreman export easier, like https://github.com/aserafin/capistrano-foreman-systemd. But they are optional, as you can just call the commands via shell outs in the cap run anyway.
Thanks for all of the recommendations. I am using ubuntu 14, so not on systemd yet. Still using upstart I believe. So I'll check into foreman. Thanks!
Pretty easy to write an upstart file, too.
&gt; Ruby's standard library is in the process of being gemified. It will soon - Ruby 2.5 - consist of RubyGems, which can be updated independently from Ruby. I don't understand what this means. 
Whoa, this is major news. Now we can get OpenSSL fixes independent of MRI upgrades!
Fancy new (3rd party?) summary, existing ongoing project: https://bugs.ruby-lang.org/issues/5481
Just learning, for the sake of learning, isn't generally enough to make the knowledge "stick". It dribbles away pretty fast. If you have a specific project or goal in mind, you are more likely to retain your learning. Doesn't have to be a big project, but making it something useful will give you the double benefit of retaining all your hard work, AND having a useful thing at the end.
Welcome to the world of decimal floating point math using binary logic. http://www.smbc-comics.com/?id=2999 https://m.youtube.com/watch?v=PZRI1IfStY0
Whew -wipe my brow- I'm not the worst coder on my very first lesson. Does that also explain for why 2X3=8 and 3X8=6,561?
Ah... that makes sense. Thank you
Something like: ([[]] + arr).slice_before{|item| item.empty?}. map{|chunk| chunk[1..-1] } I'm not sure what "out", "plugs" and "current" are, but hopefully you can do something with the above. Edit: slightly better: ([[]] + arr).slice_before{|item| item.empty?}.map{|head,*tail| tail } 
I was pretty sure this means OpenSSL is still a 'standard' gem, in that it gets installed with ruby, you can't remove it, and it's maintained by ruby core. As far as getting independent fixes, the openssl gem 2.x has been released since last November (https://rubygems.org/gems/openssl/versions). 
Never directly compare floating point numbers. Computers can't exactly represent floating point numbers, so while 5.3 - 2.1 will not == 3.2, it will _very_ nearly equal 3.2. You might get an answer like 3.20000021 or something. This is a problem inherent in all floating point numbers, it's not just Ruby. The CPU represents floating point numbers using IEEE 754 notation, which is like scientific notation in binary. Instead of digits meaning 1,2,4,8,etc each digit means 1,1/2,1/4,1/8,etc and that is multiplied by some exponent also encoded in the number. So a number might be represented like **1+1/2+1/16+1/128 x 2^7**. If your number can't be exactly represented this way, it will find a number that's very, very close but not exactly the same. However, to make things more confusing for newbies, there are many cases where the == operator works just fine with floats, you can say **1.5 - 1 == 0.5** and it should be true, this is because 1.5 if one of the numbers floating point can represent exactly, with **1+1/2 x 2^0**, similarly with 0.5. So they use it and suddenly down the road _bam_, the == operator appears to break. Then they scratch their head because the == operator _broke?!_ Just never use the == operator on floats unless you know exactly what the result should be because you just set it using a constant. For example, you can say **f = 0** then test if f still equals 0 by saying **f == 0**, setting it to a constant will always make it equal to that constant. However, if you do any operations on f and expect it to arrive back at 0, such as **f = 1.3 - 1 - 0.3** then you're back to where you started. Honestly I've never found much need to compare floats, but if you have to then use something like **(a - b).abs &lt; 0.00001**, in other words if the distance between the two numbers is less than some arbitrary small number then they are "close enough" and are "equal."
More like a standard version would ship with the core and updates could be made independent of full os releases. 
Took a moment to realise this is not a game. 
Quote from post: &gt; Yup. Six. Weeks. Hm. Six. 6. We already had Half-Life 2. 6 / 2 = 3. Half-Life 3 confirmed.
I hope when they do this they fix some of the platform shortcomings of gem.
Never hurts to start checking things out and playing with them. i'd say check out both rust and ruby and whatever else catches your fancy, in whatever order you want, to get a feel for how they work and how they differ from each other. rather than picking one in advance to dedicate to trying to master. If you haven't done OO before, that general concept might take a while to wrap your head around. ruby's as good a language as any to do that in, I think. once you do, you'll find all the OO languages more comprehensible, regardless of which you start with. 
it might pay dividends especially if integrating with other google apis........i haven't tried it (yet) but it looks very promising. 
This is not the Ruby you are looking for.
HL3 is written in pure Ruby. Performance tuning is what's taking so long.
Why?
You SJWs are terrible human beings. I bet you all turn on each other in your slack group. 
What is the better way to fix it? What alternatives do you offer? Does it hurt you that they want to work together enough that you need to put them down?
"Everything is oppression"
Does your brain release a small dose of dopamine every time you type "SJW?"
&gt;What is the better way to fix it? What alternatives do you offer? I'll pipe in. How about this? You are not defined by who you find sexually attractive. Furthermore your code has nothing to do with who you are attracted to. When I look at your code I don't say "well this was obviously written by a gay person or a transexual". Git doesn't care about genitals, ruby doesn't care about you sexual preference, and neither do I. But when you shut me out and close yourself off in a small circle you are making a statement. you are saying "I am not like you, you should treat me different and you should treat my code differently". My advice is not to do that. That's just going to cause you more pain in the end. All of a sudden I might be asked to care that the code was written by a transexual and treat it accordingly.
Allies?
I think that the term 'snapshot' was poorly chosen for this survey as it means something very different in other ecosystems, and in fact means something that is NOT locked: https://stackoverflow.com/questions/5901378/what-exactly-is-a-maven-snapshot-and-why-do-we-need-it So anyone who is familiar with this meaning of snapshot (or found it by googling), would not choose it to describe bundler. I also suspect a significant number of the Haskell answers are actually referring to this definition rather than the survey's one, since that seems to be what it means in Haskell. 
Videos in this thread: [Watch Playlist &amp;#9654;](http://subtletv.com/_r6evcyc?feature=playlist) VIDEO|COMMENT -|- (1) [RailsConf 2014 - All the Little Things by Sandi Metz](http://www.youtube.com/watch?v=8bZh5LMaSmE) (2) [Ruby Midwest 2011 Confident Code by Avdi Grimm](http://www.youtube.com/watch?v=T8J0j2xJFgQ)|[+3](https://www.reddit.com/r/ruby/comments/6evcyc/_/didawsx?context=10#didawsx) - I shall start. All the Little Things by Sandi Metz (RailsConf 2014) Confident Code by Avdi Grimm (Ruby Midwest 2011) [RailsConf 2015 - Nothing is Something](http://www.youtube.com/watch?v=29MAL8pJImQ)|[+1](https://www.reddit.com/r/ruby/comments/6evcyc/_/dieb177?context=10#dieb177) - Great list! I'll add Nothing is Something by Sandi Metz (RailsConf 2015) I'm a bot working hard to help Redditors find related videos to watch. I'll keep this updated as long as I can. *** [Play All](http://subtletv.com/_r6evcyc?feature=playlist&amp;ftrlnk=1) | [Info](https://np.reddit.com/r/SubtleTV/wiki/mentioned_videos) | Get me on [Chrome](https://chrome.google.com/webstore/detail/mentioned-videos-for-redd/fiimkmdalmgffhibfdjnhljpnigcmohf) / [Firefox](https://addons.mozilla.org/en-US/firefox/addon/mentioned-videos-for-reddit)
No
kind of a small thing, but `unless ... else` bugs me ... you can just do `if item.empty? ... else` and avoid the double negative
Yes, third-wave progressive leftist feminists can stop holding online seminars called "healing from toxic masculinity", "teach men not to rape" and BLM can do the same with "healing from toxic whiteness". When a movement forcibly pushes its extremist ideology on an industry, with tactics such a doxing, threatening boycotts on a person's employer and the likes, it does two things - it isolates people who identify with the movement from the rest of the population, and it creates an echo chamber by suppressing opposing opinions for fear of repercussion. There is no need for exclusive, isolated groups in tech (such as women who code ^no ^men ^allowed), as an industry, tech is already inclusive, and in fact, most people will apologise and change their behaviour if you tell them that they have offended you, but I, like many others, draw the line at addressing people with ze, zir, xir, schlerr and whatever other silly pronoun anyone wants to invent, if you're a woman and I accidentally call you Sir, Mr, him or he I will apologise and switch to Mrs, Miss, her or she happily, and vice versa. If you really want to attack an industry for sexism, you could try Law, but that wouldn't be very clever now, would it? If you're hosting an event or building a community, can we just make it a tech or programming event/community, and assume everyone with an interest is included, rather than creating these exclusive echo chambers and attacking anyone with a differing opinion, please? // Edit: Spelling / formatting
Not sure if you have had a chance to use this in a project but it's pretty awesome. Follow a few links to the git repository and do a trial build. The amount of time you can save while having some flexibility is very useful. Daniel does a lot to help out the community and his tutorials are excellent. The purpose of the Kickstarter is to bring all the tools up to date with rails 5.1. Access to tutorials, GoRails and Micharl Hartl's site is a bonus. Please take a look and if you think it might be useful support him. No I don't know Daniel or receive anything from the Kickstarter. 
Thanks for posting this. I am very very new to programming and I have dabbled with a few different languages and Ruby is by far my most preferred. I haven't looked much into Rails yet but I can't wait to get stuck in. Backed the 9$ pledge. 
We just had a $850 contribution from an amazingly generous supporter! Just an ordinary developer who wants to keep the project alive for everyone. Open source projects are funny that way. One or two people take up the burden and thousands benefit. In a way, the Kickstarter campaign is not about the funds needed to keep the project going. Rather it's an indicator of support that people want the project to live.
Asking why makes it feels like it's not legitimate to do it in the first place, asking twice makes it feels insisting. Do the two people who asked even really care for an actual answer?
Sinatra is pretty great IMO
This is helpful, thanks. It was tricky to find terminology that worked across all the ecosystems we were surveying (as edwardfingerhands points out below). Maybe a problem is that "snapshot" and "version ranges" aren't strictly mutually exclusive, since you can configure bundler with either a version range or exact number for any particular dependency, and then it would only behave differently when you later ran `bundler update`. So I suppose rubyists may have been answering according to how they configure bundler as opposed to what bundler is actually doing. One of our next steps is to validate what we can by analyzing software repositories, and this question should be relatively easy to get at.
Thanks for actually hearing me. I could have been clearer, but yes. All I want is to be supportive and inclusive. And if there is something that this community can do, I think we should listen. If a bunch of lgbt folks want to get together and code and mix that with lgbt discussions, that's totally cool. I mean, maybe OP is being respectful towards the fact that this is in fact a ruby sub. Not a ruby sub plus gender discussion? I mean, that would just mean OP is respecting the point of this sub. I just want to ask the question: can I (we) be more supportive? Having read this thread... I encourage OP even more in his/her persuite.
As is stdlib?
Why do you perceive the "ze, zir, xir, schlerr" folks as belonging to the same group as people wanting to build this slack community? I see a world of difference between the two, yet they seem to be the same in your eyes. Different perspectives, I guess.
Based on your situation - you seem to be enjoying tech that is to stay relevant longer. I'd recommend choosing something in that accord. **JavaScript** - it's changing so fast, and the tooling is a mess (as already mentioned). Although, I can see it as something that is here to stay, I'd suggest to avoid it :) **Go** - it's popular and has Google behind its back. Furthermore, a lot of software is being written in it at the moment. I can wager that if you knew Golang, your knowledge will be relevant for the next 10-15 years. **Elixir** - It is interesting. It's fun. It will most probably stay relevant in the next decade (based on its close relationship with Erlang). If you'd prefer fun over comfort, I'd suggest giving Elixir a try. And again, I'm seconding it - trust your gut ;)
Wat? Sounds like they didn't correctly understand packaging or components.
 arr = [ [1], [2], [], [3], [4], [5], [], [7] ] arr.chunk(&amp;:empty?).reject(&amp;:first).map(&amp;:last) =&gt; [[[1], [2]], [[3], [4], [5]], [[7]]]
Budget truck rentals still use that shit
That's perfectly fine. I'd rather be deploying ruby projects with rpm than capistrano, personally. But I'd use `bundle --standalone` and package the project along with its dependencies.
I suppose people are asking why and that's a legitimate question, so here's my answer: I work for a software company with ~230 employees. There is nobody in the company that looks like me or identifies as other than their sex assigned at birth. There is one other non-heterosexual person. I wish the company was more diverse in that area although racially it has done a very good job. SO I do what I do best and turn to the internet to satisfy my need to interact with people with similar lives experiences as me. Hence I like to hangout in this slack group because that's the one place in my life where I can chat with people who have lived through a lot of the things I live through. That's really it tbh, we all just want friends we can chat with and be who we want to be. I can't get that irl, so I get it online. I think many people can identify with that (i.e. going online to find a community otherwise inaccessible irl)
In your Developer class, you initialize the names in the constructor to a nil default but then || into a blank string. You might as well make the empty string the default value and assign it directly Edit: actually you seem to do this for most classes. If you're going to do an expanded method definition you might as well use the real default values since you're already essentially doing this in your constructors. 
Keen! Here's a few things that jumped out at me: Developers should implement Enumerable, or not and let folks use the #developer_list array directly, but not both. Currently, you can use [] access by index, but there's no way to know how many developers are in the list, for example. Ditto for the Repositories class. Having a private accessor for @parser just to avoid typing the @ symbol is bad form - the parser *is* an internal variable, keeping the @ makes that clear for literally zero cost. You have both a LICENSE and LICENSE.txt, with identical contents. Skip the .txt version. I prefer gems that wear their dependencies on their sleeves, so I'd suggest adding a Dependencies section to your Readme calling out mechanize as a required dependency, for folks who weigh their gem burden carefully. You have 3 binaries in your /bin dir, none of which really provide value to end users of the gem (who would just launch IRB/pry and require your gem). I'd exclude them from your build rather than including them. If you really thing folks need a console launcher, then at least add pry as a required dependency to the gemspec. Congrats on the gem, and welcome to the wild world of gem publishing! 
I ended up just writing an upstart script. Thanks everyone
Wow, thanks man! Much appreciated feedback.
If there is behavior attached to `Timer::Units::MSECS` I would probably chose that approach, otherwise the symbol which is less typing.
Symbol makes it easier to type and read. Go with that, assuming both function the same way.
Consider what happens when you misspell the symbol or ever want to change it. I tend to encapsulate symbols.
Yes, and the error is never straightforward, it's inevitably some manifestation of the error having propagated elsewhere. Whenever I allow symbols over an interface I'll validate it upfront.
Whether you use a const or a symbol you need to validate the input if you're concern is avoiding difficult to find errors, there is zero difference between the approaches in this regard. Symbols are easier to read than long winded constant names.
Even better would be to use `concat`: developers_list.concat @parser.parse(parse_args).to_a.compact But looking at the code: def get(*args) parse_args = Gh::Trending::Parsers::ParserArguments.new(*args) developers_list.clear developers_list &lt;&lt; @parser.parse(parse_args).to_a.compact developers_list.flatten! end This could just be def get(*args) @developers_list = Gh::Trending::Parsers::ParserArguments.new(*args).to_a.compact end
Hey, I was just wondering about the term "hash syntax" in regard to arguments. Hasn't the official name been "keyword arguments" since Ruby added first level support in 2.0? Not really that important I guess ^^
Get this bot out of here
The special trailing hash argument syntax was never removed, but yeah, looking at the first couple examples in the readme, there is a double splat on `Parsers::ParserArguments#initialize` so I would expect arbitrary trailing hash arguments to raise an exception. Only keyword arguments can succeed.
In `.gemspec`, the boilerplate about preventing public pushes can be removed. This is a public gem with a permissive license so it should be permitted to push it to any gem server. Also in `.gemspec`, if a gem is included among the runtime dependencies, it isn't necessary to include it among the development dependencies. Given the name `gh-trending`, with the dash, I'd expect to be able to load this library with `require 'gh/trending'`. This convention appears in other gems with dash names such as `net-ssh` and `rspec-rails`. Also, I'd expect loading this library to add the constant `Gh::Trending`, and make no other changes to the top-level or `Gh` namespaces. This seems to be the case, so well done matching the gem name to the ruby namespacing.
check nim-lang, it's great language, but has small community
class_attribute default **hooray**! Guess I might need to wait for rails 5.2 for it though, doh. 
Well, as the previous comment stated, the majority of the world is cis-hetero, so it's not hard to find people who have had similar dating experiences or like, chat about crushes and stuff. For example, when I have a crush I can't just assume they could be interested, because chances are, in my environment, they're cis and hetero. So cis-Herero people can find that sense of camaraderie in the workplace or in life in general. Just statistically speaking it's less available for people like me. And I do think it's useful to center the group explicitly on LGBTQ+ so people don't have to figure out if it's "ok" to talk about certain things. We often have to "read the room" for signs that it's safe to express certain thoughts. In this slack group the default is that if it's related to non-normative gender identities it's ok to share. 
Thanks for the feedback!
Thank you!
Thanks, I'm checking for errors because the symbol will define how the object behave.
Any lessons learned from your experience? I looked at graphql for a while and I just couldn't quite connect the dots with what I wanted to do. Something about the query approach wasn't lining up with what I want to accomplish. Perhaps that the querying feels too explicit or verbose. Dunno, sometimes I have to reinvent the wheel to see why it was made round in the first place.
&gt; Possibly, the people that shout the loudest are heard the most I guess, for most people, this is the face of feminism, the people that represent the movement. I don't hear those people shouting, personally. It's an unfortunate aspect of the modern internet that loud fringes get to characterize the movement they stand on the extreme of. Life is a lot better, I've found for me personally, when I take steps to prevent their perspectives from skewing my own. It's a lot easier to get 10k retweets saying really shocking shit than something reasonable.
I haven't gotten around to using it yet. 
Paging /u/FooBarWidget. Check out the description of H2O above. Wanna make Passenger capable of doing that too? I suspect you are already on this. And will make it an enterprise feature, doh, ha. 
By reading the description, it seems incredibly limited in capabilities. Like, in reference to the requirements for the audio file itself. 
An obvious (and still my favourite) one is http://rubyweekly.com/.
Yes, definitely limited. Any feature in particular you're looking for?
Let's have a round of thanks for the great people who spent so much of their time providing that awesome resource!
No, no, I was just browsing and killing time. Thanks though
Httparty is pretty straight forward and it is synchronous, so that's probably why you didn't see any mention n on the docs. If you need more help I'll give you some examples when I get home
The `StringScanner` standard library sounds like a perfect fit for this: require "strscan" scanner = StringScanner.new(text) found_strings = [] loop do scanner.scan_until(/Argentine/) or break string = scanner.scan_until(/marriage/) or break found_strings &lt;&lt; string.chomp("marriage") end scanner.terminate Alternatively, if performance is not hugely important (and it's probably not if the file is only 2MB), you can use `String#scan`: text.scan(/(?&lt;=Argentine).+(?=marriage)/) # returns array of matched strings in between "Argentine" and "marriage", # using lookbehind (?&lt;=) and lookahead (?=) to exclude the boundary words # from the matched results
I'm on my phone still, so this might sound incomplete, your sample looks mostly ok, but your nil is a quirk of httparty which I have mix feelings for: when you get empty responses (http 204, 302,404,403 etc) the response object is nil, but you can still use methods on it, such as #code, #success? I advise you to check for success so your code doesn't break when something unexpected happens. Use debug_output $stdout or stderr to see what it's doing. And don't bother to make your own query string, it does for you: get url, query: hash
It's always synchronous. But I'm REALLY not a fan of HTTParty. 
What, it returns an object that looks like nil, but isn't the ordinary nil singleton, it has methods? Phew, I really don't like HTTParty. It is a mystery to me why it became so popular. 
Thank you. I made the wrong assumption when I said it was async, I was making a logical error elsewhere. 
For the String#scan example, you could add /m (multi-line regex) so it supports newlines too, just like StringScanner example. :) 
do consider using the HTTP gem over httparty. it's much smarter at setting up requests, returns better information, and is faster. 
Curious how you make a custom object evaluate as falsey. Maybe I'll find some time to look at the source, that's a clever trick. Ah, looks like you just [def nil?](http://www.virtuouscode.com/2011/05/30/null-objects-and-falsiness/) as `true`. [yep](https://github.com/jnunemaker/httparty/blob/70030731d9a8e2943019adb5747c5060875fc151/lib/httparty/response.rb#L58-L60). That's probably a bad idea, for reasons the first link goes into. I would not have made it's #to_s and #inspect read `nil` in that case, at least. I would have thought carefully about using that clever trick at all. Is `if response.success?` really so bad? HTTParty is fine (if pretty terrible performance) so long as you only need to do exactly what it intends you to do. As soon as you need to do something unusual, it's a mess. As you discovered. It's also got some thread-safety issues I think. I guess ruby is lacking a well-written well-maintained http gem with good API at both high and low levels. Which is odd, since ruby is used for HTTP so much! They tried with ["http the gem"](https://github.com/httprb/http), I'm not totally happy with it. I tend to use [HTTPClient](https://github.com/nahi/httpclient), but it's not perfect either. 
[Dear people from the future](https://xkcd.com/979/): str = "the dog is running and the fox is running" str.scan /((?:dog|cat|fox) is running)/ #=&gt; [["dog is running"], ["fox is running"]] 
 &gt; default_options.update(verify: false) **Sorry to drop in here and don't add any constructive to the actual topic.** But please, don't do this. The api seems to have a valid certificate and if you do need to skip verification for development or test reasons, consider making it something like default_options.update(verify: !ENV['RACK_ENV'] == 'production') Cheers! 
as much as I hate saying this, datica probably has the more mature capabilities. didnt see anything about heroku handling the adt stuff. 
Awesome. I figured there was probably something akin to `#chunk` but I was looking in the wrong spot (`Array`). This is a clever abuse of the fact that .empty? returns whether we want to reject it. It's feels opposite to what I'd assume is about to happen next. "We want these ones --- TO THROW AWAY!" Neat. For someone wanting a breakdown: subject = [1, nil, nil, 2, 3, nil, 4, "", 5, 6] expected = [[1],[2,3],[4],[5,6]] def chunk_expanded arr # iterate each item. Return the block's result as the first element of a 2d array. # Return the consecutive "sames" as the 2nd element. # Exactly what OP was looking for. arr.chunk {|i| i.to_s.empty? } # =&gt; [[false, [1]], [true, [nil, nil]], [false, [2, 3]], [true, [nil]], [false, [4]], [true, [""]], [false, [5, 6]]] # If the first element is `true` -- drop it. # i.e. if the series was in fact .empty? .reject(&amp;:first) # =&gt; [[false, [1]], [false, [2, 3]], [false, [4]], [false, [5, 6]]] .map(&amp;:last) # Get the remaining elements, dropping the tags for .empty? results. # =&gt; [[1], [2, 3], [4], [5, 6]] } end chunk_expanded(subject) == expected # =&gt; true
Indeed, good catch :-)
Awesome. Thanks! Clever!
&gt;Great, but this is still years away from getting whitelisted. Correct. Where compliance-based workloads are concerned, there is a difference between "standards compliant" and "standards approved". Still, you can't get there without getting here first. This is a big step. 
Aww, shucks. [blush]
second, your API will raise 500 errors and not 404 is the record is not found, for example: task = Task.find_by(id: params[:id]) task.destroy if task is not found, then client will receive a 500 which is pretty much meaningless from their perspective, it just says "the server fucked up". other than that, just two things I noticed while scanning: 1. it seems odd to me that the db connection code should be in config.ru and not the app. 2. The javascript looks a bit soupy, which is typical of sites built with just jQuery and not a framework. Not necessary a bad approach to use just jQuery, since it's easier to get the ball rolling, but it requires some diligence to keep well-organized code. A good refactor would be to contain the app in a single namespace, and split more stuff up into functions. 
It looks like the `finished` property is an integer? That seems weird to me. Wouldn't `finished` be a bool? If it has more than two states, there is probably a better name to be used there.
I have done some refactors. :) thank you for your comment https://github.com/sushant12/rack-todo/releases/tag/7
I appreciate your commitment to small commits and general git/project organization for a single-person project. Solo and learning projects are a good opportunity to build those habits and to test out new workflows. I find a lot of developers do the opposite - massive commits, no branches, etc on personal projects and the same people often have those behaviors leaking into projects "that matter" also. 
I find the presumption that type systems are somehow new and weren't invented when Ruby was coming about to be... hilarious.
Because that's not how Ruby was designed to work. Yes, Ruby uses classes and objects, but Ruby doesn't care what an object IS so much as what it DOES. [POODR](http://www.poodr.com/) is a mind-altering look at how to write Ruby code if you're coming from some other language.
If you are using the letters "a", "b", "c", etc for names, you have much bigger problems than typing. In practice, variables, methods and classes have much better names and you should be able to tell what an Object does without having to know the type at code-time. Additionally, "type" is not always the most important concept in Ruby. In Ruby, you usually care what an object "responds to" instead. It's a subtle difference to someone not familiar with the language but it has a lot of value. It does not matter at run time what the type of an object is as long as it responds to the requesite methods. 
Ok... but what about the OP's post makes you think that they are presuming that? I don't see that presumption anywhere at all in the post, or even any of the comments at the time of writing.
You make it sound like duck typing and static types/type hints are incompatible. That's not the case: E.g. interfaces in Java or type classes in Haskell are a way to "not care about the concrete type" while maintaining type safety. /edit: According to Wikipedia I'm wrong: &gt; In computer programming, duck typing is an application of the duck test in type safety. It requires that type checking be deferred to runtime, and is implemented by means of dynamic typing or reflection. Duck typing is concerned with establishing the suitability of an object for some purpose. With normal typing, suitability is assumed to be determined by an object's type only. In duck typing, an object's suitability is determined by the presence of certain methods and properties (with appropriate meaning), rather than the actual type of the object. The static typing counterpart of duck typing seems to be called structural typing.
I should have qualified this... I am often hearing people in the PHP and JS communities talk about type systems these days, and they generally treat static typing as some new technology that ruby hasn't somehow discovered yet. So my comment was about a broader trend I see, of which the OP might be an example. Regarding the OP, I see evidence that they don't have a command of the tradeoffs of static typing (the question itself is evidence). That _suggests_ that an understanding of the history of static type systems isn't present, but that's just a guess.
So how can I store an exception?
&gt; "text".to_enum(:scan, /regex/).map { Regexp.last_match } Thank you, that looks a bit over my head. Never used map before. But I am reading already. It is good to have an idea to work along. Thanks a lot for that.
&gt; The StringScanner standard library sounds like a perfect fit for this Hi /u/janko-m, thanks for this answer. Never used StringScanner before, read some pages about it today and indeed it looks what I can manage to use. At least I will give it a try. When I am comfortable with it, I will have another tool in my box, which is something I really appreciate. If I find a good solution, I will post it here as well.
Didn't know that, thanks.
I guess, but I think it is not optimal. What are conventional ways in ruby to handle exceptions and avoid repetition? Thank you.
I would not be surprised if it's gone for good now. There were no updates for years and cron job that refreshed stats didn't seem to be working for over a year. These days I'd use something like awesome-ruby or something.
https://youtu.be/qObzgUfCl28
&gt;[**Kaiser Chiefs - Ruby [3:30]**](http://youtu.be/qObzgUfCl28) &gt; [*^KaiserChiefsVEVO*](https://www.youtube.com/channel/UCEGENb0qic-2tdRWP5FRjXg) ^in ^Music &gt;*^26,878,394 ^views ^since ^Dec ^2009* [^bot ^info](/r/youtubefactsbot/wiki/index)
&gt; While your center may offer a one day “birthing” class In my experience, if you sign up for one of these your baby will decide to come the night before the class to troll you.
Why did you ask this question if you're only going to get so snarky with anyone who doesn't answer it the way you came in thinking it should be answered? The answer is not everyone agrees with you that static typing is always best! That's it! You can tell me you think I'm wrong all you want, but that's still the answer to your question. I see your example and I don't think it even comes close to illustrating all the issues in this ongoing 50-year technical debate.
you make it sound as if you cannot have the best from both worlds. I am not saying "ALL MUST BE TYPE HINTED NOW" not at all. 
&gt; you want to have the best from both worlds I can see that point of view. But the Ruby interpreter and language is simpler and more manageable by omitting this feature. Maybe that was a motivation at the time. You can't add every feature to every language. It becomes unmaintainable.
&gt; You and I, we both do not want to go back to static typing. Agreed. But both of us do not want to code without type hinting. A program written using a statically typed language with good type inference ends up looking pretty much like using "type hinting", but you end up catching all errors before runtime. I don't understand why you'd prefer PHP's type hinting to a statically compiled language in this case. The statement "go back to static typing" makes me wonder whether you ever used a language with type inference?
The server seems to have died today. Sorry for that! I set up DNS to a replacement site at https://rubytoolbox.herokuapp.com/ but it's not propagated yet. Next steps should probably be discussed elsewhere.
Lexers are programs that analyze text and break it up into units ("tokens") for analysis. A lexer is what makes syntax highlighting work in your text editor, and lexing is one step in the compilation of source code into machine code. Good luck with your project!
No, but that's a straw man as already brought up. Nobody names things x, a, or b (except maybe in quick throwaway script). The problem with thinking types give you readability and reliability is that that it's dangerous -- in reality, a function probably can't just take in any integer and be meaningful -- instead it really needs (for example) a positive integer between 1 and 10 and you need code to check this in your function whether you have types or not. There is a real reason for declared types, but it is in compiled languages that need it to make efficient code. And even then, the trend these days is for the compiler to guess the types from your code where possible.
Aren't you supposed to post to delete? In your javascript, you should attempt to make your Ajax code more DRY. You create a XMLHttpRequest object very frequently, and then the other associated code. Try to build similar methods so you may reuse them throughout your code. Also look up Single responsibility principle to help organize your code better
Agajn, you argue with shitty name definitions. Using meaningful names for methods and variables is why this isn't exactly necessary. 
You've been the only one arguing this it seems. And while you're right that the latter is more readable, but that's because you're using shit variable and method names to begin with
&gt; Single responsibility principle I will research on it. thanks for the comment, i will fix it.
I dunno, if I had to describe GenX in a nutshell, I might say "impressively angry assholes" :-)
Jeff Foster has done some interesting work in this area with [rdl](https://github.com/plum-umd/rdl). From the README: &gt; RDL is a lightweight system for adding types, type checking, &gt; and contracts to Ruby.
You really should train it too. You'd live a very happy life.
Before you master your first. You don't want the baggage of feeling "ugh if I were just allowed to use x to do this, it'd be done in no time" to weigh you down.
There are two different awesome-ruby listings and I'm not sure which one is "better".
Thank you for the explanation. I will tell you how I got along.
For a second I didn't understand why this was in this sub. And then for another second, I realized not everything has to be about programming to be applicable to a programmer. Unfortunately/fortunately I will not be having a baby anytime soon.
Hello, The universal [feedparser gem](https://github.com/feedparser/feedparser#Microformats) that reads web feeds in XML (RSS, Atom) and JSON (JSON Feed) now supports HTML feeds w/ Microformats ([h-entry](http://microformats.org/wiki/h-entry), [h-feed](http://microformats.org/wiki/h-feed), etc.). Note: Microformats support in feedparser is optional. Install and require the the [microformats gem](https://github.com/indieweb/microformats-ruby) to read feeds in HTML with Microformats. Example: require 'feedparser' require 'microformats' text =&lt;&lt;HTML &lt;article class="h-entry"&gt; &lt;h1 class="p-name"&gt;Microformats are amazing&lt;/h1&gt; &lt;p&gt;Published by &lt;a class="p-author h-card" href="http://example.com"&gt;W. Developer&lt;/a&gt; on &lt;time class="dt-published" datetime="2013-06-13 12:00:00"&gt;13&lt;sup&gt;th&lt;/sup&gt; June 2013&lt;/time&gt; &lt;p class="p-summary"&gt;In which I extoll the virtues of using microformats.&lt;/p&gt; &lt;div class="e-content"&gt; &lt;p&gt;Blah blah blah&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; HTML feed = FeedParser::Parser.parse( text ) puts feed.format # =&gt; "html" puts feed.items.size # =&gt; 1 puts feed.items[0].authors.size # =&gt; 1 puts feed.items[0].content_html # =&gt; "&lt;p&gt;Blah blah blah&lt;/p&gt;" puts feed.items[0].content_text # =&gt; "Blah blah blah" puts feed.items[0].title # =&gt; "Microformats are amazing" puts feed.items[0].summary # =&gt; "In which I extoll the virtues of using microformats." puts feed.items[0].published # =&gt; 2013-06-13 12:00:00 puts feed.items[0].authors[0].name # =&gt; "W. Developer" ... Happy publishing w/ web feeds. Cheers. 
I think it really don't belong here. If it's related to programmers, fine. But Ruby subreddit? Even Rails posts are "encouraged to be posted in the r/rails subreddit". I don't come here to read on pregnancy, sorry.
The main issue, as some have already hinted, is that an object type doesn't really tell you anything about what that object actually does. Methods are not attached to classes, they are attached to objects and they can be modified at runtime, so knowing an objects type is quite useless actually because it's​ not telling you any definitive thing about the actual methods on the object.
And by the way, this is been discussed in the Ruby bug tracker already: https://bugs.ruby-lang.org/issues/9999
What kind of ruby would you write?
Looks much better. How do you feel about it? As for your last question, I wouldn't say it is necessary. Just keep like functions and variables together. I would add comments to code that edits the dom... or even move that to its own function with a descriptive bame. I love code that documents itself. 
The current code base is busted beyond repair, but yes - essentially I've been intending to build a nice and shiny open source version for years now to take away the dependency on me, but I simply could not find the time to pull through with it. I'll take the outage as a kind reminder I should take care of this asap!
As one of my kids said once, "Daddy where's that book 'Learn to Pine' by Chris Program?"
First, if I could get away with it I wouldn't check for types at all. If it works it works, duck-type. There's no end to defensive programming, checks are for borders. Second, I'd consider why these checks needed to be factored out. Why not a single if x.is_a?(Thing)? Is it being performed in multiple methods within the class? Is it for use in all initialize methods, all the time? Does it matter that it checks the arguments before setting instance variables? After determining that it was really necessary and that it needed to be factored out, depending on the situation I'd probably write a mixin that generalises these checks across multiple variables and could be used across different classes. A bit like validations in Rails. Maybe something like this: module VarChecker def self.included(base) base.singleton_class.send(:attr_reader, :check_vartypes) base.instance_eval do def checks_vars(vartypes = {}) @check_vartypes = vartypes end end end def check_vars self.class.check_vartypes.each do |varname, expected_class| var = instance_variable_get("@#{varname}") raise ArgumentError, "#{var} is not a #{expected_class}" unless var.is_a?(expected_class) end end end Then I'd use it like so: class Rubyist include VarChecker check_vars name: String, age: Numeric, type: Symbol def initialize(name, age, type) @name = name @age = age @type = type check_vars end end Rubyist.new('abc', 1, type: :pragmatic) # =&gt; ArgumentError: {:type=&gt;:pragmatic} is not a Symbol
I feel like i am passing a lot of local variables in another functions as parameters. Is there a way to avoid doing that? It makes my code very coupled with that function.
Why in the fuck is this here...
He prefaced it with "it feels like." I dunno, it read more like a comedian doing a venting bit. It's not the kind of sentence that bothers me, because it's obviously said in jest. I'll concede that it might take a lot more to put me off than most.
&gt; but having a pre-runtime check for correct types would fit my definition of "static typing", ¯\\\_(ツ)\_/¯ The OP and Chris' comment was about type hinting, which Matz has repeatedly said he'll never add to Ruby. Fair enough that static typing can include type inference.
&gt; You should consider this gem if you want your page to load up faster, so your users don't wait for all the data to be fetched synchronously. Will this perform better than moving the large datasets over to an AJAX call? &gt; Or if you have a piece of code in your controller that takes down whole page when it breaks. That sounds like a bummer of a problem to have, but it also seems worth fixing, rather than band-aiding. Frequently -- and actually more frequently than this non-rails rubyist would like -- new rails features come up in /r/ruby. I have been noticing a pattern lately that a lot of these features are attempts to provide crude workarounds for problems that don't need to exist in the first place.
That's pretty much the best way I've seen it done, personally. I dig it!
What are you expecting to see instead?
This imgur album only contains 1 image! Here's the direct [link](https://i.imgur.com/3sLQrfo.png) --------------------------- *I'm a bot! [Contact](https://www.reddit.com/message/compose?to=theo65_theo01&amp;subject=ImgurAlbumsAreSlow) | [Delete](https://reddit.com/message/compose?to=ImgurAlbumsAreSlow&amp;subject=Remove&amp;message=This+is+only+available+for+the+creator+of+the+post.+If+you%27re+not+the+creator+of+the+given+post+your+message+will+be+ignored.+Spammers+will+be+blocked+and+reported.%0A%0ASubmission+id%3A+6g230n%0A%0ASubreddit%3A+%2Fr%2Fruby%0A%0APermalink%3A+https%3A%2F%2Freddit.com%2Fr%2Fruby%2Fcomments%2F6g230n%2Fcan_someone_explain_why_do_i_get_this_page_every%2F%0A%0AReason+%28Optional%29%3A) | [Ban](https://reddit.com/message/compose?to=ImgurAlbumsAreSlow&amp;subject=Ban&amp;message=This+is+only+available+for+subreddit+moderators.+If+you%27re+not+a+subreddit+moderator+this+message+will+be+ignored.+Spammers+will+be+blocked+and+reported.%0A%0ASubreddit%3A+%2Fr%2Fruby%0A%0AReason+%28Optional%29%3A)*
Thanks for taking the time, noted.
Point 2. tells you what to do: Set up a root to replace this page. [Rails Routing from the Outside In](http://guides.rubyonrails.org/routing.html) - find root on the page, google rails root &gt; So frustrating. Every time I try to learn a new language I get sidelined by trying to just run something. I am afraid this is exactly what learning new language means. Learning new stuff is not easy. Hope this helps. 
There's another post that said it pretty well https://www.reddit.com/r/ruby/comments/6fuby1/the_programmers_guide_to_pairing_on_pregnancy/dim5rl8/ Within reason I don't think it's up to a poster to censor themselves. I write for programmers and about programmers. I post to Ruby because that's the community I target with my writing. I'm deeply embedded in the Ruby community and I want them to succeed not just in technical tasks but in life. Even with technical articles some may be applicable or not to you. Not everything has to be for you. I've given plenty of talks where afterwards in the same talk people will tell me "that was too technical" and others say "that was way to simplistic, you should have made it more technical". Also FWIW this sub is way more active and generally better than /r/rails in my experience. Reddit (the software) doesn't do a good job of making it easy to get your posts to the most applicable places. I think this is something the system could do much better at. i.e. better cross-posting mechanisms or the ability to move posts to more appropriate subs, or better tools for suggesting good places to post. As it stands users are rewarded generally for posting to a large number of places and seeing what sticks. I appreciate your comment and your feedback. I knew this post was pushing it when I wrote it and when I posted it. I generally average around 20 or so points for most of my stuff, and you can see this didn't do nearly as well, however it's still liked a little by enough people (70% of /r/ruby voters as of now). If you have a better suggestion for places where this post could be well received, that would be appreciated. 
**Here's a sneak peek of [/r/rails](https://np.reddit.com/r/rails) using the [top posts](https://np.reddit.com/r/rails/top/?sort=top&amp;t=year) of the year!** \#1: [Rails 5.0 has been tagged for release!](https://np.reddit.com/r/rails/comments/4qofer/rails_50_has_been_tagged_for_release/) \#2: [19 Ruby on Rails Gems which Can Amaze](https://np.reddit.com/r/rails/comments/656fhc/19_ruby_on_rails_gems_which_can_amaze/) \#3: [My 'Learn Ruby on Rails' book now free on Google Play](https://np.reddit.com/r/rails/comments/5lqek4/my_learn_ruby_on_rails_book_now_free_on_google/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Rails routing. Google exactly that
the first answer from Enumerable_any I disagree with. yes you can throw an error and "implement type hinting manually". Like the homeless man's type hinting. Like he gave in the example. But that voids the value type hinting adds. It is not that you have runtime error throwing (that is just added sugar). But you can now write code in your IDE knowing it will work. You can read code and understand it because you can follow the references "what interface is it", "what objects implement this interface". I spent days if not weeks reading a nodejs app. It was a bloody mess. You didn't know at all what objects were getting called. In _each_ function. Each function call was a fucking "hmmm well I guess I just run it and debug it at runtime to _guess_ what an example of an object used in this function might be like". Exactly, an example of object. Because in a different fucntion call, it is a different object maybe. You can refactor, say class names, function names, function arguments, etc (there is no end to this, say u have an error on Foo.bar(), if type hinting is used through your app, you can more easily find most calls to Foo.bar() and estimate what damage has been done), more easily, because your IDE will detect most references automatically. "well but I can throw an error manually in each function call" well yes, but none of the big advantages type hinting is about, will get something out of this. It isn't about the runtime thrown error. But of course: if you use windows notepad to edit your files, you won't have advantages from using type hinting. 
the homeless man's type hinting. Don't get me wrong, docs is better than nothing for sure! I understand, but that wasn't the question. The question was "why not" and the answer was probably "python php javascript all didn't have it neither, because nobody thought of it when they came up"
angry? why?
it wasn't meant as an insult. You have to understand, I came to the ruby forum, basically saying "I love type hinting, why do you guys do not have it?" and guess what, everyone says "meh meh meh, we don't need type hinting" but nobody was able to explain to me why not. In contrary, people started saying things that made me think that they do not even understand the benefits of type hinting. I expanded my question, because initially I thought people just know what type hinting is about and what benefits it brings. 
You've had enough. Not going to feed you any more today.
You just want something an IDE recognizes, use yard-formatted comments and get an IDE that recognizes them? yard argument formatting lets you specify types in a variety of ways. And is pretty standard. I don't know if there's anything for SublimeText that will do anything with them. Maybe RubyMine will? [looks like maybe](https://blog.jetbrains.com/ruby/2011/04/what%E2%80%99s-mining-advanced-yard-support/) If you're trying to make a case for adding PHP-style type-hinting with runtime checking to ruby, I don't think you're going to convince us, and it doens't matter anyway unless you convince Matz. :)
matz is already convinced, see in the thread. 
The issue is here: "I am just assuming that type hinting is better for me, because I know it and I love it." Your previous post question(s) were answered. It just seems like you didn't like them.
A few thoughts (after reading your original post): - For starters, nothing will save you from writing terrible code. If you're having to validate dozens of method invocations at the call site, you're doing something wrong. - I suspect "The Ruby Way" of fixing the problem would be to isolate the validation logic in an Email class. In that case you wouldn't have dozens of call sites to fix; you'd just fix the (one) data validation site. - Barring that, you don't have a ton of options: - You can always grep for the relevant method invocations. In practice, this works quite well when paired with good, consistent code review. - You can implement protections at the database layer (e.g. by setting the columns to non-NULL) and then consult the app logs. - You can write new automated tests or extend your existing ones to surface the error. As an aside, there's nothing in principle preventing an IDE from searching a Ruby codebase for instances of an object or method. Fundamentally, I think your complaint is about tooling more than about the type system. (Although strong static type systems make it easier to write that sort of tooling, without having to resort to heuristics.) --- Regarding your original post... Ruby was originally developed before the modern idea of gradual typing had taken hold, and in many ways was a reaction against the unnecessary pomp and circumstance of verbose type systems. (I'm looking at you, old Java.) Most apps, certainly your typical business app, don't need all that crap—jettisoning some type "safety" in exchange for a 3-4x up-front productivity and hiring boost is well worth it. Nowadays, expectations have shifted. Developers and businesses expect both productivity _and_ compile-time type assertions. I would expect Ruby to either adopt features like that in the future or die. --- Lastly, I'll just note that I've programmed professionally for 15+ years in a variety of languages—Python, Perl, PHP, Go, Java, and C, at least that I can recall. Flame wars like your last post just reek of n00bness. Just use the right tool for the job, taking into account _all_ the issues that go into defining "right" (short- and long-term productivity, hiring, time and performance constraints, "beauty", etc.).
So, what is your goal here, just like to argue? I'd be shocked if what Matz is interested in is anything like PHP's type hinting. I've never heard anyone suggest before that the primary value of type hinting is IDE support, but if that's what you want, specially formatted comments can do it with an IDE that supports. The widely accepted Yard doc format has machine-readable arg-type comments, and apparently RubyMine does at least something with them. Check it out and see what you think? If you want it to do more, suggest it to RubyMine? No matter what's in the language, you only get IDE support with an IDE that supports em. Since you can already get arg type annotations suitable for machine-readability with yard comment format, I think an IDE that does something with em is your bigger barrier. 
Can't you get the same performance benefits on the server side by using threads (assuming you use JRuby or the code is mostly I/O bound)? At least that's how I dealt with external services in the past and it works pretty well. Besides that: You should always account for external services being down and fail gracefully. You can't ignore this with the AJAX approach either. Most of the time you want to display some kind of message if the AJAX call failed. To be fair: In Ruby it's pretty hard to figure out all exceptions an HTTP request can raise, JS makes this easier.
thanks sprayAtMeBro :D it wasn't meant as flame war. Btw java coders are equally ignorant like ruby coders it appears https://www.reddit.com/r/java/comments/2lezw9/why_is_dynamic_typing_so_popular/cluczo6/ (this was not even the top answer) it was an honest post to understand if there is something in ruby i dont know about. and as far as I understand your point, you are saying yourself this is a shortcoming of ruby. So it is generally considered a weakness of a programming language to not have that it seems to me. Can we agree on that?
&gt; Can't you get the same performance benefits on the server side by using threads Probably, but I didn't want to use threads in my use case. &gt; Most of the time you want to display some kind of message if the AJAX call failed. With render_async you can do just that. You can render a partial that explains why an external service failed. AJAX call that contacts action responsible for calling external service will return partial with external service data or with a explanation on why it failed to deliver.
Why do you need magic? Just accept and adapt. Sometimes the simplest and tedious are the solutions. Nothing is stopping you from developing helpers to do what you want if the solutions given isn't magical enough for you.
I don't need magic. I just thought: maybe there is something I don't know about. Because as far as I know, javascript creators negated themselves of implementing type hinting as well. There was a fight about it afaik. And many devs left after the decision was made to not make type hinting happen. But someone must have had a reason to reject it. 
&gt; it is generally considered a weakness of a programming language to not have that it seems to me. It depends on the use-case. If you're writing code for an airliner that will have to survive in the wild for 30 years, then it's a deal-breaking weakness. If you're writing utility scripts to munge database records, then it probably doesn't matter or actually helps you be more productive.
You can use [appscript](https://github.com/mattneub/appscript) to talk to System Events and send keystrokes that way. It's kludgy and somewhat unwieldy, but it does work for the most part. [ASTranslate](http://appscript.sourceforge.net/tools.html#astranslate) will also likely come in handy to help with translating AppleScript commands to Ruby statements.
Not for keypresses, but Puppet also ships as a gem and can be used on macOS for all kinds of automation. What are you trying to do, more specifically?
&gt; What has become out of the golden age, where people do know about interfaces? &gt; It feels like the ruby coders think they are sitting on a noble throne, while in reality they are just mad men, sitting naked on a pile or donkey shit. &gt; It is just that you don't understand it yet. Even matz understands it &gt; If you cannot tell the difference, well, I am really really sorry for you, nothing I can do to help you. &gt; if you would understand about the benefits, there would be no argument &gt; you seem upset. I didnt mean to upset you. Have you read through the thread? &gt; I have been writing code since 1995. None of this contributes to the discussion, but only serves to attempt to demean the audience. If you don't get why that's off-putting and detrimental to open dialogue, then I'm really really sorry for you, nothing I can do to help you. Also, you need to work on your English. 
Thanks for all the answers I ended up using JRuby and Robot from awt :)
You should make a post detailing what you did.
I am not a rubyist but I can google... [It means all the declarations that follow within the class scope are private](https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Classes#Private) EDIT: Excuse me for being a bit of an ass. I went back and reread the code. The private method is in the scope of a module and is followed by a class, so we are to assume here the class is being made private. Why make this assumption -- consistency. If Ruby does anything else in this case then it's garbage (and sense it's not garbage we can safely assume the behavior). [This talks about it a bit more](https://stackoverflow.com/questions/3496291/private-class-not-class-method-in-a-ruby-module). As noted in the SO, this is a product of there being no such thing as a "class" in ruby and instead everything is an object (I think this is a product of all run-time compiled languages but ask someone smarter). This is very similar in python and javascript. 
Depends on what you want to optimize for. TTFB (time to first byte) is obviously faster if you skip rendering half of the page [1], but TTLB (time to last byte) is slower because you pay latency twice and pay overhead for each request made (HTTP parsing, authentication, authorization, logging, ...). [1] Streaming might help lowering the difference between server-side data fetching and the AJAX approach.
the class that follows after the private keyword is instantiable, https://github.com/sinatra/sinatra/blob/9bd0d40229f76ff60d81c01ad2f4b1a8e6f31e05/test/helpers_test.rb#L596. so i am confused why even use the private keyword there
Do you by chance have any idea how such a pre-runtime check might work? I'm curious.
This does look like an "error" to me. At least if the goal is make the AcceptEntry class not accessible to the outside world. You can just fire up irb and check: require "sinatra"; Sinatra::Request::AcceptEntry - works. The way to enforce this is to declare the class and then add a line that reads "private_constant :AcceptEntry". To be honest, I haven't really understood why the private keyword doesn't work on constants. I have seen this erroneous assumption a couple of times (also had it myself), or rather, that people just choose not to set the visibility of their constants and inner classes. For a popular framework, having the internals actually not be exposed would be a good thing in my view. You could create a PR fixing this if it bugs you.
Again, this is probably outside of my space of understanding but it seems superfluous and you seem to be answering your own question. Then follows, are you asking why have it there in light that it does not appear to actually make the class private? The only two general conclusions are that it's either boilerplate (as you notice most the other modules do have private methods -- and I looked at history to see if it's a relic of private methods but no). Likewise it could be boilerplate in that it's there if private methods are ever needed. The other case was put their either because they thought it was making it private (seems unlikely as the tests appear to have always been there) or it is assumed the consumer will not need to call it directly, so it works like a comment. I am not completely sure but I think this is what the SO comment is suggesting in the second answer where he gives a number of ways to actually make a private class and the general challenge. &gt; Really the only way to get actual privacy or encapsulation is using local variables and closures, though. I think this again goes back to the object issue mentioned (but might have to do with weak typing too). Which is that unless you do that closure, you got objects dangling and you can always get into those objects in some dirty way. The test, makes sure the functionality is appropriate but I would guess the consumer never calls AcceptEntry.
ya I should probably send a PR
Im writing on my blog ill post it here when its up 
Nope. Maybe ask @chrisgseaton on Twitter.
Someone asked me how I implemented that, and ultimately there are more Rails-specific bits than just "using hopscotch.js", so I thought I would share it here. Happy to answer any questions that may pop up, either here or on the gist directly.
This is why I enforce prefixing individual methods with `private` &amp; `protected`....
Thanks for pinging me.
Look, my comment was nothing against you. If anything I always like your *tech* posts. I just feel that the idea of curating small subreddits like Ruby is exactly to avoid postings like this. &gt; Even with technical articles some may be applicable or not to you That's a very poor argument I think :). Otherwise all could be one Reddit no? Imagine that every Ruby programmer would post here one life post once a while... and you can pretty much cancel the page.
I've been using [feedjira](https://github.com/feedjira/feedjira). (in http://rubyland.news for instance). Curious if you were aware of that gem, and if you have a compare-and-contrast, what motivated starting fresh. 
You say this now but once you actually fix the routing you'll be flying along having your code work great. Power through now and you'll have a great time soon, I promise.
It looks like a leftover, but not a bug. It is reintroduced [here](https://github.com/sinatra/sinatra/blob/a58834812b455101111ef332c7510bc9083c30d0/lib/sinatra/base.rb#L172). It does not affect methods defined in nested scopes.
Oh no. :c I know it can be frustrating just starting out, but if you stick with it things will start making sense (well, more sense anyway). Starting out I was in a similar position. I'd read guides and eventually be able to understand all the individual words on the page, but all together they made no sense to me. It wasn't until an intro to programming course in college that things "clicked" for me. It may take a bit to find what makes it click for you, but I'm sure there's something out there that will do it. To your points. No, you're not retarded, programming is hard and the entire industry sucks at helping beginners. Someone else has had issues doing this, they just didn't write about it. Now is not a good time to become a trucker, robots are gonna take yer jerb in the next decade. So, you're trying to get practice code from App Academy running. Let's work with that. Did the practice code come with any screen shots or a `README` file? Any instructions about what it's supposed to look like? I want to get an idea of what the code is supposed to be for so I can help point you in the right direction.
&gt; Practical Object-Oriented Design in Ruby That's not really about learning ruby, it's about learning proper OOD for someone who already knows ruby?
Thanks for rubyland.news. Yes, I know feedjira. feedparser itself is not "new", that is, it's 2+ years or more (in the early days the gem was called feedutils). What's different? feedjira as you sure know better - as a happy user I assume ;-) - is more than a parser - it fetches your feeds and was quiet "opinionated" I suppose e.g. using curl with a c-extensions for fetching? In contrast feedparser is a feed parser - no dependency on fetching feeds on purpose (by design) - also the feedparser uses "simple" structs for the feed model e.g. feed/item/author/tag etc. and "normalizes" the different feed formats. For now feedparser uses the stdlib for RSS and Atom (feedjira uses nokogiri/saxmachine or something?). The idea was to keep it easy to install (e.g. no c-extension). To conclude if I dare to say (I'm biased, of course) - feedparser is more lightweight with a focus on feed structs. And now, of course, feedparser supports more formats e.g. JSONFeed and Feeds in HTML w/ Microformats (h-entry/h-feed), etc. Cheers. PS: feedjira in version 4.0 is trying to move away from fetching feeds and might add JSONFeed sometime ;-) In contrast feedparser might switch (optional) to using nokogiri for xml parsing (w/ c-extensions) in the future. So both can learn from each other somehow ;-)
I see what ya did there 😉
I don't know the choices Ruby interpreters have made but I will try to illustrate how languages in general handle closures with examples in Ruby code. Firstly lets take a simple method with a local variable: def counter n = 0 end When we call `counter` it might allocate a local variable and store 0 in it (or allocate an object representing 0 on the heap and store a reference to it in `n`'s location). When the method returns, that variable will be cleaned up (and any no longer referenced heap objects will be eventually garbage collected). For a closure, we want the `n` to be shared between the method and the closure, and to potentially outlive the method it's defined in. Here's an example of that: def counter n = 0 proc { n += 1 } end c = counter puts c.call # =&gt; 1 puts c.call # =&gt; 2 One way to do this is for the language to spot you've closed over `n` and rewrite it to something like: class Closure attr_accessor :n def call self.n += 1 end end def counter closure = Closure.new closure.n = 0 closure end Now the `n` is stored as part of the closure and it's lifetime is no longer tied to a local variable in `counter`. Of course, now the lifetime of `n` is tied to the closure which means it can only be referred to by that single closure (and the method that created it). If we wanted something like: def counter n = 0 [proc { n += 1 }, proc {n += 2}] end one, two = counter puts one.call # =&gt; 1 puts two.call # =&gt; 3 puts one.call # =&gt; 4 then we need to keep the environment separate from the closure itself. This might be turned into this instead: class Env attr_accessor :n end class ClosureOne def initialize(env) @env = env end def call @env.n += 1 end end class ClosureTwo def initialize(env) @env = env end def call @env.n += 2 end end def counter env = Env.new env.n = 0 [ClosureOne.new(env), ClosureTwo.new(env)] end A third approach is to only allow read only access to the variable in the closure and just pass a copy into the closure object: class ClosureOne def initialize(n) @n = n end def call @n * 2 end end class ClosureTwo def initialize(n) @n = n end def call @n * 4 end end def times(n) [ClosureOne.new(n), ClosureTwo.new(n)] end two, four = times(3) puts two.call # =&gt; 6 puts four.call # =&gt; 12 This is less useful but it's the approach taken in Java. This is why all closed over variables in Java have to be declared `final` (readonly), to avoid exposing the fact that the closures have independent copies of the variable. This isn't completely useless as those readonly variables can be objects which can be mutated, but it's not as flexible as the other approaches.
The middle finger one made me laugh - that and the broken link one are pretty good. There's actually an artist which used the broken link as their album cover https://nmesh.bandcamp.com/album/web-timeout-ep
Eloquent Ruby and [The Well Grounded Rubyist](https://www.manning.com/books/the-well-grounded-rubyist-second-edition) are the books I used to teach myself Ruby. I think I went WGR first, then Eloquent Ruby, but they were both in the same couple weeks.
So glorius &lt;3 Just send the user input to your objects, at least it's more prededictable than eval! 
You should definitely report this to [jruby/jruby](https://github.com/jruby/jruby), it will be very helpful for them that you already have a minimal example that reproduces the issue.
Have you run "bundle install" ?
&gt; For something more similar to the link you posted try learn ruby the hard way https://learnrubythehardway.org It is fucking awful. It's basically "how to code ruby as if it was python" and completely misses the point.
It looks like the project was active in the past few months. Maybe open a GitHub issue asking for a Quickstart to be added to the readme.
You're right. I thought about it after the fact. You're certainly right. 
Hello, the notes from last night's Vienna.rb talk titled "Meet Jason Feed - The Future of News (Facebook &amp; Co) w/ Web Feeds (Ruby Edition)". All about Web Feed Formats in XML (Atom, RSS), JSON (JSON Feed), HTML (Microformats w/ h-entry/h-feed), TXT (Feed.TXT w/ YAML &amp; Markdown) and more. The message &amp; conclusion: Live and let live! The more formats the better! Let the computer (e.g. feedparser gem) handle the reading of feeds. One gem to rule them all! All your base are belong to feedparser ;-). Cheers.
Basically I write down what I need to do, do it all then test it works via test suite and/or manual testing. If possible I try to do some boyscouting to clean up stuff that's already there and/or remove duplication. I haven't been a rails dev for a long time, but I used to use rinari for emacs which let me switch between controllers/views/models with a keyboard shortcut (even if I didn't have the files open) so I didn't need to worry too much about context switching.
Some time ago I wrote a blog-post how I approach big refactorings/changes by using bookmarks to remember about all the code I plan to touch: https://medium.com/planet-arkency/how-i-use-bookmarks-in-rubymine-5d79bd655e17
I think there's a point where it becomes muscle memory. To begin, you may need to consciously write down a list of tasks like: * Add bacon attribute to food - generate migration with bacon - permit bacon attribute in controllers - update new, show and edit pages to allow user to edit bacon attribute on food - update model and integration tests to cover off this new wild world of bacon After doing things a few hundred times, you still need to write something down, but instead of being as explicit you'll implicitly know what needs to get done when you just write 'add bacon attribute to food'. Being a few years into Rails, reading your post made me remember just how many steps there are to get the hang of!
/r/learnruby Might help to see some code. What message does heroku give when it "breaks"?
&gt; Things like class diagrams, data models, and process flows, are going to let you easily see how everything is connected, and you'll be able to plan what changes are needed where. Great! Any suggestions on where to get started learning this stuff?
Not really the issue at hand, `private` nor `protected` work on classes. class A private class B; end end TypeError: nil is not a symbol nor a string from (pry):2:in `private' class A private class B; end end $&gt; A::B =&gt; A::B The correct way to do this: class A class B; end private_constant :B end $&gt; A::B =&gt; NameError: private constant A::B referenced
That format looks like `ini` to me. I would split the input into records then run them through https://github.com/TwP/inifile. You'll have to do some cleanup like removing the @ symbol and parsing the multi-value fields (ini doesn't have arrays). That will get you the structured data, then you just need to transform it to your desired output format. I'd just write the output as csv using `CSV` from the stdlib which excel should be able to read without issue. If you want more structure around the process, you can use something like Kiba: https://github.com/thbar/kiba This should get you started: require 'csv' require 'inifile' records = File.read('input.txt').split(/(#.*\n|\*+\n)/).each_slice(4).map do |r| data = Hash.new { |h,k| h[k] = Hash.new } IniFile::Parser.new(data, '=', ';#', 'global').parse r[2] { file_name: r[0].strip, comment: r[1].strip, data: data } end puts records # TODO data transform, cleanup and convert to CSV...
Okay :D I'ma give this gem a read, and see if it can help me with syncing my ENVs to Heroku. ( I had no idea that they weren't deployed along with everything else, I'm really new to coding ). 
In jruby the Ruby backtraces aren't the real callstack since it's converting to bytecode which then goes through the JIT. As a result if you want Ruby backtraces it has to maintain them separately which has a performance overhead. In a lot of cases if they can detect a backtrace isn't used they will not maintain it to avoid the performance hit. I haven't really kept up to date on this problem but I as I recall there were a bunch of issues related to edge cases of this optimization on their github repo. It also could be something else but sounds like the same thing.
@moomaka : Thanks a ton for your guidance, Is it possible to arrange or structure the data without the ini format ? Also the commented lines and the empty lines can be ignored. Thanks again for your help.
OMG THX. That just saved me, I have been trying to set them for like an hour now !!!!!!!!!!!!! Thx a lot 
I added an edit to my post above which you may not have seen, it should provide the basic input parsing needed. Let me know if there is something with that which isn't working for ya.
&gt; `require: cannot load such file -- capybara/dsl` This indicates that [Capybara](https://github.com/teamcapybara/capybara) (a Ruby library, which are referred to as "gems") is missing. Make sure you have Ruby installed, and that you have the `gem` command installed. Once you do, run `bundle install` inside the directory you extracted those files. If `bundle` is missing, just type `gem install bundler` and try again. This should manage all the dependencies you need. The reason we know you need to run this is because the project includes a Gemfile, which is used by bundler to know and install the dependencies you need. Alternatively, `gem install capybara` should also work for you, but you may continue to have issues unless you install all the required dependencies manually. &gt; `applier.rb:121: warning: key "How did you hear about this job?" is duplicated and overwritten on line 127` This indicates that there's a hash (I think they are called dictionaries or associative arrays in other programming languages) with a key defined twice. The error indicates where the duplicate is located. It is a warning, so this shouldn't make your application error out. I hope this helps you out, and good luck finding a job!
In my case I have more than 1000 entries separated by series of * , any idea how to split that. I have mentioned only 4 entries in the question. I'm really sorry If its an annoying question , I'm very new to programming and ruby so taking time to solve it.many thanks
Write tests. Tests are supposed to fail while you're coding. That's what they're for. Use git or some other version control and review the changed files (github pull requests are especially good for this).
Thanks for the information. I don't know as much about the inner workings of JRuby.
I did and I got some errors. http://paste.ubuntu.com/24824933/
When I run bundle install I get the following output: http://paste.ubuntu.com/24824933/ When I run gem install capybara I get the following output: http://paste.ubuntu.com/24824943/ Thank you for the help and encouragement. If the solution is found I will keep this post on here so others could use it as a reference. 
You're awesome. I also have Windows and OSX at my disposal if needed. Were you able to get this working on OSX completely? If so what did you do? Unfortunately installing build-essential did not solve the problem. It did however put this at the bottom of the bundle install command which is different than the one above slightly. http://paste.ubuntu.com/24825180/
I just checked the second link above and the console logs a 500 response. That means something went wrong with the app (server side issue). Without seeing the codebase there isn't much we can do but guess.
Something like this should work, although it's rather hacky require 'csv' require 'inifile' def transform_data(data) groups = data.delete('groups').map do |k,v| values = v.split(',').map(&amp;:strip).map do |v| # IniFile has a bug in it's parser that doesn't handle `\\n` and similar escape sequences correctly v.gsub(/[\n\r\0\t]/) do |char| case char when "\0" then '\0' when "\n" then '\n' when "\r" then '\r' when "\t" then '\t' end end end [k, values] end.to_h data.flat_map do |endpoint, attrs| attrs.flat_map do |cluster, access_level| c = cluster.gsub('@', '') groups[c].map do |id| { cluster: c, id: id, case: endpoint, access_level: access_level } end end end end records = File.read('input.txt').split(/(#.*\n|\*+\n)/).each_slice(4).flat_map do |r| data = Hash.new { |h,k| h[k] = Hash.new } IniFile::Parser.new(data, '=', ';#', 'global').parse r[2] file_name = r[0][/(?&lt;=\/)[^\/]*(?=-values\.txt)/] transform_data(data).map { |d| { file_name: file_name }.merge(d) } end CSV.open('output.csv', 'wb') do |csv| csv &lt;&lt; records.first.keys records.each do |hash| csv &lt;&lt; hash.values end end 
Look up rails routing. You have a bunch of routes in routes.rb that can be removed and replaces with resources :items
I pulled and built his code myself. Only thing I changed was the ruby version in the gem file from 2.3.3. to 2.3.0 (that's what I have installed). Works fine for me... /shrug
Are you trying to go directly to localhost:3000/items/index in order to get to the index page? If you are, that's the issue. items/index will match with the index/:id route for the show action in items_controller. Then the params[:id] will be "index" and you'll fail to find it. If you want to see the index page for the items, go to localhost:3000/items.
I seriously hope these are not your real credentials: https://github.com/chc544/justsmurf/blob/master/.env If those are your real credentials, you need to invalidate them and/or close that account ASAP, it's likely already been scraped. You need to take a step back and learn the basics before you consider implementing payments for anything, you're setting yourself up for a royal fucking mess.
I had to do something like this recently and the most reliable solution was brute forcing the language of the input. Go through a few dozen input examples, manually catalogue where the pertinent data comes through, and write your program to find the break points. Write language conversion CSVs if necessary. Save the relevant data in an array, then convert it into whatever the end result needs. 
Look at my other comment.
alright thanks a lot
Thanks, I'll try to fix it
the code is here https://github.com/chc544/justsmurf the env vars are sandbox credentials, so no need to worry
Video linked by /u/sirunclecid: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Installing Ruby on Rails 4 - Ubuntu 14 - Postgres 9.3](https://youtu.be/JAgS_Pm5Bno)|SirUncleCid Dev|2016-01-20|0:14:19|3+ (100%)|408 &gt; This video shows for you a tried and true installation of... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/sirunclecid ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=diqmhjs\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.1b
Ah, I see the problem. The wiki says "PLEASE DON'T SUGGEST ANYTHING BELOW VERSION 5" but the error says: &gt; Project ERROR: capybara-webkit does not support Qt versions greater than 5.5 [Just install Qt4 and you should be golden](https://stackoverflow.com/questions/11354656/error-error-installing-capybara-webkit). To be sure, make sure you uninstall Qt4 first, just in case. `sudo apt-get install qt4-dev-tools libqt4-dev libqt4-core libqt4-gui`
I don't think you should have run `sudo gem install appraisal launchy mini_magik rake rspec selenium-webdriver sinatra bundler capybara json` Try uninstalling those so you only use bundler's one. That should do the trick. The error you're getting indicates that you should be using only the project's dependencies and not the system ones, specially with sudo.
Yea its cross platform. Mac and windows at least.
Thanks@Zacmon, let me check that way
Great post
*Do you use a kanban or other project management tool?* Yes. That can really help with a lot of this. If you use something like Trello, Pivotal Tracker, or even Jira, you can create a story around one of these big-picture items (aka "Add an Organization to associate with Users"), and then create a checklist to make sure you're getting all of the pieces in place: generating the files for the MVC portions, adding validation, ensuring the database fields are present and of the right data types, any additional changes to other parts of the app that interact with the new model, writing tests either before (TDD) or after the main set of code changes, etc.
I could see Permission denied error in reading file. Please see what it is?
Honestly I would say go with rbenv or chruby instead. RVM is a little long in the tooth these days and kind of unwieldy. Sorry, I know that doesn't help your issue.
I want to know what issues people have because I have been using it for some time now and have not run into any issues. 
You installed the gpg2 key as the root user on your machine and are now trying to install rvm as not the root user. The rvm installer is trying to read that key but only the root user has access to read it. You either need to reinstall the key as non-root user (suggested) or install rvm as the root user (not suggested).
If it's working for you then that's great. No reason not to run it, unless you run into any issues. It's been a while since I was using it and can't remember now what my problem was that led me to switch. Seems like it had something to do with shims but my memory is crap so I could be totally wrong on that. Sorry.
Hello, as an alternative to JSON Feed I've put together Feed.TXT - a new feed format in plain text with structured metadata in YAML and content in HTML or Markdown. Use the [new feedtxt gem / library](https://github.com/feedtxt/feedtxt) to read / parse the new feed format for publishing &amp; sharing posts, articles, podcasts &amp; more. Try `Feedtxt.parse()` returning an array with a metadata hash and items (w/ metadata hash and content). Cheers. PS: Feed.TXT is also knowns as RSS (Really Simple Sharing) 5.0 ;-)
You need to look beyond the hype. Considering many full stack frameworks clone RoR patterns I'd say it's still very relevant.
&gt; When I was creating my first major Sinatra project, Cook This &gt; Way, while doing Learn Verified, I was looking for a way to build a &gt; Sinatra skeleton similar to running &gt; &gt; rails new APP-NAME FYI: There's the quik gem - the missing scaffolder / quick starter for ruby ;-) For a sinatra app try: $ quik new sinatra See the [Sinatra Quik Starter Template](https://github.com/quikstart/sinatra-starter-template) for more. Cheers.
&gt;The way I see it, NodeJS The way I see it, NodeJS is worst thing to happen in development history. Even if I didn't write Ruby, I would write Erlang, Elixir, Go, Clojure, Rust, and web applications using CGI scripts written in C before I had to write NodeJS again (yes I have used it). Let's face it, you're not asking for constructive criticism when you say "pushed Ruby to irrelevance" and "but still never Ruby".. in the Ruby sub. You're posting bait and trolling for responses.
Thanks this just fixed everything for me :D your my hero &lt;3
I didn't try it yet, so not 100% sure. I didn't see any breaking changes being mentioned, though.
Why do you think Ruby is not relevant anymore? Just because you mostly hear about a specific technology more, doesn't mean others are obsolete. We still have several applications written in RoR in production (with 1 big one). 
What does it matter? Trying to compare languages and frameworks without the context of a specific problem you're trying to solve is such a pointless exercise so often. It's like we distill the pros and cons of each language/framework and discuss them in oversimplified sound bites like American politics. Beware of this type of thinking and discussion because it won't help you understand the nuances of a language or its community. I use Ruby because I'm very productive using Ruby, and most of the problems I solve using Ruby don't run up against the performance limitations imposed on the environment. Is it a perfect language? No. Is it a perfect community? No. Could it be faster? Sure, but the amount of time it would take to rewrite this work in something more performant absolutely does not offset the cost of having code working right now. My boss would fire me if I walked in tomorrow and proclaimed that we should rewrite everything in a JVM language because Ruby is slow. Not to mention the growing pains that the JS community is going through right now with respect to their frameworks and tooling (I'm looking at you, [left-pad](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)). Performance is a key aspect of software development is critical, sure. But it's not the only one, nor is it the singularly most important unless the problem domain requires it, IMO. The vast majority of side projects people work on don't even reach the scalability issues of Rails that are so often thrown around. 
&gt; Why you should probably avoid bad code design FTFY
&gt; I never hear any web developers talking about RoR anymore, or Ruby in general. Agreed, but I think you are drawing the wrong conclusion from this. People also don't talk about internal combustion engines, airplanes, electricity or cellular telephones like did at one point in the past. People talk about what is new and hip, not what is stable and reliable. There is a lot of interesting action in ruby with the [dry-rb](http://dry-rb.org/) team, imo.
I'll take a huge blob of code in the controller over some bad abstractions which were the result of some arbitrary "small classes" metric any day. Such procedural code is usually very easy to refactor. With 20 different classes each depending in some obscure way on each other on the other hand...
Strong words for someone who confuses then and than... I mostly agree with what you are attempting to communicate though.
Good to know. Thanks!
Right. I was just pointing out, that "hundred lines of procedural code" is not necessarily the worst code base you could have and refactoring might do more harm than good. I'm wondering why my original comment got downvoted. Wrong abstraction &lt; no abstraction is basically what Sandy Matz preaches all the time: https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction
It's all about the right tool for the job. If you like Ruby, use it. If you don't, use something else. I'm well-versed in Perl, PHP, and Ruby. Along with JS and all sorts of other things. I use what I need for the job. I think an argument could be made saying Perl is no longer relevant as I don't know of any big site still using it, but maybe for non-web stuff there's still great uses for it. With PHP I use it if it's an existing project. Anything new it's Rails for me. It's actively developed, great community, great resources and tutorials, and I really enjoy using Ruby. I like the elegance of it. But that's just me and what I like. Rails was never as popular as PHP or some other languages/frameworks but who cares?
"then" and "than"*
Totally agree. Most of the n lines of code metrics are silly. Keep texting right abstraction level, don't overstep responsibility. That's all it needs to be. 
Sinatra with rails-like ... simplicity? Its a catch 22. Would be more accurate to simply call it a rails-like generator. Although this is cool, I dont see myself using it, since if I want rails-like boiler, id just go with rails
But Enumerable_any's extreme is one I have experienced, especially, as they suggest, from people just blindly following strict rubocop settings, and figure if it passes rubocop it's good design. Nope. Forest, trees. 
Man, I fought so hard against stupid metrics like method length, class length, nesting etc. I thought I came up with a good argument against method/class length check - suppose the max length is X, the method currently has X lines. You've fixed a bug or implemented a new requirement and it became X+1. What would you do? Everyone answered "ignore" but I still couldn't convince anyone. People want to feel nice about themselves.
While agreeing with overall sentimemt I want to point out that Sidekiq and DJ aren't interchangeable, they have different semantics WRT database transactions.
I've only used whenever, but now we run tasks using containers, so we're good 
Too real
Certainly! I wouldn't suggest following a blind metric. I would absolutely advocate for critically analyzing code against principles like SOLID. A huge method is likely to be un-SOLID, especially in a language as expressive as Ruby. You just can't write code that way and still only have one reason to change (SRP) or be loosely coupled (DIP). Hell, you can't write code that way and end up with code that's readable and testable. I'm not in favor an arbitrary line-limit, but I do adhere to principles of OOP. I think there's a happy medium and the situation I describe is far from it.
&gt; but I would much rather have that extreme then the opposite Understanding the control flow can get pretty hard, though. So does finding the place where the real work happens (bonus points if every dependency is injected, there's no documentation and dozens of the possible dependencies implement the same interface namely `call`). Procedural code vs bad "SOLID" code feels like a linked list vs an arbitrary graph in terms of complexity.
If you think race conditions are eliminated with an event loop then you are mistaken. Event loop based concurrency eliminate concurrent writes to the same memory location, which is a very low-level concurrency problem. It does not eliminate wider classes of high-level race conditions problems.
It is one of the things we have considered. HTTP push adoption is kind of bad right now. It doesn't help that Nginx doesn't support it. Something like H2O would solve it, but H2O is less flexible than Nginx so you lose features, and putting Nginx behind H2O feels kind of weird. Passenger could definitely help by making the entire experience much smoother. The main thing holding us back is not knowing whether there is enough demand for a feature like this. It sounds cool, it sounds useful, but not many people are actually asking for HTTP 2 push. But who knows, maybe if we launch a marketing campaign to push HTTP 2 push adoption then people will be much more excited about it.
&gt; Ruby is a weakly typed language You mean dynamically typed. Ruby is dynamically and strongly typed. Examples of weakly typed languages are PHP and JavaScript (lots of implicit type conversions going on).
&gt; With 20 different classes each depending in some obscure way on each other on the other hand... This is a strawman. SOLID is the opposite of "classes depending on each other in some obscure way". Yes, I have seen the problem you described; it results when a developer realises that there is too much duplication / methods are too long and do too much but they lack the experience or ability to decompose the functionality into isolated pieces of functionality.
The grass is always greener on the other side of the fence. :)
You mean this?: signal_processing_start start_time_measurement process stop_time_measurement signal_processing_end ----- def process_signals signal_processing_start yield signal_processing_stop end def measure_time start_time_measurement yield stop_time_measurement end process_signals do measure_time do process end end ------------------ I do like how your code makes this sort of thing more flexible. Also, I think if, doing it my way I wouldn't go more than 2 levels deep. But with your code, I think it stays readable to quite a deep level of nesting.
Glad my click bait could help ;)
Any tips on how to NOT use conditional logic in the view? Isn't that nearly impossible to achieve? For instance, say a user can have up to 5 different specific objects. So, when returning those to the view: @user.objects.where(type: "beer") However, since a user doesn't have to have that beer, then wouldn't you need to check if it's there first? @user.objects.where(type: "beer").any? 
please do not rescue Exception. Rescue StandardError instead. https://stackoverflow.com/questions/10048173/why-is-it-bad-style-to-rescue-exception-e-in-ruby
I see, you're right. Thanks for explaining.
Now, why would I want to switch from ruby to scala? I probably should read it to get an answer, but I do not have the intention, so why bother? 
I think we can agree both are terrible and should be avoided.
I made the switch to use Spark for big data and machine learning stuff. If you don't want to work with big data, you don't need to make the switch. I wouldn't switch to Scala to build websites.
Yep, I need to get a lot better at understanding type systems and I will study hard to improve.
The difference is that with Sidekiq it's pretty easy to submit a job that will try to read data that wasn't committed into a database yet. DJ uses the same database as the main application so both jobs and models are committed at the same time.
Yeah, it's certainly a ramble. I will be iterating on it. Thanks for the feedback!
Ooo good point yeah, makes sense, with dj it's the same process and probably the same txn unless you're explicitly managing it to be separate.
Another handy one - `bundle console`. Really useful when you're working on a gem and want to fiddle with something without writing a wrapper script. And I agree with /u/Blimey85 - click bait but it delivers! I had forgotten to set this on my new laptop... oh wasted hours...
Right on, that one's worthy of a `alias bo="EDITOR=mate bundle open "`.
Honestly I wouldn't use it. Yes it's less LOC, but it's a bit too clever/meta for my tastes. I normally pull `begin ; rescue ; ensure ; end` blocks into their own methods which changes it to `def ; rescue ; ensure ; end` which reads just fine IMO. I could see it being useful in a library with lots of pluggable features but I like to keep my apps as straight-forward possible.
I have to think a bit more about this but there is one risk: code might be too terse. Sometimes too fancy will lead to unreadable code. Also, if individual code pieces (those, that you factor out into methods) are short then readability of the `begin ... rescue ... else ... ensure ... end` sequence (or subsets thereof) with the code contained is likely be much better than for the same code distributed across a number of method definitions and invoked via your `run`. Also, `File.open` and the likes do use a block with `ensure` already to ensure proper resource cleanup. If you use that pattern regularly then there is only exception handling left. And in my experience there are not too many places where exceptions are handled. Plus, if the same exception handling is applied chances are that it should be in one place on a higher level in the program which makes the method declaration redundant because the method is used in one place only with your approach.
[aasm](https://github.com/aasm/aasm) might cover some of the bases, although you'd probably have to implement a fair bit of functionality on top of it.
Is it generating a matrix of all zeros? "..." excludes the end value from the range, you want ".." http://ruby-doc.org/core-2.4.1/Range.html
I've tried...get a nulls in all indexes. Something is broken with that loop but I can't see what.
Ah, sorry; I'm drinking. You'll want to fix the "..." thing, but your loops currently have no side effects! "each" does not do an assignment. I think you can switch to "collect!" to get the result you want. The simplest fix is to use the default assignment operation on the inner array as well as the outer array. Array.new(dim){Array.new(dim){random.rand(0..1)}} Least amount of thinking IMO Edit: You could also use "each_with_index", and do an assignment with the provided iteration indices. Collect! Should work because x = y returns y, you don't need the assignment in ruby. Or returns, a block returns the value of the last statement.
Using random.new a lot is not a good idea; you should stick to one random instance as much as possible. Random number generators only guarantee a nice distribution when you use the same sequence for a long time (aka reuse the same random object). Depending on the application it may be nbd. Edit: https://en.m.wikipedia.org/wiki/Pseudorandom_number_generator Random has a period, and if you make a new instance you are messing with the period. Which messes with the distribution. Ruby has a SecureRandom class which might be better or worse for your use case
Use bundler to manage gems for different projects. http://bundler.io/
As others are saying, you'll likely have to build on top of other solutions. [Flor](https://github.com/floraison/flor)'s an ongoing workflow management system you might take a look at. 
Just to add on, you generally want to set this to the # of cpus cores you have: bundle config --global jobs `sysctl -n hw.ncpu` In some cases you can benefit from higher jobs counts than this, but it'll depend on your work load. Particularly how many gems need to compile C extensions and how parallel those builds are.
Care to elaborate? Do you mean in hooks?
Phrasing it a bit differently: the initial example misses out an important part: open file # allocate X begin read_file # use X rescue IOError =&gt; e handle_io_error ensure close_io # release X end And here "release X" depends on "allocate X", i.e. the type of cleanup to do depends obviously on the type of resource X. So the way `File` and others are doing it is actually the best way, i.e. to have allocation and release code in one method that then passes resource X to a block. Ripping both apart into two methods that are somehow invoked by `run` is error prone and not readable. Regarding exception handling: this is often done on a different level. In fact, I guess it is rather the rare case that exceptions are handled on the same level as resource allocation and release. For example, when reading a configuration file and working with the results you want to catch exceptions higher up the call chain in order to also skip the usage part. begin conf = Config.load ".myconf" use conf # skipped as well rescue StandardError $stderr.puts "ERROR: no config found" end You can also imagine cases where you want to catch exceptions parsing individual lines from the file to be able to skip them. Here, exception handling would occur on a lower level, i.e. inside the part that uses the file descriptor. Bottom line, exception handling is more often than not not on the same level as the resource allocation and deallocation. So having one method that delegates to resource allocation, deallocation, usage and exception handling methods does not work well.
It sounds like you are running into problems because you have conflicting gems. This is what bundler was designed to deal with. Bundler uses a local directory for each "project" (aka, directory with a Gemfile). If things get weird you can use "bundle exec thingiwantodo" when you are in that directory.
The reasons behind my opinion is that it both become hard to reason about what happens very quickly, and also have a tendency of creating hard to find failure modes. Just the other day we had an issue where a validation failed on an object that was created in an after_create callback, which failed the whole create, without adding errors to the object we where trying to create. No stacktrace, no error added, just a silent nope - save failed. I much prefer service objects that reflect the whole **process** that is done instead of jamming all that logic into the models representing the database objects. To give an explicit example, I greatly prefer having a Signup class and a SignupController over having logic like that in the User model and/or UserController. That also gives you the possibility to get error handling that is specific to the signup process instead of mashed together with the user or whatever it is that fails.
Great article! It reminded me of a [similar article](https://twin.github.io/evaluating-ruby-libraries/) I wrote some time ago. I agree about understanding the code to be the most important thing. And it's not that you have to understand everything, but at least to have a general understanding of how the gems does what it does. Contrary to the folks who look at the number of stars, I'm usually more interested in new projects (which will obviously have fewer stars), especially if I see that they have considered existing alternatives and they explain the advantages. That way I've discovered many amazing gems that would have a much larger community if Ruby developers would put more effort into choosing what's *better*, instead of what's familiar. And the word "better" here doesn't have to be something subjective like just "having a fresh design", it can be very objective like "having more features and more flexibility".
My preferred way is to include ActiveModel::Validations and ActiveModel::Naming into the service class and then you get it more or less for free. Other people prefer different ways. It greatly depends on which types of state people prefer to use. I'm not against state, but I really dislike mixing state from different contexts.
I have `function to_gem { cd $(bundle show $1) }` (not sure if the syntax is correct, not using bash anymore), which can be useful when some gem doesn't seem to be doing what it's supposed to do. Couple this with the new `bundle pristine` command and profit. :)
I think you're missing `jobs` in your example. For ease of copy / pasting: bundle config --global jobs `sysctl -n hw.ncpu`
This is a common mistake to make. If you do array.each { |e| e = 2 } for some `array`, you're not setting every element inside that array to 2. `e` in your block is just a local variable. By assigning a new value to `e`, you're just changing a reference - not what's contained *inside* that reference. Doing that is actually impossible in a language like Ruby. If you want to do this in an imperative way, you'd have to do something like array.length.times.each { |i| array[i] = 2 } Here you're actually not just assigning the new value to a local variable but to a position inside the original array. A better way (IMHO) to do this would be something like new_array = array.length.times.map { 2 } or in your example dimension.times.map do dimension.times.map do random.rand(0..1) end end Understanding how references work can be a bit tricky. It certainly took me a while (I remember having a similar misconception, but at that time I was writing Java code - same thing, really). It may be helpful to read up on how such things actually behave at a low level (e.g. how is an array laid out in physical memory).
it's not about `each` not doing assignments. You can perfectly well have `each` calls that do assignments; in fact the original code *is* an `each` call that does assignments. The problem is just that the assignment is to a local variable that disappears as soon as you exit the block.
&gt; I think Devise is awesome for knowledge, to learn about all possible security things to watch out for [...] I hadn't considered that, good point! &gt; I don't know if you've ever seen Grape code [...] Yes, I have. Unfortunately, while I like some things about grape, I've always felt like it's too much DSL-first without a good abstraction layer and so some things end up being very complicated to do. I think I understand your point about Roda. I'm just not sure if I don't feel uncomfortable putting a lot of logic inside my routes because that would make it hard to unit test that kind of logic (or is there some way?).
There are a few ways: * Use an environment variable to set the dependency version: `gem 'rails', ENV['RAILS_VERSION'] || '~5.1'` Run locally as `export RAILS_VERSION=4.2.1; bundle update; bundle exec rake test`, use `env` matrix on travis for testing all versions. This approach works best if all you need to do is switch one or two versions. * Use separate gemfiles. Gemfiles are just ruby code, you can break them up into pieces and combine them. e.g.: `common.gemfile` - Put all your shared dependencies here. `rails4.gemfile` - Put rails 4 specific stuff here `rails5.gemfile` - Put rails 5 specific stuff here A 'child' gemfile may look like: source 'https://rubygems.org' gemfiles = [ 'common1.gemfile', 'common2.gemfile' ] gemfiles.each { |file| instance_eval File.read(file) } # add extra child specific deps here You can choose the gemfile to use when running `bundle` commands locally and travis has support for matrix testing multiple gemfiles as well. This approach works best when there are more substantial differences between the setups. * Use https://github.com/thoughtbot/appraisal which is really just some sugar around the multiple gemfile approach. This works best if you like the sugar appraisal provides.
Oops, thanks, updated.
The world would be a better place if 'use the right tool for the job' sold nearly as well as absolutionism. Alas, I don't see it happening.
If you can't produce a sound design, then perhaps having all the code in one big controller method is superior to a bunch of indirection between poor abstractions. I look at either one as amateur hour, though.
It's an extra dependency on code that the Ruby core team has accepted the responsibility to maintain, and whose bits don't need to be downloaded before they are used. I am not sure I buy the "depend on as few gems as possible" as an absolute but it sure is annoying when adding a gem dependency pulls in unnecessary extras.
&gt; Generally this is because they are unaware of how biased they are in favor of familiarity. I'm not so sure it's a bias toward familiarity in general, but there certainly is a bias. The construction of the bias is complex, familiarity is certainly an input, but there are various other inputs. Resume Driven Development, bad past experiences that are easier to trump up to design choices rather than just bad developers, etc, etc; a long list if one were to get a group together and enumerate it. &gt; I agree, but I think those programmers believe they are choosing the right tool for the job. I think _believe_ is the operative word. It's much easier to accept a belief than to shake one or apply critical thought.
IRC is for winners anyways
really appreciate these little tidbits from big binary -- keep 'em coming!
I know you're just trying to troll, but I'd still love to hear about where you think e.g. dry-transaction is problematic. Its goal is to allow you to break apart complex business operations into smaller, easier-to-understand, and easier-to-reuse pieces and then bring them back together so you can safely run those pieces in sequence. How would you rather approach such a problem? I've learnt that some people will see the words "IoC container" and immediately (and unreasonably, IMO, since I think this approach in Ruby actually works quite nicely) rubbish everything associated with it, but with this release of dry-transaction, we've actually made the container _optional_, so this gem is more flexible than ever and more readily able to integrate with various different application architectures.
I'm not trying to troll actually. It's rather difficult to look at 'dry' and see anything else but JavaEE re-written in Ruby. It suffers from all the same issues. &gt; I know you're just trying to troll, but I'd still love to hear about where you think e.g. dry-transaction is problematic. Its goal is to allow you to break apart complex business operations into smaller, easier-to-understand, and easier-to-reuse pieces and then bring them back together so you can safely run those pieces in sequence. How would you rather approach such a problem? Why do I need a framework to execute steps in sequence? I just call methods in order, you've built a framework on top of calling methods in sequence. Why so much ceremony? &gt; I've learnt that some people will see the words "IoC container" and immediately (and unreasonably, IMO, since I think this approach in Ruby actually works quite nicely) rubbish everything associated with it, but with this release of dry-transaction, we've actually made the container optional, so this gem is more flexible than ever and more readily able to integrate with various different application architectures. You can count me in the camp that considers IoC a huge anti-pattern in any language, and it's clearly a huge part of why I see 'dry' as just JavaEE written in Ruby. But, back to my first point, if you don't use a container than what is the point of `dry-transaction`? It really seems to be a DSL for calling methods in order, why does such a thing need to exist? 
&gt; Unfortunately, while I like some things about grape, I've always felt like it's too much DSL-first without a good abstraction layer and so some things end up being very complicated to do. Yeah, me too, that's why I like Roda's instance-level routing "DSL" which is basically just a wrapper around simple conditionals. &gt; I'm just not sure if I don't feel uncomfortable putting a lot of logic inside my routes because that would make it hard to unit test that kind of logic (or is there some way?). In my opinion all HTTP-related logic _should_ go into routes, and I want to test this logic end-to-end (is there a disadvantage to that?). All other logic can go into a service class that can be unit-tested. The [multi_route](http://roda.jeremyevans.net/rdoc/classes/Roda/RodaPlugins/MultiRoute.html) plugin can be used to separate routes into multiple files.
&gt; dry seems to use classes quite heavily so I don't really get what is being said here. Sorry for the confusion. What I was saying is that so much of an app can actually be modelled as classes, named by verbs, with `#call` methods and no mutable state. This is the beginnings of what allows them to be composed in interesting ways, like we do with dry-transaction. Hope that clears it up! &gt; What you want to do is enqueue a background job to send a notification email only after the database transaction that creates the relevant records has been committed, less your worker pick up the job and see out of date info when it's hits the DB. Yep, you're right, you definitely have to be mindful of this. In our apps I have an `enqueue` step adapter that serialises an object and puts it into a background job queue. When the object is run from the queue, it re-fetches any required records from the database, so there's no issue about stale data. And as for database transactions, that was something I had in the back of my mind when making the change to dry-transaction in 0.10.0 – because it's persistence-agnostic, it doesn't give you anything out of the box to help with wrapping steps in database transactions, but now that transactions are class-based, you can create a shared transaction superclass with its own `#call` that adds the database transaction wrapping behaviour. &gt;&gt; This arrangement allows each operation to remain independently testable, and independently reusable.\ &gt; &gt; You can do that with simple method calls, no need for the ceremony. Well, my feeling here is that having methods about creating database records _and_ delivering emails in the same class is a violation of SRP that will likely cause you pain over time, so this is why I break things apart as much as possible :)
I think the key insight she gives can be summed as: make smaller things.
Callbacks and model level validations are great if they are universal to all contexts of the object, [and--- AND --- they rely and involve state INTERNAL to that object.](https://www.bignerdranch.com/blog/the-only-acceptable-use-for-callbacks-in-rails-ever/) The second you start adding conditional validations to your model based on callbacks is a sign you need to change up your design to do something more in line with what you're describing. And while I do like Service objects, I have seen them often produce code much much worse than traditional rails stuff. After all, service objects are basically a license to start writing ruby however you want, conventions be damned....
Yeah, no problem with services. And this part of functionality can be solved with some other solution. I made a research about Camunda and Activiti, but can't guess how to work with them.
You didn't give an answer about this part: &gt; Oh, the other purpose for dry-transaction is that it allows you to perform "railway oriented programming" for these business transactions. It's not just a "sequence of methods", but it's a sequence of operations that only runs as long as each operation in the chain succeeds. dry-transaction codifies what you'd otherwise have to manage casually throughout your codebase, and if you didn't have the help of monads or something similar for wrapping results in success/failure objects, you'd end up with big control flow messes. For me this is one of the most important advantages of `dry-transaction`, because always checking whether the previous operation succeeded is really ugly.
I don't think that's true at all. If you create small things that are tightly coupled and badly abstracted, you're not improving your codebase IMHO.
Why couldn't you just do a begin except end block and have your methods raise errors?
Because it would look like this: begin user = save_user(attributes) begin send_confirmation_email(user) rescue Redis::BaseConnectionError # ... end rescue ValidationError # ... end
&gt;I'd use a class because, when I want to refactor a command into multiple methods, I don't want to have to pass the initial parameters to all the methods as arguments. That's functional programming. That's how you avoid mutable state. 
And writing functional-style classes is easily the most natural way of achieving this kind of outcome in Ruby. Anything else and I think you truly do end up going against the grain of the language. Here's something I wrote about it a little while ago: https://www.icelab.com.au/notes/functional-command-objects-in-ruby. Hopefully that helps better explain this approach.
But being able to deploy artifacts into an application server is (as far as I know) not specific to J2EE, doesn't every Java web framework work like that (including some that are decidedly Rails inspired)? I don't need to have *that* in order to justify using dry-validations, for example. What you're saying sounds to me like: they're doing some things that (allegedly) J2EE also does. Therefore these things can only make sense if you have the full J2EE experience. But I don't understand why that needs to be the case. And I don't even know how much J2EE is an inspiration for dry-rb, but even assuming that it is, there is no reason that you couldn't pick individual parts. By your logic, you should not use `map` because that comes from functional languages but Ruby is not functional and has mutable data structures.
Exactly. There may be some operations you want to retry if you get one error or abort if you get another.
&gt;It would be good for us to stop making these arguments so personal and try to bring more objectivity into the discussion. This is an odd argument to make now when you started out saying the developers should not be insulted when there was no personal insult directed at the developers. So in this case it seems to be the developers took it as a personal insult when somebody said their work was not useful and a waste of time. I am not saying their work was a waste of time because I personally believe they got something out of it and that's enough but the OP doesn't agree with me there. 
[Good luck getting decent coverage](https://www.youtube.com/watch?v=Zzc_2nD9Jzs)
SECTION | CONTENT :--|:-- Title | SymfonyLive Berlin 2013 - Anthony Ferrara - Development, by the numbers Length | 0:38:36 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
&gt; I agree with him that the dry-* gems are needlessly complicated and attempt to solve problems which people don't have. That's objectively not true. For one, the counterargument is the maintainers of the `dry-*` gems, they obviously had problems that these gems solved, otherwise they wouldn't put so much work into building them. But I can also give you a personal example. Rails has a problem with slow boot time, because it `require`s a lot of code, that's why the Spring and Bootsnap bandaids were invented. However, Spring still doesn't always reload the environment when it should, which broadens the reasons why your tests for new changes might be failing, and causes people to [report](https://github.com/janko-m/shrine/issues/112) [issues](https://stackoverflow.com/questions/43263779/ruby-rails-shrineerror-storage-cache-isnt-registered-on-pdfuploader) to gems that are actually Spring problems. There is no real solution for that in Rails, because the issue is in Rails' design. `dry-system` solves that. It non-obtrusively proposes a different file structure for your application, one which will eliminate these issues. It uses `dry-container` as a wrapper around referencing external collaborators (e.g. a Redis client). Note that this is very different from autoloading (which is pure evil), it simply `require`s an object that you're referencing. Other than this automatically solving my application boot time, my tests can also now load fast, that each test file only requires what it needs. It also means I can easily swap dependencies inside tests with test counterparts. I want to stress here that **I wasn't able to solve these problems by myself**. I tried hard to figure out how to reorganize my application to fix the problems I mentioned, and whichever idea I came up with it always required that I sacrifice readability and convenience in some place. And I had experience with non-Rails custom project structures before. So, in this case `dry-system` **solves** a problem **I have**. &gt; They actually make your code more verbose I don't know if you've missed it, but people are massively switching to `dry-validation` from `ActiveModel::Validations`. I remember one developer saying that the switch reduced their validation code by 50%. That would then be the exact opposite of "verbose". &gt; and scattered over more files making it harder to debug and keep track of The `dry-*` gems don't enforce your file structure in any way. They do provide convenience methods to name dependencies based on the path to the file. In the case of `dry-transaction`, it doesn't force you to split the files in any way, you can have all steps in a single class. Notice that **Rails does enforce file structure** – the autoloading won't work correctly if you name classes differently than the file. So, you are your own boss here, in no way you're limited. `dry-container` even allows you to specify all configuration dependencies in a single file, and allow you to only load the one that you use. Options are endless! Also, making general statements about `dry-*` gems doesn't make any sense, because each of those gems is totally different, the only thing they have in common is the `dry` prefix and the fact that they reuse and build on top of each other. &gt; Maybe you love them and that's OK but people ought to be able to say they hate them. Why do you think that it's right? Do you tell people you hate that you hate them? Imagine that everyone that hated you told you that they hate you. How is that useful? The sender of hate would feel bad, because sending hate produces a negative feeling (but people still choose to do it), and you as the receiving of hate would probably feel bad, because you wouldn't understand what is so wrong with you that people decided to make the extra effort to tell you that they hate you and why, even though you know you cannot please everybody.
You expect me to watch a 38 minute video?
Wrong subreddit. Wrong Ruby.
&gt; they didn't want the return value to be a complex object that isn't the result of that operation, but something you actually need to call #value Result monads are not complex **by definition** as they consist of a single thing - a value. On top of that you have an interface that's pretty narrow and consistent. I can understand why people are against it - because it doesn't feel rubyish enough. I get that, and we've built a very rubyish result-matching DSL in dry-transaction specifically so that we can use more natural ruby code along with result monads (where they are used as an implementation detail because dry-transaction unwraps values automatically, and in your code all you need to learn is using `Right` and `Left` constructors for return values).
&gt; This is an odd argument to make now when you started out saying the developers should not be insulted when there was no personal insult directed at the developers. I'm sorry, where did I say anything about being insulted? It's not my point to argue about who should or should not be insulted when. My point was about constructive criticism. And "your work is a waste of time because [no proper argument, just a reference to J2EE]" is, IMHO, not constructive criticism. I don't see how it helps, that's all.
&gt; I don't care about the validations. But I do. You're making a blanket statement that the `dry-*` gems are overcomplicated and don't make sense without a J2EE environment. But here's at least one library that solves a problem and doesn't need such an environment. `dry-struct` is another. There is also `dry-monads` which I haven't used yet, but it definitely takes inspiration from Haskell rather than from J2EE.
It's a bot. See the "user" [submission history](https://www.reddit.com/user/roxannevan/submitted/). All submissions are to subreddits where the name of the subreddit is in the title of the story.
&gt;&gt; they didn't want the return value to be a complex object that isn't the result of that operation, but something you actually need to call #value &gt; Result monads are not complex by definition as they consist of a single thing - a value. On top of that you have an interface that's pretty narrow and consistent. Actually, I remembered now there was another, bigger problem – that it could cause exception silencing. For example, if you execute a Redis command where you don't care about the result (so you never call `#value`), the exception won't bubble up even if you might have wanted it to. The preference was to therefore leave the exception-rescuing opt-in, rather than having it opt-out. I for one feel like having result monads would make me care about exceptions *more*, not less, because the fact that I always get result objects always reminds me that this command could have failed. And if I want the exception to bubble up, I can just call `#value` without checking whether it's a "left" or "right" monad. And the solution for remembering the possibility of failure for "pure commands" would for me be `dry-transaction`.
Yes, that's right
And how would I do that? I read same advice on some forums, but with no actual steps lets say of how to do it
PS - Maybe this would help. https://www.edx.org/course/object-oriented-programming-iitbombayx-cs101-2x-0
The standard in my day (and, not much has changed for the principles) was *Design Patterns* by Gamma, Helm, Johnson, and Vlissides - Addison-Wesley, 1994 https://en.wikipedia.org/wiki/Design_Patterns
&gt; it's too slow to be useful Huh?
i think a lot of people don't understand the difference between a server and client side framework. What server side Javascript framework will eclipse Rails? Meteor and Sails are the only ones I know of; Express is so barebones that it hardly seems like a framework at all. So I think DHH is right
I agree with your warning against using mixins to split a class amongst multiple files. I think modules are still useful if the code could conceivably be mixed into multiple classes, especially the if the usage contract is minimal (i.e. if there are few methods that must exist in the class) . However, I'm not sure what you mean when you say "prefer composition". It seems to me that the most obvious alternative is to use class methods, or change the modules to their own classes. 
Thanks so much. Nice book, lots of good ratings, will add it in shopping cart. One last question, if not too much. Since I will be doing Ruby, do you consider good to learn C++ in parallel ? As many are recommending C++ for the basics
I had this idea for a project not so long ago that would test you code against possible variations of dependencies essentially finding the minimal supported versions. It's an interesting problem for big projects I think but a bruteforce implementation would be pretty straightforward. Anyone knows of any similar solution already out there?
For me, these two books are essential: - [99 Bottles of OOP](https://www.sandimetz.com/99bottles) by Sandi Metz and Katrina Owen - [Practical Object Oriented Design in Ruby](http://www.poodr.com/) by Sandi Metz The two of them are based in Ruby. Also, I'd watch anything by Sandi Metz, starting with [All the Little Things](https://www.youtube.com/watch?v=8bZh5LMaSmE). That for OOP, but for grasping Ruby the best book I've followed so far is [The Well-Grounded Rubyist](https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692) by David A. Black.
I am sad i actually did not learn enough about japanase usage of Ruby. What i gathered is that they use embedded ruby and ruby on iot and something something R like data analysis.
Haven't they already?
http://rubyland.news
&gt;How do you handle POST bodies, i.e. how do you validate the data passed? Do you have/use JSON schema validators? I have a set of classes I have built over time for this stuff. I think it's quite elegant while being lightweight but then I am biased because I wrote it. &gt;(I find ORM validators just wrong). I don't use an ORM but I sure as hell use heavy check constraints on the database itself. Postgres is awesome for this. I try to push as many validations down to the database as possible to protect the integrity of the data. With postgres you can even put nice error messages so the error raised can be passed on to the client. 
There are other libraries which do monads and structs no?
&gt;What kind of argument is that? I also have the freedom to come to some random person's house and kill them, but it doesn't make it right. I don't think expressing a negative opinion is the same as murder. &gt;Nope, never. Then I submit that either you are lying or that you are some sort of an unusual person. &gt;Not everyone can ignore that. Everyone can ignore. It doesn't take any skill or time or money. &gt;I hope you're not one of those "grow a thicker skin" people, because that's bullshit. I am one of those people who say that I will not change myself to better suit your thin skin. I suspect I am not the only one. &gt;Notice that having a thin skin is not necessarily a sign of weakness, because it shows that you're embracing vulnerability (so in many cases it's the opposite). It's fine to have a thin skin, it's not fine to demand that everybody in the world change their behavior to accommodate your thin skin. &gt;just that if everyone could simply deflect other people's hate, then everybody could be jerks to other people and nobody would mind. I believe honesty is more important. 
&gt;. And "your work is a waste of time because [no proper argument, just a reference to J2EE]" is, IMHO, not constructive criticism You can't force people to stay silent unless they disagree with you in the way you want them to. That's a simple fact. What you want doesn't really matter. People have the freedom to speak as they will on the internet. Your only recourse is to complain to the moderators and see if you can get them banned which would silence them from this subreddit under that user name. 
I'm not sure where that "~3x" comes from 🤔 ... can you clarify?
Right - as context, "optcarrot" is the benchmark that Ruby officially uses to measure Ruby 3x3 progress.
&gt;You're only this way because you've got no skin in the game. Publish something publicly (written articles, a gem, etc.), under your own name, and lo and behold, a miraculous 180° change of opinion. I don't think so. I guess I am not as sensitive to these kinds of things. If people want to bitch and moan I don't care. The way I see it anybody who complains about a gift is an asshole but I don't try to shut them up because that makes me an asshole. &gt;A more likely outcome, though, is that you'll never publish anything publicly for fear that people will treat you the same way you treat them. And how do I treat them? Do I make baseless passive aggressive accusations about them? &gt;It's a convenient way to justify your continued, toxic, courageously anonymous behaviour. This sentence pushed you into the asshole category in my book. 
Oh, you're right (sorry, it's been a while since I've done much Ruby). It's [system](http://ruby-doc.org/core-2.4.1/Kernel.html#method-i-system) you want, in the second or third forms, where there's no shell involved.
I don't get this. This is the second time I've seen a project claim to implement a JIT and achieve 3x Ruby performance increase. Why hasn't the mainline picked up on some of this?
&gt;I believe honesty is more important. It is important. They should be honest so I can judge their character accurately. &gt;This is the internet and you are doing things in public. Everybody has the freedom to be critical of you or your comments. Of course they do. We agree on that fully. I would never try to silence anybody online for saying things I don't like. &gt;This sentence pushed you into the asshole category in my book. Good. We are now two people who don't like each other. There is nothing wrong with that. You can't get along with everybody. I promise not to try and silence you though. Even though you are an asshole I will respect your right to express your disgusting views on the internet.
I'm a complete noob on this kind of stuff, but usually the trade off is memory consumption vs. speed. In JS land for example, V8 is super fast, but look at how much memory Atom, Slack, etc. are using. I remember when one of the JIT implementation came out (RuJIT?), someone talked about how Matz and company worked for Heroku. Heroku's concern was their base offering was/is 512MB. With any Ruby JIT implementation that would give you &lt; 2 processes using Rails.
Yeah that all does make sense. But realistically, two processes running three times as fast it still quite feasible for entry level projects, and likely to be a major improvement at the larger scale.
[Awesome Ruby @ libhunt](https://ruby.libhunt.com)
Thanks so much
If you want projects, the [Ruby section of The Odin Project](https://www.theodinproject.com/courses/ruby-programming) has a good amount of them. Good to put the concepts into practice making small programs (command line games, algorithms and data structures, etc.). You can also receive help in the community [chat](https://gitter.im/TheOdinProject/theodinproject). For programming exercises, I'd recommend [exercism.io](http://exercism.io/) and [codewars.com](https://www.codewars.com/).
In dry-transaction you can select which exceptions should be rescued and wrapped in a failure, so anything that is truly an exception (semantically speaking) will blow up and you can add custom rescue clauses to handle it the way you want. For me it's very important to make a distinction between expected failures and actual exceptions. That's why I don't use exceptions for control flow except situations where there's code which I don't control where exceptions are raised but they shouldn't cause a crash (which means I use `Try` and it's still part of a standard control flow).
Yes, and?
Thanks for that insight. It does explain a few things. I guess the issue for someone on the outside is the combination of: - Generic complaints about MRI's Ruby performance - Years worth of hearing about MRI getting faster without significant practical changes (for definitions of "significant") - Multiple projects popping up showcasing apparently major gains that never go anywhere - The issues you mentioned not being very visible to an observer that hasn't seen your post above Edit: As a side note, the commit messages in this particular project are particularly disappointing.
But would you consider c/c++/java to learn as to grasp the basics better?
That sounds perfect! 
Buzzword, buzzword, webscale!
&gt;Quite frankly I do expect people to be polite and respectful to each other, which should be the norm. What you're saying in this thread is pretty much disturbing as you're openly saying that it's OK to express hate towards other people's work. I am saying that people have the freedom to do this which is true. You can't stop it no matter how much you don't like it. In fact if you try to silence people you are just going to make it worse. &gt;Personally I did grow a thick skin after participating a lot in OSS for roughly 8 years, but it doesn't change the fact I still expect people to behave in a nice way. I don't expect anybody online or in real life to act in a nice way. In my experience the vast majority of humans (almost all of them) are not nice people. They may pretend for a little while to be nice but they are not nice inside and sooner or later they will do something shitty to you or somebody you know. &gt;For me some of the comments here are already a good reason to report some people to the moderators. you have the freedom to do that. They run this place and can do anything they want without consequence. Reddit is not a democracy, it's not a nice place. The moderators are dictators who can do anything they want to a user including banning them, shadowbanning them, reporting them to the police, even doxxing them. Nothing anybody can do about it. That's reddit. 
The first time was IBM's OMR, which depends on their internal proprietary technology. Ruby core is skeptical of outside dependencies that they don't control.
If you read the benchmarks, they achieve 3x on the optcarrot benchmark with just 15% more memory usage.
Vladimir Makarov did get his faster-hash-table patch merged, so he's not a complete unknown to ruby-core, [and at least one ruby-core member likes it.](https://twitter.com/tenderlove/status/875467599290613760)
[There is an open issue on the bug tracker.](https://bugs.ruby-lang.org/issues/12589) 
Rails based, but there's a lot of crossover: https://dgosxlrnzhofi.cloudfront.net/custom_page_images/production/64/page_images/Rails_Competencies.png?1386276348
Here is another book, just for Ruby, that I just now found in a later thread in this sub. It may be exactly what you need: http://designpatternsinruby.com/ It wouldn't hurt to learn c++, but when I was a c++ programmer, I found it to be invaluable that I had learned Smalltalk, first. c++ is such a nuts and bolts language, it is difficult to "see the forest for all the trees". Smalltalk is a perfect language for learning the basics of OOP.
&gt; and at least one ruby-core member likes it. Matz liked RuJIT (which used a similar shell-out-to-a-C-compiler mechanism as this one), but that doesn't mean it's going to be merged
Keep in mind these are more like things that could potentially be good to know in some circumstances, not things that necessarily provide any benefit at all. It'd be very hard to someone who didn't already know the implications of these things to know what to prio. 
Thats a pretty neat thing.
Right on. Derek Prior has a [great talk](https://www.youtube.com/watch?v=HctYHe-YjnE) where he describes breaking out new controllers as giving you "breathing room". Same thing when moving something out into a service class; now instead of a private method you have a whole new file to work in and whaddya know, all sorts of additional helpful refactorings start pushing their way forwards.
There's the [ruby-talk mailing list](https://www.ruby-lang.org/en/community/mailing-lists/).
Good stuff Rich!
This argument makes no sense. By that logic there should only ever be one validation library, one HTTP client, one solution for everything. Let's just write everything in the same programming language, while we're at it.
What benefits are you seeing from the switch?
Great explanation. I do a similar thing with having both a class method and an instance method to make the interface a bit cleaner. If you want, you can actually extract that as a separate module and include it in all of your service objects.
Fat anything isn't worth striving for, and there are a couple of big problems with this approach. I'll be blunt in my technical criticism, but I am not intending any offense. 1. What does the word "service" mean in this context? What I see is the command pattern applied to a query. We don't need to attach a name like "service" to something just to name a new subdirectory under `app`. Just call it an "object." Consider putting it in `lib`, i.e. `lib/vendor_payout/calculate.rb`. We don't need some word to describe some overarching pattern (i.e. like `service` or `controller`). Sometimes rails programmers feel uncomfortable writing objects outside the boundaries of the framework, and feel compelled to add letters to MVC just to continue feeling like their code is following convention. This is flawed; our project structure should keep related concepts grouped, it shouldn't subdivided by some paint-by-numbers mishmash of misappropriated pattern names. 2. The thing that makes rails apps hard to change is that everything is coupled to the underlying storage model. With ActiveRecord, you often can't change your model code without expensive data migrations because much of their behaviors and interfaces are derived from the database itself. And so notice that the "service object" is still heavily coupled to ActiveRecord models. For instance, see `line_item.license.price * vendor.get_split_percentage(line_item.track, time)`. Thus, on its best day, this kind of approach is more pain management than pain prevention. You haven't really reduced the amount of complexity that goes on in your web request/response cycle, and this service object is difficult to change for the same reason the underlying models are difficult to change. You still need to build up a bulky object graph to test this thing. Speaking of which... 3. That "test" is hard to read (I don't know why RSpec users think `described_class.new` is doing anyone any favors), but it does reveal something interesting. You have two flavors of orders, click orders and custom orders. You might have two pricing _strategies_. Currently, the calculator exhibits pretty low cohesion because of this. I can't even understand what it does because it has so many little methods that seem to handle nuances of various use cases. Teams expecting to add "service objects" like this one are not going to end up with a significant win -- I've seen quite a few teams try and none succeed.
This is great, nice examples and good explaination. Thanks for sharing
I moved to a service-based architecture a while ago and I love it. Keeps the app extremely organized. I've been writing Rails apps for 10 years and the architecture I'm using now solves most of the architectural issues I've run into repeatedly over the years. I combine PORO classes with the Wisper gem and have Wisper listeners sometimes call other services. This basically replaces model callbacks and keeps my models skinny as hell. As such I scarcely use model callbacks for operations unless I feel like it's something absolutely crucial to the integrity of the record. Similarly my controllers don't really do a damn thing but run services and render/redirect/respond based on the success/failure of those services. For example I had an app where a user could have multiple email addresses associated with his or her account. Let's say we're confirming a user's email address, but we also want the user in question to be confirmed once an associated email address is confirmed. The controller action for this operation would run a `ConfirmEmailAddress` service which, after running, would call to `EmailAddressListener#confirm_email_address_successful`, a method that would run a `ConfirmUser` service that would update the `User` record. The code is highly compartmentalized and a service only really creates or updates one thing at a time. Services that would modify multiple records generally delegate to services that modify single records. This is easier to test and easier to wield (e.g. in the console). It's easy to call `ConfirmUser.with(&lt;User&gt;)`. "Fat services" is kind of wrong because a service should only do but so much. What you really want is a fat services *directory* with a lot of services that do one thing well and then broadcast their success/failure to a listener that will run more services (if necessary).
Thanks for that. Agreed, aService really shouldn't be "fat", nothing should in an application. It was just a 'clever' title :), but now I see the flaw in naming the title that. "What you really want is a fat services directory with a lot of services" is right
You're welcome :)
Smalltalk? Doesnt pop up much on the forums/blogs about the OOP. Most advices I saw were either C++/Java for basics or Python/Ruby I will definitely have a look at it
I love it, but is it a living diagram? As requirements change does the trees grow and fall?
Are you asking if the table has become outdated?
Thought I knew quite a bit before looking at this. It's well done and comprehensive. 
Nice articles. I really like how Hanami is put together actually. The separation of code is really pleasant. I'm really interested in some testing articles though. 
Can't take anything that references Quora seriously. 
Ok, I guess I should've said full http2 support...
It doesn't seem to me that this JIT addresses issues with extensions and the overhead from switching from ruby VM world to native code. Has anything been proposed for doing this using this approach?
Rather than reply I'll just [show you the excellent case Sandi Metz makes for doing this.](https://www.youtube.com/watch?v=8bZh5LMaSmE)
I hope you see the irony of your statement. 
ideally yes there would be one canonical library for commonly used idioms. This would make it easier both for newbies and also experienced devs. One of the reasons Rails is so popular and has so many contributors is that for a very long time it was the only game in town. This allowed it to be robust and more importantly properly documented. A newbie now knows where to go. Other more lightweight frameworks came and went and some are still around but by and large most people use rails. I say that as somebody who is not a huge fan of rails but I begrudgingly accept that if I want to build a proper, secure web site in Ruby for profit I'd be foolish to do it in anything else. Sooner or later you are going to want etag support or secure sessions. I am saying that if you are going to be spending all this time building something you better be bringing something really cool to the table otherwise you'd be better off helping an established project which people already know. 
Have you seen my drawers gem? :) Might be up your alley
How do we convince the community to think about the semantics of what's being done. Services make 0 semantic sense. What's a service? Stripe, Twitter, etc
In that case there may be no functional difference with and without. The '@' refers to instance of the test. If you used a 'before' or 'after' block in addition to the 'it', there could be more code elsewhere that would have access to this variable over the duration of the test. Leaving off the '@' would prevent that.
Thank you
Others are right that in your example that instance variable isn't in the top-level scope. But: Everything in ruby resides in an object of some class. You can always find out which one in a debugger, just look at `self`. A truly top-level instance variable would be in the special `main` object: # ./test.rb puts self # `main` puts self.class # `Object` There is a "main" object that the top-level scope actually is. https://codequizzes.wordpress.com/2014/04/23/rubys-main-object-top-level-context/ In general, it's not a very useful thing to do to create an instance variable in the `main` object (top-level scope), but it can be done, and that's what it refers to, nothing special. But please don't try to take advantage of this to do something clever, there are probably better ways to do most anything than trying to use the `main` object's instance variables! 
I don't think `--without` keeps gems from being included in dependency resolution and recorded in Gemfile.lock, it just keeps them from being _installed_ as a result of the `bundle install` that included that option. I wasn't sure, but your results suggest I was right. And the docs kind of say this, although not entirely clearly: &gt; While the --without option will skip installing the gems in the specified groups, it will still download those gems and use them to resolve the dependencies of every gem in your Gemfile(5). http://bundler.io/v1.13/man/bundle-install.1.html If it weren't for this, then the `without` arguments you use (or don't) on any given invocation of `bundle install` might have to change _other_ dependencies in Gemfile.lock as well, to resolve against those gems that are sometimes included and sometimes not. In some cases, the Gemfile could even be _not_ resolvable (incompatible dependencies) or not, depending on your `without` arguments. This would be confusing and undesirable. `without` is used to avoid installing certain gems in certain contexts, in an otherwise stable Gemfile.lock. Once you have a Gemfile.lock, it won't be changed as a result of `with` or `without` arguments, only what gets installed on the system will get changed. 
Thank you, and yes the reddit code formatting is annoying that's why I put my code in pastebin.
SECTION | CONTENT :--|:-- Title | RailsConf 2014 - All the Little Things by Sandi Metz Description | Theory tells us to build applications out of small, interchangeable objects but reality often supplies the exact opposite. Many apps contain huge classes of long methods and hair-raising conditionals; they're hard to understand, difficult to reuse and costly to change. This talk takes an ugly section of conditional code and converts it into a few simple objects. It bridges the gap between OO theory and practice and teaches straightforward strategies that all can use to improve their code. Sandi... Length | 0:38:47 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
the pattern you're looking for is a "state machine". https://www.ruby-toolbox.com/categories/state_machines.html
Thanks for the link to your video, I understand your examples!
No, the naming isn't too bad. Unfortunately, I'm away from a computer so I can't really type anything up. What I'm trying to say is that I would have a content object separate from a mechanics object. So I would have a different object holding the method that prints out the scene text - the scene object just provides the text. Same thing for transitions - a transitions object would contain the methods for creating and executing the transitions, and the scene object would just pass the info for that scene. Hopefully that makes sense.
&gt; The thing that makes rails apps hard to change is that everything is coupled to the underlying storage model. Too true; I'd go one further and say that most developers tightly couple everything to the Rails framework without any level of abstraction between it and the underlying logic, ending up with a mess thats simply spread out a little more ... that said I think this is true almost whatever the language/framework. &gt; Teams expecting to add "service objects" like this one are not going to end up with a significant win -- I've seen quite a few teams try and none succeed. 'Service objects' can make sense although there are usually better abstractions. However its likely that any team that employs them though will be unable to recognise the alternatives. e.g. where I have most recently seen them employed it progressed to the level of having an Anemic Domain Model (which is a logical conclusion - validation of input is just a service after all [not my words]). I'd call it 'a complete disaster' due to the underlying data corruption, but the team were happy with it (customers were a different story). 
I am going to second /u/realntl that the word "service" is vague. It's almost intentionally vague, in fact; like "decorator"; you can use it for anything. As you say, as long as it could otherwise be in a model, you can put it here. But what differentiates this "service" concept from something that already exists in Rails, a "concern"? Which, by the way, are basically just modules. More generally, I think the concepts you bring up are fundamental ones (splitting code up in isolated mixins/classes). But I don't see the purpose in creating a new moniker. That's great that your team _agreed_ on something, but it doesn't explain _why_. It's not like introducing jargon is necessarily a bad thing, but it needs to be adequately defended and distinguished or else it will sound pretentious. 
For sure, I can see your point. Services aren't anything new actually, we didn't make up that moniker. It's a pattern that is used by many folks. Example, looks like these folks use them: https://blog.engineyard.com/2014/keeping-your-rails-controllers-dry-with-services The Why? We preferred Service objects over Concerns because a Service is structured as a PORO, while a concern is extracting methods into a module to be included in a model(s). I believe the service is easier to write tests for, as it's just a Ruby class. Also, it feels more intentional in the code when in numerous places, you see a well named service being called. "CalculateVendorPayoutService.calculate!"... Seeing that called from controllers or what have you should make it really clear what you are going to get back from this Service object. I have nothing against concerns, we use them for connecting to some external API's. But for some small bits of functionality that are to accomplish one thing, I prefer to use a service. 
The first question I'd be asking would be: can I make the scenes out of pure data (like a YAML file, or JSON, or something). Then you can have a single `Scene` class, and use it to load each file in a folder. But it sounds like you need logic/behaviour that is different for each specific scene, so you probably need each scene to be a bit of code. There are a few different approaches that you could take, but the easiest would probably be to make a `Scene` base class, and have each scene inherit from that class. You can keep a list of subclasses automatically, something like this: class Scene def self.subclasses @subclasses ||= [] # start with an empty array end def self.inherited(scene_subclass) # keep a record of all classes that inherit from Scene subclasses &lt;&lt; scene_subclass end end class SpookyDungeonScene &lt; Scene def description "A spooky dungeon." end end class ElfVillageScene &lt; Scene def description "A village full of elves." end end # if all your scenes are in the same folder, you can automatically require # them all like this: Dir.glob('scenes/**/*.rb').each { |path| require path } Scene.subclasses.each do |scene_class| puts "#{scene_class}: #{scene_class.new.description}" end Which will output: SpookyDungeonScene: A spooky dungeon. ElfVillageScene: A village full of elves.
So you are saying you have 600 scenes and want to *"just really quickly, open up a scene file, add the scene number and text, write the logic, the small little if and else's, close it up"*. For me this looks like you have a Scene class and 600 scene objects, one for each scene. Now, if each `#start` method is different, you could just use a passed-in block for this method. Additionally, you describe four actions that are available for a scene. These actions are probably best implemented by separate Action objects. # One of the four actions you describe class DoNothing def initialize(page) @page = page end def execute # go to page @page end end class Scene attr_accessor :start_block attr_accessor :action attr_accessor :page_index attr_accessor :text def start @start_block.call(self) end def transition @action.execute end end Finally, in Ruby land many people would use a DSL (domain specific language) for the definition of the scenes. This could look something like this: scene(5) do text "The text of the scene" # this becomes the start method start do |scene| end # sets the action of the scene action(:do_nothing, 10) end # Implementation class FileDSL def initialize @scenes = {} end def parse_file(filename) instance_eval(File.read(filename), filename) end def scene(page_index, &amp;block) @scenes[page_index] = SceneDSL.new(page_index, &amp;block) end end class SceneDSL def initialize(index, &amp;block) @scene = Scene.new @scene.page_index = index instance_eval(&amp;block) end def text(str) @scene.text = str end def action(kind, *args) @scene.action = case kind when :do_nothing then DoNothing.new(*args) end end def start(&amp;block) @scene.start_block = block end end 
I thought about doing it this way but couldn't figure out how to keep an array of the subclasses. thanks!
I'd probably just fold `CreateUserAction` in to the `CreateAttorney` class as there is little advantage to keeping it separate. I'd also change `CreateAttorney` to be `RemoteUser`. Now you can do all your management of remote users through a single class `RemoveUser.find`, `delete`, `update` could all be handled here. 
Hello, I've updated the [Dr. Jekyll's Top 22 Open Source Static Website Themes](http://drjekyllthemes.github.io/top) page today. Congrats to: - #1 Jekyll Now ★ 3653 by Barry Clark - #2 Poole ★ 2178 by Mark Otto - #3 Minimal Mistakes ★ 2068 by Michael Rose and all the runner ups. Happy publishing with Jekyll &amp; friends. PS: Any theme missing? [New themes welcome](https://github.com/drjekyllthemes/themes). 
[DelegateClass](https://ruby-doc.org/stdlib-1.9.3/libdoc/delegate/rdoc/Object.html) 
As others mentioned, Forwardable is the way to go if you want to mimic `delegate`, just look at RDoc documentation for it. From what I've seen, `def_delegator` is the most common usage, but it actually also provides a (surprisingly undocumented) `delegate` method, which I find the most natural to use. extend Forwardable delegate [:foo, :bar, :baz] =&gt; :composed_object
I think the issue is that CreateUserAction contains logic that will likely be needed by other classes, so just folding it into CreateAttorney will mean duplicating code elsewhere. &gt; Now you can do all your management of remote users through a single class That sounds like a huge violation of SRP. You'd end up with a large class (which is a code smell) that has multiple reasons to change. It's also likely to have lots of dependencies. Taken together, this would make the class fragile and hard to change (and test). In general, creating lots of small, well-encapsulated objects is just good OO design.
If you just want to use the delegation design pattern, you don't need a library to do that. Here's [a good example](https://github.com/davidgf/design-patterns-in-ruby/blob/master/decorator.md) based on the book Design Patterns in Ruby.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [davidgf/design-patterns-in-ruby/.../**decorator.md** (master → 2880a9a)](https://github.com/davidgf/design-patterns-in-ruby/blob/2880a9a5dcca0d8a0baf45a8244bdb4280c329a2/decorator.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dj2xjg3.)^.
I'd suggest seeing if you could use a custom domain object to encapsulate some of those parameters. I don't know the full context of what these mean, but it looks like a few of the params have to do with settings. So you might have a `GameSettings` object that owns those pieces. You could group different params together, but as an example: class GameSettings def initialize(game, number, bonuses) @game = game @number = number @bonuses = bonuses end end Then we you go to construct your scene, you could do something like: settings = GameSettings.new(game, 99, 'intuition' =&gt; 1) scene_99 = RollSceneAddBonus.new(settings, "First scene", john, 146 =&gt; [2,3,4,5,6,7,8], 444 =&gt; [9,10,11,12]) Since the hash is the last argument, we can forego the curly braces. Actually, looking at this more it looks like the concept of a "scene" is probably a reusable part of your domain. So you could do a little further and group the things related to scenes together: settings = GameSettings.new(game, 99, 'intuition' =&gt; 1) scene = Scene.new("First scene", 146 =&gt; [2,3,4,5,6,7,8], 444 =&gt; [9,10,11,12] scene_99 = RollSceneAddBonus.new(settings, scene, john) Since you already had character as its own object, this has the added advantage of bringing everything in this class to the same level of abstraction. Instead of having a bunch of different, seemingly unrelated parameters needed to created a `RollSceneAddBonus`, now you just pass in three: settings, scene, and character.
`def initialize(uid, user_data, action: CreateUserAction, serializer: AttorneySerializer)` ` def endpoint "#{ExternalDBHttpConfig.attorney_save_endpoint}/v1/save" end ` This article was pretty difficult for me to read and the solution seems put together rather arbitrarily. Sandi's point about the wrong abstraction and all that.