What is a shooter application? Have this web-app up so I can use it without installing?
Usually I only use groovy when I'm also using Grails, and prefer the grails tool and vim and shell.
The eclipse GUI was lacking functionality also that the cmd line tool had when I had tried the plugin 8+ months back.
The Eclipse Groovy plugin is getting better every week, you should try it.
About time something was posted on this sub-reddit... :-) A couple of points though: * @InheritConstructors seems pretty cool, saved keystrokes FTW I guess * Regarding the first()/last() calls on arrays; what does "primitive arrays not covered yet" mean? `String[] strs = ["a", "b"]` has those methods while `int[] ints = [1,2]` doesn't? * Also, why is the `@Synchronized` annotation exactly useful? Also, why are generated lock objects arrays instead of normal objects? 
In regard to the second point, I think it means that actual Java arrays are not covered, while array objects (ArrayList, etc), are covered. In regard to the the third point, the @Synchronized annotation uses AST (Abstract Syntax Tree) transformations to handle locks at a more granular level. When you use the synchronized keyword in Java, it locks the entire object during a method call, and the entire class during a static method call. @Synchronized modifies the body of the method such that it synchronizes on a lock object instead. You can also specify multiple lock identifiers to allow non-conflicting method calls to execute concurrently. I'm not sure about the motivation for lock objects as arrays, but it could have something to do with how they are referenced and garbage collected.
Bette late than never I guess; thank you. :-)
I got this to work, but not after a few painful minutes of replicating my Grails application's classpath (already specified in BuildConfig.groovy but ignored by STS/Eclipse) in STS build path. Also, you can do this with [Netbeans](http://www.grailsblog.com/archive/show?id=13) as well.
Is anyone using GPP in production, any war stories? A few of my clients have been using Grails + GWT with success but GPP would be a good fit for an upcoming project, but I want to get some war stories from early adopters before recommending it.
What's nice about it is that you can use it whenever you need to and forget about it the rest of the time. I haven't used it extensively enough to have any "war stories," but my experience so far has been positive. Groovy++ knows stays out of your way until you explicitly tell it to do something. Groovy by itself is fast enough for most things. If you have a serious bottleneck somewhere, this will allow you to simply extend your optimization toolkit beyond the normal capacity of standard groovy.
A***n*** groovy? Jesus!
Release notes: http://docs.codehaus.org/display/GROOVY/Groovy+1.8+release+notes
Looks interesting. Maybe I will try this out. I would love to use groovy more for my applications at work but the "dynamic" nature of groovy is unacceptable in my work environment. A "static" groovy may have a chance outside of our "toy" section.
It's a tradeoff between performance and dynamic magic. Anyway, groovyypp gives us an alternative choice to use syntax sugars in java development. 
Are you asking a question or showing a code example that works?
Actually it works! If you want to formulate it as a question it would be something like "Are there any other cool ways to switch on two values in groovy?".
If you know Java, Groovy is very easy to learn. You can write simple command line scripts using Java syntax and then run them easily, i.e. "MyScript.groovy", where an equivalent Java command line application would be invoked something like "java -cp /foo/bar/lib.jar:/temp/foo/lib2.jar:/aaa/bbb/lib3.jar com.mycompany.foo.MyClass" 
&gt; is the licensing of Groovy a lot safer than JavaSE[Oracle] (i.e. freer to use without having to pay L.Ellison somewhere down the road)? JVMs on all major platforms have been free since 1995, so your paranoia is a tad misplaced. If you don't like Oracle's JDK, use IBM's then. Secondly, Groovy requires Java to be present for the installation, so you still have to accept the license of your particular Java environment. This is true of all languages that run on the JVM. 
pretty cool
I recommend this "early access" book gor Groovy: [Groovy in Action](http://www.manning.com/koenig2/). Glen Smith is working on the [second edition](http://blogs.bytecode.com.au/glen/2011/10/31/springone2gx-2011-was-one-groovy-show.html) of the book, but it is not yet even in early access. Can't find any up to date Grails books around.
groovy docs are good. groovy in action 2nd edition is on the way. for grails, grails reference docs are great. http://grails.org/doc/latest and peter ledbrook is also writing a new grails book for grails 2.0.
I found it very entertaining and useful: "Groovy Recipes: Greasing the Wheels of Java" http://www.amazon.com/Groovy-Recipes-Greasing-Pragmatic-Programmers/dp/0978739299 
The reason my company choose groovy is that we have a lot of java developers that are resistant to change. The main advantage of groovy vs jruby or jython is that you can basically just program in java and ease into the more modern, dynamic features.
Groovy is stable, well supported by IDEs, and you don't need to learn a new collections framework or other non-Java language-native objects. A list in Groovy is a java.util.List for example. Performance-wise it is about equivalent to JYthon and JRuby. There's only so much the JVM compiler can do when all method calls are virtual lookups. I think it also has more community support, unless you count native Ruby/Python communities (and you could). All are good choices really if you need the stability of the JVM for your project. Although a better question would be why not pick scala? You get your sugar, type safety, and speed. 
I have used both Ruby and Groovy - I prefer groovy. Ruby has some really annoying syntax conventions that I find makes the code less readable. This could be because I was a long time java developer first, I admit. Also, I do quite a bit of work in enterprise environments, where java is dominant. Grails (groovy on rails) to the rescue there - it's very very similar to Ruby on Rails, but based on mature java enterprise tech in the back end (Spring, Hibernate, etc...). Good stuff. There is also an interesting adaptation of grails for desktop apps called Griffon - same structure and database backend, but a swing front end. Swing isn't the nicest window manager, but it works, is cross platform and is simple enough. 
If your developers were less resistant to change, do you feel that jruby or jython would have been a better choice? Or do you think because Groovy requires much less of a mind shift for the Java developer that it is still the better choice?
&gt; Groovy is stable, well supported by IDEs, and you don't need to learn a new collections framework or other non-Java language-native objects. A list in Groovy is a java.util.List for example. That's not a bad thing to have, if you value Java-compatibility more than consistency. I've been playing around with Groovy, and it's annoying how Arrays use `length`, ArrayLists uses `size`, and Strings use `length()`. It's more practical, more intuitive, and more structurally consistent to a) use `.length()` for every linear data structure and b) have strings be ArrayLists of characters. &gt; Although a better question would be why not pick scala? You get your sugar, type safety, and speed. Scala is interesting. Groovy's syntax is different enough from both Java and Ruby that you can't rely much on either for help. Likewise, Scala is different enough from Java and Haskell that you have to learn not one, not two, but three syntaxes. Some people say that Scala's type system is overly complicated. I don't know, I haven't used it enough to gauge that. But I have fallen in love with Haskell's type system for its intuitiveness, consistency, and flexibility. As for Scala, why not use Jaskell?
Well, there's 1000 languages right, so the "why not use X" would be an ongoing conversation. You have to narrow it down to what is important to your team/environment. I would argue that Java's inconsistencies, while annoying, are a minor concern when choosing a language. Once you start using any third party library, that team's inconsistencies (unless they are religious about proper naming) will pollute even the most pristine syntax foundation. &gt; Groovy's syntax is different enough from ... Java Actually, Groovy's compiler can accept almost pure Java syntax. If you are a proficient in Java, learning Groovy can be a very natural and incremental process. You are right though. I'd say mastering Scala would be about the same effort for a Java developer as mastering JRuby. But again, Scala was written with the Java developer in mind so many of the constructs are java-like and written to take advantage of the JVM. &gt; why not use Jaskell? Biggest reasons for me would be lack of a large community (and the stability questions that come of that, lack of ide support, lack of training resources, etc) If I wanted to go with a pure functional language on the JVM I'd probably go with Clojure. which is surprisingly easy to learn with it's tiny LISP-like syntax.
Grapes and antbuilder are the two killer features for me.
Not sure. I haven't used either of them. The groovy choice was made before I started. We could probably do what we do in any of them. Buy in is huge. We have no idea which languages are going to go the distance. Ruby is huge and will be around for a good while but jRuby is mostly made by a small team. Python is in a similar boat with the added complexity of not having a single unifying framework. Do you know python and/or ruby and just want to use it on the jvm? Do you know java and want to start experimenting with dynamic features? How about your team?
I'm a long time java developer (since mid 90s) so I'm pretty comfortable with the JVM. I remember when Ruby started coming on the scene, like most java folks, I was impressed and a bit envious of Rails when I first saw it. But after thinking about it a bit I never made the shift. Languages are nice and all but they are secondary to stability, performance, community, trainability, IDE support, third-party library support, container support, etc. Didn't matter how sugary Ruby was if the container you deployed it on wasn't stable. Around the same time period JVM languages started to grow past the toy phase (or maybe my awareness just grew) and I latched onto Groovy. I don't like Grails (or any heavy stack really) but I loved Groovy for the glue code in our applications, especially it's great XML support. Groovy isn't 100% pure functional, but it is close enough to get a person to understand the power of closures and functions as first tier objects. However, it is dog slow (so is Jython and JRuby) and I've had to retain Java (and sometimes shell out to C) for the parts of our development that do heavy calculation (we make statistical analysis software). In the last year though I've tried to branch out. Luckily with my job we have a small dev team and are allowed to pick our own toolsets (within reason of course). I had a one-off project that had to crawl and analyze our log files, so I took Clojure for a spin. I love Clojure, but it still feels pretty primitive. For example, the compiler is one-pass which means you have to have your functions in the correct order. What is this 1985? I've just recently finished my first scala project and will probably be sticking with that language for the near future. The one thing Groovy (or any dynamically typed language) takes away is easy refactoring, which increases the number of unit tests you need to write to prove correctness. Static typing brings that back. Scala seems to have the typing about right. Things can get confusing, but moreso if you are writing your own Scala APIs, not using the ones provided. I found this to be true with Java generics too: using collections classes, and other generics-enabled classes was trivial. Writing a correct API with generics often was tough. Anyway, along my road I've only dabbled in Python (played with it for a day or two) and am newb-fluent with Ruby. Our network guy uses Puppet technology which requires some Ruby knowledge. If I was working with a java-fluent team today and wanted to introduce a new language to increase productivity it would be a toss up between a mix of java/Groovy (which is very powerful) or all scala. Again, as you said, buy in is huge.
&gt; Well, there's 1000 languages right, so the "why not use X" would be an ongoing conversation. You have to narrow it down to what is important to your team/environment. Aye. &gt; I would argue that Java's inconsistencies, while annoying, are a minor concern when choosing a language. Once you start using any third party library, that team's inconsistencies (unless they are religious about proper naming) will pollute even the most pristine syntax foundation. I like being able to do `(length some-sequential-collection)`. I don't think we should just accept inconsistencies in libraries, when it's so easy to communicate with developers these days. And accepting defects in the most basic tools, the languages themselves, promotes failure. If a flashlight only clicked on every three-four clicks, you'd toss it out for a new one. The only reason we still use COBOL, FORTRAN, Pascal, Ada, C++, and Java is that programmers and businessmen are scared of rewriting busted codebases the newer, better stuff. Even if newer languages are guaranteed to present fewer bugs, they would prefer the more prevalent, more hazardous, more well-known bugs. They prefer to reboot the OS rather than change to an OS that fixes the problem requiring them to reboot the OS. &gt; Clojure Such as Clojure :) Many supposedly offbeat languages like Clojure actually have pretty active communities, even O'Reilly textbooks. I've got problems with Clojure in particular (CLASSPATH is so borked that you have to use Leiningen just to compile simple files), but that's another thing.
&gt; The only reason we still use COBOL, FORTRAN, Pascal, Ada, C++, and Java is that programmers and businessmen are scared of rewriting busted codebases the newer, better stuff. I'd say cost is a bigger impediment than fear. Would rewriting Tomcat from the ground up in Scala, say, improve it dramatically enough to be worth the cost? I think you are conflating a minor irritation (Java's size/length inconsistency) to some major failure-inducing flaw. &gt; Even if newer languages are guaranteed to present fewer bugs Gosh, I'd like to see how you back up that guarantee with metrics. Be easy to prove that more sugar means less lines of code, possibly easier to learn (at least the basics of development), but less overall bugs? I don't buy it. Not without proof. &gt; RE: Clojure Agree on Clojure, it just isn't polished enough for me to justify recommending it to my group, even though I love how it updated LISP. Cross fingers for long run? 
Examples: * [testing integers for evenness](https://github.com/mcandre/gruesome/blob/master/example.groovy) * [testing a Cisco password encryption system](https://github.com/mcandre/ios7crypt/blob/master/IOS7Crypt.groovy)
&gt; I'd say cost is a bigger impediment than fear. You might be right. However, there is something to be said for the added robustness of a new language. Rewriting code costs money, but so does failure resulting from unsafe systems. Therac-25. &gt; Would rewriting Tomcat from the ground up in Scala, say, improve it dramatically enough to be worth the cost? That's site-specific; if you value robustness above all else, then yes, it may be worth it for you to write everything in Scala. Then again, few web developers would undertake such a massive project. It's more likely that someone who really likes Scala would port Tomcat to pure Scala. In that case, the question becomes moot: Scala programmers could choose whether to use Tomcat or Scalacat. &gt; Gosh, I'd like to see how you back up that guarantee with metrics. Statically-typed languages necessarily have fewer type-related bugs than dynamically-typed languages. Declarative languages have even fewer bugs because they force data into boxes. Either x a valid result of f(a, b, c), or x is nothing. In particular, Haskell has no `null` and thereby reduces the number of type-related errors still further. &gt; Agree on Clojure, it just isn't polished enough for me to justify recommending it to my group, even though I love how it updated LISP. Cross fingers for long run? Have you tried Armed Bear Common Lisp?
&gt; value robustness above all else I just disagree with you that a new language would bring more robustness to a system. I could counter the Therac-25 example with the more recent Twitter example where they had to shift more and more of their snazzy rails code to a mostly C/Java based platform (JVM). As far as the whole bug-reducing goes, I'd still need to see some analysis that demonstrates a significant bug reduction in code because of a language difference. I just don't think that data is in. Yes, the kinds of bugs may be different, but the overall number? That's something else entirely. I guess one way to look at it would be to look at the number of successful, non-trivial projects created in each language. One complaint against languages like Ruby is that it doesn't scale to large systems. BTW: I hope this doesn't come off as Ruby bashing or me being overly in love with Java/JVM (although it is my main platform). I'm really more interested in the conversation and what can truthfully be said about languages. From my own experience, I can write the same system in pure Java that I would in Scala (and because I'm a scala newb I can do it about 10 times faster in Java) and both systems will end up probably having the same amount of bugs. That's because the bugs tend not to be the little language things but larger system things (not handling an unexpected return from a web service for example).
&gt; I just disagree with you that a new language would bring more robustness to a system. Aye, newness /= robustness, just look at Python vs C. Scala and friends happen to be new _and_ more robust. &gt; Yes, the kinds of bugs may be different, but the overall number? That's something else entirely. The number of bugs may not be as important as the _kinds_ of bugs. Type-related bugs are, in fact, very common, and they are also some of the most dangerous. There's not much to do if you treat an int as a string in a strongly-typed language; you either crash, or you throw an error and crash. Though the most insidious bugs are probably mathematical flaws, like the Intel chip that gave the wrong answer for floating point division, because those will never crash, they'll just propagate down the line. &gt; BTW: I hope this doesn't come off as Ruby bashing or me being overly in love with Java/JVM (although it is my main platform). I'm really more interested in the conversation and what can truthfully be said about languages. :) And please don't think of me as a Haskell cultist; I could generalize to MLs. &gt; That's because the bugs tend not to be the little language things but larger system things (not handling an unexpected return from a web service for example). Have I got a [book](http://book.realworldhaskell.org/read/) for you. In Haskell, it's difficult to write a program that allows "unexpected returns". Everything is of a specific type or type class, and each enumeration must be specifically handled or the code won't compile.
Yeah, scala tries to remove null-handling issues with Option. My web-service example was more of the line that I got a valid response, but the document didn't contain what was expected. So not a null pointer, but a design issue. The point I was trying to make is that the bugs I see most often in my code base aren't really language-specific, but design shortcomings and unexpected system states. If I wanted to switch to your side of the discussion for a second, the one huge advantage I've seen from changing languages is native support for asynchronous processing.
&gt; The point I was trying to make is that the bugs I see most often in my code base aren't really language-specific, but design shortcomings and unexpected system states. I don't doubt that your code is excellent. The null-handling thing is something you can encounter when someone else writes sloppy code. If you're lucky, you can rewrite it to check for nulls. &gt; If I wanted to switch to your side of the discussion for a second, the one huge advantage I've seen from changing languages is native support for asynchronous processing. Like parallel processing in Erlang and Haskell? That is cool stuff.
&gt; being a developer &gt; resistant to change WHY
Financial company.
http://crazy4groovy.blogspot.com/search/label/tutorial
Viva Groovy !
I know this is an old article, but is there any info on if there are plans to utilize the static type checking and compilation in a future Grails version? Too soon to tell?
I'm not sure what the difference is between instance-level and object-level private, but I do know that the private keyword is more or less entirely broken in Groovy. Private variables have always been accessible from outside of their own class in Groovy. As someone who writes a lot of Groovy code, I think this is both Bad and Wrong, but apparently it's a difficult thing to fix. http://jira.codehaus.org/browse/GROOVY-3010
I replied to TheGunsOfBrixton, but I want to thank you for reminding me this subreddit existed! I love Groovy and all its quirks.
To follow up... I bet you could use methodMissing and propertyMissing to determine who the caller is, and if the caller is not a method from this instance, you can throw an exception.
They have the same meaning, just not the same implementation. /lawyer In testing it's nice for DI classes to just be able to assign their dependencies to a mock. But yes, encapsulation is nice (though it is much more than just hiding your variables).
Great job Grails team. Very much looking forward to the 2.2 release.
Ditto. I'm looking forward to the Grails 2.2 upgrade to Groovy 2.0.
Very cool. I am just starting to look at Groovy myself.
I'm a big fan of groovy - I use it daily for a modern Grails project. Over the last 2 years both grails and groovy have really grown into something that is fun to use! I'm not jealous of my Rails coworkers - groovy has a lot going for it!!
I agree. I am looking at a position that uses groovy. I installed Netbeans and started playing with it and it is very nice.
You've provided a link to a product without any personal review, commentary, summary of why you thought it worth posting, access to sample chapters, etc. Downvoting as pure spam. 
Based on 45 seconds of history stalking, he is Adam Davis. This is completely spam.
Very neat. Do you think you could put a non "-SNAPSHOT" version in your repo? (Or is it already; I just noticed the SNAPSHOT in the install directions.)
&gt; Grails 2.2 will be the first version of Grails to include Groovy 2.x. Grails 2.2 doesn't actually use the new features of Groovy 2.x, either static type checking/compilation or the invoke-dynamic bytecode. Best wait until Grails is using them before using them in our own projects.
It's super easy to install with [GVM](http://gvmtool.net/): gvm install grails 2.3.0.M2
[**@gvmtool**](https://twitter.com/gvmtool): &gt;[2013-07-15 11:12:06](https://twitter.com/gvmtool/status/356732903260033024) &gt;GVM 1.3.0 is ready for consumption! Features suggestive selfupdate, flush command and DRY candidates. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1idhkm%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://www.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) ^\(times ^are ^utc)
[**@gvmtool**](https://twitter.com/gvmtool): &gt;[2013-07-15 11:12:06](https://twitter.com/gvmtool/status/356732903260033024) &gt;GVM 1.3.0 is ready for consumption! Features suggestive selfupdate, flush command and DRY candidates. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1idhkm%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://www.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) ^\(times ^are ^utc)
It can be installed pain-free from any bash prompt with the wonderful [GVM](http://gvmtool.net/): $ gvm install groovy 2.2.0-beta-1
As always, the [GVM](http://gvmtool.net/) folks are right on top of it. It's super easy to try out the new features with $ gvm install grails 2.3.0.RC1
Is this generally used throughout the Groovy community? Or it is "too new" yet?
I don't know, but a reverse range with take that take's from the logical tail seems wrong to me. (Your first example)
disclaimer not sure how all this will look def range = (100..1) println "$range.from to $range.to" &gt;&gt;1 to 100 (100..1).getClass().name &gt;&gt;groovy.lang.IntRange here comes the interesting part... [IntRange](https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/IntRange.java) public IntRange(int from, int to) { this.inclusive = null; if (from &gt; to) { this.from = to; this.to = from; this.reverse = true; } else { this.from = from; this.to = to; } * @param reverse &lt;code&gt;true&lt;/code&gt; if the range should count from * &lt;code&gt;to&lt;/code&gt; to &lt;code&gt;from&lt;/code&gt;. * @throws IllegalArgumentException if &lt;code&gt;from&lt;/code&gt; is greater than &lt;code&gt;to&lt;/code&gt;. */ protected IntRange(int from, int to, boolean reverse) { this.inclusive = null; if (from &gt; to) { throw new IllegalArgumentException("'from' must be less than or equal to 'to'"); } this.from = from; this.to = to; this.reverse = reverse; 
Static typing, grails, and gradle really boost groovy popularity.
I love groovy, and look forward to the day that it is as easy to find groovy resources as Python. Fingers crossed!
Current version of Groovy (2 and above) support static typing with @CompileStatic. It provides type inference, closure, compile time safety, better IDE support, better refactoring, and many more... Performance itself is similar to Java with some benchmark indicates better performance and other benchmark indicates slightly slower performance (slowest I see is only 2x, compared to dynamic Groovy which is on average 8x slower than java) @CompileStatic is the killer feature of Groovy that make me jump 100% to the Groovy bandwagon. Groovy has the best of both world, if you want to write simple script, you can simply use its dynamic nature. When you want to write serious and high performance application, you can switch to static mode while still writing more concise and readable code compared to Java. This + seamless integration with existing Java codebase and third party libraries is a win win situation for me. In my opinion, Groovy 2 is the real answer for Microsoft's C# in term of language features.
Nice, thanks for the answer.
Except I just realized this isn't proggit, it's groovit. Sorry everyone! :-)
Unfortunately it seems like Groovy's entry into the top 20 was a "bug". Or at least that's what the november 2013 edition of the tiobe index says: &gt;Thanks to a discussion with Henri Muurimaa we found a bug in our TIOBE index tooling for some Chinese site. This was the reason why Groovy got such a boost over the last few months. This bug has been fixed now. Groovy is now at the 32th position.
&gt; @CompileStatic is the killer feature of Groovy that make me jump 100% to the Groovy bandwagon. Groovy has the best of both world, if you want to write simple script, you can simply use its dynamic nature. When you want to write serious and high performance application, you can switch to static mode while still writing more concise and readable code compared to Java. This + seamless integration with existing Java codebase and third party libraries is a win win situation for me. Groovy's really only used for: (1) quick and dirty scripts using dynamic typing, making use of closures and terse collections syntax. This was creator James Strachan's original intention for Groovy (2) scripting for Grails, making use of the meta-object protocol. But Grails 3 may use Vert.x instead of MVC, and Vert.x is polyglot, so is scripted with Python, Ruby, and Javascript as well as Groovy (3) and _maybe_ scripting for Gradle (but Gradle still ships with Groovy 1.x). Gradle 2 might use other JVM dynamic languages for scripting (e.g. Clojure, JRuby) because the Android crowd don't like Groovy If you want serious static typing, best use Java, Scala, or Kotlin.
I know Scala and Kotlin have some serious static typing built-in. But Groovy just works and integrate well with existing Java codebase without any serious mindset changes. The learning steep is so smooth that I don't even have to spend my own dedicated time to learn Groovy, I just do my project and at the same time gradually switching to Groovy way of doing things. In addition to that, it's very easy to pass your code to the next Java programmer without them have to attend some Scala/Kotlin training. I might say that Groovy is just Java's syntactic sugar, but it is a great one. It doesn't have the latest cool technology in static typing. But it does what it does best: integrate well with Java. Maybe it just like PHP, it is shit language, which doesn't have any real feature/intent/design goal and just take a new features from here and there, but in the end, it works! I don't love my technology, I love the craft that I make. Use whatever works. 
Kotlin looks the most interesting of the non-Java JVM languages so far.
The second keynote from Grame Rocher on the 'Road to Grails 3.0' is also up at http://skillsmatter.com/podcast/home/road-to-grails-3-0/mh-8829
I am using Sublimetext and groovy is not limited to writing single script files (don't know if that was clear to you). I get the feeling that IDEs don't work particularly well with dynamically typed languages like groovy.
Thanks for the quick reply! Yeah, I get that I could one day be writing libraries, but I've yet to really write anything more than 50 lines of code so far. Does Sublimetext have good syntax highlighting? Did you need to download an additional plugin? I guess that's really what I'm looking for--and the option to use spaces instead of tabs ;-)
I use IntelliJ for my (mostly Grails) projects. Single files, I might edit with MacVim. GVM to manage my groovy/grails/gradle installs Both command line git and SourceTree for version control.
IntelliJ seems to work out a lot of stuff about groovy. Things that you might not make explicit. (Like named arguments, and Grails dynamic finders)
I use the groovy tool suite from spring source and really like it. It's got good junit integration. 
intelliJ pro v 13. It is pretty good with groovy. I have to run it in 32 bit mode however using java 1.6 otherwise the groovy plugin crashes my intelliJ every couple of minutes 
GGTS is really good, and it's free. Can't beat that!
Is IntelliJ Ultimate worth the price? It looks like a great IDE, but it's so expensive.
I use the NetBeans Groovy/Grails plugin.
tl;dr- Try SublimeText with Grails plugin (adds Groovy syntax highlighting). Long-winded version: I came to Groovy by way of Grails, so I started out using GGTS, their Eclipse edition. I liked it for managing the project, but Eclipse is fat and slow, and management doesn't buy fast computers (play violin here). When I was developing a Groovy script outside Grails, I just used GroovyConsole as the editor, and was fairly happy with it. I did miss auto-completion, though, along with some other features that typically come with more powerful text editors. I switched to SublmeText; this is a great text editor. Honestly, the multiple cursors thing? Golden. However, I'm a stingy ol' German at heart, and the gadfly notices that I really ought to buy have made me feel a bit guilty, so... I'm switching to vim, partly because I want to stop mooching off SublimeText without forking out $70, partly because I want to feel like one of the cool kids. This article is how I started getting setup: http://www.objectpartners.com/2012/02/21/using-vim-as-your-grails-ide-part-1-navigating-your-project/ I haven't done any serious work in it yet, though. I'm just starting. I've had to use vim for some server admin tasks, so I knew enough of how to get around that I was able to blaze through vimtutor pretty quickly. So the jury's still out on whether vim will take me there. Also, instead of using pathogen, as that poster suggests, I'm using [vundle](https://github.com/gmarik/vundle) to manage vim plugins. Here's my vimrc file so far. http://pastebin.com/9D1phU5M
I use Groovy a lot for file processing. As someone with lots of very current Java experience, but infrequently used shell, Perl, etc. scripting experience, Groovy is great for parsing and creating XML, delimited files, JSON, etc. I use it as test harness whenever I need to make web service calls programmatically, but want to do it fast. I've also used it in place of certain types of shell scripting for the reason cited above. It's easier for me to write, and also easier for Java developers to maintain than shell scripts. 
I use Groovy mostly for rapid prototyping and one-offs that will likely be thrown away. Since the language is already in use at my company I didn't need to sell it. We also have switched to Gradle, and while I think you can get by without knowing groovy to use Gradle it will be helpful if you want to do anything that there isn't a plugin for. PS: Gradle is awesome. Since Groovy allows you to write straight Java, you don't need to learn the whole language to start trying out some features. Learn just enough to decide if you think the language is worth digging deeper into. I think you can start to get a feel for it fairly quickly. That said, I am not a huge fan of Groovy. To me it is a useful tool with low barrier of entry both to start learning and sell to my management. My dislikes are more personal preference than serious complaints, so no need getting into an argument over them. Learn a little and see for yourself if you like it or not.
Groovy is useful for parsing XML and creating Mock Services via SoapUI
If you know Java, you already know how to write Groovy. You just need to learn how to read other people's Groovy code now.
i would be interested to know what your dislikes are. do you code in any other jvm languages apart from java? 
trying to convince our company to do the same, the java only devs are having none of it. 
I purchased the pre-release version of this book and it is pretty indepth. my only complaint is the fact that the writer is still trying to "sell" groovy to the reader, given that I have this book it seems pointless.
There are some small differences though http://groovy.codehaus.org/Differences+from+Java
That is true. The == difference has got me more than I'd like to admit. 
I use Groovy for writing lots of little throwaway scripts to automate tedious tasks. As an experienced Java programmer, Groovy feels more natural to me than other popular scripting languages. 
Do they know that their Java unit tests will also compile as Groovy?
Yes. The main complaint is "build time". we use a lot of scala as well so I just laugh at that argument.
I find Groovy very convenient to develop REST clients
Groovy smooths over a lot of the rough edges in java (To give two examples, null-safe navigation, all exceptions are treated as runtime exceptions). It also makes day to day things like manipulating collections very simple. I get the grumps if I have to use vanilla java now. Bonus for no semi-colons.
SSTS is an eclipse project (ugh). I use IntelliJ myself, which works extremely well. NetBeans also has built in support for grails (and is free), but isn't nearly as fast as IntelliJ the last time I used it. You can also just use the IDE as an editor, and use the grails command line services to actually run/test the app. This is probably the fastest way to do things, since you can use the grails interactive environment which keeps a daemon spooled up and ready, and makes good use of hot-deploy. The only time I really feel the need to run the app from the IDE itself, is when I want to do line by line debugging, which generally requires turning off forked executing anyway.
I found that the STS is a huge pile of shit. Netbeans does a better job if you don't have intellij.
Thanks for the info. Will try out netbeans sometime. Is the command-line available in Netbeans? Since sometimes there are things that need to be done from the command line that I don't know how to do in the IDE.
Yes I had earlier given thought to using the command-line for most of my tasks. Guess from now on that would be my primary way of working with SSTS.
And that's really not a work around / bad thing. The grails interactive command line is really quite nice. Combine that with some good plugins like auto-test and browser auto-reload, and you'll be exploding with productivity :)
Yes. It's to your advantage.
Yes, with a caveat: don't assume you should ignore the Java underpinnings. The huge amount of Java libraries (both built-in and 3rd party) are one of the best things about the JVM. Also, Groovy makes a lot of things easier, but you still need to be aware of basic Java-related concepts like the classpath and how it's object / class system works. But starting from Groovy will actually be much easier than starting from straight Java! Tip: Make good use of the [GroovyConsole (the GUI version)](http://groovy.codehaus.org/Groovy+Console), which makes experimenting easy and fun.
thanks can you elaborate ?
I agree with everything you just said. I would also add that you will likely have to learn some java along the way because you may have to interact with java libraries. Also, there are times in performance sensitive portions of code where I rewrite the groovy code in java for substantial performance benefits. For example, in my side project I needed to do some path finding on a graph and so used Dijkstra's algorithm. In profiling it was using up 50% of my cpu under load. I rewrote it in java and saw a 15 times speed up in my micro benchmarks. Not a 15%, 15 times. When doing a full load test again I was seeing twice the throughput and the path finding was trivial. 
That's a good point. There's some hope that the static compilation in recent Groovy will mitigate that, but static Groovy is practically just Java anyway. ;-)
You need zero knowledge of Java to start with groovy.
The biggest hurdle you will face with Groovy is the stack trace and errors it will throw up. It's a bit overwhelming at first. I find that Groovy is very similar to javascript.
Yes you can! Should you? Depends... Always chose the right tool for the right job. Groovy is easy to get started with, but its almost too easy to write extremely bad code with it. 
Just my two cents - I started Groovy with zero programming experience and managed to pick it up fairly quickly. It's **a lot** less verbose than Java and is an incredibly efficient language for business logic etc. As a side note: will you be using this for backend or frontend?
Groovy is like ruby in many ways. Basic groovy is pretty easy to pick up and run with, more advanced stuff bleeds over into the java API a bit. But you can google how to do just about anything in groovy, and there will be a nice stack overflow post with an example. There are a number of good books on it too - and the website has pretty good code examples with assertions. 
backends thanks
I always wondered about that. I think Groovy would be a good stepping stone to Java for those with little or no programming experience. No need to bother with objects/classes and go straight to simple stuff like loops and conditionals. Once the person has a grasp of this concepts, learning Java would be a lot less daunting.
JS(JavaScript) has nothing to do with Java (despite the name), so it's probably good that you haven't studied that. And since the authors of books on Groovy are invariably also very adept at Java, the distinction between the two languages can feel a bit blurred. This can be great as far as interoperability between the two languages, but can be bad as far as knowing whether you're actually learning Java or Groovy. Groovy definitely seems to need Java in order feel like a complete language. (The same can be said for Scala &amp; Java). You may like the fact that, like Python, it offers dynamic type-checking. But the only good way to find out if you enjoy Groovy is to get started on it. I have been examining languages one by one for several weeks now. Haskell was a struggle. Groovy was a much more pleasant experience. (But I think I may have finally found my home with Scala.)
Yes, I have done quite a bit of Java coding. I have done only a little bit of Groovy and Scala. There are many libraries available for Java, and many of them will also work with Groovy and Scala. I'm not sure whether it would be practical to do a GUI in Java (using one of the many GUI builders available), and connect that with a Groovy/Scala application. Not sure if there there are even any GUI builders in Groovy/Scala? Those are some experiments I'll have to conduct in the future. One thing I always like to do when exploring a new language is to make sure that the GUI (if any) and Deployment are going to be stumbling blocks. As I'm generally interested in multi-platform GUI applications, I will try to construct some basic GUIs - maybe using a couple of different technologies such as Swing (which is tightly integrated with Scala) and JavaFX. There are websites for GroovyFX (groovyfx.org) a Scalafx (https://code.google.com/p/scalafx/), though I haven't tried them yet. I will also practice deployments. With Java, deployment is quite flexible: 1. As a Java Applet, it can run in a browser, with sandbox. 2. As a Web Start app, it can be downloaded from the internet and run on the user's machine, outside of a browser. If the user doesn't have the necessary java runtime installed, it will automatically guide them through installing a newer version. 3. You can create a stand-alone app, which will install just like any normal app on your system (linux, OS X, or Windows). In this case it will still use your installed java run-time. But again, if you are lacking the Java runtime, it will guide you through the installation process. 4. Finally, you can create a *self-contained* stand-alone app. In this deployment scheme, you package everything needed to run your app (including the java runtime). This can make the file size huge, but that is exactly the form the Apple requires in their app store. Now as far as deploying a Scala or Groovy app is concerned, I'm hoping (haven't tried it) that deployment can be very similar to Java, since both scalac and groovyc produce JVM-compable .class files just like javac. But that's one thing you definitely want to try out early, before you've completely committed yourself to a new language. You may also want to explore how well the major IDE's work with your language - that usually will include Eclipse, Netbeans, and Intelij. If you want to get some practice with basic programming concepts, you can find some number theory problems over at projecteuler.net. There's also a "dailyprogrammer" reddit, though the moderators seem to have all but abandoned it lately. 
At my last company we did pretty much everything new in Groovy/Grails. It's awesome and I find my self coming back to it on my spare time. Now I'm pushing hard for the new company to switch to Groovy as underlying language whether Grails or Vertx is on top doesn't matter to me.
1. In contrast to other JVM languages like Jython, JRuby and Scala, Groovy is compatible with Java. It just adds extra features to the language you already know. 2. Reading and writing files is dead easy: String data = new File('/path/to/file').text String safer = new File('/path/to/file').getText('UTF-8') new File('/path/to/write').text = myString new File('/path/to/data').bytes = myData 3. Parsing XML is staggeringly easy: def doc = new XmlParser().parseText(something) println doc.Record.Item[0].@someAttribute 4. There's also [Grails](http://www.grails.org), a web framework which uses Groovy. 
No shit.
It's also worth noting that Gradle is based on Groovy scripts (gradle is a newer and rapidly growing alternative to Maven/Ant for build and dependency management). 
I've been using Gradle in a new project. I really like it, that's what got me curious about Groovy.
IntelliJ is the best IDE for Groovy development (by a mile). The free version of IntelliJ supports Groovy, but Grails support is only available in the paid version. For this task, the free version should suffice. To work on this project in IntelliJ all you need to do is * Create a new IntelliJ project * Add a Groovy module to the project * Add the JMeter libraries to the module. How exactly you do this depends on how your project is built (e.g. Ant, Maven, Gradle). In the simplest case, you'll need to * download the JARs containing the JMeter libraries * right-click on your module and choose "Open Module Settings" * add the libraries in the "Dependencies" tab
Here's the example from [RunHibernateGorm.groovy](https://gist.github.com/graemerocher/c25ec929d9bcd1adcbea): @Grab("org.grails:grails-datastore-gorm-hibernate4:3.0.0.RELEASE") @Grab("org.grails:grails-spring:2.3.6") @Grab("com.h2database:h2:1.3.164") import grails.orm.bootstrap.* import grails.persistence.* import org.springframework.jdbc.datasource.DriverManagerDataSource import org.h2.Driver init = new HibernateDatastoreSpringInitializer(Person) def dataSource = new DriverManagerDataSource(Driver.name, "jdbc:h2:prodDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE", 'sa', '') init.configureForDataSource(dataSource) println "Total people = " + Person.count() @Entity class Person { String name static constraints = { name blank:false } } 
Doesnt look very up to me: http://i.imgur.com/wd2VHO2.png
I am seeing the same thing the OP is on my iPad, but my work PC sees the correct site. Seems like some weird DNS issues?
Still blank for me. Could be that our DNS server hasn't been refreshed yet. 
Yeah, I think it takes time to roll changes out to all the DNS servers in the world so makes sense that some would work, others are blank. Of course this happens when I need docs today. 
Gone for me too. Same view as Jdban
Declaration works slightly different in scripts to classes. From the [docs](http://groovy.codehaus.org/Groovy+Shell#GroovyShell-Variables): using the `def` keyword will create a local variable. To declare globals, omit the type information (don't use `def` or `int`).
so..."def x" and "int x" are equivalent ?
Downvoted because this guy has been spamming the shit out of the Internet with links to his blog posts (e.g. Groovy questions on http://stackoverflow.com)
Nice. When is Grails getting it?
I *think* in grails 2.4 https://grails.org/Roadmap 
I played with the M1 release a bit, but there's so much new stuff to digest in 2.3 and 2.4 I'm not ready to jump to 2.4 yet. Probably June/July.
Compared to Visual Studio's price it's almost free! It really is an amazing IDE. I use it for pretty much every language.
The description of what you want to achieve is *very* hard to follow. I think it would be a lot simpler if you just showed an example or two of 1. what the string should look like before it's processed 2. what the string should look like after it's processed 
Sure! Before: STUFF|THINGS|20140618|MORETHINGS|MORESTUFF|2014|ETC After: STUFF|THINGS|20140618|MORETHINGS|MORESTUFF||ETC The "|2014|" will always be in the same pipe-delimited segment (the 6th one, in this example), and the date will also always be in the same pipe-delimited segment (3, here), but there may or may not be additional instances of '2014' before the "|2014|" that I'm trying to nuke.
what about: String s = 'STUFF|THINGS|20140618|MORETHINGS|MORESTUFF|2014|ETC' s = s.replace('|2014|', '||') This will only replace a 2014 that is surrounded by pipes. If there can be more than one of those, then that's still a problem.
I will try that - thanks! :) Edit: looks like it works - thank you so much for your help!
I was able to introduce it in my company. For me what did the job is that I showed my colleagues Spock framework, my team just loved it.
Are you doing this to learn Groovy, or to just get the work done? The only reason I ask is there are better tools for this, but if it's a task specifically to learn Groovy then that's another matter.
`getHttpVersion` does not return the HTTP version, it returns the content of the page
In this case is a *REST* operation, and the content of the url is a version number :) It's used for differentiation with *getJmxVersion()* and *getHJmxAppName()*
 if (line ==~ /^#.*$/) { return // skip comments } Of Perl memory... (more or less :P )
Ah ok. When you can constrain your inputs things become a lot easier =) In doing this sort of thing in the past with different languages I tend to do the equivalent of: s/#.*//; (remove all comment text) continue/next/etc. if resulting line is empty or all whitespace But of course this fails if "#" is a valid character for things other than comments. But your solution seems perfectly valid.
Groovy is not slow. Compiling may take a little bit additional time to convert the Groovy files to Java Byte code, but there should not be any issues at runtime. 
Compiled in bytecode is as slow as Java is 
Not dynamic allocation, but dynamic dispatch. Groovy methods are not "bound" at compile time like java is. In java when you write a call to a method, the compiler makes sure it's actually something that CAN be called, and gives you a compile error if not. Not so with Groovy. In Groovy, you can write: def x = new String("Foo") println(x.heyThere()) and it'll compile. The reason is that the code that gets compiled actually *LOOKS UP* "heyThere()" to see if it exists, and if it does, calls it, and if not, calls another method (methodMissing()) instead. This provides a very powerful language feature, but it is also slower than not having to look it up. There is a class annotation (@groovy.transform.TypeChecked) available that can warn you if you are writing in this manner (so you can avoid typos). Another (@compileStatic) that tells groovyc to do the same thing java will, so that you just can't compile that code at all. In the latter case, the runtime will have the same performance as java, but you lose the ability to have this dynamic nature, which you do need for certain types of programming. (Edited to add the actual annotations. Thanks http://www.reddit.com/user/karlthepagan and http://www.reddit.com/user/quad64bit)
Campbellm has the correct answer. I would like to add that "slow" is a relative term however - in the space where groovy is often used, such as grails web applications, test frameworks, and build tools (Gradle), it's really not all that slow, and is generally fast enough considering the real bottlenecks are the database or time it takes to run tests. The problems it has are shared by many dynamic languages, often for the same reason, however, it does tend to be a lot faster than some (such as ruby) due to the high level of optimization provided by the jvm. Further, optional typing is optional, and typing combined with the new compile static annotations, you can write number crunching code that is on par with java. This is the flexibility that people talk about with groovy. Try it yourself! Write the same program in groovy and java, and time the difference. For-loops with a few thousand iterations should do the trick, try calling simple typed and untyped methods, and play with compile static! Have fun!
This is the correct answer. I might add that some of this can be avoided using @CompileStatic.
"Extremely" is a relative term. Groovy is fast compared with other non-Java JVM languages, especially since Java 7 and the invokeDynamic bytecode command (google it to learn more). You can also use @CompileStatic on a subset of Groovy features to get same-as-Java speeds, basically because it ends up creating almost identical bytecode. The benefit of using a JVM language is that for the few places where your code might have performance bottlenecks you can simply write a pure Java class and use directly with Groovy (or almost all JVM languages). Keep in mind that for most code you'll write, performance probably won't matter much. Things like easy to understand, easy to test and maintain, not taking up too much ram, etc tend to be more important concerns. 
An empty map literal looks like this: `[:]` You probably want to be iterating over `sprites.entrySet()`
The groovy as a domain specific language book is a great starter. 
A DSL is a bridge between the programming model of the system and the human mental model of the non-programming user. It's better to start from the user endpoint to determine the common parlance they use to get their job done. Then use the same language they use to build out your function and data names. You don't really give much information about what your doing only how you are handling it(converting/normalizing json.) A non-programmer shouldn't have to know JSON or how it works, only how he works. If the resulting DSL is foreign to the user then adoption will be as tough as actually just teaching them how to program themselves in the first place.
Groovy can run client side like javascript in the browser, I think.
&gt; What I'm looking for are ways to make the the DSL as simple as possible; i.e. less unnecessary punctuation, etc. You're in luck. Guillaume Laforge has a presentation devoted to this very topic: [Going to Mars with Groovy Domain-Specific Languages](http://www.slideshare.net/glaforge/going-to-mars-with-groovy-domainspecific-languages) ([transcript](https://groovy.codeplex.com/wikipage?title=Guillaume%20Laforge%27s%20%22Mars%20Rover%22%20tutorial%20on%20Groovy%20DSL%27s)). &gt; And if I could get rid of the required imports on top of each file, that would be nice too. That's covered in the presentation, but for more details take a look at the [ImportCustomizer](http://groovy.codehaus.org/api/org/codehaus/groovy/control/customizers/ImportCustomizer.html) examples [here](http://groovy.codehaus.org/Advanced+compiler+configuration).
Here's a YouTube video of the talk: http://youtu.be/M1jS53bnI5A
I know this is late but: Try using a DelegatingScript, it allows you to put a object into your script which will handle all unkown method calls, the same way you would do with a delegate on a closure. This way you practically can remove all import calls, if you'd use only primitives in the input methods. However their is a catch, this is only supported in groovy 2.2.1 and higher or something. When I used it, it was not yet available for eclipse and I used a live build, this might be different now.
Groovy in Action 2nd Edition might never come out, but it is a good reference, so if you get it, just get the e version. They keep updating it because the language keeps evolving. Programming Groovy 2: Dynamic Productivity for the Java Developer https://pragprog.com/book/vslg2/programming-groovy-2 Is another really good book By by Venkat Subramaniam. This one is an easier read, because it doesn't read like a reference book. Making Java Groovy http://www.manning.com/kousen/ While I haven't read it I've seen Ken Kousen talk, so this maybe another good book if you're coming from Java. If I was starting out I would also look for online video tutorials: http://www.reddit.com/r/groovy/comments/2e8pzu/all_the_groovy_videos/ http://www.infoq.com/presentations/Transforming-to-Groovy And checkout Groovy's new documentation including the Groovy JDK and Groovy Apis at http://groovy-lang.org/ http://groovy-lang.org/api.html http://groovy-lang.org/gdk.html Also they have a google+ page which might become the go to page for questtions over the old nabble forums: https://plus.google.com/u/0/+groovy/posts There was talk at SpringOne 2GX Conf of killing the nabble forums, but they might be a good place to look at questions and answers: http://groovy.329449.n5.nabble.com/groovy-user-f329450.html 
Why might not GIA 2nd edition ever come out? 
It will be released, but the authors (in particular Dierk) are busy, and not overly concerned with concepts like publisher deadlines :) The MEAP version is nearly complete, so you can buy that at http://www.manning.com/koenig2/. According to the web site it'll be released in February.
Griovy in Action is still probably the most complete and useful guide. It wouldn't take long to look at all the release notes for updates to see what has been introduced. 
Yeah February is an estimate, and that's probably the 12th time, or so it's been pushed back. But the book itself is a really good reference. Also anyone getting into Grails should get your book Programing Grails.
Groovy can easily go after private things in java classes, so ... not sure it's possible. What you might try is use a delegation pattern. Say your java class is "Foo". Create a "RestrictedFoo" that has a "Foo" as a member. In RestrictedFoo, just have methods that you want to expose that delegate to your Foo member. This won't prevent people from getting the Foo and using the methods on it directly of course, but it's at least a start.
Sure it is. There's a gradle plugin for it and everything. Works like a champ and would recommend it.
I think code quality tools are overrated. Your own two eyes are often the best tool. Better, two sets. Pair programming is great for code quality, stamping out bad habits, and promoting good ones if you can get everyone on board.
There is a web proxy called Burp Suite that provides an API for developers to write plugins. They solved this problem by providing only Interfaces and any referenced classes are highly obfuscated before compile time. Their approach was to restrict access by making the classes/methods they don't want anyone using completely unintelligible. Not sure if this is what you're looking for, but I thought it might pique your curiosity. Portswigger (the company who makes Burp) has a great tutorial on their blog on writing a Burp extension, as well as some example projects. 
Also working on a team, it may not be possible to assess every commit, as well as the overhead of such a task on a daily basis.
Sweet! It would be cool to see the same list of resources for all the other JVM languages out there. It seems like groovy leads the pack in this regard but I'd like to see some evidence :-)
There are quite some lists out there for other languages indeed, but not all JVM. C++ and Python were just recently posted in /r/programming
They may have officially switched over to http://groovy-lang.org/, but I never saw an announcement.
Looks like you're right. Thanks.
Also, it look like groovy.codehaus.org is back up.
It's an interesting experiment - it's Confluence with a customized skin that does a good job of hiding that it's a wiki. But it will be good when they've transitioned away to a proper web app.
Maybe :) More likely Gaelyk though, since it runs on App Engine and it was created by Guillaume. http://www.ratpack.io/ is the cool one currently though - similar to Node.js and Vert.x, but probably overkill for a content-rich site. We will have to revisit though when Grails 3 starts being stable - it'd be crazy to not do a rewrite of grails.org from scratch, highlighting all the best stuff in 3.x. And then we can do the same for groovy-lang.org :)
This data is a direct copy from https://github.com/kdabir/awesome-groovy Other "awesome" lists are: * https://github.com/razum2um/awesome-clojure * https://github.com/lauris/awesome-scala The right scrollbar on Groovy's list is a lot bigger than on Scala's or Clojure's lists. And, unlike Scala and Clojure, Groovy's list uses double spacing, includes links to blogs and non-Groovy-specific apps like Vert.x, and has a large "contributing" section at the bottom, all of which makes it look like **Groovy's covering up a lack** of libraries and frameworks compared to Clojure and Scala. 
You obviously have no idea what you're talking about.
You obviously didn't answer the question.
This isn't a debate forum and your question both evidences ignorance and is Google-able. Edit: plus from a new user this seems like a troll. Performance: groovy's calls are usually only around 50% as fast as java invoke dynamic, but you can get closer to a tie with the right JVM. http://groovy.codehaus.org/InvokeDynamic+support http://www.techempower.com/benchmarks/ (compare vs spring for a practical answer) Comparisons with Ruby and Python are also on the codehaus site. Have a look and tell us what you think.
&gt; IF somebody needs a concise and dynamic language to write softwares, they will just go with Ruby or Python. Groovy is far more inspired by Ruby than Python. It's creator James Strachan basically took the Beanshell codebase and added closures. The present project manager then translated the closure-based methods from Ruby into Groovy. &gt; IF somebody needs to build web apps, Ruby on Rails (which heavily inspires Grails) and Python (lots of great and mature frameworks too) or maybe PHP (lots of great and popular frameworks too) are excellent choice too. If you need the JVM, try JRuby, or Scala's Play, or build with components written in Clojure. &gt; If for some chance your answer is related to "performance", um well I should just get into a static programming language. Just use Java 8 if you need the JVM -- it's far more likely to be supported x years down the line. 
I haven't tried the Koans myself, but [this answer on StackOverflow](http://stackoverflow.com/questions/17055814/groovy-dataset-findall-ast-not-available-for-closure) might help.
scroll down. It's not a new phenomenon. EIT: http://www.reddit.com/r/groovy/comments/1z44nn/groovys_site_is_gone/Q
Thank you very much. I'll check and let you if the knowledge in that thread resolve my problem.
I've tried all day long without success. I tried env CLASSPATH... || groovy -cp ... || gradle.build || Intellij. I'm disappointed :(
Nvm, need to read up on matchers, regexes, patterns...
runAfter is a method added to the MetaClass of the Timer object. I think the meta methods are added at runtime. 
AH HA. Thank you. Pointed me in the right direction of understanding exactly what the hell was going on. Some more information: [IBM on Metaprogramming](http://www.ibm.com/developerworks/library/j-pg06239/) [Slideshow on Metaprogramming with Groovy](http://www.slideshare.net/ilopmar/metaprogramming-with-groovy) 
Sublime Text works pretty well with Groovy. Just found this [link](http://groovy.codehaus.org/Other+Plugins) as well.
I also prefer idea Intellij, for personal use the licence is $200(well worth it), but if you can hold out they usually have one really good sale once a year, where I picked up a copy for $50. Other than that there is the Groovy/Grails Tool Suite, which is free and based on Eclipse http://spring.io/tools/ggts I've had mixed results with this in the past, but it's free, so at least worth a try. Also don't for get you have grails console: http://grails.org/doc/2.0.2/ref/Command%20Line/console.html Which can be useful for debugging/playing with code, and looking at the code generated from an ast transform.
Thanks a lot! I actually already have TextMate from a different project so I'll check that one out first.
Thanks! I started goofing around with Groovy in a Mint virtual machine so I have only used text but the IDE sounds good too.
Like these other guys have said, IDEA is a great product. Their free edition supports groovy too: https://www.jetbrains.com/idea/download/ It's not the quickest program to boot up, but honestly, if you're writing something longer than 10 lines, the gains of having an IDE are well worth it. 
On it, TheDaringHedgehog!
Yup, using the Eclipse tools sweet. Can't beat the price
i think that's possible if they just change their online editor. there are many online code editors that support auto completion. see codemirror demo: http://codemirror.net/demo/complete.html
Probably. Without seeing some of the code though its pretty hard to give you pointers. In general though have you run it through a profiler? Trying to guess what's slow is almost always the wrong solution.
install [grails-melody plugin](http://grails.org/plugin/grails-melody) * First read docs on what it does * Next let your slow code thing run for a bit. * Last check dat data from melody it will tell you what is slow.
The first screenshot is after clicking one of my buttons. The second screenshot is my current very weird fix, and I would like to know why this is working this way. If anyone could let me know that would be awesome!
the others already mentioned profiling, but if I undestand correctly you are saving something to a database? Could be hibernate flushing way to often or disk reads reading too small segments. Huge time chunks being spent on what seems like small amounts of data almost always are related to slow disk access or network access. 
You need to step through the code so you can see what is happening. I don't know eclipse but in netbeans and IntelliJ for normal Java it is very simple. Here is the eclipse step through page. http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-stepping.htm 
I'm not sure what Griffon is, care to elaborate a bit?
I hadn't but I just did a couple seconds ago and printing each i and j produced the expected output (0, 0 0, 1 ..... 7,7). I'm not familiar with threading issues or even what that is so this is about as far as I can go on this line of troubleshooting at the moment. Adding a sleep(5) after the square initiation line resulted in the same error messages. Initiating the square instances outside of my swing setup resulted in the same error messages as well. Thank you for your insights though, definitely gave me a couple more tools to use when troubleshooting in a language like this that I wouldn't have thought of. 
stepping through with the debugger did not really net any valuable information. The values of i and j are always what you would expect them to be, even at the line where I'm assigning the actionHandler. Thanks for your suggestion though.
http://new.griffon-framework.org/ Griffon is desktop application development platform for the JVM.Inspired by Grails, Griffon leverages the use of the Groovy language and concepts like Convention over Configuration. The Swing toolkit is the default UI toolkit of choice however others may be used, for example JavaFX. 
it's a way of using gui frameworks with groovy. good luck on the hackathon.
oh nice, thanks
You need to step into it further then. The pointer to i and j is being nulled at some point. It could be that since your code doesn't operate in lock step the reference to the int's value is completing before the actionhandler can get to itself and you've already exited the loop. Actionhandler looks like an [eclipse thing again](http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fapi%2Forg%2Feclipse%2Fui%2Fcommands%2FActionHandler.html). Try this. Get rid of x and y again and go back to using i and j. Print i and j in the loop. Inside your minefield code have the first thing it do be print the values as well. I am thinking you might be getting LOOP 0,0 MINEFIELD 0,0 LOOP 0,1 . . . MINEFIELD 2,3 LOOP 7,7 &lt;---loop exits and the variables i and j go poof here Exception &lt;---minefield tries to access the reference for i and j but the references are gone You could try making a queue, synchronizing the loop, or just rely on doing it like you are. 
If the code wasn't running in sync, I meant syncing the loop with the desynced part. Put the part for minefield in the actual minefield class that will be running referencing the objects that are passed.
I moved the minefield println to inside the constructor in the Square class and got the same output as above.
So it didn't generate an exception?
it did generate an exception when I pressed any button, same as the original post.
I will as soon as I get home from work, thanks!
I second reading 'Clean Code'. I agree with most everything /u/g-money-cheats said, and to expand on the "structure of the code needs a lot of work", a great first step would be to extract smaller methods out of your `getData` method. You really want your methods to be as small as possible... just a few lines each ideally. Start with the bodies of those if/else blocks. This will decrease the cyclomatic complexity (level of indentation), divide it into more manageable chunks, and allow you to write meaningful method names for those chunks to make the code more comprehensible
New version https://github.com/Flukas88/allstatus/blob/master/Version.groovy
Why not use the IntelliJ-embedded Groovy console which supports beautiful code-completion on-par with Java? Open IntelliJ, go to the "Tools" menu, select "Groovy Console". Type some code. Run with Ctrl+Enter.
Just small hint: don't use Java-style for loops in Groovy! Want to loop 10 times? ``` 10.times { println "Run number $it" } ``` EDIT: write this in Groovy, not Java
If you are just getting into groovy, I posted a good list of resources here, including books, websites and videos: http://www.reddit.com/r/groovy/comments/2hlkn7/whats_the_best_basiclevel_groovy_reference_book/
Thank you!
Perhaps not always 'best practices', but something I turn to now and then is http://pleac.sourceforge.net/pleac_groovy/
Sad
[and odd](https://www.voxxed.com/blog/2015/01/sad-odd-decision-pivotal-set-groovy-adrift/)
Ugh, that really sucks
What version of Groovy are you using? I tried both in the groovyConsole and they both ran fine. You might want to try upgrading your Groovy version. 
Confirmed the problem still happens with version 2.3.7.
Strange tried it again and it fails(2.3.7 and 2.4.0). If you change public myClass to def it will work fine. I've never running into this issue because I use the Java convention of having the class name start uppercased. &gt; println 0; &gt; class myClass &gt; { &gt; public myClass(int j) {}; &gt; public myClass method() {return this}; &gt; } 
Yeah, it does seem odd - but I also suggest sticking to normal class naming conventions. 
I totally agree...and this is something I discovered more or less accidentally. It's not a serious issue, but again, capitalizing class names is just a convention and not an actual syntax rule (unless someone tells me otherwise). Which means this code should compile; why doesn't it? One thing I noticed is that the presence of the constructor is irrelevant...the method alone causes the compilation error. It doesn't like the myClass return type for some reason.
I didn't copy it onto a personal device yet, monday.
One of the quickest ways to learn groovy syntax is to give up all "for" loops (and the "if"s within them); there are always much better alternatives using the groovy way. Also, file reading and file manipulation, in general, are simpler (no Streams, exceptions, cleanups, etc.). Think: file.eachLine { //processLine } 
**Edit:** Just tested this, it works. **Edit 2:** Updated with a selector I run a few onion sites that are written in Grails but have never had to scrape through Tor. Maybe something like this: @Grab(group='org.jsoup', module='jsoup', version='1.7.2') import org.jsoup.Jsoup import org.jsoup.nodes.Document System.properties.putAll( ["socksProxyHost":"localhost", "socksProxyPort":"9050"] ) Document doc = Jsoup.connect("http://secretsxsrvlpawm.onion/show").get(); println doc.title() println doc.select("#secretText pre").text() The onion mentioned in the URL is my own. This utilizes the SOCKS proxy that Tor provides. This code snippet should be a good start for you.
This is the best description I've read about groovy. I agree with you. I see a bright future for the language.
I just used the Groovy website and books. Only stumbling block I had was that you can't put groovy in #!. You need to call env: #!/usr/bin/env groovy It's useful to build a wrapper script that sets JAVA_HOME as well for you. @Grapes, CliBuilder, and classless script format are all useful as well as a good handle on regular expressions.
"new"
I do the same thing. It just makes sense for a Java developer to use Groovy for scripting.
I've replied to several of other post under groovy with resources, and more recently I gave a lightning talk at nejug, these are the slides I put together: https://docs.google.com/presentation/d/1RzlbuNoI3CDC9O30YJEcZybVCG1vUAZgNf5kdrE8pAA/edit?usp=sharing There are lots of links to sites, book and videos in the slides. I didn't realize it but the content I gathered, actually became a prelude for me to give a bigger talk.
Search for web scraping libraries in java. That's one of the beauties of Groovy, all java code can be uses in it.
We use JSOUP for web scraping, works quite well. It's a Java lib, but like others have said, that's what is great about groovy :)
Gradle is a wildly active project with regular releases and great support. Join the converts over at /r/gradle
Gradle is very much _not_ a Pivotal product - it is not "their own build system". It is used to build many of their products, but that's because Gradle is a great build tool. [Gradleware](http://www.gradleware.com/) is the company behind Gradle and it's completely independent of Spring/VMware/Pivotal/etc. And it's not like Pivotal made Groovy disappear - they just stopped funding the development. That's a big deal, but Groovy isn't going away. The development pace may slow, but the committers and contributors will continue to commit and contribute, and hopefully we'll hear soon that some other company has decided to hire the Groovy team. Also note that Groovy is the scripting language for Gradle builds, but Gradle is written almost entirely in Java. Pivotal's dumb decisions have nothing to do with Gradle and it remains the only sensible build tool to choose.
Thank you, but I ended up using brew install groovy. Not sure if that has any drawbacks yet
As awesome as Groovy is - and it's much better than Roby/Python IMO - that's one of the big drawbacks to the language and the main reason it hasn't seen more adoption. It's hard to pickup without a Java background first. I would think any of the Groovy books would still suffice but if you're finding it hard, then pick up a Java book first and then come back to Groovy.
I'm sure brew will be fine. I just like the GVM because it allows me an easy way to switch between versions, of Groovy, and other Groovy based projects, taken care of environment variables. The ability to switch back and forth easily is useful when doing upgrades. Also the GVM has been kept up to date, in a very timely manner, where I find most package managers tend to lag somewhat.
A little self promotion but some video tutorials: https://www.youtube.com/playlist?list=PLzerMl1XZ0X1KwRPzJwXMCUjtuzX2KkGr These tutorials are more beginner programming, but still groovy related(skip the first one) https://www.youtube.com/playlist?list=PLzerMl1XZ0X3Q5kdY2jtACBmEZSxbD-RA This is a great book to get started, very easy read: https://pragprog.com/book/vslg2/programming-groovy-2 This is a more comprehensive book: http://www.manning.com/koenig2/ Website(new site documentation is a little wip): http://groovy-lang.org/ http://groovy-lang.org/single-page-documentation.html Beyond that book the things from Java that might not be explained I think would be package structure, imports, and inheritance. You could probably Google a tutorial on those topics in java, but it depends on how much you want to do with Groovy. If you just doing some scripting you can probably get by with the books and the website. If you are going to do some more serious application development then you'll need to learn some basic Java(inheritance, package structure) 
&gt; It's hard to pickup without a Java background first No.
I picked up this book and it was pretty easy to pick up if you're familiar with Ruby. It does a good job of going over the "java" aspects of groovy without going into too much detail. And its fun! http://www.amazon.com/Grails-2-A-Quick-Start-Guide/dp/1937785777 Ack, I just realized that was Grails... but it was very fun and informative for me personally.
This is neat but with new tools like these, it's always hard to figure out to fit it into the stack. Like it would be great if an angular app could be written in groovy and then integrated with grails.
&gt; 'm not a huge fan of groovy, but I like it more than ruby and python because it has such good type hinting Okay. I wasn't really aware of this. Did you just mean *statically* typing the types like String foo = "bar" instead of def foo = "bar"
And IDEA still doesn't support it. [IDEA-136970](https://youtrack.jetbrains.com/issue/IDEA-136970)
Lots of constructors have a few variables that are required as inputs. Why waste time manually setting it when a simple symbol would do it better. Why write out stuff for a computer to interpret when a simple regex could solve it for you. This method is also alot easier to read now. CBash(String =&gt; name, Closure =&gt; input, Closure =&gt; output) { Into CBash(String name, Closure input, Closure output) {\nthis.name = name;\nthis.input = input;\nthis.output = output; I wrote some regexes a while ago that did this. I'll dig them up sometime.
Pivotal announced that they won't be contributing to Groovy-Eclipse or GGTS, so if this happens it will have to come from the community.
http://kyleboon.org/blog/2015/02/23/groovy-gvm-and-go-gvm/
That's real funny. Any particular packages I should check out?
Yup, exactly. I do use a lot of the collection'y FP stuff; `inject`, `grep`, `collect`, etc. It makes things a lot quicker and easier to grok. So tired of writing `for` loops. And the operators. `?.` especially.
I've used groovy together with jme3, it's a lot of fun to play around with, I used it to show ai agents in flocking behavior for a school project. I stuck at making the models so it didn't look that great. Later I went a bit weirder with another game hobby project where I created a groovy dsl that was handled by scala delegates. Scala is bad as a scripting language (to difficult for hobbyists) but groovy is great for that purpose. In my opinion groovy is java but easier. 
[Gradle's](http://gradle.org/) your pal.
We use maven for all our builds and use the groovy-eclipse-compiler plugin to build our mixed java/groovy sources. No complaints, just works. Sample plugin stanza from one of our builds &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;compilerId&gt;groovy-eclipse-compiler&lt;/compilerId&gt; &lt;compilerArgument&gt;nowarn&lt;/compilerArgument&gt; &lt;verbose&gt;false&lt;/verbose&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-eclipse-compiler&lt;/artifactId&gt; &lt;version&gt;2.9.0-01&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-eclipse-batch&lt;/artifactId&gt; &lt;version&gt;2.3.4-01&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 
Cool. Not sure if Im out of date on any of the above but we're using java 1.8 so can't be too far behind. 
Yep. The pom.xml provided by /u/geodebug would look something like this (pretty much off the top of my head, but pretty darn close), in its entirety: apply plugin: 'groovy' apply plugin: 'eclipse' So, that's `build.gradle` in its *entirety* for a (very simplistic) Groovy project and associated Eclipse files... Pretty terse, huh? Where gradle really shines is this: $ gradle tasks Lastly, if there's something wrong with your `build.gradle`, it'll tell you so in a slightly more approachable way. Edit: IntelliJ IDEA supports gradle. Further, if you want to create IDEA metafiles, add this: apply plugin: 'idea' Neat, huh? 
I would create a dsl rather than a string parser. looks cool enough though. Have you bench marked it against other libraries (if there are any)?
Do you have groovy as a dependency?: apply plugin: 'groovy' dependencies { compile 'org.codehaus.groovy:groovy-all:2.4.3' } 
I tried this, and got a new error: :compileJava UP-TO-DATE :compileGroovy FAILURE: Build failed with an exception. * What went wrong: Could not resolve all dependencies for configuration ':compile'. &gt; Cannot resolve external dependency org.codehaus.groovy:groovy-all:2.4.3 because no repositories are defined. Required by: :Groovy:unspecified * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. BUILD FAILED Total time: 2.963 secs
You do not have repositories setup repositories { mavenCentral() } Should work.
I don't think that you'll find one, they tend to get out of date really fast, so I think when you they moved to the new site, they decided that they were not going to publish a road map. They talked about it at a BOF session during last years Springone 2gx, and they were hinting that it might go away for both Groovy and Grails. I think the closest thing that you'll find is the jira page: https://issues.apache.org/jira/browse/GROOVY/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel
More likely "they" decided to drop the rewrite of the MOP for Groovy 3.0, and want to avoid the sort of outcry that came when they dropped the heavily roadmapped MOP rewrite when upgrading from Groovy 1 to Groovy 2. See http://groovy.329449.n5.nabble.com/Release-Grumpy-Mode-tt4978117.html for the details, e.g. Russel Winder: "*Did I miss a memo? Did we debate this extremely radical change to the road map? How long has this decision been made? I appreciate decisiveness once a reasonable majority of opinion is in agreement, I am not particularly pleased to see that decision making about the Groovy project appears to be being made by a secret cabal behind closed doors.*" 
groovy is great! Gradle uses groovy for build tasks - quite nice. Groovy is great for any type of quick data mining or API querying script. Pretty much anything I used to have to write a one off app for is now a simple 10 line groovy script.
I use groovy constantly. It is my general purpose scripting language of choice. My favorite feature for standalone scripts is the Grab annotation. Just stick something like @Grab('org.springframework:spring-orm:3.2.5.RELEASE') At the top of your script and all the maven dependencies will be pulled down and cached for you. You have all the java and groovy code in the world at your fingertips for use in your tiny utility scripts.
That's freaking awesome.
Fuck. I wish someone had told me about that a year ago. This is going to make some things so much easier.
We use Gradle extensively, and I do a lot of work on internal tools and build automation, so yes. My favorite thing I've made is a yaml-based config for Jenkins jobs, which I'm actually hoping to open source soon, and it would've taken longer to write if I didn't have access to Groovy's awesome closures and the crazy shit you can do with closure delegates. It's main benefit over other similar tools is that it's component based (so you can mix and match different bits of jenkins config) and unlike JJB, it's not limited to the XML tree used by jenkins. The syntax looks a bit like this: ``` - ownership: team: example email: !template ${team}@example.com - basicJob: name: foo-project git: provider: github pullRequest: gradle: tasks: build ``` Which would generate two jobs, "foo-project" and "foo-project-pr-builder" (the second one is identical expect it watches for pull request commits instead and doesn't otherwise trigger), defaults to `example/foo-project` in github for branch `master`, and builds using gradle. It can also create chains of jobs i.e. pipelines. Everything is scoped and overridable, so you can set defaults at the top and then customize as needed. My experience is that 99% of the stuff a lot of our projects did was the same, but it got really frustrating trying to template out the 1% that was different, hence why I made this.
Don't forget about [groovyConsole](http://www.groovy-lang.org/groovyconsole.html)! It spins up a little text editor to run groovy scripts quickly. I use it all the time when I need to do something or test a small function.
I have used groovy as a scripting language, and also mixing it with java in a lot of projects ( thanks to maven groovy eclipse compiler plugin). In my experience when you use groovy you get: * Smaller codebases : this is thanks to closures , enhanced collections , compile time metaprogramming, syntax sugar, local type inference and POGO conventions * Simpler code: I usually don´t need to implement design patterns, because I use Functions(closures) and pass them as parameters. The code ends up beign way more readeable and understandable. * Same performance as Java if you annotate groovy classes with @CompileStatic * Seamless integration with java code: but beign honest, 'extension methods' feature doesn´t work from Java. That is a pity, because is a very powerful feature ( Does anybody knows if that is possible in kotlin?) IMHO groovy is the best JVM language available today (from a software engineering perspective). Of course you need to be careful about its use: use @CompileStatic( or at least @TypeChecked) and try to avoid runtime metaprogramming. **TL;DR**: I have made my jobs a LOT easier using groovy 
Do you know Java and web application development already?
I have not seen a compelling reason to switch to v3. Eventually I will need to pick it up but as it stands, v2.*.* is great for me. I believe IDEA will have v3 support in the next version.
Between the lack of IntelliJ IDEA support and existing plugin compatibility you would be better off learning on the latest 2.x release for now. Here's some links to follow for status updates: * [IDEA-136970 Support for Grails 3.0 ](https://youtrack.jetbrains.com/issue/IDEA-136970) * [Grails 3 Priority Upgrade Plugins](https://github.com/grails/grails-core/wiki/Grails-3-Priority-Upgrade-Plugins) * [Grails 3 upgrade path: plugins you want migrated](https://groups.google.com/forum/#!topic/grails-dev-discuss/ZwNpH1MnSGI)
Kotlin extension functions work from java! ```fun T.somethig(params) : R``` compiles to ```R something(@NotNull T receiver, params)``` EDIT: btw, I like kotlin a lot more than a groovy. And your words about "best languages available on the JVM today" are heavily doubtable. It's hard to compare groovy and scala or clojure for example. Groovy is cool for scripting, but it's not the language that will be used by the mainstream crowd. Scala is not going to be mainstream either, but it niches to completely opposite direction. Kotlin on the other hand, has completely opposite goal. It as generic as it goes. It is made to be adopted by mainstream and to replace java(that is doubtable though :D). Plain modern boring( =&gt; obviously not the best of JVM lol) architecturally-mistakeless(or rather "we fixed all the java things") languange. It has all chances to be more popular than java. Will see how it goes. EDIT2: BTW my favorite JVM lang is scala :D It has lot of features and it is the lang that proven that functional and oop worlds can coexist and can be used in real-world. Sadly, scala has overbloated syntax and slow compile times, but this is the most "prominent" language of the JVM so far. IMHO
I had this same problem once, years ago, and if I recall correctly, the fix was indeed to install a different JDK. However, see also [this link](http://www.coderanch.com/t/456139/Groovy/bit-Groovy); I also vaguely recall getting it to work by setting up an alias to use the .bat version instead of the normal version. 
Do you have your JAVA_HOME system variable set up? I'm not sure if that has anything to do with this, but I know certain installs of groovy don't set it up for you automatically, and you're supposed to have it for Groovy to work correctly.
Both java and groovy are touchy on windows. Are you on a 64 bit system, with 64 bit windows, running 64 bit java? You can't mix any of these things. Might be easier to experiment in a VM - download an ubuntu disc and install in virtualBox (free). The unix experience is a little more consistent. You can get it to work in windows, but issues like this are common - as others have mentioned, paths matter, jdk version matters, 32vs64bit matters, etc....
I think it is since I hadn't set it up before and I got a completely different error message then. I'll double check though 
Ok cheers I'll check out the link when I'm home! 
Could be. I suggest using GVM for groovy installation, check it out if you haven't: http://gvmtool.net
Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html 
Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html Watch Here Now &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html mexico vs Trinidad and Tobago Live Stream Working Link&gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html legit and Free &gt;&gt;&gt; http://looks-and-charm.blogspot.com/2015/07/watch-mexico-vs-trinidad-and-tobago.html 
Thanks for this!!
Yea, that's the situation I'm faced with right now, probably will wait till Grails 3.x have greater adoption rate. Thanks for suggestion on Play Framework, I'll have a look at it. :)
Netbeans has really good Groovy and Grails support.
I won't use IntelliJ because of the license. Eclipse is completely open source &amp; I find the gui (swt) to be more performant than Netbeans' swing. It also has more usefull plugins available than netbeans.
I'm currently alternating between these two books: _Grails 2 - A Quick Start Guide_ _Grails in Action, 2nd ed_. It took me a little while to get the proper versions of everything going to match up with the books. So far everything's working very well with Grails 2.3.11. re: Grails 3 vs. 2 -- since all the learning materials and tooling are v2-oriented, I'm sticking with 2.3 for the purposes of these two books, then will switch to 2.5 for my own stuff, then upgrade to 3.0 as the learning materials / IDEA plugins improve. On that note, I'm VERY happy with IntelliJ's Grails support. Initially I tried Grails with just a text editor, which certainly works, but (unsurprisingly) it's soooo much nicer with intellisense/autocomplete. But as others have mentioned, I agree it does matter how much of a beginner you are. If you've never done any Java web development OR Groovy, you could be very confused for awhile. I've had a little bit of exposure to JSP-based web apps, a little bit of exposure to MVC frameworks, and a few months of standalone Groovy stuff (using as a replacement for both Python and Java -- I love it!). So I've been able to get my bearings pretty well just from these two books. Out of curiosity, if you're not already a big Java person, may I ask why are you looking at Grails instead of Ruby on Rails? There's definitely a lot more learning resources for the latter.
 daysOfWeek = daysOfWeek.withDefault{ [] } 
EDIT: I see, you meant this: daysOfWeek = [:].withDefault{ [] } Working pretty well so far! This is a great option for a list/map assignment.
You can find the binaries on [JFrog](https://bintray.com/groovy/maven/groovy/1.8.6/view#files). Installation is pretty simple: - If you don't have Java installed, install a [JRE](http://www.oracle.com/technetwork/java/javase/downloads/index.html) - Extract the Groovy zip file to its final location (e.g., "C:\groovy" or wherever you want it) - Optionally, add Groovy's "bin" folder [to your PATH](http://www.howtogeek.com/118594/how-to-edit-your-system-path-for-easy-command-line-access/)
Thanks for the explanation. 
You'll shoot yer eye out, kid.
Something like this should do what you want: https://github.com/NeuronRobotics/bowler-script-kernel/blob/master/src/main/java/com/neuronrobotics/bowlerstudio/scripting/GroovyHelper.java#L18 In fact if you include this library: https://github.com/NeuronRobotics/bowler-script-kernel you can allow your users to do exactly that with Python, Clojure and Groovy, each returning an Object to your runtime. 
The object created in the groovy script and returned is the object you get back, a java object. You can load any string, so loaded the string from a file, into the groovy parser. The parser runs is and returns the reference to the object returned by the groovy execution. 
Wasn't Play Framework once groovy? If so, what was the reason for moving away?
Scala then Java &amp; Scala.
[I can beat your magick!](https://www.youtube.com/watch?v=7joxOe76vCE)
OK, so I have an answer for this. What I need to do is essentially ImportCustomizer, so I looked at the source code for that. It operates in the CONVERSION phase of the compiler, and because of reasons I don't understand that can't be a "local" AST transformation, it has to be a "global" AST transformation. I don't know what the differences are. A global transformation applies to all Groovy scripts, local seems to be able to be applied when you choose. I'd prefer local, but my guess is that because we're dealing with defining symbols and hence affecting the syntax of the program that we can't do that late enough. Anyway, to do the global transformation you need to make a jar file. You can't do it like I'd hoped and have the transformation in the same source code. You also need to create a file called org.codehaus.groovy.transform.ASTTransformation and put the name of your transformation in there - this is how the compiler finds out about it. Because the transformation affects all Groovy files, you don't need the @NoImports annotation, though I suppose I could leave it there as a flag telling me whether to bring in the imports or not, so I don't affect other innocent Groovy files. Anyway, here's the transformation code: package hardthings import groovy.transform.CompileStatic import junk.Muddle import org.codehaus.groovy.ast.ASTNode import org.codehaus.groovy.ast.ClassHelper import org.codehaus.groovy.ast.ModuleNode import org.codehaus.groovy.control.CompilePhase import org.codehaus.groovy.control.SourceUnit import org.codehaus.groovy.transform.ASTTransformation import org.codehaus.groovy.transform.GroovyASTTransformation @CompileStatic @GroovyASTTransformation(phase=CompilePhase.CONVERSION) public class DoTheImports implements ASTTransformation { @Override void visit(ASTNode[] nodes, SourceUnit source) { addImports(source.getAST()) } def addImports(ModuleNode ast) { ast.addImport("Muddle", ClassHelper.make(Muddle.class)) } } So I make a jar containing this class, Muddle.java, and the ASTTransformation file and add it to my project as a library. I can then run this program: println Muddle.PIE directly from within IntelliJ. This is pretty much what I wanted.
It starts to suck when SSL comes into play. 
I don't know of any online courses, but if you already know Java, "Making Java Groovy" by Ken Kousen is a great book. https://www.manning.com/books/making-java-groovy
Also don't know any online courses specifically, but I learned with Venkat's book http://www.amazon.com/Programming-Groovy-Productivity-Developer-Programmers/dp/1937785300. Digital versions exist. There are actually tons of free resources available online, even if not courses in the traditional sense. QuickStart guides can be good too: https://learnxinyminutes.com/docs/groovy/ And there ore online sandboxes to play as well: https://groovyconsole.appspot.com
Ask for materials on the groovy mailing lists
Thank you all for the responses !!! :)
This is the second time you've posted the same article, which has nothing to do with Groovy.
Looks like books are covered so: Here is a list of videos from various Groovy/Grails conferences: http://www.infoq.com/springone-2gx-2015/ http://www.infoq.com/springone-2gx-2014/ http://www.infoq.com/springone-2gx-2013/ https://www.youtube.com/channel/UCJXNOMywewNmau4hzAy4LjA https://www.youtube.com/channel/UC7wUp2KIa1hoMNn0r7JUVEg https://www.youtube.com/channel/UCgW66PCJrada2o2_YcvFo-Q One of my favorites is this one by Venkat: http://www.infoq.com/presentations/Transforming-to-Groovy Also my youtube channel where I have a series of short pragmatic Groovy videos: https://www.youtube.com/channel/UCHRADKRXZkPB6QVee0Q3GSQ Grails Diary(despite its name it has news about the groovy ecosystem): http://grydeske.net/news Keep an eye out because Groovy is going to get a slack channel, which would be good for asking questions. Checkout Groovy's new documentation including the Groovy JDK and Groovy Apis at http://groovy-lang.org/ http://groovy-lang.org/api.html http://groovy-lang.org/gdk.html
That video series is great. 
I'll add some performance testing, it's a little tricky though, since other java renderers are typically within a servlet context (gsp from grails or jsp) so it's hard to replicate the html generation only. Note also that the renderer helps mostly simplifying the readability and correctness of complex html documents. If speed is a major concern, this is probably not the right tool
Good exercise. I have built a few of these over the years, I usually just extend http://docs.groovy-lang.org/latest/html/api/groovy/util/NodeBuilder.html
It's pretty clear to me that Groovy is a close relative of swift, though it's hard to say whether it influenced it. Groovy arose out of the common gripes around classic C-based languages. It wouldn't be a total surprise if the creators of Swift and Groovy came to the same conclusions independently. 
From the official [Twitter account](https://twitter.com/ApacheGroovy/status/733722959865614336)
They're both pretty close conceptually, if I had to pick one I'd say Python. 
Groovy is clearly closer to javascript. Pay no heed to that python peddling scum.
lol, maybe I should learn them both. :-) 
Groovy is pretty easy to start with. You certainly don't want to learn the bad habits of Javascript before you do it.
Why do you want to start with something else? You can go straight to Groovy. Knowing the 3 of them, I recommend Python though.
in terms of utility, Groovy and javascript work together , you will not often be using groovy and python together on a single application 9not impossible but they're overlap more) Javascript is for all its faults a very very popular language with lots and lots of utility in the real world. Groovy / Grails is my personal favorite thing to work with and i've done a lot with getting complex apps set up in it but it fills the same socket as python.
What do you mean with "bad habbits" here? I do agree that a lot of code and examples you'll find aren't exactly teaching you to use JS well if that's what you mean.
Can your OS &amp; browser do a print to PDF? If so then all you have to do is go to the groovy docs you want either API or getting started, select inside the main frame and print frame as pdf. Not the most perfect method but it works. 
It may cap my RAM, but I don't run very computer intensive tasks. This post is intended to provide a quick fix for people like me that just want get their groovy script to work and encounter out of nowhere the error 193 thingy for a script that worked before updating java. But it is not a complete solution. If you want it to work with java 64bits, it don't know how to do. My OS is Windows. I'll add it to the post.
Pretty weird - thanks for sharing your findings though! :D 
God I hate XML. Everything about it is a huge pain. So, you were almost there, but it took me a few tries to see what was wrong. def xml = """&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;xliff xmlns=\"xxxxx\" version=\"1.1\"&gt; &lt;file original=\"xxxxx\" source-language=\"en\" target-language=\"en\" datatype=\"javascript\"&gt; &lt;body&gt; &lt;trans-unit id=\"0\" resname=\"blahblah\"&gt; &lt;source&gt;foo.&lt;/source&gt; &lt;target&gt;foo.&lt;/target&gt; &lt;/trans-unit&gt; &lt;trans-unit id=\"1\" resname=\"Error\"&gt; &lt;source&gt;error!&lt;/source&gt; &lt;target&gt;error!&lt;/target&gt; &lt;/trans-unit&gt;\" &lt;/body&gt; &lt;/file&gt; &lt;/xliff&gt;"""; def parser = new XmlParser().parseText(xml); parser.file.body.'trans-unit'.each { trans -&gt; println ("${trans.'@resname'}"); } So: 1. When you parse the XML, the object you get back IS the root node, in your case, the xliff node. So you don't need that in your loop. 2. You can't use - in a name in groovy without '' or "". It is interpreted as subtraction, so just put it in quotes 3. I think you can use body.children().each or body.nameOfYourChildren.each, but not body.each. There is only 1 body. I just grabbed all the 'trans-unit' nodes from within body and iterated over those. 4. Attributes are accessed with the .'@attributeName' syntax. I think in jsonSlurper, you don't need the quotes except for special characters (like in #2 above), but this is parser, so I think you do. That should get you going - but you're bound to run into more pain. Make sure you make use of the .text() and .name() methods on nodes when parsing - print them out here and there. It's the only way you can figure out what you're looking at most of the time, that's how I solved #1. - And when you have no idea what type of object you're looking at (is it a list? is it a node? is it dark magic?), use println yourObject.getClass() Good luck!
 root.file.body."trans-unit".each{ println it.attribute("resname") }
Yeah, no problem! Happy coding!
Okay, I have one last question if you're willing to humor me. I am now importing two files where one of those files has more information than the other one. What I want this script to do is to parse one file (testfile1) and test it against another file (testfile2) and append everything that isn't in testfile2 from testfile1. For the life of me, I cannot get this to work. I'd like to avoid using XmlSlurper() if at all possible. Any ideas? Here's my code: File testfile1 = new File ("testfile1.xlf"); File testfile2 = new File ("testfile2.xlf"); //now create objects that will do the parsing... XmlParser parser = new XmlParser(); def c1Array = parser.parse(testfile1); NodeList c1TransUnits = c1Array.file.body.'trans-unit'; def coneArray = parser.parse(testfile2); NodeList coneTransUnits = coneArray.file.body.'trans-unit'; //checking to see that parsing is operating correctly... c1Array.file.body.'trans-unit'.each { trans -&gt; println("${trans.'@id'}"); } coneArray.file.body.'trans-unit'.each { trans -&gt; println("${trans.'@id'}"); } println("1--------------------------------------------------------------"); //the algorithm to place files... c1TransUnits.each { c1 -&gt; //for each in c1Array (checks all) boolean match = false; coneTransUnits.each { cone -&gt; //for each in coneArray (checks all) if (c1.attribute("resname") == cone.attribute("resname")) { //if the resnames match... match = true; //match is true, do nothing } } if (match == false) { //if the resnames do not match, check against all other resnames println("No match for this resname: " + c1.attribute("resname")); coneTransUnits.add(c1); //push the unmatching resname to coneArray } } println("coneArray:"); XmlNodePrinter conePrinter = new XmlNodePrinter().print(coneArray); println("WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW") println("c1Array:"); XmlNodePrinter c1Printer = new XmlNodePrinter().print(c1Array); println("WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW") 
Doing a diff, especially with XML is a huge pain. Since you don't know which elements/attributes are missing, you'll have to go into it blindly and traverse all elements. I would probably do this recursively, where you start at the root, get all of it's children, and then one by one check to see if file 2 has the same set of children in it's root. Then do the same thing again for the children's children. Every time you find a missing one, you can log it or add it to a list or map or something. If you think of the XML as a tree, then you would want to do a breadth first traversal on it. If the diff needs to be bi-directional (file a has stuff file b doesn't, file b has stuff file a doesn't), then you'll probably need to run it twice. Thankfully groovy makes this easier than java, because you have dynamic property accessors (the ability to do someObject."${someVariable}"), and various set operations (in, minus, plus, union, difference, etc...). You might be able to leverage some of those. At the end of the day, the algorithm is going to have to look generic - you won't reference any of the elements by name, rather, indirectly via iteration. On the other hand, if you're trying to validate that XML complies to a spec, that's what the XMLNS is for - you can write a spec for your XML and then just validate an input. This should be built in, but it won't detect things like *valid* omissions.
I've been meaning to look seriously into Groovy at some point, so why not with the help of an online course. How do I sign up for the free coupon?
I apologize but the link was missing. I have added the link to the description. Just sign up for free and give it a look and if it seems like something you can reccomend that would be great! 
Thank you!
I love groovy. If I've done a lot of groovy in the past what would I get out of this course?
Groovy Server Pages might be just as easy... http://docs.grails.org/2.2.x/guide/theWebLayer.html
To each his own. I developed this tool because I had so much trouble maintaining gsp Amongst the troubles I ran into, the most challenging ones were - gsp not working well outside of grails Web request (and as a consequence of you use them you are stuck with grails and its long test startup time) - complex gsp are hard to write and maintain. Refactor support is limited even in intellij, it's cumbersome to read (as html is), writing reusable components is difficult. Etc. Tag libs offer a good solution to those, which is exactly how groovy html renderer was born. I took what I liked in tag libs and made it into a standalone tool. Now granted that for simple pages gsp is a very good tool. I just think it's not very robust when projects get complex
I wonder if you could compile these into gsp for the sake of performance in some cases. Sort of like caching it. Then you get great performance while this syntax. Btw checkout what node.js jade library does for more ideas. This definitely has potential!
I was hoping for a TLDR too. Sorry for being lazy.
No need. I am just posting these to get more visibility on things happening in the Groovy world.
Is that a .gsp file?
Are you sure you have added groovy as a framework for the project? And do you have groovy and grails plugins active?
Yes and yes. I can compile and run normal groovy scripts fine fine, just not templates 
Can you give a small sample of your code? Groovy has optional typing and you can specify types for declarations, method parameters, closure parameters and return types- I would think you should be able to enforce typing if you need to.
Hello! If you use a browser like chrome, open the dev tools and then the network tab and then go to the website in question. Login. You should see a POST request. The response to this request, given a successful login, should result in a response with a cookie set. You will see this cookie in the response headers. To simulate being logged in for a HTTP request from a groovy script, you will need to add these headers to the requests you make. If you can, list what the website is and I or someone will be able to confirm if this would work.
Greatly depends on the type of login they require. If it's simple old-school auth, you can pass the username and password in the URL string. However, this is almost never done anymore. A lot of auth requires establishing an authorized session which usually involves creating a local cookie. This might not be a quick and easy task.
Thanks, selenium webdriver seems to be the way to go. I'm able to log in automatically. I'm still trying to figure out the way to pass logged session into xmlslurper but it looks promising at this moment.
Thanks, I'm not very familiar with http request details, but I'll spend some time today read about this header thing.
Hi, I've read those slides with some hints about implementing typesafe DSL in Groovy (similar to the ones in Kotlin) http://melix.github.io/javaone-groovy-dsls/#/ (there's also a video with the same name) I've started implementing such a DSL for a reverse-proxy [here](https://github.com/helpermethod/membrane-groovy-dsl). Note that the example proxies.groovy file on in the README.md shows a Groovy DSL which is statically typed. All the DSL classes are annotated with @CompileStatic and the Closures are annotated with @DelegatesTo which provides static type checking and autocompletion for the delegating Closure. 
Ohh, fantastic! Thank you.
Also note that you can use the '?' to avoid an NPE on the .size() check. So: def list = null if(list?.size()){ println("something") }else{ println("something else") } Will println something else where as : def list = null if(list.size()){ println("something") }else{ println("something else") } Will give an Null Pointer Exception. [Here is more more info on null safe operator](http://mrhaki.blogspot.com/2009/08/groovy-goodness-safe-navigation-to.html)
Yep - and I'd argue the safe navigation operator reads much more easily too. `if(list) { ... }` might be more terse, but I always find it a bit of derail when I'm reading code because I have to remember the rules around groovy truth and what the writer probably meant. Whereas `if(list?.size())` makes it much clearer that having a non-empty list is what we wanted - especially to people who don't normally code in groovy.
The main thing people use Groovy for is Gradle, the Java build system. It's the default build system for Android applications. That alone counts for most of its use.
Maybe part is due to how it's marketed as "better java". It is easy to pick up as a java dev but if you just use it as java with syntax sugar you will be seriously missing out.
If you look at the groovy logo it looks like a total joke edit: guys i'm not saying you should judge a book by a cover, but you also shouldn't draw up a shitty cover and expect people to read it
Groovy was hyped when it was new, along with Grails. Scala is talked about because there is a scientific community using it, and these people need to talk about what they do, it's in their job description. Closure is talked about because it is a Lisp, and that's enough to be talked about. Kotlin is talked about because Jetbrains wants it to be talked about. Groovy has it's own merits as a dynamically typed language with optional static typing support and some metaprogramming abilities, and close resemblance to Java for a low learning curve for migrating teams. But overall it remains a language for the masses, without special appeal to a significant niche, and the masses already have Java to use and to talk about. Because of several quirks Groovy did not manage to kill Java despite aiming for roughly the same audience, only a select few companies use Groovy instead of Java. Maybe the main problem Groovy has is that is offers so many ways to do things in a quick and dirty way, and average teams using Groovy are likely to create a huge mess. If not for that, it could be the better Java.
From book *Hooked* by Nir Eyal, at one page he wrote that in order for users to starts using new product, it has to be 9 times better! So Groovy has some nice and neat syntax, but it's not 9 times better than Java. Community is hooked with Java, and it will not change it any time soon.
It's mostly ranked so high because of Gradle (build.gradle files are written in Groovy).
Groovy is to the JVM what Bash is to Linux. I wouldn't say it's sad, just that Groovy is being used as its creator James Strachan intended it to be. Some others replaced him afterwards and tried to get people to use Groovy instead of Java for building systems on the JVM so they could profit from their control over Groovy's codebase, but developers weren't buying that. They just want a scripting language for the JVM.
While I love Groovy for its expressiveness, and the power it gives you with both run-time and compile-time metaprogramming, the biggest problem it has had, is it's image. People like to bash on it, because it was slow, kind of like how Java was... There's an old,out of context quote from the original creator, saying he wouldn't have made it, if he knew about Scala, which would have been a shame. Groovy is dynamic by default, and like tabs and spaces, the debate of dynamic vs static, continues on. Pivotal dumped Groovy, and Grails to go after their cloud business. This ended up being good for Groovy, as it became a top level Apache project, which helped lend it a more c readability. The Grails team ended up at OCI, which actually uses Grails(unlike Pivotal), and has taken over and one of the main sponsors in the Groovy community, for conferences. Another reason, it the IDE support, could be better. We have Intellij, but for opensource all we have is Eclipse, which kind of lags behind in support. So Groovy's image has taken some hits, but it's a very solid language, and has a great, very supportive community. I hope to see Groovy's popularity continue to grow. Keynote from GR8 Conf: https://www.youtube.com/watch?v=KZ7u8CddgnI
&gt; Because of several quirks Groovy did not manage to kill Java Could you point those quirks out or link to some resource that does, please?
Your Twitter link leads to a page that's no longer there.
Thanks, and that's strange. If I add the straight twitter url reddit add some charters to the url, so I changed it to a search url and it works.
&gt; Scala is talked about because there is a scientific community using it, and these people need to talk about what they do, it's in their job description. That's bullocks. The reality is, there are few compelling arguments for Groovy over Scala. Yes, it has dynamic typing discipline, and in a few scenarios you might want that. But then Scala has dynamic feel (you can even program dynamically if you want using the `Dynamic` trait), and anyways generally you don't want that. What's the outstanding property of Groovy? "Collections" someone writes. Scala comes batteries included, with an excellent collections library, way ahead of Java's. "Meta programming" someone writes. Scala has hygienic macros, with an upcoming revamp aka Scala-Meta. Quasi-quotes make life ultra easy for doing meta programming. So I simply believe there are not many spots where Groovy offers any advantage over its competitors on the JVM.
I did not say Groovy was better than Scala. Just that the main reason Scala is mentioned often is due to the nature of it's community. There are plenty of other nice languages out there used by niche users who are not as outspoken as the scientific community. If Groovy has anything over Scala than it's a low learning curve (for non-complex programming). But that is another discussion. The question here was only why people speak more about one or the other, not which one is better.
Groovy shot into Tiobe's top 20 because its rating increased from 0.4% to 1.2% in a single month in December 2015. Tiobe haven't given any indication which of their 25 search engines monitored was responsible for this. I ask, do YOU really think Groovy's the 16th most popular programming language on the web, or is it more likely the rating's been faked, given it's happened before? *[Groovy made into the top 20 in Oct 2013, but 3 months later (Jan 2014), had dropped out of the top 50 even (#32 in Nov, #46 in Dec).]* And of course Gradle 3.0 was released 2 months ago *(and Gradle 3.1 released TODAY!)*, dropping Groovy in favor of Kotlin as the preferred language for writing build scripts. 
Probably never. The style of rails and Grails is seen as old fashioned to many developers now.
GGTS is possibly quite outdated, but used to be good when I first tried it out. I'm not very sure about netbeans. IntelliJ idea has amazing support for groovy and the community edition may be all you need depending on what you're doing.
Thanks for the feedback. Do you know if Apache or OCI (the company that is now sponsoring Grails) have released anything about supporting the Groovy/Grails development tools? I had a bear of a time trying to get Netbeans, Eclipse and even IntelliJ setup correctly with a Grails project. I'd hate to see such an awesome language turn newcomers off due to outdated tooling.
Great, thank you for the feedback.
As others have mentioned Intellij has the best support, and you can use the community edition, with newer version of Grails, as Grails is now in essence a SpringBoot app, with batteries included. What you miss from the ultimate edition is some of the auto complete, and proper highlighting of some things. Even the Ultimate Edition isn't perfect, and could be better. What I've found out rather recently when updating a plugin I wrote, which gives you a Groovy DSL for enforcing business/permissions rules, is that there is a DSL(.gdsl) for intellij that allows you to tell the IDE about conventions, variables, scopes, and add auto completion: http://www.tothenew.com/blog/gdsl-awesomeness-introduction-to-gdsl-in-intellij-idea/ Eclipse has a competing standard: https://spring.io/blog/2011/05/09/better-dsl-support-in-groovy-eclipse My thought for Grails(but could be applied to other Groovy projects), is that if someone(maybe me) kicked off a project, and got the community involved, collectively, we could make the IDE support better. For me though I'm not really interested in Eclipse, unless someone steps up and either enhances, or writes a better Groovy plugin. From what I've see of the Groovy plugin, is that it includes it's own version of the Groovy compiler that lags behind the current version of Groovy. I've also been spoiled by Intellij Ultimate. I'm also going to be asking on the Grails Slack forum, to plugin developers, how widely known is it that gdsl and dsld exists.
Wow this is great. Nice to have a little more insight into all the effort that goes into making a DSL usable from a user perspective- when you see stuff like Spock, you don't realize how much behind the scenes work is going on to make Spock simple to use!!
That's the general consensus. See [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle).
OK. I read your reply to OP as "composition is preferred over inheritance because of LSP". But maybe you were more saying "composition is preferred over inheritance; also, read up on LSP". &gt; I've always considered LSP to imply that the inherited things should be expected to be used anywhere the super class may be used. I think that's the "common wisdom", but I think it misses some of the nuance. LSP talks about "desirable properties". The superclass promised certain things to its callers about its behavior. For example, Java's `ArrayList` promises that the `add` method will run in amortized linear time. This is a desirable property, so LSP-compliant subclasses need to retain this property (or improve upon it). However, `ArrayList` doesn't say anything about how many allocations `add` will do, or what the growth factor is. Subclasses can tweak these however they want, because they're not promised by the superclass. That might lead to a subclass uses more memory, which would create situations where the subclass can't be used as a drop-in replacement for `ArrayList`. But, at least according to my understanding, that doesn't violate LSP.
Yes, I meant the latter. I agree with your comment. If the contract is fulfilled, LSP is satisfied. Some side effects are permissible, and their desirability depends on context.
What is considered the more modern approach?
Using smaller libraries that don't have as much magic. For instance using Sinatra, and whatever templating, DB or other libraries you need in Ruby instead of the entire rails framework. It allows for more flexibility and is easier to debug. You're less likely to have to do hacky things when you don't use a framework. The drawback is that it will take a bit longer to get started. There still a place for rails and Grails, but most developers I've worked with in the last few years would consider it to be old fashioned and don't like working with frameworks. 
Is grails still a thing ???????
Oh yeah, i was half joking, we also use grails but omfg the non existing doc, unmaintained plugins, silent community and totally superfluous frameworks makes me beg the higher ups to switch to java/spring/hibernate and start working on content rather than understanding grails. And no it s not my first time with it either... Im actually the most experience grails dev in the team. My first experience was to convince my boss to switch to Java after they spent years on bug fixing a platform that had no clients because they only spent time fixing bugs rather than add feature. The switch changed everything. That framework is a nightmare. I have several devs in my company calling themselves frontend developers and only touching javascript just because they dont want to approach the horrendously complex backend where everything is cultural magic that no one can fully explain.
Thanks for your answer!
That document is a good start: http://groovy-lang.org/style-guide.html
There are many great books on the subject too - I've enjoyed the ones by Venkat Subramaniam- he has written several, including some O'reilly books. 
You can probably write a groovy script to help you with your homework
US$48 is *not* "being on sale". Virtually any info you'd get from this book is available online for free just by searching and browsing around. All a hard-copy book adds is the physical sensation of yanking it off a bookshelf and flipping thru the pages, something some people might pay $10 for. 
Grails has been a godsend for us. I think that if you have a Grails Front-End on top of a Java Ee, Hibernate Back-End, the development becomes a breeze. Safe navigation, shorter and more intuitive syntax, and its dynamic nature make it a far better candidate for writing dynamic sites than Java.
not sure what `service.EventService$$tt_getAvailable_closure8` is, but it might be autogenerated or declared via `def` without a type. Groovy should still be able to figure out the type at runtime, but maybe the value is actually null. Normally the pattern is to hard code the closure, ie, db.eachRow("select * from whatevs", [:]) {row -&gt; // do something with the row } But if you have one stored in a variable you can pass it in. Maybe try casting it with `as Closure`. (If it is null it will still blow up, of course.) 
Funnily enough, that is exactly what my code looks like. I ended up getting it working by eval'ing the string (created with a StringBuilder) to a gstring, so it uses the signature: eachRow( Gstring, Closure, Closure ), and it works fine. It's very odd behaviour, and has had me confounded for days.
I've run into similar issues with Groovy SQL operations using literal GStrings vs String as args. Replacing single-quotes with double-quotes (or casting to String) would most likely solve your issue too.
you've got the operator backwards, should be string =~ /pattern/ http://docs.groovy-lang.org/next/html/documentation/core-operators.html#_find_operator This site is helpful for regex specifics: http://www.regular-expressions.info/quickstart.html
https://regexper.com/#(%3F%3AHi%7CHey%7CGreetings%7CAfternoon%7CMorning%7CHello%7CDear)%5B%2C%3B%5Cs%5D%5Cs*(%5Cw%2B)%5B%5C.!%2C%3F%5D%3F%5Cs%2B(%3F!here%7Cfrom%5Cs%2B%5Cw%2B%5Cs%2Bhere).%2B
One word: Inertia
Thanks so much. That is so cool
That's awesome! I'm a huge groovy fan and use it daily - nice to see more projects picking it up. Aside from Grails, gradle and spock use of it has been great. 
I've used it extensively in a project I did with SoapUI. I liked it so much I bought a Udemy course. Def. flavour of the month for me.
&gt; When I state “valid Java code in 99% of cases will be valid Groovy code” it means that code that is developed using Java 6, 7 or 8 will be treated as a valid Groovy code. Perhaps Java 6 and 7, but certainly not Java 8. Java 8 lambda expressions won't compile in Groovy. 
Pretty sure this is by design. Just like gradle or maven or ivy, you have to declare the stuff you want in the classpath in each class/script- you don't want your scripts putting 10,000 libs in the classpath!
&lt;/thread&gt;
Yes, you have to use parentheses when using most expressions or variables as map keys. Glad to help!
I'm not at a computer but something like: def b = (1..5).find{it==3} 
Thanks for replying. This does excactly what I try to accomplish! And it's very groovy! Kudos!
Ultimately, the language doesn't really matter, aside from the libraries available - unless you're on some really deep shit and need inductive types, dependent types, etc. You're doing scripting. If your job is asking you for Perl and Python, use Perl and Python. That's what other people are using at your work, so just go with it.
I use Groovy for 3 reasons: Jenkins, Gradle and Artifactory. Otherwise I use Python, Go, bash or Java. I used to work at a Rails shop where Ruby was swapped for Python. Also, I may learn Kotlin, partly because of this https://realm.io/news/gradle-kotlin/ but also because it seems like a nice sane middle ground between Java and Groovy/Python/Ruby. Groovy is pretty cool but for me it doesn't really fill a need outside of the tools I mentioned above. Also, it's similar to Python, Ruby and Java which I've been using for years which makes it both easy and hard to learn and use. I studied Latin, Italian and Spanish in high school and college. Learning and using Groovy, is like me picking up Catalan or Portugese. On the one hand, it's familiar and mostly readable but the tricky parts kind of drive me nuts! It's like I fully understand Groovy except for a few places where it confounds and surprises me. :) It's a cool language but I don't think it's growing in popularity. If I worked at a hardcore Java shop, I'd probably use it over Jython or JRuby. 
imo kotlin has the modern conveniences of groovy without the runtime overhead. 
Better title: Groovy is now a part of JMeters scripting languages
You are correct. BTW, we have the same surname. 
You might also be able to use inject() which is a higher order function (called reduce or fold in other languages) which might give you more flexibility in what happens inside the closure: http://mrhaki.blogspot.com/2009/09/groovy-goodness-using-inject-method.html
Nice, looking forward to the rest. Grails might still be a bit "heavy", but it's user friendly. I imagine the reactor event framework could work really well with a service listening on the gpio pins.
I'm not sure. [`BigDecimal` is supposed to have a mod method](http://docs.groovy-lang.org/docs/groovy-2.4.9/html/groovy-jdk/) (inherited from Number), but I agree that I can't seem to call it. Looking at the source code, it looks like the static [`NumberMath.mod`](https://github.com/apache/groovy/blob/GROOVY_2_4_9/src/main/org/codehaus/groovy/runtime/typehandling/NumberMath.java#L92) gets a `NumberMath` instance from [`getMath`](https://github.com/apache/groovy/blob/GROOVY_2_4_9/src/main/org/codehaus/groovy/runtime/typehandling/NumberMath.java#L190), and then calls the `modImpl` method on that instance. In this case, `getMath` should return a [`BigDecimalMath`](https://github.com/apache/groovy/blob/GROOVY_2_4_9/src/main/org/codehaus/groovy/runtime/typehandling/BigDecimalMath.java#L29) instance. But `BigDecimalMath` doesn't override `modImpl`, so it gets the [base implementation](https://github.com/apache/groovy/blob/GROOVY_2_4_9/src/main/org/codehaus/groovy/runtime/typehandling/NumberMath.java#L249). And that's where your error is coming from. It's an actual runtime error. I'm sure they'd appreciate a [contribution](http://groovy-lang.org/contribute.html#code), if you're up for it.
Many thanks - and I'd love to look into contributing.
That's a great catch. Thanks for bringing to their attention.
Is there? I'm an idiot... Did not know that, thanks. 
Regarding metaprogramming. Nowadays you can achieve the same with extension methods which are a compile time transformation and work with @CompileStatic. **EDIT** Also note that with [Javaslang](http://www.javaslang.io/) the Java code would be about as succinct. 
Does that mean I should work with Grails 2? 
No. Here's what happened. When Grails moved from 2 to 3 they changed many things breaking every third party plugin. So there was a huge wait for people to update their plugins which pissed people off. That coincided with Pivotal dropping groovy about the same time and it was a great reason for everyone to say fuck off to Grails. You're better off just doing Spring Boot.
I really agree with this. Love Grails 3, but 90% of searches end up taking you to Grails 2 plugins. Also there is a great community at https://grails.signup.team/ 
And even if you are not using Grails, I have found that the Groovy community is very lively and supportive. I use Groovy with Vert.x and have found excellent support. 
Groovy is certainly not going anywhere. Between Gradle and Geb, and just the niceness of the language (why doesn't every language use ```?:```) its just a bit too nice not too use. I don't know if Grails is going away, but I still plan on using it ;). 
Does that mean I should work with Spring Boot? I was kinda looking foward to using Groovy. 
That's good news! 
You can do both, use groovy and spring boot. Remember you can use groovy in any java project. That said, I use grails3 and have a fine time.
Just take your existing webapp in Java and port it to groovy. Or take your existing webapp, port it to Java Spring Boot, and then move it to Groovy. One step at a time. If you jump directly to Grails+Groovy you might get confused between what provides 'the magic' (was that Groovy, Spring or Grails wiring this up?). 
Groovy + grails is great - It's a smaller community, but very active release cycle, it brings a bunch of enterprise frameworks along for the ride, it's full stack, modular, extendable and you can be up and running in seconds. It also has a nice ORM layer built in called "GORM" which really reduces the learning curve of something like hibernate (which it is built on top of). Grails 3 added new profiles, like API and Angular, and the entire platform is built on top of gradle (build tool and dependency management). The built-in test environment is Spock, which is way better than anything else out there, and of course the entire java, groovy, etc... set of community tools are available. The Grails 2 to 3 change was nothing but positive in my experience - making everything gradle based was way better in general, but also for IDE integration, CI servers, and micro service deployment. It is true many older plugins broke, but the core ones were ported, many others were replaced with gradle plugins, because of gradle you now have access to all the gradle plugins (that you didn't have before) and many of the things that were once plugin dependent have moved to other solutions (for instance, you would use a JS package manager and/or build tool these days (bower, grunt, gulp) rather than try to include a special grails jquery plugin). Grails apps also now build-in an embedded tomcat, so micro service deployment is stupid simple, and it makes docker much easier. There are official plugins for gradle for docker, and all this integrates will with tools like IntelliJ. And if I'm not mistaken, grails 3 is spring boot based - so you do still have access to that communities resources as well!
also ?. I hate that python doesn't do this - my lambda functions are a mess of null checks!
I still don't get the Rails part of it. It uses Spring, Hibernate.. tomcat for the webserver. What is Rails in this stack and what does it do..
As someone who's stuck with Grails 2 on a few projects the ratio seems more like 50/50 to me. That being said it's still super frustrating 😫
&gt; Should I worry? You should definitely try Grails. Unfortunately allot of "community" stuff happens in the closed Slack channels. There's a solution for that however: http://slackarchive.io/ so that they're searchable for everybody: you just need to convince the Grails Slack admins to **configure** those archives too. 
Check out /r/learnpython
No, I've always used IntelliJ for that. Doing variable inspections sounds tedious in the command line - honestly when writing a small script that I'm not firing a whole IDE up for, I just use atom and run the script directly from there, either with the script or gradle plugin, and then I really do use printlns to debug. If the debug session gets so bad or incomprehensible, then I drop it into IntelliJ .
that sounds pretty awesome! Go for it :D
Should be doable with jdb right??? 
I did Python for 10+ years and eventually switched to the Java (and then Groovy). I much prefer Groovy, mainly because I'm a big fan of optional static typing and Groovy's whole closure-centric way of doing things. Python won't be hard to learn (particularly if you already use IntelliJ and can just install the Python plugin / PyCharm). But if you love Groovy as much as I do you will probably find Python a little annoying. I can't really articulate that -- it's just a general feeling. But since it's dynamic like Groovy, you will feel very at home. Nothing to sweat at all!
I much prefer Groovy too :( But it's a compromise I have to make. It seems like a lot of it is similar to Groovy but much rougher around the edges. Lot of little details that the Groovy team smoothed out. I've done Perl for 15 years, feels a lot like that.
Misconfigured jdk maybe? I've not noticed any regressions like this from 2014 to 2017. Normally when I have problems like this it's because of a project configuration issue.
The best Grovalisous
Especially useful for testing imo. Runtime manipulation of classes is a great power, with great responsibility :)
Well I see metaprogramming as just another way of programming. It has it's advantages and disadvantages. One of its advantages, is that it makes it easier to create DSLs. Some notable ones, are Gradle, Spock, and there are some in Grails. Also keep in mind not all metaprogramming is runtime, there is also compile time metaprogramming, through AST Transforms. AST Transforms are more difficult to create/maintain, but don't have a runtime performance hit. One thing that looks like it's going to make AST transforms easier is, the addition of macro methods coming in Groovy 2.5. There was a talk at the Boston Groovy/Grails meet on on metaprogramming: https://youtu.be/V_R5pvczGAA Also if you look at the conference youtube pages, you can find more talks on meta programming. I have them on my general list of links: https://github.com/virtualdogbert/Groovy_Links Also if you are interested in an example of what AST transforms can do, I wrote a plugin for Grails, where I use AST Transforms, closures, and their delegates to create a DSL for enforcing permissions/business rules: https://github.com/virtualdogbert/Enforcer Some more simple built-in AST transforms: http://docs.groovy-lang.org/latest/html/documentation/#_available_ast_transformations
Agreed. Spring boot with Groovy is make you productive.
I like the Simpsons reference. What output are you getting ? 
as if its not been cast at all, see: https://groovyconsole.appspot.com/script/5101344520142848 click edit, then run script...
is there anyway to truly create a base instance from a child instance with groovy ?
there isn't a super clean way but what you can do is child.getClass() .getSuperclass() .getMethod("methodName", new Class[]{} ) .invoke( child.getClass().getSuperclass().newInstance() ,new Object[]{} ) ; 
Your code is talking to you: it's not a viable thing to do because it violates software design concepts (the L in SOLID.) Maybe you can achieve what you want by means of composition and injecting the behaviour you want, giving it a useful name.
Yea, provide a copy constructor in the base class. class base { String name = null base(Name) { name=Name } base(base other) { this.name = other.name } def sayHello() { println "hello from "+name } } 
so no real casting in groovy then ?
Yes, if you want the compiler to find these before runtime, you need to always use typed defines, but furthermore, you also need to annotate your class (or method) with @groovy.transform.TypeChecked. (When you're looking up the documentation for that, also read up the related @groovy.transform.CompileStatic, which affects the bytecode.)
ok thanks for the double check! just wanted to be sure I had the right handle on it!
There's a balance between dynamic typing and having the compiler check for those sorts of errors. Usually you'll have to give up the dynamic features in order to get type checking. 
 PS&gt; groovy -v Groovy Version: 2.4.11 JVM: 1.8.0_131 Vendor: Oracle Corporation OS: Windows 7
Little late to the party (aside from upvotes). I've been doing Grails web dev for exactly 2 years now, and 99% of the time, once I really know what I need, I have zero trouble finding it. We just finished upgrading several apps and proprietary plugins from 2.5.x to 3.1.x, and while the changes are significant, the only real difficulty I've seen is with plugins being updated, which was mentioned before. Groovy is great and getting better. You can stand up an app in Grails in a ridiculously short amount of time, amd you'll learn a bunch about Spring Boot (and Gradle if you go 3.x.x) in the process. Gradle is (was?) The build system for Android as well, so that's another feather in your cap, and another source of community.
Spock is pretty awesome, we use it for testing in our grails app. Works well in combination with IntelliJ's code coverage or cobertura on jenkins!
It means your testing the smallest testable thing in isolation, which is only possible through mocking / stubbing of dependencies in an OOP language.
That is exactly what I mean! Thanks.
Your integration tests (which will not use mocks) will catch any changes to the interfaces. My article is *NOT* about integration tests.
Thank you for your response. I did finally get it and this really helped. I split out the function and got rid of the @NonCPS stuff
Nice! Return statements are implicit in groovy and should generally only be used when breaking out of a method call, as in a return inside an if statement or loop. Otherwise, just ditch the word 'return', groovy will return the result of the last line!
Annotate the class with @CompileStatic for an additional speed boost and better type safety.
Thanks! I'll add the annotation :-)
Mmmm, yes I know. I put the returns because I thought the reading is better in that way...
Keep in mind that doing this will also reduce the amount of dynamic behavior that Groovy provides. For this example you don't need it, but having this type safety (a GOOD THING) requires you use a little less of Groovy's "groovyness". Nothing is free; understand your tradeoffs.
It's a style thing, but codenarc recommends against it in the default rule set: http://codenarc.sourceforge.net http://codenarc.sourceforge.net/codenarc-rules-unnecessary.html#UnnecessaryReturnKeyword
Ok. Thanks. I didn't know those rules :-)
No problem! Like I said, it's more a style thing, so don't feel it's the law. It just makes for easier reading in that you only have return statements when you're doing something non-standard, like early termination of logic.
Not so much a rule as somebody's opinion, but it is a good takeaway that you should run your code through a static analyzer like codenarc--what rules you configure codenarc to use are up to you. In a kata, an implicit return seems pretty right, and in general reducing the amount of code that you write reduces the number of places a bug might hide. However, I think implicit returns are like optional braces in a one-line `if` block ... very easy to break when the code is updated months/later. (One of the recent SSL bugs was caused by exactly that issue.) Yeah, yeah, unit tests. But I think it is a reasonable tradeoff to remind maintainers (maybe even a future you) what something is meant to return.
I've written many a Vert.x app in Groovy and love it. So much so that I got hired at Red Hat to do Vert.x full time. 
That's cool. I haven't seen or heard of many people doing the same, so I basically had to make up my own design patterns to use when building it out. I'm really loving it, though.
Is funny, the last few weeks I have been tasked with teaching Vert.x internally at Red Hat and I just introduced some people to SQLFiddle the other day, and now I find out it's running on Vert.x! Woot! 
This is one of those things I somewhat disagree with. I've had some killer bugs occur because the implicit return changes when someone adds a new statement at the end of a function, and nobody ever new someone was relying on the return value in another piece of code. I would prefer it if Groovy only did the implicit return for anonymous closures (where it really makes the code more concise) or similar. So I always put an explicit return and if it isn't there I don't consider it part of the "contract" of a function.
This isn't an issue if you use explicit return types though right?
I think it's still an issue: Integer foo(x) { int result = x.count { it &lt; 'c' } println "Result was " + 3 } Everything compiles ... but because I added a print statement it returns null.
Ah ok, I see where you're going. Fair enough points!
I work at SmartThings and we use Vert.x and Groovy at scale: https://www.youtube.com/watch?v=Xeh2IExt8rA 
They made it "better"? @Deprecated public static String padRight(String self, Number numberOfChars, String padding) deprecated: Use the CharSequence version See Also: padRight(CharSequence, Number, CharSequence) [CharSequence](http://docs.groovy-lang.org/2.4.8/html/gapi/org/codehaus/groovy/runtime/StringGroovyMethods.html#padRight(java.lang.CharSequence,%20java.lang.Number,%20java.lang.CharSequence)
Not usually, mostly just debug with Intellij. Variable inspections, and hopping through code is much much easier. 
Hey thanks for that link. Didn't even know that was out there.
You bet. Code narc is pretty easy to use with gradle, and the rule sets are pretty easy to customize. The groovy syntax rule file is a lot nicer to work with, so make sure to look at that.
I started a small app in Groovy with vert.x, but I have to admit I moved over to Grails eventually. The main problem was missing the ORM which in the end I actually needed, and the async style database access was pretty painful. I do love the idea of being able to spin up a simple web service with almost no lines of code and almost no install (since it is available with sdkman, you can bootstrap just about everything).
http://groovy-lang.org/objectorientation.html#_named_arguments There is a little bit of documentation about the method argument features. Basically, default parameters should be defined last. There used to be a quip about Maps and named parameters in relation to ordering, but I think it was in an older version of the documentation. Here's the code I tried in a Groovy console that seemed to work. I had to remove the default parameter assignment to the Map, so I guess it's a special case for Closures. def foo = { Map kwargs, ...args -&gt; println "kwargs=${kwargs.toString()} args=${args.toString()}" } foo(1:1, 2:2, 2, 3 ) &gt; kwargs=[1:1, 2:2] args=[2, 3] It got me to playing a little bit. Notice that explicitly defining a map argument caused varargs to contain the explicit map. Any "named parameters" were shuffled into the Map parameter instead of being assigned into the varargs parameter. foo(2, 3, 4, [5:6], 7, 8:9) &gt; kwargs=[8:9] args=[2, 3, 4, [5:6], 7]
Or use CompletableFuture...
 (String)it.@name Why are you performing a cast here? Is name not a String?
&gt; Groovy is able to use Kotlin extensions just like its own Apache Groovy is great for scripting. Stuff like builds, tests, and glue for code written in JVM systems languages like Java was its original purpose. So let's hope it can also be a scripting language for Kotlin, Scala, and any other statically-typed language on the JVM. Being able to handle Kotlin extensions in tests is a great start.
Groovy in Action 2nd edition
 i second that. It really is a remarkably well-written book. A diamond in the rough, as it were.
I third his second. 
How about books for compete newbies to programming? Does anyone know anything groovy centric for that? I've built a product with a groovy based DSL users have access to. Which works great, but 90% of questions I get are programming questions rather than about my product.
Problem is that the jenkinsfile is a DSL, it doesn't have the normal features of a class that you would annotate. You might only be able to document at the outermost scope- I just use in-line comments like you have.
Thing is, I really need to be able to provide the documentation in HTML, as part of a larger project and standardization effort. Is there maybe a generic parser of this kind of documentation that wouldn't care e.g. about classes and typical Groovy (or Java, for that matter) code layout?
Hmmm, interesting thought- I've never looked into something like that, but it makes sense. Sorry I couldn't be more help, if you do find something, share it!
Here are my Groovy resources that I give out to new people and use myself: https://github.com/virtualdogbert/Groovy_Links Groovy in Actions is good and While it's a bit dated, Programing Groovy 2nd edition is an easy ready, and very good. The documentation, has also come a long way, so don't discount that.
This is a reddit for Groovy - The programming language.
&gt; The HttpBuilder-NG team is excited to announce the 1.0 release of the project. We've had a lot of fun making HttpBuilder-NG and hope that others enjoy working with it. It's the client I always wanted to use, now with the imprimatur of a 1.0 release! &gt; HttpBuilder-NG is an http client for easily making and processing http requests. The main features are summarized on the project home page: &gt; https://http-builder-ng.github.io/http-builder-ng/ &gt; The user guide should get you started using HttpBuilder-NG: &gt; https://http-builder-ng.github.io/http-builder-ng/asciidoc/html5/ &gt; Finally we appreciate pull requests, bug reports, and suggestions: &gt; https://github.com/http-builder-ng/http-builder-ng/ &gt; The HttpBuilder-NG team.
Making Java Groovy is also very good https://www.amazon.com/Making-Java-Groovy-Ken-Kousen/dp/1935182943
Not an Android Dev, but I do use Groovy daily. You’ll need the groovy runtime Jars which do take a few megs, but nothing terrible. You can also run groovy code dynamically and directly without a manual compile step: http://groovy-lang.org/integrating.html#integ-eval You can evaluate groovy code loaded as a string dynamically at runtime. It also makes for a pretty good base to build a DSL. No huge gotchas that I know of, performance is great in most cases and the ease of use and terseness is really nice. Being able to write and parse JSON without external libs is awesome, closures are way easier to work with than java 8, optional typing allows you to only worry about typing when you want to, it has mixins, and you can cast damn near everything, this is especially nice for implementing minimal parts of an interface. It’s the basis for Spock unit testing which I believe android is already friendly with? So this might not be much of a lift. Good luck! 
Well I can partially answer this myself after some more reading. 1. I can stage the scripts myself in terms of giving user feedback while loading/compiling. But I won't have acces to the actual step. At least this works if the scripts are relatively small. 2. As far as seamless integration: it looks out to be that there's only one JAR that is used both in Desktop enviroment and Android. So the code uses the correct bytecode generation on the fly without needing another JAR per platform. Not entirely sure ofcourse. I'll nee to do a set up and test this. 3. As far as caching and saving compiled scripts to save time: no idea yet. Not sure if the API actually provides the location of the temp files or if I need to do some extra magic outside of Groovy on this.
Okay cool. Will try it out.
That's the only one I've read. I like it, but I have no basis to compare it to the others.
Or you could, you know, not use "def key" and instead use "String key" which will do the interpolation and behave as expected.
If I had to stop using a language every time I ran into a wtf moment I'd never get anything done.
&gt; WTF moment I'd never get anything that is also true, but groovy support is getting worst every second. 
Most programming languages that aren't too big to change, or aren't the rising stars of the moment, succumb to this. It's natural. Try keeping up with Perl sometime.
Why in the world would you ever use an interpolated string as a key?
def getKeyForServerId(serverId) { return "server-number-${serverId}" }
http://www.groovy-lang.org/syntax.html#_gstring_and_string_hashcodes &gt; using GString as Map keys should be avoided 
&gt; avoided of course. But why the hell string interpolation returns GString instead of String????
&gt; returns GString instead of String Why should it? http://www.groovy-lang.org/syntax.html#_double_quoted_string &gt; Double quoted strings are plain `java.lang.String` if there’s no interpolated expression, but are `groovy.lang.GString` instances if interpolation is present 
Because a double quoted "string" is a GString. This is not a gotcha, it's a truth of the tool. It goes back to Groovy working on older JVMs and compromises they had to make to allow Java code to be valid Groovy code too. The creators had certain goals that helped adoption and quick time to market and this had to work around things. It's not fair to blame the tool when the tool is being misused. That said it can be a gotcha if one doesn't learn the tool. Groovy does allow for static typing, favor it for certain things. Duck typing is great but only if you give your tool the respect it deserves. I don't usually give my junior devs free reign in our Groovy code. Java first, dynamic typing requires skills and/or supervision. 
You know Groovy supports typing right? You should be typing your keys. Return a string in that method instead of def, problem solved. You wanna talk about fucked up typo coercion, look at JavaScript.
&gt; The creators had certain goals Apache Groovy only has one creator, i.e. James Strachan. There's someone else in the Project Management Committee who regularly pitches himself as a "creator" of Groovy but isn't, so maybe that's where you got the idea Groovy has many creators. 
https://gist.github.com/anonymous/34fa90d1f2610c2bcd957961ac0f471e
What's the point of pasting the same gist link when it's there in the post?
because i'm dumb and copied the wrong tab i meant to post this https://gist.github.com/atbradley/946440 that should get you where you're going. 
I think this has been asked and answered, but generally, parsing and manipulating DOM with regex is a bad idea. We use jsoup which you can add to your code with grapes or gradle, and it gives you full DOM parsing, selection, extraction, and rewriting. You can work with it similarly to how you might use jquery. Little more code, but not a huge amount, and it’s much safer and less likely to have side effects than a regex.
Here are some hints: 1.) Use [XmlSlurper](http://docs.groovy-lang.org/2.4.10/html/api/groovy/util/XmlSlurper.html) to read in the HTML file. 2.) Select and replace the HTML tag using a [GPath](http://groovy-lang.org/processing-xml.html#_gpath) expression 3.) Celebrate!
https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
Thanks. Will try it out.
Thank you.
Metaprogramming is writing code that "writes code". My favorite use is to generate repetitive code from a JSON file (or some other structured data) on the fly. This also means users who can't necessarily code (but can edit a JSON file) can add functionality. Consider a client library for an API where commands are very simple (name,value) and are added frequently. You don't have to go back and add code to support new features; add the new command to the JSON file and your metacode generates the required classes/methods.
Try IntelliJ IDEA. You’ve already found what’s available for VSCode
NetBeans may have what you want. It does autocomplete &amp; syntax highlighting, builds with Gradle. It does lean toward Grails, but it perfectly serviceable for straight Groovy development.
See GPars
take a look at Reactivex. There are Observables that might work for 
thx. Yes IntelliJ, Netbeans and even Eclipse are great IDE's with really good support for groovy. And exactly this kind of groovy support I wanna see just in vs code. 
I' m more a scripting coder, typescripter or serverlesser and find it anoying to start a full blown IDE, creating workspaces, projects just for hacking my 42 liners... And I'm just in love with Erich Gamma's vscode...
This is one reason (among many) I declare types in Groovy. Being a dynamic language is great when you need it, but gratuitously declaring everything "def" just because you can is very poor style.
All sounds great to me. Glad that groovy isn't dead
Looking forward to seeing the syntax for closures harmonised with that of Java. Really one of Groovy's greatest selling points is the lack of friction in moving between it and Java. I think the article understates the extent of new Groovy 3.0 features though. If you follow the dev mailing list there are a tonne of syntax enhancements that are flowing through from the new Parrot parser. For my own wishes: I wish that compile static and type checking can get better. I need more guarantees around the behavior of the language. I see continued hours wasted solving bugs that really shouldn't occur. A great example is a function declaring a string return type implicitly casts its value to a String, so that any return path not producing a String doesn't make a compile error, but a `toString()` on the object. While I'm happy that Groovy is a dynamic language, I really want to be able to tighten up the guarantees I can have around my code in these type of situations.
The new Parrot parser was finished being written a whole year ago, and this article says Groovy 3.0 is "set to arrive in about a year", which always means longer. I'm wondering if someone in the Apache Groovy project management committee doesn't really want Groovy shipping with an Antlr-4 parser too quickly, preferring to keep it bound to its current Antlr-2 based parser for as long as possible. Maybe the tools available for Antlr-4 would make it too easy to translate your typical 15-line Groovy-based Gradle build script into a Kotlin-based one. Given that Groovy's only remaining significant presence left in industry is for specifying Gradle builds, it looks like one faction in the PMC decided to prolong the G3/Gr8 conference gravy train by stringing along the other developers with talk of extra 2.5 and 2.6 versions and pre-beta alphas.
Regular expression. Groovy has very good support for them.
There's a bunch of ways you can make that more "groovy". 1. Groovy strings are actually executable directly. So you can get the output like this: String output = 'reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\App\\UDF1 -v PatchRebootGroup'.execute().text 2. Can the group ever contain spaces? If not, you can just tokenize the result and get the last element: group = output.tokenize(' ')[-1] 
Great, this was helpful. So, here is the bit I'm using: String output = 'reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\App\\UDF1 -v PatchRebootGroup'.execute().text String group = output.tokenize(' ')[-1] println 'synoptek.DesiredPatchRebootGroup=' + group return 0
Is it me or is the groovy in that article bad style? Semicolons everywhere, .getName() instead of .name, GString and + mix...
A reputable(Paul King), more detailed source of what's going on with Groovy and why: https://www.youtube.com/watch?v=3NLPVfYLdGc And for Grails(Graeme Rocher and Jeff Scott Brown) https://www.youtube.com/watch?v=SZHeKHycKWk
I'm kinda disappointed as well. Java 8 is available since 2014 and Groovy still hasn't adopted the new language features. For me, one of Groovy's main selling point was being almost a 100% superset of Java. Since this isn't the case anymore since 2014, I don't see why one should use Groovy for anything else than small scripting stuff (scripting engine inside Java applications, Spock, Scripts with @Grab) when there are better languages available for enterprise development. For example Kotlin has much faster development speed and actually has features which are very useful (nullable types, MUCH better type inference, reified generics, compile-to-js, type-safe builders, inlining of lambas, ...). So they basically took a lot of the cool Groovy features and added a bunch of additional features.
Groovy IS compiled to Java Bytecode, and therefore has to run the same way. One difference is that since 1.6 the JVM introduced invokeDynamic. This allows scripting languages like Groovy to escape SOME of the constraints of the Java language. 
Yes, it would be better if it said "JVM" object model, but there's almost no difference between saying that and "Java's" object model. I guess the main idea here is that there are two types of JVM languages. There are those that try to be a completely different type of language to Java and thus invent new type systems with different semantics to Java's object model. Scala is a good example of this. Then there are the ones that try to be a "better" java - stick as close to Java's underlying design as possible, while drastically improving on the syntax and adding a lot of useful features. Groovy and Kotlin are examples of this type. One of the things I like about Groovy is that it does try where ever possible to align itself with Java, even down to the syntax level. If there is not a reason for something to be different to Java, it's the same as Java. People pretend the other JVM languages are just as good at Java interoperability, but it isn't true - you meet all kinds of interesting problems with impedance mismatches when you try to mix non-Java and Java code with most of the JVM languages. With groovy it fits so seamlessly in it's possible to write stuff in groovy and have other team members not even know it was written in Groovy.
It's why I tell people Groovy is really just a Java scrpiting language - and would probably have been called that literally if "JavaScript" hadn't already been taken.
&gt; If there is not a reason for something to be different to Java, it's the same as Java There are differences where Apache Groovy expands on Java's syntax, and there are differences where Groovy *behaves* differently to the same syntax as written in Java. It's the rationale behind this second type of difference I don't understand. There are so few of these that I wonder why Groovy didn't stick to the first type of difference only, similar to what the original C++ did to C. Here's some behavioral differences from the list at www.beingjavaguys.com/2013/02/what-is-groovy-java-vs-groovy.html ... *(2) In java we uses '==' to compare primitive types and '.equals()' to compare two objects, but in groovy we can use '==' to compare both primitive and object types. Although in groovy '.equals()' also works for comparing object* In Groovy '==' behaves differently to Java when comparing object types. *(4) In groovy 'in' is a keyword and we can not use it as a variable name* Why didn't Groovy just use ':' like Java eventually did so it would still work as a variable name? *(5) When declaring an array we can not write int arr[] = {1,2,3,4...} rather we need to right it as int arr[] = [1,2,3,4...]* Curlies not good enough for Groovy? &gt; With groovy it fits so seamlessly in it's possible to write stuff in groovy and have other team members not even know it was written in Groovy ...until they come across one of the above differences then they spend half a day debugging. 
XPost from same question in r/grails incase someone else sees this: I have a copy - it's pretty good. It's also one of the only grails 3x books - most of the rest are older grails 1x and 2x books which aren't very applicable to 3 (pretty substantial changes).
I got it. Even with almost no knowledge of Grails, I've reported back to the author on some things that could be explained better. He's been super receptive. If you find things that are "thin", I'd suggest send him an email.
Author here. The book is continually updated and refined (just updated to Grails 3.3.x &amp; the new Trait testing framework). I do talk about the respond method right away in the controllers section but could talk more about how models are used and passed to views. For referencing the user - I'll add in more information in the security introduction section along with some tips about storing frequently accessed information on the principal to avoid unnecessary db calls. To your last point - I didn't want this book to be a copy of the reference manual nor could I cover every use case. My goal is to cover many common cases and concepts I've used when building Grails applications. Please email me or add a ticket to the feedback tracker. Thanks for your purchase!
I love Grails
I love the fact that groovy is Java, means I can use it with any Java based web back-end. We use an Adobe product at work called aem which is normally jsp /jcr based but it works with groovy like a dream
what'd I do is iterate over the map with a .each() take each key as a tag, if the value is a collection or a single object then i'd put that as the child and close the tag, if the value is itself a map then repeat process. I've done this it's not that much code at all.
Thanks-- that was something I think I saw in a Stack Overflow post. I'll probably wind up going in that direction. I just wasn't sure if there was some type of toXML() function that would be even quicker. 
if you do it recursively it should just be a few lines. 
You may have already found this: https://stackoverflow.com/questions/30997222/groovy-nested-map-to-xml
Nice to see a new release but the real interest at this point is in 2.5, I think. I know it's bad form to be impatient for an open source project to make a release, but 2.5 feels like a very long time coming. The transition to Apache hosting slowed things down a lot, I guess, and hopefully that's a temporary hump. But still ... I never thought I'd see Java release new *major* versions faster than Groovy could release new *minor* versions!
It's an interesting idea, but it's little too conspiracy theory-ish for me to give them credit for. Watching the dev list what I think is mainly feature creep and too many parallel versions at once (4 versions in active development is kind of ridiculous for any project). But who knows ...
Please don't. While there is no real equivalent to Spock in the Kotlin world (as Spock makes heavy use of Groovy's dynamism) I'd suggest using something like [kotlin-test](https://github.com/kotlintest/kotlintest) which has similar features but is typesafe.
I'm a professional software developer. Every now and then someone will suggest I learn or use a different language (Python comes up a lot). Why? I look at other languages and I can do that with Groovy - and more. JSON &amp; map manipulation is super easy. XML support is great - unlike Python. Web apps? Grails is slick. Build tools - Gradle. Groovy lets me get work done quickly. As you say, Groovy has all the depth of Java with syntactic niceties of Ruby &amp; Python.
&gt; Spock makes heavy use of Groovy's dynamism Are you referring to things like Spock's: * overloading the | operator to create lined-up tables in the code (when a proportional font is used) * using jump labels in lieu of function blocks to mark off application logic I'd call it "intercepting the parsing process", not "heavy use of dynamism". 
You expressed quite well how I feel about it. Groovy is just brutally pragmatic: everywhere that it departs from CS purity is to achieve something with potent utility, while everywhere else it shows complete deference to Java style and syntax. Another thing people may not realise is the performance. Even without CompileStatic it's an order of magnitude faster than Python or Ruby. But *with* that it's basically Java. I recently ported a whole app from Groovy to Scala, and then ended up porting it *back* because the Scala could not benchmark at half the speed of the Groovy code, even after intensive optimisation. The problem being, Scala's separate type system compared to Groovy just sticking to raw Java data types. There are definitely a few things I would improve about the language. I *hate* implicit conversion to strings - that alone has contributed hours upon hours of debugging to my life (particularly nasty when combined with implicit return, just about any dangling statement at the end of a function returning a string will stringify and return whatever its result is!). There are a few other things like that. You have to get to know them. But after that, it's by far the most "useful" language I know for just getting stuff done.
If your codebase is only Kotlin then that makes sense. But a lot of people are using Spock to test Java code and hybrid Java/&lt;other JVM languages&gt;, and adding Kotlin into the mix. If all your tests are already in Spock it makes sense that you would probably want to keep using your existing test framework and want to know how to extend it to address your Kotlin classes.
What is it about Groovy that leads to it's poor placement (i.e. near the top, 11th) in the 2018 most dreaded language list?
I had an opportunity to work with it years ago and for some reason at the time I was like nope nope nope. Also, I think it is largely under the radar.
Yes, you are correct. Dynamism is the wrong term here.
Didn't think about that case. I totally agree.
 I think it's because there's a heap of people who encounter it only through Gradle, and usually it's because their Grade build is throwing some strange error or they need to customise it and they can't figure out how. Gradle uses highly idiomatic Groovy syntax which you actually need to be quite expert in Groovy to really understand ... I think it creates a horde of people who "dread" it, but they aren't really groovy users ... 
&gt; they aren't really groovy users Because Apache Groovy's only remaining significant use is as a DSL for Gradle, if they "aren't real groovy users", then there aren't really any "real Groovy users" left. 
Thanks for sharing! I worked on a grails project for a few months but didnt fully understand the power of groovy. My breakthrough with groovy started when I volunteered to convert a large ant build to gradle. The ant build was required to still work during the conversion so I couldnt use some of the gradle conventions. Being able to read xmls and property files and rewrite them as gradle files would have been a huge pain if I didnt use groovy. Adding ConfigSlurper to support the build config was a huge win. It handles a lot of the global properties from the old build. The build went from 2 hours to 20 minutes with tests running. Unfortunately the leads are not allowing developers to use groovy in projects. I created my own project to learn more about groovy. https://github.com/moaxcp/graph-dsl
I wouldn't worry too much about books that are 3 - 5 years old - there's nothing about the language in that time period that has changed enough to matter. I'd prioritise picking something right for you depending on your experience. Primarily whether you're coming from a Java background vs other scripting type languages vs no programming experience. For anybody with a bit of programming experience I think Groovy in Action is one of the most commonly recommended. But you might like something that's more tutorial style.
No recent books, but that doesn’t matter. I liked the books by Venkat Subramaniam. You can catch up on whatever’s new once you learn the basics- the fundamentals haven’t changed.
What I have everyone do when they start is to read through the Language Specification (http://groovy-lang.org/documentation.html) and then all of Mr Haki's Groovy Goodness posts (https://mrhaki.blogspot.com/search/label/Groovy%3AGoodness).
Try using `.each` instead of `.find`. '.find` returns 1 result (in this case the first because you aren't providing a conditional). If instead you want to return all results matching a condition, use `findAll` [groovy-find](http://grails.asia/groovy-find) List getAvailable() { List myList = [] response.value.books.book.each { node -&gt; myList &lt;&lt; node.@available } return myList }
The reason it's only iterating once, is the find closure stops and returns once the closure returns any 'true' value. The list append returns a 'true' value, but print on returns null. Use .each or .collect instead.
.with is very similar and in 2.6 I believe there will be .tap which will work like apply 
Great list, thanks!
This is a great writeup. I'm a huge fan of groovy and am always excited to hear of it being used in new things or getting new features. I rarely use the AST transformations other than @CompileStatic - this article made me want to read up and practice with those some more so I can see how I can use them in my day to day. Finally, adding negation to in and instanceof is amazing - I cringe every time I have to wrap statements in parens just to negate. Sweet!
TLDR? Usability of the site is horrible.
Nice article, I really like Ken. His groovy-grails podcast on youtube is good as well. Reading this I feel like there's been an unfortunate timing mismatch wherein the groovy team has devoted a lot of effort to maintaining back compatibility with JDK6 and JDK7 when in reality, the world has moved very fast to JDK8 as a baseline. Due to the modularity changes in Java9 onwards I suspect JDK8 may linger for more time, but all the effort around the earlier releases seems to me like it might have been misplaced.
If Apache Groovy 3.x doesn't maintain strict backwards compatibility with version 2.x, no-one will use it -- just like with Python 3 (at first), Grails 3.x, and Perl 6. When Groovy was on the rise, it could break compatibility between its 1.x releases (as it did 1.0 to 1.5, 1.5 to 1.6, 1.6 to 1.7, and 1.7 to 1.8) and users still upgraded, but that doesn't work for a language on the wane. 
[Lazybones](https://github.com/pledbrook/lazybones) can set up a Groovy project for you.
Nice to see some examples of the profiles in action. It seems like a good concept, but not too much out there on how to actually use it. Would love to see one of these for VueJS.
If it can’t resolve String, you haven’t configured a JDK for your project
that's on my plan
Damn, I have jdk 8 setup as the project's jdk and reinstalled Java twice.
I did this in like 2 minutes, but I did this on my work(OS X) Machine. I'll try this out when I get home on my home machine(linux).
It calls the closure {println it}. Parentheses are optional for method calls in groovy, therefore, it's equivalent to the call *dance ({println it})*, which is invoking dance() with a closure as argument.
As a long time groovy developer, you'll find Kotlin gets all the love for things that groovy did years before. 
Yes I see lots of the same stuff tbh, I was just learning groovy to understand gradle more, but thought I dig deeper also.
You can check out information about Kotlin's null safety [here](https://kotlinlang.org/docs/reference/null-safety.html) and the relevant part is really this line: &gt; In Kotlin, the type system distinguishes between references that can hold *null* \(nullable references\) and those that can not \(non\-null references\). That means the compiler will make you handle scenarios where your values could be null. You have to write your code so that it explicitly says you allow it to be null. You can still get NPE in Kotlin but it's usually because you're using Java code that returns null. This is a huge addition on top of `?.`.
Yeah, I mean, I love new jvm languages, but for me at least, the optional typing of groovy is way superior. Type checking when you want it, and free form when you don’t. It’s still my Goto language for most quick projects- the null coalescing operator is one of the single most useful tools for stuff like json and file parsing. 
When I read articles listing everything awesome about Kotlin, i feel like you could swap in the name "Groovy" and the article would be completely accurate. Unfortunately, Groovy never got strong momentum or sponsorship, but I really think with some work and polish, it's a really strong contender.
The biggest difference is that Groovy had a lot of organic growth. A less nice way to say it would be that it is a collection of language hacks on top of Java. Kotlin's principles are more consistently implemented, and by targeting the JVM instead of trying to to be "almost Java compatible" some other ambiguity is also avoided. We happily use Groovy at my place of work, but I don't think I'd recommend it over Kotlin for an entirely new project unless it's a very specific case. 
Groovy alone for a project i'd agree but grails makes it a whole lot more compelling. 
Thank you for the answer. What if I have: closure{ clo{ println } } Does it mean it is like this: `closure({clo({println}))`?
Correct. Provided there are methods called closure and clo defined.
REST API? Groovy has good HTTP tooling.
I wasn't aware mongo had a decent rest API? If it's decent that's awesome and seems like a simple solution.
The official driver? https://mongodb.github.io/mongo-java-driver/ Should be able to use grapes, gradle, or maven. 
Oh cool, thanks
Beautiful `tap` method!
The [release notes](http://groovy-lang.org/releasenotes/groovy-2.5.html) are much more readable.
Yes the are! Thanks.
Groovy + Spring Boot beats the pants out of Grails for anything other than Hello World CRUD.
This smacks of a take-home junior developer test.
Yep it works perfectly. I use it with my Selenium project using Groovy. As the other guy suggested. Import it into your project using Gradle.
For functional testing try out [geb](http://gebish.org)
nope...
Why don't you give us a little context. What are you trying to accomplish here?
Then how the hell does `a.b` work?
So a = { it } creates a closure which returns the object which was passed to it. it is the default name of the first argument to a closure. If no args are passed it is null. In regards to "a b c d e f g h i j k l m n o p q r s t u v w x y z * 3" From the groovy docs: "Groovy lets you omit parentheses around the arguments of a method call for top-level statements. "command chain" feature extends this by allowing us to chain such parentheses-free method calls, requiring neither parentheses around arguments, nor dots between the chained calls. The general idea is that a call like a b c d will actually be equivalent to a(b).c(d)" def propertyMissing() will be called when a property is tried to be found on an object and that property is missing. Ex, person.name if person didn't have a name field would call the propertyMissing method instead of just crashing. So let's break it down: a(b) executes the closure { it } with b as the 'it'. But b as a variable does not exist, so missingProperty is called first to resolve it. missingProperty takes the property name, in this case "b", and does ++"b", which in groovy if a String has a single char returns the next char, so "c". The last line of missingProperty is an implicit return which returns the closure: { _ -&gt; [(++name): { this."${--name}" }] } The first argument of the closure is called _, which is ignored, so ignore the _. This closure creates a map which returns (if name was originally "b", ++name made it "c", so ++name in the closure is "d"): [ "d" : { this."c" } ]... I explained some of it, I'm tired of looking at it at thing point :) 
gradle init --type groovy-application gradle run Yw
You can omit brackets for non-ambiguous use case. So do the dots. `a b c d` equals `a(b).c(d)`, and `a b, c d` equals `a(b,c).d`. `a` &amp; `z` are script wide variables if you run it in shell or as script. `b` to `y `don't exist in the script, and are relayed to `propertyMissing()` that returns a closure nesting another one, which both ignore arguments. Furthermore, property called on/in a closure, if not exists inside declaring, will be searched outside the closure(scope `this` i.e the script), and be relayed to `propertyMissing()` thus. So the whole chaining calls are basically just procedually generated closures as pretended property/method which ignore all arguments and return closures, and being called again and again. BTW, you can use groovy's *power `assert`* to see intermediate result of statement.
It will soon. The problem is that Groovy had closures before Java had Lambdas, and they chose a slightly different syntax. 
Groovy is not a strict superset of Java.
&gt; It will soon Do you mean lambda syntax will be recognized in Groovy 3 ? I'm not sure we'll see it for quite a while, and even suspect it's being perpetually slow-roaded to avoid a Python 2/3 or Grails 2/3 scenario. Even Groovy 2.x had plenty of time recognize lambda syntax since it came in Java 8, given that Java 10 is now out. 
Check out grape http://docs.groovy-lang.org/latest/html/documentation/grape.html
You might try the session videos from greach (just search for greach you YouTube). There are a number of good books out there, I recommend the ones by venkat subramaniam- they can be found in print and as ebooks. Also, depending on how much java experience you have, the groovy for java developers books might be good. If you have other programming knowledge but not groovy as much, maybe try the groovy recipes book. Beyond all that, I highly recommend the groovy goodness blog/books which has great examples of how to do very practical stuff. It’s available free online. I know you asked for videos, but there seem to be mostly written references out there. Good luck!
Wrong type of groovy, but close enough.
Close enough, lol. well played
If you're willing to pay for content, or have access to Safari via school or something, I'd check out Ken Kousen's "Groovy Programming Fundamentals". He has a few other courses with more advanced topics. Easy to watch/listen to, and actually pretty funny at times.
History. I started working with groovy long ago. If I had the choice to start over, id start woth kotlin. It seems more supported and slightly more future proof?
I like groovy as a language more than kotlin; it fills me with more joy to use, and with @CompileStatic and @TypeChecked I get much of the same joy with the same speed. Kotlin however has Google backing now, and first class IntelliJ support, so I think is probably a more practical choice. 
There are some constructs in Groovy which are not available in Kotlin AFAIK... For example: * [map literals](http://groovy-lang.org/syntax.html#_maps) * [simple currying](http://groovy-lang.org/closures.html#_currying) * destructured parameters * [Built-in Trampolines](http://groovy-lang.org/closures.html#_trampoline) Kotlin is nice, but Groovy has far more syntactic sugar.
My manager asked me to convert my Python script into our official tech stack which is on the JVM. I was given the following options: Golang, Kotlin, and Groovy. I did some research and determined that of those 3 I'd be most comfortable learning Groovy. A week later I've completed an intro course +13 hours of video lectures and will be converting my script to a proper Groovy program this week. So for now, I can see myself diving deeper into Groovy. If in the future I want to learn MORE I will certainly consider exploring Kotlin. Just for your info, here's the course I took recently: https://www.udemy.com/apache-groovy/
Kotlin is the new hotness, but I’m a long time groovy fan. The ability to switch back and forth we between script syntax (no classes, global scope variables, etc) and formal application syntax for writing OOP style code is nice. I know you said optional typing doesn’t matter to you, but it’s an extremely useful feature. There’s a lot more sugar and less boilerplate in groovy- it’s a very pragmatic language. Writing DSLs with groovy is pretty easy. Spock for unit testing is groovy based. I do t know much about the meta programming capabilities in kotlin, but in groovy you can do just about anything. For me, working with kotlin felt a little bit like going back to java after years of working with something nicer. A little bit. Groovy seems more focused on making life nice for the developer.
The business imperative behind each language is quite different: Kotlin is being constantly improved by JetBrains and always interops seamlessly with IntelliJ (including Android Studio), whereas Apache Groovy has been on a go-slow development track ever since it was promoted from the ASF incubator to top-level project. Kotlin is driven by a policy of continual improvement because it helps sales of IntelliJ Enterprize. Groovy is driven by a policy of no breaking changes (and hence no Groovy 3) because it helps prolong the consulting and conferences gravy train. 
Your take on the course? 
A great way to get introduced to the core concepts in Groovy.
For me, it depends a little bit what you want. I think Kotlin is probably better if you specifically want a robust language to build larger applications with. It has much cleaner and stricture concepts around static typing, null-safe code, etc. It will have really good IDE support obviously, so all the refactoring options etc are going to be top notch. On the other hand, Groovy is far more flexible and adaptable. It can play in everything from the one-line-bash-script space right up to full complex application development that is the equivalent of Java. In my view, Groovy is the true "scala" in that sense (because Scala was supposedly named for this capability, even though nobody uses it like that really). So for "bang for buck" you can really get a lot with Groovy, ie: it addresses a broader set of applications. I actually find it really handy to be able to write quick one liners that nonetheless are tapping into the full complex business logic of my apps just using: groovy -cp my.jar -e '..... some code ....' 
Hi, try: File sourceFile = new File("MyCoolClass.groovy"); Class groovyClass = new GroovyClassLoader(getClass().getClassLoader()).parseClass(sourceFile); GroovyObject myObject = (GroovyObject) groovyClass.newInstance();
Yeah, I suggest using packages. It’s the same syntax as java, so any guides there apply. in MyCoolClass.groovy, add `package mypackage` add this to the second groovy file as well. make sure both files are in the dame directory. Now you can reference methods and variables, and classes directly. I’ll try to post a more conplete example in a few min.
Maaan, thank you! This is working the way I need it to! Since I'm casting this as a generic "GroovyObject," are there any catches I need to look out for that would be different than if I was directly creating a specific MyCoolClass object?
Thank you, your comment and link are both helpful in understanding how groovy is working. So from my understanding the classes need to be compiled first, and placed in that directory structure along with the script (I'm doing the "script" flavor rather than "app"). Unfortunately (and irritatingly) in my specific case, the script I write gets copied and pasted into a kind of "run groovy script" node within this weird workflow manager thing, which is actually managing the execution of the script. So the script doesn't live in a directory structure where I can also keep classes.
So a script can access anything in the current classpath. That means that external libraries and files in jar files can be accessed from the script as long as they’re on the current classpath for the script. This can be done with the —classpath flag when running the script, or by including the jar files in your app server.
Thanks! Yeah that's the thing. This is node-based workflow automation software I'm working with. I'm typing groovy script directly into a "Script" node, so no .groovy file is ever saved anywhere in the filesystem. I suppose the script contents are stored in the database with the rest of the node data. Also no control over the flags the workflow software sets when it parses the script. It's some real janky stuff.
Yeah so the classpath rule still applies. If the groovy code is being saved as a string somewhere and is being executed with an in-memory script evaluator: http://docs.groovy-lang.org/latest/html/api/groovy/lang/Script.html, then you are limited to what you inherit from the classpath you’re given, what you can inject with grape, or what you can load dynamically at runtime. Are the “other” files you’re trying to work with actual code, jar libraries, or something else?
I really appreciate you taking the time to explain all this! I'm going to keep trying to understand your method, because it seems more "groovy-esque." I'm still having a hard time grasping it, but that's certainly not *your* fault. I'm dumb! Haha. But yes, in the meantime, I do have something that is up and running. Thanks again for all your help!
No problem. You’re in a little bit of a tight spot because of how your code is executed, so doing the dynamic loading the other poster showed might be your only option, but it’s definitely a hack. Ordinarily you would just write a quick groovy script that uses a bunch of external libs from maven (using grape), or use something like gradle to package it up into a nice runnable bundle. Good luck with your project!
I'm not sure if I'm misunderstanding, but this "just works" for me without any fancy tricks. The only problem you have is that Java (and by extension Groovy) won't import from the default package - but you don't need to. If you put both into the same directory then testProject.groovy can see MyCoolClass without even importing it. Just leave out the import and you will be fine. If you want to have the two files in different directories then you need to add the directory of MyCoolClass.groovy to the classpath: groovy -cp parent/dir/of/mycoolclass testProject.groovy 
Spock as a testing framework is the bees knees. I use it in production as a better, easier to write/read Java. With a couple annotations you can have it compiled statically and STILL be way better than java from a source code perspective, and maintain the static binding so you don't incur the penalty of the dynamic nature if you don't need it. 
I love spock, its approach to BDD is lightweight and fun to use compared to cucumber or similar frameworks that requires gherkin. [Docs are here](http://spockframework.org/spock/docs/1.1/all_in_one.html#_blocks), but the gist is that there are given/when/then blocks that you can use to design and document your test, and they provide some convenient features (conditional statements in the `then` block are wrapped as assertions for example), but otherwise you are writing normal code. Only big negative is that there is no parallel test runner (as far as I know), and you need to understand Java annotations better than I do to organize your tests well.
Grails makes the world happy. 
Groovy's Map &amp; JSON magic is wonderful. And regular expressions. And groovyConsole for testing out little pieces of code. And Gradle (it's a Groovy DSL so you can sprinkle raw Groovy in the build scripts) And, of course, Grails is a great layer on top of Springboot. And there are more "exotic" things like [GroovyFX](http://groovyfx.org/) and [Griffon](http://griffon-framework.org/).
I use it for literally everything. From bash style scripting to small applications to complex ten thousand line source code apps. What I most like it's how it scales between these domains so seamlessly. There is no language like it that does it as well as far as I'm concerned (including scala, which was named for that).
Backend jobs. The sql abstraction is absolutely gorgeous. 
I use Groovy as the scripting language in [BowlerStudio](http://commonwealthrobotics.com/), which means I use it for CAD, Kinematics and control algorithms for robots. Groovy lets me access all the rich JVM libraries with an easy to write, easy to read and easy to deploy scripting level. It helps me onboard new users by being low on boilerplate and low on syntactic and IDE configuration, but being fast and performant at runtime. 
I find Groovy extremely useful and extensive to add DSL scripting support to my Java applications, i.e. for plugins written by end users / customers.
Try using a Java 8 JVM and rule out Java Module issues.
Groovy 3 has a current issue where groovy-jaxb (part of groovy-all) requires the java xml package which was removed in Java 9 I think, although I think this is fixed in development. Maybe wait for alpha 4/beta 1.
Groovy is still my favorite language for its mix of java compatibility, language features 10 years before they were ‘in’, awesome dsl support, high performance, integration with gradle/Spock, optional typing and optional script syntax. They just did everything right with it. My ONLY gripe is that the groovy jars are like 5 or 6 megs making bundles scripts bigger than I’d like- but hey, it’s java where a handful of libs are 100 megs, so I guess not so bad.
I dare to ask: what exactly do you mean by „high performance“? Groovy is not generally known for being fast, or am I wrong?
Would be interesting to see some performance comparisons. Especially for numerical stuff.
Actually you're wrong. Once upon a time it was slow indeed, but these days it's very fast. I actually wasted 3 weeks of my life porting a groovy application to Scala because I thought it would run faster and after iterating through several rounds of optimisation my Scala code was ugly as hell and still slower than the Groovy code. Bottom line, if you use CompileStatic, Groovy is as fast at the byte code level as Scala, Kotlin etc, but has the advantage of zero impedance mismatch between Groovy and underlying Java data structures / libraries, which means in general it wins unless you are willing to make those languages look unnatural.
Groovy seems to bounce around in these indexes *a lot*. That is not to downplay the significance of this .... I think it means *something*, I'm just curious about what .... the methodology (counting hits from search engines) really should not be able to move this much so rapidly. I feel like it could be more to do with release cycles of either groovy itself or related products, or it could actually be changes in search engine behavior. 
I use a temporary work-around of excluding the jaxb and xml modules. Since I am not using them in my project. &amp;#x200B; `compile ('org.codehaus.groovy:groovy-all:3.0.0-alpha-3'){` `exclude module: 'groovy-jaxb';` `exclude module: 'groovy-xml';` `}`
In general, `${expr}` just evaluations any arbitrary groovy expression. Would have to see more context to try and explain any more than that.
hm, thank you. is it similar to $() in jquery? &amp;#x200B; what's the difference between ${book}.author and [book.author](https://book.author)? i'm sorry that this is so vague, i just can't give specifics at the moment. thanks again for your help
I don't know jquery enough to help there, I'm afraid. For your book example, if you had a `Book` class with an `author` and `pages` field, and you had code something like: print("I'm reading something by ${book.author}") vs print("I'm reading something by ${book}.author") Say you had an object `new Book(author: "Oliver WIlde", pages: 130)`. The first line would print: `I'm reading something by Oliver Wilde` The second... `I'm reading something by Book: author=Oliver Wilde, pages=130.author.` In other words, `${book.author}` evaluates the author field of the object pointed to by the `book` variable. `${book}.author` evaluates the entire `book` object (which would call its `toString()` method on), and then print `.author` after it, as a string. The evaluation is everything inside the `{}`, and nothing outside it. In groovy these are called "GStrings", if you want to google it. Look up "string interpolation".
hm, okay. thank you!
Groovy is better than vanilla Java for almost everything you would use vanilla Java for. If you're building web applications, Grails is an awesome Groovy based web framework that really leverages Groovy + "convention over configuration" to enable rapid development. 
"service" does not exist, "services" does.
Okay, that was just a typo when I was typing the snippet into the window. I fixed it in the post and the error is the same.
Bingo, thanks. Coming from PowerShell, that is probably not something I would have noticed.
Not really- it’s for injecting dynamic information (groovy code, variables, etc...) into a string. `def name = “bob” println “Hi ${name}” // prints ‘Hi bob’ println “Hi name” // prints ‘Hi name’` In the case of Grails, you could use it inside strings in your controllers or services like I did above, or inside views, you can can kind of think of as just big long strings. Outside a string or view, it isn’t necessary because regular programming declaration, naming, and scope rules apply: `println name // prints ‘bob’ ` Hope that helps!
Nice post. 
&gt;def definedServices = "standardServices,BITS" def standardServices = \['W32Time', 'vds'\] def services = definedServices.split(',').collect{ it == 'standardServices' ? standardServices : it }.flatten() services.each{ println it } This looks cool. I see that it works, but I'm not sure how the collection-building works. It looks like you are replacing the string 'standardServices' with the contents of the standardServices list. As far as I can tell, the question mark allows null values, avoiding an error but in this context, that doesn't make sense. And what, exactly is "standardServices : it" doing? &amp;#x200B; Thanks.
http://www.groovy-lang.org/changelogs/changelog-2.5.3.html
Thanks. 
Thanks.
I changed the command line to output = ('reg query \\\\' + hostname + '\\HKEY_LOCAL_MACHINE\\SOFTWARE\\SynAEM\\UDF1 -v PatchGroup').execute().text &amp;#x200B;
[https://www.manning.com/books/groovy-in-action-second-edition](https://www.manning.com/books/groovy-in-action-second-edition) &amp;#x200B; But if you are already a Java programmer, the documentation &amp; tutorials on the Groovy language site are good to learn the new operators, idioms, and the built in packages.
For general code style and gotchas, codenarc does a nice static code analysis and linting!
Also, there is a groovy slack group. Check it out!
/r/lostredditor
Um what this lol
I think you are misunderstanding the nature of Groovy, Kotlin and Gradle - they are built entirely of of Java, compile into Java, and can call any Java function. If you are an old timer like me, it is similar to how COBOL compiled into Assembler, and can call any Assembler routine.
I don't think it's that complicated. There are some weird edge cases where Groovy is not Java, but 99% of the time "it just works".
What if you did this: static void randomMethod(Map params,Closure body = null){ if(body==null){ body = {} } }
This throws a Null Pointer Exception
You need to make sure `net start ...` works when run on the command line first. If that's not working, doing the same with groovy won't help. But...having said that, if `net start ...` does no harm if the service is already running, why not just blindly run that periodically? If the service is already running, no blood no foul, and if it isn't, it starts it. Why even bother to check if it's down? Unless your goal is to specifically use Groovy for this, this could be put in the windows task scheduler.
What class is WMI or the "session" variable?
It looks like result java.util.HashMap is and session is com.santaba.agent.groovyapi.win32.WMISession. &amp;#x200B;
Found your post on SO: [https://stackoverflow.com/questions/53841634/groovy-start-windows-service-on-remote-server](https://stackoverflow.com/questions/53841634/groovy-start-windows-service-on-remote-server) but nothing else on the class. You have to check with wherever you got com.santaba.agent.groovyapi.win32.WMISession from.
Yeah, I just deleted this that post. I create a more generic version at: [https://stackoverflow.com/questions/53871362/using-groovy-to-create-a-wmi-object](https://stackoverflow.com/questions/53871362/using-groovy-to-create-a-wmi-object). &amp;#x200B;
He didn’t test @CompileStatic. 
Hey /u/wetling, I'm a collector PM at LM, the WMI class is provided by LogicMonitor and included in the collector. It can make queries, but WMI methods on returned objects aren't currently supported. You could accomplish this with an embedded PowerShell script. 
Very good point. Performance tests should also really use a tool like jmh. There are a lot of errors in methodology in this article.
Thanks for sharing @quad64bit Everyone can sign up for the Groovy community slack at [groovycommunity.com](https://groovycommunity.com) 
Not really a complete answer but groovy is heavily used to customize jira/confluence but not always known well by Atlassian partner/service providers. They might be interested in your skills :)
Yeah, Jenkins, gradle, grails all heavily groovy based. I'd say any shop that does java is a good fit since you're java compatible. Micronaut looks sweet for micro services and has native groovy support. I've used groovy for any clients that want work done in "java", using groovy isn't a tough sell there.
Yeah, I determined that the Groovy API won't let me manipulate the objects. &amp;#x200B; I was trying to avoid PS because of the way our collectors and device properties are organized. I have moved on to another project for the moment, but will probably end up coming back to this later. &amp;#x200B; Thanks.
I...uh... don’t think this is the subreddit you think it is.
Nearly every Jira admin contract I've had in the past 3 years has required me to write at least a little groovy outside Scriptrunner. The higher-paying ones have required me to write plugins.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/askprogramming] [How can I print the response of my mock http request when testing with Groovy \/ Spock?](https://www.reddit.com/r/AskProgramming/comments/aobfw1/how_can_i_print_the_response_of_my_mock_http/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Windows installer https://bintray.com/groovy/Distributions/Windows-Installer/groovy-2.5.6-installer
that's just the default toString() you get for all objects. Are you trying to print out the contents of the response? as in http://docs.grails.org/3.0.1/api/org/grails/plugins/testing/AbstractGrailsMockHttpServletResponse.html#getJson()
All groovy objects have dump() which is more useful than default toString(). So I use println(object.dump())
Well that's... Groovy. &amp;#x200B; In all seriousness I'm happy to see this and hopes it sparks more interest in the community, especially Grails.
The real bummer is that Jenkins implementation of Groovy is sort of broken. Me: reads the Groovy docs and finds a cool feature. Later Me: looks up some dudes blog only to discover that what I wanted to use is broken or not implemented. Thanks Jenkins. If it wasn't for that sort of thing I think I'd actually like Groovy.
Spock is broken, Gradle is broken. JDK 9+ and Groovy are broken. I highly doubt the merits of this article unless groovy devs are needed because everything broke when Java 9+ dropped.
I think it's totally fine to use Groovy as a backend language but that you're going to have a hard time getting other people to use it. Most people I know who primarily use Java will see Groovy as unnecessary because they're not really enthusiastic about programming anyway and there are so many Java jobs out there so why bother. Otherwise, and I kind of fall into this camp as well, if you're enthusiastic about programming why use Groovy over Clojure/Kotlin/Scala? It's fantastic for DSLs but unless you just insist on using a dynamic imperative language I think there are better alternatives.
Yes people use it as a development language. Our entire back-end for our product is written in Groovy. It's awesome.
Well, for my case, this was what the company was looking for. Groovy allows you to use dynamic typing as well as static (you can use @CompileStatic and @TypeChecked), also has pretty nice features like methodMissing and invokeMethod. I tried Scala and didn't like it, it was a super overloaded language that can get out of control very easily when multiple people code in the same project. I am really interested in working with Kotlin, though. I hear from a lot of java developers that groovy is slower than java, which is true because of being a dynamic language. I would like to continue working with Groovy or moving to Kotlin, but I see a very very small market to them.
I like Scala ok but would really rather use Clojure or Kotlin. We had an opportunity last year to pick a language for a project and I tried to get Kotlin (most of my team was Java developers) but Scala won out and it's been both good (particularly ScalaTest is nice) and bad (SBT :| ). With regard to speed, using @CompileStatic can put you on par with Java so I always think Groovy is at least as good but a good amount of the time language speed is not a bottleneck, you're usually waiting on http or a database or something. &amp;#x200B; If you're insistent on working in Groovy consider automated testing. It's what I do, Spock is a fantastic test framework, Jenkins pipelines use Groovy, and of course Gradle (though Gradle can be used with Kotlin lately as well). &amp;#x200B; I really hope Kotlin can take off. It's approachable enough for Java developers to move to (moreso than either Clojure or Scala) but you aren't held to writing it in the same kind of constraints as Java: it can be entirely functional. I think Groovy use outside of the things mentioned is only going to go down (which is definitely a shame as long as Java is still widely used).
We are migrating to Java Spring Boot, due to a lack of skilled groovy/grails programmers, and a huge descent in popularity. 
It is a fine enough language, but it is dead in the water, due to the trend in Kotlin adoption (and not for nothing, Kotlin is better as a statically typed language). For you personally though, Groovy skills transfer well to Kotlin skills. 
You might be interested in Micronaut - the successor to Grails. Still in early versions. For me, Groovy is a great syntax layer over Java. It’s SQL support is very useful. Do you care about Groovy for getting work done, or keeping up with the language of the week &amp; making your resume look good? I get lots of work done with Groovy &amp; Grails, and even after using them for years I am learning new things.
I've used it very effectively for backend dev many times. There are several frameworks which have Groovy as a first-class option (Vert.x or Grails come to mind), and the performance is excellent. I really enjoy Groovy for all sorts of development. 
I took a look at micronaut and looks pretty promising would like to work with it. Regarding groovy, after I tried it I liked it so much that don't want to move back to Java. I work with it in a microservice architecture and since the project is nearly ending I would like to continue working with groovy or maybe kotlin, but as said before there is very little work for groovy or kotlin in the market 
I’m surprised Scala won. These days, Kotlin seems to be a far safer bet. My team switched over to Scala around 5 years ago when the hype said Java was dead and everyone would be switching to Scala. Right now we can’t even upgrade past Java 8 because there’s no Gradle plugin that supports building Scala for Java 9+. We’re probably going to have to make the plugin updates ourselves which partially negates the team performance gains from using Scala. I personally really love Groovy, but I’m not sure I’d use it in production code for reasons mentioned in this thread. I absolutely love using Groovy/Spock for testing, though. I’ve even been tempted to become a QE, so I could code in Spock full time. 
I have used Grails with many very very very large companies (think major insurance companies and the federal reserve bank, as well as other federal agencies) It's very competent and effective. 
If you're using CompileStatic or TypeChecked, Groovy is the most java-like of the jvm languages, being really just syntactic-sugar on top with much nicer built-in support for functional blocks. (as an aside, not sure your company was specifically hiring for Groovy developers, when you can convert any Java developer over in less than a week.) Unfortunately, Groovy as a language just doesn't get very much development anymore, and tons of long-standing bugs, quirks, etc. have not been and might never be addressed. For example, it doesn't even yet have support for Java 8 features like default functions and lambdas, which came out 5 years ago. Kotlin, though much newer, has a lot more momentum behind it, especially after it got picked up by Android. Read through a list of why Kotlin is so much better than Java, and it looks exactly like a feature list for Groovy. However, Kotlin changes up the syntax a lot more than Groovy does. In comparison, you can literally turn any java file into a groovy file by just changing the extension. Now, if you want to use Groovy as a dynamic language, then there are much stronger competitors in the space like ruby, js, and python. Groovy will never be able to fully take advantage of everything a dynamic language can offer since it still wants to keep the option of switching back to types.
This is such a highly variable value as to have any of us give you numbers be meaningless. Where do you live? What industry do you work in? Even in one country (US, at least), the values could be vary by 10x.
Can confirm. Test automator using Groovy.
Use a "cron" trigger in your pipeline and a "when" clause to ONLY run the cleanWs() when triggered by Cron
The problem is, this job will run on a cron trigger every 5 minutes anyway.
You can set the cron schedule to run once per day. 
Perhaps I'm not understanding. Are you suggesting that another Jenkins jobs should be created to facilitate a clean up seperate to this job?
Hey, RedditRo55, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Huh, interesting! I’ll check this out :)
This is really sad. I certainly understand the "threat" feeling communities have, but as the author said, use the right tool for the job. I use groovy for all the reasons I don't use statically typed languages. If I want static, I probably *would* use something like Kotlin or Scala or even straight java. Groovy is my favorite glue language, my favorite language to quickly get something done, my favorite for devops orchestration and scripting - my favorite for testing. Kotlin and other are also great at what they do, and I don't think that diminishes groovy at all. Let each be great at what they're great at and lets make using great tools a good experience. 
Agreed. I use Groovy every day at work and I love it. I assumed there was maturity in the community, but apparently not. I think Gradle has been a big driver in the recent download stats for Groovy, and clearly Kotlin in Gradle is a big threat to that. To me Groovy stands on its own and I love it for it. I don't use Gradle at all. 
To be clear, I use Gradle daily too. I love Gradle, it's the perfect build orchestration tool for JVM tech IMO. And Gradle built its DSL in groovy from the beginning and will continue to support it indefinitely (so they say). I'm doing mostly node stuff these days, but still turn back to the power and ease of lazybones + Gradle + groovy to write an app in no time and have wonderful distributable packages with launcher scripts and everything. The latest Gradle versions do some templating too which might eventually replace lazybones for me, but this is a winning combo!
Yeah. I wish more people understood that. Groovy is my favorite language, but I’m not suggesting we use it for everything. Writing Scala does not spark joy for me, but I’ve been on a Scala team for almost 4 years now. I don’t need to love all of my tools. 
This is a sad day for groovy. A real sad day. People, even with good intentions, can come across as assholes.
I read the mailing list thread. I don't see anyone attacking him or his integrity. https://lists.apache.org/thread.html/d498a86a7f8147fe5dc6d21d015122b3a5befa04f12ccd497b613048@%3Cdev.groovy.apache.org%3E
You can just declare all your classes in the same file. A groovy script doesn't care about class definitions and file naming. Then you can use them however you like below. If you don't want to develop this way, and have good file structure, I would just use something like cat in the command line to aggregate the files at the end for "release". Generally speaking your groovy projects would be compiled down to byte code in a jar for distribution, but if a single groovy "script" is the expected output, that's fine - just glob it all together. 
Trust me, I would compile bytecode if I could. The output must be groovy script 😣 Hand-writing one giant file for each project poses a problem with maintaining and unit testing many copies of what should be common code, keeping classes apart from the script body on a source level is a high priority for that reason. A build script that stitches the files together poses an issue regarding imports and possibly other syntax oddities. This one was actually my first thought as well, but I want to avoid reinventing the wheel if there's a better way. Maybe there's some gradle plugin or compiler extension that already does something similar? 
Yeah I hear ya on all counts. Unfortunately to my knowledge, this is a very specific use-case and I’ve not heard of a plug-in that does exactly this. I would probably end up writing a bash script that handles the import statements and the concat. Good luck!
I've used grape to grab dependencies at runtime for execution. http://docs.groovy-lang.org/latest/html/documentation/grape.html . It's slow, as it has to download the jars at runtime, but if you publish your common code dependencies to a net accessible repo this could work.
This. Create a library, publish it to Nexus or Artifactory, and pull it in via Grape. 
That's not a bad idea! I'll give it a try and see what happens
Cool but I wish they guy have an example of why we’d want to do this- it’s a bit like saying “sometimes you need your tests to return the opposite and all in comic sans” without much context.
Thanks for the valuable comment. You're right - even a small context might help understand better if it's worth bothering. I have updated a post with a few sentences about the rationale behind it. Thanks!
Awesome, thanks! Great write up BTW, thanks for sharing!
By chance are you using LogicMonitor?
Yup, good guess! I assume you're pretty familiar with the workflow I'm trying to nail down then lol. I would love to learn from your experience on the subject. For the record, I'm trying to avoid the standard 3rd party library setup because it doesn't seem to scale well with many collectors if we're constantly updating the common classes (we actually do already use this for snmp4j since the 3.5.11 release is stable as a rock). Grape seems like an interesting trick, but I don't know if the cache files persist in the LM script environment, which could will really be a deal-breaker since these scripts will be invoked every few minutes.
I'm actually a Product Manager at LM, and I was originally on the Monitoring Engineering team building LogicModules, so I am quite familiar with your predicament. We actually did look into enabling the use of Grape within the collector for exactly this sort of thing about a year ago, but it wasn't feasible at the time. I understand it is tedious to distribute JARs to each collector and modify their configs, but it is the best supported way at this time. I'm actually kind of shocked that you've swapped in a newer version of snmp4j, I haven't heard of customers doing that and I'd love to hear more about this. Anyways, I can't promise you that we'll fix this issue this year, but it is on our radar. I can tell you that we're doing a lot to improve the module development workflow this year. If you're amenable, I'd love to get some time on your calendar to hear more about what you're doing with LogicModule development, and how we might make it easier for you. I can show you some of the stuff that's coming out soon too. We love hearing from customers that are pushing the envelope, even if you just want to complain :). I'll DM you my email address in case you want to follow up. 
Haha, you've caught me red handed! I'll definitely be sending you a couple follow up questions.
Thanks! :)
*Eyy, another year! * It's your **7th Cakeday** chaorace! ^(hug)
Guess I'll ask on SO then.
I asked, got a solution, and it was pretty [painless](https://stackoverflow.com/questions/55648167/how-to-print-the-path-for-current-xml-node-in-groovy/55648772)
nice writeup
I’d like to do that too, but now I have a big Grails server so I’m pretty much stuck with groovy.
 Anyone can make a programming language look clumsy if you use it in a non-idiomatic way. # Lambda’s and Streams That big clumsy stream example? Here it is in idiomatic Groovy: def list2 = myList.findAll { it.value &gt; 5}.collect { it.value2} # GString vs String &gt; Weird right? Wrong. GStrings are powerful string templates. It isn't a bug and most of the time they'll auto-cast to "String" when needed. # Type Checking Major eyeroll here. If the author is constantly getting runtime exceptions with typing issues then he isn't testing his code. I'd expect one here in there in development like any other in-dev bugs but in shipped code? That should be pretty rare. Second, typed Groovy (which BTW is the way I write a lot of my Groovy code) is as simple as using types instead of "def". String myString = "This article is ${bullshit.toUpperCase()}!" Notice also that the GString is auto-casted to String. Weird right? So hard! And this dumb example: .setList([] as List&lt;String&gt;) Um, author? You do understand that ".setList(Collections.emptyList())" is 100% valid Groovy code as well? # Immutable @Immutable class SimpleBean { long value1 String value2 = "DEFAULT" static SimpleBean withBuilder(Date d1) { return new SimpleBean(d1.time, d1.toString()) } String toString() { [value1: value1, value2: value2] } } println new SimpleBean(666, "bullshit") // what about mapped constructor? println new SimpleBean([value1: 666, value2: "bullshit"]) println new SimpleBean(value1: 666, value2: "bullshit") // What about default values? println new SimpleBean(value1: 666) // What about custom constructors? println SimpleBean.withBuilder(new Date()) Yeah, so most of the author's comments on Immutable classes are pure bullshit or whining because in idomatic Groovy things are done differently than Java. The above code works. You can also write Immutable classes in Groovy the more verbose way if you needed to control the constructors. class SimpleBean { final long value1 final String value2 SimpleBean(int value1, String value2) { // do some validation // .... this.value1 = value1 this.value2 = value2 } } def bean = new SimpleBean(666, "bullshit") bean.value1 = 777 // throws ReadOnlyPropertyException as expected # Truthiness Oh come on. Every programming language has a concept of truthiness that needs to be learned. I mean I could just as easily say Java's '==' is misleading because it doesn't call the Object.equals() method and, if used incorrectly, could cause runtime errors. The author is reaching now. Apple != Banana so Apple is bad. # Compilation Tooling Oh please. Like this isn't an issue with Java in general. I grant that it is complicated the first time to set up a Maven script but there are examples. Ok, I've spent enough time on this. Look, pick the languages that work best for your team and projects. If you're going to write a breakup letter to a language it better contain some real reasons: * Maybe it is hard to find enough developers who know the language * Maybe the language doesn't perform at load * Maybe the language isn't being actively developed * Maybe the language isn't supported by your team's other tooling
I don't know what the author is smoking wrt streams. Groovy interoperates just fine with them: x = [1,4,2,3,5,1] x.stream().filter { it &gt; 3 }.collect() [4, 5] I do sympathise about some of the implicit behavior causing problems. The worst being (a) access to private fields allowed by default, (b) implicit conversion to strings, especially as return values and (c) incorrect-by-default behavior of GStrings in maps. These things are recipes for insidious bugs that can creep into your applicaiton and if it is large enough they are incredibly hard to track down. However I regularly attempt to switch over to other languages and they all have equivalent or worse problems of their own. Groovy is the best I've found that offers high performance, full dynamic behavior when I want it, and a real robust type system.
\&gt; Now you could argue that 0.00 is equal to 0.000... Ha!
They are on the verge of releasing 4.0, so it is still seeing active development. I continue to use it and even after years of use am still learning and am impressed with the design. But is it popular? I really don’t know. It certainly doesn’t get much press. I get the feeling it is used on internal corporate projects. IMHO, it is starting to collect some technical debt and legacy cruft. Portions of the documentation have fallen out of date. Googling for answers will often give old &amp; out of date results which can be frustrating (but look at Angular and its mass of incompatible releases).
Yeah! It's a fairly smallish community, but in environments where it's enterprise java or nothing, grails is a breath of fresh air and is usually an easy sell. The work they're doing on 4.0 looks great with micronaut and whatnot. It's pretty performant being java based, and the latest dev efforts are making it much lighter with faster boot and lower overhead. If you're working in a java environment, I still think it's the best full stack framework - monoliths are not always bad and you can stand up a CRUD app in amazingly little time and run it with production workloads with no fuss. The micronaut stuff really makes things interesting for micro services and lighter APIs, and the Gradle integration is great. I would still recommend it for anyone working with in a java environment.
yeah at my company it's still in common use.
LOL. Yes, of course it is. There is basically nothing in computing that *isn't* "still a thing". This industry is a weird combination of hyper faddish, but incredibly unwilling to ever drop anything. So you get this effect where fads come and go, but frameworks and tools that hit a certain threshold of popularity basically *never* die. See: COBOL, for example. Not to say that Grails has much in common with COBOL of course. The point is that you can't put much stock in what the "fad of the day is". That really tells you nothing useful.
Thank you all for your opinions. I'm considering using Grails on a cluster of Raspberry Pi nodes...(might run into JVM version issues, though).
Only when writing the code for them. (As far as I can see, someone correct me here please.)
@TypeChecked has no impact on the generated java bytecode. It only adds additional compile-time checks. @CompileStatic WILL change the generated bytecode to be more efficient, by removing runtime function resolution.
Woohoo! Beta 1! It's almost here!
New features in Parrot: https://github.com/danielsun1106/groovy-parser
Hey this is great! Thanks!!
UPDATE: We've released v4.0.0: [https://twitter.com/oas\_generator/status/1128214723260850177](https://twitter.com/oas_generator/status/1128214723260850177) &amp;#x200B; Please check it out and let us know if you've any feedback.
Well the mods can't complain, the sidebar description is "All things Groovy", even if if this wasn't quite what they had in mind :) Bravo Sir/Madam!
Thanks sir/ma’am ✌🏽
Your blog talk was dope man
Haha , wrong sub buddy but this is rad as hell.
Thank you! :-)
I'd say no. Groovy has no real position in the market. If you like dynamic typed languages, Ruby/Python are more pleasant to work with (e.g. better eco system, nicer syntax). If you like static typed languages, Kotlin, Scala, Go, and Java are more consistent and better in design. Currently, I think all dynamic typed languages are on the way out. Static typed + type inference (like Kotlin, Scala) strikes a much better balance between brevity and maintainability.
Yo this song is dope, but this is a sub for the "groovy" programming language. Added this to my playlist though
hahahahaha!!! Dang it,thank you for digging it!
The [Gradle DSL docs](https://docs.gradle.org/current/dsl/index.html) are good. And though it doesn't account for the dynamic stuff, [the Javadocs](https://docs.gradle.org/current/javadoc/index.html?overview-summary.html) are also a good resource.
 throw new RuntimeException('huh?')
/r/lostredditors
Either you're in the wrong subreddit... or I am
 throw new RuntimeException 'huh?' FTFY ;)
It's possible it could be for fucking anything since its poorly moderated.
The former.
I can only see four posts about music and three of those are from the same poster.
The former.
Groovy is just a superset of Java, so if you know Java you can basically write regular Java code in a `.groovy` file and carry on. The groovy docs are there to show you what Groovy can do which is beyond standard Java.
Thanks, I did notice it looks a bit different especially how if statements are written and defining objects. Is there a good book to learn it?
The groovy documentation is actually great. https://groovy-lang.org/documentation.html Read everything under `Language Specification`. Even experienced in Groovy, i constantly go back to it.
If you're a book person, Manning has some good Groovy books. An old book I have that I still refer to frequently is from The Pragmatic Programmers "Groovy Recipes: Greasing the Wheels of Java". But as mentioned, the Groovy online documentation is very good.
Learning Groovy and Groovy In Action appear to be rated well, but I have not looked at either.
[Windows installer](https://blogs.apache.org/groovy/entry/groovy-3-0-0-beta2)