It's available for free on the kx website. [Q for mortals](http://code.kx.com/wiki/JB:QforMortals2/contents)
I never understood this: what makes superstar programmers so immensely valuable to the bottom line? mythical man month constraint?
Referenced scripts: http://www.cs.ualberta.ca/~smillie/Jpage/jcomp.ijs
[www.tryapl.org](http://www.tryapl.org)
Hello, I just wanted to thank you for your awesome contributions to this subreddit. Keep up the good work.
APL2TeX is available from CTAN.
Thank you.
Also of interest, a paper by the same author: [Fractals and Visualization](http://webbox.lafayette.edu/~reiterc/j/misc/j2000_frac_vis_print.pdf).
This is a translation of the [FinnAPL Idiom Library for APL](http://www.reddit.com/r/apljk/comments/p68bz/the_finnapl_idiom_library/) to K apparently, according to quackzone [here](http://www.reddit.com/r/apljk/comments/p68bz/the_finnapl_idiom_library/c3n3c2u).
Is the talk available online?
Thanks for the link to the paper. I quickly skimmed it, interesting idea. I don't like the idea of using a postfix syntax though. With the proliferation of smartphones there seems to be no need for a dedicated calculator. I'm interested to see how J for android develops.
The talk is in Japanese. Here's a [snippet from the talk](https://www.youtube.com/watch?v=mzZx1rmfMPg) [The original article](http://www.atmarkit.co.jp/news/200902/13/matz.html).
Yes, I've noticed but haven't given J for Android a spin yet (mainly because the only Android device I have right now is the emulator), but I've heard of people using the jhs utility that runs in-browser with success on their iPads and iPhones for example, by just visiting the URL that their jhs process is served up on. fftw in #jsoftware mentioned s/he does this. Also see [this video](http://www.youtube.com/watch?v=wXjlDUGDXDw) for beginners by Brian Schott of running jhs and viewing it on your mobile/tablet device.
Thanks - I got the gist with Google translate.
I recommend looking at examples of [generated APL to C code here](http://www.apl2c.de/home/Compiler/compilation.html) for anyone interested.
Phil's SImPL APL TTF fonts can be downloaded [here](http://www.chastney.com/~philip/), near the bottom of the page. Also on that page is another font that Phil made [called Sixpack](http://www.chastney.com/~philip/sixpack/outline.html), a universal font for programmers, using all the six scripts of modern European languages.
[More cool memorabilia](http://www.rexswain.com/stscmem.html) from STSC and the Amdahl 470, courtesy of Rex Swain.
Lyrics can be [found here](http://www.cosy.com/language/APLBlos/APLBLOSS.TXT) on CoSy's site.
But K is proprietary right ? 
[This related page](http://aplwiki.com/r2apl) on interfacing R with APL on the APL Wiki is also of interest.
- I'm learning APL with Soliton's SAX APL for Linux. I've used APLX in the past. - I've experience with Lisp, C, Matlab and Unix Shell. I've erased Java experience from memory. - I've been using it on my dinky little netbook, mostly working at the command prompt. - So far I've just played around really, trying to solve problems I've solved conventionally in the past using the tools APL provides. Results have been very nice. I also notice I've been able to help my wife out with her Matlab code (she is a psycologist). She's surprised when I provide simple solutions that exploit matlab's vectorized functions. It's all thanks to my exposure to APL. - Started about 3 years ago, but I'm not at my computer very often anymore.
Blog post about vfuncs by its creator [here](http://quantblog.wordpress.com/2008/09/24/vfuncs-functional-coding-with-array-verbs-in-c/).
Aha, yes indeed. :)
The framework is available at http://github.com/DannoHung/qspec. The presentation was originally given at the KX user group meeting hosted at Liquidnet on May 28th, 2009.
Hah, that presentation went so badly. Slides were too small and it was projected on a really bad surface. On the plus side, the Youtube video is the definitive version of the presentation :D Feel free to ask if you have any questions or feature requests.
Hey Danno, thanks for the video, I think it's great. I was wondering if you knew of anyone using Q with hooks into continuous integration systems like Jenkins? And if you could comment on how testing in Q vs testing in a more "traditional"-styled scripting language like Ruby compare for example. Thanks again.
Ok, how do I download it?
Interesting. Doesn't work on Mac or Ubuntu (x86_64).
Well, it looks like an OS written all up in K is the goal, even replacing X with something in K. To be honest, I was a shocked when I first came across this recently, for example the WYSIWYG clone of gEdit is supposedly that small blurb of K on kparc.com I'm unable to reach Arthur as he has a very sensitive spam filter it seems, rejecting all emails. Perhaps I need to be signed up for the K listbox to get them accepted.
Hey geocar, I got a email through to Simon Garland at Kx and he replied with this message: &gt;I'm afraid at the moment it's still a research project, and the code isn't publicly available. The eventual aim is to have something shareable - but that's quite a way away yet. &gt;Arthur's recent talk in Toronto at the Jconference contains _some_ more information about it - an update to the mention here: &gt;http://archive.vector.org.uk/art10500700 &gt;Regards, &gt;/Simon
Interesting. I suppose we will have to wait and see!
I've actually got a XUnit-y test output formatter almost done for QSpec that I just need to test with our CI framework before I push a new version tag on GitHub (I'm not super familiar with what's important in terms of XML tags for the various test output parsers, unfortunately, so I'm sort of guessing). I know there's some interest in it since I think I've had one or two people ask me about it, but I no one's out and out said, "Hey, I'm doing this, but with this other tool." I think David A Thomas mentioned that they'd built some sort of integrated development toolset on top of Q though. That might have some CI elements integrated. As for differences, I have to say that the biggest thing is that programming style sincerely affects how tests work. Ruby and other languages like it focus on constructing units largely by delegation (IOC and other "do a little and pass in objects obeying interfaces to do heavy lifting" styles). In Q, that's not nearly as natural, in part due to the lack of object state, but mostly due to the fact that you can have, at most, 7 arguments passed into a function and that partial application creates a small overhead. So in your deepest levels of code, you want to be dealing with as simple a set of Q primitives as possible. You get into a bit of a conundrum though. If I leave stuff in a namespace, it reduce the burden on passing things around, such as in dictionaries (and tracking how things have to fall down into different levels), but it also means that testing anything requires more setup. The easiest functions to test are, as always, purely functional ones, so I try to emphasize building programs in that way whenever possible. This has the added benefit of generally making code units more composable. So, unfortunately, you end up a in a slightly annoying middle ground between being able to do unit testing a la Ruby, Java, et al where delegation and interfaces make it relatively easy to build internal test objects and something like Haskell where you can use a tool like Quickcheck to bludgeon any value errors out of your code and rely on the type system to catch the other set of type construction errors. The only thing you can really do is try to enforce discipline in terms of how the software is created. Also, Q's ridiculous amount of overloading doesn't make anything easy either. If you've got a totally fresh codebase, my advice would be to create higher level interfaces for anything that operates on system IO, both the file writing and network operations. You want all those to be functions so that you can easily mock them out in a uniform fashion. Next would be to ensure that whenever you can, you don't allow access to internal helpers via direct data structures. Wrap as much as you can behind functions and return the simplest output data as possible that meets the needs of the interface. Just doing that as a start will probably save you hours and hours if you ever need to refactor and make testing of anything that builds on top of IO or your helper modules much simpler. For example, we have a bunch of reference data caching code that is all wrapped behind multiple layers of functions. Since uses of these are almost always against larger data sets, we can afford to have a higher level of abstraction since the final access to the internal data structure is going to be a straight table lookup. However, this also lets us simply mock out the top line function with a simple dictionary or something like that making the testing an order of magnitude simpler and divorcing it from having to have any other part of our system running in order to populate those reference data caches.
One of the things I like the most about Q (as compared to J) is its treatment of dictionaries, and this is a prime example.
Anyone able to access to repository? I keep getting errors trying to browse it.
I managed to grab a copy. http://geocar.sdf1.org/darcs_openk.tar.bz2
[I managed to grab a copy](/r/apljk/comments/xkqq1/openk_another_opensource_k_clone/c5rxd8x?context=1).
I'm curious if anyone knows whether this idiom list has any relation to FinnAPL's or the other few extensive APL idiom lists floating around?
According to Phil Last [here](https://groups.google.com/forum/#!msg/comp.lang.apl/BbyYv7kgvEw/YNq7kkDYljwJ): &gt;[...]But APL is not about one-liners. In fact we should provide one-liners only if they come naturally. &gt;The arguably best source for amazing stuff you can do with APL is probably: &gt;http://dfns.dyalog.com/ &gt;This however is not only pure Dyalog APL, all the stuff is written in D (or "direct function/operators), a functional branch in Dyalog APL. It has been written by one of APL's grand masters, John Scholes, who was also behind the most amazing APL-related video I've seen so far: &gt;http://www.youtube.com/watch?v=a9xAKttWgP4
J for Android APKs and source at Github: https://github.com/mdykman/jconsole_for_android/tree/master/dist
I recently came across my own paper copy of this. It was mentioned in the January 1986 issue of *Scientific American*, in Dewdney's "Computer Recreations" column ("How close encounters with star clusters are achieved with a computer telescope"). Chaitin (and IBM) kindly offered to send one to anybody who requested a copy. EDIT: I see by the date on the PDF that it is a slightly later version.
Cool. I'd seen it cited a few times (old apl papers via ACM) but could never find it until now.
This is a good article. I used APL in 80's, and if I had the needs I had then I'd take time to learn J. But my paycheck really does not come from arrays at this point. 
did you used to have arguments about whether APL2, sharp or STSC was best?
Anyone has a copy for someone who doesn't have an ACM subscription?
There really isn't much to it, except for the mention that the source is available and of where it could be found: http://openjdk.java.net/projects/graal/ Thanks! 
I posted about 5 [11 months ago](http://www.reddit.com/r/apljk/comments/oedc6/5_a_stackbased_array_language_with_features_of/) according to Reddit, a piece about 5 in Vector by Ulmann. Dr. Ulmann's [slides here](http://www.vaxman.de/publications/apl_slides.pdf) are always in the top SERPS for general searches about APL for me. [Another variation](http://www.vaxman.de/publications/apl) of them from another earlier talk. [Slides on 5](http://h71000.www7.hp.com/openvms/journal/v15/stack_array.pdf) by Ulmann at HP, and [other slides on 5](http://www.vaxman.de/publications/5_perl.pdf) from a talk in the same year, and the link to [5's SF page](http://lang5.sourceforge.net/tiki-index.php).
OK 
In Dyalog you can say: `{Nums[⍵]}¨A` 
OK, here is mine J solution of 35th euler project problem. As you may see, the idea is to take a big array and to give it a big operations. For usual language it's common to use cycles and counters inside them. $ cat projects/eulerproject/035.ijs NB. How many circular primes are there below one million? isprim =: 3 : '1 = # q: y'"0 circ=: 3 : '". 1 |.^:(i.#z)z=. ": y'"0 echo +/ &gt; */ each isprim each circ each &lt;"(0) p: i.1e5
[comments on hn](https://news.ycombinator.com/item?id=6115727)
nice. Did you make it?
Trying to find out if `kdb` is really all that superior to `redis` in every single way. I thought the comments on `mmap` versus `scanf` were particularly interesting.
This looks like k5 (Arthur mentioned years ago he's working on yet another incarnation/refinement of k) See http://kparc.com/k.txt - that's a new incarnation of k. monadic (unary) % is now square-root rather than reciprocal dyadic (binary) ^ is now "except", rather than "fill" And there appears to exist a new "dict" literal form
The [books section of the J wiki](http://www.jsoftware.com/jwiki/Books) has lots of great material for learning and experimenting with J. I recommend picking a task you want to do and trying it in J. There's a [bunch of useful addons](http://www.jsoftware.com/jwiki/JAL/j701) to do various tasks. For example I use the json addon plus the [gethttp addon](http://www.jsoftware.com/jwiki/Addons/web/gethttp) to retrieve data from web services and analyse them. For example: load 'web/gethttp' load 'convert/json' dec_json gethttp 'http://mmpool.bitparking.com/stats2' ┌───────┬───────┬───────┐ │rate │getwork│stratum│ ├───────┼───────┼───────┤ │4572.11│61.5 │4510.61│ └───────┴───────┴───────┘ 
Thanks, actually this is pretty useful already! But, how can I manage nested json like reddit's json? For example, http://www.reddit.com/r/apljk/.json (easier to visualise [here](http://jsonviewer.stack.hu/#http://www.reddit.com/r/apljk/.json)) I can access the first data item like (&lt; 0 1;(&lt; 1 0)) { a (a is the read json) but this gets incredibly cumbersome to just access the url field of all entries. Suggestions? I have tried reading json.ijs, but for now J code is still pretty much gibberish
You can use the indexing approach but it does get cumbersome. The `json.ijs` file provides a `gethash_json` verb. Here's some tips to give you a start. a =: dec_json gethttp 'http://www.reddit.com/r/apljk/.json' 'kind' gethash_json a ┌───────┐ │Listing│ └───────┘ Note that this is a box. To get the actual data we unbox: &gt; 'kind' gethash_json a Listing Using this we can follow a path to get to the url of the first item: &gt; 'url' gethash_json &gt; 'data' gethash_json 1 { &gt; &gt; 'children' gethash_json &gt; 'data' gethash_json a http://kparc.com/?2 You can create names to make this easier, or use J's methods of combining verbs to create useful utilities. 
Thanks a lot!
Are the submissions available anywhere?
That was disappointing. Was looking forward to at least one problem with solution. Still a good post.
Release announcement http://lists.gnu.org/archive/html/info-gnu/2013-09/msg00014.html
Ah! I waited so long for this moment! Finally there is a free APL!
A+ http://aplusdev.org - hasn't been updated since 2008, but it does work, is 64-bit and quite robust. J is free. So is Kona (K3 implementation). ngn is free http://ngn.github.io/apl/web/ NARS2000 is free. There's been a lot of free (libre) APLs for a while. And even Dyalog is free (gratis) for RasPi.
This is awesome.
J is close enough to APL that if you actually cared about APL, rather than pedantry, you'd have used it; so is A+. Do you know that this APL is good? I haven't had time to try it. (And I don't care that much - A+ was good enough for me before, and I generally prefer K these days)
I actually did try J – it the first APL-like programming language I ever learned (and I do quite like it for that matter). The point I want to make is that none of the actually free implementations you list does implement proper APL and at the same time does work on many platforms.
Does any one here have any references on statically typed versions of APL or compilation of APL like languages? I'm currently looking at this as part of my PhD research, but we are still in the very early stages.
I don't understand, possibly because I don't know K. is this bringing k-like access to C libraries to J? Was there something wrong with the "regular" J access to C? Or does this let J call C to call K or KDB or something like a bridge to call K from J?
Hm... still it doesn't compile on my machine.
What changed? EDIT: Here's what changed. Portability and minor fixes http://svn.savannah.gnu.org/viewvc/trunk/ChangeLog?revision=31&amp;root=apl&amp;view=markup
There is usually a J solution to any of the Euler problems, as well as traditional loopy solutions. Rosettacode also provides examples of both approaches.
I wrote [some elisp](https://github.com/sbisaacson/apl-mode) for interacting with Gnu APL in EMACS. This was part of a quixotic project a month earlier to learn APL, but I had to put in on the shelf for a while. All it really does is let you type APL glyphs easily when you interact with Gnu APL. To try it out, copy 'apl-mode.el' to your load-path and edit 'apl-executable-path'. Backslash is a prefix key, so, e.g., \i, \r, and \- give you ⍳, ⍴, and × respectively (to get a literal backslash, type \ followed by space). To see all the keys, run 'apl-show-extended-keyboard'.
You can find the local help after installing the system (701 for instance) via path similar to: /home/user/j701/addons/docs/help/index.htm
in j7 and j6 (and j8), you can access a local copy from the help menu.
Where is the help menu? I did not find a help menu on my shell.
in windows, its on the far top right of the interactive environment (not jconsole)
Which interactive environment? I don't see one on my system.
Ah! Now I found it. Didn't knew there was an IDE. Thank you for your help.
Videos of the presentations are being added to this page as they become available.
Slides to Yanqing's talk: http://www.dyalog.com/dyalog_13/presentations/U09_How_I_Won_the_Dyalog_Programming_Contest.pptx
Slides: http://www.dyalog.com/dyalog_13/presentations/D00_Robot_Wars.pptx
okay, found http://aplwiki.com/CsvToApl (down: https://web.archive.org/web/20111118171922/http://aplwiki.com/CsvToApl )
I want to start a little closer to the roots. J notation seems pretty obscure: I'd like to confront the original "Iverson notation" as a way to grok more fully J. I started straight with J and it seemed too hard to remember all commands.. Even knowing how many there were...
Yes, forks seem pretty useful, but J seems so far-fetched it makes me numb, whereas APL starts a little gentler. And the math notation looks neat :D
Can be solved also by adding export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 to .zshrc (or your shell RC, whatever it is)
Answering my own question for a second time, gnu-apl offers "auxiliary processors" 110 and 210. AP100 is "BIOS/DOS Interrupt" processor and AP210 is DOS file processor, which allows to open, write and read files. For info on both, see this [largish and old PDF file]. (http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/pc/languages/1502219_APL_Reference_May83.pdf) AP100 in gnu-apl seems to just offer access to bash, i.e. allows for execution of any command
It's 100% like eval in Lisp. Do you use q/k at work? Since they are not that freely available, I guess you may (and I am curious then :))
yes, i've been doing q professionally for more than seven years now. fyi there's a trial version of q nowadays available at http://kx.com/software-download.php
the whole thing takes about 30 seconds in my crude q port, all of which is the iteration itself--the index operation at the end to render it takes &lt;100ms ah, and with a little more work, i have a q version that takes ~4s for b of 600, including both the iteration and the rendering s:{(((x*x)-y*y);2*x*y)} / complex square n:{sqrt(x*x)+y*y} / complex norm r:{ / renderer B:(til 30)*\:0 0 10; raze( enlist string`P3; enlist" "sv string 2#count x; enlist string max B max over x; " "sv'" "sv''string B@/:/:x+1 ) } m:{last 150{x,enlist(last y)+2&lt;n . x+:s . 2#y}[x]/{x,enlist 0}x:-2.1 -1.3+(::;flip)@\:(count x)#enlist x:(2.6%x-1)*til x} -1" *"0=m 51; `:m.ppm 0:r m 600 \\ again, this is based on passing lists of matrices around, rather than matrices of lists--the y argument to the iterator function is, in your terms, basically (real part of m;imaginary part of m;d) interestingly, `(⊂22201 1⍴1)⌷(⍳30)×⊂0 0 10` fails with a timeout at tryapl presumably there is some better way to write this....
Weird, it shouldn't choke on something so simple. I agree that there is probably some better way to write it, but the thing is that in some sense is the natural way to do (matrix with indexes -&gt; indexes vector) Q is clearer than I thought :D I'm trying to get to grips with APL (which, having distinct symbols from ASCII is more readable for my mathematician self) and then dive into J, so Q feels like the next step will
Neat, thanks!
What would you like to see? * [Here](http://i.imgur.com/OxCQ4EI) is what it looks like when it boots up (a few msec) * The [file manager](http://i.imgur.com/anxRlZ2) on my system * One of the [example programs](http://i.imgur.com/VLZlh82), but note the interesting feature that you can [live-inspect windows](http://imgur.com/yqU554N) * A [smalltalk-like print-it function](http://i.imgur.com/jKr6W1c) I added
How do we get the login credentials to download this?
It's by invitation only, at least for now.
I have just added this to gnu-apl-mode. You might have other problems though if your system isn't using UTF-8 by default. Please let me know how it works.
So far, works perfectly ;)
kparc.com seems to be updated to remove the link to kOS pages. Any news?
I don't think there's a video recording of this? That would have been awesome :/
The C loop examples are likely wrong as they consider xsize0+1 elements: for (i = 0; i &lt;= xsize0; ++i)
You can watch a [video here](http://www.youtube.com/watch?v=xoPPfvFr5iI) explaining functionality, and give it a go on the live demo page [here](http://swatouch.hpi.uni-potsdam.de/demo.html).
K is the underlying language, which is an APL derivative. Like J and unlike APL, it only uses ASCII characters. Unlike J, it does use brackets and curly braces in pairs, and is very minimalistic about its list of operators. In previous versions (K2 / K3), the language (K) was distinct from the database (KDB) which was implemented in the language. As of version 4 of the language (K4), the database is implemented inside the language and called "kdb+". "Q" is a thin layer on top of K4 that uses words instead of symbols for verbs and adjectives. e.g.: K) +a Q) flip a K) !=b Q) keys group b It's basically the same language with a different lexer. Your first step would be to download an evaluation copy from the kx site, and read Q for mortals (available in print or the kx wiki). If you are interested in K2/K3, there's an open source implementation in https://github.com/kevinlawler/kona - but that does not include kdb or ksql or q.
Thank's a bunch, I'll start exploring the kx site, reading Q for mortals and download that eval!
This looks a lot like a programming assignment...
If you want a single letter name, your language is more similar to C++ than to K, and you don't mind taking a name that's already taken, call it C.
Thanks but I don't really like that, it makes it hard to write and would cause problems on almost all filesystems.
The problem is that C is the most well-known language that all programmers have heard of and quite a few know about. Original K seems to be somewhat niche and not that popular.
K++
So cool, and perfect for J. Site down atm though.
I'm still not specially familiar with J, but what I like from APL (I know a little more APL than J) is the fact that operations jump very easily at me, being non-ascii characters. My plan though was to start with APL as a mean to jump to J (so I could get used to how APL-like languages work without turning mad with J's function naming)
Sure, looking prettier than J is an advantage of APL, but I was wondering if there anything more substantial when I asked the question.
Aside from that, I think no. Plain "free" APL (i.e. gnu-apl, for instance) does not have (AFAIK!) forks, or any other niceties that J does have. So I'd rather use J, but I prefer APL's clear-cut visual appearance
Some of the commericals APLs, such as [Dyalog APL](http://dyalog.com) have *very* nice development environments. I've become spoiled using it and now cringe at using other development interfaces. I believe Dyalog is free for students. Also, if you're developing in a Windows environment, Dyalog has full functionality with the operating system, DLLs, COM, NET, GUI, etc.
The development environment is a good point, although to be honest it's a little lost on someone like me. I only program as a hobby, and I usually just write functions that compute stuff. I've always been content with a REPL and a text editor. For serious programmers I take it a "development environment" is worth learning...
Try typing the following instead: ⍴(⊂22201 1⍴1)⌷(⍳30)×⊂0 0 10 I.e. prefix the whole expression with rho. The execution will be immediate. The problem isn't the computation, but the interpreter attempting to format the resulting array for display.
I don't know if what specific influence from FP, but definitely APL doesn't have much support for what J calls tacit programming, from what I've heard (I know J fairly well, but APL only superficially).
After watching someone program a [Sudoku solver in APL](https://www.youtube.com/watch?v=DmT80OseAGs), I found one thing I think is nicer in APL: support for what J calls explicit definition! I can't be the only person who feels a little weird that to make a function (whether verb, conjunction or adverb) that refers to it's arguments you need to put the source code in a string and then give that string to the built-in `:`. Plus the left argument to `:` need to be memorized: 3 for monadic verb, 4 for dyadic verb, 1 for conjunction and 2 for adverb (and since I didn't look them up just now I probably got them wrong). In APL it seems instead they have function literals between curly braces. If you only mention omega, you get a monadic verb, if you use alpha and omega you get a dyadic verb, if you also use alphaalpha, you get an adverb (the video never uses omegaomega but I would guess it exists). Why do we have to pick the left argument to : in J? Wouldn't that rule work just as well? Here's a sample implementation of a version of APL's {} in J, of course I still need to use a string but this thing will keep track of which arguments you mention in the string and decide based on that whether you get back a monadic verb, a dyadic verb, an adverb or a conjunction: fn =: 1 : '(2 2 1 1 4 3 3 {~ 1 i.~ (_1 &lt;\ ''vnumxy'') e. ;: m) : m' (Here I've made the decision that a source code string with no mention of arguments gives you a constant unary function.)
Also, I should have asked: have you used J's development environment? And if so, how does it compare to Dyalog's?
APL doesn't have much tacit programming. K has a little. J has a lot. I don't have *much* experience with J, but I do with K and APL, and my impression is that tacit programming is a great idea in theory, but doesn't make much of a difference in practice. K has neither trains nor forks (in the J sense), it has its own "juxtaposition" sort-of-trains, which is much much simpler but captures all the uses I ever found in J (but I might have missed the really nice uses). I don't think being able to write "+/%#" for average rather than "(+/x)%#x" is such a win. 
I am quite enjoying playing around with this and the embedded K interpreter. Works very well with Web Sockets.
found out how: q) k) &lt;k expression&gt;
Or type a single \, or load a .k file, etc.
This is awesome. Any way to generate the special characters form the keyboard?
Not currently, but if I remember correctly the author has suggested that he wants to do that. If you have an idea how it can be done, you can discuss it on the GNU APL mailing list. I was going to paste the URL to it here, but for some reason my phone refuses to let me do that (paste into any other text fields work fine). Just Google for bug-gnu-apl which is the name of the list. 
Thanks! It's a good way, at the very least. :)
It's a very good way. Once you get used to where the keys are it's not "worse" than a normal keyboard. Even though I have written little APL yet, I already know where ← ×÷∩⊂⍴∊ are without even thinking. For somewhat less used commands I need to check the keyboard viewer, but it's not a big deal. Or display the extra keyboard of gnu-apl mode in emacs.
Thanks -- it's working really well. Also, I didn't know about the keyboard viewer, so thanks for mentioning that. It's really helpful. 
something cool is that you just solved your own problem :) 2 'x+y' fn 3 5 
Still at it I see. Time for escalation! 
I would advise you to get married
16 hours later, I've spent 9 of them polishing some stuff (also ate something.) [Newer version](http://i.imgur.com/81jSRnf.gif) It includes some neat inline plotting additions I did in JS. Finally found an use for peity.js, which I wanted to try for quite a bit.
 2 3 4 +/ 50 60 52 62 53 63 54 64 reddit"1 ] 2 3 4 +/~ 50 60 52 53 54 62 63 64 reddit"1 ] 2 3 4 +"1 0 ] 50 60 52 53 54 62 63 64 fixlenx =: 1 : (':'; '((#y) {. x) u y') 2 3 4 + fixlenx 50 60 52 63 2 3 4 + fixlenx~ 50 60 52 63 4 
http://cosy.com/CoSy/Structure.htm A 4th+k based language; basically extends shorter by cyclic replications. Not sure what's happening to it these days.
Tadaaa: [IBM download links](http://www-01.ibm.com/software/awdtools/apl/library.html) :) I checked one or two of these to understand the 100 and 101 AP's
&gt; I don't think being able to write "+/%#" for average rather than "(+/x)%#x" is such a win. forks can get 5 or 7+ verbs long How does k deal with dyadic definitions?
I know they can get long, but I've never met a case that I wanted to do that and it didn't fit into K (at the cost of at most a couple more characters, usually 0). Basically, K juxtaposition is either all monadic, or all monadic applied to one dyadic. So, e.g. "+/*" is dot product equivalent to "+/x*y" (+/ monadic, multiplication dyadic), and "-!:" is negative range (minus applied to monadic iota).
IS it similar to IBM APL/2? How much so? Is there something that describes the differences? This would be very helpful if it provided a way to learn ALP using the IBM docs. Wait, what am I saying? -- you have to be a Martian to learn anything from IBM docs....
Thanks :)
I found these IBM APL2 language docs which have been very helpful http://www.catpad.net/michael/apl/ibmapl2/. GNU APL follows ISO standard 13751. But I can't find a working link to that standard without spending money - http://www.gnu.org/software/apl/apl.html#Top. The link in the APL documentation downloads a broken PDF. From Wikipedia [APL (programming language)](http://en.wikipedia.org/wiki/APL_%28programming_language%29) &gt; GNU APL is a free implementation of ISO Standard 13751 and hence similar to APL2. It runs on GNU/Linux and on Windows using Cygwin. It uses Unicode internally. GNU APL was written by Jürgen Sauermann. Haha... yeah, though the IBM docs are slightly useful if a little weird. All these dialects are very confusing. Being a web developer I am used to having a pretty standard set of documentation and one dialect... Ah well.
No problem, always great to see a fellow APL-er (here J is more frequent)
Ok, yeah. My grandfather used to be a systems engineer at IBM way back in the 60s and 70s. He has been looking for a version of APL to play with on Linux for a long time (He used to run an old Windows 3.11 system). That is the main reason why I have gotten interested. I also found an introduction to APL2 which is very useful http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/apl/SH20-9229-1_An_Introduction_to_APL_2_Dec85.pdf
Thanks! Well, I'm just 31 and got interested out of an interest for weird languages. And I actually find it quite pleasing already, it has a weird elegance at that. And I like the weird characters (I'd love a J with APL characters!)
http://stackoverflow.com/questions/15752895/conditional-function-in-apl
Does anyone know what's changed in this release?
mostly peripheral stuff. core is the same.
This looks really cool, where can i get more info?
Hi there, thanks :D So far it's still "private" inside my computer. And I'm working on what would be a follow-up project already (extending the ideas behind what is shown here so it's easy to extend, improve and use) so much more complete and interesting whenever I have time. I expect to have a working prototype during August (I have rewritten everything from scratch and I'm back at having a REPL for testing, so speed will pick up now), and by the end of the month/middle of September have something useful enough to release to the wild as open source. I'll post here, for sure, since the basic goal I had was using better Gnu APL
if you're willing to do this in k4/q, i can give you a hand, i know essentially nothing about k3/kona note that recent q now includes json i/o e.g. given your sample data, here's how to turn it into a table note that i changed `enabled` from a string to a boolean, which makes it parse into a boolean inside q note also that `key` is a reserved word in q, so i rename that column `Key` inside q $ cat data.json [ { "key": "d1", "enabled": true, "values": [[1,2],[2,112],[3,121],[4,183283],[5,94949]] }, { "key": "d2", "enabled": true, "values":[[1,46],[2,192],[3,41],[4,183],[5,149]] } ] $ q31 KDB+ 3.1 2014.07.01 Copyright (C) 1993-2014 Kx Systems q)ungroup update`$Key from`Key xcol .j.k raze read0`:data.json Key enabled values -------------------- d1 1 1 2 d1 1 2 112 d1 1 3 121 d1 1 4 183283 d1 1 5 94949 d2 1 1 46 d2 1 2 192 d2 1 3 41 d2 1 4 183 d2 1 5 149 q)
k4/q has the same requirement i think mostly it's for semantic clarity and correctness -- with most of the kinds of data used in these languages, it's completely reasonable to expect all arrays to have the same length. e.g. what would it mean if you were working with stock market data and had times for a million trades but only prices for 900,000 of them? note that it's perfectly fine generally for structures to differ in dimensionality, as long as they're conformant on the appropriate axis e.g. * vector plus atom `2 3 4 + 1` is `3 4 5` * vector plus matrix `2 3 4+(1 2;3 4;5 6)` is `(3 4;6 7;9 10)` edit: i can't seem to get a table to show up here, either in ascii or fancy unicode box-drawing. oh well.
&gt; Oh, and can anybody explain the file i/o? I just don't get it. I try to safe the current environment `1:` works on bytes. If want to save a printable representation, you do: "env"0:5:.`dataset &gt; how can I evaluate strings that i just read? dataset:(2:"env")`k`dataset &gt; Ok, to give a bit background what i try to do… You might have more fun if you try to come up with it yourself. Here's something to ponder: (!*data)!+{x[!x]}'data *What exactly* are you trying to do at this point?
1. The difference is wether you get a table as the output or not, see http://code.kx.com/wiki/JB:QforMortals2/queries_q_sql#The_exec_Template 2. I was too lazy to build the prime factorization in q, but maybe you'll find the rest of my solution interesting: (*/){"i"$x xexp max count each where each x=pf} each distinct raze pf where pf is a list lists of prime factors for all numbers up to 20: pf: (enlist 1; enlist 2; enlist 3; (2;2); enlist 5; (2;3); enlist 7; (2;2;2); (3;3); (2;5); enlist 11; (2;2;3); enlist 13; (2;7); (3;5); (2;2;2;2); enlist 17; (2;3;3); enlist 19; (2;2;5)) 
Credit should also go to http://github.com/ngn for the initial work on adding APL. This is now also in use on http://tryapl.org. Currently the result is also highlighted which is a bit odd, hopefully this will be fixed soon! I'm open to feedback and would love to hear if you use it anywhere.
"Array of tables" isn't a healthy way to think about data. Look at this: d:+{x[!x]}'t Now your result is simply: (d 0 0;+/d 1) Back at your SQL, if I wrote: SELECT time, d1+d2 FROM a I would simply write: (a`time; +/a@`d1`d2) and I would try to arrange my data so that I could do that.
Also: `{x[!x]}'t` is illustrative; you should prefer `t@'!:'t`
symlist:get`:sym; then symlist?enumerated_list will give you the ints. ... edit, i didn't really read your question fully at first, to add a column with the enumeration it will be easier to just do this update having loaded in the spalyed table: update enum:sym?enumerated_column from t There's no reason to be writing a custom .Q.en
I believe you can do this by casting the symlist with the enum name as the left hand argument $ I am not at an interpreter right now to double heck this though.
I recorded this a few months ago. It could use a little more video editing, but overall, I'm happy with it. It's basically an beginner lesson in J, using a famous conjecture about prime numbers as the problem domain. 
Sounds intriguing. However, at the moment, even my knowledge of Scheme is very limited so I'm not sure whether I'm at a point where beginning J would be wise of me.
Comments/suggestions welcome. * It will be available in some kind of open source license when I'm happy with the functionality and code, I don't think it will be before the end of the year due to time constraints (lack of free time.) * It's a javascript frontend (handling most of the stuff, actually) and a go server backend talking to GNU APL. The backend could be whatever able to answer with AJAX (and a backend is not even mandatory, you could use ngn-APL or asm.js→GNU APL directly in the javascript layer.) * Next step is adding goodies to the backend, like reading CSV files/downloading JSON data/accessing Google Analytics accounts. For instance. The end goal is having something that "works seamlessly" (or as much as possible) saving me the hassle of moving data from one language/program to another, or having to think how to create that easy, default plot for the basic datatype I'm using. Let the computer do the work! I just want to see the trend, usually. If I need to do something fancy, I'll do it, but get the basics out of the way.
Totally possible, actually as part of the "testing" of the REPL language (those ƒ commands) there's also ? ƒ concept which calls DuckDuckGo's ZeroClick API, and img ƒ URL to display an image (both accept conditional arguments to choose what to display for DDG, and the image size for the image.) I'll probably link to some reference/search directly SO or reddit, or whatever. Part of the advantage of having a proper backend which can load webpages/json and parse them
Oh, I didn't know gnu APL had help for symbols, I need to look it up! As for tutorials, this may be harder, since I'm not a seasoned APL programmer at all: this project is kind of a prequel to actually using APL daily
I haven't seen any active IRCs for any APL, except for maybe APL's IRC itself. Gosh, all I want to do is talk about J, is that so hard, haha. Maybe the APL IRC would be cool with it, but I haven't looked.
there is J mailing list (chat or programming) that may be suitable. I think there is an IRC as well but don't know it. http://www.jsoftware.com/forums.htm
There is an IRC, but the one time I went on to ask a question there were 7 people there and all AFK.
On Freenode there is #jsoftware. Most people are talking about J, but some (like myself) are there for APL.
&gt; [#jsoftware](http://webchat.freenode.net/?channels=jsoftware) This is in the sidebar as well.
My excitement upon seeing this post is amplified by the fact that this tool was developed by my Computer Science teacher. For anyone hesitant to attempt learning such an "unapproachable" language as J, I assure you that this tool will take you leaps and bounds ahead of whatever level you expected to arrive at!
Obviously not as nice as APL/J/K but interesting; approachable by people who wouldn't be (but should be) interested in APL/J/K.
I liked that they made all of the same decisions that J did.
Could you be more specific for those of us who don't know J well enough to have picked up on that.
The 2 things that jumped out at me where rank (applying to subsets of array), and the default axis for sum/product was columnwise. Also, the what the speaker described as the core 4 functions corresponds to J's internal data representation.
The mic stand broke and I've only got two hands. Sorry about that. The hd version of the video looks pretty clear to me. Is there one that was particularly bad? Anyway, I can upload screenshots of the presentation: http://geocar.sdf1.org/howto-slides.pdf Sorry I didn't take screenshots of the live-coding segment.
&gt; heck this though. harsh
[J803 Release Notes](http://www.jsoftware.com/jwiki/System/ReleaseNotes/J803)
Nice. I wrote a [dictionary type for J](https://github.com/tangentstorm/syndir/blob/master/dict.ijs) too a while back. I've had the thought a few times recently that J could really benefit from a collections/data structure library. Even if we can use arrays to make any structure we want, sometimes it would be nice if we didn't have to. :) 
Brooke T Allen [commented](https://news.ycombinator.com/item?id=8860066) on the HN thread for this story.
Who is the teacher? Do most students have exposure to other languages? Is it a math or a computer class?
The teacher is Henry Rich. We all view him as our God of J, because, well, he is (some of the stuff he does is incredible). This is the first language I am learning, and the same is for nearly all participants of the class. It is certainly a programming class (in that there is little theory and lots of projects) but the focus is on how to think like a programmer rather than how to be really good at J. Unfortunately, many people in the class are seniors taking it for a slack class, so they don't learn or accomplish much. 
Henry Rich has done some amazing things with J, Are you maybe too hard on your fellow students? I've found that in any math or computer class even at the college level, there is probably less than 25% who understand "anything" Is this most students' first programming class? Did the class start in January, and you are already doing mandlebroot "graphics"? Are the students who "don't understand anything" angry that they don't and blame J for it?
Lathwell [taught Mandelbrot](http://lathwellproductions.ca/wordpress/2010/05/07/my-father-never-told-me/) APL who used it to develop fractals. He was active in the APL community and [attended](http://www.stanleyjordan.com/en-us/specialprojects) conferences. Mandelbrot worked at IBM's lab along with Iverson and others including Backus and Brooks as he [mentions](http://lathwellproductions.ca/wordpress/2010/07/12/the-jedi-unite-brilliant-misfits/) in his book. 
Yes! We are a small charter school in North Carolina, so it's free, but the teachers still get to do what they want (or the ones teaching electives do). We are usually ranked in the top 50 high schools in the US. 
When I started J, I did find reading other (pro) code hard, but for mean (+/ % #), these variations did not seem difficult: (+/ data) % # data or 3: '(+/ y) % # y' &gt; when they do figure something out, be it by someone else telling them/give them hints (which is how I learn most of the stuff) or by copying someone else's code, they are usually overjoyed and celebration commences. I still get to know that feeling.
What do you think you've gotten out of the course, personally?
A "slack" class - rofl
Exactly. Kids who normally get all As and Bs get a C on a J midterm and are excited they didn't fail :)
Could anyone clarify what this means - "It is the language of the future for the programming techniques of the past"
Dijkstra was a firm advocate for structured programming, but APL (at least at the time) offered no structured control flow other than named subroutines and the right-pointing arrow (goto). I have no way to know if that's what he actually meant, obviously, but I suspect that was at least part of it.
Well, he isn't quite wrong. Good thing its successors introduced better control structures.
That hypothesis makes sense to me. On the other hand, [Lamport](http://research.microsoft.com/en-us/um/people/lamport/pubs/state-machine.pdf) has argued that for formal methods, it helps —even for sequential code— to make control an explicit part of program state, and what I've found most worthwhile in messing about with APL and J has been learning just how much of what would be expressed as control in scalar languages can be carried by data and its shape in array languages. (note also the difference between Iverson62 and Iverson79: the former uses the flowcharty-goto-laden presentation of its day, while the latter uses mccarthy-reminiscent recursive functions of symbolic expressions) 
its the same engine source code as J7. New stuff is ide and qt integration. Though source has been announced as available, search the mailing list for where.
There already is, but it's low profile - look into an investment bank or trading firm. 
I think the answer is to build more tools for accessibility. Take the IPython Notebook for example; imagine if there was something like that for APL/J/K.
Hrm. But there are a *lot* of investment banks and trading firms. I guess I could compile a list by reading through forum archives. But I guess I'm thinking of something that would encourage companies who aren't using array languages now to try them out - perhaps for very small specialized tasks or prototypes. My own perception is that there's basically nobody looking for APL/J/K developers, but I also suspect that one reason for that is that companies don't know that any developers exist. :) 
You mean as a way to get more people interested in using these languages? I agree 100% that we should have something like this, and that it would bring in more people. I guess I was asking specifically about how to get companies and developers who are already using array languages talking to each other... Or at least find each other. 
Look at `jhs`; it's pretty neat.
Only expressions in comments, but not in self posts will be evalutated. Here is a example: k) 1+1 more: k) 1 2 3+4 5 6 I hope it works.
&gt; 1+1 &gt; 2 &gt; 1 2 3+4 5 6 &gt; 5 7 9 
k) t+/:\:t:!10000
reddit stripping the \\ k) t+/:\\:t:!10000
k) ,/3#,d,|:d:{x,1}\\[3;1]
&gt; ,/3#,d,|:d:{x,1}\[3;1] &gt; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
no linebreaks :(
That's how Kona behaves. Does Kx K behave differently?
Thank you. I didn't know you use reddit.
I'm not 100% sure this is useful in that you can post the answer yourself rather than hope that your k expression is valid and intended. A markdown trick I use for J is this function reddit =: (' ' , ":)"1@:": reddit &lt;"0 i. 3 4 ┌─┬─┬──┬──┐ │0│1│2 │3 │ ├─┼─┼──┼──┤ │4│5│6 │7 │ ├─┼─┼──┼──┤ │8│9│10│11│ └─┴─┴──┴──┘ 
&gt;"_X"@{2=+/(0,x,0)@(!#x)+/:!3}\0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0 &gt; ("_XXX_XX_X_X_X_X__X__" "_X_XXXXX_X_X_X______" "__XX___XX_X_X_______" "__XX___XXX_X________" "__XX___X_XX_________" "__XX____XXX_________" "__XX____X_X_________" "__XX_____X__________" "__XX________________") 
Don't know about APL or J, but if you're good with K, it is likely that Kx partners like FirstDerivatives (not Kx themselves) would be happy to employ you, as well as Kx customers. The "personal-kdb" newsgroup on google sometimes has "looking for K programmers" posts in it. Don't try to create demand - these languages have a reputation for being "write only", and -- practically speaking -- rightly so. You can't have only one K/J/APLer working in a company, because when they leave, all their work needs to be redone in another language.
The underbar does not get escaped aswell. k) ",X"@{2=+/(0,x,0)@(!#x)+/:!3}\0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0
Oh no... k)"_X"@{2=+/(0,x,0)@(!#x)+/:!3}\0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0 
k) _getenv"HOME"
&gt; \_getenv"HOME" &gt; "/home/konabot" 
k)0:"/etc/passwd"
&gt;!:'("/home/konabot";"/";"..";,".") &gt; 
&gt; !".." &gt; 
&gt; !"." &gt; 
k)/ can't help but try
Well, I'm working on something on my (spare) spare time. I submitted a video a few months ago: http://www.reddit.com/r/apljk/comments/2jvynv/my_wip_browserbased_apl_and_not_restricted_to_it/
Probably. But a loop is slow because it carries more interpreter overhead.
I don't know that I necessarily believe that. Even if it's true, linear + overhead is still better than quadratic time, and if it's not, then your data is probably so small that it doesn't really matter. :)
`f\ x` only runs in linear time when the interpreter recognizes `f` with special code. In general, `f\ x` can't operate in linear time as there isn't enough shared state. For instance, `f\ 1 2 3 4 5` results in 1 , (1 f 2) , (1 f 2 f 3) , (1 f 2 f 3 f 4) , (1 f 2 f 3 f 4 f 5) There isn't anything that makes this possible in linear time in general. Now, J's `u\. y` is a suffix scan, that is, it operates on suffixes instead of prefixes. If we apply a reducing verb, we get shareable subexpressions; `f/\. 1 2 3 4 5` yields: (1 f 2 f 3 f 4 f 5) , (2 f 3 f 4 f 5) , (3 f 4 f 5) , (4 f 5) , 5 This is just `f/ 1 2 3 4 5` with all intermediate results and can trivially be computed in linear time.
This is weird because usually precedence rules are exactly the other way round in APL-descendants. I mean, `+/ 1 2 3 4` is like `1 + 2 + 3 + 4` and that with parens added is just `1 + (2 + (3 + 4))`, so it's natural that reduction operates in the same fashion.
Good thing you can get a very similar effect with J's `u/\.`
There is significant demand for *q* programmers on Wall Street (and its international equivalents--London "City", etc.). There is very little demand for k *per se*--the only company I'm aware of that actively uses k (well, and publicizes the fact) is [1010data](https://www.1010data.com/), and they use *k2*. If you don't live in/aren't willing to move to a major finance city, your prospects are much more limited, at least for now. Kx is working on expanding q's market out beyond finance, and they've made some headway into the utility space, as well as scientific research, but it's still a pretty small share of the userbase.
The semantics of `⌽u⍨\⌽y` are different if `u` is not associative, which it isn't in my use-case. See [here](http://www.reddit.com/r/apljk/comments/2wuzc0/how_to_emulate_the_effect_of_u_in_apl/couwtvj) for more details. Also, APL's `\` generally takes quadratic time unless the thing you scan with is recognized by APL. I think some interpreters have `⍢` for *under,* but I'm not sure. Dyalog at least doesn't have this.
In my current use case, `f` is `⊣⌈+` for Kadane's algorithm. I'm not sure if this qualifies as trivially non-associative, but I think it isn't. If `⍂` was an operator such that `f⍂` behaves like J's `f/\.`, Kadane's algorithm could be expressed as `{⌈/(⊣⌈+)⍂⍵}` for non-empty subarrays or `{0⌈⌈/(⊣⌈+)⍂⍵}` for possibly empty subarrays. In this particular case, it's probably possible to combine the maximum reduction with the scan into a single reduction under loss of elegance. I'm interested in a general solution, too. Of couse, APL understands some `f` for which `f\⍵` can be computed in linear time, but even if `f` is associative, I don't see any way to tell APL that this is the case if `f` is not one of the recognized functions. &gt; I wonder if alternating sums were part of the motivation for J's `insert` to cyclically apply verbs from a gerund? I think this is just a natural extension of `insert` where the left argument is a noun. Alternating sums probably had a large part in this.
How about `¯1↑⊃{⌈\⍵+0,⍺,0}/(0 0 0),⍨` instead? It still has a `⌈\`, but only over 3 element intermediate states, not over the full ⍵.
This is a cool idea. If `⍴⍵` is constant, the runtime of `f\⍵` does not add more complexity. Neat!
Here's a playlist I watched recently which walks through creating a text-based connect four game with an AI opponent using Dyalog APL: https://www.youtube.com/playlist?list=PLcKN5S1vKBMdSrshRkpF4E_1DZGDplZtb As books go, "Mastering Dyalog APL" is available as a free PDF and seems to be fairly well regarded: http://www.dyalog.com/mastering-dyalog-apl.htm
k will return: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ..
Thanks for the reply! Do you mind me asking a quick question? I'm generating random license plates in a matrix that is N rows (3-5) and 7 columns. I got the generating a random license plate down. Here's my code so far. [0]practice ;DECK [1]DECK&lt;-CHARS /*"CHARS" was a predefined global variable in a different function*/ [2]DECK[?7?36] How can I have it so that upon calling "practice" a user can decide how many license plates he can make (rows). I was thinking about making an argument called "NUM" on line 0 and then somehow generating something like "NUM 7p" but i have had no luck so far.
Googling APL is hard because Google likes to filter APL characters from the search string.
Cross-posted on HN as well: https://news.ycombinator.com/item?id=9153805
Excellent. Next time someone on HN says they cannot understand a particular k expression, we can point them to this. Literally step by step execution.
For fun, here's a transcript of executing a single iteration of the Game of Life program on the Kona wiki: http://pastebin.com/raw.php?i=eDXTBH08 The program itself runs reasonably quickly in oK, but a trace generates so much output I'm afraid I'll melt my browser.
is there new kOS info?
&gt;k4 used underscore-prefix identifiers like _sin k3 you mean? k4 already has sin/cos/tan etc
Reminds me of this: https://vimeo.com/107069470 and this: http://nsl.com/papers/spreadsheet.htm 
k4 is in kdb3. k3 used `_sin` k5 uses `sin`, `cos`, etc. `_ci` and `_ic` are done with cast e.g. `c$42 gives `*` and `i$"*" gives `42`
Ah, that makes sense. Which symbols are valid left arguments to cast- \`i \`f \`c for int float char? edit: [implemented](http://johnearnest.github.io/ok/index.html?run=%20%7B%600%3Ax%3B.x%7D%40*%7C0%3A%22https%3A%2F%2Fgist.githubusercontent.com%2FJohnEarnest%2F625755bd86b94b99dda0%2Fraw%2F%22) the functionality of "cast" you described, as I understand it.
Thanks for the links, I had not seen them! The S- spreadsheet (http://nsl.com/k/s/s_minus.k) is the better version of what I was trying to build, as it uses native UI rather than a remote client in HTML/JS/CSS. The main thing is that it provides uninhibited access to k, unlike the S and S+ spreadsheet examples.
&gt; Q&amp;emsp;How do conventional C programmers react to this? &gt; A&amp;emsp;With horror!
That is quite close to the reaction after my team mates watched my talk.
Can anyone comment on the changes between the current version of Q and this new iteration? I'm not knowledgable enough to spot the changes (though the K changes are pretty interesting)..
This is cool! How did they gather these links? Are they curating submissions?
Screenshots: [basic functionality](http://i.imgur.com/EK0SuSw.png) [verb inspection](http://i.imgur.com/WBIoeaw.png?1) This is mostly a proof-of-concept, used by taking [this sample wrapper](https://ipython.org/ipython-doc/dev/development/wrapperkernels.html#example), adding pexpect to interface with jconsole and figuring out how to get it working (as ipython's documentation isn't very good). It also breaks if output ever starts with three spaces, as that's the way I'm currently detecting jconsole prompts. And no support for inline plotting (it shouldn't be impossible though). I don't know how much I will be working on this, I was mostly curious if that's even possible :D For people who don't know what IPython Notebook is: with it you can do great looking code presentations, which you can execute, easily modify and then put up on the web. A great Python example: http://nbviewer.ipython.org/url/norvig.com/ipython/TSPv3.ipynb **Edit**: did a big update, improved usability quite a bit, got `viewmat` and `viewrgb` to work (plot will have to wait). Currently the silliest issue to solve is that the text editor be default autocompletes `{}` brackets, which we don't want here at all, and the issue with output not appearing if the calculations were too long (that can be easily walked around by saving result to a name and outputting the value in a separate cell) Here is a simple sample notebook I made with it: http://nbviewer.ipython.org/github/adrian17/jkernel/blob/master/sample_edge_detect.ipynb
Looks great, I'm certainly going to check this out when I get home! 
Didn't see a mention of it anywhere on the subreddit, I think it's worth a mention! 
Arthur Witney also developed K, which looks like a younger (more attractive) cousin, and has an open kona version. I don't know enough to say that A+ is uninteresting, but I also don't know why it might be.
I don't think a hobbyist who wants to learn an array programming language would go for A+, unless perhaps, he really liked APL's special characters and thought dropping them was a mistake. I still felt like it was missing from the subreddit, it's the one array programming language I have learnt because I occasionally need it and it's very much alive and necessary. But you're right, it is not that interesting to the outside world.
Hi, stop by the #jsoftware channel on Freenode IRC (there's a link in the sidebar) to get help compiling.
I like my languages to check as much validity as possible before the code is run. J can't do that, but I gather that is the intent here. 
Unicode already contains the whole APL character set. This should show up in your browser without any problems. Additionally, there are less than 128 (unless you have a *really* weird APL) extra APL characters. One-byte APL encodings have existed for decades, even ASCII-based ones, like [this one](http://www-03.ibm.com/systems/resources/systems_i_software_globalization_pdf_cp00907z.pdf).
I can see them. Plain Firefox.
I can see them. Plain Adroid
iKe is still early in development, and there's quite a bit of low-hanging fruit for speeding up rendering. So far I'm very pleased with how effective K can be for writing interactive programs when it is provided with appropriate IO systems. Here's another example program: http://johnearnest.github.io/ok/ike/ike.html?gist=5da123592d2e85293903
어벤져스 에이지 오브 울트론 토렌.트 torrent 720p 어벤져스 에이지 오브 울트론 토렌.트 다시보기 어벤져스 에이지 오브 울트론 토렌.트 file 1080p MKV 다시보기 어벤져스 에이지 오브 울트론 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 어벤져스 에이지 오브 울트론 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 어벤져스 에이지 오브 울트론 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 어벤져스 에이지 오브 울트론 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 어벤져스 에이지 오브 울트론 토렌.트 torrent 토렌 torrent
1박2일 150823 토렌.트 torrent 720p Full 1박2일 150823 토렌.트 다시보기 150823 1080p MKV 다시보기 1박2일 150823 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 1박2일 150823 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 1박2일 150823 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 1박2일 150823 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 1박2일 150823 토렌.트 torrent 토렌 torrent
1박2일 150823 토렌.트 torrent 720p Full 1박2일 150823 토렌.트 다시보기 150823 1080p MKV 다시보기 1박2일 150823 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 1박2일 150823 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 1박2일 150823 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 1박2일 150823 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 1박2일 150823 토렌.트 torrent 토렌 torrent
기술자들 토렌.트' 기술자들 토렌.트' 기술자들 토렌.트' torrent 다시보기 기술자들 토렌.트 file 1080p MKV 다시보기 기술자들 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 기술자들 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 기술자들 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 기술자들 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 기술자들 토렌.트 torrent 토렌 torrent
차이나타운 토렌.트 torrent 720p 차이나타운 토렌.트 다시보기 차이나타운 토렌.트 file 1080p MKV 다시보기 차이나타운 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 차이나타운 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 차이나타운 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 차이나타운 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 차이나타운 토렌.트 torrent 토렌 torrent
막돼먹은 영애씨 시즌14 5화 토렌.트 torrent 720p Full 막돼먹은 영애씨 시즌14 5화 토렌.트 다시보기 150824 1080p MKV 다시보기 막돼먹은 영애씨 시즌14 5화 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 막돼먹은 영애씨 시즌14 5화 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 막돼먹은 영애씨 시즌14 5화 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 막돼먹은 영애씨 시즌14 5화 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 막돼먹은 영애씨 시즌14 5화 토렌.트 torrent 토렌 torrent
미세스캅 8화 토렌.트 torrent 720p Full 미세스캅 8화 토렌.트 다시보기 150825 1080p MKV 다시보기 미세스캅 8화 토렌.트 torrent 토렌 Torrent Comprehensive 720p HD Coverage aggregated from sources all torrent 파일 (Torrent) : 파일 받기 : [다시보기 미세스캅 8화 토렌.트 Torrent](http://reddit.com) torrent크기 다시보기 미세스캅 8화 토렌.트 torrent 토렌 Torrent DVD 1080p 720p HD Full HD DVD 1080p MKV 다시보기 미세스캅 8화 토렌.트 torrent 토렌 토렌 Torrent Comprehensive 720p HD 다시보기 미세스캅 8화 토렌.트 torrent 토렌 torrent
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
Somehow it never occurred to me that Ulam's Spiral could be written that simply. Great video! (|.@|: ,~ &gt;./@, + 1 + i.@#)^:4 ,. 1 &gt; The problem is, I need to pass the number to this power conjunction, rather than to a verb, and there may be a way to that tacitly in J, but I don't know how. It can be done, though it's a little weird in this case. I recommend [the NuVoc page on `^:`](http://www.jsoftware.com/jwiki/Vocabulary/hatco), specifically the `u^:v` case. The cases reduce like `x u^:v y ==&gt; x u^:(x v y) y ==&gt; x&amp;u^:(x v y) y`. Since we're repeat the verb on `,.1`, that's `y`, so only `x` is left to get the number of iterations, giving `[` for `v`. Now we need to modify `u` to ignore `x`, which we can do by composing `@]`. Finally, we bind `,.1` as `y` to get a tacit monad (spacing optional): (|.@|: ,~ &gt;./@, + 1 + i.@#) @] ^:[ &amp;(,.1) By the way, you can make this a little more efficient by observing that at each step, `1+&gt;./@,` is `1+*/@$` (or if you start at `0`, just `*/@$`, the number of elements), and computing that rather than the maximum.
I thought about going back and changing the video after someone on IRC explained how `u^:v` worked, but I figured it would just make the video even longer. I think I'll link to the NuVoc page in a little annotation, though. Thanks! I also learned about: [At Play With J: Volutes](http://www.jsoftware.com/papers/play132.htm), which covers a bunch of different ways to make this sort of array.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
Nice video, seems like it'd serve as a good introduction to APL.
Sorry for being late here, but this is still only checked dynamically right?
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
Thanks, I'll probably use J602 too. I did notice that there were labs in j8 which used other graphics addons. Also, how did you find the book? Were you using J before going through it?
Nice catch. It's probably a lot easier to write a Prolog interpreter in PHP from scratch (although it's beyond me why one would need this anyway) than try to translate the J one either way, given the paradigm mismatch between them.
&gt; It's probably a lot easier to write a Prolog interpreter in PHP from scratch (although it's beyond me why one would need this anyway) than try to translate the J one either way Yep!
thanks for sharing, can PHP represent this tree-like data structure? I'd be interested in developing the J code more, if your PHP program could call J for inferences. ,. parse prolog_code ┌────────────────────────────────────────────────────────────────┐ │┌───────────┐ │ ││┌────┬────┐│ │ │││male│jeff││ │ ││└────┴────┘│ │ │└───────────┘ │ ├────────────────────────────────────────────────────────────────┤ │┌───────────┐ │ ││┌────┬────┐│ │ │││male│fred││ │ ││└────┴────┘│ │ │└───────────┘ │ ├────────────────────────────────────────────────────────────────┤ │┌─────────────┐ │ ││┌──────┬────┐│ │ │││female│mary││ │ ││└──────┴────┘│ │ │└─────────────┘ │ ├────────────────────────────────────────────────────────────────┤ │┌─────────────────────────┐ │ ││┌───────┬────┬─────┬────┐│ │ │││parents│jeff│vince│jane││ │ ││└───────┴────┴─────┴────┘│ │ │└─────────────────────────┘ │ ├────────────────────────────────────────────────────────────────┤ │┌─────────────────────────┐ │ ││┌───────┬────┬─────┬────┐│ │ │││parents│mary│vince│jane││ │ ││└───────┴────┴─────┴────┘│ │ │└─────────────────────────┘ │ ├────────────────────────────────────────────────────────────────┤ │┌───────────────┬──────────────────────────────────────────────┐│ ││┌─────────┬─┬─┐│┌────────────────────────────────────────────┐││ │││sister_of│X│Y│││┌──────────┬───────────────┬───────────────┐│││ ││└─────────┴─┴─┘│││┌──────┬─┐│┌───────┬─┬─┬─┐│┌───────┬─┬─┬─┐││││ ││ ││││female│X│││parents│X│F│M│││parents│Y│F│M│││││ ││ │││└──────┴─┘│└───────┴─┴─┴─┘│└───────┴─┴─┴─┘││││ ││ ││└──────────┴───────────────┴───────────────┘│││ ││ │└────────────────────────────────────────────┘││ │└───────────────┴──────────────────────────────────────────────┘│ └────────────────────────────────────────────────────────────────┘ 
 (╯ಠ_ಠ）╯︵ ┻━┻
This is your second post where you ask for this. Why don't you improve your [first post](https://www.reddit.com/r/apljk/comments/3l5lnk/how_to_convert_this_j_code_into_php_code/) instead of reposting?
Having problems with the J code actually, as it doesn't work. thinking of rewritting. No sorry not interested in php.
I'm moving on to J.
I thought so too, especially with their ponderous legality references, but they themselves just big upped Bua kxcommunity.com/sports-trading-start-up-built-with-kdb.php Come to #kq on freenode when you have a sec to chat
This makes me sad.
Such encodings do exist, for example, [codepage 907](http://www-03.ibm.com/systems/resources/systems_i_software_globalization_pdf_cp00907z.pdf) is an 8-bit APL character set based on ASCII. Historically, you would find EBCDIC based encodings such as [codepage 293](ftp://ftp.software.ibm.com/software/globalization/gcoc/attachments/CP00293.pdf) to be used more often as APL was originally developed for IBM mainframes. Modern APL implementations such as Dyalog APL use some symbols that aren't found in these code pages (such as ⌸ *key* or ⍤ *rank*) which makes these code pages slightly less useful for modern APL programming.
Hey, I have the same setup. Here's a a script for downloading j804 beta (change "804" to "803" if you want the current stable version). A [previous version](https://github.com/hoosierEE/dotfiles/commit/9d7eca40acb238771544982eaf7004df7b823257) was cross-platform for ARM32, Intel Linux and Mac, but IIRC didn't work perfectly so now there's just the [ARM version](https://github.com/hoosierEE/dotfiles/blob/master/getJ.sh). Should also work for Raspberry Pi. #!/usr/bin/env bash # Install J in HOME directory. Symlink for jconsole on PATH. VERSION="804" JCNAME=jc"$VERSION" # e.g. "jc804" [[ $(which $JCNAME) ]] &amp;&amp; echo "$JCNAME installed" &amp;&amp; exit; # or upgrade J version? cd $HOME/ curl http://www.jsoftware.com/download/j"$VERSION"/install/j"$VERSION"_raspi32.tar.gz | tar xz ln -s $HOME/j"$VERSION"/bin/jconsole $JCNAME sudo mv $JCNAME /usr/bin/jc$VERSION 
Interesting talk by Rob Pike: https://www.youtube.com/watch?v=PXoG0WX0r_E
The latest 3.3 test version is implemented natively. What you have linked to was the previous version. From the k4 listbox: &gt;json aficionados will appreciate today's (TEST) release of 3.3t - we have rewritten .j.k, the json parser (deserializer), in c. The benefits are that it is ~40-100x faster, uses less memory and processes escapes/unicode in strings properly (recoding \uXXXX as utf8).
K4 (KDB/Q) doesn't change this much: * Argv is `.z.x` and files are symbols beginning with colon (prevents accidental injection), so: p:?["+-&lt;&gt;[].";]'p:,/0:`$":",*.z.x * Cond is spelled `$` and not `:` (this is true of K5 as well), so: bm:(#p)#0;l:();{c:p@x;$[c=4;l,:x;c=5;{e:*-1#l;l::-1_ l;bm[x]:e;bm[e]:x}x]}'!#p; * Printing/output is simply applying scalar ints, so: op:{1("c"$t tp)} Other than these changes, it works fine in K4/Q/KDB.
Quick question: What's the syntactic ambiguity in k? 
&gt; arity I think the correct term is valence, but I've used arity myself on occasion too. Edit: After a google search I see that arity is a perfectly cromulent word. Carry on!
That's not an ambiguity. That's the n-ality of verbs in K, a generalization of the duality found in J.
Of course there's no ambiguity (the syntax is well defined), however, J (and APL before it) can only disambiguate in run time. In most cases, K can disambiguate syntactically - but not in this one. Either way, I'm just speculating - if you want to know what t3x meant, email to ask him - I just found it and posted it.
&gt; however, J (and APL before it) can only disambiguate in run time Yeah, that's true, but it's not due to monad/dyad duality, it's because there are different kinds of words (verbs, adverbs, conjunctions, nound, copulæ, and punctuation) and you can't know in advance what kind a user-defined word has. This problem is not J-specific though, many complex programming languages, such as C, have this or similar properties. I don't see how it's a large disadvantage either.
My personal favorite word that array languages do better is `monad`.
 forcedcells =: _:`{.@.({. *./@:= }.)"1&amp;.|: : ($:@:(] #~ *./@(= +. _ = [)"1)) forcedcells 25 nonopart 1 3 1 5 2 1 3 1 _ _ _ 1 1 _ _ _ _ 1 1 1 1 _ _ 1 _ _ _ _ 1 1 _ _ _ dyadic version lets you pass a filter to extend the forced cells. for example with above, but additional first cell forced to 1 1 _ _ 1 1 _ _ _ _ 1 1 1 1 _ _ 1 _ _ _ _ 1 1 _ _ _ (forcedcells 25&amp;nonopart) 1 3 1 5 2 1 3 1 1 0 _ 1 1 _ _ _ _ 1 1 1 1 _ _ 1 _ _ _ _ 1 1 _ _ _ adds a forced 0 in pos 2 force last to 1 too... 1 _ _ 1 1 _ _ _ _ 1 1 1 1 _ _ 1 _ _ _ _ 1 1 _ _ 1 (forcedcells 25&amp;nonopart) 1 3 1 5 2 1 3 1 1 0 _ 1 1 _ _ _ _ 1 1 1 1 _ _ 1 _ _ _ _ 1 1 _ 0 1 importing from http://community.wolfram.com/groups/-/m/t/755538, placing hclues and vclues definitions on clipboard one at a time. hclues =. 0&amp;". each &lt;"1 '{}[],' -.~"1 &gt; cutLF wdclippaste '' vclues =. 0&amp;". each &lt;"1 '{}[],' -.~"1 &gt; cutLF wdclippaste '' ] startforced =: ([: forcedcells 25&amp;nonopart M.) every hclues _ _ 1 1 1 1 1 _ _ _ 1 _ _ _ _ _ _ _ 1 1 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 1 _ _ _ _ _ _ 1 1 1 1 1 _ _ _ _ 1 1 _ _ _ _ _ _ 1 1 _ _ _ _ 1 1 1 1 _ _ 1 _ _ _ _ 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 _ _ _ _ _ _ _ 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 1 1 _ _ _ _ 1 _ _ _ _ _ _ _ 1 1 1 1 _ _ _ 1 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 1 1 1 _ _ _ _ _ _ _ _ _ _ _ _ _ 1 _ _ _ _ with no hints, &gt; pass2 =. (&lt;"1 |: startforced) (hclues &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every)~ vclues &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every)~ hclues &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every)~ &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every) ) vclues 1 1 1 1 1 1 1 0 1 1 0 0 0 0 1 0 1 _ 1 1 1 1 1 _ 1 1 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 1 0 1 0 0 0 0 _ 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 0 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 0 0 0 1 0 0 1 1 1 1 0 1 0 1 1 1 0 1 1 0 0 0 0 0 1 0 1 0 0 _ 0 1 1 0 0 0 1 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 _ 0 1 1 1 0 0 0 0 0 0 0 0 0 _ 1 0 1 _ 0 1 1 0 _ 1 _ 1 1 1 1 1 1 1 1 0 1 1 0 1 1 1 0 0 1 1 0 1 0 1 1 _ 0 0 1 0 0 _ 0 1 0 1 0 1 1 1 0 0 0 1 1 1 1 1 1 1 0 _ 1 1 _ 0 0 0 0 1 1 0 1 0 _ _ 0 1 1 0 0 0 0 _ 1 1 _ 1 0 _ _ _ _ 0 1 0 1 0 0 0 1 1 1 1 0 1 0 1 0 0 0 _ 0 _ _ _ _ 1 1 1 1 1 _ 0 0 _ 1 1 _ 0 0 0 0 1 1 _ 0 1 0 _ _ _ _ 0 1 1 1 0 1 1 0 1 1 0 0 1 1 1 1 1 0 _ 1 _ 0 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 1 1 0 0 1 0 1 0 1 0 1 0 1 0 1 1 0 1 1 0 1 1 1 0 1 1 1 0 1 1 0 1 0 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 _ 0 1 1 1 _ 1 1 0 0 0 1 1 0 1 0 1 1 1 1 1 1 1 0 _ _ 0 1 1 1 _ 0 1 0 1 0 1 1 1 0 0 1 0 0 0 0 0 1 0 _ _ 0 0 0 0 _ 0 1 _ 0 _ 1 1 1 _ 0 1 0 1 1 1 0 1 0 0 0 0 1 1 1 _ 0 1 1 1 1 1 1 1 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 0 0 0 1 0 _ 0 1 1 1 1 1 0 1 1 1 0 1 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 1 0 1 1 0 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 0 1 0 0 1 1 1 0 0 0 _ 1 0 0 1 0 0 1 cleaner 3 pass version ... about 30 seconds... still converging &gt; &gt;@{. (vclues ,&amp;&lt;~ hclues &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every)~ &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every) )&amp;&gt;/^:3 (&lt;"1 |: startforced) ,&amp;&lt; vclues 1 1 1 1 1 1 1 0 1 1 0 0 0 0 1 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 1 0 1 0 0 0 0 0 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 0 0 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 0 0 0 1 0 0 1 1 1 1 0 1 0 1 1 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 1 1 1 1 1 1 0 1 1 0 1 1 1 0 0 1 1 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 1 0 1 1 1 0 0 0 1 1 1 1 1 1 1 0 _ 1 1 0 0 0 0 0 1 1 0 1 0 0 _ 0 1 1 0 0 0 0 1 1 1 0 1 0 _ _ _ _ 0 1 0 1 0 0 0 1 1 1 1 0 1 0 1 0 0 0 0 0 1 1 _ 1 1 1 1 1 1 _ 0 0 _ 1 1 1 0 0 0 0 1 1 1 0 1 0 _ _ _ _ 0 1 1 1 0 1 1 0 1 1 0 0 1 1 1 1 1 0 _ 1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 1 1 0 0 1 0 1 0 1 0 1 0 1 0 1 1 0 1 1 0 1 1 1 0 1 1 1 0 1 1 0 1 0 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 0 1 0 1 1 1 1 1 1 1 0 _ _ 0 1 1 1 1 0 1 0 1 0 1 1 1 0 0 1 0 0 0 0 0 1 0 _ _ 0 0 0 0 0 0 1 0 0 0 1 1 1 _ 0 1 0 1 1 1 0 1 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 0 0 0 1 0 1 0 1 1 1 1 1 0 1 1 1 0 1 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 1 0 1 1 0 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 0 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 0 1 not that much longer at 5 passes (memoization used), but it needs additional hints to fully solve. Correct rotation from above, also. pR |: &gt; &gt;@{. (vclues ,&amp;&lt;~ hclues &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every)~ &lt;"1@:|:@:((forcedcells 25&amp;nonopart M.) every) )&amp;&gt;/^:5 (&lt;"1 |: startforced) ,&amp;&lt; vclues 1 1 1 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 1 0 0 0 0 0 1 1 0 1 1 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 0 1 0 0 1 1 1 1 1 1 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 0 0 1 1 1 1 1 0 1 1 0 1 0 1 1 1 0 1 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 1 1 0 0 1 0 1 0 1 1 1 0 _ _ 0 1 0 1 1 1 0 1 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 _ _ 0 0 0 1 0 0 1 1 1 1 0 1 0 1 1 1 1 0 1 1 0 1 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 1 1 1 0 1 0 1 1 1 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 1 1 1 1 1 0 0 0 1 1 1 0 1 1 0 1 1 0 1 1 1 1 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1 1 1 1 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 1 0 1 0 0 1 1 0 0 _ 1 _ 0 1 1 1 0 0 0 0 0 1 0 1 1 1 0 1 0 1 0 1 0 0 _ 0 _ 0 0 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 _ 1 _ 0 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 _ 1 _ 0 0 1 0 1 0 1 0 1 1 1 1 0 0 0 0 0 1 0 1 1 0 0 1 0 0 1 1 0 0 0 1 1 0 1 0 1 0 1 1 1 0 1 0 0 0 1 1 1 1 0 0 1 1 1 1 1 0 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 0 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 1 1 1 0 1 1 0 0 0 1 0 1 1 0 0 0 1 1 1 1 1
cacplate's explanation is good, but there is still the issue of deciding whether a and c are dyadic in (a b c). One reason to prefer u@:v style over ([: u v) is that you know that u is monadic without looking for [: as the next token. (u can be a lenghty phrase, and so spotting [: not as obvious as the simple example) One approach that I like for readability is the adverb M =: @:] NB. M is for monad (+ + +/M % #M) This provides a good clue that the entire verb is meant to be dyadic (left + is ambivalent, but monadic + with non complex arg is same as `0&amp;+`) (so it is mostly "ambivalently coherent"). If the entirety was meant to be monadic, then (+ + +/ % #)M would be cleaner. In tacit code, all verbs are ambivalent. They just may produce unexpected results. Ambivalently coherent verbs are those that behave the same as their dyadic version if a default x parameter is assumed (`- % ^ ^.` ...). those are easier to read, because you don't need to know if there are dyadic parameters to understand the function. `# and i.` are more problematic bc they have unrelated monads and dyads. The key reading cues are: `(a b c)` b is dyadic. ac are ambivalent to function `(b c)` b is dyadic , c is monadic `b@c` b is monadic c is ambivalent to function `b&amp;c` c is monadic b is ambivalent to function 
⍲: pink floyd ⍱: upside-down pink floyd ⍨: unsure face ⍤: Oh-Face (oh, oh, oh! You know what I'm talking about)
With a simple tweak, a dragon curve: http://johnearnest.github.io/ok/ike/ike.html?gist=ab778d1d4bde1b22a737 
I love the wiggle effect. :)
Dammit on being across the pond and just being an interested APL dabbler :)
Not in the market for a job, but if by any chance you guys could describe or perhaps even open source (gasp!) parts of your GUI framework, I think a lot of us vector-dwellers would be curious to see what you've come up with. Even a blog post would be great - and would get you in front of K-leaning developers. This is a land of powerful tools and very little communication or public discourse, so any contributions from successful teams are greatly appreciated.
Unfortunately, that's not the first time I've heard that :-(.We're growing fast and we certainly haven't been as efficient as we could be at recruiting and hiring in the past -- and I know we are in transition to a more formal, organized process, but I'm not sure whether all the bugs are out yet. In any case, my apologies for any issues you ran into. I'm always happy to get personal email from people interested in developer jobs at 1010... that way I can personally ensure that we get back to you.
Well, our GUI framework is very tightly integrated with the rest of 1010data, as is, really, every other part of the system. That's part of our advantage, really: everything -- database, analytics, GUI, visualization -- fits together so neatly. But it does mean that there isn't really much that we could easily separate out. We're obviously not about to open-source the whole shebang, but it's not clear that there are any major parts of it that would be very useful if open-sourced on their own, either. We have a very different development model from today's typical open-source-centric stack plays -- sort of like K itself, it's a small, elegant unified code base with minimal core dependencies on third-party code (obviously the further you get to the periphery, the more dependencies there are -- we use open-source code judiciously in the browser, for instance -- but it's not heavily layered). 
[**@deleeuw_jan**](https://twitter.com/deleeuw_jan): &gt;[2016-03-08 06:17:46 UTC](https://twitter.com/deleeuw_jan/status/707087898776961025) &gt;I said earlier I was too retired to finish "APL in R". I lied. [*rpubs.com*](http://rpubs.com/deleeuw/158476) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4aadnx%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
[This](https://googledrive.com/host/0BwI7uv9YEkevREtuUmVmdTJBSXc) might be it.
This one is pretty good. http://jsoftware.2058.n7.nabble.com/J-Programming-f3.html
Thanks for the reply. Is this a better interface to the J forums ?
I think so. This interface feels more "live" to me. So, I plug in to the stream everyday and drill in on what interests me. And, when I have courage, I ask the occasional question. The J community folks are top notch, bright and patient. It's a pleasure.
&gt; Notation such as pure and &lt;$&gt; is powerful. So let's *really* use it for arrays! After all, it's a nice way to write your own version of function application. [Here](https://github.com/jrslepak/APLicative)'s a demonstration of rank-polymorphic operator lifting I came up with while stumbling around trying to explain J to some Haskellers. Following Haskell style, it's built around curried/higher-order functions rather than verbs with monadic and dyadic cases.
The `(1) 2 (3)` oddity is that J doesn't allow parsing 2 consecutive noun tokens. The quoted expression is 3 tokens, but `1 2 3` is a single token.
Overall, thanks for the detailed feedback! Always good to know I'm not shouting into the void over here.. About the two weaknesses you identified: I agree with both, but they're a result of my requirement to stick to a bare minimum, just to get something out the door. &gt; The building process is weird. You're right. I didn't go into my reasoning for not using a Makefile. That was lazy of me. I'll explain here, and then update the README: I have to make a lot of "decision tradeoffs" while developing XXL, as I am only one man, etc. I wanted `./c` to be a "featureful" build tool, meaning it would partially deduce the settings you need, use rlwrap when available, etc. Though I know that could be done in Make somehow, I didn't know specifically how. And in fact, I've often had trouble getting Makefiles to do exactly what I want, if it's something slightly different than the canonical stuff. The alternative, of course, is to use Autoconf, but that's much too complicated for me, and I've actually found Autoconf to be very annoying at times. So, in summary, building a shell-based tool was the easiest thing for me at that time, considering that I wanted something a bit "tweaked". I'll reconsider this going on, but it's not on top of my list. &gt; Unicode I dunno man, utf8 is pretty rough. I don't want the core to have a "vector that isn't really a vector in some cases" type (i.e., having to split glyphs along multi-byte boundaries for indexing complicates splitting bytes along boundaries). On the flip side, the multiword approaches are a bit wasteful in my opinion. I would be totally OK with someone else contributing a good utf8 library and we use that as a "text" type.. or "words" type.. something that means "collection of chars specifically including written language." I just don't have the capabilities right now to get that done in the face of all the other things I need to work on. Tradeoffs! Now, keep in mind, you could express utf8 as a regular string, as long as you don't have your XXL code need to split out glyphs, check for collating sequences/string comparison tolerance, etc. So you could pipe UTF8 strings around. But of course that's not very useful once things get complicated and you need to capitalize names, etc. Thanks again! Hope you continue to explore XXL.
You could try restricting searches on google to J scripts like: filetype:ijs &lt;searchterm&gt;
Other than the documentation, I don't think there are many articles/stack overflow questions about J. Though stack overflow should have a way to filter by language.
I don't think numpy explicitly calls it 'rank', but the central object in numpy is the n-dimensional array. Operators and functions can be applied to arrays, like in J, and operators can operate on two arrays of different dimensionality (rank), and the manner in which this is done in numpy is called 'broadcasting'. For example, if A is a 1-dimensional array of length N, and B is a 2-dimensional array of size NxN, then you can add A to each 'row' of B with: A+B # alternatively A[newaxis, :] + B and you can add A to each 'column' of B with: A[:, newaxis] + B 
sounds a bit more like restructuring, but still neat. A + B in J, or to add A to each row of B, A +"1 B 
Fun talk! You did an excellent job explaining the intuition behind the prime sieve and how to think through the problem "all at once" rather than iteratively. I'm not sure how much clarity it adds, but I typically refer to compounds of \\:/: in K as "cartesian product".
Thanks for the reply! I often think of \\:/: as cartesian product when using it as well, but I was wary of introducing too many analogies, wanting to keep the generality of flexibly pairing items. That said it definitely might help people understand the operation, I'll add this to my notes, thanks! :)
I'm one of the contributors to this work. The core foundation is the [apltail](https://github.com/melsman/apltail/) compiler, which is able to deduce static types for programs written in a subset of APL, which is intended to enable high-performance compilation. We're quite interested in figuring out exactly what this subset should look like. Restrictive enough to ensure good performance, but still flexible enough to not feel overly burdensome, and with restrictions that feel "natural", in some sense. (Like, nontrivial nested arrays are probably out.)
Thanks for the tip! Is there ever a time where I'd need to use the syntax I originally used? 
Good luck!
I'm fairly new to the APL/J/K scene. What, apart from a language and an IDE does one get by purchasing a commercial license of Dyalog? I'm trying to gauge if the language and IDE is the product, or if there are non-trivial additions to the core language that justify pricing well beyond the price of using most langauges (free). I understand things like q because of the 'product' of kdb. Is there a killer app that Dyalog produces for APL practitioners?
Never heard back from them.
I guess my frustration stems from the fact that there isn't seemingly a go-to Array language for new users that can be grown into a business solution without paying a hefty licensing fee.
/u/willhaney I've sent you a PM.
Yeah, J is what I finally chose. I've noticed that one of the allures of some of this stuff is it feels like a mixture of learning a new programming language, a new paradigm, and performing a weird sort of archaeology. Incidentally I'll probably start a small blog detailing some of my finding with the hope someone else can make use of anything I figure out. Now I just need to find someone with decent experience using Jd and various SQL platforms to serve as a rosetta stone for me;) Thanks for that advice!
J actually influenced numpy and a lot of the methods are very similar (even some names like ravel). As others have pointed out, a major difference is around rank; J uses verb rank where numpy uses broadcasting rules and the "axis=" pattern to achieve similar things. One interesting thing to note is that numpy only supports array shapes up to 32 dimensions while J can blow past that essentially until you run out of memory. On the other hand, numpy has support for no-copy views which can be a huge boon to large data/ limited-memory situations. Also, for better or worse numpy programming involves much more concern about explicit datatypes and memory layouts -- I'm not sure how or if J handles these kind of things.
 calc_m =: 4 : 'y + &lt;.@-: x - y' f ^: (_) a 148932 148932 148933
APL started on a blackboard, so it seems natural that it should come back to it.
J has a built-in primitive `p:` that generates prime numbers. You can use the inverse of `p:` to find the index of the prime closest to 2 million as follows: `p:^:_1 ] 2e6`.
Sorry I don't have an answer, but I'm equally interested in one. Out of curiosity, do you know any K vs J vs APL vs Julia vs ADA Benchmarks? I'd be really interested in learning which one produces the fastest binaries. I guess adding Julia and ADA maybe odd, but they offer similar advantages for Array and Vector heavy operations. Personally I think K and APL should perform similarly well, with the others being a little behind, but I hope to be wrong. Because writing in the other languages is easier than K/APL.
&gt; ... any K vs J vs APL vs Julia vs ADA Benchmarks? Unfortunately I'm not aware of such published benchmarks, but maybe those who wrote the micro-benchmarks published here http://julialang.org/ (section "High-Performance JIT Compiler") might want to add further languages too. &gt; I guess adding Julia and ADA maybe odd, but they offer similar advantages for Array and Vector heavy operations. Well, than MATLAB might be considered too :) 
My Prof. has an APL compiler that he bought for about 2 grand according to him. But I don't know if you can get an APL compiler elsewhere. Maybe the free or non-offcial APL compilers don't have the same performance. Do you have any info on that? Hmm, yes I think you could add Matlab just for comparison, but I doubt that Matlab code can even compete. It's more for rapid prototyping than building applications, although I know you can do both with it. 
&gt; But I don't know if you can get an APL compiler elsewhere. Dyalog is now free for personal (non-commercial) and educational use http://dyalog.com/download-zone.htm There's also a very interesting JavaScript based implementation: https://github.com/ngn/apl that can run in the browser for demo/quick learning purposes. &gt; but I doubt that Matlab code can even compete. It's more for rapid prototyping than building applications Oh, you would be surprised how much stuff is powered by Matlab or Matlab generated code :). Basically the market share of Matlab is way bigger than that of all other languages you enumerated above combined :).
To answer my own and your question, [Dyalog](http://www.dyalog.com/) seems to be considered the most recent (non-)commercial APL Compiler. I can't say anything about performance especially not knowing how [GNU-APL](https://www.gnu.org/software/apl) compares to Dyalog. I really found [tryAPL to be a really useful tutorial](http://tryapl.org) so far, maybe even more useful than a (lengthy) Video. Regarding the Expressiveness of APL, I should've added Haskell to the List, because it's immensly expressive, but it's not really fast, altough 'it can be really fast' in the right hands.. However to make it short, here's a good comparison of the [expressiveness of various programming languages vs APL](http://xahlee.info/UnixResource_dir/writ/Mathematica_expressiveness.html). For the researchers and curious minds out there, there is an [SIGAPL Conference](http://www.sigapl.org/) I just stumbled over, that appears to be really interesting and active. 
&gt; I really found tryAPL to be a really useful tutorial so far, maybe even more useful than a (lengthy) Video. Pluralsight (style) videos are quite efficient compared to many alternatives. I could observe this in the last few years, and it seems that those kind of videos keep people more engaged until the end of the course (something that can't be said for the interactive or tutorial driven ones).
I've not seen a Pluralsight (style) video yet :) But click on Primer Tab on trypapl.org and hover of the symbols, that was really enlightening for me. Until then I really thought that APL is unlearnable unless you've an IQ over 200 :D, but now thinks suddenly make sense. But you stand right, the motivation, usage, potential and elegance can be shown much better on video. 
I haven't seen what you're looking for, but writing such a thing isn't difficult, and might be a good way to learn/improve your K. Here's a [place to start](http://geocar.sdf1.org/unlisp.k). You can choose different names for things, or you could [parse it yourself](http://nsl.com/k/kparse/) instead of relying on KDB's parser, or you could implement a [formatter](http://nsl.com/k/tree.k), or you could try making `unlisp` shorter.
Thanks, and you have a good point about it being a good learning exercise.
Might you refer to https://a.kx.com/a/k/examples/read.k ? Do note that it's k2/k3 though.
m@:d 
I see, thank you! And (m d) woukd be (m x) d (m y) correct?
Thank you that does help! But I dont get why you changed what I wrote. Is it not legal?
It should refer to the right hand argument of a dyadic function or operator in a "short" (I didn't remember the correct term for APL, like an anonymous function in other languages) definition, eg: test_fun ← ⍺ + ⍵ and used like: 1 test_fun 2 EDIT: The mnemonic is from Greek (and/or Christianity if you swing that way). "alpha" is the first letter and "omega" the last. EDIT2: Forgot to mention that it can also be the only (right hand) argument to a monadic function or operator, eg: monadic_test ← ⍵ + ⍵ ⍝ monadic doubler monadic_test 1
they're covered with scotch tape, so as long as the tape doesn't peel off they'll be fine
What kills me every time is they could invent any symbols, but no, they used two types of boxes and several kinds of circles!
The `pl` and `ps` functions are "plot line" and "plot scatter". Each is a dyad which takes a domain (x axis) and a range (y axis) as arguments, respectively. If the domain is a number, it's interpreted as `!x`. If the range is a monadic verb, it's interpreted as `y'x`. Try it by entering something like: pl[.5*!50;sin] This frontend chooses between a "calculator mode" keyboard layout and a more conventional qwerty layout based on the aspect ratio of your browser.
While not a course as such, you may want to look here: https://www.youtube.com/user/APLtrainer/videos The quality isn't brilliant on all of these but the content is pretty good, I'll be working with the creator of these to have better quality audio and video in the future. Dyalog are also going to be looking in to creating more training videos and material. Hope this is helpful.
X-Post referenced from [/r/tinycode](http://np.reddit.com/r/tinycode) by /u/pranomostro [Solution of the first 47 of the 99 lisp/prolog problems in klong](http://np.reddit.com/r/tinycode/comments/5ampq0/solution_of_the_first_47_of_the_99_lispprolog/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Can you not use ssr to strip the commas out?
Haha, I didn't realise I could use except in the same way in q: "2,000"except"," and from there redefine everything - much tidier, thanks!
Just strip out the commas q){"F"$ x except ","}"2,000" 2000f or the vectorised version: {"F"$ x except\\: ","}("2,000";"4,000") 2000 4000f 
&gt; or would 'string BASEAMOUNT' be the easiest way to deal with that in that circumstance... yep
This will give you a integer/long type though, better to use a cast.
10.9 or os 9? longshot, j6 might work for it.
Very cool! Like the text at the start especially
is it a github.io feature to webify iKe/oK ?
I searched for an older version of j but it is hard because of the name. I couldn't find anything on internet archive. The apl versions I found for os 9 didn't work. Maybe I could contact someone from jsoftware.
&gt; only reason I see for this to be a segmented DB is to support the 32 bit version of the interpreter. I thought segmenting lets the system take advantage of paralel disk access accross machines
Always thought J was interesting and that more people used it. Have you ever tried using it outside of hobby projects?
I've used J for analyzing financial data, and for massaging data to/from/for SEO, but nothing extensive. SLOCs are a terrible measure of just about everything, but for context: some tens of SLOCs. Those lines did a lot; as is the nature of these languages. I really enjoy J, but the jewel of this language is array-oriented programming. I really like tacit programming, but from a broader perspective, I don't know if J really improves on APL. It's better in some ways and a lot worse in some other ways (half-assed implementation of named parameters when tacit programming with hooks and forks turned out not to be popular, etc.) My feeling is that modern APL's like Dylog APL have learned all of the best lessons from J. On the other hand, K has a lot to teach it. Are you thinking about learning J? :-) If so, there are a lot of beautiful ideas here. Enjoy!
&gt; In no certain order: *APL or J *Forth *Red *C++ *Fortran *Perl6 *Clojure *F#. sticking with one long enough for mastery is the hard part. A very nice list :-). At least it's interesting, and you're keeping yourself busy. &gt; A lot of these have some roadblocks too from implementation to setup to ease of learning. Would you mind telling me more about your experience along these lines? What do you find are the typical roadblocks?
Hey man I formatted your comment as I was reading it! -- - Thanks man. There are a few others as well, but these stick out the most: ## APL Dyalog costs $ outside the 32 bit version or the trial. Gotta grab a keyboard too that supports the symbols, but that isn't a real problem. It is interpreted, so not blazing, but pretty fast for what it is good at. It is so different than everything else out there that you know only you will be able to read your code at work. Most normal people are very resistant to code that doesn't look like C with a few exceptions (Python is popular). ## J More niche than APL, tiny community, only a few books I've seen for getting up to speed ## Forth very expert oriented. I've yet to see a single resource for introducing enough knowledge of the hardware, assembly, or C to start walking you through building a Forth and what the pro/cons are of the different choices. They have pre-built ones like GForth, but the appeal to me is building my own custom language with hardware level access. ## Red Still being built with lots of things missing. Almost no non-Rebol doc. The Rebol stuff I've seen is pretty basic though (build a text file database) and doesn't address larger scale concerns and how to really take advantage of its power. ## C++ This exists for windows and Linux, but if you're stuck on windows you have to deal with MinGW/Cygwin if you want to use things like the GNU Scientific Library. You definitely have to put your time in to learn how to work without a GC and manage your own memory &amp; deal with pointers. Fast to run, but very slow for someone like me to write. Lots of resources though. ## Fortran Surprisingly not too bad for writing numeric code. Fast, mature, resources available. Universally shunned though. ## Perl6 Awesome language, lots of neat features pulled from Smalltalk, Haskell, perl5, APL...etc. Docs are fairly immature although books are starting to surface, having a MOP is cool, but I know you're waaay more knowledgeable on that. Grammar based programming seems neat. The implementation is still immature and dog slow. A lot of essential features to me like a REPL are not in the standard library, but available in modules that may or may not be high quality. I'm not sure if it will pick up steam and get performance enhancements and more exposure although this has been happening to some degree. ## Clojure Simple language with a good community, resources, and performance via the JVM. I think the JVM communities are fracturing too much with Scala, Java, Kotlin, Groovy...etc. Setup is painful. You have to learn Leinegin for builds, emacs is the primary support although there is an anarchy of other tools lightly supported to some degree (too many unknowns in my stack). You have to deal with JVM stack traces instead of CommonLisp errors. Most resources assume you have significant JVM experience. ## F# Performant, access to all of .NET. Nice tools all built into Visual Studio, easy to transition from C#, type providers are crazy cool, nice REPL, intellisense. Absolutely no true beginner resources. They show basic syntax and then you have books talking about all the advanced features. Assumes heavy .NET familiarity. Syntax is extremely complex although fairly terse and powerful. Very nice data analytics tools. This is the language I've had the most trouble grokking, but the easiest setting up. 
Some things I've come across: * Computing in Statistical Science through APL * Applied Linear Algebra With Apl * books by Norman Thompson * [Physics in Apl2 Greg Chaitin](http://www.softwarepreservation.org/projects/apl/Books/Physics%20in%20APL2) https://gist.github.com/jpjacobs 
[Computing in Statistical Science through APL](https://drive.google.com/open?id=0BwI7uv9YEkevdkMxSU9FY0ZadUU).
Interesting. Never heard of Futhark. I could see Kx building something like that for high frequency trading.
Thanks for the books.
J has LAPACK in package manager, an arrayfire binding, which has blas backend in addition to gpu focus, https://github.com/Pascal-J/Jfire
Interesting...any blog posts on using it effectively?
https://www.mail-archive.com/programming@forums.jsoftware.com/msg14202.html The test file is mostly an example file.
The original discussion on Hacker News which lead to this livestream being organized: https://news.ycombinator.com/item?id=13565743
what do you use arrayfire for? 
A sample program, https://github.com/arcfide/Co-dfns-benchmarks/blob/master/blackscholes/blackscholes.dyalog The S variable holds the program, and it can be run on either dyalog or GPU? is there a way to call dyalog (from J or C) and have it produce either opencl or arrayfire kernels?
 load 'plot' load 'trig' pd 'type pie' pd 2 3 5 pd 'show' [Ta-da!](http://i.imgur.com/SQMaU76.png) Check [this](http://code.jsoftware.com/wiki/Plot) out for more info on the library.
I assume the author means he accidentally made a functional language and not that Iverson invented FP. Am I missing something here. Both the lambda calculus and lisp predate Iverson's mathematical work and apl right?
I'm not sure that the author is suggesting -- by using the word "inventing", that everyone "got" functional programming from Iverson, only that Iverson's method was independent of other origins of functional programming. I don't know how accidental it was... FYI: Iverson Notation was invented in 1957 (and perhaps earlier); Lisp is regarded as being invented in 1958. 
If you simply want to play around with a K dialect (as opposed to doing something seriously resource/performance intensive), you could try [oK](https://github.com/JohnEarnest/ok). Running it from the commandline requires NodeJS, which appears to have an ARMv8 port available. Consult your package manager. I've had success running oK (albeit somewhat slowly) on a PocketCHIP, for example. Alternatively, you might try compiling [Kona](https://github.com/kevinlawler/kona) from source- I haven't tried it on an ARM platform myself. 
DosBox / IBM TryAPL2? (medium memory model interpretor) does it need a gDOSbox x87 patch?
Without answering your homework for you, these are both pieces of arithmetic. Can you explain what you think they mean? Apply the operators you know from right to left, even if standard maths generally tells otherwise. Try GNU APL if you don't have another implementation to play with,
Note that APL doesn't have a `⋅` operator, though, a `×` operator exists.
of course you can consider verbs a data structure , sibce adverbs can manipulate them. Also arrays of verbs can be realised using gerunds.
The short answer is that the structure to focus on when learning and using J is the array. One of the most powerful eureka moments you'll experience in your programming career will be when the purpose and value of switching between a value and a structure perspectives when addressing data, and ultimately the genius of assigning as much importance to a datum's *position* as you do to its value (compare 1979 with MCMLXXIX). The only other structure built into the language is the class/object system, but it's overshadowed by the array tooling. Also, if we're being honest, it was introduced as mostly an afterthought in the late 90s as OOP's star was rising, similar to the advent of objects in Perl during the same period. Another commentor mentioned boxes. Yes, those are a way of strutting data in J, adding depth to the array's width (or spread), but when thinking in J, I tend to lump boxes in as another value type, like numbers or characters or symbols. That might be different if there were more and better primitives for handling boxes as trees, or depth processing, but given the relative dearth of such tooling (essentially you have L: and S:), boxes are mostly used for homogenization, to make inconsistent things fit into consistent arrays. 
To run 32bit kdb+ on a 64bit system you need to install some 32bit libs. See here: http://code.kx.com/wiki/Tutorials/Installation#32-bit_or_64-bit.3F &gt;But if you are installing 32-bit kdb on a 64-bit Linux distribution, you will need a 32-bit library. Use your usual package manager to install i686 or i386: for example: &gt; &gt;&gt;sudo apt-get install libc6-i386 
The kdb+ ARM package currently requires you to add execute permission to the binary file. Regardless of root access, you won't be able to run it until you enable this. chmod +x q/l32arm/q
one of the more frustrating k/Q ommissions. though my k is rusty, I think you may be able to do something like P: {x[z;y]} though that doesn't let you use it in infix form
Ah okay, I thought maybe it was named something else and I just wasn't searching for it properly.
and I think the idiomatic k way of doing passive is `%[;y] x` &gt; Which is really all adverbs and conjunctions are as a matter of reading consistency, its a sensible choice. But it seems like a pain to write. `P[%;x;y]` is not something you'd edit in from trying to swap original parameters of `%[x;y]`(mistake) more likely edited into `%[y;x]`
 ] table=: ? 3 5 $ 5 NB. Random 3x5 table 1 3 3 4 2 1 0 3 3 4 2 0 2 0 4 (, table) NB. remove structure 1 3 3 4 2 1 0 3 3 4 2 0 2 0 4 (~.,#)/.~ (, table) NB. (~.,#)/.~ produces freq table 1 2 3 4 4 3 2 3 0 3 
any idea how to sort the final table? I tried to add the monadic sort at the front to no avail: /: ((~.,#)/.~(,table))
Sort by count (second col): (1&amp;{"1 /:~ ]) ((~.,#)/.~(,table)) 2 2 0 2 3 3 4 4 1 4 Sort by item (first col): (0&amp;{"1 /:~ ]) ((~.,#)/.~(,table)) 0 2 1 4 2 2 3 3 4 4 
in J, the more idiomatic is, 3 ]\ 'ABCDEFG' though ,\ works too. in j, 3 ,/ ... would indeed append 3 to each (if they were compatible types, ie both strings or numbers). So perhaps, in apl, they used the wrong slash too? 
I could've sworn I'd already tried that as a sanity check, but looks like that execution only occurred in my mind :) Thank you! Just out of curiosity, how easy was it for you to read that Mandelbrot code as I'm not quite there.
This is because dyadic / creates a list of lists based on the right argument where each group has some some number of elements, as indicated by the left argument. It then performs the normal / operator on each group and collects the result. In other words, `'ABCDEFG'` is first split into the groups ``` 'ABC' 'BCD' 'CDE' 'DEF' 'EFG'. ``` Then, the operations: `,/'ABC'` `,/'BCD'` etc are collected into a result list.
There's the 62-page [J Companion for Statistical Calculations](http://www.cs.trinity.edu/About/The_Courses/cs2322/smillie/jcomp.pdf). I haven't read it. I hope those who have chime in!
Not exactly the same thing, but Dyalog APL is funding someone who is writing some kind of compiler that takes APL code written in the functional (co-dfns) style and runs it in parallel on the GPU. He did several talks on Y-combinator Hacker News and maybe streamed an AMA. Very cool stuff. The entire compiler is only a few pages of APL, so he doesn't have to waste time generalizing things the same way you'd do in Java to keep from duplicating code. Hopefully someone can elaborate on this more and give an update for the project. Being able to take this super high level language and make it blazingly fast will be vital for future adoption as our data sizes keep exploding. *https://news.ycombinator.com/item?id=13797797 *https://www.youtube.com/watch?v=gcUWTa16Jc0 *https://github.com/arcfide/Co-dfns
Well, K implementations (Kx, Kona, oK) are all smaller and simpler than MicroPython and friends, I'm not sure what you look for in a "small" implementation. You might like Whitney's original A interpreter given here http://code.jsoftware.com/wiki/Essays/Incunabulum - it is what inspired Hui to write J the way he did, and also was the basis for Arthur's later A+ and shares a lot with K.
&gt; Kona That's good to hear. I haven't used it for anything yet, but it might be worth getting accustomed to. Of course, you can't run kdb+ without Linux (or Windows, etc.) and oK is written in node, so it might be the only K option… &gt;You might like Whitney's original A interpreter Thanks for that. I did try getting A+ running a while back, but never had much luck unfortunately.
This subject interests me and I wanted to do a variant of XXL called XXS which would target these tiny embedded platforms - specifically the ESP8266/ESP32. Relative to XXL, I wanted to implement general lists and dictionaries as a fixed-sized Apter-style tree (to avoid malloc) and hopefully use C++14 extensions to make implementation easier (I believe these are now available in their SDK). Sadly, I couldn't figure out an efficient implementation strategy. XXL's "virtual machine" is terrible. Perhaps you have some thoughts on that?
This is how hooks work - please see [the dictionary page on trains](http://www.jsoftware.com/help/dictionary/dictf.htm) for the True Description™ I'm going to use some redundant parens below to make the structure clearer. A train works as you describe if it has an odd number of verbs (a "fork"): `(f g h) y` is `(f y) g (h y)` `x (f g h) y` is `(x f y) g (x h y)` A train behaves differently if it has an even number of verbs (it's a "hook"): `(f g) y` is `y f (g y)` `x (f g) y` is `x f (g y)` Basically, in a monadic context a hook will throw its argument up on the left with no change and pass it to the second verb as well. In a dyadic context, the left argument goes on the left with no change and the right argument gets passed to the second verb. this makes `(- getmean) 3 4 5` become `3 4 5 - getmean 3 4 5`
Appears to be some minor discussion on HackerNews: https://news.ycombinator.com/item?id=14670909 
q is pure marketing syntactic sugar on top of k. Carefully crafted q looks a lot like English (e.g. "time where differs price"), so it's a way to get people who think "time@&amp;(~=)':price" is unreadable to look again, and pay more attention. But when you actually want to get things done, if you grok it, you'd probably prefer the underlying K; (would you prefer to write "2*x" or "two times x"?) q is consistent and less ambiguous, mind you - e.g., everything is either monad or dyad, there are no disambiguation rules needed. It sure is more verbose.
I think I should go with K not Q. thank you
With inconsistency I mean having some words and some symbols as primitive rather than all words or all symbols. Also I don't get the whole .Q._ thing.
The .Q namespace just contains a bunch of assorted utility functions.
oh. thanks for pointing that out!
hmm...K has 'words' too (or at least the K4 that q is a wrapper for): q)avg avg q)\ avg avg q)var var q)\ var var I suppose one way to think about it, q is just a bunch of utility functions written in K4, existing in the .q namespace: q)svar k){(n*var x)%-1+n:(#x)-+/^x} q)svar 1 2 2 3 23 88.7 q){(n*var x)%-1+n:(count x)-sum null x}1 2 2 3 23 88.7
well, the q syntax is slightly different, too.
If you're using it to work on databases, q-sql is really nice to use and isn't available in k.
Putting the colon to the right of any operator forces it into it's monadic form. Hash is just the raw operator. If count were defined as *just* hash, then it would default to expecting two arguments.
unlike q, (and like APL), k is ambiguous - "#" means "take" if used in a dyadic context (e.g. 100#a means "take 100 elements from beginning of a, repeating if length a is less than 100), and means "count" if used in a monadic context (e.g. #a means "length of a"). Let's assume "a" and "b" are both vectors of the same length. Then you might want to compute where a is less than b (written: "a&lt;b") or you might want to , get according to b's sort order ("&lt;b" - the "grade up" verb) the values in a. How would you write it? You could do: "a@&lt;b" ; or "a[&lt;b]" ; or "a(&lt;b)" ; or "a&lt;:b" ; they all produce the same result, and force interpreting the "&lt;" verb in the monadic=unary context. The last two are exactly equivalent, and the first two essentially equivalent as well for almost all purposes. So, to sum: "#" could either mean the monadic or the dyadic depending on context, but "#:" only ever means the monadic. q has non of this ambiguity - a symbol or a word only has one arity/p-adity. edit: See John_Earnest's comment below about parsing a&lt;:b , it's important!
What does defaulting mean? If count would be defined as just hash it would have a monadic and dyadic meaning. By the way, where can I look up things like this? Is there some K4 documentation out there?
This makes sense, thank you.
&gt; q has non of this ambiguity - a symbol or a word only has one arity/p-adity I would pedantically say that q does have operators overloaded by their arity, e.g. dyadic/triadic/tetradic ?, but yeah it doesn't overload monadically like k does.
In your prompt, try making a `count2:#`, and then call `count2[!10]` and see what you get.
I bet it's not 10?
&gt; Is there some K4 documentation out there? There's no official documentation, no.
By default, I mean in the sense that the parser would create a projection if you only provided one argument. The official documentation is at http://code.kx.com Though some stuff remains at http://code.kx.com/wiki/Main_Page
I should point out that `a&lt;:b` actually parses as a compound assignment to `a` in all the interpreters I have available. Otherwise this is an excellent summary.
Thanks, forgot about that when I wrote the answer. IIRC, The K3 and K4 interpreters were space sensitive on the compund assignment, e.g. a +:b / apply a to flip of b, same as a@+b or a[+b] vs. a+:b / add b to a giving a, same as a:a+b Am I correct? Do you know if that's how K5 disambiguates? how does oK handle this?
Only difference I see at all is how dialects prettyprint their results; independent of whitespace it is still an assignment. Given the following test sequence and then examining `a`: a:(1 2;3 4) b:(4 5;6 7) a +:b K2, K3, [oK](http://johnearnest.github.io/ok/index.html): (5 7 9 11) K4, K5, K6: (5 7;9 11) 
Thanks, I haven't used K in quite a few years and misremembered.
Part of the whole point of oK is to make sure a tinkering-friendly K interpreter for testing ideas is only a hyperlink away. :)
Yes, thanks for that! I've played with it in the past. Looks from the github repository that you're diligent about parity with Arthur's recent K - that's good; There's Kx K{2,3,4,5,6}, Kona, oK, kuc, ngn/k - each implementing a slighlty-or-largely different dialect, I hope it will diverge less in the future.
The full release announcement: Q'Nial, the language interpreter developed at Queen's University for the Nested Interactive Array Language, Nial is now available in a revised version that supports both 32-bit and 64-bit architectures. The open source code can be used to build versions for both Unix and Windows operating system. Nial is a very high level, general purpose, language based on a formal model of Array theory, developed by Michael Jenkins and Trenchard More, that influenced the development of APL2. Q'Nial is a C based interpreter with efficient, tuned, implementations of basic array operations. As such it supports computations of large data sets that can be numeric or symbolic data. The programming style is highly functional but can be used in an interactive way to experiment on data and build functions incrementally. It combines concepts from APL, Lisp and functional programming and supports Algol-like control structures. The implementation is competitive with other array languages such as J and APL as well as other interpreted languages with array libraries (Python/Numpy, Lua/Torch). Nial has been used for rapid prototyping in areas as diverse as insurance underwriting, question/answering systems, composing music in a specific style, and a variety of artificial intelligence applications. The repository is located at: http://www.github.com/danlm/QNial7 This repository includes binaries for OSX, Linux, Windows, and Raspbian that can be downloaded and used directly. Coordinator: Daniel Martin Contributors: Mike Jenkins John Gibbons Stu Smith
Hooray!! :) 
Because you can use k from q by prepending k) to your line, so the only difference is that you also get qsql, which is quite nice for simple queries.
~. is unnecessary here, as all elements of each list passed to (~.,#) are the same. ({. , #)/.~ is much faster: 100 ts '(~.,#)/.~v' 0.205772 4.21623e7 100 ts '({.,#)/.~v' 0.0206011 3.14739e6
**Rice's theorem** In computability theory, Rice's theorem states that all non-trivial, semantic properties of programs are undecidable. A semantic property is one about the program's behavior (for instance, does the program terminate for all inputs), unlike a syntactic property (for instance, does the program contain an if-then-else statement). A property is non-trivial if it is neither true for every program, nor for no program. Rice's theorem can also be put in terms of functions: for any non-trivial property of partial functions, no general and effective method can decide whether an algorithm computes a partial function with that property. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/apljk/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Must it be a verb? A conjunction would likely be simpler.
`(^:1)`?
The thing is I want to be able to bind to it, so if `f` is the left argument to my function, I want to be able to say `(^:1)@:[` like rrssh said (but this doesn't work) 
I got it: applyToCol =: @:(1&amp;{@:] &gt;@:selectCol &gt;@:(0&amp;{)@:]) Applies a function to a list that's inside this table format that I defined, where selectCol has the form `(boxedColumnName selectCol table)` Your contributions helped me think to turn it into a conjunction - thank you!
If you want to try Nial it should compile out of the box on your machine. We have compile it for the Raspberry PI which has an ARM processor. 
For me, reading J (or any APL) is more like reading a mathematical expression than reading a program in another language. By that I mean a J program is usually completely incomprehensible without a sufficient understanding of the problem that program is trying to solve. Contrast that with, say, a C# program which is usually understandable without complete understanding of the problem domain. So if you find yourself totally baffled by someone else's J script, or translating your own into python and back again, I'd suggest trying to get a better understanding of the problem that program is trying to solve. 
That's a fair point -- I've seen some J solutions in the P.E. forums that made me scratch my head until I understood exactly the (clever) method that the creator used. I still feel like there are instances when I know how to do something in a language like Python that I just can't translate to J. Similar to how when I was learning Racket, I struggled a bit figuring out how to do things the "Racket way." But even that territory, uncharted as it was, seemed familiar at times. Do you have any advice on how to approach a problem in a way germane to solving it in J?
`@;` is more idiomatic, and perhaps more advanced than `[:` . Generally indicates that you are understanding tacit principles. There's probably no magic shortcut in understanding code. The advantage of one liners is that you can take a portion of the line and see intermediate results. The dissect utlity could be handy. there are idioms for if replacements... if v y then u y else y end. `u^:v` if u y then x1 else x0 end. `(x0 ; x1) {::~ u` if v y then u1 y else u0 y end. u0`u1@.v 
Did you mean `@:` or do I not understand J well enough? Dissect looks very helpful, thanks for that. Finally -- I guess I didn't make this clear enough --, do you have any advice in particular on being able to approach a problem from a "J frame of mind" so to speak? I think that I've got a good enough handle on writing tacit functions (and I know of `3 : ` and `4 : ` for when I can't figure that out), the limiter I'm facing is not being able to go about solving a problem with J. I know that this question doesn't have an "easy" answer, but I'd appreciate any pointers to things I could do to hone my chops.
yes I meant `@:` You mentioned racket elsewhere, array languages think in whole arrays at a time, but map/reduce and other functional idioms from lisp are part of that thinking (even if head rest implementation patterns are not) J thinking is transforming the input array into successive steps until the desired answer. In generalities, there's only the advice of practice.
&gt;Do you have any advice on how to approach a problem in a way germane to solving it in J? Honestly, I can't give you much more than 'study mathematics'. I think that a background in math makes 'thinking in J' intuitive, so given my own background its hard to give concrete advice. That being said, you're asking the right questions, which (in my opinion) means you're on the right track.
&gt; I think that I've got a good enough handle on writing tacit functions (and I know of `3 :` and `4 :` for when I can't figure that out) But do you know of `13 :`? I found that one very helpful when learning J. It does the same as `3 :`, but tries to convert the verb into a tacit form. Example [from JforC:](http://www.jsoftware.com/help/jforc/explicit-to-tacit_converter.htm#_Toc191734596) 13 : '(s % t) [ s =. +/ y [ t =. #y' +/ % # It really does help.
I don't think its possible. I share the why question.
Yeah, usually I use `13 :` first, but I've noticed it isn't perfect and likes using caps. It especially doesn't seem to do well with dyadic verbs, although there have been cases where it's been unnecessarily long with monadic verbs, too. As an example, consider the following 13 : '(&gt;: x) % &gt;: y' ([: &gt;: [) % [: &gt;: ] 4 (([: &gt;: [) % [: &gt;: ]) 6 0.714286 4 (%&amp;:&gt;:) 6 0.714286 4 (&gt;:@:[ % &gt;:@:]) 6 0.714286 I would say that even the third verb is preferable to (and clearer than) the one returned by `13 :`, though the second verb is obviously the most concise. I think I'm at the point where I can systematically put together trains like `13 :` does and I'm partway there to knowing how to most effectively do so. However, I think I still mostly lack the knowledge to know _which_ functions to compose with each other to get my desired result. EDIT: Added the last example function.
It isn't documented, but anything defined in one of the workspaces (.k or .q, can't remember which) becomes a verb. You shouldn't, though - because it changes parsing and would cause other files to randomly stop working (if they used that verb as a variable name).
I would also like to tangentially point out that k6 comes with a few pre-defined non-symbol verbs: in, within, cmb, avg, dev, var (according to http://kparc.com/k.txt) And have a grammar from the same source to back up your parsing statement: `grammar: E:E;e|e e:nve|te| t:n|v v:tA|V n:t[E]|(E)|{E}|N`. I assume that in, within, etc are seen as `V` instead of as `N`, which is what all other things would be seen as.
As a not-very-different alternative to an M-expression, I know that in k6 it's also possible to use dyadic `.` and a list: `f . 1 2` == `f[1;2]`. But this is completely unrelated to what you were asking. :P
I would assume that it's to not make k's parsing context/environment dependent (as was pointed out by beagle3).
for people used to APLs elegant way to work out EDSLs using this syntax, it's a huge shortcoming. But in general, I still prefer K, because of its functional programming abilities and strong focus on lists.
Does k6 actually... exist? It's not the k that exists in current versions of kdb, are there any actual implementations of it?
poor Arthur, he ran out of symbols :D
yes, but currently you can't get the language. It's used to build kOS, which is also not ready for use right now. Don't try to find information about them in the internet, that's hopeless. We have to wait until kOS releases.
Huh, kOS is still a thing? I'd kind of assumed it'd been quietly mothballed.
not as far as I know
To your last thing, I know some other programming subreddits have weekly/monthly "ask anything" threads for exactly that purpose. The traffic here is low enough that weekly threads would be pretty dense, but I'm still not that opposed. At any rate, don't be too hesitant to consider posting your question right on reddit just like this :)
I haven't found it yet. I use J a lot, but the lack of good interaction with the operating system and the frustrating difficulty in getting data in and out the interpreter is really annoying. Plus there are a lot of weird design decisions I do not understand at all. For example, why doesn't `x #: y` with a scalar `x` create a vector of as many places as needed to represent `y` instead of behaving like `|`? That's such a *non-consequitur*, considering how monadic `#:` does exactly that (i.e. behaving like `2&amp;#:` should).
Yes. There are definitely design mistakes in J. But does it somehow reassemble how your favorite language would look and feel?
Yes. If it wasn't for these little kinks here and there.
I like APL the best, because of its use of non-ascii characters, actually. Have not played much with Q/K, only used J for a while but kept being "misled" by the ascii-ness
q pays pretty well
it somehow sacrifices a but of APLs expressiveness. 
K has a concision of definition which appeals to me. It feels like a purer q, which I learnt first, so I guess that has something to do with it.
K. FWIW Python is actually one of my favorite languages! In general, I love K's simplicity and the way it handles lists. Yeah, that's all...
In that instance `#.inv` or `#.^:_1` works, FYI.
J, for a scant few reasons: 1. I like tacit programming 2. I like terse languages 3. It's the only APL dialect I know (I may get around to learning APL at some point)
Yeah, but that's just really weird.
I know J, and it's my favorite, but have been learning K (Kona actually) and can read a little bit of APL. J's "trains" semantics are beautiful, although it requires judicious use, and good taste, or can become very unreadable. Of the three, to me J feels the most "array oriented" for some reason. I agree that K feels a bit like Python sometimes. Mostly I think it feels more pragmatic; more emphasis on "get things done" and less on "purest expression of thought". APL has by far the best aesthetics of any language I've used. The symbols are just so much better at communicating the concepts than either words or ASCII-like-symbols.
Neat (?)
This is interesting - are most of your products built on top of KDB?
I like APL the most because these non-ASCII symbol really fits me. Besides that they also helps me a lot when I'm learning because my mother tongue is Chinese and I don't mind learning some more character for programming :p
Yes, when people talk about wordish languages being more readable, they seem to ignore non-native speakers, like you and me. Have you heard about A+? They use APL characters too.
Heard of it but haven't use it. It seems the definition of quite a lot symbols are different from APL. 
Yes indeed. It was Arthur's revised APL.
Yes. KDB is our backbone. We have java on top of that. But the base is KDB
there's 9!:21 or base.cfg (accessible with configure | base menu) but these already default to very high values. Try on a smaller dataset/file in case the error text is bad, but a different error appplies. perhaps convert to list after you've loaded as boxes? This could be a Jd related error, as you are using some of its utilities.
I'm interested in this as well. Recently I've been using MicroPython on a device called NodeMCU (ARM mcu plus Wi-Fi) and the interpreter is more fully-featured than I expected. The performance is more than adequate for hobbyist-grade robotics. Definitely would prefer to use J or K in place of Python though.
Cheers for the reply - the default memory limit is 2^62 (Which does seem ridiculously huge), when I try `(9!:21) 2^63` I get a "|limit error" and if I try higher than that (ie `(9!:21) 2^64`) It simply ignores me and `(9!:20)''` returns 2^62 as before. The code works fine for smaller files, and I already do convert to lists after loading as boxes. Maybe I'll try the J programming forum.
J is my favourite, because it feels the most functional with it's trains, however many things about K/Q impress me wrt how easy it is to understand, like iterate/converge/over, for which J's equivalent, `^:` (power) + gerunds/infinities is much harder to understand, and similar in power. J also has tacit function definitions which are insanely fun to write. If Arthur Whitney &amp; pals ever get bored just making Q go hella fast, tacit definitions would be the feature of my dreams.
I don't think this is related to `9!:20`/`9!:21`, unless you have 4 exabytes of RAM. This is probably simply because OS refused to allocate more memory for J. Unless you really need to store the entire thing in memory, consider processing the file in chunks. Otherwise, get more memory and/or bigger swap, I guess.
Where do you even get k5?
The docs are up at kparc. I think you could Arthur a friendly email to get early access. 
[These ones?](http://kparc.com/k.txt) I thought they were for K6.
Simpler way to get K5: oK browser repl. They also claim that's K5.
&gt;Simpler way to get K5: oK browser repl. I thought that wasn't related to Arthur at all.
Please take a look at their README
j8.06 (in beta, but works well) is implementing avx instruction acceleration. still no seemless parallelism architecture for J. opencl, arrayfire (gpu) bindings exist.
I have, I saw nothing there about links to kx or Arthur. Instead of telling me to look at the readme could you tell me if it is actually linked? 
Sure :) In the README.md, click on K5. It links to the page mentioned above in this discussion. 
k5 and k6 are rather similar, on the verge of being the same language. Syntax-wise, at least. I believe that k5 quietly morphed into k6.
It's based off of k5 (and/or k6), and isn't that far off from the "official" interpreter most of the time.
K has always been minimalist, with a good FFI (or so I've heard). Perhaps Arthur's idea is to keep the interpreter simple and leverage the FFI to provide any missing features?
That's a cool thought, though I really love the K3 vocabulary. K3 with non overloaded !, so that it only means rotate and "a b!c" would mean "a!b!'c".
Only experts in said language and no graduates right? 
Would love to consider grads (Kx has a great grad programme) but I'm only interested in 2+ years of capital markets experience
Found this in r/programming and figured I'd repost it here.
Because third argument to bond is repetition. J doesn't try to figure out the inverse in this case like it would do with `^:` but just applies `f` `x` times.
Thanks. I can use `f@]^:[` apparently.
Yep, ask your questions
What do you use Dyalog for at work? What do you like/dislike about it? Do others use it at your company? Do you like the direction Dyalog is heading towards? As far as the conference, did the co-dfns demo go well? How usable is it currently? Is it free to use? How many people attend the conference? Is the community growing, stagnant, or waning? In your opinion is the APL future bright? What was your favorite presentation?
I work with Dyalog APL full-time for quite some time, coming to APL world from J (used J in university). We're using a rather wide set of internal libraries (for instance, two of new primitives introduced by Dyalog are already specified in somewhat different form in our code). The editor in Windows is the mess and it's something we have to use all the time. I don't know if same shit goes for Linux console editor, but the windows one is really annoying. And now while getting more functionality interpretation/console mode (I mean multi-line input, control structures, matrices etc), I'm afraid it will become even worse. I hope this movement towards plain text everywhere will somehow change it for the better. Actually, your two speeches were quite nice: I'd prefer a little less preaching in the first and a little techier information about the realisation of your compiler in the second, but overall -- it was fun and useful. I myself will not use co-dfns in nearby future, but it's always interesting to know what's going on in the world. And of course, I don't agree with 90% of what you're saying about APL style :) The one thing I loved about this conference is the networking -- I saw legends in the flesh: Roger Hui, John Scholes, Raymond Polivka etc. It's so cool to have a room filled with men who know about APL more than I ever will know. I would say something that bothers me is that community is split between large companies and small 1-2-5 people companies (including here science guys also). There is mostly no bridge between those very different market representatives with very different view on the language. I like this movement to outsource some Dyalog activities to people like you or optima or whoever can hold the gun -- perhaps it's a way to move forward, spreading the ideas and getting creams of the minds at the same time. I dislike this Dyalog's focus on the cloud, while all they did at the time is just start up windows machine using existing Azure infrastructure (correct me if I'm wrong). The focus is right, but come on, there should be something more if you want to sell it. About favorite presentation -- it's hard to pick one, but still Marshall's ´Moving bits faster' was a hit. And it's even bigger fun because Marshall is not a great speaker: things he does are speaking themselves.
I'm not Aaron Hsu, but could see how my comment could cause confusion. I was merely asking what someone with a lot more APL background than me thought of his presentations. The co-dfns compiler concept is cool to me as there is a hint that APL performance could one day be very good. Running high-performance parallel code would mean I could use APL for scientific computing and not just hobby things. I did see his presentation on style, and was wondering what you disagreed with. I think I would personally prefer a style you see more in the J community, but also liked Aaron's compiler's code (watched a presentation on it once) as each line is a single term. The IDE does seem to be a mess for me too. Is using a dedicated APL keyboard effective (easy to learn the symbols?). Agreed that the cloud stuff does nothing for me...more of a big company thing. I'll have to watch Marshall's presentation again.
Ooops, sorry for misunderstanding. Now I wonder why I thought you're Aaron. I believe that the goal with those compiler is seamless integration into the dyalog apl -- i.e. if it's faster to run function using GPU, it will be ran on GPU; static code analysis could be used for pre-run check. I'm not so sure how long it would take to get to that point. No such ideas were spoken, but for me it was just breezing through the air. About APL style presentation: while it was highly professional and interesting, I don't think it's useful for me as a professional. I mean, APL's structures are close in some degree to simplest natural languages -- so what? The tools do heavily influence on way of the worker's thought goes -- so what? Paper and pen are influencing even more. And readability -- APL source is showing the way which the programmer takes, and thus is heavily personal. I think you can tell code of John Scholes from the code of Aaron Hsu -- there are lots of stylistic and structural differences there. And I can't say that one is better than the other -- it's just different. Somehow it's similar to one relatively big FORTH community, where everybody re-writes same libraries again and again because they don't want to read through other's code. I can't say that it's efficiency -- it may be efficient for a person, but it's not efficient for the community. And on and on it goes -- there are many thoughts in this presentation, too many if you think about it. There are too much unknown things that are being omitted in each of those maxims. More focused speech would be much more interesting (to me). Still all my critique is vanishing as there is one great phrase in this presentation: Good APL emphasize the human interactive experience with the code. Bad APL emphasizes mechanical control over human accessibility and freedom of expression.
Thanks for taking the time to chat! Do you mind my asking which industry you work in?
sure, PMd
If you don't like the editor you might want to try dyalog-mode for Emacs which I maintain. https://bitbucket.org/harsman/dyalog-mode I use it every day at work and it's actively maintained. 
&gt;If you are an English reader, I would like you to use Google Translate instead of being considered spam. Fair enough but why post it on an English-speaking subreddit then?
Hmm, thanks, looks very promising -- let me find some courage to get into emacs.
The Internet will be different people together, please do not engage in split, split is the root of all human problems, such as war. Only after the diversification of things / different people, intertwined to promote the progress of civilization, ShionKeys will promote the development of APL, there is reason to let people here know
Interesting read. I do a fair amount of Python daily and dabble with APL &amp; J as well as a bunch of other unpopular langs. Since you mention Python and presumably know it, it might be interesting to see the two solutions back to back for both the Fibonacci and Game of Life functions. Fibonacci is commonly used as the first recursion example, so most readers will easily identify with it. However, I think Game of Life is where people unfamiliar with array langs will find the solution quite pleasant. A little more explanation with the Game of Life demo would also help (a little more background on the goal of it although it is fairly well known in coding circles). You could also link to Dyalog APL's Game of Life example on YouTube to contrast the difference with your solution in K unless you think that is too far off topic. Overall, a fun read. I wish we had more blog posts in APL/J/K.
Many programming languages deserve more attention. That's why I write about them :) My original plan was to show APL and not K, but I chose K because it uses ASCII and some mobile browser can not display APL properly. I'm not that good at APL, but I guess you have to replace !' by inner-rotate and the other ! by rotate, as well as the whole mapping thing with outer products. But some Lisp user told me I really should link to interesting resources, so I will include links. 
Arthur's Fibonacci and Game of Life: http://kparc.com/z/fun.k
A bitmap is rank 3 if RGB triplets are used. A video is one rank higher than this. This generalizes to any data over time, as 1 rank higher.
Can you explain that in more detail please? Are you saying 3 matrices where all 3 corresponding elements (1,1,1), (2,1,1), &amp; (3,1,1) make a RGB pair? And what about time? I don't understand your comment there.
a 100x100 bitmap would have shape of 100 100 3 if rgb bytes are the raw data format. An animation of 48 frames of 100x100, would have shape 48 100 100 3.
&gt; J feels like the perfect language for crunching huge amounts of data. That requires some kind of lazy evaluation, which is absent from J. If you need to read all of your data first, you're out of luck. I like J, but for different reasons. 
Scientific computing in general is one context where rank 3 or higher arrays come up. In any of the natural sciences, you are often dealing with 3-dimensional space already. Then if you add the element of time to that, you have a rank 4 array. E.g. historical temperature data in a rectangular parcel of the atmosphere. In many cases, representing your data this way will allow more efficient computation than even a well-optimized C/C++ version that doesn't use a multidimensional-array layout, because you can take advantage of heavily optimized linear algebra libraries (BLAS/LAPACK), or SIMD hardware like SSE or GPU's. I have used rank 3 or higher arrays pretty regularly on-the-job for representing probability distributions, images, and genetic data. Never used APL/J/K on the job, but languages/libraries that take inspiration from them (MATLAB and Numpy).
Are the resources for this anywhere?
No clue, but I'd bet Morten @ Dyalog APL would be happy to set you up if you can't get in contact with Aaron. Dyalog is pretty desperate to get the word out about APL as a lot of its user base is near retirement. It's sad as it's such a cool system. I'd use it at work if Dyalog included a way to distribute programs to others without them needing a Dyalog license and if it wasn't so expensive to put into production. It's hard to champion an esoteric language that is unusual and somewhat pricey. I really like the symbols though.
I feel this way about K sometimes. There are lots of things I'd like to build on or for K, but since K is commercial and closed-source it's virtually impossible to share something with a K dependency with a broader audience. There also seems to be some weird friction between the (small) Q community and the (even smaller) K community; I've encountered a surprising number of kdb+ users who view K as archaic and "unreadable". Overall it is discouraging. APLs are hard (or expensive) to obtain and set up, programs are difficult or impossible to share, there are limited libraries and learning materials available, and any *single* one of these problems is enough to strangle a language community. All of them together seem virtually impossible to overcome.
Agreed with what you've said. I think it would be more difficult to open source kdb+ as I'm sure Arthur has a lot of magic under the hood. To use Dyalog as an example, I think they need to put out a second book going over not just the primitives, but how to build it up into larger programs. I'm sure it's different than other langs. Aaron Hsu showed 4-5 different APL coding styles recently and it would be nice to know best practices. They have some YouTube videos, but more is necessary. I think charging for the IDE is fine, llike with Visual Studio, but if I want to just use the REPL in a shell, that should be free.
I use the J plotting library because I only do simple things and it does what it does in a pretty simple and straightforward way. If you need higher speed or more features, yeah go for gnuplot.
To be fair Dyalog APL is free for personal usage. Besides its new IDE (RIDE) is free and open-source: https://github.com/Dyalog/ride It is cross-platform and quite usable already (and doesn't require you to have APL layout installed, since you can use prefix keys to enter characters). Some of their other tools are available open-source under the same organization in Github. What they are lacking is a scripting support so people could start to use it in the same way as say Python or Perl. But this is declared to be in Dyalog 17 IIRC. However there is a GNU APL which works on various Unixes (linux, osx, etc) and allows scripting and work with the plain text files. It also has a fantastic support in Emacs: https://github.com/lokedhs/gnu-apl-mode This APL seems to be more conservative though and stick to IBM APL2 compatibility.
FWIW, I contacted Dyalog about getting one of their products working on arm64, and they were very supportive.
Didn't know RIDE was free, thanks! As far as free for personal use, that isn't super useful if you want to use it for work. The single-user developer license is reasonably priced, but needing my coworkers to also buy it just to run my code is a little too much. If I can only write APL for myself, then it greatly reduces its use to me. GNU APL looks cool. I'll give it a spin after I learn EMACS, but what I really want is Dyalog, just with a slightly different license/pricing model. For now, I continue to check-in with what they're up to as it does seem pretty neat.
I maybe said not entirely correct about GNU APL. You don't need to use Emacs to work with it; it is working standalone and even his author doesn't use Emacs. You can use any text editor to edit APL code and load it into the working session. It is also actively developed and people can implement extensions to it in C/C++ (like they did for accessing sql databases). Recent big features added were in-interpreter access to documentation and regular expressions support.
I have now suffered through your article via Google Translate and have the following questions for you: 1. In what possible sense are Lisp/C/Python/D better enabled by this keyboard than a standard one? 2. Having spent the last two weeks looking at APL, I think the shortcomings of existing keyboards and keyboard layouts for APL are exaggerated—how does this improve on the situation for APL? 3. You have a design and a lot of utopian talk about it, but how did your design happen? What were your design goals and what led you to make the choices you made? What makes it so much better that it's worth the trouble? 4. You talk a lot about hardware, but what I see here looks like a keyboard layout and an additional modifier. What's different, hardware-wise? 5. What is the purpose of the "Shion" key?
Video starts at https://youtu.be/3FjYly2G_QI?t=724
There's an ISO specification https://www.iso.org/standard/15692.html 
It can be downloaded [here](http://www.math.uwaterloo.ca/~ljdickey/apl-rep/docs/is13751.pdf) but you will have to give it the extension .gz and ungzip it after you fetch it. The [IBM programmer's manual for APL2](http://publibfp.boulder.ibm.com/epubs/pdf/h2110611.pdf) is also very nice.
Is there an (EBNF) grammar file for this too? Thank you.
Given the amount of influence IBM likely had on the early days of APL, is there any good reading on why IBM sort of abandoned it, especially considering how many other legacy things they've maintained?
I don't know. I'd guess they simply did the BigCo thing and spent money on things that seemed to make money, and it did until it didn't.
Just a beginner myself, but I would be surprised if there were, for several reasons: # APL and BNF are about the same age. Backus was starting to develop the idea of BNF in 1959, and Iverson was starting to develop the idea of APL in 1958. # The ISO standard linked above does not contain a BNF grammar specification, or really any real remarks about the syntax. # The book _A Programming Language_ has about a paragraph of remarks about the syntax, basically to say you read it from right-to-left. Indeed, the only real question the parser has to resolve is whether there is an argument on the left of the function you just read. # Googling "APL BNF" produced [this article](https://dl.acm.org/citation.cfm?doid=384282.28371) from 1987 saying it was some of the first work on making a BNF for APL, and it quickly devolves into questions about performance. # J will show you the parse tree for anything you input if you ask it nicely; you get a tree-like structure but (at least in tacit mode) you don't really get a bunch of different syntactic forms, just verbs with boxes on either side. I think if you spend a day or two learning APL, it will become apparent that there isn't much to it, syntax-wise. I think it would be easier to describe using a pushdown automata and then convert that into a BNF, but I doubt you'll learn anything interesting from the BNF form. Still, it might be interesting to do. Let me point out that APL/J etc. are not the only languages to not admit a particularly useful BNF grammar. Smalltalk and Lisp also don't have enough going on there to warrant a full BNF specification. The dominant languages of our time seem to require quite a bit of syntax, but many of the interesting languages of the first couple epochs of computing just didn't emphasize it as much.
I am like 99% certain someone here can explain a much better way to do this problem than with my weird `fill` gerund.
there's this, 1 2 3 (6 {. ,&amp;(6 # _500))@{.("0 1) 3 # 500 500 _500 _500 _500 _500 _500 500 500 _500 _500 _500 _500 500 500 500 _500 _500 _500 
1. I was hoping to have the lisp / APL / C / python staff join the ShionKeys team (because I had a lot of plans) and you probably got it wrong. 2. I did not mention any shortcomings of APL. Everyone knows that the birth of APL lacks an important precondition (there is no corresponding mainstream keyboard supported, which directly leads to hard-to-reach / learn APL). If ShionKeys was born before APL, APL It may well develop, at least better than it is now. To my surprise, APL developers are not happy to see ShionKeys. Second, the shortcomings of my existing keyboard description is not exaggerated. 3. My utopian talk means ShionKeys creates the conditions for a better programming language. If ShionKeys was born before APL, I think APL will definitely be better than it is designed now. I hope Lisp / apl / c / dpython developers join to design a better programming language (this is one of my plans). 4. Product / crowdfunding plan will release more information. I really need investors now to implement the project / plan SionKeys is designed to promote / change computer civilization. You think QWERTY is fine, I agree. But innovation is always about changing the status quo. Like the trackball mouse in the past, people are using quite well, although the existing thing is very good, but it can not stop the birth of the optical mouse. My English is not good, I hope we can understand it correctly
Here is a netizen translation Project Introduction that although there is no translation of the original meaning of some places, But can make English readers better know ShionKeys project introduction https://austinhuang.me/ShionKeys/
If you want my support, answer my questions. You haven't told me anything and *why on earth* would I give you money when you haven't given anyone a clue what you're up to? I am not using QWERTY now and haven't for years, but all you've given me so far is bullshit with an accent.
The introduction of the project clearly states that only investors will get more detailed information and you should know that I have been publishing projects everywhere in order to attract investment. It would not be known to anyone except on the day that ShionKeys was released to attract investment. In fact, if you know enough about the keyboard, look at the picture on my github to know the advantages of ShionKeys and whether it is better than a traditional keyboard.
You say "the focus from left to right: lisp, c, python, d, apl." I ask: how does ShionKeys benefit these languages? You say: I want Lisp, C, Python, D and APL "staff" to join you and figure it out. Why? We are content with what we have. I ask why. You say **only investors will get more detailed information**. 2. Your ideas about APL are wrong. There are both hardware keyboards for sale from Dyalog and easy-to-use keyboard mappings that come with Dyalog and Emacs. There's no actual problem here with APL. Without APL your case makes no sense, because all the other languages *were* designed around what is easy to type, so what is left for you to do with ShionKeys? By the way, it's **easy** to make a new keyboard map, and it's **not hard** to make your own physical keyboard. Anybody who wants to do this can. Why should they team up with you? Instead of investing, I could spend $100 on some cherry keycaps and make my own layout. What do I gain from helping you? Answer: **nothing**.
I finally understand, it seems you despise my innovation (ShionKeys) 1. Only optimistic about ShionKeys will consider joining, promising ShionKeys will choose to invest, you are not optimistic ShionKeys also asked me so much why ,,, I think you can ignore me. 2. Regardless of whether APL has a real keyboard problem, the birth of ShionKeys has nothing to do with APL, just to contribute to the development of APL, I think APL developers need to publish here. You do not think APL has limited its development due to the keyboard. I can not change my mind, not to mention using emacs for APL development, even with a mouse click on the icon to make APL development possible.
If it has nothing to do with APL, why are you here? I can't have contempt for your innovation because you don't have one. I can have contempt for you, because you are a quack peddling a non-solution to a non-problem. Snake oil is exactly what this is: a pointless change for nobody's benefit, except yours, if you get investors. Look elsewhere.
I made it clear that it happens to be able to promote the development of APL, so posted here. I can tell you clearly, ShionKeys is 100 years, the biggest innovation on the keyboard. If you want to dwarf ShionKeys must find a reasonable reason. If you can not find a reasonable reason to dwarf ShionKeys, the world will see your shamelessness / stupidity. If you can create something better than ShionKeys, I admit that it does not have any innovation, but you can not innovate based on ShionKeys because it is plagiarism. Is it my business where I want to publish the project? If you are an administrator in this section, you can delete it. If you do not have anything, please let go of your shameless, get away You are not very optimistic about ShionKeys, wanton slander, you dare to honor it, vowed never to use ShionKeys, even if ShionKeys become the mainstream of the future, you will not use. Come see if you swear by honor to reveal your true message.
 this is the definition of a shot post
What stops your `void *dat` pointing to other arrays?
So you mean every datum in the array is another array?
Yes. That's how I understand that K does it.
K doesn't do arrays. It simply does lists and internally optimized homogenous lists. 
Point out how ShionKeys garbage
the 3!:1 format in J, http://www.jsoftware.com/help/dictionary/dx003.htm type, count, rank, shape, values.
I see that it works in J, but they don't have nested arrays. 
what’s the difference between nested arrays and boxed arrays?
That's a great question, because on the surface they seem to be the same right? Well, there is a question: a nested array is still an array (as a scalar or in another array), whereas a box is not an array at all: it only contains an array. Here is a bit of code to illustrate what I mean: `1+&lt;1 2 3` So if you expect the result of this J code to be boxed 2 3 4, you're probably an APL programmer, because that's how it works there with nested arrays. But in J, a box can not be mapped over implicitly, because it is not an array: it is a scalar and J does directly apply rank 0 verbs to scalars, so this code fails. 
ah, ok. thanks. but couldn’t you implement it like boxed arrays, yet map like in APL?
I think you could. Thanks for your advice :)
the type "box" (pointer) allows for heterogeneous and nested arrays.
Indeed it does, still it's not the same idea behind nested arrays. 
Yes. There's a website [here](http://kparc.com). If you ask, you might be given a download for it. There's also an open-source variant that's more-or-less the same, [here](https://github.com/JohnEarnest/oK).
What's something you can do in APL that you cannot do in J because of this difference? I don't think they're that dissimilar. I've only been doing this for a couple months, but it seems APL is often inconsistent in user-friendly ways where J favors consistency. J has a built-in `each`, which is defined as `&amp;.&gt;`, and allows you to perform a computation inside each box without changing the structure. (I believe APL's each operator `¨` is actually more like `"0` in J.) I have not found working with boxed arrays that onerous.
1+1 2 3;4 5 does not work in J. In APL something like this works. 
True, but `1+&amp;.&gt;1 2 3;4 5` does, and it says what it does: open all the boxes and add one to their contents, where yours says "add one to these two boxes." Is it a major impediment?
But having to explicitly map is what array languages try to avoid
In practice, wouldn't you either have a rectangular matrix and thus no boxes, or else a more complex data structure you're using boxes to represent? Look at cut/[`;.`](http://www.jsoftware.com/help/dictionary/d331.htm). In J; it's not a verb that returns boxed values but an adverb so you can pass an arbitrary function through. For documentation purposes it's common to use `&lt;` to show what it does, but in practice, you wouldn't need to create the boxes, cut itself would send the values through your function. This is a pervasive pattern in J, where instead of handing you boxes, you hand it a function. Outside the APL/J/K milieu I would say that it's normal for library routines to return complex data structures where in J it's a lot more common for library routines to be customized by your verb so that you _don't_ wind up with complex data structures at all.
It would be this, right? 1+⊂1 2 3, ⊂4 5 2 3 4 5 6 
you'd need parents around the enclose 1 2 3 part though
I got the same response either way.
Thanks, I acutally needed that.
My company uses k3 and we are hiring.
Thanks, that'll help me decide. Thinking about it more, it may have been a dumb question. The version on kparc.com/k.txt is too new to have been adopted by anyone.
KDB does, but you need to map them e.g. using [.Q.Xf](http://code.kx.com/q/ref/dotq/#qxf-create-file).
Most people use K3. Those companies built on KDB+ often use Q and not directly K4. In fact, I experienced that K4 seems to not even be made for direct usage, because it lacks some pretty important verbs you have to take from the .q namespace (.q.rotate or .q.mod for example). K5 and K6 are the same language though both aren't yet ready to use. They are part of kOS which in itself is not yet finished. So if you want the full K experience K3 might be the most valuable, if Q satisfies you, go with that. 
Most companies using KDB use q, which is built on K4. If you actually want to do K, not Q, it's mostly K3 I think, because K4 isn't documented. You can also pick up some basics from this old k2 reference: http://www.nsl.com/k/k2/k295/kreflite.pdf and also from the q prompt if you type a single backslash it takes you to a K prompt. You can see the K4 version of q verbs by typing them on the prompt, for example "where -&gt; &amp;:".
k5/k6 are WIP and were never released to the public. They're two names for a continuous progression of tweaks, experiments and refinements. The intention is that k7 will be most similar to k6, and k7 will actually ship as a commercial product, but it's unclear how long it will take for it to be completed and adopted industrially. If you want a job in k right now your best bet would be to learn with Q/k4. (I will say that k4 is by far my least favorite dialect.)
What company?
http://code.jsoftware.com/wiki/Essays/DataStructures Apparently I didn't look hard enough. I would appreciate any other resources that might be slightly more difficult to find.
Have you tried building from source https://github.com/jsoftware/jsource?
For nested data you can use either lists in K, or nested arrays in APL. That way you can design a binary tree like this: [ key value [key value ...] [key value ...]] As for graphs there are many ways, but I usually give each node a unique id and place all of them in a single vector (the graph).
Some time ago I wrote a paper about tree representations in K. It rambles a bit, but might contain useful ideas: https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Trees.md
I would consider it, it’ll make an opportunity to learn how to build a program from source...
Aside installing apt via yum, maybe the best way is building from source.
(The below is from a J perspective, but it at least some of it probably applies to APL's nested arrays and something in K) In J, you'd typically represent an ordinary tree as an array of boxes (which themselves may contain boxes, and so on). The "Learning J" book has [a helpful chapter](http://www.jsoftware.com/help/learning/32.htm) on some ways you can process them. In short, check out these primitives: * `{::` - fetch an item or subtree * `L.` - get the depth of a tree * `L:` - apply a verb at a certain depth and return the results as a tree, analogous to `"` * `S:` - apply a verb at a certain depth and return the results as an array (that is, without the rest of the tree) Of course, these are all operations on immutable trees, which means you can't really make a graph with them, and I don't think J supports the same situational in-place updating for nested boxes as it does for flat arrays. You can probably just represent a graph as a matrix or adjacency list as you would in any other language, but if you really need a physical representation of the graph or making a copy of a tree for every operation won't cut it for you, you can do something ugly with locales to get a truly mutable graph of nodes. Basically, for each node in the tree, allocate a (numbered) locale with some name in it that refers to the data, and have it hold the ids of other numbered locales for referring to its children. NB. initialize tree contents root =: cocreate'' data__root =: 7 left__root =: cocreate'' data__left__root =: 5 right__left__root =: cocreate'' data__right__left__root =: 6 right__root =: cocreate'' data__right__root =: 10 yuck. If you don't know J, `x__a` refers to the value of the name `x` in the locale indicated by the contents of `a`. You can think of it as `a.x` in an OO language (and so `right__left__root` is `root.left.right`). Now you can do something like NB. increment every value in a tree in-place increment =: 3 : 0 data__y =: 1 + data__y NB. check that each child is defined before descending if. 0 = nameclass &lt;'left__y' do. increment left__y end. if. 0 = nameclass &lt;'right__y' do. increment right__y end. ) yuck. But now `data__right__left__root` is 7. Furthermore, NB. makes root its own right child, turning this into a bona fide graph right__root =: root Calling `increment` on `root` now would result in a stack error. Array data is (conceptually) immutable in J, but names can be reassigned, which makes them *basically* pointers. I don't know anything about the performance of this approach. It's probably really bad. All this said, array languages tend to be happiest when they're performing uniform operations over lots of flat data, so try to get away with that if possible
Well, the build instructions are already in the source (check out overview.txt).
My point-free J BST implementation is quite short (12 lines) and not too unreadable (it has comments). Maybe it can help you: https://github.com/robknows/Algorithms/blob/master/J/binarySearchTree.ijs I modelled a BST as 4 boxes: |left-child|key|value|right-child| where leaves had empty children. It's basically the same as nested lists, but uses boxes for nice J formatting If you load up that script I linked you can see it work. The comments show usages for each function. rob@computer:~/...$ ijconsole binarySearchTree.ijs 7 4 2 3 1 6 9 5 p 'abcdefgh' NB. Boxed structure here - it doesn't copy/paste well
I would love to buy one for myself, but as a student, I cant afford $100+ or more for a tool I might use some times. plus Dyalog APL is free for students and really good.
I used HP3000 APL in 1980's. Since we had only two terminals with symbols, I got used to the ASCII equivalents. It was no big deal. J uses them logically, and has been the least of my problems. I'm more annoyed of some other syntactic oddities, like unpacking by assigning to a string of symbols. 
Unfortunately the J compiler does not seem to support Unicode in source. OTOH IMHO there are worse problems, such as the horrible explicit function definition syntaxes.
If you are interested in some more ways of generating Fibonacci Numbers in J: http://code.jsoftware.com/wiki/Essays/Fibonacci_Sequence
nitpicking comment on notin definition, 1 2 3 -. 2 4 5 6 1 3 (i.3 2) -. i. 2 2 4 5
Is Kona used in the wild?
I removed notin. Thanks!
Want to learn KDB and get paid? My company is looking for engineers who we can train. If interested, PM me.
How about NARS2000? 
Klong is similar to K, but I claim that its syntax is a bit simpler. It uses the ASCII alphabet and is very portable (runs on basically anything providing a C90 compiler). It has bignum arithmetics, decimal-based floating point numbers, and a statistics and plotting library that uses Postscript as a back-end I'm actively working on Klong and reply to questions and bug reports whenever time permits. URL: [http://t3x.org/klong/index.html](http://t3x.org/klong/index.html) 
What I am most interested in, maybe to your disappointment is speed. Does Klong utilize CPU/GPU where appriate? How does it compare to K regarding performance? Can I compile Klong programs into standalone binaries?
I'm not the author, and I don't have a copy of k to compare performance, but I can answer your yes/no questions with "no". &gt; Does Klong utilize the CPU/GPU where appropriate? No, [Klong](http://t3x.org/klong/index.html) is single-threaded, and does not utilize and GPU features (unless you compile it with a fiendishly clever C compiler). &gt; Can I compile Klong programs? No, Klong is built on [s9core](http://t3x.org/s9fes/index.html), an interpreter that the author also wrote (and wrote a [book](http://t3x.org/s9book/index.html) about). However, the binary is **really tiny**. On my 64-bit linux system, running "make &amp;&amp; strip kg" results in a standalone, 211KB executable. You could easily bundle this interpreter with your scripts into an executable. Besides its syntax, the best feature of Klong (IMHO) is its brute simplicity and openness. According to "cloc", Klong + s9core is just shy of 10,000 lines of C source and header code. For a featureful, garbage-collected language, that's pretty good. It's also generously licensed in the public domain. Mr. Holm has also written that [book](http://t3x.org/s9book/index.html) about the design of the interpreter. It's a really neat project to look at "under the hood".
Just found your main site with all those awesome books. This looks like a good addition. If you ever get around to it, you should write a book on Forth some day as well as your own Forth in C or your own interpreted language. I've always wanted to learn Forth, but despite lots of good reference material such as JonesForth and Leo Brodie's book, I need something a bit closer to your books that are closer to a more direct textbook. What got you into array programming btw? My personal journey (I'm just starting to learn APL &amp; J) is due to needing to write lots of throwaway code and getting sick of writing endless for-loops.
Here is an [introduction to statistics (and plotting) in Klong](http://t3x.org/klong-stat/index.html). Also, the plotter library (nplot) has its own entries in the help system, so you can just load the plotter module and use the ]h command: ]lnplot ]hplot However, it will only explain individual commands. The above introduction is much more elaborate. Alternatively, use the interactive plotter interface. E.g.: ]lvplot v.plot({x^3}) vh() It does not have as many features as nplot, but is self-explaining and sufficient for simple plots. The last line above prints a summary of the interface. The vplot interface requires Ghostscript and gv on Unix. 
Brevity. I find that typing and reading code distracts me from solving a problem. Klong allows me to put the focus on the mental part of the process instead of the mechanical part. My journey began when I noticed that I had lost interest in programming languages, so I looked for something different. I found a document on K, found it highly interesting, remembered some very distant APL from a shop where I had worked once (green-on-black APL on a mainframe terminal, pretty cool!), and so I got started. :) Regarding a Forth book: I'll keep it in mind! You have probably noticed the various Forth systems on my home page.
Yeah I would put "needs dfns" *way* ahead of unicode support in source code, and all the other gotchas that creates.
I believe Kerf failed, not sure if authors have future plans for it. 
There is also GNU APL (https://www.gnu.org/software/apl/), the development is quite active, with the aim to be compatible as much as possible with IBM APL2. It is quite mature, but no binary releases, better to checkout from SVN and compile by yourself. It also has a great support in Emacs https://github.com/lokedhs/gnu-apl-mode/
We used it before and still do. I know they support it for us. NOt sure if they do for "new" customers.
Sounds like he is frustrated that he needs to learn programming in a new paradigm. I can understand that. It's incredibly frustrating to be a beginner all over again. But it does pay off getting over this stage.
I'm also a beginner and, while I relate to the just-learn-it-newb attitude, I find the k community particularly hostile to helpful documentation. It's willfully exclusionary, which I can sorta respect, but I've been stuck just experimenting with different forms trying to figure out what they do; the result of which is that I've had to back burner really learning k because I don't have the time to invest so fruitlessly when there are so many other useful things I could learn. Now it only gets a timeslice in a particularly long grocery queue or the like.
k3 had decent enough documentation back when it was official, and Q’s documentation is actually pretty good (though the actual language is barely accessible to hobbyists). I don’t really know what the situation’s like with the open source Ks, though, which is presumably what you’re complaining about.
Some of these things already exist, and the fact that the author didn't find them indeed shows that they're not visible enough. &gt; label the useful primitives for a problem domain Check out [phrases](http://www.jsoftware.com/help/phrases/contents.htm). &gt; create a library of useful components Check the [standard library](http://www.jsoftware.com/help/user/library.htm) or [JAL](http://code.jsoftware.com/wiki/JAL) although I would agree that the JAL is not very easy to explore 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://code.jsoftware.com/wiki/JAL) - Previous text "JAL" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20duzgszg) 
bad bot
Thank you hoosierEE for voting on FatFingerHelperBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Any instructions on how to make it work on Windows?
32bit q has been available to download (for free) for a number of years: http://kx.com/download/ It's more than accessible. 
There's some examples of doing parallel tasks in J in the wiki, for example [parallelize](http://code.jsoftware.com/wiki/User:Marshall_Lochbaum/Parallelize). There's also some [threading examples](http://code.jsoftware.com/wiki/User:Oleg_Kobchenko/Threads) there. Nothing as nice as Dyalog's futures that I know of.
recent zeromq addon is a good resource.
If the symbol aspect is not an issue I say really easy. The whole point is you can "read" the language. It has verb's nouns adverbs etc. Makes it flow and make sense.
I'd say q is easier for having fewer features. Narrower domain applications than J, and less consistent. Probably, deep knowledge requires knowing k. (q is a k application more or less). Similar criticism apply to k. J s more open if that matters.
Learning K is complicated by the degree to which it's become fragmented. k3 was the old official kdb language but has been unsupported for a long time, k4 is the implementation language for Q which is totally undocumented and stripped down to only what's required for that purpose, k5 and k6 are mysterious prototypes that Arthur Whitney holds close to his chest, oK and Kona are open-source 3rd party languages based on k5/6 and k3 respectively. It's a bit of a mess, frankly.
Yeah, and it's up to informally k7 now I believe. It goes by snapshots/releases. I am not sure why aw is so insistent on making it closed and proprietary or a lot more could be done. The implementation seems to be nice and performant, unlike the fragmented open source implementations. So I tend to agree, although K variants are simpler and more uniform languages than J, J is at least one unified whole. And most people use Dyalog APL for APL.
Thanks for the replies. I actually like the symbolic nature of APL, and Dyalog APL runs well on my Mac. J seems more comprehensive though and has a decent community and ecosystem around it. I'm still getting my arms around K/Q/Kona.
Hi
Hi
&gt; Wider adoption, bug reports, bug fixes and other improvements "certainly wouldn't help quality"? No, they don't *certainly* help quality: There exist examples of quality open source projects, but most open source efforts are of low quality, *especially* in this space. "Open source competitors" like cloudera and mongo are slower and buggier than K, and maybe this makes sense, given that many of their users are consultants whose job it is to fix and workaround problems with cloudera and mongo. &gt; I don't see the point in chaining it up so nobody can use it or improve it. I think you need to reverse your thinking: What's the argument for opening it up? *Would* that improve it? Would Arthur think so? I can extend kdb with features I think are useful using [2:](http://code.kx.com/q/ref/filenumbers/#dynamic-load) or using `LD_PRELOAD`. If I can convince Arthur or Charlie it is useful then they come up with a better implementation that is aligned with the other things they want to do.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://code.kx.com/q/ref/filenumbers/#dynamic-load) - Previous text "2:" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Well I could compile it for "unsupported" platforms. That'd be nice.
["Should array indices start at 0 or 1? My compromise of 0.5 was rejected without, I thought, proper consideration." -- Stan Kelly-Bootle](http://wiki.c2.com/?WhyNumberingShouldStartAtZero)
Hi
Try this: Values←'0123456789abcdefghijklmnopqrstuvwxyz' Values[?3 3⍴⍴Values] ? returns a random value in the range 1-⍵, so you need to generate random indices in your 3×3 array, the maximum being ⍴Values. You can then get the actual random values using normal indexing.
`?` has a monadic and dyadic form. In the monadic form, `? N` will return a random number from `[1,N]` or `[0,N-1]` (if index origin is set to 0, 1 is the default). ? ⍴Values 14 You can also put a vector or array on the right hand side to get multiple random numbers with repetition allowed: ? 36 36 25 2 If you want 9 random values you can use: 3 3 ⍴⍴Values 36 36 36 36 36 36 36 36 36 To get 36 nine times. Put the `?` in front and you get: ?3 3 ⍴⍴Values 6 21 6 16 33 25 17 17 5 And treating those as an index back into Values (as u/deltux has done): Values[?3 3 ⍴⍴Values] pew zxh hzl Note that this allows repetition. If you want 9 *unique* values you want to use the dyadic form. `M?N` will return `M` unique values in `[1,N]` (same caveat as above if you've changed index origin). `M≤N` must hold, if `M` is greater than `N` you'll get an error. So we can do: 9?⍴Values 29 6 25 21 2 24 22 13 11 No repetition. To get it into a 3x3 we can do: 3 3 ⍴ 9?⍴Values 11 27 8 23 36 2 3 33 34 And again using those as an index: Values[3 3 ⍴ 9?⍴Values] d75 asm ygk === `3 3 ⍴ ScalarValue` will always produce 9 copies of the same thing. `⍴` will take as many values from the right side as needed to fill the shape specified on the left (here that means `3×3=9`). Since there aren't enough items it'll repeat that one thing 9 times, if there are too many then it will drop everything after the first 9 (in this example). 
I have not been in your shoes, but I'm guessing that the primers and "J for C Programmers", while excellent resources, may also annoy you. You might just start with http://code.jsoftware.com/wiki/NuVoc which is a really great entry point and daily reference for J beginners. You can see all of J's primitives (apart from those buried in Foreign), see examples of use, and find links to the official Dictionary reference.
And then there's J for APL http://www.jsoftware.com/papers/j4apl.htm which I haven't read but is aimed at you.
Related: I'd love to fill out Stack Overflow with more J questions, especially since that's where I discovered the language. Please feel free to ask novice questions, as they'll probably be useful to someone else: https://stackoverflow.com/questions/tagged/j
To me, K was the easiest to learn as it is not so "alien." It has a fixed set of predefined verbs and adverbs (no conjunctions) and does not allow you to define new ones. Instead there is a function datatype that is as first-class as all other scalar types. Q is really just syntactic sugar atop K4, so there is no difference in difficulty (unless you have issues with remembering words). Other than K4 however, Q's wordiness allows you to hack in own "primitive" verbs (although it is highly discouraged). APL and J are very similar, however J is more pure. For example, in Dyalog you can implicitly create boxes by juxtaposing elements ('ab' 'cd') and even implicitly map over boxes (1+b). J enforces explicit boxing. While I prefer APL-style for actual programming, J really helps understanding the concepts more. J also forces you to understand rank, whereäs in APL you can get away without it. Hence I think J is the better teaching language (although I much prefer APL).
Nice. I actually think we should post more code snippets like this on the sub, since it's nearly dead anyway. Maybe we could make a "week of code" on /r/apljk.
love the whitespace idea, and the forks, and composition replacing hook interpretation. not so sure (politest version possible) about 3 4 5 4
I had a quick look and it seems really neat. I'm not sure if /u/Categoria and mlochbaum are the same person but I have some questions: 1) Am I right to think that you'd have to rely on the language implementer for tree-based data structures that store sequences of values? My impression was that the built in behaviour of mapping would prevent traversal of values as though it was an array. 2) This seems to be a functional programming language. Is it designed just for mathematical calculation with no side effects, or does it have a purely functional way of defining side effects like e.g. Haskell, or does the programmer just have to know which functions are impure and use them appropriately?
unlike j, that is not a single token. 4 is interpreted as a "constant verb" and 2 dyad arguments.
hi-quality post...
I believe the thinking is "everything is dyadic" can make mental parsing be single-rule based, and even with machine context, even/odd can be an easy context mapping device. Still, though, there are 2 seperate issues `3 4 5` vs `3 , 4 , 5` vs. (not positive this equivalent due to white space `3, 4, 5`. I'd prefer the first version be considered a single token. regarding `n0 n1 n2 -: non-error` the question is not just whether its a bad idea, but what's the best non-error result. The list or boxed list of the 3 items are reasonable candidates. All 3 options can be implemented with adverbs "argumented" to n1. The gotcha example for white space in the doc trips up this. An error is ok. Boxed list auto-construction would be a good debugging tool.
The precedence-through-whitespace idea is just beautiful. One of those ideas that made me sit back and think about how elegant it is. 
Production-quality as in being usable for real work. Performance hence is important but APLs usually don't struggle with that. As for portability, I think it should run across all major desktop and server platforms (Linux/Windows/MacOSX). oK and Ivy both market themselves as experimental APL systems and are thus out of the race.
If I'm reading the website right, A+'s source code hasn't been updated since like 2002, so it would probably need significant fixes to work on an up-to-date system with up-to-date compilers. If that's the case, it also might not have support for 64-bit systems, and major parts of it might have to be rewritten to support that, as had to be done with [Q'Nial 7](https://github.com/danlm/QNial7). Granted, I haven't really looked at the code myself, so I'm not absolutely sure about the exact fixes needed, but I have attempted to compile it in the past and it won't compile on my system without some potentially major changes, at least. *That being said*, it could still be a good reference for specific features or even a solid foundation, depending on the amount of work it would take to fix it up, granted the fact that it's GPL'd isn't an issue.
Thanks for sharing this. I was just looking into Klong the other day and this is a great extra reference.
I think maintaining a legacy C codebase is not quite what I want. Starting from scratch in this case is really the simpler thing to do. 
Yep, got it. This example was a 'teaching point.' This lesson is driven home by the fact that unbalanced spaces result in function invocation of " ".
Reading `?@:$` as "shape of random" is a bit unfortunate. "Shape of random indices" is nice, but that's an interpretation. Literal reading of `? @:$ #` would be "roll on reshaped tally". After this though you can conclude that rolling on a tally results in a random index, so the result of the entire thing is indeed a shape of random indices. 
Ah, that's super helpful. As I said in the article, I'm definitely still trying to wrap my head around a lot of this. I've had trouble expressing `@`/`@:` in words. I understand how it works, but the name "at" didn't intuitively fit for me. Making the connection that "shape" is the same thing as "reshape" is obvious but helpful too. I hadn't thought of that. "Roll on reshaped tally" makes much more sense. Thanks!
Got it, but already started learning J. Feel like it's going to be too confusing to learn K. Anyone know both? If I'm going to learn K, then there better be a job at WallStreet waiting for me with ridiculous bonus. :D BTW, the license is valid only for a year.
There are plenty who know both; if you know either, the other is not hard to pick up. More time and effort will go into learning and debugging performance anyway than struggling with the languages in my experience. In k/kdb everything is crazy fast until it is not and that can be a time-sink. The semantics and the the syntax you get used to quite fast, again, in my experience. 
Why UTF-16 instead of UTF-8?
I still have to think about it, but UTF-16 makes a lot of glyphs only 1 codepoint.
But you still have to correctly handle the glyphs that are encoded as multiple units, and at that point you're better off doing it properly with UTF-8. That or go for an actual fixed-width encoding, i.e. UTF-32. UTF-16 is the worst of both worlds and should never be used.
I'm most familiar with J, but I agree it's also the most "alien" compared to mainstream languages (once you get past the symbols in APL). My dream language is basically K3 with some tweaks: - lexical closures - J's rank conjunction - J's "Key" operator (`/.`)
One person's "dead reddit sub" is another person's "high signal-to-noise-ratio reddit sub".
Would you say then that such code samples would consist of noise?
That and leaving away some features literally nobody uses (monadic : for returning). Also in my dream K all words starting with _ are verbs, but they can also be user defined. _v:{x+y}; 2 _v 3 I'd also remove "f x -&gt; f[x]" syntax in order to add general "a b c -&gt; (a;b;c)", so that 1 2 3 works, but 1 2 x does so too.
I gave a [talk about J](http://www.youtube.com/watch?v=IKfJRyoiBlY) 2014.
Certainly not! /r/apljk has 689 subscribers, /r/programming has over a million. So there's quite some way to go before the S/N ratio gets bad. Carry on with the code samples. :)
I got all of that, but what do you mean by `1 2 x`?
Well in my ideal dream K without f x syntax, 1 2 x would mean (1;2;x). I'd just use juxtaposition differently to mean list.
I think I get what you mean. Like in J, you can create an array with whitespace and literal values: `1 2 3` but not so with variables: 1 2 3 1 2 3 a =: 1 a 2 3 NB. error a , 2 3 1 2 3 
Indeed and that sucks imo. Also "f x" is 3 chars just as "f@x." It seems like wasted potential for what could be done with juxtaposition. 
You can't do that in a vector, and you can't really do it in a scalar either because of alignment issues.
Glad to know you found it useful. Just try to not imitate my line breaks and formatting :D klong is great! i hope it sticks. 
If you choose Python or Javascript, you'll lose concurrency before you even start. Performance and linked lists are not going to mix nicely, either; people doing APL-like things in Python are using Numpy, which gives you a classic array/matrix structure. You're going to want to worry about GPU processing from day one, so I would follow that line of thought wherever it leads, probably to lower-level systems like C or Rust. I would build my environment on IntelliJ and make sure the plugin is evolving concurrently with the rest of the system (but could go for a "language server" alternative if you're more windows-oriented).
It takes quite a bit of work to set up an input for `;:` that will do something useful, but once you do, it will basically evaluate a state machine for you, and there are a number of "modes" you can run it in to do something useful. I used it once to implement the [Mars Rover problem](https://withouttheloop.com/articles/2015-04-17-mars-rover/) and felt like something cool had happened. But it does take some work to set up, for sure.
While it's not a k interpreter, there is [b](http://kparc.com/b).
If you choose Python or JS you lose parallelism, not concurrency. Besides CPython can do real parallelism nowadays too, so your statement only applies to JS. Oh and where did I say anything of linked lists?
Sadly it is. You can check out A+ sources though. 
sure, see [Kona](https://github.com/kevinlawler/kona)
Source for CPython and real parallelism? Nothing has changed lately to my knowledge. &gt; PS: The language will use lists instead of arrays
Still failing to see why you think this would be better than just using the UTF-8 encoding which essentially does this.
a scalar character can't always be 8 bits. sometimes it just doesn't fit. utf 8 is a valid way to represent strings, but not for characters. 
import multiprocessing Lists as in K.
I've got it to compile on an x64 Ubuntu 16.04 VM, and squinted at the source code for a while. There are some curiosities. For example, instead of including C standard library headers it provides its own versions of read, write, malloc, free, etc. There's also no `main` function. Instead, there's a `_start` which loads something (?) into some registers and then jumps to what I consider to be a REPL/prompt. My assumption is that these design choices are for speed, but I am not fluent enough in the low level stuff to understand the *why* of it. I downloaded a snapshot a while ago and put my thoughts in a repo [here](https://github.com/hoosieree/b), and would be happy to discuss. It's certainly interesting!
Sure. We can just fork another interpreter whenever we need to do two things.
I know of them, but APL end-users shouldn't have to. 
at this point I believe all repl capable languages should come with an IRC bridge built in.
thanks for the info + links, y, be great to discuss, this could be a real gem, hope to look into over weekend and post back
Slack is too verbose for this group. There's #jsoftware on IRC free node tho.
How much effort do you reckon this will take? I'll like to see J in SWI-Prolog.
A lot :D J in SWI-Prolog? Why swipl?
that's a cool idea!
You can join this Slack group: http://www.dyalog.com/forum/viewtopic.php?f=12&amp;t=1024&amp;hilit=slack
I figure what J is to APL, SWI-Prolog is to Prolog. SWI-Prolog besides being free, broke free from some of the rules of ISO Prolog to make it much modern. Great for rules, basic list manipulation is okay, but terrible at that. APL is a perfect fit, APL is not great for one of line by line rules. Seems like a match made in heaven.
Isn't B already the name of C's predecessor?
A good place to start might be [buddy](https://github.com/tavmem/buddy/blob/master/a/b.c). This file has 2 versions of the "buddy space allocation" system. The first version was written by Arthur and consists of 11 lines. The second version was Morgan Stanley's baseline version, written in traditional, well documented C, and consists of almost 750 lines of code. Since both versions do exactly the same thing it's sort of a Rosetta Stone.
I envision a mix between slack and jupyter for i/j/k. Would like... Chatting and coding with friends...
that's very plausible, and both are very very trendy, so a bridge would not be that surprising nor too hard (considering how much they did already)
same, I still prefer some tiny emacs thing 
Dfns in Dyalog are essentially lexically scoped. In your examples, #1 would use the outer defined `A` would be used, then after you have shadowed `A`, #2 would use the redefined value. If you look in the [Dyalog Programming Reference Guide](http://docs.dyalog.com/16.0/Dyalog%20Programming%20Reference%20Guide.pdf), Chapter 2 has a subsection on Dfns and Dops. The Dyalog web site has a whole section of downloadable [documentation](http://www.dyalog.com/documentation_160.htm) in PDF files that is quite extensive.
Thanks for both the concise answer and the pointers to reference material. That's exactly what I was looking for!
No problem. Happy to help!
I have been wondering this myself
When talking about monads like this, it's important to note that the key thing that haskell (and others following haskell) offer is an abstraction *over* monads: the key thing is that the `Monad` typeclass is an object in the language. You can clearly write monads in any language: it is just a pair of functions, `bind` and `return`, and we can implement and use them (and therefore make use of haskell-style machinery, although we lose any syntactic niceties). For lists, there are some obvious definitions: `return:,:` and `bind:{,/x'y}`. This question then becomes 'do any APLs offer abstraction over typeclasses as a language feature'. I don't really know the ins and outs of APLs other than k, so I can't give a conclusive 'no', but I very much doubt that others have this sort of thing hidden somewhere.
By using gerunds as an argument I think it would be possible to control the how a "sequence" of operations are interpreted.
I'm stronger in Haskell than APL or J, but I think the answer is no. APL and J are also fairly disposed against the kind of structural abstraction it would take to deploy an FP-style monad. Even if you did, it would be like applying them to Python; in a particular context, maybe it would be useful, but systematically doesn't seem greatly beneficial. On the other hand, APL etc. users seem to have a great fondness for algebraic reasoning, perhaps even more pervasively than in mainstream FP. [A History of APL in 50 Functions](http://www.jsoftware.com/papers/50/), section 2, presents the kind of proof you often see in Iverson's work, I'm sure other examples abound. More algebra, less category theory.
Hi, you can check out my APL blog. I just made a post yesterday. Blog.alexweiner.com
Nice to see you here and not just on Twitter :)
If I only knew who your we're on Twitter lol
Nice 😆
There's a compiler (x86_64) and an interpreter (commented out).
Some algorithms are easier/better to express in an atom language; array languages do not take easily tight turns. There's no C/lib deps because that's a major bottleneck in performance. Porting a program isn't very difficult if there isn't very much to port. The reason code is written densely is so that you can see more of it on one screen.
J's key is: `@=` in K (although the arguments are backwards) One negative about lexical closures is IPC.
&gt; Do you mean that IPC is made more difficult by adding closures to the language? Yes. In Q/kdb, you will often send queries to another process: hdb({select from foo where date in x, bar=y baz};x;y) In this situation, the function "y", if it closes over any values, will need to have those values copied over to the remote system. Any changes to those values will then need to be copied back. This works if both processes are single-threaded, but breaks down if the caller is multithreaded. &gt; how do K programmers deal with statefulness? Lots of ways. Firstly, by avoiding it, and then later: * with a global table: just an upsert to change state, keyed to a channel or to a symbol allows the programmer to inspect the state easily, without being inconvenient at all. (this is the local state in the namespaces bit, but requires tables and queries to be easy) * the actor model is a good fit for q/kdb: Each process is an object and messaging mutates. This is not common at all in J. * with dynamic scope: programmers will make enter/exit routines representing the dynamic state and call them to set things up. This works because q/k has lambda (not easy or common in J) 
&gt; the actor model is a good fit for q/kdb: Each process is an object and messaging mutates. I was not expecting that! Are you talking a small handful of long-lived processes, or something more Erlang-style with a few long-lived processes and lots of shorter-lived ones?
Both, but usually more of the former simply because of a lack of built-in machinery in q/kdb. I know one big kdb+ user who had a java-based "daemon" that can be commanded to start up various processes in workflows programmatically. This has the short-lived, but means they usually come from a process template (think "class", like "rdb", "tickerplant", "hdb", etc) k5 has a `2:` operator which creates additional k processes. This makes short-lived map-reduce very easy, and requires no templates. Someone posted a fork+exec C module (like popen) to the listbox a while ago that I assume is for starting a few non-q processes but could just as easily be used to start more q cores.
Atilla's q implementation is shorter and IMO easier to read than this J implementation: r:5 5#0000000100000100111000000b life:{3=a-x*4=a:2 sum/2(1 0 -1 rotate'\:)/x} {show x:life x;-1"";x}/[r] 
This is really great! Some of the most lucid explanations of J programming I've ever seen.
Thanks, alanturingslovechild. 😃
You can use []XML representation of Dyalog APL, or just a matrix representation of the tree using boxing/enclosing, not sure how it's called now.
Is this convenient to work with?
As usual, it depends. If you really need complex trees, there's actually not much choice. If it's just couple of levels, I would come up with something more simple like matrix, where one column is the key, and other consists of vectors of the values you want to get by the key.
K uses that approach:`(+;2;(*;2;3))` try: q)-3!-5!"2+2*3" "(+;2;(*;2;3))" SA seems to collect [a lot of articles about parsing](http://nsl.com/) in K(ish) languages. J has the [sequential machine](http://www.jsoftware.com/help/dictionary/d332.htm).
Comments [here](https://news.ycombinator.com/item?id=17506789).
came from HN, this pdf is superb
I used it in 1980's. 
Very well written! I like how you contrasted it with Lisp and you were honest about the APL-family's strengths and weaknesses, with respect to individual dialects. Also the breakdown of the commonly-cited game of life is very well done, not to mention intriguing!
&gt; So the six character excerpt !'\:/: would let alone be equivalent to something like (lambda (v m) (map (lambda (w) (map (lambda (x) (map (lambda (u) (rotate x u)) w)) v) m))) in a Lisp. Most programmers would look at this as a problem to be solved by abstraction, and make the rotate-map into a function. But abstracting, whether as functions or libraries or frameworks or whole languages, involves learning new ways to do things. When the abstractions are well-designed this is intuitive and helps guide you. Otherwise it's frustrating. APLs offer an alternative technique in addition to abstraction. Often, it's shorter to write the implementation (as in `!'\:/:`) than any meaningful name you could assign it to. Avoiding abstraction can sometimes be a better choice, but it's still a trade-off. You lose what the code "should" do by not giving it a meaningful name, but you gain what the code *actually* does, because the implementation is right there, with no hidden assumptions, side-effects, or dependencies. This article does a good job showing how these traits make APLs different from conventional verbose languages.
Very interesting comment. Your observations almost remind me of assembly, albeit we're on a much higher level here.
&gt; Syntactically, ergonomically, and conceptually, the tools just didn’t jive. I think you meant "jibe" here. Do you have further ideas for this little program? I'm interested in what specific advantage J might have over other contemporary options.
Wasm is more like a target architecture than a thing you need to port to. It might be possible to simply compile with the wasm target, at least for things that build with LLVM-based compilers like clang. But I don't see this as a major impediment to uptake of APL/J/K, compared to everything else.
&gt; But I don't see this as a major impediment to uptake of APL/J/K, compared to everything else. This is quite true. Yet, having wasm support *might* give them a moment in the spotlight. It's a bit of a longshot though.
J is open source; you could try building it with clang's wasm backend and see what happens.
There's an [emscripten'd compiled version of J here](https://joebo.github.io/j-emscripten/). Described [a bit here](https://code.jsoftware.com/wiki/NYCJUG/2014-12-09#Emscripten_Version_of_J).
nice article
I think this is also an issue with J. It's easy to fall under the impression as a beginner that everything is done with hooks and forks and no named arguments, but if you look at the contributed code, a lot of it is multi-line functions with explicit variables.
Exactly. This is why I'm doing this. Do you want to share some of that code here? I could look for it my self, but I would enjoy to see your pick of a nice example.
I'll see if I can come up with something this weekend.
Great thank you :)
I'm sorry if our misguided enthusiasm comes across as propaganda, that is valuable feedback. It is absolutely correct that most of the production APL code out there looks much more like other programming languages than you might expect from the marketing, which probably focuses too much on how APL is different. As an example, I have attached the source of the "LoadSQL" function which you can find in our distributed workspace "loaddata". r←LoadSQL args;columns;sql;source;step;conn;⎕IO;⎕ML;connected;eis;cursor;data;z ⍝ Load Data from a (datasource) (tableorquery) (columns) mkrom 2009 ⍝ If simple, datasource can be the name of an open connection, if nested ⍝ it is expected to be a valid right argument to SQA.Connect ⍝ ⍝ If sql contains a single word, it is assumed to be a table or view name ⍝ If empty, return database catalogue ⍝ ⍝ If columns is not empty, used to restrict the output columns ⍝ ⍝ Examples: ⍝ ⍝ LoadSQL 'Northwind' '' 'TABLE_NAME' ⍝ Return table names from the catalog ⍝ LoadSQL ('MySQL' 'pwd' 'user') ... ⍝ LoadSQL 'Xtreme Sample Database 2005' 'Orders' ⍝ fetch all records in table 'Orders' ⍝ LoadSQL 'Xtreme Sample Database 2005' 'Orders' '?' ⍝ fetch all info for table 'Orders' ⍝ LoadSQL 'Northwind' 'Products' ⍝ Fetch the entire Orders table from the NorthWind data source ⍝ LoadSQL 'Northwind' 'Products' ('ProductName' 'UnitPrice') ⍝ Fetch 2 columns ⍝ LoadSQL 'Northwind' 'select first(ProductName), sum(Quantity) from "Order Details" O, Products P where p.ProductID=o.ProductID group by p.ProductID' ⎕IO ⎕ML←1 0 eis←{,(⊂⍣((0≠⊃⍴,⍵)∧1=≡⍵))⍵} ⍝ Enclose if simple and not empty (source sql columns)←3↑(eis args),⍬ ⍬ ⍬ connected←0 :If 9≠⎕NC'SQA' ⍝ Bring in local copy of SQAPL if not present ⎕SHADOW'SQA' ⋄ 'SQA'⎕CY'SQAPL' :EndIf step←'Initialize SQAPL' →(0&lt;1⊃r←SQA.Init'')⍴ERROR step←'Make Connection' :If (⊂source)∊conn←⊃¨2 2⊃SQA.Tree'.' ⍝ Already connected conn←source :Else source←eis source conn←1⊃((⊂'LoadSQL'),¨⍕¨⍳1+⍴conn)~conn →(0&lt;1⊃r←SQA.Connect(⊂conn),source)⍴ERROR connected←1 ⍝ Since we made a connection, remember to close :EndIf columns←eis,columns :If 0=⍴sql ⍝ No table name or SQL statement: Return catalogue step←'Read Catalogue' →(0&lt;1⊃r←SQA.Tables conn)⍴ERROR r←2⊃r :If 0≠⍴columns :Trap 0 r←r[;r[1;]⍳columns] :Else r←1 'Unknown columns' ⋄ →ERROR :EndTrap :EndIf :Else :If 0=sql+.=' ' ⍝ No blanks in SQL statement: It's a table name? :If 0=⍴columns sql←'select * from ',sql :ElseIf columns≡,⊂,'?' ⍝ request for column list r←2⊃SQA.Columns conn sql'%' ⋄ →DONE :Else sql←'select ',(1↓1⊃,,/',',¨columns),' from ',sql columns←⍬ ⍝ No further selection :EndIf :EndIf step←'Prepare Statement' cursor←2⊃SQA.CursorName conn →(0&lt;1⊃r←SQA.Prepare cursor sql)⍴ERROR step←'Execute Statement' →(0&lt;1⊃r←SQA.Exec cursor)⍴ERROR step←'Fetch Data' →(0&lt;1⊃r←SQA.Fetch cursor)⍴ERROR data←2 1⊃r :If 0≠⍴columns →(0&lt;1⊃r←0 SQA.Describe cursor)⍴ERROR r←1 1∘⊃¨2 2⊃r ⍝ Column names :Trap 0 data←data[;r⍳columns] :Else r←1 'Unknown columns' ⋄ →ERROR :EndTrap :EndIf r←data z←SQA.Close cursor :EndIf DONE: :If connected ⋄ z←SQA.Close conn ⋄ :EndIf →0 ERROR: ⍝ Bad return code should be in r :If 2=⎕NC'cursor' ⋄ z←SQA.Close cursor ⋄ :EndIf :If connected ⋄ z←SQA.Close conn ⋄ :EndIf ('Error ',(⍕r),' at step ',step)⎕SIGNAL 11 
Thank you a lot for the function. Your marketing actually isn't bad as it got me to take a look at APL. It shows the very mind blowing aspects of APL that get people into it. The next step for me was to discover that Apl Is actually useful as a programming environment, which sadly I had to find out on my own. I think Dyalog's marketing isn't somehow wrong, it's just incomplete so far.
Also #kq on freenode
I have been wondering what a simple AST evaluator would look like in J, this gives a nice clue, although I'm not familiar with the branching operators he's using in the "ugly" version. And I'm still not sure how you'd go about parsing from APL/J.
 Dyalog APL has rank too
Yeah it has. The composition symbol with a diaresis on top of it.
TIL, thanks for cluing me in.
This is actually the subject of the first section of [this paper about APL and J differences](http://www.jsoftware.com/papers/aplj.pdf).
You mean how you'd parse a different language in APL? I have a parsing combinator library somewhere, if you are interested I'd be willing to port it to J and share it.
I'd love to see it, but if it isn't in J, don't go to a lot of trouble porting it on my account.
Okay, this should be working, but it's not thoroughly tested. term =: 1 :0 if. *./ u = (#u){.y do. (&lt;(#u)}.y),&lt;u else. &lt;y end. ) anyof =: 1 :0 if. '' -: y do. &lt;y return. end. if. +./ u = 0{y do. (&lt;1}.y),&lt;0{y else. &lt;y end. ) folby =: 2 :0 if. 1=# a =. u y do. a elseif. 1=# b =. v &gt;0{a do. b elseif. do. (0{b),(1}.a),1}.b end. ) or =: 2 :0 if. 1=# a =. u y do. v y else. a end. ) cap =: 2 :0 if. 1=# a =. u y do. a else. (0{a),v 1}.a end. ) any =: 1 :0 i =. y r =. '' o =. u i while. -. 1=# o do. i =. &gt;0{o r =. r,1}.o o =. u i end. (&lt;i),&lt;r ) trim =: ]}.~[:+/[:*./\[:+./(32 9 13 10{a.)="0 _] nil =: 3 :0 (&lt;y),&lt;'' ) ws =: 2 :0 if. 1=# a =. u y do. a elseif. 1=# b =. v trim &gt;0{a do. b elseif. do. (0{b),(1}.a),1}.b end. )
 (255#"S";enlist csv) 0: `:input.csv
Thank you! This is exactly what I'm looking for. What's the character for char-vectors? Do you have any reference I can look at for these expressions? I've been trying to find some reference about it for hours already.
I would enjoy hearing some feedback on my post.
&gt; "if even" (2&amp;|) "then halve" (:-), "otherwise, multiply by 3 and add one" ((1 + 3 * ])) The case actions are inverted. nitpick.
Thanks, I have fixed that.
In most cases there you don't actually need `]`. These are mostly aesthetic, but the goal here is to gain more insight into J, so do consider these examples. Ex. 1: `(1 + 3 * ])`. What you're trying to do is "multiply by 3 and add one". Just write that! `1&amp;+ @ (3&amp;*)`. Now, as a rule of thumb, you should avoid parentheses for clarity. In this case, you could do that by putting the literal in `3&amp;*` last to avoid ambiguity: `*&amp;3`, or, when you can't do that (for non-commutative dyads) you can use a cap `[:` instead: `[: 1&amp;+ 3&amp;*`, which forces the next two verbs to be applied sequentially. Also there is an "increment" primitive `&gt;:`, which turns the entire thing into `[: &gt;: 3&amp;*` (or `&gt;: @ *&amp;3`). Ex. 2: `(] i. &gt;./)`. This, by rules of fork, turns into `(] y) i. (&gt;./ y)`, which is equivalent to `y i. &gt;./ y`. Hook is a J construct similar to fork: `(f g) y` =&gt; `y f g y`. Just removing `]` makes your code there more idiomatic.
The hook comment is very useful. I have the impression that some users prefer caps and some don't, and some like atops and some don't. Finding out that nouns can fill slots in trains was very interesting to me, as you can see; I'm not sure I find it more direct to write it as `1&amp;+ @ (3&amp;*)` as you have suggested. It's more characters, for one thing. Even `&gt;: @ *&amp;3` is still one character more. But if you think that is more idiomatic, it's good to be idiomatic even if it doesn't suit a beginner's preferences.
First thing I write in k... I just went to their documentation and banged my keyboard until it returned something making some sense, not a lot of sense though (since, why, oh why does not work just a(0)?"=" ? pick:{(raze "",(((string x ) ? "=") sublist (string x)))} pick each a Will return "ua" "sba" ,"r" Working with strings in KDB seems weird, can't find a way to convert the 1 item vector ,"r" to actually a string (that's the raze I put there, which works for 2-N items, but of course not for 1 item things. Probably someone with proper KDB knowledge can do this right :)
The first idea that comes to mind is to drop into k4 and do something like: q)\ a:("ua=1100@1 sa";"sba=2220@2 s";"r=4444@a") {(*&amp;"="=x)#x}'a ("ua";"sba";,"r") But perhaps it is more elegant to use find? a?\:"=" 2 3 1 (a?\:"=")#'a ("ua";"sba";,"r") @rberenguel ,"r" *is* a string. "r" would be a character. I suspect the OP does in fact want a list of strings as their answer.
Thanks, good to see how it's properly done. Haven't used kdb enough (it's almost 0, just for fun occasionally) to know exactly how it represents data types, the `raze` I was issuing to see it as a "string" felt weird indeed. The second approach was the idea I had on start, but I keep forgetting about adverbs (I'm more used to the APL style than the J/K style so they are not part of my mental map of the language)
&gt; someone with proper KDB knowledge can do Thanks! I sure feel better that I'm not the only one who is insanely banging the keyboard :)
Thanks for the non-cryptic explanation! I appreciate it.
It's worse when it's APL, in the keyboard banging arena :)
In case someone ever wants this in J, I came up with this: split =: ({.~ '=' i.~ ])&amp;.&gt; split 'ua=1100@1 sa';'sba=2220@2 s';'r=4444@a' ┌──┬───┬─┐ │ua│sba│r│ └──┴───┴─┘
Spending some time with the [whitepaper](https://code.kx.com/q/whitepapers/) series is also useful. Especially Parse Trees and Functional Forms and Efficient Use of Adverbs. They give some great insight into how these things work.
I had a similar experience with the H99 list for Haskell. I would love to see a resource like that for J, I have been like you, stuck not really getting it for a year or so.
I find this APL tutorial amazing: [https://tutorial.dyalog.com/try.html](https://tutorial.dyalog.com/try.html) It contains tiny problems at the end of each module. For something more advanced, you can try to solve Dyalog student competition problems (check out archive at the bottom of the page) [https://www.dyalog.com/student-competition.htm](https://www.dyalog.com/student-competition.htm)
 Posted by frowny frog in stack overflow apl chat. {∨/d←0=4/3 5|⍵:d/'FizzBuzz'⋄⍵}¨⍳100 ©Adám Apparently, inside {}, : can be used like ? in c langauges, and ⋄ can be used like : in c languages For example `{condition: true result ⋄ false result}`
There is 99 K Problems: https://github.com/kevinlawler/kona/wiki/K-99%3A-Ninety-Nine-K-Problems
 pc=: %@! * (2 | 1&amp;+) * _1: ^ 3: = 4: | 1 + ] By incrementing the input list by one (_1: 3: = 4: | 1 + ]), I was able to generate a list where starting from the 3rd item and every 4th item onwards, was a -1. By modifying '2&amp;|' to first add 1 to the input list (2 | 1&amp;+), I was able to generate a list of alternating 1s and 0s, starting from 1. The product of the result of the above 2 modifications was a list of alternating 1s and -1s starting with 1, each separated by a 0, which was the result which I was looking for. 
The function is a fork... you probably shouldn't space out the symbols evenly like that. I'd write it like this: `ps=: %@! * 2&amp;| * _1:^3:=4:|]` You're describing the behavior of these things correctly, but the way you phrase it makes it seem like you don't know why they're behaving that way... So just in case, let's review what the symbols mean... The operations are all pretty simple: `%@! -&gt; 1 over the factorial` `2&amp;| -&gt; mod 2 / parity / is odd` `_1^3=4|] -&gt; negative one to the power 0 or 1, depending on whether y is a multiple of 4` So here the `x|y` is kind of acting like a filter: for every y, if it's a multiple of 4, make it negative... Then the `(2&amp;| * ...)` zeros out all the inputs that were originally even. So now you have: `x:i.11` `0 1 2 3 4 5 6 7 8 9 10` `(2&amp;| * _1:^3:=4:|]) x:i. 11` `0 1 0 _1 0 1 0 _1 0 1 0` &amp;#x200B; It looks like for the second series you want to zero out the odd ones rather than the even ones, so you could do something like `-.@(2&amp;|)` for that ( `-.y` is "one minus y", which is "not y" for booleans...) The input sequence mod 4 starts out like this: &amp;#x200B; `4|i.10` `0 1 2 3 0 1 2 3 0 1` &amp;#x200B; Previously, you were selecting the ones where this is 3, but now it looks like you want the ones where it's 2. &amp;#x200B; I'll leave the last step to you, but putting those two ideas together gives you the sequence you want... &amp;#x200B;
Nice. You can knock off one char with \^: `k=:(]=3+4=*)[:+/^:2(,"0/~i:1)&amp;|.`
This is very nice. I'll pass it on internally at Dyalog!
Missing {}
Good to hear!
would unicode make it incompatible with k6?
Thanks for the info! &amp;#x200B; Although I am not a user, I feel fascinated by k and Whitney's code (I have spent a long time reading the source of b in [kparc.com](https://kparc.com), for example). However, I always have the feeling it is some kind of private club where I am not allowed. How everything we know about kOS is basically from rumors by Iverson College attendants is a great example.
I honestly think he just likes working on stuff by himself. 
And that is totally fine, don't get me wrong. Although I do not share his opinions on open source, I can understand that he just prefers this way of working and he has the right to keep his own work for himself/Kx/close collaborators or whoever he wants. I have also heard that he is also quite open when you approach him personally, which I have not even tried, so I shouldn't complain. But I spend a considerable amount of time reading lame blog posts about people trying Go or Rust for the first time, or with another introduction to lambda calculus, while everything I can find about all this great stuff that Whitney is doing is some small comment here and there, and I cannot avoid perceiving the whole situation like some sort of missed opportunity. It's like if some great artist (think Dylan, for example) decided to stop touring and publishing records, but you could hear from time to time that he keeps writing great songs and giving concerts for a few of his friends from time to time. He would have the right to do so, but as a fan it would sadden me.
I regret that I have but one upvote to give.
[Release Notes](https://code.jsoftware.com/wiki/System/ReleaseNotes/J807)
Only now? It's been marked as released for 10 days on [the GitHub](https://github.com/jsoftware/jsource/releases)
Hi all, I'm learning q and one thing I really miss from other languages is having a slack channel to ask quick dumb questions in. I couldn't find one so I started this. Feedback welcome. 
He does answer his emails!
 q) select (`$string iq)^name from t You have to cast to string first before casting to symbol because there are no direct casts to symbol for integers. Carat is the fill operator which selects the left argument vectorwise where the right argument is null.
Two errors here: `a="ff"` isn't going to work, because you're going to get a result of the wrong shape. Since `"ff"` is a character vector, `=` won't broadcast it to the columns of `k1`. You'll get a `'length` error from this. Instead, you can use `like`, which works as you'd expect, or '~\:' which does the broadcasting explicitly. Now we have the following query: `k2 insert select from k1 where a ~\: "ff" And this fails with `'mismatch`, so we just reselect the keys to make them the same: `k2 insert `z xkey select from k1 where a ~\: "ff"
I really wish there was an array programming conference in North America held regularly. I feel like it would greatly help the Q/K/J/APL communities to have advocates come together and have regular talks. I think it could greatly improve acceptability of those languages in industry if it seemed like there was some activity rather than some random youtube videos of people on webcams and blog posts. It gives the impression of toy languages.
I will make a small report, but what is interesting to me can be not so interesting for others
Thanks for this
https://dyalog.tv/Dyalog17/?v=W7EaWAhQX6s
My dream APL environment on Windows would be a good REPL like you would need to do using Powershell (like Julia does) so you can get coloring and symbols. I'd then use notepad or notepad++ for longer scripts. I'd rather not mess with complicated IDEs, but most people prefer them.
The problem with APL REPL is that not everything can be entered in one line (like control structures). So as far as I understand, Dyalog will propose solution for 1) complex structure multi-line input (think of matrices or cube input as in matlab) and 2) low-level redesign of control structures to use them in line-by-line input. Then we'll have both open REPL _and_ scripting using any editor or IDE. Still, it's another two years for something, which is granted for others interpreted languages.
oh, and by the way, did you know that it's possible to use APL with Jupyter? https://github.com/Dyalog/dyalog-jupyter-kernel
slides for most of the talks are up https://www.dyalog.com/user-meetings/dyalog18.htm
Thanks. The "Rectangles All The Way Down" slides are interesting. [https://www.dyalog.com/uploads/conference/dyalog18/presentations/U12\_Rectangles\_All\_The\_Way\_Down.pdf](https://www.dyalog.com/uploads/conference/dyalog18/presentations/U12_Rectangles_All_The_Way_Down.pdf)
really looking forward to the videos especially Aaron Hsu, hopefully make it to one some day. "impossible ones" sounds like cheating:) 
This is top-notch J code, and deserves a TIO: [Try it online!](https://tio.run/##y/qvpKeepmBrpaCuoKNgoGAFxLp6Cs5BPm7/NWJtjbVNbLU0o6209eOsjDR0lAz06zKtDDXVavT@a3Jx5drqWSpYKqgA9RgCMTo0ROMZYlVFF8jFlZqcka9gra9Qraaup6WukBZnpZGpZ6mpkPsfAA "J – Try It Online") Note: After tangentstorm's and according to standard stackexchange code gold rules, this is 29 bytes.
Ligatures? It looks interesting. Not APL, but also not quite J; a hybrid.
Thanks! &gt; according to standard stackexchange code gold rules Could you explain that, I'm not familiar with those rules.
Yep, ligatures!
I wonder where this will lead, reminds me of query planners in databases, will we have two langs one for intent (APL) and one with implementation of that intend.
&gt; Could you explain that, I'm not familiar with those rules. Basically, if you can write `f=.stuff`, then your byte count is `stuff`. You can see that's what I did in the TIO. So the `f=.` doesn't count toward your byte count. Which may seem arbitrary, but that's how everyone play on codegolf.stackexchange.com
Great idea! Looks easier on the eyes with the APL symbols
Kdb+ uses k4, which isn't documented. You can infer most of it by reading the initial sections of q.k though. The major difference is the use of monadic symbols, which are exclusively English words in q (first, count, flip, read0 etc). Use a bare \ on the prompt to switch to k input. You can also prefix lines with k) or evaluate strings with "k" "...". You can find documentation for k5 at kparc.com/k.txt - this is discontinued. Still a fair bit of continuity between k4 and k5. oK (by John Earnest) is an implementation of k5 that's open source and available. K6 was an attempt at kOS, a bare metal version of k. Arthur succeeded in getting it to run, but eventually got drowned in device drivers. He's now working on k7.
The examples on Wikipedia are not up to date. For example, ! no longer means rotate - it's implemented in terms of , _ | and mod.
Thank you so much for the help (and the history lesson)! I'll take a look at oK. I didn't know that k4 is the version that kdb+ uses. It's sad that there is so little K documentation. Definitely intimidating for beginners like myself. Perhaps things will change with k7?
There's a similar sort of specification to the k5 text document. The language is fundamentally extremely simple, so once you know the basic sentence construction and the symbols, you're done.
Imagine drowned in device drivers is same am the situation described in [The Thirty-Million-Line Problem](https://caseymuratori.com/blog_0031). Hopefully kOS can find a why round this.
&gt; Arthur succeeded in getting it to run, but eventually got drowned in device drivers. Well that's something that could benefit from open sourcing. Not that it will ever happen, of course :/
Makes sense! Since I am just trying to understand the basics and solve some toy problems, I wonder if [Kona](https://github.com/kevinlawler/kona/wiki) is what I should be using. It seems to have better documentation, and is open source. Perhaps, I can use the Kona documentation to get a feel for K and then try it out on the K console
You might like the power operator: times←{⍺(+⍣⍵)0} pow←{⍺(×⍣⍵)1} tet←{⍺(\*⍣⍵)1} pent←{⍺(tet⍣⍵)1} &amp;#x200B;
What does the 1 and 0 to the right of the parentheses do? ⍣ does repeated operation right? So what significance does putting ⍺ on the left of the parentheses and and 1 (or 0) on the right have?
&gt; What does the 1 and 0 to the right of the parentheses do? That's the neutral element. &gt; So what significance does putting ⍺ on the left of the parentheses and and 1 (or 0) on the right have? So `X(F⍣Y)Z` behaves like `(Z,F/YρX)[Y≠0]`, i.e. `Z` is used as the result for `Y=0`, otherwise the result is `Y` copies of `X` reduces by `F`.
Found these that might help someone get started: [https://github.com/theaplroom/apl-sound-wave](https://github.com/theaplroom/apl-sound-wave) [https://aplwiki.com/ImageFilesWithDyalog](https://aplwiki.com/ImageFilesWithDyalog) But really no experience to guide you. MaxMSP I've heard is a tool for doing AV applications.
`select` (`?`) will always yield a table of some sort. You want `exec`, or even to just index the table with the column name: a except bb `c or a except exec c from bb
&amp;#x200B; preview:{\[file;delim\] raw:read0 file; numkols:count delim vs first raw; :(numkols#"\*";enlist delim)0:raw; } &amp;#x200B; preview\[\`:input.csv;csv\]
That's because you have a typo in there leading to an infinite loop. See if you can spot it.
Care to expand on this random post with no context?
I heard on the grapevine that this is Arthur's latest Thing. I don't know why he's being so obtusely secretive about it (also he's well over a year late to slap 'blockchain' on your product and have it sell like hotcakes...)
The website has changed; previously it did mention Arthur's name.
Confirmed via Wayback Machine: https://web.archive.org/web/20181121034709/https://shakti.com/ Looks like they set up the company in Jan 2018: https://www.cacompanydir.com/companies/shakti-software-inc/ And bought the domain in August 2018: https://domainnamewire.com/2018/08/22/14-end-user-domain-names-sales-up-to-50000/
Maybe k6 was 1.0?
The "k7!" link on the main site now links to shakti.com, too. itshappening.gif
I'm interested in k and know the basics, but there's a whole nother level of mysticism surrounding this language compared to any other. Would someone care to explain to me what I'm looking at?
To an extent we just get excited over any scraps of new info we can get our hands on. I don't get the sense that the secrecy is 100% deliberate but in any case it's pretty good emergent viral marketing. This file, read closely, provides a preview into what language features k7 will have.
Has anyone tried putting in for a trial and gotten a trial?
ack←{⍺=0:⍵+1⋄⍵=0:(⍺-1)∇1⋄(⍺-1)∇⍺∇⍵-1}
Not even setxkbmap us,apl -option grp:win_switch ?
That works. Thank you very much. 
I installed it! $ k [1] 2376 illegal hardware instruction (core dumped) k
For those interested, here's the full documentation thus far. $k [-p 1234] [f.k] / .z.i(pid) .z.x(arg) .z.e(env) Verb Adverb Noun Atom List : set ' each char " ab" `c `C + plus flip / over name ``a`b `n `N - minus negate \ scan int Ø 0 2 `i `I * times first ': eachprior peach float ø 2.3 π ∞ `f `F % divide inverse /: eachright join|sv date 2019.06.28 `d `D .z.d &amp; min|and where \: eachleft split|vs time 12:34:56.789 `t `T .z.t | max|or reverse &lt; less up System &gt; more down 0: read/write line list (2;3.4;`c) ` = equal group 1: read/write byte dict [a:2;b:`c] `a `A table ~ match not 2: read/write data expr :32+9*f%5 `0 ! dict|mod key|enum 3: conn/set (.z.ms) func {(+/x)%#x} `1 .z.f , concat enlist 4: http/get (.z.mg) ^ except null $ pad|cast string $[c;t;f] cond \l a.k load \t[:n] x time(milli) # take count #[t;c;b[;a]] select \v [d] vars \u[:n] x trace(micro) _ drop floor _[t;c;b[;a]] delete \f [d] fns ? find|rand uniq|rand ?[x;i;f[;y]] splice \d [d] get[set]d @ index type @[x;i;f[;y]] amend \cd [d] get[set]dir . apply value .[x;i;f[;y]] dmend \lf [x] list files \lc(hars) \ll(ines) while[c;..];if[c;..]; ` 1:"prompt" generate: !i(enum) !I(odometer) ?i(uniform) ?-i(normal) i?(draw) -i?(deal) datetime: ymdhrst 2019.06.28+2m; monday:7*-7!2018.07.04; bar5:5*-5!12:34 `year`month`day`hour`minute`second`time`microsecond`nanosecond sql: select delete update; by from where; [x]key [x]asc [x]desc [x]cols aggr: count first last min max [x]sum [x]avg [x]var [x]dev [x]med util: in within bin like find math: abs sin cos log exp sqrt prm cmb string: `@x (`j`k`p`b64`hex`csv`der;`crc`sha`rip`b58`bad`m) object: `?x (`j`k`p`b64`hex`csv`der) e.g. `j?`j@`a`b!2 3 K:key k:key`k1 / public private(`r1 `rsa ..) K key k key"hi" / verify sign &amp;#x200B;
It looks like it is just a polished K6. Nothing more, but nothing less. It still looks very good, I see some nice additions, and I am sure the performance will be outstanding, but I don't see anything really new except maybe (if I understood right) the generalization of views to first class values (expressions). It also looks like some things may have been removed (like named parameters or list indexing and function application with square brackets), but those may just be omissions from the documentation. May I know what hardware/OS you are using to run it? I could extract this documentation (and a few more lines about tables) using strings, but it is not running.
Apparently they'll be adding more documentation over time, so there may be omissions at present. There were also mentions of blockchain tech and it's currently unclear how exactly that works. As for hardware/OS, I just have it set up in a Digital Ocean droplet running Ubuntu 18.04 at present.
I see unicode: don't know how to enter them yet. &amp;#x200B;
I actually don't know why we need Anaconda for this. the k can be run without Anaconda.
There's a Python module that I can't personally test because it's only available for Mac OSX at the moment. I'm assuming that that is why they chose to distribute it via Anaconda.
How did you get to this? Is it a switch on the k binary?
&gt; It also looks like some things may have been removed (like named parameters or list indexing and function application with square brackets), but those may just be omissions from the documentation. Just tested and looks like a documentation omission.
Ah, should have mentioned that. Type \\ in the REPL.
On a mac, Option - p will give you pi. I forgot which one was square root maybe s or z just try all the keys out while holding option
I managed to figure out how to get expressions working. Wrap the expression in parenthesis f:0 v:(:32+9*f%5) . v[1]
I asked if there’s a public forum for feature discussion, bug reports etc; Fintan Quill @ Shakti responded with this link: https://groups.google.com/forum/m/#!forum/shaktidb
Non-mobile link for convenience: [https://groups.google.com/forum/#!forum/shaktidb](https://groups.google.com/forum/#!forum/shaktidb)
What does splice do? I don't remember it from older Ks
https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Manual.md I managed to find a mention of splice in the oK docs linked above 
Thanks! Indeed seems like a useful form to have, although I personally never had the need for it.
More on exprs here: https://groups.google.com/forum/m/#!topic/shaktidb/5N6VjsOBjoA
The repo they tell you to clone is 404'd :-(
You can get a trial binary from Anaconda! Check out this thread: https://www.reddit.com/r/apljk/comments/b1l5hi/shakti_trial_via_anaconda/?st=JTDZ9EXU&amp;sh=b79f417f
You can get a trial binary from Anaconda! Check out this thread: https://www.reddit.com/r/apljk/comments/b1l5hi/shakti_trial_via_anaconda/?st=JTDZ9EXU&amp;sh=b79f417f
cool! first surprise was: 2019.03.18T13:16:55 M 12cpu 1gb avx2 ©shakti !12 !12 1+!12 1 2 3 4 5 6 7 8 9 10 11 12 deferred evaluation?
How far away is K7 from Kona? I believe Kona is based on K3/4. I was thinking on using either kdb+ or jd in a new project, but I wanted to give their languages a shot before (and J is very easy to install and play with).
Kona is based on K2/K3 with a few additions from K4. K7 is quite far. Other than the actual trial K7 through anaconda (which may or may not be useful - someone on HN said many queries are 10 times slower than the equivalent K4 query), the closest thing is JohnEarnest's oK, which is in JavaScript (so, much much much slower, and does not include the q syntactic sugar), which is pretty faithful K5/K6 implementation. If you are starting a project and need whatever you use to be reliable, Jd is likely to be a better choice at this point in time -- unless you are planning to pay for K7 in which case you should ask Shakti, not us.
&gt;\[a:2;b:\`c\] no more (enlist\`foo)!enlist\`bar: \[a:2\] seems to be a legit dictionary. &amp;#x200B;
I was already leaning towards Jd. Thanks
&gt; succeeded in getting it to run, but eventually got drowned in device drivers Could accurately summarize Linux kernel development as well... 
I'd imagine KOS was not intended as a end user OS and more of a bare metal KDB therefore I wonder why they didn't focus on a limit set of particular hardware (eg the KBox).
I mean they did seem to have a focus/interest on GUIs and other stuff you'd see in a end user OS e.g text editor 
&gt; more of a bare metal KDB I'm sceptical. Who would use that, and why? I don't see how KDB could get better at any of the things it's good at by running on bare metal; it's not impeded in any of them by the standard Linux OS.
True but I look what Vulkan was able to achieve in the GPU space and wonder what the removal of layers (eg networking) and a OS that trusted it applications more might be able to achieve.
You may like Roger Hui’s talk on inverted tables, being #4 here: https://www.dyalog.com/blog/2019/01/dyalog-18-videos-final-week/
“Where” blew my mind: https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Manual.md#where
But can be considered fundamental? &amp;#x200B; In functional languages, fold is. All the others can be build on top. But with filter/map/reduce you get a good start.
Ah, this is a columnar representation. If each column or row is a single vector certainly CRUD operations are easy. So my assumption that in array languages the arrays are like ndarrays is wrong? And instead is: pub struct Array { pub data: Vec &lt;Vec&lt;Scalar&gt;&gt;, }
&gt; But can be considered fundamental? I lean towards no. In J, defining `where` as `#(i. @ #)` seems to suffice.
Forgive my ignorance, but do you have a K translation?
I can write where as `{,/x#'!#x}`.
I suspect that you could build a model of all of the other operators with just these k verbs/adverbs: `@,/`, and you could even restrict `@` to scalar index. In terms of things that I think would be useful fundamental operators, array-index and grade get my vote.
Nice! We can add the special case for dictionaries: w:{,/$[`a=@x;x[!x]#'!x;x#'!#x]} This is obviously slower than the builtin: \t:1000 w 1000?1000 503 \t:1000 &amp; 1000?1000 241
You might find some of these papers by Bruce Maclennan interesting: [https://github.com/tangentstorm/maclennan](https://github.com/tangentstorm/maclennan) &amp;#x200B; (the links there go to the internet archive, to pdfs of his typewritten papers... the repo is an attempt to OCR them...) &amp;#x200B; His syntax rules draw inspiration from the same Turing lecture by Backus that helped inspire Iverson to create J: [https://dl.acm.org/citation.cfm?id=359579](https://dl.acm.org/citation.cfm?id=359579) &amp;#x200B;
Sorry, I don't know how read none of the array-langs syntax. What is the name of that symbols?
I don't think that you actually want to pick those as your fundamental operations: it seems worthwhile to introduce things as fundamental if it's useful to do so, rather than whether or not it is possible to write out other operations in terms of other ones. That said, the symbols I've used here are: * @ is index, as a verb * , is concatenate or enlist * / is iterate/fold/reduce * + and - etc do what they usually do
infs and nans 1-∞ -∞ ∞-∞ ø 
As far as I know, most array languages do not let you mutate arrays in place, unless perhaps they can be absolutely certain there is only one reference to the array. Most array languages also don't have a concept of "reference" or "pointer" at the language level... I don't know why that is, although they often do have the idea of shared memory / mapped arrays if you explicitly opt into it. &amp;#x200B; So, in practice, yes: unless you explicitly opt into shared/mapped memory, then every time you add two arrays, a third array is just pre-allocated and filled in. &amp;#x200B; Note if you say \`x: !10 ; y: x\` (k example for allocating an array and then assigning it to two different variables) there probably isn't any actual data being copied behind the scenes. Internally, in the interpreter, there's just an increment to the reference count on the same array. If either \`x\` or \`y\` is later modified in-place (\`x\[2\]: 343\`) then a new array is allocated, \`x\` is updated to point to the new array, and the refcount on both arrays is set to 1. So, "copy on write" semantics. &amp;#x200B; Did that make any sense at all? :D
Yes, COW make sense. I have worked in regular languages so wish to ask, how is the memory usage for typical programs? I imagine is normal to have large-ish arrays alive at the same time. &amp;#x200B; I'm under the impression kdb+ put all the arrays behind mmap? &amp;#x200B; BTW, I plan to make a language for make easier to implement business apps (ERP-like), so wonder if exist some accounts of the experience doing that?
Norman Thomson in [Chapter 3](https://code.jsoftware.com/wiki/Fifty_Shades_of_J/Chapter_3) of "Fifty Shaded of J" says: &gt;The shaper ($) starts its work as a laminator and continues as an appender. In this sense the laminator is one of the lowest level (most primitive) operators in the overall J tool kit, and thus one of the most pervasive verbs even although its explicit usage is relatively small.
I'm late as hell here but this seriously irked me: For example, unary functions implicitly perform "each" when applied to arrays. For example, f:{[a] (a*a)+3 } f'1 2 3 4 4 7 12 19 f 1 2 3 4 4 7 12 19 x (1 2 3 4;5 6 7 8) f'x (4 7 12 19;28 39 52 67) f x (4 7 12 19;28 39 52 67) The author has *badly* misunderstood what's going on here. Applying an unary function f to an argument x *always* proceeds by beta reduction on x in its entirety, whether it's an array or anything else. f x here is exactly equal to (x*x)+3. The 'implicit each' here is taking place in the operators * and +, as usual; if f had used non-atomic operators such as unary count, e.g. `f:{#x}`, then you can easily see that f x does not perform any kind of implicit each, and returns #x = 2.
Some of k7's functionality isn't finished yet, hence the large gaps. Also, I have no idea how this looks on Mac (particularly the font), so please feel free to suggest style changes.
This is awesome, and very helpful! Two suggestions: add a title, and maybe perform the link insertion once on the server so as to serve a static site (in the spirit of simplicity which seems strong in the K community).
Glad to hear it’s helpful! Just added a title in the &lt;head&gt;. Thinking about how to best do it for the body. The dynamic links will eventually go away. While the official docs are in flux I want it to be easy to update them. That means figuring out where to insert the links in a separate step. At some point the links will either be hard coded or done in a static site generator.
My understanding of how J does it is from [here](https://sblom.github.io/openj-core/iojNoun.htm#Arrays) Here, an array is a struct with metadata and a pointer to the start of the data. The metadata includes things like the refcount, type, and *shape* of the data. In J, arrays are unitype and rectangular, so shape+type are all you need to address every element of the array. I don't know Rust but it might be something like pub struct Array { pub refcount: u64, pub data: usize, pub shape: Vec&lt;u64&gt;, } As far as I know, K does it differently (lists of lists) but likely also stores metadata to make random access faster than pointer-chasing your way through the lists.
An updated version is here: https://shakti.com/tutorial/
[Kx Developer is a visual environment used to manage, manipulate and explore massive datasets in real-time by exploiting kdb+’s server-based analytics technology.](https://code.kx.com/developer/)
Nice. A few years ago we adapted [http://www.nsl.com/papers/style.pdf](http://www.nsl.com/papers/style.pdf) for our kdb projects. Good to see we were thinking along the same track.
bad advice then, bad advice now. &amp;#x200B; `newString:deleteLeadinBlanks\`oldStrings` `n:dlb\`os / delete leading blanks from old strings` &amp;#x200B; without the comment, "dbl\`os" is \*comlpete\* garbage. dont write code like this. could be interpreted as "deleteBadLines\`oldShit" or infinite amount of different ways. &amp;#x200B; jeez, this kind of perverseness is a plague. &amp;#x200B; find the typo? really? use a code editor that lets you autocomplete words, maybe... and test your code, last i ran my code in q, a undefined variable/function name will end your program in the stack.. crazy, right?!
My friend is working on hardware-accelerated messaging for IoT (many small messages, low latency requirements). He showed me a benchmark where the Linux network stack is around 95-99% overhead when sending a single datum to a remote node. Most people try to amortize network costs by sending larger messages less often, which is fine if you can tolerate latency and barrier synchronization. You can get speedups in exchange for being less general-purpose, in either hardware or software... so I can see some performance justifications for bare-metal kdb. But I wouldn't be terribly surprised if the real motivation was "because it's cool".
Good luck! Looking forward to see it :)
I have used J to generate SVG to provide feedback on the types, shapes and encodings of output in jqt and have some unofficial explorations in JHS to do the same thing. A video to demo of what I have done. [https://www.youtube.com/watch?v=dK1y\_V07214](https://www.youtube.com/watch?v=dK1y_V07214) Your project sounds a little different and I look forward to what you come up with. :)
&gt; Fifty Shades of J LOL!
Thanks for reminding me of jig. There are aspects of it that I'll try to learn from, particularly the web view parts. I'm comfortable with J in the command line, and also with js/html/css on the web. The biggest gap in my knowledge for this project is how to hook into a running J process and be able to send/receive from a web client.
I am taking the output of the system and then incorporating information that I can add using ($) Shape, (3!:0) type and (a.&amp;i.) for encodings. The result is a static webpage using SVG to display, but it is not the sort of interactivity that a game would require. Let me know if you think that it may have anything useful and you have questions. :-)
Thank you! I hope to put some time into it after exam season is done.
Interesting story and the cool motivation works for me. I suggested the KBox as half a joke but I think it may be a commercially viable solution. I would love to see something real (non-toy) like an lisp-machine. I just after reading this [Notes on Interactive Computing Environments](http://blog.fogus.me/2019/04/03/notes-on-interactive-computing-environments/),
The author is more smug than a lisp weenie.
And he manages to not mention APL once. Remarkable.
He also managed to skip Leviticus, Deuteronomy, Joshua, Judges, Ruth, 1 Samuel, 2 Samuel, 1 Kings, 2 Kings, 1 Chronicles, 2 Chronicles, Ezra, Nehemiah, Esther, Job, Psalms.
Moved to: http://github.com/kelas/kcc
This is now located here: https://kparc.github.io/ref/
Why are all the k variants released as a sort of piece inside a larger piece of a larger piece of software? I’m stoked for k7 but also don’t particularly want to think about blockchain
Just had a read through it, nicely done! Made me smile a few times
Here's a simple example: setf =: 3 : 0 if. (y &gt; 4) do. ins 0 else. sqr 0 end. t =. y ) ins =: 3 : 0 f =: / t =: 0 ) sqr =: 3 : 0 f =: *: t =: 0 ) input =: (1!:1) 3 setf (# input) g =: + f (1 2 3 4 5) g (1!:2) 4 'g is: ' (1!:2) 4 (": g) (1!:2) 4 LF (1!:2) 4 The `+ f` could be either a hook or an adverb application, but you cannot tell which until run time.
Thank you for your answer. &gt; The + f could be either a hook or an adverb application Agreed, but what prevents one to compile to a program with branching to include all such possibilities using part-of-speech as a "type system" (ie. Union adverb and verb in this particular case)? Presumably it would be difficult to optimize, but that doesn't make it impossible, does it? This is what I don't seem to understand.
If you're going that route, why not compile a program by emitting an interpreter in your target language with the user program hard-coded as a string literal? In that sense, any interpretable language is compilable, but part of the point of compiling is to avoid paying for interpretive overhead. The more decision making you shift from compile time to run time, the more people are going to be dissatisfied with your compilation process, and deferring the decision of how to handle juxtaposed text snippets is pretty much the extreme case of that. It is reasonable to say that some process isn't really parsing if the syntactic role of a snippet of text is not discovered during that process, and people who take that view probably also won't consider the "0^(th) Futamura projection" to be much of a compiler.
I see now, thank you. &gt; people who take that view probably also won't consider the "0th Futamura projection" to be much of a compiler. Incidentally, that's very similar to what I'm making right now as an experiment. I have a whole interpreter defined in terms of Racket macros working as a partial evaluator for the J language. I guess we could agree on a "1/2 th Futamura projection" ;-D Is that really of no interest? Even if it has to keep a lot of branching, it still is translated to the target language, so it should remove most of the interpretative overhead, isn't it?
Interepters can be faster when there is a mismatch with the hardware. Array to register and stack. J is trying to use AVX (simd SSE or Neon) http://archive.vector.org.uk/art10500180 Lisp compiles, so write the interpreter, compile the interpreter, write a compiler, compile the compiler. Compile if when the stack overflows.
&gt; J is trying to use AVX (simd SSE or Neon) Yes, I am aware of that. I'm not really hoping to go faster by compiling. I am just interested in trying exotic approaches to compile J, and find partial evaluation to be a beautiful concept. Whatever the performance is, I'll try to finish my compiler and if it's just personal fun, so be it... Since I saw the Co-dfns APL compiler, it seems to me that array languages won't be able to go on with interpretation only. &gt; Compile if when the stack overflows. I don't really understand what you mean by that. Do you mean conditional compilation used only when the interpreter stack is full?
Take a look at [b](http://kparc.com/b/)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/functionalprogramming] [The 2019 APL Problem Solving Competition is now open!](https://www.reddit.com/r/functionalprogramming/comments/bwmcp1/the_2019_apl_problem_solving_competition_is_now/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt;&gt; J is trying to use AVX (simd SSE or Neon) &gt; Yes, I am aware of that. I'm not really hoping to go faster by compiling. I am just interested in trying exotic approaches to compile J, and find partial evaluation to be a beautiful concept. Whatever the performance is, I'll try to finish my compiler and if it's just personal fun, so be it... &gt; Since I saw the Co-dfns APL compiler, it seems to me that array languages won't be able to go on with interpretation only. &gt;&gt; Compile if when the stack overflows. &gt; I don't really understand what you mean by that. Do you mean &gt; conditional compilation used only when the interpreter stack is full? A recursive descent parser, quickly needed compiling of the rdp. (Different lang with 32bit CL to html). I was assuming J to CL. If CL did not support simd (at least one implementation does) if you (re)write J to use the AVX verbs, those parts may be faster.
you can get the trial software from anaconda [https://anaconda.org/shaktidb/shakti](https://anaconda.org/shaktidb/shakti)
Won't put him light years ahead but if he wants to do quant work and will be amazing at math there will be a job. Honestly the time is better spebt learning something else
You will learn it much quicker and if good with math, You will be ahead of Your peers considerably and can get a great position and open a totally new world for Yourself. It is mostly used in finance though so take that in consideration.
As others are saying, the maths skills (and specialist knowledge and skills of whatever your kid wants to study / do) are going to be more important than proficiency in one specific piece of technology. Even more so a keen interest and enthusiasm to sustain them. If they're interested in maths and programming then learning an assortment of languages in different paradigms (OO, FP, array, low level, scripting, web) may be more useful - they may find themselves drawn to a particular field by exploring. But I'm no crystal ball I did a physics degree and pretty much stumbled upon an APL job by way of sheer coincidence.
I think kdb/Q skills will still be very useful in 5 years time - whether it's k4/kdb that's still around, or k7/shakti gains traction by then - however the kid still won't have practical real-life experience so many firms I imagine will pick on that as a reason to start them at a basic wage or to hire someone with experience instead. So it's no guarantee. I would also recommend python too and specifically AI/machine learning/neural-networks (keras) learning too. It's hard to see that not being dominant in the next 5 years.
You can make a compiler for any language. That is a fact. &amp;#x200B; But you can't STATICALLY solve AT COMPILE TIME everything. This is the key. &amp;#x200B; For example, if you take user input for a math formula, you can't before run the program to know what will the user input. &amp;#x200B; Now with this insight you can take a 2-fork path: &amp;#x200B; \- Make a compiler for the subset of the language that can be proved at compile time. By the way this is how a virtual machine work. \- Using that implement a interpreted. &amp;#x200B; This is how things like python work: It compile to bytecode (and from this to machine code is "easy"), then put an interpreted on top.