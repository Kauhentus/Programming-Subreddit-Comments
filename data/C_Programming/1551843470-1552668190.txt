You can also try having an hash map/table , where the key would be the student_id and value would be the list of books.
And what if the first byte of the input is zero? Another problem when using fgets() with console input, btw, is that if the input is longer than expected it won't advance to the next line but will instead interpret the remainder of the current line as though it were the next line. Really an incredibly broken function, second only to gets() which is at least more convenient, though unfortunately more broken.
this lends easily to, if paranoia is needed, else if getc == EOF last line missing a newline else line too long &amp;#x200B;
Several people have pointed out other issues but also, `=` performs assignment, not equality test.
Exactly. I should have mentioned that.
The problem with that is you can't easily detect reading an incomplete line.
I use 0 instead of '\0'.
Won't `fgets` really put `Bernard\n\0` in the array? The line strips the last character, yes, but without the NULL `strlen` won't work 
Why didn't you just write some code to test it? #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char name[10] = {}; fgets(name, 10, stdin); for (int i = 0; i != sizeof(name); i++) { switch(name[i]) { case '\0': printf("[ %02i ]\tNULL\n", i); break; case '\n': case '\r': printf("[ %02i ]\tNewline\n", i); break; default: printf("[ %02i ]\t%c\n", i, name[i]); break; } } name[strlen(name) - 1] = '\0'; printf("\n"); for (int i = 0; i != sizeof(name); i++) { switch(name[i]) { case '\0': printf("[ %02i ]\tNULL\n", i); break; case '\n': case '\r': printf("[ %02i ]\tNewline\n", i); break; default: printf("[ %02i ]\t%c\n", i, name[i]); break; } } return 0; } Input: test Output: [ 00 ] t [ 01 ] e [ 02 ] s [ 03 ] t [ 04 ] Newline [ 05 ] NULL [ 06 ] NULL [ 07 ] NULL [ 08 ] NULL [ 09 ] NULL [ 00 ] t [ 01 ] e [ 02 ] s [ 03 ] t [ 04 ] NULL [ 05 ] NULL [ 06 ] NULL [ 07 ] NULL [ 08 ] NULL [ 09 ] NULL &amp;#x200B;
I have already done this question, but this method is totally different from mine. I am just curious to know the algorithm behind his solutions nothing else.
Well you could try getting the sizeof() of a dereferenced pointer(in your case sizeof(*c); but I wouldn't suggest doing so as it will be slow &amp; and +1 argument to your functions wont hurt anyone. Or you could put your array into a struct which also holds the number of elements in the array and make this 1 struct the argument to your function.
In C there is no such thing as "passing an array" to a function. Arrays degrade to pointers in most expressions; using an array in a function call passes a pointer to its first element. If your function needs to know the size or length of the array, that needs to be passed in a separate argument.
C doesn't pass complete datatype of the variable. So only the pointer is passed in this case. Suggest you use a MACRO to get the size of array.
Pass in the size as a separate parameter. void func(int *c, unsigned int c_size) { printf("c: %zu\n", c_size); } Call this function in your `main()` as `func(a, sizeof(a))` or `func(a, ARR_SIZE)`. This approach, with the second size parameter, has the advantage that you can also use it with memory allocated with `malloc`, `calloc` or `realloc`.
&gt; but I wouldn't suggest doing so as it will be slow The `sizeof` operator is (in almost all cases) evaluated at compile-time to a constant value. It is not "slow". The one case I can think of where it needs to be evaluated at runtime is when applying it to a variable-length array. Even then, the compiler can easily arrange things so its size is immediately available, as it already needed that size when allocating it.
 #define ARR_SIZE 5 void func(int (*c)[ARR_SIZE]) { int *a = *c; /* a[] easier for eyes */ printf("c: %zu\n", sizeof *c); } int main() { int a[ARR_SIZE]; printf("a: %zu\n", sizeof a); func(&amp;a); } Not sensible, but ...
Absolutely true
That's what I thought, but I wanted to get sure. Thanks!
I just wanted to know if it's possible, finding a workaround wasn't my goal :) thanks
Just wanted to know if it's possible, finding another solution wasn't my goal :) thanks
Wow, that's awesome! I am going to test if there are any pitfalls, thanks!
Just a joke, don't take it too seriously
Then I don't get it, it seems to work?
Only while the length is that selected value. Hmm... Is it actually useful, allowing only char[5] to be passed in. I swear I didn't mean that :)
 int get\_positive\_int(string prompt); &lt;&lt;&lt;&lt;&lt; ----- 
//Reprompts if integer isn't positive int get\_positive\_int(string prompt); // &lt;--- get rid of this semicolon { int n;
thank you! it finally ran!!!!! if you dont mind and happen to see this can you explain why i need the semi colon in int get\_positive\_int(string prompt); at the top but not in the second part?
Oh it will... Eventually 😋 JK, but for real, strlen is run before replacing the newline character. In fact, the null never disappears. You do bring up an interesting issue which is if fgets takes in only 25 characters and the user puts in 25+ you'll get an overflow, which was the attempt at a joke I opened with. In the Bernard\n\0 situation strlen will return 8 including the newline and the newline will be at index 7 since arrays start at 0.
That is because in the first part you are telling the compiler "there is a function called 'get\_positive\_int', which takes a string as parameter and returns an int, but what it actually does will follow later", so you can use it in main(). That's called declaration. If you didn't do this you had to define what the function actually does before you have the main function. As you have finished the declaration you end that statement with the semi colon. In the second part you are doing what is called definition. There the '{ }' are part of 'int get\_positive\_int(string prompt)'. What you are doing is, you are telling the compiler "Now listen, inside the curly brakets is what that function I described earlier will actually do.". Since the part inside the brakets still belongs to your definition you do not put a semi colon after 'int get\_positive\_int(string prompt)'. Hope that makes it a bit clearer for you. 
 Because during declaration of function you need semicolon, but during actual definition don\`t.
Yeah, neither yours without a lot of extra steps. And you don't always have a partial line if x is NULL. You need another flag to know if that was the last line. This is another kind of problem you added just because.
You need to make a copy of the string before adding it to the array. You do this by allocating some memory with `malloc` and then copying the string data into the newly-allocated memory. void update_array(int number_of_strings, char *string_array[50], char new_string[500]) { for(int i = number_of_strings; i &gt; 0; i--){ string_array[i] = string_array[i-1]; } /* Work out how long the buffer must be (string length, plus one for the null character at the end) and allocate it */ string_array[0] = malloc(strlen(new_string) + 1); /* Copy the string data in */ strcpy(string_array[0], new_string); }
You need to dynamically allocate memory for a new string, and copy the characters in new\_string into that new memory. Then you write the statement string\_array\[0\] = new\_dynamic\_string and it will work. As it stands, you're copying the same pointer into every position of the array of pointers, which changes on every loop once console input is given.
Thanks! Its working for string_array[0] now. It still doesn't seem to update anything in the for loop however. Tried reusing malloc but is the string_array[i] = string_array[i-1]; correct?
It's not useful at all, but it answers my question :)
It should be correct. Are you incrementing number_of_strings every time a string is added?
I find C makes a lot more sense when I think low level, think about the memory and the bytes. You have two elements char *string_array[50] = {NULL}; This is an array of 50 pointers, each pointer points to a character, these characters can be read as strings. char new_string[512]; This is a string of up to 512 characters. These two elements are the only memory you have available in your program. strcpy, memcpy, etc. won't work because you don't have any memory to copy to. ** simple solution ** The simple but not fantastic approach is to define a two dimensional string array which contains the actual data. char string_array[50][512]; string_array is now no longer an array of pointers, it is an array of character memory blocks. This will allow you to use `strcpy()` as you have been trying to do. Btw. `strncpy_s()` is a safer version of `strcpy()`. It is better to use this function if it is available to you. ** dynamic solution ** The better solution, though more complex, is to use dynamic memory management. get_new_string(new_string); // gets input from console size_t len = strlen(new_string); char* new_copy = malloc(len + 1); // only as much memory as needed if (!new_copy) goto error; strncpy_s(new_copy, len+1, new_string, len); // helper function then works with new_copy // update_array works with pointer shifting as you have in your code // after the while loop, btw. you need an exit condition // dynamic memory which is allocated must be freed // this gets executed if there is an error and the program must exit // this also gets executed as the program normally finishes error: for(int i = number_of_strings; i &gt; 0; i--) { free(string_array[i]); } I would also think about if you can access the stack in the other order, rather than having to push every string up on insertion.
Yeah missed a silly pointer for it. All good. Thanks!
&gt; if (!new_copy) goto error; No, just no. No pseudo exceptions, please. 
Your function causes undefined behaviour at the start, c is uninitialized but you compare it to EOF. Also char is the wrong type for storing the result of getc
Cool story bro
Ctrl D causes flushing the input, it doesnt result in some control character being stored in the buffer 
Wrong format specifier
This is a very useful technique if you want to see a compiler diagnostic when the caller provides a buffer too small for what your function will do
The format specifier was right but the type for the size parameter was wrong (`unsigned int` instead of `size_t`). It's fixed now.
This works too in C99: void func(int n, int (*c)[n]) { printf("c: %zu\n", sizeof *c); } 
I really don't know if I got what you wanted, but perhaps it'll help: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define ARR_S 10 int main() { char buf[512]; char *arr[ARR_S] = {NULL}; unsigned long s; int i, c; for (i = 0; i != ARR_S; i++) { printf("Enter [ %02i / %02i ]:\n", i + 1, ARR_S); fgets(buf, 512, stdin); s = strlen(buf); /* * s is just correct because pressing * return after entering will put a * '\n' at the end */ arr[i] = malloc(s); /* * snprintf() sets a '\0' on it's last * position -&gt; removes the '\n' */ snprintf(arr[i], s, "%s", buf); } for (i = 0; i != ARR_S; i++) { if (arr[i]) { printf("[ %02i ]\t%s\n", i + 1, arr[i]); free(arr[i]); } } return 0; } It's just a piece of code which: 1. fills a buffer (buf\[512\]) with user-input 2. checks the length 3. pointer arr\[i\] -&gt; new memory 4. fills the memory with a string + '\\0' 5. Loops arr\[i++\] 6. after arr\[i\] is full -&gt; output loop
If someone were to use the code above for other inputs, then I think that it should first test for a control character as the last character, e.g. if (iscntrl((int)input[strlen(input) - 1])) { ... do something... } This example should work, although it's untested. As far as I've used it, linking to the GNU readline library should just provide all the text input features of the bash shell, btw. 
Or, for conformance with the more conventional argument ordering: void func(arr, rows, cols) int rows, cols; int (*arr)[rows][cols]; { printf("Size=%lld", (long long)sizeof *arr); } Note that unless the size of the array is larger than the combined number of bytes in all the computers that have ever been manufactured, the use of `%lld` and the `long long` cast will avoid any dependence upon `size_t`. It irks me that the authors of the Standard decided that they simply didn't want to bother drafting a rule that would allow the use of conventional argument ordering with new function syntax. It would have been simple: treat array types whose size isn't a compile-time constant as incomplete types until the body of the function is reached, whereupon their arguments could be evaluated. Or better yet, specify that if the size of an array-type parameter includes a type, e.g. int func(double (*matrix)[int][int]); or int func(double (*matrix)[int rows][int cols]); and the first argument was a pointer to an array of `double`, then the compiler would perform the function call as though the function took `int` arguments `rows` and `cols`, but with the compiler supplying their values automatically. This sort of feature could have easily been provided aeons ago, and would make many things much more convenient. I really dislike the way the Standard handles the creation of automatic-duration variable length arrays (among other things, there is no particular circumstance where the Standard would suggest that a VLA allocation wouldn't jump the rails) but auto-reporting the sizes of array-type arguments would be very handy.
I don't know what you're trying to do with your square function. I would have expected something like &amp;#x200B; int square(int val){ return val*val; } &amp;#x200B; and then you pass in the count to it and print that. I think the biggest error is variable scoping. &amp;#x200B;
1) what's square (); 2) your result is set to be = to count, it should be result=count*count
First, initialise the variable result to 1, then inside the for loop, try result=result*2.
Got told to use this snippet of code from lecture slides. void count(void) { static int counter = 0; counter++; printf("%d\n", counter); }
This definition of string causes some standard-library functions to be underspecified, relative to common expectations. For example, many people would likely expect something like `strcmp(someArray,"Hey")` to behave as a cheaper equivalent to `strcmp(someArray, "Hey", 4)` since either `someArray` will contain a zero in the fourth byte, or it will be recognizably greater than or less than `"Hey"`. If an implementation stops reading from the supplied strings as soon as mismatch is found or either string contains zero, an implementation that just checks for those things would likely be faster than one which must also check the index. The Standard, however, would allow an implementation to behave in arbitrary fashion if `someArray` doesn't contain a zero byte, even if it contains four or more characters. 
If you change the printf line to counter\*counter it will print the square of counter. Simple as that. printf("%d\\n", counter\*counter); 
Are you squaring numbers, or looking for powers of 2? Because they aren't the same thing. 3^2, 4^2, 5^2 vs 2^3, 2^4, 2^5 Assuming you mean powers of 2: People often trip over static variables so here's a quick summary: static means the value of the variable is kept from the last time you called that function, instead of being reset (to 0 in your example) every time. So the `= 0` part only happens the first time. Basically, static variables are just like global variables, but you can only access them from the function they are declared in. Since you want to keep the static local variable, here's an idea: powers of two are nice because you just multiply the previous one by 2 to get the next one; no need to start from scratch! So store the result (aka the previous power of 2) in the static variable and use it the next time the function is called
Try this void square(void) { static unsigned int counter = 0UL; printf(“%d”, 1 &lt;&lt; counter); ++counter; }
Linux was modeled after Unix, everything should still apply. In most cases, everywhere you see Unix you can assume Linux works as well. 
great. Thanks.
There are some cases where it is unspecified whether `sizeof` would evaluate its operand, but I see nothing that would imply that `sizeof` generally invokes UB in cases involving VLAs of non-zero size. I wouldn't be terribly surprised if the Standard is written in a way that would cause such operations to "technically" be UB and rely upon compiler writers to serve the needs of their customers even when not ordered to do so, but I don't see any such quirks. What did you have in mind? 
I think you have a good understanding. The biggest problem I have is with the text of your `printf` calls, none of which really make sense. But your description in your post is pretty good. &gt; I can get the address of the pointer which points to the "test" pointer (&amp;test). What exactly is this however? This is just a local pointer that was created when I passed the pointer to the function? It's a pointer to a pointer to a pointer to a `struct Test`. More simply, it's the address of the `test` parameter of `changeStruct`. As an aside, you should be using `%p` to print out pointers in `printf` instead of `%d`.
 //someVec is a custom Vector I wrote, this works fine Well, except for the bug here, which will cause the loop to execute one extra time than you intended: while(ip.good()){ To fix this, I would write something like: while ( getline(ip, temp, ',') &amp;&amp; getline(ip, temp2, ',') { someVec.push_back(temp); somevec2.push_back(stof(temp)); } The hard part here is that C doesn't have a standard equivalent to C++'s `std::getline`. If you can use POSIX, however, you can use [`getdelim(3)`](http://man7.org/linux/man-pages/man3/getline.3.html) If you can't use POSIX, things get a bit more tricky. I would recommend using `fgets` to read an entire line of input, and then `strtok` or `strchr` to tokenize on the `','`.
First off, I don't believe there is a "proper" way to organize these sorts of programs. It's a matter of what works best for what you're making and how you prefer to work. With that said, I have been working on a game using SDL myself during my free time (also attending university, and the way I've been handling my structures is to create them using functions that allocate memory for them, initialize them, then return a pointer and just pass the pointers around when I need to. This sounds like what you're doing a well. To minimize using that "a-&gt;b.c.d" notation you were mentioning I started to organize my structure handling functions as having a few larger functions that I pass the pointer to from main, then have those larger functions perform all the operations I need by calling smaller, statically declared functions that only take portions of that structure. Such as: static void move_player(struct position pos, enum direction d) { switch(d) { case RIGHT: ++pos.x /* Something below */ } void update_player(struct player *p) { /* Something above */ move_player(player-&gt;pos, RIGHT); /* Something below */ } I also try to avoid typedefing my structs and enums to make it obvious what exactly something is if I ever need to come back and read it, but that's mostly just my personal preference.
as you have a concrete idea of the game rules (hopefully!) it may well be worth your while, just writing out (on paper!) how you see the flow of the game working, ie what happens first, what options the player gets at each step [https://en.wikipedia.org/wiki/Flowchart](https://en.wikipedia.org/wiki/Flowchart) (I'd love to see one, even for larger projects like systemd, or for that matter any documentation in the case of so many other projects) that aside if you do plan it out this way first, you'll find the whole task so much easier (you can break the flow chart down into functions or groups of functions)
Ah let's say,you have three numbers. 4, 10, 8. You can have combination (4,10), (4,8), 10,8). My math takes average and adds the difference between two numbers / 2. For example 4 10 average is 7 + ( 10-4)/2. = 10 therefore the higher number between 2 numbers
I was able to do it through the use of getdelim(). Thank you!
You’re using things in a kinda unusual way. Usually the protocol for passing structs by reference goes along the lines of extern void demo_outArg(struct Test *); extern void demo_inArg(const struct Test *); extern void demo_alloc(struct Test **); extern void demo_free(struct Test **); … /* Read into `foo` and hand off its contents. */ struct Test foo; demo_outArg(&amp;foo); demo_inArg(&amp;foo); … /* “Allocate” a `struct Test` of some sort, then use it as above, then “free.” */ struct Test *p; demo_alloc(&amp;p); demo_outArg(p); demo_inArg(p); demo_free(&amp;p); The allocator variant of things is rarer, but you see it with things like `posix_memalign`; often you’ll use a `struct` to wrap up such pointers to discourage callers/clients fiddling with it themselves. Example function bodies: void demo_outArg(struct Test *out) { int value; if(scanf(" %d ", &amp;value) &lt; 1) for(;;) abort(); out-&gt;test = value; } void demo_inArg(const struct Test *in) { printf( "address of `struct Test`: %p\n" "contents of `struct Test`: %d\n", in, in-&gt;test); } void demo_alloc(struct Test **outp) { /* Static allocation: */ static struct Test inst; *outp = &amp;inst; /* Dynamic allocation: */ if(!(*outp = malloc(sizeof(*outp)))) for(;;) abort(); /* You can’t use a normal `auto` variable for this purpose * —it’ll cease to exist on return. */ /* Once you have *outp: */ printf( "address of `struct Test *`: %p\n" "address of (\")allocated(\") `struct Test`: %p\n", outp, *outp); } void demo_free(struct Test **outp) { printf( "address of `struct Test *`: %p\n" "address of (\")freed(\") `struct Test`: %p\n", outp, *outp); /* Static allocation: (Can just nullify, nothing needs freed) */ *outp = NULL; /* Dynamic allocation: */ if(*outp) { free(*outp); *outp = NULL; } /* Dynamic allocation, reentrance/side-effect safety: */ struct Test *p = *outp; *outp = NULL; if(p) free(p); } It’s not entirely bogus to pass small structs around directly, though; most ABIs can return pairs of words (or things that fit cleanly into pairs of words) directly in registers, and ABIs that don’t force all arguments onto the stack (e.g., not i386, but x86_64) can pass simple structs around like small groups of individual arguments. This is mostly done for things like this: typedef struct { uint64_t low, high; } pretend_uint128_t; pretend_uint128_t pretend_uint128_add( pretend_uint128_t a, pretend_uint128_t b); This lets you modify `a` should you need to, without the caller being able to tell; e.g.: pretend_uint128_t pretend_uint128_add( pretend_uint128_t a, const pretend_uint128_t b) { a.low += b.low; a.high += b.high + (a.low &lt; b.low); return a; }
When in doubt, look things up in POSIX references. POSIX is a particular breed of UNIX system library+OS tools implementations that mostly lets you sidestep the weird peculiarities between different breeds of UNIX, and every UNIX-ish thing written in the past ~20 years has implemented it to some extent. You can usually use things like `__unix__` and `__linux__` to guess at support for particular things at compile time as well.
i don't understand your post but you might be looking for *system calls* it's actually pretty simple to call linux comands from c code?
Yes it will involve using the exec system call. Then assigning numbers from 1 to 4 for specific commands. Using child and parent. 
It's great that you've started by defining the objects. [Game Programming Patterns](http://www.gameprogrammingpatterns.com/) is as good a place to continue as any.
I'd use a similar design. I think it is simple and easy to understand. It is possible to run multiple instances of the game since you can create multiple game structures. I would keep SDL stuff in separate data structures, though. As it is now, the game's data and logic is coupled with the graphics. In my understanding, they're one of many ways to visualize the game and not an essential part of it. For example, it is possible to write an algorithm that records your board game in [textual form]. If you decide to do that with your current design, the SDL stuff will get in the way. &gt; a lot of my code feels hard to read because all my variables are accessed by something along the lines of `game-&gt;ui.tilebar.highlightedRectIndex` for example I like this. Makes it clear what the data means and where it's coming from. Just from reading thar line I already have a pretty good idea of what this variable does. If you are going to use the variable multiple times in your function, it's a good idea to assign another symbol for it for brevity's sake: int i = game-&gt;ui.tilebar.highlightedRectIndex; /* Use i lots of times */ void highlight_at(int i) { /* ... */ } /* Later... */ highlight_at(game-&gt;ui.tilebar.highlightedRectIndex); [textual form]: https://en.wikipedia.org/wiki/Chess_notation
`0.0.0.0` is a special IP address that if you something to bind it, you'll bind it to all interfaces.
Static variables should generally avoided for many of the same reasons as globals. The scope may be smaller, but they are still hidden state which quickly becomes problematic and doesn't scale. Pass the things that functions need to them as parameters.
Thanks, but if I only want to bind directly to the 1.x.x or 2.x. All my google foo seems to be in vain. I am almost to the point of dumping ipconfig to text and snatching the IP that way. Seems like a waste of compute power though 
What does "hidden state" mean?
If you're writing a client, why are you binding your socket?
My loop replaces your loop and adds correct handling of some conditions that your code didn't (file ending, and file being very long) 
I was thinking of buying this book called [Patterns in C](https://leanpub.com/patternsinc) for some time now. Not sure how good or relevant it is, but it seems to address design patterns for C. &amp;#x200B; The accepted stackoverflow answer seems to show the contents of the book. Maybe going through a few can help you move forward.
You have started though but for future, have a look at sfml rather than sdl. Much easier.
A very common architecture that is used for games is the 'Entity Component System'. 
I don't know. I'm reading it now and clearly says "the operator is evaluated". I'm sure it didn't say that yesterday...
Program requirement
Thanks!
If you don't want to bind to all interfaces eg 0.0.0.0. then typically you ask the user which is their prefered interface as there may be more than one outward facing interface. Also some hosts may have multiple interfaces they use at the same time to balance load. If you *really* need the interface IP address, I would get it on a per connection basis after the connection is established.
I found a simple way to get the information i wanted. Its hacky, simple and effective so for now i will accept that answer. For obvious reasons clients are expect to change locations. So manually editing a config file will lead to tension for the user base. I have created a construct where i can obtain the answers i need perform a simple check for any IP changes and update as required. Its sad that the Linux API of the tcp standard words better than MS
Your justification is incredibly naive and rather hypocritical. Signed vs unsigned is something any C programmer should definitely learn how to deal with, its part of the language. Nothing about OP's code is inherently different using signed or unsigned so long as both i and length are both the same signedness for the comparison in the while loop. OP's code is pretty trivial but implicit casting of any kind, especially down casting is just a bad habit to get into. In _real_ code, the declaration of length as a signed type could be rather far away from the assignment to strlen's result. It would be _easy_ to forget length is signed. At the most absolute minimum one should _explicitly_ down cast here and even then I would still say its a pretty bad practice. Your solution comes with a lot of gotchas, ifs, and other conditions that have to be met - mine just works it literally every scenario except where exp exceeds the range of lengths representable by size_t. &gt; could and probably would have been kept signed as it had been in many pre-Standard dialects. This is highly unlikely. Given that the intent of sizeof_t is as a type suitable for representing the size of an object. Since it never makes sense for an object to have _negative_ size and any non-existent objects can be handled with a size of 0 it is literally a senseless waste to have sizeof_t be signed. 
Chapter 5 of K&amp;R is what did it for me. YMMV.
This is what finally helped me understand pointers, [Ted Jensen's Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/~tjensen/ptr/)
The easiest thing in the world to understand is pointers. If you don't understand pointers then you don't understand how computers work. If you don't understand how computers work then you need to switch majors today.
You can't tell what variables are used / modified by a function without reading its entire source. If you always pass all the required variables as arguments you can just read the function signature.
The system () function call might be a better option, because it waits for the subprocess to finish, which fork () doesn't. I'd say this would certainly lead to someone trying to run more than one utility at once, which could easily be a disaster. The disadvantage is that the system () function won't allow the parent program to display a spinning cursor or something while the utility is doing its task. For that, the parent program can use for () and then wait () or one of its variants to check the child process's status. I think you'd also like the parent program not to print any text while the utility is running, because its stdout is a duplicate of the parent's. The dup () function and its variants help with I/O multiplexing, and there are many good examples how to do this on the web. 
[https://www.youtube.com/watch?v=jTSvthW34GU](https://www.youtube.com/watch?v=jTSvthW34GU) [https://www.amazon.co.uk/Computer-Systems-Programmers-Perspective-United/dp/013034074X](https://www.amazon.co.uk/Computer-Systems-Programmers-Perspective-United/dp/013034074X) That series of videos and the book, if you stick with them, go into a decent amount of detail about how elements of C actually relate to what is happening in the computer at the bit/byte level. Understanding that level isn't really necessary with a high-level OOP language like Java or Python, but I'd argue that it's very important in understanding C. I've found that if you relate something like pointers to how the computer is operating underneath all the syntax -- how bits are being manipulated, and how values actually have to be stored somewhere in memory which has an address -- they sort of explain themselves and all the mystique disappears. Understanding the *why* of pointers is important, why they are even a thing at all. Going from a high-level downward is, in my opinion, much less natural than the opposite direction, so I think taking a bottom-up approach can really help. Good luck :)
Sorry for the short reply - I'm on my phone. But, a really good example for you to check out would be the BusyBox source code. They do this extensively. 
Hey -- pointers aren't too bad. I'll bet you can get it. Linked lists are just one application of pointers, so I'd start with pointers generally, then work on your linked list. In a sentence, pointer variables just hold memory locations. Dereferencing them gives you access to the value stored at that location. This is different from "normal" variables where the variable holds the value instead of the memory location. Think of them as two sides of the same coin. Let's use an example: int v = 5; // our variable, its type is int. int *p; // our pointer, its type is pointer-to-int p = &amp;v; //&amp; is the 'address-of" operator. This line says p equals the address of v printf("%d\n", v); //prints "5" printf("%d\n", *p); //also prints "5" because *p says "the value at location p" There are also ways to use the pointers alone, without just keeping the address of other variables there. This is when we allocate memory to one (using malloc, calloc, or realloc). I think it's best to leave it at that. If you have questions or examples you are stuck on, fire away. 
Wow, thank you so much for such a detailed answer. Working on digesting it all now :)
Thanks so much!
I have K&amp;R assigned in my C course this semester. I thought it was laughable to have a book from 1978 assigned in a course taught today in computer science. Then I started reading.
If you’re good in Java, pointers should be dead easy. Anything in Java that’s not a primitive is a pointer (a.k.a. reference in Java parlance, but pointer). If you pass an `Object` argument to a method, you’re passing a pointer to an `Object`, and if you return a `String` from a method, you’re returning a pointer to a `String`; i.e., // In Java: static void doSomethingTo(Object thing) {…} static String getSomeString() {…} /* In C: */ struct String {…}; struct Object {…}; void doSomethingTo(struct Object *thing) {…} struct String *getSomeString(void) {…} Managing the memory these pointers refer to can get more complicated in C, although you have fairly complete control over object lifetime, whereas Java just sorta cleans things up maybe sometimes if it feels like it. C goes a bit farther with pointer types than Java does with references, and it lets you refine things with `const` and `volatile`; e.g., if `doSomethingTo` shouldn’t be able to (or needn’t, or both) modify `thing`, you can declare it `const struct Object *` (pointer to constant `Object`). This is in contrast to // In Java: final Object thing = …; /* In C: */ struct Object *const thing = …; which means `thing` is an unmodifiable pointer to some object. Or even const struct Object *const thing = …; which means `thing` is an unmodifiable pointer to an unmodifiable `struct Object`.
Yeah that's not helpful. Also, hardly any software developers actually use pointers in day to day work, it's kind of a dumb thing to be gatekeeping over
[removed]
Need information on the compiler and platform, but guessing Linux or POSIX and something GNUish (GCC, Clang, IntelC). Is the boundless function part of your code or a library? If it’s in a system library, you can usually install debuginfo packages in addition to the normal library stuff. If it’s in a library you built, try rebuilding with `-g`. If it’s your own code, are you compiling with option `-g` to emit debug information? Are any optimizations enabled? If you need optimizations beyond `-O0` but need to be able to single-step debug sensibly, `-Og` will optimize without wrecking debugging too badly. Are the function symbol type and size directives being emitted in the assembly? `-S` option will give you a .s file to check.
do not code C like OOP, if you are just learning keep it simple and learn the basics first 
You win the "Asshole of the Day" award. Congrats.
Thank you so much Florida\_ Owl! You probably don't know this but I have questions before about C and you have helped me so much...really appreciate it
I'm definitely going to read that book then!
Thank you for the link! This seems like a very good reference!
I'm actually surprised you're having troubles. Java is so much more difficult than C. Short form: pointers are what Java calls references. Long form: C was essentially invented in the 70's to replace assembly language, which was the the only way to access stuff right at the hardware level back in the day. I say this, because knowledge of assembly language would actually be very helpful in understanding C. Nearly everything in C has a direct analog to the hardware layer. The thing to understand is this: computer memory is divided into words and bytes. Bytes are the smallest bit of memory the system can address (nearly always 8 bits, especially in modern architectures) and a word is whatever the "natural" unit of storage is for your cpu. Typically 32 bits on modern architectures. All memory is addressed by a numeric "address". Literally just a number that specifies the memory location to be accessed. Again, typically 32 bits. So … the value in a word of memory *could* be just a numeric value. *Or*, it could be an address of another word in memory. This is what a pointer is. When the computer wants to read a word data, it might know where that data is stored, and just read that 32-bit value out of memory. But sometimes it reads a pointer value and the pointer tells the computer where to read the actual data. In assembly language, we call this "indirect addressing". In modern parlance, when you read a pointer, and then use that pointer to read something else, we call that "dereferencing". Adding on: that pointer might not point to the actual data, but to another pointer, and the second pointer points to the data. In fact, there's no limit to how many pointers you have to dereference to get the the eventual data. In C, a piece of data might be declared like this: int value; Now "value", as far as the C compiler is concerned, is the 32-bit address where some data is stored. A pointer would be declared like this: int *value; Now "value" is the 32-bit address where a pointer is stored. If you dereference it, e.g. `a = *value;` then the compiler will read the 32-bit value from the storage location "value", and use *that* value as the location from which to read the actual data. int ***value; Declares a pointer to a pointer to a pointer to an integer. If you dereference it with `a = ***value;`, then the compiler will generate code to read the 32-bit pointer from "value", use that as the address of another 32-bit pointer, use *that* as the address of another 32-bit pointer, and use *that* as the address of the memory location with the actual value in it. In machine language, it might look like: ld r1, value ; load data from "value" into register 1 ld r2, (r1) ; load the location pointed to by register 1 into register 2 ld r3, (r2) ld r4, (r3) ; now we have the final value in register 4 ---- Linked lists are not complicated. Each node in a linked list is a data structure (aka block of memory) which contains as one of its members, the address of the next node in the list.
I'm not just learning but this is going to be my first big project. Is the alternative really to have everything in the main() scope? Doesn't that get messy for large projects?
wait i miss understood then i taught you are talking about breaking the code into separate file but it seems you are talking about functions and if that is the case you must break the code into smaller function and not all in main
Thanks for this info!
Your startup process will probably enter a normal menu loop and either `switch` or array-map the menu option to whatever underlying command. Once you have that set up, the parent `fork`s and *usually* `waitpid`s (or `wait4` or whatever) the child process. (Whether it’s immediate or not, you should `wait`\* for any children you create to avoid leaving zombies staggering around.) The child process sets itself up for execing, then does the `exec`; if that fails (i.e., returns at all) the child process should do a `for(;;) exit(127);` to make sure it doesn’t fall back into the code intended for the parent process. (Lots of other stuff can fail also if you’re setting up redirects and pipes and such. Error-check any library/system calls neurotically.)
Even if system didn't need to start a new process, sh still needs to parse the command and args, interpret, then execute fprintf() itself (if I remember the implementation correctly). That alone would require the system call to be slower. Then you can add on all the overhead mentioned above.
Take sometime and drill with pointers using small programs until you internalize how they work even if it may take more time to understand why they work. &amp;#x200B; Also, it may be helpful to think of variables in your program as containers: int n is a variable that can contain an integer value -- rather than thinking that it IS an integer Likewise, int \*p can contain an address to the memory that can store an integer -- rather than thinking of it as a pointer to an integer. int a\[10\] can contain an array of ints -- rather than thinking it IS an array of ints. &amp;#x200B; I think it would have been better to start with C and then learn java but it is what is. Good luck! 
Can you use PF\_ROUTE sockets.
"callback" is the only word you need to make this argument. Gtk is my go-to for gui programming. There wouldn't be any functionality behind widgets without callbacks attached to signals.
QT is the current top dog i think, but it's been a long while since I checked https://www.qt.io/developers/ You might want to brush up on your C++ going in though. GTK is another option... https://www.gtk.org/development.php
Definitely possible. A quick search on this sub yields a good deal of previous conversation on the topic. https://www.reddit.com/r/C_Programming/search?q=title%3Agui&amp;restrict_sr=on&amp;include_over_18=on&amp;sort=new&amp;t=all
I will look into that
Yes, it's possible. GTK is probably the most popular GUI-toolkit that's written in pure C and runs on Linux: https://www.gtk.org/
no, I am mostly talking about what scope to declare my variables in.
Pointers aren't hard, you just have to change your thinking. A pointer is really just a variable that contains a value like any other variable. the difference is that that value is a memory address to another location somewhere in the ram. that's it, that's the whole idea.
XLib Programming Manual, Volume. 1. .. All of the X toolkits, like the ones mentioned above, and others, are built on top of it. The first volume is a tutorial and cookbook. Its discussion of font handling is somewhat outdated - it doesn't cover outline font rendering for TrueType fonts. For any other tasks that toolkit designers didn't foresee, like borderless, transparent, or non rectangular windows (in many cases), it's necessary to be familiar with using XLib calls and events directly. The library is also installed with the display server, so in general you shouldn't need a complex toolkit upgrade nearly as often, I think. So it's more durable, I think.... 
The truth hurts you, doesn't it?
The only dumb thing are people who can't figure out pointers. \&gt;hardly any software developers actually use pointers in day to day work Hardly any REAL software developers, not the pretenders of reddit, DON'T understand pointers. They're the simplest thing on earth.
This is why schools doing languages like Java before C are completely backwards. Learn C and you'll understand better want Java is doing behind the scenes. Starting with Java you have no idea what's going on in the JVM and what leads to do many misconceptions in technology by young developers. It's like learning how to use a calculator before even knowing how to do 2+2.
Qt is C++, GTK is C.
I want to add to Gtk vurtun's nuklear Gui library(single header, ANSI C) Do keep in mind that it is an immidiate mode Gui, but you can write(or copy paste) your own renderer, so it will run on nearly any platform link:https://github.com/vurtun/nuklear
https://github.com/vurtun/nuklear
Considering that Linux is written in C and you probably are posting this from a GUI on Linux, it's obviously possible.
The best book is the one you read out of.
Your operation for binary is essentially multiplying 2 or 0 by increasing powered of 10, which is why its printing 22. You want something which uses the lsr operator &gt;&gt; Then you can check the least significant bit and print 1 or 0 until you have checked all the bits in the int (or just the first byte if you don't want 32 bits to print) 
 &gt; pointers, and linked-lists Those are where all C developers' fall short. You never get a bug because You added two pointers together. 99% of all bugs in our team is because double free, use after free, wrong pointer arithmetics, etc. The struggle never ends, you just get better at creating more elaborate bugs.
It might help if you provided a concrete example of the sort of variables and code you are thinking about here.
Link is down for me. :|
If a piece of data is a “house”, a pointer is an “address” to a house. If you want to access or modify the house, you need to know its address. You cannot move a house. You can copy it somewhere and delete the original. You can increment the address, which will take you to a new house. If you lose the address of a house, the house still exists, but you’re screwed. I used to be scared to pointers a year ago. Now I do pointer arithmetic and use double pointers sometimes.
The problem is not Reddit where people ask questions but that you are a condescending cunt. 
No. Wrong much?
this is a common way of writing c code esp for embedded software - there's some cons but the pros are pretty good too, namely it's simple to understand and it's very efficient (in terms of assembly code need, it's faster/smaller than the alternatives). doing this, you basically treat each translation unit as its own fully instantiated module (like a singleton, but even lighter weight). for small projects, this is perfectly fine. there's less of a stigma in file scope variables in (embedded) C than in other languages. the other way is to structure everything with structs (which contain the state), and pass pointer to structs around as needed. the structs can be statically defined or dynamically created. files are generally functions that act on a struct of this type. this is common for larger projects, but might be overweight for a small embedded project. you can extend this by using function pointers and base struct casting to simulate inheritance (this gives you what ppl call object-oriented C). it's pretty powerful, but there's a lot to dislike about using C to write oop style code (cuz i mean, why not just use C++ in that case). so in summary, if you are writing a small limited program, by all means use file scope variables. 
Already answered. Will answer again. Result=1 (this initalization goes outside the 'for' loop) WITHIN the for loop: Result=Result*2
Search for "pointer fun binky" on youtube. That's where it "clicked" for me. It's just a few minutes of video.
For a game, you need an event loop. It works like this: - check the user input - advance the game state by 1 step - update the screen status (= what needs to be changed on screen) - update the screen (complete or incremental redraw) - repeat "Repeat" does not mean "as fast as you can", because then the game would go faster on faster hardware. It means "at a specific frame rate". The amount of change in the state might be smaller for a higher frame rate, or you might use a fixed event loop "frame" rate, and update the screen once every "n" frames. 
``` int square(void) { static int counter = 1; counter *= 2; return counter; } ```
 int square(void) { static counter int = 1; counter *= 2; return counter; }
😄 That’s a great little video!
The book we used (written by our lecturer) is 'Programming, Problem Solving and Abstraction with C' by Alistair Moffat. I thought it was an outstanding book for a beginner class on C. I found the level of detail to be perfect and there are lots of example code snippets. He's a really funny guy too which really shows in his writing. Honestly depends on the content of your class but that's my recommendation :) (it's quite cheap for a textbook which is a bonus)
yeah, just zip it up and put it on a website. focus on making your game first. you can learn as you go.
You are Jesus. Thank you.
A text game for a console could be problematic in raw C unless you have a decent development environment. Do you mean for the PS4 and the like?
It seems like you have a bunch of responses already, so once you’ve grasped the concept of a single pointer, come back to my comment. This is what made it “click” for me, but’s it’s definitely a more intermediate concept. Let’s say you have a pointer `char* c`. What’s the size of `*c`? A byte (8 bits), since it evaluates to “the value stored at a character”. What’s the size of `c`? Well, it’s the “word size” of the architecture you are using (x86 on most PC’s and laptops, ARM ____ on mobile and embedded devices). To understand this, you have to realize that a computer’s understanding of RAM is simply a big array of space that can be used to store stuff. Consider how we access specific chunks of memory: The word size defines the native number of bits in a hardware register as well as the “address space”. Since a register can only physically store X bits, the architecture can only (natively) reference memory addresses that can be stored in X bits, specifically [0..(2^X)-1]. So, addresses are X bit numbers. Now, what’s the size of a hypothetical `char** p;`? Well, it will be the same size as `c` because they both hold *addresses* instead of some type of value (int, char, double). So, size of: `char* char** char*** ...` will all be equivalent, because they all refer to addresses— specifically, they will be X bit numbers. Until you make it all the way down the chain (in the case of our previous single pointer this would be `char* c`) the size of the pointer will always be the same as the native word size. Although pointers are not a type (they simply represent levels of indirection), it helps to think of them as one. They are devices by which you *find* values of a certain type, and they are all the same size (until you reach their value) since they carry out the same purpose.
Maybe try learn programming subreddit. AFAIK C and C# are pretty distinct so it might be that you would need two tutors. 
Yep, I'll post there then :D Oh yeah of course -- didnt expect same person. I just would appreciate help with either one. 
Since you’re using C and calculating powers of two, try using a bitshift. 
I can help you with C if you want, right now C is one of my “strongest” languages. I have also done 2 years C# in the past, but I don’t feel so comfortable with it right now. I have send you a private message.
Oh yeah. We show that video to our students in our C classes.
A few things to consider: -When you use scanf you need to add &amp; in front of your variables (as we want the address of the variable. I'm assuming you haven't learnt pointers so I won't go into further detail) -Be careful of divisions in c. As you are dividing your score by the integer 'total marks' it will always perform integer division (you will never get a decimal) -You are missing a %lf in your final print statement when you print the percentage A lot of these things are very important to know so I would recommend you try to master these before moving on to any other topics. 
ah okay thanks for this!! do you mind explaining to me float? like why is percentage a float function? is that why i write %f?
You declared the variable percent as a float in your first line - therefore it is a float.
replied :)
It's completely pointless. The network stack will automatically select the correct source address for the connection. If you need to bind to a specific port, just set the address to `INADDR_ANY`.
What did you expect would happen?
A real software developer is one who gets paid. Have you ever had a REAL job as a developer?
Upvoted in assumption you're joking.
*Hey just noticed..* It's your **3rd Cakeday** t4th! ^(hug)
You didn't specify what values the array elements are supposed to have. What do you expect?
Link works. If you still have issues search google for Ted Jensen's Tutorial on Pointers and Arrays
When you declare an array, what you are really doing is asking the OS to give you some memory to play with. The OS doesn't know anything about the memory excepts who, owns it. Usually, the OS just gives you a random unused spot, and doesn't bother to clean it. What you get is whatever was previously left by the last program who used that memory spot.
When you define something without initialising it you'll end up with whatever's already in the memory that's been assigned to your variable. If you don't want this to happen, you need to initialise the variable as well, e.g. int main() { int lucky_numbers[10] = {0}; printf("%d", lucky_numbers[9]); // 0 return 0; }
As people before mentioned when you declare the an array or any other variable you are basically saying: "Assign a specific place in memory, holding the number of bytes needed for this type and make it possible to reference using this variable name" &amp;#x200B; The memory in that specific place will already contain different values, maybe from an earlier variable but it does not really matter, you got a place where you can store your values. When you assign to it you are writing values to that place in memory. &amp;#x200B; You can visualize it like this (this its not exactly how it is happening in reality but it shows the point). &amp;#x200B; Bytes (with random values) in memory: | 200 | 12 | 34 | 0 | 100 | ..... &amp;#x200B; char b; | 200 | 12 | 34 | 0 | 100 | ..... \\ b is assigned to this byte in memory, the value of b would be 12. &amp;#x200B; b = 20; | 200 | 20 | 34 | 0 | 100 | .... \\ the place in memory represented by b is assigned the value 20.
print nothing.
Your question already contains the answer.
Hey was the same for me a few weeks ago, I am great at C++ and Java but C pointers were (and are still a little bit though) so I watch videos, read the following books and most importantly, I coded short functions in C, got a lot of segmentation fault, core dumps and debugged with gdb, used gdb print func print (pointer) and finally wrapped my mind around the fact that C is a passed by value language when Java is a pass by reference one and now, I am more at ease with pointers. Hang in there, buddy
why can i not get this to simply print: The student scored 10% in this exam. #include &lt;stdio.h&gt; int main(void) { int total_marks; int scored; float percentage; // Input marks of five subjects from user printf("Enter the total number of marks in the exam: "); scanf("%d", &amp;total_marks); printf("Enter the number of marks the student was awarded: "); scanf("%d", &amp;scored); // Calculate percentage percentage = (float)scored / total_marks *100; printf("The student scored "%f" in this exam.\n", percentage); return 0; }
What bothers me about pointers the most is that the asterisk is used both to declare a pointer type variable and to dereference a pointer. In the example above, "int *p;" declares an integer pointer, and "*p = 10;" assigns a value to what it points to. While at it, this [https://karwin.blogspot.com/2012/11/c-pointers-explained-really.html](blog post) is what clicked for me. It has some good practical illustrations.
You are telling your compiler "show the value of lucky_numbers[9]". There's no way for the printf function to now that the value it is handed is garbage. The only thing it can do is assume it's valid and show it. Even if it could know it isn't valid, why should it print nothing? Wouldn't it be more useful to crash and tell you it doesn't know what to do with it?
I didn't understand pointers until I learned how they were used in assembler. Just type some simple pointer code into godbolt.org and experiment
[Not that kind of console.](https://en.wikipedia.org/wiki/Console_application)
**Console application** A console application is a computer program designed to be used via a text-only computer interface, such as a text terminal, the command line interface of some operating systems (Unix, DOS, etc.) or the text-based interface included with most Graphical User Interface (GUI) operating systems, such as the Win32 console in Microsoft Windows, the Terminal in Mac OS X, and xterm in Unix. A user typically interacts with a console application using only a keyboard and display screen, as opposed to GUI applications, which normally require the use of a mouse or other pointing device. Many console applications such as command line interpreters are command line tools, but numerous text-based user interface (TUI) programs also exist. As the speed and ease-of-use of GUIs applications have improved over time, the use of console applications has greatly diminished, but not disappeared. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; a book from ~~1978~~ 1988 FTFY 
I know what a text console is. From his wording, his newness, and the term "download and play on console", I was trying to clarify. 
First published in 1978, second edition in 1988
If you don't *specifically* define anything, it's... Undefined. There's a reason many IDE linters will scream at you if you try to use a variable before assigning anything: there's literally 0 clue of what you're going to get. But think about it for a second, you answered your own question... In your question.
It depends, the best thing is to have as little to no variable declared globally since it will put it in heap and just stay there for entire time. But sometimes you got to put them there like maximum length or stuff that are static. By time and practice you will learn what to do but ask your self this are you going to use the same variable with the same content all the time or are you going to just use it once. If the first one put it globally otherwise locally 
With [raylib](https://www.raylib.com), a simple C library for games programming similar to SDL, some [game templates](https://github.com/raysan5/raylib/tree/master/templates) are provided to structure your C game. Also, a [bunch of small games](https://github.com/raysan5/raylib/tree/master/games) are provided using those templates.
Please do not post links to copyrighted material.
No blog spam please.
Well that's certainly not true.
Try [https://pdos.csail.mit.edu/6.828/2012/readings/pointers.pdf](https://pdos.csail.mit.edu/6.828/2012/readings/pointers.pdf) &amp;#x200B; His site might have hit a limit.
The "" round the %f needs to be removed. -&gt; `printf("The student scored %f in this exam.\n", percentage);` &amp;#x200B; How do you even compile this? Normally your compiler should give some errors
Actually everything in Java is an instance of Object String is a Class and so you can use it as a Variable Type, and classes can define Methods Every Object is a Datatype
The thing that helped with pointers was to think of them like aliases. So I would think of them as sorta like doing alias c='clear'. It helped me to understand them much easier. I hope thag helps! I can't really recommend either book as I only have done a little bit of K&amp;R and none of Modern Approach, but I hear both are amazing. Good luck!
(Gross over simplification, but works for this...) Procedural Programming is effectively saying "I have this blob of data" and then walking up to someone else and saying "Tell me about this blob of data". Object Oriented Programming is having a blob of data, but instead of others, going to the data and saying "Tell me about yourself" Or "Act on this data/yourself" or whatever.. but you get the idea. C has data and functions to act on the data. Java has data and the data includes functions to act on itself.
C does not have classes. In Java, many different container classes have a `length` method to indicate the number of elements in them. Other languages, like C and Go have functions to do the same. It all boils down to what decision the designers of the programming language made.
No no no -- C is a "with great power comes great responsibility" language. Allocating memory does not mean initialization. Similarly, accessing an index out of bounds (in stack memory) is an undefined behavior. (Someone please correct me if I'm wrong). Accessing index out of range on the heap should result in a segfault. What you're doing is undefined -- it might crash, it might not -- undefined behaviors are typically compiler-dependent -- but it's definitely not going to silently ignore whatever is already stored at that memory address you're referencing.
common dude, linked lists are just Blockchains with hashes and pointers are my darling 
In java, you ask the string to give you its length. In C, you have a pointer to the beginning of a chunk of allocated memory that you personally believe is a string. If you want to know the number of characters in your string, you use a function to count them for you.
Not sure what kind of answer you are looking for. C++ took C and added classes as a form of encapsulation, but left native things like strings somewhat alone. Java simply took the next step and encapsulated strings too; Java is very much just C++ on steroids. There's no real difference under the hood, but it makes life a little easier when you are in a Java IDE which will autocomplete the method for you if you just start typing "len". Languages like Perl and Python went in the other direction and make len()/length() a sort of universal function which would hopefully spit out the expected answer no matter the underlying data type. They are all just different linguistic approaches.
The original design intention of C was that numeric computations use the largest integer type or the largest floating-point type. The need for unsigned types emerged as a consequence of two things: 1. Although many platforms use wrapping two's-complement semantics, programs that needed power-of-two wrapping sometimes needed to run on platforms that didn't. Unsigned types were necessary to accommodate them. 2. Although an inability to fit a numerical quantity within range of a particular size integer would generally indicate that it likely to soon need more than one extra bit, quantities which might exceed 32767 but couldn't possibly exceed 65535 were especially common on platforms that used 16-bit addressing. It's often useful to have functions that can return a quantity on success or a negative number in case of error. Further, the fact that a function accepts an unsigned type may be taken as an indication that values between INT_MAX+1U and UINT_MAX will be interpreted just like any other, but such treatment may not always make sense. If a function that is supposed to copy a string to a buffer of unsigned size `n`, or report a failure if it won't fit, that would suggest that if passed an `n` of `-1U`, the function should assume the buffer will be large enough to hold the entire string. If it accepts a signed `n`, however, that would suggest that if it's given a negative size it should signal a failure because the string won't fit. I've spent most of my career programming platforms where `INT_MAX` is 32767 and `UINT_MAX` is 65535. Using such platforms makes it necessary to employ semantic concessions and workarounds that wouldn't be necessary on larger platforms. And I admit I still use unsigned types a lot as a matter of habit, since the old platforms couldn't perform signed comparisons efficiently. Perhaps I'm also spoiled by the fact that even though INT_MAX is 2147483647 on the platforms I'm using now, no objects will ever get anywhere close to that size (few will even exceed 32767 bytes). Nonetheless, I view signed types as generally preferable for representing quantities except in cases that might plausibly involve numbers in the range 2147483648 to 2147483645. 
&gt; Actually everything in Java is an instance of Object Java has scalar types as well, and strings are weird: a variable defined as `String` can represent either an object of class `java.lang.String` or a reference to a string pool managed directly by the JVM. The distinction is less visible now that Java has automatic boxing and unboxing, but that is implemented by the compiler, not by the JVM (meaning that in situations where boxing or unboxing is required, the compiler silently generates the same code that would have resulted if you had done it explicitly).
Oh thanks, didn't knew thanks for correcting me
Thanks, this works. :)
EFL - Enlightenment Foundation Libraries [https://www.enlightenment.org](https://www.enlightenment.org/develop/efl/start) [https://www.enlightenment.org/develop/efl/start](https://www.enlightenment.org/develop/efl/start) Motif [https://motif.ics.com/motif](https://motif.ics.com/motif) IUP TK XForms &amp;#x200B; ...
I was not able to learn this from a single book, I spent a very long time experimenting and writing code and toying with things and making shit break before I really understood it. So, I don't think the following is going to help you, but I'll try; When you declare a variable in C, you are telling the compiler to reserve some of the memory in advance to hold that variable. So, when you use something like `char foo[100];` you are instructing the c compiler to reserve 100 bytes of memory. A char is one 8-bit byte long - in most implementations ;-) a pointer declaration, such as `char *bar;` only reserve enough memory to hold a memory address, which on a 32bit system is 4 bytes and on a 64bit system is 8 bytes. you can declare a char array like `foo`, and then assign the address of `foo` to `bar` with `bar = foo`. in reality, you can then use `foo` and `bar` the same way - the compiler will be happy for you to address individual `char` locations with `foo[10]` or `bar[10]` (to get the 11th char, 0 is the first). But, `bar` is a pointer type, and `foo` is not - so while you can assign `bar` any `char *`, `foo` is limited to only ever pointing to the memory the compiler allocated during compilation. Same deal with non array types; you can define `int foo`; and then have a pointer `int *bar`, and assign the address of `foo` into `bar`. You can then get and set the value of that storage, of `foo`, by dereferencing the pointer eg, `*bar = 5` is the same as `foo = 5`. So you will ask, why even use pointers at all? One main reason is because you don't have to define the amount of memory your structures need up front, and can dynamically allocate memory using `malloc()` and assign that allocated memory to your pointers, and manipulate them just like they are a variable that was defined statically. Pointers point to memory. Statically variables define memory, as does dynamic allocation using malloc(). Pointers point to memory, and you can peek at the value or poke into the value of that memory by using the dereferencing operator. Write some code, toy around with the language. Allocate arrays. Arrays of integers, of chars, of structs. Allocate statically and by using malloc(). See what happens when you read memory that has not be initialized. Dereference char \* arrays and print their contents. Mess with the strings.h library. It might be that you are like me and that no amount of book reading is going to get you there. That you will need to just experiment util you get it. Good luck! And don't be afraid to ask questions in here. People are helpful, as you can see. The only thing that I dislike is when people new to the language post homework assignments. Please don't do that ;-)
That's why we version our ~~code~~ books
The syntax is intentional to visually link the declaration and usage of the pointer. The `*` operator dereferences a pointer; when you declare an `int *` variable like that you're saying "this is a variable that dereferences to an int". &gt;Hm. Does p have an address? Sure. It is a variable, and all variables have their own address. This is NOT true, although any variable that you explicitly dereference with `&amp;` will have one. An optimizing compiler can happily replace "variables" on the stack with temporary values in registers, or data segment constants, if it can tell that doing so does not change the execution of thep rogram.
For those who might be interested, I added an asciinema short demo on the repo. &amp;#x200B;
&gt; I thought it was laughable to have a book from 1978 assigned in a course taught today in computer science. Then I started reading. It's literally *THE* book from which *ALL* other books sprang.
It's a tough situation. If you start with C (or assembly), it takes a LONG time for students to be able to write useful/fun/interesting programs. Anything beyond console input/output is VERY painful in C, and even that has extremely clunky and outdated syntax compared to something like iostreams in C++. If you want to focus on teaching logic and "software engineering" rather than a specific language or architecture's syntax, C is mostly getting in the way. The undergrad CS program I did started students with Java, and the *midterm* assignment for the "programming 101" class was making a working (though very very basic) Tetris clone. That would be a lot harder in C. That said, stuff like https://www.nand2tetris.org/ is a really interesting approach as well. Our architecture course did something similar, building up from logic gates to making digital logic and a (very simple) CPU in a circuit simulator program, and then you'd write a (very simple) compiler that could output programs you could run on the simulated CPU.
Your inner loop has a typo comparing i to c instead of comparing j to c.
god damn i wish i could marry you , thankyou man
UINT\_MAX is an unsigned integer maximum, you should use %u not %d.
%d outputs a signed int. You’re looking for %u. %ld prints a signed long int, which fits a UINT_MAX and thus you get what appears to be the expected output
UINT_MAX is the maximum value of an unsigned integer whereas %d is the format specifier for a signed integer
You want to use %u for an unsigned int. %d is for signed int's, %ld is for long signed int's. &amp;#x200B; [http://www.cplusplus.com/reference/cstdio/printf/](http://www.cplusplus.com/reference/cstdio/printf/)
good spot.
Think of memory as containing a bunch of numbered boxes, each of which holds CHAR\_BITS bits. On a typical platform where `char` is 8 bits, `sizeof(uint32)` will be 4 (i.e. 32/8), and reading an object of type `uint32_t` whose address happens to be box #1234 will cause the machine to read 8 bits each from boxes #1234, 1235, 1236, and 1237 and combine the values to form a 32-bit integer. This model will work pretty well to describe how C works, with three caveats: 1. On many machines, boxes are physically placed in groups of 2, 4, or 8, and certain kinds of objects must be stored so they fit in a single group. 2. On some machines, there are multiple disjoint ranges of numbered boxes. A pointer may identify "box #57 of group #19". One can do arithmetic on box numbers within a group, but not on box numbers that belong to different groups. 3. The Standard allows compilers to assume that programs will only access boxes in certain ways, even though some kinds of "low-level" programming require that programs form box numbers in "interesting" ways beyond those contemplated by the Standard. The Standards Committee expected that people designing implementations to be suitable for low-level programming would be better placed than the Committee to recognize when their customers would need such constructs, and thus did not think it necessary to mandate support for everything that programmers might need to do. Unfortunately, some compiler writers, however, interpret the Standard as inviting them to assume that programmers will never need anything beyond what the Standard specifies. Consequently, anything that wouldn't work in the "box model" probably won't work on real C implementations either. Further, most implementations will be able to do just about anything that would work on the box model if caveats #1 and #2 are applied and optimizations are disabled. Unfortunately, enabling optimizations will cause many implementations to adopt a much more complicated and nebulous behavioral model which takes the "box" model, but with a poorly-mapped maze of landmines in front of it. Avoid all the mines and it works just like the box model. Hit a mine and a program may behave in arbitrary fashion. It's generally agreed that some parts of the maze should be free of mines, and that programmers should avoid some other parts, but for much of the maze there's never been anything resembling a consensus. 
Is the string pool not simply an indexable collection (like an array, but only accessible to the JVM) of references to `String` objects which get constructed by the JVM when a class is loaded, but afterward behave just like any others? 
Yeah, insofar as `int x = 6` is copy initialization. The right hand sides of your initializations are just casting the integer literals to (void *).
These kinds of bugs are always super annoying. I would recommend looking into GDB as it would have sped up finding the bug a ton. It's a great skill to have and I wish I would have learned it much earlier than I did!
May I ask what kind of university you go to? Is it a private or public or online school? I’m also worrying about taking programming courses at a 4 year. I’m in community college right now
It's not obvious to me what has caused the specific problem you are experiencing is, but I can certainly see _a_ problem in the code, here: while (graphFile) { graphFile &gt;&gt; nodeIndex; graphFile &gt;&gt; outIndex; // Add the new outgoing edge to the node graph[nodeIndex - 1].push_back(outIndex - 1); } nodeIndex is read from the file, but it is not validated. Then it's used as an array index. So if the input file is incorrect the program will use an out-of-bounds array index. For that matter, it's likely that the program can have uninitialized data if you skip an index in the input file.
how can I solve that? im not pro enough to fix that
Tutoring should be included in your tuition fees. Speak to your actual tutor.
Thanks for all the info! So, actually it's not such a small project. When you talk about the alternative, putting everything in structs to make it easier to pass around, these structs are all scoped to main(), correct? This is what I'm leaning towards currently
http://www.cplusplus.com/reference/ The `Example` section at the bottom of each page. inb4 cpp!=c
some pdfs from Stanford University ' http://cslibrary.stanford.edu/102/ http://cslibrary.stanford.edu/105/ Harvard University's Introduction to Computer Science (CS50) lecture on linked lists (really great lecture) https://www.youtube.com/watch?v=pA-8eBZvN1E https://pdos.csail.mit.edu/6.828/2012/readings/pointers.pdf 
It might be convenient, but it's not allowed in C 
In C programming char arrays end with a null character '\0' which marks the end of the array. In this example the char array or string 'name' has 25 characters but you can only use 24 because the last character would be '/0'. strlen(name) returns the number of characters in the name array [which is 25]. &gt;name[strlen(name)-1] ='\0'; This sets the last character of the name array to '/0' or the null character.
This is why I don't use i's or j's for loops. I'll use inner, outer, index, horz, vert, etc etc. Had that bite me way too many times.
LittleVGL if you want something that can run on Windows / Linux / Embedded Linux / Bare Metal and QT doesn’t fit your licensing needs. 
Also, suggested reading: `man printf`
Sorry if i wasn't clear enough, but i mean the console as in for example, Visual Studio when you want to test a script, and it'll show you the console.
Totally believable -- just making sure. I tend to see that referred to here as "Command Line Interface" as opposed to "console", but "console" is equally correct.
Thanks!
Most useful comment of the thread. Variable names should convey meaning.
good point, although `man 3 printf` as `man printf` gives printf(1).
You're doing, in my opinion, one of the worst things a beginner can do. Bide for time. C is stupid simple and the resources for it online and in text are so fucking numerous that quite literally anyone can learn the language. What your doing is wasting time "looking for a tutor" because you don't want to feel like you aren't doing any hard work, but all you're really doing is wasting time. Google C resources, look at the million "beginner C" posts on this reddit, Google anything you don't know or doesn't make sense right away. If you can't find resources to properly learn C now what will you do when you have to learn other languages and API's, God forbid you read some documentation. TL;DR - take a look, it's in a book... 
* This sub is for C, not C++. This post belongs in /r/cpp_questions. * Please format your code. Reddit's editor includes a handy "Code Block" button to make this easy to do. (Don't use "Inline Code" for this purpose, though.) * The problem is that `getLength` and `getWidth` take their parameter by value, don't return anything as promised, and `main` doesn't use the returned value even if they did. The end result is that the `length` and `width` local variables aren't initialized, resulting in undefined behavior (presenting as calculating a meaningless value) when those variables are used.
Book looks pretty good. Gonna check it out.
It's impossible for the computer to have a piece of memory with nothing in it. You will always have some bit-pattern there.
[raygui](https://github.com/raysan5/raygui) is a simple and easy-to-use immediate-mode gui library, running over raylib. It's written in C and very portable (single-file header-only).
Meaningful variables would help, too. “col” and “row” would have been better than i and j.
Its a public school. My course isn't 4 years tho. Why are you worried? 
its not sadly, not at my school. you only recieve tutoring if you are a minority, etc. 
okay can u chill with the passive aggressiveness... what makes u think i dont have countless resources already considering the fact im studying the damn language in my university? personally, its not simple to me and i find it hard -- is that bad? im struggling with it, because i dont feel just 'reading' a book about C is going to make me any better. i need actual help with concepts, and implementation, hence me going to look for some online help. im in my first week of uni -- so im not technically wasting any time, i want to find someone to aid me as early as possible so im not doing it last minute. don't be such an asshole dude, appreciate the help but you don't have to act so condescending and assume stuff without asking. if someone said this last year to me, then its totally accurate. i wasted a whole semester doing nothing, and just relying on a tutor literally 4 days before an assignment was due. don't want to do the same shit this year so i want someone to help me through the bulk of the content. TL;DR - take a xanax and relax 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
You're right that I was being a little bitch, but I still stand by what I said. Your time is better off posting specific questions on this sub or finding more resources online. Reading is like a majority of what computer science is. Computers are very much still in their infancy and there won't be tutors when you need to pick that new shit up. Programming is hard. There is still so much shit that I need to learn too, but when I hear someone who is in university (so they already have an instructor to ask) ask for a tutor I ask myself, "damn, how is he ever gonna handle anything else if he can't learn something this fundamental." that's not to say your problems are invalid, they most certainly are not, but asking for a tutor on something that you're paying an actual class for seems so inane. If the instructor is unclear, ask a question. If you still don't understand, read up on it. If it still doesn't make sense, watch a demonstration of how it works. There are a million steps to take before resorting to paying for another instructor. 
look, im just straight up wack and i dont understand anything like thats just the truth, even when my own instructors explain it to me my brain is like the clapping monkey from the Simpsons in homers brain, so i just feel embarrassed asking them to reexplain it to me when another 50 students are begging for their attention. i had a tutor last year that in that 4 days, he was able to explain everything i struggled with when it came to Python. I'm just a person that finds benefit when i have a 1 on 1 session where i can ask as many questions as needed. you're right about reading up more, and using online resources and im going to definitely take that into account and start utilising that more than i have been. ill pick up a couple good programming books today from the library :p 
If you have the time, watch the Ashley mills c programming videos that go from the absolute basics to everything you need to know about c. He is extremely thorough and since it's in video format you can just go back and watch it again to really let whatever you don't get sink in.
ooo yeah, i know him! ive seen his intro and history vid, but didnt delve in deeper. ill buckle down and watch his series then. thanks dude : ) 
Is Motif still being actively developed? It was my favorite, but the site openmotif.org seems to have only old packages. It would also be great to find out a reliable way to integrate it as a "desktop" in a current Linux distribution, as an option on the login screen.
Is Motif still being actively developed? It was my favorite, but the site openmotif.org seems to have only old packages. It would also be great to find out a reliable way to integrate it as a "desktop" in a current Linux distribution, as an option on the login screen.
Why does a clearly homework question where the person hasn't even bothered to format their post correctly get 6 up votes? The heck?
From now on i. Doing it too.
This isnt a hw and im new i have no idea how to format a post sorry.
C does not have copy/move semantics in the way that C++ does.
No, it's a pool of string literals. If you do String s = "foo"; you get a reference to the string pool, but if you do String s = new String("foo"); you get a full object with its own copy of the string.
`using` is a C++ keyword
I don't know much about the guts of C, is there an easy explanation for why this is? Is there something special about integer constants that a strong liberal would mess up?
&gt; Is there something special about integer constants that a strong liberal would mess up? lol 
/r/cpp_questions
This subreddit is for C. You could try /r/cpp.
Thanks I just searched C++ and C\_Programming came up 
I would suggest you rewrite this with num_rows and num_cols instead of r and c. Then write row and col instead of i and j. This will read better and help you catch mistakes like this. In general, if the iterater has a name, try to use it. Try to write human readable prose, and let the compiler condense it. 
&gt;Usually, the OS just gives you a random unused spot, and doesn't bother to clean it. I doubt this (with a modern OS), it'd be a pretty bad security hole if you could spy on the memory of old programs. 
"copy initialization" is terminology from C++, this terminology was added because there are different sorts of initialization. In C there is only one sort of initialization , it is just called initialization. (Not "default arguments"). 
For starters you probably want to stop using scanf() and start using gets(), then parse the integer using strtol(). scanf() has less than intuitive behavior and it will often cause bugs when taking input multiple times. You are also declaring two arrays of 10 elements, then accessing 11 elements from each (&lt;**=** 10). That's undefined behavior.
Format your code correctly. Please post the error(s).
This is not working. I have tried it. It still gives me an overflow error. 
I'm not sure how to format it better than it is already pasting into the field... The error is a stack smashing error. 
Post the changes.
? There aren't any changes. This is the code. It's giving me an smash overflow error. 
I gave you changes to make in my first post and toy said it's not working...
4 spaces in front of each line of code int main(void) { return 0; }
It's giving the same error. 
Well, you can try yourself on a virtual environement with something like 1ko of free memory. Or just alloc and dealloc repeatedly. Where do free memory comes from if not from, well, free memory?
Yeah, you're clearly not willing to actually make changes and you came here hoping to get someone else to do it for you.
%d signed int %u unsigned int
This doesn’t print all the numbers divisible by 5 or 3. This takes an input number and prints it back out if it’s divisible by 5 AND 3. Happy fizzbuzzing! 
i fixed it to || but the program just fails do you know how i can fix it so that it shows the integers less than n for which there are integers divisible by 3 or 5
Quick question. I have not used or seen the back-slash symbol used like that before (ex. `int x\[n\]` ) - Could anyone give me a quick hint? (I have been a hobby programmer for years too... "diploma" in c and everything lol - fail)
It would add complexity in the compiler and increase compilation times.
You use a loop to run on every number from 1 to n, and check for it
Hah I can finally be helpful to someone here! Your input (i) is never changing, you're going to either need a second variable, starting at 0 and incrementing up till i or decrement i till 0. (In a while loop) 
Try: scanf(“%d”, &amp;i);
mmmm apparently this still isnt right #include &lt;stdio.h&gt; int main(void) { int i; scanf("%d", &amp;i); int n =i; while (n&lt;=1) { if (i%3==0 || i%5==0) printf("%d", i); n--; } return 0; }
while(n &gt;= 1){...} I think 
While (n&gt;=1) and then replace your i in the if and printf with n. 
Try this #include &lt;stdio.h&gt; main() { int i; scanf("%d", i); for(j = 1 ; j &lt;= i ; j++) { if (i%3==0 || i%5==0) printf("%d", i); } return 0; }
Looks like you’re just starting C, so I recommend following the if() statement with curly braces. While your code works, the shorthand notation could lead to hard to find bugs as the code becomes more complex. Like previous people said before, you need to pass the address of an variable as an argument for scanf(). Also, make sure you understand the difference between &amp;&amp; and || because they will be used a lot. If you fix these errors, looks like you’re pretty close to finishing! For an added challenge, do the fizzbuzz challenge while using the % only twice. 
This code looks like what OP wants, with the exception that you’ll need to pass the address of i, and that you’ll probably want a newline after the print for formatting. 
Yes! I forgot the newline character. Can you explain nore about the adress?
Yes! I forgot the newline character. Can you explain nore about the adress?
this, but you shouldn't check if(i%3==0... but j%3==0 (as i is just the range and won't change) Also may I suggest another method. Insted of doing all this with modulo, you could find the 2 numbers smallest common multiply(15 in this case), and print every multiply of it, which is smaller then i so your loop would be for(int j = 15; j &lt;= i; j += 15)
pass the address of i? like make it a variable? 
**TO EVERYONE THIS IS THE SAME CODE BUT FORMATTED** #include &lt;stdio.h&gt; int printIntersection(int arr1[], int arr2[], int m, int n); int main() { int arr1\[10\]; int arr2\[10\]; printf("Please enter 10 numbers."); for(int i=0; i&lt;=10; i++) { scanf("%d", &amp;arr1\\\[i\\\]); } printf("Please enter 10 numbers."); for(int j=0; j&lt;=10; j++) { printf("Please enter 10 numbers."); scanf("%d", &amp;arr2\\\[j\\\]); } int m = (arr1\[0\])/(arr1\[0\]); int n = (arr2\[0\])/(arr2\[0\]); printIntersection(arr1, arr2, m, n); } int printIntersection(int arr1\[\], int arr2\[\], int m, int n) { int i = 0, j = 0; while (i &lt; m &amp;&amp; j &lt; n) { if (arr1\[i\] &lt; arr2\[j\]) i++; else if (arr2\[j\] &lt; arr1\[i\]) j++; else { printf(" %d ", arr2[j++]); i++; } } } 
Maybe you should start with reading the [linux coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html). 
scanf(“%d”, &amp;i) Putting the ampersand in front of a variables basically means “address of”. In this case, you can think of it as “address of i”. By definition, you need to pass the address as the argument of scanf() or you risk a segmentation fault. Once you start working with pointers (which is an essential backbone of C), then you’ll start becoming more familiar &amp;, *, and -&gt;
 printf("%d", &amp;i); undefined behaviour (+ overflow) j is also undefined ( and main() returns without being an int ).
&gt; printf("%d", &amp;i); This prints the memory address of i, not the value. You should only be using &amp; in scanf (unless this is what you actually want) printf("%d\n", i); 
??? I already did that change to my code. It didn't work and gave me the same error. I'm not sure what you're getting at. I've been working on this for a super long time and have tried tons of different things. 
&gt;(unless this behaviour is what you actually want) It's undefined behaviour and an overflow. I don't think there's a single reason why somebody should want that to get an expected outcome
See link [https://motif.ics.com/motif](https://motif.ics.com/motif) 2.3.8 (5. Dezember 2017 Since x11 development stopped, Motif should still work. I would use Gtk, but use currently enlightenment as display manager. EFL is not realy handy and is full of bugs :/
this worked with the help of others who fixed minor errors! Yay! Hopefully I can grasp these concepts sooner D:
People really don't seem to understand this. They walk around like, "hur dur, the bible is like the oldest and most popular book", absolutely NEGLECTING to notice it has always been K&amp;R. Like, where do people think addition came from? K&amp;R proposed it. Just despicable people's knowledge of our history.
This is as part of my research towards how to work with libpng. The repository demonstrate how to 1. Read/Write png image file 2. Process image data (in this case manually set pixel data) then write into png file 3. Plus: writing into .ppm (both P3 + P6 format) as a quick way to prove the concept Thanks!
They're looking for multiples of 3 *or* 5, not 3 *and* 5.
I know C shouldn't have default arguments, but I did see function prototypes in a header file that had them. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Thanks - Motif still has the sharpest display rendering of any toolkit I think, and customizing using X resources is still very useful (can still have lots of decorations on the background without looking like a virtual Maytag :)
&gt; I know C shouldn't have default arguments, but I did see function prototypes in a header file that had them. Then that was not standard C code.
Oh yes, I must print j. My god.
I am just starting in C and this whole thread teached me a lot. Thank you.
The sidebar has a bunch of great resources
r/cpp is youre friend for this one, this sub is for the far superior C language
Okay, thanks!
Don't just tell us that it fails, show us the code that fails and tell us *how* it fails. And you change the code to try something new, show us the updated code.
By my understanding, if `"foo"` happens to be the 19th string literal within the 43rd class loaded, saying `String s=foo;` would get translated into ByteCode that says "load string #19", and its run-time behavior would be roughly equivalent to saying something roughly equivalent to `String s = moduleStrings[43][19];`, where `moduleStrings` would behave as a `String[][]` which is owned by, and private to the JVM. If one were to write a class [forgive any syntax errors--my Java's a bit rusty] public class iveGotASecretBool { const bool SecretFlag = ...; // Either true or false static const foo1 = "foo"; static const foo2 = new String(foo2); public static String getString(bool mode) { return mode==SecretFlag ? foo1 : foo2; } } would there be any way of examining the strings returned from `getString` (e.g. using Reflection) of determining whether `SecretFlag` was true or false? I would think that Java's string-handling semantics and performance could both have benefited from having a `string` type that behaved like a primitive, as well as a `String` type that behaved like an object. Given that the language allows strings to be concatenated via `foo = bar + boz;` it seems silly to require `.equals` rather than `==`. It's too late to change that now, obviously, but having `==` test reference equality with strings actually makes things less efficient than they would need to be. If each string had space for a reference that could identify either a string that was known to be equivalent, or an object containing the hash code, and the GC knew about this, then after: string foo1 = produceBigLongStringOneWay(); string foo2 = produceSameStringAnotherSay(); string foo3 = foo2; if (foo1 == foo2) ... then once the strings had been compared and found equal, a reference to whichever one happened to be lower in memory at the moment could be stored in whichever was higher [let's assume `foo2` happened to be higher], and the reference which had identified the higher one could be updated to identify the lower instead (so `foo2` would be changed to identify the same string as `foo1`). If the strings were compared again using the same references, the references could be immediately identified as equal. If e.g. `foo2` were changed to identify `foo1` and then code were to compare `foo3` to `foo1`, the object associated with `foo2` would identify itself as equal to `foo1`, so `foo3` could be updated to identify `foo1`, and then quickly be recognizable as equivalent to it. This sort of telescoping equality can almost be done in user code except for one problem: generating a large number of objects and comparing them in a deliberately-chosen order, and abandoning most of them could result in a large amount of garbage that can never get collected because one string would end up holding the only extant reference to another string, which would hold the only extant reference to a third, etc. If the GC were aware of such telescoping equality, however, it could avoid that problem by replacing any references to a string which is equivalent to another, with a reference to the equivalent string. Thus, in the above example, the next GC cycle after the comparison between `foo1` and `foo2` would cause the GC to replace all references to the string originally identified by `foo2` with references to the one identified by `foo1`. In order for the GC to do this, `string` would have to be recognized as something that identifies an object, but isn't a "normal" object reference. The GC isn't allowed to take two references that identify different objects and cause them to spontaneously change so as to identify the same object. If, however, there were no means by which user code could determine whether two variables of type `string` identify the same object, then the GC could do such things. 
I have no idea what this code is *intended* to do, but what it actually does is read 22 numbers (which invokes undefined behavior since you only allocated space for 20), then print the 1st number entered if and only if it is equal to the 12th. In addition, `printIntersection` is declared as returning an `int` but does not actually return anything. You can easily fix the overflow (and the missing return), but the program would still not do anything useful.
True story: Failure to properly enclose a previously unenclosed `if` statement during a refactor led me to 4+ hours of tracing and debugging a memory issue on a kernel module I was working on last night. I'm starting to see brackets on single-line `if` statements as mandatory rather than optional.....
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Head first books are usually a good start.
Im late to the party but i just found out about the -S flag for gcc and was messing around with it, pretty cool stuff makes me want to learn a bit of asm. Any idea what "type" of asm the -S flag outputs? Im assuming x86_32 or x86_64 bit depending on my computer? 
Be descriptive with everything. Be descriptive with problems. Be descriptive with solutions. Be descriptive with troubleshooting. Be descriptive with documenting behavior. Never let anything be taken for granted. Yes, I'm making fun of your title... But I'm absolutely 100% serious. We take for granted that other humans can fill in the gaps and understand what we mean... But computers can't do that. The more descriptive and precise you learn to be with EVERYTHING, the better you can convert what you need to do project-wise into code. Similarly, the more descriptive and precise you can be with your requests (of fellow humans) the easier it is for others to (want to) help you.
The hero we need, but don't deserve...
In which order do you link these libraries in?
That's a good question, I didn't think about that.
Once you have started and are looking to practice programming in c, I would suggest trying to remake some basic unix utilties such as wc, grep, etc...
 printf("unsigned char: %d - %u [%d - %u]\n", 0, UCHAR_MAX, ++uchar, uchar); The output of this is unspecified. `++uchar` and `uchar` can be evaluated in either order.
Would it be better to keep the minimum and maximum of each type as separate variables?
a full gui, or a psedo gui in text mode (ncurses)?
Or do what you did in the other cases. printf( "...", uchar+1, uchar);
When I try to use `uchar+1`, instead of getting 0 I get 256. I'm not certain, but I'm pretty sure this is because `%d`'s maximum isn't the same as `uchar`'s maximum value.
Whatever architecture you're compiling for, that's the assembler output you'll get. By default, the compiler will generate code for the architecture it's compiling on. You can change this with command-line arguments (e.g. to compile 32-bit code on a 64-bit OS), provided the compiler supports the architecture you want to compile for. TBH, there's very little reason to know machine language in this day and age, other than it will make you a better programmer if you know what's really happening under the hood. The last time I *wrote* any assembler was 2003, and that was the context switching code for an embedded operating system. 99% of software engineers will never write such a thing.
Yes, that was bad advice. Use a separate variable of the right type. And use %u to print unsigned values.
Thanks, I'll do that
Thanks!
Incrementing (or otherwise twiddling/diddling) a signed integer beyond its range is undefined behavior. The compiler may actually do what you’ve asked, or it may crash your program, or it may be assumed that code never runs. In fact, because you’re overflowing things in the main execution path, the compiler can assume that `main` does nothing, and just returns immediately. It’s left as UB per the standards to allow for ISAs that might fault on overflow, and to allow optimizers to use arbitrary-width arithmetic in their calculations. Compilers have stretched the fuck out of that hole, however. Along these lines, if the compiler sees a loop like for(int x = 0; x &lt;= 0; --x) {…} you could real easily end up with an infinite loop, because the compiler can assume that `x` will never become positive via decrement. (You can verify that things break by running two small test programs through GCC; program #1: #include &lt;stdio.h&gt; int main(void) { int x; for(x = 0; x &lt;= 0; x--) {} puts("Here"); return 0; } `gcc -O4` just generates the call to `puts` for me. Specifically, x86-64 assembly: subq $8, %rsp # Create stack frame movl $.LC0, %edi # Set up `"…"` arg to `puts` call puts xorl %eax, %eax # Set return value from `main` addq $8, %rsp # Tear down stack frame ret For variant #2, change the `puts` to `printf("%d\n", x);`. `gcc -O4` generates this for `main` instead: .L2: jmp .L2 So it becomes an infinite loop if you try to use `x`, and no loop if you don’t. In neither case will any actual overflow be triggered.) Unsigned integers don’t have this problem, so if you want to fiddle with signed overflow you have to come up with an `unsigned` value, then explicitly cast into a `signed` form for testing. One other thing: Don’t use a lone `;` for empty loops/statements. Use `{}` or something expliitly no-op like `(void)0;`. `;`s that have wandered off will often come back and bite you in the ass.
Awesome! And I think the errors were not *that* minor. The error with the ampersand is a beginner's error, yes, but the error of printing i instead of j was a huge mistake of algorithm design of my part. Anyway, both you and me learned a lot today with a simple script.
full
I just made the EXACT changes I told you to make and the program worked... Replace `scanf()` with: char buffer[32]; fgets(buffer, sizeof(buffer), stdin); /* TODO: Check for error in strtol() */ arr1[i] = (int)strtol(buffer, NULL, 0); In BOTH places. &amp;#x200B; Change `for(int i=0; i&lt;=10; i++)` to: for(int i = 0; i &lt; 10; i++) In BOTH places. &amp;#x200B; Change: `int m = (arr1[0])/(arr1[0]);` `int n = (arr2[0])/(arr2[0]);` To: int m = sizeof(arr1)/sizeof(arr1[0]); int n = sizeof(arr2)/sizeof(arr2[0]); &amp;#x200B; and add a return to `printIntersection` or change it to `void`. &amp;#x200B; This is just complete laziness. You're not going to learn of understand any of this.
feels pythonish, you if statement has syntax error &amp;#x200B; if(condition){ code; }
That's not the issue, the only library being linked is FoundationIO, and it's right after the program name and source. 
Try running `ranlib` on the FoundationIO library. If a static library is not indexed, the linker queries the library in order for symbols, potentially not finding symbols if the object files in the library are in the wrong order.
Have you tried possible using nested if statements with a combination of logical operators? This is my first semester taking C in university and we had a problem similar to this. I suggest writing out all the possible outcomes on a sheet of paper and then coding from there.
Do you mean passing a pointer as a parameter or function pointers?
Mainly how function pointers can be utilized and what the benefits are to using them.
 ascii_value = array[i]; `ascii_value` is of the type `int` but `array[i]` is of the type `char`. ptr = &amp;array[i]; `&amp;array[i]` is of the type `char*` but `ptr` is of the type `int*`.
It means that `ptr` and `&amp;array[i]` have different types. `ptr` is a pointer to an integer. `&amp;array[i]` isn't.
There are many situation where they are useful. One example from math: You write a function that evaluates the integral (the area between the function graph and the x axis) of some arbitrary function f(x). This function f can then be passed to the integration routine as a function pointer.
this fixed the problem, but shouldn't ptr be an int* as it is meant to store numbers not char?
Maybe look into what Antergos and Manjaro use. I haven't used either of those, but in my understanding they are both based on Arch but use graphical installers instead of text-based installers.
&gt; meant to store numbers Why is is meant to store numbers? The only thing you use it for is to point at elements of your array. The array is an array of `char`, so the pointer needs to be `char *`.
Let's use an extreme case. Say you have a 8GB video clip in memory. You need to pass it to a compression routine. If you passed it as an array of bytes, the routine would need the original 8GB and another 8GB for the copy. Then to update the original, it'd have to copy all the bytes back to the original! UGH! Now if that routine needed to pass it to another routine, it'd have to copy it again. Crap you're up to 8 \* 3 GB or 24 GB. You're running out of memory fast. Now if you used a pointer of 8 bytes (on a 64 bit system), all the routines could use the original section of memory. Also no data needs to be copied back. Congratulations you achieved a 1,000,000x speed up in a single call overhead and are using 1/3rd the memory! So pointers = fast and efficient. Also some data structures require them.
You should also cast `ptr` to `(void *)` for use with format specifier `%p`, and hoist the `strlen` out of the loop since it doesn’t change from call to call. `array` should probably be `static const` also, since you’re just using it as a reference and there’s no need to initialize it at run time. Finally, `&amp;a[i]` is just `a+i`.
Despite the name `char` is just another numeric type. The only difference between `char` and `int` is the range of values it's specified to be able to represent.
Whenever you need to modify a variable in a function (that hasn't been declared in the function) you need to pass a pointer to that variable. The pointer actually store the address of the variable, and the function can then modify it directly. 
a char is just a number. in general between -128 and 127 or 0 and 255.
Strings don't hold references to other strings, though, or to anything else for that matter. They are immutable leaves. Simple reference counting is sufficient to correctly GC them.
A simple tracing GC would be sufficient to correctly GC strings, but if two strings were formed in different ways, every comparison will require examining every character therein, and both copies will need to be remain in memory as long as references to both string exist. Adding a "known identical string" reference that was understood by the GC would allow things to be handled more efficiently.
A classic example is [qsort](https://www.mankier.com/3/qsort) - it implements the generic sorting logic but leaves the decision about the order to the caller (so if you're sorting a list of people, you can easily sort by name or by age). 
Function pointers are useful for when you need to pass a function to another function as an argument. The `qsort()` function is an example of this. It takes an array of arbitrary types as well as a function pointer that defines how those types should be compared. This is an example of polymorphic design -- the qsort function itself doesn't care what it's comparing -- all it knows is that it'll be given the criteria (an unspecified `compar` function) that determines which of two values is bigger. While this seems like a no-brainer when it comes to comparing integers, the issue pops up when sorting an array of structs, for example. Another example is modular application design. Let's say at some point in your application, you want to invoke a function that its dependent on some module being installed. Rather than define the behavior of the function in your application, you simply stub the function call (ie you write a library function that calls a function pointer). Before the module is installed, that function pointer points to a function that simply indicates some default behavior. When you install the module at a later time, the module reassigns that function pointer to point to a new function that *actually* performs the required behavior. This may seem complicated, but it's actually super-useful. It means that you don't have to re-compile and update the **massive** application every time you want to update a small module -- you simply make the changes to that module. Compiling small programs doesn't seem like that big of a deal, but when you're dealing with something massive (like the Linux kernel) -- you take optimizations where you can get them. (For reference, compiling the kernel can take hours and hours, depending on how many CPU cores you devote to the task) This explanation is both a bit specific as well as a bit simplistic... but in a nutshell, you use function pointers any time you need to.... point... to a function... :D
A map function is a really simple example... map calls a user-defined function for every element in a collection. This can be implemented with a function pointer in C. #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; void map(uint32_t* array_p, size_t sz, uint32_t (*func_p)(uint32_t)) { for (int i=0; i&lt;sz; i++) { array_p[i] = (*func_p)(array_p[i]); } } uint32_t triple(uint32_t num) { return num*3; } void print_array(uint32_t* array_p, size_t sz) { printf("array = [ "); for (int i=0; i&lt;sz; i++) { printf("%d ", array_p[i]); } printf("]\n"); } int main(int argc, char* argv[]) { uint32_t array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t sz = sizeof(array) / sizeof(array[0]); print_array(array, sz); map(array, sz, &amp;triple); print_array(array, sz); return 0; } Output: % ./a.out array = [ 1 2 3 4 5 6 7 8 9 ] array = [ 3 6 9 12 15 18 21 24 27 ] &amp;#x200B; A more practical example would be a button on a GUI. You can imagine the need to change the functionality of the button depending on some state. A function pointer can be used here... store a pointer to a function that you'd like to be executed when the button is pressed. You can change what the button does by changing the function pointer associated with the button. There are other ways of doing the same thing... such as a switch statement... but there are pros/cons to any implementation. &amp;#x200B; &amp;#x200B;
It doesn't store a number. It stores a pointer. A pointer which happens to point at a char. Technically, everything is a number, including chars. But what matters is how big it is and what it is for. char* tells the compiler that variable stores the address of a char
Best explanation so far thank you!!!
Stupid phone... :(
Nice to see option for JSON output.
Does your compiler give no warnings? For line 31 perhaps?
'i' in getline() is never initialized. Also, you *are* using pointers. Every array you're passing to a function is a pointer.
No warnings, any reason for that line to cause trouble?
Fixed the initialization, thanks lol
How is it laziness when I had been trying for 10 hours to get it correct? Thanks for finally helping by the way, after making an already frustrating problem worse. Someone else already helped me, so everything you did was completely useless, and I learned more from them in 5 minutes than I learned from you during the course of this frustrating conversation. Have a good day and I hope your insults made you feel better about yourself. 
i was uninitialised.
I didn´t see any comments about C on this blog entry.
It’s c++ heavy but there’s some examples of these improvements helping c code and some of the improvements even though applied to c++ examples also apply to c.
Haha are you my last professor? 
Pointers don't store numbers, they store a memory address, they still need to be declared explicitly by type or NULL
Maybe. Where did you study?
What's weird is that 2 test programs compile and link just fine. Also, I'm using Xcode 10.1 and Clang, not sure which version, it's Xcode's default, but it's very recent.
What symbol type is given by `nm` for `_CreateBitMaskLSBit`?
The ptr itself is an unsigned int, true. But if that were the only factor, then a generic void * would work just as well. The declaration of ptr _also_ means that the compiler should consider the value that the pointer refers to a memory location to be an int. The correct type here for ptr would be char *, because you assigned it to refer to the location of one of an array of chars. If that's not clear, then maybe there are further examples that help explain the distinction. I think that the best way to understand this is that each element of the array is just a location in memory with a number stored there. It's the program's job to interpret what the number actually means in the context of the program. (This is assuming a 32-bit system, if you need to get into those specifics here. :)
I would try using data types that are more fitting to the program. Also try to limit the amount of changes a variable goes through in terms of data type. Try that out and see if that helps!
After getting past the incorrect formatting (put four spaces in front of each line) and the useless junk at the bottom, your code seems to run for me. https://repl.it/repls/AmusedValidText 
Thank you for the response what useless junk at the bottom are you talking about i got it to work in [repl.it](https://repl.it) but i can't seem to get it to work in visual studios 2017 if you can check your dms.
i got it to work i replaced scanf with scanf\_s but i didn't get the exact cost results that were expected the first test i got 3.00 which is right i guess. the second test i got 9.00 instead of 19. Is my math off or what should i do to get the expected results?
No, C++ isn't accepted here.
C++ is not generally accepted here, because it’s a different language than C. (It’s originally based on C and shares some of the syntax, but so do Java and C#.) But see these things here you’re doing: string name; double price; int quantity; // should really be `unsigned` void setName(string Name) // should be `const string &amp;` { Name = name; } void setPrice(double Price) { Price = price; } void setQuantity(int Quantity) { Quantity = quantity } These setters go the wrong way. The field names are `name`, `price`, and `quantity`, all lowercase. The parameter names are `Name`, `Price`, and `Quantity`. (Do not mix name case like that unless you have a very good reason, because stupid stuff like this happens.) You’re assigning *to* the parameter variables from the (empty, and in some cases totally uninitialized!) fields, rather than assigning args to fields. The parameter variables enter and leave existence with the function calls, so your setters do roughly nothing. If you really have to match names (which is fine when of a Style, but not a great idea as a beginner), use the exact same names for fields and parameters, and disambiguate with `this`. The compiler can generally catch and warn about an `a = a` assignment (which your code isn’t quite), and it makes it entirely clear what you want to happen, rather than hoping the reader notices the case difference: inline void setName(const string &amp;name) { this-&gt;name = name; } inline void setPrice(double price) { this-&gt;price = price; } inline void setQuantity(unsigned quantity) { this-&gt;quantity = quantity; } Also, you should really have a constructor. By the time anything can see your getters or call the display method, you should have assigned *some* value to `price` and `quantity`, so you don’t get undefined behavior. `name` will auto-init to empty. Treat object lifetime as an end-to-end assertion of validity; do not allow an undefined or invalid state to be introduced or seen from outside the class.
Oh....thank you! 
I see...thanks for helping, I'll try it.
This appears to be a false-negative in GCC's `-Wuninitialized`. In this simple test case: int main() { int i, x, z; for (i = 0; i &lt; 1; i++) x = z++; } no warning is emitted for the assignment to `x`. Drop the post-increment, or take the assignment out of the loop, and GCC correctly diagnoses it.
You’ve missed the additional charge of $10
Right? Now I'm wondering why has it taken so long for someone to come up with this.
The last four lines before the `system()` call serve no purpose. And the `system()` call is not a good way to achieve what you want; just call `gets()`, which will pause until the user presses enter.
We don't know why it's not running either, because we're not in front of your computer. Tell us what you see when you try to run it.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
it's literally unbelievable to me that you program without touch-typing
it's like swapping your hdd for an ssd
I had the same issues with codeblocks for c++. I ditched it and now I program like a professional. Download ming-w64. (it's a compiler i.e. it will convert your code into a program) Google how to change environment variables. Then, Step 1: to path browse your mingw-64 file (installed in C drive (suggested)) all the way into the bin folder and locate g++.exe.(it's for c++check for C) Step 2: Save/apply/do whatever to implement the changes you made. Use a text editor like (you type your code in a text editor) : Notepad++ (it's free and good) classic notepad will also work. Type your code in notepad then save it with the extension (it's .cpp for c++)(save it in some drive don't save it on desktop) Open cmd.exe (use windows key + r, then type cmd.exe) cmd = command line. I would suggest you to learn a bit of command line. ( takes one hour at Max) In cmd type cd &lt;path_where_the_code_is_located&gt; (don't include mycode.c in the path) Now type g++ mycode.c -o mycode.exe Errors will be displayed in cmd if no errors you'll get a .exe file in the path. I'll suggest you learn c++ Cause C + object oriented programming + STL = C++ 
Absolutely! Just so you don’t have to look at the keyboard. 
I can touch type and it does help with programming sometimes. But I find it much more useful for typing text. Perhaps because I still need to look at the keyboard for all the different brackets, quotation marks, slashes, colons, semicolons etc. Also, when programming I usually spend more time thinking about what I need to type than actually typing it. So typing speed is not a great factor there. 
I do something like 6 or 7 finger typing. I've typed so much I dont think about where the keys are I just go there. If you have something like that I'm not sure how much you would gain unless you want to do programming contests where every second will count.
Oh yes when I think about it I type with more then two fingers. To refrain, I am sure that blind 10 finger typing is more efficient, but the question was essentially, is it a good idea to relearn typing at such an age, after 33 years of doing it in another way. It's a total re-conditioning, I think I need a boot camp for that. The habit is so ingrained...
Hey badlad, thanks for your fast answer! It seems there is quite a lot of dynamism in this reddit, making Discord unnecessary. I will try what you suggest as Code Blocks seems to expect another version of C. 
I’m going to say it doesn’t matter. I type around 90-120 WPM and that has never made me a better programmer. Programming can be excruciatingly slow at times as you test and change code. I would spend your time learning design patterns, automated testing, and the nuances of your languages. Those will help you work faster. 
Reasonable speed being what? My dad gets about 30 wpm hunt-and-peck, which is alright. But when I'm at work, and not swyping text on my phone, I'm going a little under 100 wpm. Now wpm is not necessarily a bottle neck when programming, but sometimes you have a really good thought and a lot of repetitively named variables. Getting through them at 100 wpm cuts that time by a third. Then, if you learn Vim or Emacs, you can write multiple lines at once, and maybe even generate some of your code. You might be peaking at the equivalent of 240 wpm. Nearly a tenfold increase in meaningful output. So all this brings me to a second point, aside from being faster - learning. If you're an engineer, you shouldn't stop learning, new practices, idioms, techniques, etc. That's how you fall behind, stop becoming competitive, and ultimately get passed by rockstar programmers who are half your age. Learning is part of the job!
Hey badlad, thanks for your fast answer! It seems there is quite a lot of dynamism in this reddit, making Discord unnecessary. I will try what you suggest as Code Blocks seems to expect another version of C. I am a newbie regarding programming but I feel attracted to C because: \- it is the root of most languages \- it has low-level aspects which i like because it shows me more what I am doing and teaches me more about how computers work. I rather type more but have a better overview if what I am programming \- I can learn how programming has developed. I wish to learn C, C++ respectively but don't know about C# as Microsoft seems to be involved in that and I do not like large corporates very much (could be a problem with me though rather then them :D )
Actually I like MingW Dev Studio but I do not find the debugger in it
Learn it for your neck.
Using IDEs is slow, instead learn to use the gcc/clang compiler manually, if you're on Windows you can use Mingw-64 for gcc, later on you can learn writing Makefiles. It's much simpler to actually learn command line arguments (at least for me) than spend most time clicking around in an IDE. When you learn to write makefiles all you will need to do to compile your projects is alt tab into CLI type in make and run the program, to test it. Obviously, you will need some kind of an editor, I recommend Vim, Emacs or VSCode, but since you are a beginner I would recommend VSCode since it's very beginner friendly and easily customizable.
It's easier as I don't need to look down all the time. And in modern dev tools I can prototype and auto complete calls with ease. It doesn't make logic any easier, but I can stare at the screen. As mentioned below, do it for your neck. 
I've been touch-typing since before I was programming, so I can't really say. Obviously I don't program as fast as I can type. But I think it helps that I never have to look at the keyboard or think about the keys I'm pressing. I think the words and symbols and they appear. If your method does that for you, it's probably fine. If I had to find things on the keyboard, I think that would distract from my train of thought in the program.
What type of newbie questions? Think about it this way -- if there were a discord for real-time newbie questions, it would be full of newbies, and the few pros would get overwhelmed. TA office hours at schools behave like that: 3-4 TA's servicing a room of 20 students all anxiously working on their lab... Each of the 20 students think their questions are the most important, and get impatient with the TAs. There's hope, though. Much of learning comes down to hitting your head against a wall while trying to figure out the answer. That way, you don't just "get it right" -- you learn how to search, you learn how to troubleshoot, you learn how to read and interpret man pages, you learn tangential information, and ultimately you learn and remember the concept better. If you're having trouble ideating solutions, or need extra help debugging etc, then what you're really looking for is a tutor.
&gt;ming-w64 I am now trying to do it via cmd
Assuming you do still look at the keyboard: not having to look at the keyboard as much means less time and attention wasted context-switching, I think. It'll take some time to get the hang of it, though, so it's really up to you whether it's worth it. As others have mentioned, the typing speed isn't worth it, since so little programming time is actually spent typing.
What’s Red Hat? 
Well, you're never going to have *more* time left to change than you do now. I hadn't been 2-finger typing for nearly as long when I learned to touch type in the 9th grade, but I resisted it for a long time because I *was* really fast for 2-finger typing. It only took a semester of practice to get to 60 WPM or more. Definitely worth it. Also I just took a sped test for the first time in many years, and hit 101 WPM corrected. 120 WPM on a shorter sample of real sentences. I'm sure my 2-finger typing would have gotten a little faster over the years, but it'd never get *that* fast.
Touch typing won't help much with C programming. You are probably spending more time thinking than entering code, and source code is rife with punctuation characters that slow down a touch typist. BUT! You'll be able to post a lot more on Reddit and reap that ~~useless~~sweet sweet karma.
It's like sightreading piano sheet music without having to worry about the keys because your hands move on their own so you can keep worrying about the text. I've never learned a real touch-typing system; I kinda ended up with my own (something between 3 and 10 fingers depending on which keys I type on). Fast enough, blind enough. Both things make inputting stuff a lot more fun.
I told you how to fix every issue in less than a minute of reading your post. My original reply had all the info you needed. The problem is although I can fix your shitty code, I can't fix your stupidity.
I don't think so. I have seen people doing two finger typing faster than most 10 finger typers. Do what is most comfortable to you. The bottleneck in programming is your brain and your tools, and the management, not your fingers. 
Not the same as you but I tried to learn Dvorak at 35ish. I can clearly tell it's quicker but the time it would take for me to get up to speed didn't seem worth it. If this is something you *really* want to learn I think there will be a benefit. If you're kind of on the fence you might give up like I did.
I'd the description of getDistanceCovered right? I would expect it to simply return the value of distanceCovered.
Perhaps try a do while lööp in your main method?
It's definitely worth it. I wasn't a finger pecker, but I didn't learn proper touch typing [until age 30](https://nullprogram.com/blog/2017/04/01/). Once I did, I wished I had learned it a couple decades earlier because, in retrospect, it was obvious how my bad form had been hurting my productivity all those years. You will be able to reach a productive level of proficiency that matches, if not exceeds, your current typing skills in about three weeks. Go completely cold turkey and practice daily with good form. I used [TypingClub](https://www.typingclub.com/), but probably most of the other options would be fine. As usual, a number of people are saying something about programming being more about thinking than typing, so it doesn't matter. *These people are dead wrong.* Sure, when you program you're generally not hammering away endlessly at the keyboard. I don't even do that when I'm writing essays. But when I know what I need to do, good typing skills allow me knock it out and move on to the next thing quickly, or to shorten the loop when iterating on an idea. I've seen coworkers and mentees struggle because of their poor keyboard skills. They know what they need to do, but it takes them a long time to accomplish it, either because they type slowly or because of poor typing accuracy. The more freely your thoughts flow through the keyboard, the more encouraged you are to explore and experiment. Furthermore, software development is an iterative process. We write code, we build on that code, then we throw some of that old code away and rewrite it, refactor it, etc. A significant amount of the code I type ends up being thrown away. The more work it takes to type out code, the more discouraged you are from reworking old code. 
I am around your age, and I'm also doing the "Abbreviated Hunt and Peck" typing. Mine generally requires more hand movement, making it slower. However, for most of my programming I'm not actually typing as much as I'm thinking through what the structures I want to put in place are, how they're going to tie in, etc. So, for actual programming, I don't think I'm limited by my typing speed. &amp;#x200B; And for that matter, even for documentation, looking at the keyboard isn't a hindrance -- if it's coming out of my mind, looking at the keyboard is as good as looking at the screen. If I'm moving from notes to the computer, or transcribing otherwise, then my typing speed is a problem.
Brilliant comparison 😂
Yes, yes, yes, yes. I have a CECS degree and worked in the industry for years. I used a modified two-four finger hunt and peck. Investing 15 minutes a day for three months made entering text with a keyboard much easier and faster. &amp;#x200B; It makes a big difference if you use an IDE because you can keep your eyes on the screen and see hints and possible bugs. Getting my thoughts into the computer is automatic now. The time/brain space devoted to typing is gone... it just happens. 
Yes, for your neck’s sake. I’m 26 and I have had back issues for all my life, and only recently I started getting neck pains. And I’ve been touch typing since I was 12, long before I ever knew what programming was. Just a real avid computer user. Not to mention speed and efficiency, especially if you switch over to Vim or Emacs.
It’s a hat That is red
Programming is hard enough. Learning how to touch type frees your frontal lobes to concentrate on the important stuff. There's also a cultural thing. You're never ever going to be seen as technical if you don't know how to touch type. It is an essential thing these days like knowing how to use Microsoft Office and how to google something.
Yes. If you're willing to put up with a week or two's worth of pain in order to learn _quickly_, you could change your keyboard layout to Dvorak or Colemak. This will force you to unlearn any bad habits you've accumulated and if you're diligent about not looking down, you'll be back to where you were and on your way to surpassing your WPM before you know it. (I did this myself and have no regrets.)
You should learn to touch type, absolutely. I’m 36 now and just about a year and a half ago I made the commitment to learn to touch type. I started a computer engineering program as a non-traditional student (i.e. plenty older than general student body) and though I could type fast wile looking at the keyboard, I was at an obvious disadvantage when it came to processing/reading material while typing at the same time. Which is actually an incredibly useful thing to be able to do. So, as painful and as foreign as the feeling of touch typing was to begin with, I’m now pretty darn quick and the more assignments I do for coding related classes the quicker I get at touch typing all the special characters too. While I agree with other posters that programming isn’t really about how fast you type, it’s awesome to be able to trouble shoot and revise while typing quickly and being able to look directly at what you’re doing. I don’t know if I’m allowed to recommend sites... but I used typing club. It’s free and gets you started quick. Best part is, at the end of the regular typing lesson sections there’s special character lessons too. Good luck with your typing journey. Hope you find something that works for you. 
This is for C programming. Try r/cpp_questions
This is actually very helpful.
my professor wants me to use system pause for whatever reason yet my program isnt pausing after i enter in the amount larger than 50 pounds if you can check you dms
meson is easily the nicest build system I've used. I think of it like cmake but without the frustration and a lot more readable. I highly recommend it to anyone who's thinking of changing build system.
The best approach imho is to master home row, hunt and peck works fine braces and brackets but home row allows you to remember where the other keys are, it gives you a fixed approach to finding keys which helps you master the others quickly.
&gt; 10 finger blind typing You mean typing? That's just called typing. Touch typing if you want to get technical about it. I don't know, this question sounds like "I'm 45 and I've been playing the guitar most my life, should I learn some basic chords?" Well... yeah, you should. I'm not entirely sure how you've gotten by without touch typing all this time. You've been doing it the hard way because beyond the short initial learning phase, touch typing is just so much easier. I'll put it this way: how much energy do you expend typing with 2 fingers? Just look at your hands while you're typing, how much are they moving? How much does all that slow you down? The answer is that it slows you down a lot. It also introduces a lot of eye strain since you're constantly refocusing on the screen and the keyboard. There is literally not advantage to hunting and pecking for the average person, break that habit *now* and learn to touch type. However, is it going to help your programming? Not really. How much do you actually type while programming? It's not all that much. After 3 hours of transcription work, I can generate several pages of text in a word document. After 3 hours of programming? Depends on what you're doing, but if you condensed it it might be a single page. Typing slowly won't really slow your programming down.
keybr.com, don't kid yourself. Always better to learn proper.
This is a [C++ Lambda expression](https://en.cppreference.com/w/cpp/language/lambda), you can follow the link to learn more, or post in the /r/cpp subreddit for better responses, since this subreddit is for C, not C++
What kind of degenerate types with two fingers
What's wrong with: int grade; scanf("%d", &amp;grade);
You can use format specifiers. And you can put it in an int statement to check the return value. You can also determine the number of digits with a number before the specifier to avoid making numbers that are too big. Scanf returns the number of excepted values and since 0 is like false you can do... #include &lt;stdio.h&gt; int main(){ int num; if(scanf("%3d", &amp;num)){ printf("%d\n", num); } } This will only accept an int up to 3 digits. And if the input is valid it prints it followed by a newline. 
Works well only if the user actually enters an integers. If a letter is entered, it's converted to its ascii value. In my case, the grades must be between 1 and 5 and most letters ascii value are way larger than that.
You could try using a switch statement to set a certain character to an integer value. Ex. ‘Switch (grade) Case ‘A’: Grade = 4; Break;’
You could try using a switch statement to set the values of certain letter grades to an integer value
scanf returns the number of successful integers when you use %d. I just tested it with. You can use this to rule out character inputs entirely. #include &lt;stdio.h&gt; int main(){ int get; int num; if((num = scanf("%d", get))){ printf("Input: %d\n", get); print("Return Value: %d\n", num); } return 0; }
Just make the code print some kind of error message if the input is unacceptable. 
You can scanf a string value then check if it's a numeric value parsing the whole string checking each character to be in range of '0' and '9' then convert it using atoi() 
C# was made by Microsoft and in simple terms it's java++ the main problem is you can't use C# on Linux systems (popular amongst professional programmes) If you're learning C at school stop keeping up with the school cause they'll waste almost a 1.5 years in the basics whereas it's a 1 month of work for below average intellects. For the your logic (your best bet would be making algorithms but it's better you brush up your loops and conditionals and then move onto algo). I would suggest HackerRank and in total you'll be fine with C basics in 4 months. The real deal is pointers and it'll want you to quit but try not to (what makes C great is pointers &amp; memory management). 
I'm a touch typist and I'm pretty good at it. I can sustain 60wpm, and hit bursts of 90wpm. I can accurately copy text, and it is fairly easy for me to type my thoughts as I think them. Programming, even with IDEs that auto-complete, sucks. It is a train wreck. But programming is different. When I am in programming mode, I'm trying to think my way through a problem as I create the code. I don't know how it is with other programmers, but my code goes through a lot of my own re-write. (Note: I do not program for a living!)
Another example no one has mentioned, you can build OO style abstractions. struct Classish { int (*variable_func) (void* args); };
you can use `fgets` to read input to a `char` array,`isdigit` to check if it's a digit, and then use `strtol` convert it to `int`
It's really nice being able to follow along with tutorials and such without having to pause a video every 5 seconds or switch between looking at code in a book and typing it 20 times for one line. At least that's the case when you're learning. Other than that, touch typing is really fun. It took me less than a couple weeks to become proficient 
That sounds surprising to me. Did you remember to delete `file.txt` before running again? 
For programming, I’d so no. If you can think fast enough that typing is your bottleneck, that’s amazing. But for typing long emails or documentation, maybe.
using puts() and fgets() for this purpose is a kludge.
If you write documentation or correspondence often, I recommend you do. For general programming, however, I don't think it is necessary, assuming you work in a development environment that provides a code completion framework. My bare-bones vim/ctags workflow has probably saved me millions of keystrokes over the years 
In case my anecdata helps you out at all: At 16, I taught myself Dvorak (after about 13 years of QWERTY). It took about 2 months before it surpassed my skill in QWERTY, at about 100wpm. I have used it as my daily driver ever since then. In my early 30s, I broke a finger on my right hand and attempted to teach myself [left-handed Dvorak](https://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard#One-handed_versions) to compensate. After 6 weeks (when the cast came off), I could type at maaaybe 20wpm. I suspect, if you learn a new style of typing, you'll have to commit several months to become totally natural at it. Is it worth it?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Yes I did. After your comment, I did the whole thing again. No luck. char is redirected to stdout, but still an output file is produced. Still not able to figure out whats going on. (I used `gcc -shared -fPIC -ldl -o test.so test.c` to compile .so)
How do you know the original program used `fprintf`?
&gt; but still an output file is produced You haven't stopped it opening or closing that file.
Of course it's not pausing. What do you think `return 0` does?
Try /r/csharp.
This is not the C# programming subreddit. Try /r/learncsharp, /r/csharp or /r/dotnet.
scanf("%d",&amp;integer_identifier) For char it's %c For float it's %f For repeated input loop it. 
Why use the Windows API rather than C's built-in file handling functions?
I have a project that requires me to use WINAPI
You may have to write your own function that mimics `fgets`: * Call ReadFile to read some data into a temporary buffer. * Copy bytes from the temporary buffer into a location specified by the caller until a newline, end-of-file, or a length limit has been reached. * Call SetFilePointerEx to go to the end of the line, because the initial ReadFile call may have overshot and read some characters past the end of the line.
&gt; Call SetFilePointerEx to go to the end of the line That's incredibly inefficient. Read as much as you can into a full buffer, process that buffer line by line, and if you reach the end of the buffer before the end of the line, move the partial line to the start of the buffer, call `ReadFile()` again to fill the remaining space, and repeat.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp.
I learned touch typing in high school, on an electric typewriter (IBM Selectric) in the early 80’s. I went to a technical high school, and I learned programming there too (we had a PDP-11, Apples, and CP/M). I was taught the basics of programming but pretty much the rest was on my own. But.. the most useful thing I was actually taught in that school was touch typing (and accounting). With touch typing, you eventually learn to type WORDS not letters. That’s the key to it. Now, with a concise language like C, keywords are short so it doesn’t have the same effect as typing a letter or a report, but it does take out that part of having to think about entering your code - it just becomes a natural mindless thing. Maybe you are at that point with your two finger typing, so who knows. My first boss, the owner of a small software company i worked for, was probably the smartest guy I’ve ever met, and he typed with two fingers...
Many people feel that fgets is the only responsible way to read console input in C, because of the potential of scanf to create bugs.
&gt; At 16, I taught myself Dvorak (after about 13 years of QWERTY). You learned qwerty at 3?
https://www.tutorialspoint.com/cprogramming/ The PDF version is paid so better learn from your desktop. 
See our side bar for some resources.
Not sure how useful this information is, but `clang` catches it. $ clang -Wall -pedantic abc.c abc.c:31:13: warning: variable 'i' is uninitialized when used here [-Wuninitialized] lne[i++] = c; ^ abc.c:25:10: note: initialize the variable 'i' to silence this warning int i, c; ^ = 0 1 warning generated.
Bookmarked, very cool idea. Thank you for doing this
Definitely prefer `strtol` over `atoi`, because it does all the parsing for you, you can pick your base or base-swapping ability, you get a pointer to the first data after the number, and you get error readouts if the number would overflow. `atoi` just silently gives you garbage if it takes garbage in. (Although if you’re reading through each digit manualy anyway, it’s trivial to build an integer at the same time without any library assistance.)
Your welcome.
I can only see ads.
Try [old reddit](http://old.reddit.com/r/C_Programming).
Better yet, [map it](https://docs.microsoft.com/en-us/windows/desktop/memory/file-mapping).
You used both REUSEPORT and REUSEADDR, is it a Linux-spesific thing? IIRC REUSEADDR fixes the timeout with previous sockets in TIME\_WAIT state, and REUSEPORT is something different, for multicast or load-balancing.
You're right, essentially those flags were set for testing purpose but as you correctly pointed out I forget to remove SO\_REUSEPORT, which I believe come from BSD implementation. Nice catch, thanks!
Properly handling all the corner cases with `fgets()` is sufficiently awkward that in many cases one would be better off using `getchar()` [which is no less "responsible"]. It irks me that C's console-input model is bound to the way Unix handles cooked I/O, even though for many console applications it would be more useful to have a read-line function that uses raw-I/O semantics. For example, if an application uses raw I/O semantics asks the user to enter a 5-digit number, it can ignore invalid characters without echoing them, rather than echoing back however many characters the user types and not being able to do any validation until the user presses enter/return, and then having to worry about flushing the input buffer if the user typed more characters than were expected before enter/return. In ancient times, there would have been situations where using raw I/O could have reduced overall system performance by an order of magnitude by requiring that memory-hungry tasks be switched in with every keystroke. Such situations are sufficiently rare that using raw I/O along with a "read line of input with backspace/editing support" library function would be superior to the "satisfy the first `readchar()` by reading a line of input with unrestricted length, and satisfy subsequent resuests by returning the remaining characters from that line until they've all been used up" semantics of Unix cooked mode. 
SO\_REUSEPORT does work on Linux as well. It allows multiple processes to listen on the same port, load balancing the connections across processes. Useful in a http service, but this service needs to route subscriptions across the connections. If the publisher connected to one process and a client in another process, the subscription routing would need to occur across process boundaries. &amp;#x200B; Nice work btw.
The macro is better as it works with all types (try changing to `int dataMemory[10]` and int \*pDataMemory = dataMemory` to a demonstration). 
The macro is better as it works with all types (try changing to `int dataMemory[10]` and `int \*pDataMemory = dataMemory` to see a demonstration of that).
The macro is better as it works with all types (try changing to `int dataMemory[10]` and `int *pDataMemory = dataMemory` to a demonstration).
The macro is better as it works with all types (try changing to `int dataMemory[10]` and `int *pDataMemory = dataMemory` to see a demonstration).
Honestly, I don't really know how to read nm's output at that level, here's the output for that function tho: `---------------- T _CreateBitsMaskLSBit`
Pointers store some form of information an implementation can use to identify an object. The extremely vast majority of implementations use the memory addresses of the first byte of an object for that purpose, but that is by no means required. Nothing would forbid an implementation from storing pointers from using a combination of a handle and an offset; doing so would allow an implementation to guard against many kinds of out-of-bounds array accesses (albeit at a considerable cost of performance). 
You should try declaring the struct in file2 first as an "extern" variable indicating that the structure is defined elsewhere and then use it in file2. Try googling for extern variables. briefly this is how it should look in file2 &amp;#x200B; \#include file1.h &amp;#x200B; extern struct .... &amp;#x200B; //use struct as required &amp;#x200B; Hope this helps! :-)
You should do #include "file1.h" in file2.h, because otherwise the compiler won’t find the struct. If you haven’t `typedef`d something to that `struct`, make sure you’re referring to it by its full name. So if you have struct Foo { … }; then you should refer to it as `struct Foo` everywhere. You can o typedef struct Foo Foo; if you want to use `Foo` as a typename unto itself.
In your macro, it should be just `(ptr) - (arr)`, or if you really want to operator-stack for some reason, `(ptr) - &amp;(arr)[0]`. Either way, the parentheses need to be around `arr` itself. Also, it would be better to use `ptrdiff_t` or `size_t` than `int` for your index type. The pointer subtraction will return a `ptrdiff_t`, but if you’re guaranteed that `ptr &gt;= arr` the `size_t` is perfectly reasonable as well.
Thank you. So SO_REUSEPORT should come handy in a case where I design my service to divide connecting clients into small subsets, like multiple epoll descriptor each one on his dedicated process/threads right?
There's a difference between struct mystruct { ... struct members... }; and struct { ... struct members... } mystruct ; The first is a definition of a struct, while the second is a declaration that uses a struct definition. The first, can occur anywhere, even in multiple .h files. The second can appear only once, anythere in the compiled program. If you add the demotion in you. h files, then you can use struct mystruct mystructvar; (for example) wherever it's necessary. (I'm wondering if my cell phone's autocompletion counts as computer humor, too.) 
I didn't know about `ptrdiff_t`. Thanks !
The return type is `cchar*` `cchar` isn't a standard type, though, so you'll have to find it's definition to know what it is.
Yeah know that part. How is ABC\_API interacting with the return type?
What exactly are you unsure about? Displaying that information is just a continuation of things you've already done in the code you posted, namely accessing/iterating an array and printing output.
It isn't. The mackerel results to a compiler specific attribute on the function as a whole. It is specifying the linkage.
ABC\_API is #defined as AEXPORT which is #defined as \_\_declspec(dllexport) so it's: __declspec(dllexport) cchar* ABC_FunctionName();
the declspc and the return type are independent. The function returns a `cchar*`. and The function is to be exported from the DLL.
It's not. It's a compiler/linker directive for how the symbol name for that function will be generated. 
Is there a term for this, so I can read more about it?
Just got my hands on the 2nd edition. Gonna go through the whole book!
Did you try [searching for dllexport](https://www.google.com/search?q=dllexport)? The first two results are pretty helpful.
Yeah, I've been using it that way (Fedora 28). At a glance, with 16 processes with 16 listen fds on the same port, with 16 epoll fds, it's been ok distributing the load across my 16 cpus, but it's not perfect. The real competition would be a threaded server, but separate processes has other advantages... (crash separation, external orchestration, etc).
The man pages
An experienced programmer wouldn't need to come to this subreddit to ask this question. The answer is obvious: the book by K&amp;R
What does the text file contain? 
Just edited the post.
Is `line2` big enough to hold a complete line?
What are you trying to accomplish?
I declared line2 as: char line2\[255\];
I've been happy with this one https://www.amazon.com/C-Pocket-Reference-Peter-Prinz/dp/0596004362 
Is getline getting the whole line? Is scanf returning 7?
I have the one by Pearson, Introduction to C with C++. I have the 5th edition and it's genuinely an awesome book. I haven't read any others though. 
I updated the post again.
Start working lower on the stack and learn more about networking, system calls, etc..
&gt; mackerel I'm calling them mackerels from now on.
You would probably benefit from a systems manual, on top of a general syntax book like K&amp;R. http://www.amazon.com/gp/product/0131103628 https://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0201563177
I'd love to see some physics stuff in c. Do you hang on irc / discord anywhere? I'm trying to find other c graphics / game / experimenters to hang with and learn from.
Man pages are really only good when you know what you are looking for (like what a specific function does) they’re not a good resource when first learning the language.
`ABC_API cchar* ABC_FunctionName();` expands to `__declspec(dllexport) cchar* ABC_FunctionName();`. You can think of `__declspec(dllexport)` as a visibility specifier, a bit like static. Except-- it's the opposite of static. static means that a symbol is only visible within the compilation unit where it's defined, and in posix the default is that symbols are visible. On windows, however, by default a symbol is not visible in the compiled binary unless you add a `__declspec(dllexport)` to it.
I agree with the sibling. I also recommend picking up an assembly book and possibly a linux kernel manual to get an idea of how these ideas are actually implemented.
True, but he said he was an experienced programer. That's a cool feature of C, most stuff is accessible via man.
I didn't read the other posts, so I assume that they all have good advice. I just want to add two details that you need to burn into your brain: 1. You don't have a garbage collector. You need to track your own memory 2. Pointers are awesome. That's why java pretends it doesn't have pointers; it doesn't want to share in the awesome. But again, you got to track your own memory. That is all. (Seriously though... the lack of garbage collection seems to be one of the main things I see people forget when they switch Java to C)
Try this: https://beej.us/guide/bgnet/ All of the example code is in C. You've got the base in java so you'll be able to follow along easily enough and you'll have enough knowledge to start playing with toy programs to sniff packets and basic client/servers. Since you've already got a grounding in data structures and algorithms and such, you mostly just need to learn the syntax and mindset. Lots of pages online can suggest the syntax. And sample programs and the syntax resources should get you used to the mindset.
K&amp;R
Where do you define cs? If that structure contains arrays for the strings, be sure to memset to 0 each iteration. 
FWIW to you, I could help you learn C if you could try out a text editor I am working on and give me some feedback on it. (I have 30+ years experience with C.) If you're interested, send me a direct message and we can discuss it.
Since you're (hopefully) learning C as a means to an end goal (learning systems programming), I'd recommend a good systems book with projects in C since as a language C is quite small and writing useful code is the only way to experience all the pitfalls. My goto recommendation for these use cases is Computer Systems: A Programmer's Perspective by Bryant and O'Hallaron. The labs are online and should be good C practice. Good luck! 
[https://www.ossblog.org/learn-c-programming-with-9-excellent-open-source-books/](https://www.ossblog.org/learn-c-programming-with-9-excellent-open-source-books/)
[EFL C Primer](https://www.enlightenment.org/docs/c/start) is amazing.
&gt; webshit languages back to the beginning.
You need to use a loop to iterate each month and add the total rainfall together. With this information, you can then find out the total and average. Then, to find out which month is the lowest and highest you need to create a nested if/and/or loop to compare each month to find out which is which. Hope this helps. 
Cool! Next step I planned is to try to share the epoll FD among a bunch of worker threads, or separate the I/O in a thread and use some queueing to distribute work across a thread-pool. There will be contentions to handle and a bit of locking I guess.
**DID SOME QUICK FORMATTING...** int main(void) { const int NUM_MONTHS = 12; double rainFall[NUM_MONTHS]; char monthAbbr[NUM_MONTHS][4]; int i = 0; int min = 0; int max = 0; double total = 0; strcpy(monthAbbr[i], "Jan"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Feb"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Mar"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Apr"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "May"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Jun"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Jul"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Aug"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Sep"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Oct"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Nov"); rainFall[i] = 0; i++; strcpy(monthAbbr[i], "Dec"); rainFall[i] = 0; i++; for (i = 0; i &lt; NUM_MONTHS; i++) { printf("Enter the rainfall (in inches) for %s: ", monthAbbr[i]); scanf("%lf", &amp;rainFall[i]); } printf("\n"); for (int i = 0; i &lt; 12; ++i) { total += rainFall[i]; if (rainFall[i] &lt; rainFall[min]) { min = i; } else if (rainFall[i] &gt; rainFall[max]) { max = i; } } printf("\n"); printf("The total rain that fell was %.1lf inches.\n", total); double average = total / 12.0; printf("The average monthly rainfall was %.1lf inches.\n", average); printf("The lowest monthly rainfall was %.1lf inches.\n", rainFall[min]); printf("The highest monthly rainfall was %.1lf inches.\n", rainFall[max]); return 0; } &amp;#x200B;
I'm shocked none of you have mentioned [libui](https://github.com/andlabs/libui) yet.
main returns int goddammit Anyway thanks for some fun in this sub
the artist uses turboc
On POSIX platforms, use the `nftw` function for this. Though I am not exactly sure what you want, can you give an example of what you want to do?
I do jabber (xmpp), but not discord, feel free to contact me via my site, see the last link above....
As I already said I am looking for a cross platform library and I want to find specific files and folders inside folders and subfolders. I don't know how much more specific I can be. Of course if I have to I don't mind using platform specific solutions but I rather I don't. 
What does “specific file” mean in your case? What criterion do you want to discriminate files by?
Fake news !!!! &amp;#x200B; A coder using a pen and paper ? I thought coders coders cannot survive outside their native environment of torment, Vim :D
find a \*.acl library inside c:\\\[Ephestos Install Directory\]\\2.8\\datafiles\\ephesots\\acl\\hecate\_core.acl &amp;#x200B; ACL is a specifed DLL working as a plugin like component for a project I am developing called "Ephestos". It stands for "Aura Component Library". The component can be loaded and unloaded during the execution of main executable and allows me to change code on the fly, interactively, while monitoring path of execution and performance. It also design so it auto warps to python code with no need for additional code using the Python C API. Unlike regural DLLs a ACL does not allow direct access to its functions, but only indirect access through request system via the request function. &amp;#x200B; My entire project is meant to be implemented as a collection of component libraries (inspired by Delphi VCL \[ Visual Component Library \] ) so the existance of the file is crucial when the executable launched. The executable can function without the existence of the component library but in that case it falls to the default functionality which is Blender, an open source 3d graphics application &amp;#x200B; [https://www.blender.org/](https://www.blender.org/) &amp;#x200B; If the ACL is not found then I rather to alert the user of the missing file because as it is , Ephestos merely crashes which is not fun. I can do this with Python of course on which my project partly relies on but I like to keep this on the C side. &amp;#x200B; So making sure the hecate\_core.acl is located in the folder is crucial. &amp;#x200B; Hecate is a GUI API for custom GUIs I am developing meant to be used from inside Blender for more immediate access and ease of use for 3d artists. Hecate is mostly implemented as an ACL. 
and no #include &lt;stdio.h&gt;
Console or GUI?
&gt; I want to find a *.acl library inside c:\[Ephestos Install Directory]\2.8\datafiles\ephestos\acl\hecate_core.acl Still not clear. Do you want to check if there is a file with extension `acl` in that folder or do you want to check if there is a file with that extension in that folder or any of its subfolders (the latter is commonly referred to as “finding” a file)?
This subreddit is for C. Not C++.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead. Also, what kind of suggestion are you looking for?
*emacs
specific folder with relative path as I described. 
*Captain America Civil War music starts playing*
&gt; [thekilon] I want to do X &gt; [FUZxxl] Here's how you do X &gt; [thekilon] No, you don't understand, I want to do X &gt; [FUZxxl] I told you how to do X, what more do you want? &gt; [thekilon] I WANT TO DO X!!!1!
Yeah I know. But it just for fun. Don't take seriously 😊
Is this why amazon's interview is using a pen and paper? They wanted me to write the Lowest common ancestor finding using pen and paper while I am most comfortable with an IDE. Should I abandon relying on IDE suggestions?
But your example shows an absolute path (not that it would matter).
&gt;no stdio.h included &gt;void main &gt;printf to print a string at least you tried
Hello world? On paper? More like student life. 
That's some weird looking C you've got there.
#include&lt;stdio.h&gt; #include&lt;conio.h&gt; Void main() { Clrscr(); Printf("Hello world"); getch(); }
It's not c.
Really? Is it C++ then?
Yeah its fact
M using bootstrap for designing my site
What tasks are you behind on? Odds are, if this is a first or second level programming course then you do not need a "full understanding" of memory management. Understanding how arrays exist in memory, how pointers work with addresses, stack vs heap, etc.should be sufficient. That said, if there's something specific you're stuck on, you can certainly elaborate here. A good starting point would be to inquire with your instructor what level of depth is needed and perhaps why that is the case. Speaking from personal experience, when learning something new like this it is easy to start learning concept A, but then quickly see concept B that you need to look up, which itself has concept C to look up; however, most of the time all that amounts to is procrastination. Finish your initial task, and then afterwards if the thing(s) you discovered don't make sense look that up. Most of the time, I've found that the other topics I started to get sidetracked with either didn't matter or became clearer simply by finishing my initial learning task. In the bigger picture though, if you want a book try this: [Computer Systems: A Programmer's Perspective](https://www.amazon.com/Computer-Systems-Programmers-Perspective-3rd/dp/013409266X). It isn't *necessary* for learning C, but it is a good reference to have and helpful when you are beyond the basics.
Oh, is Bootstrap a language similar to C?
 if (index &gt; MAXSHELLS) { Should be &gt;= ? #define LASTARG(i) if ((i+1) &gt;= argc) { die("No port specified\n"); } Kind of spesific macro, defined far from where it is used. Would it be easier to use getopt() instead ? #define CLEARSCREEN printf("\033[H\033[J") Maybe it's fine on year 2019 to expect an ANSI terminal. IMHO, no need to clear screen at all. while (isspace(s[len - 1])) rtrim() escapes to the left, if given a chance. sigact.sa_handler = sighandle; Junk values in sa\_flags and sa\_mask, potentially strange results.
Not like c language but by using this language you can make responsive website.
Start with [What a C programmer should know about memory](https://web.archive.org/web/20151123133211/http://marek.vavrusa.com/c/memory/2015/02/20/memory/), and if you want (a lot) more: [What Every Programmer Should Know About Memory](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf).
Why is this even in C\_programming?
also no void in params
Must be practicing for a Google coding interview.
`conio.h` is not a standard C header. `clrscr` and `getch` are not standard C functions. Having `main` return `void` is not portable.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
I draw a woman, when I was at a mall's food floor. &amp;#x200B; She slapped me... However, she was prettiest woman I've ever seen.
Subject: NEW PLEAS HELP The artist has depicted a novel application of scanf in lime green against a an eigengrau background. The artist's choice of irregular indentation represents the juxtaposition of fragmentation and uncertainty against the cold calculating determination of ones and zeroes. The artist's decision not to clear the input buffer between scanf represents naiveté in wishing others to conform to the artist's expectations rather than subject considering a flexible approach to external factors. See also: "I don't get pointers" and "trouble with linked list"
I would just write `:wq` on the bottom of each sheet of paper
_nano_ sits in the corner wondering what the fuss is about... Found the sysadmin!
Thanks for taking your time, will fix these things.
What was your response to woman? After that
/r/wooosh
You should look up dirent.h. I found it very intuitive and quite simple.
ackchyually, it's *r/woooosh ^^^^^I'm ^^^^^a ^^^^^bot. ^^^^^Complaints ^^^^^should ^^^^^be ^^^^^sent ^^^^^to ^^^^^u/stumblinbear ^^^^^where ^^^^^they ^^^^^will ^^^^^be ^^^^^subsequently ^^^^^ignored
 🛑**ALERT**🛑 This account has been marked as a useless reply bot. We recommend you complain to the bot creator, where he will subsequently ignore your messages. You can also report the comment to your sub-reddit moderators to ban reply bots that don't follow the guidelines of [good bot citizenship](https://www.reddit.com/r/redditdev/comments/98vj9e/please_be_a_good_bot_citizen_of_reddit/) on reddit. 
Because most of the windows kernel is written in C, obviously.
You spelled Spacemacs wrong
Yee, spacemacs is the best. It lets the vimmers migrate to the superior editor. I just get so triggered everytime I read the word vim that I need to write something about emacs in response
conio in spanish is "pussy" badly written 😅
Who codes on paper aside from students who have to take tests on it?
Yes I was aware of dirent.h with my initial googling around but you recommending it to me gives much more motivation to give it a serious try. Thanks :) 
my bad , I was raised on command lines (back in 80s) but never embraced them so I am not super familiar with their concepts like relative paths. I should not have included that "c:" to avoid confusing you. &amp;#x200B; In any case I forgot to thank you for trying to help &amp;#x200B; Thanks :) 
"Having full understanding" is not a possibility in this universe. So its generally recommended to take things slowly , step by step , instead of overwhelming yourself with knowledge. Preferably with practicing a lot. &amp;#x200B; A good tactic I use is to make brain maps that help me map what I don't understand that I think break down to smaller questions that I should answer to gain a better understanding. Memory management is a huge subject that concerns pretty much every coder and every programming language , even ones with automatic memory management. So it will depend on what you trying to do. Memory management depends a lot on the problem you trying to solve and the type and structure of data you are dealing with. &amp;#x200B;
By convention 
uhh
Returning zero from main is you as the programmer saying that the program executed successfully. Users of the program have to take your word for it.
That's simply the way the language defines it. If you're curious, read sections 5.1.2.2.3 and 7.22.4.4 for the C11 standard, but in short it says that returning 0 means that the program will tell the operating system that the it completed successfully.
yikes
Do not fall behind on your tasks/assignments. Get them done and out of the way. If you want to dive deep after you have your studies taken care of I suggest you start at the beginning and work your way up through the layers of abstraction. I would recommend the 2 resources below that do a good job at this: 1. Read [Code: The Hidden Language of Computer Hardware and Software](http://www.charlespetzold.com/code/) 2. Watch the first 20 or so videos of [Crash Course in Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)
Not required.
I said nothing. I was shocked...
He slapped her back, she was the prettiest woman he slapped.
Why is everyone savaging OP? It's just a joke!
printf("%s","Hello, World");
Oh thank god I'm not the only one
he writing code
I think you should reply
FUZxxl is only giving platform specific answers which doesn't apply to the question. OP wants a library with a cross-platform API rather than spending time re-hashing something that's been done millions of times. &amp;#x200B; Maybe a small library like [cute files](https://github.com/RandyGaul/cute_headers/blob/master/cute_files.h) would work. Works on Windows, Mac, and Linux.
Try writing a program using `scanf` that prompts for a number, reads a number, prompts for a second number, reads that, and then outputs the two numbers. Try it with inputs (interpret `|` as newline) `12|34`, `12 34`, `12+34`, `12+ 34`, `12+|34`, `12q|34`, etc. For an interactive program, the typical preferred behavior should typically be to read what is asked for and ignore anything that follows it on the same line, but I don't think `scanf` makes that easy.
less writing code, more like drawing a matrix and trying to figure out why tf i am going out of bounds
Ya it has some quirks. That's one of the reasons I like using ncurses for interactive programs. A lof of that buffer weirdness is taken care of in the API. Challenge accepted though, I'll whip something up when I get home. 
OPs thought process: &amp;#x200B; \&gt; Looks at subreddits &amp;#x200B; \&gt; notices c\_programming &amp;#x200B; \&gt; curious.jpeg &amp;#x200B; \&gt; reads c\_programming intensely &amp;#x200B; \&gt; "c" &amp;#x200B; \&gt; "programming" &amp;#x200B; \&gt; head\_scratch.gif &amp;#x200B; \&gt; "see" "programming" ? &amp;#x200B; \&gt; see programming! &amp;#x200B; \&gt; this must be where they want to see my programming. &amp;#x200B; \&gt; takes pic of computer with phone
So FUZxxl recommending it three hours earlier was for the dogs?
Not a textbook, but clean codebases: sqlite and nanoPB. Check out an unofficial mirror on GitHub to somewhat align what your code should look like. I wouldn't expect your code to look like that in a year, but C is very easy to learn after the initial hump with pointers, and mastering simply requires reading a lot of quality code. (Unlike C++, which may as well require an apprenticeship)
There are a few sensible behaviors I could see for `12 34`: 1. Squawk because the user's entire input didn't match expectations and re-prompt for the first value. 2. Read the `12` and ignore anything past it, and then output the second prompt and await another line of input. 3. Recognize that the user has typed two valid values and accept them both *while suppressing the second prompt*. From what I can tell, the behavior of `scanf` functions other than `sscanf` and `vsscanf` are generally only useful if the input is guaranteed to match expectations. Otherwise, they are very prone to getting "out of sync" with what's being fed to the program. If there's some way to use them robustly, though, that would be interesting to know.
I'm pretty sure you're right. To use scanf in this way is a lot of extra work and I am pretty sure I'll have to manually clear the buffer with a loop in between inputs. But you've piqued my interest and now I'm going to do this. I love this kind of stuff.
I doesn't take a psychic to know you're Indian LoL
big oof
It is if you dont want the caller to be to pass infinite arguments.
At least one thing: List *nth = (List *)malloc(sizeof(List)); nth-&gt;r-&gt;key = data; //nth exists because you've allocated it, but r is a pointer that is not allocated = segfault. Also, because it is not shown here, it is possible there is a problem with how you initially started your list. I'm taking it for granted that your first instance of List was correct.
Just because it isn't required doesn't mean it's a good idea.
Step through it with a debugger. While doing so, think of what r points to after calling malloc. Understand that allocating memory for a structure which contains a pointer to another structure only allocates the memory for the pointer itself, not the child structure. In this instance, you are not allocating memory for an Employee, but only for a List.
\#DEFINE commentSection SALTY
:wq!
This is r/C\_Programming not r/ImNotTypeA
return 0;
For those wondering what the heck conio.h is, it's [this](https://stackoverflow.com/a/8792443/516959). Seems to be a MS-DOS version of Ncurses. If you want to learn how to do C in a professional way, you have to step away from such non industry-standard (in a bad way) tools. Someone sees you throwing this on a whiteboard or a personal project without being able to give an extremely good reason, they will squint hard at you and say "Thank you for coming in, you may be hearing from us during the next steps in our application process". Without contacting you again. Also, do not use getch like that. Ideally you will run your console only program from the command line after compiling it, in which you can see the output of your program after it completes. I assume you are using visual studio, in which case you can do [this](https://stackoverflow.com/a/1152873/516959) to prevent your program from closing.
I see... I added this line before I referenced `r` : `nth-&gt;r = (Employee *)malloc(sizeof(Employee));` and still receive a segfault. Below is the backtrace from gdb. Any idea why that may be? &amp;#x200B; `Program received signal SIGSEGV, Segmentation fault.` `0x0000000000400ac7 in insertAtPosition ()` `(gdb) bt full` `#0 0x0000000000400ac7 in insertAtPosition ()` `No symbol table info available.` `#1 0x000000000040082e in main ()` `No symbol table info available.` &amp;#x200B;
Emacs isn't actually real. 🙃
You'll get a lot more help if you post the code that isn't working. Otherwise, we can only guess. There are many reasons you might be getting segmentation faults.
When I run into stuff like this I start by drawing a long line of boxes on paper, filling them in with example bytes, and walking thru my algorithm by hand. 
&gt;Ah, I overlooked that. I added this line before I reference r : `nth-&gt;r = (Employee *)malloc(sizeof(Employee));` and still receive a segfault. &gt; &gt;Below is the backtrace from gdb. Any idea why that may be? &gt; &gt;`Program received signal SIGSEGV, Segmentation fault.` &gt; &gt;`0x0000000000400ac7 in insertAtPosition ()` &gt; &gt;`(gdb) bt full` &gt; &gt;`#0 0x0000000000400ac7 in insertAtPosition ()` &gt; &gt;`No symbol table info available.` &gt; &gt;`#1 0x000000000040082e in main ()` &gt; &gt;`No symbol table info available.` &amp;#x200B;
Ok, you have several potential problems here. First, there's absolutely no error checking. Before referencing a pointer, make sure it's not null. This starts with `head`, continues through the `malloc` results (malloc can fail), and should include all of the `next` references. Also, I think you should change the `List **head` parameter to just `List *head`. The pointer to pointer dereferencing can get confusing. Please also add `-g` to your build command. This will make gcc include debug information which tells you a lot more than "No symbol table found."
I'm fairly new to gcc and gdb, and didn't know about the `-g` command (very helpful, thanks!). I see that `current = current-&gt;next;` is likely referencing a null pointer. How would I get around this issue and properly make `current` non-null in my case?
Well here's the best I could come up with. I had to use the old getchar loop trick to clear the buffer after each scanf attempt, but if there's a way to do it using **only** scanf to get input and cleae the buffer I'd be pretty stoked to hear it. I went with a combination of 1 and 2: It re-prompts on bad input but takes the first valid integer it can find even if it's nonsense afterwards. The getchar while loop eats up whatever's left in the buffer until it hits the newline that was generated by the user hitting enter. I made a (terrible) game like this once about buying and selling stuff at a market. It can totally be done. #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; int main(){ int num1, num2, clr; bool got1 = false; bool got2 = false; while(!(got1)){ puts("Enter first number: "); if(scanf("%d", &amp;num1)){ got1 = true; } while((clr = getchar()) != '\n'){} } while(!(got2)){ puts("Enter second number: "); if(scanf("%d", &amp;num2)){ got2 = true; } while((clr = getchar()) != '\n'){} } printf("First Number: %d\n", num1); printf("Second Number: %d\n", num2); return 0; }
It sounds like you need a longer list. If you hit a null before finding the correct position, then the list has fewer elements than expected. What do you want to happen when you try to insert something in the 5th position of a list that's only 3 elements long? You could insert enough elements to make the list longer; you could simply add it to the end, whatever position that is; or you could not do anything and return an error.
Hi, please reformat your code by putting four spaces in front of every line, it will help other people read it! Alternatively, you can use the rich text editor on reddit, highlight your code, and click the little \`&lt;/&gt;\` icon to format your code as code! 
Writing in visual c++ talk about big oof
[Indexed sequential access method?](https://www.tutorialcup.com/dbms/indexed-sequential-sccess-method.htm)
/r/comedycemetery
The superior way to print string literals
Hey this one has some quirks in C so here's how I did it. Might not be the best solution but it may help you understand the quirks: #include &lt;stdio.h&gt; int main(){ /* Two buffers of arbitrary size. Since strings are * null terminated the length can be long. */ char buffer[50]; char buffer[50]; puts("Enter a string: "); /* Important to note from the fgets man page * that it will include the triailing newline. */ fgets(buffer, 50, stdin); int i, index; for(i = 0; i &lt; 50; i++){ /* Find the newline character and set a * variable to mark the index just before it. */ if(buffer[i] == '\n'){ index = i - 1; break; } } int count = 0; for(i = index; i &gt;= 0; i--){ /* Starting at the marked index load the * characters into a new buffer in reverse * order using a counter variable. */ buffer2[count] = buffer[i]; count++; } /* Add a terminating null character to the * second buffer so it works with printf. You * will get garbage if you don't. */ buffer2[count] == '\0'; /* Print them both to demonstrate. The * newline character is already in the first string * from fgets so only the second string needs it */ printf("Original: %s", buffer); printf("Reversed: %s\n", buffer2"); return 0; }
Only C is on-topic in this sub; try asking in /r/csharp instead.
["A derived class can have only one direct base class."](http://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/inheritance) And you get lost.
Thanks, and is this the site [https://c0x.coding-guidelines.com/index.html](https://c0x.coding-guidelines.com/index.html)
Marketing
I had never even heard of Ritchie until I started taking CS classes.
But world don't understand every single machine runs in C on basic
To be fair, the person on the left should be credited for NeXTSTEP which affected modern \*nix systems to a certain extent not to mention being the foundation of iOS and macOS.
That's outdated, but probably close enough. [Here's the C11 draft](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf) which is more current.
This is pathetic. 
Steve Jobs was more of the "face" (founder and CEO multiple times) of a huge company (Apple), whereas Dennis Ritchie was more of a "behind the scenes" guy who invented one of (if not the most) popular programming language in existence. The general public (non-programmers) focuses more on the "faces" (business people and the actual business entities themselves) rather than those who made technical innovations. Let's take Linux for example. I would bet my entire savings account that more people have heard of "Red Hat" than they have of "Linus Torvalds". It's a shame how it works sometimes. But thankfully Dennis Ritchie wasn't "ignored" among the tech industry.
Because Dennis Ritchie is not the public face of a company. Consumers don’t care about what he did. There are other people, who have made similar contributions, that you’ve never heard of. Can you name the guy who invented the seat belt? You use it every day so shouldn’t he be the most popular guy in the world?
Yes, because the inventor of C and UNIX was "ignored".
Wait, what? Machines haven't run on BASIC since the Apple II
If you're looking for fame, programming and computer science is probably not the field to go into. 
A Basic written by ***MICROSOFT!!*** I suppose they "stole" that too.
Let's also not lose sight of the fact that if NeXT had never existed, ObjectiveC would *never* have caught on. ObjectiveC is a *superset* of C, where as C++ is a derivation. Numerous languages have modeled their objected orientation on ObjectiveC.
Evil will always triumph because good is dumb. 
Get your **LYING** meme bullshit out of here fucking POS. No ideas were "stolen". [Apple offered to sell Xerox ***SIXTEEN MILLION DOLLARS*** worth of Apple pre-IPO stock for only *ONE* million, in order to get access to the technology at Xerox Parc](https://news.ycombinator.com/item?id=8979051), and Xerox lept at the deal. Xerox's engineers were upset that corporate didn't see the worth of their work, and didn't want to fund it's development any more. #YOUR POST HAS *NOTHING* TO DO WITH PROGRAMMING, AND IT SHOULD BE DELETED.
First, debug your code step by step. And let's see what happens: &gt;scanf("%s", &amp;array); &gt; &gt;... &gt; &gt; 3. Enter string here:something long At the moment you type "something long", **array** just contains the "something" part. And you did not terminate **reverse** with a null character('\\0') properly, so the printed string looks strange.
Super cool concept, but I'm going to play devil's advocate for C++ for a sec. Cleanliness. C++ combined with pragmatic coding standards is exceptionally clean, and very easy to read. Simple Containers. Containers are so damn simple to use and have half as many gotchas as manually putzing with allocated arrays. Fewer loops. Standard library functions are bountiful and their algorithms can be much faster than traditional C loops. After getting past the initial syntax, and introducing lambdas, you can filter and search arrays faster than ever. Ultra type safety and dimensional analysis. There are already a handful of great dimensional analysis libraries available, combine those with libraries for vector maths and you have very simple, but likely bug free math core. Enough soap box. Again, I think it's a super cool concept, I'm interested in helping, but the link+home brew captcha skeeves me out a bit; an alternative method of contact would be preferable.
I can help, dm me with your questions
HOW CAN SHE SLAP !?
I guess that works, but I think the code could still release nasal demons if the user types in a number that's outside the range of an `int`. If you're going to have to use `getchar()` to flush the input, I think one could just as well use it for everything.
Well you can use additional formatting to control the amount of digits included. "%5d" to only accept up to 5 digit integers for example. But I think you're right. scanf isn't really designed for this kind of thing haha. 
Optimizing compilers can do wild things to code if it doesn't change execution. I love looking at Godbolt output for that reason alone. Oh you access the same variables, in the same length arrays in multiple neighboring loops? Let's optimize to one loop.
That's when I first used a QWERTY keyboard. I don't know how to say exactly at what age I "learned" it. I guess in elementary school I could kind of type okay.
I'm a C tutor. If you want to set something up with me where we can go back and forth with your questions (and you can see my solutions to the same ones), go ahead and send me a PM.
DAE vim vs emacs????
For what it’s worth, Amazon.com have copies and they ship worldwide
The rule is quite simple. When an array decays to "a pointer to its first element" (as it does when passed to a function, say), it's only the _innermost_ dimension that decays. So if you have: char *foo[3][4]; i.e. `foo` is "a 3-element array of 4-element arrays of character pointers", then the "3-element array" bit is turned into pointer. So this array could be passed a function defined as: void f(char *(*bar)[4]) { ... } Note that `bar` here would be "a pointer to the first element" of the original array `foo`, as required. `bar` would be "a pointer to a 4-element array of character pointers". 
puts("Hello, World");
What do you mean?
Well, you can also use EXIT\_SUCCESS, EXIT\_FAILURE declared in &lt;stdlib.h&gt; as the return value. Easier to understand, probably. &amp;#x200B;
Thanks for the great explaination
What?
#IT IS IF YOU DON'T WANT THE CALLER TO BE ABLE TO PASS INFINITE ARGUMENTS.
https://www.amazon.com/gp/offer-listing/0471578053/ref=mw_dp_olp?ie=UTF8&amp;condition=all is it this
Well you have the factors right there, all you need to do is add them to a total sum and check if they are equal to your number
so total sum is an integer? im not sure how to add the factors.. like are the factors all now separate integers
The distinction between `f()` and `f(void)` only exists for function declarations, not function definitions.
So in your if statement you're checking if your number%i has no remainder and printing the factor right there which also means the current i is an integer you can add to a sum 
\&gt; home brew captcha skeeves me out Don't worry its C tutorial, so no for you... 
Kernighan &amp; Ritchie, inventors of the language, published the original book on C. I don't know if it is still in print. 
ahh thanks so much 
Yes
This language is known as HTML
They say it ships to my place, but actually it won't get here.
Nice im probs wrong cos im new to codin but make sure its compatible still 
Wow, sounds cool. Where can I get an HTML compiler?
It might not be compatible enough for a beginner to learn C from but it's compatible enough to learn about obfuscated C and some other tricks.
Ah ok. I meant incase stuff got depricated
Check out the ncurses library. http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/
These are excellent! Thank you.
I'm just being absurdly obnoxious. I actually think emacs is pretty good, and in eVil mode, I can actually use it without being confused.
Which operating system are programming for?
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
If you’re in the US or Australia you could see if there is an Amazon locker nearby.
I assume it is printing `"error"`? execvp sets errno. Print that, or the output from strerror to find out what the error is.
I get 'Undefined error : 0' What does this mean?
Is there an executable called *echo* at all along your $PATH ?
There isn't
"echo" is one of the builtin commands that shells do within themselves, without exec.
Instead of `printf("Error\n");` you should use `perror` to print an appropriate error message.
That means “no error.” Please show me how you generated this message,
Which system are you on? There should be an `echo` binary somewhere in a directory in your `PATH`.
Yes, but still, an `echo` binary should exist.
Stupid question then, how do I locate the binary 
The messages generates if I use fgets() instead of gets(). If I use gets, echo "Hello World" for example just prints another line
In the shell, type `which echo`. What is the value of `PATH`?
In the code you posted, there is no place where you call either function. If you want help, it might be useful to post enough code for others to reproduce the issue.
[https://pastebin.com/XNUZhNTS](https://pastebin.com/XNUZhNTS) \---- Full Program Output: \[ 12/03 - 15:41 \]# ls execvp: No such file or directory &amp;#x200B; or in the case of echo \[ 12/03 - 15:43 \]# echo Hello World &amp;#x200B; \[ 12/03 - 15:43 \]# &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
There is no value. What outputs is: /bin/echo ---- in terminal echo: shell built-in command ------ in iTerm
Your argument parsing is incomplete. You basically only split off the command name and enter that into the `argv` array. You neither terminate `argv` with a `NULL` to indicate the end of the arguments, nor split up the remaining command line into arguments. Another error is that `fgets()` actually reads the trailing newline you typed into the buffer, but you do not split it off. You can do this by simply calling `strtok` with `" \n"` instead of just `" "` for the field separator. `ls` is not found because you ask to execute `"ls\n"` which doesn't exist. `echo` prints nothing because you do not set up the remainder of the arguments. By chance, `argv` starts out with all entries set to `NULL`, so you at least do not see garbage being printed.
How do you check what value `PATH` has? It seems wrong that it has no value. The first one says that `echo` is found in `/bin/echo` which seems correct. In the second, it seems that you use a different shell which has `echo` built into it.
There's my Big-O moment. Thank you so much for the help!
I though obfuscated C was the shit until I knew APL
&gt;That's outdated, but probably close enough. &gt; &gt;Here's the C11 draft &gt; &gt; which is more current. thanks...
APL](https://en.wikipedia.org/wiki/APL_(programming_language\)#Examples)
This subreddit is about the C programming language. For posts about programming in general, please try other subreddits like /r/webdev.
I don't think fscanf was designed for any purpose other than processing machine-generated data whose format could be safely relied upon, and so far as I can tell both `scanf` and `gets` were intended for programs that would be directly be used by the programmer for immediate one-off tasks (if a program's going to be used once, immediately after it's written, by someone who isn't going to overflow the buffer, guarding buffer bounds may be a waste of time). Beyond those situations, keyboard input is inherently unreliable, and `fscanf(stdin, ...)` would seem like it should have been just fine for reading from pipes or redirects. For console apps or programs that process human-generated text files, line boundaries should be sacred. I really can't think of many cases where line boundaries would be relevant but code would want an over-length line to be treated as two lines, but maybe such things used to be more common? 
No, it's built into the shell executable. In an old MS-DOS system that would be command.com, and in more recent Windows versions it's cmd.exe. To execute a built-in command like echo using a spawn command you'd need to call "cmd /c echo foo".
POSIX requires there _also_ to be an `echo` binary, IIRC.
We are clearly not talking about (WIN)DOS in this post.
Please provide code for struct implementation, struct initialization and attempt to read from it.
I haven't gone into this in detail, but I can already tell I could've used it two weeks ago.... I'm writing kernel modules, and I believe one of my commit messages was "refactored error handling control flow: how I learned not to worry and embrace the goto"
Nice idea. Is there no way to embed the c files into the .md output? You can do that kind of thing with sphinx/rst.
why do you prefer multiple gotos rather than initializing variables to NULL and having a single goto that cleans non-NULL? (i'm just curious - i tend to use the single goto, but perhaps it's not optimal).
Thank you, I actually didn't know you could initialize, increment/decrement multiple things in one for statement so that's a good to know. However I have tried terminating the reverse array with a '\\0' prior, and it still doesn't completely fix the problem here's an output for an example. &amp;#x200B; Enter string here:something gnihtemos² &amp;#x200B;
I am guessing that you are working on Windows and that you are using `system("COLOR 0A")` to change the text color like is shown on [this](http://blockofcodes.blogspot.com/2013/06/how-to-change-text-color-of-cc-console.html) website. If this is the case, the [COLOR](https://www.computerhope.com/color.htm) system call sets the current color. If you want different lines to be different colors, you will need to call `system("COLOR XX")` every time you want to use a new color. You will also need to call it when you want to go back to the original color.
I'm not sure if "head = current-&gt;next" actually does something to the pointer outside of the function, it seems to me like it only changes the pointer argument that is inside the function, maybe you need a pointer to head and then change like *ptr_head = current-next. The seg fault could be because you're freeing memory but head doesn't really change in your list.
Would that issue still be the case given that the functions work properly and print when deleting any node except the first?
That's why I pointed on "head = current-next&gt;next" because it's when you try to delete the first node of the list, when you delete one node in the middle you're using "current-&gt;next = current-next-&gt;next2" which is doing a different thing, it's changing a member of a structure that holds a pointer. I'll check with a compiler later if you still have the issue.
I actually like OP's method. It resembles defer statements in Go, which I think are very readable. Also, OP's method might be more efficient because variables do not need to be tested again during cleanup. Maybe this won't be considered best practice, but I think it is a very structured and readable use of goto. C can be difficult to write readable code with, but OP's system looks like a good format for error handling.
For `scanf` and `%s`, see: ["Any number of non-whitespace characters, stopping at the first whitespace character found."](http://www.cplusplus.com/reference/cstdio/scanf/) &amp;#x200B; And make sure you terminate **reverse** right after the last character.
The [string example](https://github.com/gurugio/book_cprogramming/blob/master/cstring.md) uses too many function pointers. First, it wastes memory. An empty `cstring` already costs 88 bytes on x64 and we almost never need the polymorphism this design brings us. Second, it is going to be slow as compiler can't inline trivial function calls. Function pointers are like virtual functions in C++. They are flexible but have performance penalty. When you need to create millions of objects, putting function pointers in a struct is discouraged.
You can do it with doxygen+Sphinx 
So would it require changing the prototype to `int deleteByLocation(List **head, int location)` ? If so, how would I have to rewrite the statements that include `head` ?
Also if the point is to create a namespace, separating the functions and the data into different structs would allow reuse of the same functions instance for all data instances, reducing the memory footprint. It would probably even allow compilers to eliminate the overhead of the pointer dereferencing.
Try that, you would only need to replace `head` to `*head` inside your delete function
Tried that and still have the same issue. Here is a backtrace from gdb. &amp;#x200B; Program received signal SIGSEGV, Segmentation fault. 0x00000000004009da in printList (head=0x603250) at linkedlists.c:112 112 printf("%d, %d, %d| ", temp-&gt;r-&gt;key, temp-&gt;r-&gt;id, temp-&gt;r-&gt;age); (gdb) bt full \#0 0x00000000004009da in printList (head=0x603250) at linkedlists.c:112 temp = 0x603250 \#1 0x0000000000400863 in main () at linkedlists.c:62 list = 0x603250 check = 1 amountDeleted = 1 
Cancel that. Got it figured out, that worked for me. Really appreciate the help!!!
Can you please edit your post and remove the facebook tracking ID at the end of the link, for those who don't want to be tracked?
This code is using your delete function with the modifications I told you about, it seems to be working fine [https://codeshare.io/5NQn84](https://codeshare.io/5NQn84)
I'm glad, no problem
The approach I'd favor for strings would be to have a string descriptor type whose first byte identifies it a such, and have other string and string buffer types that are preceded by a length whose format can be identified by the first byte. Use a function to build a string descriptor given a pointer to any kind of string (which could in fact be a string descriptor) and one could gain the benefits of efficient storage and avoid the need to have to make redundant copies of data when passing temporary substrings.
The use of goto also allows for control to be cleanly broken out of any loops that may surround the error test.
I am sorry. i did not know it. I did not meam it. It is wierd...I thought I just copy a link.
Since you still need to pass pointers to the functions, same result could be easily achieved by creating functions like cstring_clear, cstring_length and not carrying the pointers around. You'd need to include cstring.h everywhere so you'd be able to access the functions anyway. You'd have your OOP and still be memory efficient.
Sorry to be pedantic, but if it's not allocated in a loop it's not a "leak" by definition. :)
Nothing wrong with being pedantic, I'm here to learn! I wrote my whole game without using a single malloc of my own because that's one of the areas I'm not confident in. But the ncurses initscr() function seems to allocate some memory that is "still reachable" after the program ends. One of the next things I need to learn about C is memory allocation. I'd be happy to read any articles or thoughts you want to share on the subject.
You misunderstand. They're asking why 3 goto targets instead of a single goto target, which is also another common form of the pattern.
I tend to use a single goto + NULLs. The only time I'll use multiple goto exit targets are if I have a "happy cleanup + return" vs a "erropr cleanup + error return".
Sorry, I don't really have enough experience to be able to recommend stuff about allocation. My reply above was something I heard from a more experienced (and pragmatic) developer and that made sense to me. He also said that the best memory free method is closing the program and as long as that works, you're fine. :) I like to keep things clean also and I strive to free all the memory I'm allocating, but to my knowledge there's no way of forcing the libraries you're using to do the same, outside of them having an explicit way of freeing their resources. 
While I'm not 100% familiar with the internals of ncurses, I think the main problem is that ncurses keeps a lot of state in global variables. This state is allocated with `initscr` at the beginning, but never deallocated afterwards. Similar memory “leaks” occur when using standard IO functions; a buffer is allocated for `stdin`, `stdout`, and `stderr` on first use and this buffer is only deallocated when you close these files. I wouldn't worry about them too much. The leaks you should worry about are the “unreachable” leaks because they indicate memory that can no longer be released by any means because you forgot all pointers to it. This has nothing to do with loops by the way.
Thank you for pointing out the definition with loops. When I read the other poster, I was scratching my head because that sounded really off. However, I think I see where they are coming from because an allocation inside a loop that's leaking is really bad because the leak will at some point become a flood, so to speak.
Seriously?
This community should be moderated.
You could do scanf to read the number, then convert the number to a string and compare the strings. Also you could write your own conversion function and check to see if the last accumulator value was bigger than the current to detect overflow. 
&gt; compare the strings. make sure you align the decimal places and pad with 0s if using string compare
If you use the standard library function strtol() to do the conversion, it will set errno to ERANGE if the number is out of the range supported by the "long int" type.
Definitely go with strtol() or strtoll() (unless you have an assignment to essentially replicate the implementation of these functions) You know the saying "don't re-invent the wheel"? Well.. there's a lesser known saying "don't re-invent a square wheel". In other words, for most common issues someone has mostly likely already built a really nice, tried-and-true solution to the thing you're trying to do, so don't waste your time re-inventing a worse version of it. In other words -- don't re-implement anything in the standard library.
strtol() just kicks the can down the road, what if the user enters another, longer, overflowing lnumber &gt; long int can hold?? Better to parse the string IMO, i.e., (in pseudo-code) Count the number of digits, if the number of digits &gt; 10, number is out of bounds, if = 10, then check first digit, if it's &gt; 3, the numbers out of bounds, if it = 2, check the next digit, and so on in a loop until all digits are checked against the upper bound you want to set.
How so? What definition of leak is this based upon? 
&gt;He also said that the best memory free method is closing the program and as long as that works, you're fine. I'm not exactly an experienced programmer, but I don't think I can agree with this statement. Sure, the OS will most likely take care of freeing any memory that your program used once the program is killed. But that doesn't mean we should blindly rely on this mechanism. Also, this seems to encourage to just keep things around and not to worry about freeing them ASAP, because the OS will do it anyway -- but this might lead to a much higher memory usage (possibly an unacceptably high usage) than the program would need to have.
You're spreading misinformation.
Lol or just don't do it. I came up with that idea after waking up 10 minutes earlier. 
I thought that, but it turns out strtol sets errno so you know for sure it couldn't fit. 
&gt; Also, OP's method might be more efficient because variables do not need to be tested again during cleanup. It is, i checked with godbolt by modifying the code to use a single goto with NULLs and both GCC and Clang produced slightly faster code with the multiple gotos (at least according to llvm-mca, although i do not see what could trip it up).
Using strtol() isn't about the size of the return type. It's about the fact it does error checking and tells you when the value doesn't fit in the type. Which is exactly what OP wants to know. Don't reinvent the wheel when the problem is already solved by the standard library, which is heavily debugged and maintained by someone else for you.
Wut? Not where?
C does not have an exponentation operator (typically \`\*\*\` or \`\^\` is various other languages), so you have to use a function such as \`pow\` instead.
in c language. i am asking which arithmetic operator you don't have in c.
We have [all four](https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations) of the basic arithmetic operators.
I mean I might be wrong, but "spreading misinformation" sounds deliberate, which I assure you it is not. Can you detail why and how am I wrong?
The definition where memory consumption increases over time. If you only allocate memory once (ie, not in a loop) this doesn't happen, hence not a "leak". 
There are infinitely many arithmetic operators and almost all of them are missing. This is a stupid question.
I can't really reproduce the context in which this statement was discussed, and I can understand you disagreeing, but the large picture would be that for short lived programs that are not doing allocations in a loop (ie, overtly leaking memory) bothering with deallocating it before application close is not really neccessary from a pragmatic point of view. Of course, from a code sanitation point of view, one should always deallocate all memory allocated.
Also, I'm pretty sure this image is just wrong. Which of [these operators](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B) would you consider arithmetic?
I mean, the JavaScript background to the image isn't the first sign of wrongness?
[It is.](https://www.reddit.com/r/C_Programming/about/moderators)
While memory leaks in loops, interrupt handlers, etc. are particularly serious, the clear definition of a memory leak is unreleased memory that is no longer needed. You should free all your memory, even if you didn't allocate it in a loop. And you shouldn't rely on the operating system cleaning up after your program terminated.
great idea! thanks.
Ah, I see where you are coming from now. I kindly disagree nevertheless: you could write a program that, even though it might never enter a single loop, allocates large amounts of memory a couple of times. The simplest example would be a program that, during its lifetime, has to read in a couple of different files and do something with the contents. If you never free and some of those files are really big, you might run out of memory before you even reach the end of the program.
The main changes since 0.4.0 (the last time it was posted here): * The library is continuously fuzzed by OSS-Fuzz * Optimizations for x86 is no longer an external patch * Source code [amalgamation](https://sqlite.org/amalgamation.html) There's also [benchmarks](https://libspng.org/comparison.html) (bottom of page) between spng, libpng, stb_image, and lodepng.
How does this compare to lodepng?
my thoughts too, to be honest tho. I've had some issues with some png's using lodepng (can't remember but I think it had something to do with alpha)
The [comparison page](https://libspng.org/comparison.html)(scroll down) compares the features and performance.
Personally, I'd go semi-brute force **if I can make certain assumptions**, such as it can be limited to an integer and the string can only contain numbers. Pseudocode would be something like this (can be updated to support signed integer): function is_int_string_in_range (s: string): return boolean precondition: for all c in s, c in [0-9] // no spaces, etc. precondition: s.first in [1-9] // no leading zero precondition: LOCALE is such that numeric strings sort intuitively ("10" &lt; "15") max_int_string= "2147483647" // can likely get this programmatically if len(s) &lt; len ( max_int_string ) then return true else if s &lt; max_int_string then return true else return false
It's not single source header pair. Were you referring to libpng in the title?
[https://libspng.org/download.html](https://libspng.org/download.html)
First, list for me ALL operators, then I’ll tell you which C doesn’t have.
&gt; * Source code amalgamation Wonderful! I love amalgamation libraries, but they're oh so rare.
Yes, this is how a string library should be implemented. It is ok to have other tricks (e.g. flexible array), but putting these many function pointers in a struct is one of the worst designs...
So it's single source/header but builds a PIE `.so` by default as well. That wasn't entirely obvious, but I'm happy to see it. 
GTK+ is the best option. it's well documented, lots of example code and has a ton of features. There's also Xlib but you won't find a lot of examples for that
That's going to be a fairly large undertaking for a hobby project. Why reinvent the wheel? Checkout GTK. https://www.gtk.org/ Maybe start by building a simple GUI program with that library first. 
You can download the source code for ncurses and investigate yourself. There is also a [partial explanation in the FAQ for ncurses](https://invisible-island.net/ncurses/ncurses.faq.html#config_leaks). Generally reading the FAQ for things you are interested in is a good idea.
It’s a shit idea. That fool is reinventing the wheel. ‘Strtol’ will tell you if it’s overflow or not. These things are trickier than you think to get right. 
Thank you! That partial explanation is something I've already come across which is why I came to the conclusion in the OP that "it's normal." I've been through the ncurses FAQ many times although I surely have much more to learn. What I was hoping to get in this thread were anecdotes and explanations about memory allocation in general from those of you who have been doing this for awhile. That knowledge will help me a lot in taking a deeper look at the source code, or any source code that uses memory allocation. To this point I've gone out of my way to avoid using malloc. I'm sure you have lots of valuable knowledge to share with someone like myself who is at this stage of learning C. 
Thank you I'll definitely look into it :)
Depending on what scale of an ide you need, vs code. 
I want to love vs code, but it randomly causes my Ubuntu installation to freeze, and no one seems to have any idea as to why.
Just install it from source
[Atom](https://atom.io)
Have you tried this? Why do you think it would be better? I'm willing to try, I'm just curious.
I’ve not tried it but I’d give it a shot. How exactly does it cause your system to freeze and have you tried launching it from the command line?
Use a terminal. The shell is your IDE.
Can you explain please? I wrote code directly into the shell? I guess not.
On the store, people's are complaining that the store edition has a lots of bugs compared to the one from the official site. I just read the comments. I've no experience. 
Use a terminal text editor (vim, nano, emacs) to make your source files then compile with gcc.
Oh okay I'd try that. But maybe a conventional IDE would be better for me.
Try it out before rejecting it. I find IDEs just confusing and annoying.
I'd definitely try it. If it feels better then I'd stick to it perhaps. Thanks anyway.
Clion is pretty nice
Do not ever use gets. Ever. At least do fgets. 
Jesus wept. What is that monstrosity ???
Vim, it's always Vim.
Your `save` function is writing the pointers to the file, not the strings. The pointers are meaningless once the program ends.
I use vim with molokai/monokai. Get vim and plug in vundle and youll have like 100+ themes for it.
neat.
Thanks! You wouldn't happen to know if the load function is doing something strange as well? It sometimes loads in just null values, other times loads in a mixutre of two saves strings and other times loads in the one string repeated. 
That's pretty cool. I like the way the database access works.
Assignment, here, is not copy assignment. string_array[i] = line saves the address of line (because it decays to a pointer) in the ith position of your array. Line's address never changes, so each time, each subsequent entry in string_array is receiving the pointer to the beginning of line. Line goes out of scope after this function concludes, so the values at that memory location may get overwritten or anything else. 
Vim in your terminal.
I use I3 proper with no desktop environment and then drop in to Unix Porn from time to time.
This community should be moderated harder.
I've been looking for similar tools like gtk and all of them look like they were built in the early 2000's. Do you know any tool that can help make a modern looking gui? I've seen some really nice looking programs made with javafx is there anything like that for c/c++?
Ok so I think qt is my best option :)
If all you're doing is messing around with colors, I'd recommend skipping ncurses and printing escape sequences (https://en.wikipedia.org/wiki/ANSI_escape_code) yourself. I wrote a library (https://gitlab.com/sifoo/snigl-term/blob/master/src/snigl_term/lib.c) to add basic support to my own language; I'm sure you can work it out from there, otherwise just ask and I'll try to help.
I used Qt Creator recently in my C programming course and I loved it! Also it's called that but it just has support to write Qt applications, but behind the hood it a common C/C++ IDE like any other. I don't know if it will be dark enough for you though, but it supports theming of the editor!
I would recommend QtCreator. Everyone recommending you jump from VS to vim is delusional tbh.
Do you really need to index/search on disk? What about simply reading all of it into memory and performing the search there instead? Assuming it's not gigabytes of data or thousands of searches, a simple linear scan should work just fine in memory. Otherwise it depends on how fast it needs to run and if you need prefix matching or only full phone numbers. Another alternative would be to delegate indexing and storage to SQLite (https://sqlite.org/index.html), depends on where you're going with this.
What is fgets and what’s the difference 
Excellent share! I've been getting more into network programming lately so this definitely looks like something I might use in the near future. Are there any plans to put the source on Github or some other open source platform? Just wondering. Either way, thanks for the library!
It looks like you never modify `wave` within your loop.
This might be heresy because I primarily deploy to Linux but dev elsewhere, but I’ve recently started doing more in Linux directly. I like visual studio code. It just works. To me that’s all I fucking want. Like, on Ubuntu 18.10? I installed code::blocks, from the package manager, and the fucking thing will crash every time after a while. After googling it, it’s a known fucking issue. Maybe it’s resolved by now, who knows, point is I grabbed from “stable”. I’m not a Vim/Emacs expert. I suspect if you are, those are great. Problem is, on the variety of shit I work on, Visual Studio style setups are king. Doesn’t have to be visual studio to edit, but the pipeline inevitably runs through MsBuild/incredibuild/whatever, so it’s best to use something compatible. I have it a shot, it’s stable, and I’m able to spend time fixing shit that matters instead of fixing the damned editor. With that said, I use vim/neovim if I’m on a *nix system I can’t alter as much as I’d like.
Atom is by the far the best IDE I’ve ever used, would recommend 
I use Vim and clion (and have used QT creator). Vim takes a pretty serious commitment. Despite the internet dick waving every does about Vim, it is not easy to setup, use, and become efficient with. If you can take the time, you will likely be more efficient at some parts of coding than you could be on clion or others after you get good on Vim, but Clion (or qt) will likely make you a better coder faster. It interfaces nicely with cmake and git and makes a lot of tough things easier with its debugging interface and its built in linting, code completion, search, and others. Negatives with clion are that it has a tough time with linting and type / code completion hints which are behind templates or auto types. I don't know if other options like the plethora of plugins in Vim are any better though, so take that as you may. 
I didn't read your code but it sounds like a missing PATH, my shell looks into my \~/.profile to get the PATH echo $PATH /home/sinus/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin:/usr/local/bin:/usr/local/sbin:/usr/games:. Something like: getenv("PATH") I think most shells have their own echo, because it's really simple to implement
I just read the code for 1-2 minutes so it's just a guess: int main(void) { struct returnData data = fileInput(); for (int i = 0; i &lt; data.arrayIndex; i++) { printf("%d\n", data.rainFallData[i]); } undefined behavior, printf needs a %f to get the value of data.rain... right or cast it as an (int). &amp;#x200B; If you give me a correct \*.txt I would test it
Thank you very much. That small change fixed the issue I was having with the display of the values. For some reason I forgot that %d and %f behaved differently. I have added the file of values into the github repository for testing as well. &amp;#x200B; Thanks!
I think there's another bug, line 50 to x give me some overflows and then a lot of 0.0 -241776797327335063635638956136172741395465333001493966370813673522684311630309235178230122511723093492945764572817519624812144623616.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 -316388621163970023587602514105600678762375585641121753801111381457065698090881113045798529569997227074223320167936877670161467398160384.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 &amp;#x200B;
1. Please pick an [indentation style](https://en.wikipedia.org/wiki/Indentation_style) and stick to it. 2. Don't disable warnings. Fix them instead. 3. Don't cast the return value from `malloc()`, `calloc()` or `realloc()`. It's unnecessary in C (unlike C++) and can hide mistakes. 4. Always check the return value from `malloc()`, `calloc()` or `realloc()`. *Especially* the latter (use a temporary variable). 5. You can't call `feof()` preemptively. Call `fgets()` (or some other input function) first, then *if it fails*, use `feof()` and `ferror()` to determine the cause. 6. There is no reason to use `fgets()` and `atof()` here. Just use `fscanf()`. 7. Although it is possible to return a struct by value, it is rarely a good idea. 8. The correct conversion specifier for a `double` is `f` or `g`, not `d`. 9. The most likely reason why your program would crash when it reaches `fclose()` is that `input` gets clobbered by a buffer overrun, although I can't quite see where. You should look at what happens in the last couple of loop iterations before EOF, and perhaps set a watch on `input`.
**Indentation style** In computer programming, an indentation style is a convention governing the indentation of blocks of code to convey program structure. This article largely addresses the free-form languages, such as C and its descendants, but can be (and often is) applied to most other programming languages (especially those in the curly bracket family), where whitespace is otherwise insignificant. Indentation style is only one aspect of programming style. Indenting is not a requirement of most programming languages, where it is used as secondary notation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
What about it is giving you trouble? In the broadest sense you need to make a question and answer key and then take some kind of input for each question and check it against the key. 
Put a unique value at the end of your data file, e.g. "42.0". I bet you find it ends up in your array twice. Hint, read up on how `feof` works - and you probably should just change your code to not use it. Carefully compare how you compute how many bytes to allocate for `rainFallData` initially vs when you realloc it. Your choice of names adds to the confusion. E.g. When I see "size" I think size in bytes, not number of elements. So, I would expect `currentSize` to be in bytes. However, maybe you prefer "size" to mean number of elements. But, whatever you decide, you need to be consistent. You can't use it to mean both - which is what you're doing and leads to reallocation bug I previously alluded to. Furthermore, `currentSize` isn't the current amount of data, it's the current maximum amount of elements you can store `rainFallData`. 'EXPECTED_DATA' is not data at all. It's the amount, in elements, by which you grow `rainFallData`. I.e. you allocate `rainFallData` in chunks of 'EXPECTED_DATA' elements. I also think `arrayIndex` is not a particularly good name. Sure, it tells me you're going to use that variable as an index into a array, but that's not very descriptive of what it's used for. Personally, I like to use "count" when talking about numbers of elements. Some people like "num". Here's some ideas for better names: `arrayIndex` -&gt; `rainfallDataCount` // the number used elements `rainfallData` `currentSize` -&gt; `rainfallDataMaxCount` // max number of elements `rainfallData` can hold `EXPECTED_DATA` -&gt; `rainfallDataChunkCount` // number of elements by which you grow `rainfallData` Improving the names will make it easier to reason about your code.
 currentSize = (arrayIndex + EXPECTED_DATA) * sizeof(double); currentSize contained the wrong value in your if() ! Your code: if ((arrayIndex + 1) == currentSize) { currentSize = arrayIndex + EXPECTED_DATA; rainFallData = (double *)realloc(rainFallData, currentSize); } &amp;#x200B;
Code formatting, please.
I went through the original code again and tried to change as much of it as I could to align with your suggestions. 1. I tried to stick more to a more conventional indentation style. 2. I can change the `fscanf()` call to an `fscanf_s()` call and that should get around the error. 3. Removed the cast type. 4. I have two checks now, one during the initial allocation of memory, and a second that occurs before every `realloc()` is completed. 5. Removed the need for `feof()`. I am not completely convinced my solution will work, but it is a building block. 6. Replaced the `fgets()` and `atof()` with a single `fscanf()` call. 7. Now passed via reference. 8. Fixed the dumb mistake. 9. No longer an issue with the population of the array, but an access violation while reading from the array in the `main()` function. Currently this solution does not work, but I will continue on it in the morning.
There is nothing wrong with your solution, only with your implementation. Take a long hard look at [line 47](https://github.com/BamSonnell/Water-System-Model/blob/e8c20b04c63190abd94dd2e0240a4e8394b0065d/Source.c#L47)... By the way, why did you change `double` to `float`? I would recommend changing it back. Just remember to use `%lf` for `fscanf()` (but not for `printf()`).
I just went through and renamed a large portion of the variables, and it made a huge difference. As you said the `currentSize` naming scheme created a large number of issues, namely, as you stated, the inability to differentiate between byte and number of elements. It is not perfect, but much better that before. I completely removed `feof` as well as `fgets` from the input function and am now using a single `fscanf` to accomplish the same task. &amp;#x200B; Thank you for the help. &amp;#x200B; [https://github.com/BamSonnell/Water-System-Model](https://github.com/BamSonnell/Water-System-Model)
I don't know actually, they are all back to `double's` now. As for line 47, my thought process is that after testing if the new allocation of memory occurred, I am able to set the pointers equal (which may not be allowed) and continue to `free()` the temp memory, so I can reallocate it later (this should be possible without `free()`ing it?) and also for memory efficiency (probably not a major importance for this program?).
If you call a stored procedure, more than one result set may be returned. Each of them must be handled properly before the next query can be processed. &amp;#x200B; See mysql\_more\_results() / mysql\_next\_result(). &amp;#x200B; More info: [https://bugs.mysql.com/bug.php?id=71044](https://bugs.mysql.com/bug.php?id=71044) &amp;#x200B; &amp;#x200B;
1. What is the value of `temp` after the `realloc()` call? (conceptually, not numerically) 2. What are the values of `temp` and `rainFallInput_File` after the assignment? 3. What does `free(temp)` do?
You can try to use linked list becouse its easy to eork with them and allocation memory for new element.
Is it an IDE or just text editor? If it it, then how do I compile and run the code on the fly? I don't see any option? 
I can recommend Geany with the Darcula theme. Not a fully featured IDE but very fast and lightweight with minimal Make and GDB support .
Break down the problem and solve it one step at a time. You program needs to: &amp;#x200B; 1. store the questions, the question choices &amp; the question answer 2. display a question 3. display the answers for the question 4. accept user selection for the answer 5. check the answer 6. keep track of grade 7. loop through 20 questions 8. display the grade at the end &amp;#x200B; If it was me, I would start with figuring out how I was going to store the questions and choices since this will determine the structure of the rest of the program. Good luck. &amp;#x200B;
Really? And here I thought that every time you make it impossible to recover a pointer (or just forget to clean it up) you had a memory leak.
Thank you. There will be a mirror on Github in a few hours.
`man fgets` is your friend. It lets you specify the size of your destination buffer. `gets` will happily overflow it if your input is too large crashing your program or worse. 
This is a subreddit for programming in C not Java. Try r/learnprogramming
Asking for help without giving any kind of effort to solve the problem isn't quite welcome in general. But you are in the wrong sub you should post here /r/javahelp/
This is the subreddit for programming in C, a different language to what you need to write in. Try /r/AskProgramming.
This subreddit is about programming in C only. Please post Java questions to /r/learnprogramming.
Removed for the same reason as your other question.
I created GUI wrapper (only windows) when I was learning C++ back in the day [https://github.com/t4th/win32-gui-wrapper](https://github.com/t4th/win32-gui-wrapper) Start with creating API you would like to use (i liked old Borland C++ Builder style) and then try to fit some native code (win32 C api in my case) into it. What you learn is how EVERY gui library works under the hood - both constrains and advantages which will help you choosing existing library. It was really fun experience to re-implement the wheel instead of analyzing millions of existing projects. It was fun learning project, but implementing full feature framework is not worth the time with all already existing stuff. 
This is one of the reasons programmers SHOULD do hobby projects where they purposefully reinvent the wheel. You won't really know what wheel you want or what makes a good wheel if you don't know anything about wheels. Besides, those libraries are built on top of already existing apis for gui stuff... they reinvented the wheel first. Also, sometimes you just need a screwdriver, not the deluxe 50-tool swiss army knife.
https://drive.google.com/folderview?id=1LSImWuoIptGbo2iwZgsZ3WJJxz664l1Y
1. Code formatting 2. Is the output from your first example or your second example? If it's the second, it looks like you never initialize wave. I think the problem here (from a coding exercise perspective) is that you're getting too lost just trying to make it work, that you've lost sight of what your code is actually doing. (Ie following the flow of the program precisely line by line) 3. As a general tip, get out of the habit of "saving" defunct lines of code in the comments. You're just going to end up confusing yourself as you essentially build and reuse broken things. It's better for your practice and muscle memory to delete a line you no longer need and simply retype what you need when you need it. 4. Rather than prompting outside the while loop, then testing for the condition, try this (pseudo-code, sorry, I'm on a phone): set up any variables you need in the loop while(1) { prompt for user input if (user input == 0) break; if (user input is invalid) display invalid input message; continue; parse user input and display output } The use of `break` and `continue` is a wonderful pattern for dealing with this type of control. The idea is that you fail early, and only deal with your success condition once you've verified that you haven't failed anything. This pattern avoids craptastic `if else` blocks and nested if statements.
A Github mirror is now available: [https://github.com/ventanium/ventanium](https://github.com/ventanium/ventanium)
Visual Studio Code and configure it to compile/debug apps.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
You may check out r/Cplusplus I'm not sure, but why can you set the private field `v`?
\+1 as complex as I get is geany, and I don't use half its facilities, its pane of functions and vars is handy, but mainly its just a text editor.... I use a separate terminal so as not to waste space with geany's term, with a good boiler plate Makefile you're golden.... 
I always compare using an IDE as a new programmer to being given a chain saw to cut a piece of paper in half. Sure it'll work, but you'll spend a whole lot less time trying to figure out how the chain saw works if you just use a pair of scissors.
That is correct.
I agree Vim is a bit much, but it wouldn't hurt to get his feet wet in some sort of terminal text editor like nano or something.
Be wary of the "I'm only going to do this the once" argument. Code has a nasty tendency to get duplicated. Encapsulating blocks of logic into small functions is generally a good practice - it helps keep your code readable and understandable, and done right, selft documenting. Is there any reason why you don't make this an inline function? Other than that and the already noted global variables issue, it's not a bad practice, and in some cases is even a good practice. A block like this limits the scope of variables declared within to that scope, so it can help with preventing leakage of variables that shouldn't be used outside the block. As with anything, it's situationally dependent.
Even if you only write this block once, you’re going to read it repeatedly. If you take liberties there, future you is going to annoyed.
Take care not to re-use variable names and make it visually clear that this is an enclosed code block (empty lines before/after, comment explaining what you're doing in the block). 
This seems unnecessary and has no actual effect on anything except making code less readable. Also avoid indentation, nesting and noise. 
It would be a tad more readable if you put your rp and rr variable declarations at the top of the block. (Some compilers will even complain about this.) Other than that, it's pretty obvious that you are setting up your just declared ramp matrix here, and it's perfectly fine, and knowing that those variables pop out of existence afterwards would be helpful to anyone coming along and debugging here in the future.
 LINKED_LIST * mergeLists(LINKED_LIST list1, LINKED_LIST list2, void * copyData(void *)) is not correct. It needs to be LINKED_LIST * mergeLists(LINKED_LIST list1, LINKED_LIST list2, void (* copyData)(void *)){ note the extra `()` This declares the parameter `cooyData` as a pointer to a function that takes a `void*` and returns nothing. void myCopy(void *p) { ... return; } int main() { ... merged = mergeLists(l1,l2, myCopy); } 
Yes, it's a function pointer. Google it.
ahh thank you. Googling "function in function signature" was NOT helping...
I second this. It's situationally dependent. There are places where putting a small, encapsulated block works well. But, on average, pulling something like this out into a separate function will make more readable code, even if this is the only use of that function. I see code all the time where people did **not** pull stuff like this out into separate functions. When the containing function reaches several hundreds of lines long, it becomes **really** difficult to understand the high-level flow of the function.
That is correct, no need for the () actually, though it's common practice with ().
I like this, but if the source is meant to be cross platform (the .c/.h amalgamation), why is the full source dependent on generated header(s) using meson? I thought this was generally only done when a large library needs target specific information.
&gt; Also avoid indentation, nesting Wut?
I like that you're trying to control scope of local variables. The typical technique is to write short functions that either call or composite other short functions. The flaw in this technique is readability and maintainability. Doing this on the occasion may make sense, but as a habit, you're introducing long function bodies and complexity. I would recommend your development process considers restructuring your code into functions before using this technique. Your compiler can inline functions in the same translation uint, and do not underestimate the value of giving something a name, even if you're using it once. And if your code you're thinking of doing this relies on a bunch of variables, and your functions start looking ugly because they have huge parameter lists, especially with a bunch of out params, that's a code smell that you need to reconsider your code structure before you consider using this technique.
There are no generated headers involved when building with meson. The amalgamation is just a concatenation of the full source.
If you nest and indent your code too much it will be less eye-friendly. Here I don't mean that you shouldn't indent code but rather refactor your code so it doesn't need indentation and doesn't nest as much. 
&gt; has no actual effect on anything Depends on how smart the compiler is, right? It would allow the memory on in the function stackframe used for rp and rr to be reused later for variables which are local to another block, as even dumb compilers should be able to figure out the memory is only being used in separate scopes.
I think I'm going to try make a few simple projects with qt to get a general understanding of how gui programs are made then then start working on my own library !
It is unnecessary. This will have no effect on the binary produced and will only add some noise.
This is such a subjective thing!!! If you are using a modern widescreen monitor. Indention nesting looks much better to me than the crap you see anymore. if(0 == i) { if(j==0) { doFoo(); } } Is Much easier to read than the following. if(0 == i){ if(1 == j){ doFoo(); } }
Unix uses byte strings to represent paths for all its file APIs. The operating system generally doesn't care about ASCII, UTF-8, etc., though that ultimately depends on the underlying filesystem. Most of the time they're just null-terminated by strings. These days, most file names are encoded using UTF-8, but it's not strictly required. To use `chdir(2)` on a directory like `"Área de Trabalho"`, you must ensure the byte string (`char *`) you pass to `chdir(2)` is exactly the same byte string used when previously creating that directory — same encoding, same normalization, etc. That's the same string you'll get from functions like `readdir(3)`. If you do this, it will work. If you're putting that string directly into your source code, there's a chance your compiler is getting the encoding wrong or otherwise damaging your filename. 
APL. It requires Greek symbols to write, so you can get an idea why it didn't set the world on fire. IBM was big on APL for a long time. APL was briefly fashionable in the late 1970s, such that the Space Cadet keyboards have the Greek symbology and Microsoft or Bill Gates expressed major interest in doing an APL toolchain around that time. 
With 8859 characters, it could be "\\xC1rea de Trabalho".
This is not what I'm talking about. I'm not talking about formatting of the code. This is bad: if (x == y) return true; return false; This is worse: if (x == y) return true; else return false; Good code is: return x == y; Also your code would be cleaner if you did: if (0 == i &amp;&amp; 1 == j) doFoo();
Unfortunately, proper use of `fgets` is sufficiently painful that one might as well just write a length-limited `gets`-style function based on `getchar()`. 
Compilers can already do that without the explicit scopes. It’s called liveness analysis.
Any program that consists of [a C wrapper that promptly deserializes its most recent Lisp persistent image](https://lwn.net/Articles/707615/), exists in a quantum superposition of existentiality, I agree. 
Simple. Use COS, the C Object System. See https://github.com/CObjectSystem/COS
Thanks. :) Is there one standard way to treat these strings before sending them as arguments to chdir ?
&gt; Could I get a better description on how to use it? Yes definitely. I would recommend searching the exact terms "implement redirection using dup2 site:\*.edu" to get some sample implementations. &gt; Is it possible to adapt the pipe redirection in that tutorial to all redirections? Yes it is, but you would be better off using resources from your school or some other school regarding this. &amp;#x200B; Personally, I used "Computer Systems a programmer's perspective" when I was studying about shells and redirection. It might be useful to you as well. [CMU has a course for which the book had been written](http://www.cs.cmu.edu/~./213/) (if I remember correctly). One of the labs in the course is a Shell lab. 
I'm about to jump into this, but to parallel-path, please specify a few details about the environment that may or may not be applicable. What OS/kernel version? Are you running in a VM? How many CPUs/cores does the machine have? What compiler are you using (and what are the arguments?) I think I might see some hints as to what's going on, but the above info is good to have anyway.
Thanks :] I think it'll work now with the suggestion you guys gave me.
You're just advocating Allman style over OTBS or KNF, which is an ancient debate. And OTBJ, KNF, K&amp;R put a space before the opening paren except in a function call, and a space before the opening brace always. 
Okay -- here's (one) problem.... This part of `popPushThreads` doesn't do what you think it does: //Pop all numbers, but only under the condition that we can currently pop (threads take turns popping so we don't pop an empty stack) pthread_mutex_lock(&amp;pop_mutex); for (i=0; i&lt;(z*numSize); i++){ if (top==NULL){ break; } Pop(); } pthread_mutex_unlock(&amp;pop_mutex); This doesn't "take turns popping" -- this `pop_mutex` blocks the critical region that loops `z * numSize` times. In other words, a single thread is going to block for `z * numSize` iterations. Instead, you need your critical region to *only* block the `Pop()` call... On top of that, you want your threads should be hungry as fuck saying "GIVE ME MOAR THINGS" -- rather than "Please, sir, I'd like `x` things." Why not toss your pop in a `while(1)` loop rather than a `for` loop? As long as there's something available, you want your thread to grab it. When there's nothing left for a thread, it can break/return/whatever.
https://en.wikipedia.org/wiki/AVL_tree
return (x==y) is not nearly as easy to read, both of your first two examples are terrible because they contain early outs. Your "good example" is only good if you do not want to be able to step in and actually evaluate what x and y are. Your example of cleaning up my code would not pass muster in anything that is critical. No code reviewer would allow that through. I was using them as an example of indentation of course converting it to one conditional would be better if that was all the code that was in the block. However; I was attempting to show you how today's indentation rules are not necessarily better than the ones that were favored 20 years ago. 
I'm not sure offhand the best ways to explicitly define character encoding, especially across platforms. You need to diagnose the problem by comparing the byte-strings you're comparing and seeing why they're not identical. You should be using [UTF-8 everywhere](http://utf8everywhere.org/) unless you have specific reasons to be using something else. If you use something else, make sure your comments and docs reflect the reasoning! My first guess was a normalization problem -- same encoding, seemingly the same graphemes, different bytes. But it could also be an encoding problem: filesystem using bytes in one encoding, your source code or inoput using a different encoding. You'll want to debug the exact byte string. 
I have access to a cluster that gives me access to basically a lot of cpus/cores. But we have specific test cases to follow such as 100 iterations with 5, 10, 20, 40, 50, 100 threads. 25 threads with 10, 25, 50, 100, 150, 200 iterations, and 10/20, 20/40, 30/60, 40/100, 50/150, and 100/200 threads/iterations.
First, pre-planning. Each of these steps is much easier if you're cool with sketching out the structures and working through the operations on paper. Next start to think about what you want to build and how you're going to test what you've built. You do not need to test the entire thing at once, nor do your tests need to resemble the actual input -- build a bit, build a purpose-defined test driver, test a little. Repeat. Here's a way to start thinking about the phases of the build: Start by just building a tree. A tree is really just a (root) node that has pointers to two nodes as it's members. Get this to work in a trivial context so you're comfortable with pointer manipulation. Next, turn it into a binary search tree. A binary search tree has certain properties that dictate how new nodes get added to it. Specifically, they're set up so that for any given node, "smaller" items get put on the left branch and "bigger" items get put on the right branch. You'll (most likely) need to write a recursive function to handle this. Note that "smaller" and "bigger" don't necessarily refer to numbers -- it can be any property, as long as you have a consistent manner of comparing entities. (Some type of purpose-built compare function? Or just strcmp if you're just doing a lexicographic sort) Next, turn your binary search tree into an AVL tree by writing functions that rotate the nodes as necessary to settle imbalances, as well as a function to *detect* imbalances. Hint: you have 4 types of rotations to account for.
This is not even close to my point. I'm not talking about the way you format code. Formatting is details and I don't care. What is important is nesting and indentation of the code. It is unimportant where you put curly braces or if you put them at all. The structure is important. The idea is that you want to avoid nested scopes and your code shouldn't go too far to right. So \`return x == y\` is nicer than \`if (...) {..} else {..}\` because it expresses the idea in single line and doesn't introduce new scope and indentation and other noise. 
There are only 2 rules in the sidebar for this subreddit. Please read those. I think you are breaking both of them.
&gt; both of your first two examples are terrible because they contain early outs. I never understood the argument against an early exit. I've determined my return value, there's nothing left to do. Get out. The only other options I see are creating unnecessary variables, possibly passing through additional evaluations that don't need to be evaluated, or using `goto` to jump to the exit at the end of the call.
Don't post screenshots, provide actual code. But I think I can answer your question anyway. String literals like `"Hello, World"` have the type `const char*`. The string itself is stored somewhere in memory, and you're provided with a pointer to the start of this string. The language also dictates that the string itself *cannot be modified.* You can't change the `'H'` to `'B'`, for example. One reason why is the string might actually be stored in read-only memory, so trying to modify it causes what we call "Undefined Behavior" -- it might actually change the string, or it might not, or it might crash your program, or something else. All that's to say, string literals are `const char*`. However, for historical reasons (C didn't originally have `const`), this hasn't always been an error. The language allowed you to do this, but it's a warning and the practice is now deprecated. So, how do you solve this? Well, it depends. The easiest thing to do is add `const` where you might need it. Or change the value to an array instead of a pointer. Or use a more powerful and appropriate string type (like `std::string` or `std::string_view`).
So let's say that I'm building a binary search tree out of nodes that store a bunch of data such as the title, the year it was released, genre, running time, etc. Could I just arbitrarily pick which of those values I want to use as the comparison for all of the nodes? Like if I wanted to use alphabetical order as my method of storing these nodes into the tree, is that fine to do?
Meh, I know what you meant, however your ability to convey your original nesting, and scope only matter if you allow yourself to declare variables within inner scope which again wouldn't pass muster in anything critical. All stack variables should be function scope and all static variables should be file scope. If you do break that rule then no two function scope static variables should be named the same within the file. 
Why not just use cd from the GNU coreutils?
I don't see why not.... The real question comes down to efficiency in specialized traversals -- ie. if you know that you're going to eventually sort alphabetically, a traversal on a particular branch of the tree would be more efficient than trying to pluck nodes from specific places. What about the use-case in which there are two movies with the same name? Maybe your comparison function uses additional parameters as a tiebreaker. Here's a mindfuck (that's more than likely outside of the scope of this assignment) -- what if you make a generic tree that takes a function pointer to a purpose-defined compare function? If you build your structure that way, you can write an add function that actually loads up **multiple** trees that all point to the same data values, so you can do an efficient chronological search as well. When it comes down to it, think about what the benefit of an AVL tree is, and how you can build for that benefit. If you just need a lookup database (without sort) maybe a hashtable is more efficient. Ie amortized O(1) put/get/contains rather than O(log(n)) depending on how you structure it) At the end of the day -- you have certain requirements and constraints... Use what you've (presumably) learned about data structures and algorithm analysis to best design within those constraints to best accomplish your requirements.
Was going to downvote for brevity. Thought about it.... Double-checked the title.... Instead, upvoted for brevity. Nice.
For a trivial (yet textbook) example of a function that takes a function pointer, read the man pages about `qsort`
What do you mean? This is about a function in C?
Thanks for the pointer, I will look into that!
I didn't even think of that. I'll see how if I can get a basic one working.
So according to [this](https://en.cppreference.com/w/c/language/operator_precedence), there are 49 operators in total. Only 13 fall into the arithmetic category, far from "around 45".
1. getchar() returns an int, not a char. 2. Are you \*sure\* something isn't consuming an input before the newline, leaving getchar() to consume and print the newline? Mixing getchar() and scanf() usage is notorious for this.
I'm sure. I used usleep before calling getchar() to make sure.
Does the following minimal program exhibit this problem for you? It works as expected for me: &amp;#x200B; #include &lt;stdio.h&gt; int main() { char ch = getchar(); printf("You entered: %c", ch); }
Clear the buffer before getchar, you might be getting something stuck from another input there or something similar.
This worked. Thanks.
You are not doing a print after your scanf
No worries mate, it's one of the usual bugs that drive you crazy when you start working with C, afterwards you start anticipating them more actively. 
Don't you need an additional printf statement to print the individual values?
goto is acceptable when backing your way out after an initialization failure, but it is not MISRA 2004 compliant therefore it is not allowed in our devices. Early exits are not MISRA 2004 compliant. Both are bad because they almost always lead to spaghetti code. When you work on devices that will be maintained by someone else. You try to write code that can be read by a 5th grader. I tend to develop for companies that hire me to come in design a device then I leave and give them the code. Their existing engineers will maintain it for years. You have to make it so that some other poor person will be able to pick your code up and be able to clearly see what your intent was, exactly what each function does and how it can be tested. If a function has a modified cyclomatic complexity above like 17 then you probably need to refactor or break that function up. That is a should not a shall, i believe for our coding standard it changes to a shall at 34. Just remember code is like a book, it is designed to be read by alot of people. 
Check your values with printf, scanf should work fine in this 
This is a friend of mine's post, he figured it out. I just posted that comment to mess with him :P
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
ok, thank you!
I added the printf, it still hangs. Oddly, when it hangs if I type any digit it continues the program. 
What is your input?
You are only reading in 4 inputs. Github's is reading in 5?
I’ll look into this but I think my reasoning is that in theory each thread should be pushing and popping x amount of times. (Rather than the popping being sporadic). 
sleeping won't clear the keyboard buffer.
? I would use readline and FFI.
The answer is from volume 2, I'm working from both books, sort of
Ah so what is your input? &amp;#x200B;
my input would be something like 0-123-45678-9
I misunderstood the question.
I haven't tried it, but I would suggest removing the \\n from the scanf statement because it might be ignoring the newline after the input
Now I've tried it. It fixes it.
1. The value of `temp` would be the resized memory block that was pointed to by `rainfallData_File`. 2. `rainFallInput_File` is still pointing to the original memory block I believe? And `temp` is pointing to the new memory block, resized 3. `free(temp)` removes the pointer to the memory and resets the memory for use by another program.
Instead of: scanf("%d -%d -%d -%d\n", &amp;lang, &amp;pub, &amp;book, &amp;check); Try this: scanf("%d -%d -%d -%d", &amp;lang, &amp;pub, &amp;book, &amp;check);
If it's printing a newline, it's because that's what you left for getchar to grab. Might want a more complete example for help.
I don't want to tell you that you can't use this solution, but how will flushing each time effect the general usability and execution speed of the function? I wrote a lexer system in C and didn't have that issue because I structured it around how functions like getchar work.
that worked!
Awesome! I've never used scanf, but it looked like a thing that could be the problem.
You should read that link. The "thread safe" actions are on the operations that do the linking/unlinking of the push/pop. What you've implemented is a global lock and ordinary operations that link and unlink. With "thread safe" operations you often get to check if you were successful in doing the operation you wanted. If you weren't successful, then another thread got in ahead of you and did the link. So now there is a new top and another place to start all over again to attempt the linking.
This isn't particularly important for this program. It's just to test functions.
The book uses it at the beginning under the pretext that at some point you'll stop using it because it's tricky. like easy but wonky.
Respectfully, your theory is bupkis. I mean yes -- you *can* code it to neatly give every thread the same number of Pops (even though that's still technically not what you're doing in the code above). But that's not going to be more efficient. In a perfect world -- yes, everything will be fair and even. This is not a perfect world. This is the ugly face of synchronization, and you don't build to support a magical, logical, fair scheduling algorithm. In the dark arts of synchronization, you *assume* an adversarial scheduler, and then you build to protect yourself against it. As programmers, we like to think of the code on our screen as neat-one-by-one instructions. It's not that simple. Threads are scheduled by the operating system and executed seemingly at random. You can not assume that threads are executed in any particular order (unless you explicitly code a locking mechanism that forces them into doing so), and you can not assume that they execute at the same speed.... And this is why we use a mutex. The mutex is used for *mut*ual *ex*clusion. It ensures that only one thread can modify your data structure at a time, because you don't want threads to overlap their pops. (If they do, the same item could be returned multiple times, or you could pop a null reference etc.) Again, this is not a "fair" system. As the developer, in this case coding for speed, do you really care about *which* thread handles the request? No -- it doesn't matter to you. You just just care that it gets handled quickly by something that's ready to handle it in whatever order it's supposed to come off the stack. Anyways -- that's really besides the point. The problem right now is that your code serializes. You run (z*numSize) Pops (in a row) on thread_A, then you run (z*numSize) Pops (in a row) on thread_B, then you run (z*numSize) Pops (in a row) on thread_C and so on. It's as if you were just running every single pop on the exact same thread. Time-wise, I actually doubt that you're going to see any type of substantial improvements to overall runtime, as long as the only thing you're doing with the stack is popping it. One last point -- as you're really not doing anything with the value that you've popped (ie. your non-multithreaded version is just popping), if anything your runtime may actually be a bit *longer* in the multi-threaded mutex-locked version.. as you're adding a bit of overhead to the entire operation...
I don't see why execution speed would matter because user input is orders of magnitude slower than flushing a buffer
R/cpp was a better fit... 
remove the '\\n' in your scanf()
Oh man you just gave me a new life goal. 
Same. I just enjoy it. I'd use and learn whatever language a job required of me but I really like writing C code for my own stuff. 
I am not saying nesting is forbidden but you should find a way to nest less. For example if you put the entire function body in an if statement it is cleaner to reverse the condition and just early exit the function. This makes for a clearer intent and encapsulates the failure domain of that function in single statement at the beginning. It represents a corner case accurately and shows how flow might go but the main context is still the rest of the body rather than a condition. Also global and static state should be forbidden.
time to read unformatted code &gt; time to format it &amp;#x200B; Here's a prototype: #include &lt;stdio.h&gt; void x(double *); int main() { double wave = 1; // works as long as x() is the first line in your while() while (wave) { // means while (wave != 0) x(&amp;wave); // you are able to change wave directly by passing an adress to a pointer printf("%lf\n", wave); } return 0; } void // no need for a return value if you pass an address x(double *ptr) { scanf("%lf", ptr); }
Try this, pictures are even worse: [https://pastebin.com/](https://pastebin.com/)
1. `temp` contains the address of the resized block. 2. I said *after the assignment*. 3. The pointer to *which* memory?
1. &amp;#x200B; 2. `temp` would contain the address of the new block, as stated above, and I am unsure of what `rainfallData_File` would be. Is the address of the original block lost during a `realloc()` call? If that is the case, `rainfallData_File` would be `NULL`. I haven't been able to find any resources on what happens to the original address. 3. To the `temp` address and memory.
You need to watch [this video](https://youtu.be/t5NszbIerYc) and then go through your code and my questions again.
Use puts instead printf where you're prompting for the ISBN number, most likely it gets optimised but no reason not to be explicit.
I just went back through the video and I understand where I went wrong with the `temp` pointer. I equating the new block of memory, `temp`, to the new one `rainfallData_File`, and then I was removing the pointer to the block of memory that both `temp` and `rainfallData_File` pointed to. I rewrote the program so that it now reliably works, and I will work on the redundancy of the code tomorrow. Currently input works for all sizes of input, as well as all sizes of `EXPECTED_RAINFALL_ELEMENTS`. Thanks for the help. &amp;#x200B; [https://github.com/BamSonnell/Water-System-Model/blob/New-Version/Source.c](https://github.com/BamSonnell/Water-System-Model/blob/New-Version/Source.c)
Nothing wrong with that then.
You should definitely read "The C programming language 2nd edition" written by the creators of C. This will enlighten you.
I have heard it is basically the C bible. Only problem is everywhere I have looked it’s very expensive ... any clue where to find it for cheap? (I am in canada just a heads up for shipping reasons) 
I hate myself to say this. But I downloaded a pirated version :( I am poor af and can't afford to buy it right now.
Work your way through K&amp;R, then eventually (once you basically know C cold) pick up Advanced Programming in the Unix Environment.
I think it is good practice, because it limits the scope of variables declared inside. I do this quite often. The one thing I do different is move variable declarations to the top of the scope to make things more clear.
Look for the International version on Ebay. Same book with a green cover.
Ebay, you can get it for $15-20 used.
You should talk to the libsoundio devs. Most people that make libraries are very happy for tutorials or other documentation to link to Consider crossposting to r/CLibs 
Ok, will do! Thanks for letting me know
Encodings are hard. The problem is that `chdir()` doesn't take the abstract word "föö" (just foo with non-ASCII chars as example) as argument but a pointer to an array of bytes terminated by a NUL byte. In eg. ISO-8851-1 (latin1) this would be the bytes 0x66, 0xf6, 0xf6 0x00. In UTF-8 it's the bytes 0x66, 0xc3, 0xb6, 0xc3, 0xb6, 0x00, where 0xc3, 0xb6 represent the ö. So now we need to understand what encoding is used internally or what should be passed to the chdir() function. This is platform-specific. On Windows this would be UCS-2 (use the TEXT-Macro everywhere and curse Microsoft). On Linux it's usually UTF-8. So one way would be doing this: // föö in UTF-8 char dir[] = { 0x66, 0xc3, 0xb6, 0xc3, 0xb6, 0x00 }; This is quite unportable and ugly though. If your compiler supports UTF-8 though, you can just initialize with `"föö"` and it will work, if also your code is set up in UTF-8. But the text you write in code is also, obviously in some encoding and it could be different from UTF-8. So the compiler needs to recognize it and know how to encode the letters within the binary. But this decision is done at compile time! So maybe, the compiler runs on some platform where it's set up to produce latin1 encodings but the platform wants UTF-8 encoded strings. You can also switch between encodings using `setlocale()` and using `wchar_t`, but that API is horribly broken and doesn't work well with UTF-8.
If you're really into C, you should definitely also start using linux. Tools, toolchain, everything is there available and at no cost. Most of the stuff is also written in C and like suggested the Stephen's books on advanced unix programming and network programming are brilliant resources to go through next. Just out of curiosity, why C? Don't get me wrong, I'm an old timer that grew up with it and it's still my first real love, but it's not exactly contemporary and it's job scene certainly has limits. While it's a great language, there are many others nowadays, too. I write Clojure and JavaScript nowadays for a living.
21st century C by Ben Klemens. Really enjoyed it. ;)
Maybe try implementing something simple using your new found pointer and memory management tools? A simple (crc32 hash algorithm, simple linked list for collisions) hash table can be implemented in a few evenings. Gives you an option to enhance the implementation if that is too easy, the Wikipedia page has a lot of details on different approaches.