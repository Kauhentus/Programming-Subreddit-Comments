They are identical. Within the function, the type of the `argv` protocol is `char **`, _even if_ you use square brackets in its declaration. From [n1570](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) §6.7.6.3 paragraph 7: &gt; A declaration of a parameter as "array of _type_" shall be adjusted to "qualified pointer to _type_", where the type qualifiers (if any) are those specified within the `[` and `]` of the array type derivation.
They're identical in every instance of usage. Technically speaking, `T []` = `T *const`.
That's not true. int main(int argc, char *argv[]) { argv = 0; } is a perfectly valid program. You may be thinking of something like: int f(void) { char a[] = "abc"; a = 0; } That _is_ invalid, not because `a` is `const`, but because it's not valid to assign to an expression of array type.
That was my point, actually. I just didn't know a way of saying it better.
Even your edit isn't correct. This is also a perfectly valid program: int main(int argc, char *argv[]) { if (argc &gt; 0) argv[0] = 0; } §5.1.2.2.1 makes this clear: &gt; The parameters `argc` and `argv` and the strings pointed to by the `argv` array shall be modifiable by the program, and retain their last-stored values between program startup and program termination. 
Also, don't overlook the humble alarm(seconds). Especially if it's fine if your program just terminates on a timeout. To timeout a read of a terminal device, you could also use termios: see VMIN and VTIME tcsetattr settings. "At least this many characters, unless it takes too much time" or something like that. And, for sockets, setsockopt SO\_TIMEOUT is an option, nice one actually.
Well... if you think that a node has the ownership over next and previous you deserve a memory leak!
&amp;x gives you address of x (pointer to it). Scanf takes a pointer and stores input to address it points to, that is to x.
The example is intentionally incorrect to demonstrate this problem, but there exist structures where it is impossible to define ownerships in a way that reference cycles are eliminated.
Because when you are calling the `einlesen()` function, you are passing __the pointers__ to `x` and `n` into it as parameters. Within the function they already have the type `double *` (pointer to double) and therefore don't need to be dereferenced again.
&gt; Or is the x and n like &amp;x and &amp;n because of my parameters in einlesen(&amp;x, &amp;n); This is the answer. The &amp; operator gets the addresses of x and n, which is the same as a pointer to the location in memory of x and n. The parameters to einlesen are *passed by reference*. That expression might help you find more information on how this works.
no. because there isn't a difference
Rename `x` and `n` in `einlesen()` to `xp` and `np` to clearly show that they are pointers, and you will no longer be confused.
That's the reason why weak_ptr exists, but talking about hidden vulnerabilities seems too much IMHO. 
Weak pointers are also mentioned in the article, but there are scenarios when they cannot provide an adequate solution. For example, if you have a map where the values are variants including the type of the map itself, then you cannot use weak pointers to refer to the values, because it is absolutely possible for the variant to explicitly own a map.
ug. medium
ugh, reddit.
[Reddit for C++](https://www.reddit.com/r/cpp/) I'm redirecting you here because the subreddit is specifically for C, and C++ is pretty different from C in many ways. It's not as disparate as Java and Javascript, though. &amp;#x200B; If you do want C help in particular, this is the place to be.
Thanks. Didnt know they were that different. My bad
NP, lots of times you'll see the two grouped as C/C++, especially in job openings written up by (most likely) non-technical people. however, most people who work with one or both of them are pretty insistent they are different
The article is wrong for most implementations, but you should stop thinking in terms of stack and heap and worry about what goes where. All that matters is lifetime and scope.
You'll probably have more applicable information if you weren't reading C# articles thinking their refer to C... Apart from that, your understanding is basically correct.
The interesting bit is you're allowed to have type qualifiers inside the brackets of array parameters, and the qualifiers apply to the pointer. A weird design decision, if you ask me. So we may write the prototype of `strcpy` as follows: char *strcpy(char dest[restrict static 1], const char src[restrict static 1]);
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
The `static 1` might be allowable under an obtuse interpretation of the Standard, but unless an implementation of `strcpy` is being deliberately obtuse, it will process a request to transfer zero bytes to/from a "just past" pointer as anything other than a no-op--something that `static 1` qualifier would indicate is not necessary. 
&gt; The article is wrong for most implementations The article is about C#. I am not sure how wrong it is regarding to C#, but I don't think we care at all about its correctness in C...
That article is incorrect. As a rule of thumb, most of these online tutorials are wrong in one fundamental aspect or another. I strongly recommend you to avoid them as a source of information. Note that C11 introduced a fourth storage class: thread-local variables are like static variables, except each thread has its own copy.
 `static 1` tells the compiler (and the reader) that `dest`/`src` should provide at least space for 1 element, because they're strings and the null terminator is required. In essence it disallows NULL arguments and `clang` will actually inform you of this: `warning: null passed to a callee that requires a non-null argument [-Wnonnull]` (`gcc` doesn't seem to, so `clang` is better in this respect). It's good to inform the reader and the compiler that your function doesn't accept NULL.
(Maybe I should stop answering in that thread) The article is NOT ABOUT C.
I'm guessing you don't work in embedded...
I'm guessing you don't work in any field that requires a minimum of reading comprehension... 
&gt; a request to transfer zero bytes There is no way to request `strcpy()` to copy zero bytes -- it always copies the terminating NUL.
This is an obvious repost and it should be removed. Also, can we please stop with C tutorial articles. Most of us here know these concepts. They should be posted on r/learnprogramming or a specific sub for learning C.
Oops... I confused that with operations that take a length parameter. I've read some people arguing that a conforming `memcpy` may behave in arbitrary fashion if given pointers that don't identify at least one byte of storage, even if the number of bytes to copy is specified as zero. Such arguments are correct, but they irritate me because they ignore one of the most important characteristics of the Standard: it makes no effort to define everything necessary to make something a quality implementation suitable for any particular purpose, nor even any purpose whatsoever. Consequently, the fact that the Standard does not require implementations to process some piece of code in a useful fashion implies nothing about whether an implementation can truthfully claim to be suitable for any particular purpose without doing so. There are many situations where the authors of the Standard almost certainly expected that implementations would process certain constructs a certain way *absent a good reason to do otherwise*, and may not have known of any reasons why any implementations would do otherwise, but didn't particularly want to pass judgment on whether any such reasons might exist. I'll agree that for `strcpy`, the `static` qualifier would make sense, but I so seldom use unbounded string operations with source operands other than string literals (which would allow smart compilers to perform stronger validation of the destination even without a `static` qualifier) that I'd neglected to consider that for some narrow cases the qualifier could enable useful inferences or diagnostics that would not otherwise be possible. 
`static` here is not a (type) qualifier (and when it's used in the usual manner it is a storage class specifier). It's the `static` keyword being repurposed for another job, i don't know if this syntactic construct even has a name. The standard didn't bother to name it. Here's the above paragraph in full: &gt; A declaration of a parameter as “array of type ” shall be adjusted to “qualified pointer to type ”, &gt; where the type qualifiers (if any) are those specified within the [ and ] of the array type derivation. &gt; If the keyword static also appears within the [ and ] of the array type derivation, then for each call to &gt; the function, the value of the corresponding actual argument shall provide access to the first element &gt; of an array with at least as many elements as specified by the size expression. To be clear: this is not an implementation coincidence, it's defined by the standard.
That has long struck me as a missed opportunity to offer a meaningful semantic difference that could have facilitated vectorization. I doubt that very many functions would accept two or more arguments using `[]` syntax in cases where the arguments could alias *without being equal*, so I doubt much code would have been broken by saying that void test(float a[], float b[]); and void test(float *a, float *b); would be identical *except* that the former would invite a compiler to assume that `a[i]` and `b[j]` will not alias for any `i!=j`. Note that this is a weaker assumption than would be permitted using `restrict` [which would invite a compiler to assume they won't alias even if `i==j`] but would allow a compiler to assume that an access to `a[i]` in one iteration of a loop will not interact with an access to `b[i]` in another.
Try /r/csharp, OP.
And here it is: https://old.reddit.com/r/learnc/
Function calling convention and the stack layout are two things that any introductory asm class teach you. The parts of the article that have to do with C syntax are well known to any newbie: you can't return arrays from functions, you can't define arrays of unknown size, pointer != array, comparing string literals is comparing pointers etc... The explanation he gives for these limitations is bad. These limitations don't have anything to do with x86 ABI. It's simply because the standard say so. &gt; Question 6: Why can’t an array be used as a function return value? &gt; [...] &gt; Return values are placed on the stack, just like arguments, and they have to have a &gt; fixed size, so we can’t just pass an array, we’d have to convert the array to a pointer. ??? Explain arrays wrapped in structs then. Structs are returned by copy, so arrays could as well. There's no reason why you couldn't implement this in a non-standard C compiler. &gt; Question 4: why can’t we declare an array of unknown size inside a function without initializing it, like so: int arr[];? &gt; Answer: because an automatic variable must have a known size when it’s declared. When the code is &gt; compiled, there are no symbolic names for variables, and all values are rather stored and retrieved by &gt; offsets from the beginning or end of the stack frame. If we don’t know a variable’s size, we don’t know &gt; offsets for variables following it. `there are no symbolic names for variables,`: it has nothing to do with symbolic names. Then VLAs couldn't exist too. First of all we haven't decided what a `int arr[];` definition should mean, we've given it no semantics. Let's assume that `int arr[]` means a resizable vector on stack, so basically a resizable VLA. Do you see how the stack growing in one direction makes this hard to implement efficiently? You'd basically have to move everything above it on the stack further up when you decide to increase it's capacity. Making working with them to have a O(n^2) complexity. So it's not impossible to implement, it just results in a very inefficient implementation. 
Care to explain your reasoning, then?
&gt; Stack is used for static memory allocation Wrong for both C and C#. Also missing a semicolon on the free().
The Standard plays loosy-goosy with terms like "qualifier" and "storage class", and a lot of other terms as well, such as "object", "lvalue", and "evaluate". Given something like `int i=2; typedef struct {int x,y[8];} foo; foo *p = calloc(sizeof (foo), 10); int *p = 3+&amp;foo[i++].y;`, what is "done" with the lvalue `foo[i++]`? Would a `foo` object exist anywhere? How would it be created, and what would control its lifetime? While `static` may typically be used as a storage class, its meaning in an array-type argument is closer to that of a qualifier than to anything else, even though the circumstances where it can be used with such meaning are more limited than for other qualifiers. 
Ugh, complaining.
&gt; foo *p = calloc(sizeof(foo), 10); &gt; int *p = 3 + &amp;foo[i++].y; You have a naming collision there. But i get your point. `3 + &amp;foo[i++].y` is UB: any object is considered an array object of 1 element. You're only allowed to point 1 element past the last element of the array, you're pointing 3. So it is undefined behavior, simple as that. `1 + &amp;foo[i++].y` would've been correct though. &gt; Would a foo object exist anywhere? How would it be created, and what would control its &gt; lifetime? Who cares? The point of not making these assumptions is so that the compile can optimize it to the fullest potential. Although in this case because of `calloc`, a function that has major side effects, it is not possible to optimize `foo` out.
I dont know how to implement it, but perhaps try to run the wood function on a seperate thread
Would probably be best to use some kind of software interrupt that triggers every 2 seconds, and have that interrupt call a functions that increments the wood variable by two. [https://en.wikipedia.org/wiki/Interrupt](https://en.wikipedia.org/wiki/Interrupt).
**Interrupt** In system programming, an interrupt is a signal to the processor emitted by hardware or software indicating an event that needs immediate attention. An interrupt alerts the processor to a high-priority condition requiring the interruption of the current code the processor is executing. The processor responds by suspending its current activities, saving its state, and executing a function called an interrupt handler (or an interrupt service routine, ISR) to deal with the event. This interruption is temporary, and, after the interrupt handler finishes, the processor resumes normal activities. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
`1u` isn't a variable. It is a number - one. The `u` suffix means it will be treated as a unsigned integer. `1` , without a suffix, is a signed integer literal with a value of one.
`1u` is a literal, not a variable. You're probably familiar with using just `1` as a literal in your code. By default, this is a literal with type `int`. But if you want a literal with some other type, you can use a suffix to change it. `u` means `unsigned`.
It denotes the 1 as unsigned integer (also see google: [1u in C](https://www.google.com/search?q=1u+in+C&amp;hl=de)) An advantage of this is unwanted integer promotions are avoided as well as the fact that shifting signed integers is implementation defined and might not behave the same on every hardware.
You might want to use `std::thread`
Correct the code to `int i=2; typedef struct {int x,y[8];} foo; foo *p = calloc(sizeof (foo), 10); int *q = 3+p[i++].y;`. The purpose of `calloc` is to create a region of storage that can be used as though it holds an array of objects whose size need not be known until runtime. In this case, the storage should be usable as a `foo[10]`. Indexing two elements into it should thus be defined behavior. Since `p[2].y` is an `int[8]`, indexing three into that should likewise be defined. To be sure, the Standard doesn't explicitly say that the storage returned from `calloc` may be used as an array, but that's because the usage was so thoroughly established that the authors expected quality implementations to recognize it, whether or not they were required to do so. Returning to the original question, suppose the call to `malloc` were replaced by `foo fooArr[10]; foo *p=fooArr;` I think it's pretty clear what objects would exist then, but the question would still remain about what is "done" with the lvalue `p[i++]` when evaluating the enclosing expression `3+p[i++].y`. The value of `p[2]` wouldn't be evaluated, but `i++` would be, so what's done with the expression as a whole? 
Notice the words “for most implementations”. Emphasis on “most”. 
This is C, not C++.
In C? 
The old-school method for doing this kind of thing is to register a signal handler for `SIGALRM` and then set yourself an alarm with `alarm(2)`. This causes the signal handler you set up to be called every two seconds. Note that in the signal handler, you need to reestablish the signal handler every time it is called as it's undefined whether the handler stays put.
The Right Way to go about this in a game is to have the game driven by an [event queue](http://gameprogrammingpatterns.com/event-queue.html). The queue is actually a priority queue, with events ordered by time. You can enqueue arbitrary future events, and these events are popped off in order of their occurrence. For this wood event, you queue up a wood-adding event 10 seconds in the future. When this even pops off the queue, you increment the wood counter and add a new wood-adding event to the queue another 10 seconds into the future. That's pretty complicated and requires orienting your entire engine around it. Here's a simpler approach: #define DELAY 10 #define AMOUNT 2 static int wood; static time_t start; int init_wood(int init) { wood = init; start = time(0); } int get_wood_count(void) { return wood + (time(0) - start) / DELAY * AMOUNT; } int change_wood(int delta) { wood += delta; } This just computes an updated value when you look at it. Don't use a dedicated thread for this. 
Thanks for the feedback! I'll look in more detail and see whether I should correct any mistakes in the article. It also probably isn't geared towards people who are well versed in C and computer architecture.
you can store the time when you start in a variable. then, any time you need the value of wood, take the current time, subtract the start time to get the difference in seconds, and multiply by 2.
https://computing.llnl.gov/tutorials/pthreads/ If it's a Unix/Linux type environment you can use a posix thread. Increments like what you are doing are atomic so you wouldn't need any complicated mutex or semophore locking logic.
Thanks for the suggestion! Would you be so kind and explain to me what the "obvious repost" comment is about? I'm new to reddit - is it against convention to post the same link in two subreddits?
Try /r/csharp/.
Oh whoops, sorry thought this was cppquestions my bad
Well, the first thing to do is post in the right sub. /r/csharp is for C#.
Shit sorry it's my first time on reddit aha
NP. It happens all the time on /r/c_programming, though more commonly with C++ than with C.
your game loop is like the following while true check_user_input check_timers update_world render end in your check_timers function, you can manage system timers -- events that must happen every x amount of seconds. if (current_time - prev_time &gt; 10seconds) wood+=2; there are no sleeps involved, and the code won't be stuck
Wow, what a garbage article. It's just wrong. It's wrong enough that it's not worth trying to pick out the parts it gets right. When you compile a program, the assembly has three (logical) sections, the .text, .bss, and .data. The .text section contains constants. This data does not change at runtime. The .bss section contains static and global variables. Let's take a moment here. In the assembly generated by the compiler, .bss isn't memory space for these variables, it's just a size variable, *for* the .bss section. When the program loader loads the program into memory, it reads a bunch of runtime data that it uses to initialize an *instance* of that executable. So each instance of your program gets its own block for static and global variables (as well as their own stack and heap). The .text section contains the instructions and inline constant variables. This is also shared by all instances of the program. Each instance of a program has its own stack and heap. And keep in mind this is in terms of Windows and Linux - it doesn't have to be this way. As far as any program is concerned - it has complete domain over the entire address space. In reality, the OS and some clever architectural trickery makes sure that multiple programs map the same address to different locations so they don't collide. It's when you start mucking with unallocated address space that you start shitting on other programs. Stack space is home to local variables and the call stack, so when a function returns, it knows which instruction to return to. You can have pointers and aliases to memory lower in the stack, but not higher, because anything above the top of the stack is uninitialized memory. Typically, stacks grow from low addresses, up. This is merely by convention. Your stack space is limited by the OS and parameters loaded by the program loader - you can configure more stack space at compile/link time if you want, though I don't know what the upper limits are. This is your automatic allocation. The heap can be any address, and typically allocations come from the upper addresses down. Again, by convention. &gt; Stack is used for static memory allocation This *might* be correct, that the bottom of the stack may contain instance information, and the call stack grows on top of that. It doesn't strictly have to be that way, but it's probably what the common program loaders are doing. On the one hand, this may be technically correct, but on the other hand, it might not be conceptually correct, because it's not really like you think of this space as something you're going to pop off the stack at some time - it may not benefit you to think of it this way. &gt; both stored in the computer's RAM . That's basically correct. But not always. Appreciate that our machines are an evolution of the Turing machine. In a proper Turing machine, program and data occupy the same memory space - programs are merely a different type of data, and programs have free reign accessing either at any time. This was quickly recognized as a security flaw, and the Harvard machine was born. Program and data are kept on separate channels (even though both channels go back to system memory on your server or workstation). You see this more with embedded or micro controllers, where you may have one bus leading to RO memory which contains your program and another bus leading to system memory for data. So the program doesn't have to load into RAM, and on many modern machines, especially many of these popular hobby micro controller boards, this isn't the case.
Trying to write to a full filesystem. Hardware problems with the underlying storage device.
If not threads, you can do an event loop: int timeout_ms = 1000; for (;;) { event = WaitForEventWithTimeout(&amp;timeout_ms); switch (event) { case TIMEOUT: wood+=2; timeout = 1000; break; case .... } Now, you have to write the WaitForEventWithTimeout function, that typically would reduce the timeout variable as well, leaving it with the remaining time.
Sorry, this example is in C++ #include &lt;iostream&gt; bool b0 (bool a, bool b) { return a&amp;&amp;!a; } int i0 (int a, int b) { return a&amp;~a; } bool b1 (bool a, bool b) { return a&amp;&amp;b; } int i1 (int a, int b) { return a&amp;b; } bool b2 (bool a, bool b) { return a&amp;&amp;!b; } int i2 (int a, int b) { return a&amp;~b; } bool b3 (bool a, bool b) { return a; } int i3 (int a, int b) { return a; } bool b4 (bool a, bool b) { return !a&amp;&amp;b; } int i4 (int a, int b) { return ~a&amp;b; } bool b5 (bool a, bool b) { return b; } int i5 (int a, int b) { return b; } bool b6 (bool a, bool b) { return a!=b; } int i6 (int a, int b) { return a^b; } bool b7 (bool a, bool b) { return a||b; } int i7 (int a, int b) { return a|b; } bool b8 (bool a, bool b) { return !a&amp;&amp;!b;} int i8 (int a, int b) { return ~a&amp;~b; } bool b9 (bool a, bool b) { return a==b; } int i9 (int a, int b) { return ~a^b; } bool bA (bool a, bool b) { return !b; } int iA (int a, int b) { return ~b; } bool bB (bool a, bool b) { return a||!b; } int iB (int a, int b) { return a|~b; } bool bC (bool a, bool b) { return !a; } int iC (int a, int b) { return ~a; } bool bD (bool a, bool b) { return !a||b; } int iD (int a, int b) { return ~a|b; } bool bE (bool a, bool b) { return !a||!b;} int iE (int a, int b) { return ~a|~b; } bool bF (bool a, bool b) { return a||!a; } int iF (int a, int b) { return a|~a; } bool (* const bx[]) (bool, bool) = { b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, bA, bB, bC, bD, bE, bF }; int (* const ix[]) (int, int) = { i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, iA, iB, iC, iD, iE, iF }; int main (void) { (std::cout &lt;&lt; "A 0 0 1 1 3\nB 0 1 0 1 5\n\n" &lt;&lt; std::hex).setf(std::ios::uppercase); for (int x = 0; x != 16; ++ x) { std::cout &lt;&lt; x &lt;&lt; " "; for (int a = 0; a != 2; ++ a) for (int b = 0; b != 2; ++ b) std::cout &lt;&lt; bx[x](a, b) &lt;&lt; " "; std::cout &lt;&lt; (ix[x](3, 5) &amp; 0XF) &lt;&lt; "\n"; } } // again sorry for the C++, it was originally an assignment for a C++ class // but I thought it might be enlightening to dissect how it works. 
&gt; moved/deleted during a read or write That is generally not an error, depends on the operating system though. On POSIX systems, the possible errors for reading and writing can be found in [this article](http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html) and [that article](http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html). Implementations of POSIX may define extra errors.
Presumably wood will also be consumed, so this wouldn't work.
you could handle consumption by increasing the start value.
yup i made stuff so that you can use your wood for building, and you can check your amount of wood any time
No threads or interrupts, those wouldn't work well for this situation. (You'd end up with way too many threads or interrupts and you'd have a nightmare coordinating them.) For a simple, first-time game, an event queue is probably a bit much. You probably want just a single thread for everything, especially since this is a text-based game, and do everything in an event loop. I don't know if this is the greatest codebase, but I found it instructive to look through the code of CircleMUD (an old online text-based RPG), which you can find here: [https://github.com/Yuffster/CircleMUD/tree/master/src](https://github.com/Yuffster/CircleMUD/tree/master/src) Start reading in comm.c. It's not a great example of how you'd want to build a game these days, but for me it helped me understand the older, simpler way of doing it.
Better to do "prev\_time += 2 seconds" than "prev\_time = current\_time", otherwise you'll probably get gradually further behind as time goes on.
Since this is a C subreddit and not C++ subreddit. I will suggest you include time.h and use clock().
Windows will not allow you to move or delete an open file. The process that tries to do so gets an error, the process that has the file open is unaffected. In Unix, renaming or deleting a file is usually seen as an operation on the directory, not the file itself, so you won't even notice. If a file is deleted while still open, it will continue to exist until closed. 
Networks file systems have all kinds of fun errors. Sometimes I get stale NFS handles. Sometimes io operation just block for a minute. The home dir disappears entirely for a couple of minutes. Windows user locks file on his end while I have it open in vim. Ahhh, fun times :)
I just used clock() in time.h and used your algorithm and it worked! Thank you
 I just used clock() in time.h and (time end - time start) / 10 \* 2 everytime the person is checking wood and it worked
Corruption of the file or inaccessibility of the media, and any number of hardware I/O errors.
I just used clock() in time.h and used your algorithm and it worked! Thank you #include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; clock_t start_t, end_t; int wood; char chat[10]; void generator(){ end_t=clock(); printf("%d %d\n", start_t, end_t); wood+=(end_t - start_t)/10000*2; if(end_t-start_t&gt;=10000)start_t=clock(); } int main () { start_t=clock(); while(1){ scanf("%s", &amp;chat); if(strcmp(chat, "end")==0){ generator(); printf("%d\n", wood);}} } Everytime you type end, it tells you your wood amount and well the clock times telling you how much time has passed from you last checked. it works like a charm
It's ok to delete a file while a process has it open. The file continues to exist for as long as there are open file descriptors on it. That's why the "delete" function is called unlink(); to remind you that the file still exists until the last link to it goes away. (In fact, here's a trick you can use for temporary files: Open the file for read+write, then delete it immediately. It's there for as long as your program wants to use it, but automatically gets freed once your program exits.) I expect that moving the file is also not an error as long as you move it within the same storage device. The file descriptor references the underlying file, and doesn't care what the file's name(s) are, if any.
`showbits()` does not perform all these steps. Here's what it does in pseudocode: for (i in (number of bits in an int)) { if(bit i is set) putchar('1') else putchar('0') } `x &amp; (1 &lt;&lt; i)` tests if bit `i ` is set by bitwise ANDing the input with a mask where only bit `i` is set. 
&gt; Windows, on the other hand, is quite different. I think it's an error to delete or rename a file that's open. Only if the other processes that opened it did not use `FILE_SHARE_DELETE` sharing.
Thanks for the effort, I guess?
You have stored it. It is stored in the variable a, and the variable test.
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char a[] = "string"; // array a gets the size of "string" + '\0' int test[strlen(a)]; // why not giving it the same size * sizeof(int) as a int i = 0; while (a[i]) { // as long as a[i] is true (!= '\0') test[i] = (int) a[i]; // you need to cast the type to convert it into an int i++; } for (i = 0; a[i]; i++) { // as long as a[i] is true (!= '\0'), i++ /* simple output */ (void) printf("%c\t-&gt;\t%i\n", a[i], test[i]); } return 0; } I think that's what you wanted? The comments should explain everything, if not, just ask :)
i want to store what it prints
how would i store what it prints as in integer
What does it display?
That sound an awful lot like `tr`. You might want to have a look at its [source code](https://github.com/freebsd/freebsd/blob/master/usr.bin/tr/tr.c).
First things first: If you write that string into an int array, it would grow 4 times in size: Most 64bit systems: sizeof(int) = 4 byte sizeof(char) = 1 byte &amp;#x200B; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char a[] = "string"; int i; int size_str = strlen(a); // storing the length of the string a int test[size_str]; // ascii storage /* storing the information */ for (i = 0; i != size_str; i++) test[i] = (int) a[i]; /* output without using a */ for (i = 0; i != size_str; i++) (void) printf("%c\t-&gt;\t%i\n", (char) test[i], test[i]); return 0; } Better? But: Typecasting the string is simpler and you don't have to remember the length as long as the string is terminated by '\\0'. &amp;#x200B;
i just started C, i didn't understand 90% of this xD lol
Storing in a file: #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { char a[] = "string"; int i; FILE *write_to; write_to = fopen(argv[1], "w"); for (i = 0; a[i]; i++) (void) fprintf(write_to, "%c\t-&gt;\t%i\n", a[i], (int) a[i]); fclose(write_to); return 0; } Now, from my point of view: \&gt; cc test.c \&gt; ./test hallo.txt \&gt; cat hallo.txt s -&gt; 115 t -&gt; 116 r -&gt; 114 i -&gt; 105 n -&gt; 110 g -&gt; 103 &amp;#x200B;
There is a program on every unix machine called `tr` short for *translate* which replaces characters: ``` $ echo 'foo.bar' | tr '.' ' ' foo bar ``` Above I gave you the link to the freebsd implementation of tr which is simpler than [gnu (linux)](https://github.com/coreutils/coreutils/blob/master/src/tr.c). Have a look at the code. If you really do not understand it—which is okay as you just started C—read the [pinned post](https://www.reddit.com/r/C_Programming/comments/9l0vuz/asking_for_help_what_to_do_when_your_program/) and update your question accordingly. Otherwise we cannot help you. 
Since `sizeof(foo) &gt; `sizeof(int)`, there is a padding after `x` within the union, which would be zero-initialized. This does not mean that only `foo.y` will be zero-initialized: padding may be actually bigger than `char[100]` due to the union or `x` alignment restrictions.
I feel like there's better ways to help him other than to suggest that the OP decipher a 400 line file, when his problem can easily be done in a mere 10 lines.
&gt; I feel like there's better ways to help him … There is no way to help OP unless they actually say what they have so far and where the trouble lies. Otherwise you are just guessing. See my second post and the linked post.
Also note that because of this uncertainty you should initialize it manually. My personal rule is that if you are unsure and have to look it up, then you need to leave a comment to make it clear for the next time. In this case an initialisation statement will make it clear, there is no downside as the compiler output will be the same.
hint: a[i] is a number that can be also stored as an integer, just use `=`
There is a lot that could go wrong, it is one of those crazy complicated areas that gets worse the deeper you go. I saw this talk live several years ago. In 40 minutes he covers safely saving a file in Linux and MacOS, Windows wouldn't fit in the time. Note that there are several corrections from Linus and Tridge in the audience because even after preparing the talk there were complications he had missed. https://www.youtube.com/watch?v=LMe7hf2G1po
You loop through the string char-by-char until you reach the end '\0', if char[x] equals '.', then set char[x] to ' '
this helped!! thank you. if you dont mind me asking, where / how did you learn C? you have a great knowledge and understanding of the language
Do not spam.
Get em
or you can just update the wood amount before wood consumption happens and then you can check if you have enough wood or not, and then use it and remove the correct amount of wood.
nope this is actually correct because when lets say 100 seconds passed you increase the wood amount and then change prev\_time to 100 so when you subtract the two you get 0
solved it with your algorithm thank you!
I believe the "proper" way to do this is with the \`ipcrm\` command. It probably does the same thing as your solution.
prinf () takes a minimum of 2 arguments. 
What's `selection`? It looks like a `char*` or a `char[]`, but I can't tell. How are you initilizing it and using it before the `printf`?
Thanks for the fast response but I can confirm positively that this is not true. printf("\nInputs:\n\n"); For example works perfectly fine.
Those that use C++ standard library, templates and other C++ - specific stuff
This isn't true. `...` is a varargs argument, which can be 0 or more.
`printf` needs at minimum of 1 argument, the `...` is an optional argument
`printf()` by default writes to a buffered file handle that isn't flushed until `\n` is read. i suspect that the bus error is happened after the `printf()` but before `stdout` is flushed. try: ``` printf("Test\n"); ``` and i bet you'll see the output and i'd wager that the bus error occurs sometime after it.
Selection is in this a char* representing a registry location and is initialized as a command line argument. However the issue isn't with the print statements themselves. They were added to try and track down exactly where in the code the error occurs (aka if I remove both of those statement the error still occurs in that position). The output I get from running is: DEBUG: Length of input string is 10 DEBUG: 0x43c00030 Registry target:0x43c0030 Bus error With the notable missing of the "Test" message. The confusing part is why is the error appearing between the two with nothing else.
Ah I didn't know that little detail. Thank you, you are correct. If I add the \\n I get the error somewhere further down the pipeline. Time to dive back in then!
The problem is that when you're waiting for time to pass, it usually happens that more time passed than you really wanted to wait for. Consider this example. For convenience, we'll say that the times are doubles where 1.0 means 1 second. (Really they would typically be integers with millisecond or greater precision.) void update_wood(double current_time, double prev_time) { if (current_time - prev_time &gt;= 1.0) { wood += 2; prev_time = current_time; } } This works fine if exactly 1 second has passed since the last time that you set prev_time. But let's say that this time, for whatever reason, 1.2 seconds passed. Now current_time-prev_time==1.2, so when you set prev_time=current_time, that was equivalent to setting prev_time+=1.2. So, for this iteration, 1.2 seconds passed, but the next iteration won't come for another full second. We just set all future iterations back by 0.2 second. If this happens many times, it will start to become noticeable that you aren't really accumulating 120 wood per minute as you should be. What happened here is that you ran the next iteration 1 second after the previous one ran. What you wanted to do was run the next iteration 1 second after the previous one was *supposed to* run. Now consider this version: void update_wood(double current_time, double prev_time) { if (current_time - prev_time &gt;= 1.0) { wood += 2; prev_time += 1.0; } } Now, the timer advances exactly 1 second every time, regardless of when update_wood got called previously. Your seconds are timed perfectly, even if the game loop is very inconsistent about timing and hangs frequently. 
Followup: Someone pointed out that printf requires a \n to flush the buffer. Changing the Test debug line to printf("Test\n") revealed that my error was much further down the code chain in *((unsigned *)(ptr + page_offset)) = value; with ptr being a pointer initialized by a mmap. Looks like the registry values in our test code may be higher than what is available in the hardware I'm guessing. Thanks for your help though!
I'm hoping to get some feedback on my first interesting C program. It uses GNU readline to create a read-eval-print loop for arbitrary shell commands. I've tried to write it in a simple, readable style that hopefully is easy to understand for beginners. Thanks!
I too have been won dering this
&gt; GNU readline to create a read-eval-print loop for arbitrary shell commands. So... a shell?
&gt; But it seems the issue is that printf() isn't guaranteed to flush unless there is a newline. And ...? How does this cause a bus error?
&gt; But it seems the issue is that printf() isn't guaranteed to flush unless there is a newline. And ...? How does this cause a bus error?
No, it creates a REPL for commands like git that always require a "prefix", so that instead of: $ git init $ git add . $ git status $ git commit $ git push $ git status ... you can do this: $ repl git git &gt; init git &gt; add . git &gt; status git &gt; commit git &gt; push git &gt; status The program automatically prefixes each command with `git`, so that you don't have to type it.
zeroing the struct sigaction before use would be good.
I watched a very basic guide: [https://www.youtube.com/watch?v=CPjZKsUYSXg](https://www.youtube.com/watch?v=CPjZKsUYSXg) Rest was learning by doing. &amp;#x200B; I use OpenBSD for coding, because there are some very lowlevel features which show you basic mistakes, other plattforms ignore Basic install + ln -s 'A' /etc/malloc.conf And you're ready to go &amp;#x200B; One thing which is also important to learn is readability [https://man.openbsd.org/style](https://man.openbsd.org/style) Just an example &amp;#x200B;
Extra note: you can use `sem_unlink(3)` to remove the semaphore's name while you're still using it. You should probably do that immediately after you no longer need to use sem_open(3)` on that semaphore. Then the semaphore will be automatically cleaned up no matter how your processes exit. 
Actually doesnt do the trick, also ipcs gives me am empty list. Weird
 void func() { int* x = malloc(sizeof(int)); free(x); }
Not quite what you asked, but here's a fun one. This function knows whether or not it was compiled as C or C++: int was_comiled_as_c(void) { auto x = -1u; return x &lt; 0; } 
No functions can be called from C when written in C++ unless they were written with extern “C” due to name mangling
The C standard states that bitwise operations on a negative number, or which would shift a one bit into the sign position of a number, are either undefined or implementation-defined. So the `1 &lt;&lt;` part could end up creating a bogus value, and then the `&amp;` with that could break things also.
It doesn't cause the error itself but it does hide the error location, making it appear to occur between the print statements when in fact it's occurring elsewhere in the code.
That is true though.
Thank you, I'll do that!
Define "won't work." If you're asking about things that won't compile, then most anything that uses a C++ feature won't compile with a C compiler. There's more possibilities here than can be summarized in a Reddit post. If you're asking about code that both compilers accept, but do different things (and, assuming the C++ behavior is desired, the C version "won't work" as you might have hoped), that's a slightly different question. And it has interesting answers. Here's a few snippets of code for examples: * Type of character literal is changed from int to char printf("%zu", sizeof('a')); * The result of a conditional expression, an assignment expression, or a comma expression may be an lvalue char arr[100]; printf("%zu", sizeof(0, arr)); * In C++, the type of an enumerator is its enumeration. In C, the type of an enumerator is `int`. enum e { A }; printf("%zu", sizeof(e)); // Note: these might produce the same result on some compilers * `struct` declarations don't hide other declarations in C, where the do in C++ char x[100]; void foo() { struct x { int i; }; printf("%zu", sizeof(x)); } There's others as well. The examples above just print out the `sizeof`, but the differences can be more significant in some cases. Fortunately, these differences don't matter much in practice.
This looks like a good idea, until you realize you're running over the usual commands. From the git manual: man git | grep ' git-' | sed -e 's/(1)//g' -e 's/^.*git-//' | xargs which # removed extra commands /bin/grep /bin/login /bin/more /bin/mv /bin/rm You'll get an awkward error if someone tried an rm.
Two different things... ipcs &amp; ipcrm is for sys5 semaphores (semget, semop), but these (sem\_open) are posix semaphores.
Try without `O_EXCL`. In combination with `O_CREAT` it tells the kernel to fail if the name already exists.
Sorry, but I don't understand – `repl rm` works fine, if that's what you mean (as does git-rm, if *that* is what you mean).
C++ doesn't allow implicit casting to void*.
Awesome job!! I'm reading *Professional CMake* by Craig Scott these days, and I have difficulty to find real examples. Do you care to add an example with `FetchContent`?
I don't think it's meant to be a shell, but rather a program that is temporarily run as a sort of subshell within your normal shell. You'd run "repl git" from your usual shell before doing a sequence of commands prefixed by git, and then exit the repl instance to be back to your normal shell prompt. So you'd still be able to use any normal utilities, even if those utilities have the same name as a git subcommand.
I made templates because I was sick of not finding good examples so made examples that are fully functional templates. I will see if I can fit "FetchContent" in a template after I do some research from the CMake's documentation and do some test just to make sure it works.
No one has answered the interesting part of your question. Given this procedure for converting to binary &gt; 1. Divide the number by 2. &gt; 2. Get the integer quotient for the next iteration. &gt; 3. Get the remainder for the binary digit. &gt; 4. Repeat the steps until the quotient is equal to 0. Does the `showbits` function perform that algorithm? The answer is "yes, a modification of it". To see how, let's look at how that algorithm works for base 10. It is exactly the same, except use '10' in place of '2'. Say the number is 173. 1. Divide x by 10 2. The integer quotient is 17 3. The decimal digit is the remainder, or 173 - (17 * 10) = 3. 4. Repeat: 17 / 10 = 1. The remainder is 17 - ( 1 * 10 ) = 7. 4. Repeat: 1 / 10 = 0. The remainder is 1 - ( 0 * 10 ) = 1. Done. Notice that you produced the digits in the backwards order. Let's deal with that later. But also notice that this description seems overly complicated. Because we normally write numbers in base 10, we could describe this algorithm as: - First take the 1's digit. - Then take the 10's digit, - Then take the 100's digit, - Repeat the pattern until there are no more digits - what's the pattern? The value of each digit is 10 times the previous one. Notice that in base 10, multiplying a number by 10 is the same as adding a 0 digit to the right. Now let's do the original algorithm for base 2. Say the number is 173. 1. Divide x by 2 2. The integer quotient is 86 3. The decimal digit is the remainder, or 173 - (86 * 2) = 1. 4. Repeat: 86 / 2 = 43. The remainder is 86 - (43 * 3) = 0. 4. Repeat: 43 / 2 = 21. The remainder is 43 - (21 * 2) = 1. 4. Repeat: 21 / 2 = 10. The remainder is 21 - (10 * 2) = 1. 4. Repeat: 10 / 2 = 5. The remainder is 10 - ( 5 * 2) = 0. 4. Repeat: 5 / 2 = 2. The remainder is 5 - ( 2 * 2) = 1. 4. Repeat: 2 / 2 = 1. The remainder is 2 - ( 1 * 2) = 0. 4. Repeat: 1 / 2 = 0. The remainder is 1 - ( 0 * 2) = 1. Done. So after reversing, we see that the binary representation of 173 is "10101101." like before, this algorithm can also be described as: - Take the 1s digit - Take the 2s digit - Take the 4s digit - Take the 8s digit - Repeat the pattern until no more digits. - what's the pattern? The value of each digit is 2 times the previous one. We can turn that into code simply, because computers "write numbers" in base 2 using binary digits (bits). Multiplying by 2 is the same as adding a 0 bit on the right. That's exactly what the `&lt;&lt;` operator does. The other piece of the puzzle is how to "take" a given digit.That's where the '&amp;' operator comes in. If `d` holds a single bit , then `x&amp;d` returns that bit if it is set to 1 in `x`. Here is the algorithm in code: bit = 1; //take the 1's digit if ((x &amp; bit) != 0) putchar('1'); else putchar('0'); //take the 2'd digit bit = bit &lt;&lt; 1; if ((x &amp; bit) != 0) putchar('1'); else putchar('0'); ... repeat while digits... This works, except that we should remove the repetition with a loop. And we need deal with the reversal before we actually print characters. So let's print from the other end (which will add leading zeros if needed). Note that doing `bit = bit &lt;&lt; 1` N times gives the same result as doing `bit&lt;&lt;N` once. Final algorithm: num_bits = sizeof(int)*8; //8 bits per byte. max_bit = num_bits-1; //0-based counting. for (int bit = max_bit; bit&gt;=0; --bit) { putchar ( x &amp; (1u&lt;&lt;bit) ? '1' : '0'); } 
(I assume this is a response to /u/noimnotgreedy.) You're exactly right! I guess not everyone has wanted this kind of tool as much as I have.
This wouldn't work easily when the binary has a space in it (e. g. `repl "some thing"` would try to execute `some thing else` rather than `"some thing" else`). You may want to look at the [exec(3)](https://linux.die.net/man/3/exec) family of functions (with a [fork(2)](https://linux.die.net/man/2/fork)). The easiest would be `execlp()` since it does some of the shell stuff for you.
What platform are you running on? Some architectures will cause a SIGBUS when you try to read a multi-byte value from an unaligned pointer. (like trying to read a 4-byte `int` at a memory location that's not divisible by 4).
Yeah, writing is hard, specifially for educational purposes, creating *demo*nstrations is even harder. I find a good usage of `FetchContent` in [here](https://github.com/JenioPY/RadioStream). 
Writing a `make` is a rather involved process. My former boss did so (his is called `smake`) and it took a few years to mature.
I prefer to use make, because it already exist and does what it supposed to do. No point in reinventing the wheel. 
have you ever seen an executable with space ?
An unknown linux OS running on a picozed. 
I just use cmake because I work on some projects on both Windows and Linux and I really don't want to write a makefile for each system I build on.
Just guessing, but probably the 2d array has rows aligned to cache line boundaries. 
How much faster? Take a look at the disassembly that your compiler generates and see if you can spot any significant difference. E.g. https://godbolt.org/z/IdC8DC
He means write your own makefile.
That's not what the title says though.
Well, one problem is your two bits of code aren't identical. Shouldn't `b[i+1][j+1]` be `b[1][j+1]`? Also, the ordering of the terms matters when it comes to operating on floating-point values (unless you specify `-ffast-math`), so I rearranged so they matched. After doing that, [both versions produce nearly identical assembly](https://godbolt.org/z/p_YMqZ) (the only difference being when a counter is incremented, which should nave little-to-no difference on performance). But that's at `-O1`. [Things get very interesting at `-O2`](https://godbolt.org/z/dY1eRt). With more optimizations turned on, the compiler decides to unroll the second version but not the first, while also choosing different SSE instructions to accomplish the same goal. I don't know why it would do this. GCC doesn't produce quite as similar code under `-O1` and `-O2`, but at `-O3` [they're virtually identical](https://godbolt.org/z/lCX-BR). The end result here, sometimes the compiler can take a slightly different optimization path because the code looks slightly different, even if the code is identical for all intents and purposes. Also, make sure you're comparing apples to apples when comparing two versions of code.
No, but such executables are legal and should work.
Hm. `repl 'test\ test'` works. It might be a good idea to use those functions, though, with an interface like `repl command [arg ...]`. Then again, I use system(3) because it's simple and leaves the interpretation to the shell. To me, the current interface of `repl anything` feels more flexible and predictable. But your suggestions are good – thanks!
I generally just use make; I find cmake to be overkill and I'm more familiar with make syntax.
Try `-O3 -march=native` too, to see AVX kick in.
I really like *CMake Cookbook* by Bast. It has examples for so many things and explains them line-by-line.
[https://en.wikipedia.org/wiki/Compatibility\_of\_C\_and\_C%2B%2B](https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B)
**Compatibility of C and C++** The C and C++ programming languages are closely related but have many significant differences. C++ began as a fork of an early, pre-standardized C, and was designed to be mostly source-and-link compatible with C compilers of the time. Due to this, development tools for the two languages (such as IDEs and compilers) are often integrated into a single product, with the programmer able to specify C or C++ as their source language. However, C is not a subset of C++, and most non-trivial C programs will not compile as C++ code without modification. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Javascript developers should learn C the same way anyone else would, through high quality books. http://www.iso-9899.info/wiki/Books OP's article is full of undefined behavior and non-portable assumptions based purely on their architecture/compiler. An important mindset for a C developer is to separate the standard itself from all the numerous implementations.
I believe you are correct, unless something was lost in translation.
Thanks! That's what I thought. It goes to show that multithreading is pretty tricky, even for the best of us! Especially the lock-free stuff, like what the above code is.
I know but his other comments say otherwise. 
You could get rid of all the repeated tests of `&amp;&amp; i &lt; nread` by computing your inner-i-loop limits up front. size_t i8_limit = (nread &lt; 8) ? nread : 8; size_t i16_limit = (nread &lt; 16) ? nread : 16; ... for (; i &lt; i8_limit; i++) print_hex(buf[i]); ... for (; i &lt; i16_limit; i++) print_hex(buf[i]); ... I'm not optimistic this will speed things up much, but it does feel wasteful to be making this test repeatedly. My other idea is that you could simplify your main read loop to only handle the case when a full 16 bytes are read. This obviates the need for the `nread` tests, as above, but also lets you get rid of the `LINE_APPEND(" ") ` loops. Then, after the main loop exits, deal with whatever is left over. while ((nread = fread(buf, 1, 16, file)) == 16) { ... } if (nread &gt; 0 and nread &lt; 16) { ... }
Unit tests, address sanitizer and libFuzzer
'`fwrite` still uses user space buffering, like all libc i/o functions. A better idea would be to use the `read`/`write` syscalls (or whatever your os offers you) and work with your own large buffer, or even better memory map it as it avoids copying to user space entirely and the kernel fills the pages for you instead.
I can't say that typing "git" a few times in a row has every bothered me at all, but it does seem like an interesting and unique idea.
 inline int push_circ_queue(struct ptr_ring * buffer, struct item * item_push) { if (!ptr_ring_full_any(buffer)) // if (not full) { DEBUG_MSG(KERN_INFO "Pushing %u and %u\n", item_push-&gt;val1, item_push-&gt;val2); /* insert one item into the buffer */ ptr_ring_produce_any(buffer, item_push); return 0; } else return 1; // full, not enough buffer space } inline int pop_circ_queue(struct ptr_ring * buffer, struct item * item_pop) { if (!ptr_ring_empty_any(buffer)) // if (not empty) { DEBUG_MSG(KERN_INFO "Before pop, head = %u , tail = %u\n", buffer-&gt;consumer_head, buffer-&gt;consumer_tail); /* extract one item struct containing two unsigned integers from the buffer */ *item_pop = *((struct item *)ptr_ring_consume_any(buffer)); DEBUG_MSG(KERN_INFO "val1 = %u , val2 = %u\n", item_pop-&gt;val1, item_pop-&gt;val2); DEBUG_MSG(KERN_INFO "After pop, head = %u , tail = %u\n", buffer-&gt;consumer_head, buffer-&gt;consumer_tail); return 0; } else return 1; // empty, nothing to pop from the ring } The above eliminates the ThreadSanitizer data race issue. However, it only works nicely for one ptr\_ring instance but not two instances. Why ? I could not pull out the same value from the second ptr\_ring instance in which I have pushed a value into it see the [problem illustration](https://i.imgur.com/LQrFybz.png)
Memory mapping won't work for output when stdout is a tty.
In set_color() should the last line be: `lastClass = class;` Otherwise it will output a color control char for every byte
Sharp! It was correct at one point (as I tested it) but I must've borked it at some point.
Thanks! I'm almost embarrassed that I didn't come up with the first. Turns out i16_limit (and the original check) isn't needed because it's &lt;=16 in any case.
I think mmap could be a real help, with a larger input buffer as a fallback for non-regular files. A larger output buffer isn't a bad idea in any case. I'll try it.
You're reading the newline character into `col`. Add a space in front of `%c` in your `scanf()` format string.
Thats because (if my reddit client renders correctly) when doing `repl 'test\ test'` (backslash before the space), the program gets `test\ test` which is valid for a shell to execute `test test` as the binary, but remove the backslash and it would fall apart. (Actually untested) In linux(/unix), `test` is also a valid command (not sure if `test test` is, but I think it is), so with that command there isn't really an error.
Thank you very much!!! Now I can go on this helped very much, thanks!
&gt; remove the backslash and it would fall apart Yes – and this is true of the shell itself: $ ls\ -l # calls binary 'ls -l' $ ls -l # calls ls with -l argument My program echoes this behavior: $ repl 'ls\ -l' ls\ -l &gt; # repl for binary 'ls -l' $ repl 'ls -l' ls -r &gt; # repl for ls with -l argument The backslash makes it very clear that `ls\ -r` is a single word. I can’t think of a better way to signal this in the REPL’s prompt.
Thanks :-)
clang does for me as well, so I use `-Wno-missing-braces`.
gprof says about 10% of time is spent in stdio, mostly memcpy between buffers.
I'd say that is not intuitive. Sure it can be make work but is not intuitive and obivous at first. Look at for example `sudo "test test"`, which tries to run the binary `test test`. Now replace `sudo` with `repl` and it falls apart. (`xargs` is an another command)
I get what you’re saying. I could rewrite it and differentiate between `ls\ -l` and `ls -l` like this: $ repl "ls -l" $ repl ls -l But then, how should the prompt look? It has to distinguish between the two somehow, and a backslash is the most obvious method. ls\ -l &gt; ls -l &gt; Now I’d have to go through the *command* string and add a backslash before every space, which isn’t too bad, but I feel it makes the code unnecessarily complicated for my purposes.
`sizeof(singular)` is either 4 or 8, not 10, because `singular` is a pointer.
As well as what /u/a4qbfb has said, you're also trying to compare strings with `==`, which won't work (unless they're both pointers pointing to the same thing). You need to use `strcmp` from `string.h` or a similar function.
Those are the most extreme comment boxes I think I've ever seen.
This is not a trie: struct trie_QNode { char * rule_name; int rule_name_index; char * key; int index; char * rule_next; int rule_next_index; struct trie_QNode *next; }; 
Yes it won't. I accidentally `fread` with `fwrite` there. Likely stdin will either be a pipe `[...] | ./xxd` or a regular file `./xxd &lt; file`. You can't use`mmap` on pipes either, but maybe there are other ways to increase throughput of pipes. 
Your assessment seems accurate.
The variable probably does store 0.0000086, but you chose not to print a sufficient amount of digits. Try printing with `%g` for scientific notation or `%.10f` to get more (in this case 10) decimal places. With `%f`, the number is printed to 6 decimal places by default.
Thanks, that did it. So simple :) &amp;#x200B; Although it did not solve actual problem. I thought the reason might be the rounding. But apparently not. Anyway, at least I learned something new. thanks! :)
Another idea; you could get rid of the switch in set_color by creating an array of color escape codes: static const char *escapes[] = { [C_NULL] = "\33[0;2;37m", [C_SPACE] = "\33[0;32m", ... } But, because this would mean you'd no longer be passing string literals to `LINE_APPEND` it would have to be modified to take a length (which I think is an improvement safety-wise, anyway). You can avoid using `strlen` with either another parallel array of lengths or simply special casing NULL since all the others are the same length. Also, once `LINE_APPEND` is passed a length you could experiment with avoiding memcpy. Since the longest string `LINE_APPEND` is passed is 8 chars, you should be able to replace memcpy with a couple of assignments. Of course, this would be endian dependent code... Before doing this, you could run the code with memcpy no-op'ed out just to see if there's any performance gain to be had.
What is your actual problem?
You probably can't help with that. I rewrote some C code to allow inputting parameters through a python script. That actually works, but the program does not yield the same results as when it is run with its regular mode which reads the parameters from a file.
Oh, this kind of situation is just terrible.
Although K&amp;R defined the behavior of array indexing such that given `int foo[N][N];`, `foo[0][N]` would be transitively equivalent to `foo[1][0]`, which would in turn imply that `foo[r1][r2*N+c]` would be equivalent to `foo[r1+r2][c]` in cases where `r1` and `r2` are non-negative, the Standard does not. In K&amp;R, an access to `foo[a][b]` could affect `foo[a+1][c]`, but the Standard allows implementations to assume that won't happen. Assuming this is a hosted implementation, I think a compiler given the second would have enough information to perform any of the useful inferences that would be allowed under the first, but making inferences based upon inner-subscript limits may be easier than trying to make them based upon loop ranges and multiplied loop indices. 
A long-shot but if this is GCC did you try forcing 'strict' floating point computation using [-msse2](https://stackoverflow.com/questions/7295861/enabling-strict-floating-point-mode-in-gcc)?
Thanks. No I did not. I don't even know what that means. I'm very new to C. I might have find a reason ... something is screwing with my regex. For example, somehow B1 = 8.6e-6 turns into B1 = 8.6e-66....
Ah yes that would be a drastically different value :) To clarify what I meant above, floating point is mostly left to the implementation. [This article](https://wiki.sei.cmu.edu/confluence/display/c/FLP00-C.+Understand+the+limitations+of+floating-point+numbers) illustrates some of the issues with that. Good luck with the debugging!
If an implementation's `int` type includes padding, and if one of the valid bit patterns for integer zero would have some padding bits set, then `foo.y` might have non-zero bits in those positions. Note that C99 added a requirement that all-bits-zero must be a valid representation of integer zero, but it does not require that it be the only such representation. I don't recall that the term "padding" is used for storage which follows a union member but is part of another. On a system with typical alignment requirements and layout rules, a type like `union U { uint32_t x; uint16_t y[3];} u1={3},u2;` would occupy 8 bytes, of which the last two would clearly be padding. I don't think the Standard is clear with regard to whether the fifth and sixth bytes would be considered padding in any particular sense. I find it curious that initialization rules specify that padding gets cleared, given that assignment rules say that `u2=u1;` would set the padding bytes of `u2` to Unspecified values. IMHO, it would be more useful if the rules allowed bytes of a union that aren't part of the first member to be left Unspecified at initialization, so as to allow a programmer to write something like: int dummy(void*p); int test(void) { union u { struct { int initLength; char initDat[3]; }; struct { int length; char dat[1000]; }; } myThing = {{3,{1,2,3}}}; return dummy(&amp;myThing); } to declare+initialize a large object while only initializing the parts of it that would actually hold meaningful data. Yes, I know that the above would be a pretty crummy way of doing that, but it's the only way I know of that would be accommodated under existing syntax. 
Here's my own take. It's about 3.4x faster than yours while also supporting an offset counter: https://gist.github.com/skeeto/73a37d2a04558f6697b1d73ad2359760 The big performance gain is from treating each line of output as a template. It fills out the template with minimal branching, then dumps the whole thing out a line at a time. 
Tests should be committed with code, with instructions on how to run them. Typically I place them in a subdirectory titled "tests" and include the testing procedure in the README.md file.
n00b here, why not?
Ha, well done. Your version is better in every way, not just performance. I'll go home now.
When output is a TTY, the 'file' is a pipe, not a regular file. Pipes can't be seeked so memory mapping isn't possible in any useful sense.
Ah, I see. I misunderstood your comment. I thought you meant that you couldn’t read from a memory mapped file and write that to a TTY.
If you don’t absolutely NEED a variable in cmake then you shouldn’t use it. There’s zero reason to define a “SOURCES” car and then use it immediately after. 
A single-producer single-consumer queue does not need any atomic primitives beyond acquire/release fences (if thread X performs a release fence and thread Y performs an acquire, one of the following will be true: 1. No action which thread X performs after the release fence will be visible to any code which thread Y does before the acquire. 2. All actions which thread X has performed before the release fence will be visible to all code which thread Y does after the acquire. The basic usage pattern for such fences is that one thread will write a bunch of information without including an indication that it's valid, then perform a release fence, and then write an indication that the other information is valid. The other thread will check whether the information is valid and, if so, do an acquire fence and examine the information. If the second thread wouldn't be guaranteed to see all the information written by the first one, it would be guaranteed *not* to see the indication that the information is valid. Implementing a multi-producer or multi-consumer queue in robust lock-free fashion is difficult, even with a good collection of primitives. For reliable operation, there aren't many alternatives to either using a linked list or an array of pointers that can be updated with CompareAndSwap. Allowing a thread to acquire ownership of a queue slot before it is ready for use creates some problematic race conditions which have no good resolution. Using CompareAndSwap pointer update avoids such issues by ensuring that even if a thread has selected a queue slot it would like to use, it won't acquire an ownership until it has made the slot ready for the reader. 
i know... ill rename it
AMAZING, WHAT ABOUT THE LANGUAGE THOUGH?
whats your question?
how can i put lastest two variables names to stcmp so i can create a function hook that can crack paid program password
No illegal stuff please.
It's handled entirely during compilation.
Preprocessor runs before compiling and is just a fancy word for copy-paste. The preprocessor will just replace the values and let the compiler do whatever it needs to do. Perhaps the standard will say somewhere how many characters a preprocessor should be able to replace.
This is undefined behaviour due to an integer overflow. The preprocessor only does text substitution. So, it will just replace N1 and N2 with their values. To see the output of the preprocessor, you can run `cpp -o test.cpp test.c` and open test.cpp in a text editor. There is no compilation done at this point, only copy-pasting of text. The compilation will happen on this preprocessed output. Integer constants in the code are treated as int unless followed by a suffix `u` indicating unsigned and/or suffix `l` indicating long or `ll` indicating long long type. So the compiler will try to store these constants as int, causing an overflow, which is undefined behaviour.
[According to the Godbolt compiler explorer](https://godbolt.org/z/TTe4Bf), the resulting value stored in `a` is 4. This is handled by the compiler (you can see the preprocessor output using the `-E` flag on all but the Mircosoft compiler) through a common optimization called [Constant Folding](https://en.wikipedia.org/wiki/Constant_folding).
I think you already have written the source code of deleteNode(). It is literally the first function you wrote. What is your question exactly?
To see the output of the preprocessor you can do `gcc -E test.c` . From [here](https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options) the description of the E option: Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output. Input files that don’t require preprocessing are ignored.
I've tested it in GCC. 4MB of nines is no problem: It only warns you that the integer constant is too large. #define Y 9...(4MB of nines in total)...9 int main (void) { Y; return 0; } My text editor stopped working and I am too lazy to write a script to generate the first line.
As others have said, the preprocessor in your example only does text substitution, so the code does exactly the same as char c = 4000000000000000 / 1000000000000000; Which will result in `4` if the constants fit in some integer type available -- since those numbers fit in 64 bits but not 32 bits, in a lot of systems those constants will have type `long` (e.g. 64-bit Unix) or `long long` (32-bit Unix and most compilers on Windows). That said, an interesting related question is: what happens if you write something that *has* to be done in the preprocessor stage, like: #if 4000000000000000 / 1000000000000000 == 4 printf("yes\n"); #endif The standard says that the arithmetic with integers in the preprocessing stage is done with the largest integer types available, `intmax_t` and `uintmax_t` (depending on whether the number is signed or unsigned). From the C11 standard, section 6.10.1 Conditional inclusion, paragraph 4: &gt; The resulting tokens compose the controlling constant expression which is evaluated according to the rules of 6.6 *^([section 6.6 describes constant expressions])*. For the purposes of this token conversion and evaluation, all signed integer types and all unsigned integer types act as if they have the same representation as, respectively, the types intmax_t and uintmax_t defined in the header &lt;stdint.h&gt;.
"Can you do my homework for me?" - /u/ramiyo99
This sort of output is relatively unfriendly to parse by computers and not significantly easier to parse by humans than just whitespace delimited, border-less output. Point being, there is a good reason why you might be having trouble finding a solution. Regardless, `printf` allows you to specify left/right padding in the output. "%s" will be replaced with the associated string with no additional characters, but if you do "%10s", then C will add a number of leading spaces to your string so that the total length of the string and added space is 10. In other words, it allows you to specify a common column width. Adding a "-" e.g. "%-10s" will add trailing spaces instead, i.e. left-align.
You have to build this yourself. Not too difficult though.
Take a look at [ncurses](https://www.gnu.org/software/ncurses/ncurses.html).
&gt; Integer constants in the code are treated as int unless followed by a suffix u indicating unsigned and/or suffix l indicating long or ll indicating long long type. That's not how it works. The type of an integer constant is chosen by the compiler according to the size of the number and the given suffix (if any), see [this table](http://port70.net/~nsz/c/c11/n1570.html#6.4.4.1p5) (C11 standard section 6.4.4.1 paragraph 5). So, for example, on my compiler (gcc on 64-bit Linux), `10000000000` doesn't fit in an `int` so it has type `long`; this program #include &lt;stdio.h&gt; int main(void) { printf("sizeof(int)=%zu\n", sizeof(int)); printf("sizeof(long)=%zu\n", sizeof(long)); printf("sizeof(1)=%zu\n", sizeof(1)); printf("sizeof(10000000000)=%zu\n", sizeof(10000000000)); } prints sizeof(int)=4 sizeof(long)=8 sizeof(1)=4 sizeof(10000000000)=8 
Well, TIL. I always thought it defaulted to int, unless explicitly specified. I'll edit my comment.
Your code doesn't do what you think it does. You want to have a 20 element array that contains 9 characters. This is better done in a single line like `char stage[20] = "StoneAge";`. What you're doing is creating an array, then having the 0th element point to a string literal, which is immutable. The compiler is throwing a fit, because your array is meant to contain mutable data. Hope that helps. If I've said anything unclear or misleading please let me know.
The preprocessor has to do arithmetic in some cases , e.g. `#if N1/N2 == 4`
you could take cell = x + strlng where x is whitespace
Should be good fun to build yourself. As /u/chimpan_z said, printf() is your friend. Your challenge would be, of course, that were you to write this as a sort of library, you probably want to utilize dynamic allocation and linked lists to handle any number of columns/rows. Neat little thing to tinker with!
On Linux, at least, you might consider using [libsmartcols](https://github.com/karelzak/util-linux/tree/master/libsmartcols). It's not really Linux-specific, but you're likely to find out already installed there, since it's developed alongside `util-linux`.
To copy a string to a between two character arrays you would need to copy it one character at a time or use a function from the string library. "StoneAge" automatically has an array created to hold it by the compiler if it isn't used to initialize one. Maybe it might confuse you even more but you could create an array of strings, each being exactly the right size with: char *stageName [3] = {"StoneAge", "BronzeAge", "IronAge"}; Then anytime you wanted to use the string "StoneAge" in your program, you can just use stageName [0] or if you kept the number of the stage in a variable something like stageName [stageNumber].
Could you describe the outline of your tests? Do they actually test an individual function separate from everything else? Do you only test larger bits of code that are stitched together as a focused system? Are they run automatically? And how do you separate them out when you compile or build your code?
I think the question is basically "is there a library out there that will do this for me?" So he probably doesn't want to build his own. 
I think the question is basically "is there a library out there that will do this for me?" So he probably doesn't want to build his own. 
 // trying to delete a student from a students bst BST Delete(BST* A, student s) 
Testing on FreeBSD, cc hello.c /..../libc.a still produced a dynamically linked executable, even though it pulled in all that it needs from the .a. When executed, it still maps in the dynamic /.../libc.so, unnecessarily.
But why? You litterally compiled the whole libc implementation in the executable? Might be an exception, since there is a -static-libc flag.
Linked, not compiled. I don't see the problem, cc -static would instruct the link phase to produce a static executable, else dynamic. Unrelated to final executable type, adding any .a will pull in needed stuff from that library (not everything) when linking.
So basically, gcc prioritises dynamic linking if possible, and will ignore .a files if all methods are found in dynamic libraries?
I'm lost. I would expect it to use all given .a as it needs, and that's what I see on my system.
Hi lost, I'm dad!
Alright ive dug a bit on google and found this: "The -static flag forces the linker to accept only static libraries and not any shared libraries" So as for why the executable was still dynamic even with libc.a, maybe the file is incomplete or outdated, or the bsd version of gcc behaves differently
You're really looking for a flow control graph, I think.
&gt; But, to my understanding, on linux, to statically link, one must simply specify the .a file to gcc, nothing more. You're confusing two different things. The `-static` option describes the executable (or library) you're producing, _not_ the libraries you're using. Something statically linked can only use static libraries (by necessity), but it's still perfectly valid for something _dynamically linked_ to use static libraries.
Wait will gcc compile a dynamic executable even if no .so file are needed? (I dont have access to my pc right now to test it out)
&gt; Wait will gcc compile a dynamic executable even if no .so file are needed? If you ask it to do so, yes. But you have to go out of you way to not need any shared objects at all. The C library will be dynamically linked by default.
updated question, would i still be looking for a flow control graph?
&gt; So is it, by omission, undefined behavior for _Bool to be bound to something other than 0 or 1? Given the standard has no way to produce a `_Bool` containing any other values, I'd say yes. &gt; The code below is also potentially UB But that problem is not specific to `_Bool`. Any read to a non-character type could produce a trap representation.
rather than limiting yourself to just a single platform (windows) consider using a cross platform library to ask this question effectively you need to detail why you are wanting to capture a key, for example is this for a game then you might want to look at GLFW or maybe SDL 
static libc does not rule out dynamic executable, say, for security related stuff. cc -v hello.c /.../libc.a blurts out /usr/bin/ld --eh-frame-hdr -dynamic-linker /libexec/ld-elf.so.1 ... Getting rid of the unnecessary libc.so mmap when libc.a was linked with, is a good question, though.
Yes. See https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs
Are you writing a GUI or a console game?
Yes.
&gt; When executed, it still maps in the dynamic /.../libc.so, unnecessarily. That's not true. The compiler driver cc always links in the libc implicitly and it does so by passing `-lc` to the linker ld. Since you did not tell cc to do a static link, it doesn't tell ld to do a static link, so ld resolves `-lc` to a shared object, linking it in. And no, the linker cannot simply leave out shared objects from a link.
Please don't use the initialism UB as it is unclear if you refer to unspecified or undefined behaviour.
Well, yes that's the basic idea, but ttys and pipes are not the same thing.
Ahh, -lc, of course.
On recent versions of Linux you can use the F_SETPIPE_SZ fcntl to change the buffer size from the default 65536 bytes, but I suspect the difference in throughput will be small for most programs.
In short, because the compiler adds padding to the structure to align it in memory. If you want to learn more check [The Lost Art of Struct Packing](http://www.catb.org/esr/structure-packing/)
&gt; but why doesn't this block get re-allocated to another virtual block, by means of the virtual memory system? Virtual memory generally operates on the granularity of pages where one packes is anything from 4 kB to 2 GB. Even if the system could it would make no sense to map a block of 7 bytes elsewhere as just the memory management overhead for a page table entry is larger than that.
According to [this defect report](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2091.htm), I'm really just describing trap representations of `_Bool`. This seems to be the only time trap representations have ever come up in practice, though, so you don't normally need to consider them.
I'm just following [John Regehr's lead](https://blog.regehr.org/archives/1496), since he likes to shorted it to "UB." Even [the Clang documentation](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html) does it ("UBSan").
I just read the [C99 draft](http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf) which covers initialization on page 126 (6.7.8 10). It states: _if it is a union, the first named member is initialized (recursively) according to these rules._ I think the addition of padding is specifically for trailing padding bytes that does not overlap with storage of a member. But I'm not sure what purpose this initialisation would serve.
I'm not sure if I'm correct, but it feels to me that you have a concept about memory as if there is an ocean of memory, and the allocation of memory is like pouring some water from the ocean into a bucket. If you think about it that way, then it would make sense for the wasted bytes to get poured into some other bucket. Memory is more like a tall library, where you move around on a ladder. Walking along the floor is easy, but getting a book off a high shelf is more cumbersome. If you allocate a collection of books to a shelf, then it is easy to retrieve. But if your shelves are 16 bytes high and you only want to allocate 9 bytes, then you will waste the remaining 7 bytes. You don't want to use those last 7 bytes because if you stored something there, it would be difficult to retrieve. You'd need to figure out where the first collection ended, and where the second one began. A computer processor can figure this out, but it's cumbersome, just like it would be for you in the metaphor. So instead compilers waste memory that is too cumbersome to use.
Yeah, I don't. I find this initialism to be a bad idea.
Quarantine?
You can generate a DFA for any regular language. I don't know if your language is regular, but odds are that it is. This is good read, specific to regular expressions: [https://swtch.com/\~rsc/regexp/regexp1.html](https://swtch.com/~rsc/regexp/regexp1.html)
Not everybody likes autotools: [https://images-na.ssl-images-amazon.com/images/I/41cA94UUuXL.\_SX287\_BO1,204,203,200\_.jpg](https://images-na.ssl-images-amazon.com/images/I/41cA94UUuXL._SX287_BO1,204,203,200_.jpg)
OP - *contiguous* is the word you want.
If you're just starting out, you may as well learn to use Ninja, which is becoming quite popular in big companies where build times are a major throttle on developer productivity. But you will not get anywhere fast without knowing the basics of make and cmake.
Doesn't your company have an integration process where new builds are tested before they propagate? You would add your tests as a test suite to that process.
Because of [Data structure alignment](https://en.wikipedia.org/wiki/Data_structure_alignment)
Data structure alignment refers to the way data is arranged and accessed in computer memory. It consists of three separate but related issues: data alignment, data structure padding, and packing.
OP asked what any of us prefer, not what everyone likes. 
Not presently. Plans are to build this up over time. However I’ve only got experience in python executing CAN signals, driving/sensing IO, and setting up/tearing down environment such as download new Firmware/wipe params/etc. I know nothing about a test framework in C. Before I ask my team to learn python to implement automated whit box function tests I would like to see what others do closer to whatever the more traditional C way is.
Be highly careful when you are maintaining an app on device that uses a #pragma pack(). Suppose you add a parameter to a structure for example that would normally save the customers user settings. The new parameter with #pragma pack() will change your alignments in the structure but the structure instances still exist. So you’ll have a situation where if your old code tries to look at all its members not knowing the memory is shuffled. New code of course doesn’t care. So essentially you must solve backwards compatibility in this case.
Did you write a program the generates a text file which you then compiled or is there a funky templatey way to write a program with ‘four megabytes of nines’?
There's usually a testing integration layer that's more abstract than any particular language / environment, which executes all the tests ever made for the changes in your build. Like a makefile just to run tests. Jenkins is popular. If you want to stick with C, then there is Google Test: [https://github.com/google/googletest](https://github.com/google/googletest) You would usually have Jenkins verify your build using Google Test for the C/C++ components.
I didn't downvote you or anything. I was just posting a funny image that you made me think of.
Yeah Jenkins is what I set up at my last company to unit test simulink models, integrate simulink models, build, burn the image on target, and towards the end I started to build what white box testing I could for features I developed. Worked wonderful for all the reporting that had to go on and requirements traceability we had. I’ll take a look at Google Test. Thanks!
Look up uuencode
In addition, VM is invisible to the application.
Oh, sorry. Didn't noticed the image :)
You might be looking for a hex editor. If you want to inspect the machine code, you might also want a disassembler like `objdump` from the GNU binutils. Note that editing executable files is generally speaking rather difficult because you cannot insert data; doing so would cause all the data after it to shift around, changing their addresses and breaking the program. So if you want to insert code or extra data into an executable image, you have to find gaps where you can squeeze it in.
I want to write simple console game in c and I'm at the beginning of this coding and first thing that I don't know is how to read event in c 
Exactly what I was looking for, thanks !
I see. This is not possible in portable C because C only thinks in terms of character streams. C doesn't know about mice, keyboards and screens, so there is no standard way to find out which keys have been pressed. That doesn't mean that doing so is impossible. It's just that every operating system has its own way to do it. On Windows, you need to use the Windows API, specifically the console subsystem. Sadly, I'm not too familiar with the Windows API, but [this page](https://docs.microsoft.com/en-us/windows/console/consoles) might get you started.
Look into the win32 api. It's the api created by Microsoft to control all of windows (based on top of the native api which is just pure system calls). Win32 is a mix between system calls to the os and high level windows abstractions including stuff like building a window and event handling. When it comes to the cmd shell I have no clue how to help there, not too many resources on it unlike the Linux terminal. Try looking up conio.h on the MSDN
Contagious. You can force C to ignore alignment and tightly pack structs together without any alignment padding being added.
`... | awk -F "| " ...`
You can convert the binary to octal or hexadecimal, both of which are human readable. Sorta. Uuencode is meant for transfer of binary data over ascii channels. It was used back when email was often sent over store-and-forward networks running atop analog phone lines and modems. In the old days of uucp, fight-o-net, wwivnet, mail tossers, BBSs, and Telix. 
Thanks All of you for great answers.
contagious?
Are you just reading input from the keyboard? Could you just use scanf and run the program in the background? 
Ok I will add this in my todo list before releasing version 1.0.2
I will get the book thanks for the recommendation. 
What about the row borders?
`... | awk -F " |" 'NR%2==0 { print ...'`
The link is very useful. Thanks. I have a question about it. Is structure alignment and padding a feature of the language itself or is it defined in the standard? Or is it just an implementation that all compilers follow?
You are correct, I am/was looking for an existing library; however, as /u/FUZxxl and /u/frugal_masturbater said, I probably should roll my own. My C skills are *very* basic so it would be a great learning experience.
"9" "9" -&gt; 2^1 select copy paste -&gt; 2^2 select copy paste -&gt; 2^3 ... select copy paste -&gt; 2^20 = 1 MB select copy paste -&gt; 2^21 = 2 MB select copy paste -&gt; 2^22 = 4 MB
Indeed! It's a really good exercise actually. I should use it for my students.
Tests are largely driven by determining what the code should do. You may want to read up on testing in general; there are many resources available online.
If you're using some sort of *nix you can use [od](https://www.mankier.com/1/od). od is an acronym for octal dump although modern versions support a variety of output formats.
Could he not use the ncurses library? I've used it in the past and never ran into any portability issues.
Ncurses only says which character was received, not which key was pressed to send it. Release events cannot be detected either.
updated post
updated post
I'm not sure, but if I believe, there are some requirements on the standard but a big part of it is implementation dependent. Take a closer look at the article, if something is standard or implementation dependent, the article probably mentions.
The standard allows the compiler to place empty space between any `struct` members, or at the end, but it's completely up to the compiler whether or not it actually does. Generally speaking, whether or not it happens is more a function of the architecture you're compiling for rather then the compiler itself, since it is the architecture that determines if alignment is necessary. That said, since alignment requirements don't generally vary by compiler, figuring out how much padding is necessary to properly align the `struct` members is pretty simple and you'll likely get the same padding even when using two different compilers, though that's definitely not guarenteed.
Why not parse any structured data or create a simple text database?
Thanks for the link, definitely a very interesting and important read. Now the author speaks specifically about compiled languages (like c, c++, rust and go), but i wonder if i was to look in to the actual memory that (say) a Java program uses, would the same sort of alignment rules apply? My guess is that given the VMs are most often implemented in c/c++ and that the author says that it is largely dependent on architecture it must be so, but then again they might be doing some clever stuff and trading some access time for more tightly packed data. It shouldn't matter for any Java programmer, but if it does - well, that would be yet another point for "data oriented programming". Still i would very much like to know how it is in reality.
This \[stack overflow answer\]([https://unix.stackexchange.com/questions/176111/how-to-dump-a-binary-file-as-a-c-c-string-literal](https://unix.stackexchange.com/questions/176111/how-to-dump-a-binary-file-as-a-c-c-string-literal)) has a few other suggestions such as \`hexdump\`, \`xxd\`, and there is also an answer that is a manual implementation. Pretty nice read.
I can't really think of a common instance where the character received wouldn't correspond to its relative key. But you're right there is no way that I know of to detect a key release.
Excellent, thanks
For example character 0x09 is “horizontal tab” and can be generated both by pressing the tab key and Ctrl + I. Similarly, 0x0d is “carriage return” and is generated both by pressing Ctrl + M or the enter key. These cannot be distinguished.
Ah I see thanks for that, but for a simple game this might not matter much. I mean if you're expecting the enter key but the player chooses to use Ctrl + M instead for whatever reason then there really isn't a problem. Though I suppose the player could've configured their keyboard so that the enter key doesn't generate a carriage return in which case yeah there could be a problem.
&gt; Though I suppose the player could've configured their keyboard so that the enter key doesn't generate a carriage return in which case yeah there could be a problem. There is no way to change this configuration as it is not a configuration. This is just an artefact of how ASCII works. As I said before, the more difficult problem is that you do not get key-up events as releasing a key does not cause a character to be generated, so there is no way to know how long a key has been pressed.
I’m asking if you guys wrote down notes though? It seems like the general consensus is to not write down anything, so I’ll probably follow that.
https://stackoverflow.com/questions/44468639/memory-alignment-of-java-classes Has some detail on this. Seems like it is largely platform dependent and you should not really rely on members being packed (or not). I’m not sure if Java/C# even guarantee that member variables of a class will be stored in (virtual JVM) memory in the order they’re declared.
When learning don’t restrict yourself. Just try a lot of different ways until you’ve found some success getting knowledge to stick. When I’m college I wrote hand notes because it wasn’t common to have a laptop in class. In the pro world I like to google instructional videos (some good ones on micro controllers by Quantum Leaps I’ll link in a minute). In any case I need to already have the concept in mind clear to me. Then I can figure out different solutions as I reason through just what the specific task is. But Ive found a few “follow along” video sets to learn C with a specific hobby board and program exercises. The person does the exercise and explains as they do it. Might be worth it to find a series like that and buy the matching controller. No matter what technique your looking for everyone agrees that you must write code, both good and bad, over, and over, and over... it’s not about getting it right. No, it’s about many different repetitions and the discoveries along the way. Anyway here’s the QL videos I mentioned which are good if I recall: https://www.youtube.com/user/StateMachineCOM/videos?disable_polymer=1&amp;app=desktop
Right but the OP asked about key presses and all text-based console games I've played never relied on key releases.
OP asked to “determine which key is pressed on the keyboard.” You cannot generally do this. You can only infer the instant a key is pressed down and that only for some keys and not unambiguously and not without knowing the keyboard layout. This is not an acceptable solution for most purposes. The Windows API provides ways to sidestep this, which is why I and other users try to point OP to it.
I think you need to take into account the context of the question. OP just wants to make a simple game, so I'm sure this would suffice. I've made a few games in ncurses and it was a straight-forward and easy process.
At this point give us a link to the file, reddit doesnt keep indentation. Plus you should describe the problem in more details. Does it compile? What compile option do you use? What OS? What version.
[https://drive.google.com/open?id=1jxEGqjfcbV2wg5nzG\_cbQ1b5X7jvdcw6](https://drive.google.com/open?id=1jxEGqjfcbV2wg5nzG_cbQ1b5X7jvdcw6) windows 10, GNU GCC ,Display board for option 2 isnt working after first selection,compiles without errors
Ill take a look at it tomorrow (in a couple hours). I should be able to work with this
alrite thanks
Please read and follow the instructions in the "asking for help" sticky.
Wow
How is your inbox doing? :P
You’re completely right. I’m going to have to try a few study methods before I find the one that best works for me. I’m currently working on the most basic concepts right now, and I decided to just leave little notes on the side of the page. I’ll be sure to check out that tutorial some time in the future. Thanks for the response!
OP asked literally: &gt; I want to write simple game in c and I don't know how to determine which key is pressed on keyboard. You cannot do that in portable C. Should I ignore the question OP asked in favour of a question OP did not ask which might be easier to answer? That would be quite dishonest.
Many programmer would love to have someone to look up to. I'm no professional but I've been working for a year now (in embedded programming) and would always love it if there's one to answer my questions. But the we have stack overflow for that, it's a great community. But I think I've learned the most by working on something with someone better than me. So I'd you're planning on working on some new project I would love to join. I just don't want to take a lot of your time, just working with someone better would be a win-win.
No, you don’t have to include he corresponding `.c` files. Otherwise you’d be recompiling the whole stdlib after including `stdio.h`, for example. You build a library from some of your sources, then use the library’s header in the code for an executable, finally, you compile the executable and _link_ it with your library (which you _don’t_ have to recompile).
http://idownvotedbecau.se/imagesofcode
&gt;gcc helloWorld.c math.c -o helloWorld This is accomplishing two steps in one command 1)compilation 2)linking. The header file simply contains forward declarations of functions you use in your helloWorld file, but it doesn't contain the actual definitions of the functions. It essentially tells the compliler that "this function exists, go ahead for now and you'll get the full definition later" (which is the linking). If you only use your second command, the compiler lacks the information it needs to include the functions that the math.h header says exist. Side note, is the the standard math library? You don't need to recompile that every time you use the &lt;math.h&gt; header. You can just link it directly (unless you for some reason do not have this included in your system).
&gt; In exchange, maybe you could help me out a little Looks like somebody needs help with metadata ;). Jokes aside, what you’re wanting to do is admirable and I hope it works out well. 
Normally you would compile every .c source files to an object file and then link them together. The commands you mentioned combines these steps into one for simplicity. Like: gcc -c -o helloWorld.o helloWorld.c gcc -c -o math.o math.c gcc -o helloWorld helloWorld.o math.o Assume you've compiled before and thus have object files cached. If the build system decides you need to rebuild `helloWorld.c` (because you've changed it), it'll only run the command to build `helloWorld.c` to an object file and then link these together. It won't compile `math.c` again, since it was never changed. Also notice that `math.h` doesn't have a (direct) relationship with `math.c` for the compiler. It's just common convention that the header files only says what exists and a file that implements these.
Ok, thanks, your explanation makes total sense now. Lol its not the standard math library, I just chose a random name for a library for my helloWorld example. My math.c file consists of a single function that adds two integers together. Thanks!
Say the OP wants to make a simple console game where the arrow keys move your character around the screen and certain keys such as \*\*i\*\* open your inventory or \*\*e\*\* equips an item. This most certainly can be made portable via ncurses. In fact this is how a lot of rogue-likes are made. I'm not sure I understand the point you're trying to make. Maybe there are edge cases but for a simple game I'm sure this will do what he wants. I'm not trying to be a dick, I honestly don't understand what you're getting at. If you could explain more in-depth why this wouldn't work I'd appreciate it.
&gt; Say the OP wants to make a simple console game where the arrow keys move your character around the screen and certain keys such as i open your inventory or e equips an item. This most certainly can be made portable via ncurses. In fact this is how a lot of rogue-likes are made. I'm not sure I understand the point you're trying to make. Maybe there are edge cases but for a simple game I'm sure this will do what he wants. OP did not ask that. You assumed something based on your preconceived notion about how terminal games work. This notion is true, because all terminal games have to deal with the fundamental restrictions that you only get a character stream from the terminal and that it's impossible to find out which keys are currently pressed or when a key has been released. However, do you think OP knows about these restrictions? OP said: &gt; I don't know how to determine which key is pressed on keyboard. What I get from that is: OP wants a method to find out at a random point in time which key(s) is/are pressed on the keyboard right now. This is a fairly normal operation when you program a video game where you sample input once every frame. And I say: that's not possible in plain C without platform-specific code and provide a platform-specific alternative which can deliver this. That's all there is to it.
Make a start. Show us what you have so far.
Actually you are correct in that I was assuming he wanted to make a specific game based on how I imagine terminal games to be. I didn't consider other possibilities, and for that I apologize. Though I will say I've made a Snake clone in ncurses where the snake moves around in real-time and the player can press a key independently at any time to control the snake's movement, so I'm not sure this is a restriction like you say. Though I very well could be misunderstanding again so if I am feel free to correct me haha.
&gt; Though I will say I've made a Snake clone in ncurses where the snake moves around in real-time and the player can press a key independently at any time to control the snake's movement, so I'm not sure this is a restriction like you say. Curses is implemented using highly platform specific code. If you use curses, you might as well use the Windows API as I suggested.
True, but the details are hidden behind a common interface. All the games I've made had been portable by simply doing a simple preprocessor check at the top to include the correct library depending on OS (ncurses on *nix, pdcurses on windows). The interface is identical though.
Indeed. However, my [original point](https://www.reddit.com/r/C_Programming/comments/af6773/determine_which_key_is_pressed_on_keyboard_windows/edx5emp/?context=3) (which is why I started this discussion) still stands and I don't think that “just use curses” is a sufficient answer to OPs question. It would be sufficient if you started with a detailed explanation as to why what OP desired is not possible in a portable manner and presented curses as one strategy among several, but it's certainly not a catch-all solution, especially given that the Windows API allows console programs to do just what OP desires.
You're right it is not a perfect solution nor does it work for every case. I should've explained that rather than suggest it with no background into its limitations. If OP gives a bit more information into what kind of game he is trying to make, it would be helpful in steering him to a more appropriate library. Ncurses may be appropriate, it may not be.
Do not insult other users. This is your final warning.
Do not make alt accounts. That is against reddit's terms of service.
Your comment got caught in our spam filter. I apologise for the inconvenience.
Please do not delete your threads after receiving answers as that erases these answers and makes them inaccessible for future readers with the same questions.
You need to be more clear. As written your question does not make sense. It might help if you explain what you are trying to do and how you are trying to do it. 
This sub is for C, which isn't the same thing as C++. Try /r/cppquestions instead after clearing up your question.
hmm simple i just made a text file, then i made a new c++ project the problem is that the compiler cant read my text file ( who is existed in another file on the desktop) i hope that this makes sense.
Oh sorry i didnt pay attention my bad... sorry
What makes you think the compiler should see the file on the desktop (how are you telling the compiler about it)? How do you know it cannot (what error do you get)?
that's exactly what im talking about, how i can tell the compiler about the location of my file??. i dont get any errors it works fine. the problem is that the complier cant recognize my text file and read it because its in another file .
The lack of code division and comments hurts my head lmao
Hey I'm interested in embedded too, I've never made a stack overflow account. Is it extremely useful? 
thanks :) &amp;#x200B;
My code: #include &lt;sys/stat.h&gt; int is_regular_file(const char *path) { struct stat path_stat; stat(path, &amp;path_stat); return S_ISREG(path_stat.st_mode); } &amp;#x200B;
I think the string building is wrong. From `man strncpy`: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated. So the call to `strncat()` produces undefined behaviour because `final_path` is not null-terminated. From there *anything* can happen. Also you don't `free()` the memory you `malloc()` for `final_path`. I suggest you to check your program with something like `valgrind`.
According to the man page for stat(2) you're supposed to first bitwise-and the st_mode field with S_IFMT before testing with any of the S_IF... macros. And those are called S_IF... and not S_IS...
I can't quite say what the problem is, but I would recommend checking the return value from `stat()` - if it's not zero then the error code should give you a basic idea of what the issue is. I would also personally recommend considering using `snprintf()` instead of the `str` functions, it's a lot easier to read and harder to mess up.
Not sure what's wrong but I'd encourage you to check the return value from stat to make sure it's not failing.
Strncpy doesn’t do what you think it does. It isn’t a function to deal with normal strings with a size, it is a function to deal with string of up to a fixed length. Usage is to say “char name[8]”, and the using strn\* functions, with n==8. You will be able to work with strings of up to 8 chars, **with no NUL terminator if the string is of size 8** So your first strncpy does not terminate the string. The second neither, but your program is already undefined there. (Hint: use a debugger) 
That sounds like a bug to me. My reading of docs is `snprintf` should truncate the output. Also, you shouldn't be using `strlen` as that only tells you how long the string is already and not how much space is in the buffer. You'll need to track the allocated length of your buffer manually.
This is a subreddit about programming in C. I didn't even know you could build C programs with Ninja.
ninja is just a tool like make, except you don't write the actual build file by yourself but by an another tool, like meson or CMake (`-G Ninja`). So you want to setup either meson or CMake.
For the next time: almost all system calls can fail. Always check if system calls where successful before making assumptions about their effect.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Did `snprintf` abort or was it some subsequent use of the resulting unterminated string that aborted? If it was `snprintf` itself, it seems like a bug.
The path variable comes in from scans so I thought it'd be null terminated. And yeah I haven't done the free yet, didn't think that would be causing this problem and I usually go through and free at the end of implementing a function 
The OS is not relevant in this case but the compiler you are using. This topic without any code is pointless too. snprintf should not overwrite anything unless you are in implemented/undefined behaviour cause bad implementation. You should not use neither sizeof nor strlen as size for snprintf.
Lots of unit/integration tests. Various sanitizers like undefined, address, memory. 
Thanks to all of you -- great response! Yeah, I know when I was learning C (all on my own), I definitely could have used a mentor to help make the process go more smoothly and reduce the frustration level. So I'm happy to do that now if I can help you guys out. I have an Open Source project on GitHub called **MightEMacs**, which is an emacs-style text editor that runs on macOS and Linux platforms in a terminal window (no GUI). It is fast, nimble, and highly extensible, and uses a C-like scripting language. I am looking for programmers to try it out and give me some feedback. And of course, you could always look at the code if so inclined, to see how it works. If enough people were interested in the project and liked the editor, I would certainly be open to collaboration on it at some point. I will respond to those of you who sent me private messages soon. Thanks for replying!
`path` is fine (I guess). It's `final_path` the not null-terminated one because of how `strncpy()` works. The leaked memory doesn't cause this kind of problems, I was just pointing out another issue of your code. As others have already said, you should check the return value of functions that could fail (in this case `malloc()` and `stat()`).
scanf always make trouble with the trailing enter, use something to parse the user input, something like fgets
Meson. I already have CMake working but just need Ninja to get meson to work.
Why is the OS not relevant?
It's unlikely that the OS detects a C compiler running and goes "Aha! Time to infiltrate this process and meddle in which version of snprintf() is being linked!"
Because C standard functions are independent of the OS if you don't step in implemented defined behaviour. I will probably need someone to back this up but I'm pretty sure of it. And the probability of a bad implementation of snprintf with a user who seems clueless about the pitfalls of using sizeof or strlen as size buffers are ridiculous too.
bitches aint shit
[I don't even know what that means...](https://i.imgur.com/2xkzrJp.gifv)
Not my blog but something I came across in /r/berkeley. The first few optimizations are useful but the last one is an interesting cheat
im kinda new to this so could u maybe link an example
 &gt; Take math operations that are done inside a loop and do them outside the loop if possible. If it has constant value inside loop, any decent compiler will optimize it with one single calculation. &gt; Instead of setting array elements to zero one-by-one inside a loop, call memset to zero out the entire output array at the start. If you have the opportunity of initializating a struct you can do {0} Reference C99 Standard 6.7.8.21: If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration. &gt; Compute Loop Bounds Intelligently: Instead of writing if-statements inside a loop to check if the indices are valid, figure out the start and end values you need so you can loop over only the valid ones. Since when someone will loop on non aquired memory? &gt; Abusing the Preprocessor: Compilers these days are pretty good at optimizing simple math, and they’re especially good at optimizing math with constants. That's unironically meta. &gt; We wrote a Python script that generated a thousand different versions of calc_depth_optimized with different hard-coded values for feature_width, feature_height, and maximum_displacement, which the compiler used to produce more optimized code. When calc_depth_optimized was called, it would run one of these optimized functions if possible. What?
&gt; If you have the opportunity of initializating a struct you can do {0} This certainly saves you some characters in your code, but it won't save you any instructions--the array still has to be filled with zeroes at runtime whether you do it explicitly or implicitly in your program! By the way, the implicit initialisation, the for loop, and the memset function, are likely to all compile to the same assembly if you have smart compiler optimisation.
&gt; This certainly saves you some characters in your code, but it won't save you any instructions How so? It's implemented on the language. It's naive to think you can generate more optimized code than that. 
I believe that memsetting to zero is a simpler function, as it doesn't have to care about types or bit representations, it simply sets everything to zero. The language's implementation of implicit initialisation has to be generalised, as it must be ready for statements like float a[100] = {-723.90021};
I don't unserstand how {0} have any downside to memset. Both implementations will initialize that to 0.0f.
yes! see this link, it's easy https://www.dummies.com/programming/c/how-to-use-the-fgets-function-for-text-input-in-c-programming/
thanks
If there is no error, how do you know the compiler cannot recognize any of the file?
ugh, ugh.
Debian on Windows 10 has ilbsmartcols, as grep shows: libsmartcols.so.1 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libsmartcols.so.1 However, it won't compile: $ gcc -Wall -g col.c -L/lib/x86_64-linux-gnu -l/libsmartcols.so.1 -o col /usr/bin/ld: cannot find -l/libsmartcols.so.1 collect2: error: ld returned 1 exit status Any advice is appreciated.
&gt; `-l/libsmartcols.so.1` That's not how you use the `-l` option. Use the `pkgconf` to determine the appropriate `CPPFLAGS`, `CFLAGS` and `LDFLAGS` to compile against this library. You'll need the development package of the library installed.
It's generally the OS that provides the libc, not the compiler. The BSDs, macOS, Windows, Haiku, etc all ship with their own implementation. Linux distributions typically ship with the GNU libc, but a few others are available such as musl and uclibc. These are not interchangeable, even among Unix-likes (although macOS' libc borrows heavily from older BSD code). To see why this must be so, just consider how platform dependent something like `malloc` or `fopen` is. The implementation of these depends intimately on the host kernel, and the details of how to e.g. obtain memory is entirely different between NT and Linux. It's up to the OS' libc to handle these details and expose the functionality to C programs via the interfaces defined in the standard. That said, compilers often do implement a subset of what are normally libc functions as "builtins", and that is probably even the case here (I don't see any asserts following through [the macOS snprintf code](https://opensource.apple.com/source/Libc/Libc-1272.200.26/stdio/FreeBSD/snprintf.c.auto.html)). But it's absolutely not the case that the libc as a whole is independent of the OS.
Those first 3 are pretty basic optimizations, if they are indeed as they describe (I didn't look at the actual code).
Yup. It's EXTREMELY useful. You just have to make sure you have a clear picture of what you're asking, because there are so many "un-researched" questions being asked that the good ones don't get noticed. And also reading SO will help you. Maybe it's not a question you currently have but you'll learn a lot just going through others questions (in both how to ask a question and learn something new). 
Either your code has a bug or the OS is broken... 
The value of x and n in void einlesen() are addresses &amp;#x200B; In German: Der Inhalt von x und n in deiner Funktion ist eine Speicheradresse, die du mit einlesen(&amp;x, &amp;n) übergeben hast. Der Inhalt von main x wäre dann zB \*x. &amp;x in der Funktion würde die Adresse des Pointers ausgeben. &amp;#x200B; scanf_s("%lf\n", x); // why the \n ? &amp;#x200B;
There is libfort: https://github.com/seleznevae/libfort I haven't tried myself.
It is generalized but there's no reason why a compiler cannot see the difference between 0 and other numbers. 
Question the first: "Are C and C++ [distinct programming languages](https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B)?" Question the second: "Which subreddit would it be appropriate to post C++-related material on? Think carefully."
Hi @[flexibeast](https://www.reddit.com/user/flexibeast), When I select the subreddit option, then there is no option for selection C++ as a subreddit, As I know that this is not the correct subreddit where I need to submit my post? &amp;#x200B;
https://www.reddit.com/r/cpp/
also, /r/learnprogramming 
wrong subreddit
Did you like working with Jenkins? Are you apprehensive to use it again in this new setting?
Different cpu on the mac test? What exactly triggered the abort, illegal memory access or something else?
C++ is off topic in this subreddit. Please post C++ content to /r/cpp instead.
I don't know about your OS but on mine (Debian 9) I just ran: apt install meson ninja-build From there I simply followed the tutorial at https://mesonbuild.com/Tutorial.html and built the demo executable fine.
I'm assuming you're working on Linux. 1) Use "strace" to take a look inside what tcpdump "really" does, as in how it interacts with the system. You'll probably find that it opens a raw socket. 2) Learn about raw sockets - [http://plasmixs.github.io/raw-sockets-programming-in-c.html](http://plasmixs.github.io/raw-sockets-programming-in-c.html) 3) ??? 4) Profit? 
If you don't want to use a higher level library, you'll have to use whatever hooks the OS provides. I believe Linux and the BSDs all use BPF (*Berkley Packet Filter*) in some way. libpcap's source may be a good starting point.
i can know that from "is_open" and if statement , what happens is that is_open checks if the file is open or not the then comes "if" the if else statements says that if the "is_open" couldn't read the file then cout failed, and thats what the result of my project wast
I think you are confusing runtime vs. compile time behavior. It sounds like your code compiles, but when you run it you are not getting the output you expect. I recommend that you create a minimal reproducer, then ask for help in r/learncpp or on stackoverflow.com. When you post your request include: the code for the minimal reproducer, what output you expect to see, what output you actually see, and an explanation of what you think the code is doing (why you expect the output you do). 
* Please ask a specific question so we can see you've put some thought into it and so we know what you need help with. * If you're just generally confounded, run the code and see how it changes when you change things. * This is a remarkable collection of garbage code that you should never write and will hopefully never encounter in the wild, if that's any reassurance.
You forgot it's C++ and off-topic here. 
It's a question asked in my exam. I can't understand it. 
I think it can't compile because the int\* I variable is declared after the int\* Ptr which is initialized. When you declare multiple variables of same type, you must declare uninitialized first, then initialized variables. So the write declaration must be: `int* I, Ptr = Ar;`
The cheat defeats the purpose of the competition... And how did the contest took measures? Cmon
What os are you using?
Same CPU. All running in VirtualBox on a (mac!) host
[netsniff-ng](https://github.com/netsniff-ng/netsniff-ng) is a novel implementation of a packet sniffer. It may prove worthwhile to investigate how this is implemented.
You're right in that conversion to and from void pointers is implicit and allowed, though something to be careful with. The warning is not about that, but about the conversion of the function pointer. It will work, and you can cast to the argument type when calling the function to silence the warning. 
You have to look into specific System calls which will allow you to get elevated hardware privilieges and work from there. I dont know them off by heart but im sure theres some sort of compilation of calls you can use online.
https://idownvotedbecau.se/imageofcode Also this sub is for C, not C++, which is a different language. Try /r/cpp_questions or /r/Cplusplus 
&gt; Since when someone will loop on non aquired memory? I understood the rule meaning don't do things like for (i=0; i&lt;num_elem(foo) ; ++i) But instead do int n=num_elem(foo) ; for (i=0; i&lt;n; ++i)
Why would the compiler call memset() at run time to initialize a static variable to a known value at compile time?
A conversion from `void *` to `char *` is implicit and legal. A conversion from `(*)(void *)` to `(*)(char *)` however is neither as functions of the former type might have a different calling convention from functions of the latter type.
As a former professor, there are then two problems with your request: 1. It's uncertain if helping you here would constitute cheating. Which few people would have an interest in helping you do. 2. Even if this exam is over and you're just wanting to know the answer, professors (unfortunately) reuse the questions they ask all the time. There's still going to be reluctance to help you with this simply because this might help somebody else cheat in the future.
1. Open a socket in promiscuous mode at root (linux) or admin (windows... don't think it requires local system access). 2. Read all packets 3. Profit Reading the wire isn't all that hard. Filtering and doing stuff with it becomes the trick. https://stackoverflow.com/questions/114804/reading-from-a-promiscuous-network-device
`struct s` is the data type in your first example. Can't use `s` alone, unlike in C++. 
&gt; What's the reason for C having struct tags instead of everything just being datatypes? It's one extra name space, allowing you to use the same name for a structure tag and a variable. Not a very solid argument though.
C++ is off topic in this subreddit. Also, don't cheat you idiot!
mac Os currently. 
Prior to the introduction of `typedef`, the presence of the `struct` keyword whenever structures were used allowed C to be unambiguously parsed without a symbol table. Consider the following snippets: foo * goo; x=(moo)(zoo); If `foo` and `moo` aren't typedefs, the first line will multiply `foo` by `goo` and ignore the result. A weird thing to do, but legal. The second would invoke function `moo` with argument `zoo`. If `foo` and `moo` are typedefs, however, the first line will declare an object named `goo` of type `moo` and the second will cast `zoo` to `moo`. Note that if `foo` and `moo` were replaced `struct foo` and `struct moo`, respectively, such ambiguities would disappear. An alternative design [which IMHO should have been made a recommended syntax when `typedef` was added] would have been to allow/recommend colons when using reserved-word-based type names and mandate them for typedef names, thus making the syntax e.g. foo*: goo; or foo: *goo; x=(moo:)(zoo); Adding colons would have eased parsing, and in declarations would have helped clarify how qualifiers and asterisks should be applied when there are multiple objects [e.g. `int*: p,q;` would indicate that both `p` and `q` are `int*`, while `int:*p,q;` would indicate that only `p` is a pointer. That wasn't adopted as a syntax, however. 
because 'struct' is not a datatype. it is a container specifier.
This subreddit is about programming in C only. For general programming advice, try /r/learnprogramming. I have removed your thread so you can try again over there.
Thank you, thats a lot better indeed!!
Maybe /r/learnprogramming can help.
&gt;If `foo` and `moo` are typedefs, however, the first line will declare an object named `goo` of type _`moo` `goo` would be a `moo`-pointer, right?
&gt;An alternative design [which IMHO should have been made a recommended syntax when `typedef` was added] would have been to allow/recommend colons when using reserved-word-based type names and mandate them for typedef names, thus making the syntax e.g. Except now you have ambiguity with go-to labels, at least in the case of `foo: *goo;`.
Why have you [repostes](https://www.reddit.com/r/C_Programming/comments/afmcq4/how_do_i_setup_ninja/) your previous post?
I forgot that C allows direct use of `goto` labels without pre-declaration (unlike e.g. Pascal). I hadn't thought about that particular possibility since I don't use goto much. If it weren't for compatibility issues, requiring some slightly different syntax for labels would solve the problem nicely while leaving a clean syntax for the far-more-common declarations. The fundamental problem is the lack of anything syntactically to distinguish types from anything else. 
A `foo*`, actually, but I've fixed the text. Thanks. 
I don't really need a mentor but I'd still love to check your text editor out. More terminal text editors are always a blessing :P
What makes you believe fopen understands '~' ?
The initialization would ensure compatibility with programs that expect it, and would be unlikely to break compatibility with anything. Further, there would be no platforms where the cost would be particularly outrageous. The fact that padding is specified as zero-initialized, but may be arbitrarily disturbed by assignments, is probably a consequence of Design by Committee. Saying that assignments may leave padding bytes holding any Unspecified combination of its previous contents, the corresponding contents of the source operand, or zero bits, but may not disturb them otherwise, would have made the zero initialization much more useful without adding any significant cost to most implementations, but the person writing the rules for assignment and the person writing the rules for initialization made different judgments as to whether the Standard should guarantee anything about the treatment of padding bits/bytes. Further, it may be that the person writing the rules for assignment didn't intend to invite implementations to do anything other than the above, but thought that implementations would be sufficiently unlikely to treat any bits of padding in any fashion other than those three ways listed above, even if allowed to do so, that there was no need for a rule limiting them to those three choices. 
If you have brew installed just run: brew install ninja If you do not have installed brew first run: ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" &lt; /dev/null 2&gt; /dev/null
`~` is actually a feature of the shell. When you run `ls ~/`, it's the shell that expands the `~` to your home directory, not the `ls` program. So, you need to do the same thing. There's two ways to do this. The first is to use `getenv` to get the `HOME` environment variable and substitute that in. This is easy to do, but know that it's not robust (it's possible for that environment variable to not actually match the user's home directory, and there's more interesting things than just `~` that you might want in the future). The second method is to use the POSIX `wordexp` function, which does the full shell-like expansion of its argument. This might be more extensive than you're looking for, though.
Note first that you cannot use `fopen` on a directory. Behaviour is undefined if you try to do so. Normally, the shell interprets `~` in paths and turns it into your actual home directory. If you want to do the same in a program, you have to substitute the value of the `HOME` environment variable: char pathbuf[PATH_MAX]; const char *homedir = getenv("HOME"); if (homedir == NULL) { /* HOME is unset, add some error handling for this case */ } /* compute pathname */ snprintf(pathbuf, PATH_MAX, "%s/file.txt", homedir); /* open the file */ fopen(pathbuf, "r"); You might see that this is a bit annoying to do. Generally, I recommend you to take the names of files from command line arguments, delegating `~` expansion to the shell.
The authors of the Standard wanted the compile-time validity of a program to be independent of the target platform. Consequently, type-compatibility rules require that pointers to objects of different types be regarded as incompatible *even when processing code for platforms where their representations would be equivalent*. I disagree with the Standard authors' philosophy (some platforms are going to be capable of doing some useful things other platforms can't, and implementations that can't *usefully* handle some construct should be encouraged to reject programs containing it at compile/build time without regard for whether it's executed, rather than being required to ignore the construct until the program receives input that would cause it to be executed) but it is what it is. 
A bigger issue is that a `uint32_t` within a packed structure needs to be treated as a different type, but gcc treats a pointer to such a member as equivalent to a pointer to an ordinary `uint32_t` even on platforms where attempts to use it like one won't work. The Keil compilers handle things much better, recognizing that a `uint32_t*` and `uint32_t __attribute__((packed))*` are different types, and making the `&amp;` operator yield the latter when applied to to a `uint32_t` member of a packed structure. 
The Standard seldom applies the adjective "Unspecified" to the noun "Behavior", and does not describe any particular action as "invoking Unspecified Behavior". Instead, actions which e.g. perform operations in Unspecified sequence, or cause an object to hold an Unspecified value, are implicitly regarded collectively as invoking Unspecified Behavior. Since all that can really be said about Unspecified Behavior, collectively, is that a correct program must behave correctly for all possible combinations of choices an implementation might make in Unspecified fashion, and the only reason the Unspecified Behavior exists as a phrase is to allow grammatical parallelism with Implementation-Defined Behavior (which used slightly more often as a phrase) or Undefined Behavior (which is used a *lot* as a phrase), the initialism UB doesn't really pose any ambiguity. 
The Standard seldom applies the adjective "Unspecified" to the noun "Behavior", and does not describe any particular action as "invoking Unspecified Behavior". Instead, actions which e.g. perform operations in Unspecified sequence, or cause an object to hold an Unspecified value, are implicitly regarded collectively as invoking Unspecified Behavior. Since all that can really be said about Unspecified Behavior, collectively, is that a correct program must behave correctly for all possible combinations of choices an implementation might make in Unspecified fashion, and the only reason the Unspecified Behavior exists as a phrase is to allow grammatical parallelism with Implementation-Defined Behavior (which used slightly more often as a phrase) or Undefined Behavior (which is used a *lot* as a phrase), the initialism UB doesn't really pose any ambiguity. 
I'm only speaking personally here, but I like the extra information the extra word "struct" gives. I feel like typedefing all your structs only increases ambiguity for little gain.
&gt; Adding colons would have eased parsing Would adding colons have made it more difficult to distinguish a label from a definition/declaration?
CLion is good, but not free
I mean, the answer to every "Which editor should I use for &lt;X&gt;" question is "Vim". :-) So _other_ than Vim, I've found VSCode to be quite good and am pretty sure it comes with multiple dark themes out of the box. That said, to get full 'IDE' like functionality in VSCode will require installing plugins, so perhaps Qt Creator could work for you.
many people agree, most notably Linux developers - https://www.kernel.org/doc/html/latest/process/coding-style.html#typedefs
It might be worth learning how to write your own Makefile you're as well compiling each source file into its own object file - that way when you change just one file, its only that one that gets recompiled after compiling all the object files the last step is to link them all together with any libraries you might be using... here's and example: `CFLAGS=-g -Iinclude -Wall -Wfatal-errors -std=c99` `LDFLAGS=-lGL -lm -lglfw` &amp;#x200B; `SRC=$(wildcard src/*.c)` `OBJ=$(SRC:src/%.c=obj/%.o)` &amp;#x200B; `CC=gcc` &amp;#x200B; `main: $(OBJ)` `$(CC) $(OBJ) -o main $(LDFLAGS)` &amp;#x200B; `$(OBJ): obj/%.o : src/%.c` `$(CC) $(CFLAGS) -c $&lt; -o $@` &amp;#x200B; `clean:` `rm -rf main` `rm -rf obj/*` notice that any new source file thats placed in the src directory will be picked up automagically and turned into an object file. Even from this trivial example you can see the power of a Makefile is well worth learning...
SlickEdit is great too but not free ...
&gt; Is it because while (*p++) increases the value of *p ... Yes. Although `*p++` increments `p`, not `*p`.
Your first loop basically does this: while(*p) { p++; printf("%d", *p); } That should make it more clear.
*p++, but yeah.
Um ... huh?
Lol igonre me
Many people disagree, including most GNU software, Microsoft, and the majority of other OSS projects I've looked at. Linux is by far in the minority with this opinion.
In hindsight, I think C++ nailed this with the `using` directive.
I don't see a problem with this Makefile for what you're trying to do. To be clear, you searched in /lib/modules/$(shell uname -r)/build for your .ko file?
A function prototype like `int sendToStream(struct STREAM_THINGIE *stream, void *dat, size_t n);` will be legal whether or not a declaration of `struct STREAM_THINGIE` is in scope. If code which uses `sendToStream` has no reason to care about the contents of `struct STREAM_THINGIE`, is there any reason the prototype should demand that its declaration be in scope? If the Standard had always allowed benign `typedef` redeclarations, so one could say e.g. `typedef struct STREAM_THINGIE STREAM_THINGIE;` as a means of telling the compiler that `STREAM_THINGIE` was a struct whose content may or may not get specified later, without having to worry about whether another header might define the type that same way, then that may have been preferable to using `struct STREAM_THINGIE` all the time. Since it regarded redeclarations as a constraint violation, however, even when everything in the redeclaration was consistent, it was impossible for code to avoid having to explicitly use `struct` tag at least sometimes, Given that the `struct` tag had to be exposed to user code, I think there was a good argument for *only* exposing the `struct` tag, rather than exposing *both* the tag and a `typedef` name. 
Well, since someone else suggested Vim, I'd be remiss not to suggest Emacs... But I'd also suggest Textmate or Sublime Text.
C as it existed in 1974 didn't have `union`, but instead allowed programmers to access an object of one structure type using named members of another. For example, given: struct foo1 { int foo_size; int foo1_content[1]; }; struct foo2 { int foo_size; int foo2_content[2]; }; struct foo3 { int foo_size; int foo3_content[3]; }; one could write a function that would accept a `struct foo1*` and pass it a pointer to any of those types. The behavior of `.` and `-&gt;` was *defined* in terms of member types and offsets, and pointer arithmetic was defined in terms of addresses; since both `foo1_content` and `foo2_content` would have the same starting offset, given `struct foo1 *p` which holds the address of a `struct foo3`, an attempt to access `p-&gt;foo1_content[1]` would be equivalent to `p-&gt;foo3_content[1]`. Although the present design where every struct type effectively has its own associated namespace is generally more useful, the C74 design could nicely accomplish some things that have become somewhat more awkward under nice interpretations of the Standard, and insanely awkward the way gcc and clang interpret it.
Setting up Jenkins was kind of hard for me because I’d never built anything like it before. There is a big support community but there’s also sooo many custom things people do it’s hard to get your question exactly sometimes. We used it for: 1) Generating a spread sheet of every single connection from model to model ever in our controller. This was pulled out of our software architecture and consumed during simulink model integration. 2) Actually doing the model integration in simulink. 3) compiling code 4) executing unit tests (of unintegrsted models) 4) downloading to target 5) generating model documentation 6) generating release notes and information for an entire release of software including hundreds of models version, unit test versions, etc.. And that consisted of maybe 10-12 jobs in Jenkins. We integrated it with our version control to commit, checkout, blah blah blah. We had email reports for pass fail etc and signals newly created or added or stuck needing manual work. All in all there was absolutely no fucking way we could have even come within MONTHS of our deadline if we didn’t make huge steps to get it built out. We heavily used Python to glue it all together. This was everywhere from openpyxl for excel handling, COM API for M$ toolset (word, outlook, etc) and simulink integration, CAN protocol driver, and even controlling a serial controlled power supply running our ECU. I felt like python was doing too much of the Jenkins work, python created html formatted emails with pictures and tables, it checked out or commuted for us and handled the locks. Jenkins has more features to do a lot of stuff like that. Some of our jobs were a scheduled time of day to just call a python script. That could be done in a windows service or a python program always running. I would use it again but I would like to pass more of the work over to Jenkins.
Curious there's no mention of `restrict` semantics. Without `restrict`, any legitimate optimizations (whether made by a compiler or programmer) would need to allow for the possibility aliasing between lvalues using `depth` and those using `left` and/or `right`, which would limit re-ordering opportunities. Among other things, adding qualifier would allow a compiler to hoist all of the initializations into a single loop before the start of the function.
Just wait until you haven't port it and enter the fun world of alignment and packed struts.
You posted this in gamedev, right?
 char *token; for (token = strtok_r(buf, " "); token != NULL; token = strtok_r(NULL, " ")) { ... }
 char *token; for (token = strtok(buf, " "); token != NULL; token = strtok(NULL, " ")) { ... }
I've been building a simple-yet-multithreaded C99 SDL2-based 2D engine (I use the word "engine" reluctantly, the project is much more modest than the word suggests) for a game I'm working on. Something I wanted to try out was whether I can build a library that is "pure ECS" ([https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system)), so that the API, all the way down to the engine, is data-driven and declarative. I found this makes code more readable, as it reduces most operations to data-mutation statements which are easier to follow than a list of (arbitrary) function calls. To keep the API simple, I used a few C99 features like compound literals. For example, this statement creates a new entity with the "Canvas2D" component, initialized with the value between the `{ }`: EcsHandle canvas = ecs_set(world, 0, EcsCanvas2D, { .window.width = 1024, .window.height = 768 }); What actually happens here is, `ecs_set` is a macro that expands into this: ecs_set_ptr(world, 0, EcsCanvas2D_h, &amp;(EcsCanvas2D){.window.width = 1024, .window.height = 768}); EcsCanvas2D is a regular C-type. Before it can be used with the framework it has to be registered, so the framework is aware of its size. To do this, you can use this macro: ECS_COMPONENT(world, EcsCanvas2D); This automatically does a "sizeof", and declares the `EcsCanvas2D_h` variable. Similar to the `ecs_set` operation, you can also do an `ecs_get`, which retrieves the component value: EcsCanvas2D canvas_data = ecs_get(world, canvas, EcsCanvas2D); The `ecs_get` macro expands to: *(EcsCanvas2D*)ecs_get_ptr(world, canvas, EcsCanvas2D_h); I hope you find the demo code interesting. You can run it by following the instructions in the README (though currently only on MacOS and Linux). As the project progresses and becomes more usable I'll post more details. Link to the nbody code: [https://github.com/SanderMertens/ecs\_nbody](https://github.com/SanderMertens/ecs_nbody) Link to the ECS framework: [https://github.com/SanderMertens/reflecs](https://github.com/SanderMertens/reflecs)
I did! I thought it could be interesting for this sub as well, as there aren't as many C ECS frameworks, and the API makes use of some cool C99 features that I wanted to share.
Something like this I think is what you're looking for. if(strstr(buf, "cmd")) { const char* first = strtok(buf, " "); const char* second = strtok(NULL, " "); const char* third = strtok(NULL, " "); const char* fourth = strtok(NULL, " "); .... } 
Super cool. I love finding new ways of doing things in C, and you just showed me one. I’ll give this a spin on my system!
What kind of game are you making? Also are you a student, a developer, or a hobbyist? (or some combination of those.)
I came to say something snarky about OP wanting to install the editor on a USB stick, and how Emacs is too large. But after some investigation, it looks like it [might just be possible](https://www.amazon.com/PNY-Elite-512GB-Premium-P-FD512PRO-GE/dp/B01E17LOL6) 🙃 Don't^hurt^me.
I am a professional developer, but I create games for a hobby. I'm currently working on a simulator game where the player and the simulated entities depend on each other for survival, but at the same time they try to outmaneuver one another to take control over their own destiny. As a player you can choose to be symbiotic, or parasitic. That's a bit vague- things are still in an early stage and I want to work on it a bit more before I post about the game itself :)
Alright, thanks for answering. I've started taking cs classes but I don't have much ability to do... anything. 
I don't see any object ejection nor signs of collisions elastic or otherwise. Are you using a hamiltonian system here or some other method because the results don't look correct.
Are we doing homework for 5 day redditors now? No show us your work. What have you tried? Where are you stuck?
https://www.reddit.com/r/C_Programming/comments/9l0vuz/asking_for_help_what_to_do_when_your_program/?utm_source=reddit-android
The n-body algorithm is a kind of Hamiltonian system. There is a lot of literature on it, which by the sound of it, you might find interesting reads. I found this paper to be quite comprehensive and readable: http://www.schlitt.net/xstar/n-body.pdf &gt; the results don't look correct. There is correctness, completeness and accuracy. The code is correct, in that it faithfully implements Newtons law of gravity. The code is not very accurate, in that it uses single-precision floating points, which causes rounding errors. The code is definitely _not_ complete, in that there is many things that could be added, some of which you outline. There are two things a trained eye might spot in the video. First of all, the entities spiral around the center. This is caused by two factors. First of all, the simulation has a large central mass, which attracts bodies to the center. Secondly, objects are given initial angular momentum which keeps them in semi-stable orbit around the center mass, which causes the spiraling. Additionally, you may notice that bodies tend to cluster, which halfway the video causes the formation of spiral "arms". This is due to heavy dampening. Essentially, it makes bodies accelerate less fast in the neighborhood of other bodies than they normally would according to Newton's law. The reason I applied this dampening, is first of all because it prevents entities from being slung shot into deep space after a close encounter, and secondly, because it produces a pleasing aesthetic effect :)
Perseverance and curiosity are the key! Six months ago I didn't even know something like ECS existed, and now I'm building a game with it. Keep learning, and you'll get there sooner than you think :)
The first error means that you're attempting to access a block of 4 bytes inside an area that has been freed. This is definitely a problem. The "Invalid read of size 1" is also an error, which means that you are reading 1 byte from a memory location that has not been allocated, and is not on stack. The code in your comment doesn't provide enough context to pinpoint the issue, as I cannot see the "free" that valgrind complains about. The second error is most likely because you forgot to allocate an extra byte for the null terminator at the end of the string. In C, if you want a string of 10 characters, you need to allocate 11 bytes and assign '\0' to the last character. This lets C know where the end of the string is, and ensures that if you pass a string to a function like printf, C doesn't try to print more characters than you wanted.
Cool project! Why did you choose C99 over C11?
Simple answer: because I could do what I envisioned with just C99, and didn't see any compelling C11 features that I wanted to use! The &lt;thread.h&gt; is nice though, and I could have used that. However, that is more of an internal thing and not something that impacts the API. I may eventually use that API, which would be a minor change, which would make the code easier to port. One caveat is that I want reflecs to run on older operating systems, as there are a few use cases outside of gaming where it isn't a given that people will use the latest and greatest. I'd like to retain the possibility to be able to compile on a C99 compliant compiler.
In short: If your system would use canaries you would see something like this, the moment you give too much input: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;err.h&gt; int main() { char *ptr; if ((ptr = malloc(10)) == NULL) err(EXIT_FAILURE, "%s: malloc() failure", __func__); (void) printf("10 chars max:\n"); (void) scanf("%s", ptr); free(ptr); (void) printf("Last statement\n"); return EXIT_SUCCESS; } Input 1: 1234567890 Output 1: 10 chars max: 1234567890 scanning(35484) in free(): chunk canary corrupted 0x83ea5139840 0xa@0xa Abort trap (core dumped) &amp;#x200B; Input 2: 123456789 Output 2: 10 chars max: 123456789 Last statement I think there's no way of using scanf() secure, if used for user input &amp;#x200B;
Typically, the alignment requirement for any type will be a power-of-two factor of its size, and structures will be laid out by placing each item at the next available multiple of its alignment. Even though I know of more "interesting" architectures than most people, I know of no compiler that doesn't follow this pattern. Further, if one does something like struct foo { int32_t x; int16_t y,z; }; typedef struct { int8_t dummy : (sizeof (struct foo) == 8) ? 1 : -1; } DUMMY_FOO_SIZE_CHECK; the code would violate a constraint on any implementation where `struct foo` doesn't get laid out in the typical cashion. 
If one ensures that the number of bytes that precede each object is a multiple of the object's size, there shouldn't be any need for padding on any remotely-normal implementation. Structure layout is only "highly platform dependent" if the structure doesn't place all members in ways consistent with their natural alignment requirements (which must in turn be factors of their sizes). The Standard may allow implementations to lay out structures in goofy fashion even when no padding should be required, but that's because the authors didn't think it necessary to forbid implementations from doing things they wouldn't do anyway.
Makes sense! Thanks for the write up. The only thing I’d miss from C11 is the generics, especially for a math heavy project. It’s so nice to just write `lerp(a, b, t)` regardless of type. Regarding threads.h, it sure seems nice but since it’s an optional feature one can never rely on it anyway if the code should be portable :( 
Would you not be able to build a generic lerp with the _Generic keyword? https://stackoverflow.com/questions/38405260/difference-between-c99-and-c11
Yeah that’s what I meant, but I think that’s a C11 feature?
CMake isn't a build script, but rather a build script generator. It generates Makefiles by default, but you can choose other targets, like Ninja. I don't write Makefiles or Ninja files or anything like that by hand for the same reason that I don't write assembly by hand (unless I really have to) - it's usually not the right level of abstraction. I let my C compiler generate assembly, I let some other tools generate C, and I write in higher level languages to compose my C code. I let CMake generate Makefiles, I let some higher level tools drive CMake, and I use continuous integration to orchestrate it all. If I just used Make directly, I would have to deal with a huge mess of non-standardized ways of building stuff, and wouldn't have much time to work on other things.
Oh, sorry never mind. I read your sentence as "The only thing I miss from C11". I'll delete the comment.
This looks very nice, and also physically accurate to me. It's interesting to see how the small particles get pulled in towards the center once it has enough mass, while the large ones keep spiraling out I work with a DEM code for a living, so I hope you don't mind if I ask a few technical questions: \- How many particles are in the simulation domain, and how long did the computation run? (timesteps and wall clock) \- Did you use any type of neighbor list, force cutoff, etc? \- What are the initial conditions? \- The simulation is pure 2D, correct? \- I assume dot size is scaled with mass, and dot color indicates velocity norm? I understand this is a showcase, it's just my professional curiosity that wants to know these things :-) keep it up :-) &amp;#x200B;
Sounds like you could just do steps 3, 4, and 5. Generating docs for each release is very cool, but a lot of work, and only pays off when you're working on something old and big that supports many platforms.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;err.h&gt; int main(int argc, char *argv[]) { if (argc &lt; 2) err(EXIT_FAILURE, "%s: Missing input", __func__); int i, c; FILE *read_file; for (i = 1; i != argc; i++) { if ((read_file = fopen(argv[i], "r")) == NULL) err(EXIT_FAILURE, "%s: fopen() failure", __func__); while ((c = fgetc(read_file)) != EOF) (void) printf("%c", c); fclose(read_file); } return EXIT_SUCCESS; } I don't know how you use it but with my tool you would be able to: ./fopen ~/c_code/fopen.c ~/c_code/test.c ~/*.c &amp;#x200B;
&gt;I hope you don't mind if I ask a few technical questions Sure thing! &gt;How many particles are in the simulation domain, and how long did the computation run? The simulation in the video runs 2500 particles, which are processed by 6 threads in realtime at 25FPS. &gt; Did you use any type of neighbor list, force cutoff, etc? No, this is a brute force implementation. I want to try out the Barnes Hut algorithm in ECS, but that will be significantly more complex. &gt;What are the initial conditions? There is one large central mass, with the rest of the entities being generated in random positions on a plane, with randomized masses. Each entity receive initial angular momentum so that, if there were no other entities, it would move in a perfect circle around the central body. &gt;The simulation is pure 2D, correct? That's right. &gt;I assume dot size is scaled with mass, and dot color indicates velocity norm? Correct. If you're interested, you can give the project a try! You can easily tweak the parameters of the simulation at the top of this file: [https://github.com/SanderMertens/ecs\_nbody/blob/master/src/main.c](https://github.com/SanderMertens/ecs_nbody/blob/master/src/main.c)
You'll regret using C99 features like compound literals if you decide you want to run it on Windows. MSVC does not, and does not have any plans to support C99 or C11. Their current version of C is some ugly bastardized invalid birth of C++11 and C89 / Ansi C. Maybe there's a tool that exists that can preprocess your source code and generate MSVC compatible C-whatever-the-fuck.
Do you think it's a good idea to use C11 generics instead of just using a C++ compiler and using templates? You'd just be cutting yourself off from STL and recoding a lot of highly optimized library code yourself for the benefit of saying "haha, take that, BJARNE STRARSOUP!"
My heart skipped a beat when I read that- but after some Googling I feel a bit better: [https://blogs.msdn.microsoft.com/vcblog/2013/06/28/c1114-stl-features-fixes-and-breaking-changes-in-vs-2013/](https://blogs.msdn.microsoft.com/vcblog/2013/06/28/c1114-stl-features-fixes-and-breaking-changes-in-vs-2013/) &amp;#x200B; It looks like Microsoft added support for compound literals in VS2013.
I don't think it's a good idea to expand a macro to hide the usage of compound literals. It's a lot clearer what's going on when you just pass the compound literal directly. For example, I understand the lifetime of the data `ecs_set_ptr` works with just by looking at its invocation. When I see the `ecs_set` call, I have no idea until I look at the macro expansion and at the implementation of `ecs_set_ptr`.
That's a valid point. There are other drawbacks, like, error messages are slightly more obfuscated (and unexpected) when you use a macro vs. a normal function. However, since \`ecs\_set\` and \`ecs\_get\` are such common operations, and there is a fair bit of redundancy in the full statement (you have to provide both the handle \_and\_ the type), I created the convenience macro. Both the macro and the \`\_ptr\` calls are part of the public API, so that leaves it up to the user to pick one.
I did some probing on my mac. Process 9625 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x7ff6efbff4f8) frame #0: 0x0000000100000b03 cc`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at cc.c:161 158 sprintf(next_dir,"%s/%s", dir, directories[selection]); 159 int len_preview = getNumberofFiles(next_dir); 160 char* next_directories[len_preview]; -&gt; 161 getFiles(next_dir, next_directories); 162 163 for( i=0; i&lt;len_preview; i++ ) 164 { Target 0: (cc) stopped. (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x7ff6efbff4f8) * frame #0: 0x0000000100000b03 cc`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at cc.c:161 frame #1: 0x00007fff6e7cd085 libdyld.dylib`start + 1 (lldb) print len_preview warning: could not execute support code to read Objective-C class data in the process. This may reduce the quality of type information available. (int) $0 = -1 (lldb) print next_dir (char [250]) $2 = "/Users/&lt;redacted&gt;/foo.xml" It looks like you don't check the return value of getNumberOfFiles and so it can return -1, which you then create a VLA using char *next_directories[-1]. I'm guessing accessing the variable at this point is undefined behaviour.
It’s not really to laugh at Bjarne, it’s more that I know C and I don’t know C++. And I’m effective in C and could probably get a whole lot done in the time it would take me to learn the STL :D
Good question, with a slightly less simple answer. &gt;Do you think it's a good idea to use C11 generics instead of just using a C++ compiler and using templates? I don't use C11 generics, but I regarding macro's vs. templates, I prefer macro's for reflecs. The reason for this is templates can increase code footprint. Take a header-only C++ ECS like EnTT which heavily relies on templates. It requires the C++ compiler to materialize template code for each component type. With macro's, I can offer some type safety, while not increasing code size. However, that brings me to your next point: &gt;You'd just be cutting yourself off from STL and recoding a lot of highly optimized library code This is true. However, the STL library needs to handle edge cases in order to be correct, and that makes it more heavy weight than I need it to be. Also, I haven't mentioned this anywhere yet, but reflecs is really fast. I compared it with some of the other ECS's, and it is one of the fastest. That did not happen by accident. The reflecs data structures are heavily optimized for the ECS use case. There are other, more generic aspects about C++ that have given me pause: \- It is easier to use C in C++, than to use C++ in C. I could eventually write a C++ reflecs binding that uses STL. \- C++ binaries are painful to distribute on Linux, as C++ runtime availability for newer versions of C++ (11 and 17) is hit &amp; miss on many (especially older) operating systems. \- More a nuisance than anything else, but compiling C++ is much slower when compared with C. I like to JIB (just in time building) which is feasible with C, but not so much with C++. \- C++ doesn't support compound literals, which adds to the boiler plate. Take this example of a component in C++ (taken from the EnTT Pong example): class PositionComponent final { public: PositionComponent(double initialX, double initialY) noexcept; ~PositionComponent() = default; PositionComponent&amp; operator=(const PositionComponent &amp;) noexcept; double m_x; double m_y; }; PositionComponent::PositionComponent(double initialX, double initialY) noexcept :m_x(initialX), m_y(initialY) { } PositionComponent&amp; PositionComponent::operator=(const PositionComponent &amp;) noexcept { return *this; } Now the equivalent component in C with reflecs: typedef struct PositionComponent { double x; double y; } PositionComponent; ECS_COMPONENT(world, PositionComponent); Combined with compound literals, I can now do: ecs_set(world, my_entity, PositionComponent, {.x = 10, .y = 20}); Hopefully all that offered some insight into why I decided to go with C. Language choice is always a bit of a contentious topic, but I tried to be as subjective as possible.
The way that compile time generics work, no matter the environment, is that you compile an additional instance for every type you use. You can achieve that purely with C macros by repeatedly including files, if you were so inclined. Templates remove the boiler plate of doing so. So do C11 generics, but what's the point? There's nothing written using C11 generics, and they are functionally identical to templates.
It must not be enabled by default, I just tried to use them the other day. Thanks for letting me know. I guess I'll try to figure out what they do and don't support.
&gt;But there is strange line: &gt; &gt;int\* pc, c; I usually avoid declaring multiple variables on the same line in that way. Or you could write it this way instead which may be clearer. int *pc, c;
So, this is the same? pc is a pointer, c an int? That would be indeed clearer. Thanks.
You're also going to need to work around MSVC's non-compliant [CPP implementation](https://stackoverflow.com/questions/5134523/msvc-doesnt-expand-va-args-correctly)
If I might continue with another question: &amp;#x200B; int \*pc; int c; c = 22; &amp;#x200B; printf("pc: %u\\n", pc); printf("c: %u\\n", &amp;c); &amp;#x200B; This shows me the pc and and the adress of c. The output is: &amp;#x200B; pc: 415984016 c: 415983772 &amp;#x200B; if I change the prints to: printf("pc: %u\\n", pc); printf("c: %u\\n", &amp;c); &amp;#x200B; the output is: pc: 0 c: 22 &amp;#x200B; Why does a change in the second printf influence the value of the previous printf?
no
&gt;So, this is the same? pc is a pointer, c an int? That would be indeed clearer. Thanks. pc is a pointer to an int. Adding or removing a space between a name and an operator doesn't change anything. &gt;Just also to clarify: A pointer can never be anything different than an int? You can declare pointers to any type including void.
&gt; Why does a change in the second printf influence the value of the previous printf? It doesn't, but you're using `pc` uninitialized which is undefined behaviour, so anything can happen.
but I can reproduce everytime I run it. in the second version, pc is still uninitialized.
It doesn't matter if it's reproducible, it's undefined behaviour. Literally anything can happen. It might work as you expect, it might not. It might do something else.
Nice write up. I didn't mean to suggest using C++. C with Templates is nice. Macros are for conditional compilation, and templates are for additional compilation. And, as we both discovered, compound literals are supported in every major C++ compiler, even MSVC. If you turn on -pedantic, you get a warning for using a C99 feature.
The asterisk indicating a pointer goes next to the variable you declare, not next to the type. For example: char *foo, bar, *baz, quux; Declares `foo` and `baz` as pointers to `char` but declares `bar` and `quux` just as `char` variables.
`%u` is not the correct way to print a pointer (use `%p`) or a plain `int` (use `%d`). 
Thanks for the reply! I made the following changes in my MCVE without the previews so that I don't have a declaration that looks like `char *directories[-1]`: // Get number of files in the home directory len = getNumberofFiles(dir); if(len == -1) continue; // Array of all the files in the current directory char* directories[len]; getFiles(dir, directories); But I am still getting the same error
Why are people always so surprised that “doing what I incorrectly expected” falls within the range of possibilities for UC? Do they think the compiler or OS or CPU will try to figure out what they intended, and then deliberately do something completely different?
Can you reply with a link to the new code?
here: https://pst.moe/paste/nfjauy btw i think I found the bug. This is happening in the case when getNumberOfFiles returns a positive value but getFiles isn't able to open the directory for some reason
this is the updated code: https://pst.moe/paste/fsmkpw this confirms that the problem is happening because of what I mentioned in the previous comment. now the program just gets stuck because it repeaditly tries to call opendir() but return -1 each time and this continues
First, defining `directories` as a static two-dimensional array doesn't work because it's a different structure (an array of arrays) than what `getFiles()` expects (an array of pointers to individual arrays). If you turn up the warning level a bit, you should get a warning for the static case. Second, `getNumberOfFiles()` never closes `pDir`. Third, you never check the return value from `getNumberOfFiles()`, so you never notice that it eventually returns -1 when it encounters something that isn't a directory. And when that happens, you can't just `continue` as you suggested as that will result in an infinite loop. The simplest solution is to just set `len_preview` to 0 if it is negative. BTW, there is a race condition in your program: if someone creates a file or directory between the `getNumberOfFiles()` call and the `getFiles()` call, the latter will overrun the array. Conversely, if someone deletes something, you will try to iterate over a partially uninitialized array in the display portion of your code. The correct solution is to have a single function which allocates an array of arbitrary size and reallocates it if it turns out to be too small.
Thank you so much! I was able to fix it. Apart from this I can see that my question got downvoted. I tried my best to be verbose and give MCVEs. It would be great if you could let me know where I could improve so that it doesn't happens the next time I ask a question
&gt; my question got downvoted Not by me.
Overflow of next\_dir\[\] and prev\_dir\[\] looks possible.
If `memset()` produces the correct result, then the compiler will use it (or its inline equivalent) instead of some nebulous “generalized implementation of implicit initialization”, unless the latter is *more* efficient than `memset()`. And if `memset()` does *not* produce the correct result, then you are wrong to recommend using it instead of `{ 0 }`.
&gt; Because C standard functions are independent of the OS They are part of what the standard calls “the implementation” which in practice is split between the compiler, OS-provided headers and libraries, and the OS kernel. It is *very* unlikely for a compiler to have its own implementation of `snprintf()`, although it may in some cases replace a `snprintf()` call with something else (e.g. `strcpy()` or even inline code equivalent to `strcpy()`) in accordance with the as-if rule. The actual implementation is normally part of the OS-provided C library.
&gt; Is structure alignment and padding a feature of the language itself or is it defined in the standard? Can you please explain the difference between the two?
&gt; I think there's no way of using scanf() secure, if used for user input You can specify a maximum size of the string to read in the format string, e.g. `scanf("%9s", ptr);` will only read 9 chars in to ptr. Having said that I'm not a fan of using `scanf` for user input, I'd rather let the shell handle that and use arguments, or if I really have to have interactive use I'd use `getline` or even the readline library if I'm doing anything funky.
The standard allows and even requires padding, but the amount and location of that padding is implementation-defined. (Padding is required to ensure that every struct or union member is correctly aligned, provided that the struct itself is correctly aligned, and to ensure that each element of an array of that struct will be correctly aligned as well. The alignment requirement for the struct is determined by that of its members with the strictest alignment requirement. Note that the standard requires that stricter alignment requirement must be multiples of all weaker alignment requirements.)
Oh yeah, I never wrote anything with direct userinput in the last year (in C). I should read the manpage before writing here...
MSVC is not the only option though. Im pretty sure both mingw-gcc and tcc work on windows and support up to c11.
&gt; or c=1 ; c=2 ; c = 3? -&gt; LIFO-Stack ... if is it this path, how could i save c=123 with getchar? This is what will be happening. You can't do this with getchar on it's own, you'll need to save each value of `c` in to a character array then convert it to an integer with a function like `atoi` or `strtol`. &gt; Why this code print me 123 if i enter 123&lt;return&gt;? Let's have a look. So the first time we call `zeige`, `c` is set to 1. 1 is not `\n`, so we run `putchar(1)` then call `zeige`. The second time `c` is 2. 2 is also not `\n`, so we run `putchar(2)` and call `zeige` again. The third time `c` is 3. 3 is still not '\n', so we run `putchar(3)` and call `zeige` again. This time `c` is `\n`. The `if` statement is now false, so we don't run `putchar('\n')`. We still run `zeige` again though. In this snippet there is no 'else' - `zeige` will always be run regardless of the `if` being true or false. Does that clear it up at all? 
First of all thank you, i will think about it one more time with, what u answered me and will come later on to ask u if i dont understand something more! &lt;3
I am just playing around and was surprised why pc should suddenly be 0 when I didn't change anything about it.
It was really important for the automotive industry where I was at. We had to know precisely which versions of sub components cruise control in software version x.y.z was 10 years ago in the event a law or regulation affected the product, a defect was discovered, or a recall deemed necessary. Therefore having a master index of all models, model requirement specs, and unit tests were required. Easy to generate the models version control tag number Symantec version of the model because they all were tagged together in the same folder. The hardest part was making python generate the document of release info. Every three weeks we released what we did that sprint for black/white box testing and that excel document got so full so fast. When it was done though it really saved our asses with how many releases were performed. My new job totally agree. I could run the bash build script, email results, and even package a release up for submit to test. A lot less to monitor than what I used to have in Jenkins.
People that walk in a desert with camels covered in lice receive their own reward. Microsoft is for the lowest rung on the ladder. The morons who sit in their own filth with snot stains on their shirts. The lowest rats that scurry in the darkness hated and despised even by their own families. Not that I have an opinion.
More correct http://www.scholarpedia.org/article/Hamiltonian_systems approach.
That link explains what a Hamiltonian system is, nbody being a subclass of it. Not sure what you are trying to get at.
[That's a pretty big Emacs...](https://www.gnu.org/graphics/gleeson_head.jpg) ^(*In seriousness, I've never seen Emacs alone be bigger than ~150MB. Depends on how much you want, how it's compiled, and what's in your config. Usually a standard distro takes ~50-60MB.)
That was kind of left field.
You keep posting this every week on all of my favourite subreddits. Please stop, or at least post when you make significant progress.
Nope. Only the copy in that one process is changed.
Thanks for the perspective, and sharing in general. Have a nice Tuesday (:
Is this a metroid prime 5 announcement?
You don't return anything when `n` is greater than `1`. Try this: #include &lt;stdio.h&gt; float reihe(int n) { if (n &gt; 1) { return (1.0 / n) + reihe(n - 1); } else { return 1; } } int main() { float resultat = reihe(3); printf("Summe ist %f", resultat); return 0; }
I use Sublime Text. It's technically not free, but the trial is even less intrusive than WinRAR. It asks you to purchase the full version once every twenty or so times you hit save.
You got down votes because this isn't the right sub for debugging help. You will probably get a better response on /r/programminghelp 
Here's a sneak peek of /r/programminghelp using the [top posts](https://np.reddit.com/r/programminghelp/top/?sort=top&amp;t=year) of the year! \#1: [At what point can you say with confidence that you "know" a coding language?](https://np.reddit.com/r/programminghelp/comments/abv0n5/at_what_point_can_you_say_with_confidence_that/) \#2: [\[META\] Can we make it a rule that all posts with images of code must also include a transcription of said code?](https://np.reddit.com/r/programminghelp/comments/9wv0q7/meta_can_we_make_it_a_rule_that_all_posts_with/) \#3: [I have recently started a programming class and this is one of the questions What are the basic 2 components of a recipe? I don't understand what to answer for this question and need help their isn't any context or further explanation of this question I am most likely just missing something simple.](https://np.reddit.com/r/programminghelp/comments/9n6l9u/i_have_recently_started_a_programming_class_and/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
From my perspective, language defines features and concepts. The standard defines behavior and constraints for these features and concepts. And anything left as undefined behavior by the standard becomes implementation-defined by the compilers. For example, Language says arrays are zero-indexed. Standard says if you use indices which are less than 0, you may get undefined behavior. Compilers define what value to return in case user tries to do arr[-1] I wanted to understand struct alignment is which of the three. 
&gt; From my perspective, language defines features and concepts. The standard defines behavior and constraints for these features and concepts. You are creating a distinction where none exist. The language is defined by the standard. You cannot separate the two. &gt; And anything left as undefined behavior by the standard becomes implementation-defined by the compilers. Undefined behavior and implementation-defined behavior are two distinct terms with distinct meanings.
Interesting question! I actually had not had to deal with this myself, so I did some digging about the topic. I am a linux/gdb user, so I focused on that. The short answer there is no. The OS manages the shared memory such that if changes are made a copy is created for the process doing the alteration. GDB sets breakpoints by modifying the binary to force an exception it can stop at, so the shared library binary will cause a copy-on-write action to take place. GDB gets its own copy of the segment of memory used by the shared library where the breakpoint is. I've included some links below that get into it a bit more. The links below basically say it's not (generally) a problem. When you set a breakpoint, the debugger is overwriting the original by inserting an additional command at your breakpoint location to cause an exception for the debugger to stop on. With a shared library, that means [https://sourceware.org/gdb/wiki/Internals/Breakpoint%20Handling](How GDB internally handles breakpoints) [https://landley.net/writing/memory-faq.txt](Copy-on-write memory) [https://stackoverflow.com/questions/22876949/questions-about-shared-libraries](Stackoverflow shared library and C-o-W memory)
Are you sure that I cannot separate the 2? Do you realize constraints and behavior definitions for features of the C language might be different for different standards? For example, the behavior for certain things between C99, C11 and ANSI C was different. And while undefined behavior and implementation-defined are 2 different things, the implementation of everything that is undefined in the standard gets defined by the compiler. I think I should have said implementation-dependent instead of implementation defined. 
It was accurate. From those of us that work in data centers with IBM Z-series and massive Linux and ESXi farms the Windows loser is the lowest form of human trash and they deserve their blue screens and 'update' problems and one other thing is entirely assigned 99.99% to those rats : the virus. The Windows user is the carrier of sickness and filth into any network. They should be firewalled off and never seen again. Human garbage all of them.
The approach used in Linux wasn't always the minority, since it used to be the *only* approach in the early days of Unix. If, when `typedef` was added, it had been accompanied by a syntax that could say "allow this identifier to be used in prototypes or pointer declarations as a tentative typedef for a {struct/union/function} whose exact type is unknown", making it possible to say e.g. typedef struct auto CLIENT; typedef struct auto SERVER; typedef struct { SERVER *server; ... } CLIENT; typedef struct { CLIENT *client; ... } SERVER; without having to use struct tags, then tags might reasonably be regarded as obsolescent, but no such feature exists. If code will sometimes need to identify structure types via tags, I think there's a sound argument to be made for *always* accessing them that way, rather than sometimes using tags and sometimes using typedef names. Incidentally, from what I can tell, struct tags have actually become more important with later versions of the Standard and link-time optimization. If one compilation unit contains a `typedef` declaration of a structure type that includes a tag, and another contains a `typedef` for a structure with the same content but no tag, the Standard (N1570 6.2.7p1 following the colon)would allow a link-time optimizer to assume that no object of that type which is created in one compilation unit will be accessed in the other compilation unit via pointers to the not-quite-identical type. 
Uhhhmm, thanks for sharing..
A confusing feature of console input on many C implementations is that `getchar()` does not typically read a single character from the keyboard and then return. Instead, the first call to `getchar()` will typically read a line of input and then return the first character if there were any, or a newline otherwise. Successive calls to `getchar()` will each return one character as long as characters remain, and the first call after no characters remain will return a newline. The next call after that will read another line of input and proceed as with the first. This approach tends to produce lousy user interfaces unless an application either takes care to avoid prompting for input between the time it reads a non-newline character and the time it receives the succeeding newline, or else uses implementation-specific means to read input without buffering. It irks me that the Standard didn't provide any means of requesting non-buffered keyboard input. While some implementations would have no means of supporting non-buffered input, the Standard could/should have accommodated that with a standard macro indicating whether non-buffered input is always, never, or sometimes supported (depending upon environmental characteristics at run time), along with a function that would indicate whether the current environment can support non-buffered input. Given that the vast majority of hosted target environments would be capable of supporting such a feature, there should be a way of using it that would be portable among such implementations. 
&gt; Are you sure that I cannot separate the 2? Yes. The language does not exist independently of the standard. &gt; Do you realize constraints and behavior definitions for features of the C language might be different for different standards? There is only one standard. &gt; For example, the behavior for certain things between pre-ANSI C, C89, C99, C11 was different. These are different versions of the same standard. Each supersedes the preceding one. &gt; the implementation of everything that is undefined in the standard gets defined by the compiler No. The compiler is free to assume that the code it compiles does not invoke UB, either implicitly (by simply not handling it, possibly even crashing) or explicitly (by performing optimizations based on the assumption that UB does not arise).
ty though&lt;3
The problem is platforms that only allow (for example) memory accesses to start on 4-byte boundaries. So structs with 1- or 2-byte fields might have to be padded out, or else the compiler has to generate terribly inefficient code to access them. There are probably still some embedded platforms out there like this. But yes, if you manually pad things then this generally goes away.
You do realize you can define your own "a4qbfb standard for the C programming language" right? ISO C standard is just a standard and does not define the language. C can exist w/o the standard. The standard cannot exist w/o C. The working group was formed to establish a behavior for C. I do understand that they are different versions of the same standard. But you can still compile C code with C89-compliant compiler. C89-compilers won't just vanish because a new version was announced. The very assumption that the user won't invoke undefined behavior is compiler-dependent. To use your terminology, a compiler defines whether to resolve stuff implicitly or explicitly in case a user invokes UB. 
There are small distros and forks of Emacs designed for that kind of thing. You can also build emacs without graphics, I think.
&gt; You do realize you can define your own "a4qbfb standard for the C programming language" right? Then it wouldn't be C. And strictly speaking, it wouldn't be a standard either, since a standard is something a large community agrees upon. &gt; ISO C standard is just a standard and does not define the language. It does. It literally does. There is no other definition of C. &gt; [...] a compiler defines whether to resolve stuff implicitly or explicitly in case a user invokes UB. The compiler might not even be aware that the *program* invokes undefined behavior. Some of it can be caught at compile time, some of it can't.
I think I understand what you are saying. While I do not completely agree with it, I sort of see why you are saying it. You or I do not know of any organization that uses C internally with their own defined standard. The reason a program can invoke UB during runtime is because compiler allowed the code to be compiled. UB can be caught at compile-time by adding stricter constraints. For example, a negative index user input might trigger an array access UB. An extremely strict compiler can ensure that every user input is checked with array bounds in the source code. In theory, given a really long time to compile, a standard C compiler can always catch undefined behavior and give you compile-time errors. In any case, I do not think there is anything to be gained from discussing this more. It was nice discussing with you. Thanks! :)
Couldn't you just write your macro differently? I would consider something like: #define ABSTRACT_THING(a, b, n) do { \ THING(CONST_##a_##n, CONST_##b_##n) \ } while (0); Unless I've misunderstood your needs.
Yeah, you can implement a simple tiny type system in the preprocessor. https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms
Of course many systems have alignment requirements. The question is whether programmers should be expected to make allowances for the possibility that an implementation may place a structure field at something other than the lowest succeeding address that fits the required alignment.
The pattern is not quite as clear in the actual code, or we would have done something like this! Sorry for not making that clear
Interesting idea, will look into it!
No worries! Sorry I couldn't help. u/okovko seems to have a promising answer below though!
Duct tape.
&gt; &gt;ISO C standard is just a standard and does not define the language. &gt; It does. It literally does. There is no other definition of C. What language is described by K&amp;R's "The C Programming Language", 1st or 2nd edition? What about Dennis Ritchie's 1974 C Reference Manual? C89 was written for the purpose of describing the language underlying a family of dialects called C that had *already* become popular. An interesting feature of C was that dialects' behaviors were tightly bound to the execution environment in such a way that someone who was familiar with the language in general and with a particular execution environment could write C code to access many features of the environment without the programmer having to know anything "special" about the compiler being used, and without the compiler having to know anything about those features of the environment. Consider something like: struct foo {float x,y;}; void test(struct foo *p1, struct foo *p2) { p2-&gt;y = p1-&gt;x; } on a machine where `float` was 4 bytes, In the language described by the 1974 C Reference Manual the behavior of the above code could be effectively described as "Instruct the execution platform to load the addresses in `p1` and `p2`, load a `float` from the former address, add 4 to the latter address, and store the just-loaded float to that adjusted address. The code will 'behave' in whatever the execution platform does when so instructed." Nothing I know of in either edition of K&amp;R would contradict such a description. I'm not sure how one could fully describe the behavior of the above code according to any particular version of the C Standard, in such a way that described the behavior in all cases where the Standard defines it, but did not specify the behavior in any situation where the Standard would impose no requirements. Given the lack of consensus as to the meaning of things like Common Initial Sequence guarantees, any attempted description would run afoul of at least some interpretations of the Standard, but even trying to come up with a full description which would be consistent with some possible interpretation of the Standard would be a nightmare compared with simply recognizing that different platforms have different corner-case behaviors. 
&gt; In theory, given a really long time to compile, a standard C compiler can always catch undefined behavior and give you compile-time errors. Mr Turing would like to have a word with you...
Let me know if you want help.
&gt; What language is described by K&amp;R's "The C Programming Language", 1st or 2nd edition? What about Dennis Ritchie's 1974 C Reference Manual? K&amp;R 2 describes C89. The other two describe predecessors of the C standard for which no compiler has been written in 30 or 40 years. 
strcmp(string1, string2)
&gt; a streq() in the standard library for convenience? As syntactic sugar over `strcmp(a,b) == 0`, maybe... Not that big of a benefit IMHO. &gt; an encoding-agnostic equality function for Unicode strings? Unicode equality is very complicated; slow, has security implications (example: two HTTP headers that normalizes to the same Unicode string might get interpreted differently depending on where in the webserver stack you are), is not what you want in most situations, and has edge cases that cause serious issues: e.g. [updates to the Unicode spec breaking database indices](https://www.postgresql.org/message-id/flat/BA6132ED-1F6B-4A0B-AC22-81278F5AB81E%40tripadvisor.com) – or, if you're using Linux &amp; an Unicode locale, try putting ①, ②, and ③ in a text file (one row each) in a random order and run *uniq* on it to remove duplicate rows. It'll remove all but one, since it works on the normalized collation value of the rows (which is identical for each of those characters, contrary to what you might expect), not the actual data. If a developer still wants to do Unicode string comparisons, he better know exactly what he's doing; adding it to the standard would just lead to a lot of people messing everything up.
Option 1: Slow option. extern inline bool streq(char \*first, char \*second){ return strcmp(first, second) == 0; } Option 2: Fast option. extern inline bool streq(char \*first, char \*second, size\_t len){ return memcmp(first, second); } Option 3: I'm compiling to wasm and/or trust no one. extern inline bool streq(char \*frist, char \*second, size\_t len{ for(int i = 0; i &lt; len; i++){ if(first\[i\] != second\[i\]){ return false; } return true; } }
Ah okay thank you! I realize my mistake, so dumb. myDir-&gt;name = dir; so when I free'd dir it was still being used my myDir-&gt;name
K&amp;R and C89 are similar, but there are many situations where K&amp;R2 will describe how a construct works but C89, at least the way gcc/clang interpret it, will impose no requirements. Consider the simple function `test` above. Nothing in K&amp;R2 suggests that the behavior of the function should depend upon, interact with, or otherwise "care about" anything other than the contents of the first four bytes starting at the address given in `p1` and the fifth through eighth bytes starting at the address given in `p2`. If attempting to load certain bit patterns into a `float` would cause an implementation to jump the rails, the compiler would be under no obligation to prevent that from happening, but if the platform handles floating-point in a way that would allow loading whatever bit pattern are stored at `*p1`, the implementation should load that bit pattern without regard for where it came from. Dennis Ritchie's 1974 manual defined the behavior explicitly in terms of addresses. K&amp;R2 doesn't specify things in quite such concrete terms, but says that object values are stored in sequences of bytes and doesn't say that principle only holds when various other vaguely-defined conditions are met. The C89 Standard, however, adds additional restrictions without making any effort to ensure that they don't treat necessary constructs as UB. Given that--*according to the authors of the Standard*--the Spirit of C includes the principle "Don't prevent the programmer from doing what needs to be done", such an omission would seem odd unless one recognizes that even if the Standard fails to mandate that implementations support a necessary construct, an implementation that upholds the Spirit of C *can support it anyway*. BTW, why would the authors of the Standard make mention of a desire that the Spirit of C be upheld, if not to acknowledge that the language has an essence beyond what the Standard defines? 
Loops and conditionals can only have one statement following them. The braces make multiple lines into one statement.
There's no real why, it is just how the syntax works. It's like asking why does a semi-colon end a statement. The answer is that is how the syntax was written.
I don’t get it. So what if there’s multiple print f statements in a FOR loop. 
Loops only execute one statement. So you can put a line of code as that statement or you can put a block. 
NEVERMIND! I get it, thank you!
personally, i would do `int sendToStream(void * stream, void * dat, size_t n);` int sendToStream(void * _stream, void * dat, size_t n) { struct STREAM_THINGIE * stream = _stream; assert(stream); ... } like you said, the contents doesnt matter. and having (void \*) instead of (struct STRING\_THINGIE \*) in the prototype effectively conveys the fact that it takes an opaque data structure. &amp;#x200B;
Well, you said: &gt;If one ensures that the number of bytes that precede each object is a multiple of the object's size... But that is not sufficient to ensure alignment with no padding if the size of some struct objects is smaller than (or not an even multiple of) the required memory word alignment of addresses on a given platform. Either the compiler has to place some fields "badly" wrt what the platform allows in terms of reads/writes, or it has to pad the struct. IMO, if you're using a language that is higher level than C++ you shouldn't be writing code that relies on struct padding or lack thereof. Maybe in very narrow situations like writing data to a network packet header, but in that case you should be telling the compiler explicitly to not pad at all even if it seems like a bad idea.
Because that is how the standard is written and how the compiler is built.
All I’m tryna find out basically is what if I put another statement under a loop statement and I don’t bring curly brackets. What happens? Does it run the loop for all iterations before executing that code?
It'll run whatever statement immediately follows the loop statement, until the loop runs out, and then it will proceed to run the statement below that one time.
What if it’s a block statement? The statement right below the loop statement , I mean . It’ll run every code in that block statement until the loop runs out?
Indeed! That's the whole reason for using curly braces after a loop statement, because it's fairly rare that a loop with a single statement can do something useful in your code, but it's incredibly common that you need to do multiple steps for each run of the loop.
So can I ignore the curly brackets for the loop if a single line of code is written right after the code below the loop statement? Will it just run the code below the loop statement until the loop dies out before running the code after it?
That's exactly how that works, but depending on how new you are to coding in C, you might want to add the curly brackets, anyway. When you're not as used to reading code, it can make it easier to debug things if something goes wrong, because you can easily see that the statement in the brackets goes with the loop. In fact, some coders opt to **always** use curly brackets, even if it's looping a single statement, because it improves readability.
The present `strcmp`, `strncmp`, and `memcmp` have a couple of deficiencies: 1. There is no practical way of using them, or anything else in the Standard Library, to discover the location of the first mismatch. 2. Some comparisons will, 90%+ of the time, be performed on large objects which match. Others will, 90%+ of the time, be performed on objects which have few if any bytes in common. On many platforms, having a separate function optimized for each scenario, and using each when appropriate, would allow for an easy performance boost (in embedded situations where code size is more important than performance, both functions could if desired execute the same machine code). I'd be more interested in having improved versions of `mem*` functions than `str*` ones, but both sets leave room for improvement.
but BLOCKS always go with curly brackets right? Wow thank you so much. I understand it perfectly now 
&gt; because it's fairly rare that a loop with a single statement can do something useful in your code, Eh, it's not really *rare*. My code is full of loops with one statement bodies.
easy way to get rid of compiler warning is just cast the function pointer inside the function. since C is such a weakly typed language, it isnt a good habit to rely on compiler warnings. // valid void fp(char * ptr, void * (*fptr)()) { fptr(ptr); } // equally valid assuming sizeof(void *) == sizeof((void (*)())) void fp(char * ptr, void * fptr) { ((void * (*)()) fptr)(ptr); } &amp;#x200B;
Any object, if placed in an array, will have a stride which is equal to its size. Any object's stride must be a multiple of its required alignment, or else it would be impossible to have two consecutive elements of an array that are both properly aligned. I think I forgot to mention that to ensure portability structures may need to include explicit "dummy" fields to ensure that the total size of their fields is a multiple of the size of the largest primitive field contained therein. Ironically, even though C# would normally be considered a "higher-level" languages than C, C# allows programmers to explicitly specify the offsets of structure fields, while the authors of the C Standard have yet to provide any means of doing so. If there were a syntax to specify e.g. that field X should be stored as four octets big-endian starting at offset 8, it would be much easier for compilers to handle such a feature (especially given that much of the work is already needed to accommodate bit fields) than to try to recognize all of the combinations of operations that programmers might try to assemble 32-bit values out of octet sequences, or decompose 32-bit values back into octets. 
[check this code out and kindly explain to me how the omission of the curly brackets makes sense](https://imgur.com/gallery/aDOcA3U) 
&gt;Any object, if placed in an array, will have a stride which is equal to its size. Any object's stride must be a multiple of its required alignment, or else it would be impossible to have two consecutive elements of an array that are both properly aligned. I've never actually *tried* this, but I would assume that when faced with, e.g. a `uint16` array on a platform that requires 4-byte aligned reads/writes, the compiler would produce code that does aligned reads/writes and shifts/masks as necessary. And then you die horribly if you take the address of a misaligned `uint16` and dereference it in such a way that the compiler can't tell it's misaligned. &gt;I think I forgot to mention that to ensure portability structures may need to include explicit "dummy" fields to ensure that the total size of their fields is a multiple of the size of the largest primitive field contained therein. Yes, *that* will work, at least in C/C++. I'm not sure about exactly what Java promises in that regard. &gt; If there were a syntax to specify e.g. that field X should be stored as four octets big-endian starting at offset 8, it would be much easier for compilers to handle such a feature Yep.
&gt;I am just playing around and was surprised why pc should suddenly be 0 when I didn't change anything about it. you changed the stack size. `printf("c: %u\n", &amp;c); // &amp;c is 8 bytes` `printf("c: %u\n", c); // c is 4 bytes` &amp;#x200B;
I see you came from the python forum like i suggested. glad i could help by pointing you here :D
 for (x) foo; for (x) foo; for (x) { foo; } are all the same
Yes, there was no `.ko` file. That wasn't the makefile from LDD3 though, it was from Stack Overflow.
That's one of those potentially confusing situations (also a reason why tabbing your code also helps immensely with readability). The for loop requires a statement to loop, and the if statement requires a statement to evaluate. So the line b += c[a]; is part of the if statement, which itself is the statement for the for loop. This is a case where I personally would use curly brackets for the for loop. Even though it only loops a single statement, visually, it *looks* like a block of code, hence, the brackets reinforce that all of that is a part of the for loop.
One thing that I caught vs others was that it used pwd instead of PWD.
While, technically, it true that the omission of the curly braces in a block with a single statement is mainly syntactic sugar, there is a very real (but implicit why): CPU context. When you create a new block., you are asking the compiler to tell the CPU to switch context, which means setting up the CPU registers, stack, address register and program counter. And yes, in a for/while loop you do switch context, cuz the compiler sets up the Program Counter for the loop^^[1] You can force a CPU context by declaring a block anywhere within your code, as blocks/compound statements can be declared anywhere a statement can: int main( void ) { int foo, bar = 0; { int koko, lala, bar = 1 } return 0; } When opening a new context, you can do whatever you can do when starting a new function: declare memory/variables, check the value of a variable, whatever. And when you exit the block, you are back to your original context with the original values. Do you know why you can do this? Cuz recursion. Or rather re-entrant context, which in the case of a function is renamed to 'recursion': That's how recursion is performed: same code with a new context with slightly different initial conditions than last time. In fact, a `for loop`^^[2] is nothing more than two nested contexts with a goto label (which translates to a jump instruction), the inner-most checking the Program Counter to see if it should loop back to the outmost context or not. so [1] When not compiling with no optimisations [2] In assembly
On a typical platform, accesses to `uint8_t` can occur on any address, accesses to `uint16_t` can occur on any multiple-of-2 address, accesses to `uint32_t` on any multiple-of-four address, and accesses to `uint64_t` on any multiple-of-8 address. Java stores every object or variable using a multiple of four bytes. If one creates e.g. a `short[75]`, the compiler will allocate an object with a header that says it's a `short[75]`, followed by with 38x4 bytes of storage to hold the data. The load-array-element and save-array-element opcodes will access the appropriate halfword within the object, but the object itself will be a multiple of four bytes. Java makes no effort to save storage for individual fields. Personally, I think `short` and `byte` should have been omitted from the language, keeping only `short[]` and `byte[]`, but that would require that Java allow an `int` to be stored into a `byte[]` without a cast.
If anyone is interested: https://gitlab.com/SpectralMemories/noname-3d-renderer I should add binary releases soon
I don't think you understand Physics.
Good luck - it's a deep hole you're falling into ;) 
Suggestion (only if you want to rebuild your rendered on Windows or other platform without support for *usleep* ) - since you are already using a C++ library like SFML, you can avoid the use of *usleep* by wrapping the C++11 function *std::this_thread::sleep_for* https://en.cppreference.com/w/cpp/thread/sleep_for in a C function.
And to reply to myself - You might want to look into a little more encapsulation - structs that hold the needed data and are passed around rather than globals would be a good start
I've always wondered about this myself - is the binary program affected by sloppy variable scoping, or is it just for code readability, or what?
Looks great! How does one draw in C? I started learning C recently and I couldn't find a standart graphics library. All my programs are just console applications :( It would be great to write a visual program. I am using windows and mingw64 compiler. 
Search for [SDL2](https://www.libsdl.org/index.php) tutorials, this is a C library for game development, you can use it for graphics only. Another good one is Raylib.
Well I use SFML (opengl 2D wrapper), which while written in C++, has a C translation (their site claims its a binding but apparently the C library works on its own, so its a translation to me), which is called CSFML. Its awesome to display 2D stuff with high efficiency, it works on windows, mac and linux, and it has many, many binding / translations, including C, .net, java etc etc. Plus its open source. https://www.sfml-dev.org/download/csfml/
Yeah, that wasn't just a typo. I guess that this one is inherently broken.
Only one thing is being executed and re-executed again and again. I would suggest using the braces, though because in my opinion it helps with readability and is definitely more consistent.
Right, there's no standard library for graphics in C. But there are lots of good libraries. This project uses [SFML](https://www.sfml-dev.org/). A lot of people use [SDL](https://www.libsdl.org/) (with [SDL2_gfx](http://www.ferzkopp.net/wordpress/2016/01/02/sdl_gfx-sdl2_gfx/) if you want more graphics primitives). Another one is [Cairo](https://www.cairographics.org/).
Ah, I see you've started following an openGL tutorial. It's fun to see how much hard work goes into actually making a game engine. You'll quickly find out why many opt to buy an engine, even when a company has built engines in the past.
Google OpenGL tutorial. You'll get started quickly.
I am currently working on a simple 2D renderer with SDL2 and GFX. The API is very straightforward if all you need is 2D shape primitives, sprites, sound and input. The downside is that you can't use the SDL rendering API if you want to do something a bit more interesting, like applying post-processing (like bloom) effects. To achieve that, you'll still need OpenGL / Vulkan.
&gt;Ah, I see you've started following an openGL tutorial Where did you see that? OP's project is written in C SFML. The project contains no OpenGL function calls. &gt;It's fun to see how much hard work goes into actually making a game engine It's fun to see how easy it has become with libraries like SFML and SDL to draw 2D/3D content on a screen. The project has just \~300 LOC (roughly- I did a quick scan), which is pretty impressive considering what it does.
Global variables will take more space in the actual binary because they are saved in the file itself instead of just being pushed to the stack at runtime, but performance should be negligible. It's mostly about maintainability, readability, and the ability to multithread in the future, globals generally ruin all 3 of those.
It's not, in fact at the low level there is no concept of higher level things like OOP. Writing good code is just easy to maintain and reason about in the face of bugs.
Ha very nicely done - wireframe and projection is the easy part ;) Wait until you get to rasterisation and depth sorting...
Depth sorting doesnt look THAT bad, but rasterization does look rather intimidating haha
I guess you're right. Im on mobile and thought I saw OpenGL push and pop vertexes loops in the code there. My mistake!
Gotta love people that publish code without testing it. Glad it worked out for you.
SFML uses openGL
You printf() it two times, because you call reihe() in the function reihe(). It has to printf() itself two times &amp;#x200B; #include &lt;stdio.h&gt; float reihe(int n) { float summe = (1.00 / n); if (n &gt; 1) summe = (summe + reihe(n - 1)); // second reihe() call else return 1; printf("Summe ist %f", summe); } int main() { reihe(3); // first reihe() call getch(); } &amp;#x200B;
I shall convert that degree on the wall to toilet paper !
If you have a function which needs 20 values to operate, would it be easier to type out all 20 of them or use a single struct?
Suppose you want to save details of people such as their names, age, location and so. If you choose to use individual variables for each person name, age, location... it will get messy soon. 
Pros: \- easy pointer / variable handling \- easy malloc() calls \- easy free() calls &amp;#x200B; Cons: \- hard to learn / understand &amp;#x200B; They're made for lists with a lot of data which look similiar all the time
Ok, so it's "just" time saving when you don't want to declare the same variables multiple times ?
Yep, i saw that, you can make some pretty databases with the structures but i was asking myself if there's one other reason or multiples reasons where the structure could be usefull in another way :d
Have you seen tinyrenderer? https://github.com/ssloy/tinyrenderer/wiki
Thanks!
Isn‘t his renderer written in C? (I‘m aware he‘s using a lib written in C++). The STL isn‘t an option if he want‘s to keep it pure C.
But the instruction to push the variable to the stack takes up the same space (or more) as the global variable... It's just that you use instruction memory instead of data memory. So the binary should not be bigger.
Why do you write code like this? (*(cubes_triangle + 0)).vertex[0] = (vector3) {0.0f, 0.0f, 0.0f}; (*(cubes_triangle + 0)).vertex[1] = (vector3) {0.0f, 1.0f, 0.0f}; (*(cubes_triangle + 0)).vertex[2] = (vector3) {1.0f, 1.0f, 0.0f}; What's the problem with array indexing syntax? cubex_triangle[0].vertex[0] = (vector3) {0.0f, 0.0f, 0.0f};
Awesome. I love these small graphics projects.
Nice read, thanks!
The `printf(3)` manpage on your system should have the details.
If you haven't already seen it Mike Abrash's Graphics Programming Black Book is a supremely accessible guide to everything in software rendering. Still a fantastic resource for learning and it's online here: http://www.jagregory.com/abrash-black-book/ 
Now that C has native support for threads, why the frick does it not have native support for thread sleep? :o
Hey great Stuff, i like this kind of small projects too. In the past i wrote a tiny little dirty rasterizer too, but don't know what i could use for. My starting point was stratchapixel.com and a lot of wikipedia article. What did you used for yours? Maybe you wan't to take a look here: https://imgur.com/gallery/q4G6YdZ Happy coding, gfx coding is one of the most interesting topics i think.
Sometimes the correct answer *really* is RTFM and everyone has to read printf(3C) at least once in life. Usually a dozen times.
[https://stackoverflow.com/questions/19894483/is-there-any-difference-in-using-f-e-g-e-or-g-with-scanf](https://stackoverflow.com/questions/19894483/is-there-any-difference-in-using-f-e-g-e-or-g-with-scanf)
Have you tried reading the manual?
Yeah, Initialized global variables and local statics generally take up space in the binary barring any optimizations. Zero-initialized/uninitialized globals on the other hand are similar to local in that they don't take up space in most executable file formats.
Nope, not really. With a struct, you can have a pointer to all these variables at once. This is not possible without structures.
&gt;Why does a change in the second printf influence the value of the previous printf? Undefined behavior &amp;#x200B; I'll show an example for undefined behavior: #include &lt;stdio.h&gt; int main() { int *pc, c; pc = &amp;c; (void) printf("c\t:%i\n", c); (void) printf("*pc\t:%i\n", *((int *) pc)); return 0; } c has no value, so \*pc (pointer on c) should show on "no value": c :-189768 *pc :-170524672 &amp;#x200B; Now I give c a value after the first printf #include &lt;stdio.h&gt; int main() { int *pc, c; pc = &amp;c; (void) printf("c\t:%i\n", c); (void) printf("*pc\t:%i\n", *((int *) pc)); c = 1; return 0; } Output: c :1 *pc :1
It can be. In C++, declaring objects in their innermost scope will avoid unnecessary constructor calls, for instance.
Your code doesn't handle `~` expansion either. You can check by printing the names of the files before opening them. The shell handles it for you. If you wrote the file name as a fixed string in your program, it wouldn't work either.
It does: https://en.cppreference.com/w/c/thread/thrd_sleep
You could check for the first char in the array and do a switch(buffer[0]) { case '~': .... break; default: .... break; } Or you let your shell do all the work :)
You misunderstood me. My suggestion was to wrap a C++ function in a C interface (just like CSFML does) and call the wrapper C function from his code. The main code will remain pure C.
I recommend trying to model and draw greater than three dimensional objects. It's a lot of fun.
According to man gmake, &gt;By default, make starts with the first target (not targets whose names start with ‘.’). This is called the *default goal*. (*Goals* are the targets that make strives ultimately to update. You can override this behavior using the command line (see [Arguments to Specify the Goals](https://www.gnu.org/software/make/manual/html_node/Goals.html#Goals)) or with the .DEFAULT\_GOAL special variable (see [Other Special Variables](https://www.gnu.org/software/make/manual/html_node/Special-Variables.html#Special-Variables)). [https://www.gnu.org/software/make/manual/html\_node/How-Make-Works.html](https://www.gnu.org/software/make/manual/html_node/How-Make-Works.html)
Aside from that, what's with the + 0?
The `reihe` function is called `n` times in total, so if you call it using `reihe(6)`, `printf` will be called six times. You could also use it to output all summands: #include &lt;stdio.h&gt; float reihe(int n) { if (n &gt; 1) { double summand = 1.0 / n; printf("%f + ", summand); return summand + reihe(n - 1); } else { printf("1"); return 1; } } int main() { int n; printf("n = "); scanf("%d", &amp;n); float resultat = reihe(n); printf(" = %f\n", resultat); return 0; } 
Consistency with the ones that have an offset
Linked lists and other data structures.
Your `$(ASMb)` rule needs to look like your `$(ASMs)` rule, but with `bin` instead of `asm`.
&gt; As syntactic sugar over `strcmp(a,b) == 0`, maybe... Not that big of a benefit IMHO. Considering how often people mistakenly write `if (strcmp(a, b))` instead of `if (strcmp(a, b) == 0)` and how difficult it is to spot: yes, there is a huge benefit. 
TIL structs are hard to understand
Since globals are generally externs, the binary will need a specifically allotted slot so that it has a unique memory address instead of locals which just take wherever the stack is. I assume the compiler could optimize static globals (i.e. single translation unit) to not need space in the binary.
A translation means that the whole thing would have been re-written in C. A binding means that even though the library “thinks” in C++, you can “talk” to it in C and 
CExceptions doesn't look like a particularly good idea. It's based on `setjmp` and `longjmp` which is glorified `goto`. Not that there is anything wrong with `goto`, but the problem is that your code cannot be re-entrant or thread safe.
Yeah got my words confuded a bit here. Im guessing the dll itself is written in C, but statically link the regular sfml library
Yeah, thanks for that ! 
Ah, throwback to learning C in the 90s as a kid, trying to make a software first person shooter engine.
I'm pretty sure VSCode has a portable mode. 
Anytime you deal with heterogeneous data that makes sense to be logically grouped together (so file headers and data structures come to mind). But even for homogeneous data it's useful to refer to the members by name and unlike arrays, structures can be passed by copy.
Insert dummy/future-expansion fields as needed to ensure everything gets placed on a natural alignment boundary and such issues won't be a problem. The fashions around "aliasing" and "missed optimizations" are a bigger issue.
It does have a memory address, but in the binary it is just included as a section header without any actual data such as you would find for the .text or .data sections.
You only "need" [one instruction](https://github.com/xoreaxeaxeax/movfuscator) to do virtually anything computational with a computer. In that sense, everything from variables to arrays to structs to classes are strictly unnecessary abstractions, *and* it is generally good practice to examine your assumptions and whether an abstraction is actually a net benefit for your purposes. However, structs in C require little to no extra overhead and gets you a lot of consistency and clarity in your code. It's usually a no-brainer to use them whenever you have tightly coupled variables, etc.
Maybe cubes_triangle wasn’t defined as an array. You can run into problems with using array notation on pointers in some esoteric situations, but given the context, you’d have to wonder why they wouldn’t be defined as an array. 🤷🏻‍♂️
&gt; Maybe cubes_triangle wasn’t defined as an array. You can run into problems with using array notation on pointers in some esoteric situations, but given the context, you’d have to wonder why they wouldn’t be defined as an array. It doesn't make a difference as the C standard defines `a[b]` to be exactly equivalent to `*(a+b)`. Perhaps it does in C++?
Well, sizeof() depends on an array or pointer‘s declaration and could return different values for one case versus the other. If you use sizeof() in memory allocation, expecting them to be perfectly equivalent, you’ll run into trouble. Array notation works equivalently to (offset) pointer dereferencing according to standard.
&gt; There is no practical way of using them, or anything else in the Standard Library, to discover the location of the first mismatch. This also allows them to be implemented faster than an implementation that had to find the location of the mismatch. Though I agree a `strmismatch()` function would be nice.
Or for (int i = 0, n = num_elem(foo); i &lt; n; ++i) :)
bingo! works a charm thanks....
A `memeq` function which merely reported whether two blocks were identical could be faster than one which had to determine the location of the first mismatch. The guarantee that the sign of the result from `memcmp` will reflect the values involved in the first mismatch, however, effectively compels the system to find the first mismatch whether it reports it or not. Given a function to find the first mismatch, one could synthesize an efficient `memcmp` from that. int memcmp(void *restrict p1, void *restrict p2, size_t n) { uint8_t *diff = memdiff(p1,p2,n); if (!diff) return 0; return diff[0] - p2[diff-(uint8_t*)p1]; } The only extra work that function would need to do is the computation of the address `p2+(diff-p1)`, which the comparison logic might already have available. By contrast, there's no way to use the existing `memcmp` to synthesize `memdiff`. BTW, the Standard should clarify whether `strcmp` guarantees that it won't read any portion of either string past the first mismatch. I think it's reasonable to say that `memcmp` should be allowed to read `n` bytes from each operand, but it's unclear whether e.g. `char foo[3]="yes"; strcmp(foo, "yeah");` should be allowed to try to read `foo[3]` or must exit without doing so given that `foo[2] != "yeah"[2]`. 
damn your skills make my stuff look like Hello World
Skill? More like my ability to spend a day following a youtube video and replicating what im seeing on screen 
&gt; A memeq function which merely reported whether two blocks were identical could be faster than one which had to determine the location of the first mismatch. The guarantee that the sign of the result from memcmp will reflect the values involved in the first mismatch, however, effectively compels the system to find the first mismatch whether it reports it or not. Well, I can imagine an implementation that just subtracts big-endian words and returns that value whenever it's not zero. There would be extra work to isolate exactly which byte was different. &gt; BTW, the Standard should clarify whether strcmp guarantees that it won't read any portion of either string past the first mismatch. I think it's reasonable to say that memcmp should be allowed to read n bytes from each operand, but it's unclear whether e.g. char foo[3]="yes"; strcmp(foo, "yeah"); should be allowed to try to read foo[3] or must exit without doing so given that foo[2] != "yeah"[2]. I believe the standard does specify that `strcmp(foo, "yeah")` is undefined behaviour. This is not so explicitly stated, but `strcmp()` is described as &gt; The strcmp function compares the string pointed to by s1 to the string pointed to by s2. And earlier in that section, it says &gt; A string is a contiguous sequence of characters terminated by and including the first null character. ... In contrast, the `strncmp()` description is careful not to mention that its arguments are strings: &gt; The strncmp function compares not more than n characters (characters that follow a null character are not compared) from the array pointed to by s1 to the array pointed to by s2.
Check out GObject... or do you mean a library comprised of object files? Your request is phrased ambiguously. As for a web framework, I’m pretty sure most were written in C up until recently, though I haven’t really messed with that.
Well if you get really into them... but that goes for anything.
I would bet that the 'union hack' is part of the problem. If valgrind is telling you not to do something, it's probably not wise to switch to a union to try to get around valgrind's complaints. &amp;#x200B; &amp;#x200B;
alignment to what? a cpu that doesn't exist yet? The problem is in porting existing binary protocols. Its that nonsensical 'optimized by alignment' in silence that breaks things in interesting and fun ways.
Better version of 'newTree': &amp;#x200B; Tree newTree(size\_t tsize){ Tree tree = {0}; tree.tsize = tsize; return tree; } &amp;#x200B; What exactly are you doing with 'tsize'? &amp;#x200B;
alignment (*(cubes_triangle + 0)).vertex[0] = (vector3) {0.0f, 0.0f, 0.0f}; (*(cubes_triangle + 1)).vertex[0] = (vector3) {0.0f, 1.0f, 0.0f}; (*(cubes_triangle + 2)).vertex[0] = (vector3) {0.0f, 1.0f, 0.0f};
No.
In which cases of C does it differ? Any loops? Any basic function?
If you're referring to something like this: if ( int i = 0; i &lt; size; i++ ) // ... if ( int i = 0; i &lt; size; ++i ) These do the same thing, and which you choose to use is a matter of style preference. However, the reason they are the same is that there's nothing else going on in that statement. If the statement is more complex, `++i` and `i++` do different things. For example: int i = 10; printf("%d\n", i++); // Prints 10, but now i is 11 printf("%d\n", ++i); // Prints 12, and now i is 12
On any CPU that could possibly exist that would support `uint8_t`, `uint16_t`, `uint32_t`, and `uint64_t`, any even offset will satisfy the alignment requirements for a `uint16_t`, any multiple-of-four offset will satisfy the alignment requirements for a `uint32_t`, and any multiple-of-eight offset will satisfy the alignment requirements for a `uint64_t`. Some CPUs may accept placements in addition to those listed (e.g. on most 32-bit platforms, offsets that are multiples of four will satisfy the alignment requirements for `uint64_t` even if they aren't multiples of eight, but the offsets described above will meet alignment requirements for *all* CPUs that support the indicated integer types. 
It differs when you use the result, instead of just using the side-effect. int i1 = 1; int i2 = 1; int a = i1++; int b = ++i2; `i1` and `i2` end up with the same value (2) `a` and `b` have different values (2 and 1, respectively)
I don't see how sizeof is relevant here. We were only talking about index notation vs. add and dereference.
...they just group data together in the same order the members are listed + taking care of aligning members to their respective data type alignment. It's literally just that.
sizeof doesn't dereference though, that's why it can be different. This is dereferencing, hence the equivalent array-notation can be used.
Pre and post increment differ when using them in recursive function calls
That, while truish, is not the only way in which they differ.
&gt; Well, I can imagine an implementation that just subtracts big-endian words and returns that value whenever it's not zero. There would be extra work to isolate exactly which byte was different. The overall cost of the function will generally be dominated by the cost of finding the first word that doesn't match. Allowing the function to report that a mismatch occurred without having to know whether it had found the first may reduce that time significantly on some architectures. If, for example, some later portions of the blocks are expected to be in cache but earlier portions aren't, it may be useful to compare the parts that are in cache first and, if they don't match, not bother waiting for the earlier parts to get fetched. If one is worried about performance, one should worry more about the time spent examining things that turn out to be equal than the time spent examining the last word to find out exactly where any differences occur.
Was just trying to give an example of when they are different
No. The error/warning is different. It's a warning about unitialized values that do get initialized. It was fixed in the newest version, but I haven't updated. It's a false positive, nothing more. I even have the link to the git issue about it somewhere. I'd have to update manually since my linux distro doesn't stay on the bleeding edge. The issue is, I assign the Tree's root element in a function, then outside of the function my assignments are ignored. The loop runs for 15 iterations -&gt; 15 mallocs. If you remove the failing assert, you will get 15 mallocs from valgrind.
Noted. tsize, aka type size is the size of the type within the tree. If it's a tree of ints, I'd use newTree(sizeof(int))
It _may_ differ for _certain_ architectures that are no longer in use. Some professors, depending on how hold they are, will stand and try to convince you that one _is_ somehow faster than the other -- this is almost certainly no longer true, but they love to throw this one out there.
I don't see where you're allocating memory for the elements, or copying them. It looks like you're just sticking the pointers in? Honestly, this code is huge and messy. You need to debug each function individually.
Where do you use 'root'? I don't see anywhere that you assign anything to that other than NULL.
&gt;The issue is, I assign the Tree's root element in a function, then outside of the function my assignments are ignored. The loop runs for 15 iterations -&gt; 15 mallocs. If you remove the failing assert, you will get 15 mallocs from valgrind. I don't see 'root' being written to anywhere in that code.
Structs are much more than just the alignment scheme they represent. Their usage can be much more complex than just fancy arrays. (Data Structures, anyone?)
I was offering some reasoning as to why OP may be averse to that. Never said I agreed with their decision to do it that way, nor do I really know for sure if that’s the reason why, but since they didn’t answer, I don’t think arguing will get us anywhere.
Maybe a r/unixporn user.
Good example. It's hard to find useful example of preincrement. Ifeel like it used to make sense but the website's examples confused me more by talking about when addresses are accessed. 
This is good
I can't stop staring at it.
This is the kind of guy I wish I had as a too late. Instead I got Brad.
If only any of that held any water. Have you ever moved between compilers on the same platform? Get ready for alignment issues. Going from Watcom to Microsoft to GCC, then back to Microsoft introduced so many of these things it's insane.
Inside addTree you assign an uninitialized pointer (alpha.root) to 'current'. This is undefined behavior. I suspect that is the immediate cause of your problem. Anything that happens after that is up for grabs and your malloc is probably getting lost to the ether, so to speak. Also, +1 for the person who said to re-write your newTree function. It seems like you're using raw to zero out the memory inside your variable? Not everyone will have that as 32 bytes, and it may introduce another bug for people trying to run your code and help answer questions.
Inside treeAdd you have Bnode *current = self-&gt;root You're assigning NULL to current. When you malloc memory to current, that information isn't stored at the memory address of self.root.
Hilarious. And educational too. I just learned about the LOLCODE programming language. Reading it is pretty hilarious, and it doesn't help that I'm high right now.
For those who do not know the [C Programming Language](https://en.wikipedia.org/wiki/C_(programming_language)), this program will print one "r" and then print an infinite number of "e"'s after it. I think it is kind of pretty the way the characters are arranged in a triangle and then the bottom part (roughly) shows what it will output. Here it is without those pesky `#DEFINE` statements: #include &lt;stdio.h&gt; int main(){ putchar('r'); while(1){ putchar('e'); } }
For other fun code to look at: [http://uguu.org/sources.html](http://uguu.org/sources.html) &amp;#x200B; This is a friend of mine who frequently wins in the ioccc contest.
What Youtube tutorial you've followed ?
This one: https://youtu.be/ih20l3pJoeU The guy is freaking awesome, you should check him out
I use pointers instead of array, since arrays are basically macros for pointers, and I like explicitly stating it. Oh and the + 0 is indeed for consistency / code allignment.
They can really help with minimizing branch misprediction and cache misses for example.
The request URI [must be an absolute path or absolute URL](https://tools.ietf.org/html/rfc2616#section-5.1.2). Try adding a leading `/`.
Psst, you're in r/C_Programming... But thanks for converting it.
well the google style guide recommends ++i when it doesn't matter if you use i++ or ++i. But it's one of the points that you can argue about. The reasoning behind it is that i++ might be worse but to be honest shouldn't be with a decent compiler (i haven't tried it myself). i++ might have to make a copy. The old value is in the copy that gets passed while value of the variable gets increased. old_i = i i = i+1 foo(old_i) this doesn't happen with ++i ++i i = i + 1 foo(i) that being said i am pretty sure a compiler should optimize this. 
But thast's not the same code
LOLCODE is hilarious, i remember laughing for couple hours after realizing this stuff even exists 
Parser generators usually don't generate code that produces a parse tree. They generate code that performs the appropriate user-provided action for each nonterminal (the lexer takes care of terminals). It is up to you to define data structures and write code fragments that produces a parse tree.
I can't see one, but you definitely have a memory leak and possibly use-after-free. Also, this: item_pop-&gt;val1 = item_temp-&gt;val1; item_pop-&gt;val2 = item_temp-&gt;val2; can be written more simply as *item_pop = *item_temp; but the best option is to just return `item_temp`.
Clang is just not clever enough to figure out that what you are setting in \`if ( !p )\` to \`flags\` will cause \`if ( ! (\*flags &amp; 0x02u) )\` to not take the branch
&gt; memory leak You mean item_temp = (struct item *)ptr_ring_consume_any(buffer); ? &gt; use-after-free Which line ? 
Here's what happens: Some part of your code, call it `foo()`, calls `push_circ_queue()` with a pointer to a `struct item`. That `struct item` is either static, automatic or allocated. Later, a different part of your code, call it `bar()`, calls `pop_circ_queue()` with a pointer to a different `struct item` and `pop_circ_queue()` pops the previos `struct item` from the ring and copies its contents into the one provided by` bar()`. * If the struct is static, the code is valid, but you can't reuse the same `struct item` until you know for sure that it's no longer on the ring, but you don't know when that is. So in practice, you can never reuse it until the ring is empty. This is actually equivalent to the allocated case (see below). * If the struct is automatic, you have the same issue with reuse within the lifetime of the invocation of `foo()` that pushed it to the ring, and you invoke UB if it's still on the ring after `foo()` returns. * If the struct is allocated, you have a memory leak because `pop_circ_queue()` neither frees it nor returns it so `bar()` can free it.
Yes, and it's called [syntax-directed translation](https://en.wikipedia.org/wiki/Syntax-directed_translation). Now it would be a good time for OP to pick up the dragon book and read the SDT chapter.
Nope, no matter their usage they will remain just that. Using them in data structures doesn't magically make them more abstract or complex.
There is absolutely no point in doing that. Neither from a theoretical, nor from a practical perspective. It just looks weird.
This is a bit complicated and not something you can explain in a comment. Typically, a whole semester-long class in university is dedicated to explaining how this is done.
Also, don't fake the user agent. If you write your own program, use your own custom user agent string.
You have been asking essentially this question twice already. What has changed since your last two posts to make it worth reposting the question?
I would be happy if someone makes an esolang based on this (think Br\*infuck).
See [riffa\_driver.c](https://paste.ubuntu.com/p/g93K5cZXCb/) which calls `push_circ_queue()` and `pop_circ_queue()` Note: Due to instantiation of two ptr\_ring , the caller had defined some structs with the names: item\_send\_pop, item\_send\_push, item\_recv\_pop, item\_recv\_push
Right, so this is effectively the same code as last time, and it's just as pointless now as it was then. If the driver already has an array of items for each ring, you can dispense with the entire `ptr_ring` and `circ_ring` mess and just use a single index for each ring.
Go to okay the source code
It would be challenging to write a non-trivial program in C without a pointer appearing somewhere, especially programs that need to process arbitrary-sized inputs. So just programming anything in C will expose you to pointers. I never heard of this book, so I took a quick look at it. It's not bad, but it does make the same mistake with `printf` over and over throughout: printf("%d\n",sizeof(char)); printf("%d\n",sizeof('a')); This is undefined behavior and so no particular behavior is guaranteed. The correct format specifier for `size_t` is `%zu`, not `%d`. It even introduces `%zu` earlier in the book, but then fails to use it. This particular example also has a second mistake, saying that the second will print 4. The correct answer is that it will print the same thing as `sizeof(int)` which isn't necessarily 4 (something *else* that is also covered earlier and then ignored). Some of the practical information in the book is out of date — discussion of specific GCC behaviors on x86-32, etc. Some of this stuff was already out of date even when the book was first published in 2013. Most of my other complaints are stylistic. For one, the book insists on casting the return of `malloc`. There's a brief discussion of this noting that it's not necessary, but its reasons are dubious. This isn't C++, don't explicitly cast the pointer returned by `malloc`. At one point it introduces `alloca` and VLAs. While it does note that `alloca` is non-standard, it doesn't discourage VLAs. The correct thing to do is introduce these concepts, then immediately tell the reader never to use them because, just like `gets`, there's no safe way to do so. The author can't make up their mind about whether to put the `*` next to the type or the variable name. It varies throughout the book, even within the same block of code. A lot of the examples are sloppy like this. There's no discussion of integer overflow when allocating memory. This is one of the most common mistakes when using dynamically-allocated memory and it has serious security consequences. It's very strange to omit this in a book about pointers. There's even a security section at the end of the book, but still no mention. More time should have been spent addressing aliasing. It's only mentioned briefly near the end of the book. I dislike that `typedef` is *always* used when defining structs, but that's me being really picky. The book doesn't omit the tag when doing so, either. There's no discussion of tags, so perhaps the author didn't know? 
#### FEATURES - Modes - Basic, detail (default), disk usage analyzer (du) - File picker, vim (or neovim) plugin - Navigation - Familiar, easy shortcuts (arrows, `~`, `-`, `&amp;`) - *Navigate-as-you-type* with auto-select directory - Contexts (_aka_ tabs _aka_ workspaces) - Bookmarks - Pin and visit a directory - Sorting - Directories always listed on top - Sort by file name, modification time, size - Numeric order for numeric names (visit _/proc_) - Search - Instant filtering with *search-as-you-type* - Mimes - Open with desktop opener or specify a custom app - Create, list, extract archives (needs (p)atool) - Open all text files in EDITOR (optional) - Information - Detailed stat-like file information - Media information (needs mediainfo/exiftool) - Convenience - Create, rename files and directories - Select files across directories - Copy, move, delete selection - Transfer files using lftp - Batch rename/move/delete (needs vidir) - Show directories in custom color (default: blue) - Per-context directory color - Spawn a subshell in the current directory - Run a command, launch applications - Run custom scripts in the current directory - Repository of custom scripts - Run current file as executable - Change directory at exit (*easy* shell integration) - Edit file in EDITOR or open in PAGER - Terminal locker integration - Unicode support - Highly optimized, static analysis integrated code - Available on many distros
I use mimeopen to open files. Is it possible to specify a custom file opener?
Omg. I can't believe I missed that, ty! 
Yeah, I switched it thinking it was blocking my request because it didn't recognize the user agent or something weird.... It's almost always the simplest solution I guess
Yes, you have to export `NNN_OPENER`. It's available on master. The feature was removed once and added back last night. :)
Awesome! Thanks!
That really only applies to classes with an overloaded `operator++`. In that case, Google's style guide has a point, because some iterators might be less easy for the compiler to optimize out the copy. But this is /r/c_programming, and none of that applies here.
I have that book also, and while it's useful, your review is pretty accurate, as I felt the same regarding most of what you said when I read it.
Also look at [Ted Jensen's Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/~tjensen/ptr/)
I mean.. we have Ook!, Which is basically BF but using combinations of "Ook.", "Ook?", And "Ook!", So.. a similar concept but with variations on a reeee might work. ....someone get me my laptop, I'm on this.
Just looked at the C assembly of if( ++num2 == 2){a=-10;} if( num1++ == 1){a=10;} and it doesn't agree with you
I know your question has already been answered but I couldn't help but add a small optimisation: char* request_packet = calloc(4096, sizeof(char)); int packet_len = sprintf(request_packet, "GET %s HTTP/1.1\r\nUser-Agent: %s\r\nHost: %s\r\nAccept: */*\r\n\r\n", url-&gt;path, "curl/7.47.0", url-&gt;host); n = write(serv-&gt;sockfd, request_packet, packet_len); As `sprintf` returns the number of characters it writes (excluding any null terminators) there's no need to use strlen.
Took me a while to figure it out. What’s wrong with “just using if(!p){}else{}” in this code? Cleaner, easier to read and clang will more likely understand it? 
That makes sense. If the base case is fundamentally incorrect, then following cases where I add more elements would be incorrect as well. Rather than reassigning the node, should I make a pointer to the pointer? Should I use memcpy instead of the assignment?
Oh cool ty! I didn't think to check its return value when googling
Just do it!
`cat tree0.c | grep -n root` `33: Bnode* root;` `56: self-&gt;root = NULL;` `67: Bnode *current = self-&gt;root;` `79: else if(memcmp(self-&gt;root-&gt;elem, elem, self-&gt;tsize) &gt; 0){` `82: else if(memcmp(self-&gt;root-&gt;elem, elem, self-&gt;tsize) &lt; 0){` `106: assert(alpha.root != NULL);` `111: Bnode* node = alpha.root;` 7 lines out of 122. That's like 6% of the whole file... did you even look before you posted? 
He sets it to NULL. He never sets it to anything else. Yes, I \_did\_ read the code.
That output is pretty misleading since all optimization is disabled. Enabling any optimization will result in equal code. 
[You already reported this 3 months ago](https://www.reddit.com/r/C_Programming/comments/9jl3w1/bug_in_clang_static_analyzer/). I am not sure if someone reported the bug already.
Can you give an example of a non-contrived compiler that supports the indicated types, whose alignment requirements would not be satisfied by the above?
No worries, you might want to use `snprintf` instead of `sprintf` so you can make sure you don't accidentally overflow your buffer too.
Something seems fishy. If the first `if` were `if (p)` instead of `if (!p)` then I could see what the compiler is complaining about. Consider the following similar snippet (use same types as in your example): S foo; void f( uint8_t *flags, S *p ) { if ( p != &amp;foo ) /// ****1 { *flags |= 0x02u; } if ( ! (*flags &amp; 0x02u) ) { char const *q = p-&gt;prompt; /// ***2 } } The only change I've made is in the first marked line. With the code as shown here, clang could reason that the only way `q` can get assigned is when `p` is equal to `foo`. It could thus replace the second marked line with `char *q = foo-&gt;prompt` if so inclined [in fact, I think `p-&gt;prompt` would be just as fast, but it would have the option to make the replacement]. If the first marked line had been `if (p)`, or `if (p != 0)` then the same logic would allow the compiler to replace the second marked line with `char *q = ((S*)0)-&gt;prompt`. In the days when the choice of how to process Undefined Behavior was recognized as a Quality of Implementation issue [which is--according to the published rationale documents--what the authors of the Standard intended], compilers that were intended to be suitable for low-level programming would process actions like the above in the same fashion as if they had no idea whether or not they invoked UB, so as to trigger any behavior defined by the execution environment. Clang, however, is warning that it has no idea how to generate code for the second marked line above because, from its perspective, that line can never have any meaning. 
How exactly would they differ assuming the implementation of the architecture's C compiler is standard-compliant?
On some old architectures, preincrement was slightly faster than postincrement. 
So the result of the program would be the same, but its efficiency would be affected. That makes sense, thanks.
&gt; the contents doesnt matter The contents *absolutely* matters, it's just that the structure and actual data of those contents are not supposed to be understood or manipulated by the caller. However, it definitely matters to `sendToStream()`, which wants to make sure it gets passed a `struct STREAM_THINGIE` rather than a `struct FILE_THINGIE` or `struct OBJECT_THINGIE`. Using a `void*` for that parameter completely bypasses typechecking.
Sure, without any optimizations at all the compiler will produce whatever code is easiest and fastest to compile. It won't even *try* to remove the copy. But enable even minimal optimizations [and all major compilers produce the exact same results](https://godbolt.org/z/vrNXxo).
Ah good call! 
Early days of Unix?! That was almost 50 years ago! You keep making arguments based on rationalizing C's syntax. What I was saying is that it's 2019, and what I observe most software groups and projects *actually doing* is using typedefs for structs.
That...that is some wallpaper you got there. :)
Oh no! It's the image from the Youtube video.
Motorolla 68000 for example had post-increment and pre-decrement addressing modes for single operation use, but the opposite would take multiple instructions. In that case i++ and --i were much more efficient than ++i and i--.
You could use a double pointer. Then *current* would store the address of the variable self-&gt;root. You would have to add another level of indirection for the rest of the uses of *current* in the function. Remember that the -&gt; operator has a higher precedence than the /* indirection operator, since you'll be using both with *current*. Stylistically, I personally wouldn't do that. The variables *current* and *previous* are logiclally indicative of the same type thing -- a node. Using a double pointer on one makes the code less self-documenting and possibly confusing to read. Using a double pointer on both means you're using unneccessary indirection on *previous* to the same effect. My choice would be to separately code a base case where you explicitly malloc to self-&gt;root since you know you won't be descending through a tree and won't need the current/previous logic. Again, that's just me, but I find it to be more self-explanatory. If you do use the double pointer option, this is a place where you'd want a comment that explains why you did what you did for future readers (including future-you).
well that's what i said the first time round wasn't it?
yeah, that's what i said. But after mr. c here said this only happens in C++ i went and checked it and it clearly doesn't only happen in C++.
If you use `sprintf()` to get the length, be aware of the return code: char *request_packet = malloc(BUFSIZ); if (request_packet == NULL) error(...); int size = sprintf(request_packet,...); if (size == -1) error(...); assert(size &lt; BUFSIZ); That last check ensures the program crashes if size exceeds the size of the buffer, as `sprintf()` *can* overwrite the buffer. Better to use `snprintf()` but be aware that while it *won't* overrun the given buffer, its return code *can* be larger than the given buffer size as it returns the number of bytes it *could have written*.
&gt;I dislike that typedef is *always* used when defining structs, but that's me being really picky. I didn't read the book so I may not understand exactly what you're talking about, but what is wrong with this? I always typedef my structs because it's just easier to type, say, *Sprite player*, rather than *struct Sprite player*.
So ... I'm confused then. What about your example "doesn't agree" with my comment? The reason [Google's style guide recommends preincrement](https://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement) is explicitly because of iterators with an overloaded `operator++`: &gt; If i is an iterator or other non-scalar type, copying i could be expensive. &gt; For simple scalar (non-object) values there is no reason to prefer one form and we allow either. For iterators and other template types, use pre-increment. That distinction simply doesn't exist in C (since it doesn't have classes or operator overloading). You tried to contradict this by showing compilers can produce awful code when they're not trying to optimize anything ... which is a non sequitur in this discussion. There's still no reason to prefer one or the other for scalar values, since if you care about speed you'll be compiling with `-O1` and it won't matter, and if you don't care about speed then it doesn't matter either.
Here's what Linus Torvalds has to say about it: https://yarchive.net/comp/linux/typedefs.html Summary: it introduces abstraction that can make code harder to understand to someone not already familiar with the types. When you see a typedef type being used, is it a struct? enum? integer? Leaving it as `struct X` makes that clear. Every time the book defines a struct, it does this (including the unnecessary `_foo` tag): typedef struct _foo { /* ... */ } foo; 
 *(arry + size) = FINISH_STRING; // will put "\0" to end the string. If you allocated 1 byte of memory, this would be trying to write to `(arry + 1)`, which is unallocated memory. You should be terminating your string at `*(arry + size -1)`, or `arry[size-1]` It's hard to identify exactly why this would be giving you a breakpoint, but some kind of [buffer canary](https://en.wikipedia.org/wiki/Buffer_overflow_protection) would be a reasonable guess. char* arry = malloc(size*sizeof(char)); `sizeof(char)` is defined as 1, so you can skip this *if you and/or your shared coding standards prefer*.
**Buffer overflow protection** Buffer overflow protection is any of various techniques used during software development to enhance the security of executable programs by detecting buffer overflows on stack-allocated variables, and preventing them from causing program misbehavior or from becoming serious security vulnerabilities. A stack buffer overflow occurs when a program writes to a memory address on the program's call stack outside of the intended data structure, which is usually a fixed-length buffer. Stack buffer overflow bugs are caused when a program writes more data to a buffer located on the stack than what is actually allocated for that buffer. This almost always results in corruption of adjacent data on the stack, which could lead to program crashes, incorrect operation, or security issues. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Agreed, this is all good advice.
Ah okay, thanks. So if I'm just writing code for myself it's not too big of a deal then?
There's nothing *wrong* with it. It's purely a matter of personal preference, which is why I said I was being picky. If you prefer to typedef your structs in your own projects, then there's not really any reason to avoid it.
Thank you so much! All is good now with this mini project. if you don't mind I have another question and not sure on how many post im allowed so here it goes: I need to make a phonebook and this is the function that adds it to the phonebook: int add_number(char** phonebook, int phonebook_len) { int res = phonebook[0]; char temp[11]; scanf("%s", temp); for (int i = 0; i &lt; 10; i++) { if (!((MIN_DIGIT &lt;= temp[i]) &amp;&amp; (temp[i] &lt;= MAX_DIGIT))) // if temp[i] is not in range. return -1; } for (int i = 0; i &lt; phonebook_len; i++) if (!(strcmp(phonebook[i], temp))) return 1; strcpy(phonebook[0], temp); return 0; } in strcmp it doesn't work unless I put &amp;phonebook\[I\] (reading violation) and in strcpy it doesn't work at all. (writing violation) &amp;#x200B; what am I doing wrong?
We’re clearly talking about different things. Of course the bits and bytes are the same. That’s like saying atoms don’t amount to anything more complex because they’re just a handful of particles.
I suspect you haven't allocated space for each of the individual `phonebook` entries.
Depends on the OS, but hopefully the latter.
Yes
You sir are a genius! Thank you so much for the help.
UB in C provides high performance, which would be impossible with full specified code behaviour
Whereabouts in the linked article does the author argue for "full specified code behaviour"?
`else if` would fix this particular instance, although in the "real code" the function also goes on to do another similar block (`p` dereference behind the flag check) . The flag check can't be omitted because it might have already been set prior to entering the function.
Well... I see the problem in your version, but the line is actually `if (!p)` which seems to be significant here. The `q` line can only be reached when `p` is not null , and any inferences the compiler might take from that are entirely valid. 
Haha, forgot about that. Their online bug interface still doesn't allow you to sign up automatically, so reddit it is I guess :)
Don't know if you're answering according to the "tertium non datur" principle or not.
How can I know how the latest version of Ubuntu behaves ? 
Depends on the architecture. X86? Will suspend the thread in an io wait
We can't do much without seeing the code.
I'm not really sure what the point of this article is? for(int i=0; i &gt;=0; i++){ //try it a bunch of times if ( getpressure() &gt; DANGER)openvalve(); } Is quite simply bad code, if you're a competent C programmer you know this and you don't do it.
 struct element{ int valeur; Element* suivant; Element* precedent; };
Sorry for that, This is my Element struct : struct element{ int valeur; Element* suivant; Element* precedent; }; struct Heap (Pile in french) : struct pile{ Element* tab[10]; int ind_sommet; int nb_elements; }; My function stack : void empiler(Pile* p, Element* e){ if(p-&gt;nb_elements == 10){ printf("%s\n", "La pile a atteint sa capacité maximal."); }else{ p-&gt;ind_sommet++; p-&gt;tab[p-&gt;ind_sommet] = e; p-&gt;nb_elements++; } } The test I've did on my function main : Element* e1 = initialiser_element(1); Element* e2 = initialiser_element(2); Element* e3 = initialiser_element(3); Element* e4 = initialiser_element(4); Element* e5 = initialiser_element(5); Pile* p = initialiser_pile(); empiler(p, e1); empiler(p, e2); empiler(p, e3); empiler(p, e4); empiler(p, e5); 
Without seeing the code, I can only suggest [debugging with gdb](http://www.unknownroad.com/rtfm/gdbtut/gdbsegfault.html). Also, you use the verb 'stack' when I think you mean to use 'insert'. [Stacks are another data-structure](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) and mixing the term in when using the heap data-structure is confusing. &gt; I have created a struct for implementing a heap, which contains an array of struct element that I've also created, represented by an int. I'm not sure what you mean by 'represented by an int'. What is represented by an int? 
I think the point is that these sorts of _optimizations_ are often rather subtle and that it would be better to warn the programmer of, what is most probably an error, rather than to silently take advantage of it. I realize that this might be easier said than done... Here are links to posts with some more example you may find more compelling: [Krister Walfridsson](https://kristerw.blogspot.com/2017/09/why-undefined-behavior-may-call-never.html), [LLVM Project Blog](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html).
It is sometimes necessary that an API document a struct tag. Failure of an API to document a struct tag can sometimes create problems for clients of the API. While it may be convenient for clients to have both a struct tag and a typedef available, it does to some extent violate the "single source of truth" principle. If the Standard had a variation of typedef that says "this is the type of some kind of structure, but I'm not sure what"; it will get further refined before code uses any types that refer to it", then typedef labels might be viewed as superior to struct tags in every way. No such feature exists, however. 
https://www.learncpp.com/cpp-tutorial/27-chars/
From a quick scan of this what I"m seeing is you would use char for how little space it takes. Is that right? 
In C there is no string type, strings are an array of char.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Are you asking about C or C++? The short answer to both is that chars are not used often. As you said, there aren't very many use cases where you'd want to store a single character. They would be necessary if you were searching inside of a string, but you'd want to use a standard library function for that, anyway. In C, it would just be flat-out impossible to have strings without char, since C does not have a string type. In C++ things get a bit more complicated. C++ does have a string type, which *is* built on chars, but you can use C++ with all of that hidden away, so that you never have to deal with chars directly. (Also, sometimes people use signed char or unsigned char to store very small integers, but I think that's not what you're asking about)
Generally speaking, there is no busy wait in this situation. However, as POSIX does not specify how this is implemented, it could theoretically be a busy wait. For example, this could be the case on embedded platforms which have no way to perform a non-busy wait.
RTFM? Read the fucking manual?
There has been great fun in CPU emulation, network stack emulation among others. It's basically binary data that is expected in a format where struct alignment was decided to implicitly have certain padding that wasn't in the source. One of the 'popular' ones was SLIRP, a user mode implementation of FreeBSD's TCP/IP stack that not only has clashing symbols on many systems (because it's the TCP/IP stack) but exposes all kinds of fun in it's structures. Hours of fun packing stuff, watching implicit signed/unsigned and just renaming clashes that'd I'd only find under debugging.
i still need help :(
&gt;dispense with the entire ptr\_ring and circ\_ring mess and just use a single index for each ring. See where the push\_circ\_queue() callers are located in the interrupt handler. I presume we cannot just use a single ring index without some linux kernel function as well as locks for handling interrupt. This is why ptr\_ring data struct comes in handy in dealing with this.
 #define streq(a, b) (!strcmp((a), (b))
Then start with asking same questions. Just asking someone to dm you without providing useful information will never work in any sub. Also we are not here to do your homework for you. If you want help post the problem, what you have done so far and where exactly you are struggling. Only posting the assignment and asking for a working solution will not work either. 
are you asking a question for c++ on a c forum?
Yes, that is exactly what I did... my apologies.
where is your code? which is the problem?
Done bro. On a side note, can you please also see this question i have. This is of higher priority. [https://www.reddit.com/r/C\_Programming/comments/ah5w6m/help\_post/](https://www.reddit.com/r/C_Programming/comments/ah5w6m/help_post/)
It works via [recursion](https://en.wikipedia.org/wiki/Recursion_(computer_science)) - check out [this section](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_programs) of the Wikipedia article.
You declared 'term' static, and then recursed into the function. That means every time you call sum() the same location in memory is used to store 'term', so it is getting overwritten. &amp;#x200B;
Firstly, initialise *term* at its declaration (although this is unrelated to your issue): static int term = 0; You might be struggling with **Order of Evaluation** here: return (term + sum(x-1)); There's no guarantee that the current value of "term" is evaluated before sum() is called. For your first code snippet, it's diving into sum(), *modifying term*, then returning out of sum() and adding the *new* value of term. You just need to grab the value of term into a temporary var first: if(x) { term = (term \* 10) +1; int tmp = term; return (tmp + sum(x-1)); }
&amp;#x200B; \#include&lt;stdio.h&gt; \#include&lt;math.h&gt; \#define \_CRT\_SECURE\_NO\_WARNINGS int main() { float m, f; double GRAVITY\_CONST, mass, distance; &amp;#x200B; ; printf("Enter launch speed (ft/s) : "); scanf\_s("%f", &amp;m); &amp;#x200B; f = 3.2808399 \* m; &amp;#x200B; GRAVITY\_CONST \* mass / distance \^2; &amp;#x200B; &amp;#x200B; printf("The maximum altitude is %f km", f); &amp;#x200B; &amp;#x200B; return 0; } is what i have , [https://gyazo.com/0e9f5c312e805b1ee47fa8705491a860](https://gyazo.com/0e9f5c312e805b1ee47fa8705491a860) is the problem &amp;#x200B;
the only error im getting right now is the \^2, but im not sure how to do exponents
This sub is for C, not C++; try asking in /r/cpp_questions instead.
Microsoft Word
If the struct definition in the source includes members at offsets that are not multiples of their worst allowable alignment requirements, that can happen. The Standard, however, requires that the size of an object be a multiple of its alignment requirement, which in turn means that a type cannot have an alignment requirement larger than its size. If a conforming implementation defines `uint32_t`, its alignment requirement must be 1, 2, or 4. There are no other choices. While the Standard would allow an implementation to impose an alignment requirement for a struct or union that is coarser than that of its coarsest member, the only time an implementer would reasonably consider doing such a thing would be on a hardware platform which, for optimal efficiency, would require a different representation for `char*` and `int*`. While there have certainly been C89 implementations for such platforms, I'd be surprised if any such platforms have received full conforming C99 implementations, much less C11. Perhaps it's time to officially recognize a few more dialects of C. If someone needs a language for use with an obscure hardware platform that can't uphold the same expectations of commonplace ones, it may be useful to have a standard for an "Unusual C implementation" which would be allowed to use things like non-two's-complement integers, different pointer representations for different types, etc. but then say that programmer targeting a "Commonplace C Implementation" may assume that integers are two's-complement, all object pointers have the same representation, `char` is 8 bits, structure members will be placed at the lowest offset satisfying their alignment, etc. The fact that it may be useful to have a recognized C dialect that can handle unusual platforms should not imply that programmers who aren't interested in such platforms should have to allow for their quirkiness. 
I don't know why but your code have a lot of "\\" inside, also have a ";" before one printf(...) for the square you could use (distance \* distance)
\#include&lt;stdio.h&gt; \#include&lt;math.h&gt; \#define \_CRT\_SECURE\_NO\_WARNINGS int main() { float m, f, ft; double GRAVITY\_CONST, INITIAL\_VELOCITY, SINE\_OF\_LAUNCH\_ANGLE, ACCELERATION\_DUE\_TO\_GRAVITY; &amp;#x200B; printf("Enter launch speed (ft/s) : "); scanf\_s("%f", &amp;m); &amp;#x200B; f = ft/3280.8; &amp;#x200B; GRAVITY\_CONST(INITIAL\_VELOCITY\*INITIAL\_VELOCITY)(SINE\_OF\_LAUNCH\_ANGLE\*SINE\_OF\_LAUNCH\_ANGLE) / (ACCELERATION\_DUE\_TO\_GRAVITY\*ACCELERATION\_DUE\_TO\_GRAVITY);m &amp;#x200B; &amp;#x200B; printf("The maximum altitude is %f km", f); &amp;#x200B; &amp;#x200B; return 0; } is what i have now
&gt; p.s. You should also initialise term at its declaration Static variables will always be initialized, at least in C99 and newer. 10 If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then: — if it has pointer type, it is initialized to a null pointer; — if it has arithmetic type, it is initialized to (positive or unsigned) zero; — if it is an aggregate, every member is initialized (recursively) according to these rules; — if it isaunion, the first named member is initialized (recursively) according to these rules. 
first, and sorry for this, your code is really ugly... second. initialize all your variables: `float f = 0;` `float ft = 0;` &amp;#x200B; in this new code you are using ft variable before asing any value
i know, but for parsers to generate code they first need a structural representation of the data they receive right? such as an AST or similar, then they operate according to that AST or similar to output the parser
Yep, overflowing an 'int' is UB.
Read The Full Manual (page)
A 'buffer' as a concept does not pertain to any programming lamguage. 'String' is part of the c++ libraries.
No blog spam please. Though I must admit, this tutorial is of higher quality than the usual ones, it still contains an obnoxious amount of advertisements, which is why I decided to remove it anyway.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
The fundamental problem is that the Standard was written to codify a "language" [actually a family of usefully-diverse dialects] that was defined more by practices rather than formal design, and there is thus a substantial difference between the language the Standard was *written to describe*, and the language that it *actually specifies*. This stems in part from the f\act that the Standard makes no distinction between code which should be portable to many but not all implementations, and code which would only be meaningful on one. It also stems in part from the fact that the authors of the Standard made no attempt to specify all the corner cases that implementations should be expected to handle, in cases where all known implementations *did* handle them. Consider, for example, the following function: void* qmemcpy(void *restrict dest, void const *restrict src, size_t n) { if (!n) return dest; if (src==dest) return memmove(dest, dest, n); // Complies with rules for "restrict" return memcpy(dest, src, n); } If one needs a function that behaves like the above in all defined cases, and that one wishes to chain to the built-in `memcpy` whenever possible, are the two `if` statements necessary, or do they handle cases that `memcpy` should be expected to handle? Note that the `memmove` is used to avoid making the function handle the scenario where it is not possible to write `n` bytes to `dest` but `src` holds the same address--a scenario that many `memcpy` implementations would not normally handle. If someone had asked the authors of C89 why they didn't explicitly specify that `dest` and `src` are ignored if `n` is zero, which of the following responses would seem most plausible: 1. The act of "copying" zero bytes is naturally a no-op which doesn't involve any address, and the act of copying a block to itself would work for any plausible implementation of `memcpy`; it's sufficiently obvious how `memcpy` should work in those cases that there's no need to waste ink saying so. 2. In the unlikely event that there were a platform whose customers might benefit from having `memcpy` handle those cases in unusual fashion, someone writing an implementation would be better equipped than the authors of the Standard to determine whether those customers would benefit more from the common behavior or something else, and if no such platform exists any time contemplating such hypotheticals could be better spent on other things. 3. Leaving the behavior undefined in those cases would allow compilers to propagate inferences about the values of `src`, `dest`, and `n` into the calling code. I would guess some members of the Committee might have said #1 and some might have said #2. I doubt any would have said #3. For the Standard to stop doing more harm than good, it needs to do one of two things: 1. Make more explicit the fact that it isn't trying to be a full and complete behavioral specification, and amplify the point that it deliberately allows implementations which are targeted toward specialized purposes or unusual hardware to behave in ways that would make them unsuitable for most other purposes. The fact that the Standard allows a "conforming" implementation to do something does not mean that such behavior would not render an implementation far less useful than it should be, nor that programmers should be called upon to make any effort to work with such an implementation. 2. Recognize categories of "optionally defined" behaviors, along with a means by which code can test for them. This approach would allow more optimizations than are presently possible, especially if programmers could test for loose behavioral guarantees. Suppose, for example, that one wants to find "interesting" objects, and performance is going to be dominated by a function which must return 1 for any interesting object and should return 0, as quickly as practical, for as high a fraction of uninteresting objects as possible. Within that function, one needs a function with the following specs: int mulDiff(int x, int y, long long z); * If the arithmetic product of x and y is within the range of `int` and is less than z, return 1. * If the arithmetic product of x and y is within the range of `int` and is not less than z, return 0. * If the arithmetic product of x and y is not within the range of `int`, return 0 or 1 (chosen at the implementation's leisure) with no side-effects. If an implementation could guarantee that integer multiplication and comparison will never have side-effects without having to guarantee that integer values always wrap at `INT_MAX`, then writing the function as `return x*y &lt; z;` would on many platforms allow more efficient straightforward code generation than `return ((long long)x)*y &lt; z;`, but also allow optimizations that would not be possible if it were written `return (int)((unsigned)x*y) &lt; z;` The only time the more aggressive "Beyond the Guidelines" optimizations can pay off is when either (1) there are some inputs for which it would be acceptable for the program to behave in completely arbitrary fashion, including giving control to whoever composed those inputs, or (2) an optimizer has failed to recognize that there are no inputs that can cause certain conditions, but benefits from assuming they cannot occur with the aid of UB-based inferences. The former won't occur outside some specialized application fields. The latter might sometimes occur, but I doubt the benefits will often be sufficient to justify the costs outside contrived scenarios. 
Parsers don't generate code. 
On which architectures is this different?
Last time, you insisted that there were no concurrency concerns. 
Compilers can gain real optimization benefits from being allowed to assume certain laws of arithmetic will hold using signed integer types, and I would have no beef with a compiler that would process a `for` statement such as the above as an endless loop. On the other hand, I do have a major gripe with the notion that a compiler given a function like: unsigned mulMod65536(unsigned short x, unsigned short y) { return (x*y) &amp; 0xFFFFu; } should use the fact signed integer overflow "can't" occur to draw inferences about the values of x and y--something which gcc in fact does. Note that the authors of the Standard have stated in their rationale how they expected commonplace implementations to handle the above. To wit: they expected that most `int` and `unsigned` operations, including multiplies, would be treated identically except when the result is used in certain ways, and they expected such treatment without regard for whether the MSB of the result was set. Since the above code does not use the result in any of the ways listed by the authors of the Standard, that would imply that they expected implementations to treat the multiply as unsigned (and such expectation almost certainly played a significant role in their decision not to include a rule that would force compilers to process constructs like the above using unsigned arithmetic). 
You will have to shift all elements after ‘y’ to the right one and set the element after ‘y’ to a space
If you don't want to write an array shifting function, try using the C library function *memmove(void\* dest, void\* src, size_t num)* from [&lt;string.h&gt;](https://en.cppreference.com/w/cpp/string/byte/memmove). It does the thing you need to do.
Google "linked list". Dynamic change of array size (with realloc) is another solution. 
 #include &lt;stdio.h&gt; int main() { char b[] = "myself"; char *ptr; int i, c; for (i = 0; b[i]; i++); char a[i + 2]; /* "%.*s (two chars of b) + " " + %s (rest of b) */ (void) snprintf(a, i + 2, "%.*s %s", 2, b, &amp;b[2]); (void) printf("%s\n", a); return 0; } Get the string-size ob b (for loop), create a new buffer (char \*a) and use a function (or write it yourself) to get b into a. I used snprintf() to get everything into char a\[\]. 
It would be much simpler but in class they didnt teach us realloc only malloc so Im not sure if im allowed to use realloc.
I second this implementation. Linked list is the best way to do this sort of thing and it's really quite simple to learn how to implement.
 #include &lt;stdio.h&gt; int main() { int i = 0; char b[] = "myself"; for (; b[i]; i++); char a[i + 2]; while(i--) a[i] = b[i]; for (; b[i]; i++) { if (i == 2) { a[i] = ' '; a[i + 1] = b[i]; } else if (i &gt;= 3) { a[i + 1] = b[i]; } } (void) printf("%s\n", a); return 0; } Here without the usage of a function to fill a\[\]
Hm? That's a weird limitation.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct pb { char *number; struct pb *next; }; #define NUMBER_SIZE_MAX 50 int main() { struct pb *head, *current; head = current = malloc(sizeof(struct pb)); int opt = 1; /* * Filling the struct pb */ while (opt) { (void) printf( "Choose:\n" "1: New Number\n" "0: Cancel\n"); (void) scanf("%i", &amp;opt); switch(opt) { case 0: break; default: (void) printf("New number:\n"); head-&gt;number = malloc(NUMBER_SIZE_MAX); (void) scanf("%s", head-&gt;number); head-&gt;next = calloc(sizeof(struct pb), sizeof(char)); head = head-&gt;next; break; } } head-&gt;next = NULL; /* * Output of struct and free()'ing it */ while (current-&gt;next) { printf("%s\n", current-&gt;number); free(current-&gt;number); head = current; current = current-&gt;next; free(head); } return 0; } I didn't do a single error-check (readability) and scanf is able to overflow &amp;#x200B; Please don't use it as it is
Creating a series of "C Language" Reference Card on GitHub as I go through each chapters. /r/C_Language
&gt;push\_circ\_queue() callers are located in the **interrupt** **handler** This is not directly related to locks if you were referring concurrency as the need of locks.
That picture /r/indianpeoplegithub
Just because it's in an interrupt handler doesn't mean it needs a lock. It only needs a lock (or some other synchronization primitive) if multiple instances of the interrupt handler can run in parallel. And you don't need a lock at all if the index is atomic. Speaking of which, as written, your code does not support multiple instances of the driver, since it relies on a global array, and no amount of locking will alleviate that.
Er... `strlen()` is a thing.
Yes, it is and it was in my code. I didn't want to use a big collection of functions to explain a simple problem. &amp;#x200B; Another way: (I hate the fact, that this is working\^\^) #include &lt;stdio.h&gt; int main() { char b[] = "myself"; int i = sizeof(b); char a[i + 1]; for (;i != -1; i--) { switch(i) { case 0: case 1: a[i] = b[i]; break; case 2: a[i] = ' '; a[i + 1] = b[i]; break; default: a[i + 1] = b[i]; break; } } printf("%s\n", a); return 0; } 
So you allocate the memory for the new phonebook once. You need to free the old phonebook once. So shift the free() call to outside the loop. You also need to think about the size of the phonebook entries. Currently you are allocating a single character to each phonebook entry. This is enough space for the string terminator character but no content.
I actually switched to `ptr_ring` because [original circ\_queue.c](https://github.com/KastnerRG/riffa/blob/master/driver/linux/circ_queue.c#L110) is too slow. `ptr_ring` is way more speed-efficient. And if you look into original `circ_queue` code, I suspect all those `atomic` functions are slowing it down. I have eliminated the slowdown factor of the modulo operator within `queue_count_to_index()`
[https://idownvotedbecau.se/imageofcode](https://idownvotedbecau.se/imageofcode)
Probably none. But it can be and I do t want to claim anything I don't know.
https://www.youtube.com/playlist?list=PL07B3F10B48592010 follows the book "Programming Challenges" by Skiena
thank you!
Thanks for the information, I'll try to format my code next time as plaintext! This helped a lot, thank you very much! The 'stack smashing detected' error really disappeard after I changed the str array from 3 to 4 chars. Furthermore the flush stdin worked with while((c = getchar()) != '\\n' &amp;&amp; c != EOF); &amp;#x200B; So the only thing I'm missing now is the correct way to end the program. This also is a perfect support, I can see what you mean and will implement it later. But I have a question here: &gt; When a mine is marked correctly, decrement the mine counter. Did you really mean decrement? It does make sense for me if I'll increment the mine counter and then check if it is equivalent to the number of mines placed. Again, thank you very much!!! &amp;#x200B;
I've always really liked this lecturer, and I think the course teaches you some fundamental (and especially important in C) things about how a computer works (cpu, memory) and how a program works (stack, etc) that a lot of programming classes leave out: https://www.youtube.com/watch?v=hE7l6Adoiiw&amp;list=PL6B940F08B9773B9F For some of the trickier particulars, I've found this FAQ particularly helpful, and kind of secretly one of the best ways to test your understanding of C (by trying to answer the questions yourself without clicking through to the answers first): http://www.c-faq.com/
I intentionally left the mine and open-cell counters portion somewhat ambiguous/misleading so that you would have a direction to head in without the specifics of a working implementation. There's more than one way to accomplish your goal, so pick the one that makes the most sense to you.
Clearly not the same thing, there are very complex forces acting between atoms. When the whole system is considered, the mathematical equations are mind-boggingly complex because of the intricate interactions between them. The whole analogy is bad. If i define a struct in a context it has not effect on another struct, it doesn't "interact" with it. They are a well defined language feature and they are context independent: whenever the compiler sees a struct it tells it "put these things in the same order in memory, and take care of alignment for me". This doesn't change if you use the struct for a linked list, a B tree, a hashtable, or whatever else ds you have.
Reconsider the size that you're passing to `malloc`.
I did it and it's working now! Thank you very very much! That really helped me a lot!!!
Glad you got it.
part of the assignment is to be able to delete phone numbers from the phone book in linked list can I remove 1 term from the list and keep all the rest linked?
You can remove, append, prepend, insert, split, join, pop etc. It will be easier to remove elements with doubly-linked list.
Even on some 4MHz MCU there is probably a way to set an interrupt when a network packet is received. The last thing you want to do is to spin in a loop and consume extra current because of that.
Yes indeed, this is not an issue on most systems and as I said, it can be safely assumed that no busy wait is performed. It is however not unthinkable that there is an implementation that performs a busy wait. I don't know of any though.
Your only mistake is that you're passing the wrong size to malloc. The phonebook is an array of char* pointers, therefore you need to use sizeof(char*) instead of sizeof(char). 
Thanks i finally got it. I want a single var. term to store the current term corresponding to each recurse and also pass that current term to next recurse which was not possible. &amp;#x200B; Nevertheless , i made another program that does something pretty cool too. I made that into a program that prints and sums the series: 1 + 22 +333 +4444 +.... N terms
Thanks! 
1. I don't get how you said " There's no guarantee that the current value of "term" is evaluated before sum() is called. 2. But i understood the issue with my code so i have manged to make it work . Thanks for the help. &amp;#x200B; int Display\_and\_Sum(int x) { static int temp; int term; if(x) { temp = (temp \* 10) +1; term=temp; if(x!=1) printf("%d + ",term); else printf("%d = ",term); return (term + Display\_and\_Sum(x-1)); } return 0; &amp;#x200B; 3. I think my main issue was making the variable 'term' as static as such in unwinding part of recurse it would always take the latest value. For Eg. For x=3, the last value of 'term' on the winding phase would be 111. So on unwinding phase it would return 111 +111 +111 = 333 Nevertheless, i managed to learn something new from my mistake &amp;#x200B; PS : I didn't initialize the static variable thinking it would start from 0 (if uninitialized). Does it not?
Ok i will keep that in mind. On a side note. Why cant i do: int temp; static int term = temp;
Question: will the big compilers interpret these programs as intended as long as optimisation is not switched on explicitly with a compiler flag? Or will they "optimise away" these checks even in default operation?
Might be worth throwing the code on pastebin or git gist, listings can be hard to read on mobile
Null pointers are false, all other pointers are true. So if (foo) bar; only executes `bar` if `foo` is not a null pointer.
Thank you very much sir. Have a great year ahead.
NULL pointer is falsey value, all other pointer are true. &amp;#x200B; For example consider call to malloc. It returns pointer to allocated memory if successful, otherwise null. So common idiom is to check if call was successful by "if return\_of\_call\_to\_malloc", working on returned pointer only in "then" branch of the if and handling the error in "else" branch. &amp;#x200B; Another use of pointer as scalar is pointer arithmethics. Most common usage example is looping over array: [https://en.wikipedia.org/wiki/Pointer\_(computer\_programming)#C\_arrays](https://en.wikipedia.org/wiki/Pointer_(computer_programming)#C_arrays). Here you have to be a bit careful though, when you add 1 to pointer it doesn't point to address 1 byte to the right of pointer, but to the address 1 \* datatype\_size right to pointer. So for example, adding 1 to pointer to int will increment it with at least 4 bytes (depends on architecture). So it points to next valid value in array.
Basically treat NULL poiter as 0, any other pointer as some other value. So if you have if(p), where p is a pointer, it do it if the pointer p is not null. This is handy for checking for example if malloc was succesful.
Ohhhh great, learnt a new thing.
What doesn't work, what's the compiler output etc?
I've only looked briefly but I think you need to first malloc for the phonebook array of strings, then malloc for each individual item so your initial malloc should be (char**)malloc(new_phonebook_len*sizeof(char* I.E. WITH THE STAR)); then for each item that your'e copying, i.e. in your for loop, you need a new_phonebook[i] = (char *)malloc(strlen(old_phonebook[i]) * sizeof(char)); before each strcpy
the program works for a few rounds then i think something is going bad with scanf and newlines, i think after a few rounds newlines start to build up untill it get pushed into the memory then when i want to delete it wont allow me.
the program works for a few rounds then i think something is going bad with scanf and newlines, i think after a few rounds newlines start to build up untill it get pushed into the memory then when i want to delete it wont allow me.
[https://pastebin.com/SHCd1jLS](https://pastebin.com/SHCd1jLS)
I repeat: What doesn't work, what is the output when it fails, what is your compile command, what does the compiler output?
Here what it says: access violation reading location. &amp;#x200B; heres what i did: added 4 numbers, deleted 1, deleted all, then i tried to add 1 number and it gave me the error.
Thank you, there are a couple issues, so I recommend compiling with stricter warnings but this crash is because you don't actually update the length of your book when deleting items. This cause the 2nd loop in check_number to go out of bounds
&gt; c complete reference Ah, my poor ears! 
What are your views on it.
Wow that is very much correct, it worked! I think Everytime I either add or delete number I will make a new phone book so that there will be no "holes" in the phone book memory. What do you think about it?
Since this is a beginner's assignment and you're not allowed to use structs, the length of the book (of which there should only be 1) can be a global variable which you update with the add, delete and clear methods. There's a couple ways to pack the book on deletion. I'd suggest thinking of a fun one and implementing that, you're doing it to learn after all.
&gt; Here you have to be a *bit* careful No pun intended, I'm sure. :-D
For the most part, unless optimizations are enabled, optimizations beyond basic CSE or (overtly) dead code elimination won’t happen unless the compiler is told to enable optimizations. I say “for the most part,” because most compilers also offer a way to change optimization options for specific functions, regions, files, etc. using attributes or pragmata. Some stuff may also show up as a surprise, since considerations aroun UB can work their way into higher-level assumptions outside of optimization specifically.
Let me give you a pedantic explanation, as the other ones here are not strictly true (pointers are not really true or false -- even if you can think of them like that: for example, ```if (p==true)``` will generate a warning) So, what is going on? Form [the C Standard](https://docs.google.com/file/d/0BwtP9e5j1RbpbHF2UXg3dEg2eWs/edit) page 42: &gt; Arithmetic types and pointer types are collectively called scalar types. Array and structure types are collectively called aggregate types. Pointers are scalar because you can do things like + on them. Ie ```p[4]``` is defined as ```*(p+4)```. Then on page 69: &gt; 1 When any scalar value is converted to _Bool, the result is 0 if the value compares equal to 0; otherwise, the result is 1. What this says is that ```if (x)``` is equivalent to ```if (x!=0)``` if x is a scalar. Ok, good, but how does comparison works ? Well, 6.5.9,page 96 says it is defined when &gt;&gt; — one operand is a pointer and the other is a null pointer constant. Then, the last piece of the puzzle is given page 55: &gt; An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.66) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. We can now understand what is going on: if (p) if p is a pointer is *defined* as the result of if (p!=0) and the ```0``` in that code is NOT a int, but the null pointer constant, so the code is the comparison of ```p``` to the null pointer. So, pointers are not true of false, they just magically compare to the null pointer when used in ```if``` statements (there is an analog with '=' and the assignment to a _Bool variable). Sorry for being pedantic, have a nice day.
https://en.wikipedia.org/wiki/Object-oriented_programming https://en.wikipedia.org/wiki/Procedural_programming Start with these, ask specific questions about what you don't understand.
**Object-oriented programming** Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of "this" or "self"). In OOP, computer programs are designed by making them out of objects that interact with one another. There is significant diversity of OOP languages, but the most popular ones are class-based, meaning that objects are instances of classes, which typically also determine their type. *** **Procedural programming** Procedural programming is a programming paradigm, derived from structured programming, based upon the concept of the procedure call. Procedures, also known as routines, subroutines, or functions, simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself. The first major procedural programming languages first appeared circa 1960, including Fortran, ALGOL, COBOL and BASIC. Pascal and C were published closer to the 1970s. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
 char test2 = "WASGEHTAB"; You have declared `test2` as being of type `char`, but you've assigned it a string. This should be giving you a compiler warning or error in both examples.
Neither work well. Your strcpy is wrong. In one way for an empty source string and in a different way for a non-empty source string. And both mains are wrong since they're overflowing the test1 array. 
Procedural is functions and blocks. If, case, that kind of stuff. Object oriented wraps them into objects, and hides the contents. The original goal of OO was to break up systems that were too complicated to think about, and represent them sort of as mini-programs which chat with one another. Arguably OO is a kind of procedural, though people will get into bitter battles about that.
OOP does not mean you cant write procedural code. It is not really mutually exclusive relationship. Instead it means you focus on the objects. You design a program around the objects instead of an executable statement. If you need to build a car, how would you build? You will need an engine, tires, wheels, and so on. These objects composed of smaller objects such as nuts and bolts maybe. You do the same in OOP. You build objects (or actually a class which is a blueprint of real world object). And then you use the objects to build something like a self driving car. While working on that, you will execute sequentially as in a procedural programming. Just like how you can tell what happens sequentially when you start the car. But you rather focus on building right objects instead of these procedures. If you have right components, putting things together is the easy part. Building a desk from IKEA is the easy part because they already made right components to you.
In general I agree with the premise of the article, but I take some issue with the “ridiculously contrived”-ness of the `zero_array` example. When suggesting that the programmer just call `memset` directly, per the C standard they’re potentially changing the semantics of the code. This is slightly beside the TBAA -related point, but IMO it’s a common sort of argument that pops up when discussing UB in C. Namely, the idea that all-zero-bytes will always be a valid representation for floating-point zero is outside what the standards specify, and as such ABI-dependent. In practice, it’s almost always the case that all-zeroes can be interpreted as 0.0F (whether or not the reverse is true), because most stuff nowadays uses IEEE-758 or some related format and IIRC POSIX requires all zeroes to be interpretable as 0.0, so we’re probably not going to see any remotely modern hardware violate that assumption. But using `memset` explicitly can cause other problems and potentially inhibit more important optimizations, because reversing the `=0`→`memset` transform can be much more difficult, given that the f.p. values now have to be pieced together at compile time. If, say, the next step of the program after zeroing the array is adding another array to it, the compiler should just `memcpy` the augend array over the would-be-zeroed one without zeroing it, right? But unless it can tell that all the *f.p.* values in the array are *f.p.* zeroes, it’s going to have to `memset` the array, then actually add the two arrays, on the off chance that one of the values in the `memset`tee isn’t 0.0. So the `=0.0F` code is easier to read, potentially much easier to optimize, and more portable than an explicit `memset`-based version. This kind of thing also shows up with the practice of `bzero`ing or `memset`ting a structure with pointers in it to all-zero-bytes; POSIX dictates that `NULL` must be representable by all-zero-bytes and most people operate blithely on that assumption, but the C standard says nothing about `NULL`’s representation, so if you want to write more generally portable code, it’s best to explicitly assign to `NULL` and let the compiler optimize to `memset` for you, as appropriate. (Unless you’re defaulting some POSIX-specific abomination like `struct sigaction`, in which case there’s really no better way to default the thing than `memset`ting.)
But how i could have declare it as an string? Sorry i am new to programming.. 
The difference in spirit is that OOP languages like Java and C++ couple data with functionality using inheritance and strict type systems, whereas in procedural programming languages like \`C\`, data can be applied to any functionality. The limitations of OOP aim to decrease the use of data with improper functionality. Another key difference is what data looks like: in OOP, data is made up of objects, whereas in \`C\`, data is composed of binary values with known byte sizes. Unfortunately, there is a critical side effect of bad OOP design that frequently makes it difficult to program with on a large scale: with deep and complex inheritance schemes, it is extremely taxing to look at a given line of code and understand the stack trace of execution. Code from a dozen or more files may execute just on a constructor call. It's like programming with \[COMEFROM\]([https://en.wikipedia.org/wiki/COMEFROM](https://en.wikipedia.org/wiki/COMEFROM)) (it's the unfortunate cousin of \`GOTO\`) plastered everywhere. Modern IDEs exist to alleviate this burden, but it is a burden nonetheless. The bros who came up with OOP design warned everybody not to do that, but it is everywhere. Today it is less common to write new OOP code that way, but it is still everywhere. If you want to learn more about OOP, here's the seminal \[book\]([https://en.wikipedia.org/wiki/Design\_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)). Still the best one. If you remember one thing from this comment: prefer composition over inheritance.
The authors of the Standard intended to avoid requiring as a condition of compliance that implementations targeting platforms whose underlying means of integer arithmetic handled corner cases strangely, expend any effort shielding programmers from those such behaviors. According to the Rationale, however, some of their decisions were predicated on the expectation that commonplace implementations would treat signed and unsigned arithmetic in equivalent fashion even in certain cases where the Standard would not require it, and where implementations targeting unusual platforms might do otherwise. A fundamental assumption of C89 was that if processing certain actions a certain way on certain platforms was widely recognized as useful, compiler writers seeking to write quality implementations for such platforms would process such actions in such fashion if the Standard allowed it, without regard for whether the Standard required them to do so. The more obvious the usefulness of a behavior, the less need there was to mandate it. Since the authors of the Standard explicitly recognize that it would be possible to write an conforming implementation that "succeeds at being useless", they saw no need to forbid implementations from behaving in stupidly-useless fashion,. 
Because static variables are only initialized once, and what you initialize them to has to be known at compile-time. /* Uninitialized, the value will be whatever happens to be on the stack */ int temp; /* `temp` isn't known until the program is running, so this is invalid. */ static int term = temp; 
In the second example, you’re passing a `char` (test2) into a function that expects a `char *` argument.
Is the null==false in conditionals guaranteed on systems where null != 0?
Yes, check out this thread: https://stackoverflow.com/questions/2599207/can-a-conforming-c-implementation-define-null-to-be-something-wacky
Unfortunately, for whatever reason, the authors of clang and gcc have yet to define a set of flags which can be expected to, for all present and future versions, avoid the kinds of "optimizations" that violate the Spirit of C's "Don't prevent [or needlessly impede] the programmer from doing what needs to be done", without generating horrible code that's full of unnecessary register shuffling, reloads of constants, and other such nonsense. Further, there's no mode I can find which will use N15706.5p7 (or equivalents in other language versions) to determine when seemingly-unrelated objects may alias [which is the purpose for which the rule was written] without also using it to justify willful blindness about pointers that are quite conspicuously derived from related objects, Instead, the best one can do is enable optimizations but then explicitly disable all of the phony "optimizations" favored by the authors of gcc, and hope that they don't decide to add any new ones one hasn't listed. 
Thanks
More generally, if one has a piece of code like: void reduce_mod_65536a(uint32_t *p, int n) { for (int i=0; i&lt;n; i++) ((uint16_t*)(p+i))[!IS_BIG_ENDIAN] = 0; } a compiler that isn't willfully blind to the fact that the pointer being accessed is freshly derived from a `uint32_t*` would be allow for the possibilities of the function affecting objects of type `uint16_t` or `uint32_t` without having to allow for the possibilities of it accessing unrelated objects of other types. If the code were rewritten as something like: void reduce_mod_65536b(uint32_t *p, int n) { for (int i=0; i&lt;n; i++) memset((unsigned char*)(p+i)+2*IS_BIG_ENDIAN, 0, 2); } a compiler would have to allow for the possibility that the function might act upon objects of any type, and on platforms with alignment requirements would typically also perform the `memcpy` using two 8-bit stores rather than one 16-bit store. The notion that programmers should use `memset` for such things in order to accommodate willfully-obtuse compilers is silly, dangerous, and Just Plain Wrong. 
Looks like you might have opened the .o file instead of the .c file
&gt; char test1[] = "Hallo"; There are two things happening here. "Hallo" is a *string literal*. It exists in a section of read-only memory. Then, because it is part of an initialization, it is copied to the char array *test1*. In your first version, *"Warumgehtned"* is also a *string literal* and because c passes everything by value, a **copy** is made in the form of a char array used inside the function. &gt; char test2 = "WASGEHTAB"; This is wrong. *test2* is declared as type char, meaning it is a single character. I am surprised your compiler did not give you a warning along the lines of "initialization makes integer from pointer without a cast". What this warning would be telling you is that *test2* expects a single number assigned to it. You are giving it a sequence of numbers (a string-literal, which is like an array). In C arrays are accessed by a reference to the beginning of the memory where they are -- a pointer -- which is the type of argument your function expects. As an extra note, be aware that there are multiple ways to initialize variables with string-literals in C: &gt; char test1[] = "Hallo"; //string-literal copied to read/write memory &gt; const char *test2 = "Hallo"; //this directly refers to the read-only memory and should be const 
Looks like the contents of a .o file. Maybe you accidentally overwrote the .cpp file with the compiler output?
yep.
It's all a matter of where you put your code. Imagine you want to add a numerical datatype. For example, a complex number. Your program can mix and match types, so you need to define addition and multiplication, for your type, and the combination with other types (integer, float). * In procedural programming, you have one routine for addition, one for multiplication, etc.you need to add your code for your data type to each of those routines, respectively. * In OO programming, you have a siurce file for your data type, the conversion routines, and addition and multiplication, all inone place . OO keeps your data , and your routines, together in a single place. 
Although the Standard refers to pointers as scalars, they're really a unique kind of thing that shares one trait of non-pointer scalars, but differ in almost every other way. Given any two *non-pointer* scalars X and Y, the expressions "a+b" and "c-d" will convert both operands to a common type and yield a result of that type. If `a` or `b` is a pointer, however, the other must be an integer type or a literal zero or equivalent (interestingly called a "null pointer constant") and the result will be a pointer. If `c` is a pointer type, the result will be an integer if `d` is a pointer, and a pointer if `d` is an integer. If `d` is a pointer, `c` must be a pointer, but as mentioned the result will be an integer. The only trait which applies to all scalar types, and only scalar types, is that the null pointer constant can balance all such types (but no others) in equality/inequality comparisons and assignments. Since a statement like `if (x)` is precisely equivalent to `if ((x)!=0)`, the expression `x` can be any type which will balance the null pointer constant in the comparison, i.e. any scalar type. I'm not sure it's worth defining a special term for such types, given that the Standard's vocabulary is lacking so severely in other ways [e.g. it doesn't have a term to describe what is done to the sub-expression `arr[i++].x` when evaluating the expressions `&amp;arr[i++].x.y` or `arr[i++].x.y = 5;`, nor does it have a term to describe the result of such action]. Nonetheless, for better or for worse, the term "scalar type" as used by the Standard refers to things that either act like numbers, or that don't act like numbers but can balance a null pointer constant in some contexts. 
Don't panic! Focus on improving your bug report.
I’m pretty much of the mind that the whole Spirit of C push is well-intentioned and generally correct, but probably pissing vainly into the void at this point. The land mines are already out there, and while the various major compilers can fix their behavior based on that (though I’m not sure what N15706.5p7 is), the percentage of developers who’re actually going to be working with those versions of the compilers is gonna take a good long time to get anywhere significant. Hell, C99 is still considered New C to most developers/houses and quite a few toolchains, even if we’re mostly all familiar with it by now. (MS still hasn’t made it to C11, and unless they’ve done something major, their C99 compatibility is debatable considering the way their preprocessor handles spacing and variadic arguments and the bitching about use of any non-`_*_s` functions.) And of course, it’s going to be virtually impossible to satisfactorily define the Spirit of What Code Should Mean in standards-able language, so most of that is going to be whatever a handful of companies/groups agree upon, and anybody not in that group or emulating their toolchains is going to do whatever they want anyway. W.r.t. defensive magic, theoretically one could do `#pragma GCC optimize "-O0"` then set whatever baseline batch of optimization operations won’t break things, or do the same on a function-by-function basis with `__attribute__((__optimize__))`. Of course, that only works as long as those optimization flags don’t change their behavior/meaning, which is nontrivial to track or determine.
Procedural: Spray water on the fire- Object Oriented: No wait that makes too much sense. What is fire, anyway?
AfricanScreamContest is right, but also your `strcpy2` function is wrong in a few ways. You’re copying into your destination string `d`, and then checking for the end of that same string before the next iteration, whereas you should be checking for the end of the source string you’re copying from. In other words, the loop condition shouldn’t be `*d != '\0'`, it should be `*s != '\0'`, and since this is basic string processing in C it can just be `*s`. If the destination string hasn’t been initialized before calling `strcpy2`—it generally needn’t’ve been in normal use—then your first read of `*d` will be of garbage memory if your compiler ends up actually generating runnable code for it, because it’s undefined behavior. Furthermore, because you did a `do`/`while` instead of just a `while`, if the source is an empty string, the destination memory won’t be touched at all; if it weren’t initialized beforehand, this would leave the destination string unterminated in this case, which is an excellent way to elicit undefined behavior. Even if it were initialized prior, unless it were initialized as empty or otherwise NUL-initial, the output string would be left unchanged. Finally, functions like this should really have the source argument marked as `const char *` (or `char const *`, depending on religious preferences) for a few reasons. You have no need or intent to write to the source string, so there’s no reason to force (well, strongly suggest) that the compiler forbid (well, strongly discourage) passing a constant string as input. (Note that string literals give you strings that you’re more-or-less not allowed to modify, but they lack the `const` type modifier. This was a decidedly very bad decision that probably made sense in light of very old, very bad code targeting very old, very simple architectures, and it’s the only reason you’re not getting an additional warning for passing a string literal to a `char *` argument.) Using `const char *` also implicitly documents the purpose of the second argument, so that nobody has to scan your code to see whether `d` and `s` are actually being used as destination and source, or whether you just felt like using those letters for some other reason. (Perhaps there’re some D-initial “source” and S-initial “destination” words in …German? I’m guessing?) Instead, since all the C/OS libraries use `const char *` or something like it for unmodified strings, C programmers will immediately guess that the `const char *` means “input string” and an adjacent `char *` means “output string,” and 99% of the time they’d be right. And since the compiler will kvetch at you if you try to write through a `const char *`, you can’t easily write to the source string without explicitly casting away the `const`. (Doing so is UB unless the source string originates from a non-`const` value.)
Instead of creating a new phone book every time you delete a number, just move all of the pointers to the strings (phone numbers) up one to fill in the hole. Then you could use realloc to adjust the size of the phone book (requirement 1). Moving the pointers is way more efficient than creating a new phone book and copying all of the entries. Also, you say that you haven't learned structs yet - which sounds like you are not restricted from using structs. If this is the case, I would take the 1/2 - 1 hour it would take to learn the basic of structs and use them. With structs, you will find that it will be easier to write your program and your code will be a lot cleaner. 
Next time, put your code on a paste sharing website like [GitHub Gist](http://gist.github.com/) or [Pastebin](https://pastebin.com/) Anyway, I think you'll find that your problem lies on this line. &gt; if(letter == "N") Double quotation marks(`"`) denotes a string literal, which will get compiled to a pointer. If you want a character literal, use single quotes(`'`).
you have two returns from a void function, thats not necessary, and in the fprintf, you could use printf and again you have some issue with the quotes ""
change `char *array[commaCount];` to `char array[commaCount];` and check what happens
Thanks, that fixed it! Sorry, I am new to C (and thus subreddit), I will do that next time! Any idea why that setup would have worked on one computer but not another? I frequently bounce back and forth between Uni PC's and my own laptop with SVN.
In other words, static variables have to initialized to a constant value?
You’re sorta close, but you’re making it a bit too complicated. Rull high-level, because your output string is strictly shorter than your input string, you can do this in-place without an extra array, no need for the extra `char array[…]` declaration or multiple passes. You can basically do for each input line /* which you’re not technically doing rn if lines might be &gt;1035 chars */ do skip whitespace v = read next character number poke v into next slot of output buffer while next input (consuming it) is a comma print output buffer How you do it exactly depends a bit on whether you’re taking unsigned or signed values, and whether you’re actually dealing with/in ASCII or merely acting as a conduit for whatever character encoding you happen to be seeing as input. To avoid having to fork off a bunch of different things, I’ll define a few things here: /* If using ASCII: */ #define OUTPUT_CU_MIN 0 #define OUTPUT_CU_MAX 127 /* If using signed 8-bit input (i.e., −128…127): */ #define OUTPUT_CU_MIN SCHAR_MIN #define OUTPUT_CU_MAX SCHAR_MAX /* If using unsigned 8-bit input (i.e., 0…255): */ #define OUTPUT_CU_MIN 0 #define OUTPUT_CU_MAX UCHAR_MAX (You should probably `#define` the size of `path`, also.) Given the above: #if OUTPUT_CHAR_MIN &gt;= 0 # define signed_as_output unsigned #else # define signed_as_output signed #endif #if OUTPUT_CHAR_MIN == 0 # define in_cu_range(x) ((x) &lt; OUTPUT_CHAR_MAX) #else static char in_cu_range(long v) { return v &gt;= OUTPUT_CHAR_MIN &amp;&amp; v &lt;= OUTPUT_CHAR_MAX; } #endif These are because Reddit is a shite IDE and I’m lazy. `U_OUT_P` (`U` for “unsigned”, `P` for “predicate”) will yield the text of its first argument if we shouldn’t bother with a sign, or the text of its second argument if we should. Also, you’ll want (preferably before the above) #include &lt;limits.h&gt; #include &lt;stddef.h&gt; in addition to what you have. Anyway, inside your line loop: /* `p` will point to the next input character. */ const char *p; /* `q` will walk behind `p`, pointing to the next output slot. */ char *q; size_t count; /* Loop until we’re out of input on this line: */ p = q = path; do { char *after; signed_as_output long byteValue; /* Skip intralinear whitespace. */ while(*p &amp;&amp; (*p == '\t' || *p == ' ')) ++p; /* No useful input on line? Move to next line. */ if(*p &lt;= ' ') continue; /* ↑ That’s quick-and-dirty, and means slightly different things depending * on signedness of `char`, but will always include NUL and LF (\n). * Also depends on ASCII-compatibility, but you’re not doing EBCDIC. */ /* Try to read out the next number. */ errno = 0; byteValue = strtoul(p, &amp;after, 10); /* If the input number is not representable qua `value`, * or the value is out of character/code-unit range, move to next line. */ if(errno || !in_cu_range(byteValue)) continue; /* Store the next character. */ *(q++) = (char)byteValue; /* Advance `p` to the first thing after the byte value. */ p = after; } while(*(p++) == ','); /* `line` now contains the binary-ified representation of your input. * If you want output newlines between input lines, do *(q++) = '\n'; * and maybe check input more carefully than I have. * * If you need to use the string more generally, do *q = '\0'; * before letting it escape. */ /* Write the line to output. */ count = q - path; /* or compute it along the way, whichever */ if(fwrite(line, 1, count, stdout) &lt; count) { fputs("output error\n", stderr); return 1; }
&gt;Any idea why that setup would have worked on one computer but not another? It's just a warning - it's still valid C so it can compile, it's just not going to do what you want. When "N" gets converted to a char, it starts by becoming an integer that represents the address that the compiler placed the constant string "N" at, and then it truncates it to fit in a char. Depending on where the compiler placed the string in memory, it *might* equal the letter N - but probably not.
Perhaps you meant to say '2 * i - 1' instead of `2i - 1`? `2i` is an imaginary number.
Whether what you typed is syntactically correct or not depends on whether C99 complex numbers are supported. Note the use of `2i`; pre-C99, that’s not a valid token, and post-C99 that’s an imaginary number if `_Complex` and associated machinery is supported. Of course, changing `2i` to `2*i`—almost certainly what’s intended—is fixing a syntactic error only when !defined(__STDC_IEC_559_COMPLEX__) || (__STDC_IEC_559_COMPLEX__+0) &lt; 1 (mind you, that’s a preprocessor expression, which works only with `#if` and `#elif`) and a semantic error otherwise. Arguably `i + (i - 1)` would be slightly more stable for large `i`, since `2*i + 1` or `(i+i) - 1` might lose the −1 faster. You have no way to know which is right, of course, especially since you’re already forced to fix semantic stuff like `%d`→`%f`. Also, `1/2` is zero, because it’s using integer division. That’s another semantic error, but see if `0.5` works. (And things like using `%d` to print a `float` is way-the-fuck far away from being a syntactic error—it’s undefined behavior resulting from an attempt to pass a `double` for use with a format specifier that requires an `int` argument. That UB might occur at run time, when syntax is a thing of the distant past. The final `printf` should usually have a final `\n` also, because otherwise you’re being rude to the vast majority of command prompt users.) I’m also not sure if you’re double-escaping things like `\n` as `\\n` purely for representation in your Reddit post (don’t do that or `\*=`, just indent by 4 spaces and it’ll come out fine), or if you’re actually using the escape sequences in the original code. It’s likely your professor intended the `\t`s and `\n`s to be actual tabs and newline sequences, in which case use those specifically were already fine in the original source.
Wouldn't "modern" assemblers optimize the code such that it won't matter as much how you implement it because it all comes down to the assembly code and then machine code? Or does this not happen?
There are a lot of factors that can impact that. For instance, `num_elem` could be a library function where the compiler can't know. Also, a compiler for a niche processor might not have a good optimizer
What has happened, fundamentally, is that C has diverged into two languages, one of which has quality semantics but which seems to be being abandoned by vendors who had been interested in supporting it efficiently as they migrate toward clang-based compilers, and the other of which has deteriorating semantics. The language with quality semantics isn't going away, though the quality of code generation may go downhill. The difficulty of optimizing safely is vastly overstated by compiler writers who want to justify obtuse behavior. Most of the places where type-based aliasing optimizations would have a big payoff don't do any pointer casting, union accesses, or `volatile`-qualified accesses, and most of the places where phony "aliasing" optimizations break things do involve such operations, so using the presence of such operations an indication that a compiler should proceed cautiously would be a simple and obvious way of resolving issues for any compiler vendor that made any bona fide effort to do so. If nothing else, perhaps what's needed is a different name to distinguish the language the versatile Standard was supposed to describe from the feeble subset which the Standard actually specifies. Make it clear that the programs which gcc/clang don't support aren't in the language that their authors feel like processing, and that when optimizations are enabled, the language gcc/clang process is not the one which became popular in the 1990s. 
Once you get past the basic understanding of programming and can write code that executes the primary skill becomes managing complexity. Computer programs can be amazingly complex, with hundreds of thousands of functions developed by thousands of different developers. I am not aware of anything of comparable complexity that we try to undertake, the success in managing this complexity is a large part of why designers try to shift functionality into the software domain. Sequential code starts at line 1 and continues to the end of the file. A basic bash script is of this style. Procedural code is more complex. You introduce functions which perform a task. The execution flow is less clear, it jumps around the file to the function and back. Crucially functions variables can be scoped (local in bash), this means that the variable is contained within that function. You can look at the function, and the variable, without understanding every other function in the program, because a local variable i is independent to the local i in the next function. Object orientated code takes this to the next level. An object is a collection of functions and localised variables. You encapsulate the complexity by making the variables only accessible the objects functions. The object presents a well defined interface to the rest of the program which you try to keep consistent, this means that changes can be made within the object without knowledge of the rest of the program. It also means that other elements of the program can use your object without knowing exactly how it works inside. The actual implementation of object orientated programming varies a bit between languages. Stronger support for OOP patterns is a defining feature of most high level languages.
i'm not great with compilers so can anyone explain to me how he uses gcc and clang for c++ code? It's really confusing me that he doesn't seem to differentiate between clang++ / clang and gcc / g++. Now i am sitting here wondering if he just changed the code or if he changed compilers too?! But i agree in general a very interesting (even though not so surprising) read. One of the better performance comparisons i have red but i'd still like to see open source code and compiler/build commands. Once again i can't repeat the experiment myself...
I didn't read the article, but Clang produces slower code than GCC does, and GCC produces slower code than MSVC, which produces slower code than the Intel compiler. If he's changing up the compiler, the benchmarks are meaningless. Furthermore, I think it's fairly difficult to prove that the *language* itself is responsible for the performance differences, as opposed to differences in how the compiler itself produces the code.
Regarding when to use STL, I just stumbled upon this article: [https://zeuxcg.org/2019/01/17/is-c-fast/](https://zeuxcg.org/2019/01/17/is-c-fast/) The author discusses how he was able to increase performance twofold and decrease compile time between 5x and 36x (when using debugging), by switching from STL (std::vector, std::unordered\_set, std::sort) to custom functions / data structures. That is not to say STL is bad/not optimized, but for it to work in \_any\_ kind of scenario, it needs to be correct, and that comes at the cost of performance. 
I think by saying gcc and clang he meant g++ and clang++. Anyways, you can build c++ code with gcc -lstdc++ or clang -libc++ given the file has a c++ extention. The compiler would recognize that file as a c++ file. 
gcc and g++ are just wrappers for cc1 and cc1plus. gcc compiling c++ code calls cc1plus under the hood. Similar story for clang.
If you read the article, you will note that the author actually concludes that a C++ compiler is not significantly slower than a C compiler, \_if\_ you take proper precautions to not include STL headers: &gt;... it doesn’t look like C is faster to compile than C++ assuming a compile time conscious subset of C++ is used 
It's because GCC is ambiguous. .GCC stands for GNU Compiler Collection and refers to the whole suite of GNU compilers, but GCC is also used to refer to GNU C Compiler.
Looks like a good read, I saw this posted on the subreddit.
Is this "linked list"?
I think so
thank you for taking the time and writing a code for me, very much appreciated! 1 quick question: when you defined struct pb, you have inside struct pb \*next. what is happening there when you have the struct inside the same struct?
I explain it in some hours, too hard to explain with a smartphone 
no problem, in the meantime i will go over structs so ill be ready to understand better.