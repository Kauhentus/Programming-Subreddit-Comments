I'd say that to write, as long as it has highlight it's okay. I'm not used to vim however, it may be more powerful than I think. My point is, text editor &amp; GCC winning combo
As a rule of thumb: * For constant integer values, use an anonymous `enum` * For lookup tables with constant values, use an array in static storage qualified `const` * For constant structures, use either a `const` object in static storage or a macro, depending on the cirumstances * For constants of other types than `int`, use a macro * For constants you intend to take the address of, use a static object, optionally qualified `const` if the constraints permit that. I recommend against using `const` for scalar values as constants declared this way occupy memory, need to be fetched from memory when the compiler needs their value and aren't compile-time constants. All these are things that go away when you use an enum or a macro instead.
No hard and fast rule, but using a const variable rather than a define encourages type safety. I agree with everything else said here. I'd probably stick to const variables rather than defines for most work.
That's not cool man
Originally it as designed to tell the compiler to place the variable in the stack, but compilers do that anyways. So it's basically an obsolete keyword, sort of like "register". In C++, the auto keyword has been repurposed to automatically deduce the type of a variable. 
It does nothing (assuming you're talking about declarations at function scope.) It's a holdover from B, which had no types, and required that you instead introduce a declaration by stating the object's storage duration, such as: auto i, j; static x, y; C bolted types onto that, so that you can write: auto int i, j; static short x, y; However, now that there are types involved, the storage duration can be defaulted to 'auto', since that's what is used in the vast majority of cases: int i, j; static short x, y; This wouldn't have been possible in B, since you'd be left with just `i, j;` which is ambiguous as a declaration because that's also valid as an expression. But not in C, which makes the specifier optional, but `auto` still hangs around as a vestigial organ. 
That would be fantastic. I'm developing a custom operating system for the 80286 and it is really diffiuclt to find out how other operating systems of that time dealt with segmentation.
Cool project. I hate to say it, but at one time I had the complete QNX 2 porting package. The project I was doing needed some customization so we bought the whole kit. Had most of the source for the OS. Long gone unfortunately. 
Ah that sucks a lot. Perhaps I can ask the vendor?
Look through the archives of this subreddit. This question has been asked a lot.
Are you trying to say that compiler choice is independent of hardware, or something else? 
He said hardware determines what IDE he uses. In a lot of ways, it doesn't choose the compiler either though that's more broad.
Yeah, I'd just use the next letter in the alphabet, j, in place of i in the loop heading if I already had a variable i defined outside of the loop. 
For small embedded systems you're more likely to use defines for constant values. An 8-bit value accessed as a define on a typical 8-bit von Neumann architecture machine might have a one-byte immediate load opcode and the value itself for each reference. With a const, it'd probably be a load from a 16-bit address *and* the value itself takes up an extra 8 bits of memory.
&gt; I prefer to use static const if possible. However, sometimes that doesn't help, i.e. in the case of array sizes you have to provide a literal (on some compilers atleast). So I use a define instead. GCC is not OK with static const, Clang is OK with them.
&gt; I recommend against using const for scalar values as constants declared this way occupy memory, need to be fetched from memory when the compiler needs their value and aren't compile-time constants. All these are things that go away when you use an enum or a macro instead. I don't get it, so a global `static const int` will not be translated into a literal by the compiler but `static int` will? I think it should be the other way around?
&gt; With a const, it'd probably be a load from a 16-bit address and the value itself takes up an extra 8 bits of memory. Well since it's const, the compiler could determine the required size for its particular value, no?
Yes I was, so the const "quirk" is only present in C++?
I'm sure that's all true, but do you know that it matters? Do you know you need that extra speed in your application? It seems like premature optimization to worry about that - especially since the OP didn't give any particulars of the usage.
Please read my comment again. Neither a `static const int` nor a `static int` are compile-time constants and will be loaded from memory every time the compiler needs their value (with caching of course). Only macros and enums generate compile time constants. For scalar constants, an automatic variable (optionally `const`) also optimizes well, but you can only have these in block scope. And they aren't compile-time constants either, so you can't use them to form array sizes in declarations (except when using variable-length arrays) and you can't use them in preprocessor tests.
To the best of my knowledge adding a const will not trigger pessimisations in plain C.
Small embedded systems are probably the *only* place you'd normally worry about that. I work almost exclusively in that domain, but even there it's less important now. 10-15 years ago I was working with systems that had 8 kB of flash and 192 bytes of RAM. Now I typically have 1 MB of flash and 128 kB of RAM. Even on a PC, if you need the highest possible performance you'll need to give some thought to how things are implemented at the instruction level, but 99% of the time you probably don't need to worry about the performance difference.
Thank you.
Vim has a steep learning curve. For someone who doesn't have much experience coding, having to also deal with an unorthodox text editor can be frustrating.
Please put four blanks in front of every line of the sample patterns so they are readable.
You're right, I think the example is wrong. Decimal values for one byte range from 0-255, and in a group of 4 bytes that should be 12 digits (3\*4) (3 digits * 4 bytes).
Ahh, I think you're right. I completely take back what I said about it being in K&amp;R 2nd Edition. It simply isn't true after looking through the book a bit. Thanks to everyone that's setting me straight. I'm new to C and I bring with me a lot of bad habits from other languages. I want to learn it right.
yeah it just depends on where you place the space. It's meant to separate the groups, so two obvious places are either at the end of displayBuffer, or after displayBuffer is called. There's probably other ways to do it, but those are the most obvious (imo).
[removed]
ok thank you. 
Probably: function(&amp;p2);
That was my initial thought. But I want to build something like your search bar on your computer. It will compute values as you type them. In my case, I just want a+b+c or something similar. Thanks for the suggestion, though.
You're going to need a nonblocking input then, alot of games libraries has these. Off the of my head ncurses and sdl. 
I think that is the most basic way to make one. However, I would like to make it with no prompts. simply type 1+2*3 = 9 using some sort of fifo
You'll need to use some kind of parser to turn the expression into a data structure. You could use a parser generator like bison (along with flex) but for something this simple that's probably overkill and you should just write your own. Look up "recursive descent parser" for a simple way to do things.
Easy: libmatheval (or similar library) Still easy, but a little more code: https://en.wikipedia.org/wiki/Shunting-yard_algorithm Can also write a recursive descent parser. Also: lol at the quality of most responses in here.
[removed]
Thank you. I will give it a try.
The ␣␣␣␣ in the submission help is just visual representation of whitespace. Hit the spacebar four times before each line. &gt; (2^days )/100; It looks like you have this: `(2^days)/100;`, but that's not how you do exponents in C (it's a bitwise XOR). You're also doing integer division here instead of working with decimal values.
It looks like you're already calculating it like your professor requested. You could try replacing all doubles with "long double" which might give you some extra resolution for free, depending on your compiler. 
Have you looked into how Minix did it? That code should be available.
This bothered me enough that I went to lookup the 80286 programmers manual from Intel (1987) and it states that the 286 has a virtual address space of 2^30 bits, so a whole 1GB, on page 1-2. So, I learned I was wrong this whole time. 
Ah yeah, you get that additional bit when you use both the LDT and GDT to its fullest extent. However, for practical reasons you typically would leave the GDT untouched and use only the 2¹³ segments in the LDT.
I'm looking into that now, thank you
`fwrite` writes binary data directly to a file. So if you pass a pointer to an integer to `fwrite`, it writes the bytes of the integer into the file just as they are represented in RAM. `fprintf` prints according to a *formatting string* where you can specify how the data is supposed to be formatted. Generally, it is used for textual output. However, you can also write ASCII with `fwrite` if you first convert your number into ASCII digits and then print the buffer with the digits inside.
&gt; You can precalculate the factorials --- they never change so you could calculate them prior to calculating the sum. Instead of precalculating x!, consider precalculating 1/x! so you can multiply instead of dividing.
Having function prototypes inside of other functions is odd but legal. It's more usual to have them at top level near the top of the source file. You don't have to keep repeating them that way. Also, what's with that second, empty while loop in main?
In C, the integer constant `5` has the value five. The character constant `'5'` has the value 53 because the *character* 5 has ASCII code 53. To convert single digits to ASCII, you can generally simply add `'0'` to the number to get the ASCII code. ASCII code 5 is a *control character* called ENQ (enquire) that is displayed differently depending on your operating system. Perhaps that's what you saw.
Could you elaborate on how to do that FUZxxl? 
&gt; To convert single digits to ASCII, you can generally simply add `'0'` Example: char c = 5 + '0'; the char `c` will contain the char '5'. This works because the ascii values for the 10 digits are in the correct order (although K&amp;R warn that this is not necessarily true for all platforms).
For one thing, the "2 ^ (days)" code will give you the bitwise exclusive or. You probably want to replace that with the power function, "pow(2, days)". Also, make sure to printf days and penny right after you GetInt or GetFloat them, to make sure that they have a reasonable value in them. Finally, the condition (days &gt;= 32 &amp;&amp; days &lt;= 28) can never be "true."
Just use the '*' symbol.
Sounds like you want a stemmer or something like that.
Im going to be honest. I though C_programming meant computer programming. Thank you though.
[removed]
I mixed up K&amp;R talking about the digits and letters. From 2.7 of K&amp;R 2nd edition: &gt; This* works for ASCII because corresponding upper case and lower case letters are a fixed distance apart as numeric values and each alphabet is contiguous -- there is nothing but letters between A and Z. This latter observation is not true of the EBCDIC character set, however, so this code would convert more than just letters in EBCDIC. *a generic tolower function that given `c &gt;= 'A' &amp;&amp; c &lt;= 'Z'` returns `c + 'a' - 'A'` EBCDIC isn't used much anymore AFAIK, so it's not really a concern unless you're programming on certain 40 year old hardware. However, the digits 0 through 9 are in numerical order in EBCDIC, so my original post was wrong.
Oh wow, so compilers can do that by now. Neverthless, the other points still stand.
My other points also stand for `static const int` variables: They aren't compile time constants, you can't use them in preprocessor tests and you can't use them to specify array sizes in declarations (except when using variable length arrays).
Good shout, I hadn't tried doing those with a `static const int`; you're right.
Note that if you are programming in C++, then you are not programming in C. C and C++ are separate languages and C++ is off topic in here. For this reason I have removed your post, even though it is very interesting. I welcome you to post C++ projects to /r/cpp.
oops sorry! thanks for the note, i will look at /r/cpp have a nice day :)
**Here's a sneak peek of [/r/cpp](https://np.reddit.com/r/cpp) using the [top posts](https://np.reddit.com/r/cpp/top/?sort=top&amp;t=year) of the year!** \#1: [Visual Studio adding telemetry function calls to binary?](http://imgur.com/TiVrXyf) | [214 comments](https://np.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/) \#2: [g++7 is C++17 complete!](https://gcc.gnu.org/projects/cxx-status.html#cxx1z) | [31 comments](https://np.reddit.com/r/cpp/comments/5nee0r/g7_is_c17_complete/) \#3: [operator &lt;-](http://www.atnnn.com/p/operator-larrow/) | [48 comments](https://np.reddit.com/r/cpp/comments/4v7xyn/operator/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
[removed]
If Vim is to steep, how about Emacs + evil-mode? 
When you can reasonably inline the function body, and are in a position where you don't want to pay for a function call. I use a mix of the above commenter's tagged unions for type resolution and macro functions for operating on them, in some cases a few levels deep. There's a trade-off between size and speed. Call a macro function too often and you risk code bloat; use a regular function in a hot path and you risk slowdowns. I only use macro functions on bodies I know are either going to be on hot paths, or will expand to be roughly the size of a function call, including bookends. For everything else, there's the `inline` keyword.
You might get marginally better precision in this particular implementation of cos if you computed your power sequence in reverse order, starting with the 21 and ending at 1. You could be losing some least significant digit precision through rounding by adding very tiny terms to the larger values in early terms. Add all your tiny terms together first with near full resolution, in case they add up enough to be significant. Or you could not use the hard-coded 21, and compute terms until the sum converges, which would fix your large value problem. Or you could add/subtract multiples of 2 pi from your start value until you are in the [0, 2 pi) range, and then use your 21 iteration technique. 
Since macros expand into C code they're never _absolutely_ necessary. They're a convenience. Ideally they're used to make your code more readable/maintainable, but that's a rather subjective criteria. Macros are so flexible and are used (abused) in so many ways it's really hard boil it down to a handful of guidelines. Here's a couple of thoughts: I think the most legit use for them is in defining constants, and even then there are often better alternatives (e.g. enums). Sometimes a .c file contains large tables of data. Macros can help make that data more legible. Read up on [x-macros](https://en.wikipedia.org/wiki/X_Macro) - a somewhat _advanced_ technique that can be useful for this sort of thing. Sometimes they're used to avoid the overhead of a function call. Make sure there's actually a problem before using this justification. For code that's local to a file I'd use static fns instead. Nowadays, compilers are pretty smart about inlining them. People can go nuts with them and basically write a language on top of C. There are some pretty clever macro sets that give you "object oriented" syntax. Personally, I'm not a fan of this category. Sometime they come about when people notice they're repeating the same code over and over again. E.g. they invent some clever loop generating macro. I'm not typically a fan of these constructs either. When you run into a situation that you think calls for a macro, post it here. Hopefully someone will be able talk you off the ledge. 
I mean you can inline functions with an optimizing compiler (like clang) so that goes right out the window too... and for #DEFINEs you've got enums, so AFAIK there's no real use for macros anymore (outside of #include, header guards, and pragmas)
An easy way to find these kind of things is to always include a default: entry in your switch() statements which prints/logs/exits when you get input that you're not expecting.
Looked through my current codebase and found a few macro functions. Most deal with tracing, adding __FILE__, __LINE__ and a trace type qualifier. There are few others that I would put in the lazy / makes the code look nicer category. One useful one that gets used all over the place wraps a message handler callback setup function. #define SERVICE( code, callback ) Service( code,# code, (callbackType *) callback ) The `code` is a defined constant, `#define SRV_DO_THIS 0x1234`. This uses the # stringify operator. The end result is the Service function gets the value of the code as the first argument, a string describing the code as the second argument and the callback as the third argument. Handy for tracing. SERVICE( SRV_DO_THIS, doIt ) becomes Service( 0x1234, "SRV_DO_THIS", (callbackType *) doIt )
Getting closer, but your description could be more precise. (My explanation may not be much better... please, no one tear me down for using terminology a bit wrong.) &gt; In memory, an array symbol is a pointer to the first element. No... in memory, "symbols" don't exist. Those only exist in the C language, but there is no such thing in machine code. &gt; In the compiler, an array symbol is known to be an array, not a blank pointer. In the compiler, an "array" is a symbol – that is, a *name* – for storage of a known quantity of values of some type (scalar value (`int`, `double`, `char`, etc.), enum, struct, etc.). A "pointer", when we're talking about a variable, is a name for storage of the value of a memory address which will point to some type. It's important that we frame this in terms of *storage of values*, because that's what the compiler really sees. When translating to machine code, though, the compiler has to work with that the C standard requires and what the machine provides. It's not possible in C to pass an array to a function *by value*, where you copy every element of the array. Even if you describe the parameter using array syntax, what you get is a pointer (although the pointer is passed by value). int globalArray[10]; /* array */ // sizeof(globalArray) == 10 * sizeof(int) void functionA(void) { int localArray[10]; /* array */ // sizeof(localArray) == 10 * sizeof(int) } void functionB(int* parameterPointer) { /* obviously pointer to int */ // sizeof(parameterPointer == sizeof(int*) } void functionC(int parameterArray[]) { /* pointer to int */ /* It can't be an array because we don't know its size, and arrays in C always have known size. Without knowing the size, we can't create storage for an array. */ // sizeof(parameterArray) == sizeof(int*) } void functionD(int parameterArray[10]) { /* also pointer to int, even though we know its size */ // sizeof(parameterArray) == sizeof(int*) } The thing is, you can't actually *do* anything with a symbol that's an array. For instance, you can't do this: int x[10]; int y[10]; x = y; Here are the only things you *can* do. You can use one of the *values*: x[0] = 42; or you can use the whole array by causing it to degrade to a value which is a pointer to the first element: int* z; z = x; // or using our functions from earlier functionB(x); functionC(x); functionD(x); In effect, we could really say that declaring the array is actually declaring sequential storage for 10 values, whose "names" (in air-quotes) are `x[0]`, `x[1]`, `x[2]`, `x[3]`, `x[4]`, `x[5]`, `x[6]`, `x[7]`, `x[8]`, and `x[9]`. And it also declares a "name" (in air-quotes) `x`, whose value is the address of `x[0]`. That's why `functionC(x)` does exactly the same thing as `functionC(&amp;x[0])`, because `x == &amp;x[0]`. Except that the *type* of `x` is not "pointer to int". It's "[array 10 of int](http://cdecl.org/?q=int+x%5B10%5D)". So when you do `sizeof(x)`, which always tells you the size *of the type*, it knows that its size is `10 * sizeof(int)`. But when you do `sizeof(&amp;x[0])`, it has to process that in order: take `x[0]`, which is the "name" (in air-quotes) of an `int`, and then get its address, which will have the type `int*`... so that gives us the same thing as `sizeof(int*)`. As [C FAQ 6.2](http://c-faq.com/aryptr/aryptr2.html) explains, this difference is also why the compiler *may* end up generating different code for arrays versus pointers. When you say `x[3]`, you're using the "name" (in air-quotes) of storage for an `int`; the compiler can probably emit code that directly references that location, without any math, and if it can prove that it knows what that value will be (e.g., because `x` was actually declared `static const int x[10]` and the compiler knows nobody cast away the const) then it can substitute the actual value. But given a pointer, the compiler usually can't prove that it knows that the value of that pointer will be, so it *must* do the math: get the value of the pointer, add `2 * sizeof(int)` to it, and then get the value at that location. (However, if the function gets inlined or IPA is applied, the compiler may be able to prove that it knows what the value of the pointer will be, and then it can optimize by precomputing what `p + (2 * sizeof(int))` will be.) Try some of that yourself in the [Compiler Explorer](https://godbolt.org/). Try global arrays, local arrays, array parameters, and pointer parameters. Try with and without optimizations (nothing vs. `-O1`, `-O2`, or `-Os`). Try making the arrays plain, `static`, `const`, or both. If you have two functions (you'll need two sometimes so one can call the other passing the appropriate array as a parameter), try the called function plain, `static`, and `inline`. (Interestingly, I tried making a const array, casting away the const, and changing a value in the array. It didn't do what I expected! I guess that's undefined behavior after all, in which case the compiler is free to do whatever it wants.)
Macros are very powerful but they need to be used judiciously. (Helpful, right?) If you have toolchains that manipulate/observe the AST (Abstract Syntax Tree) then those tools can't discern macros, and macros can make things difficult. On the other hand, macros are extremely good for ensuring portability, as you've probably noticed, and substituting custom versions of functions (malloc() is a favorite function to replace in the past). Also, you're right in targeting C99. 
Macros make sense more often than you imply. Also, we shouldn't use pragmas -- they're extremely nonportable and it's very much a mistake to use them. I haven't ever seen a pragma that wasn't handled properly and portably with other macros. They're a crutch that are used in certain insular programming environments. 
I use #ifndef NDEBUG, which is the same macro that switches asserts. A basic example (many coding standards specify the # always in the first column): #define MYDEBUGMACRO(x) fprintf(stderr, "\t **DEBUGLVL=%s**: %s@%s:%d\n", #x, __func__, __FILE__, __LINE__); #ifndef NDEBUG # ifdef DEBUG # if DEBUG &gt;= 2 MYDEBUGMACRO(2) # endif # endif #endif Output: **DEBUGLVL=2**: main@code.c:20 
Yeah, I just had to use one for win32 compatibility; but I stand my assertion that writing macro functions is pointless at best, and defines are almost always better written as enums. Depends on the pragma, All I use it for is once, and I've been playing around with OpenMP lately. I was using the poison macro to not use "bad" standard library functions but I never did and the compiler warning got annoying.
[removed]
Split it into whole and fractional (careful with negative values), then use `%lld.%02u`. Alternatively, `sprintf` it with a minimum number of places `%03lld`, then slice up the string to add the decimal point.
so you're getting caught up on how to create your shift table/array based on the user supplied substring? If so, I find that the wikipedia article on the KMP algorithm is actually pretty well written. (https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm) Basically the user input string needs to be preproccessed to create a skip table. This is done by looking for parts of the string that internally match. So that when going searching through the longer subject string, if a mismatch occurs between the query string and the subject string, you don't have to start all over again, but instead can skip a certain amount of comparisons. The walk through on the wikipedia page is pretty good. I'm a bit confused about your subject vs query sequences, how big they are, and where they are coming from. You have two sequences, a larger one that you are searching *through*, and then a shorter one that you are are searching *for*. How long are each of these, and how are they being provided to your program? 
It makes sense, though, doesn't it? I'd say it's preferable. The right tool for the job and all that
alright thanks I will fix this
Also note you are using values for `errno` like `EINVAL` that aren't part of ANSI C (but in POSIX). Perhaps you might want to explain that your library requires POSIX. Lastly, why a single header file? That's a terrible way to design libraries.
so you need to turn ADAAG into int[] = {-1, 0 , 0 , 1, 1}. Basically as you match the query string to the subject string, when you hit a mismatch, how many places in the query string can you skip matching. I won't be able to explain the algorithm itself any better than the provided websites do. If you have trouble implementing a particular operation in c-code free to ask.
this is the best I can do: char *query = "ADAAG" char *subject = "GTGAGCADACADAAG" // this is the skip table for "ADAAG" // it needs to be calculated for each input int skip_table[] = {-1, 0 , 0 , 1, 1} as you move the query along the alignment: index of subject: 0123456789... subject: GTGAGCADADAAG |||x query: ADAAG skip table: -10011 index of query: 01234 ^ so during your seach, you get to subject[9] and find subject [9] != query[3] so you find skip_table[3], which is 1. This means that as you stay at subject[9] and start over with the query, you can skip to query[1] and compare query[1] to subject[9] index of subject: 0123456789... subject: GTGAGCADADAAG | query: ADAAG skip table: -10011 index of query: 01234
Just making sure I understand this right, I will probably need more help but just the basic idea. In the example 0 1 2 3 4 5 6 7 8 9 10 11 A A G A G A A G A A A C 0 0 1 0 1 0 1 2 3 4 2 2 Where the 3rd row is the shift table. It is basically saying if I have a nonmatch at the argv[1][6] I have to restart from this point at argv[1][1] or if I have a nonmatch at argv[1][11] I would have to start again at argv[1][2]? And if argv[1][11] is equal to c(where I am in the text), I have a match at that location? Am I understanding that correctly? I guess my next question would be, without knowing the letters in argv, how would I go about setting up the shift table?
yep you get the idea. one thing: the first int in the skip table, skip_table[0], is set to -1 automatically. It's a special case, which you handle specially: when you have a mismatch at position 0 you have to advance along both the subject and the query. Yep the next question would be can you find the pattern in this process and put into code. This is where the articles you linked to talk about prefixes and prefix matching. One other thing, you should be able to just use strlen(argv[1]) to get the length of the input string, if you want. It should be null-terminated. 
A header only library is just easy to work with. I get that the most common problems with them is potential file size bloat due to inlining all the functions, but the mechanism '#define CML_IMPLEMENTATION' prevents this. If you really wanted to you could just have a .c file and put this in it: '#define CML_IMPLEMENTATION', '#include "cml.h"'
&gt;don't use void * I'm hoping you mean with macros and not just general. But yes that's how i used to do it. I'm considering using a variety of both normal functions and macro functions where for example the vector_init function would take in the vector and the sizeof the desired type as well as the vector size and you would do the whole memory allocation thing, however for things such as removing a specific element and the equivalent of c++'s pushback require some type of macro as I don't see any way of doing those without knowing the vector type, thank for your help by the way!
&gt;Helpful, right? very ;). Actually though thank you for the help and answering!
Wouldn't it make sense to define an error enum and return that instead of mucking around with errno at all? Or is setting errno a common thing even for libraries like this?
It is just defining the struct in-line: ".tag = tag" will assign the value "tag" to the "tag" field of the struct that will later be assigned to the content of cmd. With this syntax note that any field not mentionned will be initialized with 0.
Ah right thanks! That is kind of what I suspected. Just wanted to make sure :) Also I just remembered I have another small question. In the code I am reading through, at one point right after the case is defined for a switch statement it has brackets {} and all the code relating to the case is defined in there. The thing is that some cases don't have {} while others do. The code writer commented that {} was included to create a scope so he can declare more variables. Do you know what this could possibly mean? Because I don't see why you need the scope specifically to declare the variables. I can include some of the code if this sounds rather confusing. 
Thanks for this, it worked perfectly. printf("Expected bit(s) = %u \n", (buffer[byte] &amp; 1)); int idxToCheck = bit + byte; int *array1 = malloc(sample * sizeof(int)); array1[idxToCheck] = (buffer[byte] &amp; 1); printf("Expected bit(s) = %u \n", array1); Why is it that when I try to add each bit to an array, it adds large integers? The sample variable should already be initialised at this stage(want it to be dynamic as it will change depending on the .txt file used to embed). The print is just there to check what's being added.
Even in C99, case labels cannot attach to variable declarations. You have to use a block as the case target in order for that to work.
I guess? I only do so if I have variables to declare, personally.
What, no one likes C anymore? I guess too many companies just see C as an inferior C++.
it's hard to tell, since you have a lot of errors in there. I would suggest you do it incrementally. Write a small C program that can take a string and creates the skip table, then add handling argv input, then add searching for this string in another string via the skip table, then add using stdin to get the second string. is there a reason your using KMP vs boyer-moore or something else? I'm guessing this is a class assignment?
well it's telling you that the argument you are passing to `prefixSuffix()` is a char** if you look at where you define `findThisString`: char * findThisString[strlen(argv[1]-1)]; you are actually declaring an array of char* 's (an array of pointers to chars, aka a pointer to a block of memory with pointers to chars, aka a char**). I would just do char * findThisString = argv[1]; int lengthOfPattern = strlen(findThisString);
Okay, so I cleaned up a little bit and got part of it working. However, for some reason after it runs the 10th time here it just stops running as if there was a blank infinite loop and I can't find it. I'm also have 0 warnings when using -Wall include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int currentLine = 1; int currentRow = 1; int c; void nextChar(); int* prefixSuffix(char*, int, int[]); int main(int argc, char * argv[]) { char * findThisString = argv[1]; int lengthOfPattern = strlen(findThisString); int j = 0; int shiftDataInfo[lengthOfPattern-1]; while(j &lt;= lengthOfPattern){ printf("%2d ", j); j++; } printf("\n"); j = 0; while(argv[1][j] != '\0') { printf("%2c ", argv[1][j]); j++; } printf("\n"); prefixSuffix(findThisString, lengthOfPattern, shiftDataInfo); while(c != EOF ){ nextChar(); } return 1; } void nextChar(){ c = getchar(); currentRow++; if(currentRow == 70){ currentLine++; currentRow=1; } } int * prefixSuffix (char * thisPattern, int length, int shiftDataInfo[]){ int j = -1; int i = 1; shiftDataInfo[0] = -1; for (i = 1; i &lt; length; i++) { while (j &gt; -1 &amp;&amp; thisPattern[j+1] != thisPattern[i]) j = shiftDataInfo[j]; if (thisPattern[i] == thisPattern[j+1]) j++; shiftDataInfo[i] = j+1; printf("This number is %d \n", shiftDataInfo[i]); } return shiftDataInfo; } My return is 0 1 2 3 4 5 6 7 8 9 10 11 12 A A G A G A A G A A A C 1 0 1 0 1 2 3 4 and then it just keeps running with nothing happening However, if I don't have the \n in the printf statement in the prefixSuffix, I am getting 0 1 2 3 4 5 6 7 8 9 10 11 12 A A G A G A A G A A A C Still running but nothing happening already This doesn't make sense at all, why would the \n make the numbers not print? 
edited the last one with brackets. I get the same result
Just kidding, no option to edit. Here it is. int * prefixSuffix (char * thisPattern, int length, int shiftDataInfo[]){ int j = -1; int i = 1; shiftDataInfo[0] = -1; int shiftArray[length]; shiftArray[0] = -1; for (i = 1; i &lt; length; i++) { while (j &gt; -1 &amp;&amp; thisPattern[j+1] != thisPattern[i]){ j = shiftDataInfo[j]; } if (thisPattern[i] == thisPattern[j+1]){ j++; } shiftDataInfo[i] = j; shiftArray[i] = shiftDataInfo[i] + 1; } int k = 0; while(k &lt; length){ printf("%2d ", shiftArray[k]); k++; } printf("\n"); return shiftDataInfo; }
As /u/antiquark2 said, it depends on the compiler. A compiler is not the only program needed to produce executable target program, in fact the 4 phases you wrote are part of a *language processing system*. Let's forget about GCC for a moment, I'll try my best to briefly describe each phase in a general way. Since a source program may be divided into modules and stored in separate files, the task of collecting the source program is *sometimes* entrusted to a different program, called **preprocessor**. The modified source code is then fed to a **compiler**, that **may** produce assembly-language program as its output, because assembly is easier to produce as output and easier to debug. The assembly language program is then processed by the **assembler** that produce relocatable machine code as its output. Because large programs are usually compiled in pieces, the relocatable machine code may have to be linked together with other relocatable object files and libraries files into the code that will actually run on the machine. The **linker** then resolves external memory addresses (where the code in one file may refer to a location in another file, see keyword *extern*), the **loader** then puts together all of the executable object files into memory for execution. So generally speaking that's what usually happens. Another thing to note is that the compiler is not just a "single program" or a single box that maps a source program into a semantically equivalent target program, but the compiler can be divided into two parts: (1) analysis (also called front-end) (2) synthesis (also called back-end) Without going into too much details, the compilation process can too be divided into phases (which can be grouped into passes): https://i.imgur.com/Pbq7dnt.png The first 4 phases make up the analysis part, the rest make up the syntesis part. I'd like to continue but I'm afraid it'd result in an extremely long wall of text, if you want to read more about this I can reccomend some books.
The scanf in the second while loop is probably reading the newline that's left on the stream after the earlier one reads an int.
Would be cool if you'd add a [rotate function](http://pdl.perl.org/PDLdocs/Slices.html#rotate), that shifts vectors. When I saw the [Conway's game of life one liner in APL](https://dfns.dyalog.com/c_life.htm), I wanted to reimplement it and see how good I could golf it in C, but failed to find a library that provides it out-of-the-box. I eventually went [with Perl/PDL](https://metacpan.org/pod/Graphics::Raylib#Conway's-Game-of-Life). EDIT: typo
you either need to: 1. malloc a piece of memory, put your skip table array there, and return the pointer to it, 2. or you can pass the memory in which to put the data as a parameter. You are actually already doing this, as you are passing to the function `shiftDataInfo[]`, so just put the skip data in this array and you can use from main(). 
OP gave no constrains so I can watch an healthy discussion of pros &amp; cons. C is a nightmare around my course and I'm trying to understand the best practices
I think you're overthinking it. Why not just # add your object files here ARCHIVEOBJ=obj/obj1.o ... UNARCHIVEOBJ=obj/obj2.o ... TAROBJ=obj/obj3.o ... all: my_archive my_unarchive my_tar my_archive: $(ARCHIVEOBJ) $(CC) $(LDFLAGS) $(CFLAGS) -o my_archive $(ARCHIVEOBJ) $(LDLIBS) my_unarchive: $(OBJ1) $(CC) $(LDFLAGS) $(CFLAGS) -o my_unarchive $(UNARCHIVEOBJ) $(LDLIBS) my_tar: $(OBJ1) $(CC) $(LDFLAGS) $(CFLAGS) -o my_tar $(TAROBJ) $(LDLIBS) obj: mkdir obj obj/%.o: src/%.c obj $(CC) $(CFLAGS) -c $@ $&lt; clean: rm -f obj/* my_archive my_unarchive my_tar 
I could be wrong, but maybe because it sees obj2/3 as the same as obj1 and thinks there's nothing left to do? Try switching to 3 different src directories
Yeah, I am particularly interested in learning about micro-controllers, I think I need to know more about c before I can dive into that though. Although if you have any references for microcontroller stuff I would be interested I was specifically asking about the "K &amp; R" books "dated-ness" in relation to current c not disparaging c. Thanks EDIT: I reread my answer and can see how I left that ambiguous, I edited the post
Just click on “search” to search for old posts. That's it.
The norm is that a compiler produces assembly which it then passes to an assembler.
Ah, so do you think that K&amp;R would be good enough for current c? Would it be good enough for arduino stuff as well? Thanks for the help
Also only up to 32 bit which can be a PITA.
Yep; My dad and I wrote a suite of loan-processing software using floats once. We'll never make that mistake again.
They're specifying how to parse floating point and integer constant literals. Or rather they are specifying placeholder fragments that are used later to form complete definitions. The first one corresponds to the exponent part of a floating point literal, e.g. `42.5e10`, and similarly for the second one and hex-float format, e.g. `0x6.2fp+36`. The other two are for the various suffixes, e.g. `42UL` or `42LLU` or `42U` or `1.4f` and so on. 
Look below where they are used. Looks like scientific notation and floating point symbols. Check out http://en.cppreference.com/w/cpp/language/floating_literal 
I really like Atom but I only use it for js, html, etc. When I'm working with C/C++ I want to have a debugger ready to go so I just use MSVS or if it's embedded-c I'll use whatever debugger is appropriate for the hardware. EDIT: By the way the best improvement I've seen in Atom wasn't with packages but with taking the time to set all the keybinds and options to how I think they should behave. This goes for all editors.
le my_tar est pas si dur, rtfm
[removed]
"Hey guys I have to find a subject for a 2.5 years long project, any ideas ?"
`E` defined the exponent of a floating point number: `1234e+56`. `P` does the same thing for hexadecimal floating point numbers. `FS` are the valid suffixes for floating point constants, `IS` are the valid suffixes for integer constants.
Visual Studio Code has an official c/c++ package that, I believe, includes support for debugging. If you like Atom and want to stay with free tools it's worth checking out. BTW: it runs on Linux and Mac too. 
I use Visual Studio at work and when I need to just edit a small file that isn't part of a project I use Visual Studio Code. 
I had not, and that is what I want to write. Thanks. 
Any feedback would be greatly appreciated. 
You shouldn't have the actual code for your functions in your .h files, just their declarations. utilfuncs.c should have the code, utilfuncs.h should have the function declarations, then you include utilfuncs.h in your keywords.c file and the linker connects everything together.
Thanks! Do you recommend it over the clang linter? (And if so, why?)
Post a self-contained code example 
[removed]
&gt; the linker looks in associated C files for the function definitions. To be correct: The linker looks in the *object files* you tell him to look in for function definitions. The linker doesn't even know that there's a source file.
You're not linking in the turtle library. You will have to ask your instructor about that because it depends totally on your environment.
`-L` takes a directory, not a filename. You can either write `-L/usr/share/p2t/lab05 -lturtle`, or you can just provide the name of the archive directly, without any flags. 
I tried both of those, but it still keeps bringing up the same error.
Post the full, exact command. The order of options matter, so make sure the library comes after the things that use it (like your .c file.)
I took `libturtle.a` out of `-L`. I put `-lturtle` at the end of the command but I'm still getting the error: `usr/bin/ld: cannot find -lturtle` `collect2: error: ld returned 1 exit status` This was my command: `gcc --std=c99 -Wall -L/usr/share/p2t/lab05/ Lab5-Exercise2.c -o ex2 -lturtle`
It sounds like there isn't actually a file at `/usr/share/p2t/lab05/libturtle.a`. What's the output of ls -l /usr/share/p2t/lab05/libturtle.a And the output of file /usr/share/p2t/lab05/libturtle.a 
First output is: `/usr/share/p2t/lab05/libturtle.a` in green. Second output is: `/usr/share/p2t/lab05/libturtle.a: current ar archive`
Didn't you just post about a problem with scanf and get an answer? You're still making the same mistake. You're also trying to use a variable before it's initialized to a value. That's bad. Hint: turn on your compiler warnings (-Wall -Wextra for GCC) and pay attention to them.
What is it actually printing?
I'm not the hiring manager, just an employee, but my company is hiring quite a few people right now. **Company:** Eaton **Type:** Full time **Description:** Lighting control **Location:** Peachtree City, GA, USA, English **Remote:** possible for the right candidate **Visa Sponsorship:** not sure **Contact:** [here](http://www.eaton-jobs.com/ListJobs/ByKeyword/peachtree%20city%20embedded/) Edit: Reformatted
When you write **fib1 = fib2** you're actually shuffling pointers around, not actually assigning a value to another value. Same with **fib2=result**. However I'm not familiar with HugeInteger. Maybe try with a "long long", that will give you integers up to approx 10^19.
Will this work with a set amount of columns? Just do away for the COL parts of the code? What I am doing right is just setting the amount of possible to 5000 and just allowing the user input to dictate the amount of rows up to that amount of course.
&gt; strcpy_s(prompt, strlen(prompt), &amp;argv[outerloop][innerloop+1]); You should use **sizeof** instead of **strlen**. What's probably happening is that **prompt** is (by chance) initialized to zero bytes, so **strlen(prompt)** is returning 0, so **strcpy_s** complains that **size_in_elements** is zero.
Hmm... replacing `strlen(prompt)` by `10` makes the error go away but pretty much ignores the parameter completely. :(
`prompt` is a `char[10]`... Ah. OK, that was stupidity.
Thank you. :-) `sizeof(prompt)` does not crash anymore. (But it also does not work - it should call `showUsage()` but it doesn't. Hm.)
A general debugging trick is to printf the strings as you're about to use them, to make sure they are what you think they are. Or, try single-stepping with a debugger if it's available. 
Thank you. :-)
This works for me: printf("line equation: Y = ±%f * x ±%f\n", m, b);
Emacs. Or vim if you're one of *those* people.
-c isn't a recognized option for me. Man page with list of options: http://i.imgur.com/pCakzaI.png
Good call, will check that!
are they easy to use?
OpenBSD flavor nc try -N instead. http://man.openbsd.org/nc.1
Found some bugs after your advice, but after fixing them I still don't receive anything. Mind taking a look at the updated code, in the post?
Notepad++ is pretty simple. https://notepad-plus-plus.org/
As one of *those* people, vim is probably the weirdest text editor you'll ever see. It has a steep learning curve. Emacs is apparently slightly better about it's learning curve, but I couldn't say from first hand experience. That said, Emacs and Vim are the go-to text editors for c. Neither of these are really IDEs, so they won't resemble code-blocks much at all.
Emacs is. Vim probably is if you spend quality time with the tutorials.
I see, can they both compile and run the code? Or will i have to find an online compiler? 
Two things: 1. I personally like Sublime Text, it works well for how I work. 1. I may have misread things, so throw this out if this isn't where you are at. But, over the course of your C "life" you will need 2 types of editors. The first is an editor which you learn C in; the second type is the full-featured editor you use after you learn C. While you learn C, your editor should not be very exciting. The reason your first editor should not be exciting is that you should be spending time learning C, and the tools for building C projects. Having a fancy editor has a tendency to get in the way. It's much more important to become familiar with C itself, your compiler (gcc, clang, vcc), and your build automation tools (make, Cmake, IDEs). Once you are familiar enough with the language, and the other tools, it then makes sense to look for a more exciting editor. So, the deal with full feature editors is that they are not an end in themselves. The are another tool and their only job is to make it more efficient for you to write programs. There is a never ending flame war about which is "best". Ignore it. Try Emacs, get good at it, and see if it works for your brain, do the same with VIM, N++, Sublime, Atom, VS Code. Try as many as you want. Stop when you find one that makes you forget you are in an editor and you can just write your program. 
How many times a day does this question get asked on reddit? Or is it an hourly question?
windows
Not at all. But once you get used to them you'll wonder how you ever did without.
lol ill see how to use them 
[removed]
If you're running on Windows, you might be in for some real pain. Maybe someone else has good advice for installing an easy compiler, but I've never found it to not be a pain. My current "compiler solution" is to use the MSVC compiler. It comes with Microsoft Visual Studio, which has a free community edition [here](https://www.visualstudio.com/vs/community/). After you download it, you might try using Visual Studio as an IDE. I don't love it, which is why I use vim. I still prefer to compile by command line by opening a cmd and calling the compiler by hand. This is admittedly a round-about process. I have a batch file that I put in my project directories, it contains this: &gt; call "c:/Program Files (x86)/Microsoft Visual Studio 12.0/vc/vcvarsall.bat" x64 This line makes it possible to call Microsoft's compiler by command line, assuming you installed visual studio in the standard spot. I usually call this .bat file "setup.bat". So I open the command prompt, type &gt;setup.bat Then I can invoke the compiler "normally" just like you would invoke gcc or clang with &gt;cl main.c -o out.exe I will be the first to admit this is kinda meh as a process, but compilation for c and c++ will be kind of disgusting no matter what you do. I have found this is the most reliable approach for a new project in c or c++. Edit: Grammer.
it just sucks that they make it so easy for you to program for java for a windows machine but mission impossible for c on a windows machine. 
[MSYS2](http://www.msys2.org/) is a popular distribution of MinGW-w64 (GCC compiler suite) and Cygwin for Windows, with the pacman package manager similar to Arch Linux. It doesn't include a text editor, but any of them will do. 
If OP doesn't have the root permission: ./configure --prefix=$HOME/opt make &amp;&amp; make install export PATH="$PATH:$HOME/opt/bin" valgrind
Simplify the program. Remove the nonblocking code and the select() code. Get *that* working then go back and add in the nonblocking select() stuff. 
Ah. I don't use an IDE :) I use vim and actually have git autocomplete in my .bashrc file. It is pretty great and I would definitely recommend it if you get around to using it. Thanks for the link though! I'll check it out if I get around to using Atom. 
After trying programming C in vim, Sublime, VS Code and Atom, I think I have settled for Atom for now. The choice of editor really is a matter of personal preference, but I use Atom for the following reasons: - It's free software - Good support for C (and pretty much any language) without proprietary plugins (unlike VS Code) - Has (for me) the most important features of Sublime - Highly customizable, for example with an integrated terminal and vim mode - Nice handling of "projects", namely they are pretty much just sets of folders that can easily be restored
You could save yourself some money and install linux on your PC (or in a VM, or dual boot if you want to keep windows as well)
like this? gcc pacman.c map.c path.c -lcurses if so, can u explain the reason or give a source so i can read about it ? 
No. The linker can only consider files you tell him to look at.
You are almost exactly right. Include the header in both your lcd.c and main.c files, but don't #include .c. Instead you will compile each of those files and link them together. I am not familiar with Atmel studio, but IDEs usually have a concept of a "project" and files that go in the project. You just need to tell it that both "main.c" and "lcd.c" are in the project and all should be fine. Libraries are not more efficient; it is just a way of organizing code. For what you are doing, directly linking the files together is fine.
Thank you 
Thank you! So I guess my only problem now is getting Atmel Studio to recognize both .c files and compile them together. I would like to be able to use these .h and .c files in other projects so I would rather them not be required to be inside the same project folder if possible. I will look more into it, and thanks again!
Please format your code by putting it in a paragraph on its own with four blanks (that is, a space character, not an underscore) in front of every line of code.
**Short answer:** `char* name` already *is* a string. "String" in C just means "pointer to an array of characters". `char* name` is a string. If you wanted a pointer to a string, that would be `char** name`. **Longer answer:** If you read the manual for `printf()`, you'll see why `%s` behaves this way. From the [Linux printf(3) man page](https://linux.die.net/man/3/printf): &gt; s &gt; The `const char *` argument is expected to be a pointer to an array of character type (pointer to a string). Also, a fairly technical note: usually we're more specific and say a "string" in C is a pointer to an array of characters, with the end of the string denoted by a null character (a character with the value `0`, typically written as `'\0'` to indicate that we mean the character not the integer). The length of the string is then implied: it's the number of characters before the null character, which could be 0. A pointer to an array of characters that isn't terminated by a null character isn't a "string" in C; it's just an array of characters.
First off, probably oughta be `const char *name = "john";` because `"john"` is a probably-not-modifiable array per the standards. Could also be `static const char *name` because `name` should always point to the same thing no matter how many times you call `main`, but that’s mostly beside the point. Second, it’s not working (and any C compiler with all its warnings enabled should tell you this—with `gcc` or `clang`, use options `-Wall -Wextra`) because `name` is a pointer to zero or more `char`s. When you pass it to the first `printf`, it receives the starting address of the string array and will internally toodle through that until it hits a NUL. The second `printf` receives *the first character in the string* (`*name` ≡ `name[0]`), which is promoted to an `int` because it’s in a function argument, and which `printf` will then interpret as a `const char *` like the first `printf` does. The first character should be somewhere from −128 to 255, any of which is a pointer to bogus memory space on most OSes, and so your code will segfault or bus-fault or just die in some unusual way. Remember that functions have no way of telling what’s actually passed to them—things like `printf` have to go by what the format string says, and `%s` says “use the next argument as a pointer.” And of course, if you want to refer to a string in its entirety, you need a pointer to the beginning of the string (i.e., `name` alone), not some dereferenced content from the string (e.g., `*name`).
Yes, like: if(0 == strcmp(val,"square")){ etc 
Lol, probably not. You could get an Indian printing of the book for pretty cheap if you're worried about it. The cover is teal, and the paper is much thinner, but AFAIK, it's at least authorized. 
The C isn't even centered! Yeah looks sorta fake!
The second printf also lacks a ". See the other answers for the actual problem.
Actually, ["programing" is not completely incorrect](http://english.stackexchange.com/questions/244280/programming-versus-programing-which-is-preferred).
Got the samd book on my hands without the typo. Everything else is the same. Maybe the spaceing in the names kf the authors is smaller. Could possibly be! :D
The language doesn't have classes, but that doesn't mean you can't use the same concepts. GTK has to manually implement a lot of concepts that aren't found in C, like an object system. You can still write code that uses object-oriented techniques without explicit support from the underlying language. (For another example, the Linux kernel implements a sort of class inheritance system built from structs of function pointers, kind of like virtual functions in C++. [See this LWN series for more details](https://lwn.net/Articles/444910/).) 
thanks. That leads me into the other question I have just posted about the advantages of C programming for GUI development.
It is the C programming book, we just think it might be an unlicensed copy of it.
But why do we need this?
We don't need it.
You will rarely find an example that exactly matches your issue. You have to use them as inspiration for your solution instead of blindly copying. That said, turning a 1xN matrix into a Nx1 matrix is really simple. The only issue is how to allocate the destination matrix, and you don't give any information to know what the best way is. 
Personally I've only ever used GTK3. You're right in saying that it has far less documentation and up-to-date tutorials are even harder to find for GTK3, but it is (as you say) more "modern" and up to date. GTK3 also has huge advantages over GTK2 when it comes to styling, because GTK3 is styled using CSS. Also, If I'm not mistaken, GTK4 will likely break compatibility with GTK3. I think they want to rework GTK4 and clean it up (a good thing in my opinion). So you're also right in saying that GTK4 is irrelevant (at the current time) in terms of if you should choose GTK2 over GTK3. I would say: try both, and see what you find will work better for you.
Got it, that's exactly what I was missing. My first post.
The font and spacing looks different than my copy, so I'd say its probably fake. As long as all the info inside is correct though, you should be fine as long as you're gentle with it. 
[removed]
Like the 98% on life.
You obviously don't understand the Gravity of this situation.
I have this book out right now. Yours definitely has some differences.
Here we go: C programing https://imgur.com/gallery/dNqrT Seems it's really just the cover. From there on everything is spelled as programming.
You want a legal half price version pm me,i'll ship it to you from india.
*cough* I do hate to be a grammar nazi, but both "Programing" and "Programming" are acceptable spellings of the same word. Program is the US version of the UK Programme, and thus originally "Programing" was the US version of "Programming". Although the preference now leans towards "Program" and "Programming" which defies all logic. **Edit** Downvoting me because you disagree or because you think I'm incorrect? If you disagree, then don't downvote - comment. If you think I'm incorrect, then go do some research as I am not incorrect.
That is some well-written and organized codebase right there edit: however he is saying &gt;It is written in portable C code that can be compiled on any platform using a C99 compiler but I see this on his code https://github.com/marcobambini/gravity/blob/master/src/runtime/gravity_core.c#L153 he's using a non-portable pragma directive
The computer meaning behind program comes from this definition "to arrange according to a plan or schedule". Program and Programme have been words for a very long time before they gained the additional meaning. They come from Latin, not French, and have both been used since the 17th century. The US took the shorter spelling, as they did with most other words, whilst the UK took the longer spelling. Since computer programming was invented in the US, they used the term "Program" to refer to it, as that is the spelling they were used to. The UK initially used "Programme" but eventually switched to "Program". Both spellings are still considered correct, and both spellings of their present participles are considered correct. Don't try to correct someone without doing a little bit of research first... I mean seriously.
It's only non-portable if the pragma cannot be ignored without changing the meaning of the code. From what I see here it is just suppressing warnings. I would rather just omit the names of unused declarations or do (void)unused; than pragma though.
Why do we need most things? Because they're nice to have.
Not programming languages tho
It's true that (void) is legal syntax, but it's not a guarantee that it will suppress warnings on all compilers, rather it's more like an unspoken convention that some modern compilers may choose to follow. The safest solution in my opinion would be a long and tedious `#ifdef` macro.
It really depends. On libraries use return codes and (almost) never print anything. Leave the message printing and perhaps asking the user what to do to the main program. I'd really advise against jumps, they make the code really hard to reason about. 
Now it looks great! Thank you for caring.
The only semi-official rule: Do some basic research before you post so you don't annoy people with questions that can be answered by pasting the question into Google.
Personally, I don't know any good books. I got a lot of useful information by visiting the relevant class (outs was called *Operating Systems II*) in university, but obviously that's not a choice for everybody.
I thought the inside page said "test printed on recycled paper"
Sounds like a bigger project than you expect. I would say, start small: first get your tree diagram working for N=2, then N=3, then N=4, etc. 
&gt; If I understand alignment correctly I don't think you do, from your description. Let's say `size_t` is a 4-byte type, and I want to use vec to store `double` or `int64_t`, which are 8-byte types. On many processors, a `double` or `int64_t` must be aligned to an 8-byte boundary. If you try to read a value that's unaligned, it's a fatal exception and your program will be terminated. (Or in the case of my embedded system, the whole device will have to reboot.) You probably haven't noticed because x86 doesn't have such alignment requirements, due to its CISC heritage. However, accessing a value that's unaligned might be slower than one that's aligned. (Or [maybe not](http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/), due to advances in processor technology and caches.) If you had a struct like this struct { size_t cap; size_t len; size_t item_size; double value; }; the compiler knows the alignment requirements for the platform it's on, so it will add padding space to make sure everything is suitably aligned. The actual struct, in memory, would look like this: struct { size_t cap; size_t len; size_t item_size; char padding[4]; double value; }; However, since you're not using a struct and are just playing with void pointers, there's no padding and alignment being enforced. Your structure looks like the first one, and that's bad. The offset from the beginning of the struct to `value` is 12 bytes, which is not a multiple of 8. So it's probably going to cause errors on platforms that require stricter alignment. This is why using a struct is such a good idea. By doing so, the compiler will *always* take care of alignment for you, no matter what wacky platform somebody tries to run your code on. Without a struct, you have to implement padding and alignment yourself, which you can't do 100% correctly; the best you'll be able to do is make the code sufficiently tweakable that whoever is using your code can set some #defines to add the appropriate amount of padding, once they determine what that amount is. It's you and your users doing work that the compiler could have done for you. So as it is right now, vec is not "gimmicky and uses some nasty tricks"... it's *wrong*, and will crash when used on some platforms. &gt; having a struct with a void* would require two allocations instead of one For one, don't use a `void*` as a way to store "any type of value". It's only big enough to store any *pointer*, but not necessarily any scalar value. That should be obvious: on x86, pointers are 4 bytes, but `double` and `int64_t` are 8 bytes. Clearly, we can't use a `void*` to store the value of a `double`. That's why I suggested a union in the structure. That guarantees that the union will always be large enough — and suitably aligned — to store any type of value it can hold, whether it's a `void*`, a `double`, an `int64_t`, or anything else you add. (Maybe someone wants to store a `long double` that's anywhere between 80 and 128 bits, and requires 96- or 128-bit (12- or 16-byte) alignment. Simply adding a `long double` field to the union will automatically make that work correctly.) Second, although there are probably some portability corner cases to be careful of, there's no reason you have to use two separate structures, allocated separately. Just make one allocation, big enough to hold the array of values + the size of your struct - the size that the value or union type contributes to the struct. For this you want the `offsetof` macro. Stick one value at the end of the struct as a placeholder, but then treat it as the first element of an array... that is to say, take the address of it. Heck, you could even declare it as an array of size 1 in the struct. (I don't think this will have any effect on the padding or alignment. It would save you having to take the address of it, but it might cause more problems than that's worth as the compiler starts complaining about accesses beyond the array's bounds.) Basically, it would look like this: typedef struct { size_t cap; size_t len; size_t item_size; union { void* p; intmax_t i; double d; long double ld; } data; } vec; /* Let's say we want to store long doubles. */ size_t size_of_each_element = sizeof(long double); size_t num_elements = 100; size_t data_array_size = size_of_each_element * num_elements; /* FIXME: Check the multiplication for overflow! * calloc() does this, and you should too. */ size_t struct_size = sizeof(vec); size_t offset_of_vecs_data = offsetof(vec, data); size_t amount_vecs_data_and_trailing_padding_contributes_to_its_size = struct_size - offset_of_vecs_value; /* don't need this, but it's interesting to see */ size_t size_of_vec_header = offset_of_vecs_data; size_t amount_of_memory_to_allocate = size_of_vec_header + data_array_size; /* or in other words */ amount_of_memory_to_allocate = offsetof(vec, data) + data_array_size; vec* v = malloc(amount_of_memory_to_allocate); /* check for null */ ((long double*)&amp;v-&gt;data)[0] = 0.0; ((long double*)&amp;v-&gt;data)[1] = 0.0; ((long double*)&amp;v-&gt;data)[2] = 0.0; /* etc */ If you're going to do tricks with structures, packing, and arrays, you really need to read up on [structure packing](http://www.catb.org/esr/structure-packing/) and [alignment issues](https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt) on [various platforms](https://msdn.microsoft.com/en-us/library/aa290049\(v=vs.71\).aspx).
Learn MPI it is pretty simple and used a lot in industry
That makes so much sense. I never really had issues with alignment but after reading up I see why this can be such a big deal on different platforms. With that out of the way, the only option is the use of structs. Probably going to rethink this; thanks for the knowledge.
Is that in the USA? It would be great if you could add that information.
Yeah this is actually for my uni class too. I was hoping to get some reading in before labs start next week. I heard threading and parallel programming is the worst cause it is hard to detect errors in the code :/
Ah okay I see...also I think something you wrote got cut off from the last sentence? (Sorry if not just looked like last sentence was unfinished)
If you're looking for stuff to do the parallelization for you, you can look into OpenMP and MPI. They're awesome and what I learned in my Parallel Programming course. Otherwise, I'd look into p_threads (the only other multi threading thing I've learned).
Classic concurrent programming is indeed rather tedious. I prefer CSP based concurrency, which is what Go uses.
You'll just get a segfault if you're screwing with memory, otherwise, all functions will return a status code. Look at the 'RETURN' section of the function's man page.
It's copyright infringement, but something being illegal doesn't stop everyone from doing it.
That's the 48th printing. Of the second edition. I have the first printing of the second edition. It looks like yours. And someone else commented that they have the 49th printing and it looks like OPs. Weird. 
I think it's called with another command like `gcc-arm` (I'm not sure, I played around with it like a year ago)
If you installed `arm-linux-gnueabi-gcc`, then you actually need to invoke `arm-linux-gnueabi-gcc` to compile.
I've been meaning to look into [ConcurrencyKit](http://concurrencykit.org/) at some point. 
The windows C standard library is a pile of garbage. Yes it's often hard to write portable code, but for god's sake the whole point of the standard library is that you should be able to rely on the portability of it.
Looks like there's gcc-multilib-arm-etc packages. Try one of them? 
The gcc-multilib package does not install a cross-compiler. It installs the support libraries necessary to compile 32 bit x86 on a 64 bit x86_64 system (or vice versa.) You need to explicitly install and invoke a cross compiler, which will be completely different from a native compiler (i.e. they are different commands and different packages.) The gcc architecture only allows one backend to be enabled in any given build, so it's never going to be possible to target ARM from a native x86 compiler. (The x86 and x86_64 targets use the same common backend, which is why you can switch between them with `-m`.) 
&gt; The system call wrappers are defined within the C standard library libc To be pedantic, the BSD sockets library is not defined within the scope of the C standard library (what is usually considered as *libc*) but in the POSIX extension. Beyond that your post seems good. You have a good writing style. I don't see the point of going into so much detail with respect to linking but perhaps it isn't my cup of tea.
Many platforms provide outdated toolchains. If you program against the latest standards, then you're going to have trouble compiling on such platforms.
Many platforms provide outdated toolchains. If you program against the latest standards, then you're going to have trouble compiling on such platforms.
Clang has fully supported C11 by default for three years now.
Do you have a link? I would be massively surprised by this... Especially because clang doesn't provide a clib.
Note that `while (!feof(stdin))` [is always wrong](http://stackoverflow.com/q/5431941/417501).
&gt; Update: '.' character also gives the same results as the '+' character, so now I'm even more suspicious that it has to do with the scanf-double call consuming these problematic chars, thinking they're optional prefixes for some number. But a failed scanf match shouldn't change my stream reading position, right? I'm pretty sure this is the problem here. If I just do `scanf` for a char then '+', '-', '.' etc all work fine - it's combining the two that doesn't work. There's nothing in the manual for `scanf` to suggest that it rewinds the stream on failure, in fact it wouldn't be possible to rewind a stream like `stdin`. For your calculator you'll need to read in whole words rather than different types with `scanf`, and then convert them as necessary. Or parse the input character by character with a small state machine.
There is absolutely no issue with embedding Lua in iOS and Android applications.
As already pointed out, you'll need to install and correctly invoke the ARM cross compiler. The easiest way to do this is by installing the `gcc-arm-linux-gnueabi` package for software-float or `gcc-arm-linux-gnueabihf` for hardware float. To invoke the cross compiler you flip the target triple to be before the `gcc`, so for example if you install `gcc-arm-linux-gnueabihf` you invoke it as `arm-linux-gnueabihf-gcc`; you'll also have other utilities such as `arm-linux-gnueabihf-objdump`. You can check the list of available `-march` flags by deliberately passing garbage to it, for example: $ arm-linux-gnueabihf-gcc -march=. arm-linux-gnueabihf-gcc: note: valid arguments to '-march=' are: armv2 armv2a armv3 armv3m armv4 armv4t armv5 armv5e armv5t armv5te armv6 armv6-m armv6j armv6k armv6kz armv6s-m armv6t2 armv6z armv6zk armv7 armv7-a armv7-m armv7-r armv7e-m armv7ve armv8-a armv8-a+crc armv8.1-a armv8.1-a+crc iwmmxt iwmmxt2 native arm-linux-gnueabihf-gcc: fatal error: no input files As you can see, `-march=armv7-a` is listed. Hope that helps.
can you give me an example of those platforms? Do you mean in jobs where people used older version of C? or just in general some platforms might not work well with it?
I reckon any Linux produced in the past 5 years will support at least some form of C11. I think it's GCC 4.7+. Glibc 2.16+. I think saying "many platforms" is a stretch. Obviously every platform that predates the standards release would not support it. 
Again any platform that is older than the standard or close to it obviously won't support it. 
Let's start with the facts: * [GCC mostly supports C11 as of 4.9](https://gcc.gnu.org/wiki/C11Status) * [Clang supports C11](https://clang.llvm.org/compatibility.html), although I don't know as of what version. * [Microsoft Visual Studio (MSVC) is getting better](https://en.wikipedia.org/wiki/Visual_C%2B%2B#C99), but it's still mostly a C++ compiler that happens to also do C, and it doesn't support anything newer than C99. * Plenty of embedded processors, microcontrollers, DSPs, and PICs are only supported by proprietary compilers. It's a safe bet that those are going to be much more outdated. The particular one I use at my day job does fully support C99, but my company's coding standards require us to stick to essentially C89 because some of our customers do compile our code on proprietary toolchains that don't support anything newer than that. Now, the question is, who cares? The choice of a language, whether it's C vs. C++ vs. Go vs. Rust, or C89 vs. C99 vs. C11, should be made based on *your project's requirements and limitations* and *the advantages that the language provides you*. So first, what are your project's requirements? Do you need/want it to be portable to lots of platforms, possibly including embedded platforms that don't have modern C compilers? Or maybe this is just a personal project for your portfolio and you want to show off your knowledge of the latest C standards? Second, what advantages would you get by using C99 or C11 over C89? Moving up to C99, I can name several advantages: * proper fixed-size integer types (`int32_t` and friends). But note that you could always implement these yourself. This is what my company's code does, since our codebase predates C99. * intermingled declarations and code (although stylistically, I still prefer not to use it, but that's my personal preference) * official support for `//` comments * designated initializers * official support for variadic macros * new functions like `snprintf()` (Hmm, really? I didn't realize that's not available in strict C89.) Moving up to C11, I'm less sure what advantages it brings (partly because I'm not very familiar with it). * Cross-platform multi-threading support sounds nice, as do built-in atomic types * Anonymous structures and unions are nice to have occasionally * Static assertions are cool * Type-generic expressions might be useful in some situations, although I'd want to see and play with an example before I buy into it fully Like I said, my company's codebase already has a lot of functionality built up so that even though we only officially use C89, we have equivalents of a lot of the important luxuries of C99 and C11, like fixed-size integer types, and cross-platform macros and code for multi-threading support. Other features like designated initializers we just live without. The right choice for you will depend on your project and your own preferences. edit: formatting
what I'm getting from this so far is, it depends, some fields will other won't it just depends on who's gonna be using the software. Im guessing that for software that's just going to run on consumers pc it's safe to assume that they're using a recent version that support's C11? And as for fields that are a bit older they will most likely require older standards like C99 (or 89 as someone mentioned), well that solves it I guess.
I should probably include the original text, as it doesn't seem to copy here: Hi all, I've read K&amp;R. I'm rereading it now. Using Ubuntu Linux on X86_64. I'd like to work on C in an IDE. I'm familiar with Eclipse for Java. Can you suggest a good dev setup for me in C. I've tried to set up a few automake projects in Eclipse, but it's not working so well for me. I hear nice things about JetBrains' CLion. I use vim fairly regularly with server admin duties, but I struggle with vim for programming, as I'm not used to the vim key bindings. I'd really like to find something that integrates well with core projects like make, gcc, git, gdb, valgrind, etc. Also, any other productivity tools you can suggest/recommend will be appreciated. I'd like to work on coreboot and depthcharge to start, if that makes a difference in the tools I should look at. 
Be aware, though, that C11 threading is an optional feature and currently not supported by any toolchain except [Musl](http://www.musl-libc.org/) C library implementation.
Eclipse works fine on windows. As does Code::Blocks and Dev-C++ (despite the name works fine with C). Those are just the ones I have personally used. For a beginner I would suggest Dev-C++.
Dev-C++, Eclipse, Code::Blocks, NetBeans and CodeLite probably top the list in my opinion. The first two are the easiest and most feature full respectively in my opinion. However Dev-C++ hasn't seen much development in years.
Are you in an advanced class? Regardless, if you don't know C very well just tell your professor and see about getting transferred to another class. It is unlikely you would even be able to get a good 2d one without much experience in C. If you want to have a go regardless, I would split the board into 3 different sections and display them side by side if all you have is a console. Bottom Middle Top | | | | | | ---+---+--- ---+---+--- ---+---+--- | | | | | | ---+---+--- ---+---+--- ---+---+--- | | | | | | From there just throw it in a game loop and assign each cell it's own letter/symbol (numbers are not enough anymore). Bottom Middle Top Q | W | E R | T | Y U | I | O ---+---+--- ---+---+--- ---+---+--- A | S | D F | G | H J | K | L ---+---+--- ---+---+--- ---+---+--- Z | X | C V | B | N M | , | . Then expand the logic you would use to verify the winner to a 3x3x3 board instead of just a 3x3 board.
They work, yes, but they're slow and/or lack features that you'll really miss when your projects start getting larger. 
Eclipse is neither slow (at least if you have a computer produced in the last 6 years) nor lacking in features? It hasn't been slow since Europa or Ganymede almost 10 years ago.
So you just now got put into a C class (as in a day or two ago?) and now you have a 3d tic-tac-toe in C due tomorrow? That is kind of crazy. 10 weeks of python doesn't translate well to C at all, but it does introduce core programming concepts. If you are any good you can [simply use this Python to C primer](http://www.toves.org/books/cpy/) to get you up to speed on C.
Trust me, I noticed :p but for real the only things I could find that support it are either pellesC and musl, it makes me sad.
Thankyou for link hopefully it helps, and ya the guy does not teach programming he tells up things to do says how he did it and then says google it
Ah, ok, I think I might end up learning/using both of those for now simply because of the convenience that C99 offers, and C89/ansi because, well, like you said it's the lowest common denominator. Thanks for the flags by the way I didn't know about a lot of those! I still have some questions though. They aren't specifically about the C standards but more about things you mentioned in your comment. Aren't the types in `stdint.h` defined using normal C data types? What's stopping you from just redefining them in a separate header file in ansi C? You also mentioned that Variable-length arrays are generally not something that should be used, what exactly is wrong with them?
Yeah, that primer will not help you with all the little gotcha's in C, but it should allow you to complete this assignment. just be sure to compile with the -Wall (meaning Warnings ALL) so gcc can warn you about any issues.
Creating the array in main and passing it seems fine. Some considerations: * In main, where you create the array, you'll have to know the max number of nodes so you can allocate an array that's big enough. * Along with the array, you'll have to pass in the number of elements it contains. This increases by one each time you add an element. When a call to preOrder turns around and recursively calls preOrder(temp-&gt;left). That recursive call will add to the array changing the number of elements. You need to figure out how to make that work so that when you then make the call to preOrder(temp-&gt;right) you pass in the updated number of elements. If you're trying to write a general purpose traversal fn, instead of an array, you'd pass in a function pointer and a void*. But, I'm guessing that's more than you need to be worrying about at the moment.
Why don't you Google or go on git hub and see if someone has done something similar where you can learn from. Refactor some of the code and use it as a foundation for your code. That is the best bet imo, I imagine this can't be the first person to ever have to or want to build a 3d chess board. It's actually not that bad of an assignment if you sit down and think about how you want to build it. I feel like your teacher wants you to problem solve, you can do it man. 
coreboot and depthcharge? That's a very specific combination of obscure technologies. I only know one place where that's used. Who do you work for/want to work for?
I wouldn't say that. Unless you **really** need those feature not supported yet by gcc, I'd go with gcc. 
microsoft word? Wouldn't it be better to represent a procedural language in powerpoint?
I'm asking why the language makes us use the unwieldy `int (*ptr)(int)` syntax when the actual function type `int ptr(int)` is barely used. 
You're asking about the syntax of it? The problem is that: { int foo(int); int x = foo(3); } Is perfectly valid syntax in C. The first line is a declaration to an existing function called `foo` that's defined somewhere. That is *not* a pointer to a function, just a regular old function. Compare that with: { int foo(int); foo = some_func; int x = foo(3); } Now we're using `foo` as a pointer to a function, not a function. At the time `foo` is declared, the syntax would make it ambiguous as to whether `foo` is a function or a pointer to a function.
Ah, that makes sense. 
Actually, I was referring to (what I thought was) a difference in treatment between '+' chars and '-' chars, but then when I ran your code, I realized I was seeing a difference only due to the even-odd position difference when I have input like: --- +++ And when I create separate input files, each with either --- or +++ only, then I see that they're parsed/not-parsed in the same pattern. Anyway, thanks! I had all but shelved this issue, but it's much more satisfying to have your answer. :-)
I want to do a Libreboot type thing for Samsung Chromebook Plus. One tweek though, I'd like to keep the signature stuff Libreboot tosses out. I'd like to use my own signing keys, not Google's.
All [according to plan](http://harmful.cat-v.org/software/c++/I_did_it_for_you_all), mwuahahahaha
Think about the difference between a variable and a pointer to the variable. With a variable, you are storing the data somewhere, typically on the stack. With a pointer, you have a pointer to data stored somewhere else. So if you could use a function type directly instead of as a pointer, you would be storing the function as data on the stack. This isn't even possible on a [Harvard architecture](https://en.wikipedia.org/wiki/Harvard_architecture). But even on an architecture that doesn't have strict instruction/data separation, there are a lot of complications and reasons you wouldn't want to do it. It's similar to why you use a pointer to an array instead of the array itself.
Ah ok that makes sense now, thank you so much for answering all my questions and for all the help so far I really do appreciate it!
that's definitely an interesting approach, I might start doing that.
You really don't need any programming for that. Just a slight familiarity with the tools and you can set your own keys on the firmware that's already installed on your computer.
I'd say you're on exactly the right track. My company's code does this exact technique in many of our networking functions. (We target small embedded systems that have varying capabilities. They may not have a per-thread `errno`, so as /u/Meriones says using a global variable is a no-go.) You may not need to define a `FunctionErrCode` type; a plain `int` ought to be enough, right? `int` is guaranteed to store at least -32768 to 32767. Surely you're not going to have more than that many types of errors. (The standard `ENOERR` list of error codes from `errno.h` doesn't have more than 100 errors.) Since it would be consistently used throughout your API, there wouldn't be much risk of confusion, since users would very quickly get used to it and know what it's for. Also, I partly just want to be lazy and only have to type `int` on the keyboard every time instead of `FunctionErrCode`. But I suppose as a good programmer, I ought to support using a typedef for clarity, because it's obvious what a `FunctionErrCode` is, but it's not obvious what an `int` represents. &gt; please don't bash me for heavily using typedefs, I know you guys don't like them No, *Linus Torvalds* doesn't like them, and he happens to run a large software project that many people learn from or emulate. Others of us think typedefs are a very good thing indeed.
With the benefit of hindsight, they should have made functions values, and function declarations would then just be uninitialized function values. All that's missing is a function-value literal (lambda) I wonder if there is a variant of C with first-class functions, not just tacked on syntax like objc blocks. It seems the delta to such a language is not very large. 
its almost comedic how many questions can be answered from the man page. I must have missed that line somehow, thank you !
Oh, ok, I understand. It is actually easy. `strlen(char*)` takes an string and returns the amount of characters in the string. For `abcdefg`, it's `7`. You want to chop off the last 5 characters, so the new length should be `7 - 5 = 2`. Now you know the length of the new string. (Note: You need to include `string.h` to get `strlen(char*)`) `printf`s `%.*s` means, that it prints (at max) `*` characters from a string. The amount of characters is put before the string. In the example, you want to print 2 characters, so you'd use: `printf("%.*s", strlen(stem) - 5, stem);`. `strlen(stem)` would be `7` in the example. Subtract by `5`, and you get `2`. You pass the `2` to the function and it takes it as the amount of characters to print, which is `2`. (Then you pass the pointer to the string and `printf` only prints the first 2 characters). Or, as the other person suggested, you manually truncate a string by terminating it early. Arrays are 0-indexed, so `stem[0]` is the first character and `stem[2]` would be the third. The character `'\0'` is a string terminator, so you want put it after the 2 characters. As you can see, we can just do `stem[strlen(stem) - 5] = '\0';`. In the example, it will be `stem[2] = '\0';`, which is setting the third character to null. Then you can normally print the string using `"%s", stem`. Before: abcdefg0 After: ab0defg0 Index: 01234567 ^^ new string characters ^ new string ends here ^^^^^ Unused (doesn't really matter in fixed-width array) The latter is usually used (when you want to give other functions the truncated string), but then you need to make sure that the string is writable (string literals aren't: `stem = "abcdefg"`, use `char stem[] = "abcdefg"` instead or allocate memory and copy the string manually).
They might not be single bits on some systems, the only thing you can assume is that you can or them together to combine them.
Unless it's undecidable, the answer is yes. The answer is yes in this case.
Using threads to compare two trees seems like massive overkill...
I think this might be literally the most reasoned, balanced, sensible, and human thing you've ever written. That says a lot about how shit you are as a person. 
I took "in parallel" literally.
&gt; What if I told you that arrays are pointers on the first element in array? If you told me that, you would be incorrect.
Can you explain me why this is incorrect? I'am pretty sure than I read it in the C how to program book by Deitel.
Correct me if I'm wrong. I might be talking out of my ass but if I remember correctly, arrays are automatically cast to pointers when you access them. They work like pointer for the most part but pointer can be reassigned, arrays can not. 
Here's a good example, note the arrays declared just before main(); ^^^//pardon ^^^the ^^^c++ #include &lt;iostream&gt; bool b0 (bool a, bool b) { return a&amp;&amp;!a; } int i0 (int a, int b) { return a&amp;~a; } bool b1 (bool a, bool b) { return a&amp;&amp;b; } int i1 (int a, int b) { return a&amp;b; } bool b2 (bool a, bool b) { return a&amp;&amp;!b; } int i2 (int a, int b) { return a&amp;~b; } bool b3 (bool a, bool b) { return a; } int i3 (int a, int b) { return a; } bool b4 (bool a, bool b) { return !a&amp;&amp;b; } int i4 (int a, int b) { return ~a&amp;b; } bool b5 (bool a, bool b) { return b; } int i5 (int a, int b) { return b; } bool b6 (bool a, bool b) { return a!=b; } int i6 (int a, int b) { return a^b; } bool b7 (bool a, bool b) { return a||b; } int i7 (int a, int b) { return a|b; } bool b8 (bool a, bool b) { return !a&amp;&amp;!b;} int i8 (int a, int b) { return ~a&amp;~b; } bool b9 (bool a, bool b) { return a==b; } int i9 (int a, int b) { return ~a^b; } bool bA (bool a, bool b) { return !b; } int iA (int a, int b) { return ~b; } bool bB (bool a, bool b) { return a||!b; } int iB (int a, int b) { return a|~b; } bool bC (bool a, bool b) { return !a; } int iC (int a, int b) { return ~a; } bool bD (bool a, bool b) { return !a||b; } int iD (int a, int b) { return ~a|b; } bool bE (bool a, bool b) { return !a||!b;} int iE (int a, int b) { return ~a|~b; } bool bF (bool a, bool b) { return a||!a; } int iF (int a, int b) { return a|~a; } bool (* const bx[]) (bool, bool) = { b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, bA, bB, bC, bD, bE, bF }; int (* const ix[]) (int, int) = { i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, iA, iB, iC, iD, iE, iF }; int main (void) { (std::cout &lt;&lt; "A 0 0 1 1 3\nB 0 1 0 1 5\n\n" &lt;&lt; std::hex).setf(std::ios::uppercase); for (int x = 0; x != 16; ++ x) { std::cout &lt;&lt; x &lt;&lt; " "; for (int a = 0; a != 2; ++ a) for (int b = 0; b != 2; ++ b) std::cout &lt;&lt; bx[x](a, b) &lt;&lt; " "; std::cout &lt;&lt; (ix[x](3, 5) &amp; 0XF) &lt;&lt; "\n"; } } ^^^^edit:formatting
That's what I had initially, but that read the entire array as decimal or hex based on the first index. The gotos were added to jump between reading decimal and hex values. Either way, I've prettied up my code now and eliminated those pesky gotos.
First thing to note. In C, the full type name of a struct includes the struct keyword. i.e. When I define a struct: struct Foo { int bar; }; // I must write "struct Foo" struct Foo myFoo; myFoo.bar = 42; C programmers often use the typedef statement to create short-hand names for structs types. The typedef statement takes two arguments. The first is an existing type, the second is a new name that you can use for that type. typedef AnyExistingType AliasForThatType; If you break apart the original typedef for `Node`, it can help you see what went wrong, and can see a quirk about C. The first argument passed to typedef was: struct { int data; struct Node* left; struct Node* right; } Notice that this struct has no name. This is a definition of an **anonymous** struct. Note that the fields `left` and `right` are of the type `struct Node*`, but the compiler does not know what that is. Those are called **incomplete** types. The compiler just assumes those are pointers to some struct called `Node`, which is defined *somewhere*. As long as you don't try to read anything inside of them, the compiler won't complain. When you write `typedef struct Node Node` you still declare an incomplete type named `struct Node`. But you immediately create a short-hand name for it called `Node`. Then afterward, you "completed" the type by defining what `struct Node` actually is. The compiler now doesn't complain because it now knows `struct Node` and `Node` are the same type.
As a beginner, that was a nice easy read. Right now in the works of practicing pointers, so it came at the right time. Hope to see more C posts as these. 
well explain bro
As others have pointed out, you defined `Node` but not `struct Node`; Different coders and projects have different styles. In some places, these types of typedefs are frowned upon, while other places typedef all their structs so that they don't have to type `struct` in front of all their types. I often see the pattern `typedef struct Foo { /* ... */} Foo;` or sometimes `typedef struct foo_s { /* ... */ } foo_t`. I personally consider the `treePtr` typedef you have to be more harmful than helpful. I'd normally rather have `Node *`s than `NodePtr`s. I'm also bothered by the inconsistent use of capitalization. There's a common pattern, that I think comes from Java, where if the first level is capital, a `CamelCase` name is a type name, while if the first letter is lowercase, as in `camelCase`, then it's an instance of that type.
Yeah I just bought mine on amazon a couple of weeks ago an its the same as yours. Weird. 
Awe I like vim :(
Shitty gotos used to avoid proper looping and syntax like `if ('-' == c)` This post triggers me pretty hard.
I considered using strtol() but that would require a pre-defined buffer size which would limit the size of my array. I could also dynamically allocate the buffe, but then I'd need to pre-process the length of the array, rewind and free the buffer once I'm done.
Ahahaha I know, right? Thankfully, the fixed code now looks like this: static FILE* file; static char c; int* read_array(int size) { int* array = malloc(size); memset(array, 0, sizeof(int) * size); for(int i = 0; i &lt; size; ++i) { if (is_hexadecimal()) { array[i] = get_hexadecimal(); } else { array[i] = get_decimal(); } } return array; } int get_decimal(void) { int number = 0; int sign = 1; c = getc(file); while (' ' != c &amp;&amp; '\r' != c &amp;&amp; '\n' != c &amp;&amp; EOF != c) { if ('-' == c) { sign = -1; } else { /* Add digit to current index. */ number *= 10; number += c - '0'; } c = getc(file); } number *= sign; return number; } int get_hexadecimal(void) { int number = 0; int sign = 1; c = getc(file); while (' ' != c &amp;&amp; '\r' != c &amp;&amp; '\n' != c &amp;&amp; EOF != c) { if ('-' == c) { sign = -1; } else if (c &gt;= '0' &amp;&amp; c &lt;= '9') { number *= 0x10; number += c - '0'; } else { ASSERT(c &gt;= 'A' &amp;&amp; c &lt;= 'F', "Invalid hex digit: %c", c); number *= 0x10; number += c - 'A' + 0xA; } c = getc(file); } number *= sign; return number; } bool is_hexadecimal(void) { int start = ftell(file); if ('0' == getc(file) &amp;&amp; 'x' == getc(file)) { return true; } fseek(file, start, SEEK_SET); return false; } Surprisingly, it's the same length as the goto version line-for-line. Any reasons why you don't like `if ('-' == c)`?
My rule is to only use goto to move forward in a function. That way it's no worse than a `break` or `continue`. 
Because functions aren't types (nor should they be) and nor are they variables. If you check the C grammar (appendix A section 13 of K&amp;R), you can start at the production for `function-definition` and work your way down. `type-specifier` by itself never satisfies any production that could be a `function-definition`. If you allow a `function-definition` to also be a `type-specifier` you end up with multiple levels of left-recursion. Now you could probably come up with some shoe string and bubble gum to work around that; but it makes the parser more difficult to write and the language more ambiguous. 
iirc, the header `cs50.h` defines several "easier-for-beginners" versions of standard C types and functions. Going by the signature of `main`, `string` must be a typedef of `char *`, and it's probably safe to assume that `get_line` is a wrapper around `fgets`.
It looks to me like the problem is in this line: printf("%c", (int)s[i] + k); What happens here if `k` is 3 and the first character of the plaintext is z? (Hint: take a look at the [ASCII character table.](http://www.asciitable.com/))
They're implementing a [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher).
I would do something like `mainString[50] = 0;` and everything before that just gets truncated. Your while/if statements makes no sense, since your array is limited to only about 50 anyway this will almost never get called.
It used to be true but isn't anymore. Both languages have taken their own path and now have their own constructs to provide the same modern features that didn't exist when C++ diverged from C. 
What if i told you i'm part of the cult of vi?
Eclipse (CDT) has a pretty decent GDB front end.
One nit: In C++, sizeof returns `std::size_t`, which is an `unsigned int`, while an integer is returned in C11. C++: &gt;std::size_t is the unsigned integer type of the result of the sizeof operator C11: &gt;The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand. The result is an integer. 
"They" are different groups. If you have windows 10, use LFWS and do all your work there. Even better just install Linux. Windows is easily one of the most obtuse and painful development environments. Among other things, it does everything the exact opposite of the rest of the world. * One file system root? Windows/DOS have multiple roots (drive letters * POSIX compliance? Not really, especially with C * using common names for data types? Nope * file separator is /? Nope * case sensitive fs? Nope * well understood platform? Not even ms seems to understand some portion of windows, due to the way its been handled * there is a simple command interface to the system? Nope, windows is UI-first -- not even apple is like this * file system is the most important component of the system and everything is accessible from it? Nope, applications and configuration data are stored in strange places * tooling that is easily scripted and makes sense? Definitely not. msbuild is a terrifying monstrosity, and is an example of how not to design a build system. msvc is like a tricycle that was designed by a committee of aerospace engineering students and/or middle managers who were told to build a space shuttle. * the registry * company culture and ethos *encourages* severe deviation from the standards that everyone else (even apple) follow
&gt; C++ compilers actually give better warnings for C code For sure, especially if you ever have to port something, and gasp if it's not GCC all around, it's sometimes so much easier to get it to at least compile under C++ and try to port from there. Running is as always another story. Although I have found some odd 'unknown' crashes being more magically fixed going through with CLANG and finding all kinds of subtle gotchas here &amp; there that made things all the better.
 /* a constant integer can define the size of an array in C++ but is an error in C */ const int size=4; char b[size] = "Bob"; This doesn't sound sensible to me, and gcc doesn't treat it as an error (however it considers it a variable-sized object which may not be initialized) Is the comment misleading or is this a case of (oddly) noncompliant code permitted by gcc?
Looks like you are trying to do something along the lines of this: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char mainString[52]; char subString[31]; char finalString[81]; int c; printf("Please enter main string (max %lu characters):\n", (sizeof mainString / sizeof mainString[0]) - 2); do { fgets(mainString, sizeof mainString / sizeof mainString[0], stdin); if (!strchr(mainString, '\n')) { while ((c = fgetc(stdin)) != EOF) { if (c == '\n') break; } printf("Your Entry was too long, Please try again\n"); } } while (!strchr(mainString, '\n')); printf("Please enter sub string (max %lu characters):\n", (sizeof subString / sizeof subString[0]) - 2); do { fgets(subString, sizeof subString / sizeof subString[0], stdin); if (!strchr(subString, '\n')) { printf("Your Entry was too long, Please try again\n"); } } while (!strchr(subString, '\n')); printf("Combining main string and sub string into final string...\n\n"); strncpy(finalString, mainString, 50); strcat(finalString, subString); printf("The combined final string is %s\n", finalString); return 0; } 
Thanks for the help! I was just starting to look into EOF. Only question I have is weather there is a reason for dividing by sizeof(mainString[0]) as it equals to 1 and as such wont affect the numerator? Thanks again, this has been stumping me for too long!
`sizeof array / sizeof array[0]` is just a common technique to determine the number of elements in an array and will still give the correct answer even if the type changes. Admittedly, in your example the type is unlikely to change so the division is probably unnecessary. Another option is to use an `enum` declaration to set the size of the array and use the enum instead. To be consistent, there should also be a `while ((c = fgetc(stdin)) != EOF)` loop while reading the substring.
&gt; Note that even in C++, size_t is not necessarily an unsigned int. It can be any unsigned integer type. Touché! Digging into the spec: &gt; The type size_t is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object. In any case, the posted code example assigns the result of `sizeof` to an `int`. My original cringe still applies. 
An octree can be good depending on your use-case. But if you just need to write single values at a coordinate and read them back out, a hash table can be really efficient in terms of size and performance. The most trivial way to compute a hash for a 3D coordinate is simply to XOR the components together. Your hash function just needs to be reproducible. Technically, you could even just add the three numbers together, it would still function as a hash. `int hash = x ^ y ^ z;` Plus, a hash table is a lot simpler to implement than an octree.
Actually, it looks like you take the dimensions of your array (height and width) already, and are iterating over the entire array printing one int at a time. However, you are passing as the second argument sizeof(array) which is not what you want- this argument should be the size of the element to be printed, which is an int. So your argument should be sizeof(int).
The header string is valid? Perhaps you could share the code where the array itself is generated?
I'm actually unsure if the header is valid come to think of it. I'm using fprintf instead of fwrite, so it may not work. I'll upload that code shortly just need to copy and paste it to pastebin.
Here is the [main part of the code.](http://pastebin.com/FGtkJNML)
Okay. This looks quite interesting! I had no idea what PGM files were. It does look like your string is correct - documentation says P2 for plain PGM files and P5 for pgm files. ~~Just curious though - the sample input on the site shows the array elements separated by whitespace. Does that mean that the whitespace must be printed out as well? I mean, suppose the array is 10 x 20 with 200 elements, should the output actually consist of 19 x 10 additional whitespace and 10 additional newlines?~~ ~~EDIT: I downloaded a sample PGM file and when I removed some whitespace between the elements, I saw a similar blank screen. To test this hypothesis, how does the output of your plain file version look like?~~ UPDATE: Whitespace between bytes doesn't matter for binary PGM! 
It's a little funny because it looks like your assignment has a linked list implemented using array indices, whereas the usual way you implement a linked list is with memory pointers. That said... I think your checks for LinkA[nextA] != -1 (and similarly for LinkB[nextB] != -1) are wrong. Take an example, where the array A has values (7, 9) and the array B is just (8). So, I think your array C will look like (7, 9, 8). And LinkA will have the values (1, -1). That is, you have 2 elements in the list. The variable HeadA will be 0, indicating the first element is at position 0. And then LinkA[0] will be 1, because the element following the first element is at position 1. LinkA[1] will be -1, because there are no more elements after that. LinkB will have the single value (-1) because there is only 1 item in list B, so the next pointer for that one item is -1. The initial 'if' statement will correctly pick '1' from array A and make HeadC point to that position in the merged array C. But what happens at the while loop? At that point, nextA will be 1 and nextB will be 0. And for both, LinkA[nextA] and LinkB[nextB], you'll get a -1 value. So the while loop doesn't execute. And neither will anything happen in the last chunk of code. To fix that, I think you want your guards to trigger on nextA == -1 rather than LinkA[nextA] == -1. Does that make sense? (Also similar for nextB...) That explains why you'd be missing 2 elements. Where's the third? My guess is that you've got the same mistake in the code you're using to print out the result, which will skip the third item your missing.
Man, I can't possibly thank you enough.
Preorder isn't postorder in reverse... The runtime thing always confuses me. Right now, I have two functions that find the preorder and postorder traversals. The traversals are stored in an array. Each of which has a runtime of O(n). Then, I have another function called Comparison that checks whether the preorder traversal of tree A is equal to the postorder traversal of tree B, or vice versa. This function calls each preorder and postorder functions twice. Then the comparisons between the arrays are done. Wouldn't the Comparison function exceed the O(n) runtime restriction? Or am I totally off? Edit: In the preorder and postorder functions, I know what size to allocate for the array because I have another function that returns the number of nodes in the tree (which would have a O(n) runtime).
O(n) just means that the time it takes to run your algorithm scales linearly with the size of the input. Say you and another programmer write an algorithm, but their algorithm takes 3 times as long to run with 1000 inputs. As long as their algorithm takes 6 times as long with 2000 inputs, it is still O(n). Technically it is O(3n) compared to yours, but we factor out the constant 3.
You may have already solved it, but just in case you didn't, I wrote a program to write out the exact array that you're generating, using both fputc and fwrite. The behaviour is...interesting. Writing passes in both cases and generates (seemingly) valid PGM data which I can open in Preview on my Mac. Here is the code that I used: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; const int MAX = 1024; void fill_array(int height, int width, unsigned int array[height][width]) { for(int i=0;i&lt;height;i++) { for(int j=0;j&lt;width;j++) { float is = i/50.0 - 1.0; float js = j/50.0 - 1.0; array[i][j] = ((is*is - js*js)+2)*63; } } } void write_pgm_fputc(const char* file, int height, int width, unsigned int array[height][width]) { FILE* fp = fopen(file, "wb"); if (!fp) { perror("could not open file to write to"); exit(1); } // header info fprintf(fp, "P5 %d %d 255\n", width, height); for (int i = 0; i &lt; height; i++) { for (int j = 0; j &lt; width; j++) { fputc(array[i][j], fp); } } if (ferror(fp)) { perror("could not fputc to eof for file. aborting...\n"); exit(2); } else { printf("finished writing pgm data to %s\n", file); } if (fp) { fclose(fp); } } void write_pgm_fwrite(const char* file, int height, int width, unsigned int array[height][width]) { FILE* fp = fopen(file, "wb"); if (!fp) { perror("could not open file to fwrite to"); exit(1); } // header info fprintf(fp, "P5 %d %d 255\n", width, height); fwrite(array, sizeof(array[0]), width * height, fp); if (ferror(fp)) { perror("could not fwrite to eof for file. aborting...\n"); exit(2); } else { printf("finished writing pgm data to %s\n", file); } if (fp) { fclose(fp); } } int main() { const char* pgm_fputc_file = "/Users/guest/Desktop/pgm_fputc_file.pgm"; const char* pgm_fwrite_file = "/Users/guest/Desktop/pgm_fwrite_file.pgm"; unsigned int data[MAX][MAX]; fill_array(100, 100, data); write_pgm_fputc(pgm_fputc_file, 100, 100, data); write_pgm_fwrite(pgm_fwrite_file, 100, 100, data); return 0; } Running it: $ gcc -Wall -std=c99 -O2 -o pgm_write pgm_write.c $ ./pgm_write finished writing pgm data to /Users/guest/Desktop/pgm_fputc_file.pgm finished writing pgm data to /Users/guest/Desktop/pgm_fwrite_file.pgm Here is the output when using fputc: http://i.cubeupload.com/Om2FpQ.jpg and here is the file generated with fwrite: http://i.cubeupload.com/z8OwuE.jpg (Sorry for uploading to that site - imgur doesn't seem to be working for me right now). A couple of observations: * The fwrite output looks patently wrong. Also, using fwrite when copying another image file corrupted the file. fputc works reliably (didn't use buffering since the file size is small here). Also the fputc output looks like the one you had shared (copied in text mode). You are the best person to verify that! * According to the PGM spec, we have to specify the width (or columns count) first and then the height (or row count) in that order. In this case, it's a square array so it doesn't matter, but could be a problem for other arrays! 
The comment is misleading because in C99 you can have variable length arrays, however I still get an error because of the initialization. Need to change that.
There are two major things we look out for. One is obviously malloc failures. Our devices do networking and VoIP, and have quite a bit of heap (we usually have 8 or 16MB RAM total), but obviously there's always a danger of running out. So we just code to expect it, and give up on whatever operation we were trying to do. This may mean some operation doesn't get done, but oh well... that's better than crashing. Maybe we have to drop a network packet; that's fine, the protocols were designed so that that's okay anyway. For stuff that's more critical, we use pools of fixed-size buffers. We can calculate (or sometimes just guess) what the maximum number of items we'll need is, and allocate them up front. As long as there's not a leak, it will be enough forever. The audio processing library does that with its audio packets; we allocate a pool of maybe 200 of them at startup. This way, even if the rest of the system runs out of heap for malloc, the audio task can keep going. The other major problem is, of course, failures you didn't expect... aka asserts. Maybe you pop something off a list, but the item is null. Maybe you ask for the length of something and it's negative. Whatever. Again, we mostly just try to deal with it. Since the alternative is to crash and reboot the whole system, it's better to just give up on the action we were doing. I dunno... part of me wants to say we just the same techniques as any program would. But maybe I've just been doing this long enough that it's become second nature, and I can no longer see another way of doing things. How else *would* you deal with unexpected conditions in your program, if not to try and suffer through it as much as possible before giving up on one action while trying to keep the whole program operating?
I have removed this post as being off-topic since it is about C++, not C. Also, please stop with the PVS-Studio spam already. We're all sick of it. You actually spammed this software so much that I have decided not to evaluate it for use at work, as I do not support spammers. Note though, that I am not going to remove posts just because they are about PVS-Studio, I'm just sick of them.
If you're working for such company, you can recommend the thread to the people in charge of hiring. 
Like I said... it's my first game so I don't have anything to show. That's why I'm asking for help on the project.
Hi, thanks for the post. And don't get me wrong, just for personal curiosity, but why did you not use the recommended formatting? In your case, something like this: **Company:** Eaton **Type:** Full time **Description:** Lighting control **Location:** Peachtree City, GA, USA **Remote:** possible for the right candidate **Visa Sponsorship:** not sure **Contact:** [here](http://www.eaton-jobs.com/ListJobs/ByKeyword/peachtree%20city%20embedded/) 
**Here's a sneak peek of [/r/Cprog](https://np.reddit.com/r/Cprog) using the [top posts](https://np.reddit.com/r/Cprog/top/?sort=top&amp;t=year) of the year!** \#1: [Small, lesser known C compilers - a list](https://np.reddit.com/r/Cprog/comments/4egaog/small_lesser_known_c_compilers_a_list/) \#2: [The ISO C WG has started working on a new standard: C2X](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2021.htm) | [10 comments](https://np.reddit.com/r/Cprog/comments/4asku0/the_iso_c_wg_has_started_working_on_a_new/) \#3: [sort.h - compile-time sorting library in a header](https://np.reddit.com/r/Cprog/comments/4f6ex9/sorth_compiletime_sorting_library_in_a_header/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
&gt; intermingled declarations and code (although stylistically, I still prefer not to use it, but that's my personal preference) Huh, really? That's interesting; I don't often see people who feel this way. I very much prefer to declare variables in the tightest scope possible and as near to their use as possible, in part because it's clearer to me but also because I've seen bugs like this far too many times: int foo; /* used in both branches */ int bar; /* only used in the if branch */ /* Code */ foo = 7; if (some_condition) { /* Code */ bar = 9; /* Code*/ f(bar); } else { /* Code */ g(bar); /* the author really meant foo */ /* Code*/ } It's true that many compilers are smart enough to warn for this and it could avoid undefined behavior by always initializing your variables, but declaring the variable in the scope in which it's needed statically prevents this.
What is your issue?
`sqft = ((yard * 3)^2)`. ^ is not a power operator but bitwise XOR in C. Use `pow()` function or, in your case, just type out the calculation as `yard * yard * 9`.
If the console is a post office, printf doesn't mail the string to the destination. It drops it in the mailbox, and will be sent eventually. To force output, you have to use fflush, as noted.
fstat() is one of the more common and widely compatible ways to do it.
like i said to the previous post, I have an assignment where we can only use open(), stat(), lseek(), write(), and create().
It's not a terrible practice. `literal == variable` is the idiot-proof way of writing `variable == literal`. If you mistype the latter as `variable = literal` it'll create subtle bugs that'll drive you nuts. But if you mistype `literal = variable` it won't even compile. It's really awkward at first, but helps prevent bugs in the long run. I picked the practice up from a style guide somewhere. I can't remember which.
You are right, they aren't reversable, I don't know why I post stuff late at night, but I shouldn't. 
What have you tried? What does your book or lecture notes say? Why are people doing OPs homework?
You can't put equations in the format strings of your printf statements. printf(".03 *" + %d + " isn't valid c", x ); // Prints x Perhaps you meant to put the math somewhere else? printf(".03*x is %d\r\n", .03*x ); Does that help?
I made a [thread](https://www.google.ca/amp/s/amp.reddit.com/r/C_Programming/comments/5t9tcs/check_if_file_exists/) about this a while ago, maybe something there willgive u a hint. Just google example code for those functions and you will be fine.
This line's funky too ... else if (yard &lt; 500 &lt;= 2000 ) Perhaps you meant something like ... else if(yard &gt; 500 &amp;&amp; yard &lt;= 2000)
As with many things, it all depends on the specifics of what you're doing. If you're controlling a car engine, firing the spark plugs at the right time is critical, but it's better to skip one than to fire it at the wrong time. If you're JPL designing software with a failure cost in the hundreds of millions of dollars, it probably makes sense to say "[No malloc allowed, ever, except bulk allocations during startup](https://en.wikipedia.org/wiki/The_Power_of_10:_Rules_for_Developing_Safety-Critical_Code)". In our case, we're doing VoIP intercoms. The audio task is designed to never fail, because when it does, there's no way to recover. If it starts running out of audio packets, it's really unpredictable whether it will be able to generate usable audio at all, or garbage, or silence. At that point it's all shot to hell. We're usually consistent about checking for null in most places, but it won't be that long before it either hits an assert, or just plain dereferences null. The result is the same in either case; the system will get rebooted. You have to keep in mind, as an embedded system, calling `assert()` or `abort()` doesn't kill that one task but leave everything else running. We do run an RTOS, so we could kill the task, but what would be the point? Every task in the system is essential; it's not like we're closing your web browser that you can just open back up. We'd have to restart the task anyway, but it's not possible to do that because now the global state is all screwed up. Well, I'm sure it'd be possible, but that's a lot of work to code and test all that protection and recovery functionality when you could just reboot and reliably come back up. &gt; I agree that you should do what you can to keep going, but sometimes you just have to say that things are too far gone to keep going. Agreed... it sounds like we're saying the same thing here. If the filesystem fails to read a block or allocate a buffer, it probably needs to give up on *that operation*. It certainly should abandon trying to do anything that would corrupt state and make things worse. But as a whole, it should return an error and leave the rest of the system up. Maybe writing to the filesystem keeps failing, but reading is working fine, which is what the system needs to do most of the time, so you could go longer before the user complains or before you crash hard enough to need to reboot.
What a beautifully accurate personification of C. C++ is like C once it had kids. Still a mess, just more organized about it.
Maybe early C++, C++11 and later barely resemble C anymore
No. 
Do you happen to have any good resources for learning modern C++ for someone already familiar with C (and also old C++, if possible)? I learned C++ around 2000, and mostly moved on after playing with it briefly. If it's more different than C (than it used to be) it might be worth taking another look at, but I'd hate to have to wade through a "this is a 'for' loop" tutorial from the beginning...
&gt; but I'd hate to have to wade through a "this is a 'for' loop" tutorial from the beginning I would take the time to start from the beginning, they even changed for loops :) `for(auto&amp;&amp; element : container)`
Scott Meyers has two books on the subject: Mdern C++, and Effective Modern C++. Both are very good for learning best practices with the new toys. A Tour of C++ by Bjarne stroustrup is a good (relatively) short intro to the language that presumes programming knowledge.
I read those Scott Meyers books. They were pretty good.
Okay... I recognize the for-each style for loop from other languages, and I know what auto means in the modern context, but I have no idea what to make of &amp;&amp; when used in a context that is obviously not logical AND. Interesting.
Feel free to post questions here.
I think the stream of questions would be too long to post here one on one, in order for it to be constructive
C is a mess to those too intimidated to code in C.
He's not wrong. But nowadays, C isn't the fastest thing on the road anymore^I ^like ^Rust, ^don't ^hate ^me. The thing is, you don't write "fast C". You write something that the compiler tries to understand and convert into efficient assembly. The more the compiler knows about your code and can reason about it, the faster your code will execute. However, due to the language design, the compiler is limited in what it can do.
`strtok()` keeps internal state of the position where the previous token ended, so that it can start at the next character on the next call. Passing the null pointer is how you signal that you want that behavior. You can't pass `input` (i.e. pointer to the beginning of the original string) because then it would start looking at the beginning again. You would need to pass a pointer to one past the null of the previously seen token. While you could derive that yourself, `strtok()` already has that information which is why it stores it and makes it available implicitly by passing a null pointer. This behavior makes `strtok()` non-reentrant, and is generally considered a failure of library design. In addition to making it completely unsafe for use in programs with multiple threads, it also means you have to be extra careful what functions you call in your loop. For example: for(;;) { foo = strtok(...); if(!foo) break; if(get_config_var(...)) { // do something } else { // do something different } } In this loop, the code is trying to decide how to handle each token, and one aspect of that involves checking a configuration variable. That function might require loading and reading a config file, and that process might itself use `strtok()`. If that's the case, the resulting loop is hopelessly broken because `strtok()` only stores state for the last caller. This is especially pernicious because not only do you have to be aware of what functions you're calling, but you have to be aware of what functions those functions call, and so on. It's not immediately obvious that `get_config_var()` might call `strtok()` internally, and those relationships can be extremely unintuitive and hard to work out. For these reasons, you shouldn't use `strtok()`. Instead, use `strtok_r()`, which takes an extra parameter that is used to explicitly store that state between each call, making it re-entrant. Unfortunately this function is not part of ISO C, but it is POSIX. 
Almost made me feel like I understand programming. 
That would be C99
&gt; you're not going to learn it by asking about things one at a time on reddit! You're probably, right, at that. Wasn't actually even intending to "ask" about that item so much. More an attempt to observe that I could understand readily part of what I was looking at, even having not seen it in C++ before, but acknolwedging the fact that other syntax was completely foreign. I've dealt with "move" semantics plenty in the context of Rust though, so knowing what that is, it makes perfect sense. I expect I'll start with Meyers' stuff for getting up to speed, as I've done well with his writing in the past. To clarify, by "Stroustrup's book", were you referring to the Tour book that /u/theboxingfox recommended to me, or his *The C++ Programming Language* one? 
Do you just use gdb in a virtual terminal in emacs, or is there some kind of integration?
I know you wrote a function to seed the RNG. But you never call it.
Yeah, "The C++ Programming Language (4th edition)". 
https://www.gnu.org/software/emacs/manual/html_node/emacs/GDB-Graphical-Interface.html
Ok then, thanks. Why does it still appear to give randomized numbers though, if it isn't seeded?
C is a mess to people who code in C for a living, too. Source: my job
YOOOOOOO another Rustacean
Too many kids 
Is that compared to GNU grep? I can't talk about all modes, but the fixed-strings single-pattern and fixed-strings multi-pattern search in grep is terribly slow. A hand-crafted Wu-Manber beats it easily. And here's also a point: Many algorithms are presented (or designed) with C in mind, especially anything that bets on cache conciousness.
I personally use GDB. I use this because I'm taking my first course in C programming right now (since January) and that is what they are teaching use to use. To be honest, it's very useful. That and valgrind.
&gt; `auto&amp;&amp; element` means the for-each loop transfers each item out of the container into `element` using a move-assignment rather than the usual copy-assignment. This is wrong. It's actually the opposite. The `&amp;&amp;` is there to prevent any kind of copy or move. The relevant fact lies in the concepts of "value category". There used to be only two such categories: lvalue and rvalue, but now we have five of them, so it's a bit more complicated. The facts are: * if you use plain `auto` you will get either copies or moves (lvalues are always copied) * if you use `auto&amp;`, it binds a reference so it won't copy nor move, but it will bind to lvalues only: this might produce an error in case the iteration produces non-lvalues * you can use `auto const&amp;`, this will bind to everything (both lvalues and rvalues) but it's ugly and verbose, plus you might actually want to modify the value * `auto&amp;&amp;` is also a reference, so no copy or move will occur, but it binds to everything, lvalue or not, without adding `const`: that's why is also called "universal reference"
Let's see if I got this right. auto&amp; is an lvalue-reference and auto&amp;&amp; is an rvalue-reference, right? I don't code in C++ very often at all (C# mostly)
Close. The presence of `auto` complicates things... If you have an object type it would be as you said, for example: `std::string&amp;` is an lvalue reference and `std::string&amp;&amp;` is an rvalue reference. However`auto&amp;` is an lvalue reference too, but `auto&amp;&amp;` could be either an lvalue or an rvalue reference! Why is that? Because `auto` is a *placeholder* for a deduced type and the deduced type might be... a reference type. If, for instance, `auto` is deduced to be `std::string&amp;` then `auto&amp;&amp;` would be `std::string&amp; &amp;&amp;` (not valid C++!), the two references collapse and the final type is `std::string&amp;`.
That's right. I knew I was forgetting something about that. Complexity aside, most of this new auto stuff is actually pretty awesome. I know one thing though, using auto as the return type on a function seems like an absolutely awful idea, outside of maybe some private helper function dealing with an exceptionally long type name (std::vector&lt;std::vector&lt;MyFavoriteTypeInTheWholeWideWorld&gt;&gt;)
C is definitely a mess of a language. But it's rather small, so it's actually possible to remember all the quirks. C++ is also a mess. But it's a huge language so it's literally impossible to understand all of it. Source: did work in both :-)
Yet another Rustish "yes, it's fast but it's not that kind of fast" :-)
[It's compared to GNU grep, ag, and more](http://blog.burntsushi.net/ripgrep/)
Tru tru
I think the problem was with my preset array length instead of using malloc. I changed that and got it working in OJ.
How does the analogy work with smart_pointers in c++?
I gave you multiple ways to do just that.
&gt;Doesn't have full POSIX regex though so there's that That is the reason it's faster. It probably doesn't implement backreferences since they require a backtracking regex engine and can't be modeled with a finite state machine. 
It uses DFA, yes, but afaik GNU grep tries to use the same mechanics when it doesn't need a backref
&gt; But as far as raw performance goes, C is still king. i just really don't see how C magically performs better than Rust - C programs for some things are faster because you can do sketchy shit with your memory, and you can do the same thing in Rust, you just have to put it in `unsafe`.
Array of what? What do you mean by "the string"? Need a bit more context here.
Isn't that rigorous and responsible engineering practices, and not necessarily because of C?
cgdb
I don't think I understand your question, could you provide some example code? What kind of errors are you getting? At compilation or run-time? &amp;nbsp; I assume what you mean is that you've implemented a linked list in a single source file where a global variable is being used by nearly every function. In trying to write more modular code you've elected to split the source into multiple files and headers, but those now external functions can't access the global variable you've declared in the file where you've defined `main`. &amp;nbsp; If that's correct, my solution would be to wrap the global variable into the struct for the linked list since I assume you'd be passing that to all these functions anyway. &amp;nbsp; If I'm incorrect and you're stuck with what you describe above I recommend double checking your: * function declarations: have you added this new parameter to the list in your declarations? Same goes for definitions. * variable definition: have you defined a variable in `main` to pass to your functions? * compilation: have you updated your makefile or compilation command to reflect the changes in the structure of your code? &amp;nbsp; Hope this helps. &amp;nbsp; **EDIT:** formatting, clarification.
Did you open the file in binary mode? http://en.cppreference.com/w/c/io/ftell
Thanks! Using fopen(filename, "rb") solved the issue. Should I keep fopen(filename, "r") for non-windows systems?
I believe OP is attempting to avoid the use of global variables altogether.
This is all I get: http://i.imgur.com/GTE68pr.png
Fortunately, most platforms are nominally POSIX. On Windows, I typically add a define for strtok_r (as well as strcasecmp, which I also often use): #ifdef WIN32 #define strtok_r strtok_s #define strcasecmp _stricmp #enif I wish there were as easy a replacement for a proper `snprintf` on Windows, but I suppose it's only ten lines of code or so to provide an implementation there, so not big deal. NB: By "on Windows" I mean "compiled with the Microsoft compiler using the Microsoft CRT".
For the future, always specify all error messages you get right in the question.
[modern c++](https://www.rust-lang.org/en-US/)
Like this: unsigned short my_array[] = { 0x0001, 0x0403, 0x6014, 0x0900, 0x0080, 0x0008, 0x0000, 0x12A0, 0x28B2, 0x1ADA, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0056, 0x0001, 0x92C7, 0x356A, 0x0154, 0x3100, 0x744A, 0x6761, 0x5D53, 0x3274, 0x434E, 0x0000, 0x0000, 0x0000, 0x4400, 0x6769, 0x6C69, ... }; Note that the actual order of bytes in memory depends on the byte order of your platform.
Indeed, and if you want to just make it an array of single bytes rather than shorts (two bytes), you can do this instead. unsigned char my_array[] = { 0x00, 0x01, 0x04, 0x03, 0x60, 0x14, 0x09, 0x00, 0x00, 0x80, 0x00, 0x08, 0x00, 0x00, 0x12, 0xA0, 0x28, 0xB2, 0x1A, 0xDA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x01, 0x92, 0xC7, 0x35, 0x6A, 0x01, 0x54, 0x31, 0x00, 0x74, 0x4A, 0x67, 0x61, 0x5D, 0x53, 0x32, 0x74, 0x43, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x67, 0x69, 0x6C, 0x69, ... };
Ok, thank you
Just be sure to `#include &lt;stdint.h&gt;;` to prevent compiler errors.
Your post got caught in our spam filter. I apologize for the inconvenience.
Thank you for this interesting article. However, I do not see how it is related to C programming and have removed it for being off topic. Please post this content elsewhere instead.
I'll admit I have done this myself but you should be aware of this: **Do not use fseek() and ftell() to compute the size of a regular file.** https://www.securecoding.cert.org/confluence/display/c/FIO19-C.+Do+not+use+fseek%28%29+and+ftell%28%29+to+compute+the+size+of+a+regular+file
Using fork() for that sounds like a dumb idea. Start here: https://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations
this is for a school project,i know it doesnt make any sense at all.but i need to perform it in using forks 
Alright, now what exactly are you trying to do? You mention writing data, but then you mention a console. And from your code it just looks like you're writing numbers ``0 ... EEUA_Size`` to the EEPROM?
Just change: FT_EE_UAWrite(ftHandle, buffer, EEUA_Size); to: FT_EE_UAWrite(ftHandle, (uint8_t*)Xilinx, 256);
Could you just use a normal recursive algorithm but fork instead of recursing? This whole idea reminds me of [sleep sort](https://i.imgur.com/hYbOssz.png).
I'll give it a look. Thanks
The problem i'm having is the last part, to query if a certain date is in the list. As far as I know i've done it correctly but it isn't finding dates that are there. Description: Input n (1&lt;=n&lt;=10000) and then followed by n lines. Each line corresponds to a valid date, consisting of one string ("January", "February", ..., or "December"), one integer between 1 and 31, and one two digit integer representing the year (from 90 to 99, and then from 00 to 12). You do not have to worry about date validation. All dates in the input are valid dates. Please use structures to store the dates. Please use malloc to dynamically allocate just enough space for n structures. You are asked to sort the dates chronologically using the built-in qsort function. Please output the sorted list, one date per line, from most recent date to oldest. Please also use the built-in bsearch function to allow for a user query to check whether a specific date is in the list, and output either "Yes" or "No". Input: n, the number of dates to sort, followed by n dates, followed by a user query in format day month year (e.g. “1 1 00” or “31 3 68”). (Note this is a different format as the rest of the dates are presented in) Output: Sorted list of dates, followed by “Yes” or “No” to indicate whether the query date input by the user (e.g. 1 1 00 day month year) is in the list. Test input 10 January 1 01 January 1 00 February 28 99 July 17 12 September 10 12 July 1 00 June 30 90 August 25 06 May 27 08 October 1 03 1 1 00 Test output September 10 12 July 17 12 May 27 08 August 25 06 October 1 03 January 1 01 July 1 00 January 1 00 February 28 99 June 30 90 Yes
This is not a general purpose solution and the resulting C code is fairly questionable. It is however, impressive.
It's still stupid; you just got lucky.
Isn't just better to write the thing all over from scratch? Aren't we coders?
[Weak ass instructor.](http://stackoverflow.com/questions/28394145/three-sort-without-if-conditional) That's a crap homework exercise. 
Depends on how much time you want to spend. I prefer not to waste man hours if there is no need. Work smart, not hard. That said, of course rewriting is often appropriate. Though, I cannot say that it is in this case.
I'm sorry for the author, seems like his time machine is broken.
Just use comparisons of the form (a &gt; b) &amp;&amp; (a=max) 
I don't find C itself to be a mess, but the resulting code you write may be.
Well C is a beast when it comes to different OS. Perhaps lenght of long is 32 bits on 32 bit liux and 64 bits on 64 bit linux. And this isnt only thing... (Though you could be safe if you would use long long (they have same lenght in bits in both of OS). As it follows I would recomend that you work in an exact environment that you are using at university. Just run it via Virtual machine and do school codimg in it.
Is there any way on a 64 bit system to just run the code in a 32 bit compiler perhaps? I could just test my code in Eustis, but the whole reason I'm trying to get it done locally is because every time I edit my code in an editor like Atom, I have to reupload the new saved copy to the Eustis server before I can compile. The server sometimes experiences some lag when a large volume of students are using it too, especially close to due dates. 
Or just use fixed size integers. Include `stdint.h` and enjoy `int32_t`, `uint32_t`, `int64_t` and other goodies.
Your IDE is just calling your compiler with a pre-configured set of parameters, which you can probably tune. You could just save your source files and compile them manually, or better yet write a Makefile for your project and ditch your IDE. It'll help you learn how things work *and* you won't have any issues with different environments (just recompile it there with the same parameters or cross-compile for it). Since I mentioned compiler parameters and Makefiles here's a nice set of warnings: `-Wall -Wextra -Wpedantic -Wformat-security -Wfloat-equal -Wshadow -Wconversion -Winline -Wpadded`, some more useful for learning purposes than for practical ones. Expect things to break. 
Does he not know what indentation is?
That reminds me, I was looking at a Z80 assembly program once, and at one point it used a jump instruction to go back to half-way through an opcode (turned out that the second half of the opcode was a different, valid opcode)
If I were you I'd install the 32 bit version of Ubuntu 16.04. If you can install the 64 bit version, you can install the 32 bit version. You have the advantage of being able to write on the exact platform the code will be run on, which is a luxury not all programmers have.
Then the title is wrong and needs to be changed cause the tool does not do what the title describes.
Why would anyone want to do this at all?
This isn't a disassembler.
That's a great point that I'd entirely forgotten about. Also I don't know why but this sub seems completely obsessed with `scanf`.
Well, the author wrote a couple other programs that were successfully translated, so there's that.
&gt; scanf("%d", &amp;i); causes undefined behaviour if they enter a number that is outside of the range of int. (For example 123456789101112 on a system with 32-bit int). &gt; Do you have a reference for this? I just looked at the man page for scanf and didn't see anything like that mentioned.
we havn't learnt switch yet
yes you can https://www.tutorialspoint.com/cprogramming/c_operators.htm you can use everything under Arithmetic, Relational, and Logical operators.
we havn't learnt 'for' statements yet, I did have a look and it seems very similar to 'while' statements, but they want us to stick with 'while' statements for now. thanks for offering!
I'm not sure how to compare 3 integers using this form, it will also need to account for cases where 2 or 3 of the integers are equal
Just going by the man page, it looks like `scanf` actually checks for this error: &gt;ERANGE &gt;The result of an integer conversion would exceed the size that can be stored in the corresponding integer type.
§7.19.6.2-10: &gt; Except in the case of a % specifier, the input item (or, in the case &gt; of a %n directive, the count of input characters) is converted to a &gt; type appropriate to the conversion specifier. If the input item is &gt; not a matching sequence, the execution of the directive fails: this &gt; condition is a matching failure. Unless assignment suppression was &gt; indicated by a \*, the result of the conversion is placed in the &gt; object pointed to by the first argument following the format &gt; argument that has not already received a conversion result. If this &gt; object does not have an appropriate type, or __if the result of the &gt; conversion cannot be represented in the object, the behavior is &gt; undefined.__ It's still [undefined in POSIX, too](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html).
It's worth pointing out that checking `strtol` for errors is a little bit awkward (you have to check both the "end" pointer passed into it as well as `errno`). Enough people check `strtol` for errors in the wrong way that the OpenBSD people created `strtonum`, which is simpler to check for errors. If `strtonum` is available to you, it's another option to consider.
The first problem you are going to run into is that `scanf()` tends to not be a very safe function in the first place. As you have already encountered, it does no validation of its own. There are other functions that allow you to read in strings of an arbitrary length but that is also dangerous since someone could send a continuous stream of junk characters to the program and fill up memory. You first need to write your own "read" function, which, if you are careful in the design, you can save and reuse in other programs. This function will not read in an integer but a string. char *get_input(int len) { char *str = calloc(len + 1, sizeof(*str)); if (!str) { return NULL; //out of memory } int c = 0; char *p = str; while ((c = fgetc(stdin)) != '\n') { *p++ = c; if (str + len == p) { break; } } return str; } Notice that you can pass in a length and we only read in that many characters. This prevents users from shoving more data into the buffer than we've allocated memory. Here I'm using `calloc` instead of `malloc`; this way the buffer is initialized to 0, remember, in C strings are null terminated character arrays, initializing to 0 makes sure I don't have to worry about tacking `\0` on the end once the user presses enter. Now you need a way to convert the string to an integer. One way to do this is with `strtol()`. You should read the man page on this function to get all the details, but it does a lot to help prevent issues. In the event that `strtol()` is unable to parse at least part of the string into a `long` it returns `0`. So consider that if you want your users to be able to enter `0`, you may need to come up with something else. l = strtol(str, bad, 0); Here is a dumb sample. The checks aren't the greatest, you could add some functionality using the facilities provided by `errno.h`; that is left as an exercise to the reader. :-D I've used some more "advanced" stuff with the pointers here, but then this is C so "embrace the power of the pointer or embrace your own destruction" as Saruman would say if he were a C programmer. Feel free to ask me for clarification. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; char *get_input(int); char *get_input(int len) { char *str = calloc(len, sizeof(*str)); if (!str) { return NULL; //out of memory } int c = 0; char *p = str; while ((c = fgetc(stdin)) != '\n') { *p++ = c; if (str + len == p) { break; } } return str; } int main(void) { char *s = get_input(3); char **bad; long l = 0; if (!s) { fprintf(stderr, "memory alloc error\n"); exit(-1); } l = strtol(s, bad, 0); // do something with l return 0; }
I've been coding Python3 for several years, and I'm starting to pick up C, currently. Judging from this post, is the market for C simply declining or is it being replaced by demand for other languages?
Good to know; thanks.
Thanks!
&gt; Is there any way on a 64 bit system to just run the code in a 32 bit compiler perhaps? Yes, you can tune your compiler flags to have it only produce 32 bit instructions for your assembler. `gcc -m32 -o foo foo.c` Is probably the simplest way. However, I'd recommend you SSH'ing into the development environment that you'll be graded on. That is the easiest way to avoid ugly surprises. Especially if you plan on linking against OS and third-party libraries.
What don't you understand exactly? if it's the define directive with arguments, [google first result seems quite usefull](https://gcc.gnu.org/onlinedocs/cpp/Macro-Arguments.html) If it's the max(a, max(b, c)), max is an associative function, so max(a,b,c) = max(max(a,b),c = max(max(a,c),b = max(max(b,c),a) If it's the med = a + b + c - high - low, then that's because in three numbers, you have a high, you have a low, and you have a median number. Adding the three and substracting the high and low leaves you with the median, as (a+b+c)=(high+median+low) =&gt; (a+b+c)-(high+low) = median
&gt;read a string With `fgets`, worth mentioning I guess.
You can use `xxd` to generate a C file, to include in your program. ``` $ xxd -i FILE &gt; binary.h ``` where `FILE` is your binary file. 
Break the problem down into simpler steps. Sort two numbers first, and then figure out where to place the final number. Equal numbers aren't a concern as swapping them yields the exact same order as before. Here's a (thoroughly untested) example implementation. int a, b, c; /* Inputs */ int x, y, z; /* Outputs */ /* Initial ordering. */ x = a; y = b; z = c; /* Sort A and B in ascending order. */ (a &gt;= b) &amp;&amp; (x = b, y = a); (a &lt; b) &amp;&amp; (x = a, y = b); /* Place C at the end if it is the largest number. */ (c &gt;= y) &amp;&amp; (z = c); /* Otherwise, insert C between A and B. */ (c &lt; y) &amp;&amp; (z = y); (c &lt; y) &amp;&amp; (y = c); /* If C also happens to be less than A, swap them. */ (c &lt; x) &amp;&amp; (y = x); (c &lt; x) &amp;&amp; (x = c); /* Print results. */ printf("%d %d %d\n", x, y, z);
Both approaches are fine, but I prefer the former.
Having just one exit point for a function might make cleanup easier (i.e. freeing resources). On the other hand it might lead to things such `goto fail;`.
in your function compare() you have two if-statements for the years. What are they for?
maybe it doesn't work because of this: http://www.cplusplus.com/reference/cstdlib/bsearch/ "Because this function may be optimized to use a non-linear search algorithm (presumably a binary search), **the elements that compare less than key using compar should precede those that compare equal, and these should precede those that compare greater.** This requirement is fulfilled by any array ordered with the same criteria used by compar (as if sorted with qsort)." edit 1: So if you delete line 44 to line 49 it may work ~~edit 2: Hmmm maybe if you do in compare(): { return yearcompare x 7000; return monthcompare x 400; } (replace x with times) and change compare, that it works with bsearch and use it for bsearch~~ 
 let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect("Failed to read line"); let guess: u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; continue, }; That's how Rust does it. So the C equivalent would be something like... int safe_int_input() { const int N = 20; char input[N]; if (fgets(input, N, stdin)) { return atoi(input); } exit(-1); } It's still not safe, however. [The atoi documentation](http://en.cppreference.com/w/c/string/byte/atoi) says that if the converted value falls out of range of corresponding return type, the return value is undefined and if no conversion can be performed, ​0​ is returned. There isn't a really good way to detect that unless you go over the string manually and check that each character is an actual digit. The best solution would be for atoi to be able to return some sort of error if it eventually fails, but we can't change that now.
Just install it in a VM. Virtual box will work fine for this. You can even find VM images online so you don't have to do anything.
Thanks, I'll have a go at it tomorrow since i'm not able to today. I'll let you know how it goes :)
This is exactly the type of coding i'm trying to switch to! Versus using an IDE like code:blocks, I'd like to use a text editor (Currently use Atom) and compile through the command line. On Eustis being a Ubuntu 16.04.2 LTS 32bit terminal, I compile like so: gcc Fibonacci.c testcase01.c However, when I update my code in Fibonacci.c for example, I have to delete it from the server, and then reupload the new one. For debugging early on where constant changes are being made, this is a pain. Especially when the server is under load an you have 200+ students trying compile code simultaneously. (We've definitely destroyed it's memory capacity more than once this semester.) So I still intend to test the final version of my code in Eustis before I submit, but for all the coding up to that point I'd like a local environment that is similar enough that I don't get a bunch of surprises at the end due to the cross platform. 
!!! I actually was just reading about the -m32 flag in this article: https://www.cyberciti.biz/tips/compile-32bit-application-using-gcc-64-bit-linux.html So if I were to run 64bit version of Mint or Ubuntu, and then compiled with the -m32 flag, wouldn't that be equivalent to compiling in the 32bit Ubuntu 16.04 environment? 
There was [an infamously catastrophic Apple TLS or PKI bug a couple of years ago caused by a mistakenly copy-pasted `goto fail` without braces](https://www.dwheeler.com/essays/apple-goto-fail.html). The fact that no static analysis flagged this and then subsequently no testing regime noticed that bad certs were being accepted is the real tragedy, of course. 
That's fine then, Ubuntu is pretty easy to install. I only suggested a VM because it sounded like you only needed the os installed specifically for this class. I was trying to save you the trouble of installing it on a partition on your computer is all. But if you're all ready started with the install feel free to dual boot. The experience won't hurt. The only suggestion I have is install a 32-bit version since that's what they are using at your school. The amount of memory reserved for the primitive types in Clang depends on the address bus size. You might also want to check what compiler and version they are using and try to match that as well.
Spin up VM of an ubuntu server that matches the spec of the machine your working on "Eustis". VirtualBox is a free option that runs Linux, OSX, and Windows. There are a few commands that can give you info on the system.... &gt; `uname --all` &gt; - This gives you the linux kernel version and the OS version you are running I also found this thread below about Eustis which might be helpful. https://www.reddit.com/r/ucf/comments/2kt78l/using_ucf_eustis_for_cs1/ 
It can. This is a typical reason why you might need to violate the rule of thumb. But considerable effort should be invested in trying to refactor it until the code is very clear but there is still one entry and one exit. 
I agree, but I interpreted the original comment of "things such as goto fail;" as being a reference to this notorious Apple bug in particular, not the use of `goto` to jump to a unified cleanup. 
This is a point of contention for many people. In most cases I use multiple returns because as I'm reading it is easy for me to see that control is returned "here", I don't have to slog through a bunch of extra checks and try to follow a stored return value; I think it is more error likely to not exit immediately when you are ready to do so. However, if I feel that storing a return value makes more sense in the context of the code then I'll do that. Sometimes the rules are just guide lines - this is one of those times.
So if a function has a fairly involved clean up process it would be better to use the second method?
Yes, because otherwise you need to do the clean-up code before every `return`. You don't even need to think of an "involved process", if you have to do any cleanup at all using the second method is preferred if only because you only need to program the cleanup once.
Exactly this. My rule of thumb is 1. before any return, make sure you're doing any needed cleanup 2. within reason, avoid code duplication. This aids tremendously with maintainability (you will have to update the cleanup code eventually) and readability (the reader - maybe future you - will have to look and see if the blocks differ)
Single Entry/Single Exit is a lot like Third Normal Form in databases, largely academic. 
 goto cleanup; ^^^j/k
It's under the GPL 3.0 license tho.
Pretty much. You "see" the files as if they were local but they aren't. When you unmount, or when you make changes, they are listed to the server. You may prefer starting with an sftp plugin for atom first however. It's a bit simpler.
So it turns out after going ahead and going about the previous line of thought and changing it so that pretty much all the functions in the code look like this in regards to pHead: /* Display Double linked list data in forward direction */ void DisplayNodeForward(DoubleLinkedList* pHead) { DoubleLinkedList* pCurrent = pHead; if (pCurrent) { while(pCurrent != NULL ) { printf("\nNumber in forward direction is %d ",pCurrent-&gt;number); pCurrent=pCurrent-&gt;pNext; } } else { Error = LISTEMPTY; ErrorMessage(Error); } } It compiled fine and opens the menu, however as soon as I select an option, I segfault. Like so: https://i.imgur.com/FKfeFKc.png Doing what you mentioned, however, so that the respective functions essentially look like this: /* Display Double linked list data in forward direction */ void DisplayNodeForward(DoubleLinkedList** pHead) { DoubleLinkedList* pCurrent = *pHead; if (pCurrent) { while(pCurrent != NULL ) { printf("\nNumber in forward direction is %d ",pCurrent-&gt;number); pCurrent=pCurrent-&gt;pNext; } } else { Error = LISTEMPTY; ErrorMessage(Error); } } gives me a butt ton of errors like so: https://i.imgur.com/OWYmM0V.png Everything does have necessary mallocs and frees.
https://en.wikipedia.org/wiki/GNU_General_Public_License#Reception https://lwn.net/Articles/200422/
thank you very much for clarifying!
You'll have to post your full code if you want some help. It's hard to guess without seeing all the pieces.
God this list is terrible. Some things are wrong and some important operators are missing in this list. Please don't use this tutorial site, it's full of mistakes.
&gt;I assume you mean #include and not #define? yeah, I did mean #include. &gt;What MCU are you using that has the same interrupt vector for both the USART and I2C? If they share a vector there must be a way to check what the source of the interrupt was by polling status registers, and you can write a short function that will check the registers and call the appropriate handler. It's STM32F091RC. usart and i2c use the same DMA interrupt vector. I do poll the status registers for determining what actually caused the interrupt. &gt;I'd also suggest naming the function something more descriptive than interrupt_function, if you were using that literally and not as a placeholder. It's just a placeholder, the actual function name is defined within uC specific files provided by the manufacturer, so I can't really rename it. It's plenty descriptive though. &gt;If you have two .c files with the same symbol defined and it's not static, you're going to get an error regardless of whether you've included a header. I understand that. My question is, how should I manage my libraries, so that only the libraries that are included in the compiled program (through `#include &lt;lib.h&gt;`) are actually included, and those that are not are ignored during compilation. If I understood you correctly, you're suggesting to control the added libraries not through including them, but through makefile targets (adding a target `make include_usart` and `make include_i2c`)?
This is the full code with the edits than give me all the errors. http://pastebin.com/fFt6ADvs
Maybe someone else will chime in with ideas, but in my understanding no, not like you're thinking. The compiler operates on one translation unit a time - a source file with all of the #includes and macros expanded. Your makefile is compiling *.c and you can think of it as a batch file that expands to a bunch of lines like 'gcc source1.c', 'gcc source2.c', 'gcc lib.c', and so on. By the time the compiler gets to your source file that might or might not have an #include, it may have already compiled the .c file in question. You can go the *other* direction, though, and control the behavior of source files from the makefile. Usually you do that by using -D on the compiler command line to define a macro and then use #ifdefs to control compilation of sections of code. For example, I might use a -DNOWIFI macro in one make target to specify that the target shouldn't have the WiFi-related code compiled in, and #ifndef NOWIFI blocks in the application code would wrap the WiFi-specific parts. The make target could also exclude any source files that have only WiFi functions. 
 int *x = NULL; somefunc( *x ); // This is not allowed Perhaps you meant to take the address of x, using the &amp; operator? 
I appreciate your help. Would it work if I switched the #include statement to #define statement and the I would wrap the DMA interrupt vector function with #ifdef? Would this cause any problems that I'm not seeing?
You can certainly wrap the interrupt function with an #ifdef. Remember that the scope of a #define is only that translation unit, though. If you have a #define in myprog.c it's not going to carry over to mylib.c. You could have a configuration header for a project that is #included from all of your files, and then edit that header to control what's built. For example, the EWL C library that Freescale provides (and maybe other implementations, I don't know if it's universal) uses ansi_prefix.h to control options like whether you want printf() to include floating point support. You can also use that -D option from the makefile like I described previously to exclude the ISR, or to have an alternate version that does the polling and dispatching for a project that includes both libraries.
&gt;You can certainly wrap the interrupt function with an #ifdef. Remember that the scope of a #define is only that translation unit, though. If you have a #define in myprog.c it's not going to carry over to mylib.c. That's right, forgot that for a second. I guess I'm still puzzled what does #include actually does. I should refresh my C knowledge with Rich's book.
In your Makefile, replace the `all:` target with separate `i2c:` and `uart:` targets. pigeon@gauss ~/blah $ for f in $(find . -type f); do echo ":::${f}:::"; cat $f; done :::./main.c::: #include "lib.h" int main() { foo(); return 0; } :::./Makefile::: SOURCES_APP := $(wildcard *.c) SOURCES_I2C := $(wildcard i2c_lib/*.c) SOURCES_UART := $(wildcard uart_lib/*.c) OBJ_APP := $(SOURCES_APP:.c=.o) OBJ_I2C := $(SOURCES_I2C:.c=.o) OBJ_UART := $(SOURCES_UART:.c=.o) CFLAGS += -I./lib all: i2c uart i2c: CFLAGS += -DI2C -I./i2c_lib i2c: $(OBJ_I2C) $(OBJ_APP) $(CC) -o $@ $(LDFLAGS) $(LDLIBS) $^ uart: CFLAGS += -DUART -I./uart_lib uart: $(OBJ_UART) $(OBJ_APP) $(CC) -o $@ $(LDFLAGS) $(LDLIBS) $^ :::./lib/lib.h::: #pragma once void foo(); :::./i2c_lib/i2c.c::: #include "lib.h" #include &lt;stdio.h&gt; void foo() { puts("i2c"); } :::./uart_lib/uart.c::: #include "lib.h" #include &lt;stdio.h&gt; void foo() { puts("uart"); } pigeon@gauss ~/blah $ make cc -I./lib -DI2C -I./i2c_lib -c -o i2c_lib/i2c.o i2c_lib/i2c.c cc -I./lib -DI2C -I./i2c_lib -c -o main.o main.c cc -o i2c i2c_lib/i2c.o main.o cc -I./lib -DUART -I./uart_lib -c -o uart_lib/uart.o uart_lib/uart.c cc -o uart uart_lib/uart.o main.o pigeon@gauss ~/blah $ ./i2c i2c pigeon@gauss ~/blah $ ./uart uart pigeon@gauss ~/blah $ Be careful about using the `UART` or `I2C` defines, or anything included from headers in `i2c_lib` or `uart_lib`. You'll need to ensure the relevant bits are rebuild any time you change targets or Bad Things will happen.
`#include` just includes the actual contents of the referenced file as if the whole thing was pasted in to the referencing file. You *can* put function definitions in a .h file - the compiler doesn't care - but it's bad practice and it will give you multiple definition errors if you include it from multiple files. Nothing that actually occupies memory should go in a header file. In other words, the header provides information about objects that exist elsewhere. If the header has a declaration for `void foo(int bar);` then when your code references foo() the compiler knows that foo() takes an int and returns a void and it compiles your code trusting that foo() actually exists somewhere. The linker comes along, gathers up all of the individual object files, and resolves all of those references. Somewhere in those object files, there should be one and only one place that actually defines and exports a function named foo().
I was thinking about implementing it as targets in the makefile. I guess I will have to try it, since it won't work the way I wanted at first.
That's as it should be, then. I'd add one more thing for clarification - when you're dealing with standard libraries, it *does* feel like the `#include`s are controlling what libraries are included, but that's not really the case. You have something like libc.a that has all of those functions compiled in already. If you use the proper declaration for memcpy() in a source file, for example, you could call memcpy() without including string.h and it will work because memcpy() is already there - it's not like including string.h tells it to link in a different library. That might be the source of some of your confusion.
Sure thing. What do you need?
Hi, thanks. PM your email and I'll send a pdf with the task on it.
Sorry, I'm not going to do your homework for you. You won't learn anything this way and it's academic dishonesty. I am not going to be your accomplice in this kind of behaviour.
If it's homework - write it out on paper first. Sequentially. Once that works, coding should be easy. If you don't learn this skill, don't expect to hold a gig very long. The better companies will see through you easily.
Sucks to be you. Own up and learn from your mistakes, don't try to cheat.
You know, writing this: if(something) { puts("Yes"); while(true) { puts("looping..."); } } instead of this: if(something) { puts("Yes"); while(true) { puts("looping..."); } }
`valgrind` is a must have
I'd do this with a switch() statement -- with a case for \n and a case for \r : switch(buf[i]) { case '\n': case '\r': done = TRUE; break; default: break; } This is very extensible too -- like -- one day, you may wish to use this code block to trap another char, and do some other action. A setup like this makes that mod a snap. switch(buf[i]) { case '\n': case '\r': done = TRUE; break; case '\0': printf("NUL detected in stream at offset %d -- wtf?!\n", i); break; default: break; } 
**Company:** Imagination Technologies **Type:** Full Time **Description:** OpenGL ES / Vulkan driver developer, Work primarily in C. Working knowledge of the graphics pipeline a must, Vulkan experience a plus. Experienced and graduate positions available. The vacancies below only mention OpenGL ES but they're shared with the Vulkan team and you'll be directed to whichever team seems more appropriate. **Location:** Kings Langley (30 minutes from central London), UK. English **Remote:** No **Visa Sponsorship:** Yes **Contact:** Careers Page [2017 Graduate role](http://careers.imgtec.com/cw/en/job/496164/2017-graduate-opengl-es-graphics-driver-software-engineer), [Current graduate role](http://careers.imgtec.com/cw/en/job/495751/opengl-es-graphics-driver-software-engineer), [Experienced role](http://careers.imgtec.com/cw/en/job/495714/opengl-es-graphics-driver-software-engineer)
This is it so far. Need to sort the numemployee starting from smallest and familyname ******************************************************* #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //declaring the DOB Structure struct strDOB { // declaring variables int day; int month; int year; }; //declaring the strstartadte Structure struct strstartdate { // declaring variables int day; int month; int year; }; //declaring the strname Structure struct strName { // declaring variables char firstname [25]; char middlename [25]; char familyname [25]; }; //declaring the strstarttime Structure struct strstarttime { // declaring variables double hours; double minutes; double seconds; }; //declaring the main streperson structure struct strperson { // declaring variables char jobtitle [50]; int numemployee; // decalring structures struct strDOB strDateOffBirth; struct strstartdate strStartDate; struct strName strName; struct strstarttime strStartTime; }; // function prototypes void fnPopulateArray (struct strperson person []); void PrintPeopleDetails (struct strperson); // main method int main(void) { // struct strperson *arrayPointer struct strperson person[5]; //*arrayPointer = person fnPopulateArray (person); return 0; } void fnPopulateArray (struct strperson person []) { // pritiing out details printf("Details Off The Five People...\n\n"); //adding the deatils off person0 strcpy (person[0].strName.firstname, "David"); strcpy (person[0].strName.middlename, "Denis"); strcpy (person[0].strName.familyname, "Hodgkiss"); strcpy (person[0].jobtitle, "Senior Lecturer"); person[0].strDateOffBirth.day = 04; person[0].strDateOffBirth.month = 9; person[0].strDateOffBirth.year = 1954; person[0].strStartDate.day = 1; person[0].strStartDate.month = 9; person[0].strStartDate.year = 2001; person[0].strStartTime.hours = 8; person[0].strStartTime.minutes =0; person[0].strStartTime.seconds =0; person[0].numemployee = 3; //adding the deatils off person1 strcpy (person[1].strName.firstname, "James"); strcpy (person[1].strName.middlename, "Albert"); strcpy (person[1].strName.familyname, "Mccarren"); strcpy (person[1].jobtitle, "PT Tutor"); person[1].strDateOffBirth.day = 6; person[1].strDateOffBirth.month = 6; person[1].strDateOffBirth.year = 1902; person[1].strStartDate.day = 9; person[1].strStartDate.month = 10; person[1].strStartDate.year = 1987; person[1].strStartTime.hours = 9; person[1].strStartTime.minutes =0; person[1].strStartTime.seconds =0; person[1].numemployee = 1; //adding the deatils off person2 strcpy (person[2].strName.firstname, "Rachel"); strcpy (person[2].strName.middlename, "---------"); strcpy (person[2].strName.familyname, "Cornes"); strcpy (person[2].jobtitle, "Head of Department of Computing"); person[2].strDateOffBirth.day = 1; person[2].strDateOffBirth.month = 1; person[2].strDateOffBirth.year = 1990; person[2].strStartDate.day = 6; person[2].strStartDate.month = 11; person[2].strStartDate.year = 2012; person[2].strStartTime.hours = 9; person[2].strStartTime.minutes =30; person[2].strStartTime.seconds =10; person[2].numemployee = 1; //adding the deatils off person3 strcpy (person[3].strName.firstname, "Russel"); strcpy (person[3].strName.middlename, "j."); strcpy (person[3].strName.familyname, "Campion"); strcpy (person[3].jobtitle, "Dean of School"); person[3].strDateOffBirth.day = 6; person[3].strDateOffBirth.month = 7; person[3].strDateOffBirth.year = 19879; person[3].strStartDate.day = 9; person[3].strStartDate.month = 9; person[3].strStartDate.year = 1989; person[3].strStartTime.hours = 9; person[3].strStartTime.minutes =0; person[3].strStartTime.seconds =0; person[3].numemployee = 2; //adding the deatils off person4 strcpy (person[4].strName.firstname, "Astrid"); strcpy (person[4].strName.middlename, ""); strcpy (person[4].strName.familyname, "Herhoffer"); strcpy (person[4].jobtitle, "Senior Lecturer"); person[4].strDateOffBirth.day=9; person[4].strDateOffBirth.month =8; person[4].strDateOffBirth.year =07; person[4].strStartDate.day = 12; person[4].strStartDate.month = 12; person[4].strStartDate.year = 2014; person[4].strStartTime.hours = 11; person[4].strStartTime.minutes =30; person[4].strStartTime.seconds =0; person[4].numemployee = 5; // passing the person details to the function printf(" person 1\n"); PrintPeopleDetails (person [0]); printf("\n person 2\n"); PrintPeopleDetails (person [1]); printf("\n person 3\n"); PrintPeopleDetails (person [2]); printf("\n person 4 \n"); PrintPeopleDetails (person [3]); printf("\n person 5 \n"); PrintPeopleDetails (person [4]); } // printng out details void PrintPeopleDetails (struct strperson p) { printf("\n First Name Is: %s",p.strName.firstname); printf("\n Middle Name Is: %s",p.strName.middlename); printf("\n Family Name Is: %s",p.strName.familyname); printf("\n Job Tittle: %s",p.jobtitle); printf("\n Date Off Birth Is: %02i/%02i/%i", p.strDateOffBirth.day, p.strDateOffBirth.month, p.strDateOffBirth.year); printf("\n Start Date Is: %02i/%02i/%i", p.strStartDate.day, p.strStartDate.month, p.strStartDate.year); printf("\n Start time is: %d:%d:%d", p.strStartTime.hours, p.strStartTime.minutes, p.strStartTime.seconds); printf("\n The Enployee Number Is: %03d \n", p.numemployee); }
 ******************************************************* #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //declaring the DOB Structure struct strDOB { // declaring variables int day; int month; int year; }; //declaring the strstartadte Structure struct strstartdate { // declaring variables int day; int month; int year; }; //declaring the strname Structure struct strName { // declaring variables char firstname [25]; char middlename [25]; char familyname [25]; }; //declaring the strstarttime Structure struct strstarttime { // declaring variables double hours; double minutes; double seconds; }; //declaring the main streperson structure struct strperson { // declaring variables char jobtitle [50]; int numemployee; // decalring structures struct strDOB strDateOffBirth; struct strstartdate strStartDate; struct strName strName; struct strstarttime strStartTime; }; // function prototypes void fnPopulateArray (struct strperson person []); void PrintPeopleDetails (struct strperson); // main method int main(void) { // struct strperson *arrayPointer struct strperson person[5]; //*arrayPointer = person fnPopulateArray (person); return 0; } void fnPopulateArray (struct strperson person []) { // pritiing out details printf("Details Off The Five People...\n\n"); //adding the deatils off person0 strcpy (person[0].strName.firstname, "David"); strcpy (person[0].strName.middlename, "Denis"); strcpy (person[0].strName.familyname, "Hodgkiss"); strcpy (person[0].jobtitle, "Senior Lecturer"); person[0].strDateOffBirth.day = 04; person[0].strDateOffBirth.month = 9; person[0].strDateOffBirth.year = 1954; person[0].strStartDate.day = 1; person[0].strStartDate.month = 9; person[0].strStartDate.year = 2001; person[0].strStartTime.hours = 8; person[0].strStartTime.minutes =0; person[0].strStartTime.seconds =0; person[0].numemployee = 3; //adding the deatils off person1 strcpy (person[1].strName.firstname, "James"); strcpy (person[1].strName.middlename, "Albert"); strcpy (person[1].strName.familyname, "Mccarren"); strcpy (person[1].jobtitle, "PT Tutor"); person[1].strDateOffBirth.day = 6; person[1].strDateOffBirth.month = 6; person[1].strDateOffBirth.year = 1902; person[1].strStartDate.day = 9; person[1].strStartDate.month = 10; person[1].strStartDate.year = 1987; person[1].strStartTime.hours = 9; person[1].strStartTime.minutes =0; person[1].strStartTime.seconds =0; person[1].numemployee = 1; //adding the deatils off person2 strcpy (person[2].strName.firstname, "Rachel"); strcpy (person[2].strName.middlename, "---------"); strcpy (person[2].strName.familyname, "Cornes"); strcpy (person[2].jobtitle, "Head of Department of Computing"); person[2].strDateOffBirth.day = 1; person[2].strDateOffBirth.month = 1; person[2].strDateOffBirth.year = 1990; person[2].strStartDate.day = 6; person[2].strStartDate.month = 11; person[2].strStartDate.year = 2012; person[2].strStartTime.hours = 9; person[2].strStartTime.minutes =30; person[2].strStartTime.seconds =10; person[2].numemployee = 1; //adding the deatils off person3. strcpy (person[3].strName.firstname, "Russel"); strcpy (person[3].strName.middlename, "j."); strcpy (person[3].strName.familyname, "Campion"); strcpy (person[3].jobtitle, "Dean of School"); person[3].strDateOffBirth.day = 6; person[3].strDateOffBirth.month = 7; person[3].strDateOffBirth.year = 19879; person[3].strStartDate.day = 9; person[3].strStartDate.month = 9; person[3].strStartDate.year = 1989; person[3].strStartTime.hours = 9; person[3].strStartTime.minutes =0; person[3].strStartTime.seconds =0; person[3].numemployee = 2; //adding the deatils off person4 strcpy (person[4].strName.firstname, "Astrid"); strcpy (person[4].strName.middlename, ""); strcpy (person[4].strName.familyname, "Herhoffer"); strcpy (person[4].jobtitle, "Senior Lecturer"); person[4].strDateOffBirth.day=9; person[4].strDateOffBirth.month =8; person[4].strDateOffBirth.year =07; person[4].strStartDate.day = 12; person[4].strStartDate.month = 12; person[4].strStartDate.year = 2014; person[4].strStartTime.hours = 11; person[4].strStartTime.minutes =30; person[4].strStartTime.seconds =0; person[4].numemployee = 5; // passing the person details to the function printf(" person 1\n"); PrintPeopleDetails (person [0]); printf("\n person 2\n"); PrintPeopleDetails (person [1]); printf("\n person 3\n"); PrintPeopleDetails (person [2]); printf("\n person 4 \n"); PrintPeopleDetails (person [3]); printf("\n person 5 \n"); PrintPeopleDetails (person [4]); }. // printng out details void PrintPeopleDetails (struct strperson p) { printf("\n First Name Is: %s",p.strName.firstname); printf("\n Middle Name Is: %s",p.strName.middlename); printf("\n Family Name Is: %s",p.strName.familyname); printf("\n Job Tittle: %s",p.jobtitle); printf("\n Date Off Birth Is: %02i/%02i/%i", p.strDateOffBirth.day, p.strDateOffBirth.month, p.strDateOffBirth.year); printf("\n Start Date Is: %02i/%02i/%i", p.strStartDate.day, p.strStartDate.month, p.strStartDate.year); printf("\n Start time is: %d:%d:%d", p.strStartTime.hours, p.strStartTime.minutes, p.strStartTime.seconds); printf("\n The Enployee Number Is: %03d \n", p.numemployee); }
If you have control over what is being sent you could frame the packets and include a length in bytes as a part of your header. Otherwise, myrrlyn's answer would work.
Dude, you are printing the result before you've done any calculations. Moreover, the code is filled with *very* basic errors. What do you think `if (m == 4 || 6 || 9 || 11)` does? Find a tutorial that teaches you things from the beginning, and follow that.
Seeking through whole file is not the brightest idea, especially if you're checking many of them. `struct stat fst; if (stat( filepath, &amp;fst ) != -1 ) file_size = (long long) fst.st_size; `
Given the function name "ircget" and assuming the program is supposed to read IRC packets, a better size would be 512, since that's the maximum message size used by the protocol. This will make sure the message will always fit.
CodeBlocks is just an IDE. It doesn't ship with compilers. Enable all warnings. Some compilers behave differently than others.
Yes, that would be correct. Though, you don't need all of the parentheses: if (m == 4 || m == 6 || m == 9 || m == 11)
You are asking a lot to expect people to wade through your code as you have posted it to try to help you. Try using the follow to make your code readable before posting it: 1. a [code formatter](http://codebeautify.org/c-formatter-beautifier) 2. post code for larger programs to [Gist](https://gist.github.com/) 3. for smaller amounts of code, you can use [Reddit Lint](http://redditlint.com/) to insert the required 4 spaces 
Yes I know but for small program its fine. Ok In next lecture I will make my code more readable thanks for feedback. 
you are printing the result before evaluating it. In c we have top down approach so default value of variable intially is 0. your code should be #include &lt;stdio.h&gt; int d, m, y, nwd, nwm, nwy; int main() { printf("Enter a date in the form day month year: "); scanf("%d, %d, %d", &amp;d, &amp;m, &amp;y); if (m == 4 || 6 || 9 || 11) { if (d &gt;= 24) { nwd = d + 7 - 30; nwm = m + 1; nwy = y; } else if (d &lt;= 23) { nwd = d + 7; nwm = m; nwy = y; } else { printf("Error.\n"); } } else if (m == 1 || 3 || 5 || 7 || 8 || 10) { if (d &gt;= 25) { nwd = d + 7 - 31; nwm = m + 1; nwy = y; } else if (d &lt;= 24) { nwd = d + 7; nwm = m; nwy = y; } else { printf("Error.\n"); } } else if (m == 12) { if (d &gt;= 25) { nwd = d + 7 - 31; nwm = 1; nwy = y + 1; } else if (d &lt;= 24) { nwd = d + 7; nwm = m; nwy = y; } else { printf("Error.\n"); } } else if (m == 2) { if ((d &gt;= 23) &amp;&amp; (y % 400 == 0)) { nwd = d + 7 - 29; nwm = 3; nwy = y; } else if ((d &lt;= 22) &amp;&amp; (y % 400 == 0)) { nwd = d + 7; nwm = 2; nwy = y; } else if ((d &gt;= 22) &amp;&amp; (y % 100 == 0)) { nwd = d + 7 - 28; nwm = 3; nwy = y; } else if ((d &lt;= 21) &amp;&amp; (y % 100 == 0)) { nwd = d + 7; nwm = 2; nwy = y; } else if ((d &gt;= 23) &amp;&amp; (y % 4 == 0)) { nwd = d + 7 - 29; nwm = 3; nwy = y; } else if ((d &lt;= 22) &amp;&amp; (y % 4 == 0)) { nwd = d + 7; nwm = 2; nwy = y; } else { printf("Error.\n"); } } printf("\nThe date a week later is: %d/%d/%d", nwd, nwm, nwy); } 
what you are talking ???
int Add(int x, int y) { if (y == 0) return x; else return Add( x ^ y, (x &amp; y) &lt;&lt; 1); }
This is a binary adder. It's how the add instruction is implemented in hardware. As we have access to the Boolean operations that compose it, one *can* perform addition by doing so instead of using the `+` sign. However, doing so is dumb as hell.
Implementing the basic arithmetic operations using bit wise operations is a very common way to get started in digital systems, and used in multiple courses.
[I'm well, well aware](https://myrrlyn.net/blog/how-computers-work/processors#binary-addition).It's not done in C, though, but in Boolean algebra on paper and then in an HDL such as Verilog.
As a rule of thumb, always, always, always post as much code as possible with your question. This way it's easier to spot the problem, especially since it might be somewhere you didn't even mention in the first place. 
&gt; 1. What are your main obstacles? 2. What would help you to learn C? Some kind of information? A system? A framework? Community of people tackling the same challenges? 3. What is the best format for you to learn programming? Textbooks and exercises? Interactive format? Video courses? A project with multiple tasks? That differs from person to person, these questions are for you.
It's just a HW, right? I don't think skipping this one will make you fail the class. 
1. Linked lists, structures, recursion. 3. Small projects where you solve problems on your own. Maybe some spoilers in case you're struggling. 
What do you think is missing from the current ecosystem of C tutorials? 
That could be true, but people don't have to follow the blog I believe that teaching is a good way to learn a subject through and through and will help the writer get a clear understanding
Sure, sometimes there's a modern language that's tailor-made for the problem, but there's absolutely nothing you cannot do with pure C. And even there's task you cannot do with nothing else but C. There's no way it can be replaced. There's just no substitute for the tasks it excels at, and really, there's no need of substitute it. C is here to stay. As long as there is Assembler running down in the basement.
I definitely don't mean to imply anything about the usefulness of C. There's a reason so much performance intensive software is written in it, and why it's used across such a broad range of devices. Personally I love the simplicity of the language, but it's hard to deny there are some dark corners that could use some improvement. You might consider watching Jon Blow's language "Jai" closely, as it's aiming to be a modern replacement for C (in the same sort of way C++ was meant to be before it become an overgrown monster). No guarantee of it coming through with all its intended features, but it looks promising.
Yes
You've heard this 3 times, but post code. It's much easier to help then. How many characters are you able to get from scanf? Is it just one, or is it multiple?
I have high hopes for gamification in general, and for learning in particular. People will go to great lengths to conquer computer games, including programming. Last week an open-source game with some embedded simplified C type programming was released: [Liberation Circuit](https://linleyh.itch.io/liberation-circuit). 
The last line is incorrect. Instead of calling `initial()` in the `printf` store the value returned in a variable and print that. I'm also confused by your second link; what are you trying to get that loop to do? 
Based in your response I don't think you've actually looked much into the language. If you watch his (uncomfortably long) videos where he demos the language, there's actually some really cool and interesting features. Compile-time executable code, effortless conversion from AOS to SOA, RTTI for free, multiple return value functions, not-garbage template functions, and self modifying code at compile time, etc. And that's just what I'm up to date on. It is being made with gamedev in mind, but I can see it being useful to a wide variety of performance intensive software. It's not so much reinventing the wheel as taking out the splinters and jagged edges from said wheel.
the whole program needs to loop, since this function has a do while do I need to just get rid of the do-while? 
Do you have any positions in the US?
&gt;A novice can write a linked list in C but an expert will write a cache-optimized, lock-free and multithread-safe linked list which is re-usable What do you mean by cache-optimized? Unrolled linked list ? Or some other magic? I would really like to know. 
I didn't need the loop in the second link. Thank you for your help!
Skimming the career website, it seems engineering positions are also available in India, Poland, and Taiwan. But they are for more senior engineers. 
And how would you implement a cache-optimized linked list? 
&gt; What do you mean by cache-optimized? Generally speaking, if you allocate the items next to each-other then you'll get better cache performance. This is a lot like unrolling (And you could also go for unrolled) but it would still be a standard linked-list. That said a generic linked-list implementation can't really be that cache-optimized unless it also controls the allocation of the items. Edit: I would also add, if you're using a non-intrusive linked-list then the allocation of the node's for the list can be done to ensure it is cache friendly. But that really doesn't buy you anything over a intrusive implementation because the items may still be allocated randomly. If you have to access all the items in the list then it's worse, because now not only do you have the cache issues from the items themselves, but you also have to access all the separately allocated nodes, which requires even more pointer-accesses and more cache space. Intrusive is basically always the way to go. It's also easy to implement a non-intrusive linked-list using an intrusive linked-list implementation anyway if you happen to need one somewhere.
&gt;1. What are your main obstacles? Not for me, first picking up K&amp;R was magic. Loved it from the first page. But worked as a TA in beginner and advanced c system programming courses . And also seen "professionals" struggle. The problem with C is handling the complexity, you are programming against real hardware / or at least a subset of real hardware. Add concurrency and it is a kill. Most cant handle it. &gt;2. What would help you to learn C? Brain transplants.. C programming is not for the weak, only the strong, only the Spartans! On a more serious note, emphasises on good programming practise from the start (helps with handling complexity, no magic numbers, good use of header files, when to make funksjon etc.), no hacking, you have to know what you do (lot of student are used to hacking python etc. This result in infinite amount of pain in C) and basic understanding of hardware is a must. &gt;3. What is the best format for you to learn programming? Study the works of the prophets, read your K&amp;R! Do the assignments, they are great! Then look at good code, the Minix project is nice. Also exist a text book that explains stuff. Learning asm is also a must. Also as a said in may other answer, writing a OS is a great way of learning C! 
Not ... really? C is a *terrible* language in which to explain Boolean arithmetic. &gt;help understand how it works at the lower level The full adder in C: `int s = a ^ b; int c = a | b;` doesn't explain *anything* about how binary adders work. Doing it on paper in Boolean arithmetic or Karnaugh maps, or doing it on a breadboard with logic chips, or doing it in Verilog, *those* grant actual understanding of how arithmetic works and why a ripple-carry pipe is cheap but slow whereas a look-ahead tree is expensive but fast and a Kogge-Stone is magic. C doesn't teach *anything* about how hardware works, which is explicitly by design. You can learn to toggle control switches in C, a purpose to which it is exceptionally well suited. But it's specifically designed to not reveal any of the digital architecture of which a CPU is composed. A core's assembly language will get you closer, but the actual electrical logic and HDL are the best means of learning how CPUs actually work. C is not.
If these variables are global then they will already be available for use in main // variables //... int main() { float f = inforgetter2(); // ... use variables } However excessive use of globals isn't a good idea. Consider breaking down what's happening in this function into several functions with arguments and return values. If you want to group data together, consider using a struct. typedef{ //members }Info; Info infogetter2() { ... } 
Thank you for the reply! &gt;What would help you to learn C? &gt;&gt;"Brain transplants.. C programming is not for the weak, only the strong, only the Spartans!" This is hilarious!!!
Do not post pictures of code. Instead, paste the code into your post and indent it with four spaces so it appears readable.
A pointer is *true* if it is not a null pointer. So if (lock-&gt;holder) { ... } is the same thing as if (lock-&gt;holder != NULL) { ... }
The importance of all the bitwise operations is dependent on what exactly you want to learn about or use the code for. If you really want to know about low-level, high performance code you'll need to know about bit masking, bit shifting, and general bit manipulation. This is because these are the smallest/fastest/most optimal operations, as you can store one piece of information per bit. Ultimately, using smaller bit sizes is usually more efficient for the processor. A basic example would be the use of a "flags" parameter to a function. Say we have some function that can take two string inputs, and does something with those strings. We don't really care what. You can define something like the following: #define STR1_IS_SPACE_TERMINATED 0x00000 #define STR1_IS_NULL_TERMINATED 0x00001 #define STR2_IS_SPACE_TERMINATED 0x00002 #define STR2_IS_NULL_TERMINATED 0x00004 (The use of these particular macros might be if you have a function that can be called from C, which NULL-terminates its strings, or COBOL which terminates using a space.) You can set up a flags parameter as something like the following: int flags = 0 flags &amp;= STR1_IS_NULL_TERMINATED flags &amp;= STR2_IS_SPACE_TERMINATED (I'll apologise here if this isn't correct syntax...I don't have a compiler infront of me right now) What those lines will do will be to set flags from all 0 bits to something like the following (exact result depends on the number of bytes used to represent an int on your system. I'll assume it's 4, the most common one) 0000 0000 0000 0005 You can do the easy maths to see that 5 must have been made up of a 4 + 1, given the available inputs. So when you examine the flags variable inside the function, you can do something like this to see what you should do: if ( flags &amp; STR1_IS_SPACE_TERMINATED) //Treat the first string as though it's space-terminated else if (flags &amp; STR1_IS_NULL_TERMINATED) //You can treat this string like a normal C character array which is NULL terminated
Well I mean, you're right that if cache performance is a huge concern you may want to just use an array. But arrays have big problems when removing and adding entries anywhere except for the end, so they're not really a solution if you need the flexibility of a linked-list. Using a separate allocator for the items in your linked-list to ensure the items are located close together allows you to get some of the benefits of using an array, while still maintaining the benefits of using a linked-list.
The easiest way to understand this stuff is to write all of the examples out in binary and go through them step-by-step. Take this passage from K&amp;R part 2.9: &gt; The unary `~` yields the one's complement of an integer; that is, it converts each 1-bit into a 0-bit and vice versa. For example, &gt; &gt; x = x &amp; ~077 &gt; &gt; sets the last six bits of `x` to zero. There's a lot going on here. To understand it, let's start by writing `077` out in binary. Integer literals that start with a 0 are interpreted in octal (base 8) in C, which means each digit corresponds to 3 bits. 000 111 111 0 7 7 Written out this way, it's easy to see that `077` is an integer with the six lowest (i.e., rightmost) bits set to 1, and all the rest set to 0. Now, if we take the one's complement of that integer, using the `~` operator, we'll get an integer with the six lowest bits set to 0 and all the rest set to 1. The exact value of the result depends on how many bits are in an integer. I'll use 16 bits to make this example easier to write; modern computers typically use 32. ~ 0000 0000 0011 1111 (= 077) --------------------- 1111 1111 1100 0000 Finally, we take this new integer and bitwise-and it with some arbitrary integer `x`.\* Since we don't know or care what the bits in `x` are, I'll just write them all as `b`, for "bit": bbbb bbbb bbbb bbbb &amp; 1111 1111 1100 0000 --------------------- bbbb bbbb bb00 0000 The result, as we can now see quite easily, is in fact `x` with its lowest six bits set to zero! --- \*If you don't understand bitwise and, here's a quick example. Suppose you have two binary numbers, `1100` and `0110`. To compute `1100 &amp; 0110`, all you do is line them up next to each other... 1100 &amp; 0110 ------ 0100 ...and then do a logical and on each *pair* of corresponding bits (i.e., each column), treating 1 as "true" and 0 as "false". Before moving on, you should convince yourself that - and-ing any bit with 0 gives you a 0. - and-ing any bit with 1 gives you back the original bit.
in our project- we allocated the nodes of a linked list using a custom allocator. Meaning we wrote a cache-optimized allocator which is just your standard malloc + optimizations. We wrote specifically to improve efficiency of a linked list. 
The sidebar at /r/opengl has several. [open.gl](https://open.gl/) or [learnopengl.com](https://learnopengl.com/) are both good.
I think you mean |=. Other than that, great reply!
It's not clear what you're trying to achieve but it's probably best to separate input reading and input validation.
C is certainly not the best language, but it is a common, high level language. I don't mess with hardware, so from my perspective seeing it in c helps me understand better. 
Thank you. This helped me a lot!
`if(x)` is always equivalent to `if( (x) != 0 )`. 
&gt;So my question is, is this part really important? If your interest is in low level programming and electronics, then this is absolutely essential - it is the foundation of digital computers. You might want to back off from the specifics of the C language for a minute if you don't have a solid grasp of how numbers are represented. Looks like [Khan Academy](https://www.youtube.com/watch?v=ry1hpm1GXVI) has a thing on binary numbers. Start with binary numbers (including how negative numbers are represented using two's complement notation) and then the Boolean operators that work on bits individually. Once you've got those concepts, the C bitwise operators should make more sense.
You might need to read up on the difference between single and double pointers, and how/when to use each one. int x[20]; int *px; void myfunc1( int *x ); void myfunc2( int **ppx ); myfunc1( x ); /* this works */ myfunc1( px ); /* this works as long as px is preinitialized. *px can be changed, but px cannot */ /* myfunc can change the values pointed at by x, but can't change x itself. In this case, px should be allocated in advance! */ Now, let's try with double pointers. myfunc2( &amp;px ); /* myfunc can allocate new memory by dereferencing the (int **). The address pointed at by px can change. */ myfunc2( &amp;x ); /* This is bad because...well, it's complicated */ 
if you do not set a value, the variable contains some random stuff from memory that was left there by some other software. so always initialize your vars
That makes sense, does you know of a way to ignore the 0's if the user inputs them? I have been searching and testing different modifiers like crazy but I can't find anything that is remotely useful. I have even tried casting but it doesn't change a thing
Software pre-fetching is also a nice trick, if you can get it right..
Top-level comment legitimately sounds like someone who just took an intro to HPC.
You do HPC as well ? 
Do not think C is a good first language. Also K&amp;R is the solution to all you problems, but is probably a little weak on bitfields and function pointers, in my opinion. And also do not cover c99 and c11. 
&gt; It really surprises me how a small book like K&amp;R can have so much depth, despite the fact that it's only 200-something pages! Indeed! It is incredibly dense without being overwhelming. I truly feel that students must be exposed to this textbook right in college (I was, and I thank my stars for it!), get their gears ground, and learn that pithiness does not necessarily equate incomprehensibility! Working through the entire book (most especially all the exercises) will definitely make you a better programmer for the rest of your life.
What runtime error? Also, could you please put this on pastebin or something, I'm on mobile and it's an abomination on there.
oops, I got the pointer freed and pString isn't pointed to the newly allocated memory 
I like stuff from [suckless](http://suckless.org), but dwm might be a little too small for what you're looking for (2000 loc). [tmux](https://github.com/tmux/tmux) is probably closer to the sort of scale you're looking for. **EDIT:** It may also be worth considering [vim](https://github.com/vim/vim) or [git](https://github.com/git/git).
Wrt Git, Fabien Sanglard released a great article that reviews the source code for Git. Would make a great complementary read. http://fabiensanglard.net/git_code_review/index.php
[Xv6, a simple Unix-like teaching operating system](https://pdos.csail.mit.edu/6.828/2012/xv6.html)
You didn't include the source for **writeFromARGV()**, but if it's similar to **writeFromSTDIN()** in that it contains: &gt; close(bufRead); then that's your problem. That line doesn't make sense, you should only call **close()** on a file descriptor, not a buffer size. I'm guessing **writeFromARGV()** reads from the file until it reaches end of file, when **read()** returns 0 which will be assigned to **bufRead**. When it executes **close(bufRead);** it closes file descriptor 0, which is STDIN. 
You're welcome, glad I could help :)
I wrote [this program](https://github.com/2mac/ttt) and now use it as training material for new C programmers. I leave reported issues unfixed so that new programmers can try to tackle them as learning exercises, and when I approve them, I'll merge.
&gt; an expert will write a cache-optimized, lock-free and multithread-safe linked list which is re-usable Or a newbie could just use ck fifo from http://concurrencykit.org/ which is everything he says 
I know this is a bit of a shameless plug but I get no benefit from it. I write solutions to Project Euler problems (mathematical problems you solve programmatically) in C. They are pretty easy to understand because the questions are pretty small and you can step through the code logically if you follow the problem. May even inspire you to do some. I highly recommend it as that's how I got my C literacy up. https://github.com/guynan/project_euler
I constantly see this mentioned but have you actually read the fossil code? Although clean, it uses a lot of non-standard stuff to build the project including three preprocessors (http://fossil-scm.org/index.html/doc/trunk/www/makefile.wiki). Definitely something I would recommend to an experienced C programmer (showing solutions to issues you have on large projects) but not at all something I would recommend to someone new to the language.
Thank you, fair enough. I will remove my post above though can you please tell me what I must improve on most pertinitely?
Sure. Pick any one of the files (I skimmed through 7 or 8 of them) and I'll PM you a code review.
Have a look at the underhanded C contest - there are write ups for the winning entries which explain some very easy to miss pitfalls, which may not be covered in textbooks. 
&gt; but you probably at least want to get the sign of the result correct? It depends on the context. For sorting / ordering, sure, but when you just need to find out if one set of bytes matches exactly (which is the use case described in the article), why would it matter?
As pointed by most posters, this is bad code, and bad benchmarking. But, the icing on the cake is that, for the problem at hand, it is the wrong solution: Fast string matches algorithm should at least be things like [boyer-moore](https://en.wikipedia.org/wiki/Boyer–Moore_string_search_algorithm), as it will skip over wrong matches, but will probably shine only for longer signatures. However, the OP is looking for several signatures at once, which is the realm of [deterministic finite automatons](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) (aka: the engine that powers regexp). Those will be able to find all the matches of all the headers in a single scan over the memory and will beat the hell out of any crappy optimisation. It may be a bit more tricky to code than casting misaligned char * to long *, though... edit: As if looks I have triggered OP, I'll clarify a bit the things here. * I am not going to answer to the comment below, the discussion /u/feelix had with /u/venju is a clear enough indication that it'll be a fest of improper behavior, goalpost moving, bad faith and inacurracies. I'm too old for that. * *"There is far more to data recovery than matching a bunch of file headers"*. Well, this is the extend of the problem definition in the blog post: *"it would memcmp() the start of filesystem blocks against a known list of file headers to find out where a file started"*. Not going to comment further. * *"That's about 1% of the job"*. I will not point at the ridiculness of making a blog post that involve poor benchmarking and undefined behaviour in order to get a 35% apparent speedup (apparent, because the speedup is only here on debug -- see comments about bad benchmarking) then claiming that it is now only 1% of the problem. * *"And the solution you proposed is useless for the job when you take the other requirements into consideration. Explaining them all to you would take far too long"*. You have no idea the things I have done. However, I give zero fuck about hearing your explanations, because a) I know them (I actually wrote a filesystem, so I have an ok grasp at data recovery), and b) the problem you defined in the blog post was scanning for headers. * *"If you think it's so easy,"*. I don't. I explicitely said it was more tricky than casting misaligned pointers. * *"I suggest you write your own data recovery software that's better than anything else on the market. You'll be rich. I'll just be over here laughing at you."*. Boy, this is /r/c_programming. Some of us in the audience have actually done quite a lot of commercial software in our lives. Do you really need to show how much of a cunt you can be ? For the misalignment part, I suggest people read the hilarious exchange below. It *is* undefined behavior, as far as C is concerned. Admire the goalpost move with /u/feelix drifting from *"It's in no way part of the C spec"* to *"Unaligned reads are supported by Intel"*. It is especially funny, as unaligned access are [not supported by Apple ARM](https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaTouch64BitGuide/ConvertingYourAppto64-Bit/ConvertingYourAppto64-Bit.html), and his product is a Mac OS X product (It is obvious that ARM will be the CPU of a future OSX version). For the record, in the 90's I vastly improved a parser (like made it twice faster) by surgically replacing if (!strcmp(foo, bar)) { /* stuff */ } by if (foo[0]==bar[0] &amp;&amp; !strcmp(foo, bar)) { /* stuff */ } removing the function call cost. It was in a time where compilers were bad at inlining standard function calls. Nowaday, they'll do that themselves (unless you compile in debug, of course). 
Use a `switch` statement: int ergebnis; switch (opva) { case '+': ergebnis = zahl1 + zahl2; break; case '-': ergebnis = zahl1 - zahl2; break; /* further operators here */ default: printf("Ungueltiger Operator!\n"); abort(); }
~~Even if you disable the aliasing violation, the new `long` load might go past the end of an allocated object and/or cross across to a new page. That can then trigger a pagefault where none existed before.~~
Thank you. 
What is your problem?
Nope you can't. Note how an operator is distinct from the symbol used to represent it in the C programming language. If you want to connect these two in your program, you have to somehow tell the compiler which symbol should represent which operation, which is what I did with the switch statement above.
"Y" is a string, which is a char array that is terminated by the null character. So a char and a char array (w two chars) are not the same.
You can use e.g. `goto` to do this.
The computer seems incredibly hard to beat.
thank you, this was exactly the issue.
For fun, try to print out the value of 'y' and "y" and consult an ASCII Table
N0 perhaps you can not store operator in variable. you want a=+; d=bac; this type of operation
&gt; There is an extra space before %c, otherwise you'll run into issues with newline. I learned about that today the hard way ^^ but thaks anyways for your reply.
a=5 b=5 a&amp;b= a=0101 b-0101 a&amp;b=5; why because 0 0=0 0 1=0 1 0=0 1 1=1; same for bitwise or operator 0 0=0 0 1=1 1 0=1 1 1=1; a|b=5;
`"y"` is a array of characters, which is made up of multiple characters. `'y'` is just a character. `"y"` will evaluate to a `char *` or a pointer to a character, in this case, the first character of the array of characters. Therefore you could probably get away with `value == *"y"`. But since the integer value of `"y"` will be a memory location, it is very unlikely it will match the input character.
There is far more to data recovery than matching a bunch of file headers. That's about 1% of the job. And the solution you proposed is useless for the job when you take the other requirements into consideration. Explaining them all to you would take far too long. If you think it's so easy, I suggest you write your own data recovery software that's better than anything else on the market. You'll be rich. I'll just be over here laughing at you. And there are several posts in this thread talking about the potential misalignment of the char * being cast to an int, but on modern 64 bit Intel CPU's [alignment simply does not matter](http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/). There is no performance hit or any other kind of penalty. It's amazing how many misinformed people there are on this topic.
^ Disregard, output a spaghetti-bowl of bugs, and **watch the world burn!** Just kidding. Foundational C knowledge is imperative so you *don't* have things breaking at random down the line.
&gt;But since the integer value of "y" will be a memory location, it is very unlikely it will match the input character. Especially since any address from 1 to 127 are in kernel space...
The benchmarking code is indeed indicative only, only there for illustration purposes. If you had that result, add a 0 onto the number of iterations for the for loop and then run it again. You'll find that the mycmp() version is indeed faster. And you have to run it without optimizations so it doesn't remove the loop, for this illustrative example. In practice, running it with full optimizations in production, obviously the speed advantage is still there (which is why the post was written in the first place)
KenM, is it you again?
Why are you trying to use such an old version?
It's just for a school assignment; the lab we use is normally on 4.8.2 already but mine for some reason isn't and they have not responded to any of my questions on how to fix this. I lost a lot of points for using 5.4.0 without realizing :/
At the hardware level unaligned access is possible, but at the C language level it is not. You've potentially broken the rules, so your code could have undefined behaviour. Also, the blog you linked to only mentions unaligned access performance for Intel, but what about ARM, POWER etc? Page 37 of [this PDF](https://www.redbooks.ibm.com/redbooks/pdfs/sg248171.pdf) disagrees with your statement entirely. Page 230 even says: &gt; To give an indication of the penalty for this type of misalignment, on a 4 GHz processor, a nine-instruction loop that contains an 8-byte load that crosses a 128-byte boundary takes double the time of the same loop with the load correctly aligned.
This code runs on Intel hardware. Unaligned access is not against the C language specification, so it hasn't 'broken the rules'. And I don't see how linking to a completely irrelevant PDF bears any relevance to this.
Your exact words were "alignment is irrelevant in modern (64-bit) CPU's" and what I referenced says otherwise. Also §6.3.2.3/7 says: &gt; A pointer to an object or incomplete type may be converted to a pointer to a different object or incomplete type. If the resulting pointer is not correctly aligned for the pointed-to type, the behavior is undefined.
compiling gcc and installing it yourself is NOT the right thing to do 90% of the time. it is not even good to do that on a regular linux system much less a cygwin system you should probably just use your "lab computers" to do your assignments, or just get a virtual machine with that version, or if you insist on cygwin, cygwin does have alternative versions sometimes. 
I always do my assignments on those lab computers, but my account specifically has gcc 5.4.0 tied to it (I don't get why), and when I ran module load gcc/4.8.2 instead (as suggested by the grader), it still doesn't work, so I just ran out of options... I'll probably try to find a vm with the version.
Yes. However you linked to a pdf from IBM. Which is irrelevant.
&gt; Explaining them all to you would take far too long. If you think it's so easy, I suggest you write your own data recovery software that's better than anything else on the market. You'll be rich. I'll just be over here laughing at you. This behavior is inappropriate. &gt; There is no performance hit or any other kind of penalty. It's amazing how many misinformed people there are on this topic. As another commenter below pointed out, unaligned accesses in C are undefined behavior. That's bad for a number of reasons, including but not limited to: * nondeterministic behavior * inconsistent behavior across systems * potentially exploitable states for attackers
Here it is: &gt; A pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned [...] for the referenced type, the behavior is undefined. From the C11 standard, 6.3.2.3 p7. Asking people for sources is fine, but aggressively accusing them of making things up doesn't make any sense. In your function you cast a char* to a pointer to another size, which means you have a potentially misaligned read.
Why don't you quote the footnotes from that very same excerpt you're selectively quoting? &gt;EXP36-C-EX1: Some hardware architectures have relaxed requirements with regard to pointer alignment. Using a pointer that is not properly aligned is correctly handled by the architecture, although there might be a performance penalty. On such an architecture, improper pointer alignment is permitted but remains an efficiency problem. (And in regards to the efficiency issue, as I stated, modern Intel processors do not suffer from that either).
IBM make 64-bit CPUs where alignment is relevant. If you mean only 64-bit *Intel* CPUs you should make that clearer. The title of the article makes it seem like it is applicable to C in general when really it is absolutely implementation-dependent.
That footnote doesn't define the behavior. It is specifically noted as undefined behavior.
For the astute, there is a hidden clue somewhere in the URL of **macosx**filerecovery.com
 Please post the code around the `getline` call. It may be suffering from a similar problem as the `printf`.
No they aren't. I don't think you have a grip on what undefined behavior is. It means it is undefined according to the language; determining how it behaves depends on knowledge of the system and hardware running the code. Undefined behavior "works" all the time; that's the problem. If it never worked it wouldn't be a problem because no one would ship it.
yep. sorry to sound harsh that way but it's just true. the place that I worked at had dinosaur servers with multiple versions of GCC installed, but this has the consequence of making different binaries having different standard libraries so your LD_LIBRARY_PATH has to be precisely configured for every program you ran or you get this error http://stackoverflow.com/questions/1952146/glibcxx-3-4-9-not-found/23228289 so, just strongly recommending that you not do this in "production"
They are. Intel specifically says that memory reads need not be aligned, and they went so far as to remove any performance penalty from unaligned reads, in order to support them. They are fully supported, and in this case they are faster.
Yes this is part of a larger homework assignment. The professor provided "skeleton code" which I am trying to work with. The contents of the .csv file are just views/duration/user/titles extracted from the index page from youtube using a BASH script(Each line being a different video). I am then using C to read in the .csv line by line, splitting the data, storing it in a linked list, and then printing the linked list. 1. Its a pointer to a char array? 2. Its expecting a character pointer? 3. 5 I still don't get what I am doing wrong. Its late though maybe what you said will make more sense in the morning. 
I dont think I understand what you are asking? struct clip *build_a_lst(char *fn) { FILE *fp; struct clip *hp; char *fields[4]; int cnt=0; hp=NULL; char *line = NULL; size_t len = 0; ssize_t read; fp = fopen(fn,"r"); while ((read = getline(&amp;line, &amp;len, fp)) != -1) { //split_line(*fields,&amp;line); } free(bine); fclose(fp); // open fn - done // while no more lines - done // read a line // split the line into four substrings/int and store them in a struct // append - add the struct at the end of the list // return the head pointer holding the list return hp; } 
You are capable of seeing that that does not logically follow and are choosing to say it anyway because you are afraid of admitting you are wrong. It's really not that bad after you do it. You may even feel some relief.
[Nope. Unaligned reads are supported by Intel.](http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/)
I did, I used Intel's version of `memcmp()`, I called your loop first and the native one second, oh and I compiled with `-fast`, icc version 17.0.2.174, and extern'd the string so the compiler just doesn't remove the loop altogether: $ ./a.out Modified memcmp: 66.692504 Native memcmp: 30.322648 That's a slowdown by more than 2. Edit: Interestingly, it depends on who's first, here's the result in the original order: $ ./a.out Native memcmp: 33.904786 Modified memcmp: 57.479598 
You can go ahead and work on a better benchmarking system if that interests you. But as I already said, the speedup works in the production code in a production environment and that's what really matters. The benchmarking is not real benchmarking and is just there for illustration of the idea.
And yet you got loads of upvotes. This whole thread seems really weird like that.
Yeah, I am also surprised that it took that long for someone to see my mistake. I was probably confusing things with `strcmp`.
`sizeof(unsigned long)` is 8 bytes on 64-bit macOS though.
Yes, I did get you mixed up with someone else, hroptatyr and hegbork look similar in small font, and you're replying to a comment that says this (that it's awful): &gt;Code is badly written, badly compiled and badly benchmarked. Oh, and the function he implements isn't actually memcmp because it has the wrong return value on at least some architectures (or all of them, I haven't bothered figuring it out). 
Well I'm sorry, I was referring to your post where you suggest to try the benchmark with 10bn iterations. I really should have started a new thread. Sorry. 
Try like this -- look closely for the difference: void split_line(char *line) { printf("%s\n", line); } Here is another issue -- no space is allocated for this pointer -- it is not capable of holding any characters/data in this state: char *line = NULL; There is a problem here too ... identification of the problem (and fix) is left as an exercise for you: while ((read = getline(&amp;line, &amp;len, fp)) != -1) { There are more problems in the code, best if you find and work them out for best learning. 
Not gonna do your homework dude, you need to do it yourself to learn from it. I will [POINT](http://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm) you to a tutorial with examples. (Pun intended).
Hello I am not sure to understand what you are trying to achieve. Could you explain what is a "corewar" for instance and what it is supposed to do precisely 
its an interesting [game](https://en.wikipedia.org/wiki/Core_War) 
Floating point numbers use a form of scientific notation to store values. Assuming a `float` is 32 bits on your system, like it usually is, it can only accurately store about 7 decimal digits. The number 2^28 is 29 is 9 decimal digits, and 2^31 is 10 decimal digits. So, a `float` will not be big enough to store the number accurately. (It can actually store 2^x exactly for x between -126 and +127, but the closest it can get to storing 0.01 is 0.010000114, and that rounding error will add up.) If you have to use floating-point numbers, use a `double`. A 64-bit `double` can accurately hold about 15 decimal digits. Even then, there might be a rounding error because 0.01 cannot be represented exactly as a binary fraction. Ideally, floating-point numbers should never be used to hold money values because of the rounding error. Ideally, you'd use an integer type to store a number of pennies, and just add the decimal point when you print it out. A 32-bit signed integer (which `int` usually is and `int32_t` always is) can store a number up to 2,147,483,647. A 64-bit signed integer (sometimes `long`, almost always `long long`, and always `int64_t`) can hold a number up to 9,223,372,036,854,775,807, which should be sufficient for almost any monetary application.
Please put four blanks in front of every line of code so your code appears readable. Right now, it's a garbled mess. You can click “edit” to edit your post and do that. Alternatively, upload your code to a paste service of choice and link it.
I have thought about using a long long variable, but how do I express each output as dollars and cents (with two decimal places)? I've tried before and it always comes back as a whole number.
The Decred Project, an open source blockchain project, is accepting submissions for wallet integration tasks. If selected, the Decred Project will contact you at the provided email by Friday 3/22/17. To apply, complete and submit this brief google form: https://docs.google.com/forms/d/e/1FAIpQLScUTa8pUCZPfbUADBrcecuM1zASVO39EYPrfOvHd3DxyM0xtg/viewform?usp=sf_link
did four everywhere except between the #define and #include 's did a lot before the code and it is not showing it. I'm going to add the link to a paste service as well
 long pennies = 123; long dollars = pennies / 100; // dollars == 1 long change = pennies % 100; // change == 23
not sure I understand what you mean but I added a paste service like you said so hopefully that will just be a better alternative haha. Sorry I'm not a very big reddit user usually and this is my first coding class. 
Yeah, that would be good. You could also remove all the extraneous newlines for readability.
The standards only specify minimum precision/exponent values (5.2.4.2.2 in C11; 6/10/10 decimal digits for `float`/`double`/`long double`, exponents in [−37, 37] for all), just like they only specify minimum integer ranges. Actual sizes and representations involved vary per-ABI, even post-IEEE-754 and sometimes within the same hardware architecture or family; e.g., 64-bit numbers may use a pair of 32-bit numbers, or everything could be done with the Intel 80-bit or Motorola 96-bit forms, or even via distinct, semi-independent integer fields and software tricks. And the accuracies of operators and such are largely independent of the floating-point formats used for data storage, so even if `float` is 64-bit you may only be able to compute a subset of the possible values within C.
NP, the C standards is crazy shit. I would dearly love it if there were some “Un-Embedded Modern C” standard that did tie down the types and representations and un(defined|specified) behaviors somewhat.
Use sqlite. Sorting strings with a linked list is a bad idea, you'd want a [hash table](https://en.m.wikipedia.org/wiki/Hash_table) or some sort of [trie](https://en.m.wikipedia.org/wiki/Trie). Sqlite has also the benefit of being a database so here's your file, and it supports unicode.
Non-Mobile link: https://en.wikipedia.org/wiki/Hash_table *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^46923
thanks for the answer, I will definitely look into sqlite but for the moment I would rather just use the built in functions/libraries to be more familiar with C. I forgot to mention the strings were saved in structs. do you know of any other way I would be able to solve the problem?
Okay, now you've done it. Now I really am over here laughing at you. Thank you for the morning chortle
Merge sort is the usual way to sort an existing linked list, if you must use one - this is for a class assignment, right? You can also build the list in sorted order by inserting a new item in the appropriate place so the list remains sorted after adding it. 
You can certainly do something similar, but I'm not sure the two examples you cited will work properly. You could try something like this (using the [ternary operator](https://en.wikipedia.org/wiki/%3F:#C)): #define PINB (PINA == HIGH ? LOW : HIGH) 
Why would that be any faster? A brief search shows me that the Rabbit 2000 is an obsolete 8-bit MCU, which is presumably communicating with your PC over a serial link. This is likely the bottleneck, and there is no simple way around it. I'd also be very impressed if that compiler supported multithreading in any meaningful way.
Thank you for realizing me to do it my self. I know I'm too stressed about it. lol
What's the problem?
Darn, you're right in assuming the bottleneck is the serial connection. I thought that if I didn't try to write to a GUI and instead just a random file, in this scenario just a text file, I could save the output somewhere and not wait a millennia. I'll keep researching but your comment is a grim reassurance. 
You can have the define do whatever you want, but if your intention is for PINB to always be ~PINA in operation, that won't work. You still have to invoke some code to change the state.
Using openssl libcrypto: http://stackoverflow.com/questions/2262386/generate-sha256-with-openssl-and-c for detailed discussion. [SHA256()](http://man.openbsd.org/SHA256.3) for the quick way.
It doesn't do any good to say "I found something, but I tried it and it didn't work." You need to tell us: - the exact code you tried using - the exact commands used to compile and link - a complete description of what exactly "it didn't work" means, i.e. complete error messages, incorrect output, whatever If you don't tell us those things then we can't tell you what you did wrong. 
Another way to look at #define's is that they're essentially fancy copy-paste operators. If you can write a line of code, it should be possible to turn it into a macro. (Note it's not necessarily a good idea, for readability's sake, but you can do it). It is also possible to pass arguments into macros. Something like: #define PSEUDO_FUNC(foo) my_func(foo,0) That'll call my_func() with parameters foo and 0. Something similar may be useful to you here.
A \#define is really very simple: it defines a textual replacement. So if you do something like #define A B then anywhere that an A occurs as a separate token, it gets replaced by B. "Separate token" means that an A doesn't get replaced when it occurs as a character inside a longer string (as in ABC) or when it occurs inside a quoted string (as in "A string"). It has to be a standalone A surrounded by white space. So, your first example would cause every occurrence of the string "If" in your code to be replaced with "(PINA == HIGH){ PINB == LOW}" which is probably not what you want. Your second example would cause every occurrence of the string "PINB" to be replaced with "~PINA". I can imagine cases where that might be useful, but it doesn't do what I think you think it does. Anyway. \#define replaces one string with another, and that's all it does.
A naive and inefficient way could be this: First define your struct with whatever info you want and not the string itself but a pointer to it. When you add a string use malloc to allocate your new struct, then usr malloc for the string and copy it. Then you just iterate your list and compare strings with strcmp or strcoll or their wide string equivalent, and insert your new struct where appropriate. To save, the simplest way is to save the structs in one file, the strings in another because a linked list is sequential, you just write in list order. Same process to load, you just read one struct and the associated string then the next and so on.
That's the way I'd do it most likely.
RedHat hires from what I know. C programmers are a niche.
WolfSSL and associated crypt libraries are useful and I think well respected. It has good documentation. https://github.com/wolfSSL App docs here - https://www.wolfssl.com/wolfSSL/Docs-wolfssl-manual-18-wolfcrypt-api-reference.html 
That really is not a solution, is it? That appears to be a bug.
Ok, but that doesn't really have anything to do with macros. Don't create a macro to do what you just told me, just write the normal code to do it. If that code turns out to be a bit repetitive code, you might turn it into a macro, or a function. 
Thanks, i did just wrote wrong brace in here. weird, it did work.. even tho i tried million times xD
its strange, but i kind of like the old style foreach loop. Everything is laid out for you in all its glorious mess. Also, I hate auto because it gives me no warm fuzziness as what the type really is, it should have been renamed to 'maybe' for all I care.
It just isnt compiling. I dont have a compiler on my computer and the library is closed for spring break so i couldnt tell you the exact errors
Well, its not going away, because you have to use it if you want to do something that requires iterator/offset access. I just hate dealing with the iterator syntax, especially with nested containers..it just gets super annoying to write down the type without auto. At least in Visual Studio you can mouseover the auto keyword or the variable and it will tell you the deducted type. Maybe they should add an interface option to automagically show the deducted type (in a different color to show it's an auto type) and/or give you the option to replace auto with the deducted type in the source code. It's seems like an issue with the interface and hidden information, not necessarily with the auto keyword itself.
Thank you!
Your question got caught in our spam filter. I apologize for the inconvenience.
Use any code/text editor, and `clang` as the compiler (IIRC it's bundled with xcode), you can invoke it from the command line.
Sorry I'm new to this sub.
Since they didn't offer alternatives, you can enter code using four leading spaces for a whole line or enclosing backticks (the backwards apostrophe on your tilde key) for a few words of code in a line. Kind of like this Or `you can do` this Also, using a pastebin service can be nice, just `cat` the file and pipe it into your pastebin command.
Remember that a for loop heading requires two semicolons. You don't have to have anything in the first part, but it still requires that a semicolon be present. for(initialization;test;increment) is an easy way to remember it when you're starting out. for (horizontal = 0; horizontal &lt; 2; horizontal++) for (vertical = 0; vertical &lt; 3; vertical++)
For one thing, `else;` is the same as `else {}`. (note the semicolon after `else`). You should probably just omit the `else` altogether, considering the `if` block has a `return` statement. Secondly, this is a pretty messy function. You could write it much more simply: void insert_last(int x) { struct node *new_node = malloc(sizeof(struct node)); new_node-&gt;data = x; new_node-&gt;next = NULL; // since it will be the last element, it will always be NULL if (head == NULL) { head = new_node; return; } struct node* p = head; while (p-&gt;next != NULL) p = p-&gt;next; p-&gt;next = new_node; }
Here is a shorter version. It might be a little more complicated, and I"m not sure if it's more efficient (you trade a branch at the beginning for an extra layer of indirection), but it's interesting: void insert_last(int x) { struct node *new_node = malloc(sizeof(struct node)); new_node-&gt;data = x; new_node-&gt;next = NULL; // since it will be the last element, it will always be NULL struct node **last_node = &amp;head; while ((*last_node) != NULL) last_node = &amp;((*last_node)-&gt;next); *last_node = new_node; } 
For reference, the second one is certainly more efficient. The optimizer doesn't end up needing to do any extra indirection, so it just removes a branch. Here's the [assembly](https://godbolt.org/g/m4aEwu) from each version (to simplify the output, I removed the `malloc` calls). The loop is the same in both cases
No such thing as stupid questions :)
Seems pretty straight forward. Simply add 7 to the day, and if it is over the days in that month then subtract the days in the month from it (say 7 to 28, and there are 31 days, 28+7=35, 35-31=4). then add 1 to the month. If the month is more than 12, than change it to the first month, and add 1 to the year. So Dec 30, 2016 will become 30+7=37,37-31=6 the 6th of (12 + 1 = 13, so change to 1) January, (2016+1=2017) 2017. The hardest part of this is determining the number of days in the month, for which there are algorithms online for.
That being said, if you have a more specific issue rather than "how do you do this" I would be more willing to spoon feed.
You don't want to call `srand()` in the custom function. If your processor is fast enough, it will be seeding `rand()` with the same time each time the function is called. Try putting that statement at the beginning of `int main()`.
Yea I notice that too, but since my professor asked for it to be that way, I have been breaking my head trying to make it work, I have keep reading the instructions to make sure I didn't interpret it wrong, his instructions are: "• define a function called get_value() that when called will return a random number. • call this function in every iteration of the loop and assign its return value to the appropriate value of the cell (he is talking about saving those random number on a array in the main function)." But thanks for the help man. Edit: I have it working by using pointers and an array, I guess I am just going to do it my way, bcz I don't really know what he really wants.
No, that wouldn't work. Even if you had the argument right, gets() is the only function that has been removed from the standard because of how bad it is. **Never** use it. Use fgets() instead. I'm not really clear on what you're trying to do... If you're trying to read a line no matter how long, you'll need malloc to start with...
IF I was to do this, I would turn the date time into a unix timestamp, then subtract/add the number of seconds (i.e seconds in 1 day, or 7 days) from it, then turn it back into a date. That gets you out of any calendar processing as its a pain in the....
Before each fgets, allocate a buffer and add it into an array of pointers. Or, allocate a big buffer, copy the pointer into tmp, pass it to fgets, increment it by the length of the line, decrement the count you pass to fgets, repeat.
It depends on how you take in the input. If you have the inputs read in (directed in) from an input file, you can easily keep the same single print looping logic, and still get the output that you want/need. For instance, suppose you want to read in a bunch of words and convert each word to upper case, you could do it so: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; const int MAX = 100; void str_upper(char *s) { int len = strlen(s); for (int i = 0; i &lt; len; i++) s[i] = toupper(s[i]); } int main() { char input[MAX]; while (scanf("%s", input) == 1) { str_upper(input); printf("%s\n", input); } return 0; } Usual program, read in one word at a time, and convert it to upper case and print it immediately. However, if you redirect the input to the program from a file like so: $ gcc -Wall -std=c99 -o input_demo input_demo.c $ ./input_demo &lt; input_demo.in HELLO WORLD HOW DO YOU DO? Then you get the output, one per line, without getting interleaved with the input. For reference, the contents of `input_demo.in` are: hello WORLD how do you DO? 
[revised form](http://pastebin.com/8iiD85xD) I tried doing that but it gave me the same amounts, always a little bit over the real answer.
In fact, the language is already (mostly) working, check it out, it compiles on Linux and OSX. I'm just getting trouble with this bit. I knew about the capacity variable, and mustsay that I'd rather use something which would double its size when exceeding capacity, as otherwise it makes to many calls to realloc.Thanks anyway for your reaction.
Neat! In fact, this code does double its size every time it requires a realloc. The line array-&gt;capacity = (array-&gt;capacity ? array-&gt;capacity : 4) * 2; updates the capacity variable to twice its current capacity, or a capacity of 8 if the array was previously empty.
Fine. Maybe looking at [this](https://github.com/fennecdjay/Gwion/blob/dev/core/map.c) would suffice, as `Vector` structure is opaque(I mean defined in the object file, not the header). Maybe you'll see what I missed just glancing at it. Thank you **so mush** for taking care. 
I'm a moderator of this subreddit. Thank you for your concerns. &gt; Remove minimal effort "open ended" homework questions, e.g. "I have errors, here is the code, please help" where the poster doesn't show what they have tried so far. &gt; &gt; Remove posts where people dump unformatted code into the question or comments. Longer snippets should be posted to e.g. pastebin. &gt; &gt; Remove posts where the user hasn't compiled the code with warnings and it would have told him exactly what the problem was. I have as a personal rule decided not to remove questions just because they do not meet quality standards. Unexperienced programmers, and especially absolute beginners have not yet learned how to ask a proper question. I believe that rejecting people's questions because of insufficient formatting or unclear language doesn't help those people. Rather, that would serve as an excellent way to get rid of most beginner questions in general. I have analyzed whether we want beginner's questions or not by posting a survey about one year ago. The result showed that about 80% of the survey takers are interested in questions, so I see anything that effectively removes most questions as being against the wishes of this community. So what can we do instead? I have so far taken an approach were I explain newbies how to format their code and how to ask a good question. I have even put this into the [submission hints](https://www.reddit.com/r/C_Programming/submit?selftext=true) but apparently, barely any newbie reads that. Perhaps it may also be the case that this guide is too difficult to understand. I invite you (or anybody else for that matter) to write a better guide for asking questions, especially one that picks up newbies right where they are without confusing them. However, I am not going to remove posts just because they are of low quality. Use your vote buttons for this purpose. &gt; Remove and ban users who posts horrible blogspam and youtube videos in the style of this. I try to be as unbiased as possible when it comes to (shitty) tutorials. I do already remove obvious blogspam according to the following criteria: Tutorials are removed if they a) are factually incorrect or generally of low quality **and** b) show an intrusive amount of advertisements. The video you linked is merely of low quality but neither misleading nor have I seen any advertisements. I see this as insufficient reason to remove a post. I act this way because I believe in being objective. I only remove posts because they are clearly off topic, rule violations, spam, illegal, harmful, or clearly not welcome in this community. When in doubt, I leave the post. My job as a moderator is to enforce the rules (this includes the topic), not to rate content for quality. Being objective is very important for me because I do not want to have a bias against certain nationalities. For example, all blog spam on this subreddit I can think off has been written by Indians. It is very important for me not to introduce a bias against Indians into my moderation as I do not want to exclude people's context based on superficial attributes of their content (such as, their nationality). That would be a bad thing.
Just going to say that given the volume of traffic in this sub I think this is a good policy that comes from a place of genuine concern and I support your decision.
9front, better.
Thank you for the informative post and genuine effort into moderation. IMHO removing posts isn't that harsh of a policy – adding a message in the style of "Thank you for your post; unfortunately you are breaking rule X about Y, please fix it and resubmit!" is used successfully on several subreddits, and would help tremendously while being not too high of a barrier. Your posts are good, but unfortunately people seem to be somewhat indifferent to act on simple politeness when it doesn't affect them. I think it is possible to be a little stricter while maintaining impartiality, as long as every decision is based on a clear and objective rule. 
I really appreciate how you (and I assume the rest of the mod team) run this sub. It's very encouraging that you put this much effort into your thinking as a mod, and it makes me appreciate this sub even more. Thank you.
It's my pleasure.
Your comment has been closed as a duplicate of a similar but actually not applicable one from 5 years ago.
`#define PINB ~PINA` would work, provided you never intend to write/assign directly to PINB, only read from it, and you expect it to always be equal to the bitwise negation of PINA. Basically, by defining this macro you're telling the compiler "Whenever I say PINB, I really mean the bitwise negation of whatever value PINA represents."
Now i understand Thanks. But i have follow up question, What would happen if a file stays open (consider the program never crash and say i open more files as the program run)? 
We already have a search function which yields good results but people seem to prefer not to do their own research. But you do have a point and I have enabled our wiki for editing.
Well I can't access it still.
Generally, writing shitty blog spam tutorials is a bizarre India thing.
Assuming that's the exact code that produced that output, it would at first seem impossible. The loop clearly has equal numbers of "It is %s" and "It is @ %d\n", so why are you seeing more of one than the other. The only way I can think of this happening is if the second "It is %s" is being hidden. I have an idea. It may be way off base, but what would happen if your file had carriage returns in it? So one string would be: It is 00000000 followed by It is @ 0 and the next is It is \rIt is @ 1 On the screen, the first "It is " wouldn't be seen because the cursor would go back to the beginning of the line and overwrite it with "It is @ 1". Not knowing your data file or exactly what the output is, this is my best guess. Why aren't you printf'ing "It is %s\n"? Actually, I would probably do "It is '%s'\n". If you do that, and see lines that look like: 't is ' then you know you're printing out a single carriage return. Or, you can do: runDis HW3.dat | cat -v and it will show you carriage returns in the output.
Do you know how long the input is? If you have an upper bound on the file length, then you can just create a buffer (either with malloc or on the stack) read the whole thing (with read() or fread()), and do it that way. If you don't know, and the file could be huge, then you'd probably want to use some kind of linked list.
You already know the first factor from the first loop (where you do stop = 0). So just print that out by itself, divide by it, and continue on. That can even save a bit of time if you try to factor numbers like 39203
&gt; Heavy moderation is bad Amen! Heavy moderation *sucks ass*, in fact. I'm not making this up: ------------------------------------------------------------- Rules for posting to /r/namewitheld This sub is about helping people in need - If you are not providing such help (i.e. abuse, jokes, meta arguments, fighting with other posters, pointless tangents), your comments may be removed. Please report comments that you feel are in violation of these guidelines to keep discussions constructive. At any time mods may remove or refer posts to other subs as we deem appropriate, and our decisions are final. Please read the Wiki before posting or commenting. Ages, genders and relationship length required! Spelling, grammar, and readability count! Include a TL;DR! - a brief summary at the end of your post. No "See title".** First person posts only. No gift or activity questions. No general/meta questions. No polling questions or "opinion gathering" No questions directed at a single gender. No photos, links, or videos Please don't feed the trolls or request proof. Use the report button instead! Do not repost removed material Posts that are removed by the AutoModerator that are missing information submitted for approval will not be considered unless you use the link explaining what was wrong with the post. The only exceptions are posts that were removed by actual humans for missing information. Do not request personal info, including pics. No agendas Crossposting to other subreddits will result in an instaban. No politics! Do not encourage violence or criminal behavior, even as a joke. Do not mention upvotes or downvotes. We do not allow vote manipulation. Be respectful at all times. It's nice if you tell people that are giving you advice, "thank you." Creative writing projects and trolls are not welcome. Most importantly, abuse, bigotry, misogyny, misandry, racism, homophobia, gendered slurs, agendas and encouraging violence are not tolerated in our community and will result in a ban. Don't be rude. Assign proper flair Relationships -issues in ongoing romantic relationships Infidelity -issues of actual cheating ON YOU that you have evidence for Breakups -immediate issues surrounding a break up. Dating -new people in your life, crushes, unclear relationships, or things shorter than 1 month Updates -"UPDATE" needs to be in the title. Link to the previous post, which cannot be deleted or removed. Original post cannot be on the front page or within 48 hours. The update needs to be about the solution. One update only. Personal issues -internal problems and behaviors that cause you problems in relationships Non-Romantic -issues with family or friends. 
&gt; Not knowing your data file ... bada bing. The data file seems to be an **important** but missing element He's only reading 9 chars, and treating the return of strok as if the buffer *guaranteed* to have a '\n' --- but does it? (need to see that data file) : item = strtok(hold,"\n"); printf("It is %s",item); --- see? no check for pointer "item" being a NULL pointer -- just hands it over to printf(). I could see this alone bringing a segmentation fault on a picky system. strtok() returns...: If a token is found, a pointer to the beginning of the token. Otherwise, a null pointer. &lt;--------------- !!!! 
thanks you for the response. it's seemed to be a issue with the fput() giving me a weird return error when it hit new lines. I found replacing fputs() with fscanf() fixed everything 
That's not what `strtol()` is for. It takes a *string*, i.e. a series of ASCII digits. You have four raw bytes. And they are not "hex", they are just bytes, i.e. integers. Integers don't have a base. Hexadecimal is a way of representing integers in base 16. But an integer exists regardless of what representation you use. If you want to convert those four bytes from big endian into the native representation, you want something like this: uint32_t foo = ((unsigned char)hex[0] &lt;&lt; 24) | ((unsigned char)hex[1] &lt;&lt; 16) | ((unsigned char)hex[2] &lt;&lt; 8) | ((unsigned char)hex[3]); Note that you should really be using unsigned char for representing bytes; you can avoid the tedious casts.
thanks you very much! 
thanks you very much! 
Actually a pointer can require more memory resources than an int. For example on x86_64 integers are 32 bits and pointers are 64 bits.
I think the level of moderation here is fine. I usually don't downvote low effort posts. But I don't help them fix their problems either.
Less memory is faster to process. Wasting memory for no reason is never a good idea.
The main advantage of using a pointer is for a structure which is more than 4/8 bytes. In C, if you pass a structure to a function, the entire structure is copied onto the stack. If you pass a pointer, then only one instance of the structure exists and you are passing a potentially much smaller address around instead.
Interesting read so far but the formatting is really bad on chrome on Android. Thought I'd let you know in case you want to fix it.
So, in the C programming language, there are four *storage durations.* The storage duration of an object describes how that object is allocated and released. These are the four storage durations: * An object in *static storage* is allocated when the program begins and deallocated when the program terminates. To declare a variable to be in static storage, use the `static` storage class specifier. Global variables are in static storage unless otherwise specified. String literals are also in static storage. * An object in *thread storage* is allocated whenever a thread is created and deallocated whenever that thread terminates. When you refer to a variable in thread storage, you refer to your thread's copy of that variable. You can declare a variable to be in thread storage using the `_Thread_local` key word. You probably won't need this unless you write multi-threaded programs. * An object in *automatic storage* is allocated each time you enter the block it is declared in. When you leave the block, the variable is automatically deallocated. If you enter a block multiple times recursively, there is one copy of the variable for each time you entered the block. You can declare a variable to be in automatic storage by declaring it inside a function without any storage class specifier. You can also use the `auto` or `register` storage class specifiers to clarify your intent. Global variables can never be in automatic storage. * An object in *allocated storage* is allocated when you successfully call `malloc()`. It is released when you call `free()`. You cannot declare a variable to be in allocated storage, you can only refer to such objects by pointing to them. I hope this clarifies your questions.
=D I think we found ourselves a winner!!! If no one has told you this yet today then let me be the first; you are a wonderful person. This should be exactly what I need.
If I understand you correctly, then because these raw bytes can be integers, I should be able to atoi() right? edit No i cant just atoi(). OK so for some reason if I shift the values to deal with the endian problem I get a number other than what I know its supposed to be. 1006632960. So what I did was use my loop to fix the endian and I got what I wanted. Then used the code you provided to concatenate(? I know I am just OR'ing the values) the values to get 60. 
No problem. I forgot to mention that global variable, while sometimes useful, are generally considered to be a bad practice. What are you trying to do? Maybe there is a better way to do it.
No, both strtoi and atoi take ascii strings and turn them into ints. char str[] = "42"; is the equivalent of char str[] = {0x34, 0x32}; And `int i = strtoul(str, NULL, 16);` will give you `i = 42` What you have is already an int just split into four different bytes, you can store them as uint32 the way /u/Rhomboid posted. edit: typo
What you're doing is shifting the bytes to the right position, you can change the order in the loop or at the point of shifting, apart from readability that doesn't really matter. Say you have `0x1f 0x00 0x20 0x10` as seperate bytes, you're basically turning them into `0x1f002010` as uint32, because `0xf1 &lt;&lt; 24 == 0x1f000000`. Then you OR `0x1f000000` with `0x00002000` to make `0x1f002000` and so on. 
http://stackoverflow.com/questions/33622787/are-pointers-considered-a-method-of-calling-by-reference-in-c Crystal clear. 
I think some of the beginner posts are ok, but I think they appear more frequently than I'd like. I wish there were more advanced threads 
Generally, you want your main function to be small; it should be just the main loop that calls functions to do all of the work. Your main function should probably look something like this: int main(void) { /* declare variables */ do { reset_horses(your_variables) run_race(your_variable) wager = get_wager() bet = get_bet() switch(bet) { /* bet choices */ } new_game = play_again() } while(new_game != quit) } I think what is tripping you up is passing arrays. In C, you pass an array like this: int array_function (int array[], int number_of_items); 
I know the main is suppose to be small but I wrote this up for my own ease because functions overall kinda trip me up haha. So should I avoid using Global variables in this case? as I was saying I planned on rewriting this as functions in the footer and to do a do while to have the game play through. This is where I get confused so I have a variable called "chip_count" and I'm using it in a function called "bet" and another "wager". In my mind when I write the function for bet and use the variable chip_count it's only going to check that particular function's chip_count. E.g. bet uses bet's chip_count and wager uses wager's chip_count or am I just completely nuts here? In your example where you have /* Declare variables */ can I do just that and declare them there and if they're the same variables in my function(s) will it pass along the appropriate information accordingly?
C being a low level language leaves a lot of things up to the programmer to keep track of. One of these things is the size of arrays passed to functions. You pass arrays as follows: #include &lt;stdio.h&gt; #define SIZE 6 void print_array(int array[], int nmemb); void print_array_ptr(int *array, int nmemb); int main(void) { int n[SIZE] = { 1, 2, 3, 4, 5, 6}; print_array(n, SIZE); print_array_ptr(n, SIZE); } void print_array(int array[], int nmemb) { printf("print_array\n"); for(int i = 0; i &lt; nmemb; i++) { printf("array[%d] = %d\n", i, array[i]); } printf("\n"); } void print_array_ptr(int *array, int nmemb) { printf("print_array_ptr\n"); for(int i = 0; i &lt; nmemb; i++) { printf("array[%d] = %d\n", i, *(array + i)); } }
sorry for audio and readabilty. I have already expalined about getch() function in previous lecture.
If this was the 17th century I would accuse you of being a witch, that literally destroyed my noggin! Can you elaborate on the type void? does it have to deal with passing by type vs reference ... and then can you explain to me what I just said... My professor is horrible with returning e-mails. Edit: Okay so its pass by value not what I said or are those things as well? Edit-2: Sorry, you said not to use Global variables but how would I then up date a variable in main after one of my functions adjusts it so that a later function can use the up-dated value?
Please always make sure you are compiling C not C++ when writing C tutorials.
A function is a block of code that can be called to perform some task. A function can receive zero or more parameters (also called arguments) and it can optionally return _one_ value (called the return value). /* * a function that takes no parameters and returns nothing */ void say_hello(void) { printf("Hello\n"); } /* * a function that takes a parameter and returns nothing */ void say_my_name(char *name) { printf("hello %s\n", name); } /* * a function that takes two parameters and returns a value */ int sum(int a, int b) { return a + b; } /* * a function that take no parameters and returns a value */ int meaning_of_universe(void) { return 42; } In the context of declaring functions, a void return type means that the function does not return a value, and a void parameter means that the function takes no parameters. Pass by value means that you are passing a _copy_ of the variable to a function. This means that whatever the function does to that copy of the variable does not change the variable in the calling function. Pass by reference means that you are passing a pointer to the variable to the function. This means that the function _can_ change the value of the variable in the calling function. #include &lt;stdio.h&gt; void pass_by_value(int num); void pass_by_reference(int *num); int main(void) { int n = 10; int *ptr; ptr = &amp;n; // set ptr = to address of n printf("in main\n"); printf("n = %d\n", n); pass_by_value(n); printf("main: n = %d\n", n); pass_by_reference(ptr); printf("main: n = %d\n", n); return 0; } void pass_by_value(int num) { printf("pass by value: num = %d\n", num); num = 1000; printf("pbv: num = %d\n", num); } void pass_by_reference(int *num) { printf("pass by reference: num = %d\n", *num); *num = 500; printf("pass by reference: num = %d\n", *num); } The best way to learn is to write small programs like this. Use printf to see what is going on. 
&gt; everything that the compiler does is predictable and deterministic I'm pretty sure the above thing is predictable and deterministic but I haven't completely learned why yet. &gt; C wasn't designed to do this. &gt;If you want features which deliberately abstract away the computation, you're &gt; probably using the wrong language. Isn't C still used because you can write highly-performant code with it? I thought that was a major reason why all the mainstream kernels and the majority of embedded software is written in C. Although portability (only C compilers for exotic platforms) might be another important one. Also, I'm not yet sure whether to switch to C++. I like C's minimalism and actually like it being explicit sometimes. I've also tried C++ RAII and while it's definitely nice to be sure all resources will be properly free'd and closed when the object goes out of scope, at the same time I didn't like how all constructors and destructors of the object (and the ctors/dtors of objects this object contains for that matter!) are called implicitly. I can definitely imagine how confusing this could be in large software projects. I think it's probably a trade-off. On the other hand, I didn't manage to write a faster linked list than std::vector in C yet (that might be due to inexperience/stupidity). I could use some random libraries but I think a standard library is more field-tested.
Predictable and deterministic is the wrong phrase. It should be entirely obvious how the compiler is going to compile each abstraction. In the case of recursive template metaprogramming (in more complex situations), that is much less clear than any feature that C uses. C is fast, but good C++ code is just as fast (and in some cases it can be faster). The difficulty is actually getting good C++ code. [Here's essentially what Linus has to say about it.](http://harmful.cat-v.org/software/c++/linus) You shouldn't think of C and C++ as doing the same job, because they really don't. They each have their different use cases, along with their different strengths and weaknesses.
&gt; Personally I just find the language more fun to use than C++ Being able to keep a large amount of the language in your head is definitely something nice (C has its complicated corners though as well). But I'll probably keep learning C++ even if I might end up not using it often, just so I can put it on my resume later.
Not much to do with c vs c++ imho, it's just the compiler optimizing what is ultimately a constant. Declare a volatile int and pass it to your function.
Oops nevermind, i'm an idiot. 
Just to nitpick, that's not really recursion though, is it? It's just calling another instance of the template function with a reduced argument which the compiler optimises away. I agree with the other poster who mentioned that C and C++ are completely different beasts.
My mistake. Thank you for fixing it but the point remains. 
Well, for your particular example 1 &lt;&lt; 10 would suffice.
Tells you about the value of ESET, I'd say.
C will "round half to even" : https://en.wikipedia.org/wiki/Rounding#Round_half_to_even This prevents a huge number of calculations from producing a bias in one direction, because the rounding of a ..5 value alternates between up and down. The rounding you're looking for is "round half up." A simple way to implement this is like: double round(double x){ return floor(x + 0.5); } In your case you will have to multiply by 100, round() it, then divide by 1000. (Code not tested, so be careful if you plan to use it!) 
C already has a function named round() btw. It rounds halfway cases away from 0.
The problem here is not "round half to even". C's **round**() function (and I *think* **printf**() too, but I haven't found a reference) rounds as OP expects, that is, last digit 5 rounds up (or, more correctly, away from 0). The problem is that the number being rounded does not actually end with a digit 5, because the number that *does* (13.245) can't be represented as a double.
C++ templates are Turing complete and undecidable. They are the exact opposite of predictable and deterministic. &gt;I didn't manage to write a faster std::vector And you won't. C++ isn't C where the standard library is just enough to get by; the STL is built specifically to be performant by people who dedicate their professional lives to the task. Furthermore, you *can't* write a linked list that's more performant than a vector because a vector is an array and has only one pointer access; it's O(1) access and O(log(n)) growth whereas a linked list is O(n) access and O(n) growth.
`printf("%d\n", 1024);` is pretty fast ;)
It's recursion. The fact that it happens in the compiler rather than in the compiled artifact doesn't change that.
Certain aspects of C++ are useful in embedded or freestanding contexts. Many are not. Kernels can't throw exceptions and real-time services can't use `new`, for instance.
Nope. Recursion as we know it is when we have an actual function whose address doesn't change regardless of the function call. That is not the case here. This is more like generating specialised versions of the function for different number of arguments at compile time, and then invoking them. This is more like loop unrolling. Sure, it can be argued that the process itself is recursive in a mathematical sense, but this is not actual recursion.
Yes, that should be "recursion as happens inside a machine". As for the second part, variadic templates generate different functions with the given number of arguments (reducing from whatever value was initially given) down to the "base case". That's what I'm coming at. In the traditional sense of recursion, the function address does not change (talking about self-recursion, of course) which is not the case here. That's why it can be thought of in a recursive manner, but that's hardly different from one overloaded function calling another with a variable number of arguments. For instance, suppose we wanted to add three numbers, we can do the following, right? #include &lt;iostream&gt; // base case int add(int x) { return x; } int add(int x, int y) { return x + add(y); } int add(int x, int y, int z) { return x + add(y, z); } int main() { std::cout &lt;&lt; add(1, 2, 3) &lt;&lt; "\n"; return 0; } $ g++ -Wall -o add add.cpp $ ./add 6 This produces `6` as the answer. However, this is not recursion though, is it? Suppose we take the variadic version of it: #include &lt;iostream&gt; template&lt;typename T&gt; int add(T t) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n"; return t; } template&lt;typename T, typename... Ts&gt; int add(T first, Ts... rest) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n"; return first + add(rest...); } int main() { std::cout &lt;&lt; add(1, 2, 3) &lt;&lt; "\n"; return 0; } That produces: $ g++ -Wall -std=c++11 -o variadic_add variadic_add.cpp $ ./variadic_add int add(T, Ts...) [T = int, Ts = &lt;int, int&gt;] int add(T, Ts...) [T = int, Ts = &lt;int&gt;] int add(T) [T = int] 6 So, it's clearly just generating the three function calls at compile time, and then calling them to generate the result. This is almost the same as the overloaded functions version. 
IMO function overloads like that are actually an excellent instance of mathematical recursion that also won't run into the problem of hardware-recursion that never terminates. In a non-tail-recursive situation, recursion is just a loop that blows the stack as it's "base case"; in tail recursion, it's a jump rather than a call so it can reuse the current frame -- that's straight up a loop that just happens to look like a function. Calling the "same" function is recursive, even if it goes to a different spot in the executable; in C++ (IIRC) we pay for the function call whether it's to self or another address. In this instance, though, the type system happens to guarantee that the recursion will terminate and unwind, since there are a finite number of hops that can be made. TLDR the overload is mathematical recursion, the classic example of recursion is a bad idea that got glorified by age, and templated recursion is an automated, type-checked, guaranteed-to-not-blow-stack recursion. :(){:|:&amp;};: Is the simplest form of recursion, but its category of uniqueness should be "catastrophic bug", not "recursive"
That's just abusing the definition of recursion as used in programming. We might as well call function calls recursion then - there's nothing special about the name. Well, let's leave it at that since this is clearly going nowhere.
Ordinary calls aren't recursion because they're different tasks. Calling oneself is recursion; reusing the same address is an implementation detail.
Please elaborate on what you mean by "I want to swap the structures between the pointer,". I looked at the example and it addresses this issue of a function swapping two arguments it's passed (arguments that happen to be pointers). Is that really what you need to do? It doesn't strike me as a particularly useful operation.
Your code is written in C++ and is off topic in here. Please ask questions about C++ code elsewhere, e.g. in /r/cpp_questions. It doesn't matter if you use functions that can also be called from C code; C and C++ are separate languages and C++ doesn't belong here. I have removed your post as it is off topic.
I recommend the following approach: * at first, write a dummy header specifying `0xffff` messages. * while writing data to the file, keep a running sum of all bytes you've seen so far. When writing the trailer, you can use this running sum to generate the checksum. * next, write all log entries into the file. Keep track of how many you wrote. * when all log entries have been written, compute the checksum you would get if the right number of messages was specified in the header and write it into the trailer. * lastly, use `fseek()` to move back to the beginning of the file and fix up the number of messages to the actual number of messages.
Ask for a message as a pointer to the message and its length. You cannot validate that.
Packed structures are not standard C, and are almost definitely not how OP is supposed to be handling what is most likely a homework assignment.
You say "a couple" of questions but then you list 4 and suggest there were more than 4... Have you done all the practice questions? If you complete the four that you gave them you're pretty well prepared.
thanks, I'll check it out
Since we were given solutions, I only figured out the last two by looking at the solutions. I'm looking for more problems to see if I can come up with a solution myself and to increase the speed that I complete them. 
Hide the solutions and see if you can solve all of them again from scratch. If so then you'll be prepared.
Since these questions remind me of an entry-level technical interview, you might try something like Programming Interviews Exposed and focus on the areas/data structures you've covered in class. It has problems with solutions/explanations in C.
I'll give it a try, thanks!
Assignment returns the assigned value; you set and then set again immediately following it. The line prior to setting `bitInserted` is unnecessary. I don't see anything else immediately suspect, so I'd guess that clobbering the entire variable rather than just LSB was the issue but I wouldn't guarantee that.
Do you have to make sure that no rook is able to beat another rook? Do you have to change your algorithm if the piece would be a knight instead of a rook? ---- It is good to start with such question by drawing what happens so you better understand the question. Draw a small board with a low number of rows and colums (3 to 5). Look at what happens if you start placing the rooks. Look at what happens when the field is square, look at what happens if the board is loner than wide - how does it change the number of rooks? This is how you are able to solve quite a few problems in programming, start to create a **minimal working example** and **minimal problem set**. Then spend time on it. This looks a bit like a homework problem. If you don't know how to output text "YES/NO" to the screen read up in your script about input/output. If you don't know how to get your program running read up on compiling (and after you done the job about debugging). If you don't know how to branch out depending on conditions look up loops and conditional branches (so basically: *while, for, if, else, case, switch*). I would suggest you to post in /r/learningprogramming, read up about C in /r/c_homework and a tutorial of your choice. cs50 is a edx Harvard course about how to start programming. That might be a good place to learn. *Edit* /u/FUZxxl is correct with his solution, but rather try to work it out on your own. His solution is based on valid syntax that rarely gets used in introduction courses. The ternary operator syntax is: *condition* **?** *if_true* **:** *if_false* So a &gt; b ? result = x : result = y is the same as: if (a &gt; b) { result = x; //if_true } else { result = y; //if_false }
I second K&amp;R. Legendary book with tons of good practice problems, covering all major areas of C. I'm working through it right now actually. You'll have to pick and choose what you want to do since there are so many though.
But then I won't need a container to deal with package management failure.
Some people haven't programmed long enough to learn that there is value in stability. I try not to use tools that are younger than, say, five years to make sure that they are mature and won't change in incompatible ways.
I'm in the same boat as you, but perhaps a little more relaxed. So long as something is well documented and clearly shows "polish" and a dedication to being stable / support current users I am happy using it regardless of age. That being said the above qualities are indicative of well maintained, longer development cycle projects.
Of course, if a project explicitly declares its intent to remain compatible (e.g. by publishing compatibility promises and detailed specifications), it's easier to make the choice to use it.
I know that's where my confusion is, just showing that in case people are confused where. I'll look up fread/fwrite now, I think I'm more concerned in the idea that I wanna be able to just open the file and read the contents as well. As opposed to only just being able to reading/writing from the program itself.
I gotcha. I think that starting with simply reading an already created file (if you have one) would be an easier starting point then writing a new record into the file. I would start with writing two functions something like this: void read_log_info(FILE *fp, int *record_count); void read_record_info(FILE *fp, int *sequence_number, int *aux, int *dst, time_t *timestamp, char *msg); The first function is used to read the 'header' of the log, which gives the number of records. The second function is used to then read a specific record. Internally in these functions, you just call `fread` on `fp` to read a buffer the size of the log-header or record, and then read the bytes from that buffer. Looking at the [picture again](http://imgur.com/a/QIsZY), by looking at the largest offset you can get the size of the log header (Everything before the first record - 4 bytes) and the size of a record (40 bytes). I think the important thing to understand is that if you simply declare a `char buf[40]`, that declares an array of 40 bytes. Meaning to read and write to the file all you really need to do is declare a buffer of the proper size and then either `fread` into the buffer, or `fwrite` the buffer to the file. You can access each byte in `buf` individually since it's just an array (`buf[0], buf[1], buf[2], etc...`), and the offset's listed in your picture will correspond to the array index in `buf` that it will be located at after you do an `fread`. So if you want to read the sequence number from a `buf` that you `fread` from the file, you just have to take `buf[0]` and `buf[1]` and assemble them back into an int (An `int` is multiple bytes long, so when it is stored it takes up multiple offsets in `buf`). When you read the message from `buf`, you can just do a `strcpy` or `memcpy` to copy everything from `buf[9]` to `buf[38]` into a separate `msg` string.
Don't have a created file to test with, this is all from scratch. That's why I'm trying to at least get a small fwrite working so that I can developer a reader to actually see some results so I understand more. Going with your idea however, how would I pass parts that require more array elements (E.g. Timestamp requires 4 elements)? This will carry on to the message part[9-38] as well.
Going with that completed code so far, what would reading it look like? In order to see say the sequence_number and aux/dst flags placed into variables?
I was able to make a small test program to understand fread/write: int x = 25; FILE *fptr = fopen("myfile", "wb+"); fwrite(&amp;x,sizeof(x),1,fptr); fclose(fptr); int y; fptr = fopen("myfile", "rb+"); fread(&amp;y,sizeof(y),1,fptr); printf("%i", y); //displays 25 now My concern is how would this work for multiple files in the records array. Such as your finished function above, would I need to read each piece specifying the size of each value on its own (E.g. timestamp is smaller than the msg). 
Think we need to start smaller, I'm probably jumping the gun trying to read everything at once when I should be trying to get just something passed in/read back to ensure a template is working.
I touched on this and gave more explanation in my other comment, but reading a sequence number will be something like this: seq_num = (buf[0] &lt;&lt; 8) | buf[1]; Reading one of the flags I didn't touch on, but is still pretty simple. `buf[2]` holds the flags in its bits, so it's just a matter of checking if a certain bit is set. There's lots of way to do this, a common one: dst = (buf[2] &amp; (1 &lt;&lt; 6)) != 0; It uses the same concept of the 'masking' in my last post. Basically, we create a value that only has the one bit set that we care about (That is what `(1 &lt;&lt; 6)` is), and then use a bitwise 'and' to use our value to clear all the rest of the bits except for the one we care about (bit 6). Then we do a simple `!= 0` check, which is true (1) in the case bit 6 was a one, and false (0) in the it wasn't. Since all the other bits are set to 0 by the 'and', we don't have to worry about those bits causing a non-zero value - any non-zero value must be caused by bit-6. The AUX flag would be the same, but bit 7 instead of 6.
What is a c string exactly?
Yes. It leaves the string un-terminated, which means that when you print it you're accessing the back half of the array which is uninitialized. In your case that memory contained nulls by luck, but that's not always going to be the case; it could have contained other values, causing `printf()` to walk off the end into whatever memory comes after the buffer. Regardless, it's always UB, since both walking off the end and accessing uninitialized data are UB.
Think I just had an epiphany lol, going to try coding something on my own. I'll send it back for you to validate if I now understand it all. lol
Ok got the data actually moving now, think I'm just confused on the restructuring with bitwise notiation. Since I'm getting random dates now. Storing to log: record[3] |= (timeStamp &gt;&gt; 24) &amp; 0xFF; //high byte record[4] |= (timeStamp &gt;&gt; 16) &amp; 0xFF; record[5] |= (timeStamp &gt;&gt; 8) &amp; 0xFF; record[6] |= timeStamp &amp; 0xFF; //low byte Reading from log: time_t timestamp = (record[3] &lt;&lt; 24) | (record[4] &lt;&lt; 16) | (record[5] &lt;&lt; 8) | record[6]; 
Some people are instant that all problems are to blame on the language.
That looks very good. I would try declaring the buffer as `unsigned char` and check if that helps. I'm wondering the `char` is getting cast up to a `time_t` and the sign then gets extended. Declaring as `unsigned char buf[40]` shouldn't cause any problems with the rest of your code, I should have mentioned it before. Responding to your other messages: &gt; I got it to display the sequence number using the bitwise notation. I understand it more now but feels a bit tedious once we get into more detailed work. Such as coding all the message or time stamp. Not to mention when reading more than 1 message when we dump the log You're right it is a little tedious, but it is the best way to ensure things will continue to work. There are some shortcuts you can take, but conceptually they're a bit harder to understand and they tend to be more compiler and architecture dependent. That said with the text message data you really can just use `strncpy`, so it should be pretty easy. That said, this is also why I recommend extracting this code out into a function that just returns the values. Then you only have to write this byte manipulation code once, and you can just call the functions to do all the heavy lifting for you.
Ya, unsigned char buf did the trick. Displaying the right time now. I'm going to attempt the message part and see if I can do it without a hitch.
The hackernews thread he linked was just ridiculous. The top comment was pointing out how a cornercase issue where _512MB_ username parameter that caused issues would be fixed by Rust.
Ok I almost have this finished except for the checksum stuff. My only issue now is how do I add another record after the first one? Not Only that how do I read multiple freads ensuring each one is [40] in size? I've included all my code now, cleaned up of course to give you an idea of where I am now and to show how much I now understand: //confirm a file exists in the directory bool fileExists(const char* file) { struct stat buf; return (stat(file, &amp;buf) == 0); } int rightBitShift(int val, int space) { return ((val &gt;&gt; space) &amp; 0xFF); } int leftBitShift(int val, int space) { return (val &lt;&lt; space); } int determineRecordCount(char * logName) { unsigned char record[2]; FILE *fp = fopen(logName, "rb"); fread(record, sizeof(record), 1, fp); //display the record number int recordNum = (record[0] &lt;&lt; 8) | record[1]; recordNum = recordNum +1; return (recordNum); } void createRecord(int argc, char **argv) { int recordNum; int aux = 0; int dst; char* logName; char message[30]; memset(message,' ',30); //check argument count and validation if (argc == 7 &amp;&amp; strcmp("-a", argv[2]) ==0 &amp;&amp; strcmp("-f", argv[3]) ==0 &amp;&amp; strcmp("-t", argv[5]) ==0) { //aux flag on aux = 1; logName = argv[4]; strncpy(message, argv[6],strlen(argv[6])); } else if (argc == 6 &amp;&amp; strcmp("-f", argv[2]) ==0 &amp;&amp; strcmp("-t", argv[4]) ==0) { logName = argv[3]; strncpy(message, argv[5],strlen(argv[5])); } else { printf("Invalid Arguments\n"); exit(0); } //check if log exists to get latest recordNum if (fileExists(logName)) { recordNum = determineRecordCount(logName); printf("%i\n",recordNum); } else { printf("Logfile %s not found\n", logName); recordNum = 1; } unsigned char record[40]; /* One record takes up 40 bytes of space */ memset(record, 0, sizeof(record)); //Begin creating record //recordCount--------------------------------------------------------------------- record[0] = rightBitShift (recordNum, 8); /* Upper byte of sequence number */ record[1] = rightBitShift (recordNum, 0); /* Lower byte of sequence number */ //get aux/dst flags--------------------------------------------------------------- //get date and time time_t timeStamp = time(NULL); struct tm *date = localtime( &amp;timeStamp ); if (date-&gt;tm_isdst) dst = 1; record[2] |= aux &lt;&lt; 7; //set 7th bit record[2] |= dst &lt;&lt; 6; //set 6th //timeStamp----------------------------------------------------------------------- record[3] |= rightBitShift(timeStamp, 24);//high byte record[4] |= rightBitShift(timeStamp, 16); record[5] |= rightBitShift(timeStamp, 8); record[6] |= rightBitShift(timeStamp, 0); //low byte //leave bytes 7-8, set to 0 ----------------------------------------- record[7] = 0; record[8] = 0; //store message-------------------------------------------- strncpy(&amp;record[9], message, strlen(message)); //write record to log----------------------------------------------------------------- FILE *fp = fopen(logName, "w+"); unsigned char recordCount[4]; recordCount[0] = rightBitShift (recordNum, 8); /* Upper byte of sequence number */ recordCount[1] = rightBitShift (recordNum, 0); /* Lower byte of sequence number */ recordCount[2] = 0; recordCount[3] = 0; fwrite(recordCount, sizeof(recordCount), 1, fp); fwrite(record, sizeof(record), 1, fp); fclose(fp); printf("Record saved successfully\n"); } void printLog(int argc, char **argv) { if (argc == 4 &amp;&amp; strcmp("-f", argv[2]) ==0) { printf("Opening file: %s \n", argv[3]); } else { printf("Invalid Arguments\n"); exit(0); } //get header data unsigned char recordCount[4]; FILE *fp = fopen(argv[3], "rb"); fread(recordCount, sizeof(recordCount), 1, fp); int numRecords = (recordCount[0] &lt;&lt; 8) | recordCount[1]; printf("Total Records: %i\n",numRecords); //continue reading the file for every record[40] found--------------------------------- unsigned char record[40]; fread(record, sizeof(record), numRecords, fp); //display the record number int recordNum = (record[0] &lt;&lt; 8) | record[1]; printf("Record: %i\n", recordNum); //aux and dst flags int aux = (record[2] &amp; (1 &lt;&lt; 7)) != 0; //10000000 int dst = (record[2] &amp; (1 &lt;&lt; 6)) != 0; //01000000 //determine time stamp of report time_t timeStamp = leftBitShift(record[3], 24) | leftBitShift(record[4], 16) | leftBitShift(record[5], 8) | leftBitShift(record[6], 0); printf("%i%i000000 - %s", aux, dst, asctime( localtime(&amp;timeStamp))); //read the message of the record char message[30]; //retreive report message for(int i= 0; i &lt; 30; i++) { message[i]=record[i+9]; } printf("%s\n",message); fclose(fp); } int main(int argc, char **argv) { if (strcmp("dumplog", argv[1]) ==0) printLog(argc, argv); else if (strcmp("appendlog", argv[1]) ==0) createRecord(argc, argv); else printf("Invalid Argument\n"); return 0; } 
It is all indented in my code, it's just reddit and me trying to get it indented a bit so it appears in a code block rather than just spewed like normal text here. That was my assumption that fseek was needed. I was just unsure of where the offset needed to be placed. I am able to store multiple files it seems however when my reader reads it, only the most recent record has it's content. The older ones are all set to 0, January 1st and no message. //write record to log----------------------------------------------------------------- FILE *fp = fopen(logName, "w+"); unsigned char recordCount[4]; recordCount[0] = rightBitShift (recordNum, 8); /* Upper byte of sequence number */ recordCount[1] = rightBitShift (recordNum, 0); /* Lower byte of sequence number */ recordCount[2] = 0; recordCount[3] = 0; fwrite(recordCount, sizeof(recordCount), 1, fp); fseek(fp, 4+(40*recordNum),SEEK_SET); fwrite(record, sizeof(record), 1, fp); fclose(fp); printf("Record saved successfully\n"); I originally was using unsigned char record[40]; while (fread(record, sizeof(record), 1, fp)) {} until I was getting some bad results, now with the fseek it's at least returning multiple rows, just all empty other than the most recent. 
And would the checksum for the record be something like this? unsigned int checkSum = 0; for(int i = 0; i &lt;39;i++) { checkSum += (unsigned int)record[i]; } record[39] = ~checkSum; printf("%i\n",~checkSum );
Yep that looks perfect. I think it would make more sense to make `checkSum` an `unsigned char`, but it doesn't make a difference in the end.
The returned value is "-202" when I insert my first record. Isn't this wrong as it's not 255?
Are you numbering your records starting at 0, or at 1? I'm guessing that's where the problem is. The `(4 + n * 40)` relies on `n` being 0 based, so that your first record starts at `4`. If your first record is at `n==1`, then your first record appears in the 'second' record spot at `44`. The easy fix is to just subtract one from `n` in your `fseek` call. Also a note: When you seek and start writing to a random location in a file, it'll basically fill the rest of the file till that point with zeros. So when you seek to position `44` (When `n==1`) and write your record, it fills the empty data between 4 and 44 with zeros.
o of course. The 4 I was being thrown off because of the 4 bytes for the file count + space. Didn't take into account the n cuz I was distracted.
I just noticed the issue, it's your `fopen` call actually. The [specifier](http://man7.org/linux/man-pages/man3/fopen.3.html) format is a bit dumb. The "w" specifier always truncates the file, even with "w+". To open for read/write without truncating you actually want "r+"
Cool. I thought about what you said and figured I might as well as fgets and sscanf and maybe a while loop?? I tried it out with a couple of my commands and things seem fine. Thanks for your help!
Alright, got everything all setup and working now. Logs all get returned in proper order and no 0s come at me. Final piece is just the total checksum for the entire file. So for this one should I simply just tally all the [40]s and initial [4] in the reportLog function similar to the record checksum and then inverse it? I looked up fgetc so seems easy enough really.
I'm currently getting Checksum: 0 but I'm probably doing something wrong here: //determine log checksum unsigned char finalChecksum = calculateFileChecksum(fp); printf("Checksum: %hx\n", finalChecksum &amp; 0xFF);
 //read through entire log file to calculate checksum unsigned char calculateFileChecksum(FILE *fp) { unsigned char checkSum = 0; while (!feof(fp)) { checkSum += fgetc(fp); } return (~checkSum); } Did the seek before those 2 lines as well, just didn't add them fseek( fp, 0, SEEK_SET); //determine log checksum unsigned char finalChecksum = calculateFileChecksum(fp); printf("Checksum: %hx\n", finalChecksum &amp; 0xFF);
It's writing the null out of bounds. It only appears to work by sheer chance. You could be corrupting some other variable, or possibly the stored return address, causing a crash when the function returns, or numerous other possibilities. Undefined behavior can manifest in many ways, and one of them is appearing to work fine. (That is, until something subtle changes, like you change the compiler optimization flags, or add another local variable, and then you get a crash out of nowhere.) 
&gt; So my log Checksum is now always returning ff. That doesn't sound quite right. I would expect a varying checksum, especially when you add new records. When you have two different sets of data, you only have a 1/256 chance of having the same checksum between them (Since this checksum is 1 byte long). &gt; When it's the same amount of data for each record It's not the amount of data that determines the checksum, but the data itself. Since each record will have different bytes that make it up, it will end-up with a different checksum. You can picture the record like a big list of numbers. If you pick 39 relatively random numbers and add them all together, you're not going to get the same value every time. But, given those 39 it's easy to come-up with one extra number to make the now 40 numbers add to any number you want (such as `0xFF`), that's what we're doing here.
Ok that, makes a lot of sense then. Unsure of what's causing the constant FF then however.
Well, getting `0xFF` would indicate that you're probably just hitting `EOF` immediately, which leaves `checkSum` at zero and makes `~checkSum` `0xFF` like you're seeing. Is it possible the file isn't open for reading, and only writing?
As of now I took it out of its own function and placed it inside the dumpLog. Still returns FF when I simplify it to the minimum. unsigned char checkSum = 0; int curChar; fseek( fp, 0, SEEK_SET); while((curChar = fgetc(fp)) != EOF) { checkSum += (unsigned char) curChar; } printf("\t\t\t\tLog Checksum: %hx\n", ~checkSum &amp;0xFF);
Whole lot of gibberish data, �ܶ����L�$�o�9l���� ,Ll���� ,Ll�����ܶ�t�L�)��4i��4h���(Hh���(Hh\6&lt;���&amp;��r�I��Ff����&amp;Ff����&amp;Ff��� And ya, got a seek back to start of file, and the open is set to rb. unsigned char checkSum = 0; int curChar; fseek( fp, 0, SEEK_SET); while((curChar = fgetc(fp)) != EOF) { checkSum += (unsigned char)curChar; printf("%c\n", checkSum); } printf("\t\t\t\tLog Checksum: %hx\n", ~checkSum &amp;0xFF);
I'd print it as a `%d` or `%x`, `%c` is going to treat the checksum as an actual character value instead of an integer. That said, you can still tell from that output that the value is clearly changing. `Log Checksum: ` is always `0xFF`?
I wonder if the interaction between the checksums in the records and the checksum at the end of the file is causing the issue. If you think about it, checksumming the records when checksumming the entire file is basically pointless because the 40 bytes of every record are required to sum to `0xFF` - that's the point of adding the checksum at the end of each record. With that in mind though, the record count at the beginning of the log should cause the checksum to be something other then `0xFF` even if that is the case, since it is added too. Is it possible the record count at the top of the file is actually zero? That wouldn't quite explain it, but that could contribute.
I tried ouputting the compliment every loop, it start's at ff of course, but every loop it changes value. Nearing the end tho it goes back to FF then finishes on FF: Log Checksum: 99 Log Checksum: 79 Log Checksum: 59 Log Checksum: 39 Log Checksum: ff Log Checksum: ff 
Or if you target Windows...
Do you know how to submit change requests to the committee?
I'm well aware of bit-shifting. This was just a particularly simple example from a textbook that outlines how template metaprogramming works. I was actually asking about template metaprogramming in general and whether it's possible to achieve this in C (since that would mean C++ definitely *can* be better optimized than C). &gt; Even if that were true, template metaprogramming doesn't really address any of those problems. The above text was just some sort of introduction and background why I even bothered digging into this C++ stuff (and had the additional purpose of asking for an opinion about the use of C++ in classic C domains). You are right, I could have left it out. It's unnecessary.
&gt; The proposal repurposes the register keyword Dear god...
ANSI C is the most portable language on this planet. So that's probably one of the most important reasons why it's not obsolete. I'm pretty sure if we're going to have reasonable DNA or Quantum computers one day, someone is going to write a C compiler for it first so we can run Linux and all that stuff on it. Good luck with a C++ compiler. I bet that's a science within compiler construction itself.
I remember how excited I was when I first saw the proposal for array selection. I'm still just as excited now reading about it again. I really want to see this come to C. It would make it so much easier to write numerical code.
Can't wait to see Decimal floats!
Yes. Read the top reply to your post again.
I second this.
Try /r/embedded/ In general: You've got a lot to learn. Embedded is a huge space, which has many subdisciplines. You won't master them all in a day. Start simple and work out from there. 
Also, be careful of definitions. I've got a few professional jobs where I will claim I was an "embedded programmer" but the hardware was basically commodity x86 desktop hardware, but it was shoved in a box and had no monitor, ui, keyboard, etc. At the same time, I've worked on embedded ARM procs with custom linux kernels. I'll call that embedded too. And then i've done work with microcontrollers on custom PCB's. Also embedded. There is a spectrum, like /u/dmc_2930 says, but not everyone may play with the same definitions. I've interviewed with people who would consider both of my first two examples to not be embedded just because there was an OS between me and the hardware. 
To start with the programming part you can learn about programming the bare AVR with atmel studio (using the hardware from arduino that you already have), move on to ARM cortex series for more advanced stuff on the low end. Learn systems programming (linux syscalls, drivers, ioctls). Basic electronics is important, stuff like kirchoff's laws, opamps, transistors, how digital logic works. Layout your own board and get a PCB made somewhere (it can be done quite cheaply in china). This is a great skill for hobby projects as well even if you want to focus more on software. Learn digital systems - basically how digital IC's are designed, learn a bit of a HDL and build something on an FPGA to really get an idea of how things work from the bottom up. Low level understanding of some network (Ethernet + TCP/IP) stuff is useful as well, along with the other common buses of course (SPI/I2C/UART/CAN) but you'll probably pick those up soon enough when using microcontrollers in general. Some knowledge of control systems and DSP is useful as well though not really required. ---- Once you have a basic understanding of all of that, pick a direction to specialise into, you can't be a master of everything. 
Since eveything is set to NULL, why don't you use memset(my_array,0, sizeof(struct x)); But your question migth be more about syntax...
Yes it is more about syntax but using memset is still a good idea.
I hate to be that guy, but did you even TRY googling it first? http://lmgtfy.com/?q=c+initialize+struct+array Just to be clear, you have options. Option 1: struct x myarry[N] = { { .high = NULL }, { .high = NULL, .hello = NULL }, ..... for however many you want ..... }; Or, initialize them each like normal: myarray[0].high = NULL; myarray[0].hello = NULL; ......... 
It looks as though you are expecting a typedef but instead just defined `example` as a variable. Also see dmc_2930s reply for syntax details.
Your last stament is invalid syntax. `arr[0]` is a `struct x` instance. Assign to it directly. `arr[0].high = &amp;thing; arr[0].hello = "world";`
Firstly you need to be clear about the difference between *initialization* and *assignment*. *Initialization* is when you provide initial values as part of the declaration of the object. You can write: struct x my_array[1] = { 0 }; which will zero-initialize all members of the array, recursively if the array contains other arrays or structs as members. In general it's better to do this than to list all named members; imagine if you later update your struct to have a third member, then you don't have to go and update all your initialization statements. *Assignment* is when you provide new values to the object in a statement separate from the declaration, for example: struct x my_array[1]; my_array[0].high = NULL; // assignment You can't use initialization syntax in an assignment statement: my_array = { 0 }; // error However, you can assign to a struct using a compound literal (There's no equivalent for arrays -- you can only assign each array element individually): struct x myArray[1]; my_array[0] = (struct x){ 0 }; Using `memset` is not a good idea because, (a) it is not guaranteed to make null pointers, (b) you can make a mistake and write past the end of the array, or not write enough of the array.
If they do that they'll screw up every C-lang programming interview until the end of time, because storage classes. 
In his example he is using the terms declaration and initialization the correct way. Initializing a struct or its contents as NULL is not necessary for it to be an initialization, just a beneficial practice. And initialization does not have to be a part of the declaration. 
Yeah so my array is like char array[x][y]. But what do you mean by multiply the dimensions? 
I'm surprised it did compile, you shouldn't (can't) use variables to determine size of array. For security reasons as stack space is limited. You want to initialize it with in heap with malloc, or here better with calloc: ``` int length = 10; char *myArray = calloc(length, sizeof(char)); ``` and change it's size with realloc. See manpage malloc(3). And don't forget to free() the memory after you stopped using it. See man free(3).
OP can also use a struct literal: my_array[0] = (struct x){.high = NULL, .hellow = NULL};
While you are theoretically correct, all but the most exotic platforms define the null pointer as the pointer with all bits set to zero, so in practice, this idiom can be used. If you are programming for a platform where that is not the case you know and you won't ask questions like this.
So in the last example, did you make a 2d array into a long array where each "row" if you will is just listed one after the other?
A null pointer might not be represented by all bits zero. When the integer constant `0` is converted to a pointer, it gets converted to the null pointer, not all bits zero per se. 
It's easy enough to use portable idioms and there's not really any reason not to. Maybe not this case specifically, but you'll be glad for having written portable code some time down the track. 
Yes of course, thanks for your advice!
Eh ... if you can use the compiler from VC++ 2015 or 2017, you can use most of C11. It's not perfect, but some of the biggest pain points are addressed. What I'm really looking forward to, though, is the work towards using clang with MSVC codegen.
Note that in many cases, you won't be able to beat the compiler until you are a very experienced assembly programmer. Been there, done that.
If it's a core module with Ethernet, you can get a faster throughput sending your data over a TCP/IP socket. You can also configure your program to send stdout to a serial port (typically at 115200bps) when you aren't connected to the debugger, and that would allow up to about 11kB/s. If you're seeing a lower transfer rate, your code could be the bottleneck and not the connection. What's your expectation and use case? You might want to ask your question (with more details) over on Digi International's website: https://www.digi.com/support/forum/rabbit
You can talk to people about your proposal and get more info on how to officially submit it [here](https://groups.google.com/forum/#!forum/comp.std.c)
No, in fact they take up slightly more memory (usually either 4 or 8 bytes these days). What they do, is massively increase IO throughput, by not having to copy around structs/arrays all the damn time.
Thank you. I was requesting to standardize the common `#ident` directive. Having a standardized way to mark binaries could be very useful at minimal extra effort required to implement.
That could work. Another idea would be to have each entity contain a pointer to a list of components, and have your function look at that. If you go this route, your entities will all be the same size so you can store them in an array instead of keeping track of a pointer to each.
Actually, C99 does let you use a variable to determine the size of an array, which is nice. However, the size of the array is still constant, so for OP's use case that involves resizing the options are either to use an array with some maximum size that's large enough, or allocate on the heap and use realloc as you suggested.
I do think C still has many decades left in it at least. Even if it's just in legacy systems. It is simply everywhere. But the greenfield projects (especially among less risk adverse crowds) of the near future I can foresee Rust gaining traction as a long term replacement. C will have less of a plurality in low level development
&gt; I do think C still has many decades left in it at least. Even if it's just in legacy systems. It is simply everywhere. I absolutely agree.
&gt; The same applies to local variables, except they're accessible only within the function they were declared. Almost. Locals are visible withing the *block* in which they are defined. Local variables defined within an inner block (e.g., the block of statements within a conditional statement) are only visible within that block. That's a subtle, but important, difference. &gt; It's good practise to declare all your variables first - at the begining of file/function. There is a good argument for not defining variables until you're ready to initialize them with a useful value to avoid the risk of accessing an uninitialized variable, as well as to avoid unnecessary initialization to a value outside the valid domain, such as NULL. In addition, there is value in constraining the scope of variables by defining them in the smallest reasonable scope. That avoids the risk of reusing a variable, and getting bitten by it containing an unexpected value because of this.
But that exact issue *would* be fixed by changing to a memory safe language, since in order to remain memory safe, they include bounds checking (or sometimes bounds proofs, where that can be done). The rest of your "even then ..." comments are the same old tired excuses and attitudes that are the reason we have so much insecure and crappy software. Look, I *love* C. I've been coding in C since the early 80s, before it was standardized. I currently spend about a third or so of my working hours coding in C. It is simply a fact that languages such as Rust bring advantages to the table that C does not. And I strongly agree with the curl maintainer that it makes no sense to rewrite curl &amp; libcurl in Rust. However, it think it would be a *great* idea to use Rust to write new tools and libraries to fill the same role as curl.
Always
TO be MISRA 2004 compliant you can only go to C89 I work on medical devices. Had to be a departmental decision to use C99 and disable that particular check.
Just forget about Visual Studio and use MinGW-w64.
The year is 1700. Commenters on the internet say that phlogiston theory will soon fully explain combustion.
You should also mention `_XOPEN_SOURCE` which enables a couple other useful interfaces.
Yeah, this should work.
`_XOPEN_SOURCE` pops up occasionally. many interesting bits and pieces are only available with `_XOPEN_SOURCE` defined.
Yes of course, `_XOPEN_SOURCE`, duh. No idea why I typed that wrongly.
Unlike phlogiston theory, language theory has been reliably demonstrated to work and provide material benefit. In this metaphor, OP's article is the one touting phlogiston and aether.
Can't mention C's flaws in here, friend
Ostriches at least bury their heads in sand for a useful purpose
Right ok so it kinda works. It works when I put in one of my functions (not the main but another one). However, if I have it outside all of the functions but after the #include ___.h file it doesn't compile. Says it recognise my struct name :/
Actually I realised that I'm just going to have to define this in the main function rather than outside all the functions. Thanks again so much for your help. It's encouraging to know that whenever I have a problem I can't solve, there are people on this subreddit ready to help. Hopefully I don't annoy everyone by posting too much...
So _XOPEN_SOURCE is a macro option to enable POSIX standards that also enable a few BSD features? So it is the combination of a subset of unix related macros combined with BSD features. I found only commentaries about what exactly entails, it is neccesary to know them (like the C standards)?
For the code to appear readable, you need to put four blanks in front of every line of code. Please do that.
I'll have to check it out.
Thank you! 
You are doing the calculations in the main function. An alternative way to do it would be to create a function that returns a volume for a given radius and height, then printf the results of that.
Funny, that's exactly how I feel about C.
Sorry I came off as an evangelist. It was the main language that fulfills all these requirements, but I personally think that Go and modern Python are just as interesting in a lot of ways, especially for I/O bound applications, because they make parallelism much easier. Go is exceptional in that regard because of Goroutines.
I am so sorry that it disturbs you that people talk about C in a subreddit dedicated to talking about C.
I think he wanted a function in your code to perform division operation as follow- #include &lt;stdio.h&gt; int div(int a,int b) { return a/b; } int main(void){ int A; int B; int solution; printf("Select two numbers to be divided.\n"); printf("What is the numerator?\n"); scanf("%d", &amp;A); printf("What is the denomenator?\n"); scanf("%d", &amp;B); if (B == 0) printf("A number cannot be divided by 0.\n"); else solution=div(A,B); //function call printf("The division results in %d.\n", solution); return (0); }
Talking about Rust is today like talking about immigration. You might have a good point and it may be an interesting and important discussion by itself, but it's more likely than not that you will get associated with the horde of single-minded dolts. Sorry if I lashed out. But I'm in a terrible mood, ironically because of debugging a really stupid problem in a C program[1], and I've had Rusters not leaving me alone all week. [1] Out of 187 threads I have thread 1 doing a NULL dereference and crashing while thread 185 is right in the middle of printing the backtrace inside the double free check code in glibc and thread 172 is dereferencing a thread local variable that definitely belongs thread 1 and no one else, it's not easily reproducible and requires a misconfiguration and about 50k requests per second to that daemon to trigger once a day on average. The whole thing is in a botch job of converting an event driven daemon to threaded that should have been scrapped 7 years ago and the faulting bit where callback chains get 8 function calls long can literally be replaced by 6 lines of synchronous code or hidden by fixing the misconfiguration, but I don't want to do either until I understand if I'm actually treating the cause or just the symptoms.
My problem with it is requiring python to build a C project.
&gt; For dozens of entities, I'm retrieving dozens of parts for each per frame. What platform/system is this for? I would think not PC, because any PC from the last 20 years should be able to read hundreds or thousands of megabytes per second. Along the same lines, while having a struct with hundreds of members, of which you only use a tenth, is not making very good use of memory, is it really a problem? Just making up some sizes, if each entity takes up 16 KiB, to have 1000 of them requires less than 16 MiB. In short, don't fall victim to [premature optimization](http://wiki.c2.com/?PrematureOptimization). If this game is a hobby/toy, and is on a system that can run it well even if it's wasteful and inefficient, then who cares? But, if you mean for this to be a serious undertaking, then you probably need to get serious about how you approach it. First answer: don't reinvent the wheel. Memory allocation is an old field, and there are lots of memory allocators out there tuned for many different needs. Rust uses [jemalloc](http://jemalloc.net/). My company uses [TLSF](http://www.gii.upv.es/tlsf/). I know for certain that there are allocation algorithms tuned for the usage patterns found in games. (I don't know what they are, but I know they exist.) Similarly, there are data structures that get used often in game engines that are uncommon elsewhere. Second answer: While you're saving space in your main structure, pay close attention to the overhead (in space and time) of the additional metadata you're adding. The size of an entity now is just its size, since it's in an array. If the entity instead has a pointer to a malloced list of parts, its size is `sizeof(entity) + sizeof(variable_to_count_numparts) + sizeof(*part) + sizeof(malloc_overhead) + sizeof(part)*numparts`. All that overhead adds up quickly; you've had to add two new members to entity (pointer to the list of parts, and count of parts), plus the overhead of mallocing the list. There's a time cost, as well; not just for mallocing and freeing the list, but also to romp around memory and cache jumping from the entity to the list of parts. If you used a linked list of parts instead, it gets a lot worse a lot faster, both in space and time. This is why changing data structures in order to "save memory" or "make the code faster" is a dangerous path. If you truly are concerned about memory or CPU usage, you have to actually dive deep to analyze it and get real numbers to support your theory that data structure X is better or worse than data structure Y in order to justify changing anything.
Thank you so much! With your help and some (tedious) work , it looks like I got it working as expected now. 
I like clang's static analyzer, and gnu indent.
offcourse In video You will get a view of source code. If you need source code then comment your mail in inbox. 
Clang format is also pretty good.
From your question: &gt; What are the standard tools for linting, formatting and unit testing? Yes, you did ask for standard tools. If that's not what you meant, then please edit your question.
 include &lt;stdio.h int div(int a,int b) { return a/b; } int main(void) { int A; int B; int solution; printf("Select two numbers to be divided.\n"); printf("What is the numerator?\n"); scanf("%d", &amp;A); printf("What is the denomenator?\n"); scanf("%d", &amp;B); if (B == 0) { printf("A number cannot be divided by 0.\n"); } else { solution = div(A, B); //function call printf("The division results in %d.\n", solution); } return (0); } same code, but formatting should be fixed newline braces are a style, sameline as written before are the classic way, i thing this one's more readable few advices from me: braces for 1 line if statements are not neccessary, but they are good practice, as you don't have to add them when you'd wish to expand it later; learn to use 4space (or 2space) instead of tabs, in visual studio, eclipse and vi you can easily set the editor to insert desired amount of spaces after you hit the tab key (other ides/editors probably have that as well, but i can't speak for all of them). lastly, that's for both op and /u/manish_kumar123 : familiarize yourself with regexp, adding 4 spaces on the start of each line of code, so it can be pasted into reddit is child's play if you use it (obviously it has more use than that)
It doesn't work too well with C though. Worked super well with C++, mind sharing your configuration for C?
As far as linting goes, don't most of the modern compilers (gcc, for example) have linting capabilities built in through their various warning switches?
&gt; That's a good point. In hindsight, I should be able to simply just calculate the length of the output string based the length of the input string and only allocate once. Is that more like what you would expect? You can do that but you still need to tell the caller how long the decoded data is. Remember how base64 has an end-of-stream signature that can appear anywhere. Checking the length of the input only gives you an upper bound on the output length, not a hard figure. &gt; If the returned string is null terminated, can't the user use strlen() to get the length? I suppose the only case where this won't work where the unencoded string contains null characters. But I am not so sure my library is meant for those cases. As it is meant to encode/decode null-terminated character stings. I'll have to think on that. So if the input is a base64 string without a null terminator, your code generates an unterminated string? That's not good at all.
If there aren't any standard tools then recommendations are fine 😊
For C, I tend to use `indent` in Linux. It has a bunch of options. 
astyle for formatting, lint, splint, infer, vera++, and also the gcc/clang compilers for linting. CMake encourages simple assert-based applications for unit tests, though i'm sure fellow redditors can suggest better ideas
I've thought about it and I think you're right. I'm planning to release a moderately-demanding roguelike on mobile, but this all might be premature optimization. My original system had a wasteful fixed size for all entities. My planned system was to store all entities in a single malloc()'d blob. My current system is somewhere in the middle. Each entity is individually malloc()'d and they can be realloc()'d if they grow too large. Component retrieval now looks like this: void* eps_get_part(int id, int part) { return entity[id].data + ent_diff[part + id * part_max]; } Where entity[].data is a pointer to that entity and ent_diff[] is the relative offset of that component within that entity. So...I've lost cache-friendliness when iterating over entities, but I've gained memory space and kept cache-friendliness when iterating over components.
&gt; splint I think splint is c89, and balks at some c99 code. 
Please format your code by putting four spaces in front of it, like so: //first typedef struct { int food, beer; }inventory;
cat $file | base64 &gt; $encoded_file 
Say what? C is definitely an evolving language. K&amp;R, C90, C99, C11, and there are plans underway for C2x (likely 2022.) 
I don't know anything about the book in the title, but as long as it covers C99 it's probably fine. You can pick up the later changes after reading the book.
Quick question: You mention in some of your comments that this code is intended for encoding strings, which is why encoding the null byte is not important. The primary use of Base64 is to encode binary data for situations where only the ascii character set can be used. If you're expecting a string of valid characters, why would you base64 encode it? Is there a specific type of data you had in mind that may contain out of range characters, but still has a null terminator?
Well, in my vimrc file I've got things like automatic indentation and a line to mark 80 characters for consistency. I normally have another terminal emulator open for compilation, but if you want to compile through vim you could use :make (if you have a Makefile in the directory), or you could use :!gcc [source code]. Replace GCC with clang or whatever else you're using. If you're not using a GUI, I'd say tmux is a good choice. The basic hotkeys are in the manpage, and are fairly easy to memorize (e.g. Ctrl-B % to split horizontally, Ctrl-B o to move to the other pane). Really though, programming in C works out of the box on most *nix systems. Just configure things to your preferences.
Only asking cuz I'm nosey: what makes you want to pickup C after doing Java for so long? Its a good thing, don't get me wrong, just curious.
Please restrict the meta discussions under this comment. This includes suggestions and criticisms. Just to avoid legit hiring posts got buried. 
If you are only studying C for college, do you know which C standard is part of your curriculum or which compiler you will be using?
They use Tubro C/Codeblocks. 
You need to put for spaces (hit the space bar four times) in front of every line of code. Reddit recognizes this and formats your code as code. Then it looks like this: main() { puts("Hello world!"); } It seems that you haven't added enough spaces.
Haha yes. Weird college :S
Oh, thank you. I thought that it is enough to put 4 spaces before the whole code.
No problem. Now it looks great!
From 1995? No. Never heard of it. If you want books from 1995, get "the white book".
Yes sorry. So in other parts of the code I made it so that input is an array of example_t structs. Each example_t struct is 40 bytes. And so I want to double the size of the array so that it takes up 80 bytes i.e. I had another struct onto the end of the input array. 
Yes sorry I should have mentioned. In my C file I made it so that input is an array of example_t structs. Each example_t struct is 40 bytes. And so sizeof(input) would just be the size of the pointer to the first element which is 8 bytes. This is what I get and that is fine. But when I print sizeof(*input) after the realloc, I expect it to double in size since I need room to attach another struct onto the end but I still just get 40 bytes.
If you are using turbo C you certainly cannot use any C99/C11 features. Like /u/FUZxxl suggested, K&amp;R second edition is the best book to read for ANSI C/C90. Admittedly I haven't read 'Let us C', but from what I have heard it is written with the turbo C compiler in mind which has a lot of non-standard libraries (graphics, conio, etc). It should not be used if you want to learn from the perspective of the actual C standard.
Again, `sizeof(*input)` is always the size of the struct, not the size of the block of memory that the struct is stored in. The size of the struct is fixed and constant, as `sizeof()` is evaluated at compile-time, not at run-time. (Except for C99 VLAs, which you're not using, so ignore that.) There is no way to get the size of a block of memory that was dynamically allocated. If you want that you have to keep track of it yourself. 
Sounds like you are trying to write an interpreter. The TL;DR is to checkout /r/Compilers You don't want to be trying to use looping or threading to tackle this problem. You want to create a stream of tokens by reading STDIN one character at a time and identifying "words" then trying to reduce the tokens into an executable statement. The keywords you are looking for as you research are "finite state machine", "lexical analysis", "semantic analysis", and "code generation". Having written a few compilers of my own; if you aren't interested in the computer science behind compiler design, it is a real pain in the ass. So you may want to skip over a lot of the theory and use tools like `flex` and `bison` to help ease the load. You'll still need to design a good language free from ambiguity though.
You can use something like this to test dwarf premTrp = { { MAX_FOOD, MAX_BEER }, { MAX_TIRED - MAX_TIRED , MAX_BORED - MAX_BORED } }; storage premSkl = { MAX_STORAGE, MAX_STORAGE, MAX_STORAGE, MAX_STORAGE }; dwarf *poinT = &amp;premTrp; storage *poinS = &amp;premSkl; fprintf(stdout, "Storage Pointer:\n food %d, beer %d, ore %d, coins %d\n", poinS-&gt;food, poinS-&gt;beer, poinS-&gt;ore, poinS-&gt;coins); fprintf(stdout, "Dwarf Pointer:\n Inventory: food %d, beer %d \n State:\n tired %d, bored %d\n", poinT-&gt;preINV.food, poinT-&gt;preINV.beer, poinT-&gt;preSTA.tired, poinT-&gt;preSTA.bored); 
No. It has nothing to do with whether you've used the space or not. `sizeof()` will *always return the size of the struct*. It will never tell you the size of the memory block. It will always return 40 no matter what your program does with memory, because 40 is the size of your struct. 
Space Dynamics Laboratory Full Time Aerospace software. Our C is for embedded systems, ground- and space- based. We're looking for embedded-capable devs familiar with a POSIX target environment. Entry level folks accepted. Logan, Utah; Albuquerque, New Mexico. English. On-site. As we are a semi-public (gov't, not stock) company almost universally working for gov't or defense contractors, our employees pretty much *must* be US nationals. I don't know how we handle non-nationals. http://spacedynamicslaboratory.org/employment/
Every argument is always passed by value in C. That includes the pointer `root` which you are passing to the function. Passing a pointer makes a copy of the pointer. You can dereference the pointer and change what it points to, but you can't modify the pointer itself, because you're working on a copy. In other words, the following will never work: void f(T *foo) { foo = ...; } int main(void) { T *ptr = ...; f(ptr); // ptr is unchanged } If you want to modify a caller's variable, you have to pass a pointer to it (i.e. add a layer of indirection.) That applies to any type, including pointers themselves. You'd need to pass `T **` in order to modify the caller's pointer: void f(T **foo) { *foo = ...; } int main(void) { T *ptr = ...; f(&amp;ptr); // ptr is changed }
Shame that there doesn't seem to be as many for nyc. Why are most of these centered all the way in ridiculously sparse cities? 
[removed]
MinGW or another port of GCC to Windows works fine.
A `struct` declaration simply defines the data that will be stored in the structure. You cannot initialise values inside a declaration since it's a template for a type, not a value itself.
Read up on calloc.
I'm pretty sure that 0 is considered the inverse of 0 in that situation, so it will return true for 0. Also, I thought that all of the results that are derived are independent of all of the other values in inverse. If that one situation was causing a problem, then I would think that only that one would be incorrect and all of the others aren't. Actually, now that I think about it, there are more instances than I would expect of correct results turning up in the incorrect output. For example, 0xff maps to 0x16 in both the incorrect and correct outputs. Here is a picture of the incorrect output: http://imgur.com/a/Vko8j. 0x00 is supposed to map to 0x63. Here, it is mapped to 0xbf. One time before when I tried compiling, it was mapped to 0x73. These changes only happen after recompiling though, so I don't know if it has to do with garbage going in or whatever. I have a feeling that uint8_t does not have the same properties of a byte. Maybe it has some properties of a byte, but if it was actually stored in 16 bits for example, then that would definitely be a problem for the way this program works. Thanks for your help btw. I need to go help my parents rake some leaves. I'll check back in a little while.
You really really need to look more at the case of 0 and what happens in practice. Sure that `reducepoly(multpoly(0,0))` returns true? Hint: If you don't initialize a variable (Or element of an array) that's defined at function scope, like invs, its value is undefined and unpredictable. Using it before setting it to a value is also undefined and anything can happen. Hint 2: It takes adding one line to get results matching that original image you posted.
Are you talking about one line for the condition of 0 in the main function? That should make it work for zero definitely, but i don't see how that would affect the other results.
One invalid undefined value will throw off everything following. See afftrans().
That is only for the specific value of an sbox though. I don't see how that would affect others. What aff trans does in matrix multiplication with the same value aff cycled by 1 every time for 8 times. I don't see how one bad value in invs affect other sbox values other than the one it corresponds to. It affects the results for the corresponding sbox definitely.
I missed that you reset bprime to 0 in the loop. Nevermind that. 
My best guess is that the two different compilers I'm using have two different definitions within the stdint.h files. Either that or the definitions are treated differently by each compiler. It doesn't make sense to me that the stdint.h works fine for the pocketcpp compiler, but it doesn't work for the gcc compiler.
I fixed it and I got the right result. I still don't understand why though. None of the other values in sbox should have been affected by invs[0] being something that it isn't supposed to be.
Your post got caught in our spam filter. I apologize for the inconvenience.
 bubbleSort( &amp;array[x], SIZE); When you get here, `x` has a value of `SIZE` since that's what terminated the `for` loop just before,
Ok now when i reverse the change only sbox0 is incorrect. Im so confused. There was a different situation before where all of the outputs were different.
not sure I understand what you mean, x took the value of SIZE on? 
No problem
so just make it array[] ?
I see, thank you very much!
German necessary?
Yeah, this seems to be the most reasonable thing to do. Probably just accept coordinates or maybe a direction as an argument. 
It's not very clear what you're asking. At all. Have you tried using gdb to pinpoint the issue?
I've never used gdb before. I've been using xcode and an online compiler to debug. There are not currently any errors and it is running fine but the output I'm pretty sure is just giving me the arrays that were already stored on the computer because they are not random like I created in the main function, they are not ascending like I did in bubbleSort and selectionSort, and they are not below 1000. I think I need pointers to carry the values from the previous functions into the displayResults function because I think the displayResults is just creating new arrays.
wow I feel so dumb, thanks so much. Only thing wrong with it now is that the array is only displaying 11 numbers instead of 25
You can't copy to `last_name` without first making `last_name` point somewhere valid. For that matter, you can't use `c` without first making it point somewhere valid. I think you need to review how pointers work. Using uninitialized pointers like that is undefined behavior. A pointer by itself is useless; it must point to an actual object before you can use it. For example, to store the various fields you might allocate sufficient space with `malloc()`, and similarly for allocating the structs themselves. Also, `c` is going to go out of scope when the while loop ends, which would be a memory leak if the structs are allocated dynamically. 
Company: 1010data Type: Full time [Description posted in /r/NYCjobs](https://www.reddit.com/r/NYCjobs/comments/626b3v/hiri]ng_1010data_is_hiring_a_c_developer/) Location: NYC Remote: On-site Visa Sponsorship: We will sponsor Visas Contact: Send a PM to get things started
I have solved it by simply changing the array allocation size to `numbers[6];` rather than `numbers[5];`. May i ask what makes it obvious to you that the in statement doesn't show the problem because i don't get to the last branch? I have 6 numbers stored in the array and therefor, shouldn't `numbers[5]` be used on number 6? For example, lets assume the six numbers that have been stored in the array are 1, 2, 3, 4, 5, 6. This is the way i was counting: Array Location/number: 0 | User's number: 1 Array Location/number: 1 | User's number: 2 Array Location/number: 2 | User's number: 3 Array Location/number: 3 | User's number: 4 Array Location/number: 4 | User's number: 5 Array Location/number: 5 | User's number: 6 If what you were saying is whats causing the issue (which it does seem like it is, but i'm confused why and hence why i'm asking all this in this reply) then why would `if(numbers[5]==0)` not be used? Or am i completely misunderstanding what your point was?
Ahhh, i see what it is now! I'm only storing an array to hold 5 numbers, 0-4 not 6 numbers of 0-5. Thank you for pointing that out in simple terms for me. I realised soon as i got to the end of the second sentence. I'm only using a online compiler at the moment just testing things out, and it uses gcc and therefor (as you said) it was just the program misbehaving rather than an error code. I've made some extra work inside of the program since i shared it here. I have a lot of cleaning up work to do but i generally do that towards the end of finishing the 'get the processes down on paper first' phase. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int numbers[6]; //variable to store array of numbers int lotterynumbers[6]; //variable to store generated lottery numbers int i; //variable to use as counter int entrychoice; //variable to store entry choice int c; //variable to use as counter for lucky dip int j; //variable to use as counter for number checking int n; int m; printf("Welcome to the lottery game\nWould you like to choose your numbers manually or would you like a lucky dip?\nPlease enter 0 for manual entry or 1 for lucky dip.\n"); scanf("%d", &amp;entrychoice); if(entrychoice==0){ numberentry: printf("Please choose 6 random numbers in the range of 1-49. \n"); //Ask user to input 6 numbers //Cycle to input 6 numbers for (i=0; i&lt;6; i++){ printf("Please enter number %d: ", i+1); scanf("%d", &amp;numbers[i]); } } else { if(entrychoice==1){ srand(time(NULL)); for (c = 1; c &lt;= 5; c++) { numbers[c] = rand() % 48 + 1; printf("%d\n", numbers[c]); } } else{ printf("Sorry, that is not a valid selection\n"); } } printf("These are the number you have chosen: %d, %d, %d, %d, %d, %d\n", numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], numbers[5]); //Show user what numbers they have chosen for(j=0; j&lt;6; j++){ if(numbers[j]==0){ printf("I'm sorry, number %d is not a valid number in the range of 1-49. Could you please enter your numbers again.\n", j+1); goto numberentry; } } srand(time(NULL)); for (n=0; n&lt;6; n++){ lotterynumbers[n] = rand() % 48 + 1; } printf("These are the numbers from the lottery draw: %d, %d, %d, %d, %d, %d\n", lotterynumbers[0], lotterynumbers[1], lotterynumbers[2], lotterynumbers[3], lotterynumbers[4], lotterynumbers[5]); //Show user what numbers have been drawn for (m=0; m&lt;6; m++){ if (numbers[m] == lotterynumbers[0]){ printf("Number %d matches!\n", m+1); } } return 0; } Its not a productive program, just a learning exercise. I'm having a little issue with the random number generation for the entrychoice section, if i make the counting integer 0 (c=0) it falls over and crashes. I'm attempting to fix that now. I'm aware that all my variables can be tidied up and i could get away with using the same counter variable throughout probably if i reset it each time before using it, but to keep it simple for me at the moment, i'll keep it as is right now. As i become more familiar with C i will start tidying up.
&gt;I have it defined globally Found your first problem. 
&gt; c = malloc(sizeof(PERSON)); &gt; (c+i)-&gt;last_name = malloc(sizeof(char)*30); What is the logic behind trying to use (c+i) like this here? Pretty sure you could just find and replace (c+i) with c to fix it though.
Strange, it must have been compiling wrong. `for(c=0; c&lt;=5; c++)` is working now. Just attempting to get two random generations working within the same program with srand(). From research, we can't use `srand(time(NULL))` and get different generated sets each time srand is called. So, i may just make the second generator use a seed of 2 with `srand(2)` and just keep the second set of numbers the same every time the program runs but have the first set generate new numbers each time.
. . . because the first of April is "April Fool's Day", and that's a bad day to announce or launch pretty much anything. It looks pretty safe, actually, but I would have expected some idiot(s) to post joke job listings.
Well, i have written a function for this last month, [here it is](https://gist.github.com/htmk/47ee0b5dba3c61c91c1ef7980cf9d6da), i've commented the lines for your convenience, note that it works not only on single characters, but it splits on occurrences of strings.
You're welcome, glad I can help.
Damn, facil.io seems like a very fine library, i will definitely look it up, thanks for sharing!
Hey, that's not C! #include &lt;stdio.h&gt; int main(){ const char base[] = "this is to be encoded"; FILE* tmp = fopen("totally_random_name","w"); fprintf(tmp,"%s",base); fclose(tmp); system("cat totally_random_name | base64 &gt; totally_random_name"); tmp = fopen("totally_random_name","r"); char b64[256]; fgets(b64,256,tmp); printf("%s",b64); system("rm totally_random_name"); return 0; } There, no need to downvote you now! :p
I see what you mean. Yes, you're right. If `srand` is initialised the same way multiple times in the same program, the same sequence will be generated. The general pattern it to initialise the seed **once** at the beginning, and then use that same generator for the rest of the program. One problem with using multiple `srand` initialisations with different values is that the two sets of numbers may *never* actually match. For instance, #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main() { int numbers[6], lottery[6]; int matched = 0; for (int i = 0; i &lt; 1000000; i++) { srand(time(NULL)); for (int j = 0; j &lt; 6; j++) numbers[j] = rand() % 49 + 1; srand(2); for (int k = 0; k &lt; 6; k++) lottery[k] = rand() % 49 + 1; // check if any matched for (int l = 0; l &lt; 6; l++) { if (numbers[l] == lottery[l]) { printf("%d matched after %d iterations\n", numbers[l], i); matched = 1; break; } } if (matched) { break; } } printf("No match!\n"); return 0; } $ ./srand_test No match! So no number in the two sets matched even after a million iterations! This is understandable because every time `srand` was used to initialise the seed for `numbers` and `lottery`, the same two sets were being generated for `numbers` and `lottery`. That's the problem with *pseudo*-random number generators. On the other hand, suppose we do the same by just seeding it once at the beginning of the program: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main() { srand(time(NULL)); int numbers[6], lottery[6]; int max_matches = 0, max_matches_idx = 0; int matches = 0; for (int i = 0; i &lt; 1000000; i++) { for (int j = 0; j &lt; 6; j++) numbers[j] = rand() % 49 + 1; for (int k = 0; k &lt; 6; k++) lottery[k] = rand() % 49 + 1; // check matches matches = 0; for (int l = 0; l &lt; 6; l++) { if (numbers[l] == lottery[l]) { matches++; } } if (matches &gt; max_matches) { max_matches = matches; max_matches_idx = i; if (max_matches == 6) { break; } } } printf("max matches = %d after %d iterations\n", max_matches, max_matches_idx); return 0; } $ gcc -Wall -std=c99 -o srand_working srand_working.c &amp;&amp; ./srand_working max matches = 4 after 50172 iterations So we can get at best 4 matches after a large number of iterations even in this case. The chances of matching all six numbers are almost none. Also, one more comment is that if you are looking to generate random values between 1 and 49 inclusive, then the modulus operand must be 49 as in `rand() % 49 + 1` (since rand() % 49 will produce a number in the range [0, 48]). Hope that helps!
Sorry, I might have used the wrong word here. The variables are global, but I defined the port and structs in main so I wouldn't have to pass them to a function. So would passing them to the function rather than giving them global access make write() properly? I will try this. Thanks.
Like C jobs? I don't see that many C job posting in city I've been. More C++ job postings. Either there's just not that many companies hiring C programmers, or they just don't hire strangers. 
Damn! Thank you for going to such trouble and writing that for me. I can't thank people like you enough. I've been in tech for a long while now, I'm educated in computing with microsoft certs to my name but I've always found it extremely hard to get into writing software, coding in general was a very hard concept to me. But its people like you that make things embed into my knowledge base, people taking time to do exactly what you have just means much more than reading it out of a book, and I can't thank you enough. The operand that i used `% 48 +1` is something that i read from somewhere, I didn't think about it when applying it, i will amend that right now and finish off my program thanks to your help!
That's a type error: function call binds tighter than type cast, so you are attempting to call `val` which doesn't have function pointer type.
This isn't C-programming related. You might have better luck on stackoverflow or something specific to your platform/environment. What you've read about `write()` doesn't mean what you think it means: `write()` in POSIX (which includes Mac OS X and Linux) can return success when the data is written to a network buffer, but before the data has been confirmed received by the client. Indeed there are no system calls that unambiguously can detect that the data has been received.
Why not just write your own logging function? that's what I did.
Alrighty, thank you. I'll try this and come back.
Grab yourself a development board for which a C compiler is available (e.g. an ARM board) and write some software for it. Read the manual for details.
Thanks for the suggestion!
Definitely satellites or different space vehicles. I am very interested in space so basically anything having to do with that would interest me greatly 
Everyone can benefit from reading the MISRA C safety/reliability guidelines, but they're especially valuable for embedded developers. 
If OP is a student, QNX has free academic licenses that are easy to get. You get full source and all the docs; just no support other than forums. EDIT: [Turns out Curiosity runs VxWorks.](https://en.wikipedia.org/wiki/Curiosity_\(rover\))
Can you recommend any good resources for learning these two types of embedded?
If you have a raspberry pi, you can compile C code that will run directly on the hardware with no OS! This guy has made a great tutorial about it. http://www.valvers.com/open-software/raspberry-pi/step01-bare-metal-programming-in-cpt1/
If you're a freshman and already have the foresight to know what you want to do, even better. Are you able to purchase a board and write code for it? 
That gets into some serious analysis work and tends to be heavy on formal methods, as I understand it. That's not universally true - I've had two devices flown in low earth orbit and I'm a self-taught programmer and engineer - but those were amateur radio projects with a shoestring budget and not much impact if they fail. If you want to work toward something along those lines in your garage, get a ham radio license and check out high altitude ballooning. Building and launching a balloon to fly to 20 miles altitude is about the closest to launching your own satellite that you're going to get as a hobbyist. It's fun and gives you some interesting challenges. [Here](http://n1vg.net/balloon/) is a write up on my very first launch, back in 2006.
Yeah. There's only one more course; it's called Realtime Bluetooth Networks. I enrolled last year, but could not complete the course. I'm planning to do it this year. 
You need to show your code.
Nice. Thanks.
Can you talk more about your specific field and those libraries you made? I've toyed with writing general purpose libraries when I start a project that might need them.
That depends on your platform and architecture. On a UNIX-like system, run `nm` on the compiled program. The output should contain a line like this: 0000000000400766 T win This line says: `win` is a global symbol in the `.text` section (indicated by `T`) at address 0x400766. You can use this information to find the right input to win. For example, if `win` is at address 0x400766 the correct input is 67139168. Note that on some platforms (e.g. some Linux distributions), the address your program is loaded to is changed every run, making it somewhat tricky to find the right address (this is a security feature).
Generally you can download the headers for peripheral addresses and such right off of the chip manufacturer's website. 