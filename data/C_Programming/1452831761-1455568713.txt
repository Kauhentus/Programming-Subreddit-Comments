I am running my project through the Dev C++ program. Thanks for the link, will help until I can schedule an appointment with my professor.
One other thing to check - is your AntiVirus blocking the program? Some (especially Avast) have a habit of blocking self-compiled code. Try excluding your build directory (wherever the .exe ends up) from the AV.
Avast was messing things up before, but I added Dev C++ to a list of exceptions. Should I try just (temp) disabling my antivirus and restarting my comp possibly? Edit: It worked! Thank you so much. Might look for a replacement to Avast all together since that is really silly.
Interesting feature. I'm not sure I see why you wouldn't use a pointer, though. I'm definitely not an expert, just wondering. Is there a practical advantage to contiguous memory use in some cases?
I honestly just like this write-up since it was a different take at coroutines building up from basic C blocks. But like /u/acwaters pointed out: _ This is a brilliant hack that I would never use in production code, but I'm going to make this quote into a poster._ There's a lot of cool coroutine libraries for C that implements this without the ugly cruft.
Thanks.
Either way is OK, but it's important (I forgot to tell you earlier) that the pointer increase/decrease be in the opposite order in `pop` and `push`: if you increase and then `push`, then you must `pop` and then decrease (otherwise, you would be ignoring the last element and taking the one before it); similarly, if you `push` and then increase, then you must decrease and then `pop` (or you would be getting a value you haven't assigned anything to). Edit: if you increase before `pop`ping, then initializing to -1 is OK, and, in fact, better than initializing to 0. Also, note that when I mean things like “decrease and then `pop`”, I mean “decrease the pointer and then access the value it points to get the value”, not that you must decrease before calling `pop` (as it's there where the decrease should happen).
-Wno-blah when I know better than the compiler about something and don't have a better way to tell it to shut up.
Thank you for reading the submission guide! Please note that `␣` is just a visual representation of whitespace. Hit the space bar once for every `␣` instead.
Great software, great concept, great execution! I like this. For a standardized approach, use `ucontext` which was until recently part of POSIX. They removed it because you can use pthreads instead.
Thank you thank you thank you thank you so much!! Running code: (YES!!!) http://ideone.com/TCzWT6 THANK YOU FOR YOUR HELP!!!
"Wait, you can build on the command line?"
`state_table` is an array of pointers, to functions which takes no parameter and returns nothing.
You are right, that is a suitable use case for this library. You can also keep your event loop for polling in another thread and send the ready sockets to a handler thread which loops through a pool of coroutines. This is also suitable, because some sockets may have more data and some might finish faster so you can exit the coroutine and pass the data to the appropriate handler . This library does not come with a scheduler, but you can easily write one using priority queue for example.
* `state_table[0]` is the function `GD` * `state_table[1]` is the function `WT` * `state_table[2]` is the function `RG` * `state_table[3]` is the function `GU` * `state_table[4]` is the function `LG` This allows you to look up the state as an index, and make a (rather inefficient) driver: state_table[state](); calls `GD` if `state` is 0, `WT` if `state` is 1, and so on... 
Oh ya.. I missed that. I was actually thinking of C only.. Mistake. It should be, `state_table` is an array of pointers, to functions which takes an unspecified number of arguments and returns nothing.
It's a fine way to do it. On dumb compilers, it's faster than other methods, and (more importantly) it's a lot *clearer* than using a switch: switch(state) { case 0: GD(); break; case 1: WT(); break; ... }; Often I make the functions return the next state, i.e. int (*state_table[])()={... so that I can do: while(state&lt;5)state=state_table[state]();
Well, a recursive function calls itself right? So, to stop it, just have it not call itself. If you want it to stop if something is true, then only have the function call itself when it is false.
Isn't boolean only in c++?
Unfortunately I am on a windows machine. I will have a look to see if I can understand sublimes build system, I only got that code snippet from exhaustive searching online 
I really don't follow what you just wrote. On one hand, it really sounds like you want to call `exit()` ... why not just do that? Though another interpretation is that you want to jump out of all your recursion up to `main()` instantly, without going through each call on the stack manually. Is that roughly true? If so, there's no good way of doing this -- a language with exceptions would give an easy way, but in C you'd do it with `setjmp` and `longjmp`, which I don't recommend. So, you'd do it manually, maybe by returning a boolean so the caller knows whether to proceed or to unwind the stack. Or by setting a global condition to do something similar (though this is bad practice IRL).
I'd love to use exit() but this is a school project for which I'm only allowed to use malloc, read and free.
Oh, then I am not allowed to use it as I am only able to use read, free and malloc for this school project :/
That's what I already do but for some reason it ends by a segfault. (Doesn't segfault with an exit())
Take the following recursive process as an example, which makes a copy of a linked list, struct node *new(int c, struct node *next); struct node *copy(struct node *list) { return list == NULL ? NULL : new(list-&gt;c, copy(list-&gt;next)); } If new is a function that cannot fail, then this implementation is fine and it will run without issue. If new can (and does) fail, it will return an incomplete list and potentially leak the memory that was allocated for the child nodes. In order to change this behaviour, so that NULL is returned and any memory is released, the function needs to free any memory that has been allocated when new fails, return NULL, and test for that return value and pass it along to the previous calls. As NULL already has a meaning in this context -- it is the empty list -- it is a bit more complicated to test whether an empty list was copied, or a call to new failed. But it is just a matter of ensuring that a) the list to be copied is not NULL, and b) the list that was copied is NULL. With these considerations in mind, the implementation is straightforward. void freelist(struct node *list); struct node *copy(struct node *list) { struct node *next; if (list == NULL) return NULL; next = copy(list-&gt;next); if (list-&gt;next != NULL &amp;&amp; next == NULL) return NULL; if ((list = new(list-&gt;c, next)) == NULL) { freelist(next); return NULL; } return list; } As the test `(to = copy(from)) == NULL &amp;&amp; from != NULL` may be considered cumbersome for linked lists whose length may be 0, a similar solution could involve the introduction of a third value, static struct node foo; struct node *Error = &amp;foo; struct node *copy(struct node *list) { struct node *next; if (list == NULL) return NULL; if ((next = copy(list-&gt;next)) == Error) return Error; if ((list = new(list-&gt;c, next)) == NULL) { freelist(next); return Error; } return list; } The test then becomes `(to = copy(from)) == Error`. 
The contents of your func.h are a no-no. (Seeing people learning C like this makes me rage—not at you, but at anybody who teaches somebody hopelessly-out-of-date C! Old-style prototypes have been deprecated since 1989 FFS!) What you’re actually doing with that one line is declaring to the compiler that there is a function named `Message`, returning `int` (!!) and taking *any number of arguments of any type*. This is called an “old-style prototype,” and you should never use one unless you have a very, very good reason to (read: practically never). Also, don’t use `()` when declaring or defining functions; this isn’t C++ or Java, and however reasonable it may seem it doesn’t have the meaning you’d expect because C is encumbered by some 46ish years of history. Use it only when calling functions (e.g., int x = getchar(); or in the extremely rare case where you’re actually referring to a function whose parameters you have no way of knowing or don’t care about int (*const x[])() = {printf, getchar, scanf}; In a function declaration, definition, or type expression, `()` refers to an *arbitrary parameter list*, something the compiler has no way of checking properly from outside the function itself. Note that this is a concept distinct even from variadic parameter lists (denoted by `, ...` at the end of parameters), and you can’t necessarily call safely from a `()` pointer or name into a `(args, ...)` function. Instead, func.h should look like this: /* First, an include guard so this file doesn't get included twice. * In this specific case it doesn't matter, but the instant you try * to do something more complicated it will. Get into the habit now. */ #ifndef FUNC_H__INCLUDED__ /* or something similarly unique-ish */ #define FUNC_H__INCLUDED__ 1 extern void Message(void); /* `extern` is optional here, but clearer. * Message takes *no parameters* and returns *nothing*. * C will usully assume `int` if you omit a type! */ #endif /* ndef FUNC_H__INCLUDED__ */ and func.c should look like this: #include &lt;stdio.h&gt; /* (^So that you can use printf or puts in this module. * You only need the func.h include from main.c because * that's the only function you're calling therein. Includes * are specific to the containing compilation-unit.) */ #include "func.h" void Message(void) /* &lt;-- Note the argument list of `void`! */ { puts("Hello"); /* or printf with a \n at the end of its string */ } Failure to fix stuff like this can lead to warnings at the very least, possibly a declaration mismatch error when you try to compile func.c because you implicitly declare `Message` as returning `int` and then define it as returning `void`. Using arbitrary parameter lists can make really basic operations in your code like (e.g.) passing a `void *` or `long long` or `double` into a function unnecessarily dangerous, because the compiler has no way of knowing whether it’s doing it right at all, or even what it’s supposed to be aiming for.
books to learn data struct in C. I need it for school.
`state_table` is an array. An array of function pointers. And the functions in question have a type signature of `void funcname()`.
I like this book. it had a section on data structures. good thing is it comes with C code. http://www.amazon.com/gp/aw/d/0201756080/ref=mp_s_a_1_5?qid=1452906633&amp;sr=8-5&amp;pi=AC_SX110_SY165_QL70&amp;keywords=data+structures+c&amp;dpPl=1&amp;dpID=51Ea0S0MQwL&amp;ref=plSrch
Not a great solution, but you can come up with a macro to disable warnings for a particular expression: #ifndef __GNUC__ /* or some version check fails */ #define nowarn(w,expr) ((expr)) #else #define nowarn(w,expr) \ (__extension__( _Pragma("GCC diagnostic push") \ _Pragma("GCC diagnostic warning \"-Wno-" #w "\"") \ expr \ _Pragma("GCC diagnostic pop"))) #endif and then you can do nowarn(whatever, printf("%l$d",10)) not that that’s all that satisfying. For the `write` one having a way to explicitly discard a value will work, #if __GNUC__ #define discard(expr) (__extension__((void)({ \ register const __typeof__((expr)) discard__0 = (expr); \ (void)discard__0; \ }))) #else #define discard(expr) ((void)(expr)) #endif I agree that preventing `(void)x` from canceling that warning was a dumb move though.
nice! thanks i will try to find more about it!...im just new to this!
 struct uint24 { unsigned int int24 : 24; }; uint24 x; x.int24 = 42; x.int24 *= 1000; Edit: i see your comment about wanting it to take up 24bits. This solution does not meet that critereon. Unless your hardware &amp; compiler has a 24 bit type then you're not going to be able to do what you want.
I'd prefer to not waste 33% of my RAM on useless crap for 24 bit audio.
smell you...
I also like how they introduced the continuation using the duff-device switch/case concept. Outside of duff-device, I haven't really seen it used before.
I agree with the other responses. It is all sound advice. Additional points: (1) I would also suggest when writing C code, try to write unit tests to verify your code is correct. An easy entry point into testing is the [minunit](http://www.jera.com/techinfo/jtns/jtn002.html) framework. It takes almost no time to get up and running. While testing can make sure your code is correct, it also helps with *refactoring*. If you think your existing code is ugly, you can have confidence of rewriting/refactoring and making sure it still produces the same results, since you have unit tests to verify against. (2) Use a build system when working on projects. There's a plethora of information on Makefiles which is my go-to, even though I rarely remember how to use them. There are other options. But make sure you have something. It avoids all the tedious shit of manually compiling, or copy and pasting specific commands. That's all I have to add. 
That's a shame since the brainchild of the project is none other than Fabrice Bellard.
He hasn't had anything to do with the project in a decade though.
This code isn't slow because your compiler is uniquely good at dealing with 4 byte integer, it's slow because your *machine* isn't good at dealing with 3 byte integers. Get it?
Imaging has this same 'waste' too. For 16M colors(True Color), you only need 24 bits, leaving 8 bits unused of every 32 bit value in the image and in RAM on all but very, very few systems (the 4th byte is used somewhere in the world, have no idea where that is). This frustrated me at first, but there's no efficient way around it. Thankfully, image compression exists so at least savings can be realized on the disc and during transfer. https://en.wikipedia.org/wiki/Color_depth
So... Why not bit masking?
 struct uint24 { unsigned uint24 :24; } __attribute__((packed)); This is a GCC extension that will do what you want.
The 4th byte is usually used for transparency when you use the image as a texture. Rarely, it's used for exponent in RGBE (but I don't think any video card uses that). There are also 30-bit video cards with 10 bits per channel.
There are commercial tools that make debugging multiple MPI processes (threads) easy - I work for the company that develops the most popular one - [Allinea DDT](http://www.allinea.com/products/ddt). They can add breakpoints to individual or all processes - and look at the data across multiple processes. 
i don't know why but the name buf seemed so funny :p 
I call my pointers, pointer obviously! To be honest give your variables a describing name, new IDE have the amazing feature to show you the type of a variable. e.g. JakobiMatrix[4][4] SerialDataBuffer 
your function should have a base condition where it stop calling itself. Like in below example the base condition is n==0 int sum(int n){ if(n==0) return n; else return n+sum(n-1); }
Thanks.
Don't use Hungarian notation. Someday you are going to change the type of a variable, you are going to look at the 12,000 places that variable is used and you're going to decide you don't have time to Fix the variable name everywhere. I know you will, I can see into your soul. That said if i am doing pointer indexing into memory I use pThing for the starting pointer and tThing for indexing pointer. But that's just me.
Agreed. I just don't have a video card like that, nobody I know has a video card like that, but maybe one of them knows somebody, who has heard of somebody, who has a video card like that, lol
Fgets isn't discarding it. Show your whole program.
I like to call mine Bob.
Exactly! I'm also left to wonder whether using an array instead of a pointer has the possibility of introducing a possible security issue. It sounds far fetched, but it's more probable than had you simply used a pointer. Also, all the (subsequent) talk about how memory is allocated is cryptic at best..
I often see pointers whose names begin with a "p" or end with a "Ptr". But I don't really read a lot of C code, I don't know if it is that common. But as long as it is descriptive, I don't think there's a problem. For example, I think it's easier to understand a `workersRecordPtr` or `pWorkersRecord` instead of a `wrPtr` or `pWr`.
I was thinking about that, but I thought the `switch` command can accept both an int *or* char type variable for an argument?
It can, but you are passing in the int 2 and then testing against the character '2'. You need to make them match. They are two separate values when it comes to bits, so 2 does not equal '2'.
Yep, just like I wrote in my original answer. 
Also, is there another way to check if the next bracket is the pair of the previous one without using ASCII values of the characters?
You're doing something weird with your `top` pointer. Don't de-reference it before you pass it to `push` or `pop`. Make sure you're compiling with at least `-Wall -Wextra`, your compiler should have warned you about this.
I think that's kind of clever. Though you don't really need abs()...the numbers should always be either -1, -2 or other, right?
Do not cast the return value of `malloc()`. Your problem here is that you allocated enough memory for an `element*` but not for an `element`. Fix this by writing instead: element* newElem = malloc(sizeof(*newElem)); And turn on warnings, good compilers tell you when you do this mistake.
Why is a cast so dangerous ? You have to do it in c++. And I find it is a good idea because if you change the value on the left side and the right side is a cast you will get an error. 
Valgrind is right. Double check the argument of malloc. It's `sizeof(newElem)` and `newElem` is an `Element*` (note the asterisk), so `sizeof(newElem)` evaluates to the size of a pointer, not the size of the `Element` structure.
It hides compiler warnings (such as when you forget to include `stdlib.h` or the warning that you chose the wrong size) adds noise and is generally useless. and “you have to do it in C++” is not a good argument, it's an argument against C++ if at all.
Good to know. In our school we have to do it with a cast. 
http://c-faq.com/malloc/mallocnocast.html C is not C++. The best practice way to do something in one language is rarely the proper way to do it in the other. For example, using malloc() at all in C++ is very bad form.
Seems legit
That's weird. I have definitely seen this being warned about before.
+1 for clarity :)
Performance would be one of the issues (many memory allocations, indirections, loss of data locality) It would also break compatibility with 'legacy' code that expects data to be contiguous. You'll have to provide conversion functions (more performance impact in computation and memory footprint) The other alternative is to use a struct with pointer/size/capacity and alloc/realloc when you need to grow (usual factors range from 1.5 to 2). You have better performance and compatibility but worse memory consumption. At the end of the day it is a tradeoff between security and performance. 
&gt;I would never have caught those errors on my own. Then you need to turn on -Wall, because many of these errors are things the compiler can warn you about.
The best idea would be to have a C implementation of C++'s vectors and just append to the end. 
You've already gotten a great answer, but I'll add that this example is the best demonstration of why. The cast hides the error in the call to malloc. I've been doing C and C++ for years, and I overlooked the error. Question: would the compiler or valgrind (or cppcheck) have warned if the cast were omitted? I'm on mobile and can't check. 
It's best if you post your actual code. All of it. I know this isn't your actual code because you have 2 members called 'zero' in the code you posted. It looks like your problem is saying `&amp;currentBranch.zero` instead of `&amp;currentBreanch-&gt;zero`, but I can't be sure unless I see your code.
`&amp;currentBranch` is the address of `currentBranch`, which is itself a pointer holding an address. You need to dereference the pointer, not take its address. `currentBranch-&gt;zero`
* does both of those. &amp; is for getting the address of a variable to store in a pointer.
Wait, so when you say char *ptr = "Hi"; isn't that saying "I want a character that is at the pointer "Hi""? You're trying to assign Hi as a pointer, right?
So could you say c = *&amp;a, if you wanted to?
"Hi" is data that resides some place in memory. ptr is a pointer to char, whose value is the location of that data. Now you know where the data is. You can pass the location of the data to other functions instead of copying all of the data, which is expensive. Essentially, you tell functions to use data at this location. 
thanks for the answers. i found the solution but it was something totally different. i wanted to do something like this: http://i.imgur.com/0azRfmW.png 
str, buf, arr, ptr, fp, ret, node, next, head, top those are probably my most common generic ones.
Remember that &amp;Foo means "give me the address of Foo". In your case you are requesting the address of a pointer which isn't what you want to do. As others have said you need to leverage the arrow operator Foo-&gt; to access members or dereference it will *Foo then you can use the dot operator 
Also identations since you weren't using braces in your if...else.
To be fair, an implementation in POSIX shell would be just set -e yesno() { while true do printf "$1" IFS="" read -r input echo "$input" | grep -q "$(locale yesexpr)" &amp;&amp; return 0 echo "$input" | grep -q "$(locale noexpr)" &amp;&amp; return 1 done }
That's actually my job! We use an open-source framework called [Frama C](http://frama-c.com) for this purpose. Ask me anything!
At first it's harder to screw up but this is easily overlooked when refactoring, causing really strange bugs. Remembering the idiom variable = malloc(sizeof *variable); and applying it consistently has been easier for me.
what color underwear are you wearing?
What company do you work for?
Have you ever looked into [sel4](http://sel4.systems/)? General thoughts?
I know that this project exists but I haven't looked into it specifically. I generally welcome the idea to make a proved operating system / kernel, but seeing the limitations of today's static analysis frameworks, I image this being an almost impossible task. What this project achieved is an amazing feat.
 PROMPT; C; These are macros aren't they? :-(
I don't get it, could you eli5 it to me ?
I was just going through my includes to remove redundant and unused crap I don't need, and stumbled upon stdint.h, and apparently it defines a uint24_t? I'm on OS X if that matters, is this normal? does it actually work? Here's the exact code, I'm not an expert in the preprocessor, and I'm not sure why "#define __INT24_TYPE__" isn't working (sorry for the formatting, escaping isn't working for some reason) #ifdef __INT24_TYPE__ typedef signed __INT24_TYPE__ int24_t; typedef unsigned __INT24_TYPE__ uint24_t; typedef int24_t int_least24_t; typedef uint24_t uint_least24_t; typedef int24_t int_fast24_t; typedef uint24_t uint_fast24_t; # define __int_least16_t int24_t # define __uint_least16_t uint24_t # define __int_least8_t int24_t # define __uint_least8_t uint24_t #endif /* __INT24_TYPE__ */
Can you tell us more about your job? What kind of projects are you working on? What are your tasks?
ELI5 what?
I would say that you dont see a lot about static analysis in the most IT communities. What do think is the reason? Do you think code verification will become more important in the near future? Or is it allready important in the industrie and i just dont recognize it when i browse typical IT-webpages? 
How I can use Frama-C as `flawfinder` or `splint`?
How do you see the evolution of C verification versus other languages? Do you think we could reach something similar to SPARK/Ada(2012), with proof of correctness and verification of assertions logic as something intrinsic to the language standard itself instead of an extra add-on tool? Is the right direction to have a modified subset of safety-critical C which can more easily accomodate proof and verification (not a MISRA coding standard but an actual change to the language standard) or instead continue inovating on the tools around the existing standard? 
&gt; Do you think we could reach something similar to SPARK/Ada(2012), with proof of correctness and verification of assertions logic as something intrinsic to the language standard itself instead of an extra add-on tool? I don't think this is happening any time soon. The C Programming language is mostly used by people who have entirely different priorities than industry programmers and I don't see any language extensions for better static analysis becoming part of the language any time soon. Even from the WG14 itself there has been fierce opposition to simple things like making more behaviour of arithmetic operators well-defined (like signed overflow) or even detectable and I don't see the language going anywhere with respect to this. &gt; Is the right direction to have a modified subset of safety-critical C which can more easily accomodate proof and verification (not a MISRA coding standard but an actual change to the language standard) or instead continue inovating on the tools around the existing standard? I'm not sure what the right thing is. We do static analysis by restricting ourselves to analyzable constructs and annotating source code by extra-syntactical means (i.e. special comments). This is a good approach as it does not interfere with the language and allows us to use a large variety of compilers and tools to do further analysis but it also has a few backsides like not being able to enforce any of that.
Did you check the VCC homepage? The summary description of it is pretty good: &gt; VCC is a mechanical verifier for concurrent C programs. VCC takes a C program, annotated with function specifications, data invariants, loop invariants, and ghost code, and tries to prove these annotations correct. If it succeeds, VCC promises that your program actually meets its specifications. E.g., you put annotations in your code like "this function will overwrite *x with positive values only" or "each iteration of this loop will either leave y unchanged or decrease the value of y" or whatever and compiler will try to assert that those annotations are correct.
Also from me a big thank you for all the nice answers! I still have a last, liddle selfish question: Would you say that it is a plus to have something about C code verification in your portfolio if you apply for jobs in the german industry? (Anyway i started to read the Frama C docs allready ;D ) 
You're probably aware of this, but one exception to the "don't include code in headers" rule is for inline functions that are used in different files, although that's not really applicable here.
Hey...did you find anything useful? I need help on how to run this library.
&gt;Clean up your repo. If v2.c replaces main.c and cell.h, then delete those from the repo. Ended up deleting v2.c and optimized the files &gt;Include a Makefile so somebody else can easily compile your code. I never used make, I always wanted to but I always end up being lazy and making a bash script calling gcc &gt;Don't include code in a header file (cell.h). Headers should contain prototypes, not implementations. Done &gt;The C standard requires a newline at the end of header files Done &gt;\#ifndef CELL probably isn't a very good header guard, since it might be used elsewhere. I would recommend CELL_H Done &gt;I'm pretty sure you could optimize get_neighbours() and reduce the amount of duplicate code. Too lazy for that, it's the most repetitive and boring part of the whole program &gt;Your switch(userinput) code has no default case. What happens if the user enters an invalid character? Added a warning &gt;C89 requires all variables be declared at the start of a scope block. It's fine if you want to use a newer standard but you should probably specify that somewhere. I decided to comply to C89 and moved the variable declarations to the beggining of main(). The code is much more cleaner now. &gt;Your 32-size is hardcoded everywhere. I get that it's based on the size of an int, but might be worth putting in a macro. Too much work, and only one dimension would be variable (the Y axis) &gt;I don't recommend your FOR_X and FOR_Y macros, they drastically reduce the readability of the code without adding anything to the efficiency. I removed them, but they make typing easier
You can't just plop down a problem description and leave it at that. We aren't here to do your homework for you. You need to ask specific questions, and show what you have so far. If you don't have anything, then try to describe in plain English or in pseudocode an algorithm to detect runs of repeated values. 
As a general rule of thumb, you should rarely (if ever) be copying and pasting segments of code. With this in mind, try rewriting get_neighbors()
No, the problem is literally what it says. If you type in "bbb a ddddd bbb" , the output should be e.g. Sequences of a's: 0 Sequences of b's: 2 Sequences of c's: 0 Sequences of d's: 1 ... 
Thanks for the ideas. Will post more info as soon as i have access to a real computer. 
(1) You're not checking if fgetc() returns EOF. What happens if someone assumes they can quit by closing stdin with \^d? (2) To enter data in the main loop you have to enter a character followed by a new line. fgetc() will consume both characters and the program will throw an error when the newline is read. This is why almost every command is followed by "[FAILED] Unknown command ". You should probably use something other than fgetc() for the main loop. (3) Personally I think the whole CHAR_EXIT, CHAR_HELP, CHAR_NEWG, CHAR_LOAD, ... thing is excessive / unnecessary abstraction. I'd simply put the character and short comments within the switch. (4) I don't like using goto to reset the game. There is nothing technically wrong with it but it seems to me that this could be done in a more elegant way using either while, do...while, or for. (5) It may be only marginal but I wonder if bzero or memset would be faster than XORing your data to clear it. 
In your merge function, take a closer look at this block. Is it possible to violate an array boundary? while (i &lt;= middle &amp;&amp; j &lt;= right) { if (data[i] &lt; data[j]) { temp[k++] = data[i++]; } else { temp[k++] = data[j++]; } }
This is funny, because nothing in it is copy/pasted... even though it looks like it is I've been thinking about other ways to check the neighbours. I might change this function soon.
Sorry, I'm French aha
Plz make your post more readable. This is almost impossible to anwser, right now.
I am not able to format it correctly. But I have tried to make it more readable. Is it better now?
Have you tried debugging it? Use a debugger to track down where it's going wrong, or try adding 'printf'. For example: printf("Calling push. Stack is %p, stop is %d\n", ....... ); See if each function is doing what you expect. Print all your max's and min's until you find the problem.
There area number of spelling and grammatical issues throughout this page. Also, I have issues with a few of the answers (some samples): &gt;3.What is an array? &gt; &gt;Array is the data structure which contains homogeneous data i.e. The similar type of data. &gt; &gt;8.What is the minimum number of nodes that a binary tree can have? &gt; &gt;The minimum number of nodes in that binary tree can have is zero whereas maximum value is 2. &gt; &gt;9.What is bubble sort? &gt; &gt;It is the one of the type of sorting which arranges smaller values at top while larger values at bottom. 
The third answer (the first one you quoted) is not *that* bad, but the next one has quite the typo (nodes in a binary tree → nodes that come from a given node) and the last one is just stupid.
Write your own function using fgetch. I believe this is the best solution.
Removing this because of low quality.
here are the gcc warnings: http://pastebin.com/tpwuBhws
Good point. I just like keeping my functions short, so I like to keep the declarations in one place. I would maybe argue one should stick to ansi while first learning. But then I might just be an old stick in the mud.
Thanks for that hint! I also needed to change the return type of `mergesort` to `void*`.
Sorry for taking so long to get back to you. For naming variables, you'll find some people take the no caps thing serious (eg Linux kernel). But when first learning I would just do what feels natural. Took me a little while to get used to the underscore as well. You might want to just bite the bullet and get used to it now. As for not commenting.. Don't do that. That's fine for small learning projects.. But for anything more interesting, they'll make your life easier when you need to juggle tons of functions. And especially use them if someone else might look at your code. Good to get in that habit now. With the naming.. I think you have the right idea. Give a meaningful name.. If your function contents can't be summarized, break it up. The CompUsers sounds like a good size.. Though I would make the name a little more descriptive: find_users_db. In general, if you can't keep track of exactly what your function does, it's too long. A good rule of thumb is if you can't remember every variable in a function, break it up.
The gnome-common.m4 autoconf macro with a list of some good ideas for [warnings](https://git.gnome.org/browse/gnome-common/tree/macros2/gnome-compiler-flags.m4#n32) and [errors](https://git.gnome.org/browse/gnome-common/tree/macros2/gnome-compiler-flags.m4#n44). There is also a more complete list in [a cmake macro for the squash project](https://github.com/quixdb/squash/blob/master/cmake/ExtraWarningFlags.cmake) (which I maintain) which is based off an old version of the GNOME macro, plus a few extra flags I like. Some of them are, I'm sure, duplicates of stuff already in -Wall or -Wextra, but others aren't.
Judging from your previous posts, you got an assignment to write a chess game and probably stole it from someone else, and now your assignment is to change it to 'atomic chess', but you don't know how to do that either. Sound about right? What's the specification for your homework assignment? 
You should probably [start here](https://en.wikipedia.org/wiki/Atomic_chess).
Are they eggs or oranges?
Savage. I like it 
I cannot fix the mistake!?! The variable `j` clearly goes out of bounds, it goes above the right boundary almost every loop. If the right boundary is the max. index, its a n invalid read. But how do I prevent that? The algorithm requires that j increments. Every time I prevent it the list ends up not being sorted... 
If you're really willed to learn C, I'd suggest to warm up to the cmd and learn how to use it as well. gcc $PATH -o $NAME shouldn't be that hard to remember. I can understand the desire for something simple though, in which case I'd second Visual Studio.
I'm assuming you're using Windows, since you mention Notepad++. As /u/philipbuuck said, Visual Studio is free (for personal -- not sure about commercial) and is a pretty decent one-stop-shopping IDE. Eclipse is a pretty common IDE to use (a bit heavy for my taste). They have a [CDT](http://www.eclipse.org/cdt/) (C/C++ Development Tooling) download that I think is a simple "install it and use it". I could be wrong, as [this page](http://www3.ntu.edu.sg/home/ehchua/programming/howto/EclipseCpp_HowTo.html) says to install mingw or cygwin first. I'd suggest starting with mingw -- it's GCC for compiling native WIndows apps; cygwin is kind of (gross over-generalization) a way to make unix code compile and build on Windows. I just found something called [Orwell Dev-C++](http://orwelldevcpp.blogspot.com/) which is a maintained version of the venerable Dev-C++, one of my first Windows C IDEs. I've not used Orwell, but it has a good pedigree. Edit: /u/Newt_Hoenikker reminded me: choosing open source is a big plus, especially when asking for help. If you can find one that supports Linux and WIndows, that will broaden your base. 
Visual Studio has good command-line compiling tools too. I only mention it because a) a lot of people seem to be under the impression that you can't compile with Visual Studio from the command line, even though you totally can, and b) I don't see why we should be telling beginners that the command line should be intimidating or difficult for them. I mean I was proficient with the terminal for many years before I even learned how to program so overall I just never got the sentiment that it's supposed to be something over the head of beginners. Anyway when I code C I use Notepad++ and compile it from the command prompt, and it's a pretty simple, quick setup for me that doesn't require me to fiddle with Notepad++ settings just to change the warning level or something.
I did not mean to imply there's no command line, but OP sounds pretty overwhelmed by everything they've seen from C so far. Sounds like they're asking for the easiest possible entrance to the language, and I don't know an easier one than VS.
Yeah I agree that VS is a good starting point. I don't use the IDE anymore (except for debugging) but when I was starting out, Intellisense was extremely helpful to me with the hints and the ability to jump to definitions and declarations. One of the main reasons I don't use the IDE anymore is that I can't stand its project structure, but I hear it's good for large projects. I just don't happen to have any. :P
If you can learn to use vim or gvim, I'd highly recommend it. Especially for a language like C. It's just that C being a low-level programming language is associated with the commandline, and vim is the strongest and most powerful editor for the commandline. It's based on the old unix editor vi, and has stuck around for a good reason.
-Wall is helpful too. 
There's a [really good online course named CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x) that is available through EDX.ORG. People check your work, excellent community. Here, you can learn how to start with programming from scratch. You can start with zero knowledge. C is what the course uses. It even has it's own popular subreddit: /r/cs50 . I actually feel this should be on the side bar
Oh yes. I should have lookup closer at the manpage.
No, you'll never get 100, as conversion from floating point to integer truncates. The result is integers in the interval [0, 99]. But even if it did work, you shouldn't use that method because it results in a non-uniform distribution, i.e. certain numbers will be more likely than others. The fundamental problem is that there is *no* way to uniformly distribute values from the interval [0, RAND_MAX] onto some other interval unless the length of that interval evenly divides (RAND_MAX + 1), which in most cases means a length that is a power of two. Using floating point instead of modulus does *not* fix the problem. To do it properly you have to use a more sophisticated algorithm that involves potentially calling `rand()` more than once in certain circumstances. If this was C++ you could use `std::uniform_int_distribution` but I don't know off the top of my head any libraries that implement the equivalent functionality for C. Edit: the algorithm to use if you want an actual uniform distribution is outlined [in this stackoverflow answer](http://stackoverflow.com/questions/11641629/generating-a-uniform-distribution-of-integers-in-c/11645590#11645590). 
Ohhhh, thank you! That's why it seems to give more some numbers than others... I noticed it but i thought it was just random...
So you changed fgets() to scanf() but there's still a bug. What if scanf doesn't match anything? You should make sure scanf() returns the number of matches you expect. something like: if (scanf("%c", &amp;input) != 1) { ... exit gracefully here ... } 
It's Python. Just read what it says on the site. In the footer there's a link: https://github.com/reddit/
This post is off-topic in this subreddit as the subreddit is exclusively about C programming and your post fails to establish a relationship to the C programming language. I removed the post. Please ask elsewhere, like in /r/programming or /r/redditdev.
I believe the best advice, and I believe this goes for not only this, but also programming languages in general, is that you should really familiarize yourself with the optimizations performed, and understand them, and then not use them at all, except when you know it is a really really good idea.
The family of optimization flags -O*n* bundle optimizations that are known to be somewhat well-behaving and effective. Consult your compiler's manual to find out what exactly happens at each optimization level. That said, the difference between `-O2` and `-O3` is minuscule at a cost of longer compile times. I usually compile with `-O3` or `-Os` depending on whether speed or size is more important. If I'm debugging, I still compile with that optimization level unless I can't figure out what happens anymore. Recent compilers also provide `-Og` for debug-friendly optimizations. The only optimization level you should never use is `-Ofast` because that completely breaks floating-point math.
Thanks.
&gt; that completely breaks floating-point math. How?
As a simple example, try to implement [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm), and algorithm that carefully avoids summing errors in floating point summation. Here is the code: #include &lt;stddef.h&gt; double kahan_sum(const double *a, size_t n) { double sum = 0.0, c = 0.0, y, t; size_t i; for (i = 0; i &lt; n; i++) { y = a[i] - c; t = sum + y; c = (t - sum) - y; sum = t; } return sum; } This is the slightly edited output `clang` generates with `-O3` (and `-m32 -mfpmath=387 -fno-asynchronous-unwind-tables -fomit-frame-pointer` just so the output is easier to understand): kahan_sum: fldz movl 8(%esp), %eax testl %eax, %eax je .LBB0_1 movl 4(%esp), %ecx fld %st(0) fldz fxch %st(2) fxch %st(1) .LBB0_3: fstp %st(2) fldl (%ecx) fsubp %st(2) fld %st(0) fadd %st(2) fsub %st(0), %st(1) fxch %st(1) fsubp %st(2) addl $8, %ecx decl %eax fld %st(0) fxch %st(1) fxch %st(2) jne .LBB0_3 jmp .LBB0_4 .LBB0_1: fldz fldz .LBB0_4: fstp %st(1) fstp %st(0) ret This is the output with `-Ofast` instead of `-O3`: kahan_sum: fldz movl 8(%esp), %eax testl %eax, %eax je .LBB0_3 movl 4(%esp), %ecx .LBB0_2: faddl (%ecx) addl $8, %ecx decl %eax jne .LBB0_2 .LBB0_3: ret As you see, the entire error correction code has been optimized away, leaving the code as if I had written #include &lt;stddef.h&gt; double kaha_sum(const double *a, size_t n) { double sum = 0.0; size_t i; for (i = 0; i &lt; n; i++) sum += a[i]; return sum; } totally destroying the carefully designed Kahan summation.
Well, here's an example of a complication you'd run into: the IEEE 754 standard requires that floating-point inaccuracies and rounding errors at least be deterministic, so that when you're performing mathematically equivalent operations, you at least get the same answer, even if that answer is slightly off due to floating-point imprecision. So for example `x == (x * y) / y` will always be true. When you turn on ffast, all such guarantees fly out the window, different rounding methods may be used if you transform a variable one way and then reverse the operation, etc., and essentially all comparison operations are completely useless. [This page has more details.](https://gcc.gnu.org/wiki/FloatingPointMath)
&gt; So for example x == (x * y) / y will always be true. Nope. Not at all. In fact, it's false in about half the cases as division looses about one bit of precision.
I stand corrected.
Things I don't like about it: * __builtin_expect isn't really useful here * personally don't see a use for some_assert_type, if someone wants to test a specific type is using C it's implied they know how to do so * You implement a LCG rand for some reason * personally I hate typedefs * It seems you mix benchmarking (time) in with unit testing * There is heap allocation within the test framework * There is non-static stack allocation within the test framework
 char input[256]; That's a single string. You seem to be looking for an array of strings, like this: char input[100][256]; If you don't know the maximum limit of the amount of strings use dynamic allocation.
That's cool, µnit isn't for everyone; I link to some others you may like better in the README. Personally, I think cmocka and greatest are pretty cool, or if you're already using glib then that's a great way to go. * `__builtin_expect` may not be particularly useful anywhere, it's just a hint for the compiler which doesn't hurt anything. * The reason for the `munit_assert_cmp_*` macros instead of just assert is laid out right at the beginning of the [Assertions section of the documentation](https://nemequ.github.io/munit/#assertions). Basically, it lets you print the values (e.g., 1701 != 1729 instead of just foo != bar) * Is your objection to the rand function chosen, or that one is implemented at all? If the latter, the reason is explained in the [PRNG section of the docs](https://nemequ.github.io/munit/#prng). If the former, why? It's not like it's for a cryptographic application. FWIW, this particular variant of [PCG](http://www.pcg-random.org/) was chosen because it has 32 bits of state which makes it easy to implement a thread-safe function to generate a new number using atomics instead of having to resort to a mutex (which requires pthreads on most platforms, which can be [complicated to get right for a build system](http://git.savannah.gnu.org/gitweb/?p=autoconf-archive.git;a=blob_plain;f=m4/ax_pthread.m4)). * I can understand not liking typedefing away the structs and enums. I think most people prefer to do so, though, so unless I see a lot of people complain I'll leave them in. * Including timing information has proven very useful for me, and I actually have [a dedicated benchmark](https://quixdb.github.io/squash-benchmark/) for the software µnit was written for. I've already fixed one issue, and am talking to some people about some other issues. ~~If there is a demand I can add a define to provide a way to get rid of the timing information, but if you don't need it you can also just ignore it…~~ I just added support for disabling timing by defining `MUNIT_DISABLE_TIMING`. * Yes, it does some heap allocations. Getting rid of some of them wouldn't be hard, but others would require some pretty large changes and complicate the internals unnecessarily. I'd rather have a simpler implementation with malloc than a complicated one without. If you don't have access to malloc/free (because you're on an embedded system or something) then µnit probably wouldn't be appropriate anyways. * Where is the non-static stack allocation? You're right, I should remove that. *Edit*: I still can't find it, perhaps the [conformant array parameters](https://www.securecoding.cert.org/confluence/display/c/API05-C.+Use+conformant+array+parameters) are confusing you? They do not allocate anything on the stack, they just tell the compiler (and static analyzers) how big the array you're passing is. Edit: also, thanks for the feedback. It's always good to hear constructive criticism :)
And then use fgets instead of gets so that the input can't overrun each string's allocated length.
I implemented your solution but now I can't send EOF anymore. Pressing ctrl+D doesn't do anything and I have to leave the program by killing the process. 
 #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { char input[100][256]; size_t i = 0; for (; i &lt; sizeof (input) / sizeof (*input); i++) if (gets(input[i]) == NULL) break; for (size_t c = 0; c &lt; i; c++) printf("%03Zd&gt; %s\n", c, input[c]); } 
Thanks for the advice! I got a bit clearer picture of how C works now and I think it's gonna go well!
This post is not about C and was removed right now. Reporting about Linux kernel bugs is okay, but then the post should contain details about what exactly happened with some C code inside.
Unaligned loads are not significantly slower on reasonably modern CPUs (anything from Intel in the last 5 years or so). What CPU and compiler are you using ? 
Not sure if you've seen this trick before and you're using the assert_cmp_* macros for compatibility across compilers, but if you're willing to use gcc extensions (or C11) you can make a generic print statement like: #define get_format_string(type)\ __builtin_choose_expr(__builtin_compatible_types_p(type, int), "%d",\ __builtin_choose_expr(__builtin_compatible_types_p(type, float), "%f",\ // ...
Thanks, that is good to hear. I think another big inefficiency is that the skj is repeatedly getting loaded with the same values, i should reuse it.
No, but I am putting this together to add to a performance discussion of various languages (Which do not expose SIMD) vs C, and their test example uses doubles, so I am just holding that constant. I realize I could be doing 8 a time with floats. 
The code looks pretty tight. I assume you compiled at a high optimization level? You could check the assembly to see if the compiler's output is reasonable. What might help is unrolling the loop a few times depending on how large the input is. You could read in two sets of inputs per iteration, and write two sets of outputs, instead of just one.
less repeated loading of the k,j cell of the matrix added another 5% speedup [pastebin](http://pastebin.com/QAF1E025) I tried bumping it to chunks of 8 but that was slower. 
I usually compile with `-O2` because `-O3` once broke my program and it was a pain to debug, so I wouldn't recommend you using it. One of my favorite optimizations is `-funroll-loops`, which basically transforms for(i=0; i&lt;3; i++) c[i]=i; into c[0] = 0; c[1] = 1; c[2] = 2; thus removing all the loop logic but with the expense of bigger code. You should never use it for big projects, as it will run slower due to cache and stuff, but it can improve small programs with many loops. Also, if you are compiling local programs, add `-march=native`, which breaks compatibility with older processors but may make your code run faster. [Here](http://gcc.gnu.org/onlinedocs/gcc-4.4.1/gcc/Optimize-Options.html) you have a list of all the optimizations.
It looks like you're accessing the matrix in column order when it's stored in row order, which isn't cache friendly. You can do an LU decomposition on the transpose instead to do row order access as transpose and inverse commute.
I usually compile with -O2 and have even noticed slowdowns with O3 a few times. Link time optimization can be huge regardless of optimization level due to inlining functions across compilation units.
If you want to learn more about the C language, use `-O3` and then investigate why your program breaks 
&gt; The only optimization level you should never use is -Ofast because that completely breaks floating-point math. Well, it gives you fast math. Depends whether or not that is what you want. 
It was a post, which was linked to the code in github. The code as it was to work in kernel, was in C. It would have been very strange just to provide the link to the code as there was no explanation there. Anyone who would read the post would find the link and thus the C code.
I've found that -O3 can break some kinds of inline assembly code
That's right.
To expand on that: In context of DSP -ffast-math is useful where the SNR requires well below 32 bits, meaning you can afford to be sloppy with small values to gain speed. And there is also the whole denormal issue, where correct floating point behavior is actually undesirable in DSP code.
 malloc(my_strlen(entry + 2)) If entry is the string *"hello"*, that is going to pass the string *"llo"* in to `my_strlen()`, which will return 3. Also, don't forget to account for memory space for the null terminator character. This is probably what you're looking for: res = malloc(my_strlen(entry) + 1); if (!res) { return NULL; }
&gt; Yes but in the case of multiple whitespaces within the phrase, I still need to put the spaces between the arguments So? I understand that. This isn't an objection to my comment. &gt; the only thing that is not working is that extra whitespace at the end, and I don't know why, trying to change it to a '\0' didn't work. What if there's more than one whitespace character at the end? What if `entry` contains *only* whitespace, or is the empty string? Then `j == 0` at the end of your function, so `res[j - 1]` yields undefined behavior. &gt; There is another thing I didn't say in my post, I'm doing this for a school project and I have to respect a specific norm that implies I can't write functions with more than 25 lines and 80 characters per lines. So what? This does not constrain your algorithm. This is only a formatting rule. Do not worry about these limits while writing the algorithm. Get a working algorithm first. *Then* clean up your formatting.
Before you told me my mistake, I had +1 instead of +2, but valgrind showed invalid reads and writes of size 1 in the function and I ended up putting +2 instead of +1 (without any changes in the valgrind of course). So thanks to you I was able to fix the valgrinds error which is nice !
&gt;What if there's more than one whitespace character at the end? There can only be 0 or 1 whitespace at the end (that's how I coded the thing and checked it by piping cat -e), &gt;What if entry contains only whitespace, or is the empty string? I don't mind empty or full of whitespaces strings since I will not use this function on them. I thought of an algo that would check the string again and fix the end if a whitespace is found, not working either 
&gt; I thought of an algo that would check the string again and fix the end if a whitespace is found, not working either Well, obviously I can't help you when you provide no code and a useless description of the problem. http://meta.stackexchange.com/questions/147616/what-do-you-mean-it-doesnt-work You are apparently just ignoring the [suggestion I've already given you](https://www.reddit.com/r/C_Programming/comments/4202us/troubles_getting_a_char_clean/cz6hfnr), so I don't think it's worth my time to keep giving suggestions that are going to be ignored. Good luck with your program.
The way you wrote this line of code if ((res = malloc(my_strlen(entry + 2))) == NULL) is very mistake prone. There is nothing wrong with splitting it up to multiple lines, it's much more readable.
Can you provide sample input and output demonstrating your problem? Other than the previously mentioned issue with your call to `malloc()` it works fine for me.
“it doesn't work” is not an error description. It's a completely useless statement. Clarify what “it” is, what “work” is (i.e. what is supposed to happen) and what “doesn't” is (i.e. what happens instead), then your statement is useful.
On some systems, `char` is an unsigned type. Then `c` can never be negative and `c == EOF` never succeeds. On all systems, the program misbehaves when `getchar()` returns 255, which is some times a valid character (typically ÿ). Then the program erroneously terminates when there is still more input to process. 
It looks like, in the case of 2 nodes, after one loop through the `while` currNode is pointing to NULL (if the nodes were switched). Try changing your `while` condition to this: while (currNode != NULL &amp;&amp; currNode-&gt;next != NULL) {
Be careful, apparently the guy who made libcurl is [an infamous hacker](http://daniel.haxx.se/blog/2016/01/19/subject-urgent-warning/) and your code might be compromised. =)
You're not completely wrong, but according to the standard, `int main()` is fine, too. And `main() { ... }` is equivalent to `int main(void) { ... }`. Returning `void` from `main` is wrong, though.
Of the two of them, the main() declaration which implicitly returns int is more correct, but yes, I didn't feel like going in to the specifics :) 
There is no “more correct,” there is only “correct,” “incorrect,” and “implementation defined.” Correct are `int main(void)`, `int main(int, char*[])` and equivalent declarations, like `main() { ... }`.
That's it. Can't believe it's so simple. Thank you very much.
Not strict squares, but close. Thinking about the complexity of *the function* that way isn't helpful: You almost can get away with it for a *pure* function because it is by itself a self-contained program, so you think you're summing complexity, but there's an easy way to see why this doesn't work. if(x)a;if(y)b;if(z)c; Has 8 code paths: * x=0, y=0, z=0 * x=0, y=0, z=1 * x=0, y=1, z=0 * x=0, y=1, z=1 * x=1, y=0, z=0 * x=1, y=0, z=1 * x=1, y=1, z=0 * x=1, y=1, z=1 It doesn't matter if these are in the same function or in sequential functions, and it should be absolutely clear that the number of code paths increases so quickly as to become incomprehensible with just the if statements you can count on your hands. When we say that a function has time-complexity of `O(1)` or a space complexity of `O(n)` we're talking about estimating the run-time complexity, not the cost in our brains of imagining *exhaustively* our algorithm.
Why do you say ``*argv[]`` is less clear than ``**argv``?
[Done](https://www.reddit.com/r/Cprog/comments/422b8x/%C2%B5nit_a_new_unit_testing_framework_for_c_xpost_rc/).
Also, if you keep track of the position of the last swap, which can also double as a flag for whether or not there was a swap, you can make it a bit more efficient. You only need to keep sorting until there are no swaps and you don't need to sort anything from the index of the last swap in subsequent runs. Check out the writeup here: http://www.algorithmist.com/index.php/Bubble_sort
That's not close at all. That's doubling: {1, 2, 4, 8, 16, ...}. Squaring would be: {2, 4, 16, 256, ...}. So like I said, adding n branches multiplies the complexity by n.
I don't have my copy of the C11 spec handy to check, but I believe that int main() is a valid prototype for main too.
&gt; getchar() returns a char value (which is not specified by the standard whether it is signed or unsigned by default) No. The standard specifically says that the value is an `unsigned char` converted to an `int`. Here is the description for `getchar`: &gt; The `getchar` function is equivalent to `getc` with the argument `stdin`. Okay, and for `getc`: &gt; The `getc` function is equivalent to `fgetc`, except that if it is implemented as a macro, it may evaluate `stream` more than once, so the argument should never be an expression with side effects. And, for `fgetc`: &gt; If the end-of-file indicator for the input stream pointed to by `stream` is not set and a next character is present, the `fgetc` function obtains that character as an `unsigned char` converted to an `int` and advances the associated file position indicator for the stream (if defined). The value returned by `getchar` will *never* be negative unless it is `EOF`. Speaking of which: &gt; OR -1 (`EOF`) on failure. The standard says that `EOF` must expand to an integer constant expression with type `int` and a negative value. It does not require `EOF` to have the value&amp;nbsp;−1.
Yes, sorry.
Fair point, but it doesn't matter at all what type getchar() returns if you assign it to a `char` as was the point given in the text.
&gt; Omitting a return from a function that returns a value (i.e., &gt; non-void) will usually get you a warning; it induces undefined &gt; behavior I wanted to look this up to see if it was undefined behavior or just an indeterminate value. Instead I found out that a strictly conforming program is permitted to not return a value from non-void function. In the standard under §6.8.6.4¶2: &gt; A return statement terminates execution of the current function and &gt; returns control to its caller. A function may have any number of &gt; return statements. "Any number" would presumably include 0. 
I wonder how viable it'd be to fill those in with the corresponding C++ features (which MSVC does support) only under MSVC. 
http://c-faq.com/expr/seqpoints.html &gt; Clearly, a is initialized to 41, then incremented. No. The statement `a = a++;` contains *two* writes to the value of&amp;nbsp;`a`: the increment operator writes to&amp;nbsp;`a`, and the assignment operator also writes to&amp;nbsp;`a`. Two writes to the same variable without an intervening sequence point yields undefined behavior, which means that the language gives absolutely no guarantees about the behavior of any part of the program.
Oh, thank you. I just overlooked that and have never seen anything similar to this. So essentially this is just some horrible coding practice. It should just be `a++;`, `a += 1;`, or `a = a + 1;`.
All of those statements are fine, yes.
OK thanks. The main issue was just what exactly a sequence point was, it's a new term to me.
A sequence point establishes a “happens-before” relation. Without a sequence point, things can happen in arbitrary order even if that seemingly makes no sense.
Any idea why clang gives me shit about this?: int i=0; i = (0,i++); 
Maybe [this](https://embeddedfreak.wordpress.com/2009/02/10/removing-unused-functionsdead-codes-with-gccgnu-ld/) would help.
Uh... that's a terrible compiler. Well, okay. Let's see if this works out.
Notice that this option only works on elf targets as far as I know. COFF doesn't have the required machinery to support this option.
Well, what platform of TI are you developing for? gcc is available for some of them and with a few changes to your code you could switch to a different toolchain. However, I completeley agree. If it ain't broken, don't fix.
Oh, okay. I thought you were programming with MSP430 or their ARM chips. Anyway, I don't think gcc is available for these DSPs. Did my suggestions improve anything?
I thought it was obvious, but maybe I should have qualified my statement with "if used correctly". Yes, it can hurt (slightly) if used incorrectly, *which µnit clearly is not doing*. µnit uses it * In assertions which basically `abort()` on failure, but may be tested millions of times. * Handling `malloc()` returning `NULL`, as well as a few other standard library functions which are very unlikely to fail unless something is *horribly* wrong. * In the PRNG when rounding errors result in a number outside the desired range (basically, when `uint32_value / UINT32_MAX &gt; 1` or `&lt; 0`). * When checking the return status of a test. That last use is the only place it's even vaguely questionable, but it's still pretty obviously correct. If your tests are failing often you have *much* bigger concerns than branch misprediction in the testing framework.
I've checked out liburl but I can't find some good examples on how to fetch actual content from the website like names of the posts on reddit etc. :/
[An emulator](http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/) It's easier than it sounds at first.
Write a unix utility.
Can I recommend trying out [SDL](https://www.libsdl.org/)? It is a cross-platform game development library. You can check out [this tutorial](http://lazyfoo.net/tutorials/SDL/index.php), it uses C++ but they don't use any advanced C++ functionality so you can follow along with C. You can also try [GTK+](http://www.gtk.org/) for GUI's, if you want to make a graphical application. A short search also led me to a [web framework for C](https://kore.io/). I haven't used this or GTK+, so I can't really comment on them. 
interesting reply - where/how would start writing a file system? a file is a bunch of bytes, but ls/read/write files on your own file system? Sounds challenging.
Maybe you should develop some [arduino](https://www.arduino.cc/) device like weather station and a fan connected to it. Then you can write a driver for that device in C and control the fan based on temperature and/or button from status bar. Also you can create a web site that shows your room's temperature and humidity. Implementing web server in C may be a good exercise too.
I think this is excellent advice. Another thing they have in common is that they are essentially the set of things that C was designed to write, at least for fairly simple examples of their kind. And in the same vein, you could add to that list other operating system components. In the very early days of C and Unix, you couldn't fit anything too big for one person to write and understand in memory on the machine anyway; don't take the amount of source code in today's Linux kernel download as a model of what an OS must be, especially if you are just writing one as a learning experiment. There's a lot of advice today that tells people they should never implement their own OS or filesystem or crypto implementations. In a sense, there's some truth to that; you shouldn't expect to write any of those for real use without a lot of experience and training behind you, especially if you need a reliable filesystem or crypto that provides actual security. But the learning that comes from building "toy" versions of those things is an incredible thing, both in terms of learning different aspects of software development as well as getting a basic understanding of how more robust real-world versions of them work. 
&gt; So its easy to be like "to learn language x I'm going to build a web site that does y" but with c .... I sit here and I'm like "to learn C I'm going to build .... ????" and I cant come up with an idea. You could build a website using C to implement the site's (sever-side) features. This probably means you'll learn what those other languages are doing at a very low level when you use them. You can also try C client-side with something like [NaCl](https://developer.chrome.com/native-client) or a [C-to-javascript compiler](https://github.com/kripken/emscripten).
X-Post referenced from /r/node by /u/the_legend_of_dave [How I fixed libuv (the basis of Node.js)](https://www.reddit.com/r/node/comments/422jvp/how_i_fixed_libuv_the_basis_of_nodejs/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
The first thing to understand is that a harddrive is nothing but a big chunk of memory not that different from what you'd get from malloc. Then understanding that a file is just some data (the content) with a header (metainformations) and that everything is a file (including the filesystem itself). So the problem just transformed into "I have a set of data that I must organize in this chunk of memory. I don't want to simply put them there, I want to be able to accurately access, move or rename them later. What information do I need? Where do I store it? Using what structure?". None of this is system specific, everything is useful in lots of other situations :-)
Yep, I learned most of my practical C reading the manual. Not the fancy text given by the man command, the paper version of the SystemV programmers's manual. I recommend it to anyone: as people had to actually understand how things worked all the standard, simple, but robust data structures used in the system were documented and explained. As the system was really small it was easy to see the interaction between thing. Even today I keep it near because when reading about something like a binary format it is interesting to look at how it was done in the past. Most of the time the recent version just have more non-essential stuff so it helps identifying what's really important.
Any specific type of utility? 
And where do you create your filesystem? Do you create a partition for it, use an emulator of some kind (so that it looks like you're modifying an actual hard drive) or just set the filesystem in the RAM?
every type all in one progra... dammit emacs.
"Embedded C" isn't a thing. It's not a different language, it's just C. Depending on the platform, you might not have access to the full C standard library, and the platform might provide a set of other libraries you can use instead, but that really depends on the platform (which you didn't specify).
Could you provide me more context, please? Echoing what /u/boredcircuits said, embedded C isn't really a thing. It's just C. So, what platform are you targeting? ARM, AVR, ...?
A FS is just a block of memory + some structure + some functions to interface with it. Where you put that block of memory is of no importance. Put it in RAM, put it in a file, write it in the partition, write it directly on the disk.... it doesn't change anything to the problem, really. What's on your disk anyway? It's just a block of memory: [ ] What's a partition? Well, some metatada at the beginning to know what starts where and then the partition data (I'm simplifying everything a bit): [PPPP ] What's on that partition? A file system: some metatadata then a list of files: [PPPP####L L L L L L L L L L ] What's a file? Some metadata then some content: [PPPP####LF LF LF LF LF LF LF LF LF LF ] What's the content? Could be anything. [PPPP####LFCCLFCCLFCCLFCCLFCCLFCCLFCCLFCCLFCCLFCC] The only thing that makes a bunch of memory a partition is the structure of its header and the fact that you try to use it as a partition. The same goes for the FS, the files, ... The space that we just filled could have sit anywhere, including a file on a higher-level filesystem sitting on a higher level partition in a higher level disk. That's what virtual machine managers do: they take a big file of, say, 10G and create the appropriate structure on it so that internally the system thinks it's a real hard drive. Medium matters not. EDIT: btw, note that everything here is convention, you could imagine structuring things in a totally different way.
http://codeandlife.com/2012/04/02/simple-fat-and-sd-tutorial-part-1/ That will give you a perspective on a userspace filesystem
Depends - but a big blank file would work. 
Thanks for the detailed answer! It looks pretty doable; I might do it during the summer, to understand better how the different formats for partitions work.
Recently I was annoyed by having to write my japanese homework by hand, so I developed a transcriber and a macro preprocessor in C so that I could write with a normal keyboard and have it transcribed to japanese symbols. It was fun and I learned a lot about how to deal with Unicode with C89 dialect. 
There is no *standard* way to do this automatically; you would have to do something like put a different ifdef around each function and define only the proper macros, or only include the file(s) you need and keep each file minimal. I know you said you're using TI Code Composer Studio, so this may or may not help you (I'm not sure what it supports and what it doesn't), but for people finding this in the future: With gcc or clang (and probably MSVC, though obviously with a different syntax, maybe with ICC…) you can accomplish this with [link-time optimization](https://gcc.gnu.org/wiki/LinkTimeOptimization) and [visibility flags](https://gcc.gnu.org/wiki/Visibility). If you're building an executable it's really easy; just add -fvisibility=hidden to your C flags, and -flto to your C and linker flags. If you're compiling a shared library, things are a bit more complicated. The generally preferred approach is to pass -fvisibility=hidden to the compiler, then add `__attribute__((visibility ("default")))` to any functions you want to be public (usually by via a preprocessor definition).
Thanks for replying. Its an ARM 7 i believe. It will be for Usb
That's not how it works, unfortunately, and this is a common stumbling block in C. The size of a pointer is not the size of the thing it points to. You could have allocated something that's 1000 long, and it'll still print 4. You have to keep track of the number of elements yourself in a separate variable. Remember: a pointer is not an array, it's just a reference to the first element of one.
It does... But my problem was that when I use that pointer as a variable in another function, it only goes up to 4. When I try to go through values 0-7 in a for loop, the program crashes once it goes to the 5th loop. Sorry, I should've specified, I thought those 2 would be connected.
See §6.9.1¶12: &gt; If the `}` that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.
Yeah, don't use a global variable. There's two common options: First: int* foo(int* count) { *count = 7; return malloc(*count * sizeof(int)); } ... int count; int *array = foo(&amp;count); Second: typedef struct Array { int* ptr; int count; }; Array foo(void) { Array array = { malloc(7 * sizeof(int)), 7 }; return array; } ... Array array = foo();
Okay, it's working now. I must have messed up my code with some "solutions" I found on Google and even upon removing them Visual Studio kept crashing, but it's working fine now after restarting the program. Thanks for the help everyone!
If you're coming from PHP, Ruby, or JS, I think the best place to start is to create an extension to bring a C library to one of those languages. This has several benefits, but the biggest one (IMHO) is that it will actually be useful to other people The odds that you create a compelling compiler, file system, emulator, etc. are pretty low. On the other hand, if you bind a library that you know to be useful to a new language, people are likely to actually use your code, and having people actually want to use your code is remarkably encouraging. Other advantages include: * It helps connect the world you're already familiar with to C in a much more real way. * It is relatively easy, a much more "introductory" task than most of the stuff being suggested here. * It will help you get a better handle on how concepts like OOP, or other features from whatever language you choose, map to C. * It will help you understand what makes different APIs good and what makes them bad, which is a critical (if often overlooked) skill when creating your own APIs, even if they're only for your own private use. * If you're interested in contributing to an open source project it can be daunting knowing where to start, but creating bindings tend to be a fantastic entry point to contributing to the library itself. When working on your bindings you'll almost invariably notice small (or perhaps large) issues which you could fix. Finding a library might be a little challenging, but the best advice I can give you is to go with something that sounds interesting, something that you would like to be able to use from PHP/Ruby/JS/whatever. For selfish reasons I'd love for you to choose [Squash](https://quixdb.github.io/squash) (which I maintain), but there are tons of possibilities. Most established popular libraries will already have bindings, but [GitHub's list of "trending" C projects](https://github.com/trending?l=c) could be a gold mine for interesting ideas. If this idea doesn't interest you, another would be to find a library you are interested in and start adding unit tests and/or example code. This is a great way to familiarize yourself with how APIs work in C, and to contribute in a meaningful way without much fear of breaking something. **Edit**: I also have a *what not to do* suggestion: anything isolated. Writing your own thing that doesn't depend on any other code may teach you how to do stuff yourself, but you're quite likely to learn the wrong way of doing it; you should try to expose yourself to other people's code to learn what works and what doesn't, and you should try to do something other people will use so you can get feedback (especially criticism!) from them on what you did that works and what doesn't. Yes, that means I pretty much completely disagree with most of the things people here have been suggesting.
Thank you. I'll use that in my code.
Thanks, that's ultimately what I was looking for but couldn't find.
Just use socket. Its simple, "out of box" and pretty portable.
Ouch! Sounds like you've got the makings of a blog post of your own there :-)
Demoscene coding is my goto recommendation for such things usually. Any language works, but there is an aspect of it that focuses on tight, fast code and I don't think much is replacing C on that for front yet (maybe C++)... I keep thinking of doing a CUDA project doing stock analysis. Not like I'll be able to find any patterns or secrets, but it's something that might be fun to play with. Getting the day's closing numbers is easy enough from online sources.
&gt; You can't see how many values a pointer "has". A pointer carries no information about how it was allocated. Strongly agree. 
Any advice or resources on getting started with demoscene coding? I want to be a graphics programmer, so it seems like a worthwhile thing to learn to practice optimization and build a portfolio.
Firstly it eases proving academic integrity and while the IME thing is nice, I just dislike predictive text for any longer text.
Do you mean it's running Windows? M series can't run an os like Windows because there is no mmu etc. I assume you mean developing from Windows, in which case there are a few ides, such as arms own keil. As someone who has experience working with these ides I actually recomend you learn to use the command line in a Linux machine and code in your text editor of choice, I like vim but sublime, notepad++, gedit etc all have nice plug-ins to help with c development. That, gcc, the programming program, and gdb are all you really need and take just as much effort to learn how to use as one of those ides. Pm me for specific questions I don't mind helping you out a bit. As far as c, as said c is c you just might not have a full stdlib or it could be different 
Thanks for the feedback! I put the error return as a parameter because I wanted to make it easy to ignore errors - if that's what the caller wants. For example, if you just want to evaluate an expression and ignore errors, you can simply use: printf("%f\n", te_interp("1+1", 0)); If I returned the error and took the output as a pointer it would be at least three lines: double result; int error = te_interp("1+1", &amp;result); printf("%f\n", result); I just made `te_compile` to match, for consistency. I do think I'll take your advice and have `te_compile` call `te_free` internally on errors. Then `te_compile` can return NULL for errors. 
I took some of your advice and updated the library. `te_compile()` now returns 0 on failure and you don't need to call `te_free()`. Also, I changed `te_interp` to return `NaN` on failure. So I feel like the return values can indicate the error condition. The extra parameter `error` is really only useful now if you want to know the precise position of the parse error. It is no longer needed to solely determine success/failure. Does this feel better to you? Thanks!
That's neat! Good ideas.
There is direct input mode on IME, where each key represents either a hiragana or katakana character. The IME has pretty extensive options. However, not sure how you can write Kanji unless you use the predictive support.
Your explanation isn't clear enough for me. How about you show me a full program with complexity c (where c != 2), then you show me another full program with complexity c^2 where the only difference between the two programs is that the latter has exactly one more branch. 
Why does *find_function* perform a binary search? It looks like overkill when there are just 16 functions. IMHO you should treat functions the same as variables, including the possibility of binding custom functions. Another thing, *te_interp* calls *free* rather than *te_free*, so I think it leaks memory. Everything else looks pretty good.
Taking the bitwise and of pointers is not doing what you expect and may create false positives (e.g. imagine one pointer being `0x200` and the other being `0x100`). It also doesn't work on platforms where the null pointer is not all bits zero. It's also a constraint violation—the C standard constraints the operands to binary `&amp;` to have integer type. In my code, I usually react differently to each situation where a pointer could be null and the reaction usually is not to terminate the program. The following cases all occur frequently: * The null pointer does not constitute an error but most be treated specially (the usual case) * An error is reported by returning an error code or a null pointer (typically in library code) * A different strategy is tried (typically when `malloc()` or any other resource allocation function fails) * Optionally, a warning is produced and the process that yielded a null pointer is tried again (typically in case of user input) * The program is aborted (in small utilities or when the null pointer indicates a “can't process any further” kind of programming error) The most important information about an error condition for me is its source as this is the information you need to find out what caused the error. Any error handling strategy that erases this information is an inadequate error handling strategy. Doing a bunch of operations and then doing one large error check that throws away the error source is not the way I like to handle errors. If you are too lazy to think about a good way to deal with a null pointer you got, at least use a macro like this to check the null pointer: #define CHECKPTR(p) if (!(p)) { \ fprintf(stderr, "%s:%s():%d: %s is null, aborting.\n", __FILE__, __func__, __LINE__, #p); \ abort(); \ } or even better #define CHECKPTR(p) ((p) ? (p) : \ (fprintf(stderr, "%s:%s():%d: %s is null, aborting.\n", __FILE__, __func__, __LINE__, #p), \ abort(), NULL)) because that allows you to use `CHECKPTR` in an expression.
yea.. and the declaration only even has one pointer, the others are declared as ints. If all three were pointers still only one variable is being checked for NULL, and it is pointing to a mixed up location from ANDing together 3 separate addresses. If I recall the NULL value is actually a small area at the beginning of the program memory space.
Oh yeah, totally missed that one. If one of the variables is an integer, the pointer is probably implicitly converted to an integer which explains why OPs code compiles at all.
If that's all you want to do, check the return value of `malloc` and die on error, then just write your own little wrapper around `malloc` and use that instead. void *my_malloc(size_t n) { void *p = malloc(n); if (!p) { puts("Memory allocation error!"); exit(EXIT_FAILURE); } return p; }
Why are you declaring `k`&amp;nbsp;and&amp;nbsp;`d` to be arrays? You are also wrongly using the `%c` specifier for `scanf` and `printf`, when you really mean the `%s`&amp;nbsp;specifier. And for `scanf` you should use `%9s` so that you don't overflow your array. You have declared `s` to be an array-of-`char`. That's good. But when you use the name of an array as a value, the value that you get is a pointer to the first element of the array. So you don't want `&amp;s` in your `scanf` call, because just&amp;nbsp;`s` gives you the pointer that you need. Take out the spaces and the `\n` in your `scanf` string. Whitespace in a `scanf` string does not do what you think it does.
If I understand this right there are a couple things here. First, you don't need to use the square brackets on anything but `s` because strings are arrays of characters. Since you only need one value for `k` and `d` you can declare them as: int k; double d; The other thing I'm noticing is that you're using `%c` to scan and print your string, but `%c` is used to print and scan for single characters. You want to be using `%s` which will read in a string of characters and stop at the first whitespace character. Hope this helps! **EDIT:** Please see the post from /u/zifyoip. It is more accurate and in depth.
And where is the `=` sign it wants you to add? I think your bug is that the types of `k` and `d` shouldn't be array types. Also, when you pass `s` to `scanf`, you don't need to take its address—arrays implicitly decay to pointers to their first element. And you are also using the wrong formatting specifier for `s`, it should be `%s` or `%10s`, not `%c`. A similar thing happens with `printf()`. Read the documentation of these two functions for details.
They weren't initially.... I started off with int k=1; double d=2.3; but after I kept messing up with char s I began switching it up. Thank you, that makes much more sense. EDIT: I also added a second printf just now. Ugh I kept making silly mistakes. EDITEDIT: So I made the changes to the scanf and printf...Looks like this now(much cleaner): int k; double d; char s[10]; scanf("%9s%lf%d",s,&amp;d,&amp;k); printf("%s %f %d\n",s,d,k); printf("%d %f %s\n",k,d,s);
Saw another problem...Wow you really helped me get my mind going again...Thank you. EDIT: GOT IT! Had to reverse my order in scan to ("%d%lf%9s" , &amp;k,&amp;d,s)
What I mean is this: If my program has a flag `-p` I want your option parser to set a variable `pflag` to `0` if `-p` is not provided and to the number of times it was provided otherwise (or just to `1`, that's also okay in most cases). Right now it seems like I have to pass a callback to do that. And that's just ridiculous.
You could use `argparser_add(&amp;ap, "-p", "--pflag", ARGTYPE_INT, &amp;pflag, NULL)` and pass `-p 1` to the program
Do you have any suggestions? The reason I include the enum parameter is so that I know how to set the data in a type-safe way without having to resort to macros.
I suppose that would be easy to do if I know ahead of time that it will be an `int` pointer. I'll make the change. EDIT: I've made the change! The example's been updated to reflect this; I *think* this is what you wanted.
Yeah, looks great.
If `j` is 0, say, and it contains `5` then you set freq[5] to 1. (line 36) Then you print freq[j] which is still 0. (line 38) Note that looping through x=1 to 10, looking for that value in the cell is inefficient. You know what value is there so for each `j` you can do `freq[arr[i][j]]=1`
Someone reported this post with the reason &gt; more "rate my code" github spam (please make it stop) There is no rule against this kind of content in this subreddit. If you don't want to see this kind of content, use the vote buttons.
Looks fine. But please, please, please, don't post text as images.
Just a few remarks (that will not help you finding your potential leak): In main.c. You need not cast what calloc returns: my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *)); You need not cast NULL: my_items[n_choices] = (ITEM *)NULL; You need not cast my_items, it is already an `ITEM **`: my_menu = new_menu((ITEM **)my_items); In function `print_file` you assign `read` but you do not use it later: while ((read = getline(&amp;line, &amp;len, fp)) != -1) { Could be replaced by: while (getline(&amp;line, &amp;len, fp) != -1) { (and the declaration removed). 
Excellent, thanks for taking a look. I've now removed those casts and actually removed the `print_file` function because I was not using it any more.
There might be a leak there: void add_to_string(char **str_ptr, int num, ...) { va_list valist; va_start(valist, num); for (int i = 0; i &lt; num; i++) { char *str = strdup(va_arg(valist, char *)); if (*(str_ptr) == NULL) { *(str_ptr) = str; } else { *(str_ptr) = realloc(*(str_ptr), strlen(*(str_ptr)) + strlen(str) + 1); /* +1 for null termination */ strcat(*(str_ptr), str); } } va_end(valist); } Some `malloc`ed memory is created for `str` (inside `strdup`). In the `if` part, no problem, you need it for `str_ptr` which will point to this memory. But in the `else` part, some independant space is created for `str_ptr` with the `realloc`, and then the content of `str` is copied in it (with `strcat`). So, after the `strcat`, you still have this memory allocated for `str`, which is now useless (some new memory will be allocated by `strdup`in the next iteration of the loop). So you should `free(str)` after the `strcat`. But it is 5AM and it is possible I say crap. 
In your program description, there is a picture for the program usage where text would have sufficed. This is bad for blind participants and kills the ability to search for the text inside the image.
Fair enough, but since I made an ncurses UI it make quite a lot of sense to show it off visually.
Right, the image is in a link tag that sends you to the asciinema site, which is the tool I used to do a recording of the terminal use. I should probably replace it with an animated gif and it will probably be less confusing. Edit: I have now changed it to an animated gif.
Ah? I did not even notice :-) BTW, is there a reason why you seem to dislike to return values from functions? Almost all your functions are `void f(...)`. So that forces you to use extra `*` in *in/out* arguments(like `**str_ptr` in `add_to_string()`, or to have pure *out* arguments (like `*size` in `get_boot_options_list()`), and therefore the code is less readable (for it is harder to remember at which indirection level we are) and is a bit more prone to bugs. 
There is no particular reason, as I said I'm not that experienced using C and I'm looking to learn best practices. So I take it that it's a good idea to return some sort of result in C functions, an example being the size of the array that's been allocated?
What makes you think you need that book?
It's listed as one of the best C books, has 5/5 stars everywhere, looking for new C ideas (I've read other books as well), and I'm really curious to see what's inside
libgen is your friend...
&gt; scanned copies Of what book? I've read "Expert C"; not considering alternatives at the moment, looking for just that book :)
Both, since another commentor mentioned it, libgen is your friend. Also, bookzz if you are okay looking at djVu files (kindlebook)
I looked it up on that site as well (again before posting, just to be sure); no luck
I can vouch for it too :)
Have you checked with any public libraries? 
I just downloaded your source. I am not sure how you were not getting warnings. I get the followings: * the default language standard for (my) C compiler is C89, which does not support declaring variables everywhere. Add `-std=c99` to your CFLAGS in the Makefile. * I totally forgot this one: `strdup` is not standard C, it is (amongst other standards) POSIX. So you need to define POSIX either is the source files which need it, or in the Makefile by adding ` -D_POSIX_C_SOURCE=200809L` to your CFLAGS. I could not pass the linking phase but that is because the ncurse/terminfo setup is broken on the machine I am on at this time. I shall try later on another one.
Thanks for taking the time to review the code, this seems like a really good idea. 
 #define PTRLOLS( a, b, c ) ((a) &amp;&amp; (b) &amp;&amp; (c)) I don't know why they went with a bitwise and when and worked just as well. (I don't really understand why they want to chain all the checks together anyway.)
I didn't find any copy here at all
Strange that it's listed everywhere for &gt; 500$. I was able to just find one link to a relatively fresh (paid) download size, which i declined for obvious reasons. Looks almost like some kind of scam to me.
Still a few details, not C related : * in the Makefile, the `clean` target is wrong: you should remove `$(SRC_DIR)/`, for it is already included in the paths in $(OBJECTS). Else it tries to remove `src/src/config_handler.o`. * s/J and K arrow keys/J and K or arrow keys/ ; s/naviage/navigate/ ; s/q to quit/'q' to quit/ ; s/a to apply/'a' to apply/. Yes, I love to pick nits :-)
sci-hub.io may help
That should really go to stderr not stdout.
There's not enough information here to be able to help. What platform are you on and what libraries are you using?
Without making the jump to C++, the easiest way is probably to "flatten" the two-dimensional array: uint32_t *pixels; pixels = malloc (w * h * sizeof(*pixels)); uint32_t p = pixels [y*w+x]; // rather than pixels[x][y]
Okay so let me understand. You're making it into a single, one-dimensional array instead of a 2 dimensional one. But how does that allow resizing? Basically I want to say int grid[100][100], then later on change grid to be [x][y], once I know what x and y actually are.
Damn, and I used to have this book. John Perry had special editions made for his classes since as you discovered, the original edition is very expensive. Having taken his class based on the book, and seen the book itself, I can tell you that its mostly a regular data structures book, although made specifically for C. So you won't be exploring esoteric data structures, but ones very common to C -- arrays, multidimensional arrays, stacks, queues, linked lists. The chapters on string handling are nice because they help you get an intuition for how strings work in C, but this is one you can easily do yourself by writing a couple of string manipulation programs. 
What about this? https://www.opengl.org/documentation/specs/glut/spec3/node23.html EDIT: was not reading close enough, this probably isn't what you want
True, not standard per ISO, but standard as in “every compiler you’ll ever encounter that targets a non-embedded machine newer than 1975 supports this form.”
Only C99 and later specify this. It’s not in C89, and it’s not the default for most compilers that use C89-sludge mode unless instructed differently.
If you want to support resizing, too, your best bet is allocate a sufficiently large array for all window sizes in the beginning and then use an appropriately sized window out of that.
Ah, okay. Still having trouble understanding dynamic memory. That makes sense now.
Could you put up your code pastebin?
No sorry, it's for a class, so the "skeleton code" wasn't made by me. I'm not authorized to redistribute someone else's code without their permission.
Because it masks what’s actually happening. *Every other* argument type (including compounds like `struct` or `union`) is passed by value, and any other situation where you’d apply array types/operations to array-typed values they stay array-like (i.e., they don’t decompose to pointers). Argument-passing is the sole exception to this, and they are decomposed to pointers for passing, then recomposed as faux arrays on the other side. The `**argv` syntax, OTOH, is explicitly a pointer-to-pointer copy operation. For example: void foo(int x[], int y) { x[0] = 4; x[1] = 2; y = 9; } Here, the first instinct upon seeing these assignments should be that none have any effect on the outside world—pass-by-value, right?, so modifying these is no different than modifying locals. Similarly, slapping `const` on them in the prototype should have no effect on the type involved, so `const int x[]` should be treated identically to `int x[]`. In contrast, when we’re explicit about things: void foo(int *x, int y) { x[0] = 4; x[1] = 2; y = 9; } it becomes much clearer that `x[]` is modifiable (per lack of `const` in declaration) and these assignments modify `x[]` outside the function. If we marked `x`’s referent `const`, it would clearly be a different prototype from `x` without `const`. And of course when we pass an array name as argument, there’s still a decay to pointer, but it’s an expected one that’s in line with everything else in the language. Array parameters are also a really terrible corner of the syntax, where you’ll see things you won’t see anywhere else in the language just to get around the pointer-ness. They do come in handy when you’re passing around multidimensional arrays, like void sum(const int x[][4], unsigned count, int (*out)[4]); where you can let the C compiler do the work for you, or the one case where both array parameters *and* old-style parameter definitions are a “good” idea: void sum(x, dim, count, out) unsigned dim, count; const int x[count][dim]; int out[count][dim]; { ... } But even then, you’re getting into territory where it’s almost better just not to bother, and instead bite the bullet: void sum(const int *x_pseudo, unsigned dim, unsigned count, int *out_pseudo) { #define x(i, j) ((*((const int (*)[count][dim])x_pseudo))[(i)][(j)]) #define out(i, j) ((*((int (*)[count][dim])out_pseudo))[(i)][(j)]) ... #undef x #undef out } or else use an accessor function pointer or something. The prototype for the former `sum` is also a terror to behold—because `dim` is declared before `x` or `out`, one has to do things like `int[][*]` which is super-rare syntax, or in GCC you can do void sum( unsigned dim; unsigned count; const int[count][dim], unsigned dim, unsigned count, int[count][dim]); if you’re desperate.
In general, don’t use global variables if you can help it—bad practice for any number of reasons. On the rare occasion you actually have to, make them `static` (i.e., not visible to every other module) if at all possible and try to group related things into single structure variables. (As was noted, the second one doesn’t use the global `array` at all, but:) For `function` you’d generally want an extra argument, something like void function(int *array, size_t count) { int i; for(i=0; i &lt; count; i++) array[i] = i; } or else have some `#define`d or `enum`’d or `static const size_t` `ARRAY_LENGTH` macro that you use consistently. Your caller would look something like #define countof(arr) (sizeof(arr) / sizeof(*(arr))) // (small array:) void caller(...) { int array[5]; function(array, countof(array)); } // (large array, nonreentrant:) void caller(...) { static int array[1048576UL]; function(array, countof(array)); } // (dynamically allocated/reentrant:) void caller(...) { static const size_t ARRAY_LENGTH = 1048576UL; int *array; if(!(array = malloc(sizeof(int[ARRAY_LENGTH])))) { fputs("insufficient memory\n", stderr); for(;;) abort(); } function(array, ARRAY_LENGTH); free(array); } 
Thanks! I added the `-lm` linker flag (I'm using mingw and didn't need it, but it doesn't hurt either) and fixed the dumb printf usage errors.
&gt; It did work when I specified in a for loop that it's supposed to print out 7 values. My main problem is, though, when I try to use that pointer in the other function, it crashes on the 5th loop. To get help with this you would need to post the actual code that is crashing. We can't guess what you might have written. &gt;Another separate matter is, why would the pointer print out 4 values when I tried to do a sizeof? Again you would need to post your code. Perhaps you wrote some code with undefined behaviour, or perhaps you misunderstood what `sizeof` was telling you. 
In your first example, the compiler could make that replacement if and only if it knew that `a()` and `b()` did not modify `x`. `x ^= y ^= x ^= y;` is UB, not unspecified. `x` is written twice without a sequence point. 
Further to this, `i = (i++,0);` would in fact be correct. 
well mathematically speaking -0 = 0 right? So your condition if (X == -0) will evaluate true for either case. If you want to differentiate between them you'll have to do something different than checking if they equal zero.
To someone not familiar with that non-standard acronym, it is. I've literally never seen this acronym outside of a small circle of users on Stack Overflow so better don't use. It's not widely known and terrible (it could stand for both *undefined* and *unspecified* behavior). Why do you need to abbreviate such a short term anyway?
The guy you're replying to is quite right in that `-0` is an integer expression and equal to `0`. And in OP's example, changing `-0` to `-0.0` would actually reflect OP's intent better (whether or not it actually works). It's a more interesting question as to why the version of the code with `-0.0` fails, as opposed to the actual posted code. 
It's completely relevant, that's exactly what's happening here. The expression he's written tests whether x is *mathematically* equal to -0. It *doesn't* test anything specific to computers, and that's exactly the problem, it should have. The question the comparison should be asking is "does this value have a specific bit set indicating the sign is negative". Math or "computer arithmetic" should've never been involved at all.
Not in terms of doubles, which have a sign bit. Look up how computers store doubles to understand. 
-0.0 is required to compare true to 0.0 with respect to equality (==) as per the IEEE-754 standard. So everything thoughzero said holds. The storage of doubles is irrelevant. 
It doesn't give which addresses every line of the macro corresponds to. I have an address (0x08blabla) and I would like to see which instruction it came from.
You can debug the assembly code... BTW, there is a -P flag for gcc, have you tried it?
GCC's `__float128` type supports up to ~1e+4932. What kind of numbers are you storing? If you actually need arbitrary precision, consider using [GNU MP](https://gmplib.org/). If you insist on implementing it yourself, consider using an array of limbs: Subtraction is simply the difference of each pair of limbs with a normalisation step (borrow from the next limb for each negative limb). If you insist on implementing it yourself, using strings, remember how you did it in grade school. [Here's a multiplication example](http://rosettacode.org/wiki/Arbitrary-precision_integers_(included)#Pure_C). Try something, then ask for advice on what you're finding difficult.
Look up arbitrary precision arithmetic. 
The -P flag doesn't work, gdb still uses the .c.
Never seen it in my country.. I will ask
Any chance you might get back a copy for a couple days? :)
If your compiler follows the IEEE754 standard you can just check the bit pattern of the double (use a union trick to get it into a 64-bit integer first). Once you've confirmed that X == +-0, -0 will have the most significant bit set.
Your biggest problem right now is that you're not right-aligning the numbers before subtracting. If your input number is 130568, you need to turn that into 000000000000000000000000130568 first (with the appropriate number of leading zeroes).
[KickAssTorrents](https://kat.cr/) has it (I won't link it directly, search it), but currently the torrent has just one seeder. Try your luck, maybe you can download it from him.
Having just read a couple of sections of the C specification with regard to floating point numbers and floating point literal expressions, I am fairly sure that you can't rely on C semantics to set the sign bit on a zero value based on the negative sign in a literal expression. Since it's a purely representational distinction rather than something inherent to the mathematical concept supposed to be represented, I assume compilers will generally choose to normalize to positive zero. I am not positive about this, though, as sometimes there's clarification somewhere else in the spec, and I haven't combed through it comprehensively. Also, I'm not sure if other relevant platform-specific specifications like IEEE754 or POSIX say anything about signed zero literal expressions. If you know any further information about how the question would be resolved, I'd be curious to hear!
How often are you logging per second? How much text do you need? Can I have further details?
Sorry, I saw your answer but I currently have no answers for your questions, will ask tomorrow at work! Thank you for caring and helping.
You're right it was just a guess, but I wasn't at my computer to try, there's no need to be rude
-Wall FTW!
"I'm not sure what you are trying to achieve with that." I have been using discord for only a month and I'm simply impressed with how easy to use it is. Literally any one can use discord and setup a server within just a few clicks. It does not require you to pay for servers, manage them, secure them, and etc. More importantly it doesn't require much effort from a user. You can literally send them a link and it will auto-connect them to the server and use the web browser version. The voice system has to be the most impressive with quality on par with teamspeak and mumble. "a medium where no record of the answer is preserved." I'm assuming your referring to logging chat. The server automatically does that. I don't believe there currently exists a feature to export the log; possibly a plugin you can use. So you don't have to scroll through days, weeks, months of chat logs. To me guaranteeing it stay up indefinitely I guess that would simply come down to if the discord company had to shutdown would be the only reason it would not stay up indefinitely. There's not much I can contribute while I have been programming in C for the past 8 years I still don't know much. And I'm pretty terrible at programming I would only be comfortable helping the absolute beginner. edit: I'll admit me setting up a discord server is selfish as I would like to share, collaborate, and learn from others on programming. I have been using IRC for a very long time. Without naming any some of them are incredibly toxic. There was an author of a very popular C book that even commented on it and went as far to call certain individuals out by name. I have seen countless times people being discouraged from participating or completely put off on the community to not continue pursuing knowledge on the subject. Bottom line is I find that unacceptable I don't care how "stupid" your question is I'm going to treat you like a decent human being. I'm not going to treat you differently or much less belittle you for pursuing knowledge. 
&gt; "I'm not sure what you are trying to achieve with that." I have been using discord for only a month and I'm simply impressed with how easy to use it is. Literally any one can use discord and setup a server within just a few clicks. It does not require you to pay for servers, manage them, secure them, and etc. More importantly it doesn't require much effort from a user. You can literally send them a link and it will auto-connect them to the server and use the web browser version. The voice system has to be the most impressive with quality on par with teamspeak and mumble. And what is this helpful for? Please remember that this is not a subreddit for 1:1 coaching and there is a huge degree of asynchronicity—most posts are only responded to about an hour after they were posted. I don't think any of the active users in this subreddit have an interest in a sychronous (as in, requires both parties to be online at the same time) communication medium. &gt; I'm assuming your referring to logging chat. That and the fact that speech (even if it would be recorded) is not searchable. In fact, none of this is searchable. &gt; There's not much I can contribute while I have been programming in C for the past 8 years I still don't know much. And I'm pretty terrible at programming I would only be comfortable helping the absolute beginner. &gt; To me guaranteeing it stay up indefinitely I guess that would simply come down to if the discord company had to shutdown would be the only reason it would not stay up indefinitely. I've never used discord before, so I'm not sure how this works. But if the company hosts that, the risk of the channel going down is little. Still, my other points apply. Answer questions, ask questions, do your best, submit interesting content. That's how you participate.
Don't forget to free the pointer when you are done! free(array); This tells the operating system that you are done with the chunk of memory that it gave you when you called malloc().
`=`&amp;nbsp;is an assignment operator. `==`&amp;nbsp;is a comparison operator. Don't confuse them. Also, don't post screenshots of code. I can't run a screenshot.
Except that there are tonnes of useful warnings that `-Wall` doesn't enable. If you're using `clang` I'd recommend `-Weverything` and then disabling individual warnings you don't want if/when it comes up.
Do not delete your post just because your question has been answered, /u/ClemsonTy.
I'll look into these errors, but because of the iterative nature of my program, it doesn't really help - I know the problem is there but I'm struggling to see why it occurs. / has 3 folders Dir 1: /Folder 1 Dir 2: /Folder 2 Dir 3: /Folder 3 Folder 1 has 1 folders Dir 4: /Folder 1/Folder 1-1 Folder 1-1 has 2 folders Dir 5: /Folder 1/Folder 1-1/Folder 1-1-1 Dir 6: /Folder 1/Folder 1-1/Folder 1-1-2 --5818-- REDIR: 0x4eafa90 (libc.so.6:free) redirected to 0x4c29ca3 (free) Freeing / ==5818== Conditional jump or move depends on uninitialised value(s) ==5818== at 0x400A38: vfs_rmdir (main.c:170) ==5818== by 0x400D1E: main (main.c:281) ==5818== Uninitialised value was created by a heap allocation ==5818== at 0x4C2AB5D: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==5818== by 0x40092C: vfs_mkdir (main.c:133) ==5818== by 0x400B39: main (main.c:258) ==5818== Freeing Folder 3 ==5818== Invalid free() / delete / delete[] / realloc() ==5818== at 0x4C29D2A: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==5818== by 0x400AAB: vfs_rmdir (main.c:183) ==5818== by 0x400D1E: main (main.c:281) ==5818== Address 0x51d8370 is 128 bytes inside a block of size 192 alloc'd ==5818== at 0x4C2AB5D: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==5818== by 0x40092C: vfs_mkdir (main.c:133) ==5818== by 0x400B39: main (main.c:258) ==5818== Freeing Folder 2 Freeing Folder 1 Freeing Folder 1-1 Freeing Folder 1-1-2 Freeing Folder 1-1-1 ==5818== ==5818== HEAP SUMMARY: ==5818== in use at exit: 0 bytes in 0 blocks ==5818== total heap usage: 21 allocs, 24 frees, 882 bytes allocated ==5818== ==5818== All heap blocks were freed -- no leaks are possible ==5818== ==5818== ERROR SUMMARY: 6 errors from 2 contexts (suppressed: 0 from 0) ==5818== ==5818== 3 errors in context 1 of 2: ==5818== Invalid free() / delete / delete[] / realloc() ==5818== at 0x4C29D2A: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==5818== by 0x400AAB: vfs_rmdir (main.c:183) ==5818== by 0x400D1E: main (main.c:281) ==5818== Address 0x51d8370 is 128 bytes inside a block of size 192 alloc'd ==5818== at 0x4C2AB5D: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==5818== by 0x40092C: vfs_mkdir (main.c:133) ==5818== by 0x400B39: main (main.c:258) ==5818== ==5818== ==5818== 3 errors in context 2 of 2: ==5818== Conditional jump or move depends on uninitialised value(s) ==5818== at 0x400A38: vfs_rmdir (main.c:170) ==5818== by 0x400D1E: main (main.c:281) ==5818== Uninitialised value was created by a heap allocation ==5818== at 0x4C2AB5D: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==5818== by 0x40092C: vfs_mkdir (main.c:133) ==5818== by 0x400B39: main (main.c:258) ==5818== ==5818== ERROR SUMMARY: 6 errors from 2 contexts (suppressed: 0 from 0) 
Also, &gt;==5818== Conditional jump or move depends on uninitialised value(s) &gt;==5818== at 0x400A38: vfs_rmdir (main.c:170) tells me that `pop-&gt;n_virt_dirs` is uninitialized 
It's difficult to say as I don't understand all the math. My bet would be that you're overflowing the primes[] array that you've allocated. That is, you're writing more values to it than you've allocated with malloc(). That's often what causes a segfault. I'd recommend using a debugger (like gdb). Run it in the debugger, and when you get the segfault, the debugger will show you the call stack and the values of the variables in the functions in the call stack. If it's truly dying in primes, then you can see what the value of 'i' is when you hit the failure and see if that's bigger than what your computed size was for the call to malloc(). Valgrind is nice. But in this case, I suspect a debugger is going to be more directly fruitful. Learn to use it! As for the printf's output not showing up, printf is buffered. That means your program will hold onto printed data until you've queued up a bunch of it, then it dumps it to your terminal all at once. If your program dies before that occurs, you won't see any output. To get around this, you can either call fflush(stdout), which will flush any buffered data that was printed to stdout (which printf writes to), or you can write to stderr, which isn't buffered. You can write to stderr using fprintf(stderr, "abc").
Thank you, spotted that error and have fixed it. I think I understand the other allocation error, but it's 5 in the morning and I'm over this shit lol. Appreciated anyhow, I'll crack on with this tomorrow. 
Okay yep. So the VALUE to modulo with should be 2. I made it use the INDEX of 2, rather than INDEX 0, which HOLDS 2. I changed the program and the same thing happens though. Now the loop in the prime function starts at i = 0.
... Did you even read the post? I already tried valgrind. 
With a grid size of 8, you get (primes) size = 20. When the prime function is checking 30, we have primeFillIndex=28. this line is the issue: primes[primeFillIndex] = check; 
If you want to see the results of your printfs, you should probably add newlines. printf("What's up?\r\n"); That's the normal DOS way of doing it. For unix/posix, you can skip the '\r' part. That will at least help you figure out why you aren't seeing your printf outputs. Now go add more printfs and figure out where/why it's crashing.
I think the real issue is that you didn't cast your returned memory from mallac(). It should be cast as (unsigned long int *), otherwise, when you dereference your items in your primes array, they'll be dereferenced as bytes. This because memory is returned from malloc() as raw bytes and the pointer to which it is assigned becomes a pointer to raw bytes by default. By casting the pointer to your declared pointer type (and the same type in your sized() call, you tell the compiler how to interpret the raw block of bytes as its true data type. This should prevent the violation. Google or man malloc() for the correct form and more info. But it should look something like: primes = (unsigned long int *) malloc ..... Edit: fixed syntax problem
Alright, got the needed info: there will be few logs per minute usually, however if we will have to debugg a problem if could go up to few logs per second. How much text? Timestamp +text which will be ~10 chars long, but again, when debugging, it could be a lot more. The macine has 128MB flash drive with 10MB for logging.
No, that's just super-duper wrong. `primes` is declared as an `unsigned long int *` so when you access `primes` as an array you get elements of type `unsigned long int`
Found this out of coincidence reading the top posts. I'm curious though, do you do work on an in-house or proprietary engine?
dragon_wrangler is right, see the [this thread](https://www.reddit.com/r/C_Programming/comments/3wxgvb/malloc_type_casting_needed/) for details.
sry, reddit on a phone is a bit tricky :/ In line 193 you malloc the array with a certain size, but in your prime function you have no knowledge about the size of your allocated memory, which is why you get a segfault after 'size' calls. In the for-loop in prime(..) you start with index 2, which is predestined to cause problems if the given size is smaller than that. On a side note: #defines work like a simple search-and-replace, so every occurence of "true" is now replaced with "1;", if you were to use it in an if-statement ("if (something == true)") the generated code would look like this "if (something == 1;)" - which gives you an error saying that there is no closing bracket. And always check the return value of allocating functions for a NULL-Pointer.
I'm new to C, what does the * do exactly when declaring the array?
&gt; As for the binary search, I agree it's overkill, but it's already written/tested, so why not? Because it's most likely slower than linearly going through it due to cpu cache. You could have a speedup by not being fancy.
&gt; I'm sorry for being like a total newbie here. Once you've written something, you should try to make it simpler. &gt; What's a driver routine? Something (like `main()`) which can call `bigsub()` multiple times and mechanically verify the result.
Edit: I'm apparently confused about how the sizeof macro operates.
Crashes: 1%0 
gdb doesn't just provide output magically on its own. It's an interactive tool that you have to give commands to in order to get useful information out. You have to learn what those commands do and use your brain to leverage them effectively. There's plenty of material online about how to use gdb. Here's a simple "how to" I found w/ google: [How to Debug Using GDB](http://cs.baylor.edu/~donahoo/tools/gdb/tutorial.html). There are tons of others. If you're going to be writing code, you should really learn how to use a debugger to help figure out problems in that code. gdb is a great example of a debugger and is pretty much the standard on linux systems. And learning how to use a tool like gdb effectively will also help you learn how the programming language and computer work.
On some system this is still true, but they are very (very) special systems, like OS that runs on embeded device, or very old (~1990) systems, etc... On a classic computer, this is indeed "blatant lie". Maybe your class is about writing C code for those kind of special system? I guess this is a classical "educational lie", where they oversimplify things at the beginning to enforce good habits and then explain in more detail when you have some practice.
Thanks for correcting me. I'm showing a combination of age and C to C++ sloppiness here (although it was correct in the dark ages when I learned C). 
&gt; So "free" is for if your own program will need more of its own memory for its own operations later on. You surely mean "malloc" instead of "free" ;)
This tripped me up because the floats are converted to integers to preform the modulus operation. Good catch! I actually wrote a fuzzer to test random expression, and it still missed this simple case. I fixed it to use the standard `fmod()` function. It returns NaN instead in the case of X%0. Thanks for pointing it out!
I'm going to benchmark it and find out, although you've almost convinced me to put in the simpler code regardless.
sizeof is an operator. &gt; are you saying sizeof will just look for what pointer type it's defined as without the * operator ever being called Yes. char *x = 0; printf("size is %d",sizeof(*x)); will print `size is 1` and not crash. Similarly int a = 42; size_t size = sizeof(a++); printf("size is %d and a is %d\n",size,a); will print `size is 4 and a is 42`. `a++` is never evaluated.
There are many uses for pointers. In the original case, the author wanted an array whose size was based on user input. The answer is to use malloc, which returns a pointer to a block of memory. Other common uses are to pass large structures, objects etc to functions (a small pointer is passed instead of copying all the data) or a pointer is passed to a function so that the function can alter an argument. void AddSix(int *a) { (*a) = (*a) + 6; } int x = 42; AddSix(&amp;x);
Since the compiler knows what type `something` is then it must know what type `*something` is. E.g. If `something` is a pointer to an int, then `*something` must be an int. Dereferencing is dealing with values, sizeof deals with types. The value of something doesn't affect its size. The value of a pointer doesn't affect the size of the thing that it is pointing to.
So, how is this size supposedly known? #include &lt;stdio.h&gt; int main(void) { void* someArray = NULL; printf("Size is %zu\n", sizeof(*someArray)); } 
OK so one more question. Would you say it's better practice to use `sizeof(*someArray)` or refer to the type directly? I figure that the type is more readable, but for `sizeof(*someArray)` if you change the type, it will still work so that may be a bonus?
Your figuring is correct. I prefer sizeof(Type) over sizeof(*pointer) since I find I don't go around changing types all the time.
I am not at a computer to test this, but it looks pretty good. I do have a couple of observations. * I don't see any calls to free. Is the data automatically freed by the message queue? Kind of looks like a memory leak, but I could be wrong. * you might reconsider the name data_t, as POSIX reserves the _t suffix * this is pretty pedantic, but consider replacing sprintf with snprintf * you also, for rigor, should test that malloc succeeds (again, kind of pedantic but good practice)
Excellent thanks
When reading in a string through `scanf()`, you do not need the ampersand (&amp;) because you're already passing in a pointer. When printing an integer with `printf()`, you do not need the ampersand because you want to pass in the value, not the address.
Hey I'm glad you solved the problem, I didn't knew that option before and I'd appreciate if you would show us the final code. About 0 equaling -0, you need to understand a bit machine arithmetic. The way of computers to negate numbers is called 2's complement. Put simply, because the number is actually stored in bits, to negate a number you turn around all bits and add one, so -0 in 8 bits for example will be: 11111111 + 1 which is 0 (remember the number in this example has 8 bit capacity so when capacity is full it becomes zero). When the computer tries to check if 2 numbers are equal, it actually subtracts them and checks if it is equal to zero, so 0 - -0 is, well 0 which means that they're equal (according to the computers' calculation). Correct me if I'm wrong!
How would you do it by hand, with pencil and paper? You can't write a program that tells a computer how to do something until you understand how to do it yourself.
Forget about code. You aren't ready for that stage yet. First you need to have a clear understanding of a precise, step-by-step process for solving the problem. "Kind of getting the gist of it" isn't good enough. Imagine that you have to explain how to solve the problem to a very stupid person with no common sense, so that you have to explain every part of every single step in great detail in order to make sure that the person follows the steps correctly. What would your explanation of the step-by-step process be?
&gt; an array type variable is always a pointer No it isn't. `sizeof(some_array)` gives you the size of the array, not the size of a pointer. Also `++some_array` does not work.
Do not delete your post, /u/steeltown123.
Looks like your question has been answered. A few pointers (ha): * If you know the size of your array, there is no reason to use malloc. Just declare an array like `char buffer[255]` * If you do use malloc you need to manually "free" the memory you used when you are done with it with the conveniently named `free()` function. You just pass the char* that you allocated earlier to that function. * This is a little more advanced, but unless you use width specifiers, `scanf` can be a very unsafe function, especially when you use it to grab a string. 
Thanks, I appreciate the advice. * Good point, data is removed from the queue on call to mq_receive. I'll do a little research and testing. * I've seen the '_t' suffix outside of POSIX libs, I'm curious, are folks concerned about namespace collision? * Will do. * Good point, that was something I meant to put in, but I forgot. Seems I need to reinforce some better code hygiene.
Right--I learned malloc() back in the day when the cast was required and didn't realize it was no longer needed after C99 came out.
I used afl to fuzz inputs, it seems to be the only low hanging fruit at least.
You don't need the '/r' on Windows either, assuming that's what you mean by DOS.
What is your question? You can't just dump an assignment in here and expect us to do it.
Why don't you try dynamic allocation? Declare myarr as a pointer to an integer, and then allocate the requirement amount of memory using len.
This is one way to do dynamic memory allocation. Instead of doing: int myarr[len]; you would do: int *myarr = malloc(sizeof(int) * len); malloc() is a function which returns a pointer to allocated memory of the size (in bytes) specified. sizeof(int) returns the number of bytes per int. Since we multiply this by the number of array elements, it will allocate you enough memory to store the values. It may also be important to note that this memory isn't initialised, but it probably isn't anything to worry about for your program. If you want initialised memory, use calloc() instead. Once you have allocated the memory, it can be treated as a normal array. myarr[1]; will be the second element of the 'array', as if you had declared a normal array. You could also do something like this: *(myarr + 1) This is known as pointer arithmetic. When you have finished using the allocated memory, it is important to free the memory. Otherwise, it may cause memory leaks, which are very very bad when programs become complex. To free, memory, you use the free() function, as such: free(myarr); 
Use 4 spaces to indent your code so it displays properly on Reddit
Your post was never correct, you have just misunderstood it your whole life. Although the cast was necessary for some compilers prior to C89, the reasons are still nothing to do with what your post talks about.
Yes , the C standard doesn't specify much detail at all. There is an annex which talks about what exactly is guaranteed if the implementation also followes IEEE754 (which almost all of them do). I believe the IEEE754 spec says that `-0.0` should generate negative zero, and the `==` operator should return `true` when comparing negative zero with positive zero. The top-voted suggestion to use `signbit()` seems like a good idea. 
Sorry. I thought the announcement had already been done as the subreddit is listed in the sidebar.
MinGW/GCC. Windows 10 x86
don't forget step 0, which is preprocessing, handling includes, etc.
Preprocessing is part of step 1. Actually the compilation process is way more complex than just preprocessing / compiling (see ISO 9899 for more details), so I simplified this quite a lot.
That's an implementation detail. The thing we conventionally call “preprocessor” combines multiple translation phases and actually cannot be implemented as a separate program with a modern C compiler due to the way in which preprocessing tokens are converted into actual tokens.
&gt; Do I just search for a main() function somewhere? Yes.
grep can help with this.
It's frequently the last function in a file named "main.c". 
Dude thank you... you helped so much. i forgot to print it out such a noob mistake i was only returning it.
All memory allocated by a program is freed automatically on program termination. This is not an issue you need to be afraid of. That said, you should try to free all memory you allocate because if you forget to deallocate memory it hangs around until your program terminates. If you do this a lot, your process grows larger and larger.
When the process is terminated, memory associated with it is freed. When the system runs out of memory, an OOM killer may be in place and will most likely target this program for termination in order to free memory.
This is called a memory leak, and is especially troublesome if it happens in a part of your code that may run multiple times in the lifespan of the process (e.g. the undo function in a text editor).
If only some of our Java developers understood this..
Deallocating all memory at exit is useless (and takes time) except for debugging purposes. Some times you can't do even that: For example, consider a function that creates a lookup table on first use. It's useless and requires complex extra code to deallocate the lookup table on program exit but you demand this.
This is why I think learning to program with C is such a great idea. You have to do things manually and understand why you are doing things. Then when you move onto something like Java you understand so much better what is happening behind all the code you write. 
What you're describing is a memory leak. This is not defined within the scope of C, because for the most part memory allocators come from the operating system. This was one of the big changes from Windows 2 to Windows 3, was allocators which reclaimed memory after the termination of the program, and which immediately terminated the program if they requested more resources than the machine had. In the Windows 2 era, you'd be taking a machine's resources down until the machine was rebooted (exiting Windows wouldn't help, since it just deferred to EMM386, and EMM386 wasn't smart enough for this.) This was handled in the Unix family around Unix V if I remember correctly, but I probably don't. On an unhosted implementation (what you might call embedded or bare metal c, where there is no operating system,) you've lost the RAM until restart, unless you're willing to go hand-edit the memory tables. You'll notice that, for the most part, systems which don't handle this are single tenant, and this is before the network in any real way, so this is before viruses in any real way. So, on the timeline where this is relevant, there would be no motivating factor.
Stating which part is wrong and giving a reason why this is incorrect would be really nice .... The only thing I can think of: In Linux memory is virtually allocated until it is needed. As I understand it, the kernel assumes that programs will ask for more memory than they need, so the kernel will let programs request as much memory as they want and then allocate the real memory when the programs actually use it. So really your program isn't really growing larger just because you allocate more memory. Or maybe you're saying that memory isn't freed on termination? Or maybe that OP should be afraid trojans? Be afraid that malicious code would not free memory? In the meantime, have a downvote for being unhelpful. edit: added statment
Is it even possible?
That was very funny. I really hope that was satire. 
I need to test if the auto moderator was set up correctly.
Off topic? Hardly. This is an example of undefined behavior caused by a buffer overrun in cat.c.
No, I said it's wrong. It's only right on hosted implementations in consumer and server operating systems. In the C world, this is an ***enormous*** difference. C is still quite heavily used in embedded devices.
Or embedded devices. Less than 60% of C source is on the operating systems this answer takes for granted, according to MITRE.
I'm relatively confident that Unix didn't get separate address spaces until it had MMU support, and also that that wasn't from day one, but I could be wrong. I am no expert in this space. Thank you for an interesting discussion either way. `:)`
Hi, I had a quick look and I see that you don't do free on new_node-&gt;cmd as I think strdup will use malloc. Probably not your problem, but you should put it in anyway Where exactly does the segment fault occur? Or you don't know exactly? What platform are you running it on? Inside the history struct, why don't you make cmd an array instead of a pointer and use strcpy instead? Will be interesting to see if the crash still happens 
Great point.
Java still requires thinking about memory management. The most common cause of a memory leak is a strongly-connected object sitting in a long-lived cache. That object will keep all of the attached objects from being garbage-collected. This is a big problem in Java web development. Inexperienced developers will put, for instance, a strongly-connected Hibernate DTO directly into a user's session, rather than trimming off the bits of data they need (even worse if they are inexperienced enough to make a ton of fields on the DTO eagerly-initialized). Another potential cause of memory leaks in Java is resource-intensive singleton components; when designing a singleton, you need to be very, very careful about what information you attach to it, because your library client may use your service once, at the beginning of a long batch process, and now they're stuck with having 20% of their heap missing for the rest of their 3 hour PDF generation process. Crucially, with how "meta" jars are getting (e.g. Spring), you may not even know the type of the object reference you're holding onto, so a certain use case might blow the heap while your normal test use cases don't. Java is definitely a lot easier to work with for memory management (except when you're *really* pushing the limits of your heap, where explicit control is easier than carefully profiling the heap and trying to trick the gc into working), but I believe you should think about memory management for every piece of code you write, especially in web apps where high parallel load can cause problems you don't really notice until your performance test stage (if you're smart) or production (if you're not).
Well, it'd be a travesty to omit Unix. The C language was created with the Unix operating system in mind. And it would be nearly as bad to omit Linux. For developers, it's hard to beat sed and grep. I'd have included awk, but I'm not sure if the awk interpreter is written in C. There's a direct correlation between skill with these tools and the respect one gets from fellow C devs. gcc was originally written in C, and this is probably one of the most important pieces of code ever written. And of course python is implemented in C.
https://github.com/search?l=c&amp;o=desc&amp;q=stars%3A%3E1&amp;s=stars&amp;type=Repositories
thanks to: http://computerwriteup.blogspot.com/2013/10/c-program-to-identify-available-memory.html #include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;conio.h&gt; int main() { MEMORYSTATUS ms; GlobalMemoryStatus(&amp;ms); printf("\nTotal memory available: \n"); printf("\n Total Physical Memory:- %d MB\n", ms.dwTotalPhys/1024/1024); printf("\n Total Available Primary Memory:- %d MB\n ", ms.dwAvailPhys/1024/1024); printf("\n Total Virtual Memory :- %d MB\n ", ms.dwTotalVirtual/1024/1024); printf("\n Total Available Virtual Memory:- %d MB\n ", ms.dwAvailVirtual/1024/1024); /* This section will loop until ESC key hit. You can start and stop other programs ** and watch the available RAM amount change. Just hit any key to get a new ** reading. Hit ESC key to quit the prog */ while (getch() != 27) { GlobalMemoryStatus(&amp;ms); printf("\n Total Available Primary Memory:- %d MB\n ", ms.dwAvailPhys/1024/1024); } return 0; } 
This isn't /r/doYourHomework. If you want help with a problem, post code you have tried to implement so far and we will give constructive comments. If not, you will not get any help or sympathy here.
Perhaps not the most famous, but I use tmux quite often and that is written in C. Most popular is obviously Unix/Linux, git, and parts of Mathematica and Matlab are implemented in C.
Apache web server
Linux, OSX and Windows are the main ones I can think of off the top of my head.
Hello world. https://www.artsy.net/artwork/brian-kernighan-hello-world
Doom by Id Software
Parts of Windows are written in C++ I believe.
I remember had studied something like that. Right now I'm kinda sleepy, but yeah, I think you're right. This is a cool way to negate a number xD My final code was: #include "stdio.h" int main(void) { double X; scanf("%lf", &amp;X); printf("%+.4E\n", X); return 0; } \\ Just simple as that. After two days trying exhaustively, It was like a cheat lol
Hi there, So you are trying to fill a char[] variable bye adding a bunch of lettres but this doesn't work in C, you need to see the char * like an array of char and place each char un the position you want un the array. For exemple for 1, you want a I in char[0] and a \0 un char[1] , etc. + as I said you need to film thé thing char by char So a' appropriate syntax would be char[position_in_char] = 'letter'. I don't know if it was clear but if you have more spécific questions I'd ne glad to answer :)
Deep Note, that awesome THX sound. https://en.m.wikipedia.org/wiki/Deep_Note
The software on MSL (the Curiosity rover on Mars) is written in C: https://www.reddit.com/r/IAmA/comments/ybmmh/we_are_engineers_and_scientists_on_the_mars/c5u2yx4
I'm sorry, but is there a typo where it says: If the package is over *50* pounds... For the last part just add 10 * (shipmentMiles / 500) 
Hello World is probably the most famous program written in C.
I believe GIMP is written in C
Quake's renderer is written in C, though if memory serves the rest of the engine is C++.
As far as I know this applies mostly to the shell, Windows as whole is too big of a scope anyway. Also the OS X gui is mostly Objective C, but both are hardly comparable, because Linux is only a kernel and can have C++ guis like KDE.
The core is written in C but many parts of the command line interface are actually shell scripts. The built-in GUI is written in TCL and there also some Perl and Python tools.
And the inverse square root code thing.
Quite clever. I see by your "too short" example that you are counting the trailing nil in the size. I'm glad. 
&gt; `FILE* file = fopen(argv[i], "r");` This line opens a file, whose path is given as an option to this program (so it's read through `argv`), in read-only mode (that's what "r" means) and stores a handler to it in `file`. &gt; `for (int c = fgetc(file); c != EOF; c = fgetc(file))` This line loops through the whole file, reading a character every time and storing it into `c`, until the read char is `EOF`, which represents that the end of the file has been reached (`EOF` means “End Of File”, and is equivalent to the `int` value -1).
FILE* file //typedef that creates a file navigation pointer named "file" = fopen(argv[i], "r"); // open a file from the input string read only. //file is then checked to see if an error occured and if not for (int c = fgetc(file);//grab the next char c != EOF; //check that it's not the end of the file c = fgetc(file)) //and print the chars until the file ends. //repeat with all inputfiles EDIT formatting
Pretty much no games for the NES were written in C. It was assembly for the most part on consoles until the 5th generation (PS1, N64).
Thank you so much! I just tried populate my char with the char[position_in_char] thing. But it's still not compiling :/ I don't know what's wrong now, so I'll post my new code. I really appreciated your attention :)
#include "stdio.h" int main(void) { int N; int aux = 0; char N_out[9]; scanf("%d", &amp;N); int j = 0; if (N &lt; 1000 &amp;&amp; N &gt;= 500) { //N-entre 500 e 999 if (N &lt; 900) { // N-entre 500(D) e 899(DCCC) N_out[j] = "D"; } else { //N-entre 900 e 999 N_out[j] = "CM"; } j += 1; N -= 500; } if (N &gt;= 100 &amp;&amp; N &lt; 500) { //N-entre 100 e 499 if (N &lt;= 399) { //N-entre 100 e 399 aux = N / 100; N = N - 100 * aux; if (aux == 1) {N_out[j] = "C";} if (aux == 2) {N_out[j] = "CC";} if (aux == 3) {N_out[j] = "CCC";} } else { //N-entre 400 e 499 N_out[j] = "CD"; N -= 400; } j += 1; } aux = 0; if (N&gt;=50 &amp;&amp; N &lt; 100) { //N-entre 50 e 99 if (N &lt; 90) { //N-entre 50 e 89 aux = N / 10; N = N - 10 * aux; if (aux == 5){ N_out[j] = "L";} if (aux == 6){ N_out[j] = "LX";} if (aux == 7){ N_out[j] = "LXX";} if (aux == 8){ N_out[j] = "LXXX";} } else { //N-entre 90 e 99 N_out[j] = "XC"; N -= 90; } j += 1; } if (N&gt;=10 &amp;&amp; N &lt;50) { //N-entre 10 e 49 if (N &lt;= 40) { //N-entre 10 e 39 aux = N / 10; N = N - 10 * aux; if (aux == 1) { N_out[j] = "X";} if (aux == 2) { N_out[j] = "XX";} if (aux == 3) { N_out[j] = "XXX";} } else { //N-entre 40 e 49 N_out[j] = "XL"; N -= 40; } j += 1; } if (N &gt;= 1 &amp;&amp; N &lt; 10) {//N-entre 1 e 9 if (N == 1){ N_out[j] = "I";} else if (N == 2){ N_out[j] = "II";} else if (N == 3){ N_out[j] = "III";} else if (N == 4){ N_out[j] = "IV";} else if (N == 5){ N_out[j] = "V";} else if (N == 6){ N_out[j] = "VI";} else if (N == 7){ N_out[j] = "VII";} else if (N == 8){ N_out[j] = "VIII";} else if (N == 9){ N_out[j] = "IV";} N -= N; } printf("%c", N_out); return 0; }
A lot of that is TCL too, but given that TCL is implemented in C, I guess it counts to a certain extend. 
thank you
It'd be the same, except in this case the opened file is called Database. Also, as someone else commented, you should check if `file` is `NULL`, because if it is, the file couldn't be opened.
"It doesn't work" is not an error description. Please tell us a) what you tried to do, b) what you expected to happen and c) what happened instead. Also, what is your question?
Maybe you are giving the wrong inputs. I see the scanf() calls -- maybe remove those calls, and create a static array of proper inputs, and let the code feed from that instead of user run time input. If nothing else, it will speed your debugging and development time by removing typing (and associated user input errors). Once it's working nicely, put the scanf()'s back in. You might also inspect array 'A' immediately after qsort() (use printf() to print each element) to make sure the sort worked as expected. As written, you're flying blind and have no idea if that is the painpoint or not. It's horrible to lose hours of debug time --- all spent looking in the wrong place. 
Git, subversion, perl, mysql, postgres, python, ruby, linux, unix, 
This post was removed because it is not about C. Please post questions about C@T to /r/c_at.
This post was removed because it is not about C. Please post questions about C@T to /r/c_at.
you have to download more of it seriously though, people sort of think this: https://itunes.apple.com/us/app/memory-clean-monitor-free/id451444120?mt=12
Off topic. Dude, ur code is awful. How u can read it?
No, all id Tech engines up to id Tech 3 (Quake 3 Arena) were C. id Tech 4 (Doom 3) and beyond are C++.
Read the declaration from the inside out. char (*foo)[10]; // foo is a pointer to an array of 10 chars char *foo[10]; // foo is an array of 10 pointers to char Those are quite different an distinct types. 
Linux kernel, OS X kernel, Bash, Bind, Apache, nginx, lighttpd, OpenSSH, UNIX kernel, most (all?) of older UNIX userland, most of older BSD userland, GNU Binutils, Doom, Quake, parts of Git, almost all hardware drivers (except the ones written in assembly), Perl's reference implementation, the main Python implementation, Ruby's reference implementation, gcc prior to 2010, Netscape Navigator, Marble Madness, SimCity, AmigaOS, most embedded software in automobiles (control systems)... the list is kind of endless. C++ and other languages eventually took a big hit out of end-user applications (and network servers) written in C, but for kernels, drivers and embedded it's still king. Incredibly, the first version of Photoshop was done in Pascal (and 68k assembly).
http://lmgtfy.com/?q=C%20programming%20print
Agreed. I don't follow all of their philosophies, but I admire their commitment to minimalism and implementation thereof in the code they produce. It's allowed me to learn a lot about the language from traversing advanced, concise, and easily understood source. Not to mention, the tools themselves are incredibly useful; I install dwm, surf, slock, tabbed, dmenu, and st on every system where I need a GUI.
This should be the top comment.
Hey don't forget Ruby :)
Seems like it says I'm right
Please do some research before posting.
Not true at all for current developments. Historically ADA has been preferred for high integrity developments but the tools are just too expensive and take too long to make and the skills are not available and so unless the space industry shackles itself to 20 year old processors its only option would be C or something akin to GNAT which is built on GCC and therefore not cert compliant. C is far more dominant these days. 
Go get down on some http://cdecl.org/ 
The other thing that is tripping you up is that there is a difference between `"x"`, which is a string with the character 'x', along with the NULL terminator, and `'x'`, which is a single character, no terminator. You're still trying to append strings at a time in this code, too. Either do a character at a time, or use the string functions from the standard library. And in the future, don't delete your post. People after you can use it to learn from you.
GNAT Pro is widely used by most of the big players in the defense and aerospace industry. I have a few friends whose ADA code is currently on the ISS and a few European communication satellites. I believe they use GNAT Pro. I'd am really curious as to how much C code is actually in space as opposed to ground based, and how much of this C code is hand coded versus automatically generated by something like SCADE. I wish I knew more. Even though I live in Houston, I know more about ESA programing practices than I do about NASA's. 
I'll keep that in mind and rewrite my code. Thanks for your time!
You are very welcome! Please, if convenient, share with us all where the painpoint was? Some of us are very interested (I know I am). 
I changed the logic completely, actually. I was trying to make the thing work for some test cases only. I mean, I thought of some test cases that were "corner cases" and tried to code it so I'd get the answer. Code, since you are interested: http://ideone.com/3wGNNX
Sorry, I kind of wasted your time. :(
&gt; Sorry, I kind of wasted your time. :( Never! And thanks so much sharing the finished code. Yes, i see major changes. Cool! 
`char (*arrptr2)[];` is legal in C (but not C++). It may be used to point to any char array.
Oh my god. This is such a stupid mistake on my part. Thanks for catching it!!
What exactly are you trying to accomplish here? If you're wanting to play Doom or do source mods on anything reasonably modern, you'll be better off using a modern source port. If you want something that stays 100% faithful to Doom, go for Chocolate Doom. If you don't mind some more 'modern' features like Boom support and large resolution support, go for prboom. If you want to go all out and have pretty much the most featureful engine, do ZDoom or GZDoom. Also, both GDB and LLDB are debuggers. What are the diferences? [Ask Google.](http://lmgtfy.com/?q=gdb+vs+lldb)
I even looked at finding a C compiler for the NES just to give it a shot a little while ago. Hardware is so tight on NES that C is not worth it there. It's probably more plausible from Genesis/SNES on, haven't checked though.
I just want to compile DOOM from source and make it run on osx, just for fun, and also because I want to understand better how that complex (for that time) game is made in C!
I mention all this because the original source from 1997 is quirky enough that it does not run properly on modern systems. I'd suggest, then, if you want to study the source, is pick up the source to Chocolate Doom. The only changes are for modern platform compatibility - it's the same Doom v1.9 that was there on DOS, without much in the way of new features or support for things like big monitors.
I was unaware of these, thank you!
Just like a pointer of type `X *` can point to an element of an `X[n]` array, a pointer of type `X (*)[10]` can point to an element of an `X[n][10]` array: http://i.imgur.com/ugEncg8.png Note how `p` points to the entire array `a[0]`, not just the element `a[0][0]`.
Haha, thanks! It's good to know I'm not babbling nonsense :) but I still think there is more to gain from looking at the source of Chocolate Doom or similar, rather than trying to work with antiquated code that won't compile without serious changes. Either way, I hope OP finds what they're looking for.
Thank you for you answer, I add informations here and then in the head also. I use gcc to compile, and flag -g. I don't use gdb because it's not that simple to make it work on OSX, and lldb works by default. I used -g flag many times, on many single-file sources, and it always worked with lldb. I have the copy of the game .wad file. Valgrind is not supported by osx 10.11 yet so I can't use it obviously ;) I'm interested in learning how to adjust C code through years and different systems, not in having a fully functional game ;)
I'm asking how to compile code in order to have everything linked for debug and showing the source code during debug, not the assembly equivalent. With single-file sources gcc -g is enough, here I have a bunch of .c and .h files and I don't know how to do this 
All good to know, thank you for the update! As far as I can tell, OSX uses the DWARF format for debugging data, or at the very least shouldn't use the stabs format, so increasing the debug level to `-g3` shouldn't hurt, and might provide some additional insight. Other than that, I'm not sure what there is to be done. Could you share the output from LLDB via [pastebin](http://pastebin.com/) or [github gist](https://gist.github.com/)?
I am just now reading this. Have you never before used `make`? It is a utility used to ease the compilation of large, multi-file projects. For instance, in the `linuxdoom-1.10` directory there is a Makefile meant to be used with `make`; if you `cd` into this directory and then `make` (or `make Makefile`, by default `make` will use any Makefile in the current directory) it will compile and link all the source files into an executable.
Yes I use make, but in Makefile it uses gcc to compile. 
POSIX reserves the entire namespace of identifiers ending in `_t` for future expansions. I highly recommend you not to name your identifiers `something_t` unless you are implementing operating system libraries that might one day be incorporated into / considered by POSIX.
A neat short form that you find in many c projects: if (!strcmp(stringA, stringB)) { // handle equal string }
 I don't know OSX nor Doom. Is Quartz related to one of those? If it's their X11 library, then there should be a way to tell your debugger to use the debug versions. If looks like the problem is in a call to XQueryExtensions, in one of the init routines. You could set breaks on that function to print the stack each time. Maybe the stack is getting messed up? 
It can be very instructive to force your program to fail on purpose. For example, try to fopen a file that you know for sure does not exist - how does your program behave? Does it report the error and handle it cleanly? If you've personally caused your program to hit every one of its possible error conditions and ensured it worked well and reliably with all of them your program's likely pretty solid. 
That is fascinating, I take it you are in US aerospace. I started out studying aerospace engineering in the late 80s, but the market was so bad then that even our professors told us to switch majors. I went into computer science. Ironically my first paying job was with an aerospace company where I spent a couple of years programming mainly COBOL. It seemed like a waste of time then, but now I get to write my paychecks because COBOL programmers are in high demand, the language has made a comeback and the tools have improved. I come across a Ada applications in finance and insurance regularly with their own teams of developers so Ada experience can't be that rare. My guess is that a lot of the US aerospace dysfunction has to do with the 80s downturn and the fact that so few young people went into aerospace and were never exposed to existing practices. Most of the US aerospace programmers I know are either about to retire or got into aerospace later in their careers. 
Which program do you use in this screenshot?
Logic is separate from language, so what you're asking doesn't really make sense.
ok so no logic is needed in a language?
Logic is something you express using language, not defined by it. If you're looking to improve problem solving skills, practice solving problems from places like project Euler, hacker rank, and code wars, etc.
You can change the compiler used. Make is basically a way of automating what you'd enter at the command line.
thank you
You're getting assembly because it's a segfault in a library that doesn't have debug information or source code. It's probably caused by the doom source passing a bad pointer to a library. You need a stack trace to look higher up in the call stack. I don't know about lldb, but in gdb the command would be 'where'. I'm guessing the issue is related to code assuming a 32 bit environment.
My mistake; I misunderstood the nature of your above comment.
Sorry for the delay; I had to sleep and once I woke up I got busy. I suspect the assembly you're looking at may be from a section of the Quartz library that is written in assembly, or something similar. /u/raevnos seems to have a better idea of what may be going on and what you might need to do. I'm fairly out of my element here. I hope you get it working! Please keep us all up to date.
`compChoice=((int)compChoice==0) ? "heads" : "tails";` should give you a compilation error. It's important to pay attention to the messages that your compiler tells you. (Anything saying "warning" should be treated as an error too).
find this https://www.quora.com/How-do-I-improve-logic-building-skills-in-a-Programming-language
You can actually use LGPL code in non-GPL projects, all you have to do is include a notice that you are using LGPL licensed software and a download link or something similar. You can even see this with the PlayStation 3 and 4, there's license information hidden deep in the settings menu, where Sony mentions some LGPL and MIT licensed projects.
&gt;In creating a circular queue which is better, initializing both front and rear to 0 or -1? Why are you initializing values at all? 
so the program doesn't behave differently every time I run it...
 /* This program stimulates time-sharing. Programmer: Date Started:January 26, 2016 Date Finished:January 28, 2016 */ #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;stdbool.h&gt; #include&lt;windows.h&gt; #define M 5 typedef struct{ char pName[20]; int du; }PROCESS; typedef struct{ PROCESS que[M]; int front, rear; }QUEUE; void Process(void); void addProcess(QUEUE*); void createCQue(QUEUE*); void enCQueue(QUEUE*, PROCESS); PROCESS deCQueue(QUEUE*); void evaluate(QUEUE*); bool isFull(int, int); bool isEmpty(int, int); void createCQue(QUEUE *q){ int i; for(i=0;i&lt;M;i++) { q-&gt;que[i].du=0; memset(q-&gt;que[i].pName,'\0',M); } q-&gt;front=-1; //my question q-&gt;rear=-1; } bool isFull(int rear, int front){ bool full=true; if(front!=(rear+1)%M) full=false; return full; } void enCQueue(QUEUE *q, PROCESS a){ bool full; full=isFull(q-&gt;rear, q-&gt;front); if(!full) { q-&gt;que[q-&gt;rear]=a; q-&gt;rear=(q-&gt;rear+1)%M; } else { printf("Error: queue is full...\n"); } } PROCESS deCQueue(QUEUE *q){ PROCESS data; bool empty; empty=isEmpty(q-&gt;rear, q-&gt;front); if(!empty) { data=q-&gt;que[q-&gt;front]; q-&gt;front=(q-&gt;front+1)%M; } else { printf("Error: queue is empty...\n"); } return data; } bool isEmpty(int rear, int front){ bool empty=true; if(rear!=front) empty=false; return empty; } int main (void){ Process(); getch(); return 0; } void Process(void){ int i; QUEUE q; createCQue(&amp;q); addProcess(&amp;q); evaluate(&amp;q); } void evaluate(QUEUE *q){ PROCESS t; int i=0; bool empty=false; system("cls"); empty=isEmpty(q-&gt;rear, q-&gt;front); while(!empty) { t=deCQueue(q); if(t.du&lt;=10) { printf("Process name: %s\nRemaining time: 0\n", t.pName); // sleep(t.du*1000); } else { t.du-=10; printf("Process name: %s\nRemaining time: %d\n",t.pName, t.du); // sleep(10000); enCQueue(q, t); } empty=isEmpty(q-&gt;rear,q-&gt;front); } printf("All process done.."); } void addProcess(QUEUE *q){ int i,du; PROCESS a; for(i=0;i&lt;M;i++) { printf("Add #%d process name: ", i+1); gets(a.pName); do{ printf("Process duration: "); scanf("%d", &amp;a.du); if(a.du&lt;=0) printf("Duration should be greater than 0.\n"); while(getchar()!='\n'); }while(a.du&lt;=0); enCQueue(q, a); } getch(); } Edit: readable Edit2: added comment on code for my question
i tried to take out the initialization on createQueue. program doesnt work.
This is illegible. Indent each line with 4 spaces, or use a website like gist.
done. sorry xd
Oh, you mean initializing what you are storing to be the front/rear indices here. It depends on how you want to do it. You need to distinguish full from empty some how. There are a few ways to do it. (edit: I had originally posted a wrong way of doing it. the wikipedia article gives better ways to do it: https://en.wikipedia.org/wiki/Circular_buffer) I thought you meant initializing the data, which you are doing here: for(i=0;i&lt;M;i++) { q-&gt;que[i].du=0; memset(q-&gt;que[i].pName,'\0',M); } that is unnecessary since you aren't going to read any data until it had been assigned. (Some people will prefer to initialize data though, so I wouldn't harp that much on it, except that I thought you were using that initialization for something that didn't make sense).
“It doesn't work” is not an error description. Please specify what happens and what you expected to happen instead.
(Author here.) Exactly right. LGPL isn't a big deal with dynamic linking, but it's a lot of friction when used with static linking, which is exactly how I'd want to use a libc in this case. I'd need to distribute either my application's source code or its unlinked object files. This wouldn't matter too much for an open source project, but it's absolutely not an option if I wanted to use it at work. 
Homeworld. Quake III. OpenGL. SDL. Java (pre-Oracle, at least). Python.
I'm confused. if plibc is LGPL doesn't that mean that your proprietary software can statically link to it without violating GPL? EDIT: Nm. [this explains it](http://stackoverflow.com/questions/10130143/gpl-lgpl-and-static-linking) it looks like if you statically link it then you have to explain how to statically link it with something else. either way, I think using plibc as a dll is a pretty decent way of working around the msvcrt requirement.
since you're dealing with integers, all your formating specifiers (%blah) should be %d for scanf and printf. 
Mruby doesn't produce small, freestanding Windows applications ([it uses glibc](https://github.com/hone/mruby-cli/issues/37)), so it's not even on topic if you ignore the subreddit.
You mean the front (head) index and the rear (tail) index, not the actual values stored there. That's why people are confused. Initialize both to zero, when you get an push_front, just increment tail by one. If you get a push back, set head to (capacity - 1) and keep tail at zero. This is much more natural and makes your code simpler. I've written a high performance CB for production code. Great little data structure. It's a pain in the butt to support insert middle, and totally defeats the purpose of a CB, so I would much recommend avoiding it.
Remember that `#include` just dumps the contents of the file in, so some investigating for the situation that works: - try calling a stdio function inside main and compile - try calling a stdio function outside main and compile
Do you get them it both modes ?
I got it. It's all about nested functions.
OK. Thank you!
I'm surprised stdio.h contains function definitions, actually. I guess for optimization reasons you might want some functions inlined.
It sounds like you may need to learn how to use a debugger to step through your code. With a good debugger, you can execute your program line by line and see where it is deviating from what you expect. This is an essential tool if you are going to do any programming. Further reading: [How to debug small programs](http://ericlippert.com/2014/03/05/how-to-debug-small-programs/). 
Note that it is [redundant and potentially dangerous to cast the result of malloc and friends in C](http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc). 
What do you already know? What is CSE?
Check this: http://c.learncodethehardway.org/book/
Hi ! I'm in a french programming school, and we mainly learn C in the first few year, I can give you our ressources if you want to.
&gt; Strange it may seem, I have no idea of programming languages Probably not.
First of all, don't learn C first, or at all if you don't have a reason to. Learn Go or Rust or even JavaScript instead, and then come back to C later if you are still interested. They all do a better job than C at presenting a coherent language abstraction layer, which means that the errors you get will make more sense and you'll have an easier time figuring out what you did wrong. Once you get the general concepts of programming, C will be easier to pick up. Get a C tutorial ("The C Programming Language" is a good place to start; the first half is tutorial material). Get a C reference book ("The C Programming Language" second half will get you started, but you'll want something more comprehensive and covering C99, like Harbison &amp; Steele). Now write lots of C programs, debug them, make sure you understand what went wrong with every bug. Use the reference book for that; there are lots of surprising cases where things you might think are valid C aren't. Also, read lots of C programs; figure out how they work and why they were written the way they are. Rewrite bits of them to see if you understand correctly and then figure out what you misunderstood when that breaks them. If you see something that you don't understand, work hard to figure it out. See if you can do interesting things you see in your own little test programs. Once you start to feel comfortable, get a copy of the language specification and find out what you have been misunderstanding all along and what kinds of undefined behavior you haven't been watching out for. Read through all your programs and fix them again. Make them portable and as conforming as possible to the standard. Learn how to use advanced debug and profile tools. Learn the memory model and other architectural details of the platform you'll be using. Learn at least how to read the basic instruction set that your compiler emits in assembly form. Learn your platform's libraries; learn your platform's ABI. Then learn them for *another* platform to see the sorts of things that vary between them. If all that sounds like a ridiculous amount of work--it is, but it's the sort of stuff you need to know to use C well. If it doesn't sound fun, pick a different language to learn; you will either not enjoy C or you will enjoy it but make a lot of messes for other people to clean up. Either way is not doing yourself any favors.
Mostly, but my school is a little bit weird, it's a free peer to peer school, we don't have any course/lesson or even teacher. They just gave us increasingly harder project to do, so I could give you some translation of my own in exchange of the correction of the translation (my school is looking to translate all his ressource in English)
People have said particularly bad things about LCTHW, on mobile so no link though EDIT: https://www.reddit.com/r/C_Programming/comments/3rd4dg/peer_review_learn_c_the_hard_way_by_zed_shaw_pub/ Here's the post I thought of in particular. The author seems to have deleted the posting, but it was asking for peer review on LCTHW. Top comment explicitly expresses his dislike of the book. Ought to read the link within.
A similar question was asked some days ago. You might want to look [at the responses](https://www.reddit.com/r/C_Programming/comments/43idvw/-).
I use cscope often for the linux kernel. Works great. 
Good list of recommended C books here: https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list 
What is the name of your school ?
Does my school's name matter ?
[LXR](http://lxr.sourceforge.net/en/index.php) source browser. Originally written for Linux, but can index any source you throw at it. It's not much more than "find all definitions" and "find all uses", plus an indexed full-text search, but that's 98% of what you need. I set it up within a few months of starting at my company, and it's simply indispensable. When you have a few million SLOC, you *need* tools in order to browse through it. A good IDE can give you similar features, but only for one project at a time. Ours has dozens or hundreds of projects (depending on how you like to count them), so limiting myself to only seeing one project at a time wouldn't be acceptable.
Okay, I am from MNNIT ALLAHABAD. See my school is very good and it is my entire fault that I don't know programming. Please help me.
You never heard of 42 before ? The school is 3 years old, a few people are starting to graduate and I'm there since November and I'm really enjoying myself. It's a real pleasure to learn there.
Sure I heard of it, but never heard of their "teaching" method. To me it sounds a bit weird but at least it is free compared to all the private schools which are very expensive for no reasons.
I think you mean "Kernighan and Ritchie". Dennis Ritchie was certainly a driving force in the creation of the language, but Brian Kernighan wasn't as strong a contributor. C was mostly the result of Ken Thompson and Dennis Ritchie.
If you are interested I could explain you more in depth how it work.
What I found strange is gcc's different reaction on same code on different optimization levels. Now I understand how it works technically, so I'm OK.
K&amp;R ("The C Programming Language 2nd edition") is short, sweet, easy to read, and will give you everything you need to know to use the language. 
Yeah, that was not expected, cause they always say that headers are for declarations :) 
Uh, well, cygwin is just a Unix-style shell environment running on Windows. If you are using Windows-specific functionality, you would probably be best off just dual-booting into Windows on your MacBook. But, you're probably not if you're just doing C programming assignements. In that case, you can use Terminal and any text editor, either from the shell, or install another app. If you install XCode, you will get "clang", which is the C compiler. You might already have it. Try opening a shell with Terminal and type "which clang" or "which gcc". If they return a path, you have a compiler already installed. 
~~http://www.cprogramming.com/xcode.html~~ ~~http://masters-of-the-void.com/~~ EDIT: You can just install xcode command line utilities to do what you need.
So basically Cygwin creates a [POSIX-compliant environment](https://en.wikipedia.org/wiki/POSIX) for Windows. Mac is already POSIX-compliant, so if you're on Mac, you don't need Cygwin.
You can use the built in terminal, but I prefer iTerm2. For text editing there's Textwrangler that's free, and similar to notepad++ 
No. Kensington and Remington invented C. I remember because Kensington also invented those laptop lock things, and Remington invented guns.
I've tried learning a language quite a few times during my life in IT. I've bought different books (and online courses) of different languages and never finished any. Yet I picked up a C book that became the first resource that I've ever completed. It really takes you step by step with chapters that are quite brief (around 7 pages each including the code samples), this (among other reasons) became key to how I advanced through the book with ease as opposed to feeling the often drag I've felt in previous books where typically chapters are of around 30 pages. It's been a great first book on programming. C Programming Absolute Beginner's Guide, 3rd Edition: http://www.amazon.com/gp/aw/d/0789751984/ref=mp_s_a_1_1?qid=1454457666&amp;amp;sr=8-1&amp;amp;pi=SL75_QL70&amp;amp;keywords=C+programming+for+the+absolute
That's cool, we were all new to this at some point in our lives. Nobody here was born with a copy of K&amp;R :) For C programming OS X is actually a lot "nicer" than Windows as the primary development tools use Clang/LLVM or you can easily get a proper build of GCC which will work just fine. On Windows we have to resort to Cygwin or MinGW-W64 for such things. Yes we can use MSVC but until very recently C programming with MSVC was dire. I mean it still isn't great but at least with MSVC14 they support C99. 
If you have 30 independent macros, then at some point you'll have to type 30 names and 30 values. Is the #define part the issue? Type out the parts you have to and use a regex to add in the #define. Don't want to look at it? Put it in a header file. Don't want it in your source code at all? Put it in your compiler options (`gcc -DFOO=0`) Or are you looking for some kind of a configuration file, or to leverage environment variables? I guess it comes down to why you don't want to use #defines
&gt; printf("Your average grade is: %.2f\n", &amp;average); Pass `average`, not `&amp;average`, to `printf`. Turn on all warnings in your compiler, and pay attention to what they say. A good compiler may warn you about mistakes like this. &gt; system("pause"); Take this out. It is nonportable and unnecessary.
oh my god......thank you....I've literally been here for 2 hours........lol
I like Ada as a language for building things that need to work, but it's not a small language. I think part of the issue with engineers is that the learning curve is rather steep. You can keep pretty much all of C in your head. That combined with the fact so many companies don't invest in training, probably means it won't be a popular language choice among engineers. For example, a company I work for used to charge 2,000 to 2,500 USD for 1 week developer training courses. Now they give them away for free but clients won't give their people the time off to take training. [Edit: I should mention that the same clients spend between 5 and 7 figures for software licenses and then complain that they can't find anyone that knows the software.]
I didn't want to use an enum because it's very object-like which is inconvenient for me. To use this code, wouldn't I then have to make an instance for each value I need? like constants foo = FOO; constants bar = BAR; constants something = SOMETHING; That's no more convenient than writing out my 30 macros. Is there a way that I can use the values inline without making instances of the enum?
I'm not worried about the 5 minutes I'm going to spend typing this code block. I'm concerned about doing it the "best" way. I like code that shows good planning, code reuse, minimal code, and readability. I'm looking for an interesting and clever solution, not a way to type faster. I want to learn a better way to do something so I know how to do it again some other time. 
&gt; code that shows good planning, code reuse, minimal code, and readability An interesting and clever #define alternative will be the exact opposite of this. Future self and others looking at your code know what defines are and how they work. There isn't really a need to improve on them.
You could put them in a header file.
But you don't have to make instances of the enum. They're just "named numbers". enum test { FOO = 10 }; if (FOO == 10) { bar(); } That is perfectly valid.
You have `while(1)` as the condition for your loop, ~~and nothing within to break out of it~~ EDIT: See below. What do you expect to happen? One option is to create a new variable, something like `int keepGoing = 1`. Change your loop to `while(keepGoing)`, and set it to 0 within the loop when you want to exit.
`printf` is a very complex function. It does not map to a single machine instruction—it probably becomes thousands of machine instructions.
~~Not the way you have it written.~~ EDIT: Yes, the `return` statements will break out of the loop. On second examination, that might be working properly. Your issue is the one I mention below. Also, your `case` statements are wrong. You're checking for the value `'0'` but setting `state` to be `0`. Remove the quotes from your `case` statements.
Your compiler should provide a switch to show the assembly code. As for ways that the computational complexity printf("cat"); Would be less complex than printf("%d",2.02); Since the latter would involve more memory and string parsing. 
What compiler do you use?
source insight is good
You would need to look at the implementation of the function in the libc that you're using. There's nothing special about `printf()`, it's a regular function written in C, the same as any function you write yourself. And as others have mentioned, this is an incredibly complex function that has to be able to do a lot of things. Moreover, the libc implementation is going to want to share as much as possible between the entire family (`printf()`, `fprintf()`, `snprintf()`, `sprintf()`, `vfprintf()`, `vprintf()`, `vsnprintf()`, `vsprintf()`, etc.) which adds extra complexity to the implementation, for example there's probably a way to treat a string as a `FILE *` so that everything can be implemented on top of `vfprintf()`, even the ones that print to a string. Here's an example: $ cat foo.c #include &lt;stdio.h&gt; int main(void) { printf("%.4f\n", 3.1415926535897932); } $ gcc -Wall -Wextra -pedantic -std=c11 -O2 -static foo.c -o foo $ perf stat ./foo 3.1416 Performance counter stats for './foo': 0.341404 task-clock (msec) # 0.441 CPUs utilized 2 context-switches # 0.006 M/sec 0 cpu-migrations # 0.000 K/sec 23 page-faults # 0.067 M/sec 920,715 cycles # 2.697 GHz 656,371 stalled-cycles-frontend # 71.29% frontend cycles idle 544,316 stalled-cycles-backend # 59.12% backend cycles idle 257,978 instructions # 0.28 insns per cycle # 2.54 stalled cycles per insn 47,155 branches # 138.121 M/sec &lt;not counted&gt; branch-misses 0.000774251 seconds time elapsed This program took a quarter of a million instructions to format a double. (This count will also include the startup code, so this is an overestimate of the amount of work done by `printf()`, but probably not by much. I used static linking to avoid the significant amount of overhead of the dynamic linker at startup. Edit: a little experimentation shows that this is wrong, and that the startup code is the majority. The `printf()` code itself takes around ten thousand instructions, which is still a lot for something that seems simple.) 
Thank you for being friendly and helpful! Honestly I know basically nothing cygwin was just what we used in class and its all I knew what to type into lol. To be honest a lot of this stuff sounds like a foreign language to me but i'm new and committed and I got time to learn so thank you all again. 
Yeah programming languages and all the related areas are pretty weird when you first start out. It gets much easier once you grok* things. Acronyms, strange names for common things, etc. will come in time. Google is your best friend when it comes to programming so learn how to use it properly. Something to know from the start is that a lot of people don't like lazy questions. If you spend half an hour on Google or StackOverflow looking for some answers and you still don't get it then mention that so people see you are trying to work it out on your own but are stuck. Everyone gets stuck on things, even experts with 30+ years experience find some things hard. There is lots of parts of things to know and you can't be an expert in them all. Having said that there is a very small number of programmers who are just not helpful. At all! If you meet one, and you will, just ignore them and move on. Don't let it get you down if they attack you (they will!) for not understanding something. Maybe they are just having a bad day in their personal life or maybe they are just a dick but whatever the reason don't dwell on it or feel stupid, just go and look for help somewhere else. Also think of programming like a sport or other skill. Sure you might have some natural talent (or not) but that doesn't mean you don't need to practice. You will find some things come easily to you and some things take days or weeks (or years!) to really understand. Everyone has this too it is just that some people find different things easy (and hard) to you. If you don't understand something the best thing to do is practice! Just code. Code and code and code. Doesn't matter if the program is pointless in what it does if it helps you get better at something you kinda suck at then it is worth it. Also learn how to use Git and github.com. Make an account and get Git installed on your computer. Learning about version control at the beginning is the best thing you can do as you will need to know how to all works at some point so just learn and benefit from it early on. Also when you figure something out that has been vexing you for a while make sure you document that code and stick it on github! Trust me you will be so glad you did as you will easily be able to look back on it in the future and hopefully not have to spend days working out how it all works again. * Not everyone knows the meaning of Grok so have a read of https://en.wikipedia.org/wiki/Grok, in short it means to understand something thoroughly.
Yeah I read that over the Christmas holidays also, made me laugh :)
Functions like `printf()` are implemented in the libc, the C library. You can find the source code of some implementations on the internet, although I doubt that you are going to find the Microsoft one. For example, here is OpenBSD's [vfprintf](http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/lib/libc/stdio/vfprintf.c?rev=1.72&amp;content-type=text/x-cvsweb-markup) (the underlying function `printf` calls), but be careful, it's one of the more complex functions in the libc.
This is basically what I always use for timing, however I use rdtsc**p** as it forces a serialization of the processor. I doubt it would affect printf, but theoretically it could affect smaller pieces of code by e.g. moving memory accesses outside of the timed scope.
I put some links on r/learnc
Thanks, I'm used to an embedded environment, where neither exist. I have `uint16 start= TIMER_REGISTER;` Looks like those SO answers need improvement.
OS X comes pre-installed with emacs (and vi, possibly vim?) although I would recommend the graphical version eg from homebrew.
Damn, nice words...
Not 100% sure if this is what you are looking for, but this (http://stackoverflow.com/questions/1779715/how-to-get-mac-address-of-your-machine-using-a-c-program) may help. Also, you have submitted us C code, not C++... If you want a solution in C++, you will have to look to a different subreddit.
Thanks but what would i open if there is no item called ipconfig like there is for windows. The only thing i was able to find that was similiarly close was to go to Untitled(harddrive)\\library\\preferences\\com.apple.networkextension.cache.plist 
Reading a file isn't what that code is doing. The IP address isn't stored in a file. system() is a function that lets you run other programs that are on your system. In this case your teacher's program is using system() to run another program called ipconfig. That program is doing the work of looking up the IP address and printing it out. There's a few strange things about this that I assume are quirks of windows: they've written the full path to the ipconfig program, it looks like they expect their version of ipconfig to return an address without passing it any arguments, and the system("pause") call looks like a weird windows only way to wait for the user to hit a key. A mac version would be a little different. Something like this would probably get you there: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main () { system("ipconfig getifaddr en0"); getchar(); return(0); } If you have multiple network interfaces available you might have to do some work first to get a list of them. 
Thank you so much, that made everything make perfect sense. i thought her program was running an instance of a file, but its an actual command. 
It was a C question. The post title isn't accurate. Should probably read the questions before deleting them I'd think... 
It's a question about using C's stdlib.h It has nothing to do with C++
Sorry - I missed the fact that you wanted to do this on a Mac - I thought you just wanted to get hold of the IP address inside a Windows program. On Mac OS X you can use either `ipconfig` or `ifconfig` and then either invoke this via `system()` or `popen()` as appropriate.
The `system()` function also exists in C++. The `stdlib.h` header also exists in C++. This is not a proper argument for this being a C question.
Theoretical courses emphasized on concepts with a small bit of programming. Coding was required in practical courses only and even though I couldn't do the programs, I would easily get B or B+. Please suggest me what I can do. 
Check out Beej's guides http://beej.us/guide/bgnet/. They are highly regarded as some of the best guides to network programming in C. 
These instructions are telling him he needs to get a Mac Developer account, or go to the Apple Store. He doesn't need to do that. He just needs to install the xcode command line utilities, and he can do that by typing a command at the command line.
This is the correct answer. Helped me out when I was learning network programming.
Thanks very much! I'll dig in soon
Apologies; didn't mean to mislead.
You're right, i think I misunderstood how enumeration works in C! This is probably what I need. Thanks.
`fgets()` includes the newline in the buffer.(*) If you type "abcba", the buffer contains `"abcba\n"` which is not a palindrome. You need to remove the newline first. There are a variety of ways of doing that, but try to figure it out for yourself first before looking it up as a learning exercise. Also, contrary to your comment your loop does not include the null terminator when calculating the length. But that's good, because it's what you want. Why not just use `strlen()` instead, though? Also, `NULL` is the null pointer, which is completely different from the character null. You should not use `NULL` as a character value, despite it giving the appearance of working. Use `0` or `'\0'` to refer to the null character. (*) It doesn't always include a newline, such as in the case where it reaches the end of file condition without a trailing newline. This is somewhat common when dealing with text files, as users don't always terminate that final line. Any code for trimming off a trailing newline in a buffer read by `fgets()` needs to deal with this possibility without invoking undefined behavior and without mangling the string (e.g. by always trimming the last character regardless of what it is.) 
&gt; `while(x=0);` Nine out of ten times, this is not what you want. Maybe you prefer `x==0`? (Taking into account that you don't seem to want to print more than one triangle, you could remove the `do` and `while` altogether.)
You're reading from stdin, so you don't know whether you're actually reading from a file or not. A user could run your program with stdin redirected to be file input. But that's actually a red herring, because it doesn't matter whether the input is coming from a file, or a console/terminal, or any other sort of stream. It's possible in all cases to signal the end of file condition without a trailing newline, so it's something that you always have to deal with. At a terminal on most Unix-like systems for example, you can type Ctrl-D to signal the end of file condition before typing anything and without pressing return and the standard input stream will be closed having read nothing, which means the buffer filled by `fgets()` will have length zero. That's a trap if you blindly take the length and subtract one to get the index of the last character. You can also type some characters and then press Ctrl-D twice without pressing return and those characters will enter the stream without a trailing newline. It's impossible to use `gets()` safely, so it should never be used. In the latest version of the C standard (C11) the function has been removed.
I'll just do the cutting and checking if input is empty then. Never knew all these... damn
Yeah, can also recommend it! 
So, one of the most important things you want to think about is how you will transition from building the top half of the triangle vs the bottom half. Perhaps if you considered *IF* one of your variables, say `i`, was larger than some value, you would reverse your process here... Another hint is that you can implement this with only two local variables, i, j, and a global `#define` variable indicating the maximum "height of your triangle". In the case of your post it would be 9. Finally, think logically about where you would want to stop printing larger and larger asterics lines, and start printing smaller ones. From there, how would you then print smaller lines while still iterating through your wile loop. If you are still reading this, a small giveaway is that you will need something along the lines of `if ( i &lt; SOMETHING) {//....} else { //....}`. Once you chew on that for a bit come back if you have more trouble.
Why do you use `(*a).b`? There's the `-&gt;` operator for that purpose. And please don't suffix your own types with `_t`, that suffix is reserved by POSIX for system types. Could you show us the code you use to add elements as well? I'd like to have enough code to reproduce your problem myself.
can you also declare it ? ie. BinarySearch(key,values, static int m = MIDPOINT(min,max) ) , also it would have to be declared twice, once one each call to binarysearch, in which that case i would prefer to just use the macro MIDPOINT(min,max) instead to keep it updated, anyway im getting pretty confused at all of this at this point
No, that's something you need an extra statement for.
how about this then, since m is static and therefore preserved across function calls, it shouldn't matter what values is passed on to, since it gets updated as soon as it reaches that initial values[m] &lt; key condition, the updated code is thus : int BinarySearch(int key, int values[], int min , static int m) { return (max &lt; min ) ? -1 : ((m=MIDPOINT(min,max),values[m] &lt; key) ? BinarySearch(key, values,++m, max ,0) : (values [m] &gt; key ? BinarySearch(key, values, min, --m,0) : key )); }
You cannot make a function parameter `static`.
well scratch that then, just declare m somewhere and in theory this would work int BinarySearch(int key, int values[], int min ,int max); int m; int main() { //other code } int BinarySearch(int key, int values[], int min ,int max) { return (max &lt; min ) ? -1 : ((m=MIDPOINT(min,max),values[m] &lt; key) ? BinarySearch(key, values,++m, max ) : (values [m] &gt; key ? BinarySearch(key, values, min, --m) : key )); } 
since i was declaring it in the body of the recursive fxn before, and forgot to remove it tho, i read somwhere if declared within the fxn, then each recursive call will be accessing the same static variable, overwriting values stored in the variable , thats no longer an issue since its declared in main
This is a large portion of everything I've ever wanted. I can't thank you enough.
No need to thank me I just posted the link. You could drop Beej an email to thank him though :)
`qsort(...)` is technically one line ;)
Why are you bothering to reverse the string? Do you think there is a way to can use a look to check if a string is a palindrome using logic similar to what you use to reverse the string?
I thought the joke was going to be a call to `exec` calling out to a browser somehow. Still funny.
I'll admit that I've never actually used it, but [zeromq](http://zeromq.org/) seems to be a great way to get into network programming.
I'm also curious why all the casting from linked_list_t to list_t. Why not just use list_t if that's always the desired type? Also, probably unrelated, but *list_t-&gt;count* is never updated, yet defined.
Haha. love it.
Not sure why this is so downvoted. it's solid advice.
Yeah, someone else pointed that out. I was trying to use `-&gt;`, but got a syntax error. I automatically assumed c didn't have it, but must have been using it incorrectly.
In Remove_From_Beginning you're not updating to_delete-&gt;next-&gt;prev to point at to_delete_prev When removing an item from a doubly linked list you always need to update 2 pointers. If you make the ends of the list point at the anchor then you'll have a properly circular list and you'll be able to remove some of the special cases you have. 
Thanks! But I'm looking at my code, and I change `head` to be the second element in the list, then change `head-&gt;prev ` to 0 since it's the beginning of the list. Wouldn't that be correct? 
You can have a pointer to a multidimensional array, like this: (*pmyarray)[100][100] = &amp;myarray But notice you need to use the address-of operator. Without the address-of operator, you are converting the array to a pointer to the first element. The elements of a two-dimensional array are one-dimensional arrays, so that's why you have only one dimension in the pointer.
 they have different types char (*ptr_stuff)[100] = myarray; char (*ptr_stuff)[100] = &amp;(myarray[0])//same thing char (*pmyarray)[100][100] =&amp;myarray 
 int x = 2 * 1.-t; This means (2 * 1) - t which is 2, since t is 0. x is always 2. By messing up your printf specifiers you're not printing the true value of x.
A lot of game programming even once the switch to C++ happened was still very much C programming with a few C++ bits.
Ok, now I feel stupid. It was very misleading because there was no space after **1.**. I still can't get why messing up with this specifier cause printf to give strange values. After this: int x = 2 * 1.-t; x is always 2. Then why printing **now** completely unrelated variable (I assume it is unrelated since we've done with multiplication before) **t** with wrong specifiers is also giving wrong value for **x** with correct specifier.
printf is declared as `printf(char *format string,...)`. The `...` means it can take any number of arguments after the 1st. It relies on the format string to know what the remaining arguments are Conceptually, when you do printf("t=%f, x=%d\n", t, x); it pushes 8 bytes of t onto the stack, then 4 bytes of x. When printf exectutes, it sees %f so it pops 8 bytes and prints it as a float. Then it sees %d, so it pops 4 bytes and prints it as an int And when you do printf("t=%lu, x=%d\n", t, x); it pushes 8 bytes of t onto the stack, then 4 bytes of x. (The same as before) And when printf exectutes, it sees %lu so it pops *4* bytes and prints it as an unsigned it. Then it sees %d, so it pops 4 bytes and prints it as an int. But those 4 bytes weren't the 4 bytes corresponding to x. They were 4 bytes corresponding to the 2nd half of t. (Depending on your CPU, compiler, sizes of your types, etc, the above isn't *exactly* what's happening. (e.g. the parameters are really pushed in the opposite order) )
In that case you would have to use: (*p2myarray)[100][100] = '!'; But the 1D-array pointer works just as well, with less typing.
That's great, hahaha
There's no speculation, it's well known that the Windows kernel is programmed in C and ASM and talked about amongst MS Kernel Programmers blog entries.
ya that is neat. Please share with the rest of the class
Just read [the official manual](http://sourceware.org/gdb/current/onlinedocs/gdb/) front to back. It's an easy read and you'll discover all sorts of new things. For example, did you know on some platforms you can step programs backwards?
Also, on the line that reads `for(y = 0; x &lt; y; y++) {` are you really wanting to check if x is less than y?
Please use a descriptive title for your post. "C&amp;nbsp;question" is a completely non-descriptive title in /r/C_Programming.
I will remember that for next time! Sorry!
Use a pin change interrupt on your Rx pin. Unless Arduino has hijacked it, in which case you would need to add whatever you're looking to do into the Arduino source files. 
the reason i looked into this is not having to change the existing code. I used the 1d array pointer with success for that now. Thanks for explaining!
asynchronous code is still not fun with gdb. lldb handles that a tiny bit better but still not fun either.
This does not appear to be C.
This isn't really a C question, so much as a microcontroller or Arduino ( if that's what you're using ) specific question. Try /r/Arduino/ or /r/avr/
It's not C, it's not even a variant of C. It's a programming language created by someone else. The syntax is not even close to C.
To continue down your current path, use [AttachInterrupt](https://www.arduino.cc/en/Reference/AttachInterrupt) to get an interrupt on your rx line and then tell your main code to go read data. But looking at your code it looks like you're just reinventing I2C. Arduino can do I2C through it's [Wire](https://www.arduino.cc/en/Tutorial/MasterReader) library. It would be more robust than your custom bit-bang solution.
Can't you use the interactive generator for that purpose? This is what I use when I want to change a signal by pressing a button.
Don't worry!
Are you talking about the Panel Designer?
No. I don't. Check out page 18 of the attached link. http://vector.com/portal/medien/cmc/info/CANoe_ProductInformation_EN.pdf Anyhow, if you want to run your script you first have to configure your "Simulation Setup" correctly... Unfortunately I do not have my company pc nearby so I cannot help you alot.
Oh I tried this, I put all the signals I wanted in here and I only seem to receive/detect information on the tracer, but it will not send. The tracer says the message is set as Tx but I do not see any changes in the system.
Did you add the IG in your simulation setup? Is it activated? Which nodes do you have there and which one are activated? 
Sorry, CAPL is not C. Your post is off-topic, this subreddit is about C programming only. Please ask elsewhere. Perhaps you can find help in one of the generic subreddits listed in the sidebar?
I don't think I'd call casting malloc() a 64 bit specific error. It's poor C no matter the word size.
In [a more recent blog post from the same guy](http://www.viva64.com/en/b/0374/), he posts something for clarity on this topic: &gt;However, the analyzer can track down some erroneous patterns that it refers to as "64-bit errors". &gt;To tell the truth, there are no 64-bit errors. There are just those that are connected with undefined behavior, that have been hibernating in 32-bit code, and these then show up when we recompile in x64 mode. But if we speak about UB, it wouldn't sound very interesting and people won't buy it (PVS-Studio that is). On top of it all, they won't believe that there are any issues with it. But if the analyzer says that this variable can overflow in the loop, and it is a "64-bit error", then it's a different story. Profit. And [in another](http://www.viva64.com/en/t/0002/), &gt;Those errors that we call "64-bit" may also show up on the systems whose architecture differs from Intel 64 / IA64. The code containing "64-bit errors" is often inefficient and incorrect and performs the actions it has been designed to perform only due to mere luck and peculiarities of the 32-bit architecture. The term "64-bit error" is introduced to single out the class of errors the programmer starts to encounter with while developing code for a 64-bit system or porting the existing 32-bit code to a 64-bit platform.
&gt; This is probably what I need. I'm not sure I agree. It saves you some bytes in your source code, but it's using a feature of the language for the wrong thing. You mentioned in another comment that you want "code that shows good planning, code reuse, minimal code, and readability". Using enums as a way to define global constants, without any intention of using them as an enumeration, fails the "readability" part. This is *not* a normal way of doing things in C, and will be somewhat puzzling to anyone else trying to read it. Is it a huge deal? No; it's not *that* hard to figure out. But you came here asking for advice on how to write code in C, and my advice is that this isn't the feature you're looking for. Edit: typo
you could try /embedded or /ece
Ugh, another damn article from that PVS-Studio guy to plug his product. The examples are okay — I guess they do explain what's happening to make each thing an error — but for the most part, this entire article is kind of a tautology. "When you move to a platform where sizes of some types are different, you will be affected by problems due to the sizes of some types being different." What it *doesn't* tell me is how to *find* these problems — well, except for his plug for PVS-Studio at the bottom — or how to *fix* these problems, since the correct fix is usually *not* blindly changing `int` to `__int64` (or to any other single type).
See the sidebar.
A way to help find these problems is to use his product or any other static analyzer. There are plenty of free static analyzers out there. In fact, PVS-Studio is free. [The paid version removes the following limitation](http://www.viva64.com/en/pvs-studio/): &gt; The demo version has restriction of the number of the click-jumps to the code fragments that contain bugs.
Maybe if I tell exactly what I'm trying to do you can better understand what's appropriate and give me advice. I am defining a language of signals that come as on/off to a device. It doesn't matter what. Say it's an LED or a buzzer or whatever, but they'll be buffered as an int array designating time on, time off, in milliseconds. Symbols in the language are made of combinations of lengths of on-signal. Like Morse code. But this is to be a general solution because what combinations of signal length make a symbol may change. How many signal lengths there are may change. And the length of each signal may change. So what I was thinking was use global constants that define SHORT as 100 and MEDIUM as 200 etc. Then enum of each symbol in the language. What do you think is better?
Why is casting malloc an error? (I'm new to C).
It's not needed because C allows implicit conversion of `void*` to other pointer types and can cover up forgetting to `#include &lt;stdlib.h&gt;` to get its prototype.
 if (faherenheit &amp;&amp; celsius &lt;= 100) isn't doing what you think it is. if (a &amp;&amp; b &lt;= c) evaluates as if (a &amp;&amp; (b &lt;= c)) or if (a != 0) return b &lt;= c; 
it’s because `faherenheit &amp;&amp; celsius &lt;= 100` and `faherenheit &amp;&amp; celsius &lt; 0` are not doing what you think they are doing. Operators evaluate two operands at a time and the compiler has a table of precedence rules to decided the order. Comparison operators like `&lt;=`and `&lt;` have higher precedence than logic operators like `&amp;&amp;`. Additionally, in C any value == 0 is false and any value != 0 is true. So your first condition actually does this: `(fahrenheit != 0) &amp;&amp; (celsius &lt;= 100)`. To do what (I think) you meant to do you have to say `(fahrenheit &lt;= 100) &amp;&amp; (celsius &lt;= 100)`. Because of the precedence rules I mentioned above you don’t actually need parenthesis here, but I put them to make it more clear. (The program is still not correct after you fix this, but I’ll leave the rest to you ;)
if you're trying to say "if faherenheit is less/equal to 100, and celsius is also less/equal to 100, then..." you need to write it like if (faherenheit &lt;= 100 &amp;&amp; celsius &lt;= 100)
I actually don't mind the occasional PVS spam. The articles are usually very informative and give insight about C problems.
Thank you all for your prompt and very useful suggestions ! After i read all the comments and tweaked the program it finally does what is supposed to do !! Thank you !!!! here is the working program : #include &lt;stdio.h&gt; #include&lt;cs50.h&gt; int main() { printf("Enter a Fahrenheit value from 1 to 100 : "); float fahrenheit = GetFloat(); float celsius = (fahrenheit - 32.0) * 5.0 / 9.0; if ((fahrenheit &lt;= 100 &amp;&amp; celsius &lt;= 100) &amp;&amp; (fahrenheit &gt;= 0)) { printf("%.2f degrees Celsius\n", celsius); } else if (fahrenheit &gt; 100) { printf("Number higher then 100!\n"); } else { printf("No negative number allowed!\n"); } } 
OS?
Windows 7, i'm not sure if i'm taking right approach at this but i basically want it to be able to control numerical keyboard that will be used inside a game to change camera positions. EG: If something ingame happens, it goes to camera bound to number 5 etc.
Take a look at my response to FUZxxl.
are you using any library for your game?
There are none sadly
I understand, thanks for your concern
So you are writing your game directly against the Windows API? Aren't you using stuff like Direct X?
You *can* simulate key presses like that in Windows, but why? If pressing 5 calls SwitchToCameraX(), and you also need to switch to CameraX in a different situation, why not call SwitchToCameraX() directly instead of faking a key press? EDIT: That said, if you're determined to simulate a key press, the answer is [SendInput()](https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310\(v=vs.85\).aspx)
If you simply want to analyze the source code, use Coverity. If you're willing to also modify the source code, usually embedding some kind of proof into comments, there's for example Frama-C. Either way, the only good tools are proprietary and very expensive because they target large companies, willing to spend 10^6+ per year in licences.
If you don't insist on C: 1) simple tool is: xdotool (linux only) 2) very powerful with OCR and automation: sikuli (java)
What school / class?
&gt; He wants our programs to run on a unix server, but I am not familiar with unix and I don't have any unix machine to test on. Can't you log into the Unix server that he wants your program to run on? &gt; Is there any way for me to write this program on my Windows computer? You can try installing Cygwin, which attempts to provide a Unix-like environment inside Windows.
Looks like your class is teaching POSIX semaphores, which you generally won't find on Windows, even with MinGW. What you can use instead is [win32 semaphores](https://msdn.microsoft.com/en-us/library/windows/desktop/ms685129(v=vs.85\).aspx) which are going to be semantically identical for your purposes. With a few `#define` you could very well pretend they're POSIX semaphores. * `sem_init` =&gt; `CreateSemaphore` * `sem_wait` =&gt; `WaitForSingleObject` * `sem_post` =&gt; `ReleaseSemaphore` * `sem_destroy` =&gt; `CloseHandle` 
Try Virtual Box with Ubuntu. It's a Unix System "emulator", which will allow you to run programs in a Unix environment. I think that you can even develop them in Windows and just run them in Virtual Box, but I wouldn't recommend that.
Well, I do have access to it but only when I'm on campus. I commute to school and to work right after my classes get out, so I don't really have free time to spend there. So I will have several chances to test it on the server before I need to turn it in, but not really while I'm working on the project. 
Is this something that could easily be changed to work on a unix server before I turn it in? I'd like to write this project on my Windows computer but the end goal is for it to run on unix. 
MinGW -w64 has pthread.h support. MinGW -w64 was a fork of MinGW in 2007.
The includes you used are a little unusual, but if you really are talking about POSIX semaphores this bit of code at the top of your source should allow you to pretend you've got it on Windows. You won't be able to check the return values, though, if you're required to be that thorough. #ifdef __WIN32 #define WIN32_LEAN_AND_MEAN 1 #include &lt;windows.h&gt; typedef HANDLE sem_t; #define sem_init(s, p, v) *(s) = CreateSemaphore(NULL, v, LONG_MAX, NULL) #define sem_wait(s) WaitForSingleObject(*(s), INFINITE) #define sem_post(s) ReleaseSemaphore(*(s), 1, NULL) #define sem_destroy(s) CloseHandle(*(s)) #else #include &lt;semaphore.h&gt; #endif 
I'll give this a try, thanks!
I hadn't noticed that, thanks. I do specifically use Mingw-w64 for Windows development rather than the old MinGW. I'd still prefer just to call win32 myself, though this would certainly help in porting an existing unix application.
yes there are... plenty
The worst offence to coding practice isn't what he listed. It is the use of static variables. These coroutines are thread unsafe, and not even reentrant. 
LOL that's great, but i dont understand the !! part if somebody could explain
AMD and Intel are both the same hardware architecture, x86. You don't need to cross-compile anything for that to work. As long as you don't select any extensions that aren't supported by all the target machines, you don't have to do anything. 
how about !!flag&lt;&lt;2 then? essentially the same thing but it looks more cryptic lol
https://gcc.gnu.org/onlinedocs/gcc-4.5.3/gcc/i386-and-x86_002d64-Options.html
The linker script is used by the link editor (ld), not the runtime linker (ld.so). Its basic purpose is to define the layout of the thing being linked. This mainly involves defining how sections are combined, and how sections map to segments. For example, one feature of newer compilers is hot/cold partitioning. The compiler will emit code that it thinks won't be called often in a section like `.text.unlikely` and code that it thinks will be called often in a section like `.text.hot`, and normal code that it hasn't decided either way into the traditional `.text` section. At link time, all of the contents of the cold sections need to be combined, and then all of the hot code sections need to be combined, and then all the rest of the text sections need to be combined, and then the whole thing needs to go into the text segment of the resulting binary or library. The linker script defines these relationships. Another feature of the linker script is defining symbols. Sometimes it's necessary from within code to know the beginning and end addresses of a certain region. The linker script allows defining symbols at those boundaries. An example of where this is used is in C++ when you need to call static constructors at program startup. An array of function pointers is collected in a section named something like `.init_array` and there are symbols defined for the start and end of it so that code in the CRT startup files can locate the array and call each of the function pointers. It's very uncommon to require a custom linker script. Pretty much the only time it's required is if you're defining your own sections and need them to be handled specially. The linker comes with a set of link scripts for a variety of different use cases (e.g. executable, shared library, special options, etc.) 
Thanks for spending the time to explain. Im on the phone so I cant say much. Your first sentence already pointed out a confusion I had. I thought `ld` was involved in runtime linking (even though I knew about `ld.so`).
I disagree with the dichotomy between malloc and static. We write embedded code without either malloc or static. We do use global variables as allocations (we always pass ptr to them, never use them via global scope, so they're not really global vars in the typical problematic ways). Our code is reentrant and thread safe because we can make sure our global allocations make sense for their use cases since the allocator is high level and can assume these things. Low level infra code shouldn't assume these things.
I can't say I disagree with your points, really. But I'm not a believer in code guidelines that can't be overridden for well-argued reasons, so I think it's useful to be aware of this sort of thing in case a good reason for it arises. That said, I've been aware of this one for a long time, and never found a compelling reason to use it, despite often wanting the clarity of coroutines.
Turn on all warnings in your compiler, and pay attention to what they say. $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:10:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int] main() ^ program.c:20:6: warning: incompatible pointer to integer conversion initializing 'char' with an expression of type 'char [7]' [-Wint-conversion] char Hero1 = "Batman"; ^ ~~~~~~~~ program.c:34:50: warning: format specifies type 'char *' but the argument has type 'char' [-Wformat] printf("%s\'s favorite hero is %s.\n", Kid1, Hero1); ~~ ^~~~~ %c 3 warnings generated.
Use the SDL library, and make something among those lines: uint8_t keep_running : 1; keep_running = 1; while(keep_running) { SDLEvent event; SDL_WaitEvent(&amp;event); switch(event.type) { case SDL_KEYDOWN: switch(event.key.keysym.sym) { case SDL_UP: //The UP arrow key //... } break; } } I myself used the SDL for a REALLY BAD implementation of Conway's GOL. You can check the code on the [Github repo](https://github.com/Garuda1/game-of-life)
To give you an idea, the only time I can recall using a custom linker script that I myself touched was when I was writing a custom bootloader for an embedded project.
The one and only time I used one was [to construct a custom, raw binary](http://nullprogram.com/blog/2014/12/09/) instead of an ELF binary.
Sections are combined based on their name by default, without linker scripts. I think the main use is setting up specific addresses of sections and symbols.
I think fiddling with the stack with a bit of assembly is somewhere around the same level of "dangerous". Either way, you subvert the normal way things work in a way that's clear and safe provided you see the bit of code that does it and understand how it works and what the limitations are.
Pseudo code to sort three values, a, b, c, such that a &gt;= b &gt;= c: if (a &lt; b) swap(a, b); if (b &lt; c) swap(b, c); if (a &lt; b) swap(a, b); Now all you have to do is implement this in C, then test and debug it. 
The other answers here are assuming you're using arrays. If you're only 5 weeks in, it's entirely possible you haven't used arrays yet. If you don't know what arrays are yet, you can definitely still solve the problem. Assuming you've read in the 3 numbers into 3 different int variables, you can use &lt; and &gt; and &amp;&amp; to figure out which of the 3 is the smallest and which of the 3 is the largest.
Basic construct: If((a - b) &gt; 0) //no swap Else: //swap
Do you know if/then/else?
I am not allowed to use comparisons, if/then, UDFs, or anything else basically. We can only use things we have learned this far, and bubble sorts do not count 
What can you use? Also, you're 5 weeks in and haven't learned about if, comparisons, and functions? That's sort of frightening.
&gt; Don't learn C with an IDE, you aren't going to learn C programming if you do so. That's a bit of an overstatement.
I think I only have access to stdio.h
Thanks. Most helpful comment here. Alot of the readers don't realise I'm an absolute beginner in C, hence the work book Im working with. Leads like this are great
`palindromep` - found the Lisp programmer :) Seriously though, checking the string without making a copy is much faster and more efficient
A few examples of reasons I've mucked around in the linker scripts (to expand on your answer): 1) I was working on an embedded processor with FRAM (MSP430FRxxxx) for a project that would occasionally lose power. I segmented the memory in the linker script and made a new region. I could then define variables in that region and when I lost power could retrieve them. The particular compiler I was working with had a pragma for configuring these variables, something like: #pragma location="CUSTOM_SECTION" volatile int var; 2) I was working on an embedded project that needed to noinit some RAM on powerup and keep it valid between resets. So I segmented RAM and defined the new section as noinit. I could keep my data in that section and read/write to it between resets. So yeah, not a very common thing to be messing around with.
Can't use sort :) haha. After giving it more thought, it might have to incorporate modulus
michael1026, please don't remove your posts after receiving an answer.
Well what value does ch have when the if statement sends you to to the "invalid input" branch? Where did ch get set to that value? If you don't know, then the root problem that needs fixing isn't your code, it's that you're not debugging your code. The debugger is how you "see" what your program does. Without it you're just throwing darts with your eyes closed. Writing a ton of stuff and then just hoping for the best isn't how programming is done. You have to actually look at it.
Sorry. My professor said during class (after I had posted this) that if any of your code is hosted publicly, it's considered plagiarism and will be reported for academic dishonesty.
If this is the case, then don't ask questions in public forums.
I've seen this before. In both C (and C++), certain kinds of input fetching simply do not get along well with others. And I suspect this may be highly compiler-dependent. When you call mk_acnt(), you invoke scanf(). When you come back to getchar() (in menu() ), it chokes (apparently on residue) left in the keyboard buffer by scanf(). It may go beyond that, and I'm not expert on every detail in this regard. That said, I was able to duplicate your issue, and remedy it (on my side) by adding fflush() prior to the call to getchar(). More elegant solutions may exist, and hopefully more knowledgeable people could fill you in on all the horrors of mixed - function I/O (or you could locate same on the web.... ) Painpoint: calling getchar() and scanf() (mixing input functions) in one program. FIX: call fflush() before changing input functions. Hope the work-around works for you: static int menu(void) { int ch; menu_options(); fflush(stdin); //FIX: flush stdin before you call getchar() while((ch = getchar()) != EOF) { **EDIT**: before trying this, see replies. I invited other views, and they arrived, lol. Just because something works doesn't equate to 'advisable' ;) As for my posit concerning mixing I/O functions, I'm certain I found stuff on the web about it, and that I wasn't the first to get snagged. Others have posited that I'm way off on this notion, and I could be, and probably am. 
You must be able to use logic, are you sure you didn't sleep through a lecture? How are they asking you to express the result? Without logic you wouldn't be able to print them in a different order. I guess you print them in the order they were entered with a score next to them...
Nice! Apparently I'm bad at algebra then. Good thing I'm allowed to use logic ;)
Absolutely not. fflush is undefined behaviour on input streams.
&gt; Painpoint: calling getchar() and scanf() (mixing input functions) in one program. It's not caused by mixing different functions. This is the normal behavior for getchar(), using it exclusively would do the same thing. It will happily take a newline character if that's the first character sitting in the input buffer. When you call things like getchar() you're asking the user to type *multiple* characters into the input buffer. At minimum you want him to type two characters (his choice followed by the return key) and nothing prevents him from continuing to type an entire chapter of fan faction at the prompt. But then you're only asking to take the *first* character from the input buffer. Everything else is left waiting in the buffer. Any call you do next is going to get the data that's left in the buffer, whether it's getchar(), scanf() or something else. It looks like OP was aware that getchar() will naturally leave newline characters in the buffer since he's got a little check there to filter them out. The problem here is it's not in the right location. 
Is there a way of doing it without max min or mid?
&gt; when would you define your own? Embedded systems. My company designs PCBs, so we're in complete control of the hardware. We know that we have 8 MB of memory, and that due to restrictions on this processor, it's noncontiguous: we have 2MB, 6MB gap, 2MB, 6MB gap, etc. The linker script defines what the output regions are (region from 0MB to 2MB, region from 8MB to 10MB, region from 16MB to 18MB, etc., plus the processor's internal data and instruction memory). It gives them names, and says in what memory regions to put all of the various input regions. (So the `program` input sections from a handful of files go in the `INTERNAL_FAST_PROGRAM` output memory region, the `program` input sections from everything else goes in the `PROGRAM` output memory region, the `constdata` input sections go in the `CONSTANT_DATA` output memory region, etc.) In our case, because of the noncontiguous memory and restrictions on instruction and data caching, we can't just have it assign things wherever and spill over to the next available memory address. We have to decide that one 2MB memory region is for code, and another region is for data, and so on; no mixing and matching for us. We can also play tricks with it, like in our C and assembly code telling it to put the compiled output in the `fast_program` section. Then in the linker script, we can choose whether we want the `fast_program` section to map to fast internal memory, or slow external memory. (I'm simplifying for example; that would actually be for several different algorithms like `encoder_fast_program` and `decoder_fast_program`, and we would choose which one or ones need to be fast depending on the project.) &gt; Do most libraries rely on a default (implicit) linker script? There always has to be a linker script. Most of the time it's the built-in one. You can view it by running `ld --verbose`. Funnily enough, the syntax for my processor's linker is similar to GCC / ld's. Inside `SECTIONS` it defines an output region `.text`, and in that output section it does `*(.init)` to place the `.init` input section from all files, `*(.text)` to place the `.text` input section from all files, and so on. They're placed in the output section in order, so that's why it sorts some input files/sections and lists everything in a particular order.
In his examples max min and mid are just integer variables, which you should be allowed to use. 
&gt; The problem here is it's not in the right location. Thanks. Yes. The following seems to resolve the issue nicely. Does anyone see any flaws with this approach?: void mk_acnt(Account * acnt) { Account temp; ... ... puts("Enter Credit Limit:"); scanf("%lf", &amp;temp.lim); while(getchar() != '\n'); //fetch &amp; discard residual junk in buffer *acnt = temp; printf("\nAccount %d created.\n", temp.acntnum); } 
Instead of trying to foresee what each operation will leave in the buffer and then trying to clean up after it, I'd suggest a more robust approach would be to think of the buffer as something that's always dirty and move the idea of sanitizing it to the line immediately *before* you ask the user to enter something. It may seem like a philosophical point right now if what you've got at the moment achieves the same goal of making it work, but to me it's the most reliable place to put it. I'd tend to group calls that rely on each other like this into a single function as well to make it even less likely you'd ever miss one or call them in the wrong order. You could call it getcleanchar() or something and have it empty the buffer, call getchar(), and return the user input. 
I'm not sure how you can do any sorting without at least an implicit if statement. Also, the modulus operator doesn't have anything to do with sorting so that's kind of weird. Can you post the actual requirements of your problem?
Sounds like you're supposed to call [read(2)](http://linux.die.net/man/2/read) with a `count` of 0.
You could rename them x, y, and z. They are just variable names, not functions. 
 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/time.h&gt; #define TIME(exp) ({ \ struct timeval ts, te; \ gettimeofday(&amp;ts, NULL); \ exp; \ gettimeofday(&amp;te, NULL); \ unsigned long long uss = ts.tv_sec * 1000000 + ts.tv_usec, \ use = te.tv_sec * 1000000 + te.tv_usec; \ printf("%lluu\t- %s\n", use - uss, #exp); \ use - uss; \ }) int main(int argc, char *argv[]) { TIME(read(0, NULL, 0)); } 
This should be doable if you remember that the C standard (at least 11 - I couldn't find a good source for 99 from my quick search) states the following: Each of the operators &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), and &gt;= (greater than or equal to) shall yield **1 if the specified relation is true and 0 if it is false**. **The result has type int**. You also need the property of modulo where (a &gt; b) iff ((a % b) &lt; a). (EDIT: When I say "need," I mean that that's a property you can use to include modulus in the algorithm.) Since you can multiply by the result of a comparison, this means that you can effectively have one value if the comparison is true and another if it's false without the need for an if - or even implicit if - statement (at least not at language level).
Well, there's ways of computing a min and max of two values [without a branch](https://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax). Do this on a sorting network on three items and you have a completely branchless sort. I still don't see what this has to do with modulus, though.
I see. I believe I am on to something. I have Int X, y, z; Factor1= X/y; Factor2= y/X; Factor1= (factor1 +2) % (factor1 + 1) Factor2= ^same as above Max = factor1 *x + factor2*y; And it continues in this fashion, comparing X and Y, comparing that with Z, then min and mid to hopefully get Min= X + y - max Mid = X + y+z -min -max I got about half way then got confused. Any idea on how to finish?
Without further work (debugging, reading the source) you don't really have any idea how good this method is for measuring the latency of a syscall. You don't know when the check for a 0-byte read is performed. It might be done in usermode, and so no syscall is ever performed. Or the kernel may execute many other instructions before checking the length.
I was able to come up with a solution based on this, but as you hinted the modulus is completely superfluous. Still seems like a weird assignment.
bah! sure, if you insist.
Shouldn't i represent all the corresponding values within the array?
Thanks, I appreciate this. My program works great now. Although this works I think I'm eventually going to convert my program to use fgets like u/balkenbrij suggested. 
You have to tell it the type of variable you want to print, so printf("You said: %s", userSays); %s = strings %d = integer 
FOR THE LOVE OF DJIKSTRA DON'T USE `gets()`. It's bad. Real bad. If you use it, you'll die. Use `fgets()`. 
for starters learn to use scanf to handle user input 
I have an if statement checking for NULL and exiting if it is null. Right after that I fseek, ftell, and print the result.
That's about it. To be safe you should probably check for EOF there as well, so the body of the function would look something like: while ((ch = getchar()) != '\n' &amp;&amp; ch != EOF); return getchar(); 
What compiler are you using? Are you compiling with -Wall? If you were, it would have told you what you were doing wrong. As ProgGod already said, you need a %s in the format string of the printf. printf is a variadic function, it takes a variable number of arguments. The way this works in C, is that the function has no idea how many arguments it was passed. For functions like printf, it relies on the content of the first argument to know how many and what type of arguments you passed it. For that reason, you usually want to pass it a literal string as the first argument, even if it's just "%s". Since printf is a part of the C standard library, the compiler knows about it and can give you warnings if you use it wrong, for the most part.
ProgGod outlined the basic answer, but I would like to ask: Is it possible you're coming from a different language? It might make more sense to you if you see the differences: In a lot of languages, the 'print' function in one way or another takes a bunch of things in order as input, and then displays them all to the output. Java is a language like this - You convert everything into a string, and then combine it all together and print the resulting string. C++ is similar, you send everything to the 'output stream' one at a time. In Java, you would do what you want here using something like "out.printLine("You said: " + userSays);" (Forgive me, my Java is rusty). As you can see, you combine them in the order you want the displayed. C, on the other hand, is decidedly *not* like that *at all*. Instead, C takes a single string as input to print, and replaces parts of the string with other provided inputs as it writes to the output. This single string is called the "format string", and is the first argument to `printf`. You tell `printf` to do replacements via `format specifiers`, which are nothing more then things like `%s` which means "replace this format specifier with the next provided input". The common ones are `%s` for string and `%d` for an integer. Because of the way `printf` works, if an input is not referenced in the format string via a specifier then it will not be displayed to the output. In your example, you never referenced the input `userSays` with a format specifier, so consequently it was not displayed to the user at all. It's worth noting, as long as the format specifiers are in the right order relative to the inputs, they can be anywhere in the format string. IE: This works just fine: printf("%s You said: ", userSays); Which will just display `userSays` *before* displaying " You said: ". Note that you can print multiple things with multiple specifiers (Just make sure they're in the right order - A good compiler will check this for you): printf("You said: %s, int1: %d, int2: %d", userSays, 2, 3); Prints "You said: This is user input, int1: 2, int2: 3". This is very different from other languages, where you might do something like this: print("You said: ", userSays, ", int1: ", 2, ", int2: ", 3); /* This doesn't work at all in C */ printf("You said: " + userSays + ", int1: " + 2 + ", int2: " + 3); /* Also doesn't work */ Personally I *much* prefer format strings, but either way, it's important to understand the differences between the different techniques, and how C's technique works.
Ah I see thanks a lot. So I tried checking what the size of the directory file is using stat ./ and the size is 578 whereas the c code was returning 510 when checking the length. Is the extra bytes just some kind of metadata associated with the directory file?
I have to build a functional shell, written in C on Cygwin using the Emacs editor by Friday. I have never used or even seen C, Cygwin, Emacs, or Linux. The code I gave in the description was written based on things I saw on Stack Overflow and the example code my Professor gave us. 
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char* argv[]) { char str[10]; fgets(str, 10, stdin); printf("The user said: %s", str); return EXIT_SUCCESS; }
Wait, what? When you say that you need to build a functional shell, do you mean you need to make bash from the ground up, or do you have a small list of commands? What about program execution? Do you need to do be able to scan directories and launch programs, or can you just pass that shit on to bash and have it handle all of it? What the hell kind of first introduction to C is this?
I have no idea. Traditionally, UNIX systems allow you to read the contents of a directory with `read()` but this is a long obsolete feature and Linux never did things this way.
The idea is simple, the usage not. There are hundreds of flags and output formats and you need to know at least some of them to understand how to use `printf` effectively.
Number of possibilities means more flexibility than complexity imo, and you don't have to commit a lot of them to memory to be efficient but simply have a hint of knowledge about what printf() can do.
Dijkstra.
Uuugh. That's it. I give up. I never get his name right! Might as well start calling him Bob. :|
Why do you have to use Emacs? That's the really messed up part. I think I need to start the Vim Defense League or something.
OS X symlinks clang to gcc, so it'll compile just fine and you don't need to install anything but Xcode.
Well, have you tried to check if that comment can be executed in the command line? Please consider posting your code so we can investigate what's happening. 
Yes I have. And It runs without a hitch. I do not wish to publicly post the code, but if it would help you or anyone else, I can send it via message.
Sorry. Can't help you then. I'm not answering questions in private without getting paid for that and there is no point in trying to fix code you can't see.
Because in 90% of the cases where something that should obviously work fails, the problem is in the part of the code you didn't show us. Surely the problem is not in the part you showed to us, since that doesn't seem wrong. There is a good reason why Stack Overflow requires questions to contain a minimal self-contained example of the problem you have. This is not Stack Overflow, but it's really hard to diagnose problems knowing literally nothing about your code or situation.
any links will be helpful :) 
You wouldn't have seen `main()` (no return type) or `gets` on StackOverflow, that shit gets downvoted into oblivion instantly (and rightly so)
And the `%d` and `%f` formats which have unavoidable undefined behaviour (user may type something out of range for the target type)
Not commonly explained is that the format string has to match the data type of the argument. The string doesn't specify a conversion ; you have to convert the argument to the type you want, and then choose a matching specifier. 
Nice, glad you found a solution! When I programming in C on Windows, I installed cygwin, and gcc. So that's an alternative option, if you are running Windows on your machine, but like a Linux like environment for programming.
Thanks. I'm not very comfortable with Linux and want to limit my hurdles to learn C. 
Your indentation got all messed up, use http://pastebin.com or http://codepad.org to host your snippet. It looks like maybe you forgot a `}` at the end of your function, but it's really hard to tell with your code so messed up.
Thanks for asking. typedef struct deque* Deque; //creating a handle for struct queue Full header file: http://codepad.org/rQs74vka I can post a link to client file too if needed. 
I don't follow. Isn't that what the link I shared in the post does?
Yes, you can invoke the MSVC compiler from the command line. Since when is this news? Are Windows devs shocked and awed when they realize that, no, you don't need a GUI for every little thing?
&gt;for(comparatorIterations&lt;arrayLength; comparatorIterations++;) { I suspect this is not what you intended. The initialization action of the for loop goes first. You've chosen to omit an initialization action, which is perfectly legal, but you still have to leave an empty statement in its place, followed by a semicolon. As it stands, comparatorIterations&lt;arrayLength is the initialization action, which is also legal but has no effect at all. In fact this for loop terminates immediately without any iterations; I leave it to you to figure out why. :P
This line :- for(comparatorIterations&lt;arrayLength; comparatorIterations++;) is wrong. A `for` statement has 3 parts. It is okay to provide less then 3, but they still need to be in the correct place. Yours aren't
What would you suggest for a beginner who's only used to Windows? I can't operate Mac either. I tried Ubuntu once a while back, but that was on a netbook edition. 
Ok, so we're on the same page. The link in the post does exactly that, it's a command line interface for the C compiler that installs with VS. 
Apologies. I'm not a developer, I'm trying to learn C to become a firmware engineer and I own a Windows laptop, so I was looking for an easy solution for C that I had trouble finding when I searched online, so I thought I'd share for newbies like me :)
Linux is not that hard to use. You have to get used to using the command line anyway for any kind of programming job so better start learning now. And don't use an IDE. An IDE only distracts you and hides important things you need to learn.
Couple problems I see. First the compiler errors: *In removeLeft() (line 63) you have an else if, but no condition to check. Did you mean else? *In removeRight() (line 78) you have the same problem. *In removeRight() (line 80) you reference size. You probably meant q-&gt;size since there isn't a size variable in this function. Then you'll run into some warnings with insertLeft() and insertRight(). They both return a value (char specifically), but claim to return void. 
Rubbish. "His biggest hurdle" is going to be getting comfortable writing clean code in an unfamiliar language. Honestly I think you're being hyperbolic in support of your personal preferences. You haven't even established his reasons for learning C. What if he wants to write programs targeted at Windows users? Your advice is even less useful if that is the case. Yes, there are some edge cases that crop up for advanced C programmers, but he's a beginner. He's going to be doing basic stuff. If he tries to bash his head against multiple things he's unfamiliar with, it's only going to make it less likely that he'll stick with it. Let him learn and get comfortable with general C programming and then transition to Linux if he needs to.
My opinion is to ignore the hyperbole and keep going with what you're doing. If standards-related edge cases become an issue, check out MinGW. The VC++ compiler is not the only option on Windows. Also, take a look at the Atom or Sublime Text editors. They're much nicer than Notepad++.
You nailed it, I figured it out right after I wrote that post. Thank you so much for the help though. Sometimes I just need some sort of nudge to look at my code objectively again.. 
The short answer is, you save your code as a text file with a .c extension, and pass that file as a command-line argument to your compiler. What compiler are you using on your Windows computer? (Probably one of: Visual Studio, Clang, MinGW.)
Why though? I'm not trying to be the downer on this thread, I'm just curious... Why do C development on Windows? *nix is just the natural environment for C work. Plus you'll get the added benefit of learning Linux/Unix! If there's a reason I'm missing, help me out... are you doing .NET development simultaneously or something? EDIT: Really? downvotes for a legitimate question? OK...
I just installed MinGW but I had Cygwin64 already installed. I'm not entirely sure which one is being used... I got the files running through use of the command prompt. Basically I just changed the directory to the folder containing the files that I created in the text editor and then typed "gcc file.c -o file.exe" then pressed enter then typed "file.exe" and pressed enter again then the output of the program popped up and worked. I'm using a math library and I did not type "-lm" in the gcc line because it is my understanding that the MinGW compiler automatically adds the "-lm" so I assume the MinGW compiler is the one being used for this reason. I thought I had to open up the compiler and type some shit into that though?
I would have to check a little more thoroughly, but it looks like you are resetting the minimum bound for each new set of numbers, and you should set it once and let it carry over.
&gt; Thanks, I appreciate this. My program works great now. Great, very welcome! &gt; Although this works I think I'm eventually going to convert my program to use fgets like u/balkenbrij suggested. I think that is sound advice. You can still get the benefit (easy float conversion from input) of scanf() by using the string version sscanf() -- this next worked nicely in test and didn't need any buffer clearing mechanizations *at all*: void mk_acnt(void) { double p; char buffer [180]; puts("Enter Account Balance:"); fgets(buffer, sizeof(buffer)-1, stdin); sscanf(buffer, "%lf", &amp;p); printf("\nAccount balance: %.2lf\n", p); } It's way too interesting. I mean, fgets() and sscanf() combine to do nicely what scanf() itself should have done in the first place. But that scanf() ... :-/ I never have liked it. I remember back in the day (so long ago now) abandoning it, and doing sscanf() upon the input buffer. Only difference is I was using gets(), cgets() -- which always assume stdin (was doing a lot of console work -- this coming back to me now). Then ultimately, in frustration with all the limitations, flaws, etc even with those, I finally wrote my own cgets(), which utilized getch() in a while loop, and it could also handle arrow keys, destructive backspace, HOME, END, DELETE and F-keys too (like, for context-sensitive help and such). Oh man I spent hours and days on that shyte, coordinating the screen cursor with the buffer index, and the like, LOL. Basically a one-line text editor. My most recent version allows copy, cut &amp; paste from/to the global Windows buffer. And of course you know, you have to maintain text highlighting (for selected text) when you get into that. So, yea, loads of fun. You can see why so many have given in to Windows (or some other OS) GUI programming, where a couple quick calls and some easy GUI design brings all the functionality I just described but without re-inventing the wheel. And then a part of me feels this is cheating. But I get over it, usually. 
First, change "maximumRange = tempnum;" to "maximumRange = INT_MIN;", and elliminate "tempnum". It should solve your problem. 
Sorry, so actually, do what /u/pm_ur_favorite_thing said. The problem is that you set minimumRange and maximumRange whenever you read a new line of numbers. You should do it only (set max=INT_MIN, min=INT_MAX) (for example) at the beginning of your code, and when you find a bigger or a smaller number.
I'm glad I spent a long time on the command line in the beginning. Later when large projects merited the IDE, it could *then* be appreciated. I compiled stuff with batch files and such automatically when my editor exited. Might have been too much mastering an IDE with all its quirks, while taking on C too. Everybody's different tho. Some are lost outside the IDE from the beginning, depending on how you learned. IDEs can be a little cumbersome and daunting, until the cumbersomeness and dauntingness of your projects exceeds the former. Then the IDE is sweet. 
LOL! Yes you did! I guess my late nite eyes missed the '++' first time. -cheers
There's such a thing as Windows Console mode, which is dirt simple to build and is actually a fully Windows compatible app. You don't need anything more than simple main() and using basic printf(), etc., to build these. This is highly advisable for learning essential C routines first, and GUI complexity later (or never, up to you). And the Console is as extendable as you want it to be -- adding color, mouse and nearly any 'windows only' code you want. In example, you can launch a windows GUI dialogue box actually from the console app (code below). Great stuff for beginner or not-so beginner. Later, you mite abandon console apps for Windows GUI (only) apps, which are significantly more complex. #include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;conio.h&gt; int main() { /* We start in raw console mode -- just like the app you see when you launch 'cmd' */ puts("Hit a key when you want to see the Win GUI dialogue box"); getch(); /* Now we launch Win GUI dialogue box from the console app. The console app will stay active */ MessageBox(NULL, "Hello World! (If you use this code, no one will care)", "Boy Howdy!", MB_OK); /* The Win GUI dialogue box has exited by now, and we just have the console remaining...*/ puts("Cool, huh? (hit a key to exit..."); getch(); /* Console will now close */ return 0; } EDIT: Man! People *hate* this code, lol!
Lots of downvotes for showing ill of windows here... To add to what other already have said, *Nix is the most natural environment for C, at least from a historical perspective. All the standard libraries were sort of developed in tandem with Unix way back then, so there's certainly a natural correspondance there. That's not to say that you can't use C on Windows or that the experience is inherently worse, it's just different and less commonly used. From what I recall, most developers for Windows are using C++/C# with the visual studio compilers and .net, not C. The C features in visual studio are a little underdeveloped IMO, but I might just think that because of my lack of experience. I strongly recommend you learn how to use a Nix environment, though. More or else all "real" programmers are at least fluent in it, and it's really not as difficult to learn or understand as you might think. The open nature of Nix will allow you to learn about more about how operating systems in general work, and C experience will allow you insight into some really cool behind the scenes stuff that definitely comes up in firmware development. It's simple to start learning nix. You don't need to install Linux on your laptop; get a virtual machine! VirtualBox is open source and very stable, and you can get a Linux virtual machine up and running in 10 minutes if you wanted.
Go with Cygwin or Cygwin64; it gives you the most complete environment, not pure Windows but good enough to learn with and easy enough to move on from. You write C files in a text editor (obviously), including source (.c) and header (.h) files. An IDE is just a text editor on steroids, sometimes which has a compiler built in, and which will usually let you call external tools (like compilers) quickly and easily. I like Eclipse CDT for this purpose, but it’s only worth bringing to bear on a larger project. When you need it, it’s nice—it’ll let you hyperlink between lexical elements and walk through preprocessor expansions, stuff like that. The interface you generally use to GCC or CC or BC or Clang is a compiler frontend, just a program that coordinates a single action in the overall build process. It does the following things by default: 1. Read and preprocess your source code. Your `.c` file usually has to `#include` and `#define` things; the preprocessor strips out comments and expands includes and macros, in the process converting the various preprocessor-referenced files into a single monolithic file. (Usually there’re no preprocessor directives left in the results except compiler-specific line directives, like `# 3 "file.c"` to tell the compiler that the following code comes from line 3 of file.c. That lets it track across `#include`s so that it can give you reasonable error messages; `#line` is a way to engage this manually from standard C.) 2. Compile your source code to target-specific assembly code. This converts statements like `x += 4;` to instruction mnemonics like `addl $4, %eax`. Technically this is all the compiler itself needs to do. 3. Assemble your assembly code to (binary) machine code and raw data in an object file. The object file is not yet a complete executable file; for example, most of the C library functions have probably yet to be filled in all the way. The object file has a bunch of entries both for things that the object provides to others (exports) and things needed from other objects (imports). 4. Link your object file with whatever static libraries it needs (fully linked right now) and half-link it with dynamic libraries (basically, just leave a little note in the executable that the dynamic libraries will be needed, plus a set of entries telling how to link them in). Once the compiler driver is done, you’ll have an executable file. If it’s not a static image (not supported on all OSes), your OS will need to link it into a memory image when it’s loaded by dragging in any dynamic libraries and finishing off the linking process just before the program starts running. Various static library managers like `ar` can also be used to tack object files together for use as a single entity (usually .a on UNIX, .lib on DOS/Windows). The linker can also produce a dynamic library from the right kind of code (usually .so on UNIX, .dll on Windows). Older compilers could also produce overlays (.OVL on DOS) which were ways of swapping out parts of your program when dealing with limited memory, occasionally still a useful technique on teenytiny embedded systems. Caveats: Some compilers have preprocessors and/or assemblers built into their core, so that they can deal with code at all three levels. Usually you can make them generate or accept preprocessed output or assembly language just as if the compiler were in separate pieces, all the same. For example, Intel’s C compiler family has at least an assembler built in; you can cause a behavior toggle by inserting `__asm__(".if 0\n.endif");` to give the assembler something it can’t handle, and force it to do the assemble in a separate stage. Microsoft’s Visual C/etc. compiler has an integrated preprocessor as well, and because of implementation bugs (still not… quite… C89-compliant in that department) you can actually get different results sometimes just by running code through the preprocessor in a separate stage. To trigger separate stages for gcc (most other UNIX frontends like `cc` or `clang` work the same way): # Dump the initial preprocessor environment: gcc -dM -E - &lt;/dev/null # Preprocess only: gcc -E -o file.i file.c # Dump assembly output, not an object file: gcc -S -o file.s file.c # Note: .s is a usually-AT&amp;T-syntax raw assembly file. # .S (capital S) is a .s file that gets run through cpp first. # .asm is a usually-Intel/MS-syntax, usually-x86 assembly file, different beastie. # Compile to object file, not executable: gcc -c -o file.o file.c # Link object files to an executable gcc -o file file1.o file2.o In most cases, you can leave off the `-o` and it’ll pick a good output file name; the exception is when generating an executable file, in which case `a.out` (a relic of bygone days) will be used, short for “assembler output”. You can also mix inputs, so you can throw it a `.c`, `.i`, `.s`, two `.o`s, and three `.so`s and it’ll perform the appropriate actions on each to get an object, then link them all together. You can specify the input format explicitly with `-x`, but generally you should name files so it can guess the type on its own. You can also usually run the stages separately, should you need to: - `cpp` is the preprocessor - `as` is the assembler - `ld` is the static linker - `ar` is the library archiver - `ld.so`or `ld-linux.so` (possibly with a `.[0-9]` suffix) is the dynamic linker on Linux. And usually buried somewhere in `/usr/lib/gcc` or `/lib/gcc` is `cc1`, the compiler backend. You can use option `-v` to `gcc` to see all the machinery going on at each step—more than you’d think. If you have more than a couple files, you’ll probably want some help coordinating all of this, and the most common way to do that is with a Makefile, which is used by `make`. You can use this to detect and fill in any files that need to be built. (E.g., I lack foo.o, and I know that I can make it from foo.c; I will compile foo.c to make foo.o and move on.) If you have more than a couple of Makefiles or a complicated build process, you might need even *more* stages like using `configure` (autogenerated via `m4` scripts from some `configure.ac` you provide), which ties in automake, autoconf, autotest, and various other frameworks by autogenerating any old text (makefile, source, headers, whatever). That lets you adapt your code to just about any platform “easily,” although you’ll spend hours just waging maddening battle on the tools once you get to that point. If you want to distribute your C project for POSIXish systems, you’ll probably want to use autoconf; then your user would unzip/untarball your source code, run `./configure --options`, run `make`, and then run `make install` (or just `make install` if there’s no root needed) to build and install your program semi-automatically.
Clang/LLVM is a great compiler that works on windows, I used it with codeblocks ide.
https://www.youtube.com/watch?v=QqOrQN0bxNE
oh wow thanks so much! I made those changes looks a lot better now. It keeps giving me an error upon the return of process1. I'm thinking of just having it send the answer to the loop argument from the function through the return. http://pastebin.com/3AttijCc
Yes, but not for learning. You need to understand how the compiler is invoked and how to write Makefiles before you can use a program that abstracts that away from you.
I've been a Linux user my entire life. I love it and wouldn't use anything else unless I absolutely had to. Now that I have that out of the way I want to tell you forget all the people telling you switch to Linux. Your post was asking specifically about C on windows. Changing to and learning a new operating system before you get to do the thing you wanted to do to begin with is going to suck the big one. Stick with Windows learn C and just do it. If in the future you want to try on a *nix OS by all means do so but its not necessary for learning C. And if you do switch to Linux don't let the hipsters and ole G types deflect you from using a user friendly Distribution. An operating system should stay out of your way and provide the platform for completing some useful work. In your case windows will suffice if that's what you already know. May the code be with you!
Ok finally fixed slope now lol! I wrote out the other function ran it and its going good. I tested the program with all my test cases and it worked perfect :)! Thank you so much! I learned a ton and you helped greatly! code: http://pastebin.com/1J0VAh5P
&gt; I'm not a developer, I'm trying to learn C to become a firmware engineer I think you're splitting hairs here... When I said "C development" I meant "writing code in C". If you want to do firmware engineering, drivers, etc, I suggest you still learn *nix. If you want to know where to start, there are plenty of resources online, or you can do what I did and just install Arch Linux and build up a system from scratch.
There's a reason you had trouble finding info about C on Windows online... because its a bad idea.
Thank you for all who helped. I finally ended up figuring it out. It involved using modulus multiplication. I'll include my code below: #include&lt;stdio.h&gt; int main (void) { //Variables int x; int y; int z; int max; int min; int mid; int factor1; int factor2; //Statements printf("\nEnter the three integer values: "); scanf("%d %d %d", &amp;x, &amp;y, &amp;z); factor1 = x / y; factor2 = y / x; factor1 = (factor1 + 2) % (factor1 + 1); factor2 = (factor2 + 2) % (factor2 + 1); max = factor1 * x + factor2 * y; //Maximum of x and y factor1 = max / z; factor2 = z / max; factor1 = (factor1 + 2) % (factor1 + 1); factor2 = (factor2 + 2) % (factor2 + 1); max = factor1 * max + factor2 * z; //Maximum of the entire data set factor1 = x / y; factor2 = y / x; factor1 = (factor1 + 2) % (factor1 + 1); factor2 = (factor2 + 2) % (factor2 + 1); min = factor1 * y + factor2 * x; //Minimum of x and y factor1 = min / z; factor2 = z / min; factor1 = (factor1 + 2) % (factor1 + 1); factor2 = (factor2 + 2) % (factor2 + 1); min = factor1 * z + factor2 * min; //Minimum of the entire data set mid = x + y + z - max - min; //Solving for the mid by process of elimination printf("\nOrdered values: {%d, %d, %d}\n\n", min, mid, max); return (0); } 
So? Doesn't mean you can't call Dijkstra, Ed. It's way closer to his name than Bob.
&gt; He says he wants to be a "firmware engineer" - well - then learn the OS the firmware engineers are using to write C code Firmware engineer here. The embedded OS I code for is proprietary, so knowing Linux doesn't help. Same if you're using one of the big name ones... VxWorks, µC/OS, FreeRTOS, etc. But actually, we code a lot for Windows. Our software is cross-platform, so we have to make it work on Windows no matter what. But we also run Windows for our dev machines because the embedded compiler is Windows only. So when I want to whip up some demo code for something, do I fire up Linux? No, I just code for the OS I'm already running. It's not like Windows doesn't implement the standard C library.
 $ ./sort Enter the three integer values: 1 1 2 Ordered values: {4, -4, 4} $ ./sort Enter the three integer values: 0 1 2 zsh: floating point exception (core dumped) ./sort
If you include games consoles as firmware programming (which they are, a bit more powerful than traditional firmware but don't include an OS then most programming is done on Windows machines). On the GBA I would use a software emulator before deploying to hardware since it was a faster turnaround.
Why has nobody mentioned mingw without cygwin? It's pretty much the same as what OP is doing except without the strange stuff windows adds like using %I64d instead of %lld. You don't need to learn linux to use gcc. That's how I started anyway. Also, as a bit of a noob myself having almost exclusively used gcc, how does the VS compiler(does it have a name?) compare to gcc or clang? 
man strcmp
Do you really though? I mean, that sort of thing can be learned at any time, can't it? Why is it a prerequisite for using an IDE?
Open a terminal window and type 'man strcmp'. And then read the whole thing. Edit: Also, it's "lose", not "loose". 
Googling 'man strcmp' also works. All of the C standard library and POSIX functions have manual pages. If you're on a unix-like OS such as Linux, BSD, or OSX, the 'man' command is used to read the manual. Learning how to read the manual should make your life much easier, as it relates to C programming anyway.
Try testing your function with different input values - you should soon see that it doesn't actually work.
well first off your code doesn't actually work, as SantaCruzDad, pointed out (although its very close). for `double` vars remember that fractional exponents have a corresponding radical representation 
It's not just not knowing how to write Makefiles—it's being oblivious about how the C code you writes ends up being turned into an executable program. I've seen really weird ideas about what you can and can't do in C on Stack Overflow which mostly stem from people having never actually seen how the compilation process works.
I do know about C99, but I prefer to declare variables at the beggining of the function, initialize them later and do everything else later
There's two ways you can do this: void f1(date d) { d.day = 10; } void f2(date* d) { d-&gt;day = 10; } int main() { date main_date; f1(main_date); f2(&amp;main_date); } The difference, as with any time you use a pointer for arguments, is `f1` makes a copy of the structure while `f2` does not. This means that `f1` will not modify `main_date` while `f2` will. For large structures, making that copy can add runtime overhead that you might not want, in which case a pointer is the way to go. You can use `const` to make sure nothing is actually changed.
while (C != C++) ignore(post);
Came here to correct the original function; this is a big improvement. It does have me thinking though, since 0^0 is undefined, should it return NaN in that case?
Waiting until you're ready to initialize the variable helps to avoid errors where you accidentally use uninitialized variables, or even use the wrong variable entirely. There was a question on SO this week; I can't find it now but it turned out the issue was that the code had `int temp, temp1;` near the start; and then a long way down the function, in just one place `temp1` had been used instead of `temp` inside a loop Both variables could actually have not been declared until the inside of the loop they were being used in, which would have let the compiler catch the error. 
Please consider posting job posts to /r/cjobs.
http://cdn.cs50.net/2016/x/psets/1/pset1/pset1.html Scroll to the mario section. Maybe thats a better explanation.
Yes, you are explaining what it is *supposed* to do. But that is only the first part of explaining why "it doesn't work." I now understand what it is *supposed* to do. But what is it doing instead? Why do you say it doesn't work?
When the for loop "for(length = length - 1; length == 0; length-- )" begins, it seems to think length is zero. i don't understand why?
What do you intend that loop to do? Here is what it *actually* does: 1. Evaluate `length = length - 1`, which decrements the value of `length` by&amp;nbsp;1. 2. Test the continuation condition `length == 0`. **This is a continuation condition. The loop will execute only if this condition is true. If this condition is false, the loop will terminate.** So the loop will immediately terminate without ever executing if the value of `length` before the loop begins is anything other than&amp;nbsp;1, because unless `length` begins with the value&amp;nbsp;1 then the condition `length == 0` will be false, and the loop will terminate. Note that the condition of a `for` loop is a *continuation* condition, not a *termination* condition! 3. If the condition tested in step&amp;nbsp;2 was true, then execute the body of the loop. 4. Evaluate `length--`, which decrements the value of `length` by&amp;nbsp;1. 5. Go back to step&amp;nbsp;2.
No problem. Just take some time to provide more detail that's all. *Help us help you*.
&gt; Can someone write me the function, and the call of the function in main and why uses pointers, dereferencing, -&gt;, etc... Here on this sub (and in other places on the Internet), we aren't going to just feed you an answer. We will help you, not do it for you. See [this document](http://www.catb.org/esr/faqs/smart-questions.html). What have you already tried? Can we see the code that isn't working? Where else have you tried to consult for an answer?
Are you sure you understand why it's throwing that warning and error? If you did I think you'd see what the issue is immediately. Since that's not an answer to your question though (more a question you should be asking yourself), here's whats going on. If you haven't changed anything in the posted header and te.c file the problem is because you haven't defined a function called newDeque(); you have one called createDeque(). So the compiler sees a function it hasn't found a prototype for so it assumes it returns int (your first warning -- pointer from integer), then during linking it can't find a reference to the function since it doesn't exist (the linker error).
I got it to work. Thanks! #include&lt;stdio.h&gt; int main(void) { int height = 0, width = 0, length = 0; printf("enter a number: \n"); scanf("%i", &amp;height); while(height &lt; 1 || height &gt;23){ printf("BEEP! Try again!"); scanf("%i", &amp;height); } for(length = 1; length &lt;= height; length++){ printf("\n"); for(width = 1; width &lt;= height; width++){ if(width &gt;= height + 1 - length){ printf("#"); } } } while(length != 0){ for(length = length - 1; length != 0; length-- ){ printf("\n"); for (width = length - 1; (width != 0); width--){ printf("#"); } } } } 
Thanks! That was exactly it.
Thanks a lot for the reply! Got it figured out :D
Say you want to compute 2^x for non integer x. First we break it into an integral and a fractional part: x = q + r where 0 &lt;= r &lt; 1. We can easily compute 2^q by just setting the exponent of the double. Now we just need to compute 2^r and our answer is (2^q)(2^r) = 2^(q+r). There are a couple ways to compute 2^r. A common way is to evaluate a closely fitting polynomial. Say of degree somewhere between 5 and 10, depending on the accuracy and computational trade off we want to make. Look up Horner's rule for how to evaluate a polynomial quickly. There is more than one way to choose a fitting polynomial. The most obvious, but not the best is to use a truncated Taylor expansion of our function. We can also choose d+1 points (where d is the degree of our polynomial) and solve using a linear system the best fitting polynomial that goes through those d+1 points. This linear system has special structure and can be solved in n^2 time if desired using the Newton basis polynomials. Which points to use as control points has a great impact on the accuracy of your overall approximation. In general using equally spaced points will result in high error around the boundaries (r=0 and r=1). Using the Chebyshev nodes will dramatically improve this error. Finally, you can use the Remez algorithm to choose the optimal control points that minimize the maximum error in the approximation.
changed it to 0&lt;m &amp;&amp; m&lt;13 still if I enter 13 it still runs..
DId you recompile?
im just simplifying things to test out my coding skills. learning by myself :3
Show us the new code? Also, I think you have a bug where you won't actually hit the February code because of how your if-else if is ordered. And why do you try to handle February properly, but not the 30 vs 31 day months? I might suggest using a switch case instead of these ifs: switch(m) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: // handle 31 day months break; case 4: case 6: case 9: case 11: // handle 30 days break; case 2: // handle February break; default: // handle bad input } You could make this even better (more readable) by adding constants for each month name like #define JANUARY 1 or const int JANUARY = 1; And while you're at it, consider replacing your single letter variable names with words, for example, change d to day. This will make your code easier for others to read. Not so difficult to figure out on something small like this, but that becomes a big deal on large, complicated projects.
Again, that's personal opinion. I develop on Windows and it doesn't bug me the way it seems to bug you. Different OS' are different, with their own strengths, weaknesses and idiosyncracies.
I don't see how portability comes into this. I see loads and loads of software written in C that only runs on *nix environments. It's very easy to have dependencies that are OS-specific no matter what OS you use.
&gt; I think you used conio.h functions on dos? Yes, true. In fact my 1st programming was pre-DOS, and yet I'm still learning, lol. conio.h still finds use in Windows console programming, however. MS has made it possible to develop fully windows-compatible console apps now. It's nice for those of us - although few - who still like the simplicity and coloration of console apps. &gt; I used ansi codes on my msx and xt :) Yes, yes - ANSI codes for color and blinking and stuff. I remember that -- nice. And whatever happened to ANSI art, heh :)
I understand and respect your perspective on it, FUZxxl, and that you aren't the only one with that perspective. Additionally, I anticipated your response. Please know the post wasn't made with the motive to be an irritant to you, but just presented as an option for guy who flatly stated he's a beginner who's only used to Windows, and clearly wishes to accelerate his learning. What I presented could enable that -- yet I'm in full agreement it's not ANSI. Kindly, -z EDIT: if you'd like posters to abstain from non-ANSI posts, please consider stating that somewhere plainly in the side bar? This *might* help eliminate a lot of future frustration. (If it's already there and I didn't see it -- sorry). 
Should really be a rule against obvious homework questions.
Thanks. I don't mind all the excitement :)
&gt; Please know the post wasn't made with the motive to be an irritant to you, but just presented as an option for guy who flatly stated he's a beginner who's only used to Windows, and clearly wishes to accelerate his learning. What I presented could enable that -- yet I'm in full agreement it's not ANSI. The point is, that while a beginner gets somewhere with using non-standard APIs, he is going to be trapped in a Microsoft mindset and is going to have problems writing standard C programs. That's why I recommend beginners to not use Microsoft Windows as their first platform, so they learn what standard C is and can subsequently distinguish non-portable extensions from standard features. &gt; you'd like posters to abstain from non-ANSI posts, please consider stating that somewhere plainly in the side bar? This might help eliminate a lot of future frustration. (If it's already there and I didn't see it -- sorry). There is no rule against non-standard C in this subreddit and there probably won't be. Feel free to ask about Windows specific questions. I'm against Windows as a first platform as a person, not as a moderator of this subreddit and I'm not going to remove any posts just for that.
i still like console apps. I think on an operating system such as linux or unix they are much more thought out and easier to use then their graphics counterparts. Especially the piping function so you write filters to one simple thing and pass text forward i find appealing. And you don't need a gui for doing that :) I think there are still ansi packs released btw!
I forgot to mention that I'm trying to ditch the standard libs to make my own, except for `unistd.h`
For the actual summing, there are two ways to do it; with a loop and without. For the loop version, you need a third variable to hold the running sum, and then loop from Alpha to Omega, and adding the value to the sum at each step. If you want to do it without a loop, you can use a formula which looks something like (Alpha + Omega) * (((Omega - Alpha) + 1) / 2), which is a generalization of the formula usually mentioned in reference to [Gauss](http://mathcentral.uregina.ca/QQ/database/QQ.02.06/jo1.html). Make sure the division is done as a float, or it will not work for a series with odd number of values.
Software written for the UNIX environment can often be easily ported to Windows with the help of either Interix or Cygwin. The other way round, it's not so easy.
I'm pretty sure glibc has their own implementation (due to GPL) although I'm sure it's very similar. Edit. I always assumed it would be some asm bit trickery and anything I do will be generally slower but it seems it might pay to use my own when I only need certain special cases Edit2. [Here's glibc version which is surprisingly shorter](http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=math/w_pow.c;hb=HEAD)
Okay, let me help you by explaining everything, providing hints and a working program too. Though try not to check the working code, unless you really can't understand the explanation. Here we go! First, you will need to include a header file. This header file is called **stdio.h**. This header file is needed for you to be able to use functions like **printf** and **scanf**. For this task you won't need any other header file. The way to include a header file in C code is to write: #include &lt;stdio.h&gt; Next you must specify your **main** function. This function is the first function being executed when you run your executable. In C you specify your **main** function like this: int main() { /* Your code goes here */ } After that you should think about what variables you will need. The first 2 obvious is M and N. You refer to them as constants, but then you go on and say the user must initialize their values. So let me take a guess and tell you that they should not be called constants. Constants are set by the coder not by the user. Meaning that with every execution the user can set M and N to whatever he/she likes to get different results for each combination. So they are not constants. So you need these 2 variables. You name them Alpha and Omega. You should learn that variables tend to be lowercase words and have a meaningful name. So a better naming would be *min* and *max*. M and N do not make clear which is expected to be greater, and Alpha and Omega, while good candidates are adding a complication layer. You should write simple code, you'll thank me later! You declare variables like this: int min; int max; Though a shorter way is by separating each variable with a comma: int min, max; Then you need to prompt the user to enter 2 numbers. You can print a nice message to notify the user that he needs to take some action: printf("Enter first number: "); But this line only prints a string. You actually need to store the input the user gives you. You do this by using **scanf**. scanf("%d", &amp;min); %d means that you expect and integer. Then the input goes to the variable *min*. If you need to know why there is an "&amp;" in front of *min* ask me, but you don't need to know yet, just keep in mind that **scanf** needs this syntax. (for a reason though) Okay, now we can ask for the second number in the same manner: printf("Enter second number: "); scanf("%d", &amp;max); Now that we have the 2 numbers we must check that the second is greater than the first. In C we can do this with an **if** statement: if(max &lt; min) { printf("Error: The second number must be greater than the first number!\n"); return 1; } Don't get overwhelmed! The first line means that if the condition inside the parentheses is true run the code inside the curly brackets. So if by any chance *max* is lesser than *min* we run the code inside the if statement, we have caught an error. The second line just prints our error message. "\n" means *new line*, a special character that acts as if you pressed the "Enter" key. It adds a *new line*. And lastly, *return 1;* means that the function running right now (in our case, **main**) must exit. It is convention to *return 0;* if everything goes okay, and *1* or *-1* otherwise, inside the main function. This is because **main** expects and integer as a return type as stated above (*int main()*). So if there is an error, our program will quit printing a nice message right before. Now, we dive into the heart of the task. We must calculate the sum. We can do this by using a formula as others suggested here, but you stated that you *have* to use a **for** loop so we will go that route. Calculating sums is a common task and has a common solution. You create a *sum* variable initialized to *0*. And you add your new number to the previous sum. At the end of the day you will have the total sum. But because we are using a **for** loop we must use an extra helper variable. It is convention to name this variable as *i*. So, let's declare these variables and initialize *sum* to *0*: int i, sum; sum = 0; A better approach though, would be to declare every variable in one line. So the line *int min, max;* above could be changed to: int i, min, max, sum; It's a lot cleaner. Now we need a **for** loop. Let me show you and then explain: for(i = min ; i &lt;= max ; i++) { sum += i; } In the first line, our helper variable *i* get initialized to *min*. For each iteration of the loop *i* will get incremented by *1*. That's what *i++* means, it's the same as writing *i = i + 1;* but shorter. The loop will run until *i* reaches *max*. So if *min* was 2 and *max* 4, *i* would get these values: 2, 3, 4, 5. Note that when *i* becomes 5, the statement *i &lt;= max* is not true so the code inside the **for** loop won't run. Now we have this line: *sum += i;*. This is the same as writing *sum = sum + i;* but again, a lot shorter and cleaner. Lets trace the code with *min* = 2 and *max* = 4. First *sum* is *0*, *min* and *i* is *2* and *max* is *4*. *i* is lesser than or equal than *max* so *sum* becomes *0 + 2 = 2* and *i* becomes *3*. *i* is lesser than or equal than *max* so *sum* becomes *2 + 3 = 5* and *i* becomes *4*. *i* is lesser than or equal than *max* so *sum* becomes *5 + 4 = 9* and *i* becomes *5*. *i* is not lesser than or equal than *max* so *sum* remains *9* and the loop ends. 2 + 3 + 4 = 9 just like *sum*, so the code is working as expected. Now let's print the result in a pretty way: printf("Sum between %d and %d: %d\n", min, max, sum); As I said above, "%d" means that we expect and integer. The first "%d" will get replaced with *min*, the second with *max* and the last one with *sum*. In our example we would get this output: *Sum between 2 and 4 is 9* Now that we achieved what we wanted, we need to exit the **main** function. As everything went okay, we can type: return 0; Our job is done! Now, try to write the whole code in a *sum.c* file and compile it like this (assuming you use Linux/Mac): gcc -Wall sum.c -o sum gcc is the compiler, -Wall means print the warnings, sum.c is our input file and -o followed by sum, means that the output file, our executable should be named *sum* If you won't specify an output name file, gcc will create by default an *a.out* executable file. Now run it by typing: ./sum and pressing enter. This is all you need, I tried to explain every step. I will provide a link to a working code but please at first try to compose it yourself. It won't have anything that I didn't mention. If there is something you didn't get, just ask. If I made any mistake please tell so fellow redditors. Link to working code: https://gist.github.com/anonymous/6fe5f2c11dc6aadd068d Hope I helped! Good luck!
You might just want to use a while loop. Your do while is only executing once 
Have you done a printf on another? When you take in input? 
I think this spambot had some kind of mental breakdown
Well, then using the power series for ‘pow’ is the right answer. 
Thank you so much
First, this is C++ code posted in a C programming subreddit. Second, if you do post your question somewhere else, you need to include more information. You've said what you expect to happen, but you haven't described what's actually happening. Which values are "completely wrong"? One thing I notice is that your examples are calculated as the tax rate applied to net income (income - deductions), but your code is calculating the rate on the full income.
Thanks I posted in the correct subreddit. https://www.reddit.com/r/cpp_questions/comments/45b1kq/guys_my_code_isnt_outputting_correctly_some/ the link is my post with correctly formatted code.
Fair point. I was trying not to introduce too many potentially new (to OP) bits of syntax at once, but you're right, an enum is really the way to go.
You cannot just insert in a file. In your situation, either make a text file for each save, or somehow copy the content of the file into another auxiliary file up to the line you want to modify, then modify it, and then append back from the auxiliary file to the initial file. edit : files or other buffers
A "Thank you!" is more than enough for me! Glad I helped...
Understood on all and thanks your kind reply!
Usually you would have separate save files instead of one consolidated save file, then the user is able to save as many games as they like (up to the limit of available storage of course). If you really want to limit it to 5 saves, you can just name each of your files `save1`, `save2` ... `save5`. If you *really* want to save all five games in the same file, then typically you would ensure that save data is the same length for each save, for example, 32 bytes for the player's name, 8 bytes to store progress. Then you know that your save data will always be (32 + 8) * 5 = 200 bytes, and that slot one will be at offset 0, slot two will be at offset 40, slot three at 80, four at 120 and five at 160. To save data in the second slot, open the file (with mode `r+`), seek to offset 40, and write the 32 bytes of the player's name (padded out with zeroes perhaps), then write the 8 bytes of progress data, and close the file. Change the size of each field as you see fit. Better yet, create a structure, e.g.: struct savedata { char playername[32]; unsigned long score; unsigned long level; }; Then you can just write these to a file. For example, seek to the 3rd record using: FILE *file = fopen("savegames.dat", "r+"); struct savedata mysavedata; strcpy(mysavedata.playername, "Ronald"); mysavedata.score = 12345; mysavedata.level = 4; // assuming saveslot is 1-based int saveslot = 3; fseek(file, sizeof(struct savedata) * (saveslot - 1), SEEK_SET); fwrite(&amp;mysavedata, sizeof mysavedata, 1, file); fclose(file); 
The file should be opened in binary mode for this. (`"r+b"`)
You don't have to write a struct direct to file (in fact that is a non-portable idea anyway). The key idea to understand is that if you make your file contain the data in fixed-size records, then you can modify one without having to rewrite the whole file. 
Get Oracle VirtualBox and put a Linux .iso on an external hard drive or USB connected over USB 3.0. Install Linux flavor of choice, sudo apt-get install gcc and begin playing with C. If you want to continue with Windows, do so, just know that Linux has more intelligently written structures, data types and function calls than Windows and like others have said, Linux has more resources written about it's particular flavor of C.
I could just not understand this, and the null byte byte character could be the same as null, but why isn't the for loop that is causing you problems set to terminate when the next entry in the list is equal to NULL? If the pointer were not pointing to anything, in my previous experience I've always checked for it being equal to null. When you create the list, do you set the next pointer contained in the last entry of the list equal to NULL?
You mean you want to read the entire file into a buffer? That somewhat defeats the purpose of the function, but okay: fscanf(yourFilePointer, "%[^EOF]", yourBufferPtr); Note that this WILL break if your file is longer than your buffer. The proper way to make sure you read an entire file would use the file functions to determine the length of the file in question, allocate a buffer large enough to hold all that, *then* read the file into the newly allocated buffer. 
Hi, There are some issues in your program, and some style points to consider. First of all, the reason why length() sometimes gets stuck, is that you are allocating memory with malloc(). Malloc does not initialize memory! That means, any random garbage data can be in your variables at any time, so -&gt;next can be any value, zero or otherwise. And there are places in your code where you do not explicitly set -&gt;next = 0, like on line 119, where it might slip by you if carry is not == 1. To check user input, you can use if(strcmp(number, "0") == 0). This will tell you if the input is exactly "0". You also need to handle empty strings somehow, just pressing enter at the moment will cause your program to hang. Then some other things you might want to think about. In your length() function, you check against '\0'. While this is technically correct, it looks really weird. Better to use 0, or define a NULL value and use that, to make it more clear that you are doing pointer comparisons. When checking lengths of strings, consider using strlen() rather than making your own version. Your digit handling code does not check that it actually only gets one digit, e.g. entering "a" as a value will result in -&gt;digit becoming 49. In many places you could skip using your length() function at all; since your are traversing your linked list anyways, you could loop "while(pointer != NULL)" rather than counting the number of elements you check in on.
Is it written in C or is it written in C++? These two are different languages. Please choose one.
when you use scanf to store a value into the int variable, in the input buffer whatever remaining things you entered stay there. For example say you put the number 21 then 'enter'. scanf stores 21 in num but new line is still in the buffer. To see this if you examined the value of the char variable you would see that its value is 10 (the ASCII code for \n). two simple ways of avoiding this is use scanf("%d\n", &amp; num) to ignore the newline or use getchar() after the call to scanf to free up the input buffsr. Sorry if my wording is a bit confusing, wrote this on my phone. If you need more help feel free to ask. 
Yes sorry, If I have something like this void strcpy (char x[], char y[]) { int i; i = 0; while ((x[i]=y[i])!='\0') i += 1; } -how does the computer read the statements in the while loop?
there aren't multiple conditions. '=' is an assignment operator. so, variable is storing the result of variable1 and variable 2. without context it's difficult to see what you're doing, but the while loop should be checking the value of variable as its condition
Please also note that this is bad code, because if `y` is longer than space allocated for `x`, at best you'll segfault, and at worst you'll trample some other data and have to deal with a potential vulnerability.
Thanks for explaining that. I was thinking of characters more as objects I guess, and forgot they were just numerical values. And I guess I had just assumed the thing about pointers pointing to null by default. But now I realize that's what makes it even more important to set them to null when they don't point to anything. I'm not all that experienced with straight c yet, so it's also nice to learn about the existence calloc.
Not to sure where all the hate for c development on Windows is coming from. Using codeblocks with a gcc compiler works (for the most part) just fine for me, granted I'm still very much so a beginner. The only real problem and the thing that lead me to switch over to linux is the lack of memory debugging tools. keeping track of freeing up memory and the like manually becomes bothersome to say the least. 
I'm not there yet :) I'm just two weeks into my class
How are you formatting code markup inline?
Surround the text with `.
Please notice that this subreddit is about C only. Please ask questions about C++ elsewhere. Also, please understand that this is not your subreddit. If you want to get answers to your questions, consider being polite instead of condescending.
I don't think it's correct to set the tail to be equal to the input? You should only be incrementing and decrementing head and tail (and mod with max size), not assigning the value being inserted. I recently implemented a [Deque in C](https://github.com/php-ds/ds/blob/master/src/internal/php_deque.c) (for PHP), might find what you're looking for here. However, I'm gathering that you're implementing a Deque for educational purposes. If that's the case, I urge you to only use my implementation as a reference when you're stuck, rather than a complete solution. I also made a [video](https://vimeo.com/154438012) for a [blog post](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd).
I'll take a look at it for reference only. It is for education purposes... Professor gave us an example of a queue (not deque)... In his insert he had just: q-&gt;items[q-&gt;tail++%q-&gt;size] = new_value 
But you're saying `q-&gt;tail = input` instead of `q-&gt;items[q-&gt;tail] = input`. The example your professor gave you increments the tail, then mods the size. The correct approach is to update the value at the tail first (which is one cell to the right of the last item), and then move the tail forward: q-&gt;items[q-&gt;tail] = input; q-&gt;tail = (q-&gt;tail + 1) % q-&gt;size; &amp;nbsp; 0, 1, 2, 3, 4, 5, 6, 7 [_, _, _, _, _, _, _, _] head=0, tail=0 insertRight "c" [c, _, _, _, _, _, _, _] head=0, tail=1 insertLeft "b" [c, _, _, _, _, _, _, b] head=7, tail=1 insertLeft "a" [c, _, _, _, _, _, a, b] head=6, tail=1 insertRight "d" [c, d, _, _, _, _, a, b] head=6, tail=2 ^ ^ T H I would recommend using pencil on paper to step through your algorithm. Determine what you want to achieve then step through your code one line at a time. Literally draw each step.
First, it's worth noting that (AFAIK) `const` variables *can* be initialized with pointers to other variables. I'm fairly certain this is fine by the standard. Thus, this is valid: const struct mystruct list[] = { { .a = 0, .str = "abc" }, { .a = 1, .str = "def" }, }; const struct mystruct2 foo = { .name = "foo", .list_of_mystructs = list, }; That said, it is entirely possible to remove the `list` variable, it's just not as well known feature. It's called a `compound literal`, which is just a fancy name for a variable declared in-line without a name. They're a C99 feature, and `gcc` allows you to use them to initialize static variables (Which is technically illegal by C99 standards) with a `compound literal` made-up of only constants (IE. It can be figured out at compile time, like your examples). The syntax looks like this: const struct mystruct2 foo = { .name = "foo", .list_of_mystructs = (const struct mystruct[]) { { .a = 0, .str = "abc" }, { .a = 1, .str = "def" }, }, }; Essentially, you take the initialization pat of the original declaration (Everything inside of the `{}`), and then "cast" it to the type you want (It's not *really* casting in the normal way, but it's a simple way to think about it). In the program, this will result in exactly what we had before, but the `list` variable doesn't exist. You also might like to know that you can initialize individual array elements by specifying the index: const struct mystruct list[] = { [1] = { .a = 1, .str = "def" }, [0] = { .a = 0, .str = "abc" }, }; That gives you the same list as above. IIRC, if you use that syntax you can still leave the array index empty on the declaration. And of course, that can all be combined: const struct mystruct2 foo = { .name = "foo", .list_of_mystructs = (const struct mystruct[]) { [1] = { .a = 1, .str = "def" }, [0] = { .a = 0, .str = "abc" }, }, }; Also, you can chain `[]` and `.` together to access members multiple levels deep. Ex: const struct mystruct2 foo = { .name = "foo", .list_of_mystructs = (const struct mystruct[]) { [1].a = 1, [1].str = "def", [0].a = 0, [0].str = "abc", }, }; Also, it's valid to make the entire thing modifiable (IE. non-const). struct mystruct2 foo = { .name = "foo", .list_of_mystructs = (struct mystruct[]) { [1].a = 1, [1].str = "def", [0].a = 0, [0].str = "abc", }, }; It's should be noted that a compound literal's lifetime is the same as a regular variable declared in that scope would be. So, for global variables, they're valid for the lifetime of the program as you'd expect. But for functions, they are only valid *for the lifetime of the function call*. Thus, it's not valid to return a pointer to a compound literal like it would be to return a pointer to a string literal. This is true *even if you declare the compound literal `const`*. I've been burned on that a few times.
Your second sample has an issue in that there is no way for the user to know how many items are in the array. In the samples with `(const struct mystruct[])` you would also need to change the structure member to `const struct mystruct *`.
I updated the file and this is what it looks like: http://imgur.com/HLt1YRk Does it make sense? I used 0's markers? and space as a common delimiter.
I think it's iterating through the array until it reaches the end, and copying (what's probably a string) from y to x. If y[i] isn't the null byte '\0', assign the value to x[i], then increment i.
Very good point. NULL terminated is always an option. Of course, if you want to be able to get the size with `sizeof`, there's no real replacement for just declaring the array separately and using `sizeof` to get the size. If you declare it `static` then at least it won't be seen outside of the current file/compilation unit, but it's still not perfect. Though, a lot of the time I get around this by creating an `enum` for all the elements in the array. Then each entry in the `enum` gives you it's index into the array, and you can add an extra member to the end of the `enum` to get the total number of elements. There's a few different options, but you're completely right that with the example it's impossible to figure out the length of the array. Also you're right, though it does still compile with a warning. I was originally giving an example for creating a global `const` variable that way, but since OP didn't originally do that he didn't declare it `const` in the `struct`. That last example without any `const` compiles without any warnings.
normally on a file you read a line until EOF (end of file) marker is read. fp = fopen ("file.txt", "r"); //open the file as read only while (!feof(fp)) //read the file fp as long as fp is NOT the end of file marker { read the file using fread into an array } fclose(fp); you may want to google feof or look at your IDE's help if it has any. Also you need to initialize declare/define etc etc etc. This is This is one of many ways to do it.
All the custom function I use are not broken (went through stress tests), and before posting I tested to replace my custom by the system functions and the result is the same. I dont know why but the client seam to receiv a signal that kill it, but I dont how becouse the only signals I send are from the client to the server's pid :/ 
1) Add some debug prints! Print out everything. Try printing the PID before the start of the loop sending signals 2) Are you launching this from a debugger? By default, gdb will catch the signals, even if you have a handler registered. If that's your problem, just hit 'continue' and you should be good to go. 
got it just set sum to 0 and its working flawlessly now. Thanks. Out of curiosity, why did it work when i used float instead of int, but still didn't define sum 
Dunno, floating point register happened to be 0 at the time? It's not guaranteed to work, it just happened to -- such is the nature of undefined behavior. For what it's worth when I just grabbed, compiled, and ran your source I was getting the correct values because sum happened to be 0 when I accessed it, but there is no guarantee that it would or always will.
In C, if you don't explicitly set the value of a local variable, its value is *undefined.* It can be anything and usually the compiler doesn't care. By chance, altering the program to use a different type for `n` might have changed the undefined value to 0. Don't rely on that. Always compile with warnings turned on and listed to what the compiler says to you.
Thanks for the info!
You need to copy the bytes to the end of your buffer. Start with a pointer to your buffer. Make sure it's big enough. Keep track of how much you've stuffed in there, and COPY the MEMORY...maybe there's a function for MEMory CoPYing? 
Haha, I appreciate the hints. Something like below? I just keep getting strange errors and can't believe that string building is so complicated in C :/ char * allMessages; while(condition not met){ recv(connection, buffer, BUFFERSIZE-1); char * temp = allMessages; allMessages = malloc(totalNumberBytesReceived); strcpy(allMessages, temp); strcpy(allMessages, buffer); } edit: do I need a memset on allMessages before I malloc or idk
Woah woah woah, how do you specify where in the buffer for the recv to place the message? recv(int sockfd, void *buf, size_t len, int flags)
buf is a pointer. You can add something to it..... See my comment above. recv( sock, buf + 3, ........ ) 
Well, you should know the length of your buffer. You can realloc() if you run out of room. It's best not to call realloc() every time though, because it's expensive. Now you'll need to keep track of your buffer, your offset, and how big it is.
String building can be made much easier with `fmemopen()`.
Thanks for your help!
Wow, this is an incredibly helpful blueprint for what I need to do. I think I should be good on the detail that /u/OldWolf2 mentioned since I'm generating this with a program I'll simply add another variable describing the length of the list inside mystruct2. Did you have to do something similar to this yourself at one point? Most of the examples I could find on stackoverflow were overly simple and what you've detailed is some pretty in depth knowledge of C. Very impressive. EDIT: I've been writing C for the last 4 years for the industry and I never had to do this myself so I just had no idea about the more complex options. 
Please don't delete your posts after receiving an answer. That's bad style.
Just hit the space bar a few times.
Well, you'll need to fix a couple of things; - there's an error with an ending } - you don't initialise i, j and wordcount to zero. - i'd ditch nxtword and the calls to it, it has no added benefits and complicates things. - there are some off by 1 errors - you should reset j to 0 - try to use fgets instead of gets These are some quick changes i made which made it work ok i think; - i = j = wordcount - 0; + i = j = wordcount = 0; - if (j == wlen) { + if (j == wlen - 1) { + j = 0; i++; Enter String: I only have 2 cars, but I want hundreds of cars.. Enter the required word: cars Word count: 2 
I'm currently going through http://c.learncodethehardway.org/book. It's a bit boring but it's trying to teach you a mindset too. If you want to learn it together, send a pm. We could make a chat and help each other understand better. The C Programming Language must be good too.
The Harvard cs50 class on edx uses c. It was fun. 
I'm going through C at the moment and really enjoying it. I'm currently using: * Lynda.com - C courses. (There are 4 of varying scopes) * Sams Teach Yourself C * Zed Shaw's learn C the hard way. I'm getting a good feel for it and the mindset with this setup. Zed Shaw has you typing it all out yourself and compiling from the command line without the comfort or spoon-feeding of an IDE. Sam's Teach Yourself has you using Code::Blocks (or an ide of your choice, providing exercises too at the end of chapters). Lynda.com I'm using supplementary to the books. They have good content for watching someone talk about the language but always let themselves down pasting in code and missing out explanations. To remedy that I'm using all the courses on there and as well as doing the intermittent exercises they give you I am typing out all the content from the videos and reading into it and breaking it as you are shown in the two books. Also I'm aware the C hard way book is online but I'm finding the videos that come on an accompanying disc really refreshing. I have the K&amp;R C book on order too but I doubt I will be using that until I am happy that I have a good grip on the language. Hope some if this might be of use to you! 
I'm working with my current constraints. I cannot modify the calling code. So no, there have been no solutions.
Unfortunately I can't get away with this assumption for my current situation, I tried it and it would only receive a partial. The calling code may be invoking multiple send() statements so I need a way to terminate with little knowledge of what they're sending.
This is a terrible reference for learning C, and some of the things taught in it are downright wrong. KN king's book is a much better option, and if you want the truly classical method, read K&amp;R C. 
Do you have an example of a downright wrong thing taught in it. I believe the author has the best intentions. Now that I finished half of it I think I will finish it, after I finish it I don't think I couldn't give a look over K&amp;R C; http://c.learncodethehardway.org/book/krcritique.html Edit: I found this post which is interesting: http://hentenaar.com/dont-learn-c-the-wrong-way
Unfortunately the description is really all there is to it. 1. Don't know the length of message. 2. Potentially no delimiter. 3. Connection remains open after message has been sent by sender. I think we can all see how this could be solved with a timeout - recv until delimiter is reached. If delimiter isn't reached after x-seconds, timeout and tell sender it was bad.
I think what your professor wants is that you find out that doing this is impossible, so you understand the reason why message lengths are usually sent with messages.
Get the book programming in c by Kochan
You are a beast! Reading your code is so mesmerizing. I've seen &amp; used jump tables included in struct definitions before, but many times they weren't as automated as this. I really love learning new tricks using the preprocessor or really anything that is lesser known in C and you seem to have a really good grasp on that stuff. You seem to really have a good strategy down for generating most of the supporting code. I like how you used macros in your base window initialization too. I think I might go that route as well. With respect to all the tricks you mentioned using (generating xmacro files, string tables, jump tables, etc), do you have any resources that detail that or is it mainly just the source code?
I haven't read Sam's Teach Yourself C, but other Sam's Teach Yourself booms have been great references, so I'll say that's probably a good resource!
I would check out K&amp;R for the core concepts of the language, then check out the 21st century C book to get a more modern perspective of you want to keep going
It depends on your compiler and how it's configured. On a unix system, it's probably /usr/include/stdio.h. On windows, good luck.....
and the stdio.c ?
[The website for the c## channel on Freenode has a list of things to avoid and why; though kinda vague.](http://iso-9899.info/wiki/Main_Page#Stuff_that_should_be_avoided)
So the problem lies in the function for factorials and function for the fibonacci sequence. There are no errors. But when I run the program, the answer I get is not the correct answer. 
Read all your compiler's warnings. If it isn't giving any then turn up the warning level.
I agree, a message length would be nice. I know a timeout would work, however, so it looks like that's what I'll have to do.
I have all three of the books you mentioned. I also highly recommend K.N. King's book. Can't say a bad thing about it. Great explanations, great code examples, just great! This coming from someone who tried and failed to learn C from K&amp;R.
Not a specific example, but [this post](https://www.reddit.com/r/C_Programming/comments/3a4l0y/learn_c_the_hard_way/) details most of the reasons I dislike the book.
Unlike python's print, printf doesn't automatically add a newline to the end. Try adding \\n to the end of your printf's so that they all look like `printf("%d\n", something);`. You'll have an easier time spotting the mistake that way.
c is free but at the same time it is a bit strict(coming from python,but i like how my programs stop responding if i mess up lol)
Your page appears editable... nothing there.
You could use macros to achieve this effect, but macros only allow you to define identifiers (if I recall correctly) and even if you could define punctuation, something like `&lt;-` is more than one token and a macro name is always a single token. The operator names are pretty much hardcoded in the C programming language.
To answer to another comment, click “answer” right below that comment. Otherwise the user you answer to is never notified of your attempt to answer.
Hi Jack, I know that it will have a cascading effect on operators which uses the = ( i.e. == may become &lt;- &lt;- or := := and other nonsense). But out of curiosity, is it doable without too much pain ? 
This is usually a condescending thing to say, but as the other commenters haven't explained it, I'm going to point out that you really, really shouldn't do this even if you could. `=` is the assignment operator in C. People expect it to be the assignment operator. If you replaced it with something else, you would only make your code unreadable to other people. But to answer your question, I don't think you can define a new operator called "&lt;-". You could, hovewer, do this: #include &lt;stdio.h&gt; #define is = int main() { int foo is 123; printf("%d\n", foo); return 0; } ...but please don't. And instead of `x = x + 1` you should do `x += 1` or `x++`
This wouldn't be the case, they're just suggesting that you use the simpler form `x += 1` or `x++` instead of `x = x+1`.
An easy way without using libraries is to get the input from the files: /dev/input/event{number} For example on my computer the file: /dev/input/event0 is the keyboard. /dev/input/event10 is the mouse. I will edit with some libraries I had found for this exact problem and some code. This is the documentation and the format: https://www.kernel.org/doc/Documentation/input/input.txt Check the events section in the above file: struct input_event { struct timeval time; __u16 type; __u16 code; __s32 value; }; I bet that you could also get the proper file on any linux system by parsing the right file from: **/proc/bus/input/devices**
Ok, thank you for the answer.
&gt; For example on my computer the file: &gt; &gt; /dev/input/event0 is the keyboard. &gt; /dev/input/event10 is the mouse. How do you figure out which one is which?
One way is to cat /dev/input/event{num} and do some keypresses or move the mouse. Another easier way would be to look it on /proc/bus/input/devices. So do a cat /proc/bus/input/devices, look up your keyboard or mouse and check the handler.
As far as libraries go, probably [terminfo](https://en.wikipedia.org/wiki/Terminfo) is what you want. [curses](https://en.wikipedia.org/wiki/Curses_(programming_library\)) is more popular than using terminfo directly, but it is a much more featureful library (it allows you to make a terminal-based GUI)
I believe Visual Studio has a bundled compiler to go with it: [Visual Studio Express](https://www.visualstudio.com/en-US/products/visual-studio-express-vs#2010-Visual-CPP) Also could you try cl in your cmd? example: cl file.c source: https://msdn.microsoft.com/en-us/library/bb384838.aspx Another great compiler that I use is clang which has an installer for windows: [Download Clang](http://llvm.org/releases/download.html)
In which context do you want to do this? Is this a terminal program? Or are you doing GUI programming? The answer depends on what you want to do because what constitutes a “key pressed” is different depending on how you get your input.
I've visited that page before. I have tried the cl command and it's unidentified, as i mentioned in my post. I'll try the VSE however I've tried to download VS Community and it fails because a file is missing and GNU (I don't remember exactly) is not able to run.
I am wanting to create a terminal program.
Not what you asked for, but maybe what you want: #define S(x...) #x used as: const char *glsl_code = S({ /* glsl code */ #version 330 layout(location = 0) in vec3 in_position; uniform mat4 u_projection; uniform mat4 u_view; uniform mat4 u_model; void main() { gl_Position = u_projection * u_view * u_model * vec4(in_position, 1.0); } });
"Failed to execute MSU package, Failed to configure per-machine MSU package, Failed to send progress from BITS job, Failed to acquire payload: VCRedistD12x86 to working path : ..." Those are the errors I get everytime. 
Does fgets(Input, #, stdin) not work for you? Then you can just print to stdout (unless I'm missing something, I think this should work. You can treat stdin and stdout like files)
Terminals have the concept of [*cooked*](https://en.wikipedia.org/wiki/Cooked_mode) (default) and *raw* input. If you want the input immediately and unprocessed, you need to put the terminal in raw mode. You can use ncurses to do this, or here's a short snippet from the termios(3) manpage on Linux that will also work: static struct termios termios_orig; void raw_begin(void) { tcgetattr(STDIN_FILENO, &amp;termios_orig); struct termios raw; memcpy(&amp;raw, &amp;termios_orig, sizeof(raw)); raw.c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON); raw.c_oflag &amp;= ~OPOST; raw.c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN); raw.c_cflag &amp;= ~(CSIZE|PARENB); raw.c_cflag |= CS8; tcsetattr(STDIN_FILENO, TCSANOW, &amp;raw); } void raw_end(void) { tcsetattr(STDIN_FILENO, TCSANOW, &amp;termios_orig); } (Those flags refer to physical characteristics of old teletype terminals and I don't actually understand what any of them mean, but this code works.) Here's that code in action: [Goblin-COM](https://github.com/skeeto/goblin-com). 
Every device just sends input messages. Some messages are key events and some messages are pointer events. You have to ask the user which input devices they want to use for your application: * A terminal server with many keyboards and many displays will want a keyboard+mouse pair routed to a single display. Which-is-which has more to do with physical wiring than anything else * A laptop user with an external keyboard (and/or mouse) will want both keyboards (and/or mice) running to the same display * A desktop user with two displays may have a single keyboard+mouse pair mapped to both displays. And so on. The X server normally deals with this nonsense for graphical users so *normally* you'll just receive X key events instead of accessing the input device directly, meanwhile most console users are content with terminal (character) events instead of key-events.
There are programming languages such as Go that use := as the assignment operator. Perhaps you could look into those, if this is something you really care about. 
This error is coming from your shell, not the C code. Does "./pointers" exist and have execute permissions?
Are you perhaps storing your code on a FAT file system? http://askubuntu.com/questions/370163/geany-permission-denied
does it matter if you use x or i as the place holder?
Windows 8.1 does not come with a C compiler by default. So you will need to install one in order to compile C programs. I don't have much experience with C compilers on Linux, but I have used the Borland compiler on Windows in the past. You can try installing that and use it to compile your C programs. I'd also reccomend checking out the GCC (GNU C Compiler). It is an open source c compiler which is generally used more on Unix-based systems, such as Linux. However, I believer there is a port of it for Windows, which you can try.
Haskell uses = for definitions, too. There are no assignments in Haskell, the closest thing are bindings in `do`-notation which indeed use `&lt;-`.
Go uses `=` as the assignment operator just as C does. `:=` is a separate shorthand for a declaration with assignment.
This isn't your problem, but the format string you probably want to use for printing the address is `%p` not `%x`. (And according to the standard you need to cast it to a `void *`) Consider the following program: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;inttypes.h&gt; #include &lt;stdint.h&gt; int main() { int var = 0; int *varp = &amp;var; int *foo = malloc(sizeof(int)); printf("&amp;var:\n"); printf("%%x: %x\n", &amp;var); printf("%%llx: %llx\n", &amp;var); printf("%%p: %p\n", &amp;var); printf("(void *) %%p: %p\n", (void *)&amp;var); printf("(uintptr_t) %%PRIxPTR: %" PRIxPTR "\n\n", (uintptr_t)&amp;var); printf("varp:\n"); printf("%%x: %x\n", varp); printf("%%llx: %llx\n", varp); printf("%%p: %p\n", varp); printf("(void *) %%p: %p\n", (void *)&amp;varp); printf("(uintptr_t) %%PRIxPTR: %" PRIxPTR "\n\n", (uintptr_t)varp); printf("foo:\n"); printf("%%x: %x\n", foo); printf("%%llx: %llx\n", foo); printf("%%p: %p\n", foo); printf("(void *) %%p: %p\n", (void *)foo); printf("(uintptr_t) %%PRIxPTR: %" PRIxPTR "\n\n", (uintptr_t)foo); free(foo); return 0; } Running this on my (x86_64) machine (with ASLR, so the addresses will always be different, but...), I get the following output: $ ./addrs &amp;var: %x: 7c915e44 %llx: 7ffc7c915e44 %p: 0x7ffc7c915e44 (void *) %p: 0x7ffc7c915e44 (uintptr_t) %PRIxPTR: 7ffc7c915e44 varp: %x: 7c915e44 %llx: 7ffc7c915e44 %p: 0x7ffc7c915e44 (void *) %p: 0x7ffc7c915e38 (uintptr_t) %PRIxPTR: 7ffc7c915e44 foo: %x: 1b32010 %llx: 1b32010 %p: 0x1b32010 (void *) %p: 0x1b32010 (uintptr_t) %PRIxPTR: 1b32010 Note that `%x` and `%p` give different values for the stack variable (&amp;var / varp), because an `unsigned int` can't necessarily hold a `void *` #include &lt;stdio.h&gt; int main() { printf("unsigned int: %d\n", sizeof(unsigned int)); printf("void *: %d\n", sizeof(void *)); return 0; } when run returns: $ ./sizes unsigned int: 4 void *: 8 But here are the same two programs run on a different (32-bit) machine: $ ./addrs &amp;var: %x: cfbead58 %llx: cfbead78cfbead58 %p: 0xcfbead58 (void *) %p: 0xcfbead58 (uintptr_t) %PRIxPTR: cfbead58 varp: %x: cfbead58 %llx: cfbead78cfbead58 %p: 0xcfbead58 (void *) %p: 0xcfbead54 (uintptr_t) %PRIxPTR: cfbead58 foo: %x: 7a00e6f0 %llx: cfbead787a00e6f0 %p: 0x7a00e6f0 (void *) %p: 0x7a00e6f0 (uintptr_t) %PRIxPTR: 7a00e6f0 $ ./sizes unsigned int: 4 void *: 4 
Thanks a lot. Borland worked for me though. [I followed these instructions.](http://www.cprogramming.com/borland.html) Sucks that VS doesn't work though.
Generally it is considered good practice to have the main function of the program return an integer. The integer can then be used to determine whether the program ran successfully or failed. A value of 0 is returned to show that the program ran successfully, while any other integer value is returned to show that the program failed. Example: int main() { int i = 1; if (i == 1) { // Program ran successfully return 0; } else { // Something went wrong return 1; } }
I think it would be a good idea for there to be a rule along the lines of 'we are happy to help with your question [so long as you have put effort into it](http://www.catb.org/esr/faqs/smart-questions.html)' I always mention this to inquirers I look at that seem to have not put a lot of effort into their question.
Something of the form `'...'` is a *character constant,* something of the form `"..."` is a *string literal.* It seems like you wanted the second but accidentally made the first.