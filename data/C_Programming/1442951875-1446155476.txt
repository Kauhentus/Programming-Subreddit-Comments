 yup you were right...sorry! so heres the new one, and how i call it: (its still resulting in segmentation fault...) void potencia_por_referencia(int *x, int y) { int i; int res=1; while(y!=0){ res*= *x; --y; } *x=res; } int main() { int x=2; int y=2; printf("Numero x= %d\n", x); printf("Numero y= %d\n", y); potencia_por_referencia(x,y); printf("Resultado de x elevado a y: %d\n",x); }
x is an int within main, and potencia_por_referencia() is expecting a pointer to an integer as the first parameter , maybe i didnt get your question ?
Yes, x is an `int` and you're passing it to potencia_por_referencia() which wants an `int*` You need potencia_por_referencia(&amp;x,y); 
Totally right... Thanks for pointing that out jedwardsol :)
Welp, I couldn't resist. After today's class, I just went ahead and implemented queues too. I guess I'm gonna implement even more data structures until the end of the year. 
The header files are required when you compile, so they are somewhere on your system. Find out where the default include folder is. Typically /usr/include
Thanks.
If you want to know what you can rely on to be in the standard header files, on any compiler or platform, take a look at the [the C standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf). Or the [POSIX standard](http://pubs.opengroup.org/onlinepubs/9699919799/) (which extends the C standard) for Unix-related stuff.
Very nice. Thank you.
Visual Studio 2015 Community Edition is free, will compile C (it doesn't make it obvious, but it does), and includes a profiler. Reading from memory you've allocated via malloc is just a question of "dereferencing" the pointer i.e. if you have an int at an address you could say "int foo = *pointerToInt;"
Thanks for the reply. The IDE that I use is Code::Blocks and I've been reading their website but can't seem to find if it comes with a profiler or not. I'd rather not download VS2015 if I don't have to because I read that it was a very large file.
Does MinGW come with [gprof](https://sourceware.org/binutils/docs/gprof/)? If so, use it.
I'm not sure. Profiling is still new to me. A quick google search hasn't turned up much yet. I think it's a plug-in. 
Very nice. Thanks.
Thanks. I'll look into it. You've been a great help.
Also, try to see whether there's a more efficient *algorithm* to do what you're trying to do. You can spend all day trying to optimize the implementation of a naive algorithm, but you're probably going to get a faster program if you switch to a faster algorithm (if it exists).
It does.
It makes sense to split stacks and queues into separate files.
This line: scanf("%d") &amp;weight; calls the function `scanf("%d")` and then applies the bitwise-AND operator to the result of scanf, and the `weight` value. This causes undefined behaviour in two ways: * You didn't pass an argument to `scanf` corresponding to `%d` * You used `weight` uninitialized. Modern compilers will give a warning for the scanf argument mismatch. If you did get a warning, pay attention to it. If you didn't then turn up your compiler's warning level. You meant `scanf("%d", &amp;weight);`. Also, indent your code by four spaces when posting, if you look at your own post you will see that the code looks messed up.
You're right. The program compiles because `&amp;` is the bitwise `and` operator. Since `scanf` returns an `int`, this means that the statement `scanf("%d") &amp;weight;` is valid. However, as /u/OldWolf2 said, the compiler should give a warning about the number of arguments that are passed to scanf.
Thanks, I have it working now. I'm only started learning C yesterday, thanks for the help :)
Thanks, it is working now, just a silly mistake by me, I am new to C, Thanks for the help :)
the pNotation comes from old windows days. Nobody does it anymore. Just do it like this: int ring_buffer_init(RingBuffer *ring_buffer, uint32_t size) If you use descriptive names, then its mostly obvious what type the argument is. E.g. it would be very weird if ring_buffer wouldn't be a pointer. You nearly never copy such a struct by value, especially not in a class-type function. And size is of course unsigned and a number. No need for uiSize or stuff like this.
If you want to learn about parallelization and use all your cores, then these videos on OpenMP are a great place to start: https://www.youtube.com/playlist?list=PLLX-Q6B8xqZ8n8bwjGdzBJ25X2utwnoEG And yes, reading from memory is usually faster.
A very simple method is to run the program in the debugger and then just interrupt it a couple of times and get the call stack. Look for functions that appear often, since they will be your bottleneck. The method is described here (it says C++ and Linux, but can be applied much more widely if you can get the call stack): https://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024 I'm not the author of that post, but I've personally also had a lot of success with this technique. My best win was probably the speed up of some scientific code by over a factor of 100, which cut simulation time from 4 months to less than 8 hours.
&gt; If a compiler generates assembly that "wastes cycles" then report a compiler bug. "Optimizing" compilers do not optimize, they merely improve. That is why [superoptimizing compilers](https://en.wikipedia.org/wiki/Superoptimization) were invented.
Okay. I restructured the project and renamed my arguments &amp; types. Should look like proper code now. 
&gt; Another question I have is what's the difference in read time between reading from memory and reading from a file? Is it a small factor or is it orders of magnitude? Cache makes this a difficult question, but assuming reading from a file is *actually* reading from a file, you can generally consider file I/O to be *much* slower. If you have things waiting on I/O, that is almost certainly the bottleneck by a very wide margin unless you are doing a *lot* of very expensive computation per I/O.
all you guys are jaded, I wanted help on how to finish it cuz i barely have a grasp on this, was i headed in a right direction ?, I was going to make a printf scanf statement to tell the user for the height weight, show/tell variables and finish the statement using the bmi formula with if statements and else statement, but I guess What I asked for was for you guys to do my hw
pretty cool. I like it!
When you're just writing short programs like this add `-Wall` and `-Werror` to your compiler options, it'll be a pain in the arse but it forces you to write good programs from the get go. 
Indent all the lines of code with 4 spaces so it's formatted better or alternatively put it on [pastebin](http://pastebin.com/) so we can read it better.
Thanks.
Thanks.
&gt; I heard it's a divide by 0 problem but I can't see where I'm getting that. /* Divide first element of identity matrix with given Matrix A Do same thing with Y */ ident[i][i] /= a_hat[i][i]; This is the only part of your code with a division in it. Why not just throw a printf in there to check if the numbers in `a_hat[i][i]` are 0 or not? By the way, if you are only going to use numbers without fractional parts, then don't use double. Just use `int` or `long int`. Edit: ~~Also, you can declare pointers in function arguments as pointer to whatever you want. So your `matMult` function could be defined as:~~ void matMult(char *A, char *B, char *C, int size, int L, int M, int K, char type) ~~This way, you could simply use it without having to cast it:~~ a = A + (i*size)*M + (k*size); ~~It also gives the compiler to check the types of the arguments, which is very useful when trying to catch bugs.~~ Oh I see, you are creating a generic function that works with different types of matrices. 
&gt; cross-platform Which platforms did you try it on?
Sounds like you don't understand the problem. Take programming out of the equation; how would you solve the problem? Consider a subset of the problem: let's fix the starting point at 1 meter and let's fix the bounce coefficient to 90%.what height would the ball get to after one bounce? Two bounces? Three?... Go until it's at 10cm. You've now solved the problem. Now allow for those variables go be inputted. 
Have the height multiplied by the coefficient on each bounce, the distance is the height of each bounce added up. Number of bounces is the amount it takes to reach 10 centimeters (I know this should be done with a while loop, I just don't know how)
So is your specific question "how do you do a while loop?"? If I asked you to print out "foobar" 10 times, could you do that with a while loop? Or is it that you don't understand how to track everything during the while loop? 
It's the tracking, I have a rough understanding of the loops, just not sure what to put in it
You're on the right track. Now, what happens when the ball bounces once? What should happen to those variables?
Then what are you waiting for? Go do it!
It took me around 10 years (4 school + 6 work) before I finally found a situation where goto was the best option. I was actually in disbelief at my own conclusion; it was a weird day.
Weird. I frequently find use cases where `goto` is the best way to structure control flow in a readable manner.
Does build on Linux, too. Looks pretty portable to me. Good job! Why do you use these `_s` functions on Windows?
The compiler doesn't give you any warnings?
Thanks a lot, that explains it! :) Why is testArray already a pointer? Is an array the same as a pointer? (new to C programming, used to Java and C#)
&gt; Is an array the same as a pointer? Arrays (or rather, variables that refer to an array) can be transparently converted to pointers. If you need a pointer to the first element of an array, you can either do this: `&amp;array[0]`, or simply use `array`, both expressions work.
If it really is CPU intensive and can benefit from running in parallel then consider GPU programming if you have a suitable graphics card: https://docs.nvidia.com/cuda/cuda-c-programming-guide/ The actual code for GPU programming is relatively syntactically the same as C/C++ but the way you program the GPU is very different to a normal processor both conceptually and memory wise and can lead to code that runs at no performance increase to normal serial code. There are various places you can go to find resources on Cuda C and how to develop for Cuda GPU's, it is not ridiculously difficult to get basic operations running on the GPU and there are library's for a lot of different mathematical operations see; MAGMA. Given you are running on Windows you will probably consider Nsight + Visual Studio but there are obviously other routes you can go down. Keep in mind this may be slightly difficult for you if you have not had any threading experience and you will need to consider the learning curve in regards to what you actually need to achieve.
Exactly the situation. I was doing a long resource-by-resource stack initialization. Writing it otherwise would have been a mess. I was previously unaware of the pattern, so realizing it was a legit use of "goto" was quite a day.
Yep. Arrays in C are pointers. And they're also not pointers. It's kinda hard to explain. When you do something like int array[5] = {0, 1, 2, 3, 4}; Inside a function, you're creating an actual array. You can get its size and do all sorts of array stuff with it. But when you pass an array to a function, it gets deprecated into a pointer to the first element of the array. So when you do void displayBoolArray(bool *a, int aLength){ for(int i = 0; i &lt; aLength; i++){ printf("%d", *(a + i)); } } `a`, which is supposed to be an array, gets converted to a pointer. So when you call the function, you can call it either with `displayBoolArray(testArray, 10);` or `displayBoolArray(&amp;testArray[0], 10);`. They both do the same thing. And since it's now a pointer inside a function, you can't get the size of the array and do some stuff that you'd otherwise be able to do if you were working with it as a local array. Additionally, here's an interesting thing: `*(a + i)` is exactly the same as `a[i]`. You can use them interchangeably. (And actually, `*(a + i)` is actually `*(a + i * sizeof(typeof(a))`, but the compiler automatically multiplies the `i` variable for you)
I think it would be closer to normal usage to do this more like: while(!exit) { switch {}; } 
Tagging on to you with this &gt; difference = difference/1.5; You declare difference as an int, so I'm going to hazard a guess this won't work the way that you'd expect it too. Also, do want them to break out if they enter 2 or three? 
 do{ }while((number != r) &amp;&amp; (number &lt;= r) &amp;&amp; (number &gt;=r)); There is nothing in the body of the do-while loop. You want to move both these lines so that they enclose the code you want repeated. The `do` needs to move up and the `while` needs to move down There are other bugs, but this is the cause of what you're seeing for now.
Thank you so much for your response. i did what you said but after i input a number, the program ends. also how do i generate a new random number everytime, its always 41?
Wait i found it { while ((guesses != 0)); }
Yes. Although `while( guesses &gt; 0 &amp;&amp; number != r)` will terminate when you guess correctly too.
Have you read the docs on strcpy? http://man7.org/linux/man-pages/man3/strcpy.3.html
What do you mean when you say that the code you're given to modify doesn't let you use the ternary operator? (condition ? expr_true : expr_false ) (userVal &lt; 0) ? "negative" : "positive (or zero)" should work just fine? 
my program tries to guess the number you are thinking by inputting 1 if your number is higher than the guess, -1 if its lower, and 0 if its correct. im trying to make it so that when you press 0 it asks if you want to play again (1) or not (0). i want to make it so that if you select 1 the program starts over.
 {int main(){ int number; int guesses = 5; srand(time(NULL)); int r = rand() % 101; printf("Welcome to the Guessing Number Game.\n"); printf("You have 5 guesses, so choose wisely between 1-100.\n"); do{ scanf("%d", &amp;number); guesses--; if (number &lt; r){ printf("Sorry your guess is too low, pick a greater number..\n"); printf("You have %d tries left\n", guesses); }else if (number &gt; r){ printf("Sorry but your guess is too high, pick a lesser number..\n"); printf("You have %d tries left\n", guesses); } } while ((guesses &gt; 0) &amp;&amp; (number != r)); if (number!=r){ printf("\nYou lost.\nThe number was %d", r); } if (number== r){ printf("you won! It only took you %d tries", guesses); } return 0; } i finally got it but when i get down to 1 more guess it will say i have {1 "tries" left } how can i fix it so that when it gets down to 1 guess it will display that i have 1 more guess left instead of tries i dont know where to put that type of if statement? also when i guess the right number { if (number== r){ printf("you won! It only took you %d tries", guesses); } it will print out that i won but in 0 tries.... help me:(
Correction: I couldn't get an if/else construction to work within the solution spot of strcpy call, but I could set up a function to return the string "positive" or "negative" and put the call in the solution spot. A bit of perseverance and I worked out how to get the ternary operator to work too - had erroneously included a semi-colon when I tried.
Hm. That makes me wonder. In what ways are C and C++ pointers different? I thought they were mostly the same, except that they have different functions for allocating and freeing memory. And some reference variable rules in C++.
iteration statements: `do`, `for`, `while` jump statements: `break`, `continue`, `goto`, `return` selection statements: `if`, `switch` 
C++ is a different language, although a language designed to be similar to C with respect to syntax and semantics. There are subtle differences though, and as I'm not a C++ expert I cannot give you an exhaustive list of the differences concerning pointers. One thing that comes to my mind is that C++ has different rules regarding implicit conversions of pointers: For example, in C, a pointer to `void` (`void*`) is implicitly converted into a pointer to a concrete type where required. This does not happen in C++. Another thing is that in C++, the unary `*` operator (dereference) is overloadable. There are classes in the C++ standard library that overload this operator to implement stuff like smart pointers and such.
Oh, that's interesting. I didn't know that void pointers are implicitly converted to a pointer of concrete type. Thanks for the answer.
Wow! that is amazing! I have yet to learn some of the stuff you did, but i see the overall picture now! i really appreciate your help! how long have you been programming in C? this is my first language ever so im struggling a bit, but i really enjoy it!
Ugh... dammit. Any luck from the gurus on the forums? If so, post a link to it here.
Realize I'm a bit late to the party, but you might want to get a simple user input if they want to continue or not, but the do-while statement would need to be nested in a do-while or just plain while statement, so: `while(userInput != n || userInput != N)` `{` ` //do-while statement` ` print("Do you wish to continue? \n");` ` //check for input, can't remember exact things for it.`* `}` If you want, I can send you the c file for a "game" that I was doing, so you can look at the code and see how it works. \*found the code: char ip [MAX_SIZE - 1]; fgets(ip, MAX_SIZE -1, stdin); if(strstr(ip, exit) != NULL || strstr(ip, "EXIT") != NULL) { printf("Your ship has exploded. All hope is lost for the human race.\n"); running = 0; } **Above code is nested in a while loop, stated as "`while(running == 1)`" with running being that the game is running.** " char ip [MAX_SIZE - 1]; fgets(ip, MAX_SIZE -1, stdin); " char ip, for initializing input. MAX_SIZE for the maximum size of the input (declared previously), minus 1 because it's an array (so, declared is 255, but use -1 to ensure no issues and reads correctly.) fgets is (iirc) the poor choice for user input, but it works (i.e. where fgets is at, it'll pick up what is typed, but won't display anything besides what's typed.) stdin, can't remember exact functioning of it. " if(strstr(ip, exit) != NULL || strstr(ip, "EXIT") != NULL) " strstr(string1 /*input/*, string2 /*what you're comparing to/*) for string comparison (declare each word as a variable, due to the fact it may be used more than once.) between input and another string. != NULL meaning that if it contains "exit" or "EXIT" then it'll go through that if statement, otherwise it does something else. EDIT: Formatting hell EDIT2: Clarifying something
I wrote a solution for practice but it is giving an incorrect answer. Can someone tell me why? //calculate the number of times and distance a ball bounces with given coeficient of restitution #include &lt;stdio.h&gt; int main(void) { int t =0; float i, c, d; printf( "What is the bounce coeficient? "); scanf( "%f", &amp;c); printf( "What is the height of the initial bounce? "); scanf( "%f", &amp;i); i *= 100; d = i; while( i &gt; 10 ) { i *= c; d += (i + i); t++ } d /= 100; printf("the ball bounced %d times\n", t); printf("the ball bounced %f meters\n", d); return 0; } edit: after a bit of thought and reviewing the sequenceing of the loop statements i got it to give the result I wanted, //calculate the number of times and distance a ball bounces with given coeficient of restitution #include &lt;stdio.h&gt; int main(void) { int t =0; float i, c, d; printf( "What is the bounce coeficient? "); scanf( "%f", &amp;c); printf( "What is the height of the initial bounce? "); scanf( "%f", &amp;i); i *= 100; d = i; i *= c; for( ; i &gt; 10; i *= c) { d += (i + i); t++; printf(" the %d bounce was %f cm\n", t, i); } d /= 100; printf("the ball bounced %d times\n", t); printf("the ball bounced %f meters\n", d); return 0; } 
 else ((b*b)-4*a*c &gt; 0); An else statement doesn't need a condition, but you're also not dealing with the case where the discriminant is zero. You're using ints in the solving function, but the result is likely to be a fractional value. Other than that, without going through all the math, it looks okay. What part isn't working? **Edit:** Also, you have a typo in this line: if (b=0)
Perhaps you wanted to type : "else if" instead of "else" in solve_quad. Your compiler should give you a warning. void solve_quad( int a, int b, int c ) { if ( ( b * b ) - 4 * a * c &lt; 0 ) solve_complex( a, b, c ); else if( ( b * b ) - 4 * a * c &gt; 0 ) solve_real( a, b, c ); } 
Ok well, I don;t know what happened but solve_quad works now where it wasnt before. But on the solve_linear, i just got a 0.0000. like if i type a.out 0 5 10 i should get a -2 answer
 else ((b*b)-4*a*c &gt; 0); Your else statement has a semicolon on the end, so the solve_real part isn't inside a conditional block. That line should just be "else"
I'm not too mathematical, but it looks like you have: x = b / -c; If the intention is to make c a negative number, I do not think you can do it like this in c. 0-c might work instead.
In `solve_complex` you're not grouping the 2.0 and a properly.
Are you sure that something is writing to the pipe from the other end? If that's the case, then I believe you also have to close all references to the write end of the pipe after you're done writing, because otherwise the reader has no way of knowing whether more data is going to be written or not.
I didn't completely inspect your code, but you have to make sure you close the write end when you're done with it on **both** sides of the fork.
when the child calls execlp() with sort, after using dup(), it should close the pipe when I close pfdout[1]. See what I updated, it still hangs on what is now line 129, and I closed pfdout[1], so the child should not be waiting on input from it.
This is being taken care of. I have a policy of removing all posts that are not about C. Posters who ask C++ questions get a helpful comment and a deleted post from me. Please flag posts I miss.
All of the problems here would have been detected if you simply enable warnings on your compiler. If you're using GCC or clang, simply compile your code with: gcc -Wall -lm source.c -o program or clang -Wall source.c -o program In fact, clang without the `-Wall` already provides a number of useful diagnostics.
&gt; `#define __MSK__ 0b10000000` Never seen the 0b prefix before, I think it's an extension? `__MSK__` could be a reserved identifier, too, as it begins with _. &gt; `n-&gt;array = (unsigned char*)calloc(bytes, sizeof(unsigned char));` This may be written as simply as `n-&gt;array = calloc(bytes, 1);`, it's good to check the return value of `calloc` each time to handle the cases where it returns a null pointer. The following points are less critical and are more related to style &gt; `size_t bytes = ceil(s / 8.0);` There's another expression that could be used here, `s/8 + (s%8 &gt; 0)`. From a readability perspective, I prefer what you wrote, but this may be worth considering if it's the only reason &lt;math.h&gt; is needed. A couple other ideas are to move includes out of the headers and into the C files, and to try shifting the majority of the storage allocation onto the caller which will provide them with more flexibility and make your own code a bit simpler. Also, in practice I think you'll find that the bit matrix module will provide minimal benefit over the bit array module, as the key difference is just a multiplication and an addition, so it may be worth reconsidering the utility of that and stripping the library down to its essentials. (I personally find it easier to iterate over `w*h` elements as it spares a level of nesting, then divide when I need the row and column indices. In that scenario it would be easier to use the `ba_*` functions rather than the `bm_*` functions.) All in all, it's good work. :-) ----- edit: From [7.13p1](http://port70.net/~nsz/c/c11/n1570.html#7.1.3) of n1570: &gt; All identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved for any use. And, yes, binary integer constants [are an extension in GCC](https://gcc.gnu.org/onlinedocs/gcc/Binary-constants.html). (And probably other compilers too.) So it may present issues on other build environments. 
I don't think you should implement the `bitmatrix` type at all, as making the index calculations opaque inhibits any optimizations the compiler could possibly perform. Generally, you should consider making the access functions macros or inline functions so the compiler can perform better optimizations. I also advise against using the `__MSK__` macro you defined. Why not use `1 &lt;&lt; ...` instead of `__MSK__ &gt;&gt; ...`? You could redesign your structure to contain one less level of indirection. Consider something like this: typedef struct { size_t size; unsigned char array[]; } bitarray; this way, the entire `bitarray` lies in consecutive memory locations. While we are at it, we could also eliminate the `size` member as it's not needed for any of the operations you provide. Here is how I would implement a bitarray: typedef unsigned char *bitarray; #define ba_new(s) calloc(1, ((s) - 1 + CHAR_BIT) / CHAR_BIT) #define ba_get(ba, i) (((ba)[(i) / CHAR_BIT] &gt;&gt; ((i) % CHAR_BIT)) &amp; 1) #define ba_on(ba, i) ((ba)[(i) / CHAR_BIT] &amp;= 1 &lt;&lt; ((i) % CHAR_BIT)) #define ba_off(ba, i) ((ba)[(i) / CHAR_BIT] |= ~(1 &lt;&lt; ((i) % CHAR_BIT))) #define ba_set(ba, i, v) ((v) ? ba_on((ba), (i)) : ba_off((ba), (i))) #define ba_free free
Yeah sorry, my expression was incorrect. `(s + 7) &amp; ~7` would be that idiom, but in this particular use case, the number is also being divided by eight which we can implement with a shift to the right, making the `&amp; ~7` superfluous. This yields the aforementioned `(s + 7) &gt;&gt; 3` which behaves like you `s/8 + (s%8 &gt; 0)` but is a more efficient.
That's a very good advice.
`sprintf` doesN't work like this. You need to do something like this: char buffer[100]; sprintf(buffer, "C:\\%s.txt", fileName); Make sure you don't overflow `buffer`! Even better, use `snprintf` for this purpose.
It's a pleasure to me!
This is a minor aside, and since you now have it working I wouldn't worry about it too much, but in numerical code you can't just naively apply the quadratic formula (you lose a lot of bits of precision when subtracting two numbers that are close together, e.g. b and sqrt(b^2 - 4ac) when 4ac is small. To fix this problem, you basically solve for the first root with the quadratic formula (picking negative or positive to be the opposite as the sign of b). So you have x_first = (-b + sqrt(b*b - 4*a*c)) / (2*a) if b is negative and x_first = (-b - sqrt(b*b - 4*a*c)) / (2*a) if b is positive. You then get the second root by x_second = c / (a * x_first) which is x_second = (2*c) / (-b + sqrt(b*b - 4*a*c)) if b is negative and x_second = (2*c) / (-b - sqrt(b*b - 4*a*c)) if b is positive. Note that I didn't mention here the subtraction in the discriminant (b\*b - 4\*a\*c). Fixing that issue is actually [a bit more complicated](https://www.cs.berkeley.edu/~wkahan/Qdrtcs.pdf).
Also would help to set -Werror, and if your compile time is short -Wfatal-errors so you don't get confused by error puking.
An example, size_t ba_len(size_t n); #define ba_len(n) ((n)+7 &gt;&gt; 3) /* macro for integer constant expression */ void ba_set(unsigned char *ba, size_t i, bool v); bool ba_isset(const unsigned char *ba, size_t i); unsigned char ba[ba_len(8)] = { 0 }; ba_set(ba, 2, true); assert(!ba_isset(ba, 1)); assert(ba_isset(ba, 2)); unsigned char *ba; if ((ba = calloc(ba_len(8), 1)) != NULL) { ba_set(ba, 2, true); assert(!ba_isset(ba, 1)); assert(ba_isset(ba, 2)); free(ba); } 
That's even better. :-)
It's simple to handle this while you're parsing the input: If you encounter '&gt;', transition to a state where you store the next token as the output filename and open it, then go back to the default state. You should be able to produce an array that can be passed to `myshell_launch` without requiring further modificiation. 
AFAIK you need the C runtime MSVC which is only available through VS. So no alternatives for C ( which is C89 ).
mingw
Uh... MinGW? Cygwin? Surely you're not suggesting VS is the only way to develop C on Windows. 
Thanks, and will do.
Yes but all of these use the MSVC don't they ? Yeah I read too much into the question... I was looking into a alternative C runtime some time ago and didn't find one. That's what I reduced the question to.
Struggling to learn a completely new way of editing text is not something you want to do concurrently with learning how to program. As much as I love vim, I would not recommend it to a beginner. Same goes for emacs. I'd use CLion if OP is already used to PHP Storm and find the right environment after the pressure of performing is off.
The LLVM/Clang build for Windows is awesome now. Use Sublime Text plus Clang.
If your program has to be cross-platform, and Windows (and the Microsoft toolchain) is among your targets, your only option right now is C++11.
I advise you to start programming C *without* using an IDE. Just use a text editor, a compiler and invoke the compiler from the terminal. That's all you need to learn C.
The Microsoft C compiler doesn't support C11, they don't even support C99 completely. This makes it hard to use C11 in a program for Windows. Sure, you can use another vendor's C compiler, but that's often quite a hassle. Outside of the Windows world, people *do* talk about C11, but the changes in C11 are mostly unimportant. The largest new parts are the new threading API (which nobody uses because it hasn't been implemented yet and because there is pthreads) and Annex K “bounds checking functions” (which is useless and only available on Windows).
I used Orwell Dev-cpp for years, it's a modified version of bloodshed Dev-cpp and it works pretty well! It includes TDM-GCC inside, it's a sort of mingw for both 32 and 64bit
 #include &lt;stdio.h&gt; int main(void) { switch(printf("hello, world")) {} } edit: should be "hello, world\n", missed the newline. :-p
MinGW is a version of GCC for windows. In conjunction with MSYS you get a unix-like environment, which allows you to make use of most libraries as if you were using a unix. For a graphical IDE, you can use Eclipse, which works well with MSYS/MinGW. Alternatively, take a look at Pelles C for a nice lightweight compiler/IDE with very good C standard compliance.
ITT: people acting like MSVC is important
 #include &lt;stdio.h&gt; #define hw "Hello World." int main(void) { while(puts(hw)&lt;0) {} }
Let's say we have defined a variable **int** arr[10]. The type of arr is **int**[10]. Unless we take the address of it, or use the **sizeof** or **alignof** operators any mention of arr in an expression *decays* into a value of type **int**\* and is a pointer to the first element of the array. The type of &amp;arr is **int** (\*)[10]. If we have a pointer **int** (\*p)[10] we can point it at arr like this: `p = &amp;arr`. It could also point at the array **int** foo[10][10] as `p = foo`. Note that there is no ampersand, because a mention of foo decays to a pointer of the same type as p. So in this case `p + 1` points to the next array of ten **int**s after p. The type of `*(p + 1)` is **int**[10] so in your expression `*(&amp;arr + 1) - arr` we have an expression like **int**[10] - **int**[10]. Because we aren't taking the address of or using **sizeof** on either array they decay into pointers and we end up with pointer arithmetic. However this is undefined behavior according to C11, because ~~we're doing pointer arithmetic on pointers from different arrays. Also,~~ (edit: not really according to C11 § 6.5.9/6) we're not supposed to dereference the pointer that points to the one past the end element.
Unless you use Clang/LLVM for Windows which lets you write C11 just fine. Or MinGW which also works.
Orwell Dev CPP. It has an option to install itself together with GCC and set it up automatically. And it's free.
Eh, it's only the main compiler for the most used OS in the world. If you think it's not, you clearly need a reality check.
Couldnt you just make a bootable ubuntu USB and develop in that environment? 
Why not work in a virtual machine online? Just SSH in and write all your code in that, then download it when you are done. [Digital Ocean](https://www.digitalocean.com) have VMs for $5 a month, and you get a [web shell](https://www.digitalocean.com/community/tutorials/how-to-use-the-digitalocean-console-to-access-your-droplet) so all you need is a browser.
 #error Hello, world! (I hope it's okay to have some other output in there with it...? ;P)
No root access and no way of installing anything. 
I'll take a look into that. I'll tell if it works. 
Never judge the quality or relevance of a programming language or framework by the amount of talk that is going on about it. If something is confusing, overcomplicated and broken, people talk much more about it because they don't understand it, have problems with it and complain about it. There's simply not much need to talk about C11 because it's just a few welcome improvements to an already near-perfect language.
 while(!printf("hello world!")){} 
Your post is a bit hard to read because random words are in **bold.**
MSVC is only a C++ compiler. Although it started out as a C compiler a long time ago, it doesn't support C anymore (except for the parts that are also a subset of C++) and is not advertised as a C compiler. [Luckily](https://en.wikipedia.org/wiki/Embrace,_extend_and_extinguish) Microsoft doesn't care about C for some reason.
Relevant username is relevant! &gt; However this is undefined behavior according to C11, because we're doing pointer arithmetic on pointers from different arrays. Also, we're not supposed to dereference the pointer that points to the one past the end element. This is actually really important. C11 changed some rules that (a) are pretty important, and (b) are the basis for a lot of old "tricks" like this. The trick is now wrong under C11... well, not so much _wrong_, but undefined -- which is worse than wrong. If it works today, it's just by happy accident.
I think the first bullet point [under pthreads](http://tdm-gcc.tdragon.net/quirks) is out of date: mingw-w64 4.9.2 supports `std::thread` and related using Win32 native threads plus a free header-only [patch](https://github.com/meganz/mingw-std-threads).
There is no value stored at `&amp;arr + 1`. Writing `*(&amp;arr + 1)` causes [undefined behaviour](http://stackoverflow.com/a/4105123/1505939) because `*` may not be applied to a pointer that does not point to an object that actually exists (except in unevaluated contexts, which this isn't, and the exact combination `*&amp;` or `&amp;*` which are defined as having no effect). This specific case is actually mentioned in C11 6.5.6/8: &gt; If the result points one past the last element of the array object, it shall not be used as the operand of a unary `*` operator that is evaluated This "trick" relies on the compiler "being nice" and as such, is a very bad idea because you never know when a later version of compiler (or same compiler with different switches, or different compiler, etc.) might do something differently. The array dimension can be found without causing undefined behaviour by writing `sizeof arr / sizeof arr[0]` .
How do I do that?
As you said, you can't use break and continue outside loops or switches. If you want to "skip a statement" use a condition: that's what they're here for. Here are some suggestions derived from your example: Naive fix: char someFunction(char a) { // If you return a char, and you return a, // then a is a char no? if (isTrue(a)) { // No semi-colon inside printf("message"); return '\0'; // You said in the signature you wanted to // return a char, you have to return // something. Here I use a dummy value. } return a; // param is undefined } Let's remark that "if(isTrue(a))" is just "if(a)" char someFunction(char a) { if (a) { printf("message"); return '\0'; } return a; } Sometimes, inversing the conditions proves nice: char someFunction(char a) { if (!a) return a; printf("message"); return '\0'; } 
I can have two return statements in one function? So once it hits any return statement, it leaves that function? That solves my design issue. Thank you!
You can't dynamically change the return type of a function, and you can't "skip" the return statement. All possible codepaths within a function need a return statement. You could do something like this, and check `out` after `someFunction` is called. void someFunction(char in, char* out) { if( isTrue(in) ) { printf("message"); out = NULL; } else *out = in; return; } Without more context of why you want to this, its kind of hard to give concrete advice. 
Yes, in C you can. Let's say however (for the sake of the argument) that you can't. After all, some languages don't let you have multiple return statements. How would you do? The solution is to use a temporary variable: char someFunction(char a) { char result; // Here is our temporary value if (a) { printf("message"); result = '\0'; } else { result = a; } return result; // We return at only one place } To emphasazise the use of our dummy variable, the following would be better: char someFunction(char a) { char result='\0'; if (a) printf("message"); // We don't change result and keep its default value else result = a; return result; } Such strategy is often useful. 
I use EXPO(tm) brand dry erase markers. They come in different colors so you'll probably be able to find one that contrasts well with the glass. They're also language agnostic, so not limited to just C. 
Damn straight.
You should also take a look at c9.io, I used it to run through a ruby tutorial and it was nice
Very nice, thank you.
Sorry, the intention was the opposite, trying to emulate a code highlighter in order to keep it short.
&gt; If something is confusing, overcomplicated and broken, people talk much more about it because they don't understand it, have problems with it and complain about it. This applies to so many software communities. I won't name any for the risk of offending sensibilities.
~~Actually you don't need to include stdio.h.~~ And puts() already adds a newline, you don't need to add a `\n`.&lt;/nitpicking&gt;
second that, I use it in conjunction with gvim and found it pretty satisfying. 
someones being a sadist here I guess
&gt; And puts() already adds a newline, you don't need to add a \n. Fixed. &gt; Actually you don't need to include stdio.h. If we didn't `#include &lt;stdio.h&gt;`, we had to declare `puts` manually, which requires a semicolon. I double checked specifically because of your remark and the standard explitly says in ISO 9899:2011 §7.1.4 ¶2 (*Provided that a library function can be declared without reference to any type defined in a header, it is also permissible to declare the function and use it without including its associated header.*) that it's legal to manually declare `puts`. You have to declare it though, if you don't, that's a rejected program (no called undeclared functions in C11). In C89, that might be legal though.
&gt; welcome improvements Not all of them are welcome. Annex K can go die in a fire.
You can't "continue" or "break" out of a function. Instead you can return a result that can be used as a flag as to what should be done next. 
Why is the list defined in a header file?
&gt; out = NULL; This doesn't do anything as far as the caller of `someFunction` is concerned. You need to set `*out`, not `out`. Changing the value of `out` will be visible only within `someFunction`.
Good stuff! Thank you By the way, if you have a github account try making a pull request with that, because it might help other people. It definitely helped me.
To make it easy to use it in your program I guess. I tried to copy the Microsoft style on that one: [vndrlist.h](https://github.com/Microsoft/Windows-driver-samples/blob/master/usb/usbview/vndrlist.h)
Im using Borland in my first year of college and so far its seems alright.
&gt; To the first point, the location one element past the end of an array is &gt; still a valid location for a pointer from that array. I think saying it &gt; points to a separate array is on somewhat shaky ground unless the standard &gt; specifically says something about this case. Now that you asked, I had to check. At C11 §6.5.9/6 it says that &gt; Two pointers compare equal if ... both are pointers to the &gt; same object (including a pointer to an object and a subobject at its &gt; beginning) ... which as I understand it, in my example, `foo` and `foo[0]` must compare equal, even though they have different type, and further &gt; both are pointers to one past the last element of the same array object, or &gt; one is a pointer to one past the end of one array object and the other is a &gt; pointer to the start of a different array object that happens to immediately &gt; follow the first array object in the address space. which pretty clearly says that `&amp;foo[0][0] + 10` and `&amp;foo[1][0]` (and by the previous part also `foo + 1`) compares equal. In that case, even though we're comparing pointers from two different arrays, they are part of the same aggregate object and are consecutive in the address space (which the standard explicitly mentions). I was wrong. The section just before talks about the relational operators when applied to pointers to aggregate objects with similar meaning. &gt; To the other point, I don't think you can make the argument that we're &gt; derefing a pointer to the element one past the end of the array. We're &gt; derefing a pointer to the array that starts one element past the end of the &gt; last array. That sub-array is the element that's dereferenced and we need to access it to get the pointer to its first element. Like /u/OldWolf2 said referring to the standard, the pointer `&amp;arr + 1` must not be dereferenced, and that's where the undefined behavior stems. While nothing is accessed like you put it, that is besides the point. 
I usually put my structs after my includes and before my functions. 
&gt; in my example, foo and foo[0] must compare equal, even though they have different type, Pointer comparison is not permitted between pointers of different type. One of the pointers must be converted to the type of the other (or both converted to a common type). This can only happen implicitly if one is a `void *`; otherwise you will have to use a cast. Back to whether the pointers (after conversion to `char *` for example) compare equal: Having spent a lot of time debating issues around array bounds access, my point of view is that the standard is unclear. It doesn't cover what happens when one array contains another array, it just says "the array object" but there are multiple overlapping array objects. So you can argue in favour of a variety of different resolutions. My preferred interpretation is to go with the Rationale behind these rules, which is to allow bounds-checked pointer implementations. 
The main issue is when you have multiple C files that access the same array, in that scenario you want the array to be declared in every C file that accesses it, but you only want it to be defined in a single C file. Assuming this is intended to be used in different programs, each with their own type and naming conventions, a clean approach is to define the initialiser list in its own file, let's call it usbid.inc, then include it when you want to define the array. struct usb { unsigned short vid; unsigned short id; char *vendor; char *device; }; struct usb usblist[] = { #include "usbid.inc" }; It's also straightforward to add a { 0, 0, NULL, NULL } terminator after the `#include` directive, if necessary. 
the primary goal, for me, has been to figure out where code is redundant and refactor so that I can re-use a piece of code across my program. this only comes with practice/experience.
&gt; It is not required but good practice is to always include it. It doesn't harm or help the generated code but it helps the maintainer immensely. No. It looks incredibly stupid if a `void` function ends with a pointless `return`. That's just boilerplate and noise that stops my eyes causing me to wonder why someone put a useless `return` there. Please don't add useless code. &gt; Again, good practice is to always return something. OPs example returned a char so \0 would probably be most appropriate. I suggest to expand the data type `char` to `int` and use `-1` as an error return so it's easy to distinguish the function returning a character including `'\0'` from it returning an error.
&gt; You can't have a function that returns char return nothing. You can. If control reaches the end of a function not returning `void`, an indeterminate value is returned, so basically “nothing.”
I'm not particularly fond of this kind of macro trickery. It's hard to understand, error prone and causes readers of your code to go all WTF. Remember, code quality is anti-proportional to [WTF/min](http://www.osnews.com/story/19266/WTFs_m).
But you can do it, so your point “You can't have a function that returns char return nothing.” is invalid. That's all I'm trying to say. It doesn't matter if it makes sense to do it.
Indeed. Not saying I disagree.
Just about the first thing your main function does is call (in the loop) print_weights(); As the weights array has not been changed yet, and is still in the initial zero state, that is what prints.
The link is not working..
What does ` error = sum&gt;threshold;` do? 
Looks like it could be from this page? https://en.wikipedia.org/wiki/Perceptron#Example
Could you fix the link so we can see what algorithm you actually mean?
 fscanf(finput, " %d%d%d", ptrStudent-&gt;strDOB.nDay, ptrStudent-&gt;strDOB.nMnth, ptrStudent-&gt;strDOB.nYear); fscanf needs a pointer to the integer. This bug is repeated in all other fscanf calls. Also, `while (!feof(finput)){` is incorrect. You mustn't call feof before you've attempted any I/O 
Yes, it's that one sorry. The link got cut off for some reason.
It's the one that very_mechnical just linked to. Sorry.
 fscanf reads data from the file and puts it somewhere. You tell it by passing the address of the memory where the data is to go. You are passing the *value* of the variable instead of passing its *address*. fscanf(finput, " %d%d%d", &amp;ptrStudent-&gt;strDOB.nDay, &amp;ptrStudent-&gt;strDOB.nMnth, &amp;ptrStudent-&gt;strDOB.nYear);
It tests to see if the sum from the previous line is greater than the global threshold variable which is set to 0.5. 
Sorry, I got the link to work now. You're right that dot_product() just returns 0 each time. It seems to skip the entire if conditional because error is always 0. 
You moved a bunch of stuff into the dot_product function that's not related to computing the things. The original python doesn't do that; neither should you.
Okay, I will try and fix that and get back to you if I have trouble. However, I would like to know how you improved your programming skills. Can you give me some tips? Like, do you do practice drills or something of that nature? Like if I want to learn calculus, I can get a calculus book and start working on problems in each chapter. But, there doesn't seem to be an easy go-to like that for programming. Don't get me wrong, there are programming books, but most of them just tell you what different functions do and stuff like that, they don't set it up to guide you from the beginner stage to improve your skills gradually.
The following program reads and converts sequential decimal values, and prints each one on its own line. (Note that the arithmetic range wasn't specified, so this will handle anything in the range of INT_MIN to INT_MAX, and fail terribly with anything outside of that range.) #include &lt;stdio.h&gt; int main(void) { int n; while (scanf("%d", &amp;n) == 1) { printf("%d\n", n); } return 0; } Think about how you would modify this program to print a count of the number of values that were read up until a -1. From that point, it should be very straightforward to solve this assignment.
&gt; and will fail terribly with anything outside that range. OP has a few options here. He could use unsigned integers. It would still not be desired behavior should there be overflow but at least it wouldn't be undefined. (Obviously rather than checking for -1 he'd check for UINT_MAX). Another option would be to use fgets to capture the input and then use strtol to convert it which would check for overflow.
the closest thing I can think of is just a linux package manager like apt or yum. 
int main(int argc, char** argv) { int number; int i; int total; float mean; float sum; // print welcome message printf("Welcome user!\n This program will calculate the mean, or average, of a set of positive integers entered by you!" "\n Let's get started!\n"); //prompt for and read in integers provided by user printf("Enter a positive integer:", i); scanf("%d", &amp;total); while (number &lt; 0) { // print error message printf("Remember the number MUST be a positive integer!\n"); printf("Enter a positive integer:"); scanf("%d", &amp;total); while (number &lt; 0) { scanf("%d", &amp;total); } } if (number &gt;= 0){ printf("Enter a positive integer:"); } else (number = -1); { mean = total / i; printf("The mean of your numbers is %.2f", mean); } This is what I have so far
Thank you.
Buy a book called “The C programming language,” it shouldn't be hard to find a used copy. It has exercises in each chapter. I also suggest you to just try to make toy programs. Don't forget to ask others about stylistical critique. Also, try to read a lot of code to get an idea how other people program.
Your post got caught in our spam filter. My apologies.
You can fix the `while (!feof` problem with a `do ... while` loop. Also make sure to check for both `feof` and `ferror` or your program might enter an infinite loop in case of an IO error. Oh wait, you don't do any error checking at all, so it probably doesn't matter too much.
I would suggest C or neither of them. C++ is a horrible first programming language as it's very complicated with lots of pitfalls. The same thing applies to C, but less. Learn Python or something like that at first.
You Do Not initialise number neither do you ever give it a value (Not completly true, in your Else Statement you give it a value istead of checking for a condition. It should be == Not =). Variables wich are Not initialised can lead unwanted behavior, the First value of number could be any value a integer can hold. You should also consider drawing a diagram of the programflow to understand the schedule of the different Statements. Also whats the "i" for in the First printf Statement? 
We're all just busy working. No spare time for writing shitty blog rants about one language being superior to others, or praising brand new frameworks (one for every day of the week).
This would totally get me an F in C Programming. :( /* cc -std=c99 mean.c -o mean */ #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int sum = 0, count = 0; for (int i = 0; ((fprintf(stderr, "sum: %4d, count: %4d, mean: %4.3f, enter new number: ", sum, count, count == 0 ? 0.00f : sum / (float)count), scanf("%d", &amp;i)) == 1) &amp;&amp; i != -1; count++, sum += i) ; } 
Remember, the task is to read positive integers and calculate their mean. The best advice I can give you is to focus on that particular task. The banner, the prompts, the tool-tips, and the retrying of invalid inputs can all be added later on when you have a working solution for this assignment, but they are unnecessary at this stage. Stay focused. :-)
There are some issues with your logic in your inner while loop. In general, what you want to do is add up a sum of integers entered and add up the number of integers entered. With those two numbers you can calculate the average at any point in time. Feel free to use the break statement to exit the loop early if there are any errors. For example -- you could do something like: int count = 0, sum = 0; while (1) { /* loop forever */ int input; printf("Enter a positive integer: "); scanf("%d", &amp;input); if (input == -1) break; else if (input &lt; 1) printf("You must enter a number greater than 0 or -1 to exit.\n"); else { sum += input; count++; } } 
I'm probably going sound like a broken record but i would say if you have no programming experience then do java then go do C The reason being Java is a pretty easy to learn language and pretty common. Then after you are comfortable then go to C since its a high /low level language and gets pretty complicated at times Hope This Helps! 
I'm currently learning C and then will go to C++. I think it's cool, because you start wanting features that aren't in C but are in C++. And you also learn what you do in C that you shouldn't do in C++. Don't get me wrong, C++ is different from C. I'm just saying that learning C will either make you fall in love with C or make you hate C and move on to C++ (making you understand the C++ features better). 
That is definitely the closest thing I have seen so far. Thanks for that!
So, there's no central repository that's language-specific, like for Python, Java, Scala, etc? That's kind of disappointing, but I suppose an artifact of being an older language. Thanks.
When I first started learning C, the first thing I did was try to build a GUI text editor. It's not too difficult, but it's challenging enough to occupy your time whenever you want to work on it. The hardest part would probably be learning the different dependencies and how to use them. (Pango, gtksourceview, etc.)
I wrote lots of UNIX command-line tools for myself. Tiny stuff - dice rolling programs and the like. One of the ones I'm more proud of does pitch detection and spits out MIDI to the JACK server for incoming audio - so I can use my guitar as a synth. Scratch an itch, really. Next time you need a tool, or think one would be nice, write it in C.
Some simple game like asteroids or tetris or breakout maybe? 
implement a cmd line bittorrent client. 
&gt; Arrays and pointers are closely related language features in C, but contrary to popular believe, they are not the same thing at all. Author here. Happy to answer any questions you might have.
It's a fill-in-the-blank activity. The activity provides you with a code, and the only part you can modify is strcpy(condStr, /* Your solution goes here */); You can't add to the code, or remove things to use if statements.
What program are you using for your demonstration?
Forget computers for a minute. How do you find the GCD by hand? Once you figure that out, then you just teach the computer to do the same.
Thanks! So when you pass an array as an argument, you get its pointer inside the function, so to get the size of an array inside of a function, does one typically get the size of the array first and then also pass the size of the array as an additional argument to the function? Is there no other elegant way?
Nice video! I think it also would have been helpful to show that a[i] is actually just *(a + i) 
https://en.wikipedia.org/wiki/Greatest_common_divisor#Using_Euclid.27s_algorithm It's easier to implement recursively, but iterative isn't much harder.
In the library there is a specific macro to make the test cases prototyping. If all test cases are written in only one file I think that these prototypes are a little bit useless.
Or `*(i + a)`, or `i[a]` if you like your code to be an unmaintainable mess
 while (remaining_mortgage &gt; 0) The 1^st time it reaches this line, remaining_mortgage has not be initialised. It is possible it is 0 or negative , so the while loop will never execute. You need to give remaining_mortgage a sensible value before starting the while loop if (monthly_payment &lt; 100) { printf("Sorry, this plan won’t work."); } You need to check if the monthly interest is greater than the payment before deciding whether the plan will work or not.
Exactly; passing the number of elements as an additional parameter is how you do it in C.
I'd never seen `i[a]` but it makes sense, worst possible notation though.
I love that notation!
Further to jedwardsol's comment about the while loop; you might want to consider changing it from a while loop structure, to a do-while loop structure. The code in the loop would be run at least once to create a valid remaining_mortgage value, which would be checked after the loop body has run.
 if (expectations == low &amp;&amp; intentions != evil) download("http://www10.zippyshare.com/v/FmRxGGU9/file.html"); Let me know if this works for you...
You could add a conditional check, something like: if( remaining_mortgage &lt; monthly_payment ) monthly_payment = remaining_mortgage; *Edit: Changed comparison operator.
I've been working on the op's code too, should that be the following instead? if( remaining_mortgage &lt; monthly_payment )
Your if statements all have semicolons on them. They should not. You can also look into the switch...case structure. Edit: As does your for loop. You need braces around the repeated code, and remove the semicolon from the for statement.
Before or after my edit? What do you mean it "didn't work"? Where did you add the check?
 if (box[i] == 'r'); ^Remove this semicolon Same for each other `if` statement and the `for` loop. You might consider using braces for clarity. A switch statement would be better for what you're doing, but you might not have learned about it yet. Also, you made all your variables global instead of local. This isn't a problem in your current program, but is a bad habit to get into. Move those variables to within `main`.
after your edit if you inout my code you'll see that the monthly patent will just equal the remaining mortgage i need the monthly payment to equal whatever the remaining value is and subtract it by that amount #include &lt;stdio.h&gt; int main() { int mortgage; float new_mortgage; float annual_interest; float monthly_interest; float monthly_payment; float remaining_mortgage; int month = 1; printf("What is the value left on the mortgage?\n"); scanf("%d", &amp;mortgage); printf("What is the annual interest rate of the loan, in percent?\n"); scanf("%f", &amp;annual_interest); printf("What is the monthly payment?\n"); scanf("%f", &amp;monthly_payment); if (monthly_payment &lt; 100) { printf("Sorry, this plan won’t work."); } monthly_interest = annual_interest/100; monthly_interest = monthly_interest/12; new_mortgage = mortgage * monthly_interest + mortgage; remaining_mortgage = new_mortgage - monthly_payment; printf("Month\t Payment\tAmount Owed\n"); while (remaining_mortgage &gt; 0 ) { printf("%d\t\t %.2f\t\t %.2f\n", month, monthly_payment, remaining_mortgage); month = month + 1; remaining_mortgage = remaining_mortgage - monthly_payment; if( remaining_mortgage &lt; monthly_payment ) monthly_payment = remaining_mortgage; } return 0; } i also realized that it doesn't input the monthly interest after each payment.
Forever alone... ;_;
~~`if`is not a statement, it's a control structure. If it was a statement, it would end in a semicolon, but it isn't, so it doesn't end in a semicolon.~~ **EDIT** Sorry, please excuse my uninformed ramblings. I'm wrong.
I would say that `*(a+i)` is actually just `a[i]` 
There is no elegant way if you don't know ahead of time how many elements the passed-in array will/should have, as is the case in many array usages. *However*, in many cases, you have a function that needs to take an array of exactly `n` elements. If this number is known and fixed, rather than letting the array decay to a pointer to its first element, you can accept a pointer to the whole array and bask in the (relative) safety of the type system: int sum_ten (int arr[10]) { int sum = 0; for (int i = 0; i &lt; 10; ++i) sum += arr[i]; return sum; } int safe_sum_ten (int (*arr)[10]) { int sum = 0; for (int i = 0; i &lt; 10; ++i) sum += (*arr)[i]; } int main() { int x[10] int y[5]; int sumx = sum_ten(x); int sumy = sum_ten(y); // Compiles: Decays to int* int ssx = safe_sum_ten(&amp;x); int ssy = safe_sum_ten(&amp;y); // Type error: int(*)[5] != int(*)[10] } If you're willing to take on the cognitive load of C++, templates and references can make this almost completely transparent.
The preprocessor can only read one line at a time, so the backslashes are used to tell the preprocessor to continue reading the next line as a continuation of the current one
None of your variables are initialized, so the first time you use red++ it will have an unpredictable value. Make sure you set red=0 (and the other colours) before you start processing your string.
Thank you very much for your help :D I have moved the variables and removed the semicolons. The program can run now, but the output is wrong. (check above)
Moving the variables had an unfortunate side effect: globals are automatically initialized to 0, locals are not. Set them to zero when you declare them.
I wrote it back in junior year of high school - it's on an old hard drive in a busted computer. I can tell you that I used PortAudio for grabbing PCM, GSL for the FFT (I meant to switch to a wavelet approach but never got around to it), and the JACK API for dumping MIDI out. The code really isn't all that quality, but I'll try to find it.
`i[a]` is my favorite example when teaching about arrays and pointers in C. It's an immediate lightbulb moment for many students. 
Did you get the idea to do this after Linus Torvald's recent rant?
Depending on how you look at it (runtime vs compile time), they're either exactly the same or pointers are a subset of arrays. At runtime, arrays and pointers have the exact same representation. However, arrays (in C89) have an *optional* static size type parameter, which is only known *at compile time*, which allows the compiler to produce the allocated size with the `sizeof` keyword (evaluated at compile time) as well as perform additional static analysis (bounds checking) on arrays with a static size. Does the relaxing of static bounds in C99 means dynamic arrays are essentially equivalent to pointers to stack-allocated memory?
They work particularly well if you don't need to modify the options, I like fopen's mode string as an example of a string interface. For this particular one, I guess a `char *[]` would be more practical: void fn(char *s) { int n; while (s += strspn(s, " "), *s != '\0') { n = strcspn(s, " "); if (strlen("key") != n || strncmp(s, "key", n) != 0) printf("%.*s\n", n, s); s += n; } } fn("abc key def key ghi"); /* ------------------------------------------------------ */ void fn(char *s[]) { int i; for (i = 0; s[i] != NULL; i++) if (strcmp(s[i], "key") != 0) printf("%s\n", s[i]); } char *s[] = { "abc", "key", "def", "key", "ghi", NULL }; fn(s); But sometimes bit flags work better, sometimes macros set through CFLAGS work better, and sometimes no configuration works better. For the pthread attributes, I'd actually look into using a struct. 
That's exactly why I started developing the tool; I teach C to beginners.
&gt; At runtime, arrays and pointers have the exact same representation. How can they have the exact same representation? The video clearly demonstrates they consume different amounts of memory.
lol fyi JavaSuck is a 100k+ user on SO. Their knowledge of C is indeed most likely imprecise in some places!
Well, I basically had two choices: make a video as soon as I could demonstrate something which people may or may not find interesting, or first polish my tool until it follows the C standard 100%. (I would probably have given up before reaching that goal.) But yeah, of course 100% is what I *aim* for. It's not like I've stopped developing :)
Let me put it this way: after reading the rant, it occured to me that this video might be a lot more useful than initially expected :)
How useful is a function that can only process arrays of exactly 10 elements though?
It is a statement. Any C grammar, in the standard document or elsewhere, does name it as such. The `if` is a kind of `selection-statement`. The other kind of `selection-statement` is a `switch-statement`.
for the curious: [Linus' rant](https://lkml.org/lkml/2015/9/3/428)
How useful is a function that can only process 32-bit two's-complement integers or NUL-terminated strings of 8-bit ASCII characters? The point is defining an interface and then statically verifying adherence to that interface. Sure, this case seems limited -- it doesn't work with dynamic allocation, which cuts out many uses of arrays -- but you might be surprised how often fixed-size buffers do come up in code. If you ever happen to require ten integers for some operation, you can guarantee that you're getting exactly that (or that the user of your interface is a fool) with just a layer of indirection.
While that's cute, I doubt that's what she's looking for. The functions you want to look at for pseudo-random numbers are rand() and srand(). There are other ways to do it too that cryptographers are more approving of, but I have no experience with them.
That's not what I mean. What I mean is that this (i.e. the failure to understand `i[a]` syntax by your program) demonstrates, that you didn't even read the C standards for the parts you did implement. If you would have used the C standard from the beginning, you would have already implemented the required behaviour when implementing the binary `+` operator for pointers, but it seems like you didn't.
you can also do it...."the doom way" :P (j/k)
You can't simply treat `a[i]` as syntactic sugar for `*(a+i)`, or the error messages become very confusing. When the beginner writes `p[q]` with `p` and `q` both being pointers, I don't want the compiler to complain about bad operands to the `+` operator. But yes, I haven't implemented `integer + pointer` yet. That doesn't mean I don't read the C standard; it means I have read the C standard and decided that this particular use case is not important enough to implement *now*. (In fact, the parser is littered with references to the C standard, and I keep the C standard open in my text editor all the time). It would probably take me 15 minutes to implement the correct semantics, but I have about a hundred more pressing issues on my plate before I'm willing to spend those 15 minutes. I have been teaching C for a long time now, and I have never felt the need to demonstrate the `i[a]` syntax. I simply don't *want* students to write that kind of code. YMMV.
&gt; ssh uses a slightly convoluted scheme where a service ssh-agent is running that knows the passphrase and decrypts data for other processes with the key and the passphrase. Other programs simply store passwords in files. There are daemons and libraries specifically designed to securely store secrets like SSH key passwords, and SSH can make use of them if they are available. For example, both GNOME and KDE provide keyrings, which hopefully allow you to type a password once, then keep it securely saved and only available with your login credentials. [libsecret](https://wiki.gnome.org/Projects/Libsecret) can be used to access those same keyrings in other applications. &gt; “Getting rid” means “overwriting with '\0'” not just “calling free(),” as freed data can persist for quite a while in your program if it's not needed anywhere else. This is actually quite harder than it seems at first thought. Compilers will gladly optimize away writing out data that will never be read. So if you simply `memset` something with zeroes and immediately free it, it might be ineffective. You have to read the content in some fashion after wiping it.
Yeah, that's correct. OpenBSD even has an `explicit_bzero()` which is designed to make sure that the compiler is not going to remove it.
Wathever you do, **do not** put the call to `srand()` inside a loop. #include &lt;stdio.h&gt; // printf() #include &lt;stdlib.h&gt; // srand(), rand() #include &lt;time.h&gt; // time() int main(void) { srand(time(0)); printf("%d\n", rand()); // &lt;== random between 0 and RAND_MAX (from &lt;limits.h&gt;) return 0; } 
Here are some others, HTH 4+2i -13+8i 0+i 9+17i
Imagine that the random number generator in C is like a big library of books full of random numbers. When you do `srand(N)` you select a book; the first time you do `rand()` you get the first number in book N, and after that you get the next number in the same book. If you do `srand()` inside a loop, you will be selecting a book over and over again (possibly the same book if using `time(0)` and less than a second elapses between calls to `srand()`); and the next call to `rand()` will always select the first number in the book. The books are practically infinite. Select a book once (typically one of the first functions in `main()`) and stick with that book for the duration of your program.
It's in the wrong place. You should use the if (remain &lt; month) portion before subtracting the monthly payment. As it stands, your code should still subtract the monthly payment the next time it runs through the while loop. Are you claiming that your code ends with a remaining mortgage value that is not zero? Keep in mind that your printed line occurs *before* the last payment is subtracted.
I really don't think the analogy helped at all there.
Since we're looking for facts about how things work, let's run an actual experiment. [I created a gist of files I'm going to reference in this comment](https://gist.github.com/anonymous/d404852febf3ecb54bbd). To start, the hypothesis is that `array.c` and `pointer.c` should generate assembly code with the following differences/observations: 1. The string contents will be different 2. The assembly will be equivalent, specifically the parameters to `printf` should be congruent 3. The result of `sizeof` will be baked into the assembly Here are the results of the diff: https://gist.github.com/anonymous/d404852febf3ecb54bbd#file-array-s_pointer-s-diff There are a heck of a lot of differences! It turns out that arrays with defined size that are allocated in a function are allocated on the stack, so the assignment to a value will perform a memory copy from the data section. So yes, arrays with size **are allocated on the stack**, which means they do have different semantics than pointers. However, if we run the same experiment with a `static` array, we get the following differences in the produced assembly: https://gist.github.com/anonymous/d404852febf3ecb54bbd#file-static_array-s_pointer-s-diff These two behave identically.
I was more pointing out that the analogy didn't really add anything, but thanks for the explanation anyway.
`time(0)` is a terrible seed and `rand` in general has poor qualities. 
It's not even just cryptography that needs better ways to generate 'random' numbers. In fact there are various uses for random data where different qualities matter, different kinds of 'randomness'. For example, for some uses it's important that knowing something about some random data doesn't tell one about random data generated beforehand and/or afterward. In other applications it may not matter at all if one can tell those things, but it may be important that each possible value is generated exactly the same number of times across the whole repeated sequence of generated numbers. Or that every possible sequence of three values appears the same number of times. Sometimes what matters is the length of that repeated sequence, or other features of the algorithm such as being able to efficiently jump ahead or back in the sequence. [Here's][1] a site that talks about this topic and links to some other useful resources, as well as [providing][2] implementations of random number generation developed by the author. [1]: http://www.pcg-random.org/blog/ [2]: http://www.pcg-random.org/download.html 
[Image](http://imgs.xkcd.com/comics/random_number.png) **Title:** Random Number **Title-text:** RFC 1149.5 specifies 4 as the standard IEEE-vetted random number. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/221#Explanation) **Stats:** This comic has been referenced 372 times, representing 0.4429% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cvkpcqx)
&gt; The books are practically infinite Not with typical implementations of `rand()`. Most of the time the entire sequence which implementations of `rand()` generate is 2^32 or less, which doesn't take long to scan through. 
I can't stop crying . . . with laughter.
https://github.com/zhaphod/Marvin As usual I start more than I ever finish. I have implemented only bencode parser. nothing else. I will have to get back to it sometime.
How are fd and fd2 declared and opened? You haven't included that part of your code. What is nrOfBytes set to? What is i initialized to? What does the fd file contain, and what does the fd2 file end up with? As the code is written, you should only end up with one byte so saying you get "weird characters" is surprising. Is SM1 supposed to be the same as SM[i]? If so, you haven't allocated any memory for it so you shouldn't be writing to it. If not, what is SM1 used for, and where is SM declared? Also, what's up with the sizes? Your IN array is 10 bytes, you only assign 5 of them to SM, and then you only write 1 to the file. The code you've included is missing a lot of details. Please post a [short, self-contained example](http://sscce.org/) Edit: Also, your printf statement is displaying a different variable than the one you wrote to the file.
Why do you say that SM[0] will be a null character? Doesn't it depend on what was pulled out of fd?
&gt; I'm new to programming with .net I think you've come to the wrong place.
Woops, found /r/csharp now, sorry!
That's pretty interesting. I was unaware that you could use it outside of the preprocessor.
I removed this post for you.
"Also, your printf statement is displaying a different variable than the one you wrote to the file." You mean a different variable in the same array? Yes on the example it is...
If you still need help with this, after a bit of trial and error I think I have worked out the correct algorithm. If so please let me know.
Nice one. :-)
i figured it out thank you
`srand` *seeds* the generator. Given a fixed seed, the generator always gives the same exact same sequence. Each call to `srand` resets the generator to the beginning of the sequence, and since the time is nearly constant inside a very fast loop, you will get the same number in every iteration of the loop … which is probably not what you intended. Rule of thumb is that you should only seed the generator once per program (unless you're doing something funky).
You posted this topic and asked "What am I missing?". I asked those questions because the answers to them could help us find your problem. You say you're copying the value from another char, but that may not be true if i is not properly initialized. You say that when you printf you get the correct value, but the code you posted does not print the same value that it writes to the file. You have now shown what ends up in your output file, but you haven't shown the input so we don't know how it could have ended up that way. I would very much like to help you solve your problem, but you have not provided enough information to do so. 
 int previouslightlevel=0; int lightlevel; while(!AttackedByTheCat()) { lightlevel = GetLightLevel(); if(lightlevel == previouslightlevel) { // stuck Turn120Degrees(); } else { MoveForward(); } previouslightlevel=lightlevel; } In the real world, you might want to store more than 1 previous value and/or backup if the difference is small, not just 0. Also, you need to account for dogs as well as cats.
If you look at /u/xNotch Reddit history, he linked to a really interesting presentation on using random number generators in c. I'll look in twelve hours when I'm on a computer if I remember.
Yes, the basic principle is to remember something about the state and then see if it has changed. I always have 'previous' somewhere in the variable name so I know it is something stored from an earlier test.
So internally, computers work on a system called binary, base 2. There are 2 digits, 1 and 0. Now it's kind of a pain to actually write in that, so over the years we've come up with some shorthand: octal and hexadecimal, both of which can directly represent binary in a much easier form, because 8 is 2 to the 3rd power and 16 is 2 to the 4th power. One hexadecimal number represents 4 binary digits, so rather than writing 1100 1010 0011 1000 0000 0010 1111 1101 you can just write 0xCA3802FD. Basically you use it if you have a specific pattern of bits in mind while you're writing it out, or if you need a number and you want letters in it (0xBADB002 is a signature for a certain bootloader, for example)
You're assuming that decimal is easier to understand than hexadecimal! Some times, hexadecimal is actually the preferred format for understanding what's going on *when you care about the bits themselves* instead of the number. And when you're working close to the hardware (a common use for C), you want to see things in hex rather than decimal. But again, remember that *everything* in a computer is in binary. Nothing is converted from hexadecimal to decimal -- instead, it's a question of whether binary is converted to decimal or hexadecimal, whichever is more appropriate for your situation.
you shall think the srand() as a select_book(id). and each time you call that function, it reset an inner static int called current_page to 0. and rand() is read_one_page(). it uses current_page, so you can imaginate reading the book, the first page of each book, and the same book until it pass 1 second. Sorry for my english.
A good example of hex in real world programming is flags. let's say you had a function void order_hamburger(bool lettuce, bool tomato, bool pickles, bool onions, ... That's a lot of arguments... You only need one bit to represent each value though. so check this out void order_hamburger(char ingredients); ingredients has 8 bits. Let's say the first bit represents lettuce (i.e. 0 means no and 1 means yes), the second represents tomato, and so on. I don't like onions or tomatoes, so my ingredients looks like this: 11110101 (bit 0 is on the right). in hex this is 0xF5 so instead of calling the function like this: order_hamburger(true, false, true, false, ...); I do this order_hamburger(0xFC); There's nothing preventing me from converting 11110101 to decimal and doing this order_hamburger(252); but hex is much better suited for flags, especially when you start referring to, for example, the 27th bit: 0x800 0000 in hex, 134217728 in decimal. in the real world you probably wouldn't be using actual numbers (hex or otherwise) in your function call. once you learn boolean arithmetic then you can do stuff like this #DEFINE LETTUCE 0x1 #DEFINE TOMATO 0x2 #DEFINE PICKLES 0x4 #DEFINE ONIONS 0x8 order_hamburger(LETTUCE | PICKLES | ... ); If that makes no sense then consider it a sneak peak :&gt;
Octal and hex are often used because most computers store bits in groups of 8 (bytes) or 32 (a common size for `int` in C is 32 bits or 4 bytes). Octal and hex numbers "line up" with these sizes. Octal has 8 digits (0-7) and can represent exactly 3 bits, and hexadecimal has 16 (0-F) and can represent exactly 4 bits. Decimal (0-9) requires doing a lot more math in your head to figure out what bits are being set or how many bits your number takes up, but once you get used to octal and hex it's pretty easy to see at a glance. For example, two hexadecimal digits correspond to one byte's worth of bits: `0xFF = 1111 1111`. This is why some programs for editing binary data will show you pairs of hex (and thus they're often called "[hex editors](http://www.funduc.com/images/fshedshot.png)"). In low-level code you will also often seen hex numbers with 8 digits: `0xDEADBEEF` which sets every bit of a 32-bit int.
thanks
It's really hard to find interesting videos related to C, but here goes nothing: [more on undefined behavior](https://www.youtube.com/watch?v=uHCLkb1vKaY) [UNIX history lesson](https://www.youtube.com/watch?v=tc4ROCJYbm0) [recent Brian Kernighan interview](https://www.youtube.com/watch?v=de2Hsvxaf8M)
My interpretation of [`srand()`](http://port70.net/~nsz/c/c11/n1570.html#7.22.2.2) is that it generates a new sequence rather than position itself on same point of a specific sequence. I mean if somewhere in the sequence generated after `srand(42)` there are 100 sequential `rand()` values of `0`, that may not happen at all when the sequence was initialized with `srand(43)`.
* Don't use `char` for `getc()`! Use `int` so you can distinguish the character with the value 255 from `EOF`. * Your `else if (index == (size - 1))` is not reached if `c` is `'\n'`, making it possible to overflow the array by receiving many newlines. * Where do you allocate memory for the columns of the array? I only see a `malloc()` call for the columns, but none for the rows. 
So I created the program in vim. saved it as a .c file. from there I did cc "program" and got the a.out file. then I have to do ./a.out to get the file to run. however on this program it isn't working, It might be an error in the program but after I couldnt figure it out I copied it directly from the book. Here's the program; #include &lt;stdio.h&gt; /* print Fahrenheit to celcius for certain values main () { int fahr, celsius; int lower, upper, step; lower = 0; /* lower end of the table */ upper = 300; /* upper most end of the table */ step = 20; /* this is how much each step moves up by */ fahr = lower; while (fahr &lt;= upper) { celsius = 5 * (fahr-32) / 9; printf("%d\t%d\n", fahr, celsius); fahr = fahr + step; } } 
sorry for the poor formatting I forget how to format it correctly
To quote myself: &gt; Source or binary? Anyway, it's way too alpha to publish it anywhere.
Here's the video from a talk by Stephen T Lavavej: https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful
“it isn't working” is not an error description. What happens, what did you expect?
if someone can point me to the direction of formatting this correctly on reddit don't hesitate
 cmdln@cmdln2:~$ cc f2c.c f2c.c:10:2: warning: data definition has no type or storage class [enabled by default] upper = 300; /* upper most end of the table */ ^ f2c.c:11:2: warning: data definition has no type or storage class [enabled by default] step = 20; /* this is how much each step moves up by */ ^ f2c.c:12:1: warning: data definition has no type or storage class [enabled by default] fahr = lower; ^ f2c.c:12:8: error: ‘lower’ undeclared here (not in a function) fahr = lower; ^ f2c.c:13:13: error: expected ‘)’ before ‘&lt;=’ token While (fahr &lt;= upper) { ^ f2c.c:18:1: error: expected identifier or ‘(’ before ‘}’ token } 
It is possible to have such a pRNG, but most implementations of `rand()` don't do that. It can easily look like two seeds produce independent streams, however, because two seeds are likely to correspond to positions that are far away from each other, and you won't see the overlap unless you go on generating numbers long enough. For example, if you generate one random seed, use 20,000 values, generate another random seed and use 20,000 more values, there's a 0.0009% chance you'll get some overlap if the pRNG has a single stream with a period of 2^32.
Sorry I didnt mean to make this program specific, that's why I didnt clarify. "cmdln@cmdln2:~$ cc f2c.c f2c.c:10:2: warning: data definition has no type or storage class [enabled by default] upper = 300; /* upper most end of the table */ ^ f2c.c:11:2: warning: data definition has no type or storage class [enabled by default] step = 20; /* this is how much each step moves up by */ ^ f2c.c:12:1: warning: data definition has no type or storage class [enabled by default] fahr = lower; ^ f2c.c:12:8: error: ‘lower’ undeclared here (not in a function) fahr = lower; ^ f2c.c:13:13: error: expected ‘)’ before ‘&lt;=’ token While (fahr &lt;= upper) { ^ f2c.c:18:1: error: expected identifier or ‘(’ before ‘}’ token } " these are the error messages im receiving. Here are the steps I took. cc f2c.c (my program) after this point is when the error occurred. Normally after I do this I get a "a.out" executable, chmod u+x to run it and then It outputs what I want (in this case giving me the integer numbers or corresponding temperatures, I.E. 0 -17 20 -7 so on and so forth) Does this help?
http://stackoverflow.com/questions/13319492/understanding-the-difference-between-f-and-fvoid-in-c-and-c-once-and-for-a
So you are getting errors when you run "cc f2c.c" cc is the compiler so you are getting compiler errors. Whenever asking for help, you should always post any errors you get and what you do to get them up front. It looks like reddit messed up the formatting of the source, but I would say it's an error with your first comment not having */ on the end of it.
In function **definitions**, there is no difference. In function **declarations**, there is a difference: void a() {} // a takes no parameters void b(void) {} // b takes no parameters void c() ; // c takes an arbitrary number of parameters void d(void) ; // d takes no parameters
Yeah, I was wrong again.
I would think that the in person interview would test knowledge of C. This would be an extra take home to test for well structured, readable programming techniques.
I found these two interesting: [PolyConf 15: Cello - Hacking C for Fun and Learning / Daniel Holden ](https://www.youtube.com/watch?v=bVxfwsgO00o) ["Liberating the Smalltalk lurking in C and Unix" by Stephen Kell ](https://www.youtube.com/watch?v=LwicN2u6Dro)
What about just asking for a coding sample? This will of course disadvantage people who have only ever coded for work post college and have agreements against sharing that code, so it will have some false negativesnegatives, but I think a sufficient number of programmers either contribute to open source, or have a pet project in their free time, or have code from work that they are allowed to share that you won't rule out too many that way. Then you aren't draining to much of this person's time on an interview and you getget something they've put some time into. Then you can look at the structure, readability etc of that. 
Not a bad idea. Besides the drawbacks you mention you just never know who wrote the code if you do that. Plus, a code sample may not be anything related the kind of issues we see at our company.
That's fair. To the first point, have them sit down and talk you through it in an interview, and also do some online searching. That will tell you if they understand it well (regardless of whether they actually wrote it), and searching online smartly should take out anyone who just pulled down something from github they didn't write. Fair enough about concurrency though.
I will definitely think about this. Thank you.
No, the `int` cast is not needed and even if it was, it would be wrong as this would cause the addition to be performed with `short` precision instead of `int` precision. This does not happen though because of implicit conversion to `int` (see my answer).
No need to cast; the type of `short+short` is `int`, anyway.
Basically i want to do something like int compact_shorts(short* shorts, int n_shorts, int* integers); So every two elements of shorts, sum them and put them on the int array, and then return the number of elements of integers.
I like this question, for c specifically. It is very simple and tends to allow you to step up an interview pretty quickly. Explain what happens when you call this.. void doSomething() { int edx[10]; int i; for (i=0; i&lt;=10; i++) { edx[i]=0; } } 
Bring them in the morning, give them a problem, have them code something in 2-3 hours. Allow them to use Google or any reference.
That wouldn't get you the specific element within the structure. And hopefully you understand that I was just trying to illustrate a point. Anyway.. I'll check out /r/dailyprogrammer. Thanks.
Apparently is not this simple...I'm told that i am supposed to do something like [this](http://stackoverflow.com/questions/17768625/2-chars-to-short-in-c) and i have no idea how to implement that... So instead of this: &gt; twoBytes = receivedData[14] &lt;&lt; 8 | receivedData[15]; &gt;&lt;&lt; 8 means a left shift by 8 digits (binary; or 2 digits hex), essentially multiplicating the value by 64. This means 0x0007 becomes 0x0700. &gt;| will then or this with the other value, essentially setting it to 0x07bb. i have to do for 16..? for example if i have 16 bits of a short 1000101010101011 and another one 1110101001010101, the result would be 10001010101010111110101001010101 
There was an error on the question presented, we want to construct an int outof two shorts (like the link) and not sum them... 
I'd imagine that it leads into follow up questions. "what if edx was declared static? what if edx was declared static, but outside the function i.e. file scope?"
I give this question on a white board normally. It tests far more than attention for detail. How memory is arranged on the stack is the 'twist' to this question, it's amazing how many candidates immediately incorrectly answer it's simply an index out of bounds error. The arrangement of i on the stack and the subsequent overflow into it causing the infinite loop are a great topic of discussion, it immediately allows me to lead onto discussion about language design, compiler differences and memory management. An interview is not an exam, I don't care about what someone answers so much as their ability to describe a problem, test it and share that information prior to fixing it. An interview is individual and you need to step up the interview to the level of the candidate and do it very quickly. Questions like this make it possible. 
here you go. i'm not sure what exactly you want to do, but this will add random numbers to an array: #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define SIZE 1000 //used for size of array int main(int argc, int **argv) { int i; //counter int randomArray[SIZE]; //array size SIZE srand( time(NULL) ); //initialize random seed for(i=0;i&lt;SIZE;i++) { //populates array with random numbers between 0-99 randomArray[i] = rand() % 100; printf(%d\n", randomArray[i]); //prints each element } return 0; //done }
`short` and `int` have a minimum 15-bit precision, so `short` is a poor choice as a source type (ideally `unsigned short` or `unsigned`, min 16-bit precision), and `int` is a poor choice as a destination type (ideally `unsigned long`, min 32-bit precision). Your multiplier would be 65536, as the maximum value is 65535. unsigned src[] = { 0x8aab, 0xea55 }; unsigned long dst; dst = src[0]*65536LU + src[1]; assert(dst == 0x8aabea55); 
He is/you are actually losing the benefits of using calloc by always passing nmemb as `1`.
Jl777: i lose out on benefiting from a multiply. this is not any meaningful issue. the benefit of calloc I am using is that it clears the memory 
Why is that a problem? Posting 200 lines of code is not a problem on Stack Overflow.
/u/bez3 owes /u/danielcamiel 10 bitcoin.
solved it was the compiler, sorry I didnt post sooner I have been at it all night. Thank you for your help
Why try crypto if you're new to C? This is a bad idea :-(
Isn't that like 1/1000th of a pizza?
Any assumption is a security flaw.
If you are talking about a $2.4 million pizza, sure.
You simply don't know who jl777 is in crypto :) Keep on laughing...
http://slackinvite.supernet.org/
I removed this post. If you post a bounty, please outline precise conditions on which the bounty is awarded. Right now it looks like you're a phony (cf. the wrong `calloc` call where it seems like you refused to award the bounty), and we don't like people who offer a bounty and then don't pay it in this subreddit.
And now you deleted this post again. What do you try to achieve by constantly deleting your posts?
This is undefined behavior. There is no guarantee that the behavior you described will occur.
&gt; pointers to pointers can also be represented as a multidimensional arrays Not really. Multidimensional arrays in C are _not_ pointers to pointers. If you declare `int a[10][10]`, this is not an array of pointers. It is, instead, an array of `int[10]`. This is pretty important, because, for example, `a` is in no way convertible to type `int**` but would decay to type `int(*)[10]`. So, `a` is actually a contiguous block of `100*sizeof(int)` bytes and `(a+1)-a` would be `10*sizeof(int)`. &gt; therefore, pointers to pointers are also an array of pointers with each element of the array pointing to another array. This is no because pointers are not arrays. But, you can model jagged arrays in C using pointers to pointers. For instance, int* c[10]; for (int i = 0; i &lt;10; ++i) c[i] = malloc((i+1)*sizeof(int)); // check for malloc success and free omitted Then, `c` can be accessed like you'd suspect (`c[0][0]`, `c[1][0]`,`c[1][1]`, `c[2][0]`, etc). But, this is a fundamentally different thing than a multidimensional array. 
Thanks for the reply. Your example of dynamic memory with jagged arrays is exactly the problem that I was working on. Thank you very much.
[related FAQ](http://stackoverflow.com/questions/4810676/)
Thanks.
I wasn't looking for you to answer, however your answer is a perfect example of how you should handle an interview question like this. Bonus points for providing the interviewer an interesting article which he can potentially learn something from. My best candidates in interviews have left me with something new I didn't know and a real sense of 'I want to work with this person'. The only thing I can add to your answer is on the testing side I would want to hear something around unit testing, but nothing specific at all and tbh unit testing doesn't really fit well with the example so well. But it's never a bad thing having a candidate suggest that it should be written in way it can be tested either :)
The point of `strtok()` is that it's intended to be called multiple times because a string generally contains multiple tokens, and each call extracts (or rather isolates) one token. But if you called it as `strtok(str, s)` each time, it would always start looking for a token at the beginning of `str` and you'd never make any forward progress — you'd have an infinite loop as the first token is returned over and over. The function remembers the position where it left off on the previous call and starts there if you pass `NULL` as the first argument. When there are no more tokens to extract, then it returns `NULL`. That `NULL` is a completely different and unrelated `NULL`. 
If you aren't embarrassed by your first version, you released too late. 
Just do it? What is the problem you experience?
thanks:) i am new to c.
Thanks for the feedback but doesn't look like my slice of cake thanks anyways :)
Why not run `limits.h` through the preprocessor?
thanks! sorry didn't think to adjust those, trying to fix it up
How did you do that? I can't figure out how to indent on reddit and whenever I do a blank line it creates a different color box. I tried (with spaces removed after &amp;'s) &amp; nbsp;&amp; nbsp; &amp; nbsp;&amp; nbsp; for indents but it goes nuts with blank lines.
It will produce nothing if run directly on the header, although a preprocessor can be used to find a specific value, e.g. # echo LONG_MAX | cpp -include /usr/include/limits.h | grep -v '^#\|^$' 9223372036854775807L Although some outputs may need further evaluation, # echo UINT_MAX | cpp -include /usr/include/limits.h | grep -v '^#\|^$' (2147483647 * 2U + 1U) edit: I didn't actually think to use the preprocessor before, it's a nice idea. :-)
I read that. I don't understand what it means. Are you saying the code won't compile? What are the errors/warnings? Also, are you including `stdio` and `stdlib`?
Put the prompt and calculations inside a `while (1)` loop, like this: while (1) { int a = getInt(); int b = getInt(); int c = a + b; printf("SUM = %d", c); if (b == 0 &amp;&amp; a == 0) break; }
If you want to begin with C, join us on /r/cs50
Out four blanks (simple white space) before each line and a blank line before and after the code block.
Particularly for the case where there isn't a &lt;limits.h&gt; yet (bootstrapping -- probably the main use case for this program), but also because it's been quite fun to do it this way. I did use the &lt;limits.h&gt; method for ensuring that this program produced the correct output, however.
`&lt;limits.h&gt;` is available when bootstrapping. "... A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;float.h&gt;, &lt;iso646.h&gt;, &lt;limits.h&gt;, &lt;stdalign.h&gt;, &lt;stdarg.h&gt;, &lt;stdbool.h&gt;, &lt;stddef.h&gt;, &lt;stdint.h&gt;, and &lt;stdnoreturn.h&gt;. ..." http://port70.net/~nsz/c/c11/n1570.html#4p6 
Rename your `main()` function to something else. Write a new `main()` function that calls something else in a loop. int somethingelse(int argc, char **argv) { // whatever return 0; } int main(int argc, char **argv) { for (;;) somethingelse(argc, argv); }
Hmm, a freestanding implementation is usually one that doesn't run under an operating system. Not sure if bootstrapping's the term I'm looking for? Like when you're installing a C library or compiler, you have it built, but you need to create the headers in the include search path so they can be used by the programmer. It seems like the &lt;limits.h&gt; I have in /usr/include is the same for different platforms, and all that changes are some macros that are exported by the compiler (e.g. `__WORDSIZE`, `__CHAR_UNSIGNED__`), so the &lt;limits.h&gt; covers multiple platforms but it's only useful to the preprocessor. I like the idea of producing an easily readable &lt;limits.h&gt; for each platform, particularly from a 'self-documenting' perspective. :-)
Read the documentation of `printf` or `scanf` resp. and figure out what you did wrong. Without seeing your code it's hard for us to see what went wrong.
Thanks for the formatting ElGringoFlicka, but you could add on top the #include ...... main should be: int main() and the line //set the parameters of the first link t-&gt;item = 1 //assigns item of the first link is missing ; after 1
Basically, the number of `%` must match with the number of variables/pointers. printf("%s is %d years old.", name, age); // two %, two variables if (scanf("%d%d", &amp;a, &amp;b) != 2) /* error */; // two %, two pointers 
If you want to learn the basics of C, there is a free online course called cs50 that is an awesome introduction. It's on www.edx.org There is a subreddit as well at /r/cs50 You will learn much more quickly with that course. 
The main performance impact when using a function pointer will be that the compiler will generally be unable to optimize the call, e.g. by inlining it. Depending on what the function does and in which contexts it is called, this might be negligible or a huge deal, as inlining sometimes opens up a host of other optimizations the compiler can perform. In addition to that, function pointers may contribute to instruction cache misses during runtime, when the CPU expects the code to go in one direction, but at the last moment, it sees that the function pointer points to another part of the code. As always, if you are worried about performance, measure it instead of making assumptions.
My code isn't slow. At least that wasn't the issue yet. I was wondering what kind of overhead is there against calling functions directly. Nature of programs I make for myself are so that they require several different implementations for same functionality. It's more of a general rule in all of them (image processing). I don't like abstractions and avoid them, but in these cases I see no other option.
Sure, but actually happens under the hood?
Is that a compiler optimization? 
You are making a few assumptions here about the way things work, and it is not clear that those assumptions are supported by the C&amp;nbsp;standard. For instance, you assume that the value of `CHAR_BIT` is&amp;nbsp;8; that assumption is certainly not supported by the standard (but you recognize that assumption). You also assume that the value having sign bit&amp;nbsp;1 and all value bits&amp;nbsp;0 in two's complement is not a trap representation, so that the minimum value is one less than the negation of the maximum value; that assumption is also not supported by the standard. I would feel uncomfortable using your code without careful justification, by reference to the C&amp;nbsp;standard, for all of the assumptions you are making, so that I could be sure that the values produced are correct for the system I'm working with. It would be a lot easier just to use `&lt;limits.h&gt;`.
Well I didn't know what to expect, hence why I asked! I somehow thought there was a stack frame for function pointer that then got delegated as a stack frame for called function and that that somehow was the extra effort/cycles vs normal calling. 
Disclaimer: I'm no expert on compilers / CPUs, so take the following with about a teaspoon of kosher salt. The CPU has something called a [Program Counter](https://en.wikipedia.org/wiki/Program_counter), sometimes called instruction pointer. It's a register that holds a pointer value. This pointer points to the current instruction of the current program. Normally, this pointer is incremented by one after each instruction is processed by the CPU, so the processor steps "line wise" through the program. However, there are some instructions that manipulate this program counter. Some of them are used for conditional execution ("if the eax register contains 0, write 0x4aef into the program counter, otherwise write 0x4bcc"). Another one, "`call`", is for calling functions. Each function in your program has a unique address in memory. At this address you will find the first instruction of the function, probably writing the function arguments into registers. When you call a function the normal way, the compiler emits a "call" instruction to the CPU with the function's address (plus some other instructions for argument passing etc.). In this case, the address is hard-coded. The compiler knows exactly where it wants the CPU to continue executing. In the case of function pointers, the compiler emits the same instruction, but instead of hard-coding the address, it asks the CPU to read the next instruction address from a register. That's what /u/jedwardsol was mentioning: call foo // Call function "foo" with a hardcoded address call [rax] // Next instruction is at the address found in the rax register, e.g. a function pointer 
That's not at all what the situation is like in reality, though.
Either you forgot a format specifier: // wrong: printf("my age is ", x); // correct: printf("my age is %d", x); Or you forgot an argument: // wrong: printf("ASCII code of %c is %d", 'a'); // correct: printf("ASCII code of %c is %d", 'a', 'a'); 
The [Computer Language Shootout Game](http://benchmarksgame.alioth.debian.org/) has a series of benchmarks designed to be hard to optimize away for the compiler. Go is also in there, here is [Go compared to C](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=go&amp;lang2=gcc).
This example is from the book Algorithms in C by Robert Sedgewick. It's a good book on algorithms, but the C practices has changed from 1997.
It's exactly like reality. #include &lt;stdio.h&gt; #include &lt;string.h&gt; size_t MeasureString(const char * string); size_t MeasureString(const char * string, size_t(*Measurer)(const char *string)); int main(int argc, const char *argv[]) { printf("%d %d", (int)MeasureString(argv[0]), (int)MeasureString(argv[0], strlen)); } size_t MeasureString(const char * string) { return(strlen(string)); } size_t MeasureString(const char * string, size_t(*Measurer)(const char *string)) { return(Measurer(string)); } Disassembly 00007ff7`1cdb178f mov rcx,qword ptr [rbp+0E0h] 00007ff7`1cdb1796 call qword ptr [rbp+0E8h] 00007ff7`1cdb173a mov rcx,qword ptr [rbp+0E0h] 00007ff7`1cdb1741 call strlen (00007ff7`1cdb11a4) The only difference between the 2 functions is the form of the call instruction used. There are no extra stack frames and no extra setup or cleanup
That makes sense. The formatting really made me cringe. Also the single letters for variable names. Ewwwww.
Thanks!
I have another question for you. How do I realloc() my array of pointers when they reach a certain size? If, I'm using the example you provided (with char cast instead of int) and then putting strings in each c[i], why doesn't something like this work? if(i == 9) { c = realloc(c, 20*sizeof(char)); }
 for( a = 0; a &lt; arg1; a++ ) { sum += a; } It's called induction variable: https://en.wikipedia.org/wiki/Induction_variable
You could change the condition to be isspace(last) &amp;&amp; !isspace(c). This will only count the last sequential space. It will not increment if the file ends in a space, so it's up to you if that's a problem and how to account for it. Also worth noting that isspace() includes the newline character (\n), but I assume you realized that already and are intentionally including it.
Thanks for the help! It looks like changing the condition gave me the output that I was looking for.
`rand` is not thread-safe. Use `rand_r` instead.
In the example I gave, `c` is not dynamically allocated. You can only `realloc` memory that has been allocated using `malloc` (or others in the family, `calloc`, `realloc`). Also, since `c` would be holding `char*` not `char` if it was an array of C-strings. 
What's the best way to get the seed for rand_r ? I'm trying to use _Thread_local unsigned int seed = time(NULL) but I keep getting "initializer element is not constant" errors, and Im not sure of a good workaround.
Never mind, I just defined a global integer of some arbitrary number, thanks for your help!
I'm not sure this is what you want. That gives each thread the same state, and unless you provide your own synchronization for each call to `rand` it's not thread safe again. I would provide each thread with its own seed (maybe from `time(0)` + the thread id?), stored as a thread-local or somewhere on the stack.
Please try this, it works on only 1 line of input but on any number of blanks. #include &lt;usual.h&gt; int main( ) { int c; //current character int last = '\n'; //Previous int line_count = 0; //Number of lines int char_count = 0; //Number of characters int word_count = 0; //Number of Words int getout = 0; int prevspace = 0; while ( ( c = getchar( ) ) ) { if ( isspace( c ) &amp;&amp; prevspace ) continue; if ( c == '\n' ) //When 'Enter" is pressed { line_count++; getout = 1; } else if ( isspace( c ) &amp;&amp; !prevspace ) { word_count++; prevspace = 1; } else { char_count++; prevspace = 0; } if ( getout &amp;&amp; char_count &amp;&amp; !word_count ) word_count++; if ( getout ) break; } printf( "Number of Lines: %d\n", line_count ); printf( "Number of Letters: %d\n", char_count ); printf( "Number of Words: %d", word_count ); return 0; } 
And it doesn't have to be over skype, just need assistance with a semi-complex issue i'm trying to solve
You could post your issue here, then we could try to help you all together.
What is wrong with this syntax?
I'm thinking: y1 = p1 + 1; y2 = p2 + 1 + "E"^p1; y3 = p3 + 4 + "N"^p2 y4 = p4 + 9 + "S"^p3 so i broke out p, dvs input. 
`rand()` isn't suitable for Monte Carlo simulations anyway, nor will `rand_r` typically be more suitable than `rand()`. Your problem with seeding a `_Thread_local` variable with `time(NULL)` is that the initialization must either be executable at compile time or you must execute it at run-time on the correct thread. So you could set the `_Thread_local` seed at the beginning of your thread entry point if you wanted. However it's not a good idea to use `_Thread_local` variables for something that you're going to be accessing very frequently, such as for the state of a RNG when the threads are doing a Monte Carlo simulation. This is because accessing `_Thread_local` data can be relatively expensive. Instead what you should do is avoid the need for any synchronization at all: simply have an array of seeds which you set up in your main function before launching the threads, and simply tell each thread what state to use. int thread_work(void *ptr) { int *seed_ptr = (int *)ptr; rand_r(seed_ptr); // ... } int main() { unsigned int seed_data[n_threads]; // ... initialize seeds; thrd_t thread[n_threads]; for (int i = 0; i &lt; n_threads; ++i) { thrd_create(thread + i, thread_work, seed_data + i); --- Since, as I said earlier, `rand()` and `rand_r` are not suitable for Monte Carlo simulations you should use a different pRNG. [Here's][1] one option which should be relatively easy to integrate into your program. [1]: http://www.pcg-random.org/download.html
So for a pthread I would just pass the seed in as the fourth argument to pthread_create? Sorry for late reply. I ended up setting a global int and then changing the value to time(0) in the main function and using that as the seed for all of my rand_r calls, and it seemed to give me reliable randomization, as my results were all a little different, however I was also creating a random number of pthreads, up to 999.
I agree that the description of an induction variable in the wikipedia article matches the loop in the benchmark. However the wikipedia page only shows simple optimizations that will be performed on induction variables, like replacing a multiplication by an addition. It doesn't give any example like in the blog, where a complete loop was eliminated. Do you think it is nevertheless the induction variable optimization that is used here?
My guess is that the induction variable analysis is used as a generic mechanism to detect this optimization opportunity and that the summation formula is one of many handcrafted transformation plugged into the induction variable analysis. But maybe I'm wrong and there is a generic method that derives the formula from the code...
For small `arg1`, this is probably possible on machines where multiplication is slow.
Thanks.
&gt; I just assume… *otoh* I do sympathize. Any time I read some mangled name like -- Computer Language Shootout Game -- I just assume that if the writer cannot be trusted to correctly copy text from a web page then we shouldn't trust them to understand what's shown on that web page. *otoh* I suspect that the difference we care about is the actual not the theoretical -- if it takes an ideal programmer, unlimited time, to achieve… Can we agree that comparisons that show low-level languages performing high-level tasks may be misleading, because the low-level language offers myriad possibilities while the high-level language offers standard libraries.
You allocated n as an array of 5 ints, but then you're trying to free each element in the array individually. You aren't allowed to do that. In C, each malloc() call must be matched by exactly one free() call. You're malloc'ing once, but free'ing 5 times. Alternately, the only valid arguments to free (http://linux.die.net/man/3/free) are pointers that have previously been returned from malloc. That is not what you are doing.
Relieving to know my problem wasn't caused by my other code. I was just writing some random test code. Thanks, and thank you for the note on free()'s arguments. Not noted by my question, but it also explains why valgrind was saying I had a lot of frees vs mallocs. Good things to know for future reference.
Thanks for the heads up.
Yes, I was referring to the data member. /u/morethantoast and /u/dragon_wrangler expressed it more clearly than I did. Your solution is half way there - the node should be responsible for the allocation and the freeing of the memory, not just the freeing. At the moment `createNode` doesn't know the size of the data it is managing (other functions know it is an int) You can extend it by NodePtr createNode(void *data, size_t datasize) { ... node-&gt;data = list-&gt;af(datasize); memcpy(node-&gt;data,data,datasize); } where list-&gt;af is an allocator function which matches list-&gt;df (malloc and free, for example) 
Thanks for the reply. When I compile it in debug I don't get any errors. Is there another debugger that I don't know about? I'm still fairly new to C so pardon my ignorance. My IDE is Code::Blocks and my OS is Windows 7.
Thanks for the reply. You're always helpful on this subreddit. I added: int i; i = index; before // Print the tokens. and then I changed my "Free the memory" section to: // Free the memory. for(index = 0; index &lt; i; index++) { free(pointer_1[index]); } free(pointer_1); but I'm still getting the error. Am I missing something?
Gotcha, thanks for the note! It's just that in our implementation (for class), my professor wants the list to be able to handle any data type, and to be able to destroy the list without knowing if the data it received was dynamically allocated (by the caller). The list is a separate library. I think this wasn't clear in the code I provided, but the caller provides both a comparing function and a destructor function. So if the data for a list wasn't allocated, the df given to the list would point to a similar function as the `DestroyAllocated()` one I provided, except it is pretty much blank and does nothing. I'm not sure if that's considered a poor convention, but I believe the lesson is to practice information hiding. Of course, my implementation could in fact be handling that specification incorrectly/poorly. Otherwise, is what you are suggesting still necessary?
You have the same bug on the previous line - you are printf'ing up to p_array_size as well.
Add comments. Not for others to read, [but for all your future selves](http://catb.org/~esr/writings/unix-koans/prodigy.html). Try not to be too clever.
Interesting read. Thanks.
Some tips: * Use a consistent style throughout your code (I won't advocate any specifics here, just choose a style that makes sense to you and _stick with it_) * Choose descriptive names for variables * Minimize the scope of all variables * Minimize repeated code-- make functions reusable * Avoid using complex macros * Never use magic numbers * Add comments that answer the question "Why is this code necessary?", not "What does this code do?"
Thanks.
Very thorough. Thanks.
This is an amazing comment. I've been working on a huge code base for a very long time and areas of the code where these types of patterns were followed are SO much easier to maintain. It's so much more important to write easy to understand / debug / maintain code than it is to be clever and fancy.
Repeated multiplication. 
Yes, I did, this is the Makefile: obj-m += reverse.o CFLAGS_reverse.o += -DDEBUG all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean ------------------
That runs another makefile. See `man make` and `/-C`
Right, it's getting that path from someplace else. It's not a secret though where. Just follow what the Makefile is doing with `clean` there.
I just found it! /lib/modules/4.2.3/build and /lib/modules/4.2.3/source are actually soft links to /home/andres/kernel/linux-4.2.3. Thank you very much, Andres 
On the product's page is the datasheet for the device: http://cdn.sparkfun.com/datasheets/Sensors/Temp/DS18B20.pdf You'll wanna read it thoroughly. The device only communicates data using a single pin. On page 5 it briefly discusses the configuration of the resolution of data in bits. One concern this brings up is whether you want a program which reads data with a single bit resolution, or if you want to be able to adjust the resolution any time. Be aware of endian-ness of data, size (in bits/bytes) of data points, etc. Around Page 10 it starts discussing comms with the device and describes how you'll query the device for data. I could read more and give out more specifics on what it says, but it may be better for this sub for you to give that a go and return with specific questions. Read it VERY thoroughly though! Whomever developed that code you're trying to not use theoretically only had this PDF to reference (and perhaps a call or two with the manufacturer for clarifications) so what you're trying to do should be quite possible :) Good luck!
Good point, here is some code to solve for an arbitrary root: def root(n,r): ''' Programmer: Function title: root Description: takes in a number and how much error desired, and returns the ans Inputs: n --&gt; The number one wishes to root r --&gt; The desired root one wishes to solve Outputs: ans --&gt; n to the root r Note: uses Babylonian Method ''' e = 0 guess = n/5 ans = n timeOut = 10000 # Keeps the program from looping indefinitely i = 0 while( abs(guess - ans) &gt; e) and (i &lt;= timeOut): guess = ans ans = ( ( (r-1) * guess ) + (n/( guess ** (r-1) ) ) )/r i = i + 1 if i &gt;= timeOut: print("\nERROR, function has timed out.\nThe answer may not be accurate.") print("Number of iterations: ",i) return (ans) # end of function: root 
Great list! What tools do you use/can recommend?
Test to see if it is actually maintainable - get a friend who is bright but has not seen your code and ask that friend to make a bug fix or an addition to your code. See if it can be done quickly or not. Hard to find a better indicator of code quality than measuring how long it actually takes to make changes to it.
Last time I checked, Newton's method did not have exponentiation.
That's a good idea.
This is not a language requirement. The standard library can be written in whatever language the implementors want. Often it will be C, some times it will be assembler; it can be COBOL or Perl too.
You can implement whatever you want. You can even do it without floating point support if you implement floating point yourself..... typedef struct myFloat { unsigned long mantissa; unsigned long exponent; } Have fun!
Nothing super clever about the code by any means, but doing it (as ghos7rider suggested) via binary search seems to work pretty well ... #include &lt;stdio.h&gt; double abs(double x) { return(x &lt; 0.0 ? -x : x); } double getRoot(double value, int n, double tolerance) { double low = 0.0; double high = value; double guess = 0.0; for(;;) { double current = 1.0; double delta = 0.0; int i = 0; guess = (low + high) / 2.0; while(i &lt; n) { current *= guess; i++; } delta = value - current; if(abs(delta) &lt; tolerance) break; if(delta &lt; 0.0) high = guess; else low = guess; } return(guess); } int main() { const double tolerance = 1e-10; int number = 10; while(number &lt; 10000) { int i = 2; while(i &lt; 10) { printf( "%d^(1/%d) = %.10f\n", number, i, getRoot((double)number, i, tolerance) ); i++; } number *= 10; } return(0); } 
Whenever you fix a TODO, don't remove the whole comment, just remove "TODO:" and let the plan become a description of the code below.
Musl has a complicated implementation in C [here](http://git.musl-libc.org/cgit/musl/tree/src/math/pow.c). Glibc has [this](http://sourceware.org/git/?p=glibc.git;a=blob;f=math/w_pow.c;h=33a45ac6110027a09e8fa7aa58308a71ce036b64;hb=HEAD), which delegates to [__ieee754_pow](http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/i386/fpu/e_pow.S;h=8203c9625ac02da52a72b7af73d5ac4627ea829c;hb=HEAD), an assembly function, and then handles the error conditions in C. The real question is why glibc's assembly implementation is so complex. You can compute x^y as 2^\(y ^* ^log2(x)), and the x87 FPU has the instruction `FYL2X` to compute y * log2(x) and `F2XM1` to compute 2^x - 1 (no clue why it subtracts 1), then you just have to add 1 back.
This will solve for it: #include &lt;stdio.h&gt; double absoluteValue( double input ){ if( input &lt; 0 ){ return input * -1; } else { return input; } } double exponent( double base, int power ){ int i; double ans = 1; for( i = 0; i &lt; power; i++ ){ ans = ans * base; } return ans; } double root(double n, int r){ double e = 0.0000000001; double ans = n; double guess = n / 5; int timeOut = 1000; // used so that the function will not loop indefinitely int i = 0; while( (absoluteValue(guess - ans) &gt; e) &amp;&amp; (i &lt;= timeOut) ){ guess = ans; ans = ( ( (r-1) * guess ) + (n/( exponent(guess, r-1) ) ) ) / r; printf("ans = %f\n", ans); i++; } if( i &gt;= timeOut ){ puts( "ERROR: function has timed out\nThe result will not be accurate!" ); } printf("Number of iterations: %d\n", i); return ans; } // main is for testing the above functions int main(void){ printf("abs(-3.5) = %f\n", absoluteValue(-3.5) ); printf("exponent(3, 4) = %f\n", exponent(3, 4) ); printf("root(10, 3) = %f\n", root(10,3) ); return 0; } 
The glibc's exponentiation routine is very complicated because it's both precise (the result is always correct to all available bits) and reasonably fast. The x87 instructions often have limited precision (for example, `fsin` is known to give very wrong results for some cases) and aren't particularly fast.
You should leave the #include in. The alternative is to have a comment at the top which says "you need to include time.h in order to use this header file" If I am happily using version 1of your header, and then upgrade to version 2, I now have to edit every source file which uses example.h and add an include to time.h. 
Not really and why would you want to? You are building a dependency on time.h into your library. If you remove the #includes for all dependencies, then anyone who uses your library will necessarily need to know and source anything you're dependent upon, dramatically decreasing the value of your work.
Why are you so bent on removing all `#include` directives? There's a reason they exist! In this case, however, you can use a forward declaration: #ifndef EXAMPLE_H #define EXAMPLE_H struct time_t; void fooFunction(struct time_t*); #endif However, keep in mind that you'll probably need to `#include &lt;time.h&gt;` at some point, probably in the `.c` file where you define `fooFunction`. And depending on the situation, you might be requiring almost anything that uses this header to `#include &lt;time.h&gt;` for similar reasons. This usually isn't worthwhile. Not in C, at least (C++ changes things somewhat).
Thanks for the reply! Maybe I should clarify a bit though, I understand how the signal is structured I'm more curious as to what resources I have in C to read it. Ie I'll need to wait x milliseconds and check a value, put it in a buffer, wait, check again... Things like that. What libraries should I look at in C to allow me to synchronize things with real time as opposed to what I'm used to, writing instructions with no real concern to how long or when an individual one occurs 
It's not really RPI territory. You can't use this hardware (with Linux. in userspace), unless the RPI hardware directly supports the protocol it uses. The thing is, Linux sucks for realtime, so the interaction can not happen in user land. You pretty much have 3 options: * Use an MCU (like Arduino) to convert it to standard rs232 serial signal, because it's easy to use the serial port on Linux. * Write a "driver" kernel module, this could work, but i'm not that familiar with the raspberry, but i'm pretty sure you can configure interrupts for the GPIO and have precise hardware timer interrupts. * Use an RTOS with the raspberry pi 
[pastebin](http://pastebin.com/6FSmva6g)
I *think* I've got it. The last rule there says "for any file [name], that file depends on [name].o and you generate it by linking", so what's happening is that you run `make all`, it wants `core1` so it looks for `core1.o`, builds it, but then it will try linking it. What you really want is `all` to only depend on the final program(s), and then the final program to depend on all the `.o` files which are compiled with the second rule there for `%.o`. I'm not a makefile wizard, I need to look up the rules every time I play with it. Here's one that I can barely read I made a while back which hopefully illustrates the point. SOURCES:=$(wildcard *.cpp) OBJECTS=$(SOURCES:%.cpp=.%.o) # Pull in auto-dependency info # -include $(OBJECTS:.%.o=.%.d) # Link # prog: $(OBJECTS) $(LINKER) $(LINKER_FLAGS) $(OBJECTS) -o $@ # Compile # .%.o: %.cpp $(COMPILER) $(COMPILER_FLAGS) $*.cpp -o .$*.o $(COMPILER) -MM -MT .$*.o $(COMPILER_FLAGS) $*.cpp &gt; .$*.d # Clean # clean: rm .*.o .*.d prog As you can see, the program linking depends on the objects and the objects depend on their relevant cpp files
It's a matter of exposing an implementation detail of your interface (API) to your users (including yourself). Why you define an interface is so your users can care only about it, not the implementation details behind those interfaces that can change over time.
should the x%2 be a%2 ? edit: actually, i think that won't work since i think the first term is supposed to be positive. but i think it has to do with that mod check being incorrect since x is always odd . on mobile or else I'd look into it further. I'll also add that Wikipedia has a simpler formula already in summation notation so it's easy to code in a for loop.
Some of these "tips" are just awful.
This code works, I have personally tested it. #include &lt;stdio.h&gt; int main() { double R_n; //Input by user double I_guess, N_val, IT_exp, d_0, N_val1, a; // Variables used in the program int rt, n, i, rt_1; // roots char trash, cmd, con; // command to redo root and also trash which clears the buffer. do { do { //Input Request from user printf("Enter a real number and an integer: "); n = scanf("%lf %d", &amp;R_n, &amp;rt); //Invalid Input Protocol if (n != 2) { printf("Invalid Input! Try Again \n"); // Clear the buffer do { scanf("%c", &amp;trash); } while (trash != '\n'); } } while (n != 2); //loop repeated until desirable input is obtained. I_guess = 1; N_val = 0; do { //I_guess = N_val; d_0 = I_guess; rt_1 = rt - 1; //Exponent calculation IT_exp = 1; for (i = 1; i &lt; rt; i++) { IT_exp = IT_exp*d_0; } //Formular for finding the root. Major maths done here N_val1 = ((1.0 / rt)*((rt - 1)*I_guess + (R_n / IT_exp))); a = N_val1 - I_guess; //absolute value if (a &lt; 0) { a = -a; } I_guess = N_val1; //Increase guess in case the initial guess is wrong } while (a &gt; 0.000001); //Precision check printf("The %d root of %lf is %lf \n", rt, R_n, N_val1); //Ask for command //clear the buffer before asking for command do { scanf("%c", &amp;trash); } while (trash != '\n'); do { while(trash != '\n'){ scanf("%c", &amp;trash); } printf("Find another root? Y/N: "); scanf("%c", &amp;cmd); switch (cmd) { case 'Y': case 'y': con = 'y'; break; case 'N': case 'n': con = 'n'; break; default: printf("Invalid command! \n"); con = 'o'; break; } } while (con == 'o'); } while (con == 'y' ); //redo the root if command is Y or y. return 0; }
You seemed to understand the problem but I think your solution is too complex. You don't need to do this on a line-by-line basis -- you can read it a character at a time and replace any instances of '\t' with TABSTOP number of spaces as you go-along. This boils down to having a loop that reads a character. If that character is a tab ('\t'), then print eight spaces. If it is not a tab, simply output that character. Here is a quick example of what I'm talking about: #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int c, tabsize = 8; while ((c = getchar()) != EOF) { if (c == '\t') for (int i = 0; i &lt; tabsize; i++) putchar(' '); else putchar(c); } } 
And just for fun this is a short and incredibly stupid version. #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { const int tabsize = 8; for (int c = getchar(); c != EOF; c = getchar()) (c == '\t') ? printf("%*.*s", tabsize, tabsize, " ") : putchar(c); } 
Thanks again for the advice. I do own a few MCUs I've been playing around with namely the Arduino, ATMEGA 328p (which as I understand is the Arduino's MCU sans fancy breakout board), and an mbed lpc1768. I've used the serial library a little bit in the mbed and it's starting to sound like that might be a more clever, or at least more sensible, solution. 
The problem is that in your 'all' rule, you list 'core1 core2 manager1 and manager2', which will all be seen as binary (executable) files. This will invoke the '% : %.o' rule (which will, in turn, invoke the '%.o : src/%.c' rule) for all of these, including (as you've seen) for core1 and core2. What you actually want to do, is to tell make to compile (but not link) the sources to create the files core1.o, core2.o, manager1.o and manager2.o. And then once you have those files, you want to link manager1.o, core1.o and core2.o together to create manager1, and then link manager2.o, core1.o and core2.o together to create manager2. So, first of all, your 'all' rule should just have the filenames of your final binaries: all: manager1 manager2 And then, in the link stage, you want to specify that, to build a binary called XXX, you need the file XXX.o along with core1.o, core2.o and core3.o: % : %.o core1.o core2.o core3.o $(CC) -o $@ $^ $(LDFLAGS) Note that I've changed the command slightly. I've moved the $@ to the correct place (after the '-o' as that's the option to specify the output filename) and I'm using $^ instead of $&lt;, so that _all_ the prerequisites (the .o files in this case) will be provided to the linker ($&lt; just provides the first prerequisite). You could consider adding the '-o' to your compile rule, to be explicit about the output filename instead of asking the compiler to base it off the input filename: %.o : src/%.c $(CC) -o $@ -c $(CFLAGS) $&lt; Here we definitely do want to use $&lt; instead of $^. I'll mention why in a second. You probably also want to put in some dependencies so that if you change, for example, core1.h, then core1.o will be recompiled. You can do this explicitly: core1.o: src/core1.c include/core1.h core2.o: src/core2.c include/core2.h core3.o: src/core3.c include/core3.h or using wildcards: core%.o: src/core%.c include/core%.h Note that these rules don't override or invalidate the '%.o : src/%.c' rule, they simply add dependencies to it. You probably also want to add something similar for the managers, as they will use the core headers: manager1.o: src/manager1.c include/core1.h include/core2.h include/core3.h or using wildcards: manager%.o: src/manager%.c include/core1.h include/core2.h include/core3.h (and it would make sense to put that list of headers in a variable, but we'll come to that in a bit). This is why we want to use $&lt; for the compile rule. The first prerequisite is the C source file (.c), which is the file to pass to the compiler. Any remaining prerequisites will be header files, which we definitely don't want to pass to the compiler on the command line. (You can also generate these 'dependency rules' automatically, as in /u/ChallengingJamJars' example makefile. But I'd recommend avoiding that for the moment so you can get a better handle on how make works.) In /u/ChallengingJamJars' comment, their example makefile uses variables to specify lists of sources and object files. Although I personally disagree with using $(wildcard) to automatically grab a list of sources (except for Quick And Dirty projects), using variables in this way is highly recommended. Not only do you save time, but your makefile will be easier to understand and modify as you are separating the project structure from the actual rules that do the work. So, your list of final binaries could become a variable: ALL_BINARIES = manager1 manager2 manager3 which would change your 'all' rule to: all: $(ALL_BINARIES) And maybe your list of core modules: CORE_OBJECTS = core1.o core2.o core3.o which would change your link rule to: % : %.o $(CORE_OBJECTS) $(CC) -o $@ $^ $(LDFLAGS) You could, if you wanted to, use $(wildcard) to generate things like your list of core objects: CORE_SOURCES = $(wildcard src/core*.c) CORE_OBJECTS=$(CORE_SOURCES:src/%.c=.%.o) Finally, what if you have say, manager1 requiring manager1.o, core1.o and core2.o, and then manager2 requiring core1.o and core3.o (but not core2.o)? You could do this in a similar way to the dependencies for the object files. First of all you would change your linker rule back slightly: % : %.o $(CC) -o $@ $^ $(LDFLAGS) so it doesn't require any of the core modules, but it still uses $^ to pass all prerequisites to the linker. Then you add dependency rules for each of your binaries: manager1: manager1.o core1.o core2.o manager2: manager2.o core1.o core3.o One final caveat. I haven't tested any of this, it's all off the top of my head, so there might be mistakes. Also, I think you don't actually need to specify the automatic dependencies in the dependency rules for either the compiler or linker. So this: core1.o: src/core1.c include/core1.h could probably be: core1.o: include/core1.h as the '%.o : src/%.c' adds the dependency on src/core1.c anyway. And also: manager1: manager1.o core1.o core2.o could probably be: manager1: core1.o core2.o as the '% : %.o' adds the dependency on manager1.o. Either way, I think it's clearer to include all dependencies in dependency rules as it's a bit clearer. Let me know if you have any further questions or if anything I've mentioned here doesn't seem to be working (and anyone else who's actually bothered to read all of this, please correct me on any mistakes I've made). PS. I recommend adding in a 'clean' rule, to delete all output files (object files and binaries). I don't recommend using wildcards for this: clean: rm *.o as you might end up deleting something you wanted to keep. Instead, this is another area where it's useful to have variables with things like your list of objects and list of binaries in. So then you can just do: clean: -rm $(ALL_OBJECTS) $(ALL_BINARIES) The '-' before the rm command is to tell make not to abort if the command fails. This means that you can do a 'make clean all' after doing a 'make clean' and the failure of the 'rm' command (as there are no files to delete) will not stop make going on to run the 'all' rule. PPS: I'm guessing as you have .c files in srcs/ and .h files in include/, you have stuff like: #include "include/core1.h" in your source code files? You should set CFLAGS so that you can instead do: #include &lt;core1.h&gt; This can be done by adding (near the top): CFLAGS = -Iinclude
I think the memcpy example is backwards. It should be memcpy(dest, src, n).
Your post got caught in our spam filter. My apologies.
Loop through the first index and call a function to print the row for (row = 0; row &lt; nrows; row++) { if (array[row][0] == 1) printrow(array[row]); } Writing `printrow()` is left as an exercise
Memory allocated with `malloc` is available until it is freed with `free`.
Thanks.
Sorry about the mansplaining, but: There are 4 different regions of memory, the text segment, the data segment, the stack segment and the heap. The text segment you don't control - that's your program's machine code loaded into ram for execution by the CPU. The data segment refers to the data that you specify in your program, that are not local function variables. The stack, which is a region of memory that grows as functions are called and shrinks as functions return, stores your function arguments and local function variables. That's why they disappear when the function returns, because the stack pointer is unwound to wherever it was before the function was called. Finally there is the glorious heap. The heap is where malloc allocates new memory. Anything you allocate in the heap is there until it is freed. If you had forgotten to free the returned memory address to your buffer, for example, it would live until your program died. If you lose track of something allocated on the heap (a very common problem), your program is said to leak memory. Another common problem is freeing allocated memory and then attempting to refer to that memory. In general, it is a good thing to avoid using heap allocated memory unless it is truly necessary. Generally, the most common use case for heap allocation are data structures that are dynamically sized or effectively global in scope. Often, you need a structure just for the life of a function. For example, lets say you want to check for the size of a file before reading it, using the "stat" system call. In that case it is better to use a local variable of type struct stat and pass the address of that to the stat function. That way you don't have to worry about cleaning anything up. A common cleanup pattern with allocated memory is to use goto. (Yes, despite what your mother says, goto isn't evil.) Generally you have a label that cleans up any allocated memory and you can jump to that label if your function needs to abandon early. If you're going to use heap allocated memory, do yourself a favor and initialize the pointer to NULL during declaration: int *my_ptr = NULL; /* you need to do this because the stack doesn't get zero-initialized and may contain garbage */ so that you can easily test and free: if (my_ptr == NULL) { free(my_ptr); } That way you can have code like: ... if (something_bad_happens == 1) goto My_Label; ... My_Label: if (my_ptr == NULL) { free(my_ptr); } Another tip is to avoid lots of tiny allocations in favor of larger blocks. Heap fragmentation can lead to a situation where there is no block of memory large enough to satisfy a request for memory (malloc call), but the total aggregate free memory is larger than the requested memory. Imagine if we had 4 bytes of memory and every other byte were already malloced. Asking for 2 bytes can't return a valid memory reference because there aren't two contiguous bytes free. Look at functions like realloc to resize already allocated memory. Finally, test your malloc calls. Get into the habit because someday a malloc will hit against a memory limit and return NULL. Then hilarity will ensue and chances are, if you're using up that much memory, you're doing something interesting that you don't want to fail.
Thanks for the reply. I had a good laugh when I got to this part: &gt; Get into the habit because someday a malloc will hit against a memory limit and return NULL. Then hilarity will ensue
Also, `sizeof(char)` is unnecessary since it's always `1` by definition. It can be good for clarity, but when directly assigning the result of `malloc` to a `char*` anyone should be able to understand without it just fine. (/u/Asus_)
I just left it up to OP :) If he eventually starts working with unicode, and those chars become wchars....things get weird!
Thanks so much. I think I understand what's going on here. I'll spend some time at it today and will report back my success/fail. Thanks a ton.
I know all about virtual memory systems. Your program will not crash - it'll take a page fault and, as you say, the OS will give you a page. 
Unless it doesn't have any to give you, in which case your program will crash. https://www.kernel.org/doc/Documentation/vm/overcommit-accounting Linux isn't the only system that does things this way.
Linux in mode 0 is a broken operating system.
Guess what mode is the default? It's mostly the same for Mac, Windows, and BSD like systems too.... Checking the return value of malloc is an okay thing to do, but for 100% reliable C code it is not sufficient. There's a reason I hate using dynamic memory allocation.... ( I'm and embedded developer. I'd much prefer to just have everything statically allocated at run time!)
On some of the boards which I use for projects have a fixed amount of ram and I don't believe they support virtual memory (not that there's anything to swap to). I believe if you malloc you can get back a null. But yes, on a "real" computer with "real" memory it is incredibly hard to run out of memory. Although I should say that a slow leak can eventually cause memory exhaustion without any "red flags" being raised as the program and OS start to use a lot of swap.
http://imgur.com/4yJ99UE
Thanks.
This is called a [thread pool](http://docs.oracle.com/cd/E19253-01/816-5137/ggedn/index.html). The basic concept is that you create a queue of work items, and each thread in the pool waits for a work item to be available, retrieves it from the queue, completes the action, then starts waiting again. If you've just started learning about threads, this concept is quite a bit more difficult to implement but you should be able to understand the basics.
This is exactly what I'm trying to do. Just manually on a very small level. Is there anyway I can say when i write pthread_create to not take any function/routine argument or to take any dummy function as argument and then change that later using say the thread id? 
Micros can also be set up fairly easily depending on your needs. Give it some power-conditioning caps and an optional timing crystal and your ready to play with the code! (32khz external crystal for slower, but more precise timing that can be offered by the matster internal CPU clock) Just remember to keep your ISRs as light as possible, leaving the bulk of your logic for your infinite loop within main()! Oh that's another thing. ISRs are tricky and sorta hacky on an Arduino imo.
He is not stupid, you just mis-copied. It is not "hate" but "Hate" so the word printed out isn't "sove" but "love". EDIT: by the way, I think the formula with .92 etc is designed so that the for loop goes to i&lt;3 so that it reads somewhat like “I am not but I grow until I love (&lt;3 -&gt; love + the fact that then the word reads "love")”
[Here you go](http://lmgtfy.com/?q=If+I+use+malloc\(\)+in+a+function+and+then+return+the+pointer%2C+will+that+memory+be+available+in+main+or+is+it+local+to+the+function+I+created%3F)
I am working on a data structures library. Is this an acceptable use of goto? https://github.com/ivandardi/Data-Structures-Library-in-C-Pointers/blob/master/src/list.c
You are absolutely right! I wasn't thinking. 
It's not for me to tell anyone what is and is not acceptable, but I wouldn't do it like this. All you're doing after those error labels is set the return value to 1 and return. So why not replace those `goto error;` statements with a `return 1;`? If you had to do a lot of cleanup work after detecting some kind of error, then yes, you might jump ahead, do the cleanup and return. But you don't, so this just seems needlessly complicated to me.
But this way I get a single return point from the function, so it's easier to debug or something. I dunno. I've seen lots of people saying that gotos are acceptable for achieving a single return, so I just went with it. And it's actually easier for me to use that, because if I find an error, I just set the error variable to the error and go to the error part. It abstracts me having to think about dealing with the error, because it's already handled in the error label. And as you said, it's good for cleanup, so if I eventually create functions that need some cleanup, I can use the style that I'm using already, right? 
Is that tattoo in comic sans?
Look at the for loops in merge (). You're comparing two unrelated pointers.
Why is the code image at the top not of C? 
&gt; Is there a way to convert the 3 letter string into decimal numbers that do not over lap, and so that it stays below 100, as the size of the array is 100. There are 17,576 possible three-letter combinations, so obviously this is impossible in general. However, if there are no more than 100 three-letter strings that will ever actually be used, then you could design a [perfect hash function](https://en.wikipedia.org/wiki/Perfect_hash_function) to map each string to a distinct number in the range 0,&amp;nbsp;1, ...,&amp;nbsp;99. I've never used it before, but you could try using `gperf` to generate a perfect hash function: https://www.gnu.org/software/gperf/manual/gperf.html
Are there specific codes that are used? If yes, you could map those to numbers. Otherwise this is impossible, with letters going from A to Z, there are 15600 possible combinations. There is no way of mapping that to an array of 100 without any collisions, even a hash-table would have them. You'll need to implement some sort of collision resolution.
What are the types of `count` and `sum`? Does the compiler give you warnings when you pass `-Wall`? It might be possible that the problem comes from the code before what you showed us. Please show us more code.
Please put four blanks in front of *every* line of code so your code comes out readable and not garbled as it is right now.
Compiles fine without warnings even when you pass `-Wall` to the compiler?
sorry...new to the site
i have no warnings on either
Where is `count` declared? And what is the definition of `avgWeather()`?
Or put it up on pastebin or the like.
Why did you delete your post?
trying to fix it
I see. I also saw that you deleted [a previous question](https://www.reddit.com/r/learnprogramming/comments/3mhpz2/can_someone_tell_me_whats_wrong_with_my_c_program/) of yours. Please understand that deleting questions, especially answered questions, is highly discouraged in many forums and *will* get you banned in some of them. If you are afraid that someone is going to find your post and cause you trouble, you should have probably not posted in the first place.
GCC had a web page showing where they are incompatible with K&amp;R. otherwise I think you'd perhaps want to try to run an old unix system in an emulator. I think Dennis Richie's original C compiler source code is available somewhere on the Bell Labs website, too. 
&gt; If all you want is a compiler that will compile functions where the parameters are declared in the funny pre-ANSI way This style of function declaration is part of the C standard, too, so just compile it with any standards-compliant compiler. The standardization process added the modern form of function declaration, but it hasn't yet removed the old form, although the old form is described as "obsolescent."
Ah I didn't know that! Is it even marked as deprecated in the new standard?
Oh my, I should've realized quotations aren't passed into the program! I see the quotations marks bound the values, so argv[1] would contain the first string in quotation marks, while argv[2] will contain the second string in quotation marks. Using strstr makes it alot easier! Thanks, I think I got it.
The kinda defunct Turbo C has a K&amp;R mode. It always looked interesting, but i never used it. It's worthwhile to bring up, because Turbo C is actually still abundantly available, although out of mainstream for sometime. 
I believe earlier versions of Irix (we're talking the earlier 4.x release from 1991 here) had a compiler where you had to pass -ansi to get ANSI C89/C90 support. It's possible other unix vendors from this time frame also only supported K&amp;R style C. Feel free to check the C compiler in Microsoft/SCO Xenix releases as well. If your intention is to write C that works on ancient systems from the 1980s to 2015.. well have fun with hello, world type of programs, but you're in for a long journey of wasted time and #ifdef preprocessor hell if you do anything more complex. 
&gt; (Edit: if you want to disallow K&amp;R code with GCC, you can use the -pedantic flag, but that's disabled by default) Note that C89 allows much more of K&amp;R than C99 and C11.
Quotation marks and stuff like that are evaluated by the shell. They do not reach your program. (Except on DOS and Windows, but that's another story).
But it also means the pointer will never be freed if it was allocated....I.e. Memory leak
Thanks! I looked it up and it's right here http://port70.net/~nsz/c/c89/c89-draft.html#3.9.4 I suppose I should have searched more.
The `scanf()` function returns a value. Read the documentation of the `scanf()` function for how to use this value to find out if a number has been entered. Please notice that you cannot make pop-up windows with pure C (if that's what you want to do), you are going to need to use an operating-system dependent library to do any GUI stuff. You can however just output a message saying that the user entered something that is not a number.
Linux will happily over-allocate memory for you and not return NULL even if technically you're "out" of memory. As long as you don't *write* to it, you're fine. By the time a malloc actually fails on Linux, it means the OOM killer is active and chances are you can't do anything meaningful at that point anyway. The OS is killing everything it can to free up memory. So in a modern Linux, checking for NULL from a malloc call is actually 99.999% a useless activity. That's my understanding of "modern" things. Maybe your advice is sound for specialized embedded systems tho. 
Ah, I see. What operating system are you working on? Here is [some documentation](https://www.freebsd.org/cgi/man.cgi?query=scanf&amp;sektion=3) for `scanf()` and related functions. See the section “Return Values” for how to use the return value of `scanf()` to do error checking.
Hmm... i still don't quite understand, and Windows. Currently using microsoft visual studios. It already reads the numbers, but if a non number is input by the user, the program just ends, would using a loop or if statement prevent the program from ending? sorry for all the questions, i've just started learning and non of the videos i've watched seem to have covered this aspect
What don't you understand about the return value?
No! Where does it say that?
Alright, so this is what I could quickly come up with. [simple_thread.c](https://ideone.com/xYp9S9) I don't think was able to explain properly last time, but what I'm trying to do is GPU like parallelism. I want to call one function on a stream of data and want each thread to compute the same function per one data. Right now my example works for just one function and one list of data. I want to scale this for multiple functions and different data, however the format will be the same which is one function on a stream of data. My question is, is what I'm doing even right or worth it? Does this kind of parallelism make sense? My threads are still being created serially hence I don't even think I'm paralleling anything. Any help will be appreciated. Edit: Ignore the output in the ideone link. Its works fine on my pc.
How are you printing out your x &amp; y values? Your variable name choices are a bit confusing. Looks like you use i for your X value and x for your Y value. Maybe this is tripping you up? 
You can also separate the columns in your table with \\t characters instead of varying numbers of spaces.
something useful but not directly related to your problem printf("%*s Hello World!",num,""); the above one prints **num** spaces followed by *Hello World!*
As said in the submission instructions (which you apparently didn't read), put four blanks in front of each line of code for the code to come out readable.
they are two separate loops, and would simply list out all the numbers from 0-100 then all the numbers from 0-10000
This is what the code you provided will do, in English: Initialize n and s to 0 While n is less than 100, Print n then increment n While s is less than 10000, Print s then increment s Take a moment to read that and ask yourself what each while loop is supposed to be doing. The first one will print all numbers from 0 to 99 (why 99?) The second looks like you intended for that to be the square, but the loop you have is going to print all numbers from 0 to 9999. -- Here is what your code should be doing, based off the information you gave: Initialize n to zero Print "n s c t" While n is less than or equal to 100, Print n, n*n, n*n*n, n + n*n + n*n*n Increment n Now all you need to do is translate to code, and understand why this solves your problem.
Yeah I saw what I did and fixed it with a simple append function. I'm getting a 3 character garbage output in front of my fixed string. I updated the paste bin on my OP. Not sure why I'm getting this garbage now. 
What is `fixedstring[0]` before your loop starts? Your first version was a better approach, BTW. That's a horribly inefficient approach to adding characters to a string.
The answer is, yes but not really. A structure is really just an organized series of bytes, and if you know how the compiler arranged those bytes you could access them directly. In reality, don't do that. Structures that will be shared among functions should be defined outside of function scope. Other than that, you would pass and return references just like a string. You know about malloc and free, right?
Thanks for the quick reply. Yes I do know about malloc() and free() but I've never used them with structures. Is there anything special I need to know?
Thanks. I might have more questions for you over the next couple days once I start trying to use them in my project. I appreciate your time.
Did someone else define this or are you just making shit up?
`strtok` would be useful for splitting a string by whitespace.
I'm not 100% sure if the pairs of words will be input on newline. I was under the impression it was how I first said it. 
Firstly, what is this code trying to do? Secondly, they print overlapping because every time your while loop runs both print statements are executed and they both contain '\n' which is for a newline. Thirdly, the printf("%d\n",sqr,s); only prints sqr. If you want it to print both, the print statement should be printf("%d %d\n",sqr,s); although s will always print 0 because you assigned s = 0 in the beginning and then never did anything with it. If you want to make n, sqr, and s print side by side then simply remove one of your print statements and replace the other print statement with printf("%d %d %d", n, sqr, s); This will print all three in the given order side by side. 
If you use scanf properly, it won't really matter. 
How would you use it? I was under the impression scanf stopped at first white space?
You should consider getting a book. They cover questions like these and often approach the language in a way that isn't intimidating. I use the reference appendix of K &amp; R frequently. If you end up working with an esoteric compiler, you should definitely get the compiler manual.
Thanks for the advice. I have K&amp;R and have read it twice but some parts are still confusing. The book is an excellent resource to me but it's not beginner friendly. I use MinGW and so far I haven't run into any compiler specific problems. 
&gt;Thanks for the advice. I have K&amp;R and have read it twice but some parts are still confusing. The book is an excellent resource to me but it's not beginner friendly. I use MinGW and so far I haven't run into any compiler specific problems. I can't judge beginner friendliness. There are some details that I don't always remember, so I use the language reference. I use MinGW as well. Most of the stuff I work on needs to run in Linux and Windows.
Maybe like: char first[40], rifts[40]; scanf("%39s%39s", first, rifts);
To clarify what /u/quintus_horatius said: You *can* use a structure defined in `main()` in another function just fine. You just need to make sure the function you use the structure in knows the type of the structure. It's best to declare the type of the structure up front like this: struct something { ... }; /* notice that we only declare a type */ void foo(struct something smthng) { ... } int main() { struct something my_something; /* define my_something */ ... foo(my_something); }
There's a programming style trick you can use to avoid those kind of mistakes: if (1 == prime1) { ... You can probably already see why that helps: If you were to accidentally write "1 = prime1" it would be a plain and simple syntax error because you can't assign a value to a ~~constant~~ literal integer expression. And "1 == prime1" still works exactly like "prime1 == 1", they evaluate to the same comparison. There's a caveat here, though: If you do it like that, most programmers will hate you and come up with all kinds of irrational excuses for why it's wrong. It boils down to "I don't like the way that looks".
Small note, since primes are defined as being greater than one, and you initialize i to 2, if you use IsPrime(1) you are going to return 1 (true as you seem to define it), which is not correct. I don't see that invocation being made here, but I wanted to let you know incase this is for development of something down the road.
Or, you know, you can have the compiler warn you, or even just have the IDE put a little red squiggle there. Then you don't have to resort to this kinda stuff which makes code harder to read. 
Oh i didnt see it,first time in reddit. Thx so much. 
A hint for future posts: Spelling your words out completely and correctly and using correct grammar will make others much more likely to answer your questions. People highly dislike answering questions in text speak.
How old does your fucking compiler have to be to not warn you about that? I'm guessing it's *at least* 30 years. I was using compilers 25 years ago that warned about that. *You have to turn it on*. 
Something like this? for (int i = 0; i &lt; exponent - 1; i++) base *= base; If you need for it to work with negative/zero exponents it'd be easily expandable.
Thanks.
No. Remember, pointers hold a value. The value stored in `c.ptr` is a memory address. When `c` is copied into `k`, that address will be copied. So if `c.ptr` is `0x20` then `k.ptr` is `0x20`; it's the same address which was returned from `malloc`. So, `free` would be called on `k.ptr`when you're done with the memory.
If you `malloc` space on the heap and then place a variable in there, the variable will live beyond the function where it was allocated (i.e. you just return the pointer, no need to reallocate anything at the call site). Note that whoever receives that pointer is responsible for `free`ing it when they're done.
I think your confusion primarily lies in that functions can accept arguments. That is the way information should be passed into a function. For example: #include &lt;stdio.h&gt; int square(int); int main() { printf("%d", square(10)); } int square(int x) { return x * x; } 
If you're trying to copy strings, you can't do char * pVehicle_name = &amp;vehicle.vehicle_name; You have to use `strcpy` to copy the contents of the vehicle name to your string. Also, two things. First: don't use globals. They're bad. Extremely bad. If you are using globals just so that you don't have to deal with passing function parameters, then sorry, but that's not programming. Second: Put 4 spaces before each line of code so that it gets formatted properly on Reddit. EDIT: Oh, I see your problem. You declared `pVehicle_name` inside the `simulator_input` function and then tried to call it from the `run_simulator` function. The problem is that `pVehicle_name` is a local variable to your `simulator_input`. That means that it's not global and that you need to pass is with parameters to your `run_simulator` function. As I said, globals are bad. You could probably have avoided this mistake if you didn't use globals at all.
Thanks for the reply. I understand that global variables shouldn't be used, so how would I pass the local variable with parameters?
Some of them may well be 20 years old. They are embedded compilers for old processors. 
Like this: int main(void) { int number; simulator_input(&amp;number); return 0; } void simulator_input(int *input_param) { scanf("%d", input_param); printf("%d", *input_param); } In the example above, I passed it as a pointer, so I can edit the variable inside the function. int main(void) { int number = simulator_input(); return 0; } int simulator_input() { int temp; scanf("%d", &amp;temp); printf("%d", temp); return temp; } In the example above, I declared a local variable and made its value be the return of the `simulator_input` function.
Thanks. I appreciate your time.
server.c: &gt; send(client, "Test", 10, 0); // Send the username prompt That's not right. client.c: &gt; fgets(username, 21, stdin); // Get the username input &gt; if (send(server, username, 21, 0) &gt; 0) { // If we sent username to the server That's not right either. What if the username isn't exactly 21 characters (Counting the trailing nul. Also not you declare the username array to be 20 characters, not 21)? What if it's only, say, 5 characters? It'll *work* given the size of the buffers in the server (Though you're using the wrong length in one recv() call), but it's poor design to be sending excess garbage characters.
[Don't use feof() like that](http://c-faq.com/stdio/feof.html). You're immediately freeing what readToken() returns, and then assigning that freed pointer to a spot in the array. Attempting to access that pointer after freeing it is undefined behavior. If you're lucky it'll just crash. The only one you're not freeing is the very first token read. Also, when you grow the array, you're never increasing the size variable. That's also not the right way to use realloc(). You're ignoring the return value and computing the wrong size.
Agreed. I really like this subreddit, probably one of the most underrated on Reddit. It has less shitheads (well virtually none) compared to the #c irc channel on freenode. The response to questions have quality similar to StackOverflow. There's lots of good discussion.
You're already doing what you need to when sending the password prompt in the server. strlen() is your friend. TCP sockets, like files, are streams. If the remote end sends 15 characters/bytes, and the receiving end reads 5, there's still 10 bytes waiting to be read that will be used the next time the receiver reads from the socket. If it's willing to read 100, but there's only 15 bytes waiting, it'll read just those 15 and not touch the rest of the buffer being used to hold what's read (read/recv/etc. return the number of bytes actually read. You have to save that and use it, not just check for a -1).
You were taught wrong. That happens a lot, unfortunately. You should use fgets(), fgetc(), etc. until they indicate failure. Then use feof() and ferror() to tell why, if you care. There's an example using fgets() in that FAQ link. Here's the FAQ on [realloc()](http://c-faq.com/malloc/realloc.html), with examples of usage. Your attempt to grow it will actually shrink it.
Okay so you pass in 50 bytes to read statically there, and then set length to the bytes of the actual buf? so what the client actually sent? What does "buf[len] = '\0'; do? I know my issue is related to sending/receiving too much data so the program is waiting, however I honestly don't have a clue how to for example change my username prompt send/receive to properly send the prompt, and properly receive the username from the client.
That is how I used feof as well. We may or may not be doing the same program. Justifying text to a specific width and justification
Exactly what I am doing.
Your question is about C#, not&amp;nbsp;C. This is /r/C_Programming. C#&amp;nbsp;and&amp;nbsp;C are two very different languages. Go to /r/csharp.
 if (readstring(tmp)) /* error */; if ((w = readwidth()) == 0) /* error */; if ((j = readjustification()) == 0) /* error */; printformatted(tmp, w, j); /* viola */ 
#Never, ever, ever, under any circumstances, use `gets`! The `gets` function is inherently broken and literally impossible to use safely. It doesn't even exist in the latest C&amp;nbsp;standard; it's been removed because it's so broken. Do not use `gets` under any circumstances. If you are learning from a source that is teaching you to use `gets`, then stop learning from that source immediately and use something else.
The null character is `'\0'`, not `'/0'`.
It turns capital letters into lowercase letters. I'm not sure where I need to put it. I need it to be somewhere that when I type in "Hello" the program counts h as being entered once.
I figured I should put in before reading in the actual string but when I tried that it messed up the program. I also tried doing it directly after reading in the string and that also didn't work. To me that seems like the only logical place to put it.
Pay attention to the *types* involved in `tolower`. The `tolower` function converts a `char` from uppercase to lowercase. It does not convert an entire string from uppercase to lowercase. You need to understand how functions work in order to use `tolower` correctly. If you want to get the square root of a number stored in the variable&amp;nbsp;`x`, then the function call `sqrt(x)` will do that calculation, and the value of the expression `sqrt(x)` will be the square root of&amp;nbsp;`x`. (The `sqrt` function is in `&lt;math.h&gt;`, by the way.) You can then do something with that value: store it in a variable double y = sqrt(x); or print it printf("%f", sqrt(x)); or use it as part of a larger expression double z = 3.14 + 2 * sqrt(x); or whatever. But sqrt(x); as a statement by itself accomplishes nothing, because it just throws away the result. Note that `sqrt(x)` does not change the value of&amp;nbsp;`x`—it *returns* the value of the square root of&amp;nbsp;`x`, but the value stored in the variable&amp;nbsp;`x` stays the same. Likewise, if you want to convert a single character stored in the `char` variable&amp;nbsp;`ch` to lowercase, then the function call `tolower(ch)` will do that conversion, and the value of the expression `tolower(ch)` will be the lowercase version of the character stored in the variable&amp;nbsp;`ch`. You can then do something with that returned value. Again, tolower(ch); as a statement by itself accomplishes nothing, because it just throws away the result. And again, `tolower(ch)` does not change the value of&amp;nbsp;`ch`—it *returns* the lowercase version of the character stored in the variable&amp;nbsp;`ch`, but the value stored in&amp;nbsp;`ch` stays the same.
How about you put it inside the first while loop?
Yay I got it!! I put the statement string[i] = tolower(string[i]); inside the body of the while loop.
The ndigit[c-'0'] is giving you the element of ndigit that corresponds to the numerical value of the character c. So if I had c= '0' I would get element zero of my array, if c= '1' I would get the first element, etc. 
Yeah I need a function that prints the string to a variable width then once that line is full it goes to the next line
All characters have an internal value that may be different from computer to computer (though mostly every computer out there uses ASCII or something ASCII-based where the *"plain"* characters all have the same value everywhere). The C Standard mandates that the values of the characters `'0'` to `'9'` be consecutive (see [5.2.1 in C11 Standard](http://port70.net/~nsz/c/c11/n1570.html#5.2.1)). So from that it follows that if you subtract `'0'` (48 in ASCII) from any digit in char representation you get a value from 0 to 9 '0' - '0' // in ASCII: 48 - 48 = 0 '1' - '0' // in ASCII: 49 - 48 = 1 ... '9' - '0' // in ASCII: 57 - 48 = 9 The beauty of this is that it works for every character set (ASCII, [EBCDIC](https://en.wikipedia.org/wiki/EBCDIC), ...). '5' - '0' = 5 // in every character set // '5' in EBCDIC has value 245 This is most often used (as in the example posted) to convert digits in character form (`'4'`) to integer values in the range 0 to 9 (`'4' - '0' == 4`). ---- Edit: note that `'0'` is a value of type `int`
That's not a question, it's a statement. There are lots of people here who are willing to help you, but nobody wants to write your code for you. Show us what you have so far. If you don't know the code for it yet, start with pseudo-code. If you don't know the pseudo-code, describe in plain English the steps you need to perform to complete your task. Then try converting those steps to C code. If you have problems or questions about that, then post them here.
`fgets` is not `gets`.
Got the include guards in, but i still get an error( incompatible types when assigning to type 'complex' from type 'int') on all of my ans = add_complex(num1, num2); ans = multiply_complex(num1, num2); etc
char is basically an int with a much smaller range (between -128 and 127). Each ASCII character is assigned an integer value ([table here](http://www.italysoft.com/utility/converters/ascii-table.php)), and it's designed such that the distance between the value for '0' and the value for any other digit [1,...,9] is the value of that digit. So for example, the value of '8' is 56 and the value of '0' is 48: &gt; 56 - 48 = 8 So &gt;++ndigit[c - '0']; is equivalent to saying &gt;++ndigit[c - 48]; 
Glad you're having fun, but there'll be a multitude of little things to remember to get the best result from your program. Like taking the srand line out of the loop and ensuring it is run only one time before using the rand function.
Was this:for(i==1; i&lt;1001; i++) intended to be like this? for(i=1; i&lt;1001; i++)
Very nice! I did something similar a while back, not sure in which language. I'll see if I can dig it up.
Try not to use system("pause") It's: * Heavy weight (Suspends your program and calls into the OS [see here](http://www.gidnetwork.com/b-61.html) for details as to what system() does) * Not OS independent (Windows/DOS only) * Insecure (The system() call just executes a given program, someone could replace the program you rely on, since pause is an internal call I'm not 100% sure if that works here) As an alternative you can use. getchar()
You need to program that logic yourself.
Your indenting is wacky; the `printf("----------------------------------\n");` line actually executes every loop iteration, whereas the way you wrote it it looks at first glance as if it is part of the `else` block. (Which it isn't since there is no `{` after the `else`). 
I don't see it :( Where is it? I'm relatively new to this site.
`ans` (and `num1` and `num2`) is of type `int`. You cannot assign a value of type `complex` to a variable of type `int`.
Yep that's my mistake. I deleted the code where I read in the string when I hard tested it with two separate one word strings. My question is still the same though. I have no idea how to read in a bunch of words on a single stdin and then split them up. 
This seems a bit disorganized, so let's attack it bit by bit. If you have this on github or a pastebin, that will help a lot. For every variable that is not declared here, I'm going to assume they're declared earlier. &gt; scanf("%s", filename); You probably mean &amp;filename here. &gt; There is also a -1 at the very end which should tell the program to stop reading the file. Are you expecting something like this in the file? 1 1 2013 63.4 1 2 2013 66.1 1 3 2013 67.2 -1 If so, [fscanf](http://www.cplusplus.com/reference/cstdio/fscanf/) should cover you, and you won't need to detect EOF or even that value striclty. &gt; while(input != -1){ range[i] = month; range[i] = day; range[i] = year; range[i] = temp; fscanf(ifp, "%d", &amp;input); } This is where a bunch of stuff looks bad. This portion alone sort of makes me think you never tried to test the code and haven't looked around online all that much. Where was input initialized? Where are you reading month day and year from, and are they all the same type which you've implied by using range as you have? You probably want something along these lines while(fscanf(ifp,"%d %d %d %f", &amp;month, &amp;day, &amp;year, &amp;temp)==4){ // your code to crunch the numbers and printf the averages } fscanf will do the work for you here given that the data is formatted regularly as it is. We can expect it to return 4 since it is reading 4 values per line. When it hits a line with less (the -1 or end of file) we will get a non4 value. You could also nest an if checking fscanf like this in a while loop iterating on the condition !feof(ifp) note, you will need to declare those month day and year variables. If you really really want help, I again suggest putting every line of code you want looked at into pastebin or something, and explaining very clearly what you're trying to do.
I was surprised by the scorn for `strlcpy()` in the comments, there. I didn't realize this was such a touchy issue... it makes me feel guilty about the sprintf-backed macro I've been using to mimic it.
Do you have any code written? If not try putting at least something together then come back with specific questions. 
One difference that stands out to me is `strscpy` returning `ssize_t` where `strlcpy` returns `size_t`. Signed Asia has always been at war with Unsigned Asia...
Visual Studio only accepts a really old version of C. Don't use it for C programming, unless you're writing C that is also C++ and can be compiled as C++. If you're using Eclipse, you have to have a compiler installed separately. I think it works with MinGW and Cygwin. Do you have either of those installed? To give you any more help, you'll need to share your code and the specific errors you're getting. 
Oh, I confused value and address. I have added the % in front of the format specifier, and the name, address and hobbies works fine now. for "database[count].age,p.age;" , because age is not a string, so I can not use strcpy like other things. I try to simply print the value of age, but it does not work. Age in output is still 0.
Visual Studio is perfectly capable(\*) of compiling C. You need to do a better job of explaining. Tell us *exactly* what you did and *exactly* what happened. It doesn't do any good to leave it at "it didn't work." Can you compile a simple Hello, World program? Post the full and complete output, including all error messages. (*) Other than the fact that it doesn't fully support C99. But the latest version comes pretty close, supporting most everything but VLAs.
I will have to test it when I get eclipse to start working. Thank you though.
Thank you very much for your help :D. Everything looks fine after I change the format specifier for age.
 string letters = "acbdefghijk" int len = strlen(letters); for (count = 1; count &lt;= len; count = count +1){ putchar(c); } I would put a char array with the string in above the loop and loop through each position in the loop commands but the suggestion is specifically to do it with just putchar(c); in the loop. Thanks in advance for any help! 
I think what this problem is supposed to demonstrate is that you can put other initialisations, conditions, and statements in the for loop definition - other than the standard ones, that is. The *count = ~~1~~0;* part is the initialisation, the *count &lt;= len;* part is the condition, which leaves the increment part (*count = count +1*) as somewhere you can add a statement that does something each run of the loop as well as increment the counter. Perhaps an assignment for a char variable c?
 #define _CRT_SECURE_NO_WARNINGS #include "stdafx.h" #include "stdio.h" char(numdays); int main() { printf("\nEnter the number of days"); scanf_s("%c", &amp;numdays); if (numdays &lt;= 0); { printf("\nThat number is invalid"); } return 0; } This is what I have so far. Still need to find out how to not let the user continue if he has not entered a value &gt;0. I also don't know how to include any of the stuff mentioned above. Also, Visual studio can't compile this, it says: Severity Code Description Project File Line Error LNK1104 cannot open file 'c:\users\"user"\documents\visual studio 2015\Projects\Weather\Debug\Weather.exe' Weather c:\Users\"user"\documents\visual studio 2015\Projects\Weather\Weather\LINK 1 :(
There's also the [now standard, but optional] `strcpy_s` and `strncpy_s` in C11. So many competing implementations all trying to achieve the same thing.
No, iteration is fine. I've never done recursion in C so I don't want to mess with it at the moment. Reading your pseudo, wouldn't you get duplicates though? 
Yes you would. It's redundant. can fix this with your if statement as well by using an AND in the if statement such i &gt;j. Or, could just replacement with i&gt;j entirely. I'm too tired to quickly compile it. But, that should get you most of the way at least
Or, better yet, drop the if statement and just make the inner loop go to i - 1. Also, since we're in C, you want to be using 0 based indexing.
I prefer CMake which is also available on Windows.
Note that char can either signed or unsigned depending on the compiler, machine, and options. "char", " unsigned char", and "signed char" are all distinct types. http://stackoverflow.com/questions/2054939/is-char-signed-or-unsigned-by-default
for( int i = 0; i &lt; count - 1; i++ ) { for( int j = i + 1; j &lt; count; j++ ) { printf("(%d, %d) ", i, j); } }
C libraries can be used from virtually any language, so there's less of a language-specific community.
Except that the `_s` functions are basically unusable in libraries due to the global constraint fault handler you can't make any assumptions about.
It doesn't install C or C++ compilers by default. You have to do a custom install and make sure to select them.
You're making it way too complicated. It's as simple as this: char *c = some_string; while (*c) putchar(*c++); A C string is just a pointer to an array of chars that ends in '\0'. Just take a pointer to the start of it, and step through until you hit that nul byte that signals the end of the string. In this case, you don't really care about how long it is since you're just looking at a character at a time. You've also effectively halved the runtime, because it only walks the string once instead of twice (Once for strlen(), one for printing the characters).
Sounds like you want something like an array of function pointers. I'm on mobile so I can't easily look up some resources on it, but there should be tons of info on that topic (or fellow redditors can help out)
&gt; // warning: = is assignment, did you mean == instead? This already exists in most compilers. &gt; // warning: ignored function result So does this.
The relevant [warning flags for gcc](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html): &gt; // warning: unused variable z `-Wunused-parameter` &gt; // warning: identifier has no effect `-Wunused-value` &gt; // warning: &gt;= has no effect Not sure if gcc has an effective warning for that. A static code analysis tool should catch it though. &gt; // warning: + has no effect (dito for other operators) `-Wunused-value` &gt; // warning: = is assignment, did you mean == instead? `-Wparentheses` &gt; // warning: ignored function result `-Wunused-result` (On by default, but only works for functions explicitly marked with the `warn_unused_result` attribute) &gt; // warning: unused function foo `-Wunused-function` (Only works if the function is marked `static` or `inline`, otherwise the function might still be used from the outside by linking to this translation unit)
arrays (and strings which effectively are arrays) start indexing at `0` and go to `n - 1`. The canonical way to walk an array with a for loop is `for (count = 0; count &lt; n; count++) { /* access array[count] */ }`. In your snippet you are ignoring the element with `count == 0` and accessing the element with `count == len` which does not exist.
I've just noticed that you're writing your own compiler, I didn't realise that sorry. In my opinion uninitialised variables are one of the biggest sources of bugs, so definitely warn against them. I would strongly prefer that they be warned against at compile time because run time errors are much harder to debug, but I can imagine it would be a difficult thing to implement.
Forgotten semicolons perhaps?
code::blocks is really good and you can use it to compile c99 Also it is open source. http://www.codeblocks.org/downloads
Sorry but i have no good example. I just thought about mistakes that beginners often make.
I think what would be a good idea is marking the correct line where the semicolon is forgotten. For example, with gcc: printf("%d", x) return 0; This code leads to the error: test.c:6:9: error: expected ‘;’ before ‘return’ return 0; ^ It would be better if the error showed the printf line as the missing semicolon, I remember finding this confusing when I first started learning C.
You need to put parentheses around `c = getchar()`. Without parentheses there, your code is interpreted as if you wrote `while (c = (getchar() != '\n'))` which sets `c` to 0 unless a line ends.
Thank you
Here's a few beginner's mistakes that I see on StackOverflow time after time: * Casting the return value of `malloc` * Allocating enough space only for a pointer type, e.g.: typedef struct node *node; struct node { node left; node right; }; // later node mynode = malloc(sizeof(node)); * Using `sizeof` on a pointer returned by e.g. `malloc` and expecting it to result in the size of the allocated memory * Not including the appropriate headers for various functions and relying on backwards-compatible compilers to accept undeclared functions. * Using `gets()` and other potentially unsafe string functions * In addition to the above, using an unbounded scanf call, e.g. `scanf("%s")` * Initialising a `char *` to point to a string literal and then subsequently trying to modify the string (C++11 fixed this but AFAIK all flavours of C still allow it) * Not checking the result of `scanf()` and then subsequently assuming a value was set * The typical `feof()` loop problem - e.g. beginners are often unaware that `feof()` doesn't return true until *after* an attempt read past the end of the file, and their `while(!feof(f))` loop appears to e.g. iterate the last line of a file twice. * Using an if statement that is always true because of using the wrong logical operator, e.g.: if (ch != 'A' || ch != 'B') { // "not 'A' or 'B'" } * Similarly, using an if statement mixing signed and unsigned types that result in an always-true or always-false condition: if (strlen(str) - 4 &lt; 0) * Off by one errors in loops, e.g.: char buf[10]; for (int i = 1; i &lt;= 10; i++) buf[i] = ... or char buf[10]; for (int i = 0; i &lt;= 10; i++) buf[i] = ... * Returning address of function-local storage: char *createstr() { char buf[100]; ... return buf; } * Declaring function names or types that are reserved, .e.g using identifiers that begin with an underscore followed by another underscore or uppercase letter. Not a huge deal but I see it a lot. * Double terminating a string, e.g. `"Hello, World!\0"`. Sometimes this is intentional, but for beginners probably not. * Attempting to do pointer arithmetic with `void *`. Some compilers already have warnings in place for many of these but it somehow doesn't prevent beginners from posting questions on StackOverflow asking why their program isn't working.
In older compilers it can mask a serious issue. If you don't include `stdlib.h`, the compiler may assume `malloc` returns `int` rather than `void *`. Explicitly casting from `int` to another pointer type masks this issue and will cause problems if `sizeof(int) != sizeof(void *)`. Without the cast, the compiler will warn about a conversion from an integer type to a pointer type.
Yes, it's just a lot of image processing code which doesn't use anything beyond the most basic set of C99 features. But it is growing rapidly so I'd like to be aware of the issues. I'll start digging now.
It would also be nice to detect errors like: if( condition ) do_something(); do_something_else(); 
Some of my most time-consuming and seemingly confusing bugs have ended up being simple things like this. Off by one errors, or something to do with parenthesis. C is a simple language, but it can be really sneaky and complex in some ways like this.
Here's your problem: printf("\n you now require %d", &amp;current); ^--- Here You use the &amp; with `scanf`, not `printf`. Since you got it right in other places, I think you already know that, but it's a very easy mistake to make and not see. If you can enable warnings in your compiler, it will tell you about this sort of mistake.
How are you compiling?
I compiled the menu.h header and menu.c files seperately as object files then ran a basic gcc personal.c -o personal where personal.c is the name of my file with the main function Now that you bring it up, something tells me I need to explicitly state that I want to compile all three together? I figured the include tags would solve that for me, but I'm doing everything via terminal and gedit on a linux system
The correct way to compile it would be: gcc -c menu.c -o menu.o gcc -c personal.c -o personal.o gcc menu.o personal.o -o personal You don't compile .h files. What is happening here is that you compile each .c file into an object file then link all the object files into a single executable. As you add more files (even with 2 files in my opinion) it will be more efficient to create a makefile.
&gt; Now that you bring it up, something tells me I need to explicitly state that I want to compile all three together? I figured the include tags would solve that for me, but I'm doing everything via terminal and gedit on a linux system That's exactly it. You have to do this yourself. Right now you have three files: `menu.h`, `menu.c`, and `personal.c`. The `#include "menu.h"` only takes care of one of those, the rest has to be done explicitly with the compiler. The easy solution is to just specify both lines to the compiler: gcc personal.c menu.c -o personal But this is also a good time to talk about separate compilation. You can compile each file separately and then link them together: gcc -c personal.c -o personal.o gcc -c menu.c -o menu.o gcc personal.o menu.o -o menu Why would you do this? Well, if you have a LOT of files, you don't always need to recompile everything always, you only want to recompile things that changed. That's also where build tools like `make` come into play. You could make a simple Makefile like: CPPFLAGS += -MMD -MP personal: personal.o menu.o -include personal.d menu.d Then you can just use `make` to compile, and everything works automagically.
I never got this argument. Do these older compilers not warn about undeclared functions?
So, if you're using a good compiler, that shouldn't be an issue? Just to be clear, I too am against casting the return value of `malloc`, but I'm wondering if the whole "implicit `int` return" argument is overblown.
The argument is overblown a lot of the time. It's really not a huge deal, especially with today's compilers. Most modern compilers will warn about undeclared functions even in C89 mode simply because these days there is little point relying on the implicit `int` behaviour. Some compilers even issue warnings telling you the right header to include for standard C library functions. From my experience, most newbies posting code on StackOverflow are casting the return value of `malloc` because they are unknowingly using a C++ compiler (which doesn't permit implicit conversion from `void *` to other pointer types), or are just under the impression that some magic happens behind the cast in order to make the memory usable as intended. Casts can mask some really ugly bugs sometimes, so liberally casting things is a particularly bad habit to get into. Casts should almost be a last resort, not a "go to", if you catch my drift.
Put four blanks in front of every line of code, then the formatting (including the hashes) comes out nicely.
Arrays start indexing at `0` and go to `n - 1`. I didn't study your code very attentively, but I noticed 2 big "smells" The loop `for (i = 0; i &lt;= indexcount; i++)` is probably going once more than required. The several `+1` in your code look wrong. Maybe you want to loop 2 less than the whole thing with `for (i = 0; i &lt; n - 1; i++)` (or start the loop at `1` : `for (i = 1; i &lt; n; i++)` And, the casts for the return value of `malloc()` are not needed and may hide an error the compiler would catch in the absence of said casts (if you're compiling C++ maybe you could use a different approach to memory management).
instead of variable = (variable_type)malloc(size * sizeof(*variable)); write just variable = malloc(size * sizeof(*variable)); In your concrete example, leave out the `(char **)`. 
Ah, I see. Thanks!
Thank you for making your code more readable! Let's see if we can resolve your issue.
that got rid of the second error, the first is still there though :/
thanks, that seems to have fixed it! but now i've run into another error that I didn't notice before if(input &gt; Node-&gt;dict.Element) that line results in "error: expected expression before 'Node'"
input is just a string that is passed through the function and Node is the tree struct (as stated in the original post)
Can you show me how `input` and `Node` are declared? Can you show me some context? If you can, please post your code. It's really hard to help you if I don't know the thing you are having problems with. 
No one singled you out to solve the problem. Chill.
The person who responded to you is not OP, and I assume that at issue was: &gt; *it's not my job* to replicate the content of tutorials in here [emphasis added] Not the part about reading a tutorial.
We're allowed to ask questions but we're not meant to post our code online (due to the plagiarism check). If it would help I could PM you the code. EDIT: Nevermind, I figured out how to fix the code, thanks for your help!
I put it into text now: -#include&lt;stdio.h&gt; -#include&lt;math.h&gt; double bogenmass(int n); main(){ int n=0; printf("Was ist der Winkel in Grad?"); scanf("%d",&amp;n); printf("Der Winkel in Grad ist %d\n", n); printf("Der Winkel in Bogenmass ist: %f\n", bogenmass(n)); } double bogenmass(int n){ return ((n%360)/180.0)*M_PI; }
Here is my code: -#include&lt;stdio.h&gt; -#include&lt;math.h&gt; double bogenmass(int n); main(){ int n=0; printf("Was ist der Winkel in Grad?"); scanf("%d",&amp;n); printf("Der Winkel in Grad ist %d\n", n); printf("Der Winkel in Bogenmass ist: %f\n", bogenmass(n)); } double bogenmass(int n){ return ((n%360)/180.0)*M_PI; } The output of bogenmass is sometimes pi(3.1415...) and sometimes 0.0000, the output of the first printf however always seems to be 0 for me.
Think about what happens when i is 0. What happens if the iD doesn't match? What do you want to happen?
When scanf is reading in data, it goes through the format string ("%s\n") one character at a time and, if it is a '%' it checks the rest of the format specifier (in this case the 's') and reads in the appropriate data. If it encounters a whitespace character (like ' ' or '\\n') it reads any amount of whitespace up to, but not including, the next non whitespace character. If it encounters anything else, it reads that character from input or fails if that character isn't next. In the case of "%s\\n", it reads in a sting of non whitespace characters ("%s"), puts that in the appropriate variable, then skips any amount of following whitespace. If you want it to read to the end of line, and skip the following whitespace you should use "%[\^\\n]\\n".
If the ID doesnt match I want the function to return a -1 so that I can print out an error message. If it does match I want it to return the number in the second culumn so I can use another function with switch statements to calculate some things based on the value in the i column
Not really. If the iD of student 0 doesn't match you want it to check 1. The else should be removed and return -1 moved to outside the loop
Handling implementation-defined types in a portable way is certainly important, and this information is good to have on hand. That said, it seems like a *major* oversight for those defining C library extensions to specify new types without also specifying corresponding size, limit, and format specifier macros the way the standard types do.
it compiles fine, just when i test it by entering an id from the array even if it is correct it will return a -1. It's not a syntax error but a logic error that I can't pinpoint
That's because the order of indices is wrong. Your `stuInfo` should have type `int[2][6]`, not `int[6][2]` as it's an array of 6 arrays of 2 `int`s. Please always compile with warnings turned on, the compiler would have warned you about this.
I'm not sure I understand your question. When `i` is&amp;nbsp;4 and `j`&amp;nbsp;is&amp;nbsp;1, then `j &lt;= i` is true. When `i` is&amp;nbsp;4 and `j`&amp;nbsp;is&amp;nbsp;5, then `j &lt;= i` is false. When `i` is&amp;nbsp;1 and `j`&amp;nbsp;is&amp;nbsp;1, then `j &lt;= i` is true. When `i` is&amp;nbsp;1 and `j`&amp;nbsp;is&amp;nbsp;2, then `j &lt;= i` is false.
The first loop will be 4,3,2,1. That sequence will control each set of iterations for the second loop, as it sets the condition for each loop. The second loop will be 1,2,3,4, then 1,2,3, then 1,2, then 1. 
So do you actually know what &lt;= means? It means that if x&lt;=y, that x must be smaller or equal to y. So this is true if x is 2 and y is 2, but also if x is 1 and y is 2. If x equals 3 and y equals 2, then it is false. So if we look at your loops, we start with an i of 4, then we have a j of 1, which increases with 1 every iteration. The second loop (containing j=1) stops if j is smaller or equal to i. So, first it will be able to print 3 asterisks, since j is 1 (1&lt;=4), then j is 2 (2&lt;=4), then j is 3 (3&lt;=4), and then j is 4 (4&lt;=4). When j becomes 5, the statement in the second for loop becomes false, since 5 is not smaller OR equal to 4, but it is bigger. Therefore we now go to the first for loop, where we print an enter, and decrease i with 1. Now we go into the j loop again and do the same, but now i equals 3 and not 4, therefore we get 2 asterisks. Then it happens for i equals 2 and i equals 1, after which it stops.
 if(temp[31] &gt;= min_range) if(temp[31] &lt;= max_range) num_temps = num_temps +1; else(num_temps == num_temps + 0); else(num_temps == num_temps + 0); This right here is getting interpreted as if(temp[31] &gt;= min_range) { if(temp[31] &lt;= max_range) { num_temps = num_temps +1; } else { num_temps == num_temps + 0; } } else { num_temps == num_temps + 0; } I'd recommend always using the curly braces, even with one line if statements. It can avoid a whole lot of confusion. Also, that's not how you use else statements. Look above to see how they're used. EDIT: And you're using `==` to assign stuff in the else statements. Make them into `=`.
Try this: WORD = hello hello: - @echo $(WORD) goodbye: WORD := goodbye goodbye: hello output: &gt; $ make hello &gt; $ make goodbye goodbye 
I don't really understand the procedure you want to implement. Could you elaborate a little bit?
-Werror is a nice addition too (with -ansi -pedantic maybe). [No executable for you](http://www.thecommonsenseshow.com/siteupload/2013/08/NO-SOUP-FOR-YOU.png) on an error! :) 
Why is it `X XX X` and not `X XXX`? I mean, the latter would not have a repetition. What is the exact algorithm to choose how many characters to take into the next word?
Because you're greedily terminating and saving the substring as soon you find one that hasn't been saved yet
Hey, that's what OP is supposed to find out on his own.
Okay then, do you have an idea for an algorithm to do this? You can use pseudocode and it's not a problem if there are steps you don't know how to program, just describe them.
/u/yoyEnDia is correct. I'm greedily terminating (I didn't know that was a term). I'm having trouble figuring out how to check to see if the string is in the array already. I can do it in python with if string in array. but not sure how to do it in C.
You need to implement that algorithm in C yourself. You can use the `strcmp` and `strncmp` functions to compare two strings. Compare all previous strings with what you currently have for a rather inefficient O(n²) algorithm. There are more efficient ways to do that (you can use tries for O(n)), but they are more complex to implement.
my idea was find to start an iterator which goes to the length of the string. and search through the characters of the string then add when there's a string that isn't in there. for the strings longer than 1 char I would create a temporary string with a new iterator which resets once the string stops existing in the array. All that I can do that. What I can't seem to figure out is how to search the array to see if the string has already been added. 
&gt; to start an iterator What do you mean with “iterator” in this context? Try to express your algorithm with what you want to do, not what tool you want to use to do that. &gt; What I can't seem to figure out is how to search the array to see if the string has already been added. Iterate through the array, compare your current string with each string in one of the arrays using `strcmp` or `strncmp`, whatever is more appropriate.
That solution is going to work, but it's going to be a little slow as that's going to be an O(n²) algorithm. You can solve this in O(n) but the algorithm is slightly more complicated.
Huh? I'm just restating the problem statement, I'm pretty sure he had that much down
But he wasn't able to explain that to me. If OP is not able to explain his problem to me precisely, how is he supposed to be able to explain his problem to the computer?
Have you considered using strncpy()?
I use it on code that I create, but not on code that I modify.
It's a command line program. Run it from a shell. EOF can be signalled interactively, but how depends on your OS. Ctrl-d or -z are common.
So just add it manually.
Just saw your reply after editing my post. I'll be running it in a shell from now on thanks!
Why do you make another post about [your previous problem](https://www.reddit.com/r/C_Programming/comments/3p7klw/separating_a_string_into_an_array_of_the_unique/)? It's also unlikely that someone is going to help you further without you posting the code. If you are not allowed to post the code, then ask your instructor for help.
Someone asked a question about the same problem [two days ago](https://www.reddit.com/r/C_Programming/comments/3ovcy9/reading_numbers_from_a_file_into_an_array/). Perhaps you can find something about your problem in there?
alright I'll edit this post with that info
Crtl-Z on Windows, Ctrl-D literally anywhere else.
&gt; I'm going to have to do a lot of copy-and-paste work to make pointless duplicates of a whole bunch of make rules You should really use autotools instead of make directly.
Please do not post data or code as pictures, this is useless for anybody else.
I'm going to pass on some 'wisdom' rather than answering your question directly. 80% of software development is formulating really tight questions. Once you've got a well constrained question to ask either yourself or someone else, you've understood most of the problem at hand and will likely be able to answer your question yourself without too much trouble. If you still can't, the person you ask probably can. In this case you seem to have put some boilerplate code in place and then thrown your hands in the air. Make your best effort at asking a solid and specific question and you'll probably make more progress and be more likely to get assistance here.
The problem does not necessarily require an array. This is an algorithmic problem, a somewhat non-trivial one. You haven't described the algorithm you are proposing very well, I think "reads the string from right to left and greedily terminates when it reaches a combination not already in the array", is missing some details. What exactly is the problem you're having? Is it crashing or it just isn't arriving at the answer you expect? I would suggest that you think of an easy test example. Like "ABC" and see exactly how your algorithm would calculate things step by step.
What's wrong with changing the original string? I actually was going to suggest that. You waste one bite but you save a memory allocation and a bunch of read/writes... Seems like a great tradeoff to me. 
Looks good to me! &gt; If this is an acceptable way of implementing the adjacency list Of course! However, I would say that the best way depends on how dense your graph is and how you will be walking the graph. I noticed you hard-coded the adjacencyList to length 6, a linked list would give you more flexibility and might not have any drawbacks. You should also probably consider reading about heap vs stack memory, and what the benefits of each would be. You've used the stack here for your adjacencyList. &gt; If I'm actually using pointers efficiently. I think you're using them okay, but you can simplify some things. a-&gt;adjacencyList[0]-&gt;id = 4 could just be: b-&gt;id = 4 Which is easier to read and more efficient(one less read from memory). Same for the printf. It's a bit unclear to me what you mean by 'efficiently'. 
Don't get stuck just trying to code. If you write a line of code and it 'works' but you don't understand it, you'll find that you become frustrated. Find the lines in your code that you don't understand and do an hour of reading until you understand it. Don't get caught up thinking that you need to sit down and immediately start writing code. Do you have a specific question about arrays? They are just a continuous block of memory. You get a pointer to the front of the memory and then you can increment that pointer to read/write other parts of the array. It's as simple as that! edit: one other thing, not sure if the pastebin has the right code, but it looks like maybe you are trying to write the whole program in one go. You should always do one simple change and then run your code. Start from "hello world" and just add one or two lines at a time, then run. Repeat that process over and over until you have a working solution.
Hi, thanks for the reply! &gt; a-&gt;adjacencyList[0]-&gt;id = 4; I used the line to check that I was actually modifying b. Also, I thought about using a linked list but I couldn't implement one given that there might be an edge a-&gt;b &amp; edge a-&gt;c but there wouldn't be a path a-&gt;b-&gt;c and wasn't sure how that'd work. 
I still don't understand what you want to do. Please explain it clearly and in detail. Don't assume that I understand what "it" is or what it means for "it" to "work."
What is the definition of the type `node`? Do you have all warnings turned on in your compiler? Are you paying attention to what the warnings say?
Sorry I just edited that in to the original post! I get a warning about this line (the line where I call the function): head = replaceChar(head, key, *str); Where head is the node, key is the char we want to replace, and str is the string we are replacing the char with. The warning says: "warning: passing argument 3 of 'replaceChar' makes pointer from integer without a cast [enabled by default]" and also a warning on this line: "head-&gt;data = str;" inside the if loop in my function. This warning says: "warning: assignment makes integer from pointer without a cast [enabled by default]" I actually didn't really notice these but I am still at a loss Also thanks a bunch for helping me out I've been stumped for a while on this.
I have no idea what you are asking. &gt; Number of Bits in a single Char This is the value of the `CHAR_BIT` macro in `&lt;limits.h&gt;`. &gt; based on the following declaration of a character called C. I can assume that C is the value of 4 bytes No. By definition, the size of a `char` in&amp;nbsp;C is one byte. &gt; what happens if I use the unary operator &amp; to do &amp;C. The value of the expression `&amp;C` is the address of the variable&amp;nbsp;`C`. &gt; What is the value of bytes now? The `&amp;`&amp;nbsp;operator does not perform a write, so it doesn't change the value of anything.
 char* scanInput(){ int done = 0; int iterator = 0; char x; char* start; do{ x = getchar(); if(x == '\n' || x == '\0') { if(iterator == 0) { start = (char*)malloc(sizeof(char)); *start = '\0'; done = 1; } else { start = (char*)realloc(start, sizeof(char)*(iterator+1)); *(start+sizeof(char)*iterator) = '\0'; done = 1; } } else { if(iterator == 0){ start = (char*)malloc(sizeof(char)); *start = x; } else{ start = (char*)realloc(start, sizeof(char)*(iterator+1)); *(start+sizeof(char)*iterator) = x; } ++iterator; } }while(!done); return start; } Sorry if the code formatting looks awkward on Reddit. Either way, I felt like scanf() was not doing what I wanted it to do, so I wrote a function to get input from user and return char* back to me. Do not have any issues freeing any other strings that I have created with this function. 
SIGTRAP is usually only raised to signal the debugger. Do you get it when running the program on its own? What about through valgrind? 
Are you sure you receive a `SIGTRAP`? That's unusual and should not happen.
Okay I think I am starting to understand it, thanks for being patient with me. I've fixed the warnings that they gave me and I now have 0 warnings. I don't expect you to do my homework but could you point me in the right direction for inserting new nodes where I want to replace them? I can't quite grasp how I would start doing that. In my mind I would free the node that holds the character that I want to replace. Then maybe make a new function that will read the string and turn it into a list and return the head of that list, and then set the head of the string's list into the open element. Sorry if I'm explaining that badly. Edit: I believe I'll also have to push the rest of the nodes backwards to create space but I'm not quite sure how to do that either.
Comments about this code: * You are assigning the return value of `getchar()` to the variable&amp;nbsp;`x`, which has type `char`. That is the wrong type. The return value of `getchar()` is `int`, not `char`, because one of the possible return values is `EOF`, which is a value distinct from all `char` values. You need to assign the return value of `getchar()` to a variable of type `int` so that you can test whether it is `EOF`. * By definition, `sizeof(char)` is always&amp;nbsp;1. * You are not testing the return values of your `malloc` or `realloc` calls to see if they succeeded. If those calls fail, they will return a null pointer. You should test for this. If you don't test for this, and then you attempt to dereference that null pointer, your program has undefined behavior, which means that you have absolutely no guarantees about the behavior of any part of your code. * The expression `*(start+sizeof(char)*iterator)` is a really awkward way to say `start[iterator]`. * You don't need separate code for the case when `iterator` is&amp;nbsp;0. Just initialize `start` to a null pointer at the beginning, and then do this: start = realloc(start, iterator + 1); start[iterator] = x; ++iterator; This works whether or not `iterator` is&amp;nbsp;0. * This is not a particularly efficient way to allocate memory for a string. A string of 80&amp;nbsp;characters should not require 80&amp;nbsp;calls to memory allocation functions. * I don't see anything in this code that should cause your `free` call to fail. The likely cause is that somewhere else in your program you have a wild pointer or are writing beyond the bounds of an array or something and so you're scribbling on the memory that `malloc` and `free` use for their bookkeeping.
You may need to press Enter after entering things before they get displayed; standard input and output may be buffered.
Thank you for the input. I have acutally "solved" (read: managed to avoid) the problem. I had to create a function that would accept input from scanInput() and using good old atoi() convert it to an int, then return the result. I assume that there must have been something else going on between my allocation and free-ing that somehow affected free().
&gt; (the size of a 'char' is 1 byte or 8 bits) The size of a `char` is 1&amp;nbsp;byte, but not necessarily 8&amp;nbsp;bits. That is the reason for the `CHAR_BIT` macro in `&lt;limits.h&gt;`. &gt; Depending on your platform, (64 bit or 32 bit), the pointer will be either 32-bit (4 bytes) or 64-bit (8 bytes). Or it could be some other size.
This is sort of OK, but you waste space if there are fewer than 6 adjacents, and you couldn't handle a situation with more than 6. It'd be more general to store the adjacency list separately to the vertices. BTW, writing `(vertex*)` before malloc is a mistake, it has been hanging around because people copy-paste it without understanding what they are doing. You could simplify your code by taking it out.
As well as the other problems - your program writes past the end of the array. In the line: for(int i=0; i &lt;= MAX_SIZE; i++){ It should be `&lt;` instead of `&lt;=`. The array indices range from `0` to `size - 1`.
C and C++ are different languages. I might ask you "I'm a C++ programmer thinking of learning Python - should I do that or skip it and go straight for Ruby?" C has a smaller amount of syntax and a smaller standard library, so it is easier to "learn everything". On the other hand, *because* it has a smaller standard library, when you actually code a real project you end up spending more time implementing things that were in the C++ standard library (for example, a resizeable array). For me, C++ is more productive, however there aren't any good internet learning resources that I know of. To save time your best bet will be to buy a book.
Your scanInput function looks like it should work but it is excessively complicated. Compare this: char *scanInput(void) { char *start = NULL; for (size_t iterator = 0; ; ++iterator) { int x = getchar(); start = realloc(start, iterator + 1); if ( x == '\n' || x == 0 || x == EOF ) { start[iterator] = 0; return start; } start[iterator] = x; } } You should really check for `realloc` failure and take some action even if it is only `exit`ing.
&gt; the size of each structure element will also be determined during run-time as well. No, you are mistaken. The sizes of all types are determinable at compile time. This is a fundamentally important fact in&amp;nbsp;C. (This is a tiny lie in the context of C99, in which the sizes of variable-length arrays are not determinable at compile time. But you are thankfully not using variable-length arrays.) If you want an array whose elements have type `struct test`, then your `malloc` call should be `malloc(num_of_structures * sizeof(struct test))`. Or, equivalently (but better so as to avoid coding errors), array_of_structures = malloc(num_of_structures * sizeof(array_of_structures[0]));
Thanks for the reply. &gt; No, you are mistaken. The sizes of all types are determinable at compile time. (This is a tiny lie in the context of C99, in which the sizes of variable-length arrays are not determinable at compile time. But you are thankfully not using variable-length arrays.) This is interesting. I didn't know this. &gt; array_of_structures = malloc(num_of_structures * sizeof(array_of_structures[0])); Why is this considered better? Is it less prone to error?
If you know python, you can probably pick up C quickly. It's simple language, which is why it's so powerful. You should get a book on it, see the sidebar. The standard C libraries are not expansive. Since you know Python, you can leverage it by using the pseudo-code programming principle. Write in Python. Comment it out as you write in C. Leave the Python as comments.
&gt; This is interesting. I didn't know this. This fact is obvious if you have a correct understanding of types in&amp;nbsp;C. If it was not obvious to you (and especially if you thought it was false), then you need to improve your understanding of types. There is no type in&amp;nbsp;C whose size cannot be determined at compile time. The sizes of fundamental types (`int`, `char`, `double`, etc.) are fixed. Array types always have an associated size: there is a type array-of-5-`int` and another type array-of-10-`int`, but there is no type array-of-`int`. The sizes of pointer types are determinable at compile time, because it's the size of the pointer, not the size of the object the pointer points to. The sizes of structure types are determinable at compile time because the compiler knows the sizes of all the members inside the structure. &gt; Why is this considered better? Is it less prone to error? Consider this code: int *array; /* a bunch of code */ array = malloc(num_elements * sizeof(int)); /* do stuff with array */ You test and debug this code and get it working. But now you realize that the elements of this array really should be `double`s, not `int`s. So you change the declaration: double *array; /* a bunch of code */ array = malloc(num_elements * sizeof(int)); /* do stuff with array */ See the error? You haven't allocated the correct amount of space. This may mean that when you attempt to write to elements of the array you end up writing beyond the bounds of the allocated space, thereby corrupting other things in memory and leading to bugs that are *extremely* frustrating to fix because things appear to be breaking in code that isn't even supposed to be touching those things. I have made this mistake several times, and every time the resulting bug is unbelievably infuriating to try to diagnose and fix. But the whole thing could have been avoided if the original code were written like this: int *array; /* a bunch of code */ array = malloc(num_elements * sizeof(array[0])); /* do stuff with array */
Very clear. Thanks for your time.
More to the point, C is *tiny* compared to C++ and I'd definitely suggest starting with C even if the end goal is using C++. C is a really important language to understand imho
&gt; There is no type in C whose size cannot be determined at compile time. Other than variably modified types (which you mentioned in a previous post, but not this one). Given that variably modified types exist; pedagogically I'd prefer to not try to draw a distinction between compile-time and run-time in terms of the size of types. What is certainly true is that the *size of a `struct`* is known at compile-time, as is the size of any member of a struct (other than a flexible array member, which is an incomplete type, not a variably modified type). It is only the dimension of an array which may be determined at runtime. OP's quote that spawned all this was "the size of each structure element" so his confusion could be cleared up without needing a special case for variably-modified types. 
&gt; Given that variably modified types exist; pedagogically I'd prefer to not try to draw a distinction between compile-time and run-time in terms of the size of types. There are several reasons that I think it is useful to keep in mind that `sizeof` is evaluated at compile time (again, except for variable-length arrays). If you keep this in mind, important facts such as these become clearer: * When `sizeof` is applied to a pointer, the value is the size of the pointer itself, not the object the pointer points to. * `sizeof` does not give the length of a string. * The size of all objects of a given type, even structure types, is the same fixed value, regardless of the contents of the object, which is how arrays are able to work as they do. So my pedagogical approach is different—I'd prefer to pretend that variable-length arrays don't exist. :-)
&gt; one "char" is almost always one byte, but NOT always. No, always, by definition. That is the definition of "byte" in&amp;nbsp;C. The value of `sizeof(char)` is always&amp;nbsp;1, by definition. Now, you are right that the size of a `char` might not be 8&amp;nbsp;bits, but the size of a `char` is always 1&amp;nbsp;byte, no matter how many bits it is.
I'm not sure if this will work for you, but: % : - @echo $@ hello: narf: goodbye: hello frederick: narf Output: $ make frederick narf frederick $ 
Why are you using `*(array+d)` instead of `array[d]`?
using c89 and arrays decay to pointers when they're used in call by reference. So you have to do pointer arithmetic in that case. At least to my knowledge. 
&gt; void swap(int* val1, int* val2) val1 is an address. val2 is an address. *val1 is a number of size int. *val2 is a number of size int. You want to change the contents of the addresses. So what do you do? Create an int to store the number that is at address val1 and can be accessed by *val1. Make val1 store the number that's being stored on val2. Make val2 store the number that's being stored on the temporary variable. void swap(int* val1, int* val2) { /* Make t receive the number stored on adress val1 */ int t = *val1; /* Make val1 store the number stored on val2 */ *val1 = *val2; /* Make val2 store the number stored on t */ *val2 = t; } Got it?
I'm so tired I cant even post my coding right. &gt;.&gt;
&gt; it only reads the first number from the input file Of course it does! You told the program to only read the first number, so that's what it's doing. If you want to read all numbers, you have to put the scanf inside a loop. With the way you're using the `number` array, I'm pretty sure it's only got 5 elements in it. Therefore `for(i=0;i&lt;=5;i++)` is initializing an element out of the range of the array, since a 5 element array only goes from 0 to 4. You should also use the printf statements in a loop. What if you had 100000 candidates? Would you copy and paste each printf and edit the numbers? And embracing the if statements in curly braces isn't doing anything. I think you accidentally deleted the for loop that they were supposed to be a part of.
Generally speaking, probably not. C as a language doesn't define any standard for floating point and instead uses the underlying OS/Hardware floating point implementation, which is in most cases (at the present time) [IEEE-754 Floating Point](https://en.wikipedia.org/wiki/IEEE_floating_point). The minimum value of a single-precision (32-bit) IEEE-754 float is 1×10^(−101). A double precision float bottoms out somewhere around 2x10^(−308). If you do manage to go beneath these, post 1984, the standard is to signal underflow and switch to less precise [subnormal numbers](https://en.wikipedia.org/wiki/Denormal_number) so as to not drop to zero. Older implementations did just drop to zero at this point. For a reference, the mass of an electron is 9.10938291×10^(−31) kg. 2x10^(-308) is an exceptionally tiny number. See also: [Arithmetic Underflow](https://en.wikipedia.org/wiki/Arithmetic_underflow)
Very interesting. Thanks.
Yup but it isn't really nonsensical. When you divide a small number by a large number you get a really small number. At some point you run out of precision and it's just zero. Little bit-o-code to try out, #include &lt;stdio.h&gt; #include &lt;float.h&gt; #include &lt;math.h&gt; int main(void) { printf("DBL_MIN = %e\n", DBL_MIN); printf("DBL_MAX = %e\n", DBL_MAX); double a = 0x1.fp-536; double b = 0xF.fp536; double c = a/b; printf("a = %g\n", a); printf("b = %g\n", b); printf("a / b = %g\n", c ); return 0; } 
I'll be sure to do that, thanks for pointing out the _t suffix is reserved as well. 
rand( ) is a part of &lt;stdlib.h&gt; Producer is lacking a } Two things. I'm not sure if you're broadcasting the condition the consumers are waiting for. You are not (in main()) waiting for the consumers to finish, and main will exit before the consumers finish, terminating the program. pthread_join(cons0, 0); pthread_join(cons1, 0); pthread_join(cons2, 0); Adding those let the program finish on my machine. What tipped me of was never seeing the "exiting consumer" message appear
Thanks, that solved that issue. Now I just need to find a way to change the value that inputs points to, and a way to look at that to make sure it's changed. Doing something like *inputs = reset or inputs = &amp;reset; would change the value that inputs points to, right ? essentially writing the value of reset into the inputs register? And then to copy that to a temp value, I would do something like temp = *inputs ? 
&gt; *inputs = reset This will change the content of the memory that `inputs` points to (which is what you want). &gt; inputs = &amp;reset This will change the `inputs` pointer to point to the memory where the `reset` value resides. &gt; temp = *inputs Yes, this will read the content of the memory that `inputs` points to and save it into `temp`. Just as a quick recap. You can *dereference* pointers by prepending the asterisk. Dereferencing tells the compiler that you want to do something with the content of the memory the pointer points to. That can either be reading the content: a = *p; Or modifying it: *p = a; The opposite of dereferencing is *referencing*, which is what the ampersand is for. Referencing asks the compiler to give you the memory address of the referenced expression: p = &amp;a; Referencing and dereferencing cancel each other out: p = &amp;(*(&amp;a)); I hope that clears pointers up a bit.
&gt; Two things. I'm not sure if you're broadcasting the condition the consumers are waiting for. Where do you think this problem resides? Code looks like it's working as intended now, from what I'm seeing. Ahhh yes, not waiting for the consumers was definitely messing things up. Code looks like it's working as intended with the pthread_join's added for the consumers, but I need to walk through it with GDB or something similar to confirm. I removed the code, if you need to see it again just PM me 
Interesting. I can imagine a scenario where a pointer might be of other size than 32/64 bit, although I have yet to encounter one. I am curious about the case where a char is not 1 byte, when - if ever - is this the case and why? Edit: What do you mean by "The size of a char is 1 byte, but not necessarily 8 bits." ? As far as I know 1 byte is *defined* to be exactly 8 bits. I have never heard of any other definition of a byte.
How do you know? Did you confirm that with a debugger?
I have the code stored so no worries. Pop waits for **cond_nonempty**, and push waits for **cond_nonfull**. consumer broadcasts **cond_nonfull**, but producer did not broadcast **cond_nonempty** if I'm not mistaken (i changed it localy). I could be misremembering though
Here s my producer code: void * producer(void * ptr) { int data; while (has_more_to_produce()) { data = produce_one(); printf("producer %d : %d\n", (int)ptr, data); push(&amp;pool, data); pthread_cond_broadcast(&amp;cond_nonempty); usleep(500 + (rand() % 500)); // slow down } printf("exiting producer\n"); pthread_exit(0); } looks like my producer is broadcasting cond_nonempty to me unless I dont understand my code like I think i do
An array of characters *is* an array of integers of the ASCII values. If you have the string char something[] = "ace"; then the value of something[0] is 97, the ascii value of 'a' So just walk through the string seeing if each character is bigger than the previous one.
Turns out the GPIO port was write only, and reading it gives back 1. Every-time, no matter what is written to it. This thread can die, now. Thank you everyone for your help!
So it should be the file descriptor for the client fifo. Which.. I think is like a pipe.. 
&gt; please look at the errors Where are they? 3 things that jump out are that (1) you're not calling calc_bmi (2) you have `;` after your if statements and (3) you can't test if x is in a range with if( a &lt; x &lt; b)
GTK+ is rather simple to get started, and I'd suggest it. Don't start getting overzealous on your first project though. I would suggest steering clear of GtkTreeView components at first, for example. There aren't many C GUI toolkits left these days. You can also use Tcl/Tk from C directly, but I've never tried. Win32 is delightful, in my opinion, but it isn't cross-platform unless you don't mind running on WINE outside of actual Windows.
Qt is pretty good. We do most of our development in C with a bit of Qt for UIs.
So something like int a = 0; Int b = 1; While(b&lt;strlen(something)){ If(something[a] &lt; something[b]){ a++; b++; } } If not how could I fix this. I want it to return 1 if the whole string grows and 0 if not.
Here's the stackoverflow: http://stackoverflow.com/questions/1728509/does-qt-have-a-c-interface
Thanks.
At first glance to me it looks like you have put semi colons after your if statements. I think that this would cause the issues you are having with missing parentheses and semi colons further on in the code. Also, the source code is the the code you have written. Edit: as another poster mentioned you cannot test if a variable is between two values. You need to test for both conditions. HINT: this involves the AND operator. 
No I haven't, thanks for the link.
Oh my god.. You saved my butt so hard... Once I realized fdb was being set to 0 it fixed a bug that has been tormenting me for weeks.. 
Here's some pseudo-code that might help func stringIsGrowing( string ): low = string[0] for i = 1; end of string; i++ if low &gt;= string[i] return 0 else low = str[i] return 1
For what it's worth, OP's first example will always evaluate true, too \^_\^
[That feel when debugging.](http://www.phdcomics.com/comics/archive/phd011406s.gif)
Consensus: there's more than one way to do the same thing in C/C++, so don't get intimidated by the headaches. We've all been there ;)
Thanks for the reply; this looks pretty nice. The only thing I'd be worried about is that it might not be maintained. It's maintained by one guy who last updated it in 2013 and the last post to the discussion board was 2008.
Doesn't work. Try with `x = UCHAR_MAX + 6`.
And in the university program is so complicated.C language,Java,SQL,lol. 
That looks like an array or struct declaration, and it would mean reserving a new keyword `in` just so that you could type less. Sure, it's something possible, but it's not in the definition of what C wants to be. C is a very simple language, and excessively adding syntactic sugar like this would take out all of the elegance of the language and possibly reserve a shitload of keywords. And besides, adding things like this could add even more things for us to watch out for when dealing with bugs. So in other words, don't fix what isn't broken. Just learn how to duplicate lines and you should be good. 
Oh I wouldn't change anything about C to be honest. It's great at what it's supposed to be. I was just pointing out that it's possible to state the intention of "if variable is an element of this set" in a more concise way that is perfectly clear to understand. On a sidenote, it's not necessary to even reserve keywords for that if your language has infix function application.
Most of the world is using some kind of OO or other higher-level language. C++ is immensely popular, and Qt has an excellent reputation (deserved, from what I can tell). For one thing, a GUI lends itself quite nicely to an OO approach, or even a language with package support. I wish there were more C based UI toolkits because C is kind of a Common Denominator between languages. I suspect that's why Lua (written in C) uses IUP and/or Gtk. 
I would add [IUP](http://www.tecgraf.puc-rio.br/iup/) (C) to that list. I've seen it in lua a lot, so I think it's got some credibility. Agar looks interesting. I hadn't seen it before. 
But it does cause confusion after a while XD
That's really useful. Thanks 
I skipped the user input (instead using command line arguments) and assuming the user input proper values (dull boring stuff). I was able to get the drawTriangle() function to draw all six variants (handing the direction took the most time to debug actually). A nice change from work related coding. Anyway: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; void drawTriangle(int size,char direction,char pattern) { const char *even; const char *odd; const char *py; int y; assert(size &gt; 0); assert(size &lt; 16); assert((direction == 'f') || (direction == 'b')); assert((pattern == 'v') || (pattern == 'h') || (pattern == 'n')); switch(pattern) { case 'v': even = "*#"; odd = "*#"; break; case 'h': even = "**"; odd = "##"; break; case 'n': even = "**"; odd = "**"; break; default: assert(0); break; } for (y = 1 ; y &lt;= size ; y++) { int sx; int ex; int x; py = (y % 2) == 0 ? even : odd; if (direction == 'b') { sx = -y; ex = -1; printf("%*s",(size - (y - 1)) * 2," "); } else { sx = 1; ex = y; } for (x = sx ; x &lt;= ex ; x++) printf("%c ",(x % 2) == 0 ? py[0] : py[1]); printf("\n"); } } int main(int argc,char *argv[]) { int size = 5; char direction = 'f'; char pattern = 'n'; switch(argc) { case 4: pattern = argv[3][0]; case 3: direction = argv[2][0]; case 2: size = strtol(argv[1],NULL,10); default: break; } drawTriangle(size,direction,pattern); return EXIT_SUCCESS; } 
When I get home I am definitely going to take a better look at this. Its hard to understand what's going on when I'm on mobile, but that's amazing if you managed to get it done in that few lines
I'm kinda new to programming so I'm going to check this out when I get home. Its kinda hard to see what's going on while I'm on mobile. Thanks though, I'm glad people are trying thus problem out, its going to be fun to go through them when I get home.
This is only the actual output loop and does not use the given function format. It is not really simple either and absolutely not good code but for what its worth it does the job. 
 scanf("%s", fName[%d"], i); What do you think this line is doing? Because I can assure you it isn't. scanf("%s", &amp;lName); scanf("%s", &amp;pass); scanf("%s", &amp;eMail); In all of these lines you have your arguments wrong. Take off the ampersand, since those variables are already pointers. Side note: Do not use scanf to obtain user input. What do you think will happen if a user enters more than 20 characters for their password?
Can you explain why this is happening? And what makes `calloc` different there?
yes this made so much sens, lol. Thank you!
The point is it's not an error. It might crash at runtime or it might not, but the compiler isn't required to diagnose it either way.
Technically, the answer to this depends on the context of the statements. Static objects that are not explicitly initialized are actually initialized to a 0 value (interpreted for the relevant type). Automatic objects not explicitly initialized are left uninitialized. So: /* File scope */ int foo; /* Same as "int foo = 0;" */ void foo() { static int bar; /* Same as "static int bar = 0;" */ int baz; /* Uninitialized - random undefined value. */ } 
Thank you for your response. &gt; The historical definition of a byte is the smallest addressable unit of memory. This makes a lot of sense and also suggests why it is called a byte which is phonetically similar to bite.
If you’re really committed to `scanf`, you can limit the amount of input with (e.g.) `"%127s"` for `fName`—don’t forget to leave space for the terminating NUL or you’ll have a stack smash on your hands. If you’re not committed to `scanf`, `fgets` will get an entire line of input with a size limit. (You can `sscanf` the result, however, which is almost as good. However, you *really* need to check the return value from the `scanf` family of functions if you use them because they might not get you the input you thought they would, → undefined garbage values all over your program; and you also need to use format specifier `%n` to make sure that the entire string was actually consumed, which writes out the number of characters used into an `int *` in the argument list.) `fgets` takes a little bit of handling to do it right, so you’ll want to make a routine to do this for you. Basically, there are a few cases: 1. If `fgets` returns `NULL`, then the stream was at EOF and nothing was read. 2. If the buffer ends with a newline, then you read the entire line. 3. If the buffer doesn’t end with a newline but isn’t completely full, then you have the last content in the file, which doesn’t end with a newline. 4. If the buffer is entirely full and doesn’t end with a newline, then either the file happened to have exactly that many characters left in it without a newline, or the input line was too long to read. You can either use `malloc`/`realloc` to expand your buffer and keep going, or discard everything up to the end-of-line with something like while((k=fgetc(stdin)) &amp;&amp; k != '\n') (void)0; Remember to trim the newline off the end of the buffer before using it. And the ampersands were breaking things because taking the address of an array name gets you something of type `char (*)[]`, not the `char *` that `scanf` was looking for. (Just the name alone decays to the address of its first element, essentially `&amp;name[0]`. Technically the integer value of the pointer is identical between `&amp;name` and `name`/`&amp;name[0]`, but not the type.) Similarly to `&amp;`, `sizeof` acts on the array name pre-decay, so `sizeof(name)` gets you the size of the entire array instead of the size of a pointer to the start of the array (usually constant at 4 or 8).
He did link to his implementation so it's not like he didn't try it.
It's something to be careful of too. Of all the values 0 is the most likely value to be in a random spot in memory so sometimes the bug can go unnoticed, have all the warnings turned on for your compiler and it should pick up on things like this.
It's just short-hand notation, this: int foo = 0; is equivalent to this: int foo; foo = 0; Which of course declares a variable named `foo` and assigns it the value zero. Obviously, your other statement, `int foo;`, does the same thing but doesn't assign `foo` to zero (The second statement). The question of why you would use one over the other comes down to what you plan on doing with `foo`. Before you assign foo, it is said to be *uninitialized*, which is just a fancy way of saying it has no particular value because you have yet to assign it one (Like zero, for example). Reading an uninitialized variable is an error by the standard, and in practice it will yield unpredictable results. The only important point is that you have to make sure you initialize a variable, by assigning it a value, before you attempt to use it. IE. If you want to do something that uses the value of `foo`, like printing the value of `foo` to the screen, you have to assign `foo` a value before you attempt to do that (Or else, the program won't know what the value of `foo` is supposed to be, because you never told it). The syntax `int foo = 0;` is just a convent way to do this, since it's common to know what a variable needs to be initialized to when you declare it. It may, however, make sense to do something like this: int foo, bar; bar = random_operation(); foo = bar + 1; This is a fairly useless set of statements, but it still works. We declare `foo` and `bar` together at the top of the program, but because the initial value of `foo` is dependant on the value of `bar`, we need to assign `bar` first. `bar` is initialized using the result from `random_operation()`, and then `foo` is initialized with the value `bar + 1`. Thus, when this program ends, both `foo` and `bar` have been initialized correctly, even though we didn't use the `int foo =` syntax at the beginning. Note that reordering the statements produces an undefined result: int foo, bar; foo = bar + 1; /* Invalid! */ bar = random_operation(); It should be somewhat apparent what is wrong, but because in this case we assign `bar` *second*, `bar + 1` is invalid because `bar` has yet to be assigned it's first value. Thus, we can't assign `foo` to `bar + 1`. This code *will* still compile, technically, but the compiler and standard give no guarantees on the value of `foo`, because you have no guarantee on what the value of `bar` will be. If you turn on warnings on your C compiler, it's pretty much guaranteed to throw a warning in this case.
Is English your first language? I would suggest finding something in your native language :)
calloc takes two parameters, the number of elements and the size of 1 element and does the multiplication and checking for overflow for you. If your structure is 1048576 bytes (1MiB) long, and you have 4096 elements, and you multiply the two, you get 4294967296. In hexadecimal, that's 0x100000000. If that is casted to a size_t (which happens when you pass it as a parameter to malloc), and size_t is 4 (which is typical on a 32-bit system), then the result is truncated to 0x0. So, malloc will happily return a pointer to a block of size 0, and you'll write right past the end of the block into random areas of the heap.
A similar approach can be used for values outside the range of `unsigned char`, but you will usually need to write your own function to find an element in the array.
Out of curiosity, whats an example of a platform that won't happily print out whatever is in the memory location foo is stored at?
TIL there's a website to stream coding.
I would be surprised if one existed.
I don't know if this works like the Talor Series
Personally I'd just define the representation of each possible character in the code, then once you've read the input string you can loop over it, look up the representation of each character in the string and output that. You then have a large amount of data that is simply a mapping of character to a collection of strings.
Thank you! 
Yes of course, that's an initialization and you can initialize arrays. Try an assignment...that doesn't work.
Hint: Putting four blanks in front of every line of a paragraph makes this paragraph come out in a monospace font. For example, you H would look like this: HaaaaH HaaaaH HaaaaH HHHHH HaaaaH HaaaaH HaaaaH
First things first, your formatting is, well, bad. Very bad. It even looks like you commented out a brace - does this even compile? Secondly, I'd recommend that you gut `main()` and write smaller functions instead - it's easier to do I/O in `main()` and write a function `float standard_deviation(int data[])` to pass the gathered data into. Especially with the whack indentation, there's way too much mental effort to understand what's going on here. Go forth and refactor - come back if you have a problem later.
Unfortunately English isn't my first language.But studying is on English,so I should improve it:)
Ah. It would definitely be best to learn it in your native language though! Then you will only have to learn one thing at a time, instead of two things at once. Just an FYI, I actually dropped out of my Computer Science class a few days ago. It was too hard for me, so those are all the resources I have. Best of luck to you!
You should pass C (the result) to multiply void multiply(int A[][10],int B[][10],int C[][10], int m,int q,int p) multiply doesn't need to return anything - it writes the result to the C it is passed
What does your compiler tell you? I see a couple of errors that should show up during compilation. After that, have a good look at this block C[m][q] = multiply((*Aptr)[10], (*Bptr)[10], m, q, p); for(i = 0, i&lt;m; i++) { for j = 0, j&lt;q; j++); { printf("\t%d", C[i][j]); } printf("\n"); } You're only setting one element of C, but it's not one that you're printing out.
what is a datum
"Datum" just means "piece of data/information".
Singular of data.
Are you in the same class as /u/ebi1998 ? &lt;https://www.reddit.com/r/C_Programming/comments/3poi6o/please_help/&gt;
The "..." isn't actual code, it's just there to show you that there could theoretically be other, unrelated code there if you wanted. Removing it is just fine. So that's exactly what you would expect to be printed. This question gets at an essential skill in programming: can you look at some code and reason about what it does? Actually running the code will tell you what it did, but you should be able to do a high Let's reformat the code so it's reasonable: int i=0; while(1) { i=i+1; printf("%d\n", i); if (i&gt;3) break; } Here's my thought process when I look at this code. This will jump around a bit, which is part of the process for me: while(1) { Oooh, an infinite loop! Without some other way to exit, this loop will just go on forever. Let's see if there's some other way to exit the loop: `break` or `return`. if (i&gt;3) break; There it is. The loop will exit if `i` ever goes above 3. How can that happen? i=i+1; Ok, so we have a counter that increments each time through the loop. Now we know how the loop itself behaves: `i` will be incremented each time through the loop, and the loop will stop when `i` becomes 4. The loop will execute 4 times. The last piece of the puzzle is what is done on each iteration: printf("%d\n", i); So `i` (after it's incremented) is printed on its own line each time through. This happens after incrementing, so it prints starting with 1 not 0. Thus, the output should be: 1 2 3 4 Now technically, since there was "...", the value of `i` could have been changed from 0. Someone being pedantic would point this out as part of the answer, but it's probably not what's intended from the question.
Doh! Wasn't thinking. Will edit.
Write out what the code does, step by step.
This is probably a simple misunderstanding of terminology, but the C standard clearly states: &gt; The `sizeof` operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. **The size is determined from the type of the operand, which is not itself evaluated.** The result is an integer constant.
Have you tried executing the code?
sorry but if you're not gonna help me then please stop messaging me. I keep clicking my mailbox thinking its something important....
I only posted once, no idea why you think it's more than one post. Seemed like a very reasonable question too. If you can't be bothered to answer it maybe you should stop making MY mailbox organgered.
Yeah, what I was trying to say was `sizeof(expression)` only cares about the type of the expression, not the value.
Go through the same process. while(i) Not an infinite loop this time. This means the same as `while ( i != 0 )`, so now the loop will end when `i` gets to a specific value. But wasn't `i` already 0? int i=5; Ah, nevermind. So, how does `i` get to 0? i=i-1; So, it's decremented each time. So, it goes 5 4 3 2 1 0. What does the loop do? printf("%d\n", i); `i` is printed each time through the loop, after being decremented. The first one that's printed is 4, the last one is 0 (the test happens after it's printed). Here's the key: look at how a loop is controlled first. Under what conditions does it end? When do those conditions change? Once you understand what controls the loop, then look at what the loop does each time. And finally, always look at what the first and last iteration of the loop does, then fill in what happens inbetween. As a last ditch effort (for especially complex loops especially), you can always trace out what the code does as if you're the compiler, incrementing counters and "printing" lines as you go. But that's time consuming and usually misses the high-level view of the code.
Basically sizeof works on variables only. And since every variable has a type, we can conclude that sizeof only works on types.
This feels like a silly question, but I was thinking about this code and wondered: why does it stop at 0? There doesn't seem to be a condition like the one for the increment problem that stopped at 3. I know the while loop is set to run while i exists, but since an int is signed by default, why does the loop stop at 0? Why doesn't it keep going into negative numbers? 
In C, 0 is false. So 0 ends the while loop. 
Ah, that makes sense.
&gt;I know the while loop is set to run while i exists Here's the misunderstanding. `while ( i )` does not check for existence or any similar property of a variable. It's literally just checking to see if `i` is 0. Think of it as shorthand. C didn't originally have any sort of Boolean data type. (It got one in 1999, and even to this day if say the majority of C programmers don't know that and still do it the old way.). Instead, C treats 0 as false and anything else as true. So that loop could have been written with `while ( i != 0 )`, and probably should have been, for clarity since `i` is not being used as a Boolean.
Thank you for the explanation! That actually makes a lot more sense. 
Thats really cool! I'll see if I can incorporate that as well. I also hadn't thought to use typeof.
Hey, you're right, I completely forgot about structure member init at defintion ( { .whatever = 1 } ) syntax. I will definitely incorporate that, as it is better than what I am doing. Also, not sure if you're the commenter from my github, but is there a reason you dont typedef your structs? typedef struct { ... } comp; This would allow you to Optional(comp) without problem. Regarding two-part definitions, that doesn't seem like a bad idea, I'll definitely think about adding it. I wonder if typeof(struct comp) would work. Thanks for the feedback!
There is no main function...main function is necessary since that's where the execution starts..its like int main() { } Either call the function from main or write the code in main itself
Maybe I don't understand your problem. What is it that you do not understand? You asked “how do I store information in a 2D array?,” my post explains how to store information in a 2D array. If you expected a different answer, please tell me, so I can give you the answer you expect.
By convention all executable files (at least in when written C) must have a `main` function. `main` is normally written on one of two ways * `int main(void)` * `int main(int argc, char *argv[])` I'm not familiar with Xcode, but try adding to the bottom of your file. int main(void) { dadd(); return 0; } You'll need to add a breakpoint to the bottom of `dadd` to see anything.
so do you mean that placeholders are unnecessary in this case?
Updated with a "DefineNamedOptional", which allows use of un-typedef'd structs, unions, and pointers. Check out https://github.com/jamesmunns/optional_c/blob/master/examples/names_and_pointers.c
Your code doesn't make sense. `foo` isn't defined anywhere but you're trying to access it as an array. If you made a typo and `foo` should be `ary`, then you're accessing elements 5 and 6 but there are only 5 elements in the array (`[0]` through `[4]`)
Ok, I changed the code so the loop only counts till the 4th array. Now I get a Segmentation Fault, never saw something like that
Your array has 5 elements. Your loop is for an array with 7.
Post the new code then.
`feof` does NOT mean end of file. It's poorly named function. [See here](http://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong) for explanation of why to not use `while (!feof(fp))`. Instead, check the return value of `fread`. `fread(newNode, sizeof(Something), 1, fp);` could be a mistake (although can't say for sure without you posting more code). In your first iteration you set `tail = newNode;`. At this stage, `tail-&gt;next` will be a garbage pointer containing some bytes you read in from the file. This could possibly be OK if you always use `*numSomethingPtr` as a count although there's really no good reason not to initialize the pointer to null (and it shouldn't have been read from file in the first place). It's hard to say any more about what is going wrong since you never posted the code that is apparently demonstrating wrong behaviour. Ideally post a complete program that demonstrates the misbehaviour when run, and is as short as you can make it. 
The call to fread() looks funny. You're telling fread() to read 1 object of size "sizeof(Something)". But an object of type "Something" includes your "next" pointer in addition to the data you're manipulating. So the fread() call will include the size of that pointer in what it reads from the file. I'm assuming the data in the file would not include a slot for this pointer. Say your data is 16 bytes and your pointer size is 8 bytes. Each call to fread() will therefore attempt to read 24 bytes. If the file has a sequence of 16-byte objects, then on the first iteration of the loop, the code will read the first 16-byte object and half of the second one. The second iteration reads the remaining half of the second object and the third object. And so on. This would have the effect of giving you garbage data. If the objects in the file *do* have space for the pointers, that would be conceptually weird, since typically the value of a pointer would hold no meaning outside of the context of your program. Usually people don't do that. (Although there are always exceptions...) The second issue I see is that you're not initializing newNode's "next" pointer correctly. The "next" pointer for one iteration does get updated on the following iteration (because you add another node to the list). But for the final iteration, the last node that gets added to the list will not have its "next" pointer assigned at all. Thus it could be pointing anywhere in memory and lead to arbitrary behavior when you later attempt to traverse the list. (Including garbage output or a crash).
The list traversal might work if OP uses the counter to know when to stop reading. 
True. Without context, it's difficult to tell. But if this is for a class, my bet is most classes would be teaching: follow the next pointers until you hit a null one.
Well, a simple loop on the input should do it right? do { scanf("%d", &amp;n); } while(n &gt; 10 || n&lt;5); do{...}while(); works like a while loop but it checks the condition at the end of the loop. Or something like if(n&gt;5){n=5;} If you don't want to bother with asking for input several times.
I don't understand your question. The `%d` format specifier that you're passing to both `scanf()` and `printf()` stands for **d**ecimal (as opposed to `%o` for **o**ctal or `%x` for he**x**adecimal). What exactly isn't working?
basically, for when the wages get sorted, im unable to put in the number 1010.10 for instance only 1010 and the like
But foo[0] has the value 1 and foo[1] the value 4, isn't that correct? 
The binary file actually does contain NULL for the pointer. I did figure out I needed tail-&gt;next = NULL and it did compile successfully. Do you have any idea why my professor insists on using binary files? What am I gaining from this that I wouldn't from using fscaf, atleast in this particular case?
Basically, Optional is a type that can either be None (basically invalid or unusable), or Some (which contains usable data). When a function returns an "Optional", that means that the function could either return None (an error case), or Some (the function worked correctly). However, to turn the Optional into usable data, you have to "unpack" it. Unpacking in this case means checking whether it failed (None), or worked (Some). C achieves this functionality usually by doing something like this: // function declaration bool getFloat( float* foo ); // ... bool flag; float myFloat; flag = getFloat( &amp;myFloat ); // ... In that case, `getFloat` returns `true` if it was a success, and `false` if it failed. In theory, if `getFloat` returns false, you should NEVER use `myFloat` if `flag` is false. However, nothing is stopping you. For all we know, if `getFloat` fails, it could set `myFloat` to positive infinity, negative infinity, zero, or not touch it at all. Languages like Rust or Haskell (in haskell its the "maybe monad"), the language has a built in way of making you check this. You dont get a float back, you get an Optional. The compiler forces you to only use the contents after you have unpacked the result. By using the Optional, it makes it much more explicit whether the call succeeded or failed. This was my attempt to bring that pattern to C. As always, you can ignore just about anything in C, and use the data anyway, but at least if you are using it the wrong way, it should be a little more obvious.
Cool! I was thinking somewhere on the lines of that, but I kept thinking about fread still being in a nested while () for some reason and it didn't seem right. 
That was a very readable description, thank you very much. I'm familiar with several Ç idioms for error handing, and they are all usually clumsy. It's made worse with inconsistent approaches-sometimes in the same library. I toyed with having all functions return a string - NULL means no error, no warning. Non-NULL strings begin with a numeric value easily extracted (if desired) using `atoi` or similar. It, too, was cumbersome. 
http://man7.org/linux/man-pages/man2/gettimeofday.2.html This is "wall clock" or real time, not CPU time. Just call it once before you start, again after you finish, and subtract the values (correctly).
gettimeofday() is affected by system clock adjustments, such as switchovers to or from daylight savings time. For timing things you want a clock that's not affected by such adjustments. I think `clock_gettime(CLOCK_MONOTONIC, &amp;tp)` is probably the appropriate API.
Your post is a bit unclear. How fast dies the light need to blink? At one point you imply 1 hz, at another 600 hz. The general idea here is to figure out the total number of cycles you have to delay. For 1 hz, that's 1000000 cycles. For 600, it's 1667 (you'll never get it exact). Then you need to figure out exactly how many cycles the loop takes to execute each time through. Don't guess -- go to the documentation and look up each instruction. Ideally the total number of cycles will be evenly divisible by the cycles on the loop. If not, you can always add nop instructions in the loop or outside, your choice. Dividing the two will give you the number of iterations for your loop. Then maybe add some nop instructions after the loop so the total count is perfect. I think that's basically what you're doing, you just need to nail down the numbers precisely.
What I mean is that the .txt file we have to read from has a line with one number that is our number of columns, then a line with the number of rows, then the array itself. Would it be best to save all that data as a big array first, and then write something like rawdata[0] = columns, rawdata[1] = rows, rawdata[2+i] = array[i]?
Think carefully about the steps you would go through to do this calculation by hand. Your code needs to do the same steps in the same order. You need to calculate the mean&amp;nbsp;µ *first*. You cannot simultaneously calculate the mean and calculate the sum of the (x\_k&amp;nbsp;−&amp;nbsp;µ)^(2) terms, because you need to know the value of&amp;nbsp;µ before you can begin calculating the (x\_k&amp;nbsp;−&amp;nbsp;µ)^(2) terms. EDIT: Do not delete your post just because your question has been answered, /u/CavernsandDemons.
Difficult to say without knowing more about context. They possibly just want you to learn how to work with binary files. In general, a binary file can often give you a more compact storage compared to a text file (it will use less space on disk). Whereas a text file gives you a human-readable format, but possibly takes more space. Another tradeoff is that working with binary files is usually faster. The scanf functions perform a translation from ASCII-encoded characters into other types (e.g. integers). Whereas for binary, the data is already in the right format - it just has to be read from disk into memory. In some cases, the binary format will be preferable. In others, the text format will work better. They are two ways to do the same thing, but with different tradeoffs. So knowing how to work with both gives you the skill to be flexible and make an appropriate design choice when approaching a new problem.
Yes, but you're not accessing foo[1], you're accessing foo[**-**1] in that first iteration. What are you even trying to do?
The fact that you deleted your previous post, /u/CavernsandDemons, does not encourage me to help you again. https://www.reddit.com/r/C_Programming/comments/3put6r/i_keep_getting_0_when_trying_to_get_the_variance/
Ah, sorry. Yes. It is one second intervals. I figured it out. I didn't have my cycles/operations right. 
I know it's the same problem. That isn't the point. I don't want to waste my time helping you if you're just going to delete this post like you did the last one.
Consider what your .txt file will look like as C is reading in chars: '3''\n' '4''\n' '1''2''3''4''\n' '1''2''3''4''\n' '1''2''3''4''EOF' When you look at the data that way, you could use the code I provided above and modify it slightly to properly handle the data formatted above. Now for storing that data. Unless you know ahead of time what the maximum possible size of the array is ahead of time, you shouldn't use an array declaration (to avoid seg faults). If you know the max size, then you can use the method you describe. If not, you'll need to do something like this after reading in the row/column values: int * matrix = (int*)malloc(rows*columns*sizeof(int)) or if you prefer a '2D' structure, try one of the ideas listed here: http://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/ *Edit: A plus to avoiding the array declaration... practicing with pointers! 
 #include &lt;time.h&gt; #include &lt;sys/time.h&gt; void current_utc_time(struct timespec *ts) { #ifdef __MACH__ // OS X does not have clock_gettime, use clock_get_time clock_serv_t cclock; mach_timespec_t mts; host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &amp;cclock); clock_get_time(cclock, &amp;mts); mach_port_deallocate(mach_task_self(), cclock); ts-&gt;tv_sec = mts.tv_sec; ts-&gt;tv_nsec = mts.tv_nsec; #else clock_gettime(CLOCK_REALTIME, ts); #endif } ... struct timespec tstart={0,0}, tnow={0,0}; current_utc_time(&amp;tstart); ... current_utc_time(&amp;tnow); ... ... (double)( tnow.tv_nsec - tstart.tv_nsec ) ... // do something with the time I think I got that from stackoverflow somewhere.
Posts on assembly programming are off topic in this subreddit. Please try again in /r/asm. I removed this post for you.
Do you have the code defining them and how they are created? If you toss that in a pastebin and link it here it will be easier to help you.
Yeah, sorry that would probably help. Here you go: http://pastebin.com/wLYnjdW9
Yeah that would probably help. Here you go: http://pastebin.com/GPVerWsA
Even in the code you just posted, I don't see where things are added to the list or allocated.
Whoops, I can't copy and paste evidently. This should have it. http://pastebin.com/GPVerWsA
Something funky is going on. Show the definition of the struct. a [MWE](https://en.wikipedia.org/wiki/Minimal_Working_Example) would be better. I see a problem in that you're reading `sizeof(Shield)` bytes into a `Shield`, but your `Shield` struct contains a pointer to the next node, so presumably the memory you're reading in will be corrupted when you set that pointer.
Write it out in English, or whatever your native language is. The concept isn't hard if you understand what each individual loop does. Here's a simple example: Start with outer and inner set to 0 While outer is less than 5, do: print outer While inner is less than or equal to outer, do: print inner increment inner by 1 set inner to 0 increment outer by 1 What will this print? In English I might say: Print each number from zero to four. After each number, print all the numbers before it. Here's some example code for the pseudo code above: #include &lt;stdio.h&gt; int main() { int inner, outer = 0; while ( outer &lt; 5 ) { printf("Outer is %d\n", outer); printf(" Inner is: "); while ( inner &lt;= outer ) { printf("%d ", inner); inner++; } printf("\n"); inner = 0; outer++; } return 0; } Which will print this: Outer is 0 Inner is: 0 Outer is 1 Inner is: 0 1 Outer is 2 Inner is: 0 1 2 Outer is 3 Inner is: 0 1 2 3 Outer is 4 Inner is: 0 1 2 3 4 Does that make it clear what the nesting does? You're really just saying: Each time the outer loop runs, run the entire inner loop.
Please format your code so it's readable, or put it on pastebin or the like.
fixed, sorry
And your question is? 
 for(x=0; x&lt;width; x++){ for(y=0; y&lt;height; y++){ Your loops are in the wrong order. The outer loop should be 0-&gt;height, the inner loop is 0-&gt;width
WOW THANKS! That fixed the whole thing. I kept looking at my code wondering what was wrong.
Write a double nested for loop that the outer loop iterates 0, 10, 20, 30,..., 100. The inner loop iterates 1, 2, 3,..., 9. Then it prints the sum of the outer loop and inner loop: 0, 1, 2, 3,...,99, 100. Etc 
Turns out you don't have to free it. It's already done for you in the freeHeroes function that was written for us. Made things a whole lot easier. 
based on this post, I would say the regular clock_monotonic is even better than clock_monotonic_raw, so yeah. change it out. learned something with that.
 Yeah you're definitely right. Out of habit I collect my input with getchar() and use val = (val*10)+ch - '0'; to convert the values to decimal, then determine how I'll handle whitespace. He'd have to include these items (as you mentioned) to use my solution. Good catch!
What is the intended purpose of the array named "n" in your code? Note that you are overwriting the numbers from your first for loop in the second for loop. Note also that n[x] == x, which is rather useless. I also don't see anything in your code that looks like it's trying to multiply abc by cba. I recommend trying to come up with a description in words of what approach you want to take to solve the problem, and then figuring out how to write that in code. Right now, I'm having trouble following the intended logic of your program. 
some pseudo code: // make a function to reverse a number int reverse_number (int i) int reverse = 0 while i is not zero reverse = reverse times 10 reverse = reverse plus i modulus 10 i = i divided by 10 // main int i, testnum = 0 for i &lt; 1000 if 100147 modulus i equals 0 testnum = 100147 divided by i if testnum equals reverse_number (i) print found! break
Only took a very quick glance but why do you think they should be in order? Just looking at the producers they seem to not ensure ordering, while produce_one() has internal mutex once the item is produced there is some time where there is no lock before adding to queue. Threads could be adding to queue in any order, no?
push( ) sets a new endpoint, which looks correct; but it does not check wether this would overwrite the start point of the list. This is fine since you are checking if list is full first, and are aware of it; but the theoretical next person maintaining the code may not be. The output when I ran it was completely as expected (strictly ordered) Edit: Output: http://pastebin.com/uxT0feT2
Try running it multiple times, if you didn't chance anything you should e the order get messed up occasionally. It's the producer that messed up I believe, not the consumer 
I'm trying to handle that case, so I either need to make it so threads can't be interrupted between pulling an element from the structure and depositing in the buffer or so the program waits for the thread to resume. Is this not possible? I added a mutex to my producer, which fixed the problem but added a problem where my producer thread would get past the while condition but would be preempted so it would produce when there was nothing left to produce, resulting in data values less than 1 which wasn't intended. After handling that, it looks like it is working as I want it to (decrementing in order from 20-0, not including 0, where threads produce in any thread order and consumption happens in any thread order but the data is produced sequentially and consumed sequentially. producer code post edit: void *producer(void * ptr) { int data; while (has_more_to_produce()) { pthread_mutex_lock(&amp;mtx_prod); data = produce_one(); if ( data &lt;=0 ) { pthread_mutex_unlock(&amp;mtx_prod); break; } //printf("producer %d : %d\n", (int)ptr, data); fprintf(fp, " producer thread %d produces resource %d\n", (int)ptr, data); fflush( fp ); push(&amp;pool, data); pthread_cond_broadcast(&amp;cond_nonempty); pthread_mutex_unlock(&amp;mtx_prod); usleep(500 + (rand() % 500)); // slow down for demonstration } //printf("exiting producer\n"); fprintf(fp, "producer thread %d exiting producer function, there is nothing left to produce\n", (int)ptr); fflush( fp ); pthread_exit(0); } If you see any problems with this let me know please.
&gt; I'm trying to handle that case, so I either need to make it so threads can't be interrupted between pulling an element from the structure and depositing in the buffer or so the program waits for the thread to resume. Is this not possible? It is, but only if you run a single thread at the time - defeating the purpose of multithreading (the talk I linked earlier goes more into depth on why this is). It also explains a few concepts on how you would do this without any mutexes at all. 
This doesn't work on ARM as ARM uses a different instruction set than x86. Try -516948194 (corresponding to the `bx lr` instruction) or 18288 (if the code is interpreted in thumb mode) instead of 195.
I tried a bunch of values and all of them segfaulted except yours and 0x4770 which print "Illegal instruction". Maybe on ARM you can't execute data? Edit: it's 3778019102! root@localhost:~/projects/195# gcc -o main main.c main.c:2:1: warning: this decimal constant is unsigned only in ISO C90 const int main = 3778019102; root@localhost:~/projects/195# ./main root@localhost:~/projects/195# echo $? 1
Char
`const int main = -516948194;` works as expected! The device is a Samsung Galaxy S3, so the cpu is armv7l. Where did you find that constant?
Notice that when `int` is a 32 bit type, then `3778019102 == -516948194` as the former actually produces an overflow. This is the (unsigned) hexadecimal value `0xe12fff1e` which is the encoding for `bx lr`, the instruction commonly used for “return from function” on ARM.
Cool. I've seen my program using `bxeq lr` and I tried it, so 19922718 also is valid.
`bxeq lr` is a conditional instruction only executed when the zero flag is set. It's a funny thing this works, something must have randomly set the zero flag before.
well after some time i found that there is a function is **ctype.h** that checks is the entered number is really a number or it is a symbol or letter from alphabet int x; for(;1;){ scanf("%d",&amp;x); if(isdigit(x)) //do smth if(isaplha(x)) break; if(ispunct(x)) break; } Is this good?
You can proceed in a manner very similar to the way you do this with an array. Instead of retrieving a string from an array, you need to do this: 1. read one line of text into a buffer. You can use `fgets()` or `getline()` for this. The buffer can be reused. 2. find out how long the line of text is and allocate with `malloc()` a buffer of that length. 3. copy the line of text into the buffer allocated in step 2. 4. insert that buffer into the tree On POSIX systems like Linux, you can use the `strdup()` function to conveniently do steps 2 and 3 at once. Remember that `fgets()` does not remove the newline character from the input. If you don't want a trailing newline in your strings, you need to remove it. This is left as an exercise to the reader.
Thanks yah thats what is was. The assignment took me like 30 seconds, I was just really sick for a few days so nothing made sense
 void freeAllMemoryInLinkedList(NodePtr* startPtr) { NodePtr freePtr= NULL; printf("hi"); while(!((*startPtr)=NULL)) { freePtr=startPtr; startPtr=(*startPtr)-&gt;nextPtr; free(freePtr); } } freePtr is type NodePtr. startPtr is type NodePtr*.
update working now thanks. I've been at this error for 2 hours. I just had to walk away. I came back and found 2 errors. T_T thanks!!
In your functions you pass a SDL_Rect * r. You then allocate some memory, and you assign an adress to the r variable. However, I think that in this situation r is a local copy of the pointer you passed. While you can still modify the structure pointed by it, you have to either use a pointer of your pointer or return the new adress with the function. I'm not on my computer right now, so I can't try it out, sorry if I'm wrong. 
Problem has been Solved!
Fun fact: 012 == 10 Why? Because numbers starting with 0 are interpreted as octal, and 12 in octal is 10 in decimal. You can use `'\n'` instead. You don't need to look up on the ASCII table. 
That's been my issue. How can I change my insertion function to alphabetize by line?
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { const int inputsize = 10; int input[inputsize]; int count = 0; int c = getchar(); while ((count &lt; inputsize) &amp;&amp; (c != EOF) &amp;&amp; (c != 10)) { input[count++] = c; c = getchar(); } for (int i = 0; i &lt; count; i++) { printf("%c",input[i]); } printf("\n"); return (EXIT_SUCCESS); } 
/r/dailyprogrammer I find it best to learn by solving problems.
Start or join a project. If you want to start your own project I'd recommend writing a basic http server, read up on the HTTP specification and add features of that spec to the server. Support for different mime types, and so on. 
Ok. Where I can find this kind of project?
Okay, thanks. I'll check it out.
Wow, some interesting things here. I'll check it now. Thanks man.
There just so happens to be one on the front page of /r/cprog right now
Comp programming is a big world. Hackerrank is a great site for skill building. Practice problems can be found on SPOJ (sphere online judge) and on Google Code Jam's archive. These problems will help you increase your skill in identifying problems, breaking those problems down, and then implementing algorithms to solve those subproblems.
My skill want to improve is game programming. Nice, that's a wonderful idea. I have build 2dimension ping pong with LED and button. Also a password games with arduino. Thanks.
Thanks. Maybe I'll put all the suggestions here into new post.
Also www.leetcode.com if you want to also polish your algorithm design.
thank you, I'll add it to my post.
I'd recommend against Build Your Own Lisp, since it basically goes "don't worry about parsing, you'll just use this library that I wrote for this that you'll never use again." I've found http://peter.michaux.ca/articles/scheme-from-scratch-introduction to be better although I haven't looked at it in quite a while.
Thank you for listing get all those plaices where we can improve our codding skills.
Edit I added comments using `/* My Comment */` in your code Start with the simple syntax fix: UNIT8 process_age(const UNIT8 age) { UNIT8 age_status = INVALID_AGE; if (age&lt;13){ age_status = UNDER_AGE; } else if(age&gt;110){ age_status = STAT_AGE_ANOMOLY; } else{ age_status = VALID_AGE; } /* YOU MISSED ME */ return age_status; } Also you like 128, if you intend to uncomment file1 //void getLastName(char* lName){ //struct Data lNamePerson; //int count2 = 0; //do{ // count2++; //}while(*(lName + count2) != '\0' || count2 &lt; 128); /* TRUE UNTIL COUNT IS &gt;=128 AND out of range memory is a null character, this could be a while. (YOU WANT &amp;&amp; not || */ // lNamePerson.lastName = (char*) calloc(count2, sizeof(char)); // count2 = 0; //do{ // *(lNamePerson.lastName + count2) = *(lastName + count2); // count2++; //}while(*(lastName + count2) != '\0'); //}
I do intend to uncomment it out I think I just don't know how it is going along with the program at the current moment. Also, a buddy from class told me to change that while statement from || to &amp;&amp; i just had forgotten to do so. Im still getting a ton of warnings and errors when i compile though, if someone would like me to post all the errors for this program at the current time I could most certainly do that. Thanks for anymore help guys.
Do you have a specific question? You don't learn anything if people on the internet just fix all your code for you. Where I am from, that would be considered plagiarism.
`src/../hdr/A2.h:13:5: error: ‘UNIT16’ does not name a type` * You didn't typedef something to UINT16 * You didn't define LONG_NAME, SHORT_NAME * Your definition of STAT_AGE_ANOMOLY is missing a space before the value I think a few of the other errors are caused by the missing `}` I pointed out. Your compiler messages are helpful, you need to learn to read them. * &lt;File&gt;:&lt;Line&gt;:&lt;Character on line&gt; &lt;error/warning&gt;: Message `src/A2Main.c:68:1: error: a function-definition is not allowed here before ‘{’ token` That particular example is actually a bad message caused by a confused compiler. But the next error is actually much closer to my suspected cause src/A2Main.c: In function ‘UNIT8 process_fname(UNIT8)’: src/A2Main.c:28:1: warning: control reaches end of non-void function [-Wreturn-type]
... Why do you use UNIT8 instead of UINT8?
&gt;why/where should I use them? Using const-correctness in your code means that the compiler will detect for you when you potentially would write to memory that is read-only; and also when you make a logical mistake of writing to some data that you had intended to not be changed by a particular part of your code. It's also a good form of documentation; seeing a function parameter `const char *`, we know that that parameter is providing input-only data, whereas a `char *` parameter could be out, or in-out. (or even "in" if written by a poor coder) 
You go one past the end of the array. Fix the code like this: foo(i=1; i&lt;n; i++){ foo[i]+=foo[i-1]; printf("%d", foo[i]); }
Ok, I did that, but still a segmentation fault..
Thank you for this. I've been working on writing a lisp interpreter for another project and I the hardest part so far has been figuring out the form of the AST. "Use this parser generator I've just handed you because writing a parser isn't very interesting." has left me more than a little bemused.
 typedef struct { int mPosX, mPosY; //X &amp; Y coordinates int mVelX, mVelY; //Velocity SDL_Rect *mColliders; //Dot's Collision Boxes } dot; void scale(SDL_Rect* r,size_t capacity) { r=(SDL_Rect*)calloc(capacity,sizeof(SDL_Rect)); } void rescale(SDL_Rect* r,size_t newcapacity) { r=(SDL_Rect*)realloc(r,sizeof(SDL_Rect)*newcapacity); } void gc(SDL_Rect* r) { free(r); r=NULL; } void dot_init(dot *d,int x,int y) { //Initialize the Offsets d-&gt;mPosX=x; d-&gt;mPosY=y; scale(d-&gt;mColliders,11); //Initialize the velocity d-&gt;mVelX=0; d-&gt;mVelY=0;elements of //closing brace? /*The SDL_Rectis a structure and Contains fields like x,y,w,h all int. Now how to access those fields? Ex. Something Like d-&gt;mColliders[2].h=1; d-&gt;mColliders[3].w=16;//This ain't working*/ That formatting was annoying me, so I made it more readable, for me at least
This may work too https://github.com/kanaka/mal/blob/master/process/guide.md
You never set `p` to anything in `saveClients`
Sorry I haven't get it :(. I have declared person p, what else do I need to do? Do I need to set p like what I did in addMembers again?
Would you mind posting some links to specific examples? I see this advice all the time but rarely do I see an actual link to something other than kernel code. I'm always interested in well written c programs.
Read the documentation for the scanf family carefully. It only sets errno for some errors - specifically errors relating to the stream. Sscanf reads from a string, so isn't going to trigger that condition.
Word from /r/crypto is that [BoringSSL](https://boringssl.googlesource.com/boringssl/) is actually well designed and commented (the non OpenSSL parts :)).
Can you give a spesific link? so i can add it to my post.
You're welcome
Yes, it has been.
Please do not edit out the bugs from your code after receiving an answer. This makes your post less useful for future visitors who might find your post experiencing similar problems.
why dont you just print your own error message instead of using errno. also check if errno is set if sscanf fails. 
There looks like there is another mistake as well. Try writing *for* instead of *foo*. for (i=0; i&lt;n; i++) { foo[i]+=foo[i-1]; printf("%d", foo[i]); } Also, for loops, instead of declaring i and n at the beginning of the code I find it good practice to declare them in first line of the loop. i.e. for (int i = 1, n = 5; i &lt; n; i++) { *code here* }
When you start repeating yourself, or whenever you want. You can make a function to do a single thing then you just call it in main.
Then you're probably expected to divide your program into functions that each have a single responsibility. The easiest way to do this is to look at your `main` function and say out loud what you think it does. If you say "It does X, then it does Y, then it does Z" and so on, then you've identified that your `main` function is doing more than one thing and these should be broken out into their own functions. Once you've broken it out, do the same for the new functions - make sure they're only doing one thing each. In the real world, there's a tradeoff to be made here. Some people swear by the idea that if a function is only doing one thing, it should be at most 5 or so lines long. I find that a little extreme, but the principle is sound. I imagine that you're just expected to understand this principle and apply it to your code.
Its strange because the program is not long enough for me to need to reuse code (about 250 lines), but theirs no way to reach the higher than 70% mark without the use of functions, so i was just thinking of making everything into its own separate functions 
First off, there's nothing inherently wrong with putting everything in one big function. As long as you loosen it up a bit with proper formatting and comments to demarcate sections, it should still be readable. Breaking up a big function into smaller ones is only really necessary if you want to reuse parts of it. Beyond that, it's mostly a matter of taste. Now, some rules of thumbs for doing that. Look for sections in your big function that only really exist to compute an intermediate result to be used later on. That computation is something you might want to extract into another function. As for size, it's nice to be able to have a whole function on the screen at once, no scrolling required. Don't stick too strictly to that rule, though. A word of caution: if you split up a function for code reuse purposes, go for it. But be careful when doing it to make the code more "readable". When reading your (formerly) big function, it can easily get pretty annoying to have to hunt down another short function every other line.
I was going to put all the calculations that i do into my program into their own functions, but i'm not sure if that will be solely enough to get the higher grades as, according the the lecturer, the only thing that should be in the main part is the functions that are called.
For example, i have a put that the user inputs the widths of their garden, and then after asked what type of wood they would like to use. Would this be an example where I could split them up into 2 different functions?
You can pretty much make new functions whenever you want. Here is an example that I did real quick. Where you can use a new function to do something whenever you want and to use a new function where one is repeating themselves. (I know it takes longer to type print_new_line() than it does to type printf("\n"), it is just an example.) #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; void print_hello() { printf("Hello,"); } void print_world() { printf("World!"); } void print_space() { printf(" "); } void print_new_line() { printf("\n"); } int main() { print_hello(); print_space(); print_world(); print_new_line(); printf("Printing More Stuff"); print_new_line(); printf("Even more printing"); print_new_line(); return 0; }
A function should be small enough for you to reason about everything going on in it. When you have more code than fits on a screen in a single function, you need more functions. 
even if you dont want to reuse code, you could still create functions. say for ex. you want to write basic calculator program, you can have functions like add(a,b), sub(a,b), mul(a,b),div(a,b)
Thank you very much for your help! I strcpy all p from database, and the program works properly now.
I can't see the good practice in declaring variables within a for loop. Sure, the values won't be able to hide when reading the code, but it doesn't exactly add to the readability of the code either. Also, it's a C99 specific thing...
I actually got the parser working just fine, the issue was that the tree it built just had strings representing each token. *Build your own lisp* comes with a parser that has all sorts of token information built in that makes evaluating it fairly trivial. Rolling my own parser meant figuring out what token information I needed and I ended up with a lot of spaghetti code trying to get there.
Would I call that in the function itself, or in the main?
No, you simply have to call the calcpi function in the main function. It never gets executed in your current code
If you want people to help, start by formatting your code properly (including sane indentation) and showing the errors that you get. Among the problems that jump out are: - There is no semicolon between parameters of a function. - In `vektorprodukt(a[3], x[3]);`, the expression `a[3]` is an invalid access, since 3 is out of bounds as it's trying to access the fourth element of the array. Moreover, you want to pass the array itself, not a particular element of it to the function, so you should be passing just `a` there. And actually you can't pass an array to a function, only a pointer. C lets you write `double a[3]` as a function parameter, but it's really quite misleading to do so because it implies you're passing an array. The parameter should be a pointer to double, i.e. `double *a`, which is what the language assumes you meant if you wrote `double a[3]` or `double a[]`. (This applies only to the specific case of function parameters; pointers and arrays are *not* equivalent in general.) If you don't understand how arrays decay to pointers, you need to look that up in your learning materials because it's crucial. - `main()` should have a return type of `int`. In antiquated versions of C you could leave off the return type and `int` would be used as the default, but that's not allowed any more in modern C and you shouldn't be relying on that anyway. Non-essential things that still need work: - The idiomatic way to write `j=j+1` is `j++` - Use more whitespace. Don't jam everything together. For example: `for(j = 0; j &lt; 3; j++)` - If you're using C99, then declare the loop variable inside the for-statement, e.g. `for(int j = 0; ...)`. This constrains the scope of the variable and helps prevent mistakes. - Variables with static lifetime (such as global variables) are implicitly zero initialized. You don't have to manually initialize them to zero. - It's always a good idea to check the return value of `scanf()`. 
Formatted #include &lt;stdio.h&gt; double a[3]={0,0,0}; double x[3]={0,0,0}; void vektorprodukt(double a[3]; double x[3]) { double w[3] = {a[1] * x[2] - a[2] * x[1], a[2] * x[0] - a[0] * x[2], a[0] * x[1] - x[0] * a[1]}; printf("Das Vektorprodukt ist {%f,%f,%f}\n", w[0], w[1], w[2]); } int main(void) { int j; for(j = 0; j &lt; 3 ; j = j + 1) { printf("Geben sie bitte %f-Koordinate vom Vektor x ein",j+1); scanf("%lf",&amp;amp;x[j]); } for(j = 0; j &lt; 3; j = j + 1) { printf("Geben sie bitte %f-Koordinate vom Vektor a ein", j+1); scanf("%lf", &amp;a[j]); } vektorprodukt(a[3], x[3]); } Problems: 1. `void vektorprodukt(double a[3]; double x[3])` Fix semi-colon: `void vektorprodukt(double a[3], double x[3])` 1. `vektorprodukt(a[3], x[3]);` --Incorrect in a few ways. It'd be best for you to learn why.
Another bug not mentioned yet is that you use integer division in your calculation. Since `d` is an int, `d+5` is also an int, so `1/(d+5)` is dividing two `int`, which results in another `int`. Zero in fact. To fix this, make `d` be a `double`.
I ran what you have here and I don't get any problems. The problem could be with what you're trying to assign to the variables in main, considering segfaults are caused from reading/writing to an illegal memory location. If you're assigning outside of your array bounds you'll get a segfault.
also use tags or an ide for function finding.
If there are clear differences between sections of code, then you can split the code into multiple functions. Each will have a new name, like "part1" and "part2". Then call them in order. Nothing changes in terms of output, and it's not necessary, but if you go back to the code, you can change each part easier because each has a certain purpose. You don't have to sift through code and remember where one part ends and the other begins. Or you can easily make a new method and insert it between two existing ones in the call order. Obviously it depends on the project whether this makes sense, like how often it will be altered, how complicated it is to understand, is it worth the small efficiency loss, etc. This makes more sense when each part might be over a screen of code, or "very long" in your opinion, because then organization becomes important. Understandability and readability are important. It's your call as to when to do it. Often, taking a block of code and giving it a name can be very helpful for someone reading the code, because they get to look at it at a high level, and don't have to, say, read a very tedious part that only accomplishes a simple task. They get the gist and can delve deeper at their leisure. Then later, you can tweak those little parts outside of the main function and not be overwhelmed by the code surrounding it.
instead of having this: calcpi(); You need this: pi = calcpi( denominator ); First of all, the way you wrote this function it needs an integer as an argument, second of all you want pi to hold the value returned by this function, which is done by setting it equal to the function call. 
my entire code will be #include "lab13.h" #include "fileUtil.h" int main(int argc, char **argv) { int runs = 0; int solution[16]; int andromida[10][10]; char outputFile[MAX]; printf("%s",argv[1]); FILE * fin = NULL, *fout = NULL; fin = openInputFile_Args(argc, argv); readFileName_type(output, "output"); fout = openOutputFile(output); runs = getTotal(fin); printf("runs = %d/n", runs); fillSolutionsArray(fin, solution); fillAndromida(fin, andromida); fclose(fin); checkSolutionAndDisplay(runs, solution, andromida, fout); fclose(fout); return 0; } i tried to printf my argument but i'm not getting any output but seg fault statement.
sorry i didnt put my entire code. openInputFile_Prompt() function just reads input from the keyboard and fopen() with the input.
The bug could be in that part of the code. The code you have posted so far is OK. To get a good answer you should post a complete program that shows the problem, so that someone else can compile and run it.
What sort of errors? Compile or runtime? 1st thing that stands out is you are passing a pointer to a single char to load, but it wants an array of 20 chars. Also, C lets you use more than 2 letters for variable names ... Take advantages of this feature.
I was planning on checking this out but I didn't have the chance to look at it yet. Maybe you'll find it useful: https://littleosbook.github.io/
In my opinion, it's all about readability. If you have to declare the test case within the for-loop, you might as well use a literal constant. When it comes to *i* it is almost guaranteed by convention that it is of type **int** when used in for-loops. int i; for (i = 1; i &lt; 5; i++) { // code } But in most cases *n* is derived from a function further up in the code responsible of getting the size of whatever being processed and thus cannot be declared within the loop anyway. int n = sizeOfArray(&amp;foo); But, as I said, it's my opinion. And the reasoning behind it. :)
&gt; s[strcspn(s, "\n")] = '\0'; This is a nice trick to avoid the `if` statement in my answer, I should remember it. Notice that it's probably a bit slower than a `strchr` based approach unless the implementation of `strcspn` you use has optimizations for this case.
It's actually very well written and even difficult concepts get explained in a way that's easy to understand. It's a great book I would recommend every programmer to read, not only the ones planning to build an OS. But the downside is its extremely hefty price
&gt; Is this because I passed the string in as a literal, thus it's being stored on the heap? Literal strings are stored in the `.text` section. Where *string* means the characters. The pointer `char *text` is stored on the stack.
/r/osdev and the sidebar material. Most notably osdev.org
thanks
thanks everyone, I got it fixed
Another "trick" is `strtok(s, "\n");` however that is inadvisable in real code for the same reasons that `strtok` is. Bonus obfuscatory points if you write `strcspn(s, "\n")[s] = '\0';` !
Apart from your main issue, you are using `strncpy` incorrectly. It does not put a null terminator in if the string is too large for the buffer. You *must* also have a following line such as `p.equipment[sizeof p.equipment-1] = '\0';`. For this reason I advise people to never use `strncpy`. Instead do one of the following: * `snprintf` * Check lengths and `strcpy` * `memcpy` and null-terminate (preferably not) Also you waste a character in `buf` for no reason; `fgets(buf, sizeof buf, stdin);` is sufficient. I guess you put `-1` in because you weren't sure of the behaviour and wanted to be on the safe side; but you can check these things out by reading documentation for the function. 
If you're having trouble with your homework, it's best to talk to your professors or classmates. You need in person help or you won't really learn anything.
You’re passing a reference by value.
You're right. After the first iteration, i is 11. Then you execute: i /= 2 11 / 2 = 5, so the new value of i is 5. During the next iteration of the loop, you then print out 5 and increment i to become 6. You execute `i /= 2` again and i now has a value of 3. At this point the loop terminates because `j &lt; i` is false. As for the comma operator in C, `a, b` has the semantics of "evaluate `a` and disregard its value, then evaluate `b` and use its value". The `i &gt; 1` is a red herring in this example because it has no effect on the program (optimizing C compilers will remove it entirely). `i &gt; 1, j &lt; i` is completely equivalent to just `j &lt; i`
i is an integer so integer division is used meaning that 11/2 = 5 (edit: oops meant 11/2, not 11/5)
The left half of the comma operator is evaluated but ignored; since it has no side effects, it's useless in that example. The exit condition of the loop is the right half of the comma operator. Loop prints ten, increments i to 11, divides by 2 to get five (which is still &gt; j), so it prints 5, increments i to 6, divides by two to get 3. The exit condition of the loop is now false, and so it terminates.
So there is literally no point of having the i &gt; 1 in there then? As for the division, does it just take the closest whole number since it's not a float? Meaning i evaluated to 5 instead of 5.5 technically?
Correct, it's integer division
I'm curious where you found this code. It's pretty ridiculous.
If the price prevents you from reading it, then go to a library or google. http://stst.elia.pub.ro/news/SO/Modern%20Operating%20System%20-%20Tanenbaum.pdf http://infoman.teikav.edu.gr/~stpapad/ModernOperatingSystems3ndEdition.pdf http://carment.ase.ro/so/Modern_Operating_Systems.pdf 
Please put four blanks in front of every line of code for the code to come out readable.
To avoid a compiler error/warning. Since &amp;input is of type AnyClass* and not void* But it might depend on the compiler.
C allows implicit conversions to `void*` from any other pointer type.
Looks normal on desktop. I just checked on my iPhone though and there's no spacing. 
Thanks! I had a sudden surge or paranoia that I'd mess system provided gcc package.
This trick is called “pointer tagging” and is well-known among low-level programmers. You shouldn't use this in production code unless the advantages pay off the disadvantage of breaking almost all debugging tools and making garbage collection stop working.
Using `uintptr_t` rather than `unsigned int` would be a significant improvement here
&gt; Here, I am going to assume a system where size of int and size of pointer are 4 byte Not a good idea. You should use `uintptr_t` if available. 
I just read your description and didn't look much into the loop itself. it prints out i, which is 10, then on the second iteration, i is 5 (i/=2). It stops after because 5/=2 is less than 3 which fails (j &lt;i)
That was the solution :) Thanks mate !
Are you looking to hire someone or do you expect someone to do work for free? It's not really even clear what your goal is. _Why_ do you think you need to change that C++ to straight C? 
Now I want to write an xor-linked list that somehow utilizes tagged pointers just to see how terrible the code will look like.
You monster.
Yes. You've written `if(a=3)`. That's not correct.
Yeah--in a perfect world it would run through the digits 0-9 and then only print a number that was four digits (a,b,c,d) and continue. I meant that if either a is 3, or a is 7, or b is 3, etc.