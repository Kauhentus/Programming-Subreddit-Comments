Here's a follow-up tricky (to me) question: within my struct Ccfg is an element called core, of type "struct Core". I have a function compMaps declared thusly: int compMaps(struct Core *A, struct Core *B); I call it as follows: struct Ccfg CC, DD; struct Ccfg *C = &amp;CC; struct Ccfg *D = &amp;DD; d = compMaps(&amp;C-&gt;core, &amp;D-&gt;core); If I want to call it with the nth Ccfg of cardinality c as the second parameter, I was thinking: d = compMaps(&amp;C-&gt;core, &amp;((*S[c])[n].core); but I had pretty close to 0% confidence this would be likely to work, and indeed it doesn't... I am new to these complicated relationships between pointers, arrays, and structs, could someone help me figure this one out?
For that many objects, you should use dynamic allocation. What you are doing is coming out of stack memory, and depending on platform, you can easily exhaust it with what you are doing. Dynamic allocation will come from the heap which has a lot more available. 
It is "not working" because your declarations make little sense and contradict your described intent (I hope it is just a typo). According to your description, your `T`, `U` and `V` arrays are supposed to hold your `struct Ccfg` objects. Yet for some reason you declared these arrays with `solArray` element type instead of `struct Ccfg` element type. Why??? If you want to follow your original approach, then the declarations should look as follows typedef struct Ccfg solArray[]; struct Ccfg T[6], U[200], V[40000]; solArray *S[] = { NULL, NULL, NULL, &amp;T, &amp;U, &amp;V }; However, at this point one should note that an "array of unknown size" in C language is a separate incomplete type. It is not implicitly convertible to any "array of known size" types. So, your initialization for array `S` is invalid. In order to use this specific approach your have to force the conversion by using an explicit cast solArray *S[] = { NULL, NULL, NULL, (SolArray *) &amp;T, (SolArray *) &amp;U, (SolArray *) &amp;V }; Done. Now you can work with your array using your intended `(*S[c])[n]` syntax. -------------------------------- However, the whole ordeal with that "array of unknown size" type `solArray` is not worth it. What you need here is a simple jagged array struct Ccfg T[6], U[200], V[40000]; struct Ccfg *S[] = { NULL, NULL, NULL, T, U, V }; which is now accessible through simple `S[c][n]` syntax.
Oh! Yes the jagged array is exactly what I had hoped for, I didn't realise it could be done so simply. About T, U and V being declared as solArrays, I thought that since I had typedef'd a solArray to mean an array of struct Ccfgs, therefore I could declare arrays of struct Ccfgs as solArrays. It was my first time using typedef... Thank you for your help, I appreciate it. 
I think I have it, again it was simpler than I thought: myFunc(&amp;(S[card][i].core)); It compiles, anyway...
I understand 2D arrays just fine. I just don't understand why you are using them. &gt; The "array that is six things wide" is required for objects of cardinality up to 5 because objects can have cardinality 0; thus there are 6 possible cardinalities. I don't understand what you mean by this at all. This is part of the reason I don't understand why you are using a 2D array here. You have an object which can relate to possibly five other similar objects, so you're throwing them into an array. You have a whole bunch of objects, each of which could have up to five related objects? I guess I can see why you're going with a 2D array. Is it possible for you to figure out the maximum number of total objects? If so: struct object { struct object *related[ MAXRELATED ]; /* object data */ } allobjects[ MAXTOTALOBJECTS ]; Ok, now you make an index of all objects, and map their related pointers to point to their spot in the large single array. Say we have 5 objects, each of which *could* reference 3 others. { { 1, 0, 0, }, { 2, 3, 5, }, { 4, 5, 0, }, { 1, 0, 0, }, { 2, 5, 0, }, } Right? So they really only reference a total of 9 objects. struct objects a[ 9 ]; /* abbreviating */ a[ 0 ].r[ 0 ] = a[ 1 ]; a[ 1 ].r[ 0 ] = a[ 2 ]; a[ 1 ].r[ 1 ] = a[ 3 ]; a[ 1 ].r[ 1 ] = a[ 4 ]; a[ 2 ].r[ 2 ] = a[ 5 ]; a[ 2 ].r[ 2 ] = a[ 6 ]; a[ 3 ]. ... And so on. You have the total number, and as long as the object itself is bigger than a pointer to the object itself, you have saved yourself memory. You basically only allocate the exact number (assuming this is static, and if it's not, why aren't you using dynamic memory allocation?) and then just point at the exact location you need via pointers. Alternately you could store an array of integers representing the index of the reference in the big array.
I have no idea why you won't use dynamic memory allocation for this. You are over-complicating this by not doing so. Your use of the word cardinality without attempting to put it into any other words also makes it hard for me to get your point. I've tried to wrap my head around what you're trying to do to help you simplify your need for multiple indirections and such, but you're just not clear enough for me. I'll let someone else figure it out for you.
He'll also have to store the length of each jagged array some place. For example, if he has { NULL, 1, NULL, 3, NULL, NULL }, he's still going to have to store that his last one is 3.
There are times to use dynamic memory and times to avoid it. There is absolutely no reason to not use dynamic memory in a situation in which it is the right approach. It is a tool, and integral to the C language. Learn how to use it and how to use it well. Then you can decide if you want to avoid it in situations in which you would be better off without it. Pair every malloc() with a free() and you'll be fine, especially for something this simple. It's much better to have these be local variables created via malloc() than global variables, simply because they probably shouldn't be exposed outside of the functions that use them. I almost never use dynamic memory allocation, but that's because most of the things I program on don't have a memory management unit. If you're writing software for a PC, absolutely use malloc!
NASA's cost per line of code is on the order of $1000-100000. Don't try to apply what they do to your average product. If you want to become a professional programmer, you will need to learn to work with more practical standards. No one but the government can afford code like that. You can look into MISRA standards. They also don't allow dynamic memory, but it's a much more reasonable set. You can still use it - you just have to document, justify, and verify that it's done correctly. 
Then you're not good at c
Yes read it.
That's not true. You can always use a struct containing a fixed length array, which you can copy or assign by value. Hell, you can even define a struct inside of a function's scope for a quick array copying operations.
I'm sorry you could not understand my question. I did try to explain cardinality by analogy with polyominoes, but (1) you did not seem to read that bit, and (2) it should not matter--I could have said I wanted to store my structs according to a parameter called "lemon flux polyincapacitance" which can take the values 0 through 5, and it would make no difference to the specific problem I was asking, which was answered very well by Boatmontmorency who showed that ragged arrays are easier to implement than I had thought. I also asked on comp.lang.c under the same title and got two very good answers there. Thank you for trying to help.
Honestly I'm not very far. I've been using a C book from college and reading up on articles titled something like "C for Java programmers". I've never really done pointers so I've been trying to read up about them.
You clobbered something on the stack, probably the environment argument passed to main (third arg along with argc and argv), or even your return value (main returns int). That would be the next thing on the stack. At exit nobody cares you clobbered your own function parameter so no segfault. I bet it segfaults if you set arr[5] to something, but anything less than 5 is OK. It really depends on the compiler output. It may segfault with different optimization settings. 
Yes - thanks, I have the sizes of the arrays stored too, and when I fill them I have a bounds check programmed.
How the hell is this your first assignment in c?
I'll send you over a character counter function for c
&gt; in a given file ...and modify it to where it can take multiple files as input that's what I think is the difficult part of the assignment. If you only had to take input from stdin, which is what I would do first if I was doing this, this wouldn't be too bad. 
gcc doesn't do this either. You were very lucky in the past.
It's situational. However, both ways you written are actually identical. It does not affect compile or runtime. People have their choices when it comes to presenting code... Seeing as you're probably new, a polite suggestion would be to focus less on syntax and presentation and more on what you can achieve and do. Focusing on the trivial things might cause you to lose vision of the bigger image, especially when you're still green. These don't really matter as much as some people would have you think.
Write some code first and show us what you've done to try to solve the problem.
I'm not going to cover the I/O needed to read the file or print the acronyms. I am assuming that we have: int n; // number of sets char* set[n]; // initialized to the set of n strings; will really need to malloc this array char acronym[n+1]; // +1 to allow for '\0' terminator; will need to malloc this as well You then write four functions: - main: calls everything else - file_read: to read in n and the n sets - pick_letter: recursive function to pick and use each letter k from a set i - print_acronym: function to terminate and emit an acronym The code for pick_letter(): void pick_letter(i) int i; { int next_i = i + 1; int k; for (k = 0; set[i][k]; k++) { // iterate through the entire string at set "i" acronym[i] = set[i][k]; // copy the letter in if (next_i == n) // if reached end of sets print_acronym(); else. // go to next level set pick_letter(next_i); } } File_read has to first read line one of the file to get n, the allocate the sets, each element a string of length 11. Then allocate acronym a string of length n+1. Then read the rest of the set strings into their proper place. Lastly should zero terminate acronym[10] with'\0' as this character is always fixed. Main calls file-read and quits if that goes bad. Then calls to pick_letter(0). Then frees allocated arrays and quits. Finally print_acronym simple prints the acronym string.
The threads are created, but you don't wait for them to finish. You can use `pthread_join` for that.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void acronym(int i,int n,char *arr); int main(int argc, char *argv[]) { int n, x, t; char *arr; FILE *finn, *fout; finn=fopen("argv[1]", "r"); fout=fopen("argv[2]", "w"); if(finn==NULL || fout==NULL){ fprintf(stderr, "Error opening files\n"); return(-1); } fscanf(finn, "%d", &amp;n); arr=(char *)malloc(n*sizeof(char)); for(t=0; t&lt;n; t++){ arr[t]=(char *)malloc(10*sizeof(char)); } for(x=0; x&lt;n; x++){ fscanf(finn, "%s", arr[x]); } acronym(0, n, arr); return 0; } void acronym(int i,int n,char **arr) { int next_i=i+1; int k; char *temp; temp=(char *)malloc(n*sizeof(char)); for(k=0; k&lt;strlen(&amp;arr[i]); k++){ temp[i]=arr[i][k]; if(next_i==n){ print(); }else{ acronym(next_i, n) } } return(); } This is what I've got so far. Am I on the right track? I'm having trouble with the allocation of the arr but I think I will figure it out. Is the return correct?
Actually you asked it to handle three char pointers. Array indexes in C start at zero, and you're indexing 1 and 2! 
They are both correct as in they will both compile and run exactly as you are expecting, but you should stick with the latter, as it is much cleaner.
If you malloc() it, you should free() it. Don't forget to free all your mallocs before returning.
It's a matter of style. Columns emphasize symmetry, so the columns (second style) make it more obvious that you are freeing all four things. But putting them all on one line saves vertical space, and is still easy enough to understand. So if this is happens in the middle of the function, putting it on one line might make the function easier to read. 
Segmentation faults are an operating system construct that occur when you try and access memory which the OS has not permitted you to access. Array are a C construct, and C does not do array bounds checking. Technically, if you access beyond the bounds of an array, it is undefined behaviour. That is, the compiler is allowed to generate code that does *literally* anything. You can trigger them in any combination. Your code is hitting the second, but not the first. What is actually happening is likely that you are simply writing data elsewhere on the stack; hello and fucker are static strings, so you are likely just writing beyond the stack frame, which is only slightly broken.
It is an exponent. I probably assumed that was the sign for exponent but i don't know how to fix it. Edit: More specifically, those expressions are needed to make the code most concise and for it to fulfill its purpose in the first place, but i believe its the exponents in particular that is the problem
In C, structs assign by value, while pointers assign by reference (obviously). You can define a struct that contains an array of any predefined length, and by copying the struct, you copy the data inside the array. Here's an example (using C99 designated initializers): int main(int argc, const char *argv[]) { struct array_4f { float data[4]; }; // define struct containing an array struct array_4f A = { .data= {10.1f, -10.01f, 42.0f, 3.14f} }; // assign array as a member of a new struct struct array_4f B = A; // array is copied by value float *c = B.data; // alias to a pointer when needed printf("%f, %f, %f, %f\n", c[0], c[1], c[2], c[3]); return 0; } Note that because this trick only works with stack-allocated structs, It's best used for small arrays. It's pretty useful for passing around small vectors and matrices by-value without dynamic memory allocation.
More generally, whenever you're doing multithreaded code and something happens "sometimes," you have a race condition. Check your program flow, and make sure you're using your locks / mutexes correctly.
Well apparently I stand corrected. I did not know that was possible. &gt; Note that because this trick only works with stack-allocated structs, It's best used for small arrays. It seems to be working for global structs as well. All I have in main() is a **B = A;** and it is still doing a rep movsd with ecx = 4. But maybe that is not C99 standard (I tested with Pelles C).
Each call to pick_letter(i) is going to enumerate all the permutations for a string at level "i". That's what the "for" loop does. If "next_i" is "n", meaning the last level, we print a permutation. We don't stop there though as there could be other permutations.
Use [`fabs`](http://en.cppreference.com/w/c/numeric/math/fabs) instead of [`abs`](http://en.cppreference.com/w/c/numeric/math/abs), since [`abs` calculates the absolute value of an *integer* in C](http://stackoverflow.com/a/3118188). Clang actually gives a warning with `-Wall`: warning: using integer absolute value function 'abs' when argument is of floating point type [-Wabsolute-value] if(abs((larea + rarea)-area)&gt;EPSILON){ ^ note: use function 'fabs' instead if(abs((larea + rarea)-area)&gt;EPSILON){ ^~~ fabs 
Hey, is there an easier way to output the line number containing the beginning of the unterminated comment than I did it in my revised code [here?](http://pastebin.com/jz3T2sNR) Basically I just incremented an integer variable each time a '\n' was detected. Is there something like __LINE__ I could have used instead?
I could get up to 13 significant figures of accuracy by reducing `EPSILON` down to `1e-18`, so I don't see what you mean by bad accuracy? If your concern is that it converges slowly, then it's probably because of the method/algorithm you're using. There are more sophisticated ways to [integrate numerically](https://en.wikipedia.org/wiki/Numerical_integration). However, if you do care about good convergence, it's best to use one of the [proven techniques for calculating π](http://en.wikipedia.org/wiki/Approximations_of_%CF%80#Efficient_methods).
No, it isn't. You just have to enter your code correctly. Put four spaces in front of every line to tell reddit that it's supposed to be code and reddit formats it as code.
No, there isn't. C doesn't track how many lines you read.
Okay so I have a function that iterates through the source string and sets the destination array to the source but I'm not 100% sure if its doing the correct thing nor is it compiling. The error it tells me is that 'initialising makes integer from pointer without a cast'. #include &lt;stdio.h&gt; #include &lt;string.h&gt; char my_strcpy(char dest, char src) { int count; //iterate through string array and set dest to src for(count = 0; count &lt; strleng(src); count++) { dest[count] = src[count]; } return dest; } int main(void) { char str1; char str2 = "Hello world"; my_strcpy(str1, str2); printf("%s", str1); }
A string in C is a pointer to an array of characters (char\* or char[]). A char is just a single character. So the identifiers str1, str2, dest, and src should all be defined as char\*. Furthermore, you need to allocate space for str1 either on the stack (char str1[64]) or on the heap (char\* str1; str1 = malloc(64); ...; free(str1)). 
I agree with this person, but I'm going to add two things: the header you want is called stdio.h, and fibonacci numbers are trivially simple to work out for yourself (if you've been taught the relevant things). if not, I'd recommend bringing it up with your professor, reading a tutorial online (there are literally millions, use google), or talking to your classmates about the material you may have missed in the lecture/seminar.
It all sounds sketchy because the whole situation is ridiculous. It's an Assembly class, and the instructor said day 1 that all codework will be done in C until we start looking at Assembly code (x86). For whatever reason, C was not a prerequisite for the class, so about 5 people in here have any experience with it in a class of 30-35. He has also stated that he doesn't have the time to teach us the whole language, and that we'd have to learn it on the go. And I cant drop this class because a) I need it for my major, and b) it keeps me full time
I doubt your instructor was intending for you to use libraries. That said, this is actually fairly simple as far as math functions go. To give you some hints to go on: scanf is what you will want to use to capture input. For fibonacci, you will likely want a for loop that contains inside of it: next = first + second; first = second; second = next; followed by printing next. You also need a way to handle the beginning of fibonacci such as printing the 1's manually or some other method so that it shows the whole sequence. EDIT: After reading your other comment, I recommend picking up 'C Programming: A Modern Approach' by K. N. King if you wanted a physical book. It is fairly user friendly as far as C programming books go and he has a good way of explaining things.
Then take a look at the resources in the sidebar and teach yourself&amp;nbsp;C.
Not just strictly speaking; it is impossible. You need pointers for `strcpy()` and `strcmp()`.
doesnt work it keeps asking me to input in an infinite loop
Thats weird, on my machine im getting with epsilon 1e-18 im getting this: 3.141593. Could it be something because of my compile option? im compiling it without optimization.
Ah okay! Thanks for the help!
Yeah, I mean, that's correct, and that's what I meant in my comment, but you could fool yourself into thinking you aren't using pointers if you declare `mystrcmp` like this: int mystrcmp(const char s1[], const char s2[]);
&gt; A string in C is a pointer to an array of characters (char* or char[]). No, a string in&amp;nbsp;C is a null-terminated array of characters. The string is the array, not the pointer to the array. Also, `char *` and `char []` are not the same type. An array is not the same as a pointer.
Not immediately related to the deletion of a node with a single child, but your code contains such obvious errors as (*root) == NULL; in line 107. This was supposed to be assignment, apparently.
&gt; I recommend picking up 'C Programming: A Modern Approach' by K. N. King if you wanted a physical book. I second this. I'm using this book to self-teach C and it's pretty great. Covers things nicely and packed full of exercises / problems to do at the end of each chapter to help ingrain what the chapter covered.
I input 0.9180013
Ah, I understand.
&gt; 0.9180013 Oh, my code does contain an error. Instead of double user_number = strtod(buffer, &amp;end); in the cycle body it should have user_number = strtod(buffer, &amp;end); (I edited the original post as well.) The function simply returned `0.0` all the time because of that error. Now, after the fix, it returns the proper value and it works fine with `0.9180013` input. But that still couldn't cause any infinite cycles. Why you are getting an infinite cycle is still a mystery to me. 
Knowing how to do something doesn't make that thing good. I know how to do code blocks here, but it doesn't make it good design.
 struct mystring { char s[BUFSIZ]; }; int mystrcmp( struct mystring s1, struct mystring s2 ) { ... } ... int c = 0, n = 0; for( c = fgetc( stdin ); c != '\n' &amp;&amp; c != EOF; c++, n++ ) { ms1.s[ n ] = c; } ms1.s[ n ] = '\0'; Something like that will probably get you by without pointers, if we ignore the FILE*. The problem would be here when you need to actually change the contents of the passed argument. Then you're going to need a pointer. I suppose you could actually return the "string": s1 = mystrcpy( s1, s2 );
And since we're on the subject: [Arrays and Pointers!](http://c-faq.com/aryptr/index.html)
[code] [/code] Something like that is easy. Put one at the start, one at the end. The problem I have with it is that if I'm not free typing the whole block of code into my post as I go, that I have to then go line by line adding four spaces to make it all line up right. It's tedious. This isn't a perfect solution though, because people always forget to close it or use the wrong slash, etc... I guess the four spaces is actually the better solution, simply because it won't get weird if you happen to have an array with an indexer named *code*.
Pro tip: when working with function pointers, *always use a typedef*. You still have to deal with the messy syntax, but you only have to deal with it in one place. typedef void (*Fn_t)(void); // Note: in C: f(void) takes no arguments, f() takes any arguments typedef Fn_t (*GetSetFn_t)(unsigned int ChipSelectLine); struct { GetSetFn_t GetSetFunction; } GPIO; GPIO.GetSetFunction = &amp;GPIOLib_GetSetFunction; struct { Fn_t Select } Device; Device.Select = GPIO.GetSetFunction(...); Device.Select();
I see. So, homework, then? 
How far have you got? Looking at your code, this seems straightforward, as your not doing anything complex or that would be painful in C like string manipulation. How about giving it a go and asking for help if you get really stuck? /r/learnprogramming might be more suitable if you don't know any C at all.
K and r explains c really well I'm but doesn't exactly cover how to program. If you don't already know stuff like the basics of loops, you're probably going to have a lot of questions k and r won't resolve 
For a designated array initializer to be useful, you have to have a situation where a lot of entries should be initialized to 0. A great case for this are sparse arrays, as you pointed out. The other case I've used them was to place a sentinel value into an array. Something like: int data[20] = { [10] = -1 }; The goal was to create a dynamic list of sorts, initialized to a length of 10. The GNU extension that lets you set a range to a value is more useful, IMO.
Second pro tip: avoiding pointer typedefs makes things easier to read, so typedef the function type instead. 
The entries not specifically mentioned will be null pointers.
&gt; almost everyone I can't say I've seen it done much. "Almost everyone" typedefs struct types in a widespread pattern typedef struct Name { ... } Name; but typedefing pointers has always been considered a questionable style. Typedefing pointers is OK if you are defining an opaque "handle" type, i.e. a type that just *happens* to be a pointer, but is not intended to be used as a pointer by the client code. Curiously, the standard library `FILE *` type is actually a good candidate for being typedefed as a pointer type. `FILE` is an opaque type, which you will never use by itself. You will never dereference `FILE *` pointers, and generally you are not supposed to even care whether they are pointers or not. But nevertheless they force us to add the `*` explicitly for some reason. Probably just a historical quirk...
I wouldn't recommend using a Mac. Most Apple products are targeted to casual demographics There's no doubt that there exists some application for C programing or web design, but it might be hard to find. I instead would recommend using a PC or, even better yet, using one of the Linux operating systems.
I completely agree with what you're saying about typedefing pointers to structures and most primitive types. But I was specifically referring to function pointers. I don't think I've ever seen `typedef void (Func_t)(void);` in code in the wild, even though it's exactly equivalent (as far as I know) to `typedef void (*Func_t)(void);`. Maybe it's because it's still a pointer regardless of how you write the typedef, just like `Func_t fp = &amp;foo;` and `Func_t fp = foo;` are the exact same. Since it's a pointer anyway, maybe we should always write the `*` in there.
I'm assuming by "without pointers" you mean without using any explicit pointer syntax (essentially without any asterisks). Here is how I'd do strcmp() without pointers -- just array syntax: int mystrcmp(const char a[], const char b[]) { int diff = 0; for (size_t i = 0; ((diff = a[i] - b[i]) == 0) &amp;&amp; (a[i] != '\0') &amp;&amp; (b[i] != '\0'); i++) ; return diff; } Here is how I'd do strcpy: char * mystrcpy(char dest[], const char src[]) { for (size_t i = 0; (dest[i] = src[i]) != '\0'; i++) ; return dest; } It is kind of impossible to avoid pointers there.
Well, it is based on the terminal you're running it in. You should be able to change your terminal settings to show latin1 instead; This particular thread talks about a similar thing with konsole -&gt;https://www.centos.org/forums/viewtopic.php?f=47&amp;t=47926 utf8 however is the newer standard; mostly because it is impossible to do things like tell the difference between latin1 and latin2 or to show content with mixed character sets. Some people may have difficulty dealing with extended input on their systems when the default is utf8.
&gt; even though it's exactly equivalent No, actually. They are not equivalent at all. The former declares `Func_t` as *function* type. The latter declares `Func_t` as *function pointer* type. It is true that in *expressions* typically you don't have to explicitly use unary `&amp;` operator and/or unary `*` operator when working with function pointers. This happens because values of "function" type automatically decay to values of "function pointer" type. But in *declarations* function type and function pointer type are completely different, unrelated types. And no, if you declare typedef void (Func_t)(void); you will NOT be able to do Func_t fp = &amp;foo; nor Func_t fp = foo; The above declares `fp` as a function (not as a function pointer). It is illegal to assign anything to a function. The code will not compile. The only context in which `Func_t` (declared as above) would stand for *function pointer* type would be function parameter list. E.g. this is OK void bar(Func_t fp); In this case `fp` is automatically adjusted to function pointer type. But outside of function parameter lists such adjustment is not performed and `Func_t` stands for function type specifically. But I agree, if we restrict consideration to functions and function pointers only, people do indeed often hide pointers inside typedefs.
Hang on, gotta test this again with my compiler ... Ok, never mind. I thought I had thoroughly tested what I talked about before writing that, but I must have had a typo in my code, and what I said was wrong. Have an upvote for the correction.
&gt; "é" should return 233. No it shouldn't. "Extended ASCII" is not a thing, and that site is a complete lie. There are hundreds of different character encodings out there in the world. You would only get 233 if your terminal happened to be using a particular encoding out of those numerous available options that maps é to 233, like ISO-8859-1 or CP1252. But your terminal is not using such an encoding, it's using UTF-8. And for good reason: encodings like ISO-8859-1 are a toxic cancer on the world, and should be avoided at all costs. This is a feature, not a bug. You can always change your terminal (which is probably taking its cues from your locale setting), but don't. 
Why don't you run it and see?
I still dont understand how it works. I edited the OP with some commentary of how I think it works.
The line long *q = p; declares `q` to be a variable of type pointer-to-`long`, and initializes it with the value of&amp;nbsp;`p`. What is the value of&amp;nbsp;`p`? The value of&amp;nbsp;`p` is the address of the variable&amp;nbsp;`y`. So that's the value that is assigned to&amp;nbsp;`q`.
This book is so great that I enabled javascript so I could upvote these posts. I found lots of people saying "just K&amp;R it", but I'd rather just learn the idioms correctly the first time... 21st century c's ToC looks promising too, and I've borrowed a bit of the design style from master algorithms w/ C.
First, read [here](http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues) about lvalues and rvalues, this will be useful. Now, a pointer to a long is a number that represents the location in memory where a long can be stored, but I guess you already knew that right? The following: long *q = p; is possible because `p` is a pointer itself. If it was a value like `y` you would need to use `&amp;` to get its memory address instead of its value: long *p = &amp;y Don't rush it, some things take a while to grok.
Turn it down a notch. You do realize that Unicode is based on ISO-8859-1?
(In main) f1(&amp;y, z, p) // y=5, &amp;y=0x04, z=2, p= 0x04(&amp;y) ... void f1(long *x, long y, long *z) // x, y, z are local to f1. x=0x04(&amp;y in main), y=2(here y is local to f1), z= 0x04( &amp;y in main) y =*x; // x=0x04(&amp;y in main), *x=5(value of y in main), y=5(y local to f1. This value is destroyed when the program exits f1) *z=y; // y=2(y local to f1), z=0x04(&amp;y in main), *z=2(y in main assigned the value of 2) edited formatting and commentary
I managed to get the ISO-8859-1 values just by changing the encoding settings in putty. I wanted to know if the locale dictates the output, but it seems that the terminal have priority. If I do: $ locale I get LANG = en_US.UTF-8 If I set putty (and do not change my .profile) in ISO-8859-1 and do "echo é| ./program" I get : 233 and 10. I compared and I get the same decimal values as the wikipedia page. Here : http://en.wikipedia.org/wiki/ISO/IEC_8859-1
Yes. And if you look at the codepoints, you see that Unicode is an extension of ISO 8859-1.
And I already mentioned that. What on earth is your point? It doesn't somehow mean that ISO-8859-1 is an encoding worth using.
I'd recommend that, rather than changing putty to use something other than UTF-8, you instead use the `iconv` program to handle the encoding conversion: echo é | iconv -f utf-8 -t iso-8859-1 | ./program and as a little tip, you can avoid a 'useless use' of echo by using the 'herestring' feature of the shell (assuming you're using bash or something else that supports herestrings). ./program &lt;&lt;&lt; "a b" &lt;&lt;&lt; "é" iconv -f utf-8 -t iso-8859-1 | ./program
In my case, my program is translating the string in binary and I needed to be represented on ISO-8859-1 because the input will be mainly in french and the binary representation have to be 8 bit. It's a school lecture about c sockets and I guess the point is to make us realise the consequences of character encoding between platforms/terminals with different encoding or legacy choices in some case for old software. 
[Image](http://imgs.xkcd.com/comics/technically.png) **Title:** Technically **Title-text:** "Technically that sentence started with 'well', so--" "Ooh, a rock with a fossil in it!" [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1475#Explanation) **Stats:** This comic has been referenced 94 times, representing 0.1860% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cob5pv8)
Okay, I'll take a stab at this. I like pointers. This is going to be wordy, so please let me know if it's clear. I feel like it's very useful to understand what's going on with pointers, beyond just knowing how to use them, so I've expanded a lot below. As someone else noted, a pointer is simply a type of storage, just like a `long`, `int`, or `char`. As far as I know, pointers are always the same size as an `int` or `long`. 4 bytes on a 32-bit system, 8 on a 64-bit system. We'll use 4 here for simplicity (and because that's how I learned...*ahem* 25 years ago). So line by line, let's roll. Note the address numbers I use below are for illustration purposes only and **don't reflect reality**. All values are **decimal** for simplicity. long x = 3, y = 5, z = 2; We're declaring 3 `long`s here. They take up 4 byes each and the values they're assigned go into memory (let's say variables start at memory address 1000): Name|Address|Value :--|:--|:-- x|1000|3 y|1004|5 z|1008|2 long *p = &amp;y; Now we've declared a **pointer to a long**, and assigned to it **the address of y**. Let's say pointer variables start at address 3000, just to keep things separate and easy to follow. Name|Address|Value :--|:--|:-- x|1000|3 y|1004|5 z|1008|2 p|3000|1004 Notice that `p` is just a storage location that holds a value. In this case the value happens to be the address of another variable. The next line is just a little tricky: long *q = p; Name|Address|Value :--|:--|:-- x|1000|3 y|1004|5 z|1008|2 p|3000|1004 q|3004|1004 This is where it's important to remember that pointers are just variables. We declared `q` as a `pointer to long`, then assigned it whatever is stored inside `p`. `p` happens to contain the address of `y`, but in reality it's just a number. It's just like doing: int myVar = 3; int myOtherVar = myVar; ***** Okay, first function call. f1(&amp;y, z, p); We're calling `f1(1004, 2, 1004);`. See why? `f1(address of y, value of z, value of p);` So now we enter the function: void f1(long *x, long y, long *z) The function is declaring 3 local variables, which accept the passed in values. You can imagine it like this: long *x = 1004; // &amp;y from main long y = 2; // value in z from main long *z = 1004; // value in p from main So our memory map might look like this now--variables local to the functions will start at 5000 and 7000 for clarity: Name|Address|Value :--|:--|:-- x|1000|3 y|1004|5 z|1008|2 p|3000|1004 q|3004|1004 -|-|- y (f1)|5000|2 x (f1)|7000|1004 z (f1)|7004|1004 y = *x; We are **dereferencing** `x` and storing its value in `y`. Basically we're saying "take the value of whatever is stored at address `1004` (since x contains 1004) and stick it in `y`." Now be careful: this `y` is local to `f1()`: Name|Address|Value :--|:--|:-- x|1000|3 y|1004|5 z|1008|2 p|3000|1004 q|3004|1004 -|-|- y (f1)|5000|**5** x (f1)|7000|1004 z (f1)|7004|1004 *z = y; Now we are taking the value of `y` and putting it into the storage location that's in `z` by **dereferencing** it. So we're saying "take the value of `y` and stick it in location `1004`." Again, this is the `z` that is local to `f1()`. Name|Address|Value :--|:--|:-- x|1000|3 y|1004|**5** z|1008|2 p|3000|1004 q|3004|1004 -|-|- y (f1)|5000|5 x (f1)|7000|1004 z (f1)|7004|1004 This is kind of confusing, since we wrote the value of `5` into a variable already containing `5`, so it's not obvious that anything new happened. So we've returned from `f1()` and it's time to see what we did: printf("%ld %ld %ld\n", y, z, *p); Now we can just look at our chart. Value of `y`: 5. Value of `z`: 2. Value of the thing `p` points at (`*1004`): 5. This matches the output I see when I run your code: &gt; 5 2 5 ***** ONE DOWN! Next function call: f2(q, &amp;z); We're sending value of `q` and the address of `z`. So `f2(1004, 1008);` void f2(long *x, long *y) Name|Address|Value :--|:--|:-- x|1000|3 y|1004|**5** z|1008|2 p|3000|1004 q|3004|1004 -|-|- x (f2)|7000|1004 y (f2)|7004|1008 Just like before. Now we just keep doing the same thing: *x = *y; Take whatever is contained at the location stored in `y` (*1008) and store it in the location stored in `x` (*1004). What's at location `1008`? 2. So we stick that into location `1004`, which happens to be the `y` in `main()`. Name|Address|Value :--|:--|:-- x|1000|3 y|1004|**2** z|1008|2 p|3000|1004 q|3004|1004 -|-|- x (f2)|7000|1004 y (f2)|7004|1008 *y = 7; This one's easy. Just stick `7` at whatever memory location is contained in `y`. In this case, `y` contains `1008`, which is the location of `z` in `main()`: Name|Address|Value :--|:--|:-- x|1000|3 y|1004|2 z|1008|**7** p|3000|1004 q|3004|1004 -|-|- x (f2)|7000|1004 y (f2)|7004|1008 printf("%ld %ld\n", *q, z); Back to `main()` we print out the value of what's pointed to by `q`, and the value of `z`: &gt; 2 7 ***** Last one, and the trickiest. *q = f3(*p, *q); So now the return value of `f3()` will be stored at the memory location stored in `q`. The function call translates to `f3(2, 2)`, right? See why? long f3(long x, long y) Name|Address|Value :--|:--|:-- x|1000|3 y|1004|2 z|1008|7 p|3000|1004 q|3004|1004 -|-|- x (f3)|5000|2 y (f3)|5004|2 f2(&amp;y, &amp;x); Uh oh. Things just got weird. Now we're sending the **addresses** of our **local** `y` and `x` into `f2()`. But we can handle that, right? `f2(5004, 5000);` I'll just show the steps, since we talked about the function earlier. void f2(long *x, long *y) Name|Address|Value :--|:--|:-- x|1000|3 y|1004|2 z|1008|7 p|3000|1004 q|3004|1004 -|-|- x (f3)|5000|2 y (f3)|5004|2 -|-|- x (f2)|7000|5004 y (f2)|7004|5000 *x = *y; Name|Address|Value :--|:--|:-- x|1000|3 y|1004|2 z|1008|7 p|3000|1004 q|3004|1004 -|-|- x (f3)|5000|**2** y (f3)|5004|**2** -|-|- x (f2)|7000|5004 y (f2)|7004|5000 *y = 7; Name|Address|Value :--|:--|:-- x|1000|3 y|1004|2 z|1008|7 p|3000|1004 q|3004|1004 -|-|- x (f3)|5000|**7** y (f3)|5004|2 -|-|- x (f2)|7000|5004 y (f2)|7004|5000 And we're back into `f3()`: return x - y; Value of `x` minus value of `y`: 7 - 2. So now we take that result, go back to `main()` and store the value into the memory location inside `q` (because we **dereferenced** it with `*q`). So `5` now goes into memory location `1004`, which is `y`. Name|Address|Value :--|:--|:-- x|1000|3 y|1004|**5** z|1008|7 p|3000|1004 q|3004|1004 printf("%ld %ld\n", *q, y); Finally, we print out our result. The value of what's in the memory location stored in `q`, and the value of `y`: &gt; 5 5
The basic idea for a situation like this is that you'll spin-off your worker threads and then wait them they all exit. Using pthreads, the easiest approach would probably be to make a struct that holds all those params and then pass the address as the parameter to the pthread. It's also easier to just supply space to place the returned area value instead of attempting to stick it into the void * (Since pthread's requires the function return a void *), so add a 'ret' value to it as well. So something like this: struct quad_params { double a, b, fa, fb, area, ret; }; void *quad(void *p) { struct quad_params *params = p; /* Quad code using the 'params' pointer */ } And then, when you call 'quad' recursively, just spin-off two threads with their own 'struct qual_params' objects, and then use pthread_join() on both of them to wait till they exit. So something like this: struct quad_params left_p = { .a = a, .b = m, .fa = fa, .fb = fm, .area = larea }; struct quad_params right_p = { .a = m, .b = b, .fa = fm, .fb = fb, .area = rarea }; pthread_t left_thread, right_thread; pthread_create(&amp;left_thread, NULL, quad, &amp;left_p); pthread_create(&amp;right_thread, NULL, quad, &amp;right_p); pthread_join(left_thread, NULL); pthread_join(right_thread, NULL); The way this code works, both threads run at the same time with their own set of parameters, and then, we join both of them. So by the time the second pthread_join returns, both threads are done running. At this point, it's just a matter of making use of the 'left_p.ret' and 'right_p.ret' values as your new 'larea' and 'rarea' values. As far as the API goes, with you're doing threaded stuff like this it can be common to have a hidden thread function, and then your regular function just kicks off the threaded function with the correct settings. So maybe something like this: static void *quad_thread(void *) { /* Your code in 'quad' would go here */ } double quad(double a,double b,double fa,double fb,double area) { struct quad_params params = { .a = a, .b = b, .fa = fa, .fb = fb, .area = area }; quad_thread(&amp;params); return params.ret; } That way, even though 'quad_thread' takes a 'struct quad_params', you can use the 'quad' function the same as before.
Try a brainfuck interpreter. :) 
https://en.wikipedia.org/wiki/Brainfuck
Sounds great, thanks y'all. Weird I've never heard of this before tho
+1 It is a nice exercise, easier than it first seems.
One which can remove superfluous apostrophes from sentences. ;-) /s 
That is actually the point of this assignment if I recall my OS course correctly.
Just wanna say, thanks a lot for the help, i did not expect such a thorough answer. I started changing the code and came up with this: /*Trampoline function for threads to quad function */ double quad(double a,double b,double fa,double fb,double area) { struct quad_params params = { .a = a, .b = b, .fa = fa, .fb = fb, .area = area }; quad_thread(&amp;params); return params.ret; } /* Will approximate pi with adaptive quadrature routine*/ void *quad_thread(void* p){ struct quad_params *params = p; double m = (params-&gt;a+params-&gt;b)/2; double fm = calcPoint(m); double larea = ((params-&gt;fa + fm) * (m-params-&gt;a))/2; double rarea = ((fm + params-&gt;fb) * (params-&gt;b-m))/2; if(fabs((larea + rarea)-params-&gt;area)&gt;EPSILON){ struct quad_params left_p = { .a = params-&gt;a, .b = m, .fa = params-&gt;fa, .fb = fm, .area = larea }; struct quad_params right_p = { .a = m, .b = params-&gt;b, .fa = fm, .fb = params-&gt;fb, .area = rarea }; pthread_t left_thread, right_thread; pthread_create(&amp;left_thread, NULL, quad_thread, &amp;left_p); pthread_create(&amp;right_thread, NULL, quad_thread, &amp;right_p); pthread_join(left_thread, NULL); pthread_join(right_thread, NULL); larea = left_p.ret; rarea = right_p.ret; } params-&gt;ret = larea + rarea; } I then call the code in main /* set global thread attributes */ pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM); struct quad_params input; input.a = 0; input.b = 1; input.fa = calcPoint(0); input.fb = calcPoint(1); input.area = (calcPoint(1)+calcPoint(0))* (1-0)/2; start_time = read_timer(); Pi = 4*quad(input.a,input.b,input.fa,input.fb,input.area); //Pi = 4*quad_thread((void *)&amp;input); end_time = read_timer(); printf("Pi was approximated to %.13g\n", Pi); printf("The execution time is %g sec\n", end_time - start_time); Now the issue is that when I start the program, it will quickly freeze my system (a VM with ubuntu) for a bit and will never finish running, I guess the issue is that i'm running out of memory or im just doing something wrong in the code? I'm getting no warnings btw. And again, thanks a lot
Implement a (very) simple arbitrary-precision arithmetic library. that will make you practice * array * pointer * structure * memory allocation * string here a skeleton to implement #include &lt;stdbool.h&gt; // for bool type #include &lt;stdlib.h&gt; // for size_t type struct number; // incomplete type typedef struct number number; // sugar // for errors reporting typedef enum { ERROR_NONE, // if no error ERROR_UNDEFINED, // generic error ERROR_NULLPOINTER, // if one of the arguments is a null pointer ERROR_NOT_INITIALIZED // if the number object has not been initialized // ... } error; // initializes a number object error number_init (number **n); // prints the number object's digits to stdout error number_print (const number *n); // sets the number object's digits from a string error number_from_string (number *n, const char *s); // sets d's value to how many digits a number object has error number_digits (const number *n, size_t *d); // elementary operations // result = a OPERATION b error number_add (const number *a, const number *b, number *result); error number_sub (const number *a, const number *b, number *result); error number_div (const number *a, const number *b, number *result); error number_mul (const number *a, const number *b, number *result); /* compares two number objects's digits returns: negative value if a &lt; b zero if a = b positive value if a &gt; b */ int number_cmp(const number *a, const number *b); and a test case void test (void) { number *na; number *nb; number *nr; number *nt; number_init(&amp;na); number_init(&amp;nb); number_init(&amp;nr); number_init(&amp;nt); // Comparison number_from_string(na, "577934405665047976"); number_from_string(nb, "384456244062859292"); printf("cmp a &gt; b: %s\n", number_cmp(na, nb) &gt; 0 ? "Pass" : "Fail"); printf("cmp a &lt; b: %s\n", number_cmp(na, nb) &lt; 0 ? "Pass" : "Fail"); printf("cmp a = a: %s\n", number_cmp(na, na) == 0 ? "Pass" : "Fail"); // Addition number_from_string(na, "163410108723315893786007258644477071531"); number_from_string(nb, "-140852680435966298937873389594651628948"); number_from_string(nt, "22557428287349594848133869049825442583"); number_add(na, nb, nr); printf("Addition: %s\n", number_cmp(nr, nt) ? "Fail" : "Pass"); // Subtraction number_from_string(nt, "304262789159282192723880648239128700479"); number_sub(na, nb, nr); printf("Subtraction: %s\n", number_cmp(nr, nt) ? "Fail" : "Pass"); // Division number_from_string(nb, "86589965722640346"); number_from_string(nt, "1887171421764285094709"); number_div(na, nb, nr); printf("Division: %s\n", number_cmp(nr, nt) ? "Fail" : "Pass"); // Multiplication number_from_string(nt, "14149675713084855434588701768590752412528188375228589726"); number_mul(na, nb, nr); printf("Multiplication: %s\n", number_cmp(nr, nt) ? "Fail" : "Pass"); } after that, you can add more operations (power, sign, exp, ...) or code a [REPL](http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop).
It's somewhat hard to say, mostly because I don't know what the algorithm your using is. You have confirmed that the non-threaded version works as expected correct? How many levels of recursion do you think normally happen in your program? It's possible that threading the solution like this slows everything down because you're just starting too many threads at once, resulting in lots of context switches and a big memory over-head. Keep in mind, we start two threads *per thread*, so the number of threads running doubles every level of recursion (If you count the main thread). Main Thread - Level 1 (1) Worker Thread Worker Thread - Level 2 (3) Worker Thread Worker Thread Worker Thread Worker Thread - Level 3 (7) Trd Trd Trd Trd Trd Trd Trd Trd - Level 4 (15) Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd Trd - Level 5 (31) If your function goes 5 levels deep, that's already 31 threads it has to spin-up. Level 6 alone will require another 32, resulting in 63 total threads. In general I'd say you don't want that many threads going at once. This *might* be why it's locking up the VM. If you're running Ubuntu, I'd recommend grabbing `htop` and running it in a terminal when you run your program and watch what it says. You could also try running your program in `valgrind` and see what happens, it might give you some better information. You should consider having a 'run_thread' flag in the quad_params, which if not set to 1 means to just call the functions straight rather then spin-up a thread. That way, past level ~3 or so you could set that flag and keep your program from creating any more threads. Having 7 threads going is probably a good number overall, maybe a bit high depending on the CPU.
Right, as i'm demanding rather high precision for calculcating pi, I guess its creating way too many threads
Also, Now that I think about it, our teacher always goes on about dealing with these kinds of problems with a "bag of tasks", for example for the matrix sum program every row represented a task, I'd create a certain number of threads and every threads routine would just grab a task until all rows was dealt with which I kept track of with a shared variable "row counter". Could something similar be done with this kind of problem?
Stop. If you want to ask questions, then ask questions. But stop spamming all the programming subreddits with offers of payment if people will do your homework for you. https://www.reddit.com/r/learnprogramming/comments/2uu9hw/paying_for_help_with_c/
If you enjoy world creation, you could write a simple roguelike using curses or OpenGL for graphics. Personally, I'm doing just that using [Zoo](http://happyponyland.net/zoo.php) as a starting point.
Omg if you mean the title of this thread, about the word "Idea's", I was very tired yesterday and I used dutch grammar...
THIS. And I will start immediately! Thank you!
I'd say using GL for graphics is rather an advanced project, though.
[Project Euler!](http://www.projecteuler.com)
Check out some bin-packing algorithms. 
Please at least read what he is supposed to do. Edit: what a nice guy. Remembers to always downvote everything if caught bullshitting
Take small steps. 1. Check x and y Position to find out the range from your to their ship. 2. Create List (just use a doubly linked list if pure C, C++ gives you tools) with all the ships in your firing range. 3. If they do not carry the same flag as you do, fire on the first ship in the list. You now have a battleship that can kinda fight. At that point, you can go and improve. 1. Fire at Low Health ships first 2. Fire back at ships that hit you 3. If a majority of ships in your firing range carry the same flag, consider changing to that flag. But really, get started with simple code that only fires on ships in firing range.
Read the `scanf` documentation: http://man7.org/linux/man-pages/man3/scanf.3.html The `%[...]`&amp;nbsp;specifier matches a nonempty sequence of characters from a set of expected characters, and stores the resulting string in the memory location given by the corresponding pointer argument. The characters inside the square brackets are the allowable characters to read; so `%[abc]` means "read a string, but only the characters `'a'`,&amp;nbsp;`'b'`, and&amp;nbsp;`'c'`." The first character in the input stream that is not `'a'`,&amp;nbsp;`'b'`, or&amp;nbsp;`'c'` will cause `scanf` to stop reading the string and return what it has read so far. So, if your code has `scanf("%[abc]", swag)` and the user types `bacaabccxbac`, then the string `"bacaabcc"` will be stored in `swag` (the `'x'` in the input stream causes `scanf` to stop). If the first character inside the square brackets is a caret,&amp;nbsp;`'^'`, then the meaning is reversed—the set of allowable characters is everything *not* in the brackets. So `%[^\n]` means "any character *except*&amp;nbsp;`'\n'`."
Yeah you're right, I should have. But not good enough to know if [^\n] was exclusive to scanf or not. So tried to google [^\n] instead which was impossible to find result.
not specifically for this case, but scanf can be a lot more powerful for quickly reading in data that is properly formatted; contrast this with fgets, where you need to do all the necessary conversions yourself.
I've been coding C for over 30 years and I NEVER use scanf()/_snscanf(). The only time I ever see it is when helping students with assignments given by professors who don't really know/use C.
Well, the syntax is based on regular expressions, but it's not really the same thing. So, if your searching happened to find that first, you would have just been more confused.
Yes, that was my joke. Don't worry, your English is far better than my Dutch!
What do you mean "not working"? That is not a useful description of the problem. Is it failing to compile? If so, what error message are you getting from the compiler? Is it failing to run at all? If so, are you getting an error message or any other indication of what the problem is? Is it running fine but returning incorrect results? If so, what input are you giving to the program, what output is it producing, and what is the expected output? http://www.catb.org/esr/faqs/smart-questions.html#code
I'm sorry, I did not give a clear description of what's perhaps the most important things. I will definitely learn to do so from now on. I'm using xcode and the output screen is showing this: Please enter the first digit: 222 Please enter the second digit: 111 Please enter your logical operator: + Program ended with exit code: 0 That's it. It's not giving any compiling error, just not doing the calculations. My screen looks neat too, without any warnings. Would you like a screenshot?
The `%c`&amp;nbsp;specifier in a `scanf` string does not skip leading whitespace like the other specifiers. After the `scanf` call on line&amp;nbsp;21, there's still a newline character&amp;nbsp;(`'\n'`) in the input stream waiting to be read, and that newline character (not the following `'+'` character) is what is read by the `%c` specifier. To skip leading whitespace, put a space before `%c` in the format string: `scanf(" %c", &amp;operator);`
There is a lot involved in writing an emulator, even once you have the basic CPU, Graphics and Memory emulation done (well mostly done), there is usually a ton of IO and timing issues to work out. Just be sure you know what you are getting yourself into.
Yeah I understand that but I am determined to start and work on this project nonetheless.
good on you for even knowing how to do it. I get lost trying to modify a single nes roms hex code 
I googled allegro and came across [this page](https://www.allegro.cc/depot/FakeNES/) on the allegro community website.It seems that if you already familiar with allegro then that page will be a good resource for you. 
I'm doing something similar, but in a different language. I haven't gotten to the APU yet and my PPU code is in its infancy, but I have gotten my 6502 emulator working pretty well at this point. Here are the relevant (non-language-specific) resources I have saved in my project's wiki: * The [Wiki](http://wiki.nesdev.com/) and [Forums](http://forums.nesdev.com/) and other information at http://nesdev.com/ * [This handy 6502 Reference](http://www.obelisk.demon.co.uk/6502) from http://www.obelisk.demon.co.uk * And [this one](http://www.6502.org/tutorials/6502opcodes.html) from http://www.6502.org
Do a gameboy first, it's orders of magnitudes easier and less code.
Out of curiousity, what makes it so much easier?
In addition to this, easier graphical and audio functionality that needs accurate emulation.
As an additional note, your `i` and `j` are declared with `int` type (signed), while `x` and `y` are declared with `unsigned int` type. Why the inconsistency?
Take a look at my [6809 emulator](https://github.com/spc476/mc6809) as it might give you some ideas as to an approach to take. One aspect I found challenging was setting the overflow flag properly (used to denote signed integer overflow; the carry is used to denote unsigned integer overflow). Also, handing BCD was even harder (for the 6809, that's just a single instruction; for the 6502, there's a flag to set binary or BCD arithmetic). 
I don't know about the book. But I took 3 courses with Dr. King in college at gsu. The guy is a phenomenal teacher. 
Because saving vertical space is a thing in 2015. Bit of a stretch. I'd have to agree with one statement per line. No need to make implications that may not interpret as well as they intend to.
[This isn't in C, but bisqwit did a video of him making one in C++](https://www.youtube.com/watch?v=y71lli8MS8s). You might be able to gather some useful info from it.
https://answers.yahoo.com/question/index?qid=20080521100946AA0iZ1B
"#"
C is a low level language that requires you, the programmer, to handle, maintain, and keep track of all of the memory that you allocate or destroy. It's difficult to work with if you don't understand how to use that to your advantage, but it can greatly pay off in the end because it will ultimately be faster and more efficient since you are in control of everything that's stored in memory. You tell it when to allocate blocks of memory and when to ultimately destroy them. C#, on the other hand, (or any OOP language for that matter) handles almost all of the dirty work for you. All you have to do is know what classes to use, and how and when to use them. It handles all the memory management, garbage collection, and everything else for you which is what makes it high level. You don't need to have very much understanding of how memory works in order to make use of C#. The problem with this is that letting .NET or the JVM handle the memory means that it will hold onto things that might not necessarily be useful anymore and it will ultimately be much more memory intensive than a C program that functionally does the same thing.
Well they can't really be interchanged. An int is used to represent integer numbers (+- whole numbers). While a double is used to represent a double precision floating point number. The actual size of each is system dependent but a double will be two times the size of a float. I'd recommend reading up on this with an intro to C tutorial or even just something on basic datatypes. 
Is a float different from floating point? 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Floating point**](https://en.wikipedia.org/wiki/Floating%20point): [](#sfw) --- &gt; &gt;In [computing](https://en.wikipedia.org/wiki/Computing), __floating point__ is a method of representing an approximation of a [real number](https://en.wikipedia.org/wiki/Real_number) in a way that can support a [trade-off](https://en.wikipedia.org/wiki/Trade-off) between range and [precision](https://en.wikipedia.org/wiki/Accuracy_and_precision). A number is, in general, represented approximately to a fixed number of [significant digits](https://en.wikipedia.org/wiki/Significant_figures) (the [significand](https://en.wikipedia.org/wiki/Significand)) and scaled using an [exponent](https://en.wikipedia.org/wiki/Exponentiation); the base for the scaling is normally two, ten, or sixteen. A number that can be represented exactly is of the following form: &gt;&gt; &gt;For example: &gt;==== &gt;[**Image**](https://i.imgur.com/G5x0JFS.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Z3_Deutsches_Museum.JPG) - *An early electromechanical programmable computer, the Z3, included floating-point arithmetic \(replica on display at Deutsches Museum in Munich\).* --- ^Interesting: [^Floating ^Point](https://en.wikipedia.org/wiki/Floating_Point) ^| [^Floating-point ^unit](https://en.wikipedia.org/wiki/Floating-point_unit) ^| [^Double-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) ^| [^IEEE ^floating ^point](https://en.wikipedia.org/wiki/IEEE_floating_point) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cocta29) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cocta29)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Ah, okay. Thanks. 
&gt; #ifndef inline &gt; #define inline __inline &gt; #endif `inline` is a keyword in C99. This will break on any C99-compliant compiler. It should be protected inside `#ifdef _MSC_VER`. &gt; m[i][j] = a[0][j] * b[i][0]; \ &gt; for(k = 1; k &lt; dim; k++) \ &gt; m[i][j] += a[k][j] * b[i][k]; \ Uh, why did you manually unroll the first iteration of a loop? Also, note that the index convention in your library appears to be the reverse of the ordinary mathematical convention, where a matrix would be multiplied as: m[i][j] = ∑[k] a[i][k] b[k][j] Not necessarily a big deal but that should probably be clarified in the docs somewhere. Personally I find the macro-esque way of defining things very noisy and I figure there's probably a more convenient way of doing it than using `#define` for every function.
The word "float" is also sometimes used colloquially to refer to "floating point" as well.
Float(or double): you want to find the average of 10 and 3 and store it in a variable d you would need a float since it doesn't divided evenly. Int: you want to keep track of how many time you have completed a loop. You don't need partial loops counted so you would use an int (or an unsigned int). As a general rule, always always use ints if you can. Floats are not exact in programming and as such introduce error to calculations which will bite you at some point. Integer overflow will also probably get you at least once but the approximate calculations from working with floats can be unintuitive.
I think that in the case of your function the parameters names should reflect the intent better than the comment. Commenting is useful when dealing with specific cases hard to explain by naming, or to flag legacy code and so on. You can have a look at the linux kernel, or some other big projects, they usually are full of well-written comments to describe the internal mechanics because it is dispatched among many files so a remainder of who does what is often welcome. [Here](http://blog.ram.rachum.com/post/103051530508/code-comments-that-i-find-helpful) is an article on code commenting that you may find useful.
Contrast with the following signature that explains the same thing without the need for a comment: void convert_number_to_hex(double*number, int*result) (Side note: why wouldn't you just return an int instead of manipulating the result by pointer?) In general, you should aim to write code that doesn't need comments to explain its intent, but in many cases it's helpful to throw in comments anyway, especially to hilight complex sections of the code. The article linked to by /u/cym13 also seemed spot on.
&gt; but a double will be two times the size of a float. This is actually a wrong statement. On some systems, `double` and `float` are the same type and on some one isn't twice the size of the other.
Agreed, this is something important that I learned a bit late: you can do away with a lot of comments if you just name your functions and variables thoughtfully. Also, when dealing with variables that have units, including those units in the variable names helps with explaining as well as make errors stand out. Like `frequency_inHz`, or `length_inInts`.
&gt; inline is a keyword in C99. This will break on any C99-compliant compiler. It should be protected inside #ifdef _MSC_VER. Thanks for the tip, I'm working with visual studio so I've encountered more quirks like this. Manually unrolling the first loop iteration is an alternative for setting the element to zero first and then adding x times, it's a tiny bit faster. I'm using macro's because I can then create n-dimensional vectors for any dimension which I needed in a project. I admit it looks bad. I'm considering to create functions for 2 and 3 dimensions only and add functions with the number of dimensions as an argument, optimization is only really required for 2d and 3d.
Thank you for pointing this out. I'm not quite an expert in linear algebra yet. In the matrix multiplication function where matrix a and b multiplied give matrix m, a and b are constants. Multiplying in place would require a temporary copy. I think it'd be nice to have a separate function to do this.
GSL is GPL licensed, unfortunately, limiting its usefulness. 
also `open`, `close`, `read`, `write`
&gt; Well they can't really be interchanged. People used to use [fixed point](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) math because they didn't have floating point libraries.
&gt; Manually unrolling the first loop iteration is an alternative for setting the element to zero first and then adding x times, it's a tiny bit faster. Have you verified if this is true on a typical optimizing compiler?
Awesome, this is exactly what I needed. Thanks for your very direct and understandable explanation.
Some still nitpick it in the Junior level courses, some do not, and some dock you points if you DO comment. Their reasoning is that your code should speak for itself in all cases and nobody in the industry actually comments their code, even in big collaborative projects. While I'm all for readable code, I think they went from one extreme to the other...
Those are not Standard C functions . That's not to say they shouldn't be used, but in my experience if you can stick to the standard it saves you time in the long run. 
C# is a language like Java (interpreted/jit-compiled custom binary code), and it has a very large library to go along with it (just like Java). It has no similarities with C other than in name only. C# is great for prototyping and creating visual applications like accounting programs, point-of-sale, etc. It is great for making business software. While C can do these things as well, it was originally designed for lower-level software, predictable I/O processing/timing, and systems development, so it is not as fast to develop and deploy business software. C's library is very tiny compared to C#'s, so C developers either have to do everything themselves, or rely on other people's library code from the internet. C# has a library function for pretty much everything you'll ever need.
GSL's vectors and matrices appear to be optimized for large ones (e.g. numerical analysis), whereas the OP's library appears to be tailored for small ones (e.g. game graphics), which is more like [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page).
&gt; I'm using macro's because I can then create n-dimensional vectors for any dimension which I needed in a project. I think it would be easier to do it like this: #define concat3_(x, y, z) x ## y ## z #define concat3(x, y, z) concat3_(x, y, z) #define ccVecName(x) concat3(ccVec, dim, x) typedef float ccv_type; static inline void ccVecName(Zero)(ccv_type *vec) { ... } #undef ccVecName #undef concat3 #undef concat3_ You probably don't want `#pragma once` for `ccVector.h` as the user might be interested in having multiple dimensions available. You also don't really need the absurdly long name for `_CCV_VEC_TYPENAME` as long as you `#undef` it afterwards. It's also a bad etiquette to use names that begin with `_` followed by a capital letter as they are reserved by the C++ standard.
[wow so accurate, very nice](https://github.com/dogescript/dogescript)
These are interesting results! I think the compiler might take some size ratio into account when unrolling, it would be unfortunate if 4d matrix multiplication doesn't unroll well. I have investigated preprocessor for loop implementations, but they were hacky and obfuscating, and the preprocessor has a rather small depth limit in most compilers so I didn't want to go that way. It wouldn't scale well either. GCC has a [pragma directive called funroll-loops](http://gcc.gnu.org/onlinedocs/gcc-3.4.4/gcc/Optimize-Options.html) that can be used to persuade the compiler to force unrolling, but it wouldn't be very pretty to optimize the code for specific compilers unless the difference is really significant.
You're quite welcome. It gave me something to do at work. You know, when I'm supposed to be coding for work :) 
The c code will be much more verbose than the equivalent shell script. It'll also take longer to write and debug.
Sure. Sometimes I can do it faster by writing a quick C program than any other way, but that's just because I know C and POSIX reasonably well. It will generally be harder and less maintainable, though. What you are talking about is usually called systems programming. The classic books are by the late Richard Stevens. Look for APUE.
Thanks for the recommendation! I have another book in this series. I really like it!
Frankly, if I saw that code, what I'd REALLY be wondering about is the fact that I can't figure out what it means to convert a floating point number to an int in hex. What does an int look like when it's in hex? Ints are in the whatever the native binary format is (usually two's complement).
&gt; I know that you have access to all of the unix commands via unistd.h Write a C program that calls three commands and connects them via a pipe: a | b | c (without simply calling `system(3)`, since that would be shell scripting). You'll quickly see why people prefer shell scripting over C for certain tasks.
Pipelining is tricky business :(
I've written C programs like this for many years. There is less reason to do it now. Back in the early 80's computers were SLOW and shell scripts of any complexity took forever to execute. I still write a lot of little utilities in C, but I often tie them together with a scripting language. One advantage to writing interpreted code over compiled code, regardless of language, is that you inherently still have the source to interpreted programs. I can't tell you how many times I've had to rewrite a utility program because the source was lost, but it's been a lot. You can lose a script, but you can't lose the source for it.
It's just a call to pipe(), then fork(). Close receiver end in parent &amp; close sender in child. Not hard. 
Platform? As in, windows, linux etc.? And I'm using Code:Blocks.
I'm on windows. So I'll just try searching through my folders. Might also try making the output location more explicit.
*sigh* I did explicitly mention **for certain tasks** in my comment. I don't know what you try to achieve by listing one of endless number of tasks that might be better handled by something other than shell scripting.
Can you believe some piece of trash downvoted working code.
I do this too... I happen to know awk very well, but I find shell scripting (in bash) to be clunky, at best. I also know C++ backwards (and C), and have a great toolset (libraries of existing code) that makes dealing with this sorta stuff simple. Although, I will more often just use Python or Ruby. Everyone always says, "right tool for the job", but if I'm the only person that is ever going to look at a piece of code I write, I'm not likely to invest in battling bash if I can get the job done in half an hour with some other language I'm already well versed with (actually, it's more the libraries and support than the language itself). 
Lets see the code!
BTW, is `n` (the number of Taylor series iterations) declared as a `double` variable in your case? Is it supposed to be specified by a floating-point value? Also, you use format `%lf` to print `j`, which is of type `float`. This will work properly, but is rather inconsistent. Typically `%f` is `float`, `%lf` is `double`, `%Lf` is `long double`. (And why is `j` suddenly `float`, when everything else is `double`?)
Good points. I'ma sort those out now. Many thanks.
Unknown. Seems plausible though. 
I'd also be interested in hearing about this.
Come on crackez, I checked your history. I'm sure you know how to do it. Grumble...grumble: #include &lt;unistd.h&gt; #include &lt;assert.h&gt; #include &lt;stddef.h&gt; #include &lt;fcntl.h&gt; constexpr size_t N = 5000000000; // Reads may be short, technically. void read_n(int fd, void *buf, size_t n) { char *p = (char *) buf; while (n &gt; 0) { int rv = read(fd, p, n); assert(rv &gt; 0); p += rv; n -= rv; } } // Writes may be short also, technically. void write_n(int fd, const void *buf, size_t n) { const char *p = (const char *) buf; while (n &gt; 0) { int rv = write(fd, p, n); assert(rv &gt; 0); p += rv; n -= rv; } } int read_at(int fd, size_t pos) { int i; off_t rv_off_t = lseek(fd, (pos - 1)*sizeof(int), SEEK_SET); assert(rv_off_t != (off_t) -1); read_n(fd, &amp;i, sizeof i); return i; } int write_at(int fd, size_t pos, const int i) { off_t rv_off_t = lseek(fd, (pos - 1)*sizeof(int), SEEK_SET); assert(rv_off_t != (off_t) -1); write_n(fd, &amp;i, sizeof i); return i; } int main() { int rv; int fd = open("file", O_RDWR); // 1-based index var. for (size_t i = 1; i &lt;= N/2; i++) { const int n_beg = read_at(fd, i) + 1; const int n_end = read_at(fd, N - (i - 1)) + 1; write_at(fd, i, n_end); write_at(fd, N - (i - 1), n_beg); } rv = close(fd); assert(rv == 0); } This will be slooooooowwwwww. Batching for much better performance is left as an exercise for the reader. Note that I used syscalls rather that C stdio, though it would technically be better to use that. EDIT: BTW, this took me about a half-hour. It would have taken me longer to do with a bash script. But for others, maybe it would be faster with a bash script. (I actually don't even know how to do it with any of the standard UNIX tools like sed, awk, bash, etc.) When it comes to little tasks like this, it all depends on the task at hand and what you know. EDIT: The code is actually written in C++, technically. (C++11, to be specific.) EDIT: The code is probably not strictly POSIX-robust, since I don't check for EINTR. I'm not sure whether or not EINTR can be returned for a file-based operation, though of course it can be returned for a pipe/socket based operation. EDIT: It occurred to me that this would be MUCH better with mmap(): #include &lt;unistd.h&gt; #include &lt;assert.h&gt; #include &lt;stddef.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/stat.h&gt; constexpr size_t N = 5000000000; int main() { int rv; int fd = open("file", O_RDWR); assert(fd &gt;= 0); struct stat statb; rv = fstat(fd, &amp;statb); assert(rv == 0); void *vp = mmap(0, statb.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); assert(vp != MAP_FAILED); int *a = (int *) vp; for (size_t i = 0; i &lt; N/2; i++) { int *beg = a + i; int *end = a + (N - (i + 1)); int t = *beg; *beg = *end + 1; *end = t + 1; } rv = munmap(vp, statb.st_size); assert(rv == 0); rv = close(fd); assert(rv == 0); } 
Why would I downvote your code? Just because I pointed out that you need a few more syscalls to truly duplicate the pipeline that a shell sets up?
Many languages offer libraries to make such things easier. E.g., Ruby's Shell, Python's sh, Haskell's HSH or Shelly. There are also certainly ways to make it a bit better in C. But it still seems to be the prime task for shell scripting. I think bash scripting isn't even that bad if you use bashisms. It only gets bad when you have to try to write portable sh scripts. And despite its ugliness it seems to be a universal language in the sense that most programmers are capable of using it.
Not at all. I saw that you were the person who posted the pipeline code, which looked right upon a quick scan. If you could do that, you very likely could write a simple program to do some reads/writes/seeks.
I use it in combination with shell scripting. If I knew perl, I'd be less likely to, but there are a lot of things that I do that are really sensitive to performance and don't adapt well to pipes and whatnot. Apue, and a few others are quite helpful. I'll try to hunt them down when I get home. I believe advanced Unix programming is the name of the other. Otherwise, spend time truly understanding pointers and the standard library. You'll build enough stuff that you won't spend THAT much longer coding in C for anything that is nontrivial in shell.
I was hinting at being outside the realm of simple solutions.
C is not a scripting language.
Cool. The thing I hate about bash is the escaping; if you're running one bash script that calls another script that uses another script.. do you need 4 backslashes or 8 backslashes for that embedded quotemark?
brah, implicit rules... you could probably have: CFLAGS += -O2 all: seive generator clean: -rm -f seive generator
The thing about the shell is that it exposes a lot of other programs as APIs, with a focus on flexible composition. On the other hand, a language like C has a BYOA (bring your own application) attitude, and you generally build up your program from a number of very simple core functions and system calls rather than complete and complex programs. Composing utilities is a huge benefit for system administration and many other jobs that you can do from a shell but want to automate. While you *can* (for example) manage network interfaces in C, it's a giant PITA and you can do it much more quickly with shell scripts. Any turing complete language could be stood in for one another, but some types of jobs lend themselves to some types of languages. C isn't a scripting language at heart, so I personally don't use it as one. If I find that the job I need to do is too 'heavy' for bash, I'll generally switch to python.
The *most* go to code element is undoubtedly the goto statement. It is used when you want to go somewhere. Alternately there is the loop and the function call. These elements are also go to, in character if not in pronounciation.
&gt; Can I ensure the order of variables in memory will be the same as how they are declared? No, the C&amp;nbsp;specification itself makes no such guarantee, except for the members of a `struct`. &gt; Is there usually a linker option to make it do that? Read the documentation for your linker.
break and continue are my favorite gotos in disguise
&gt; I know C works in ANSII, but does that mean it could interpret something like a &lt; z? Would I have to convert it to an ASCII code to check? You are confused about a few things here. ANSI is the American National Standards Institute. "ANSI&amp;nbsp;C" is the name of the C&amp;nbsp;language specification (usually applied to the C89/C90 version) that was published by this organization. "ANSI" has nothing to do with a character set or encoding. ASCII is the American Standard Code for Information Interchange. This is a character encoding scheme. Almost certainly you are working with a machine that uses ASCII or a superset of ASCII. In this case, the characters `'a'`,&amp;nbsp;`'b'`,&amp;nbsp;...,&amp;nbsp;`'z'` are contiguous, so adding&amp;nbsp;1 to any lower-case letter from `'a'`&amp;nbsp;to&amp;nbsp;`'y'` will yield the next lower-case letter, and expressions like `'a' &lt; 'z'` work the way you expect. (Strictly speaking, this is not a portable assumption, because there do exist machines that use strange character encodings like EBCDIC in which the lower-case alphabet is *not* contiguous.) Read this for more information: [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html)
Very informative, thanks
switch is goto in lingerie.
brah, do you even serialize your data?
1) llvm/lldb/clang aren't related to gcc and gdb. 2) There's no standard compiler, and there's really no such thing as *unix or *nix. 3) llvm is open source, apple uses a different binary format and different debugging interfaces--So why shouldn't they customize llvm with their "grimy paws?" 4) llvm/clang &gt;&gt;&gt;&gt;&gt;&gt;&gt; gcc, did you notice the fantastic static analyzer that can actually tell you where a missing semicolon was?
While 1. 
I use a lot of [Arthur's macros](http://kparc.com/cs/c.h).
1) Yep. I could have phrased that better in the article :P 2) What compiler is used on Linux/BSD other than gcc? There are simple alternatives like tcc, but nothing that's seriously used, and clang isn't that common in Linux/BSD environments. 3) Ah, but why does Apple have to use a different binary format in the first place? Everything Apple does (development-wise) is non-standard and different than what everyone else does. It's different enough that I have issues with developing on OS X on a regular basis Frankly, I should just switch to Linux, as I agree with the philosophy more than I agree with Apple's. I've just had some issues running Linux on Apple hardware. 4) Totally agree with you about the functionality of clang being better than gcc. I'm not a fan of GNU and think the majority of their software is bloated and over-engineered (including gcc). However, gcc is written in C, and clang is written in C++. You may not have a problem with this, but I do. I don't like C++ as a language and I don't like the design of software that comes out if it. Clang is a good compiler and I do appreciate some of the advantages it has over gcc. I don't really like either gcc or clang, but there's really no alternative. I like gcc for some of it's compiler features, and I like clang for it's usability. Both have advantages and both have flaws. I tend to be opinionated about things like this, so please don't take offense. I just have a mild dislike of Apple and the way they lock things down.
&gt; Are there any good books in networking programming in C? Threads? Some slightly more advanced concepts? Richard Stevens is who you're looking for here. 
Share once you find them :) or post the book isbn's and I'll get them and share 
Oh, hey, me and you used to talk on my old account. I'm only going to find the latest versions, but I'll PM you or post here when I get them. Maybe upload them in a `xz`'d tarball.
Nein! Doch! Oh!
I like this style of programming. I've recently started to browse through the implementation of J, and the notation becomes more and more appealing to me every day.
Can you clarify that? Do you want to have the variables placed at *fixed addresses* or just in a particular order? In the first case, either use assembly to place the variables at a known fixed address (and use a linker script so the space isn't used by anything else). In the second case, declare the variables as a global struct. The C standard mandates that fields of a struct appear in memory in the order they are declared.
Fixed.
It only works for certain kinds of applications though and you shouldn't use it if it's not a good fit for what you are doing.
The C Companion by Allen Holub is older but covers lots of things you don't see elsewhere too much -- stack frames, pointers, absolute memory addressing, some basics on how C relates to assembly and how your compiler works. There is a small recently published book called Understanding and Using C Pointers that is very good for a widely used but often difficult to internalize concept. Advanced C Programming By Example by John Perry is in my opinion the equal or better of K&amp;R in many ways but it's out of print for a long time sadly, perhaps you can 'find a pdf' though.
In Computer games which need to be highly optimised you avoid malloc/new as much as possible. The solution is often a pool, create a free pool of the object you want to dynamically alloc.
Avoid spaghetti code by becoming familiar with complexity-reducing design patterns and principles. Ensure each function and struct serves a single, coherent purpose.
Sorry, I just read about this myself actually, so this is all I know. However, the concept is simple: allocate a big chunk at the beginning based on what you anticipate to be the requirement. If you hit the max, you can use realloc to get more data for another huge chunk. In that way, you may still have to malloc data, but far less often than if you were to malloc every single node
I'm good now. I didn't realize the linker wouldn't put them in order or that there would be an option to enforce the order that they are declared (I see them listed in order in the lst file). I didn't see the option for it. We'll use a structure to solve this, it isn't a problem - we did that on the previous program for this issue. I was trying to avoid the structure because A2L files don't play well with structs but it isn't a big problem. Thanks for your help. FYI, powerpc. windriver. Automotive.
I use calibre. PDF (or any other format) to .epub isn't good and it easily breaks formatting.
You talk about reading it with an e-reader, right? Because even with the build in pdf-Reader in Chrome or Firefox scaling the text of PDF-file to a readable size is no problem.
For a bit of a different approach, check out what Casey Muratori has been doing with his Handmade Hero project. He talks a lot about "compression-oriented programming," and I'm finding it to be a very cool school of thought. https://www.youtube.com/channel/UCaTznQhurW5AaiYPbhEA-KA/videos
malloc isn't as expensive as it seems, since it typically allocates chunks and gives you pieces. sbrk, which is the system call (in glibc, at least) is rather expensive, which is why malloc tries to minimize calls by asking for more than you asked for, and doling bits out. If you know ahead of time that you'll be using a certain amount of memory you can pre-allocate it and save some time and system calls (memory pools) but you're frequently engaging in premature optimization by doing so.
Thanks for the tip, about switching to C++, that's not possible for certain projects 'cause I have to do them in C only
Interesting videos, thanks, I'm watching now.
that .... that isn't text scaling.
"Text scaling", means changing the character size *without changing the page size*. The text has to be "reflown" within the constraints of the page. Zooming changes both text size and page size, which is a completely different thing.
about a standard from 1989? why?
The C standard says nothing about the cost of calling malloc. A decent rule of thumb would be to consider it as expensive as a system call. However, misusing dynamic memory allocation -- specifically having lots of small allocations and frees -- will degrade your program's performance over time, as locality decreases, cache performance degrades, etc. Preallocating nodes in an array can be a huge improvement. This is a fairly complex topic with many different approaches, whose performance depend on your usage patterns.
If you could have any one food for the rest of your life, what would it be and why is it spaghetti?
Personally, I try to use a garbage collecting malloc library because the lack of worry about tracking when to free memory is worth more than fretting about a few microseconds here and there. Besides, most decent malloc implementations will have free lists of common small sizes of memory that they pull from. You're worrying about nothing.
`volumeOfField` is a function. If you just write `volumeOfField`, then you are referring to the function. A function is not a `double`, and that's why you are getting that warning. You want the *return value* of the function, right? So you need to *call* the function. Calling a function requires parentheses after the name of the function, enclosing the arguments that you are passing to the function. To *call* the function `volumeOfField` with the arguments `length`, `width`, `elevation`, `rise`, and `row`, you need to write &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`volumeOfField(length, width, elevation, rise, row)` That is what you should be using in your `printf` call (or, better, assigning to a variable of type `double`, which you then use in the `printf` call).
The entire point of dynamic memory is that it is *NOT* automatically reclaimed when control leaves the scope in which it was allocated. Otherwise you'd never be able to allocate something in a function and return a pointer to it, because that pointer would turn into a dangling pointer. It is entirely up to you to determine when that memory is freed. 
&gt; Would it be cheaper to pre-allocate the memory ahead of time in the form of an array of structs and then work with pointers to the elements in the array instead? Yes, this is how you would optimize the binary tree case. Allocate a bunch of nodes in an array and when you need a new one, just pick a new element out of the array. We call this "memory pooling"/"bump allocation" in the PL world. It is so much cheaper than calling `malloc` a bunch of times. If you know how big the tree's going to be ahead of time, you can pretty much make your memory allocation as fast as possible by pre-allocating exactly that many nodes right at the beginning.
You only need one free for each malloc. It does not matter whether you use malloc in main or in another function. Just be sure you free it when you are no longer using it. If you are unsure of when you will be finish using malloc, just free it at the end of main before you exit. It is recommended to free it when you are no longer using it. Especially you are allocating a large amount of memory.
Understood this now. But he talks about, that he has problems with reading the small text, so the zoom should solve this as well.
Backslashes escape the \*, not forward slashes. But in reference to the code, you're doing: int* p = malloc(...); // allocates memory and makes p point to it //... // call this point A free(p); // immediate free it p = foo(); // foo allocates a new block of memory and sets p to point to it //... // call this point B free(p); // and now you free it You're allocating two blocks of memory here. If the code in point A refers to `p`, and when you're done with that you want a completely new area of memory that's a different size, then your code is more or less OK. It works at least, but it's pretty bad style (more on that later). You're destroying your previous block of memory (`p` now points to garbage memory), and then creating a brand new block of memory and pointing `p` to it. If the intent of this entire block of code was just to have `p` point to the memory that `foo` malloc'd and returned, then skip the first `malloc` and `free` entirely. Just do int* p = foo(); // ... free(p); As for that style issue, it's probably a bad idea to have one variable in a function that completely switches its meaning (to the programmer/reader) midway through the function. That is, don't do something like declare a `length` variable that holds the length of a highway, and then halfway through the function, make it instead hold the length of a bridge. It's really confusing to anyone trying to figure out what the function does. So if you really meant for `p` to point to two entirely different blocks of memory, you should probably call them two different things. A second style issue: it's sometimes very useful to have a function `malloc` some memory and return it, but make sure you have a consistent policy for it in your code. Maybe you call all those functions `make_XXXX` or something. As your program gets large, it becomes a nightmare to properly manage memory if you have no idea where it comes from. One good strategy is to just go with a policy that the caller always mallocs and frees the memory, except in special circumstances, which you denote with a special name.
(ง ͠° ͟ل͜ ͡°)ง
Every segment of memory you allocate has to be freed, no garbage collector. Welcome to C.
Avoid "global" variables. Keep your functions concise. Avoid multiple returns in a function. 
Could you please indent your code with four spaces so it appears in a mono space font? It even says so in the submission page.
Put four spaces in front of every line. It's not that hard, even on phones.
 void foo() { int x = 5; int *bar = &amp;x; } This function declares an int `x` and pointer to int `bar`, assigned to point to `x`. Both are local to the function and destroyed as soon as the scope is left. This is *automatic* allocation. void foo() { int *bar = malloc(sizeof(int)); } This function declares a pointer to int, `bar`, and assigns it a block of *dynamic* memory. Once the function exits, `bar` goes out of scope and no longer exists, but the block that it once pointed to is still hanging out, waiting to be freed. int *foo() { int x = 5; int *bar = &amp;x; return bar; } This function creates an int `x` and a pointer to int `bar`, sets `bar` to point to `x`, and then returns the pointer. But wait; this pointer is local to `foo` and invalidated as soon as the function exits! So what is actually returned? Well, a pointer to some memory that may or may not be in a valid state. Dereferencing this outside of `foo` is undefined behavior, like dereferencing a null pointer, and should never be done. Errors like this are subtle and can be difficult to debug; we've all been guilty of returning stale pointers. The thing to keep in mind is if you're going to be returning a local pointer, **make sure it's dynamically allocated!** int *foo() { int *bar = malloc(sizeof(int)); *bar = 5; return bar; } This function declares a pointer to int `bar`, allocates some memory for it, assigns the pointed int to 5, and returns the pointer. Now, because this pointer was allocated dynamically, it is *not* invalidated when the function returns, and you can use it freely in the calling scope; however, **it must be freed** when you are done with it, or you risk leaking memory. Now, here's how you might use it: int *foo() { int *bar = malloc(sizeof(int)); *bar = 5; return bar; } int main() { int x = 10; int *baz = &amp;x; printf ("%p: %d", baz, *baz); baz = foo(); printf ("%p: %d", baz, *baz); free (baz); } In this program, you're declaring a pointer to int `baz`, setting it to point to an int `x`, and then printing out the location and value of the integer. Then, you call `foo` and assign its return value (another int pointer) to `baz` and print out the same information again. Not that both the location and value printed should be different, because you changed the address, but you didn't alter any of the underlying memory -- `x` is still there, it is still 10, and you could go back to pointing at it whenever you wanted. Finally, observe that because you allocated `bar` dynamically, you were able to return it and manipulate it outside the function, but that means you eventually have to free it; that is the last thing done inside `main`. N.B. that allocating memory in one place and freeing it somewhere else gets confusing very quickly and is best avoided when possible; you are setting yourself up for memory leaks by writing code like this.
For every `malloc()` that is executed, exactly one `free()` should be executed. How code is organized does not change that. Note that this is not the same as "for every malloc in code, one free should be in code", for example if you allocate things in a loop, you will have to take care to separately free everything allocated.
Not necessarily. If the text is too small with relation to the page width, a zoomed page would no longer fit into the screen horizontally. This would make it almost impossible to read.
`Player` in our case implements an _opaque_ data type. The definition of that data type is not present in the header file and, for that reason, is not visible to the client code. What the client code can see is a mere *declaration* of type `Player` (aka `struct _Player`). The client code does not see, does not know and is not supposed to know what's inside `struct _Player`. The client code does not know the size of `struct _Player`. In formal parlance `Player` (and `struct _Player`) is a so-called *incomplete* type. This immediately means that client code will never be able to declare objects of type `Player`, since it is impossible to declare objects of incomplete types. It is impossible to dereference pointers to incomplete types. It is impossible to pass objects of incomplete types to functions by value. And so on. For example, if you try this on the client's side of the code Player p; the compiler will issue an error about type `Player` being incomplete. The only thing the client code can do is declare pointers to this type Player *p = /* something */; This means that all work on the client's side of the code will always be with pointers, pointers and only pointers to type `Player`. And the whole client interface of the library should be written in terms of pointers and only pointers to `Player`. This is the reason all functions in the header file are written to accept `Player *` (or `const Player *`) as arguments. The typical scenario in the client code will look something as follows Player *my_player = iniPlayer(42, "John", 33); ... printPlayer(some_file, my_player); ... freePlayer(my_player); You cannot declare `printPlayer` as int printPlayer (FILE * pf, const Player pplayer); because, as I said above, the client code cannot possibly pass `Player` objects by value.
Oops, yeah I messed up. I get it now. Thanks a lot! I appreciate you taking your time helping me!
So, what is `adc_val` before the conversion? What is the range of `int` on your platform? It looks like your platform uses 16-bit `int`, i.e. the range is `-32768..+32767`. If `adc_val` is out of `int` range, then the conversion produces *undefined behavior*. In other words, you guess is probably correct: overflow occurs during `float` to `int` conversion. End of story. Your "why?" question is not clear to me. If you attempt to overflow an `int` with an overly large value, `int` will overflow. There's no other "why" here. As for "why" your `getADC()` function returns a value out of `int` range (and whether it is by design) - this is a question only you can answer. Try using a larger integer type (`long int`?) if your platform provides one.
so my adc_val will be a float between 0 and 3.3 max, and the range of int is is -32768..+32767. adc_val will usually be between 1 and 2.5. So were are getting wonky behavior with small float values and I don't understand why. Keep in mind we have verified the correct behavior of our code on two other compilers MikroC and XC8 and they work fine, It's just this old C18 compiler that mucks things up. Reading the user guide has given no clues :( thanks for the reply mate
It's a long shot, since I've never heard of an ADC giving a float, but try my cast-happy solution: int after_dec = (int)((float)((float)adc_val - (float)before_dec) * 1000.0f);
your code is difficult to read because you haven't formatted it for reddit, you should take a couple minutes to fix it if you expect us to take a couple minutes to help you. stylistically, you have a lot more blank lines than you need, i find it makes reading your code more difficult. likewise, none of your comments are helpful. they are obvious, particularly if you fix the number of blank lines. comments should explain why you are doing something not what you are doing (the code already says what you are doing). beyond that, main should return an int and you should then have the proper return statement. flag=1; if(flag){ the `if` is meaningless. you set flag and then check it, it will always be true. For a similar reason: if(c=='.'){ ... if((c&gt;='a')&amp;&amp;(c&lt;='z')){ the second if will never be true since you only evaluate it if `c == '.'` Also, if the character is `.` you don't copy it at all. you probably want to check if file one was successful before opening file 2 since you don't need it if there is no file 1. Your code will segfault if file one isn't found (you try to close it either way). Always check to see that your calls succeed and when they fail do something useful. In this code if you had a permission problem you would never see it. This should get you most of the way to code that does what you are expecting.
Makes sense, didn't even think about that. Do embedded systems run without a kernel?
I disagree with the point about multiple returns, I think it is good practice to have multiple return statements in your function.
What's the data type for adc_val (before the cast)?
It helps to keep things simple. Instead of writing a program that opens two files, you can just read from stdin and write to stdout. A program that copies its input to its output might look something like this. #include &lt;stdio.h&gt; int main(void) { int c; while ((c = getchar()) != EOF) putchar(c); return 0; } This shifts the responsibility of opening the files onto the shell. The program can then be invoked as follows. program &lt; text1.txt &gt; output.txt Have a think about how you might modify the above program so that it applies the desired transformation to the text. If you have difficulty with that, please clearly describe what "correct uppercase and lowercase" is.
What the hell am I looking at?
That was actually a typo on my part. So if length[i] is &gt; length[i+1] the for-loop will iterate, at most, to the length of the smallest string (length[i+1]). If length[i] &lt; length[i+1] it will iterate, at most, length[i] times.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Single-precision floating-point format**](https://en.wikipedia.org/wiki/Single-precision%20floating-point%20format): [](#sfw) --- &gt; &gt;__Single-precision floating-point format__ is a [computer number format](https://en.wikipedia.org/wiki/Computer_number_format) that occupies 4 bytes (32 bits) in computer memory and represents a wide dynamic range of values by using a [floating point](https://en.wikipedia.org/wiki/Floating_point). &gt;In [IEEE 754-2008](https://en.wikipedia.org/wiki/IEEE_754-2008) the 32-bit base 2 format is officially referred to as __binary32__. It was called __single__ in [IEEE 754-1985](https://en.wikipedia.org/wiki/IEEE_754-1985). In older computers, other floating-point formats of 4 bytes were used. &gt;One of the first [programming languages](https://en.wikipedia.org/wiki/Programming_language) to provide single- and double-precision floating-point data types was [Fortran](https://en.wikipedia.org/wiki/Fortran). Before the widespread adoption of [IEEE 754-1985](https://en.wikipedia.org/wiki/IEEE_754-1985), the representation and properties of the double float data type depended on the computer manufacturer and computer model. &gt;Single-precision binary floating-point is used due to its wider range over [fixed point](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) (of the same bit-width), even if at the cost of precision. &gt;Single precision is known as __REAL__ in [Fortran](https://en.wikipedia.org/wiki/Fortran), as __float__ in [C](https://en.wikipedia.org/wiki/C_(programming_language\)), [C++](https://en.wikipedia.org/wiki/C%2B%2B_(programming_language\)), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language\)), [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)), as __Float__ in [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language\)), and as __single__ in [Delphi (Pascal)](https://en.wikipedia.org/wiki/Object_Pascal), Visual Basic, and [MATLAB](https://en.wikipedia.org/wiki/MATLAB). However, __float__ in [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language\)), [PHP](https://en.wikipedia.org/wiki/PHP), and [OCaml](https://en.wikipedia.org/wiki/OCaml) and __single__ in versions of [Octave](https://en.wikipedia.org/wiki/GNU_Octave) prior to 3.2 refer to [double-precision](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) numbers. In [PostScript](https://en.wikipedia.org/wiki/PostScript) the only floating-point precision is single. &gt; --- ^Interesting: [^24-bit](https://en.wikipedia.org/wiki/24-bit) ^| [^F16C](https://en.wikipedia.org/wiki/F16C) ^| [^Double-precision ^floating-point ^format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) ^| [^Fast ^inverse ^square ^root](https://en.wikipedia.org/wiki/Fast_inverse_square_root) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cogmxi2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cogmxi2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I don't see much value in writing C that uses the features added in C99 and C11, at least not for my own purposes. The additions to the language don't seem to add anything that can't already be done, for instance: * You can use /* ... */ instead of // ...\n. * You can separate declarations and code instead of mixing them. * You can use malloc() instead of VLAs. * You can use assignment statements (and in some cases, ordinary initialisers), instead of initialiser designations. * etc. As for the additions to the standard C library, I suppose there are some good ones, but they're generally better implemented by external libraries ... I'd say that applies a bit to the standard C library in C89 as well. I think rand() in &lt;stdlib.h&gt; is a good illustration of that point: It works well for most general cases, but you're better off using another library if you need a 'statistically accurate' pseudorandom number generator. I'd say K&amp;R2's still adequate for learning C, as it covers the bulk of the language. It has its shortcomings, and for that reason I'd recommend skimming through "The Practice of Programming", which is an excellent reference on the practice of software development that happens to present better examples for some of the things in K&amp;R2. 
You might like [this](http://www.manning.com/bhargava/). The first chapter is free, if you would like to base your judgement on that. Disclaimer : I know the author, but I think he's very good at explaining things.
thanks man, although this is bad news it helps me greatly. much appreciated
Dont a suppose he wrote one based on C.
No, I believe it's python. I assumed you were looking for understanding of algorithms based on your question
Many thanks for that. I appreciate why things aren't in -Wall (which is supposed to stand for "all" warnings) but by the time you run "-Wextra", I'd expected I'd be catching this. Or better yet, clang's static analyser, which is supposed to go beyond what a compiler would ordinarily detect, but considers this code "fine". splint produces warnings on: printf("Something %d\n", k); where k is a uint16_t. But consider this code fine. In the end, many thanks for pointing out that flag, I'll be using it at least occasionally as a debugging technique, but if someone's going to bother making a code analysis tool like splint or clang's analyzer, I'd really encourage them to look at this.
You have to realize, what you posted is *valid C*, it's not necessarily a bug, so it's not too shocking that gcc and clang don't yell at you about it by default. -Wsign-conversion isn't enabled by default because it would produce a lot of false positives. Same with splint and clang-analyze, by default they're not going to yell at you if what you have is valid code.
Have you worked through an introductory book like K&amp;R? Are you comfortable with manipulating pointers and the like? If so, check out [Sedgewick's *Algorithms in C*](http://www.amazon.com/Algorithms-Parts-1-5-Bundle-Fundamentals/dp/0201756080). You can find more recommendations [here](http://www.iso-9899.info/wiki/Books).
Yeah, I understand that it shouldn't be "by default". But I come back to a static analyser being pedantic enough to produce a warning on this: printf("Something %d\n", k); Where k is a uint16_t - but not the code in question. It just feels like the priorities are way out.
But this example really is a problem for the variadic printf routine as it needs to know about the sizes of the parameters on the stack. 
[Introduction to algorithms, 3rd edition] (http://www.amazon.com/gp/aw/d/0262033844/ref=mp_s_a_1_1?qid=1423558215&amp;sr=8-1&amp;keywords=introduction+to+algorithms+3rd+edition&amp;pi=AC_SY200_QL40&amp;dpPl=1&amp;dpID=51WLL1XC30L&amp;ref=plSrch)
[Here is the desktop version of your link](https://amazon.com/dp/0262033844?ie=UTF8&amp;qid=1415866438&amp;tag=as_li_tl-20&amp;sr=1-1)
It is correct for a 3-bit representation.
They're macros that facilitate a much more compact style of writing: fa(x){N(x-1,x*=1+i);R x;} It is generally accepted that program size is the single biggest factor in a reader's ability to reason correctness and performance; It's much more important than static/dynamic typing, language, operating system, libraries, organisational paradigms, and other things we might just call methodologies. And yet, while it is no surprise that many programmers can write "hello world" correctly and minimally, it has *generally* been accepted in the programming industry that this hypothesis does not extend to larger (more complex) problems. I believe that this hypothesis is wrong, and am finding success using this method; My programs are shorter and faster writing this way, and they work correctly when tested.
&gt; [...] check out Sedgewick's Algorithms in C. An excellent recommendation. I found it a little verbose, though. Some books that would help you build your C and DS/A muscles are: * [Kernighan and Ritchie (1988), *The C Programming Language* (2e)](http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628). This book needs no introduction. * [Kernighan and Plaguer (1976), *Software Tools*](http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X) or [Kernighan and Plaguer (1981), *Software Tools in Pascal*](http://www.amazon.com/Software-Tools-Pascal-Brian-Kernighan/dp/0201103427). Either of these books will teach you how to implement robust software tools. Although the books are based around Ratfor and Pascal respectively, IMO a C programmer shouldn't have problems understanding the code in them. You could try implementing the exercises in C. * [Bentley (1999), *Programming Pearls* (2e)](http://www.amazon.com/Programming-Pearls-2nd-Edition-Bentley/dp/0201657880) and [Bentley (1988), *More Programming Pearls: Confessions of a Coder*](http://www.amazon.com/More-Programming-Pearls-Confessions-Coder/dp/0201118890). These two books will teach you how to think about programming. Highly recommended. * [Goodrich and Tamassia (2014), *Algorithm Design and Applications*](http://www.amazon.com/Algorithm-Design-Applications-Michael-Goodrich/dp/1118335910). This book is language-agnostic. * [Weiss (1996), *Data Structures and Algorithm Analysis in C* (2e)](http://www.amazon.com/Data-Structures-Algorithm-Analysis-Edition/dp/0201498405). Two more books that my friends have found useful are: * [Kleinberg and Tardos (2005), *Algorithm Design*](http://www.amazon.com/Algorithm-Design-Jon-Kleinberg/dp/0321295358). * [Skiena (2008), *The Algorithm Design Manual* (2e)](http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693).
Keep your function definitions small and simple. I like to keep mine under 25 lines. Use the smallest scope/linkage possible for your identifiers for objects, so select the first one in the following list that will do the job nicely: * block scope (inside of a block), no linkage, e.g. ... f(...) { int a; ... } * block scope (parameter declaration), no linkage, e.g. ... f(int a) { ... } * file scope, internal linkage, e.g. static int a; ... f(...) { ... } * file scope, external linkage, e.g. int a; ... f(...) { ... } Try to write your programs in a data driven way. The simplest example I can think of would be replacing int vowel(int c) { return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'; } with int vowel(int c) { return c != '\0' &amp;&amp; strchr("aeiou", c) != NULL; } Function pointers can be quite useful for more complex data-driven examples, so they may be worth reading about if you are unfamiliar. 
To be pedantic, warnings exist to yell about about bits of C that *are valid* but probably not intended. If it were not valid C it would be an error. The canonical example is `if(foo = bar)` which is valid but GCC will tell you (in a rather roundabout way, -Wparentheses) that it looks funky. From the documentation: Warnings are about reporting constructs that are not inherently erroneous but that are risky or suggest there may have been an error. In this instance assigning -1 to an unsigned value is a common C shorthand for `U&lt;type&gt;_MAX` or `0xFF...` and even though it violates the unsignedness, C's byzantine implicit type conversion rules work out in your favor. What's less clear would be assigning -37 to an unsigned type. This too is again valid thanks to conversion, and there are even situations clever enough to use it in, but it breaks the strictest interpretation of the type and is not immediately obvious that it is not a typo. What causes -Wsign-conversion to be somewhat less helpful than you'd expect, and to not be included in -Wall -Wextra, is that it doesn't check the values of the variables, only that you've assigned a signed type to an unsigned type or vice versa. int foo = 5; unsigned int bar = foo; is something that you almost always mean but will be flagged as a warning without an explicit cast.
So I looked at the C standard, and it looks like I was wrong. The compiler should be able to convert from float to int using a cast. The compilers I've used in the past (even Microchip specific ones) will go the other way, from int to float, with no issues. 
Yeap. You are right. I was thinking about pointer casts. 
The developer command line tools package comes with the lldb command line tool. You can probably still get gcc/gdb from homebrew or something.
It's a controversial book. Some people complain that its full of mistakes. Do you know how it compares to "introduction to algorithms 3rd edition" from Corman et al...?
My trick sitll works. It's called fixed point arithmetic. You might want to google it. In the embedded world, especially 8 bit CPUs, floats are really expensive. They can also be inaccurate. With fixed point math, you control the precision. Here's an example: uint16_t ConvertAdcToFixedPoint( uint16_t adcVal ) { uint32_t temp; /* Input is up to 12 bits. 12 bits x 1000 exceeds 16 bits, so we use a 32 bit temporary value */ /* Convert 0-2^12-1 to 0-3.3 x 1000, for X.YY precision */ temp = adcVal * 3300UL; temp = temp /4096UL; return ( uint16_t) temp; } Give it a try! Now your 0-4096 value will be 0-3300, and when you output it, you can do as I suggested above - divide it by 1000 to get the top digit, then use the remainder to get the rest of the digits. Fixed point is a powerful tool, and you often don't learn about it. With fixed point, you control the precision and range of all of your inputs and outputs. You also avoid expensive floating point operations on a CPU that doesn't have a hardware floating point unit. Good luck! 
I would suggest don't look for C based examples for algorithms. From what I have seen, it helps more to just understand algorithms generically and then try implementing them yourself in a language of your own choice, and yes it might be challenging.
Converting `-1` to a unsigned type is a rather well-established idiom. It is a type-independent way to generate the maximum value of that unsigned type. Among other uses, it is often used as a "reserved" value that indicates an error condition. In other words there's no "clearly there's something wrong here", aside from superfluous `()` in `return`. If you want to catch it, you can, but don't bash it as an obvious "bug".
I made a small matrix based program ([GitHub](https://github.com/uroboro/Mathlib)). [Here](https://github.com/uroboro/Mathlib/blob/master/Classes/ptrlib.c#L181) is the inverse operation with `float **` matrices.
What problems are you encountering?
[Most books have errata available online.](https://www.cs.princeton.edu/~rs/ALGSerrata1.html)
Multiple returns can add complexity when allocations occur and deallocation must take place e.g. open file, allocate memory etc... Can sometimes be the cause of memory leaks. I will confess to using multiple returns when convenient, but have often regretted doing it during maintenance phase.
Computational mathematician here. Are you *sure* you want to write this program? Here are the reasons I ask: 1. There are a number of libraries out there that will compute the inverse of a matrix much more efficiently than the naïve method you're proposing. See, for example, this StackExchange question on using the highly-optimized [LAPACK routines](https://stackoverflow.com/questions/3519959/computing-the-inverse-of-a-matrix-using-lapack-in-c). 2. Computing the determinant of an n x n matrix using the "direct" equation requires O(n!) computations—exponential time. More clever methods exist that can compute the inverse in O(n^3 ) time (or even O(n^2.373... ). 3. Real-world problems rarely require a full matrix inverse. Solving a linear system, for example, requires O(n^2 ) time using back-substitution. You don't have to compute the inverse. If you are still feeling masochistic, then you can follow the rather nice blog post [here](http://paulbourke.net/miscellaneous/determinant/).
It might be a good idea to use doubles and flat matrices instead.
It's language agnostic, but the algorithms are presented in pseudo code which is pretty straight forward to port to C. If you want to learn about algorithms, their time complexities and reasoning about their correctness this is a great book to go to. 
yes, I am. I actually just figured it out. I didn't know I had to find the file in the directory before I used that command. I was just doing it as soon as I logged in and getting a blank file. Thanks for the reply and sorry I deleted my post before seeing your comment.
The usual approach is to use a "while" (or do...while) loop and keep some kind of a variable that stores whether or not you should do another loop. Have you seen or used while loops yet?
I'm lucky to get ten lines a week as a kernel dev That's a combination of compile time, virtual simulation, and red tape (tons of peer review) 
I think 10 lines an hour is reasonable if you think more and type less. I really miss when I could sit down with some friends or colleagues and actually think about or discuss things, then sit down and write the code for it. I am not old or anything, but I had a couple of friends in college that appreciate this way of doing things more than others and I really enjoyed that. It seems to me that the fancy thing to do now is sit down and start writing code right away, and maybe think a little while you do so. In that case 10 lines of code an hour is unreasonable, but I doubt code quality. I think many of those new shiny software engineering disciplines are due to that. Write sub-par code first, then reiterate countless times until it works well enough under a number of cases. Just reiterate as much as you can to eliminate the effect bugs (or unhandled corner cases) have. All this instead of thinking about it once at the beginning, maybe discussing it, then the code simply becomes a tool or a means that you write down and have what you wanted executed for you. Shame really.
Actually that disdain was reserved for Visual Basic.
Hmm, an illustration for this scenario would be int cat(const char *s) { FILE *fin; int c; if ((fin = fopen(s, "r")) == NULL) return 1; while ((c = getc(fin)) != EOF) if (putchar(c) == EOF) { fclose(fin); return 2; } if (ferror(fin)) { fclose(fin); return 3; } fclose(fin); return 0; } The issue with this code seems to be that the clean-up is repeated for each error case that is handled while fin is open. I prefer to break something like this into two functions -- one that performs the operation on the resource, and the other that allocates the resource, calls the function, then releases the resource. int copy(FILE *fin, FILE *fout) { int c; while ((c = getc(fin)) != EOF) if (putc(c, fout) == EOF) return 1; if (ferror(fin)) return 2; return 0; } int cat(const char *s) { FILE *fin; int r; if ((fin = fopen(s, "r")) == NULL) return 3; r = copy(fin, stdout); fclose(fin); return r; } One benefit is that copy can be reused well. For instance, in an implementation of cat, one might make the following call in main(), when no arguments are supplied to the program. copy(stdin, stdout);
Lua is a fun language, but you'll get bored pretty quickly as it has a really, really small language core and standard library. Lua is better for when you want to learn programming if you've never done it before. Something like C++ is a pretty good an logical choice, and shouldn't be too hard to pick up. Java is fun because it's so widespread (eg Android). That being said, I'd recommend learning Python or Ruby or something like that; they're scripting languages (which are useful to automate things in the development of larger projects in, for example, C) and they're so much different from C, which makes learning them good for your development as a programmer in general. So, that's what I think; pick up a scripting language like Python or Ruby.
I learned Scheme after C. An exercise I found 'intellectually' valuable was implementing some of the procedures in SRFI-1. I have also found practical value in learning to operate shells like bash. It's amazing how much you can do in only a few lines, given programs like sed, nc, grep, od, bc, etc. 
The type of `name` is array[2]-of-pointer-to-`char`. Therefore, `name[0]` is of type pointer-to-`char`. That's the correct type for the first argument to `execve`.
* The type of the object called name is char *[2], which is an array of 2 pointers to char. * name[0] has the type char *, it is the first pointer to char in the array. It stores a pointer to the first character in the array "/bin/sh". * name[1] also has the type char *, it is the second pointer to char in the array. It stores a null pointer. * name[0][0] has the type char and the value '/'. It is the object that is pointed to by name[0]. * name[0][1] has the type char and the value 'b'. It is the result of adding 1 to name[0] and dereferencing that value. * name[1][0] is undefined. * The value of the expression name is &amp;name[0], a pointer to name[0], which has the type char ** or pointer to pointer to char.
Depends on your goals. Maybe you can pick by choosing the one with the best learning process, in your opinion, as in which one has the bes tutorial/book/series of exercises/whatever. IMO, go with Python if you want to learn a language that's made to build things quickly if performance isn't a key requirement. I don't know Python, I know Java but when I see things like there is no need to declare variable type in Python that sounds interesting. I'd say Java is in between Python and C in terms of verbosity and what you need to take care of manually. 
Scheme looks really neat! My brother is getting into common lisp now so that might be pretty fun to learn alongside him. How useful of a language has it been for you so far? I hear a lot of people criticize functional programming but it seems to be getting more popular nowadays. Bash is something I've been meaning to get around to as well, been learning linux and basic commands and doing OK so far but I've only made really simple scripts 
Yup, that's correct.
- You ask the operating system to reserve some memory for your program. - Your program doesn't store where the memory is allocated or programmatically it never gets around to telling the OS it's done with it - This happens over and over again, steadily testing the OS's patience with how much memory you're using until the program exits naturally or crashes.
Good explanation. Also: Kernels have Out-Of-Memory (OOM) killers for processes that try to take up beyond some limit. 
Python is very useful for smalls scripts that are too intense for bash(such as those involving database queries, web scraping, etc.). There are also plenty of libraries for pretty much everything you'll need. Dynamic typing &amp; the ability to use OO would be useful paradigms to expose yourself too. When programs start getting very large. Personally I recommend Haskell, it's a lazy, statically-typed, pure functional programming language. The type system is superb compared to C &amp; Java, and functional programming will warp your mind in a *very* good way. Python, Bash, Lua, Java, Go, PHP &amp; Ruby will all feel a little like C. Haskell won't. 
Im a linux guy. 
Good to know. I will be implementing reediting this to work with string values soon so it should be ok.
In that case, yes. Again, the question of who should *own* that string memory - the tree itself or some independent external allocator - is still open. Can be done either way.
1. Use a descriptive title. Your post title is worthless. 2. We aren't just going to do your homework for you. Do your own homework. 3. That code is&amp;nbsp;C#, not&amp;nbsp;C. Those are two completely different languages. This subreddit is about C&amp;nbsp;programming, not C# programming.
1. I wouldn't say worthless 2. Actually not my homework 3. Noted I'm trying to help someone else and crowd sourcing solutions while they pull their hair out was the only way I knew how to help them. But they only gave me pseudocode (there was more source code than *none* going on) and I realize this is for C language. You don't have to be a dick about it, but I know you want to.
testing it in a virtual machine, I should suppose
Apple has funded and adopted clang and llvm since the beginning, so he's not far off.
Depends what you want to do with your knowledge. * Reading through [SICP](http://mitpress.mit.edu/sicp/) is always a good suggestion to learn how to take control of your language/runtime etc. Also then it shouldn't be too difficult to program with Clojure. * Learning asm is quite useful when you want to do embedded. * Java/[Python](http://learnpythonthehardway.org/)/Ruby are good, when you want a job quick. * Of course [JavaScript](http://eloquentjavascript.net/) is lingua franca in the programming world, so knowing that would be useful. * Personal recommendation would be Go, I would say it's the best language to learn how to design well written programs. * Of course learning the command line tools isn't a bad idea either - although it's probably better to learn them on a need to know basis. * Haskell/OCaml when you want to have your brain twisted with abstractions. * And... rather than learning a language, you might be better off by building something first.
You can't say `&amp;row_int[b]` if `b&lt;0`, but the reason is not that you access an element before the beginning of the array; the reason is that you are having a pointer into memory you don't own which is undefined behaviour. In the expression `&amp;foo[bar]`, the standard guarantees that this behaves exactly like `foo + bar`.
Can you please indent your code with four spaces so it appears in a monospace font?
The compiler is free to arrange memory as he wants. There is *no guarantee at all* about the order in which variables (both local and global) appear in memory. The compiler may also assume that a pointer you derive from one object never reaches into another. If you want to do this kind of trickery, turn off optimizations so the compiler doesn't do fancy things. Second, your comparison is wrong. I believe that this test if((&amp;row_int[b] != &amp;i) || (&amp;row_int[b] != &amp;ia)) is incorrect; it will never be false because `&amp;row_int[b] == &amp;ia` and `&amp;row_int[b] == &amp;ib` cannot be true at the same time unless `&amp;ia == &amp;ib` which is impossible because `ia` and `ib` are different memory objects.
I actually did that, I don't know why your computer doesn't display the indents.
But [it seems like most people speak c or java](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)
Optimise if you *need* to optimise: Profile your code with a large amount of data and see whether the time it takes is sufficient. If not, look at where your program spends most of the time, then optimise that. Always profile before you optimise -- there is no point in making your code more complicated for little to no reason. 
&gt; but I guess that is not always the case. It depends on the mood of your compiler. Never make assumptions about the order and layout of variables in memory as this is something the compiler can shuffle around freely.
I added 4 spaces to the lines that must be indented, so not the include and int main(), because I thought those wouldn't need indents.
You need to add an extra indent of four spaces to *all* lines, on top of the indent you would do anyway. This is needed because reddit only recognizes lines as code that start with four spaces. Just like you mark a quote by putting `&gt;` characters on the beginning of the line, you mark code by putting four spaces in front of it. This is the example from the submission text: &gt; A simple `Hello, World!` program. &gt; &gt; ␣␣␣␣#include &lt;stdio.h&gt; &gt; &gt; ␣␣␣␣int main() &gt; ␣␣␣␣{ &gt; ␣␣␣␣␣␣␣␣printf("Hello, world!\n"); &gt; ␣␣␣␣} becomes &gt; A simple `Hello, World!` program. &gt; &gt; #include &lt;stdio.h&gt; &gt; &gt; int main() &gt; { &gt; printf("Hello, world!\n"); &gt; } For more details, please have a look at the [commenting wiki page](http://www.reddit.com/wiki/commenting) where the full syntax for formatting in reddit posts / comments is explained.
&gt;So it's easier for a non-professional or mildly trained coder to create a Javascript application. &gt;I observed Visual Basic, when it became popular and made application-building easy, receiving scorn similar to Javascript today. You might not realize how close your analogy is to reality. When Javascript was initially developed, it was meant to be the *Visual Basic* of the browser, for casual development alternative to Java Applets, which were the tool for "real work". Hence the "Javascript" name, meant to piggyback on Java despite having nothing in common. But Java failed hard in the browser which left Javascript to fill both roles despite being horribly designed for that purpose. 
Or, for our C++ brethren, new without delete.
Memory leaks are why your web browser needs 16Gb of RAM.
What I am saying is that you are doing something that is not allowed by the C&amp;nbsp;language. You are not following the rules that you are supposed to follow as a C&amp;nbsp;programmer. The C&amp;nbsp;standard is a contract between you (the programmer) and the compiler. If you don't hold up your end of the bargain, all bets are off—the compiler has no obligation to do anything in particular with your code. It is meaningless to ask why your code is or is not behaving in a particular way if you are attempting to do something that is not allowed by the standard, because in that case the standard says absolutely nothing at all about the behavior of your program. That is what "undefined behavior" means.
&gt; Yes, of course. But if that result points outside the bounds of the array, the behavior is undefined. That's what I say. The expression `&amp;foo[bar]` doesn't *access* any memory. It just references an address. Thus, it's not undefined behaviour because of *access outside of object boundaries* but rather *reference to invalid memory address,* which is subtly different.
Okay, I see what you're saying. But I wasn't talking about the expression `&amp;row_int[b]`, I was talking about the expression `row_int[b]`. You're right that you can't say `&amp;row_int[b]` either (although `&amp;row_int[10]` is legal even though `row_int[10]` is not), but that wasn't the expression I was talking about.
Ah, yes, I missed that. I assumed it was a type since that appears with a take-address in front in OP's code.
Okay I just failed on saying my issue, I apologize, I actually do a `strcpy()` with ` strcpy(path, "C:\...")`, sorry I just failed at posting something :'(, I'll edit my post
I actually do it, I'll edit agin :P
You're also missing the semicolon at the end of the `path = NULL` line. Post your actual code, or at least post a [short, self-contained, **correct** example](http://sscce.org/) that illustrates your problem and that you have *tested* to make sure it exhibits the problem you are asking about. Don't just post an approximation that kinda gives the gist of your code.
int* hello; while(true) hello = malloc(sizeof(int));
Are you allocating enough space for the NULL terminator in the string? You should be adding 1 to the result of strlen() if you're using it.
http://pastebin.com/P5ixeX8x
&gt; if((original_folder = calloc(strlen("C:\\Users\\Name\Songs\\"), sizeof(char))) == NULL){ &gt; printf("Can't allow memory to folder originel"); &gt; } &gt; original_folder = "C:\\Users\\Name\Songs\\"; Look, you're doing exactly what I talked about in my first comment. You're also making the mistake that /u/dragon_wrangler pointed out.
There are several different types of memory leaks, and certain camps will argue that some memory leaks can be ignored (exit() frees all!). The worst type of leak is allocating heap to do some work, using a stack variable to point at the heap allocation, forgetting to free() the heap allocation, and returning from the function without returning the pointer to the heap allocation. The stack will unwind and the pointer to the heap allocation will be lost making it impossible to clean things up in the future. If this function gets called recursively or freqently, you can quickly run out of memory as you try to scale your solution.
On the other hand, I miss when I could sit down and hack some little game or something in 200 lines of code. Now I spend way too much time deciding on which technology to use, what patterns to apply... Even the most simple program takes me ages to write, and I usually give up halfway through.
Same thing with C. VMS is a nightmare. Did you know that the VMS team later designed Windows NT? Things happen for a reason...
I am not sure why this legitimate question got downvotes, it seems as if people in this sub cannot answer a question here they downvote it instead of leaving it for someone with more experience to answer... Try the following code, it is along the lines of what you learned in class and demonstrates how to use array indexing to modify program behavior. I use negative indexes for arrays in my operating systems to set up the initial stack context of a thread during creation. The stack typically has the return address of the system exit call and a pre-set parameter of 0 already set, so a thread only needs to 'return' to properly exit. **Stack/heap manipulation is not a standard and you must know your target environment to do it successfully. You must also use a debugger (in asm) to create the manipulations. Or you can guess-and-check for some simple ones like in this example.** #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; void never_called(int); // This function is never called! int main(void) { // Compile for x86 32-bit system **all optimizations off**, tested on Win 7 &amp; 8.1 64-bit OS printf("Hello, world!\n"); int abc = 500; int row_int[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int def = 600; for (int i=-10;i&lt;20;i++) { int val = row_int[i]; if (val == abc || val == def) { printf("I have found %d at address 0x%08X - Index %d\n", val, (int)&amp;row_int[i], i); } } row_int[14] = 123456789; // set up the 'what' parameter row_int[12] = (int)&amp;never_called; // over-write the return address with the address of never_called() return 0; // Instead of returning to OS, it will "return" to never_called() } void never_called(int what) { printf("I am never called.... or am I: %d\n", what); // what = 123456789 exit(0); }
The next who gets your code is gonna hate it.
Do this: char *path = strdup("the string you want to duplicate"); It mallocs the right amount of space and copies the string in. It is not a Standard C function but just about every compiler has it. (and if yours doesnt it's actually easy to write).
Lol, your code is much more logic, comparing values of the variables with the value of array[b]. Thank you for your answer and being so kind. Next time I think I'll try this, since it's easier and requires less code. Just so you know, I got the same result with memory comparing too, but not with the "==" operator, here is my code. #include &lt;stdio.h&gt; int main(void) { int i = 500; int row_int[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int j = 600; int index; /* The if statement in the for-loop checks if &amp;array[index] &lt;= &amp;variable &amp;&amp; &amp;array[index], so that it's only true when &amp;array[index] = &amp;i*/ for(index = -20; index &lt; 20; index++) { if((&amp;row_int[index] &lt;= &amp;i &amp;&amp; &amp;row_int[index] &gt;= &amp;i) || (&amp;row_int[index] &lt;= &amp;j &amp;&amp; &amp;row_int[index] &gt;= &amp;j)) { printf("----------------------------------------------\n"); printf("i = %p \t j = %p \t array = %p \n", &amp;i, &amp;j, &amp;row_int[index]); printf("----------------------------------------------\n"); } else printf("i = %p \t j = %p \t array = %p \n", &amp;i, &amp;j, &amp;row_int[index]); } } This code does change only the values of variable i and j. But yours is much more simpler. Since the "==" operator didn't work with comparing memory values, my first code looked like this. But the code I had changed the variables of i and j and (&amp;j+1), do you know why that could be? I used this if statement: if( ( (&amp;row_int[b] &lt; &amp;i) || (&amp;row_int[b] &gt; &amp;a) ) &amp;&amp; ( (&amp;row_int[b] &lt; &amp;ia) || (&amp;row_int[b] &gt; &amp;ia) ) ) printf("i = %p \t ia = %p \t array = %p \n", &amp;i, &amp;ia, &amp;row_int[b]); else { printf("--------------------------------------------------\n"); printf("i = %p \t ia = %p \t array = %p \n", &amp;i, &amp;ia, &amp;row_int[b]); printf("--------------------------------------------------\n"); row_int[b] = 1000; } 
That is C++, not&amp;nbsp;C. This subreddit is about C&amp;nbsp;programming, not C++ programming. C&amp;nbsp;and C++ are two completely different languages.
`steps=++steps;` caused undefined behaviour prior to 2011. It'd be better to write `++steps;`, or `steps = steps + 1;` (assuming that's what you meant) in case your compiler isn't up with the latest developments. Also you never initialized `steps` in `main()`. 
Of course, those types will not stop me, the author, from changing of everything. I use "const" keyword to make my code better by forcing me to think in right way. In rare cases of built in library functions, I will just use verbose definition.
I see warnings in gcc: "warning: initialization from incompatible pointer type", but it is valid, IMHO: pointer will point to value, which can be changed via another pointer, so moreattention must be devoted to this piece of code. Yes, hiding of pointers is bad practice, but overly verbose code is bad practice too. I hope, benefits of compact code and shift of attention to mutable variables will worth it. I am not sure, of course. It is why I asking for your opinion. Two heads are better than one. 
Yep, but compiler error is valid: I must be careful there. IMHO, it is benefit, not a drawback. 
I think this is probably the largest downside.
Of course I would find a couple bugs after posting to reddit... Fixed Version: http://pastebin.com/cxuQAFhE
This is helpful, thank you. Can I ask where you learned to program?
I usually only use const to let the caller of a function know that what they pass a pointer to will not be modified. e.g. char *strcpy(char *to, const char *from); Although it probably doesn't matter much in practice, 'const char \*const \*const' is incompatible with 'char \*\*', so it's probably not good to define main like that.
Started with qbasic along time ago. Went to UW Platteville for 4 years to get a Software Engineering degree. I am about half self taught. 
Your submission has been removed because it's not about C. Ask in one of the C++ specific subreddits please.
Your code definitely wouldn't have printed any values, and there was nothing in your code that indicated that's what you wanted to do... But, if you want to print each number, simply add the line printf ("%d", num); at the very top of the function definition.
No, it is essential. "const" shows my intention to not modify value of this variable. I always can modifyvariable declaration and remove "const" when necessary or, even better, I can change code to make proper copy to avoid editing in place. In 99% of cases I will not need to do that, and when I will need that, it should be clever. I thinking about empty macros "mut" to emphasize mutable variables even more: #define mut int main(mut int argc, cppchar argv) { ... // Deep in the code if(argc&gt;5) argc=5; // Discard extra arguments ... } It will be clever from first look at the function definition that variable argc may change it value. 
And I broke something else. Hopefully last try... Fixed Fixed Version: http://pastebin.com/cmZRURBf 
I like C, too, because it's the perfect tool for its domain. Don't expect to be able to use a sledgehammer for surgery work, though.
It is better not to use const at all than to use it excessively. :-)
Well after C i learned Python , the modules are awesome , and it will somehow change your way of coding ( ps : learning python a bit is a thing , mastering it might be another )
First off, thank you for your input. 1. I disagree. Everyone understands while(1). And to me, in cases where multiple conditions justify a break it makes even more sense. I mean I feel like its simpler to have 2 conditions for a break instead of 3 conditions. We can agree to disagree. 2. True i'll work on this as a part of the next revision of this program. 3. I am going to sort strings in the next revision. So this type of sort should be "less wasteful". 4. I am debating on the best way to organize this. Im thinking something along the line of. #define MALLOC_ERR_BUFF 99 #define USER_INPUT_ERR 100 etc... , what do you think? 5. For the if/else statement braces, Im flexible on this to be honest, Im still trying to feel out the style i like best. I think i'll leave them on from now on. 6. Yeah I got to work on comments. When Im in the "zone" I can't be distracted by things like comments, it just ruins my concentration. 7. There is a test to make sure that the char being sorted is alphanum. if ( ! isalnum(*c) ) continue;
I'd recommend using github or another git service for projects, or at the very least uploading these with an actual Pastebin account. This is great work, so you should get credit where due.
Use 1 for a simple string. Add const before it, as the string cannot be modified. Use 3 when needing an array of string. Forget about 2. Note that 3 is vastly different from 1 &amp; 2, as it declares an array of strings. a[0] is a char in the first two cases, and a string (pointer to char in the last one). Also *a (equivalent to a[0]) is not a pointer: it is a char in case case 1 and 2.
The first line allocates storage for two objects: A char * and a non-modifiable char[4]. It associates the identifier a with the first object. A pointer to the first element of the char[4] is stored in the object referred to by a. The second line allocates storage for a char[4] object and stores 'A' in the first element, 'B' in the second, 'C' in the third, and '\0' in the fourth. It associates the identifier a with this object. The third line allocates storage for two objects: A char *[1] (array of one pointer to char) and a non-modifiable char[4]. It associates the identifier a with the first object. A pointer to the first element of the char[4] is stored in the first element of the object referred to by a. 
this is a declaration: double exchangerate; this is a declaration &amp; an assignment: double exchangerate = 2.0f; so when you do: double exchcangerate = ONE_DOLLAR_IN_EUROS; double exchcangerate = ONE_DOLLAR_IN_INDIAN_RUPEES; you've declared &amp; assigned `exchangerate`, then attempted to declare &amp; assign `exchangerate` again, which is giving you that error. Also you really need to double-check the spelling of your variables. Use more compiler flags and you'll be told about more errors: https://stackoverflow.com/questions/3375697/useful-gcc-flags-for-c Here's my alias: alias c="gcc -g -O2 -Wall -Wextra -Werror --std=c11 -pedantic \ -Wno-unused-parameter -Wfloat-equal -Wundef -Wshadow \ -Wpointer-arith -Wcast-align -Wstrict-prototypes \ -Wstrict-overflow=5 -Wwrite-strings -Waggregate-return \ -Wswitch-enum -Wconversion -Wunreachable-code -Wformat=2 \ -Winit-self \ -ftrapv -fverbose-asm \ -D_XOPEN_SOURCE=700" 
[Aside][hack] Back in '94-96 I used the duality of pointers/arrays to draw to the video buffer for dos mode 0x13 (320x200x256) basically unsigned char vga[320][200]; then once DOS mode 0x13 was set vga=0xa0000000; //mem location for vga and I could then address every pixel on the screen with vga[x][y]=&lt;color&gt; Don't think it would work on modern OS with out Seg faulting. 
Okay, I reckon I must've made a mistake somewhere in my code then. Thank you very much, I will try to run this code when I'm home, have a nice day!
What's your skill level? How about writing a CSV parser in C. Also maybe add code to check for empty rows and columns and then re-output it.
Learned ruby and some python :)
Check out /r/dailyprogrammer It's not specifically for C but you can use C to solve the problems
Thanks :) but I just want some C ideas 
Ok well if you're on a linux system you could do stuff with the "POSIX" standard and functions, and reproduce stuff like ls / cat / find etc. If you want to fiddle with sockets you could make a terminal chat client I wouldn't wander in to GUI stuff though
You are defining the same variable twice double exchangerate; double exchcangerate = ONE_DOLLAR_IN_INDIAN_RUPEES; So here's your redefinition that triggers the error. It is hard to decipher your pile of unformatted code, but it looks like you even defined it the third time later double exchcangerate = ONE_DOLLAR_IN_JAPANESE_YEN; Variables have to be defined once and only once.
You are confused. There's no error whatsoever in the code sample I presented. Since there's no error here, the remark that "this error is impossible in Rust" makes no sense. When language behavior does not match your beliefs, it is not a problem the code and not a problem of the language. It simply means that you still have a lot to learn about C language, you still need to develop a proper understanding of the language.
You misunderstand my last point. Say I pass in nothing but a space. Walk through the code. The buffer is allocated (based on strlen), zeroed out, nothing is put in the tree (no alphanumerics in the input), the valid buffer pointer is returned, then it is sent to be printed. Since it is just a zero-filled block of memory, your print function won't print the left block (null pointer), will try and deref the char to print it (null pointer deref), and won't print the right block. So you have a null pointer deref bug. The main disconnect is between the number of blocks you allocate and the number you put in the tree. I could be wrong, that's just how I read the code there. Validate the input, make sure there is at least one alphanumeric in the input before you do anything else. If you do that, might as well actually count them, then you can allocate the right size array. I'm fine with your #define error constant ideas, that's how everyone else seems to do it. Also as far as while(1) is concerned, I know everybody understands it. That's not my point. My point is it causes bugs. Since you don't need to loop forever, why not choose a less risky predicate for your while condition, something that will terminate at some point, even if you never reach any of your break points. It probably works fine here. But keep using it and one day it will kick your butt in production code. The reason I tell you to write what you mean is that this will protect you from those bugs. If you want it to loop until some conditions are met, write that. Then it's much less likely that you will loop forever. Try to think a bit defensively. This is hard for you to realize now, since you are obviously clever, but you are not nearly perfect. You need to defend against yourself, especially against your love of cleverness. At least, you will once you get paid for this stuff.
Actually, now that I look at it, technically it will actually point it at the space character won't it. And since it's the first element in the array, it doesn't need to go through the while loop. So the bug is actually not a null deref, it's that if your first character is non-alnum, it still gets put in the list, right? Somthing like that.
&gt; There is the char[3] = "ABC" situation, which does exactly what it says. Also, one would prefer using char a[] = "ABC" over char *="ABC" only if one intents to modify the content of the array (if you don't, there is no advantage over const char *a="ABC"). However, the size of the array depends of the size of the original string, ie: char a[] = "ABC"; a[4] = '\0' is undefined I'm not sure if you are just wording this poorly, or if you are confused. char a[3] = "ABC"; This yields: a[0] = 'A'; a[1] = 'B'; a[2] = 'C'; /* a[3] = not a valid array index */ Compared to: char a[] = "ABC"; Yielding: a[0] = 'A'; a[1] = 'B'; a[2] = 'C'; a[3] = '\0'; Both are mutable, but the first one has one less character, and does not produce a *string*.
I agree with most of what you're saying, but not the last bit. *Do* wander into GUI stuff too, just to try it. You might not figure it out the first time but whatever you do learn from the experience will make it easier the second time around.
C is commonly known as "portable assembly". I'd consider that a low level language.
I think it depends on the context. In general terms, C is a high level language. But in comparison to other languages, I consider it a low level language. Keep in mind, a lot of languages have their interpreters written in C. I would also say C is about as low as you can get to where it still feels like "coding" in the modern day sense. 
In my opinion: yes. Even in Python I run into situations where knowing a little C helps me understand the problem ("Hmm, I copied A to B but when I changed A, B also changed. Oh, I know, it's copied a pointer to A, not A itself. Better make that a deep copy!"). Also, since C has been so influential, knowing a little C helps you to grasp a bunch of other languages. Just like knowing a little Greek or Latin can help you understand lots of other languages (not that I know any Latin or Greek, this is just what I've been told). I wouldn't say that you *have* to know C, but it certainly helps.
Computers work as a hierarchy of complexity where higher levels are built off of the foundation of lower levels. If you really want to be a good programmer learn from the bottom up like I did: 1: Basic electronics 2: Boolean logic and digital circuits 3: Processor and Memory architecture 4: Assembly and Machine language 5: C 5a: C++/Java/Other high level langauge Note 1: 5a not 6 because I didn't want you to think that it was a different level in the aformentioned hierarchy of complexity as the rest of them are) Note 2: It wouldn't hurt to stick compiler design between 4 and 5 
lol I didn't know this was the reason for it
If it returns a pointer, and you want to store the result in a *pointer*, then it should look as follows char *s = func(); `char s[]` is an array. If you want to store it in an array, then you can't "assign" it. Arrays in C are not assignable. You have to do something like buffer b[1024]; char *p = func(); assert(strlen(p) &lt; sizeof b); strcpy(buffer, p); 
yes.
I would add operating systems to that list.
There's no such thing as "coding". The term is a dead giveaway of a green newbie. Programmers don't use this strange word. Programming is not about writing code. Programming is about finding algorithmic solutions to problems at hand. Implementing these algorithmic solutions in code is the easiest part.
I assume you mean a pointer to a char variable... c = func(); where c is defined as char * c; and func is defined as char * func(void); You don't need an array, but if you really do have to copy it to an array you can do a memcpy()
Well... code monkeys...
\#if 0 \#endif
It means that your function does not return `char *`. It means that it returns something else. I'm not psychic, I can't see from here what it returns. What exactly does it return? Post the function declaration.
It's the stdlib function `gnu_get_libc_version()` declared as `const char *gnu_get_libc_version(void);`
The recipient pointer should be declared as `const char *` then.
those are only good at shakespeare
Still no dice. #include &lt;gnu/libc-version.h&gt; int main() { const char *s = gnu_get_libc_version; printf("GNU libc version: %s\n", s); printf("GNU libc release: %s\n", s); } 
You original post seems to show that you know how to call a function in C language. If so, then what happened to the function call operator `()` in your last piece of code? `gnu_get_libc_version` and `gnu_get_libc_version()` are not the same thing, you know.
Just use the function directly in the printf... printf("GNU lib version: %s\n", gnu_get_libc_version());
The basic idea is this: 1. Make an array of 20 integers. Set each to zero initially. 2. For each random number you get, increment the array member corresponding to the value of the random number. 3. Now each position of the array contains information about how often the corresponding number appeared. If you have further questions, feel free to ask! Please show your attempts at solving the problem, so we can give you more specific help.
Because vi is available everywhere; vim isn't. vim's commands are a superset of vi's commands which are a superset of ex' commands, which are an extension of ed's commands.
I'll offer another yes/no short reason I experience: optimizing becomes a part of your toolset. When you always have ready-to-use data structures such as lists, sets and maps, you may find it difficult to go back to arrays and hand-made indexing when you need it. I feel that avoiding off-by-one errors and considering edge cases becomes second nature when you were baptized with segfaults. Also, in C, you feel its "wrong" to allocate and free memory all the time (call it non-idiomatic). In college I spent lots of time needlessly implementing in-place algorithms just for the sake of it! Yes, I could use 2 or 3 times more memory and copy stuff from one place to another, but when you are at your RAM's limit, knowing how to use it without waste is valuable. The "no" part is obvious: you most probably don't want to waste time massaging arrays, you have some task to accomplish/memory grows in trees/programmer productivity matters. But I believe you will only know how to assess the tradeoff after you have experienced it.
I know. 
Then assign it to a variable: char* var = gnu_get_libc_version(); printf("GNU lib version: %s\n", var); Functions do not return strings, arrays, or structs. They either return an int, or something that fits inside an int, like a char or short*. So what happens when a function needs to "return" more data to a caller than an int? It places it in memory somewhere, and then returns a memory address (pointer) to the start of that data. So say I want to "return" 10,000lbs of rock to you, but it is too large to fit in your house mailbox. Instead, I dump the rocks in your neighborhood and leave a small note in your mailbox where to pick up the rocks. Functions like gnu_get_libc_version() will typically handle storing the string for you. It is also good to know that for any function that returns a pointer to a string, do not modify that string, it may lead to issues. Some functions may require you to "free" the data they return, and others will just store the data in some global variable. *Yes yes I know this isn't always true, especially on specific hardware. Like x87 leaves results on the stack at st(0), and some 8/16-bit compilers will use multiple registers to return data. But for a beginner (imo) it helps to remember that a function only returns an int!
C is defined in terms of an abstract machine, so that quote supports it being described as a high-level language. Forums like this and SO are often full of questions where people are surprised by how C diverges from their mental model of their computer's hardware. 
You're basically saying that the only low-level language is assembly.
That didn't work. int main() { char *s = gnu_get_libc_version; printf("GNU libc version: %s\n", s); } 
Seconded
Code read.
That is exactly what I am saying, and it is a 100% factual statement. What is and is not a high-level language is not a matter of opinion, it is not up for debate. Low level languages have a 1-to-1 relationship with the binary machine code and are 'assembled'. High level languages have no relationship with the binary machine code and are compiled/interpreted. These definitions were created by [computer] scientists &amp; mathematicians well over half a century ago. http://www.computerhope.com/jargon/num/1gl.htm
I mean hey, I think it worked for me.
I enjoy programming in C as much as I do in ASM, and as much as I do in JavaScript. I have (even surprising myself) learned new methods of solving problems in JS that I have back-ported to my C and ASM code. I guess my piece of advice for you is: Programming in general... makes you better at programming in general. As long as you keep practicing it, as long as you keep challenging yourself with new projects that seem impossible, as long as you continue to be a sponge soaking up everything you can, you will continue to get better at programming (and pass by your competition in your career). It is the hobbyist programmer who goes home at the end of the day and continues to program who gets better. I have met lots of people who have been programming for 40+ years professionally who are very bad at it. Even the stuff they do on a day-to-day basis in their career they perform poorly at. If someone tells you such-and-such is done a certain way demand a logical and rational explanation as to why. When they give you one, go put their explanation to the test. If they were right, or if they were wrong, you have still learned something new. Perhaps what they said was correct, but their explanation as to why it is correct is wrong. Question everything, trust no one. There are too many *experts* in the computer science industry, and too many people who have become almost religious in their ideology of "how things should be done". Only people who have stopped learning, or hit their peak, wish to control others and how they accomplish things.
 int main() { char *s = gnu_get_libc_version(); printf("GNU libc version: %s\n", s); }
That's an interesting approach, I'll have to try it. I like that there's only a single call to malloc and free. 
I highly recommend not writing your pointer definitions like this: struct Queue* queue; But rather like this: struct Queue *queue; And for multiple variables: struct Queue *queue_one, *queue_two; Because when you accidentally do: struct Queue* queue_one, queue_two; `queue_two` won't be a pointer...
In the sense of "it doesn't hurt", learning C is fine. &gt;Is learning programming in C a doorway to good programming all around? Well, depends on what you mean. In the sense of learning the alphabet to eventually be able to write poems, yes, it is a gateway. It depends if you want to learn to create models for solving a problem (computation) or if you want to learn to implement a model someone else gave you. For the latter, C is fine, if annoying. For the first, I wouldn't actually use it. Fundamental abstractions C doesn't have: - Closures - Dynamic Variables - Exceptions - Sum Types - Continuations - Operator Overloading - Type Inference To summarize what they are: Closures mean you can give a function of two formal parameters one argument and get a new function with one formal parameter, it remembers the other one(s) you gave it automatically (same for local variables of the caller). For example, in a C-like language that would be (where it doesn't work - though in gcc it does work as an extension, not sure whether safely): typedef int (*reader_t)(void); reader_t File(const char* name) { FILE* f = fopen(name, "r"); int read(void) { int result = fgetc(f); if(result == EOF) fprintf(stderr, "warning: while reading \"%s\": end of file\n", name); return result; } return read; } int main() { reader_t read_from_passwd = File("/etc/passwd"); printf("first char: %c\n", read_from_passwd()); return 0; } If you had closures, you could implement objects with it, so no non-annoying objects either. Dynamic variables mean you have special variables where you can, at runtime, push some other meaning on it. Example: dynamic FILE* stdout; void g(void) { fprintf(stdout, "hello\n"); // prints to file "A" when called from f, otherwise somewhere else. } void f(void) { push(stdout, fopen("A", "w")); g(); pop(stdout); } void h(void) { g(); } Can be simulated, though. Exceptions: you can delegate responsibility for handling errors to the caller up the stack. If a library deep down opens a file whose name was given by the caller, you don't have to manually error check for that there, the exception will automatically be raised and hit the caller over the head. Sum types: Types for variables that can for example be either int or string: int|string x; x = 3; x = "Hello"; if(x == 3) // false x = 3.2; // error Unions are not sum types since the above doesn't work. Garbage collection would be: Memory you allocate is automatically freed by the runtime system so you don't have to micromanage something that can be done by the computer. Not done by C. Continuations: remember the current state of the program in a variable and later have it continue there. Kinda like setjmp/longjmp but with arbitrary number of points. Operator Overloading: make your own data type where `+` means something else. Type Inference: See that `reader_t` above? That should be `auto`, otherwise you have to maintain temporary places for the rest of your life. Also, C has no string type. No ranges (iterators). Only half-working arrays (index range is not available most of the time). So if you want to do operating system programming where the closeness to the hardware is an advantage, use C. Otherwise, don't use it. Learning it for the sake of learning it is fine. But don't forget what you are missing and that most of the things you have to worry about in C are automatic elsewhere.
/u/FUZxxl answered it. Though I use vim frequently I used "vi" to describe vi-like editors which give you quick one keystroke access to the regex search function.
Also have a look at http://codegolf.stackexchange.com. They do a lot of code golf; code golf is a game where you have to solve a given problem with the least amount of code. Quite fun.
People who prefer `struct Queue* queue` style are usually aware of this peculiarity, which is why they also typically follow a "one declarator per declaration" style (for pointer declarations at least).
A double-linked list is basically a list where every node has a reference to the next and previous ones, have this in mind when implementing the functions for adding and deleting nodes (especially deleting), it might be useful to draw it on paper first and implement it only once you're sure that everything is referenced correctly. If you need help with something in particular I'll be glad to help you. *P.D. I didn't read your code cause I'm a lil rush right now but if you want some advices about it, I can do it later*
Go back to 1999
Go back to 1994
I think I'm missing some fundamental knowledge that would help me understand this better, like what an array is. Can you recommend any online resources to help me with the basics? My professor just started the class under the assumption that everyone knew the basics and I don't. But I'm really motivated to learn!
What you "edited into OP" currently makes no sense at all. You allocated memory with `malloc` and stored a pointer to it in `s`. Then you completely overwrote `s` with another pointer returned by `gnu_get_libc_version()`. The memory you allocated is now a memory leak. Why did you allocate it then? If you want to store the string returned by `gnu_get_libc_version()` in your own allocated memory, you should use `strcpy` char *s = malloc(256 * sizeof(char)); strcpy(s, gnu_get_libc_version()); printf("GNU libc version: %s\n", s); free(s); Note that in this case you have to get rid of `const` on `s`.
&gt; Now what binary will these create? It is unknown. If label is further than 12 bits from pc it will create 3 new places in memory. 2 instructions for a long Branch plus a literal pool. The binary is known. With the full context of the assembly, which includes all of the labels and their locations, the binary can be calculated by a person. Maybe *you* can't figure out which binary will be created, but that does not mean it is impossible. The assembler checks the distance of the label from the current PC and then it knows what type of branch to use. A human can do just the very same thing. A human can always know the binary being created from an assembly, but a human can never do the same with C (or any high level lang).
Check out the new boston youtube channel he has great videos...
This makes sense. I've never looked into hash table, so am not sure what it is.
Now you have a term you can use to learn more. That's why I just used the word...you'll understand it better if you do some research on what it is. Sometimes you just need to know the right terms to use to find what you need.
You want a function pointer, not a function call: pthread_create( &amp;tid[i], NULL, &amp;listenTran, &amp;fdsTran[i] ); 
Thanks for your reply. I thought this as well, but the function is already defined as a pointer: &gt; void *listenTran(void *fdListenPtr)&gt; {...}
np :) For future reference, function pointers looks like this: int (*func)(int arg); or less commonly: typedef int (func)(int arg); func* f;
`return(0);` is a way to make return look like a function, but the basis of it is that parenthesis are ignored and just group things. All in all, I would recommend avoiding `return(0);` because it'll confuse people.
Thanks all. I'm curious then, why do some reasonable well known game developers (e.g. Casey Muratori) use the return(0) method? 
no problem here's the code at pastebin: http://pastebin.com/SnrqHVEb
I suppose some people want consistency with function expressions. I wouldn't read much into it, and I certainly wouldn't emulate that particular personal tic. 
I started writing C back in the K&amp;R days, and it took me a very long time to get use to NOT using parens with return.
Just as an FYI you don't need to actually return 0 at the end of main if you are compiling c99 or later. Not sure about ansi though. Not sure what's up with the downvotes, try it yourselves/google it if you don't believe me lol.
Pseudocode showing numbers 0-4, you should be able to adopt it to your needs easy enough unsigned cnt[5] = {0,0,0,0,0}; for(i = 0; i &lt; 500; i++) { cnt[rnd()%5]++; }
That works but it's terribly inefficient, try this: for(i = 0; i &lt; 500; i++) cnt[rand()%20]++; If you actually have to print each of the 500 values then just store the result of rand to an intermediate variable and use it to both print and index the array. for(i = 0; i &lt; 500; i++) { r = rand()%20; print(r); cnt[r]++; } Then to print the sum of each: for(i=0; i&lt;20; i++) print(cnt[i]); As you said this fills array index 0-19, not 1 to 20, so just adjust it when you print. (obviously this is all pseudocode, use printf correctly and add formatting...)
&gt; Gcc just ceases to work No, it isn't gcc that stops working, it's *your* program that stops working. Turn on all warnings in your compiler, and pay attention to what they say. $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:18:72: warning: format specifies type 'char *' but the argument has type 'float' [-Wformat] ...&amp;f, longitude: %f, info: '%s'}", latitude, longitude, info); ~~ ^~~~~~~~~ %f program.c:18:83: warning: data argument not used by format string [-Wformat-extra-args] ..."{latitude: &amp;f, longitude: %f, info: '%s'}", latitude, longitude, i... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ 2 warnings generated.
return is not a function, so the () brackets are unnecessary. Using the brackets means you type more, and since you are a programmer (another word for lazy), you should not use them! :)
[This](http://www.amazon.com/Operating-Systems-Principles-Lubomir-Bic/dp/0130266116) is not a book on C, but is a good read for you anyway in regards to those topics.
Thanks, How do I turn on warnings in GCC command line? I just started using gcc and I like it but still learning it. Appreciate the help tons Bill
Please indent your code with four spaces so it appears in a mono-space font.
`-Wall` is enough to turn on the interesting warnings. You might not want to take the warnings produced by `-Wextra -pedantic` too serious. `-std=c99` is not an option to configure warnings.
["Operating Systems: Three Easy Pieces"](http://pages.cs.wisc.edu/~remzi/OSTEP/) is a great book and available for free online, although support the authors and order a hardcopy off Lulu if you can.
It's a statement, not a function. Unnecessary parens and lack of space is misleading. 
It doesn't apply to C, but in C++ there's a good reason to avoid the parentheses: in certain circumstances they can, unfortunately, change the meaning of the program.
&gt; However, the popularity of this pattern of allocating row memory separately for each row always puzzled me With allocating rows seperately you have the exact amount of memory needed instead. If you do all at once you may end up using more memory than needed.
There was a time when they were required, so some programmers do it habitually. I also don't really think this indicates a lack of 'being lazy' (not that I'm necessarily sure that's good advice), any more than something line aligning function call arguments that spill onto the next line does.
It doesn't matter at all. Some people also write their ifs like `if( foo )` instead of `if (foo)`. Despite what some people in this thread would tell you, it is a purely aesthetic choice.
Yes, but that would apply in situations when one's building a true jagged array with rows of different length and maybe some rows even missing. But in this example the OP wants to have a full square `rows x cols` matrix. In such cases allocating rows independently just generates more heat then light.
Sorry -- you're right.
Your submission is not on topic for this subreddit. I'm not quite sure what you're looking for, but /r/C_Programming is not the right place to hire people. I've removed your submission. Please post elsewhere.
A neat data structure for that is a [trie](http://en.wikipedia.org/wiki/Trie), but that highly depends on what you actually plan to do…
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Trie**](https://en.wikipedia.org/wiki/Trie): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), a __trie__, also called __digital tree__ and sometimes __[radix tree](https://en.wikipedia.org/wiki/Radix_tree)__ or __prefix tree__ (as they can be searched by prefixes), is an [ordered tree](https://en.wikipedia.org/wiki/Ordered_tree_data_structure) [data structure](https://en.wikipedia.org/wiki/Data_structure) that is used to store a [dynamic set](https://en.wikipedia.org/wiki/Set_(abstract_data_type\)) or [associative array](https://en.wikipedia.org/wiki/Associative_array) where the keys are usually [strings](https://en.wikipedia.org/wiki/String_(computer_science\)). Unlike a [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree), no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common [prefix](https://en.wikipedia.org/wiki/Prefix) of the string associated with that node, and the root is associated with the [empty string](https://en.wikipedia.org/wiki/String_(computer_science\)). Values are normally not associated with every node, only with leaves and some inner nodes that correspond to keys of interest. For the space-optimized presentation of prefix tree, see [compact prefix tree](https://en.wikipedia.org/wiki/Compact_prefix_tree). &gt;==== &gt;[**Image**](https://i.imgur.com/gYKAA4t.png) [^(i)](https://commons.wikimedia.org/wiki/File:Trie_example.svg) - *A trie for keys "A", "to", "tea", "ted", "ten", "i", "in", and "inn".* --- ^Interesting: [^1996 ^United ^States ^campaign ^finance ^controversy](https://en.wikipedia.org/wiki/1996_United_States_campaign_finance_controversy) ^| [^Trie-Château](https://en.wikipedia.org/wiki/Trie-Ch%C3%A2teau) ^| [^Trie-sur-Baïse](https://en.wikipedia.org/wiki/Trie-sur-Ba%C3%AFse) ^| [^Villers-sur-Trie](https://en.wikipedia.org/wiki/Villers-sur-Trie) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+colgrdm) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+colgrdm)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Directories are a special type of file. The file itself is structured using dirent.h as a definition for the entries in the directory "file" (an array of entries). You can use opendir(), closedir(), and readdir() to open, close, and read directory entries (sequentially). There are other functions as well. Look at the man pages for dirent.h and related calls. There is no way to write a directory file directly. Only the OS can do that. Note too that operations on the directory may occur in the background and calls to readdir() are async to those operations. That is, you may call opendir() and then start doing readdir() calls. Meanwhile, in the background, some other process may change the directory out from underneath you. To "write" the directory file, you need to create files (creat() or link()) or remove them (unlink()) or for "special" files (such as directories or devices, etc.) perform the correct type of OS call (for example for directories, mkdir, rmdir, or rename them).
Given the terminology, I'm guessing the OP is probably using Windows, in which case the Windows API is probably more appropriate: - [File Management Functions](https://msdn.microsoft.com/en-us/library/aa364232.aspx) - [SetFileAttributes](https://msdn.microsoft.com/en-us/library/aa365535.aspx)
Well, "use a trie" is a possible answer to your question.
It was more of a question. I imagine something of this sort is already implemented in Python, or there are libraries for C. If I never need to, I now know to use a trie or hash table.
What platform are you on? The things you want to do work differently on each operating system; I gave [an answer for Plan 9](http://www.reddit.com/r/C_Programming/comments/2m9x32//cm2jejf) before, if you are working on a different platform, please tell me so I can provide an answer for your platform.
Because hardware stores and processes things as bits.
You should check out SDL with opengl http://lazyfoo.net/tutorials/SDL/
Thanks so much! I'm working on this now. What is cnt? I got it to print out 500 numbers, but they're not randomized, just in chronological order. What am I missing to randomize them?
cnt is just what I named my array to store the counts of the different numbers. You're calling the rand() function from the math library?
/thread
Both things I came to mention were already mentioned, so I have to mention them again: Handmade Hero and LazyFoo SDL !
I'm using this to learn, maybe you can also learn something from it: http://c.learncodethehardway.org/
I know how to could, I just need a tool to code on. I"m not sure the word I'm looking is. T_T 
google for visual studio express
...on a specific platform with a specific compiler, and the behavior is probably a compiler bug.
What? No. The standard says that `void f();` declares a function that takes an unspecified number of arguments, not zero arguments. If the call site does not match the eventual definition in terms of number and type of arguments, it's undefined behavior. GHC was doing something stupid and got bit by it. It's not the compiler's fault. Edit: after re-reading the above, I can see that it might be interpreted as me saying that GHC was using `void f();` and not properly matching the number and type of arguments properly, which was not the bug. The bug was using `void f(void);` to declare a function which does not actually take zero arguments. *That* is also undefined behavior. Using `void f();` is the proper way to declare a function with unspecific number of arguments, and fixes the bug in GHC. 
Hmm, it seems I read the patch wrong. But then I went back and read over the standard, and I can't seem to find any explicit mention of function prototype declarations without argument lists. It does mention varargs as requiring the (...), but I'm not sure if that would be the correct application, either. Suffice it to say that I am not a compiler dev.
I think the ELI5 answer is why use an int when a bit will do, and many times you have less than 8 bits to work with
Erm, I don't know if you want to recommend Zed Shaw. There a couple of things posted even on this subreddit as to why you shouldn't
Just coming back to say thanks for the feedback on this. It's a better discussion than I often see.
Woah, I've never seen ideone before. That's amazing, thanks.
Can you explain a little more and/or post a link about the discussions?
Yes, I am. Thanks! I just wasn't sure. 
Who says its hated?
I don't think hated is the right word. But if you look at some of the [historic Unix source code](http://minnie.tuhs.org/cgi-bin/utree.pl), it looks nothing at all like modern C. For instance, there are no prototypes, because the compiler was too primitive to worry about checking function signatures, so it was simply up to the programmer to ensure that the caller and callee matched. If you got it wrong, you'd get a crash or perhaps silent data corruption. That kind of thing would be frowned upon today — you want to make sure you use every opportunity available to catch errors, and having the compiler check each call site against a declaration is considered essential. There's also the problem that K&amp;R style code just looks ugly as sin if you're used to ANSI C. And K&amp;R C lacks a number of features that have been added to the language in the last few decades. Also, Kernighan and Ritchie were involved in the standardization process in the mid/late 80s, so it's misleading to imply that somehow K&amp;R style is what the creators preferred and ANSI C is someone else's vision. All the changes that lead to ANSI C were evolutions of the language that were hashed out during the standardization process. Nobody ever gets it completely right the first time, and the first few versions of any language are likely to contain all kinds of warts and misfires. Telling people to avoid K&amp;R style is not disrespecting the creators, it's telling people not to use old versions of things that have since been improved by those same creators.
that function should return a pseudo-random number, which is actually just a sequence of numbers with no discernible relation or pattern, but the sequence will be the same each time you run the program unless you "seed" the algorithm with a different value each time. The "seed" determines the sequence of numbers rand() returns so you'll get the same sequence each time with the same seed value. A common tactic is using the time (expressed as a number of "ticks" of some period), so it's usually different each time the program is run. If you are getting numbers in numerical order I am not sure what is wrong, could be that you haven't seeded the algorithm and on your platform that produces that behavior but I've never seen that before.
Thank-you ! So could you explain why I don't need to pass other libs (like &lt;stdio.h&gt;) to the compiler ?
Thank-you !
I see, I'm using codeblocks, any idea how to compile them all properly? 
Yes sir, ioquake3 source can be browsed at https://github.com/ioquake/ioq3 Also, id Software's git has some nice, older games you might be interested in looking at: https://github.com/id-Software 
g++ has a compiler flag `-nostdlib` (not quite sure why it is a compiler flag and not a linker flag, but there you have it) which will not link any of the default libraries ; if clang has something imilar then throw it in to get an idea of what's being linked for you. 
The *format string* is what tells `fscanf` what to do. Your `fscanf` uses the following format string: "%79[^\n]\n" * The `[^\n]` part says: read and store all characters until you find end-of-line character `\n`. This is the primary part that basically says "read a full single line". * The `79` part says: read no more than 79 characters * And, as always, reading will always stop if it hits the end-of-file * The `\n` part at the very end says: skip all whitespace characters at the current reading position. `\n` is a whitespace character, so if `fscanf` stopped at `\n`, it will now skip it. Note that the same effect can be achieved by using *any* whitespace character in that position, e.g. one could use `"%79[^\n] "` format for the same effect. So, as directed by that format string, your `fscanf` reads until it hits `\n`. I.e. not the whole file, but a single line of the input stream (assuming it fits into 79 chars). After that it also consumes the end-of-line character and all following whitespace, but doesn't store it into the destination string. Note also that because of that last bit an input file that looks as Hello World will be read as if there are no spaces before `"World"` line - these spaces will be consumed after reading the `"Hello"` line.
Quite simply because the power of text parsing has increased significantly since then. You need to realize CPU's were so slow and memory was so limited that programming languages needed symbols (like $ or %) in front of variables.. and lines of code needed to end in CR-LF or a semi-colon ';' in order to actually compile. The syntax of old books (like K&amp;R) reflect this necessity.
It's not `printf` in particular—all functions work that way. The arguments to any function are evaluated before the function is called.
I suppose it actually changes which library names the driver gives to the linker; it wouldn't give that switch specifically to the linker.
Not exactly. You have a lot of race conditions in what you are describing. For example, one thread can modify the string before the pointer is changed, and so you would lose that part of the string. I realize this might not make much sense to you, which is why you should implement what you are describing and figure out why it doesn't work. That is really how you learn to code.
Binutils has no concept of a sysroot, the last time I checked. You need to specify the full path to anything when you're calling LD. On the other hand, GCC/Clang/Frontend-X do have the concept of a sysroot. The sysroot is usually something like /usr or /usr/local, and this is where they look for include files inside angled brackets (#include &lt;stdio.h&gt;, for instance) as well as default libraries like libstdc++ or libc and libm. Therefore, the front end driver is the one passing the default libraries to LD (which has no such concept of "default" libraries), and that's why you specify -nostdlib to the front end and not the linker.
&gt; I realize this might not make much sense to you, which is why you should implement what you are describing and figure out why it doesn't work. This isn't generally an amazing idea especially for multithreaded code, because the race conditions are very difficult to debug unless you know exactly what you're doing. OP seems not to be very familiar with threading in general, so the better option is to do a lot of reading on the topic until (s)he's more confident in the concepts.
These headers aren't available for programming on Windows. Turbo C++ makes DOS programs, which can do all these things. There are mechanisms to get similar results for Windows, but they work differently.
I'm on mobile so bear with me. I can elaborate when I'm next to an actual keyboard. With a pipe (created pre fork) you must (after the fork): - close the stdout of the kid - close the read end of the pipe from the kid - use dup2 to copy the write end of the pipe to the stdout fileno for the kid - close the now redundant write end of the pipe from the kid - close the write end of the pipe from the parent Look for `man popen`. If I recall correctly it has the popen opened up showing its inner workings. Seem a little complicated at first but its really great stuff and actually not that hard at all. 
Thank-you.
There is [libspec](https://github.com/Chase-san/libspec) one of my repos, it's a library thought and uses packed structs, and it only has about 70 functions. I am not sure what you need it for, so it's hard to be sure what you are looking for. Other libraries you could try are like all the ones for netsurf.
Sure you can. You just have to be careful with the dups and closes. Just remember that kids gets new instances of the same file descriptors. The dup2 can then be used to effectively move a file descriptor to STDIN_FILENO/STDOUT_FILENO depending on need as long as you remember to close what ever it has. Something like this (I'm not putting this through a compiler now, so take this as a pseudocode): int fds1[2]; pipe(fds1); // create unnamed pipe, 0 is read end and 1 is write end int kid1,kid2; if (0==(kid1=fork())) { close(STDIN_FILENO); // doesn't need stdin close(STDOUT_FILENO); // need the fd for the pipe dup2(fds1[1],STDOUT_FILENE); // clone the write end to stdout close(fds1[1]); // not needed anymore close(fds1[0]); // not needed by this child at all // exec what you want with execv or similar // it never returns } close(fds1[1]); // not used by anyone but the kid1 // make another pipe if you need to catch the output of kid2 if (0==(kid2=fork())) { close(STDIN_FILENO); // make room for pipe dup2(fds1[0],STDIN_FILENO); // copy pipe out to stdin of kid2 close(fds1[0]); // not needed anymore // again exec the process you want for kid2 } close(fds1[0]); // not used by anyone but the kid2 Something along those lines anyway. More pipes if you need more chaining. You could also grab the stderr to a separate pipe or even close/dup2 there in the kid1 with the fds[1] and STDERR_FILENO, which is the equivalent of 2&gt;&amp;1, but that depends entirely on what you want/need. If you need to read the file descriptors yourself I suggest you look into `epoll_wait` et al. 
"independent of complex make-files"? I think you'll find that most larger pieces of compiled software end up having an at least somewhat involved build-system, since they need to be build somehow....
Redis, by far. Code base is small and well documented. It uses some macros, some static functions, pointers-to-pointers, nested structs, etc. [github.com/antirez/redis](https://github.com/antirez/redis) 
http://www.quora.com/How-did-game-developers-pack-entire-games-into-so-little-memory-twenty-five-years-ago Read the naughty dog post, 2nd from the top. A relevant excerpt: &gt; This was after we'd already exhausted the usual tricks of, e.g., stuffing data into the lower two bits of pointers (which only works because all addresses on the R3000 were 4-byte aligned). The way you would store data like that would be using bitwise operators. 
Seconding this. Whenever someone looks for a C codebase to study, Redis is the first thing that comes to my mind.
the simplest way is int (*array)[rows][cols] = malloc(sizeof(*array)); free(array); 
I've spend some time on it, and Ive got it to work for the most part implementing a doubly link list from what I see. The problem is the time it takes to compile takes ages and Im not sure why is that. https://github.com/douseme/practicum3/blob/master/first%20file Here is the modified version of the code. If you can help me out and check the code to see where I can change to make it compile faster?
In this case the concept of "portable" code apparently implies code that will work as intended on hopelessly broken compilers. It might have been useful 25 years ago, when sometimes people had no choice but rely on broken compilers. But why would one write code for such compilers today?
I know. My question is: is the OP's question intended to be about language features or is it about code formatting style?
Yes, but there are many ways to provide legacy support. Doing it through writing "portable" code, i.e. sinking all code down to an unjustifiably low common denominator, is not the wisest strategy in my opinion.
"How to obfuscate your C code by supporting what-if scenarios for running on 25-year-old compilers which would probably just crash when compiling your code anyway"
So this is what I have. I guess I'm just not sure how to use srand. Do you use the random function with it (like I have below) or can it be used on its own? int ran_num; int i; srand(1); for(i=0; i&lt;=1; i++){ ran_num=(rand()%6); printf("%d \n", ran_num); } return 0; } 
The usual way to use srand is: srand(time(NULL)); // randomize seed after you `#include &lt;time.h&gt;` at the top. Your code should run OK, what problem are you having?
I'm having trouble understanding your problem, and your code's formatting is rather broken. Four spaces before each line will make reddit format it right, so convert all those tabs to spaces. Can you be a little more explicit about the task you're trying to accomplish? This whole rearranging an array of characters thing seems a bit odd to me.
I tried having a 2d array beforehand. Unfortunately writing the code this way made it always find a match in compare. I've made a seperate file with your suggestions and I still get the same problem as before
Style as in Code Formatting, not about the features which I think they're great.
You might want to rephrase the question now knowing the following: - a char in C is a character, one single letter, a signed byte in reality - a token is a shortish string, i.e. a char array "Move to the front" is ambiguous a bit, too. You mean to insert to the very front? or perhaps insert it next to the duplicate? And then what? Do you need to print them out or what? If it's chars you're operating with ditch the strtok and have a look at memmove/memcpy (especially if you need to insert chars into a char array). If you only need to print them in order you could mark printed chars with 0 and not print them or what ever. If it's tokens you're supposed to operate with you're going to need an array or strings, i.e. an array of char arrays.
The SQLite uses [amalgamation](http://www.sqlite.org/howtocompile.html) to combine all the source into one big file in order to get better optimization. This could work nicely for you.
&gt; I'm not sure how to do the opposite- show how many times 5 divides into that number. That's just regular division. 
It is asked to use 5 functions, you defined and used only one.
yeah, i realized that now. I'm still confused as to how this code would look. Could someone show me as I am still relatively new to coding.
Have you ever made a function outside of main? If not, there's a good place to start. Pick one of those required functions and attempt to make it. 
Normally I wouldn't post a full solution, because there's much to be gained by figuring it out yourself. But, sometimes you need to see the answer... #include &lt;stdio.h&gt; #include &lt;math.h&gt; void read(int *a, int *b, int *c) { scanf("%d %d %d", a, b, c); } void print(int a, int b, int c) { printf("%d %d %d\n", a, b, c); } void reverse(int a, int b, int c) { print(c, b, a); } void triangle(int b, int h) { printf("%f\n", b + h + sqrt(b * b + h * h)); printf("%f\n", 0.5 * b * h); } int main() { int a, b, c; read(&amp;a, &amp;b, &amp;c); print(a, b, c); reverse(a, b, c); triangle(a, b); return 0; } 
 void b( void ) { /* do stuff */; } int main( ) { b(); return 0; } Phone level coding. Define and implement a function b, b is called by main.
My gut tells me he did not get an F yet. Assignment not due yet.
I considered that. Or the assignment could be due but there's a window to re-work it. In the end, if OP decides to just cheat from my code, it'll only hurt in the end ... and I'm OK with that.
Honestly, who cares, this stuff is really simple. I hope he understands why you had to pass read the addresses of a b and c, to me that's the most important takeaway. 
okay, thanks. Yeah that is supposed to say state. Sorry.
I was thinking that because the high precedence of the array operator you have to read it like char *(state[]). It got mixed up in my head. 
So to do this the way I intended, I have to make a two dimensional pointer (lets call it "state") and allocate memory the sizeof(4*char[]*MAX)(MAX is number of characters in the state with the most letters), and initialize four arrays to a string of states(lets call the arrays state1-4). Then assign each array to the state pointer like this: state[0]=state1; state[1]=state2; and so on? Is there an easier way to initialize the 2 dimensional pointer like the way you can with the array of pointers to char in the exercise? Do I have to ask this in another post? Edit: Nvm I think I see a better way. Ill try it and if it works thanks for your time. If it doesnt I make another post.
nah the assignment was due last week and was graded this morning. http://imgur.com/sWstk9d
Seconded, JCs' Q3 engine is a wonderful thing to play around with.
Sorry, I'm new to this, where should I include Minlength? I thought I was including it by having "sizeof(buf)" in the while loop. 
&gt; C is not a "dynamic" language, so getting minlength and then creating, in the same bloc char buf[minlength]; &gt; doesn't work. Actually it does work since C99. I too just found out about this about a month ago: https://www.reddit.com/r/C_Programming/comments/2s0ra7/since_when_have_we_been_able_to_create_variable/
Oh! Nice to know. I still won't be able to use it, because critical embedded, but still.
Ok Thanks, Sorry, I'm just used to coding in Java and this type of accessing files in C is new to me. How would I check size of the string stored in the buffer? Thanks for all your help
Yeah, I read several pages on this several times. I still managed to get it backwards in my head while typing it out. Btw, do you know what a pointer to an array of char would be useful for. I am having a hard time thinking of something. The array of pointers to char I get, but the other way around it seems no different than declaring the array and pointer separately and then assigning the array to the pointer like so: char *p, arr[SIZE]; p=arr; Am I wrong?
I'm trying that right now but it doesn't print anything anymore while(fgets(line,sizeof(buf),file1)!=NULL){ printf("%d",strlen(buf)); if(strlen(buf)&gt;minlength){ fputs(line,fileo); printf("\n%d",len); }//end if }//end while The printf() for strlen(buf) just displays 1's over and over for each line. 
it is unclean, it should be: while(fgets(line,sizeof(line),file1)!=NULL){ otherwise you are supposed to only read and put sizeof(buf) (==5 if minlength==5) char into line.
I discovered while testing this that `strtoul` is bugged on Windows, converting `"-4294967300"` , or any value lower than the negative of `ULONG_MAX`, actually returns `1` (????) It seems that it is selecting the return value to indicate that an error occurred , before it is applying the negation. 
Yes. You said "char" when you meant "word," which makes your question very confusing. Now, as for your problem, if the desired outcome is just to determine the histogram of word appearances, I would suggest approaching it slightly differently. Build a dictionary by making two arrays: one with the word, and another with ints holding the number of times the word has been encountered. Each time you encounter a word, search the dictionary for it and increment its count if it exists. Otherwise add the word to the dictionary. At the end, you can do another pass on the dictionary to sort it by occurrence count. This way makes a lot more sense, as inserting an item into the beginning of an array in C is a difficult and inefficient task.
fprintf() works just like printf() except it writes to the file specified.
libm, libreadline, libpthread
I recommend using stack overflow to get answers like this it will save you time and you will get critical input that will help you advance your skills in programming :)
My gut feeling is that str_to_uint32 should return an error on a string starting with a dash, as in "this value can not be converted to an unsigned integer, sorry". Otherwise you'd introduce a similar problem to the one you (rightly) complained about, i.e. getting a return value &lt;x&gt; and having no way to know whether the original string was "&lt;x&gt;" or "-&lt;x&gt;".
There are a number of problems with your code, but the only thing immediately stopping you is that you haven't prototyped your function before you used it. By this I mean that you need the line double* intArrayToDouble (int array [], int size); before your main function. The C compiler is very straightforward in its approach. It sees that you're trying to use intArrayToDouble in your main, but since you've never defined it (i.e. written the function body) anywhere above it, it doesn't know what to do. If you prototype the function above, then the compiler assumes that that function exists and will have a definition somewhere else. In any case, /u/zifyoip is giving you really good advice. The better you get at looking at and understanding compiler errors, the better off you'll be. Also, here is a good reference for asking better questions (and also a better location overall for asking questions) the next time you want some help: http://stackoverflow.com/help/how-to-ask.
You might find this [code](http://pastebin.com/fu3jJ5sx) helpful. It uses a simple For loop for the delay.
http://svnweb.freebsd.org/base/head/lib/libc/stdlib/strtonum.c?view=markup&amp;pathrev=156707
No. You have to declare them before the function you're using them in like this: double* intArrayToDouble (int array [], int size); int main() { ... If you put this in the end of main, you'll see it works ok. int i; for (i=0;i&lt;10;i++) printf("%f\n",ptr[i]); 
Lookup fgetc for the function on collecting user input. Everything else is an if/else statement.
And `strtonum` isn't very good either. Returning errors as a string is a really shitty idea.
You can always use `sscanf`. It supports a lot of things and is only marginally slower than `strtoul`.
Please show us what you have done so far so we can provide more detailed help to you. `sleep()` might be a bit unsuitable since it can't sleep for less than one second. There are other, platform-dependent, functions for sleeping. If you tell us what platform you are working on, we can provide further information to you.
I'm a fan of libevent, but it's not really essential. Just nice. 
Nice that it makes it easy to cap the values. That's handy. Bad that it doesn't let you specify the base to convert in. That's one of the big reasons to use `strtol` in the first place instead of the even more brain-dead `atoi`.
I wonder if this subreddit needs a FAQ/guide to debugging.
Neat article, I really like the container_of trick
I think that might have been a joke.
depending on what you're coding, curses, libxml2, libcurl, some graphics library like gtk+, wxwidgets, qt, etc. SDL. libao seems useful for portable audio but I haven't started coding with it yet.
So I'm trying to run this code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; double* intArrayToDouble (int array [], int size); int main() { int x [10] = {1,2,3,4,5,6,7,8,9,10}; int n = sizeof(x) / sizeof(int); double y [10]; double *ptr; ptr = intArrayToDouble(x, n); int i; for (i = 0; i &lt; n; i++){ printf("%lf \n" ,x[i]); } return 0; } double* intArrayToDouble (int array [], int size){ int *a = array; int n = size; double *b = malloc(sizeof(double)*n); int i; for(i = 0; i &lt; n; i++) { b[i] = (double) a[i]; } return b; } And it is giving me some weird long numbers (not memory addresses). I don't seem to understand the algo.
THANK YOU SO MUCH! I thought my code implementation was wrong but it was correct i was not just printing the arrays properly and did not had that declaration before the main. Thank you, my code seems to work properly now. :)
Never mind, the algo is correct the print statement in the main was wrong. It should be something like this which /u/kynde suggested: int i; for (i=0;i&lt;10;i++) printf("%f\n",ptr[i]);
Your code is functionally equivalent to this code int main() { int x [10] = {1,2,3,4,5,6,7,8,9,10}; int n = sizeof(x) / sizeof(int); int i; for (i = 0; i &lt; n; i++){ printf("%lf \n" ,x[i]); } return 0; } Your code takes an array `x` of `int` elements and attempts to print these integers using `%lf` format in `printf`. This makes no sense whatsoever. It is illegal to print `int` values using `%lf` format. The behavior is undefined. This is why you gets your strange values in the output. Your original code calls `intArrayToDouble` function, but whatever this function does is not affecting what your code prints in any way. So we can discard `intArrayToDouble` altogether. Why did you write that `intArrayToDouble` function and why did you call it, if in the rest of the code you are completely ignoring the results of that function call? The title of your question seems to imply that you need to "convert and array of ints to double". OK, fair enough. This is what `intArrayToDouble` is apparently intended to do. But why are you ignoring the results of `intArrayToDouble`? Why are you printing `x` instead of printing the result of `intArrayToDouble`?
Bad idea, because the comparison operators always return 1 for true, not&amp;nbsp;−1. You shouldn't be using the `~`&amp;nbsp;operator to negate logical values anyway. That's the bitwise complement operator, not the logical complement operator. The logical complement operator is&amp;nbsp;`!`.
Isn't DirectX windows only?
Technique for declaring globals in a multi-file program avoiding having multiple definitions. In common header file #ifdef MAIN #define EXTR #else #define EXTR extern #endif Then declare globals as EXTR int myglobal; In one of the source files #define MAIN 
It is Microsoft-only, but that is certainly no reason to avoid learning it.
Would you say that C++ has a boolean type? Most reasonable people say that it does. I mean, it has the kewords `bool`, `true`, and `false`. And yet, all your complaints about equality apply to C++. `2` does not equal `true`. **Nor should it**. They are distinct concepts. Yes, you can use non-boolean values in conditional statements and operators, but nothing in that implies equality. And if you go through the integer promotion rules, you'll quickly realize why this is. Now, about C's boolean type. C99 introduced the keyword `_Bool`. This is not a `typedef` or `#define`. Now, if you include `&lt;stdbool.h&gt;`, you'll get a `typedef` for `bool`, but that's for convenience and doesn't affect the core situation. You're right that `true` and `false`, though. If you include `&lt;stdbool.h&gt;`, you get macros for both, defined as 1 and 0. That doesn't bother me, though. It's kinda like how character literals are in C: they're actually integers, but with convenient syntax. Does that mean that C doesn't have a character type? Of note, conversion to `_Bool` works slightly differently. `(int)0.5` evaluates to 0, while `(_Bool)0.5` evaluates to 1. This is an important distinction! So, let's look at your example of `2==true`. By C's rules, this promotes `true` (defined as 1) to an integer and then compares the two, which are obviously different. If we want to do a boolean comparison, the code should be written as `(_Bool)2 == true` ... which evaluates exactly as you expect. In summary: you're wrong.
&gt; Your statement is incorrect. The _Bool type may be larger than one bit Yes, but the standard says **6.3.1.2 Boolean type** *When any scalar value is converted to _Bool, the result is 0 if the value compares equal to 0; otherwise, the result is 1.* So (_Bool)2 == 1 yields 1. Also, **6.7.2.1 Structure and union specifiers** *122) While the number of bits in a _Bool object is at least CHAR_BIT, the width (number of sign and value bits) of a _Bool may be just 1 bit.* The maximum width of a _Bool bit-field is [1 with GCC](http://ideone.com/3LRczr) (8 with LLVM).
I dont want to use windows. Im a Linux guy
So that `[0]` doesn't bind to something inside `arr`. It's good practice to parenthesize every use of a macro argument inside the macro expansion .
....yuck 
lol..... So teach me something. Why you no like?
I'd prefer just not to have the macro. Place the `extern` declarations where you want them, and the definitions where you want them. The compiler will give an error if the definition doesn't match the declaration. , so long as the file with the definition has the header with the `extern` included. If you're worried about the amount of typing, then place all of your globals in a `struct` , then you only have one `extern` and one definition. Actually this helps with naming clashes as well; since all of your variables will be accessed as something like `globals.foo` then you won't cause a problem if there is a function called `foo` or a local variable that silently shadows the global. Also , if you have so many globals that this problem is coming up then maybe your code could be better designed. 
I see. It's 30 year old code that has fairly strict conventions. The main idea I believe was just to prevent declarations occurring in two places. The programs are fairly small but there are hundreds of them all following basically the same pattern. Each program is essentially a class with methods exposed via messages. The globals operate like private variables within the class. Each program has a header with methods stubbed off in individual files depending on size.
I think I'm still missing something here, I intend to write a function which would take in an array of ints and convert it to double. Printing is secondary and just testing. But I guess what you are saying makes sense. I'm new to pointers and doing this task so I will still try to debug my code line by line and see what is happening. Any help with how should i use that function would be appreciated! :)
tl;dr: New C programmers should spend some time learning the standard library, otherwise you'll spend years reimplementing stuff that is already there.
Or do as the APL folk do: typedef char C, *S; typedef long long I; typedef unsigned long long U; typedef double F;
I'm not going to sleep tonight knowing you're missing an el at the end of all your streq() calls. 
What do you mean by 'el'?
Um... exactly the same thing it prints out when run normally? &gt;0 1 1.500000 &gt;0 1 2.400000 
If you pay me ill do all your assigments for you and show you how I did it. Serious
streql() rather than streq(). Just being OCD. 
But it has nothing to do with longs...
Oh, you meant the name of the letter 'el'. Never thought about that. What are the names of letters 'h', 'x' and 'q' in english? 
Hmmm. ecks and cue? Not sure about H. Maybe ach. I was more concerned with misinterpreting l for 1 (one) so I opted for the el, but I see I even confused things further. Oh well. So, do you include a memeq() as well? I poked around our codebase and found streql() and memeql() calls added a long long time ago in one of our utility libs, so I guess this is fairly common. 
Pretty useful: glib without the GObject madness. It provides some good multithreading functions that are promised to work seamlessly in *nix and Windows.
This is not sorting, it's finding the min of the table d.
You're right. Wow, somehow I've skipped the first line... didn't see the first loop, sorry.
Thank you, I thought it might be but I wasn't sure and my prof had no clue what selection sort was. He's not that great xD
Sooooooo, fflush?
Why is it a tradition in C to use completely useless identifiers like `d` and `wheremin`
&gt; my prof had no clue what selection sort was [ugh...](http://i.imgur.com/iWKad22.jpg)
Depends on the platform. Some implementations allow `fflush` to be called on an input stream and in that case will empty their pending buffer. However, in general and in POSIX compliant implementations, you're 100% right.
The right way to do it is to read characters until a newline with something like errno = 0; ret = scanf("%d", &amp;val); if (errno != 0) /* Make sure we had an error */ while (!ret &amp;&amp; getc() != '\n') {}; /* Consume input to newline */
I wish they were defined without the `_t`. So: `int8`, `uint8`, `int16`, `uint16`, and so on.
d I don't get, but I thought wheremin was pretty obviously "where" the "min" is (ie its index.)
Well -- when it counts you should use the size and sign specific types defined in inttypes.h like uint32_t etc. Also if you're writing endianness dependent data to a file or over a network you should convert it to known representation using something like htons() or maybe even converting the numbers to strings.
In cases like this I work out (by hand, for a few representative cases) what the correct value should be, and I compare the value that my program generates with these "baseline" values. When they match, the test passes. When they don't, I have to investigate. Any problems that occur afterwards get fixed and maybe added to the test set.
I have an old apple machine I use for testing whether my code works on BE. But other than that, static analysis tools will also give you warnings about endianess issues fairly reliably, in my experience.
I may have to. Problem is it includes external libraries (ncurses). Would ncurses have to be installed on the client as well? I come from creating Java jars that have the libraries exported to the executable JAR so the world of low-level C is somewhat new to me. Thanks for the tip.
The type of the format picture is LPCWSTR, a long pointer to a constant wide-character string. What you have passed is a narrow string, so expect horrible things if your somehow manage to force it through. To fix this, simply prefix your string with an L: `L"myformatstring"`. When you do this, the underlying type of your string changes from `char` to `wchar_t`, which is exactly what Windows wants. 
Thanks
Well I'm not actually sure that's why he called it that, he showed us one right before that he called "exchange maximum sort" and it was just the same except start at The end and work backwards finding the new maximum. The same sort but reversed I think. I still don't fully understand .. I get that it finds the minimum and places it appropriately, then finds the new minimum. Finding the minimum doesn't confuse me, but how does it place it in the appropriate position? 
There are 4 areas you can run into trouble with ordering: * Unions * Byte arrays * Bit fields/masks * Typecasting pointers Intel provides this code to check at run-time what the current ordering is: struct { a:4, b:4 }s; char test; s.a = 4; s.b: 7; test = *(char*)&amp;s; if (test == 0x47) // Big else // Little When the code segfaults, get the current IP of the process so you can know which area of your code caused the problem.
Thank you for your response. I changed my char declaration to : wchar_t newdate[150] I still get the same output, it builds but I literally get: ddd','yyyy I'm not understanding the how (syntax I guess) to put the L in front of newdate, can you elaborate on that?
Once I get this working, I'd really like to move next to adding and subtracting days from the current date. Googling has yielded lots of *nix examples, but I haven't found anything yet that is cross platform or windows specific.
The problem is not with the output array you're passing in, although that would have suffered some very interesting issues of its own being passed in as a `char*` rather than a `wchar_t*`. The problem your compiler was complaining about was the type of your *format picture string*; it is a `char` string, but Windows wants a `wchar_t` string. This is accomplished by prepending an L to the string literal where you're passing it into the function: GetDateFormat (LOCALE_USER_DEFAULT, 0, &amp;str_t, L"ddd','yyyy", newdate, 150); Now, it will work, but when it writes its UTF-16 output into your `char` array, you'll be left with a string of length 1 or 0 depending on byte ordering -- because you'll be getting ASCII characters encoded in two bytes, which results in alternating bytes of ANSI and NULL and thus much confusion. Changing your `char[150]` to a `wchar_t[150]` as you said above fixes this problem. Your comment about `TCHAR`s is interesting... Windows allows your program to operate either in "ASCII mode" or "UTF-16 mode" (or, indeed, to switch between them arbitrarily and with reckless abandon), and it has two sets of functions for dealing with them. Nearly every "function" you're calling of the form `WinFunctionEx` is actually a macro that expands to either `WinFunctionExA` or `WinFunctionExW` depending on whether or not the constant UNICODE is defined; likewise, `TCHAR` is a macro that expands either to `char` or `wchar_t` as necessary for proper interop, and a macro `TEXT` can be used to wrap string literals that need to be conditionally narrow or wide. This is all for the purpose of easy retooling of software between ASCII and UTF-16, though it introduces its own maintenance headaches. Anyway, the proper encoding-agnostic way to write your code would be thusly: SYSTEMTIME str_t; GetSystemTime(&amp;str_t); TCHAR newdate[150]; GetDateFormat(LOCALE_USER_DEFAULT, 0, &amp;str_t, TEXT("ddd','yyyy"), newdate, 150); puts(newdate); This way, when UNICODE is defined and GetDateFormatW is called, all your arguments and variables are wide; but when UNICODE is undefined and GetDateFormatA is called, everything is similarly narrow.
I see, thanks for the explanation. I've got a new error now, but I'd like to play with it some before asking for help or I'll never learn. Thank you again. 
No problem; this is all overwhelming when you're just getting into it, and the documentation on MSDN is less than thorough (or nonexistent) in places.. If you have any other questions or problems, drop me a PM.
The [Windows API](https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516\(v=vs.85\).aspx) is wonderfully documented by Microsoft, and most functions have example code of how to use them as well. [This page has all of the information](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950\(v=vs.85\).aspx) you will need to add &amp; subtract dates and times in Windows. Also note that http://www.msdn.com is a great resource for Microsoft developers.
Firstly, the pointer in that solution is of type `char *`, not `char`, as you seem to incorrectly believe. A pointer of type `char *` is guaranteed to be large enough to store any data address. Secondly, the presented "solution" is obviously wrong. In order to point to an `int` variable the pointer has to be declared with `int *` type, not `char *` type. E.g. `int *p = &amp;x`. Formally, what they have there should not even compile.
dam Sorry first time here. Not quite sure how to post code into the text box yet
Two things about your code that I see immediatelly: 1. It's C++, not C. 2. It's converting between seconds, hours and minutes but you say it's for dollars, nickles and so on.
&gt;Formally, what they have there should not even compile. Char pointer is an exception, it can point to anything for pointer arithmetic reasons Also undefined behavior can do anything it wants, including working as expected. Its implementation specific
&gt;Firstly, the pointer in that solution is of type `char *`, not `char`, as you seem to incorrectly believe. This is an important distinction. &gt;A pointer of type `char *` is guaranteed to be large enough to store any data address. A pointer of type char * can be 32 or 64 bits ( or some other platform-dependant size ). A char is 8 bits. 
There's a paragraph on the submission site that tells you how to submit code. You could have also clicked on “formatting guide.” This question is about C++, not C and is offtopic here. I have now removed this post. Please ask elsewhere.
C is a very broad topic. Can you narrow it down?
No, just talks on anything that is related to programming in C. Have you taken a look at the list?
You will have a hard time finding talks about C in the same fashion as for the other programming languages. C doesn't stand out as a language and there are no C specific programming techniques. There isn't anything you can do in C that you can't do in any other language; there are very few things that are special about C and I doubt that you are going to find talks about these.
Nice. Thx!
They didn't do this to preserve compatibility. The suffix `_t` is reserved for system types so every new type is going to have an `_t` suffix.
I use UThash constantly.
Look for talks coming out of Linux.conf.au. This one by Rusty springs to mind https://m.youtube.com/watch?v=BEQ3sRakIs0
Your code contains a large amount of rather ridiculous bugs. * Firstly, what is this printf("HEAD OF LIST"); printf(front(Q)); ? Function `printf` requires format string as its first argument. You are passing an `int` value instead. This will simply crash in general case. The compiler, I'm sure, pointed out this error to you. Did you just ignore the diagnostic message? On top of that you are attempting to call `front(Q)` there. But on the very first iteration `Q` had only one element in it and you just removed it by calling `deleteFront`. Which means that on the first iteration `Q` is *empty* at this point. It has no front. Calling `front` on an empty list causes your program to abort immediately. (However, things are even worse because of `deleteFront` problems, see below). * Secondly, look at this //INITIALIZE SOURCE G-&gt;source = s; G-&gt;color[s] = GRAY; G-&gt;distance[s] = 0; G-&gt;parent = NIL; Why are you doing `G-&gt;parent = NIL`? By setting `G-&gt;parent` to null pointer you just lost access to your `G-&gt;parent` array. Later you attempt to do G-&gt;parent[v] = h; but `G-&gt;parent` is a null pointer now. The code will simply crash. I suspect that instead you wanted to say G-&gt;parent[s] = NIL; in the first bit of code, didn't you? * Thirdly, look at `deleteFront(List L)`. `L-&gt;head` is a data member inside `struct listL`. But inside your `deleteFront` function you do free(&amp;(L-&gt;head)); This is just catastrophic nonsense. Why are you trying to call `free` at `&amp;(L-&gt;head)`? Didn't you mean just free(L-&gt;head); ? Where did that extra `&amp;` come from? In this case `L-&gt;head` is the very first member of `struct listL`, which means that pointer `&amp;(L-&gt;head)` concides numerically with `L` itself. I.e. the very first call to `deleteFront(Q)` immediately kills (frees) your entire `Q`. The rest of your `BFS` function attempts to work with `Q`, which is already dead. The memory has been freed by your nonsensical `free` call inside `deleteFront`. * I'm not going to plow through this any further, since this is like trying to shoot an elephant with a pea shooter. I'm sure your code contains more bugs. Do you know how to use a debugger? 
If you want to start a script you can create your own service (/etc/init.d) or modify the /etc/inittab: xx:2345:respawn:/usr/bin/yourscript.sh
Alright thanks, it's now more clear for me of how it works, but what libraries are used to create a GUI app without desktop environment? The app Scratch is a full screen app with a GUI which starts and works without the desktop environment (in this case lxde) running.
In your updated code you're not freeing the strings themselves. For each runtime call to malloc() there should be a call to free(). This is a two-pass approach. You can't always use `rewind()`, such as when the opened file is a fifo or you're reading from a pipe like stdin. You can work around this by dynamically resizing your array with realloc() as you consume lines. Typically you'd just double the total size each time it needs to grow so that it quickly scales to size. 
Ah yes good point I forgot to update that, thanks! I'll look into resizing too.
Remember that pointer arithmetic in&amp;nbsp;C is defined so that `*(a+b)` is exactly equivalent to `a[b]`. That means that incrementing a pointer does not increment the corresponding memory address by&amp;nbsp;1 but by the `sizeof` the pointed-to type. For example, if `sizeof(int) == 4`, then incrementing a pointer-to-`int` will move it 4&amp;nbsp;bytes ahead, not&amp;nbsp;1, and adding&amp;nbsp;5 to a pointer-to-`int` will move it 20&amp;nbsp;bytes ahead, not&amp;nbsp;5.
Oh, I think I see. So since I was casting off of an ***iphdr*** (which *sizeof* reports as having a size of 20), it was actually giving me the memory address that was my original address plus *sizeof* times the 20 that I requested? That would explain why I was getting an offset of 400 instead of an arbitrary number like 228. *sizeof* also gives a size of *20* when fed ***tcphdr***, so that would also explain why results were unchanged when I tried casting at a different point. It also explains why my debug code still printed out each byte as intended (since I used the 1B ***uint8_t***). Thanks! Edit - Said ***iphdr*** when I meant to say ***tcphdr*** Edit #2 - Forgot to say thanks! Edit #3 - Added another example proving your explanation.
I see a few issues here, but the main one to remember is that arrays _are_ pointers*. So when you pass an array to a function, you're already passing by reference. Change this: void shuffle(struct *s[52]){ to this: void shuffle(struct card s[52]){ // Note the type fix, too. and change this: shuffle(&amp;deck[52]); to this: shuffle(deck); You'll also have to change all the -&gt; to . in your shuffle function. _\* There are subtle differences, so I recommend always using the array notation if you're using arrays._
This is quite obviously a homework question. I think if you want help, you're going to have to show at least some honest attempt at solving the problem. We're not here to do your homework for you.
To convert to uppercase, you can use `int toupper(int)` from `&lt;ctype.h&gt;` To convert digits to numbers, you can use this trick : `int digit = character - '0'` To accumulate, well, just add the numbers into a variable... You should be able to do the rest yourself.
I should have mentioned it doesn't work when I try outputting them to different files as well :\ &amp; they do both exist.
Do you know if the fact that the first passaround does not terminate until the killall command gets rid of it keeps it from actually saving the output? This is my only guess right now :\ Edit: just tried it with ./passaround-test -vc 6 localhost 4570, meaning there's an even hopcount and the second one is the one that gets killed by killall, and the second one's output didn't save... so this does seem to be the case. Just have to find a workaround. 
Well, I don't know what your code is, but certainly if the signal happens before the I/O then the I/O won't happen. Or maybe even if the signal happens before your output buffer is flushed depending on the system.
Someone asked about this [just today](http://stackoverflow.com/questions/28663266/c-usage-of-malloc-inside-a-function) on SO
Hm yeah I see what you mean. As for printf() I have deleted it, changed to G-&gt;parent[s] = NIL and change free(L-&gt;head)
If you actually *have a choice*, then the better idea would be to create the recipient object *outside* and then pass it to function for processing. That way you are not tying the function to a specific allocation method. You can pass a static object to it, you can pass a local object to it, you can pass a malloc-ed object to it, or you can pass something allocated with your own allocator. You have full freedom to allocate that recipient object in any way you see fit. The function does not care where that memory came from. This just makes the function more flexible. It decouples the actual functionality of the function from such secondary technical details as memory allocation mechanism. However, you only have such choice if you know the size of the recipient object in advance. In situations when the size is not known, like a string buffer of not yet known length, pre-allocating it on the outside becomes impossible - you simply have no idea how much to allocate. In such cases it is usually the function itself that is responsible for calculating the exact size of the buffer. In such cases you might resort to allocating memory inside the function. This latter approach has the disadvantage of tying the function to a specific allocation method, like `malloc` (unless you develop some sort of polymorphic allocator, configurable from the outside). This is generally not good. So, the third approach would be to write your function as a two-phase function. You call it the first time to a make a "dry run": to calculate the exact size of the dynamic memory block required, but don't actually allocate anything or initialize anything. The function returns the size of the memory block back to you. You allocate the memory in any way you see fit and call the function again, passing that memory to it. This time the function works "for real": it builds the result in the buffer you allocated. An example of such two-phase function is standard `snprintf` function double d = ...; int i = ...; char s[] = ...; /* "Dry run" to calculate buffer size */ int size = snprintf(NULL, 0, "%lf %d %s", d, i, s); assert(size &gt; 0); /* Allocate memory */ char *buffer = malloc(size + 1); assert(buffer != NULL); /* The actual run to form the string */ int written = snprintf(buffer, size + 1, "%lf %d %s", d, i, s); assert(written == size); This approach also has its problems, since you are basically asking the function to do the same work (or almost the same work) twice. But in many (or most) cases it works very well, meaning that its pros outweigh its cons.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; int uppercaseconversion (int c); int digitconversion (int sum, int c); int main() { int c, upper; int sum = 0; printf("Please enter a character or characters "); while (c !='\n') { c = getch(); // Check for a digit if isdigit(c) { digitconversion (sum, c); continue; } // If lowercase, convert to upper case if islower(c) c = uppercaseconversion (int c); if isupper(c) putchar(c); } printf("The sum of the digits is %d\n", sum); return 0; } int uppercaseconversion (int c); { c = toupper(c); return c; } int digitconversion (int sum, int c); { sum += c - '0'; return sum; }
Yes, I thought as much. After your hint about libclang I've played with it a little, and although it looks very interesting it's certainly not trivial. Thanks for the reply!
Your outer array should be an array of pointers to the struct. Then you would access the fields as (correct me if im wrong ive been doing a lot of java lately...) bigArray[0]-&gt;x or bigArray[0].x depending if you wanted the value or the address respectively. Edit: saw the other arrays within the elements. You might want to consider a linked list struct to store the accelData trials as that would let you travel down from the head node of the linked list which you would then save in the index of bigArray. So bigArray would contain the pointer to the head of your linked list for that trial, and if you want the third result you would just do .next until you arrive there.
My general rule of thumb is that a function should do roughly one thing. As soon as a function starts to do two things, it should be split up into two different functions. The relevant question is then how many tasks is each function doing, and how to split it up so each function does only one task.
Two good reasons to allocate early: 1) Performance-critical sections of code should usually avoid allocation (it's slow) 2) Detect out-of-memory situations earlier in your program. I wouldn't say allocating in/out of a function affects readability much, really it comes down to what you need.
Apple strongly discourages static linking. &gt;Warning: Shipping a statically linked binary entails a significant compatibility risk. We strongly recommend that you not do this. If you choose to ignore our advice, please make sure that your customers are informed of this risk.
That's cool!
&gt; instead of just declaring a new variable. Such a variable has automatic storage duration, which means its life ends when the flow of execution leaves the block in which it was declared. int *f(void) { int x = 42; return &amp;x; } This program returns a pointer to a variable whose lifetime ends when the function returns. It's undefined behavior for the caller to dereference that pointer, because it pointed to an object that expired and it is therefore now an invalid pointer, also called a dangling pointer. This function is legal and will compile but it's completely useless. If you're going to return a pointer from a function, it needs to point to something whose lifetime does not end when the function returns. Examples of such things include: - A pointer to an object with static storage duration. This includes global variables as well as function-level statics. - A pointer to an object with dynamic storage duration, which is what you get from `malloc()`/`calloc()`/`realloc()`. - A pointer to an object whose lifetime is guaranteed to outlast the function call. An example of this is when a function is passed a pointer to an object by the caller. That's an implicit guarantee that the object will outlast the function call, because even if it was allocated with automatic storage duration, that allocation had to have occurred in the caller's stack frame, which means its lifetime must include any function calls made in that frame. An example is `strchr()`: #include &lt;string.h&gt; int main(void) { char stuff[] = "abcde"; char *ptr = strchr(stuff, 'c'); *ptr = 0; } `strchr()` returns a pointer, and in this case it's a pointer to an object with automatic storage duration. But that's fine in this case because the object was allocated in `main()`, not in `strchr()`.
It's been three years now since I've used c, so I might be completely off here. I don't see any value inputed into ``classsize``. 
Display_Results.c does not #include Display_Results.h (also, typo? Your link says Dipslay_Results.h), so showGrades and classSize won't be declared when you try to use them there.
Oh, I see now !. It was simpler than I thought. .. Thank you kind person !
* You say "Initialising ... causes ...". However, I don't see any global variables in your code being explicitly *initialized*. All of your global variables seem to be defined in `Dipslay_Results.h` and none of them are explicitly initialized. (Global variables will be zero-initialized automatically anyway, but still *initialization* has nothing to do with your error.) * If you include `Dipslay_Results.h` into multiple implementation files (which is what headers are for), you will create multiple definitions of your variables, which is formally illegal in C. * Variables like `showGrades` are indeed undeclared in `Display_Results.c`. You never declared them there and header `Dipslay_Results.h` is not included into `Display_Results.c`. So, how did you expect the compiler to know anything about `showGrades` in `Display_Results.c`? * "I'm using ifndef in the header files to link the .c files together." - it is not clear what you mean here. Preprocessor directives have no relation to linking whatsoever. You can't "link the .c files together" using preprocessor directives. In any case, don't define variables in header files. If you need a global variable, *declare* it in the header file and place the *definition* in one of the implementation files.
k
* C is a compiled language. Which means that the compiler does not know and does not care what "can happen" or "can't happen" at run-time. The compiler proper will always compile *everything* that you feed to it. The whole code will always be parsed and checked for validity, regardless of whether it "can happen" or "can't happen". In the end, the compiler might decide to discard (optimize away) code that it deems unnecessary, but the code is still required to be valid. You call `div_by_zero()` in your code? You have to declare and define it. Whether the call to `div_by_zero()` can or can't actually happen does not matter. * Your call to `div_by_zero();` is not inside your `if` anyway. It is outside the `if`. If you want to place two statements under `if`, you have to group them into a *compound statement* by enclosing them into `{ ... }`. * `scanf` requires a *pointer* to recipient variable as an argument. This scanf("%f", a); is incorrect. The argument should be `&amp;a`. * You are using uninitialized variable `b`. The behavior of your program is undefined. Which means that absolutely anything can happen. * Your code calculates `b = (b + 5 * a) / a` for whatever initial value of `b`. What made you think that `a &gt; b` "can't happen" after these calculations? Let's say the initial value of `b` is `0` and `a` is `10`. The resultant value of `b` is `5`. `10` is greater than `5`.
&gt;but with a white background Life is meaningless now
Thank you kindly for your reply. I forgot ampersand in my code. However, your last point is invalid - If there are no {...} after compound statement then compiler will compile only one line after statement and jump out of the loop after it finishes. Thank you again!
No, my last point is not invalid. If there's no `{}` around the loop body, the loop body consists of a single statement. Your loop does `b += a` five times, meaning that it calculates `b = b + 5 * a`. After the loop you divide the final value of `b` by `a`, which means that the whole thing calculates `b = (b + 5 * a) / a`. So, one more time, if initially `b` is `0` and `a` is `10`, then the final value of `b` is `5`.
I'm not really sure what you're trying to say here, but you're definitely using the wrong term when you refer to the compiler. Every point BoatMontmorency made is correct. If you're referring to his point about the if block, your code currently looks like this: if (a &gt; b) printf(" Can't happen!"); div_by_zero(); "Can't happen" will be printed out only if a is in fact greater than b when *execution* reaches this point. However, div_by_zero(); will be called regardless of the values of a and b, because it is not part of the if block. If this is the intended behaviour, then the div_by_zero call should not be indented that far. If you only want div_by_zero to be called if a &gt; b, then you need braces like this: if (a &gt; b) { printf(" Can't happen!"); div_by_zero(); }
Thanks for the suggestions people, I appreciate it
**Edit:** The clarify my point program is a noun. Coding is what you do to produce a program, it's a verb. Programming is a silly word to use instead of Coding.
IAR has a lot of special pragma's and built-in keywords to make designing for embedded easier. You will have to read the help files to see what everything does and manually port the code over. This is time consuming, but fairly easy if you know what you are doing.
&gt; In industry they actually use very expensive hardware probes to debug kernel level code. That used to be the case, and still is in some ways, but virtualization/emulation is mostly used now for systems development (at least in my experiences).
Nice. Could you direct me to these guides you mentioned? I'm interested in having a look.
Declare div_by_zero(), asign a value to b
Your malloc() assignation is wrong, as the cast to char, which is not a pointer should hint. Also, whatever you think *sources[l]++ = c; does, I'm fairly sure it doesn't.
Thanks for responding. I was hoping `*sources[l]++ = c` would assign `c` to the block of memory pointed at by the pointer in `sources[l]`, and then move the pointer along one, ready for next char. You're right, it clearly doesn't. Any idea how I would do that?
1) There is a bunch of non-portable stuff in GCC too. 2) The size-limited-output version of IAR compiler is FREE.
Actually, the previous poster is wrong. `*sources[l]++ = c` does exactly what you want it to do. Just like you said, it "assigns `c` to the block of memory pointed at by the pointer in `sources[l]`, and then moves the pointer along one, ready for next char". The problem is that you should not want it. By doing this you are destroying the original value of `sources[l]`. And you need that original value since this is your only access path to the beginning of the string. And, as it has already been noted, `(char) malloc(1000)` makes no sense. `char` is a wrong type to cast the result to. But in reality you should not cast the result of `malloc` at all, to any type, no matter right or wrong.
Im not sure im following you 100% but ill give you more information as to why this all came about, and maybe you can help me some more... I found some example code provided by atmel which states their compiler to be IAR ewaavr or something like that. It includes the header file io.avr and in.avr which are what caused my errors when compiling in atmel studio. I pretty much just want to compile thr code and be able to program an avr without having to use a new compiler or something. 
I'd disagree. I don't remember ever seeing a professional software developer that would use the term "coding" to refer to the process of software development. "Writing code" is probably the closest acceptable form, which is normally used in the industry. But "coding".... "Coding" is mostly encountered in barely coherent questions on StackOverflow asked by obvious newbies. Another word that makes people cringe is "codes" (plural, specifically) used to refer to source code of the program. Source code is always "code", not "codes".
Sorry this was a sarcastic reply to someone's prescriptivist screed about how words work. He deletes it. Well everyone here says coding. Professionals too. 
All of the `*sources[l] = (char) malloc(1000);` lines should be `sources[l] = malloc(1000);`. Actually it'd be better to first count how many characters you are going to be copying, and then allocate just that amount of memory. 
Well, first of all, there is no loop in this program. What you think is a loop is simply a conditional statement; it executes once, increments `i`, and then the program ends. What you wanted is a for loop, like so: for (i = 0; name[i] &gt; 0; ++i) if (i &gt; 0 &amp;&amp; name[i - 1] == ' ') { printf ("%c\n", name[i]); break; } What this does is loop through each character of the string `name`, test if the *previous* character was a space, and if so print the current letter. This is done to prevent running off the end of the array if the last character is a space. Also, you're skipping a line at the end of your first initial; why would you do that? Presumably you want them to be printed beside each other... Now, disregard everything I just said, because the way you're doing it here is unnecessarily complicated. You don't need `cs50.h` or even `string.h`. All you need is `stdio.h`. The first thing you need to know is that `scanf` reads whitespace-delimited input. The second thing you need to know is how to call `scanf`. int main() { char fname[64], lname[64]; printf ("What is your name?\n"); scanf ("%s %s", fname, lname); printf ("Your initials are %c%c.", fname[0], lname[0]); } This solution won't convert lowercase characters to uppercase, but to do that, assuming ASCII input, you can modify the character output like so: printf ("Your initials are %c%c.", fname[0] - 32, lname[0] - 32); Note that this *only* works for alphabetical ASCII input; for anything else, it will produce incorrect output. I leave it up to you to harden it against nonstandard input.
This is not really an answer to your question, so forgive me that this advice is unsolicited: The company I work for used to use Atmel Studio religiously for their projects before I was hired on. I had never used Atmel nor IAR Workbench before in my life. In my spare time I tested out IAR's software at home over month and months. I especially put their system emulator and debugger to the test, which to me are very important features. After many discussions with my coworkers using rational arguments, logic, and a demo of IAR in action, I convinced them to switch over to IAR Workbench, and our company has never looked back. In my opinion, and experience, IAR is far superior to anything I have ever used. Their libraries, compiler, assembler, and debugging features are just... brilliant.
Yes.
+1 on not casting malloc. Malloc returns a `void*`, and that `void*` is promoted to the appropriate type. By mucking with the return value you prevent the compiler from doing type checking for you. You should turn on `-Wall` to catch stuff like this. Edit: fixed markdown eating my `*`. 
&gt; Malloc returns a void Well, `malloc` returns a pointer-to-`void`.
I don't consider myself a "beginner" in C, but I typically do cast malloc to the type I'm mallocing for. Is that really a bad practice? I've never heard some one mention this, but you do make a solid point.
&gt; Just to clear my understanding, the IAR workbench is something you use on top of/ in combination with atmel studio? Nope, absolutely not. We completely replaces Atmel products with IAR products. &gt; but I dont want to deal with annoying 30 day trial software They should have an infinite-license version available with a compile-size limitation. But this limitation is large enough to fully test out the product. In the end, you get what you pay for. I know from personal experience you can email the IAR sales team and negotiate an affordable license fee system for your needs.
Haha that answered just about every question I had. Thank you!
No problem! Everyone has to learn at some point; glad to have been of help. If you have any other questions or if something doesn't work, feel free to reply here or PM me!
Sure! Why not? Most of the libraries try to adhere to there own naming conventions so that they won't clash with other libraries (I think there is some consensus among those library maintainers on how to name variables, functions, defines, etc.). Which libraries do you want to "mix"? 
What would help is if you pointed us to that code. It could be as simple as you just need to #include &lt;avr/io.h&gt; instead , when using gcc, or it could be as involved as having to rewrite it all. It all depends on how the code is written.
ISO C and ANSI C are equivalent standards, controlled by different organizations. The C standard library is a part of these standards. POSIX is an extension of C that provides a lot of extra facilities on top of plain C. (It also specifies things beyond the C language and its APIs, such as command line utilities). There's not a lot of interesting stuff you can do with pure C programs, so POSIX is often needed the more fun stuff like: signals, filesystem management, threading, networks, etc. GNU C isn't really a standard per se, but just a colloquial way of referring to all the quirks and extensions that GCC provides.
thank you
Haha, I wasn't trying to be clever! I think I picked up the syntax from reading K&amp;R.
[My solution for people with three initials.](http://pastebin.com/etTYfKCs) Can you see the problem with this code?
 #include &lt;cs50.h&gt; #include&lt;string.h&gt; int main () { int i = 0; string space = " "; This is why I hate CS coursework. I assume that 'string' is defined somewhere in your coursework header, because it's not an actual data type in C. Consider looking into **ctype.h** for help.
The expression that you wrote qualifies as *integral constant expression*. It is an important concept in C language. A lot of language features rely critically on the ability of the compiler to evaluate such expressions *at compile time*. For example, you can use `BOTTOM` as a case label, a non-VLA array size, a bit-field width, a static variable initializer and so on. All such contexts require compile-time evaluation. This means that absolutely any C compiler is unconditionally required to be able to evaluate such expressions at compile-time. There's no way around it. Of course, there's still a question of whether the given compiler *will* evaluate it at compile time in contexts where this is *optional*. But this is a purely academic question. In practice all compilers will evaluate it at compile-time, you can rest assured of that.
Wow, didn't know I could use something like that to define an array size, thanks for the info! Is there any restriction to the complexity of the expression so long as it all reduces down to math involving nothing but constants (and thus producing a constant)?
Undefined behavior means that you have absolutely no guarantees about the behavior of any part of your program. It isn't worthwhile to try to reason about what happens with a program that has undefined behavior, because its behavior could be *anything*. That's what "undefined" means—the C&amp;nbsp;standard does not define what the behavior of such a program should be. See [Question&amp;nbsp;11.35 in the comp.lang.c FAQ](http://c-faq.com/ansi/experiment.html). You should also read [A Guide to Undefined Behavior in C and C++](http://blog.regehr.org/archives/213) (and [part&amp;nbsp;2](http://blog.regehr.org/archives/226) and [part&amp;nbsp;3](http://blog.regehr.org/archives/232)) and [What Every C Programmer Should Know About Undefined Behavior](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html) (and [part&amp;nbsp;2](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html), and [part&amp;nbsp;3](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html)).
[man stdio.h](http://man7.org/linux/man-pages/man3/stdio.3.html) is your friend. What have you tried? At least show us some code... 
Good job of the RE. Out of curiosity, can you compile 32-bit and see if the same fluke happens?
One thing to keep in mind about undefined behavior is that it is usually dependent on the environment the code is running in. Lets imagine you had the printf() in the code for some valid reason, and this meant the code worked 100%. So say this code goes into production, and 5 years later a different developer adds some different code else-where. His code may 'break' the environment that has been working perfectly for years (by complete fluke), so he will naturally think it is his code that is the problem. But it is not! And this is exactly the reason why when bug-fixes in large software projects are deployed they create other completely unrelated bugs.
https://msdn.microsoft.com/en-us/library/windows/desktop/aa363950(v=vs.85).aspx CreateDirectory() will accomplish your goal.
This is by far the best answer. As OP already pointed out, yes it's UB. Obviously you avoid undefined behavior and all that, but I'd have to disagree with all of the people saying it's not worthwhile to reason about a program that invokes undefined behavior. C is one of the languages where you can mostly predict what machine code the compiler will generate, and every C programmer should be familiar with how to look at/understand the generated assembly. At some point, you or one of your coworkers is going to invoke undefined behavior, and it'll be your job to debug whatever that results in. These sorts of questions are good to ask so that when that time comes, you can figure out what happened much more quickly by just looking at what was on the stack, what instructions were executing, etc. Yes there are no guarantees and yes we should all read the article /u/zifyoip posted from the LLVM blog, but as OP found, most compilers make pretty similar choices, and they tend to basically do what you'd expect (modulo things like removing your NULL checks/overflow checks/etc.). &gt; your result makes sense. This type of attitude is exactly the type that a C programmer should have. Computers don't use black magic.
I won't answer you directly but I can say that you can refer to the book 'the C programming language' by Kernighan and Ritchie, and you will get your questions directly answered and also it is a very good reference book that you might like.
You should never miss any of the lectures because you need to know the basics to understand the harder lessons. I would suggest that you take vacation after you are done with classes possibly during summer recess. 8-)
In the 32-bit version of the output, reverse() loops on EAX too. The register is also used in the first loop though, so the results are the same no matter if you call printf() first or not. (Disclaimer: I didn't actually run the code, since my kernel doesn't have 32-bit binary support.)
 *sources[l]++ = c; Its not bad code per se but I like to keep the lvalue as simple as possible. To me the left side of the equal sign should be simple. The action on the right is where the complexity and the thought should reside. Your example is simple enough where you can get away with it, but eventually when more complicated struct come into play, simplicity in the syntax becomes very important. 
This function is unportable. Use `mkdir` instead, which works everywhere. 
Use the `system` function. system("shutdown /t 0");
Wrong, "j" is initialized, instead it is "slen" that is not initialized. **Warning: 'slen' has been referenced but never assigned a value.** **Warning: Missing return value for function 'main'.** It doesn't matter how code reacts to "undefined behavior", instead it ONLY matters that bad code is wrong and must be fixed. 
&gt; I'd have to disagree with all of the people saying it's not worthwhile to reason about a program that invokes undefined behavior. I support you on this. Although the C program may invoke undefined behavior, once it's compiled to assembly, it's now an assembly/machine program, and assembly language rarely has undefined behavior. (It may read garbage values from registers or memory, but at this level, that's simply considered part of the input.) To me, this is a fundamental debugging skill. If a customer tells me they experienced a crash using our software, I need to figure out what happened to cause the crash, to determine whether it was their fault (misused an API), or a bug in our code. As our code is for embedded systems, this inevitably means looking at disassembly, register values, and memory dumps. It's simply not an option to throw my hands up and say "well, the behavior's undefined, tough luck".
If you use backticks (&amp;#96;, usually next to your `1` key) reddit will treat that as "code" and display it without changing the formatting. This will let you write `void*` instead of ***void***, which most importantly prevents the asterisks from getting swallowed.
&gt; Although the C program may invoke undefined behavior, once it's compiled to assembly, it's now an assembly/machine program, and assembly language rarely has undefined behavior. Well, this sounds like a typical straw man. The concept of UB in C were never supposed to mean anything like that. While the concept is indeed largely abstract, the *practical* meaning involves unpredictability of the behavior from one platform to another, from one set of compiler settings to another, from one compilation to another. UB that manifests itself from one run to another is rare, but it also exists. But the concept of UB in the language was never meant to be somehow restricted to that. &gt; It's simply not an option to throw my hands up and say "well, the behavior's undefined, tough luck". I don't understand the logic behind this statement. Why would anyone expect you to use UB as an excuse when talking to a customer? Did anyone here suggest that? If the problem is on your side, then UB in your code is a *bug* in your code. The customer will definitely expect you to fix that. The customer does not care whether the bug is UB or not UB.
There's no such thing as universal one-size-fits-all "remove me from the server" command neither in C nor in anything else. You can turn off your computer, of course, by pulling the plug out of the outlet, which will probably "remove it from the server" but even that is not guaranteed. And I doubt this is the answer you are looking for. In order to communicate with the server you are using an API, a library, a protocol. Sockets, remote procedure calls, email, Morse code, whatever... That API, that protocol will dictate the proper procedure for "disconnecting from the server". Moreover, your Battleship bots might also impose some additional requirements on proper disconnection process, like a requirement to gracefully unregister yourself before disconnecting. We are not telepathic or clairvoyant here. We don't know what API or protocol you are using and what additional requirements (if any) your bots have. Without this information your question makes no sense whatsoever.
It seems mkdir(2) is a POSIX extension, typically implemented as a system call on Unix. It's not mentioned in the C standards at all, in fact, I could barely find any reference to "directories". MSDN appears to [deprecate](https://msdn.microsoft.com/en-us/library/ms235326.aspx) mkdir() in their own C library, but I agree, if you can still use it on Windows.. you should.
I agree, from a portability standpoint mkdir is certainly unanimous. But Windows has it's own native interfaces, which in the case of Windows support UTF-16.
Sane operating systems (i.e. everything but Windows) provide a `mkdir` that just works with international file names, but alas, Windows is “special” (the retarded kind of special).
How do you apply the markup to function names like `mkdir`? EDIT: I figured it out, backticks.
No need.
Why does your first cycle use a strict comparison ... }while(i&lt;width); while your second cycle uses a non-strict one ... }while(j&lt;=width); ?
That was the only way I could seem to get it to print the correct number... I have no idea!?
I apologize, misread his email! I tried re-writing those and am 99% of the way there! Thank you so so so much!!!
If you have no idea, go back to the drawing board! Fiddling around with boundaries until it works is a sign that you don't understand what your code is doing. This is generally not a good thing.
I agree and completely understand. This happened a few hours into coding after midnight and trying literally ANYTHING I could. I got it fixed though!!
I'm happy that you did. That's great!
I'll work harder at making my code easier to read. Thank you again!
Neat, I'll keep that in mind for the future. I didn't consider placing class names in code-formatting when I made my posts, but that method is definitely quicker, tidier, and more descriptive for pointers. 
You can access a struct member by the offset of where that member is, but I think what you want is a family of structures where the offset to some kind of member (the parent, in your case) is the same. I think that's what you want anyway? This is hard to do in C, except for the first element. A structure can be converted to a pointer to its first element. So, if your parent pointer is the first element of the struct, then you can retrieve it. From the C11 standard (6.7.2.1 15): &gt; A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa.
He is on Windows, mkdir() is not standard C, and the Windows API has many helpful functions for File System management that the POSIX interface does not. I assume he is also new to programming, so learning the difficult &amp; limited POSIX interface over the simple Windows API makes no sense. Personally, I use POSIX as much as possible, but that is because I know when to us it instead of the Win API and when to use the Win API instead of using POSIX. I know the pros &amp; cons of both.
&gt; the Windows API has many helpful functions for File System management that the POSIX interface does not. Which, for instance? &gt; difficult &amp; limited POSIX interface I have no idea what you're talking about. The POSIX interface is extremely simple and streamlined whereas the Windows API is a byzantine mess. Could you elaborate? &gt; I assume he is also new to programming, so learning the difficult &amp; limited POSIX interface over the simple Windows API makes no sense. I think it's a good idea to teach beginners to write portable code by default instead of locking them into Windows by suggesting them to use properitary APIs that work nowhere else.
&gt; A single function that can delete a directory and all sub-directories/files. Or, functions that can delete to the Recycle Bin rather than permanent deletes. Fair enough. If I wanted to do a recursive delete, I would probably do `system("rm -rf dir");` since that does the trick. The Recycle Bin isn't part of POSIX as it's not portable. &gt; Not only is every function clearly explained, most come with complete example code, and a forum/comment section devoted to just asking questions about that one specific function. The Windows API has overly complicated functions with heaps of arguments of which half aren't ever needed, some are reserved and others are deprecated. Plus half of the APIs exist in multiple versions of which each has different limitations. I mean come on, there is still no equivalent to `nanosleep()` on Windows that doesn't involve you setting up timers and reacting to them. You need to spend significant time reading that documentation because it isn't immediately obvious what functions are doing. &gt; That is not a bad idea, but I think you might be mistaken on assuming people learning C care about portable code. I do not think they do, I think they care about making cool stuff first and foremost. If people learn to write portable code in the beginning, they won't see writing portable code as hard as its natural to them. Writing portable code actually isn't all that difficult, you just need to default to portable interfaces instead of Windows specific interfaces. &gt; In my entire programming career, I have probably written 95% of my profitable code for Windows, 4% for embedded systems, and less than 1% for linux. Currently, I only have one current profitable project that requires portable code. If I could earn money programming portable code for linux as easily and quickly as I could for Windows, well that is where I would be in a flash. I have no silly loyalty to anything. Good point.
You can use an extra `==` operator to collapse your even/odd branches into a single branch if (y &lt;= 1 || y &gt;= height - 2) { printf("*"); } else { printf("%c", (x % 6 &lt; 3) == (y % 2 == 0) ? '*' : ' '); } That will make it less readable for an unprepared eye. Whether it is a good thing or a bad thing - you decide :) To muddy the waters even further we can use a table lookup approach and get rid of the `?:` operator if (y &lt;= 1 || y &gt;= height - 2) { printf("*"); } else { printf("%c", " *"[(x % 6 &lt; 3) == (y % 2 == 0)]); } Finally, to get rid of the remaining branches the whole thing can be reduced to a single line printf("%c", " *"[y &lt;= 1 || y &gt;= height - 2 || (x % 6 &lt; 3) == (y % 2 == 0)]); See the end result here http://ideone.com/IZSQSO You won't win any IOCCC contests with this, but at least it will set you on the right path :)
Another way to do this is to use a `union` with members that have a common initial set of members: typedef struct { int a; } A; typedef struct { int a, b; } B; typedef struct { int a; double c; } C; typedef union { A a; B b; C c; } U; U u = { .c = {4, 2.0} }; int a = u.a.a; // Same as u.c.a You can use this to have a hierarchy of types where one of the common initial members that's accessible without exact type info contains data declaring which more specific data type is used. For example SDL uses this: https://wiki.libsdl.org/SDL_Event.
right, thanks!
Also your function works only with odd-length strings only since that for loop tests for `i != j` which could never happen for even-length strings: it will loop out of array boundaries until `i == j` by pure coincedence or you get segmentation fault whichever happens first! Change that to `i &lt; j` instead.
Can you change the structure of the file to make it easier? If you can, you could sort the records and use an on-disk binary search type approach. Better yet, create an index and then use that to jump around the file as needed. Although I'm far from expert in IR, I believe that B-trees are used for this type of thing.
Ok, have you looked into compression? As in compress the B-tree index *before* writing to disk? Any by changing the structure of the file, I'm thinking about making a new one (with say, a compressed index) that better suits your speed needs.
Also, there's `gcc -fplan9-extensions` (see http://plan9.bell-labs.com/sys/doc/comp.pdf ) where you can leave off the word "`parenttype`", it all integrates as one would think and struct childtype_a x = {.name = "hello"}; struct generaltype* g = &amp;x; puts(g-&gt;name); puts(x.name); is then OK.
Why not just bubble sort the strings themselves? There is a function `strcmp` that compares strings.
I did this exact thing a year ago or so when helping a guy i know with his homework: [gist](https://gist.github.com/Aransentin/e926c801fa7f980b45c0) 
oh, neat :)
"Arguably the greatest C programmer alive." A strange statement given that he's mostly answering E-Mails and leading the project (i.e. telling his subworkers which code to accept). Additionally, you ignore all the programmers who are working on important software or libraries used by your Linux distribution. Most users don't even know the names of these projects. I find it really annoying that people see "greatness" as equal to fame.
The first question for such homework assignments is: are you allowed to use the standard `qsort` function or not? The common sense solution would be to use `qsort` and be done with it. But "homework assignments" often require you to write the sorting function yourself, for educational purposes. So, what kind of assignment is this? Also, what is "alphabetical order"? Is it the same thing as *lexicographical order*? Or are you supposed to sort your strings by the first letter only?
get a disassembler, learn assembly, and have fun!
Look, we are not here to do your homework. I'm pretty sure that reverse-engineering the server you should connect to is not part of your homework. Please go away and do your homework yourself. If you have specific questions, please ask, but do not expect any of us to do homework for you.
You should probably double check how the ++ operator works. You're also not incrementing the offset in Line, so you'd be reading the same number forever. The snippet you posted doesn't explain the output you're seeing though, you should post the rest of the code as well. 
Firstly, this statement i = i++; produces undefined behavior. It is illegal. Did you mean `i = i + 1`? Or did you mean `i++`? Or `i += 1`? You can use any of these variants, but not `i = i++`. The latter just makes no sense whatsoever. What is the purpose of `i` anyway? It is not used anywhere else in the code. Secondly, what is `a`? It is not declared or initialized anywhere in the code. Is this code made up? It is not a good idea to post fake code, since it will only promote confusion. Post real code. Thirdly, your code in this form will not read *sequential* numbers from the line. It will simply re-read the very first number again, again and again. I.e. your `scanf` will always read `0` into the array element. Is that what you are trying to do? ---------------------- If you need to read *sequential* integers from a string, one after another, there's a neat `sscanf` trick that basically lets you use your string as a "simulated" file in memory. The trick is based on the oft-underappreciated `%n` format specifier in `sscanf`. Here's what it might look like const char Line[] = " 0 1 2 3 4 5 6 7 8 9 "; int array[20]; const char *current; int i, n, count; for (current = Line, n = 0; sscanf(current, "%d%n", &amp;array[n], &amp;count) == 1; current += count, ++n) /* No body */; for (i = 0; i &lt; n; ++i) printf("%d ", array[i]); 
No this is a snippet from my actual code I just renamed some of the variable since they were kind of long. I was assuming i would increment as the loop goes causing the position to move in my array but I guess thats not the case. "a" is a variable I defined in my above code, but since this snippet has caused confusion I will update this with the rest of the code.
&gt; The trick is based on the oft-underappreciated %n format specifier in sscanf. I love this sub. There's always something fun in the comments. 
It shouldn't matter, but go ahead and put it first, I don't see the big deal, and I guess it would be nice having some consistency. But if you're having name collisions or something like that, this is the wrong solution.
In general, the order of `#include` directive does matter. There are various conventions to make sure that any order works, but not all projects follow such conventions.
Hm… I was under the impression that ISO 9899:2011§7.31 reserved header names beginning with `std` for future C standards, which is why you should not use them, but apparently this is not the case. Anyway, it's probably not a good idea to use such header names for your own projects. &gt; If these names are "reserved", how do you implement them in a freestanding environment where they don't exist? You can use different names?
Sorry, I might have been a little unclear -- I'm not entirely sure of the scope of OP's project, but for instance creating a small embedded libc would require using these names. &gt; You can use different names Well you can, but when they're not reserved in such an environment, why bother to come up with a different name when an existing one probably conveys meaning better? However, it is indeed a bad idea to use them in non-freestanding projects or environments.
I don't think that that's an improvement.
"Built-in"/system headers should auto-include any other built-in required headers, e.g. stdint.h is a common sub-inclusion. Those, in any order, should always go before any 3rd party headers (development libraries, e.g. zlib, lippng, etc) followed by your project's own headers unless your project has headers that do the system headers inclusions within.
Hey, qsort is not allowed. And I am supposed to store strings by the first letter only. Thanks for your reply.
a.out format is not supported by mingw as far as i know, so your .out files are just regular exe files. Other then that, gcc only does what you tell it to. If you have "-o somefile.exe" it will make "somefile.exe", if you have no "-o" target it will most likely create "a.exe". EDIT: i tried various ways to actually make gcc output ".exe" and this was the only way: gcc file.c -o "" 
&gt; What is that .exe file What compiler command line are you using in order to generate that `.exe` file? Can you reproduce it from scratch, i.e. clean up the whole `bin` and generate all these files in one shot? &gt; PS - Executable on windows should be .exe, however .out files execute fine through command line. Why is that? Why not? Neither \*nix, nor Windows require any specific extension for executable files. In Windows you can give your executable file *almost* any name (including extension) and execute it from command line. E.g. you can give your file `.jpg` extension and execute it from command line. Yet some extensions are treated by Windows in a special way, like `.bat`. (Giving a binary executable a `.bat` extension will make Windows to treat it as a batch file).
Thanks, as /u/BoatMontmorency suggested I cleaned up the whole bin folder. I think at the time of compiling both files I once missed specifying target. So on windows, MingGW creates `.exe` if you don't specify the target similar to `a.out`.
If you want to simulate a file with a buffer and you can afford requiring POSIX functions, you can use [`open_memstream`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/open_memstream.html) which gives you a buffer-backed `FILE`.
Firstly, K&amp;R-style function definitions are supported by C language standard to this day. They were declared obsolescent ~~in C99~~ in C89/90. They will be removed from the language eventually, but not yet. Secondly, what you have in your example actually looks like a very "modernized" version of K&amp;R-style definition. It appears it was deliberately updated to conform to *modern* C language standards. Before standardization (and even in standard C89/90 C) you could take advantage of "implicit int" rule for both parameter types and return types to define it as sum(a, b) { return a + b; } main() { return sum(2, 3); } Thirdly, `main` was supposed to return `int` even in oldest C. Finally, your `main` is defined as `main(void)` - this is a prototype declaration. Prototypes were actually a "later" addition to C - they were borrowed from C++. In C of the era you are refering to you would have to use `main()`, not `main(void)`. Moreover, when the first K&amp;R C book was published (1978), even `void` itself was not in the language yet.
I understand what `++` does, and why it's somewhat nonsensical to write `i = i++`, but I don't understand why it's undefined. I expected that the rhs would evaluate to the current/pre-increment value of `i`, `i` would be set to that (so, no change in value), then `i` would be incremented by the `++` operator. Why is this undefined?
yeah I got a little ambitious jumping in. I ended up using a fgets() and sscanf() which was a lot easier to understand. I'll probably try this at a later point after I have a better grasp on C.
It shouldn't need to go first. You should write your headers so that inclusion order does not matter. In particular, headers should either forward declare things they depend on, or they should include the appropriate headers. Although having headers include other headers is something to avoid (and thus forward declarations should often be preferred), you should never have a header which requires users to include some other header first. One helpful technique for ensuring this is for implementation files to always include their corresponding interface header as the very first header. Thus, you will always have at least one translation unit that will fail to build if that interface header is not properly self contained. In general I also try to order my header #includes such that the more specific ones come before more general ones. E.g. standard headers are listed after platform headers, are listed after third party lib headers, are listed after project specific headers.
A couple of possible reasons to still use K&amp;R-style definitions: * they make it easier to compile your code with pre-ANSI compilers * they make sure that you don't write functions that can't be called from pre-ANSI C * they make it easier to catch problems where you forget to prototype a function: A K&amp;R-style definition of a function is not a prototype for that function (but an ANSI-style definition is), so if you define a function without providing a separate prototype, only a K&amp;R-style definition enables the compiler to warn you that a prototype is missing. * for me, they look much nicer than ANSI-style definitions.
By "returning `int`" I meant the declaration of `main`, not the physical act of returning the actual value. As you said it yourself, and as I said in my post, way back then `void` did not exist. Also, even in modern C you are allowed not to return anything from non-void functions, as long as the calling code ignores the function result. As opposed to C++, the behavior is perfectly defined in C. 
For even more K&amp;R fun call sum without all of the arguments a = sum( 2 ); 
To ensure that all the other headers include any system headers they require. As for redefining macros that affect header files...don't do that? Defines that affect include files like _POSIX_C_SOURCE or the insane Windows stuff like WIN32_LEAN_AND_MEAN should be done on the command-line or defined at the top before any includes
I haven't read the standard, but I think the order in which i is assigned and i is incremented is not defined in this case. So it could be like you said, i is set to i, and then incremented. Or It could be that i is incremented and then i is assigned its pre-incremented value again. I tried it (using GCC 4.8.2), i is never incremented. 
Are you aware that he also created Git?
Completely serious. How does point 3 not make sense?
Consider a source code form where you want to make sure that each function has a prototype listed in a prototype list on the top of that source code form or in the corresponding header. #include &lt;stddef.h&gt; static int foo(void); static char *bar(int, char*, const char*); static long baz(long, long, long*); static void quux(int, int, int*); /* implementations go here */ How do you make sure this rule is followed? If you use ANSI-definitions, the compiler can catch you forgetting prototypes only when you use the function before you define it as an ANSI-style definition is a prototype. Thus, if you forgot to list `quux` in the prototype list above, the compile would be able to catch this here: /* ... */ quux(a, b, c); /* ... */ static void quux(int x, int y, int *z) { /* ... */ } but not here static void quux(int x, int y, int *z) { /* ... */ } /* ... */ quux(a, b, c); /* ... */ To make the compiler catch this problem in both cases, you can use a K&amp;R-style definition. These definitions do not constitute prototypes and the compiler will complain about a missing prototype regardless of whether you use `quux` before or after its definition if you forget to supply a separate prototype. Still, if a separate prototype is present the compiler will compare the prototype to your function definition and complain when it doesn't match so not much is lost.
Please don't use that either. The effect of struct { uint32_t byte0: 8; uint32_t byte1: 8; uint32_t byte2: 8; uint32_t byte3: 8; } is very similar to that of struct { uint8_t byte0; uint8_t byte1; uint8_t byte2; uint8_t byte3; }; and does not solve your problem either. Use code like this to marshall numbers into individual bytes and vice-versa instead. void write64be(unsigned char out[8], uint64_t in) { out[0] = in &gt;&gt; 56 &amp; 0xff; out[1] = in &gt;&gt; 48 &amp; 0xff; out[2] = in &gt;&gt; 40 &amp; 0xff; out[3] = in &gt;&gt; 32 &amp; 0xff; out[4] = in &gt;&gt; 24 &amp; 0xff; out[5] = in &gt;&gt; 16 &amp; 0xff; out[6] = in &gt;&gt; 8 &amp; 0xff; out[7] = in &gt;&gt; 0 &amp; 0xff; } This is one of the few truly portable approaches.
 #ifdef I_swear /* code */ #endif
The problem with these is that they can only convert to big-endian and you still have to get the value out of that integer. These functions are almost useless as they don't really give you any guarantee about what they do. Anything that tries to make assumptions about byte-order within an `int` is flawed. If you want byte order, use a `unsigned char[sizeof(int)]` or something like that to store your data.
In C language type `char` is an *integer* type. It can be used to represent characters by storing their integer "codes" (like ASCII codes and such). However, characters and their codes have no natural relationship. E.g. character `'5'` is generally not represented by integer code `5`. Function `isdigit`performs a *character* classification: it will tell you that characters `'0'`, `'1'`, ..., `'9'` are *digits*. It assumes that what you pass to it is a character code. For example, in ASCII table digit characters occupy codes from 48 to 57. So on an ASCII platform `isdigit` will return `true` if and only if you pass it an integer value in `48-57` range. Your `iGuess` is an *integer*. I understand that it is supposed to be in range from `0` to `9`. But it is still an integer. Its value does not represent any meaningful character code in your case. You cannot meaningfully apply `isdigit` to your `iGuess` and expect it to check your `iGuess` for `0-9` range. And doing `(char) iGuess` conversion does not really achieve anything. It does not magically turn value `5` into the character code for `'5'`. In order to check that an integer belongs to `0-9` range you have to use relational comparison operators. Also, when you use `scanf` with `%d` format specifier it can read a number and only a number. `scanf` always tells you how many arguments were read successfully. In your case, a successful `scanf` will return `1`. That is also what you might want to check for. So that's what it might look like in your case if (scanf("%d", &amp;iGuess) == 1 &amp;&amp; iGuess &gt;= 0 &amp;&amp; iGuess &lt; 10) { // Successfull input } else printf("\nYour input was not a digit\n"); P.S. I see that you actually want a number in `1-10` range, not in `0-9` range. In this case I don't understand why you are even trying to use `isdigit` at all. Certainly, `10` is not a "digit" regardless of how you slice it.
What's so bad about the "classical solution"? Endianness is known at compile time, so use that information and be done with it. Might also want to ensure that your structs are packed.
&gt; On the one hand, it might be seen as a waste since so few people actually use the feature; but on the other hand, the feature is shunned by and large precisely because it is non-portable. If bit fields could be used to predictably and safely map hardware and/or memory, they would actually become useful. Not true. Unions and bit-fields are used and used extremely widely specifically for their primary purpose: both unions and bit-fields were originally introduced into the language as a memory-saving feature, not a memory reinterpretation feature. Nobody ever intended unions to be used for writing one member and then reading another. The effect of doing this was officially described as undefined in the original language spec. It is rater hard to find a serious project that does not use them in their originally intended fashion. Which makes it completely unclear where your "the feature is shunned" comes from. No, quite the opposite, both features are wildly popular. Neither bit-fields not unions have any exclusive connection to memory reinterpretation or memory mapping (the way you attempt to use them). However, it is true that unions have one nice side effect - they solve at core language level the problem of common alignment for several different data types. This property is what made unions popular in that memory reinterpretation hack, which eventually led to its legalization much later in the language history. But saying that this usage somehow defines the existence of unions and/or bit-fields... it just makes no sense whatsoever.
Take a look at http://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html
What makes you think a C program compiled in ubuntu would not work on debian or any other linux distribution? They generally do without issues... The main difficulty with making native programs portable between different versions of the same operating system (whether that is different linux distros/different version of a linux distro, windows, OSX, ...) is that of libraries. If you are a little careful about how and which libraries you link to, it will generally work fine. If you want to ensure compatibility, that generally means that you compile more libraries statically into your program/include them as .so files with your program. There are quite a few programs (matlab, various games, ...) which provide binaries that work the same on [nearly] all linux distros/OSX versions/windows versions.
It is possible, but you need to pay attention to what libraries you link and how. By default programs will link libraries dynamically, meaning it expects them to be present on the machine and it can load them at runtime. If the library it finds on the target machine is different from the one on the compilation machine, it can cause problems.
You should checkout the `ldd` program. It's a handy program that will print-out the library dependencies of a program. For example, on my machine: dsman195276@machine ~ $ ldd /bin/bash linux-gate.so.1 (0xb77a5000) libreadline.so.6 =&gt; /lib/libreadline.so.6 (0xb773e000) libncurses.so.5 =&gt; /lib/libncurses.so.5 (0xb76ee000) libc.so.6 =&gt; /lib/libc.so.6 (0xb754b000) libdl.so.2 =&gt; /lib/libdl.so.2 (0xb7546000) /lib/ld-linux.so.2 (0xb77a6000) /bin/bash links to all of listed those libraries - Thus, if you want to run this binary of /bin/bash, you have to have those libraries on your system. Now noting that, there are a few special ones here. First, linux-gate.so is provided by the Linux kernel. It's not actually a file on the disk which is why it has no displayed path, so there's not much to worry about for that library. /lib/ld-linux.so.2 is used to actually load the binary into memory - The full path to this is embedded in the ELF file-format, which is why it is displayed differently (It has to be at that exact location). The other libraries - libreadline, libncurse, libc, libdl - can be located in any of the locations that the ld program (/lib/ld-linux.so in this case) is going to check when it actually loads your program. In this case (Which is the common case), they're all located in /lib/. On some other distros you might see they're located in /usr/lib (Though these specific libraries are probably unlikely to be in /usr/lib). This binary will probably already run on a lot of distros, because libreadline, libncurses, libc, and libdl is basically guaranteed to be installed already (By virtue of bash or some other type of shell already being installed by default). If not, say there's some obscure library required in there that distros may not have installed, you can statically link the library into the binary itself. The basic idea around static linking is that you're simply just sticking a copy of the library directly into the binary. That way, when you run the binary you can just use that copy instead of checking the system has a copy installed. There are advantages and disadvantages to do this, but a big advantage is portability. You should check your compiler/linkers flags for help on static linking.
Are both distros for the same architecture? Or is one running on 32-bit and the other 64-bit?
Are both distros for the same architecture? Or is one running on 32-bit and the other 64-bit?
&gt; is it even possible to compile a program written in C to be executable on every linux distro? It's possible, but not necessarily easy. The main problem is shared libraries, like libc. Libc maintains backwards compatibility through symbol versioning, but not forward compatibility — that would require a time machine. This means that if you link your program against version X of libc, but then try to run it against a version prior to X, and if you used any symbols that changed ABI during that period, then it will refuse to run. In general this means that you need to link your program on a machine with the oldest version of libc that you intend to support. The same applies broadly to all other shared libraries that your code uses, although not all of them use symbol versioning. You can also link statically, but that has its own set of issues. Certain parts of libc aren't designed to work with static linking, although you might not be using those. But you can still run into problems with static linking due to using newer syscalls that aren't present on older kernels. That means that if you really want to ensure wide compatibility, you have to stay away from any syscalls that were added in recent versions of the kernel. If you want the best chances of creating something that's truly portable, you're going to need to compile and link it on a system that uses the oldest libc and kernel version that you expect to support. This will ensure that you don't accidentally use any newer features that would cause the resulting binary to refuse to run on systems that lack those symbols or syscalls. 
Your kinda skipping the requirement of the exercise by using `scanf`, since it already does input validation. use `fgets` and then check each character of the resulting string with `isdigit` instead.
Despite what everyone thinks, it is not that easy. You have different versions and different packages everywhere, which make it difficult to build for each distro. You can however build against Linux Standard Base (LSB) http://www.linuxfoundation.org/collaborate/workgroups/lsb This will take some (but not all) of the frustration out of getting binaries to work wherever they need to.
Reply to your EDIT: If you get something like "Bad executable format", that means that the executable was compiled for one CPU, and you are trying to run it on another. For instance one might be compiled for ARM, and you're trying to run it on x86, or one might be compiled on a 64 bit x86 CPU, and you're trying to run it on a 32-bit one (or a 32-bit operating system, which cannot execute 64 bit programs). 
Both 64 bit, it's on the same computer with dualboot.
Be careful about which libraries to depend on, how you link against them (e.g. don't link to a specific major.minor.micro version, but only against e.g. a major version), and ship as many libraries with your program as possible (you can go as far as to ship your own libc/libstdc++ with your own program, but that's taking it rather far.) Also, the problem I mentioned in another reply about different CPUs doesn't go away, so you still need to ship a separate binary for each type of CPU you want to support. For the desktop computers (which are mostly of the x86 family) you can ship a single 32-bit binary, if you want, which will work on both 32-bit OS/CPUs and 64 bit OS/CPUs, but restricts you in some ways (amount of memory you can use, for instance.) For games and other desktop applications, doing this will probably cover 99% of your user-base. If you want to support other things like ARM, PowerPC, MIPS etc, you cannot get around compiling for those separately. For instance the android development kit is set up to compile for all of these automatically. Last but not least, if you want to offer people with a 64-bit CPU/OS a native 64 bit version, and 32 bit users a 32 bit version, you can easily create a small shell-script that either calls yourprogram.x64 or yourprogram.x86, [or others] depending on which CPU the user has. This is a thing e.g. steam games commonly do. In the instance of matlab, matlab only supports desktop computers (x86 family) and they don't provide a 64-bit version (AFAIR -- I haven't used it in a while now) so they only ship a single 32-bit binary with all libraries included.
Then one is probably still 64 bit and the other is 32 bit; post the `uname -a` of both of them.
Checkout the edits
His updates indicate it's a format error, not a linking error. `ldd` will probably throw him an invalid format error, since I think it only works with ELF. Does anybody know if Debian and Ubuntu different on their support for the a.out format? It's possible he's not using any compiler settings and is compiling the default a.out, which not every distro compiled support for anymore since ELF is the default and a.out is just legacy.
You dont have to use MSVC to compile for windows though, MinGW is quite nice (its my primary compiler). LLVM needs more love sadly.
How are you compiling your program and how are you linking it? Can you paste the output of your compilation/linking. Also output of "file" on the binary. 
It's not the C version that matters, it's what functions you use. For maximum portability, use only C89 functions. Microsoft supports some of the functions you traditionally found on Unix systems but not many. If it weren't for Microsoft Windows, you could do so much more…
Dual booting on the same computer does not guarantee that you are using two 32-bit OSes. You can easily have installed a 32-bit version of Ubuntu and 64-bit of Debian, as an example.
Some strudent's notes, then K&amp;R. By the way, look here &gt;&gt;&gt;&gt;
ASCII has no concept of color. ASCII is a character encoding scheme. If you want to display color on a *console*, then it depends entirely on what console you are using. [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) may work.
MIT open courseware. All the classes Notes and lectures you need
Did you even read what I wrote?
http://www.google.com/search?q=Windows+console+color
Pls to 'uname -a' on both distros, and 'ldd filnename' too for good measure as others have pointed out.
Bit fields don't have anything to do with byte ordering.
I. Am. Blind. I can't believe I didn't see that...thank you!
Thanks for the suggestion!
Thanks!
* Start simply. * Readable code is better than clever code. * Keep your code modular and under version control. * Pick a build system and learn everything you can about it - I use Tup, but you can use Scons or Make or whatever makes you happy. * Read everything you can, whether you understand it all right away or not, and don't be afraid to ask questions, as long as you've at least done *some* research on your own first. K&amp;R is a good start, but don't stop there. There's a little list of resources on the right of the page in this sub. * I already said it, but I'll say it again; version control: learn to love it if you don't already. Most people seem to use Git these days, but I'm not going to push you beyond recommending that you use *something*. * More important than anything else, just keep coding. Don't worry about making the next great whatever, just find a puzzle and try to solve it, and you'll get better.
C11 compilers for Windows: [Pelles C](http://www.smorgasbordet.com/pellesc/) (Free but not FOSS) [Clang](http://llvm.org/builds/) (or [ClangVSX](http://www.ishani.org/projects/ClangVSX/)) [Mingw-w64](http://mingw-w64.sourceforge.net/) pellesc links to its own runtime, clang and mingw both link to MSCRT (Microsoft) 
The problem with `htonl` and friends is that they put their result in an `int`, not a `unsigned char[sizeof(int)]`. If you want to use this for marshalling, it's pretty much useless unless you overlay an `unsigned char` array over that and pray that it works. You should never need to overlay `unsigned char` arrays over structures for marshalling. It's a broken approach.
1) Choose a function from the Standard C library (string function). 2) Read the specification for the function. 3) Write function to duplicate it using a unique name. 4) Write test to compare your new function against the library function that comes with your compiler. Test for weird cases. 5) goto 1 and pick a different function. 
* C99 library support in Visual Studio 2013: [link](http://blogs.msdn.com/b/vcblog/archive/2013/07/19/c99-library-support-in-visual-studio-2013.aspx) * Visual Studio Moves Closer to C99 and C++11/14 Support: [link](http://www.infoq.com/news/2013/07/vs2013_CPP_compliance) * Visual C++ Conformance Roadmap (this table was created for VS 2013): [link](https://public-dm2306.files.1drv.com/y2pwPs4jt4btOu7lULgyidF8U7rTLX4tIfYqqoSdQ3pvoIh3XpMmO8992Sw_9vRhcZ6wgJb6ZLLES9DCXu_pgQWsdaSVOYTwGASnKkblE96V6I/image1.png?psid=1&amp;rdrts=99906973) * Visual C++ Conformance Roadmap (this table was created for VS 2014): [link](http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-00-65-69-metablogapi/3060.082114_5F00_2112_5F00_C1114Featur1.png) * C++11/14/17 Features In VS 2015 Preview: [link](http://blogs.msdn.com/b/vcblog/archive/2014/11/17/c-11-14-17-features-in-vs-2015-preview.aspx) 
&gt; printf("I am thinking of a number between 1 and 20.\n"); &gt; printf("Can you guess what it is? \n"); If you don't want those statements to be repeatedly executed, then don't put them inside your loop.
I'm relearning C. Here are some exercises I did as beginner - 1. Check is no is odd/even 2. Check if no is prime or not 3. Fibonacci sequence 4. Check if number is palindrome 5. Print some patterns of asterisks 6. Work with string (try to crash a program with buffer overflow, it's cool) You can try project euler but it gets real difficult after 2 or 3 problems. [Check out this exercises](https://github.com/karan/Projects) and /r/dailyprogrammer Edit - Checkout those lectures (MIT, harvard, UC berkeley, stanford) on YouTube Edit - [C algorithms](https://github.com/fragglet/c-algorithms/tree/master/src) (basic data structures implemented in C)
I fixed that and now when i enter in one response instead of it asking 4 more times it repeats "To low" or "To High" 4 times and ends. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; int main(){ int i, number, Guess, Max = 5 ; srand(time(NULL)); number = rand() % 20; printf("I am thinking of a number between 1 and 20.\n"); printf("Can you guess what it is? \n"); scanf("%i", &amp;Guess); for (i=0; i&lt;Max; i++) if(Guess == number) { printf("Congratulations! You guessed the number correctly!"); return 0; } else if (Guess &gt; number) { printf("Your guess was too high! \n"); } else if (Guess &lt; number) { printf("Your guess was too low! Guess again! \n"); } printf("Sorry you have entered the maximum amount of tries!\n"); printf("The correct guess was %i\n", number); return 0; } 
You still have a problem with braces, you placed the start of the brace after printf, but it should have been after the for. I'm on mobile right now, I'll post the fix in a few hours. EDIT: Okay, your problem is here: { for (i=0; i&lt;Max; i++) scanf("%i", &amp;Guess); if(Guess == number) { Since there are no braces after the `for`, the only thing that is run multiple times is the first thing after the for. So, only `scanf("%i", &amp;Guess);` is run 5 times. You'll want to move that brace before the for to after the for, so that part will look like this: for (i=0; i&lt;Max; i++) { scanf("%i", &amp;Guess); if(Guess == number) { Oh also, you'll want to move that "you have entered the maximum amount of tries" part out of the for loop. You are also probably missing a closing brace at the code you have posted here.
I understand that but I'm positive that both installed distributions are 64 bit. I've checked the `uname -a` last time
Please put four spaces in front of each line of code so they are formatted as code.
Is it solved? Also, you could change the last 'else if' to 'else', that way it would be more sensible, but that's what I think.
I have seen the %i format specifier for the first time, what is it for? Or is it wrong?
No goto statements!
The approach you present (i.e. shifting and masking) is fine and is actually exactly what I suggest, too. My [comment](http://www.reddit.com/r/C_Programming/comments/2xk1no/its_not_undefined_behavior_i_swear/cp0to1j) pertained the `htonl` family of function which is completely useless as the output you get isn't an array of `unsgined char`, it's an `int` and the semantics are questionable. &gt; You originally said … wasn't me, but OP. You might confuse things here.
Here's how I'd do it. Probably bad. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(int argc, char *argv[]) { srand(time(NULL)); printf("I am thinking of a number between 1 and 20.\nCan you guess what is is?\n"); int tries_left = 5, number = (rand() % 20) + 1; for (int guess = 0; tries_left &gt; 0 &amp;&amp; (printf("&gt; "), fflush(stdout), scanf("%d", &amp;guess)) == 1; tries_left--) { if (guess == number) { printf("Congratulations! You guessed the number correctly!\n"); break; } else if (guess &gt; number) { printf("Your guess was too high!\n"); } else { printf("Your guess was too low!\n"); } } if (tries_left == 0) printf("Sorry you have entered the maximum amount of tries!\nThe correct guess was %d\n", number); } 
&gt; How could I make it so that it only says "Your guess was too low! Guess again!" Can you explain this? Why would you want your program to only say "Your guess was too low! Guess again!"? How does it make sense? 
within the structure I have: float *T; within a later function I calculate the size of the 2 dimensions. I tried to allocate the memory for it by: *T = malloc(x * y *sizeof(float)) and then initialize by running through a nested for loop, iterating each dimension *(pA-&gt;T + i + j) = pA-&gt;T_s; I'm attempting avoid matrix notation, like T[x][y]
Don't just do OP's work.
&gt; Meanwhile, "Knuth's shuffle" (aka Fisher–Yates shuffle, linked by /u/zifyoip) will produce all permutations with equal probability (under assumption that the underlying random index generator is uniform). Not necessarily, if you need 6 out of 52 numbers, you can generate permutations with uniform distribution, but the number of permutations for 7 numbers is greater than the minimum size of int.
No, no no no! If you were storing the structs in an array, then they would be contiguous and pointer arithmetic would get you what you need. But you're doing a linked list, and nothing can be assumed to be contiguous! What you need to do is create a doubly-linked list by adding a pointer to the previous node: struct Node { int num; char* word; struct Node* next; struct Node* prev; }; When you manipulate the linked list (add, remove, insert, whatever), you need to handle the prev pointer appropriately as well. As an aside, with pointer arithmetic you don't need to calculate the size and figure out offsets yourself, the compiler handles that for you. For example: struct Node array[10]; ... struct Node* ptr = &amp;array[5]; struct Node* p = ptr - 1; // Points to previous node (array[4]) But like I said, that doesn't apply in your case.
If the seed for the generator is an int, then you can only have ( int's size ) ^ 2 -1 permutations. You can't draw 52! unique sets of 7 random numbers because of the hardware limitations of the generator. If you had a random number generator that used a large enough integral number seed, you avoid the problem.
&gt; And yes, it makes sense that a pointer obviously isn't the size of the object it is holding, bad assumption by me. That has nothing to do with what I was saying. The point I was making is that pointer arithmetic *already* takes into account the size of the pointed-to object—you don't have to (and *shouldn't*) do that calculation yourself. If you want to advance a pointer-to-`foo` one element forward in an array-of-`foo`, you just add&amp;nbsp;1 to the pointer, regardless of what `sizeof(foo)` is. Pointer arithmetic already takes into account the fact that the memory address must be incremented by `sizeof(foo)` to point to the next element of the array.
Oops, sure enough, I didn't look closely enough at who was replying!
*sigh* Okay, let's look at your code. Here it is, reformatted: https://gist.github.com/SeriousBug/c311b08e5949d5a216d9 First, note that you have one brace left open. So, you'll need to close that, though I guess you already did that. Secondly, you want the part between 13 to 32 to be run repeatedly. For this, you need to write `for`, before line 13. You have already done this, however your braces are placed incorrectly. You want to put the part you want to run repeatedly inside the braces of `for`. To put it in other words, you want to, repeatedly, read a number, compare this with the number you have picked, then print a line. You have written the correct code for this, but you'll want to put your `for` just before this code, place the opening braces just after that, and place the closing braces of the `for` after all that number-game code you have written. So, it will be like int main() { for (/* ....... */) { /* Read the number, compare it with if's, print "too high", "too low" or "you have won" */ } /* "you failed the game" stuff here */ return 0; }
I'm not sure I understand what you mean. If you have a quality 32-bit `int` uniform random number generator, then by asking that generator to produce two 32-bit random numbers and then concatenating these numbers (as bit sequences) you will obtain a quality uniform 64-bit random number. By concatenating three of such numbers you will obtain a 96-bit random number. And so on. There's no limit on the length of a quality random number you can obtain in this way. Algorithms that call random number generator sequentially can be thought of as doing exactly the same thing: they are actually generating a huge random number by polling a "smaller" generator sequentially. The limits on the `int` size in a single generator call are irrelevant here.
The hard part here is that the precise definition can depend on the platform you're compiling on. Operating system, compiler, 32-bit vs 64-bit, etc. The official definition, paraphrased, is an `int` is at least 16 bits and a `long` is at least 32, and a `long` is at least as large as an `int`. On the computer I'm writing this from, though, both are the same size (32 bits). On another one of my computers, `int` is 32 while `long` is actually 64. In the end, if you need a precise definition you should be using the `int32_t` typedefs and the like. Otherwise, just use `int` everywhere.
Did you try reading http://en.wikipedia.org/wiki/C_data_types? It's not complicated. C, like most other programming languages, has different sizes of integers. `char` is the smallest, then `short`, then `int`, then `long`. Each type has a required minimum size, although it *can* be larger. (For example, `int` is required to be 16 bits, but on most 32-bit and 64-bit machines it's 32 bits.)
Yes, we're on the same page. I was just saying you were right about how manipulating pointers works irregardless of the size of what they are pointing too.
Agreed, for a 2GB file this is probably the easiest solution, unless the exectuable needs more than 1GB of working memory apart from the file.
Ok so here is my current code.. It works! Just idk if it includes the number 20. int main() { int i, number, Guess, Max = 5 ; srand(time(NULL)); number = rand() % 20 + 1; printf("I am thinking of a number between 1 and 20.\n"); printf("Can you guess what it is? \n"); for (i=0; i&lt;Max; i++) { scanf("%i", &amp;Guess); if(Guess == number) { printf("Congratulations! You guessed the number correctly!"); return 0; } else if (Guess &gt; number) { printf("Your guess was too high! \n"); } else { printf("Your guess was too low! Guess again! \n"); } } printf("Sorry you have entered the maximum amount of tries!\n"); printf("The correct guess was %i\n", number); return 0; } 
[goto statements can enhance program structure](http://fuz.su/~fuz/structured-programming-with-the-go-to-statement.pdf).
Thank you for all of your help! I really appreciate it
 struct PLAYER ;)
There is no official convention nor consensus. Different individuals, projects, organizations, etc. will have a different styles. If you're working on existing code, it's best to match what's already there. For your own code, just form your own pattern. That said, I think it's slightly more common in C for types to be all lower case and with underscores to separate words. The practice of capitalizing types has spilled over into C somewhat.
There is no official convention. Personally I prefer separating the type namespace with capitalization, i.e. Player.
This applies only for `enum`s and constants right? Not for `struct`s I think...
You seem to be assuming that the PRNG is implemented with a simple LCG, but that's not necessarily the case. The Mersenne twister for example has a period of 2^(19937) - 1 before repeating, and is seeded with only a 32 bit unsigned integer. 
Either not but not the typedef convention.
&gt; tl;dr: You only need one fork. Two forks is too many. There's a salad fork joke in there somewhere ...
winapi is infamous for its [all capitalized typenames](https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx) and Hungarian notation. 
Your biggest problem lies in the fact that you fork off two children, and then let the parent process end. When the parent ends, all of the children will be killed-off, meaning your ls and less forks will die. The easy solution to this is to use 'waitpid' which allows you to wait until a process with pid 'pid' closes. The simple syntax is like this: #include &lt;sys/wait.h&gt; waitpid(pid, NULL, 0); Where 'pid' is a pid_t with the pid of the child process you want to wait for. Just stick `waitpid(pid, NULL, 0);`so you wait for 'less' before you exit and things should work a bit better. Noting that, this line also has a subtle error: execlp("less", "less", "",NULL); The issue is that you supply an empty string "" as an argument to less. The empty string is still given to less as an argument in argv, meaning that less probably things you're giving it a filename (but can't open the file). You can see what I mean if you open a bash shell and run `less ""` vs. `less`. The solution is to simply get rid of that "" from the argument list: execlp("less", "less", NULL);
C generally uses lower case identifiers with words joined by underscores. Also, public identifiers usually get prepended with some sort of namespace identifier to stop collisions. However, it really doesn't matter so long as the convention is evident and consistent across your project. Ephemeral issues such as this and indenting and other patterns that aren't directly part of the programming language do actually form part of the engineering. John Carmack talks on this and similar issues.
Seconded, C is generally a lowercase language, with exceptions for constants being all caps. But feel free to do whatever works best for you! There is no rule to follow. Some people will place one or two leading underscores on private/static functions within a .c file. IE: If you see a function such as __my_cool_function(); being used somewhere you can immediately know it is private/static to that file only. There are lots of little things people writing C do, you'll pick up on them as you gain more experience.
This is an example I gave to someone else on 2D matrices and pointers: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int num = 'A'; void* p = malloc(4 * 5 * sizeof(int)); // Allocate int[4][5] array int (*m)[5] = p; for (int row=0;row&lt;4;row++) { for (int col=0;col&lt;5;col++) { m[row][col] = num++; } } // Array in memory will now be A..B..C..D..E..F..G..H..I..J..K.... free(p); return 0; }
There are many situations where goto makes code (one or more of the following): * Easier to read &amp; understand * Execute faster * Have a smaller code size Only goofy CompSci professors with no real-world experience are against goto statements. Satellites orbiting our planet, machines/robots on other celestial bodies like the Moon &amp; Mars, the Java standard library, are all examples of code containing goto statements.
C11 is really portable, I see no reason not to use it. It is fully supported on all of the OS's you have listed afaik.
Windows has many C compilers, such as Pelles C. You do not need to use Microsoft's compiler; Intel, AMD, and Pelles all provide really great C compilers for the Windows OS. Microsoft also provides a complete C compiler/linker for free in their Device Driver Kit. It has been too long since I used it to recall if it supported C11 however. I use Pelles C for both my personal life and in business. Pelles C, for being free, and developed by 1 guy... is **incredible**. I only wish more people would spend the time developing C on Windows to see how great of an environment it is for creating software, even for systems that are not Microsoft.
double and single underscore functions are reserved for the implementation / standard respectively.
Do you mean to have a period at the end of your file name? You should be checking the value of the pointer returned by fopen before using it. If it is NULL, fopen failed.
Look up fscanf.
Try with c == '0'
atoi
changed the "count occurances" section to //count occurances while (!feof(input_file)) { fscanf (input_file, "%i", &amp;c); if (c==1) ++n1; else if (c==2) ++n2; else if (c==3) ++n3; else if (c==4) ++n4; else if (c==5) ++n5; else if (c==6) ++n6; else if (c==7) ++n7; else if (c==8) ++n8; else if (c==9) ++n9; else if (c==0) ++n0; fgetc(input_file); } The program compiles without error and runs but the output has absurd values.
 while (!feof(input_file)) { c = fgetc (input_file); if (c=='1') ++n1; else if (c=='2') ++n2; else if (c=='3') ++n3; else if (c=='4') ++n4; else if (c=='5') ++n5; else if (c=='6') ++n6; else if (c=='7') ++n7; else if (c=='8') ++n8; else if (c=='9') ++n9; else if (c=='0') ++n0; } Use chars instead of integers.
C with a formatting flaw.
this is C for DOS.
What happens when you run less without any arguments on the command line? The same thing will happen when your program runs it. Hint: "-" or "/dev/stdin" should tell less to read from standard input. I do not know if these are POSIX standards or not, or will be compatible with the requirements of your class.
I tried both of those as arguments now, but all im getting up on the shell is the process still running (nothing happening)
The process less will shutdown once it's input file sees EOF. As long as the input file doesn't indicate that it's been closed, less will keep running. I am not sure how much more I can explain without doing your homework for you. I would suggest that you reach out to your teacher or TAs if you're having so much trouble with this assignment.
It's not C# which is a very different language from C/C++/Objective-C. (Like Danish is different from Italian.) Do not conflate C# with the rest. The code you posted is valid C, C++ *and* Objective-C in the same way a piece of prose can be valid American, English and Scottish English. The idioms are more C-ish than C++-ish or Objective-C-ish and it appears to be written against a common MS-DOS console I/O library. To extend the analogy: "I took a gun to school to show the Principal" is valid English, Scottish and American English but the content of the text strongly implies a) an American speaker and b) an American speaker of High School age although neither is guaranteed to be true. Your code strongly implies a) C and b) C written for MS-DOS although neither is guaranteed to be true.
&gt; the output has absurd values That means different things to different people. To me, "absurd" would be values like 548318 or -1841. If the values are more like 4 when it ought to be 6, that's "wrong" but not "absurd".
That's backwards. The `_t` stands for `typedef`. But in your case, you would either write `struct player_t` (for the form that *isn't* typedeffed) or `player` (for the form that *is* typedeffed).
&gt; There is one convention that hasn't been mentioned here yet, which is _t to indicate that a name is a typedef. Actually, you shouldn't use this convention since it's reserved by POSIX. If you care about POSIX compatibility or portability, that is. &gt; B.2.12 Data Types &gt; Defined Types &gt;The requirement that additional types defined in this section end in "_t" was prompted by the problem of name space pollution. It is difficult to define a type (where that type is not one defined by POSIX.1-2008) in one header file and use it in another without adding symbols to the name space of the program. To allow implementors to provide their own types, **all conforming applications are required to avoid symbols ending in "_t"**, which permits the implementor to provide additional types. Because a major use of types is in the definition of structure members, which can (and in many cases must) be added to the structures defined in POSIX.1-2008, the need for additional types is compelling. http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap02.html
It is not backwards because `player_t` is just the tag, what is going to be used in the functions is `player *p;`
Wow, never knew that. I bet a lot of other people don't know that, either. Grepping around my /usr/include, there are an awful lot of typedefs of names ending in `_t` that aren't part of POSIX. Including a bunch in the Linux kernel for things like DVB and RAID. (That's particularly interesting, since Linux style is not to typedef structs in the first place!)
~~I don't know what you mean by "tag". That word has no meaning in C.~~ Okay, I never knew the name of an enum, struct, or union is called a "tag". Nevertheless, *that's not what everyone else is using `_t` to mean*. Given that typedef struct you wrote, there are two ways to declare a variable: struct player_t *p; player *p; But `_t` *means* typedef. Do you see how this is nonsensical? The name that has `_t` in it is the one that *isn't typedeffed*.
Ah right, *now* I get you thanks to that example. But isn't it weird already to use 2 different implementation? If you use the `_t` as tag then you should stick to `player *p`. But that's just my opinion since we don't have official conventions.
Without using the tag, it's not possible to separate the typedef from the definition of the struct's members. That said, I don't see much benefit in doing that in the first place. Sure, it follows the idea of data encapsulation so that the structure is opaque to the user. But most of the time, implementations just trust the user not to muck around inside a struct just because they know its contents. It's basically a mediocre compromise. If you're *really* concerned about the user not mucking up your structures, you shouldn't be giving the user pointers, anyway. There's no guarantee that the user won't at some point give you a pointer to a structure that was previously freed and is thus no longer valid memory, or just an corrupted pointer. The safe way to deal with this is to use IDs/handles, rather than pointers, so that your application/library is capable of assuming responsibility for safely ensuring that the object in question actually exists. This is what kernels do for file descriptors, network sockets, and many other such objects.
Thanks for making it clear.
What kind of portability are you looking for? ANSI C should more than enough. C89 seems over the top.
instead of passing &amp;c0 or &amp;c1, pass a pointer to a structure which contains what you need. Also, the signature for your thread function is incorrect. It should be void *funcname(void *arg);
Thanks, really helpful. I will look this over. What I'm trying to do is use each function `MC0` `MC1` etc. to grab the 4 answers to the matrix multiplication. Then display it in another function. I will give it a try and see where I get but essentially this program just multiplies two matrices through multithreading.
Parameters passed to your program through `argv[]` array are represented as strings. You cannot multiply strings. If the parameter strings in `argv[]` actually represent numerical values, it is your responsibility to convert these values from string form to integer (or floating) representation. Use `strtol` function for string-to-integer conversion.
conio.h is from DOS originally though, so the statement that it's "C for DOS" is perfectly correct. I can run your code that says "#include &lt;windows.h&gt;" on linux as well if I use a compatibility layer, but that doesn't change that it's "C code for windows", does it? I think it's certainly more correct than saying "it's C code", because that might give someone the [reasonable] expectation that this will compile on any conforming platform.
Why are you using multithreading? It's probably not going to be more efficient, at least not in this very simplified example. 
http://stackoverflow.com/a/1095006
The main reason I am concerned is because this is in a header and I don't want any problems from defining the same variable multiple times.
If you want to store an array of month abbreviations, you can write in the header: static char const *const months[] = { "Jan", ..... }; An alternative approach would be to make the header say: extern char const *const months[12]; and then have one .c file contain: char const *const months[] = { "Jan", .... }; There is no need to use malloc here (in fact it would unnecessarily complicate the code). 
In that case, you need to declare it as such: extern char** months; In your header, and define it in one of your source files using one of the above methods. Having an extern declaration followed by the definition is explicitly not an issue.
 const char const * months[] = {"Jan", "Feb", "Mar", "April", "ETC"}; for (int i=0;i&lt;5;i++) printf("%s\n", months[i]);
It's mostly just to understand it by programming something this simple. We just did a multiprocessing version and we just converted that into a multithreaded way to see how it works.
Looks like you don't know the origins of conio.h
Oh, yes I do. "Origins of conio.h" is my middle name. Yet, I saw so many Windows application that depend on `&lt;conio.h&gt;` that I can make the above statement with solid authority. DOS disappeared from the mainstream long time ago. Yet `&lt;conio.h&gt;` is still kicking here, there and elsewhere.
1. Use `stdbool.h` 2. These are the headers that you need: #include &lt;stdbool.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;strings.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; 3. After doing these two things, it worked for me Remember to *always* use -Wall -Wextra so you know exactly what you did wrong.
Got some motivation and confidence after reading your reply. Huge thanks.
I am totally confused. My question is - should I avoid this book? Many people advising me to do so.
It is hard to judge a book by a single code snippet. But yes, this terrible technique of including `&lt;conio.h&gt;` just to implement a delay at the end of the program is a serious argument against that book. A more relevant question is: do you have access to any alternatives to that book?
Our syllabus just want us to learn basic C. So I can use any book I want. The book I currently have was recommended by our teacher. Is Learn C the hard way any good?
waitpid with WNOHANG works, so it's not stuck in waitpid(), but doing something else.. If you want to find out what your program is doing, i.e. which system call it's currently executing run strace -f -p &lt;pid&gt; where &lt;pid&gt; is the process id of your program. Otherwise, use a debugger to see what is executing in your own code to figure out what's going
Thanks for the help! I'm learning so much haha. I've already moved the open and close outside the loop and am now adding the b modifier. :)
The pointer points into memory. Its value is different each time you run the program and is thus not useful when writing data into a file. Try to alter your binary file structure to not use pointers.
Ah! saviour! I understand now. Thank you very much for all your help and easy explanations! Ninja edit: Although one question! How would I avoid saving the ptr-&gt;next variable? Would I just save the node's value, and what if there was more than one value? fwrite(ptr-&gt;value, sizeof(ptr-&gt;value), 1, file); Or is that wrong and there's another way I should be doing it. 
&gt; Is there a good reason to include the the do while(0)? Yes and no. "Yes", because `do-while` is a convenient way to create a compound statement in C language that *requires a semicolon after it*. It means that `do-while` statement "swallows" the semicolon that follows it. (Why `do-while` was designed in that unusual way is a matter of a separate debate.) This property of `do-while` is the reason it is widely and idiomatically used to write multi-statement macros. A macro written in that way can be used as an "ordinary" function with "ordinary" syntax, i.e. in any context you can "call" that macro and follow that "call" by a `;`, just like you do with ordinary functions. /u/zifyoip answer has an example of when it matters. Alternatively, one can probably achieve the same effect by doing something like #define MY_MACRO() if (1) { /* statements go here */ } else but it is way more dangerous in case the user makes a syntax mistake. -------------------- "No", because in your case the macro contains only one statement, which formally makes the `do-while` unnecessary. It could be defined as a mere #define WRITE_INTERRUPT_MASK(mask) (INTR_MASK_REG = (mask)) However, sometimes the `do-while` idiom it is used unconditionally just to isolate the macro from the surrounding context, or simply for uniformity with other macros. (I also suspect that yours is not a real example, since it contains a syntax error.) 
you wouldn't. You'll be creating this when reading the _data_ from the file. This is not your internal representation of it (which is the linked list). You fill it in/create nodes while you read the data. look at what /u/angdev said again; &gt; If you want to open the file up and plug the data back into a Linked List, then go through the file as if it was an array of data, and for each array element, create a new node using malloc() and fill it out as you normally would. Keep doing this until you read the end of the file. It doesn't matter what or how your data is in the file and what your linked list (which is just these pointers) is. You can fit whatever you like in for instance a structure seperated from the linked list stuff if that makes you more comfortable. You'll still have to read the data in properly and create the list while doing so to read it back. e: for saving it's the same, you write only the data. There is no need for saving these memory addresses since when you read it back you'll have to read the data into a new linked list. e2: do care about these read and write functions though. What works on x86 might not work on arm for binary files. Also, when you write structs the compiler is free to use spacing to read it back quickly in memory but when writing these things don't work. Also, some machines order words different then others; 1234 might as well be 3412. A (cheap) way around that is storing data in ascii.
It is a bit of a goofy work-around to ensure macros function properly when a person uses them but may not be aware they are in fact using a macro. /u/Rhomboid has a pretty thorough explanation as to why.
The pointer is a variable which value is a memory address, in order to access the value inside that memory address you need to use the * operator. *ptr I believe this is a list, so it would be (*ptr).value This can also be written as ptr-&gt;value I hope this solves your question
Oops, typo on my part. There's a semicolon in the macro
To be pedantic, this is not exactly a "comma list". This is a *comma operator* that combines several expressions into a single expression. Yes, this technique works, and it might be preferable in many cases. But it can only be used to pack several *expression statements* into a single macro. Once you need to include any other kind of statement into a macro, comma operator is no longer an option. And, of course, you cannot introduce internal declarations (e.g. temporary variables) with this technique, while the `do-while` approach gives you full freedom to declare anything you want as often as you want.
Trial division &lt;3
I personally use code::blocks
code::blocks is good as an IDE and gcc compiler. I use it with GTK and wxWidgets frameworks. code::blocks is available for Linux and windows.Developer friendly and powerful.Highly recommended. http://www.codeblocks.org/home
I used Eclipse for programming a game that compiles to linux, windows and mac in c using gcc and sdl2. You only have to add the libraries and include folders in project properties, and it compiles everything automatically. The gdb gui stuff with break points and values is also good and intuitive. One other thing is that you can hover over a function and see it's code/documentation, and ctrl+click to jump to the function. If you learn the hotkeys then eclipse is good IDE that works on all platforms.
You don't need to install libraries or compilers. Just copy the files somewhere and run them.
The win32 API is available to you I guess? with a little work you can do simple graphics, and all the dialog boxes you could wish for. There's a good intro [here](http://www.winprog.org/tutorial/), and a lot of resources on the web.
Nevermind, figured it out, needed to use char** as such: void func(char** p); //Declaration in global scope static char* MenuItem_Titles[NUM_ITEMS] = {"one","two","three","four","five","six"}; func(MenuItem_Titles); //Call and access it like this: void func(char** p) { char* str1 = p[0]; char* str2 = p[1]; }
&gt; I want is for p[0] to give me a pointer to the address of the 'o' in the first string This is kinda unclear. What is "pointer to the address"? In C language "address" and "pointer" are synonyms (with some informal differences). So, "pointer to the address" sounds like "pointer to pointer". I don't see any readily available "pointers to pointers" in your declaration. I'd guess that what want is simply void foo(char* p[]) { ... } You can call it as `foo(MenuItem_Titles)`. And inside `foo` `p[0]` will give you *pointer to the beginning of string "one"*. `p[1]` will give you *pointer to the beginning of string "two"*. And so on. I'd also recommend you to use `const` qualifiers, where appropriate. Again, I don't know your full intent, but it appears that the following `const` qualifiers might be in order static const char* const MenuItem_Titles[NUM_ITEMS] = {"one","two","three","four","five","six"}; void foo(const char* const p[]) { ... } 
Er... How is that different from what angdev does?
I second using/learning the win32 API. You can do almost anything if you have the time.
He must have edited his post, it's the same now
I edited my post shortly after :p
Wikipedia is a good resource for that kind of stuff!
You want K&amp;R C, second edition. It is written by the creators of C and continues to be the definitive resource. There are a lot of exercises in there to allow you to apply the concepts therein.
This seems like a good idea. Thanks for the link. Just out of curiosity do many people use the win32 API to develop the front end of programs? Or do most people develop the front end in higher level languages?(ex: C# Winforms)
Why do you prefer to not use an IDE? Is it the convenience or efficiency that bothers you? How do you do runtime debugging? Can you setup breakpoints in whatever you use and examine the hardware? I can watch the processor registers as the code runs in slow-mo or hits a breakpoint for example, how do you do that without an IDE?
Regarding an IDE for C: I use Eclipse 90% of the time and just vim 10%. There's some things eclipse is much better at - refactoring is easy, symbol lookup is better than cscope for me - it's definitely a productivity boon if you can use the extensions. I don't use the integrated compiler/debugger as I use a separate build machine. One thing I like is that sometimes I'm in other languages I'm less familiar with (Python, Lua, Node.js, scheme etc) and I can always find syntax highlighting and validation.
If you must use an IDE, use Code::Blocks. If you can avoid it, a great Vim set up can't be beat.
Actually it can. I'm not particularly advocating for not using IDEs, but there does seem to be a shocking amount of ignorance about what other tools there are and what they can do. "Can you setup breakpoints in whatever you use and examine the hardware? I can watch the processor registers as the code runs in slow-mo or hits a breakpoint for example, how do you do that without an IDE?" Even on Windows there's WinDbg, which has powerful capabilities beyond the Visual Studio debugger.
Give me some alternative tools for the TMS320F2812 DSP and I'll try them out tomorrow.
Like I said, I'm not suggesting you use something else.
As it has already been pointed out Eclipse is an IDE, not a compiler. If you are working on large, complex, team projects, particularly involving multiple programing languages, then it is a great piece of software. However if you are just getting started with C/C++, stay as close to the basics as possible. A simplex text editor, GCC and GDB is all you need. It helps to understand how the compiler and debugger works before you hide them behind a complicated IDE. Personally what I really like about Eclipse is how easy it is to extend. Plus its modular nature makes it really easy to incorporate its components into other applications. 
You can probably use OpenGL through the Windows API if you really want to. [This is the OpenGL project](http://pastebin.com/FHGVavEW) that comes bundled in Code::Blocks. It doesn't use anything that isn't already in Windows, although you might have to do a little searching to find the headers (it's supposed to be a part of the Windows SDK- you'll find the .dlls in System32, by the way). Windows only supports OpenGL 1.1 by default though, which is just enough to make something kind of interesting, but is actually a little over two decades out of date. You could also try out DirectX, which is native to Windows and most likely has a less convoluted setup because of that. I have no idea where the DirectX files would be, but if you can find them, it would be a good choice as well.
Your scanf format string is incorrect. You used a "&amp;" symbol instead of a "%". I don't immediately know if the space is significant.
Also check the output of "file $nameofprogram" That'll tell you what it's compiled as (a.out or elf)
You almost certainly shouldn't be calling srand() each time through the loop. Just once at the start of main() is enough.
scanf removes leading whitespace when trying to read in anything except %c. With %c, you must specify the whitespace manually or else it will give you the literal next character (be it tab, space, or even a newline from a previous scanf).
Thanks a lot for the quick answer!
gedit and g++ if you're on Linux
I write primarily for TI DSP's using their proprietary code composer studio IDE... any idea if there are better tools available?
http://i.imgur.com/129albw.png It's an option in most IDE's I'm familiar with. I cannot understand why people use shit like VIM or command line tools... they are not faster, is it just because they have that "hacker" air about them? I think most people just don't bother to learn how to use the good IDE's honestly.
Familiarity is a big part of it - I can use vim for editing any file, on any platform. I can search by regex with just pushing one key ( '/' ). I can execute a regex or command with ':'. I can use ctags to navigate the source. I can split windows, and do everything I need to do. I don't find the bloat of IDEs to be helpful. A minimal environment just works better for me. I understand if others are more productive in a busier environment, but it's not best for me. Hell, I'll never understand why people use Emacs! &lt;/flamewar&gt;
Well in that same case, couldn't you just use `{` and `}` to declare a new scope, and eschew the `do-while` entirely? C wouldn't care about a spare `;` at the end of that if I recall correctly (I might not), even if pedantic.
Yes its necessary. The input **c** is a a char. You give the array a'n index of the input (char), but the index of an array must be a number. That given index will corresponded to the number from the ASCII table. Now if the input is '5', the ACII number is **53** - '0' (ASCII=48) the output is 5. 
As a addition to the answer, Kernighnan does mention later that he used the `c- '0'` to convert char to int.
Integer values of character constants like `'0'`, `'1'`, `'2'` and so on are implementation-defined. And integer value of `'0'` is not `0`. For example, `'0'` is actually `48` in ASCII table. This means that if you attempt to access `ndigit['0']`, you will actually access `ndigit[48]`, which is way out of bounds of `ndigit` array. This is the reason you have to subtract `'0'` from the value of `c` in order to *shift* the `'0'-'9'` range of characters to the desired `0-9` range of integer values. 
Thank you! I was aware that 'leftover' whitespace characters in the stream could lead to problems further down the line. However I didn't know about the space before the format specifier to get rid of the whitespace character. Previously I had dealt with it by putting in an extra 'dummy" scanf("%c") to catch the newline character before the actual input. Does this also apply if I want to scan a string with %s?
Thanks! Whether or not %s also skips the whitespace characters was what I wanted to know.
Formally, they are implementation-specific. Yet `'\0'` is required to be `0`. Note that `\0` is not a *simple-escape-sequence* like `\t` or `\n`. `\0` is an *octal-escape-sequence*, like `\13`. The language specification requires such character constant to match the corresponding octal value. So, character constant `'\0'` will always stand for integer constant `0` and character constant `'\13'` will always stand for integer constant `11`. As for `'0'-'9'`, the language does not make any guarantees about the actual integer values. It only guarantees that `'0'-'9'` is a *continuous* range with "natural" ordering, i.e. `'9' - '0'` is guaranteed to be `9`. In other words, `'0'`, `'1'`, `'2'`, ..., `'9'` is always a tight group of characters located *somewhere* in the character table. But where exactly it is located - the language does not specify.
I've already picked up that he sometimes does things, and then explains them a bit later - I read to the end of the section looking for an explanation, but maybe I missed it.
That makes perfect sense. Thank you! I just started following this sub and you seem to be quite active and very helpful/knowledgable, and I appreciate that!
The following only works if output goes to a terminal it does not work if output goes to a file or pipe. Change your `printf`-invocation from printf("foo: %d bar: %d baz: %d\n", foo, bar, baz); to printf("\rfoo: %d bar: %d baz: %d", foo, bar, baz); `\r` (carriage return) is a control character that moves the cursor to the beginning of the current line. Subsequent text overwrites the text that was on that line before. Be sure to place no `\n` in such cases, as `\r` cannot back up into the previous line. You might want to specify fields lengths (e.g. `%6d` instead of `%d` so the output doesn't jump around when the number of digits changes.
&gt; but after a (not long) while it seg faults because of stack overflow. My question is if it is possible to do something about this. First and foremost, you need to figure out whether it segfaults for "natural" reasons (by design) or because of a bug in your code that causes unlimited recursion and, eventually, stack overflow. If it is caused by a bug, then you will have to fix the bug first, instead of trying to optimize anything or "jump to an earlier place".
Would my compiler automatically do tail-call optimization if it is able to do so? Or would I need to set certain flags? I'm going to look into `setjmp` and `longjmp`. I'll post the code as is, but it is obfuscated and formatted for visual effect. It is purposely difficult to read. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; static char _[30000] ,* k = _;static long int l[10000]; static FILE *z; int v ,g,y= (7^6)-1;int main(int q, char** __){return q==(1&lt;&lt;2)-2?z=fopen( __[1],"r"),v=0,main( getc(z), __):q==053? ++*k,main(getc(z),__ ):q==0x2D?-- *k,main (getc(z),__):q==31&lt;&lt; 1 ?++k,main(getc(z), __ ):q==15&lt;&lt;2? --k , main(getc(z),__):q== 46?putchar(*k),main( getc(z),__): q==2*2* 10+2*2?*k=getchar(), main(getc(z),__):q== 0x5B? *k? l [ v++]= ftell(z),main(getc(z ),__):++y,main(5,__) :q==0135?fseek( z,l[ --v]-1, 1&gt;&gt; 1),main( getc(z),__):q==(1&lt;&lt;2 )+1?g=getc(z),g==0135 ?--y?main(5,__):main (getc(z),__):g=='['? ++y,main(5,__):g!=-1 ?main((1&lt;&lt;3)-3,__) : q!=EOF?main(getc(z), __) : 00000:0x0001;}
&gt; I was thinking perhaps there is a way for the compiler to optimize it during compilation so that the recursion is unrolled. Is that possible? Depends entirely on the recursion. If your function calls a function, get the output, and then do stuff with it, of course it is not straightforward to unroll the recursion because you're doing some calculation and requiring you maintain state during that calculation. The most common kind of optimization to eliminate recursive calls is a tail call optimization, which relies on the call being the last thing the function does. In this case, the stack frame that function has doesn't need to be maintained. &gt; Another question I have is whether it is possible to mess with the stack during runtime. The return value from the recursion is not really necessary... In this case, and you can't phrase it as a tail recursive function/your compiler won't optimize the tail recursion, it may be best to maintain everything yourself. Maintain a stack of tasks, pop one off and perform it, which might involve pushing more on the stack.
Is it just me or do you read this post in the voice of Robin Leach?
When you link your program you should manually specify the stack size you want (make it really large). The linker tries to best estimate the stack size your program will need, but since your program is designed to be obfuscated, and work incorrectly, it is probably assigning it too small of a stack.
Ah, on embedded platforms that makes sense for sure.
http://c-faq.com/osdep/cbreak.html
As said before, you cannot portably overwrite more than one line. If you tell us the platform you are developing on, we might be able to give you further help. For now, try to put both information on one line.
You need provide a comprehensible description of what you're talking about or valid C code to be examined. Unfortunately, you have provided neither, regardless of incomplete comments. As such, we have even less clue of what you're talking about than you do.
My best reconstruction of the fragment offered: int iteration; /* initial value of 1, start of numbers to be tested */ int iteration_ number; /* the current iteration */ int iteration_copy; /* the number going through hailstorm */ /* only get next Iteration_number once iteration_copy &lt;= 1 */ switch ( iteration_copy ) { case 1: /* Get new iteration_copy from iteration_number */ if iteration_copy == 1 break; What's confusing is that you say that iteration is initially 1 and that you terminate when (iteration_copy &lt;= 1), yet you never assign values to any of the variables nor do you provide any iteration construct ( "for" or "while" ). I hope you get better soon, but if the hospital is giving you something potent for discomfort I think you should ask again later when you regain clarity.
Can you please post your full source code, I still have no idea what code you've posted (it is not valid C), no idea what it is supposed to even do, and no idea what your question is.
If you can't figure out reddit's formatting, post your code on http://pastebin.com or make a Gist at http://github.com and post the link here so we know what you're talking about. 
Neat, reminds me of python's struct module. Have you seen the python Construct module?
I'm not sure what you're trying to do here, but if your switch is going to detect iteration_copy==1 then it's going straight to break and it won't go through the other options you have listed. If you want to go through the switch several times you need to put it in a loop.
Haha that's kind of why I used it. There are a lot of thing I shouldn't do here, but do because I can.
The code you have provided is still obviously incomplete. Do you mean that you want to count the number of times the same case is called in a row? Are you sure you are not in some manner confused as to what a switch statement does?
Instead of begging, ask an actual question 