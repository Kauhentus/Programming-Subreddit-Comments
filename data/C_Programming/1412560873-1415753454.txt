there are objects, they are called structs.
I seeeee. OK! Thank you very much for your help. Hopefully I can make some progress on this now. :)
A string in C is an array of type char terminated by a NULL character, also written ``'\0'``. The first thing you should do is declare an array of 80 characters, ask the user for input, and then read the user input into the char array.
It's definitely been replaced in places where it wasn't such a great fit, but within its domain I think C is still king. You need to look at more hardware based companies, for example Cisco is (last I checked) still very much a C shop.
&gt; &gt; Please help us keep this place friendly and civil. &gt; &gt; I give as good as I get. My strongly held opinion is that your reaction is not merited by the people you were responding to. It's possible I'm mistaken. Likely, even: I was simply reacting to that other people claimed to have solved it, and OP agreeing. I haven't tried it myself. My outreach to you was about tone, and your tone not only hasn't changed, but you've attempted to present it as appropriate. Given that, it's clear that you don't want my advice. Thanks for responding in detail. Please have a good night.
&gt; "In this class we use conio deal with it"-the teacher. Yeah. That's why I think you should go to the dean: the teacher isn't actually supposed to be allowed to do this. The dean is who fixes this problem. . &gt; She have 30 year working as a teacher in my college. Well, then she's had 29 years to bring her skills up to date, so that she can do the job she's paid to do. . &gt; So I think I made a point in that SOME teachers don't want to update their skills. Yep. I don't disagree with you. I just think that unless a student puts in the time, this entirely fixable problem which is screwing classes full of kids who are paying good money won't get fixed. I appreciate your taking the time to respond. Good luck. I hope that you get a teacher who doesn't hold you back, soon. One parting comment, though: don't you wish a student last year had gone to the dean, so that you don't have to put up with this?
This is a valid point. At the time that I had said this, I was unaware that it was written. All the same, I am of the opinion that time should not have been the constraint here.
From the discussion, I thought that he had tried it both ways, one ending in an apparent hang because the compiler was still waiting on whitespace. However, I may be mistaken, and it's easier/lazier to not actually go look. Thanks for a pleasant conversation, and catching me on that other error elsethread. Enjoy an upboat please.
In America, too. We use your system, after all.
I'm in one of those flexible positions. Most of my tasking is about creating some particular kind of output or building a system with a specified behavior. How I make that happen is usually up to me, so I get to pick what I want. Often that's C. My job wouldn't normally be advertised as a C position. 
First off, Rutgers? Burned-out hippie professor who’s only still there because he was tenured sometime in the late Triassic period, and has neve had any clue what he’s teaching about but he’s been teaching it for the past century-and-a-half so that’s what he’s still doing? Overhead “slides” that are frenetic 8½×11" Adobe Illustrator PDFs, scattered packed frames full of 10-pt Arial text so the Is and lower-case Ls are indistinguishable from one another? Second off, is the array mapped properly for this? Because forking a process gets you something that’s copy-on-write (“COW”), not something that shares page mappings, unless a particular set of addresses has been shm’ed or mmap’d in properly. When I TAed a class that sounded surprisingnly like this one and had an identical assignment, no mention had ever been made of memory-sharing (he had no background in OS, or even anything remotely concrete), and I’m not sure what other people’s students could possibly have turned in that resembled anything like what he’d asked for. Third—and this is assuming you have a shared memory segment of some sort—semaphores are unfortunately one of the more portable-ish ways of doing interprocess communication, so you’ll need them for at least something if you’re not allowed to do Linux-/post-1990s-UNIX- or architecture-specific techniques. `i` will need to be located in the shared segment as well (usually there’s some sort of control header before the array), you’ll have to guard it with the semaphore, and you’ll have to have some way of setting up a barrier (i.e., rendezvous point) before and after writing to the array. If you’ve `mmap`’d something, you’ll also need to use `mmap` to ensure (portably) that changes to the segment are flushed, although they usually will be without you doing that. The good news about all this is that you’ll probably never have to use SysV IPC again in your life. Most parallel programs created nowadays (or at all recently) rely on threading or some other lighterweight mechanism for parallelism, and as a result I’ve never actually heard of somebody using SysV IPC stuff as anything other than an old-school fallback mechanism for `mmap` or Pthreads. Threading is also muchmuch easier to deal with in terms of data exchange—with interprocess stuff, you’re pretty much stuck with networking techniques like sockets or pipes, architecture-/OS-specific stuff like page-mapping tricks, or nigh-kludges like SysV IPC, but with threading all the address spaces are shared comfortably and with the same base address—the only fly in the ointment is TLS and you can usually get around that with hashing or addressing tricks if you need to.
In my opinion, it's because computers gotten faster,more languages have been made, and only low level driver components are written in C most of the time.
&gt; Also, what happens when my name is very long or i just type the eof character? You learn something which will help you pass the course. Isn't school wonderful?
Sorry my response is a bit late. I had to give up and go to sleep. I'll do a re-write with your comments in mind and hopefully success will finally be mine. 
Sure you can. Couple of ways off the top of my head: - If the program takes input on stdin and outputs to stdout, you can run it as a CGI script just like any other. This is really easy to set up, but doesn't scale that well and comes with some security pitfalls. - You can compile C to Javascript these days with Emscripten and run your program client-side in the browser. - You can have a C program that includes a full-blown web server alongside its actual purpose, which gives you lots of freedom in how your web server is structured. There are HTTP server libraries available for easy integration into C programs, I think. - You can implement your C program as an Apache or Nginx module and load it at runtime. - You can setup a publish/subscriber kind of thing where you have a daemon written in C in the back end, and a PHP script on the server that relays requests/responses to the backend daemon. There are many variations on this theme.
Awesome! Thanks
One thing not mentioned by teringlijer: [exec](http://php.net/manual/en/function.exec.php). You can execute command line from PHP so you can just run your program there. I imagine this wasn't mentioned because it's extremely dangerous. Then again so are most options. I suggest you look into how exec() can be hacked, so you have an idea of how to use it securely.
Will do, thanks
You must be a business major. The output is tabbed. It's not clear how the output is derived though. Where is the code for the output?
You probably should have been contacting Dr. Adams last week.
Okay well thanks for the help :P
Get your program to start producing the right output and then worry about formatting it. That is my advice to you. Also, start you assignments earlier and ask the correct person for help, not us. 
For a start, your existing code uses the wrong limits; the assignment says the starting point is between `2` and `999` inclusive; and the end point between `(starting point + 1)` and `9999`. Your screenshot doesn't show, but the numbers displayed appear to be the result of the [Collatz game](http://en.wikipedia.org/wiki/Collatz_conjecture), this should be described above the part that you screenshotted. Your tasks are: * (a) Make a function which accepts an integer as input, and returns the Collatz depth (e.g. `func(8)` returns `3` and so on) * (b) Loop through from `start` to `end`, displaying the results in the intended format. For part (a) it will look something like this: int collatz( int num ) { // you write some logic here return something; } For part (b) some combination of `printf` will be rquired, which presumably you studied elsewhere in the course. The basic output will be something like `printf("\t%4d:%d", num, collatz(num));` . It might work to just do this in a loop (i'm not sure exactly what the effect of tabbing will be on your system after it gets to the end of the line). I'd guess that most of the marks for the assignment would come from getting the right answer to part `(a)` even if you screw up the formatting, so concentrate on that. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Collatz conjecture**](https://en.wikipedia.org/wiki/Collatz%20conjecture): [](#sfw) --- &gt;The __Collatz conjecture__ is a [conjecture](https://en.wikipedia.org/wiki/Conjecture) in [mathematics](https://en.wikipedia.org/wiki/Mathematics) named after [Lothar Collatz](https://en.wikipedia.org/wiki/Lothar_Collatz), who first proposed it in 1937. The conjecture is also known as the __3*n* + 1 conjecture__, the __Ulam conjecture__ (after [Stanisław Ulam](https://en.wikipedia.org/wiki/Stanis%C5%82aw_Ulam)), __Kakutani's problem__ (after [Shizuo Kakutani](https://en.wikipedia.org/wiki/Shizuo_Kakutani)), the __Thwaites conjecture__ (after Sir Bryan Thwaites), __Hasse's algorithm__ (after [Helmut Hasse](https://en.wikipedia.org/wiki/Helmut_Hasse)), or the __Syracuse problem__; the sequence of numbers involved is referred to as the __hailstone sequence__ or __hailstone numbers__ (because the values are usually subject to multiple descents and ascents like [hailstones](https://en.wikipedia.org/wiki/Hailstones) in a cloud), or as __wondrous numbers__. &gt;==== &gt;[**Image**](https://i.imgur.com/zzdGKoh.png) [^(i)](https://commons.wikimedia.org/wiki/File:CollatzStatistic100million.png) --- ^Interesting: [^Lothar ^Collatz](https://en.wikipedia.org/wiki/Lothar_Collatz) ^| [^Conjecture](https://en.wikipedia.org/wiki/Conjecture) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl2byzh) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl2byzh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; &gt; Someone with no highschool or college training and a year of experience could do this test in about five minutes. &gt; &gt; You're overestimating a good percentage of students here. I'm actually talking about people who aren't students, but you may be correct all the same.
I don't know what you mean by memory efficient. Without resorting to compression your puzzles are limited by the size of the word you're searching. Also, why are you limiting yourself to embedded systems? &gt; Also, before I added the diagonal search case, the code would sometimes partially find the position. i.e., for some reason it would give the correct location of the word half the time, but other times instead of printing "2,3 4,3" it would print "2,3 0,0". I am completely swamped in other work and this is draining me, so any help would be greatly appreciated! If any other information is needed, let me know. Thanks! Debugging and troubleshooting your code is part of software development. Good luck. 
If you are lost.... start from where you are.... Post where you are / what you have.
Maybe post your code to github and we can comment on it? 
 include &lt;stdio.h&gt; include &lt;stdlib.h&gt; include "scanner.h" include "support.h" int countToken(char *dictionary) { FILE *fp = fopen(dictionary,"r"); int count; char *token; char *string; count = 0; token = readToken(fp); while (!feof(fp)) { ++count; string = readString(fp); ++count; free(token); free(string); token = readToken(fp); } fclose(fp); return count; } char ** allocateArray(count) { int count = countToken(dictionary); char **tokens = malloc(sizeof(char *) * count); return tokens; } char ** fillArrayWithTokens(dictionary,tokens) { tokens[i] = 0; t = readToken(fp); while (!feof(fp)) { tokens[i] = t ++index s = readString(fp); tokens[i] = s ++index t = readToken(fp); } fclose(fp); return tokens; } I believe that successfully allocates the array but I do not know how to fill the array with tokens from the dictionary file. Thanks
What options have you considered?
reformatted
I really have no idea, I know I have to add another variable in there and edit the printf("%d x ", cur_factor); in some way, but not sure at all
Nope still not readable.... try this... #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "scanner.h" #include "support.h" int countToken(char *dictionary) { FILE *fp = fopen(dictionary,"r"); int count; char *token; char *string; count = 0; token = readToken(fp); while (!feof(fp)) { ++count; string = readString(fp); ++count; free(token); free(string); token = readToken(fp); } fclose(fp); return count; } char ** allocateArray(count) { int count = countToken(dictionary); char **tokens = malloc(sizeof(char *) * count); return tokens; } char ** fillArrayWithTokens(dictionary,tokens) { tokens[i] = 0; t = readToken(fp); while (!feof(fp)) { tokens[i] = t ++index s = readString(fp); tokens[i] = s ++index t = readToken(fp); } fclose(fp); return tokens; }
Ok, now we can read it.... I bet you haven't compiled it with warnings turned on.... So reformat it to be readble, then compile with warnings turned to max, clean up the warnings, then repost. If you are using gcc, use the -W -Wall flags to turn on warnings.
I changed the allocate array function to this and then commented out the fillArrayWithTokens function and it compiles with no errors or warnings. When I go compile the last function with it is when I get errors, the first of which is that the fillArrayWithTokens arguments are not of the right type. The main problem is I dont know how to decipher the error messages. char ** allocateArray(count) { char **dictionary = malloc(sizeof(char *) * count); return dictionary; } 
If you don't post them we can't help you either... However, I can immediately see you haven't declared the type of parameter "count" in that function. 
Count is included in an earlier funtion. That part I posted doesnt give me errors, This does: char ** fillArrayWithTokens(dictionary,token) { dictionary[i] = 0; t = readToken(fp); while (!feof(fp)) { dictionary[i] = t ++i s = readString(fp); dictionary[i] = s ++i t = readToken(fp); } fclose(fp); return tokens; } The errors are: support.c: In function ‘fillArrayWithTokens’: support.c:42:1: error: argument ‘token’ doesn’t match prototype fillArrayWithTokens(token,dictionary) ^ In file included from support.c:4:0: support.h:3:8: error: prototype declaration char **fillArrayWithTokens(char *,char **); ^ support.c:42:1: error: argument ‘dictionary’ doesn’t match prototype fillArrayWithTokens(token,dictionary) ^ In file included from support.c:4:0: support.h:3:8: error: prototype declaration char **fillArrayWithTokens(char *,char **); ^ support.c:46:16: error: ‘i’ undeclared (first use in this function) dictionary[i] = 0; ^ support.c:46:16: note: each undeclared identifier is reported only once for each function it appears in support.c:47:19: error: ‘fp’ undeclared (first use in this function) t = readToken(fp); ^ support.c:51:11: error: expected ‘;’ before ‘i’ ++i ^ support.c:54:11: error: expected ‘;’ before ‘i’ ++i ^ support.c:58:5: warning: return makes pointer from integer without a cast [enabled by default] return dictionary; ^ 
Welcome to the club
&gt; Count is included in an earlier funtion. Alas, the very very early versions of C permitted you to declare parameters without specifying a type. It then implicitly gave the parameters the type "int". So... char ** allocateArray(count) Is short hand for... char ** allocateArray(int count) And char ** fillArrayWithTokens(dictionary,token) is shorthand for ... char ** fillArrayWithTokens(int dictionary,int token) which _isn't_ what you meant. These days it is _highly_ recommended you explicitly declare the type of every parameter. support.c:42:1: That says there is a problem in file support.c on line 42 in column 1. And my guess dictionary isn't an int. Which you implicitly declare the second parameter to be. Explicitly and correctly declare the types of all parameters and a lot of your problems will go away. Except this one... support.c:46:16: error: ‘i’ undeclared (first use in this function) dictionary[i] = 0; You haven't declared i.
I am downvoting this one and upvoting the other one :D
Not sure why they are making you take C for biotech. You should be more than OK with Python as a language for sciency and mathy stuff. C is great but I wouldn't recommend it as a beginner's language. That said you still need to finish the project. I recommend you go over what the program needs to do on paper, not on code. Code is an inefficient thinking tool, but an efficient calculator. Think about what the program needs to do in order to get the output. Ignore the formatting for now as others have said. If you know what you want the program to do, and not sure how to do it, then asking a question to your professor or a community is very easy. Simply say "I want the program to interpret the input and do X to it". That should get the ball rolling. Looking at your code though it looks very barebones. Your scanfs look great however I recommend you print out the input just in case. So scanf("%d", &amp;amp;x); printf("int x = %d", x); If you got the inputs working then thats a good first step. Next step is to figure out what you want the program to do, like I said above. Figure out the logic and mathematics behind it. Next step is to the implement your thoughts. This is where asking around is super easy because you clearly specified what you want the program to do. Last step is polish - make the tabs work. Try putchar('\t') and see what happens. If you have time I highly recommend reading Kernighan and Ritchie's The C Programming Language.
Thanks man, that helped me get that part down. Unfortunately that was only part 2 of 6 that is due in under an hour so I won't have time to write the rest. But hey I'll get one third right! Anyway, thanks again and have a wonderful day 
Cheers. Bottom line.... * You can't fix code you can't easily read and understand. Format it neatly. * Remember compiler warnings are your friend... many an hour of pain can be saved by turning on all warnings and keep your code warning free. 
I need to get better at formatting more neatly and using comments to organize. I suppose I need to find somewhere online that explains the different warning and error messages because our teacher has not done that at all. You did help me learn a good bit so thank you
Agreed, although AFAIK strings in more modern programming languages are NOT implemented as C-strings with null-termination, but instead objects consisting of a character array and length parameter. This is in many ways a superior approach because you don't have to read through an entire string to figure out how long it is. Anyways, I also love C, and the fact that it showed me that strings (like everything else) are just byte sequences...
Mediocre mentality: I expect my professor to teach me everything Winner mentality: I'm gonna learn everything and ask my professors for help on tough topics. Have been the loser, now the winner. Now my grades are way better.
No, you dont. Ima slap you with K&amp;amp;R. Make some structs, each struct has a pointer to next, and contains some data like name, id, etc. Link them next pointers up. See what happens. There's seriously a TON of online resources for this, there's no way you can be complaining.
Problem is the backwards pointer
Would it be a bad idea to do the same with your own programs in C? Just make your own string objects using a struct and provide some utility functions for replacing the string.h library?
I like when people get it! :D
I love C too but i just can not get strings to click. They just confuse me. You got your string literal: char *str ="string"; Which seems like a exception to the pointer syntax where its usually: int var = 5; int *p = &amp;var; See that makes sense, you make a variable then declare a pointer and set it to the value of the address of var. Then you got your string mutable: char str[] = "string"; Which makes a little more sense but i don't see how str is getting its value, i mean unless " is some sort of operator which it isn't, then i don't understand. And then finally you have your null terminated string which someone fits into this but i don't know how... If anyone sees this and wants to give me a quick rundown id greatly appreciate it. Iv been using C for a while now but strings just don't make sense.
Some libraries have their own string classes in C, that are just that. struct str { char *text; int len; }; It especially makes sense in places where you're dealing with long strings, and you want to use substrings. Say, a web server or a parser. You don't want to take your char array and copy all the bits out of it you need, you just want to point to an important part of it. So you have say: x = "We get a result of type: THE_TYPE\0" And your char* in the struct points to: x[whatever_index_the_type_starts_at] len = strlen("THE_TYPE") So, it's not a bad idea at all - if you have a good reason for doing it. 
Okay, so, string literal is literally (haha) a string compiled into the program. char* a = "Hello"; means that literally, a points to the 'H' in your program data. "Hello" is compiled into the binary. I'm gonna be honest though, I don't know why the second version is mutable. Edit: I've checked out the assembly generated by GCC. Looks like the first is a pointer to the actual memory of 'H', like I said. The second, however, literally stores the values onto the stack. (So that -16(%rbp) is literally an ASCII 'H', -15(%rbp) is literally an 'e', etc.) Edit 2: Clang does the same thing, albeit in a little more roundabout way. 
First, those two forms: char* strPointer = "string"; char strArray[] = "string"; are ~~equivalent~~ Edit: See end of post for correction. Now, the type of string literals is `char[N]`. It *should* be `const char[N]` because the standard says that writing to an array initialized with a string literal is undefined behaviour, but for some reason, using `const` isn't enforced. You see, most compilers will put the string's data somewhere in your executable and at runtime, it is (usually) loaded into read-only memory. That allows them to do a simple optimization by reusing string literals. If you use the literal `"string"` multiple times in your program, even for entirely different variables, chances are that those variables will all point to exactly the same memory address. That's why writing into this memory is undefined behaviour. It will have side-effects on all those variables, which you probably don't want. Anyway, that pointer you get when initializing with a string literal? That's just a pointer to this read-only memory. **Edit: Correction courtesy of /u/sftrabbit:** These are equivalent and create char arrays in writable memory on the stack: char arrayFromLiteral[] = "string"; char arrayFromByteList[] = {'s', 't', 'r', 'i', 'n', 'g', '\0'}; And this is the syntax for initializing said read-only strings: char* pointerFromLiteral = "string"; 
The expression `"string"` evaluates to a pointer to char, the value of which is the address of the first character in the string literal http://ideone.com/jUoZVl There is no such thing as a string *type* in C. A string is just a convention - it's a character array that uses the null character `'\0'` to denote the end of your string. Many functions iterate through a string element by element looking specifically for the null character to know that the end of the string has been reached. Check out this example: http://ideone.com/wKz1tO 
That is completely untrue. The first two forms are different, the second two forms are equivalent. strPointer is a pointer to the beginning of the string. strArray is an 6-byte construct on the stack, with each of the bytes initialized to the value of a char. Edit: They even generate _exactly_ the same assembly in clang. In gcc, literal (even though it's not literal) goes a quad at a time, while array goes a byte at a time.
Thanks for the correction, but.. &gt; That is completely untrue is that only for the errors you pointed out, or would you also like to add something constructive to the middle part of my post?
Oh sorry, yeah, the middle part is totally true. It's late, and therefore I'm a bit cranky :P
"C is the assembly language for the virtual machine unix" Enjoy it! You know exactly what is doing your programs. I recommend you to get a look to strings manipulation functions from glib : https://developer.gnome.org/glib/2.42/glib-String-Utility-Functions.html 
Correct.
I am programming sockets in java and it is a nightmare compared to C. Lack of direct memory access is extremely annoying at times.
&gt;Even Haskell's default String type is in fact a (backwards contructed) character array that is slow. Haskell's String is a [*list*](http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#String), not an array (that's why it's slow), ByteString is a [pointer](http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString-Internal.html#ByteString) and Text *is* an [array](http://hackage.haskell.org/package/text-1.1.1.3/docs/src/Data-Text-Internal.html#Text). Both Text and ByteString are fast.
If your professor isn't teaching you much then I highly recommend reading The C Programming Language. It's a light read and teaches you a ton about programming. Including pointer swapping.
Yep. Some days you just love coding in C. Other days you just want to kill yourself.
Just dont forget to enjoy the right language for the job. :P
For me it's type-safe containers and all the stuff in &lt;algorithms&gt;.
If the homework doesn't explicitly ask for it, there is no reason why he can't define his foor loop like this.
Oh i see. Ok, but where does a null terminated string come into this? I always see people talking about problems with strings that are not null terminated. And i understand that, theres no way to know where it ends. But are the strings in my example null terminated? In what context would they not be?
According to http://www.catb.org/esr/structure-packing/ (search for "`struct foo8`"), bit fields cannot cross a machine word boundary. So in fact, this struct is useless for this task. It's doesn't store the IDs in the least amount of memory, nor does it help in any way to read them out of the file.
In the type of c projects I work on its usually the latter...high level langs just wouldn't be suitable though
All strings enclosed in double quotes are null terminated, the C compiler does that for you. But suppose you copy part of a string into a char array like this: char *s = "abcdef"; char a[10]; strncpy(a, s, 3); // copy three chars from s to a Then a will contain 'a', 'b', 'c' as it's first three elements, but the rest of the array will be undefined and thus not null terminated (unless there happens to be a NUL at a[3] of course). So in this case you have to terminate the string manually: a[3] = '\0'; 
int i, average; int sum = 0; int count = 0; for ( i = 257; i &lt;= 439; i++) { if (i%2 == 0) { // Modulo, Finds all even nunmbers, while (i%2 != 0) finds odd sum = sum + i; // or sum += i count++; //Count total, used to find average. }} average = sum/count;
C *is* a joy to program in, but string processing is the case where I enjoy it least, especially if you don't have access to standard libraries (no regular expressions, for example).
Of course "want to kill myself" would be the *true* statement in that expression.
Lots of people have already explained things to death for you, but there's a key here that people seem to have mostly skipped over, which is that even though those two cases look similar, there's actually some syntactic cheating going on in the second case that the language allows to make strings a bit more convenient. Except for the case of defining an array, whenever you have a string literal like "foo" in your code, the compiler automatically defines that string somewhere in your programs memory and gives you the address of it. You can effectively think of the double-quotes 'returning' the address of the string, much like an operator. This applies in basically every case. Ex: If we have these definitions: char *foo; void bar(char *stuff); These are both valid: foo = "foo"; bar("foobar"); In both cases, the double quotes tell the compiler to store whatever in in-between them into the programs memory somewhere, and then return the address to whatever is asking for it. Thus the address for the string "foo" ends up in the 'foo' char *, and the address of "foobar" is sent to the function bar. The only case this doesn't apply is when you declare an array. It makes sense though when you consider a key detail of what I pointed out above. Those strings are stored into 'memory', but you don't know *where* this memory is. The standard says that this memory should be treated as *read-only*, thus this is invalid: char *foo = "foo"; foo[1] = 'k'; printf("%s\n", foo); You might expect "fko" to be printed, but the standard doesn't guarantee you can modify the memory string literals are inside of and the program may very well seg-fault. To get around this, you can use an array to store your string instead. Like this: char foo[4] = "foo"; foo[1] = 'k'; printf("%s\n", foo); This works as expected. The key here is that the 'foo' array is created on the stack, in mutable memory like any other variable. In this case, the use of the "foo" isn't like the others, and it's just syntactic sugar for saying you want to fill the array 'foo' with the contents of this string. This is equivalent to the above and basically what the syntactic sugar translates too: char foo[4] = {'f', 'o', 'o', '\0'}; As for 'null-terminating', every 'string' in C is null-terminated (Notice how I added the '\0' to the array, and the array is of size '4' even though the string has 3 characters). The null is nothing special, all null-terminated means is that every string in C ends with the character '\0', which is literally a zero char value. Because zero isn't a valid character, it's used to mark the end of the string. Any function that works on strings can scan through the entire string and look for the '\0' to find the end. C strings don't contain any type of length parameter, so using the '\0' to mark the end of the string is necessary.
Thanks, that's a beautiful explanation
You can add a variable to count the exponent and print it, the + 1 in the last printf is because your code assumes that the last factor is always valid and does not goes through the if(n%cur_factor == 0): printf("Please enter a number.\n"); scanf("%d", &amp;n); printf("The prime factorization of %d is ", n); int cur_factor = 2; int cur_exponent = 0; int times; while (cur_factor &lt; n) { if (n%cur_factor == 0) { n = n/cur_factor; cur_exponent++; } else{ if (cur_exponent){ printf("%d ^ %d + ", cur_factor,cur_exponent); cur_exponent = 0; } cur_factor++; } } printf("%d ^ %d.\n", cur_factor,cur_exponent+1);
Code snippet: int a = 257; int b = 439; int n = ((b - a)/2) + 1; int sum = (n * (a + b)) / 2; double avg = (a + b) / 2.0; printf("sum = %d\n", sum); printf("avg = %0.1f\n", avg); 
&gt; Isn't K&amp;R sometimes considered a bad resource? I don't remember precisely, but I swear I read through a discussion that it's full of errors and outdated info, and another which said it was good but wasn't really meant for less advanced users. Yeah, there arguments for that. K&amp;R is old. The second edition is from 1988 (the first edition is *older* and the second is based on the first; so it has an even older [than 1988] heritage). They were writing software with a different mindset back then, for a different audience. A lot of the practices you'll see in the book don't quite fit how you'd program today. And, besides, the book has a specific set of goals which doesn't include much of the people's expectations today. - A simple example is that many K&amp;R programs are about doing relatively simple textual input to textual output transformations, which fits really well with the pipes/filters UNIX approach (both Kernighan, K, and Ritchie, R, were UNIX gurus). However, today, we tend to need a lot more complicated software. - Another example is that K&amp;R2 won't teach you about secure C programming, which becomes an issue for many teams. You probably have already heard how easy it is to ignore errors in C programming. How do you deal with that? K&amp;R doesn't talk very much about it. What about techniques for safely manipulating memory (disciplines that can save you pain in the future)? It also doesn't talk about that very much. And these security concerns are issues for C programmers. - The book doesn't have a focus on dynamicity in programming, which is fairly pervasive with OOP and late-binding today. It talks about it "here and there", but it's definitively not a major topic in the book. - The book has very little focus on modularity. It talks about the language features to support that, but it doesn't dedicate chapters (not even 1) on how to effectively do it. The whole issue is that the book focus on C, not on how to program and also not on how to effectively use C in large projects. It has stuff on how to program, but it's a book on C: its syntax and semantics. It's going to show you language features that you could later decide to apply to get modularity, dynamicity, safety and so forth, but the book doesn't have chapters on "practices for safe C programming", "practices for large teams/projects C development", "practices for dynamicity in C", or whatever. The part in which you do good programming in C is another issue that K&amp;R doesn't really cover. Kernighan wanted to do something that beginner's could read while taking an introductory programming course, which means even more strongly that the book won't touch on advanced C programming practices to get large scale right, correctness right, security right, error handling right, dynamicity right, and so forth. So, keep this in mind. It's a book on the C language, and not on how to use it well (it has only a limited set of advice on this).
Since helping people with their code is only my hobby, not my job, I'll just offer some general comments that I think will help: You're doing a lot of repetitive work. Instead of copy/pasting these loops to create 8 different cases, you could do the same with some nested loops. The word to look for can be going in one of 8 directions: forwards, backwards, up, down, and the 4 diagonals. You can think of this as "amount the x and y indexes increment per letter". Forwards means x increments by 1, and y increments by 0. Backwards means x increments by -1, and y increments by 0. Diagonals mean both indexes increment by 1 or -1 (depending on which direction). So instead of duplicating code, you really just need a bunch of nested loops. The outer two loops will loop over the x_increment and y_increment, each going from -1 to +1. In the case that both increments are 0, skip it. That covers your 8 directions. Then you need to loop over the grid for various starting positions. That's two more nested loops. Inside these loops, you should calculate whether it's *possible* for the word to start at this position. For instance, if you're searching for the word in the "up" direction, but you're at position 0,0, then it's impossible for the word to start there. If it did, the next letter would be out of bounds (it would get a -1 coordinate). So you can skip that starting position immediately. The same applies to the end of the word (you already know the length of the word you're searching for, and the size of the grid). Lastly, you need to loop over the letters in the search word. For each letter, calculate its position based on the starting position in the grid, the increments, and the index of the current letter you're checking. Then look in the grid at the right position, and see if the letter is correct. If not, there's no match and you go to the next starting position. If you make it to the end and all letter match, then you found the word, and you know the starting and ending position. Other comments: Do you know about dynamic memory allocation? What will happen if I want you to search a 10x10 grid? You only allocate enough space for an 8x8 grid. Your variable names are ridiculously confusing. So far I see `i`, `j`, `k`, `l` (which I would *never* use because it's too easy to confuse with the numeral 1), `q`, `x`, `y`, `i2`, `k2`, `k3`, `j3`, `j4`, `qb`, `qu`, `qd`, `k3u`, `j3u`, `j4u`, `k3d`, `j3d`, `j4d`, `k3df`, `j3df`, `j4df`... yeah, I think we get the point. I'm pretty sure that of most of these, you really only need 5 of them. If you *do* need this many, you better rename them in a way that makes them easy to tell apart. With names like this it's going to be a nightmare by the time you finally get everything written. It will be even worse if you come back to it months later, or if someone else has to read it. &gt; This is for an embedded systems project, so memory is precious. Memory is *not* a constraint for a program this small. This should be easily solvable even on the smallest of microcontrollers. If you're running out of memory, then it's because your solution is way too complicated; you need to take a step back, get out a pencil and paper, and think about how you're implementing this.
Thanks for going so in-depth on all this. Overall it doesn't sound like my sort of thing then, if it's considered outdated. And what you mention about back then it was helpful for "simple textual input to textual output transformations" really won't help me as I hope to get more into graphical game programming more than anything.
And then you'll discover C++ and you'll be like woaw And then you'll discover Rust and you will forget about everything you knew before
In the business world, people generally use C only if they have no other choice. I'll be honest, I wish I could use C++ at my job sometimes, because having the compiler manage destructors and vtables for me would be a lot easier. Broadly speaking, this means you need to be looking at places where they have no choice but to use C: * Embedded systems (ones that can't pay the overhead of C++) * Linux drivers * Highly-portable code (overlaps with embedded systems, because not all embedded processors have a C++ compiler) * Legacy systems * Places where shipping in C is a requirement. (A huge amount of OSS Linux software is in C, but that's not a job for many people... but you get the idea)
Right, this is a lot to take in O_O. I don't feel bad in saying I'm not even familiar with the terms 'Dynamicity' and 'Modularity' (although I'm sure if given context I'd get it!). So overall would you still recommend this book for me above all else? I recall trying to read it but just crashing and burning very near the beginning. My goal is to make games and have fun getting there, so I really don't want something which will immediately go over my head and put me off a language. And thanks for the other book links, it's nice to have supplemental stuff to read as well!
Don't worry about all these books. They were just to help me make the point. Btw, I'll write a full reply in a while. BRB.
If you look at the assembly generated by your compiler, you'd see that it has your `const char*` strings allocated statically, and later just assigns the pointer to the start to that `const char*`. For the mutable string (array of char) it will stack-allocate those characters instead.
Yes. I do recommend it above all else to learn C. It's because although it has all these problems, it's not going to teach you a bunch of incorrectness in terms of the language like many of the other materials will. Other good books on teaching C for beginners include "C: A Modern Approach". This one is surely more recent (second edition is from 2008) and surely takes more attention to the fact that beginners might be reading it seeking not just C knowledge but also how to effectively use C knowledge. Maybe you can try this one too. I never did, so I can't tell. I've heard it's extremely good however. Nothing stops you from reading both K&amp;R and this one (if you do so, read this one first because I believe it's easier). Yes, K&amp;R is hard for beginners. It was my first programming book and I surely remember getting stuck. Somedays, I'd not be able to advance one page in the book. I was 16 back then with very little programming background from PHP tutorials. It took me about 1 month to go through the book. I've re-read it twice more since that. Put all that with the fact that there aren't many places to ask questions on the internet (the ##c irc channel sort of sucks a lot IMO), and you'll have something that can be quite challenging. To write games, why not stick to python? There was a recent post of a guy who wrote a minecraft clone in less than 1000 lines of python code (I think it was between 800-1000 lines). The point is that python is enough to write lots of interesting games. It seems I'm trying to discourage you, but that's not it. It's just that this stuff can get pretty difficult, which shouldn't be a preventing reason that stops you from trying it, of course. The truth is, however, to write games, sticking to python seems like a better bet than going to C and/or C++ (C++ is actually a lot more used than C in the games industry [even for smaller games] as far as I can tell). Javascript for games seems like a good idea these days too, btw. The amount of knowledge you'll have to gather to go from beginner/intermediate python programming to a good enough C programmer that you can write fun simple 2D games can be quite a lot. If you exclude the "simple" and go for simply "2d games", then it can take a lot more. If you allow for 3D and 2D, then it takes even more. A lot of this isn't really about C, but getting the concepts and ideas behind non-trivial games to work in C is a lot more difficult than it is in, say, JS or Python. C++ also facilitates development a lot, at the cost of being an extremely complicated language. I'm not trying to discourage you. It could be that you'll find it all too easy. There are those who do. But that's not the rule. It seems, as far as I can tell, that it rarely happens. The rule seems to be that if you're finding it too easy having little programming background, it's way more likely that something else is going on. So, keep studying and practicing. Once you start getting results, you'll have feedback (working and maintainable software, team work, ...) and you'll know how much you actually know or not. __EDIT:__ Once you start studying C, you'll find out how simple it is. For example, - The most complex data type you'll have in C __by default__ is the fixed sized array. Today, the sizes can be initially drawn from variables, having what is called a VLA (variable-length array), in older versions of C the size had to be drawn from constants. But even with VLAs, the size is fixed: once it's set, it cannot be changed. - Lists that can easily let you add and remove elements aren't there. - Associative dictionaries that map keys to values aren't there. - Tuples aren't there. - Strings aren't really there as an explicit data type that you can deal with as nicely as you can in python and Java. Strings in C are just arrays of bytes that have their end marked as a 0 byte, and given the memory address of the first byte in that string, you have a set of functions that can operate on those bytes to give you the effect of string operations (like length [i.e. count how many bytes are there until the 0], or concatenation). - Values have to be put into memory regions. And you generally will have to deal with all the memory regions. Memory won't be managed for you. That means that creating and discarding complicated values, like you can easily do in python, is a whole different kind of task in C. And it frightens C programmers to the extreme. - Arbitrarily large numbers aren't there. - ... It goes on and on. So... How do you make a C book that from nothing, has to teach you C and building interesting modern applications? It's pretty difficult. It could be that what you see in K&amp;R2 (e.g. the simple text input to output transformations) are actually good examples because even though they're simple, they're still useful or something that can be useful (a lot of what is there are simplified versions of unix command line tools).
Right... You can also try different python materials, like the MIT or Berkeley lectures. As far as I know, they're very good.
I'm open to trying anything really, so long as it's a good resource. Just experimenting with other languages I guess I want the most enjoyable way to go about doing it.
Bingo. A lot of projects end up reimplementing the same things over and over.
assembly language next 
almost: char s[3] = "foo"; produces a non NUL-terminated string. it is a special case.
If you want to paste code into reddit, indent it with four spaces so it appears in monospace. Please remove line numbers so your code is easy to compile. Please also consider indenting your code so it's easier for us to read it. It's an insult to people who try to help you if you show zero effort in making the code and example data in your question readable. There is even a little "formatting help" so you can look up how to make your code readable.
When I first learned to program—this is something like 15 years ago—I started with *Learn C on the Macintosh,* by Dave Mark. It was a lot of fun, and I never regret being exposed to that stuff from the get go. The next language I learned was Perl, and I remember thinking, "This is cheating." ;-)
Well, the string literal is still null terminated, but s doesn't have enough space for the null char. Just clarifying for others :)
What I like best about it is how simple and consistent it is. Some languages let you do (pseudocode) `if (a AND b)` , however they throw an error if you write `a AND b` anywhere else. However in C, any expression is valid anywhere that an expression is possible. There's no behind the scenes magic either. 
At a bare minimum have them use a paste site, something like [codepad.org](http://codepad.org) which compiles/executes the code would be a bonus.
I agree, C strings are good enough in most cases and the alternative is easy to implement / use in other cases. The same could be said about a number of things in C. I try to be conservative about defining new data types and using non-standard libraries, but when you really need to it's not a big deal. 
&gt; manly programming lumberjack Hell yes
The copy *seems* fine although the code is more complicated than it needs to be, why not: int num_pixels = *height + *width; for (i=0; i &lt; num_pixels; i++) { to[i] = from[i]; } Also, are you passing the correct arguments to `reset()` properly? seems like you're applying filters to global.working and not global.temp, so it seems like you should swap arguments. Anyway I just skimmed the code. The above code should do a proper copy.
One thing you may want to try is Java (ducks) while working with Jython. Code up a class in python - then convert the class to a Java class and test to see it works the same. You can import a Java class directly into Jython. Theres many more hoops to jump through with other language combos.
C For Dummies is pretty good, I read the first edition though and I don't know how easy it will be to find. It's not terribly in depth but it is enjoyable to read. If you've got any previous experience it might be a bit too simple at least at first though.
That sounds extremely useful. I always wondered about that when some programs say they're created with multiple languages. I'll keep it in mind, thanks.
C for Dummies was my first real introduction to programming. It's funny and interesting, and I think it holds up today. There are even extra chapters on the website that bring in some more modern concepts.
Yes! Let's raise C programming's barriers to entry even higher!
Well, if you put it that way. Do you think this barrier would stop any people from asking questions who would actually like to get an answer instead of send-me-teh-codez? I have the hope that requiring this little piece of effort not only reduces the amount of indenting I have to do one other peoples code, but also turns away the people who put zero effort into their question. This is a forum for fucks sake, not a service you pay for.
People have told me [Build Your Own Lisp](http://www.buildyourownlisp.com/) is a fun to read online resource.
&gt; This is a forum for fucks sake, not a service you pay for. Indeed. So what is it that makes you 'have' to do anything? If people ask questions in a manner I can't decipher, or which is clearly answerable after a few minutes on a search engine (or, heaven forbid, in a compiler), I ignore them. I don't feel any need to kick them out or belittle them in any way. Their lack of an answer is punishment enough. This is the internet for fuck's sake. If you^* are incapable of ignoring things you don't like, you're in for a rough time. [*] Generic you not personal you.
Well, I'd still like to help people. And I don't like ignoring newbies because they might get the idea that nobody will help them. Instead I usually go and tell them to try again with well-formatted code which I believe is more helpful for them than ignoring and downvoting them. I have the believe, that we are helping newbies with a submission text that tells them to indent there code, since people like you are more helpful when they see a post that is actually readable. I also believe that there is a high correlation between shitposts and posts that don't format their source code. The assumption is that people who make shitposts won't go the extra mile to indent their source code, but people with actual questions will.
Hey, could you indent your code with four spaces so it appears in mono-space font? It's really hard to read otherwise.
K&amp;R. You'll learn not only C but also Unix, because they were the creator of Unix. Yeah, they were so badass they made a new programming language just to program Unix. Highly recommended read not just to learn C, but to learn many important programming concepts like pointers, arrays, memory, and how great programmers think. Also Unix is such a blast to program in, if you haven't considered it I highly recommend installing Linux or getting a Mac.
You're asking `13 mod 1`. Any integer `mod 1` will be equal to zero. Your statement is basically saying is this number perfectly divisible by 1. Remember that % and / are not the same, the percentage (modulo operator) sign (%) will return the remainder of the division. 
1) There are quite a few things that are not 'right' about this code. However to start from the most obvious one, it' the for loop. 'for (y=2;y&lt;x;y++)' If you divide any number by 1, you will not get any remainder, hence you were hitting the first 'if' condition inside the for loop. 2) You will never hit the second 'if' condition within 'for' loop, if you understand how for loop works. So get rid of second 'if' condition from the loop. 3) Now what you have is a basic structure to identify if number is prime or not. Maybe you can set a flag in the first 'if' condition within 'for' loop and break from there, if number is not prime. 4) Once you are out of the for loop, based on the flag value, you can determine if number is prime or not. Here's quick fix. int main(void) { int x, y; printf("Enter number to check if it's prime: "); scanf("%d", &amp;x); if (x==1) { printf("\nThis number is not prime."); return 0; } if (x==2) { printf("\nThis number is prime."); return 0; } int NotPrime = 0; for (y=2;y&lt;x;y++) { if (x%y==0) { NotPrime = 1; break; } } if (NotPrime) printf("\nNot a prime number\n"); else printf("\nIt's a prime number\n"); return 0; }
This is really helpful. Thank you. I'm pretty new to C, would you mind explaining why the second if statement won't work in the for loop?
'for ( y=2; y&lt;x; y++)' This loop statement has three parts i. Initial condition . Here it is y=2 ii. Exit condition . Here it is 'y&lt;x' iii. Statement to execute after each iteration. y++ - Increment y by 1. So, program will enter the loop with y = 2 in the first iteration, and at the end of the iteration it will increment y by 1. Now before proceeding with second iteration it will check for 'y&lt;x', if this condition is true, program execution would enter into the loop. At one point of time, y will be equal to x, hence 'y&lt;x' will fail and program execution would not enter into the loop.
Excellent. Thank you for this.
Hey sorry it was indented when I pasted it but it didn't take so hopefully i fixed it
Reddit makes your text mono-spaced when you indent every line with four spaces. Try again.
Let's be honest: a lot of the questions on this sub are from students who aren't trying very hard, and often haven't bothered reading the error message they're getting, or asking their TA or professor for help. If there were a barrier to them getting us to help them with their homework, I'm not sure I have a problem with that.
It's probably better to use arrays of pointers or pointers to pointers and use dynamic memory allocation. This can save a lot of memory. For example, int arr[1000][1000]; will allocate 1000 * 1000 * sizeof(int) bytes, which is quite a lot.
Learning to follow basic rules will come very beneficial in this field.
Looking at the code at the link, your reset function is calling the copy function with void reset(void) { FIBITMAP *image; copy(global.temp, global.working, global.w, global.h); //FreeImage_Unload(image); } The order of arguments coming into **copy** are void copy(pixel *to, pixel *from, int *width, int *height) so it looks like your reset is copying *into* the temp buffer from working, not from the temp buffer into working. Is that what you intended?
That sounds interesting, thanks!
For that matter, why not just use `memcpy()`? It should be more efficient than copying byte-by-byte.
Something else others haven't mentioned : it's useless checking numbers for `y &gt; sqrt(x)`. (nothing to do with C, just math) You can get the square root (as a float, not an int, mind you) using `#include &lt;math.h&gt;` and the `sqrt()` function. Also, your `if (y==x)` condition in the loop will never evaluate to true. Why?
The thought did occur to me, but then I remembered that we're mostly humans in here, not compilers. Edit: grammar
&gt; a lot of the questions on this sub are from students who aren't trying very hard Those are particularly easy to spot. &gt; and often haven't bothered reading the error message they're getting Or maybe 15 years a sysadmin means I have a sixth sense for this. &gt; If there were a barrier to them getting us to help them There *is* a barrier already though - they have to make one of us give a shit. And that's rather the point. Arranging one's question in a manner more appealing to those capable of providing an answer is just common sense if one actually wants the question to be answered. This is already innate by virtue of being humans communicating with one another. I don't see any advantage in making a rule out of it. On the other hand I *do* see it making the sub more bureaucratic, less welcoming and making more busywork work for the mods to leave them with less time for useful modding. All just so that a few programmers don't have to bother calling their ignore_this_fool(); (aka Ctrl-W).
On top of which, even if the loop were changed to have an exit condition of `y&lt;=x`, it *still* wouldn't hit the second `if`, because when `x ==y`, it is also true that `x % y == 0`, so the first branch would execute, tell the user that x is not prime, and then `break` out of the for loop. 
Because the compiler will optimise appropriately.
That depends on the compiler, and the processor being targeted. One can generally assume that `memcpy` was implemented by someone who knew what they were doing, and will be reasonably fast for any size of input. The struct in question only has 3 bytes. But an array of them may have a stride of 4 bytes, with 1 byte unused. So the compiler might choose not to copy the 4th byte in your example, which isn't easy to optimize. Doing it with a memcpy would then be more efficient, if the processor has native 4-byte words. (If it has 8-byte words, it would be faster still.)
;( everyone should just learn English! 
You have no idea how lucky you are. In my course we have been dumped into C with little guidance and the results have been frustrating and unproductive. 
You could also try here: http://codereview.stackexchange.com
My apologies then. Do you happen to know where this is stated in the standard? I'm curious!
Rather than getting moderators involved in enforcement, I support the submission text along the lines of: &gt; Code excerpts need to be indented by four spaces to be monospace on Reddit. This greatly improves the readability of code and will make it easier to answer your question. I think something like the above will make it clear that indentation improves their question and its odds of being answered, without any administrative action.
Also yo udon't need to bother checking multiples of 2.
Codereview is for working code, Stackoverflow is for broken code.
You just need to add some extra comparisons where you are comparing the names. The strcmp() function will return 0 in the cases where the items are equal and this is the case you need to deal with to make a further check on the age. An example. Your code that compares against the head: if(strcmp(iptr-&gt;name, head-&gt;name) &lt; 0) { // Item goes at head of list. iptr-&gt;ptr = head; head = iptr; return head; } You could change this to something like: if(strcmp(iptr-&gt;name, head-&gt;name) &lt; 0 || (strcmp(iptr-&gt;name, head-&gt;name) == 0 &amp;&amp; iptr-&gt;age &lt; head-&gt;age)) { // Item goes at head of list. iptr-&gt;ptr = head; head = iptr; return head; } What that's saying is "If the incoming name comes before the head's name or if they're the same and the incoming age is less than the head's age, put it at the front of the list". Notice the extra parenthesis in the second case which groups the "same name &amp;&amp; lower age" so it's evaluated before the || operation is evaluated as a whole. You could extrapolate this for the rest of the checks also. Even better would be to write a separate function that takes two items and does all the comparisons and return -1, 0 or 1 similar to strcmp. Then you could re-use this logic in many places that looks like: int compareResult = CompareMyItems(iptr, head); switch (compareResult) { case -1: // iptr comes first break; case 1: // head comes first break; default: // Assuming function only returns -1, 0, or 1 this means it returned 0. // Oh no, they're still equal! break; } You could also do that with if-else statements if you don't know switch(). EDIT: Added more info because I'm a nice guy. ;)
Pretty sure that ain't C.
Looks like C# /r/csharp
Thank you so much! You're a lifesaver. 
I would just write your own method to check if a word with dashes matches a real words. Then loop through the dictionary and print out all the ones passing this test. 
I may not have made that very clear. As you've pointed out, the trick is dealing with -t--s- or anything of that nature (cat---, --t).
Well Apple might release a new macbook on Oct 16 :)
I've done something like this before using a multi-dimensional tree structure (sorted by both length and alphabet order), to do this you can just make a normal ordered tree with some pointers to jump forward to the right length when you don't have the first letter., then use PCRE for a regular expression comparison if you're lazy, or match character by character. 
its C++. But not to worry, i figured it out :)
Is there a subreddit for C++? Think i came to the wrong subreddit to ask for help. haha.
You would write a function that accepts a single argument. You then perform the appropriate mathematical operations on that argument and then return it. i.e double MyCoshFunction(int x){ return 1 + x*x/2 + x*x*x*x / (4*3*2)... }
There's so much wrong with that I don't know where to start. Try like this: http://codepad.org/RXrFbL9g
If I designed a program to do this: 1. Make a list of words that match the length of the input. 1. Make a list of pairs from the input: where the pair, is a non-dash character and it's position. 1. Then, for each word in your list of equal-length words: 1. Go through each pair: If the word doesn't have the character at the position, skip that word. 1. If you get to the end of the list of pairs, you've got a match, continue to the next word. There may be a nicer data structure to iterate through, I haven't given it much thought.
Or five for that matter. Any prime &gt;10 will end in either 1, 3, 7 or 9. Which eliminates more than half the primes. If you've stored all previous primes up to `sqrt(n)` you won't have to compare with the lower non-primes either (as every non-prime number is a combination of two [not necessarily different. If `sqrt(n)` is a prime, the two prime factors are both the same prime, four, nine and twenty-five for example] or more primes). If you don't want to handle dynamic memory, storing the first thousand primes or so within the application might be a good idea, as to later go over to a naïve solution.
Of course I didn't, but the burden of proof is on me: [In this standard document](http://www.open-std.org/jtc1/sc22/wg14/www/docs/C99RationaleV5.10.pdf) section "6.7.8 Initialization" : For programmer convenience, even though it is a minor irregularity in initializer semantics, the trailing null character in a string literal need not initialize an array element, as in char mesg[5] = "help!"; Some widely used implementations provide precedent. The idea here is for initializing structs of fixed-length (non \0 terminated) strings, like in: Struct { char name[8]; int value; }, where name is a fixed lenght string and is handled with the strncpy family of function (a pet peeve of mine is people using strncpy function, thinking they are done to limit buffer size -- in fact they are designed to work with fixed-length string, very different beast from \0 terminated ones). I am quite surprised at the use of the 'null character' in the rationale text, instead of NUL character, so my post was half-wrong anyway. i have no idea if they started using nulln this context (my C expertise comes from the 90's), or if I have been wrong all those years... so I am a bit puzzled :-) 
Thats cool, although I doubt I'll ever be a to afford it. And as a gamer it might not be the best choice!
It doesn't even compile. I think you should consider learning C basics before jumping into coding taylor series approximation.
Take it piece by piece, and always make it your goal to make something that still compiles. Don't throw together everything at once!
If you are asking how to do this, then you might find a variant of [Aho-Corasick Automata](http://www.cs.sun.ac.za/~lvzijl/courses/rw778/autappl/crous-hw2.pdf) interesting to explore. There are also [Levenshtein Automata](http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata) for fuzzy matching using Levenshtein distance, which is probably better ([here](http://www.mitpressjournals.org/doi/pdf/10.1162/0891201042544938) is another paper on it).
You should flesh out the algorithm in pseudo-code, for example : foreach word in list match = true; for i = 0 to strlen(input)-1 if (input[i] != '-' &amp;&amp; input[i] != word[i]) match = false; if (match) output(word); The above is incomplete and will not give you exactly the right answers, but it is going in the right direction :)
Your problem is writing the wrong number of bytes. For example, with timestamps, you're always writing 80 bytes, which is longer than the formatted string, leading to writing whatever random bytes are in the rest of the string. Just use fopen/fprintf etc. for this. Much easier than system calls.
Ok, i'll look into those functions. Out of curiosity though, why am I not even printing the beginning of the string then? For example, I would expect the following: 14-22-01$#@%^#@! With the characters above being the junk in the remainder of the array. Is that not correct? 
Turn it into a regular expression and use your favorite engine. Or even call out to grep. :)
C has a cosh() already. If you're just learning math, there are likely better languages for playing with series... Octave or Pari, for example.
Your first write() is 33 bytes of a string constant that is much shorter, which means reading memory filled with a random part of the executable. That'll throw off anything after when you try to display the file in most editors. 
Do you have to do it in C? That's a one liner in shell.
I can't use my typical teaching style here since I requires answering questions with other questions to make the student think. (I'm an assistant for the first year programming module at my university). /u/_MuchToLearn posted a "correct" version of your code. *Personally, I don't think that's wise from a teaching perspective* Take a look at it and see if you can identify the differences (down to the *character* level, i.e. maybe a ; or . is different) Finally, the issues I saw with your original code are: * You tried to declare a variable *outside of the body* of the main function -- i.e. outside the {}'s *(Line 4)* * You (incorrectly) put a ; after your *main* function declaration *(Line 3)* * You forgot a ; after your *scanf* *(Line 7)* * You tried to define a new function (*MyCoshFunction*) *inside* the *main* function *(Lines 8--10)* * You forgot a ; after your *return* *(Line 9)* As I've said above, I usually help a student figure out the problems themselves, by asking them questions, or answering with questions. (*Makes the student think a bit more ;-)* )
If I didn't have to do it in C, I would do it like this. Make sure you just run the one line version. Unix commands are just really well suited for this sort of text processing. It's basically just grep with some command substitution. # echo "Provide a pattern."; #prompt for a pattern # read input; #get user input into a variable "input" # echo 'foobarbaz foo bar far boo' | # here's the data. for you it's cat /path/to/file # grep -o '[a-zA-Z]*' | # This gets all your words on separate lines, assuming they are alphabetical # grep "^$(echo $input | # this is where we start converting the input to regex # tr '-' '.' | # your idea for "-" is referred to as wildcard: "." in regex # tr -d '"' #and kill the quotes to prevent injection #)$" | sort -u # makes your result sorted and unique, though not sure if that's what you'd want `echo "Provide a pattern."; read input; echo 'foobarbaz foo bar far boo' | grep -o '[a-zA-Z]*' | grep "^$(echo $input | tr '-' '.' | tr -d '"' )$" | sort -u`
In fact, if you poke through your executable program using the Linux "strings" command, you'll see those exact strings in the output!
Well that's *technically* more than one line and it's out of the scope of the course I'm taking. Prof would definitely know what was up.
It's 2 lines in a reddit comment :). Not much I can do about that.
sorry, still new to the formatting 
Hey, no problem. You can edit all your posts after you make them.
ok, after fixing it, the last change i made was printf("Don't you wish it was %lf?",pow(avg1,1.05)); this got it to work
For mingw, I don't have that directory even though I've installed pretty much every msys bin from the mingw installation manager; do you know any specific packages that need to be installed to run make?
Presumably, * first parameter: an array in which to store the result. * second parameter: the length of that array.
Check `y * y &gt; x` instead of using sqrt
You don't need to use strncmp if you're just comparing one character, instead, you can just use: if (*lettergrade == 'a') or: if (lettergrade[0] == 'a') 
Oops. Well that was embarrassing. Thanks for the help!
In that case- no - they both compare by looking at the value at the pointer. `a[b]` is the same as `*(a + b)` - it just offsets the pointer a bit and looks there instead.
Yes and no... The sqrt can be pre-computed and stored outside the loop, whereas the multiplication will have to be evaluated every time. But still a good idea
Thats nice. My only issue is that the name reallocARRAY is a little confusing. I don't know how to make it better though. I would prefer a name that indicates that it does overflow detection since "arrays" can be allocated by any of the *alloc() functions. Maybe an ever better approach would have been an overflow detection function or macro that you could wedge into the size parameter like: a = realloc(NULL, ovfl(num, size));
Also, you have a typo. I think it should have been `printf` instead of `print£`.
I don't believe the argument that length + content is fundamentaly slower than content + null byte I more think it's more for historical reason.
I can just imagine this conversation happening: * colleague A: Hey! I am going to use Fatso on this project! * colleague B:Who the hell are you calling fatso??!! * colleague B: HRRRRR!!!! 
Good points.
I mean there is no way for ovfl() to indicate an error, as it would return size_t. Edit: :-)
&gt; Fatso supports the following build systems: &gt;- Autotools &gt;- CMake (TODO) &gt;- Plain GNU Make (TODO) &gt;- SCons (TODO) &gt;- bjam (TODO) &gt;- Custom scripts (TODO) Here's all the stuff we can^^'t do! But being serious... explain to me how will this project help me.
the nul terminated strings __have draw backs__: two example after some search https://en.wikipedia.org/wiki/Null-terminated_string#Limitations http://www.joelonsoftware.com/articles/fog0000000319.html
I haven't said that C strings are perfect. I said that C strings are minimal reasonable effort. This is a difference. And when people don't notice that strings are not containers for binary data containing zeros... sorry... but THEY have a problem not C. Truncation and overflows are different... C strings are raw/lowlevel objects and should be handled with extreme care. When security is top priority (it is not always the case!), there are libraries that help for this special purpose.
EDIT: I'm wrong, thanks /u/rafleury You declare beta as a pointer to a 2d array, not as a 2d array of pointers. Take a look at the stackoverflow question below to see the differences between declaring arrays. http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation
you have semicolons in your function after your for loops, remove those
Actually, according to the link you posted, he declared an array of pointers. "int* arr[8]; // An array of int pointers. int (*arr)[8]; // A pointer to an array of integers The third one [int *(arr[8])] is same as the first."
The more I think about it, the more the name makes sense. Originally I wanted to propose `oalloc` ("overflow-flagging alloc") to stay with the `?alloc` pattern. Then I realized that this new function is both a `malloc` equivalent when called with `NULL` as the first parameter, and a `realloc` equivalent when called with a valid pointer. Kind of a `realloc` where realloc'ing from `NULL` is a special case. So an `?alloc` name wouldn't fit both uses. As for "array", the function deals with x elements of type y, and I can see how that becomes an "array", even if it doesn't seem very C-like. It's just a block of memory, no semantics intended.
You're right, got that mixed up, probably too late for me to think straight...
Thanks for the help man, I know these are stupid questions. I think this is the last one though: when running mingw32-make I get the error /usr/bin/sh: make: command not found. makefile:110: recipe for target 'all' failed. On that line in the makefile is "(cd ../../src; make -f ../windows/msys/Makefile $(TARGET))"; should that first directory be different? I don't know where that's pointing to at all
Ah good point. But you can compute y*y iteratively as 1+ 3 + 5 + 7 + ... which avoids the multiply at least.
[Look at what Bundler does](http://bundler.io/), maybe that gives an idea. :)
&gt; Making it being able to compile stuff means that its tied to that particular language or environment. It doesn't do anything other than run the dependency's own build scripts. If your dependencies don't require building for your own project to be able to compile (such as a header-only library or similar), that's no issue at all, and you're not locked in to a specific build system or process. This is really important: Fatso packages and dependencies have zero restrictions in terms of language and environment. But Fatso does make it easy to create a local environment that doesn't interact with your system's environment, or that interacts very minimally (things like the C Standard Library are harder to get around). &gt; Also, I suspect that a lot of what you're doing could be done in the CMake work with the external_project() command. Well, if only all projects in the world used CMake. ;-)
I've never liked these systems too much. They're a workaround for bad (incomplete) package managers, and tend to be completely incompatible with the OS package management. I understand the appeal for certain re-deployable web apps. I welcome all and any attempts at formalising/standardising dependency information. But needing a different package managers for each language is just insane, especially if a package depends on a package written in another language. I'd honestly rather go Windows and just bundle all dependencies in the program folder. However, bundling is even worse [0][1]. I'm currently working on a web app. Apart from the system package manager, I have bower, bundler, and npm installed. Thankfully I was able to skip pip as my OS (Gentoo) has excellent Python support. In the end, I support efforts like yours, if only for one reason. Hopefully, all those language-specific package managers will eventually develop a somewhat uniform dependency description format, which could then become easy to standardise (freedesktop.org, I'm looking at you) and would make the lives of system package manager maintainers much easier. Some years ago I was involved in something like this at Gentoo. We were developing tools to automatically generate ebuilds (scripts that describe the dependency and building information for our package manager, Portage) from things like PEAR and CPAN, so that all packages and their dependencies could be managed by Portage. Unfortunately, back then each system had their own, completely incompatible ways of describing dependency information. This also has the potential to replace a fair bit of the `./configure` step when building. If a dependency is missing, the build will fail anyway, and the user can see the list of dependencies in a standard file. Additionally, it'll make generating dependency databases semi-automatic, reducing the amount of work distribution maintainers have to do, ultimately leading to releases making it to the package managers more quickly (not to mention leaving them more time to work on improving their distributions). In the end, whenever I have to install yet another package manager just to get one package, I seriously consider the alternatives. "Being in the system repo" is an actual attribute by which I measure my likeliness to use a package. Not to mention, this sort of vetting done by the distro devs increases confidence in a project (it's less likely to break your system, be malicious, have licensing issues etc). PMs that allow developers to upload unchecked code lack this sort of checking. [0] https://blog.flameeyes.eu/2009/01/bundling-libraries-for-despair-and-insecurity [1] https://blog.flameeyes.eu/2013/04/bundling-libraries-for-trouble
/r/cpp
To prevent name collisions.
So how to programs typically recover from this type of overflow?
Always, ALWAYS use { }, even if there is just one line at the moment of writing it.
 FWIW, this topic got crossposted to /r/programming in [this thread](/r/programming/comments/2iwzqs/openbsds_reallocarray_extension_xpost_from_rcprog/), where I pointed out some issues with the code. I then got interested in the topic, and wrote some benchmark code to test different ways to detect overflow, which I posted to Stack Overflow [here](http://stackoverflow.com/questions/1815367/multiplication-of-large-numbers-how-to-catch-overflow/26320664#26320664), and linked back to reddit [here](http://www.reddit.com/r/Cprog/comments/2izncy/how_to_efficiently_and_cleanly_check_for_overflow/). (I put it on Stack Overflow rather than on reddit in the hope that people looking to handle overflow and googling for answers will find it.)
That was me as well, I posted it on both /r/Cprog and /r/C_Programming initially but later posted it in /r/programming (..which doesn't allow self posts). I think your results are interesting, however OpenBSD developers came to the conclusion that their implementation made the most sense for them and exposed fewer toolchain bugs/regressions on the platforms they tested (m88k/vax/mips64/ppc/i386/amd64/sh-4/sparc/sparc64). 
Link to their discussion? Thus far, I haven't seen a case that looks very persuasive. * On 32-bit systems (which are the most prone to overflow issues), their code will fall through to the slow division operation a significant fraction of the time. * Integer overflow in multiplication is a serious problem in a number of circumstances, not just `malloc` (just in the realm of memory management, there is `alloca` and `mmap` to consider, and beyond those, you have other common uses such as calls to `read` and `write`). Putting a band-aid around malloc is great, but to my eye it's better to provide a general facility to catch overflow. Also, regarding toolchain issues, any system that can't correctly compile the long-multiplication version of the code isn't fit for purpose.
Do you mind sharing the code you made for 1d arrays? I'm still learning, so the other one might be a great practice tool to read code and intention :)
Please provide a copy of your code. Use ideone or pastebin or gist, anything besides a screenshot (or a picture of your screen)
For a toy program like this, a slightly better way would be to use `snprintf`: int ret = snprintf(query, sizeof(query), "CREATE DATABASE IF NOT EXISTS `%s`;", db); ...and check the return value. (Beware that `snprintf` errorchecking is notoriously easy to implement wrongly, so read the manpage very closely.) But for something you'd actually use in production, this approach is atrociously unsafe as it's susceptible to decades of SQL injection vulnerabilities. You should _at the very least_ escape all user strings with [`mysql_real_escape_string`](https://dev.mysql.com/doc/refman/4.1/en/mysql-real-escape-string.html), and preferably avoid all bare string handling completely by using [prepared statements](https://dev.mysql.com/doc/refman/4.1/en/c-api-prepared-statements.html). When people say that C is an unsafe language, _this is exactly the kind of thing they're talking about_. Not ragging on you, everybody starts somewhere. Using environment vars to keep config data out of a public repository is one way to do it; I know that Laravel does that too. The process' environment can be read out with `cat /proc/&lt;pid&gt;/environ` though.
You allocated memory for the array of strings, but not for the strings themselves. You'd have to loop the `name` array to allocate memory for them or use the 'm' specifier of scanf (see the man page to be sure). Also, I'm wondering why you allocated with a size of `n+1` as arrays don't need to be NULL terminated if you have the size on a variable.
Arguments `col` and `3` can be retrieved from argv, potentially using atoi() to make the "3" into an integer. For the `&lt; text.txt` you have to open and read stdin, cutting the input on the '\n' to make strings and passing them to sscanf() maybe?
Wrong subreddit, try http://www.reddit.com/r/cplusplus or http://www.reddit.com/r/cpp_questions
A couple of quick notes : 1. GOTO - Only use it for error handling. You will encounter very few situations where you actually need a goto. Pretend that it does not exist in the language. 2. Your code incomplete, the start and exit labels are not there. 3. Your indentation is wonky. the if / else if block would be more readable as : if ( ... ) { ... } else if ( ... ) { ... } Seriously, never use GOTO unless you have a really good reason. 
Thanks a bunch for the timely response! I'm going to fix the program tomorrow morning, as it's already quite late where I live. As for the n+1.. I did some googling beforehand and saw someone do it. Good to know it isn't necessary though! Anyway, thanks again and I'll get back to you later:)
The `n+1` is commonly used when creating strings dynamically as you need `n` characters plus the NULL terminator. Edit: Another thing, what's math.h included for?
Like /u/uroboro said, it's a memory allocation issue for the strings themselves, I wrote up a quick example solution that makes it work. You only need to change a few things in the nameInput function: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; char **nameInput (char ** name, int i){ char temp[100]; printf("name: "); scanf("%s", &amp;temp); name[i] = (char *) malloc(100); strcpy(name[i], temp); return name; }
I would probably use mysql_real_escape_string() to sanitize the contents of the environment variables. I'd also make sure that getenv() didn't return NULL. teringilijer already mentioned: snprintf() instead of strncat(). 
Also I'm not sure if I'd print "Created database" before closing the mysql connection. Seems like celebrating a little early. Make sure you close the database first. :\^)
Also, can I do a prepared statement with a database name? Or is my only options `mysql_real_escape_string`?
Possibly. I don't know. Does mysql_connect() work with some parameters NULL? Either way -- I wouldn't pass invalid data to other functions. Particularly the database name. What if someone set the database name to: "foo ; UPDATE payroll SET salary='999999999999999999' where name='ruertar';"
No, it just returns NULL and carries on. Nothing wrong with that, you can test against NULL to check if an environment variable was set. The only time the NULL becomes a problem is when you try to dereference the variable. I didn't flag that as a problem in your program because you pass the pointers to `mysql_real_connect`, which should catch any NULLs for you. However, it would be much better style in production code to always check return codes.
Use `gcc -S` to generate assembly output and you can look for yourself. Another possibility is the entire function being optimized out. In fact that [does happen with g++ -O3](http://goo.gl/QJIV0H). (this site doesn't have C , it only has C++, and I don't know of an equivalent with C). 
It's [apparently not possible](https://dev.mysql.com/doc/refman/4.1/en/mysql-stmt-prepare.html) to put database names in prepared statements, which comes as a surprise to me also. Google knows more.
[Sure!](http://pastie.org/9643121)
Practically, you should use whichever style is most readable by a human, and only worry about micro-optimization if it's justified by performance measurements and requirements. The more open-ended answer is that the machine code for both of the above will probably be identical, and will actually look more like your first function -- first add, then multiply, then sine, then multiply, then subtract, then return.
Depends on the optimization level. With optimization disabled, the compiler should preserve the value of all your local variables.
Yes, this is a very basic optimization technique. All the good mainstream compilers do it. They will only avoid to do so if you explicit say you want no optimization whatsoever.
You're printing the addresses of your integers, not their value. Get rid of the dereference &amp; in the switches. In fact the compiler told you *exactly* this. Crack those textbooks open, son.
Compilers will generally optimize code very well for a simple optimization like this. In general, when I wonder if something is worth it, I write it so it is readable, test it, and if it is slow, then look at the assembly output to see if there are any issues. Here is an example using GCC with default optimizations and with -O2. As you can see, the -O2 assembly code is identical (gcc -S -O0 and gcc -S -O2). C source code. #include &lt;math.h&gt; double func(double a, double b, double c) { double x1 = a+b; double x2 = x1*c; return sin(x2)*a - b; } double func1(double a, double b, double c) { return sin((a+b) * c)*a -b; } void main (char *argc[]) { func(1.0,1.1,1.2); func1(1.0,1.1,1.2); } The assemebler output is slightly different with -O0 (omitting stack handling): faddl -40(%ebp) fstpl -16(%ebp) fldl -16(%ebp) fmull -48(%ebp) fstpl -24(%ebp) fldl -24(%ebp) fstpl (%esp) call _sin fmull -32(%ebp) fsubl -40(%ebp) leave ret faddl -24(%ebp) fmull -32(%ebp) fstpl (%esp) call _sin fmull -16(%ebp) fsubl -24(%ebp) leave ret But with -O2: fadd %st, %st(1) fstpl 16(%esp) fmull 64(%esp) fstpl (%esp) call _sin fldl 24(%esp) fmulp %st, %st(1) fldl 16(%esp) addl $44, %esp fsubrp %st, %st(1) ret fadd %st, %st(1) fstpl 16(%esp) fmull 64(%esp) fstpl (%esp) call _sin fldl 24(%esp) fmulp %st, %st(1) fldl 16(%esp) addl $44, %esp fsubrp %st, %st(1) ret 
But the real realloc does work like that when passed null
Essentially, a local variable declaration does not require the compiler to allocate any particular resource (stack storage or otherwise), so there's nothing to remove in the first place.
This works! Excellent. I hadn't encountered strcpy either, that will definitely come in handy. Thanks a bunch
Ah, alright. That's clear then. This string array function was actually meant to be part of a larger program, but I took the rest of the code out to make it clearer for you guys. Accidently left math.h in :). Thanks!
I don't know c Int thing is 0; Int total is 0; For other thing is 1; other thing less than or equal to 10; other thing plus plus; Thing plus plus; Total plus equal thing; Accualy is dolan
Hey man, I'd suggest /r/learnprogramming if you are learning how to program for the first time. I would consider C overkill for the question you have, but since your assignment is asking for it to be done explicitly in C: Start off with the #includes. Move onto the main function, print out your numbers, then return. Something like this: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main (int argc, char* argv[]) { int i, sum = 0; for (i = 1, i &lt;= 10, i++) { sum += i; } printf ("%d\n", sum); return EXIT_SUCCESS; } Obviously I have included more than is needed for this very simple operation, however I feel that including things like argc and argv are good habit -- even if not used. Of course compile with -Wall and -Werror flags on.
Hi there. I think the following code will help you with your program. Basically, integer i within the for-loop starts at value 1. For each iteration of the loop, sum get's incremented by i. (sum += i is equivalent to sum = sum+i). This keeps going until the for-loop condition is no longer met. In this case that's when i&lt;4 is no longer true. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv [] ){ int i, sum = 0; for(i = 1; i &lt; 4; i++){ sum +=i; } printf("sum: %d", sum); return 0; } 
In addition to what people are saying, the compiler decomposes either version into what amounts to temp vars. So, both will look more like: double func(double a, double b, double c) { double x1 = a + b; double x2 = x1*c; double temp1 = sin(x2); double temp2 = temp1 * a; double temp3 = temp2 - b; return temp3; } 
That works and it makes perfect sense now, I had the idea in my head what needed to be done but just couldn't get it all set up in my head, I found the easiest question most difficult hehe. Thanks a lot for your help, and I tried visiting r/learnprogramming but thats mainly C++, I am currently duing microchips programming that's why we are using C.
Thanks for the response I'd be lost without you guys hopefully I'll get through the horrific proces of learning this language and be able to give my own advice soon .
No worries! Happy Cakeday!
An optimizing compiler (that is, a compiler like gcc, clang, pcc or the Microsoft C compiler) does not really care about how many variables you use. A compiler typically converts your code into something called a *single statement assignment form* (SSA) before doing any optimizations or other things. You can thing of the SSA representation as a restricted variant of the C programming language where the only existing statements are `if`, `goto`, `return`, possibly `switch`, and statements of the form &lt;variable&gt; = &lt;variable&gt; &lt;operator&gt; &lt;variable&gt; and &lt;variable&gt; = &lt;function&gt;( &lt;variable&gt;, ...). Your function would look like this in SSA form: double func(double a, double b, double c) { double x1, x2, tmp1, tmp2, tmp3; x1 = a + b; x2 = x1 * c; tmp1 = sin(x2); tmp2 = tmp1 * a; tmp3 = tmp2 - b; return tmp3; } The compiler then performs some optimizations and passes the resulting code (still in SSA form) to a component called the *register allocator*, which is a complex algorithm that maps variables onto registers. Note that one variable can move between multiple registers during its life time and once a variable is no longer needed [such as the `x2` variable after the line `tmp1 = sin(x2)`], its register is free to be used for another variable. If there are more variables in use at the same time as there are registers, the register allocator will spill some variables on the stack and retrieve them when they are needed again. Because moving variables between registers and memory takes time, the allocator tries hard to do this only to rarely needed variables. Because there are no nested expressions (that is, expressions like `a * b + c`) anyway in SSA form, it doesn't actually matter how many variables you use. An i386 (32 bit mode) CPU has 6 to 7 registers (depending on the compiler and if it feels comfortable using `%rbp` as a general purpose register) for integer variables and 8 registers for floating point variables available as an 8-layer floating-point stack. An amd64 (64 bit mode) has 15 integer registers and 16 floating point registers. The mere fact that there are twice as many register in 64 bit mode than in 32 bit mode can make 64 bit programs faster by up to 10% without even using faster 64 bit computations.
Not an answer, but another question: would this not make things difficult for source-level debuggers? 
The 4th argument of your display date is unnecessary. julDate should be a local variable instead of being passed as an argument of the function. 
No loops [required](http://mathcentral.uregina.ca/QQ/database/QQ.02.06/jo1.html).
Pointers are crucial to dealing with the allocation (and subsequent use) of memory in amounts known only at runtime.
Sure, that's why you sometimes compile with -O0 when you want to debug more conveniently. When a variable was optimized away, gdb or whatever will just show you "i = &lt;optimized out&gt;". It's not generally that much of a problem though, IME.
A little, but if you're diving deep enough into the debugger to need to see how an expression like that is put together, any kind of optimization is going to get in the way. The compiler would optimize away the stores to `x1` and `x2`, and keep them in registers instead of writing them to the stack. If the compiler is very good about keeping debugging information, it will know that those variables "live" in registers, but not all compilers are good enough to do this. That, and the compiler can and will reorder instructions to improve efficiency as long as it doesn't change the correctness of the program. So if you go deep enough, you'll always need to use your eyes to look at the disassembled code and reverse-engineer how each step maps back to the original source code.
Mathematically correct, but probably not helpful for an intro programming assignment of which its purpose is to practice learning loops.
Among other reasons, it can be much more efficient to pass a pointer to a huge data structure than passing a copy of the data structure. Think about the stack in the two cases. Remembering that c doesn't truly provide a way to pass by reference, and that pointers are the best approximation, will clear up a lot of your confusion, I think.
To understand what follows, keep in mind that a pointer is (most of the time) smaller than a structure which can potentially require many bytes in memory. **1) As arguments to a function** When passing a value to an argument, it's usually better to pass a pointer to a structure rather than the structure itself which would imply copying it onto the stack (*). It takes both more time and more memory. **2) As return value** When returning from a function, the program will use RAX on x64 to store the return value. This register is 8 bytes long and won't be able to contain a large structure. A function can therefore allocate memory for a structure and return the pointer to the caller. This implies that the code which called the function needs to deallocate the memory (calling free() for example). Typically, a function like struct my_struct *make_my_struct(...); will be accompanied by a function like void free_my_struct(struct my_struct *); **3) Function pointers (a bit more advanced)** Sometimes you might want to pass a function as parameter, this can be done by passing a pointer to the address of memory where this function is defined instead. For example, typedef void free_function_t(void *); void free_list(struct list *lst, free_function_t *free_function) { /* ... */ (*free_function)(element); /* ... */ } **4) As arguments but really is a return value** Here is a common idiom. Imagine you want a function which returns an error code and a value at the same time, say a count as an int. You can make this function return an error code and take a pointer to a place in memory where to write the integer. int func(int *count) { /* ... */ *count = 42; /* ... */ return 0; } **5) Recursive data structures** Say you want to define a linked list of integers, you will write something like this. struct my_list { int element; struct my_list *next; } For the last element of the list, next will be equal to NULL. You can see that, without pointer, you would be able to define a structure like this one. Think about this: if a structure contains itself, what would be its size? That goes for mutually recursive data structures and, more generally, any structures containing a value of a dynamic size (like a string for instance.) (*) A quick side note: the following program prints &gt; a = 1 &gt; b = 2 and NOT &gt; a = 3 &gt; b = 4 #include &lt;stdio.h&gt; struct my_struct { int a; int b; }; void func(struct my_struct val) { val.a = 3; val.b = 4; } int main(int argc, char **argv) { struct my_struct val = {1, 2}; func(val); printf("a = %d\nb = %d\n", val.a, val.b); }
Ask a homework question when you obviously have only the vaguest of ideas what you're doing, get a solution that's both clever and completely unhelpful. That's my motto.
It's useful for a first insight into how the choice of algorithm can affect the runtime though.
I fixed it! Thank you all for your help! The issue was that in the scanf scanf("\n%d,%d,%d",&amp;month,&amp;day,&amp;year); I was asking for a comma between each int and not a / once I switched the commas for slashes it works fine now!
If you write your code to conform to a standard then you can have reasonably good expectations that your code will continue to work into the future, even if you use a different compiler, different hardware, later version of the same compiler, etc. GCC's default behaviour is called *gnu89* which isn't really a standard, it's just C89 plus a bunch of extensions that were popular when GCC was first written. Allowing for-loop declarations like your code uses is way too futuristic for GCC apparently. You could specify `-std=c99` or `-std=c11` in order to be able to use modern constructs like this. IDK why they don't default it to use the latest standard. Probably too much risk that they would cause some 1980s cargo cultists to have a heart attack. 
Answering the question in your post: If you gave scanf a copy of your variable, then you would not be able to see the changes made to the copy by scanf. As an analogy, imagine you write out a contract on carbon paper and you hand the copy to the other person. They go home and change some of the clauses in the contract, then throw their copy in the bin. This doesn't magically update your copy of the contract; you still have the original version and the changes have been lost. In fact you never knew about them. Instead you have to tell scanf where your variable can be found, so that it can make changes to the original copy of the variable. (and in fact, the only copy, if you're doing it right). 
Regarding (2), large structs can be returned by value in C. The compiler might use indirection "behind the scenes" but the programmer does not have to explicitly do so. 
A cast is typed as `(T)var` where var is the variable to be cast, and T is the type you want. So, `(int)ParseFloat()` would get you the integer version of ParseFloat.
 // might as well hardcode the constants. double mycosh(double x) { // TODOL range check: -pi &lt; x &lt; pi return 1.0 + (x*x)/2.0 + (x*x*x*x)/24.0 + (x*x*x*x*x*x)/720.0 + (x*x*x*x*x*x*x*x)/40320.0 + (x*x*x*x*x*x*x*x*x*x)/3628800.0 }
Thanks for your help. How can I print the converted value to the screen? Like this? a = (int)(123.456 +0,5) printf("%d",a)
 printf("%d", (int)(123.456 + 0.5)) will do.
Let's say you ask me where I live. It would be to much work for me to go get my house, bring it over and show you, so I give you my address instead. Good enough analogy to passing by value and by address (pointers are by address)
VLA = [variable-length arrays](https://en.wikipedia.org/wiki/Variable-length_array).
in principle, yes, you just have to format it correctly. int a; a = (int)(123.456 + 0.5); printf("%d",a); You can also drop the temporary variable alltogether and inline it printf("%d", (int)(123.456 + 0.5));
I am really glad that there is such a nice community. Btw, I want to get into C language. The book in my hand is "Problem Solving and Program Design in C". Do you think it is a good book?
Three versions of the ISO C standard have been published: one in 1990, one in 1999, and one in 2011. Prior to the publication of the ISO standard in 1990, it was first published under the ANSI committee in 1989, but the text was adopted nearly verbatim by the ISO committee, so "ANSI C", C89, and C90 are all synonyms. Compilers often implement non-standard language extensions. [Read the fine manual](https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html) for details. With gcc, the default if you don't specify anything is `-std=gnu90`, which is C90 plus GNU extensions. You can specify any of: -std=c90 -std=c99 -std=c11 -std=gnu90 -std=gnu99 -std=gnu11 I personally use `-std=c99`, disabling all GNU extensions. I use this in conjunction with maximum strictness (`gcc -Wall -Wextra -pedantic -std=c99 -g -O2 ...`). Be aware that on Linux some features/API are not exposed by in this strict mode, and you have to `#define` them yourself. Read `feature_test_macros(7)` for details. 
Well if you don't pass in any arguments, then argv and argc will not be used :) You will have one int and an array that won't be accessed. However I have always included it in my main function for completeness and habit :P you are right, it probably would have been better to pass in void to the main function for this exercise. However (OP if you are reading this) if you wanted to add functionality like ./a.out 10 20 to get the sum between two numbers, you would need the argv and argc variables :)
gnu11 will soon be the default, I believe
&gt; 1) 3+(172-9)/23-29/2 I calculated it on google and myself (26), but I could not get any results from C. Google says the result is -4.41304347826. When I calculate by hand I get negative 4 and 19/46 (which google tells me is the same as -4.41304347826. The result with C is going to be -4, assuming you type exactly `3+(172-9)/23-29/2` into the C program, because C will use integral arithmetic: 172-9 = 163 -&gt; 163/23 = 7 -&gt; 29/2 = 14 -&gt; 3+7-14 = -4 &gt; 2) How to convert float to integer and print it on the screen. There are some tutorials on the net but I could not be sure about to use +0.5 technique. Depends. If you don't really care about rounding then you can convert a float to int with: `(int)f`, and you can print it on the screen like: `printf("%i", (int)f)`. This will truncate the floating point value, so 3.99 will turn into the int 3, for example.
This should be pinned to the sidebar of this subreddit.
well played. :D
You can't compare the contents of two strings using ==, you need to use the strcmp function. 
You can't compare strings with the `==`&amp;nbsp;operator in&amp;nbsp;C. Use the `strcmp` function from `&lt;string.h&gt;`.
You can't do string comparison using `==`. Check out `strcmp()`. http://www.cplusplus.com/reference/cstring/strcmp/
Thank you for your help. Is the error that you pointed out the missing # in the first line? Because that is indeed my mistake when I copied the code from SSH. The purpose of this exercise is to show a modularised version of a simple swap program. 
No, problem is that in C, function arguments are passed by value, which means that when you write: swap(var1, var2); you actually do something like this: swap(copy_of_var1_value, copy_of_var2_value); so when you swap them in definition of swap function, it will swap copy of these values, not your real var1 and var2. To be more specific, var1 and var2 have some addresses where they are placed at - for example 0x400 and 0x404. When you call swap() function, you will **not** send these addresses. As I said, you will send copy of these variables, so you will operate on addresses of these copies - for example 0x600 and 0x604. You need to use pointers to tell to the function: "Hey, do not create copy of it, use variables placed at 0x400 and 0x404 addresses". For me it looks like: 1. You incorrectly copied this program 2. Your teacher incorrectly wrote it 3. You need to correct this program as homework 
I'm just going to say what /u/__next__ said but in different words. Objects in C are passed around *by value*. This means that objects are copied between functions. When you call `swap(var1, var2)`, you are copying `var1` and `var2` into the `swap` function. You are later printing out the values of `var1` and `var2`, expecting them to have swapped over, but that won't have happened. The `swap` function gets copies of those objects, so only modifies those copies. The original `var1` and `var2` objects are left unaffected. What you need here is to pass *by reference*. This means you have to somehow communicate to the `swap` function that you want it to modify your `var1` and `var2` objects themselves. How can we do that? In C, we do that by passing the *addresses* of those objects instead. If we copy the address of those objects into `swap` by making it `void swap(int* para1, int* para2)` (it takes pointers instead), the addresses inside the function still point at the `var1` and `var2` objects. Now you can modify those objects through the pointers.
expression?a:b; if the expression before ? is true, a is returned else b. In your case it is 1 before ?, which is true, so whatever "(type*) g_slice_copy (sizeof (type), (mem))" does is returned.
This comment is probably relevant: /* we go through extra hoops to ensure type safety */ My guess is they're using the second half (false path) of the condition to trigger a compiler error if the type of `mem` isn't a pointer to `type`. After successfully parsing and type checking the code, the compiler is free to optimize away the conditional and keep only the desired part (true path).
To give you a bit more in-depth form of answer (since others have talked about strcmp), and because your original problem shows a lack of understanding of data in C. So, why doesn't your original solution work? First, what IS a string constant? When you throw something like "yes" in your statement, what is being produced? Your program contains a list of string literals when you compile it. "yes" will be thrown in that list, and any reference to "yes" made in your program will point to that same literal (re-used). You can even use a program like "strings" in unix to dump all the string literals in your final compiled program. It's fun! So, what does that mean? Any time you use "yes" in a compare statement, the only piece of data being generated is a POINTER TO A CONSTANT. So you are comparing the *address* of **answer** to the *address* of **"yes"**, which will never be the same. Next, what does *char affirmative[] = "yes";* do? You're creating a new character array ON YOUR STACK, at which point the program must manually copy the default value over that stack space. This is probably best accomplished by simply using the pointer to a constant (putting "yes" inline) in your strcmp. And finally, not to overwhelm you, but basic security is something you must *always* be aware of in C, even if it's just some crap program you're throwing together. The time you save from debugging an obscure overflow issue in the future is worth the effort. So: **result** is 30 characters. What happens if you type more than 30 characters in your input prompt? (Google buffer overflow exploits, and how you would overflow protect scanf) I hope this helps!
&gt; ((void) ((type*) 0 == (mem)), (type*) 0) if so the how come they took the pain and wrote the other (else return b) part? this is useless is it? ((void) ((type*) 0 == (mem)), (type*) 0)
I think it's worth noting that their test in the false path, `((type*) 0 == (mem))`, only produces a warning when used with default gcc settings. That said, GLib may very well compile with that warning as an error instead.
If the point was to force a type check everywhere g_slice_dup() is called, then splitting up the macro makes no sense.
I don't want to do your work, but here are some hints: -Your printf(...) isn't in a function. It has to be inside a function to be executed. The way you put it your code doesn't even compile. -The function MyCoshFunction(x) returns the result of your calculation and I assume you want to print the result to the screen. Try saving the result in a variable, then print this variable using printf(...). 
The macro doesn't _store_ anything. The preprocessor replaces every instance of `FLOAT` with 0.1. The reason for the difference is the way literals are treated. C will try to make integral literals of type `int` (unless they're too large) and will try to make decimal literals of type `double`. So `.1` is treated as a double when it is compared and this can lead to very confusing behavior which goes along with your rule that you shouldn't floats for equality. That said, if you change your macro to be `#define FLOAT 0.1f` then they should compare as equal. The `f` suffix tells the compiler to treat `.1` as a `float` rather than as a `double`. 
This is called "type promotion" and is well-defined. Type promotion rules dictate that when comparing a `float` to a `double`, the `float` is first upcoverted to a `double`. Because 0.1 famously has no exact floating-point representation, the expansion is inexact and the comparison fails. If you try a number that *does* have an exact representation in floating point, such as 0.25 (2^(-2)), then the comparison should succeed regardless of the difference in type. The moral: floating-point constants are not created equal!
Impressive and useful. I have to remember this.
Bring printf() back to main() and call it after MyCoshFunction(). It should look like this: double result = MyCoshFunction(x); // Save result in a temporary variable. printf("%f\n", result); // Print it as a float/double. return 0; Make sure to use "%f" in printf(). "%d" is for printing integers. If you want to print a variable of type double, use "%f".
malloc simply takes in one argument - the number of bytes to allocate. For consistency, I generally use the form type *buffer = (type *)malloc(sizeof(type) * count); Remember that C strings need one extra character for the null terminator, so you might want to allocate 52 bytes. Also, for not hitting a segfault, you need to understand that you have an entire page of memory allocated to you, and only when you exceed the boundaries of that page do you get a segfault.
I meant *variably modified type* although I was lazy in writing "VLA" to mean that. The variably modified type system is actually very useful even if you don't declare any VLAs (i.e. stack-based arrays with runtime size). For example: scanf("%d %d", &amp;m, &amp;n); int (*dynarray)[n] = calloc(m, sizeof *dynarray); // voila, can use array syntax with dimensions input at runtime printf("%d", dynarray[3][5]); 
Writing beyond array boundaries is undefined behavior, something might happen, maybe not. Also you don't have to cast the return value of malloc, that's a C++ thing, char* str = malloc(10); is enough.
Yes, it is in ANSI C89. Structs can be passed by value as function arguments, returned by value, and assigned. 
Thanks so then the appropriate way to allocate memory for the string I just wrote would be Char* str = malloc(22); since the string is 21 characters and then I need 1 extra byte for the null terminator? And I guess this is unnecessary but would writing it as Char* str =malloc(sizeof(char)*22) be the same thing as what I wrote above. 
In C++ malloc should not be used anyway, so "1970s thing" is a better description for casting malloc. 
that's stylistic, many people like the explicit cast. particularly when the assignment is happening away from the declaration.
I'm just trying to learn. I wanted to test to see if 40 would work because I'm still a little confused about how malloc works.
Yes, in 99% of the cases char is 1 byte and both would have the same effect.
&gt; Also you don't have to cast the return value of malloc, that's a C++ thing, char* str = malloc(10); is enough. I've seen enough 80-post debate threads on comp.lang.c to know that this statement is wrong. The correct statement to make is to never bother trying to correct anyone on whether the return value of malloc should be cast, and simply don't mention it. Both are valid C, and both are stylistic choices, and there's really no point in pointing this out, except to point out that you're wasting your time in pointing this out. I do, however, cast it in my own code, because my compiler produces warnings about it if I don't.
I'm not quite sure if there is one project that's going to cover all of those topics and also meet your requirement of not being a Linux kernel. You may be able to find specific projects for each of them, but I'm not sure if that's what you want. I mean honestly, all the things you listed are in several open source operating systems. Can you explain further why you don't want to use an OS or kernel for your needs?
malloc() just arranges to give you a chunk of memory that you're allowed to use as you like. Those bounds are from (returned pointer) to (returned pointer + size - 1) inclusive; you must not access memory outside that range. It might seem to work, but you are overwriting other stuff that will definitely cause problems.
You should treat malloc as a black box and trust that it's doing exactly what you tell it to do. If you tell it you want 51 characters, it's going to give you a pointer to a spot in memory with enough room for 51 characters. Full stop. How it actually works is only really relevant when you've been programming in C for a fairly long time and you're writing your own malloc implementation. But because you seem to need to know so badly, here's what it's doing: `malloc` takes the number you give it - a count of bytes (which is *not* the same thing as the number of `char`, even if the numbers are the same) - rounds that number *up* to the nearest natural boundary, and selects a block of memory that it'll fit in. Now, the concept of a natural boundary isn't obvious, because it's not part of the C standard. It depends on the *platform* that implementation of `malloc` was written for. On most platforms, it's either the natural width of the memory bus (which may be as small as 4 bytes), or the width of some fundamental unit in your CPU, like a cache line. (That being the width of the fundamental unit of memory in the CPU's L1 data cache, which is the amount of memory that it will read or write at any given time to L2 cache or main memory. On most Intel or AMD CPUs, that happens to be 64 bytes. When you write a single byte to memory, the CPU writes that to the cache line, then *flushes* that cache line back to main memory as one 64-byte block. Understanding how and why this works is important when you're doing parallelism.) Or, it may actually be the smallest unit of memory that the CPU's MMU can allocate as a block. (On Intel and AMD systems, that's either 4KiB or 1MiB or 4MiB, depending on how your operating system works.) Now realize at this point that just because `malloc` has *selected* a natural boundary doesn't mean it will actually *give* you that whole block. It may actually only give you the block you ask for. Typically, `malloc` holds a *list* of memory blocks that it can assign to your program immediately, and when it's running out, it asks your operating system for a new bunch of blocks for it to choose from. How `malloc` chooses these blocks can vary, and depending on what kind of strategy it wants to optimize for, it may choose blocks in ways that you will not expect. For example, here's how a space-optimized `malloc` might choose blocks: You ask `malloc` for a block of 51 bytes. It looks in its list of unallocated blocks for one large enough. It finds one that's 128 bytes long, but 51 bytes of it are already allocated by another call to `malloc`. No problem, 128-51=77, so there's enough space. So, it marks another 51 bytes as allocated, and 77-51=26 bytes as free. It so happens that the previous allocation was in the middle of the block, so it puts yours right behind it so that the block it gave you stops right where the other begins. Now, if you write to position 52 in the block you were given, it'll "work," but now the first byte of the other allocation has something that doesn't belong there! Another `malloc` implementation might choose to put your 51-byte block on a 64-byte boundary, so that the pointer value ends in 0x00, and you can write to the whole 64-byte block without incident. You shouldn't, because your code doesn't actually *own* that memory, and when your code is put on a platform that behaves like the previous example, it'll break in another piece of code. The reason you don't get a segfault happens to be because your CPU's MMU can't assign blocks as small as 51 bytes. It can only assign blocks as small at 4KiB, so unless that 51-byte stretch happens to be right at the end of the block, it won't be able to detect the problem when you write to the 52nd byte. Always remember: Just because your code doesn't blow up in your face *at this moment* doesn't mean it's actually working correctly. It *will* blow up in your face, and when it does, it'll be when someone's life depends on it. So make your code *correct* and always assume that writing past the end of an array will destroy all life in a 50-mile radius.
I haven't looked at the code base, but if you want to deal with drivers, maybe AVRDUDE would be worth checking out. 
&gt; Please skip Linux kernel, redis, git or any large projects basically everyone heard of. I.e. all of the best answers. 
I didn't mean one project should cover all the topics, if a project covers only one topic(it basically impossible), you can recommend it. Such as tig, it is git, but in textual user interface, the whole difference is that tig uses curses library.
Not the big ones, smaller would be better, it is unnecessary that one covers all the topics. 
Trial and error isn't a good way to learn C. This is because the language does not prevent you from disobeying the rules, in many cases. The compiler will assume you follow the rules and generate an executable accordingly, often without regard to what happens if you didn't. It may appear to work now and then break when you have to give a presentation. 
True, you don't have to cast it, but you can cast it if you want to.
I'd recommend Angband. The code is very well written. 
Is this the first fully compliant implementation of C11? (in conjunction with some compiler, presumably)
Thanks! 
Browse through /r/cprog (subreddit for C content; not basic questions) and search for [flair:code](https://www.reddit.com/r/cprog/search?q=flair%3Acode&amp;restrict_sr=on) or [flair:tinycode](https://www.reddit.com/r/cprog/search?q=flair%3Atinycode&amp;restrict_sr=on). Add additional flairs to your search depending on your interest, [like so](https://www.reddit.com/r/Cprog/search?q=flair%3Acode+flair%3Asystems&amp;restrict_sr=on). Submit more links as you find them!
thank you @machrider for the explanation you make it clear now. and just for people did not get it: At Run-time: only the first part will be executed the second part will never be executed. it may also be optimized and deleted so yes it is useless at run time. At Compile-time: here where the second part is useful. when the compiler go over it it will check if the (mem) is the same type as (type*) if it is not it will through a warning. since this is an API macro, this trick is very useful for the programmer that uses this library it will basically tell him about this common mistake if he make it
I've found the openbsd codebase to be particularly well-written and easy to digest. Is it small enough? You seem to have largely made up your mind already...
It's a perfectly fine way to learn C, because it's fundamentally how we learn anything. What one should not do, as, again, is the case with everything, is blindly trust ones senses &amp; intuition. There are more ways to fail than a segfault.
&gt; It's a perfectly fine way to learn C, because it's fundamentally how we learn anything. It really isn't a perfectly fine way. We don't "fundamentally" learn by trial and error either. Trial and error is one way to learn, but only in situations where feedback from the trials can be incorporated into the next round of learning. That doesn't happen with a lot of important things in C because undefined behaviour usually doesn't give the feedback that you have done something wrong. A much better way is to learn from an authoritative source, e.g. a good teacher, or in the case of C, a good book. 
Authorities in their various guises just help you to obtain knowledge. They are not a source of learning. I covered the apparent lack of feedback - don't trust your senses and failure is more than a segfault. In this case, the failure was the lack of an expected segfault.
Personally I find the GNU source code to be very hard to read and overly complicated, not only because of its idiosyncratic indentation style.
If you want to read some well commented code, try to read the sources Donald Knuth published on [his website](http://www-cs-faculty.stanford.edu/~uno/programs.html). He uses a tool called `CWEB` to make typeset documentation from C-source and TeX though, you have to preprocess the source with `cweave` and `ctangle`to create the C source file.
[How about the code for Doom?](https://github.com/id-Software/DOOM)
Yup, this is unfortunate. I love the GNU userland, especially when I'm on a BSD system, being reminded of how essential GNU's extra features are. But the source code for most GNU tools is anything but elegant. 
git isn't exactly large as it is a collection of many small(ish) tools.
I think step #1 of getting help is formatting the problem statement better. Or perhaps instead of just saying "Here's my homework problem" give a specific aspect of it that you need help with.
Rather than writing buffer = malloc(sizeof(type) * count); I prefer to write buffer = malloc(sizeof(*buffer) * count); This way I'm not repeating the variable's type; it only appears once, in the declaration. If you change it (maybe unlikely for a primitive type, but it could be a struct or typedef that you'll change the name or type of), this is now 1 less place where you have to find and correctly replace the type of the variable.
Write the code, compile it, and run it to see what happens. Then change the inputs and run it again until you have a good intuitive understanding of what behaviour to expect. That's the only real way to learn and remember.
yup the two best ways to learn code are to write it and to read it. With this type of question it's much more beneficial to experiment.
yeah I'm going to go and do that now, cheers guys!
install manpages-dev or the version of the package that your distributiin uses, then: man rint 
Take a look at this: https://www.reddit.com/r/learnprogramming/wiki/qtsgfb#wiki_are_you_performing_integer_division_instead_of_floating-point_division.3F
Ah, does "int r" specify r to basically be an integer? That sounds like a really stupid question now that I've said it...
Yup! And don't worry, mistakes like this are just one way to learn new things.
For more info: [the wikipedia article about the ternary operator](https://en.wikipedia.org/wiki/%3F:) 
not really true. you can use automatic variables with size only known at runtime
 #include &lt;stdio.h&gt; int main() { printf("yes/no? "); char c = getchar(); if(c == 'y' || c == 'Y') printf("\nOkay good!\n"); else printf("\nThat's too bad!\n"); return 0; } If you want to get more input, you will probably want to consume all input until the next `\n` or `EOF` with this while((c = getchar()) != EOF &amp;&amp; c != '\n');
Some of the prettiest C going. https://github.com/fogleman/Craft
Well, if you ignore the qt stuff we hacked on at the last minute in c++, then [SocketChat](https://bitbucket.org/millere/socketchat) could be worth looking through. It's a school project for a crypto class that demonstrates string manipulation, networking, math, pointers, and all sorts of fun things. Don't use any of the crypto from it! We implemented crypto from scratch _because it was for a class_. There are guaranteed exploits against this code, and I can't even tell you what they are. But for playing with to learn, it's a nice small codebase. 
I think the code in there is much too complicated for providing the portability layer they need. It looks like each platform was spliced in with the smallest possible patch. A cleaner approach would be to do what the Go project did and isolate the code for each group of platforms into its own file without a maze of ifdefs. A little more effort for coding but it's immediately obvious what code is actually compiled.
Can you put here compilable code?
// // main.c // XML Parser // // Created by Tritonia on 2014-10-10. // Copyright (c) 2014 Tritonia. All rights reserved. // #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, const char * argv[]) { FILE *fp; fp = fopen( argv[1], "r"); if (fp == 0) { printf("Could not open file\n"); } else { char x; int opening = 0; int closing = 1; while ((x = fgetc(fp)) != EOF) { if (x == 60) { opening++; } if (x == 47) { opening--; closing++; } } if (opening == closing) { char tags[opening][100]; char *data[opening]; fp = fopen( argv[1], "r"); char tagName[100]; int count = 0; int tagCount = 0; //clear first line char buffer[100]; fgets(buffer, 100, fp); while ((x = fgetc(fp)) != EOF) { if (x == 60) { tagCount = 0; while ((x = fgetc(fp)) != 62) { tagName[tagCount] = x; tagCount++; } tagName[tagCount] = '\0'; strcpy(tags[count], "hi"); memset(&amp;tagName[0], 0, sizeof(tagName)); count++; } } for (int i = 0; i &lt; opening; i++) { printf("%s",tags[i]); } }//end of parsing } return 0; } 
Posted
your opening/closing count logic is wrong. Initialize both to zero. I would also use an int for x, since that's what fgetc returns. Furthermore it's a lot easier to read if you use characters instead of ascii codes. if (x == '&lt;') Like so. What really got you into this mess is that you silently fail when there's an open close/mismatch. Print an error message.
Initialize closing to one because I need to count the &lt;XML.....&gt; as it doesn't have a closing bracket. Will change the ascii. Thanks for the tips
Uhh change what you suggested and that fixed it lol. No idea how that has so do anything with the strcpy, but it worked. Thanks!!
Please post the file that you're trying to parse then. I didn't realize that you were trying to parse an XML file with a schema.
No problem :) In the future, try to always post a compilable minimal example that reproduces your issue (like you did eventually), rather than some out-of-context and incomplete code snippet of what you *think* is wrong. Also include the input data, so that other people can reproduce your issue. 90% of the time just going through that procedure will make you realize what you did wrong in the first place.
I hate to say this, but this is for a class assignment. That's why I didn't post the code I would like to solve this on my own, but needed help with logic and syntax. I just wrote a basic XML, no attribute to test with. My prof said it doesn't have to be some complex parser. Heres the XML: &lt;?xml version="1.0"?&gt; &lt;catalog&gt; &lt;book&gt; &lt;author&gt;Gambardella, Matthew&lt;/author&gt; &lt;title&gt;XML Developer's Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt; &lt;/book&gt; &lt;book&gt; &lt;author&gt;Ralls, Kim&lt;/author&gt; &lt;title&gt;Midnight Rain&lt;/title&gt; &lt;genre&gt;Fantasy&lt;/genre&gt; &lt;price&gt;5.95&lt;/price&gt; &lt;publish_date&gt;2000-12-16&lt;/publish_date&gt; &lt;description&gt;A former architect battles corporate zombies, an evil sorceress, and her own childhood to become queen of the world.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt;
Oh, I see. Well that XML is hierarchical, so your current data model won't cut it. Good luck with your assignment!
I'm compiling with GCC in CodeBlocks with warnings on. There is no warning when compiling. My code is really short, can you check them out and tell me what is wrong with it ?
When working on production code (i.e. not school code), please use str**n**cpy() instead of `strcpy()` and pay attention to off-by-one errors (arrays indexed at 0 and `'\0'` at end). Security folks would be much obliged. Also need a constraint for tagCount in while conditional ( `tagCount &lt;= 98 /* 100 - 0 index - NULL at end*/` ): if (x == '&lt;') { tagCount = 0; while ( ( x = fgetc(fp) ) != 62 &amp;&amp; tagCount &lt;= 98 ) // 100 - 0 index - NULL terminated string { tagName[tagCount] = x; tagCount++; } if (tagCount == 98) { printf("Error! tagName buffer too small.\n"); } tagName[tagCount] = '\0'; // now we know tagCount can take the extra '\0' // also good job on using '\0' instead of NULL or 0; makes the // fact that you are operating on a string apparent. strncpy(tags[count], "hi", 99 - count); // it's 99 here since we are dealing with character count, not // array indexes, also "count" is never used // except "`int count = 0;`". do you want // to use "opening" here? memset(&amp;tagName[0], 0, sizeof(tagName)); // way to initialize your data :D count++; }
When I changed "name" variable from char to int the problem solved, fault is gone. I don't know why but I will try something, thanks :)
ccan http://ccodearchive.net/ it's sort of a collection of useful bits of code that are too small to be a library themselves, though it also includes some libraries... 
The problem with reading code is you also need to have an understanding of the design and architecture of said software. For example I added some minor patches to [sniproxy](https://github.com/dlundquist/sniproxy) and in doing so I had to read the codebase since it only contained very sparse documentation. I think the project is well written, contains tests, but the configuration parser is awkward to read and understand. Instead I would suggest you start with looking at some projects that may interest you in the [The Archtiecture of Open Source Applications](http://aosabook.org/en/index.html) and then decide if you want look delve into a specific project.
First off, **never** believe that something is too hard. Secondly, I'm sick and medicated and will most likely ramble. --- I hate to break it to you, but you've got some bugs: 1. main.c:14 `strcpy(new_cat-&gt;name, cat_name);` -- `new_cat-&gt;name` is not initialized, you need to allocate enough memory to copy cat_name's contents to the new location. 2. main.c:18 `end_cat-&gt;next = new_cat;` -- `end_cat` is `NULL`, as it is passed in the second parameter. --- When something like this happens in the future: * **Use a debugger** to find your bugs (where the program is crashing). * When you find a bug, **question everything** to get to the source of the bug. --- Never used a debugger? Learn! They're great! I've compiled your code with [clang](http://clang.llvm.org/). Replace "clang" with "gcc" if that's your preferred compiler (they're pretty much the same from the outside): mac-the-knife:~/tmp sufian$ clang -g -Wall -o main main.c * **`-g`** means "generate debugging information" * **`-Wall`** means "tell me everything that's wrong with my code" Now that we've compiled the code, we can run it in a debugger. I'm using [lldb](http://lldb.llvm.org/). Replace "lldb" with "gdb" if gcc is your preferred compiler (they're pretty much the same from the outside): mac-the-knife:~/tmp sufian$ lldb ./main (lldb) target create "./main" Current executable set to './main' (x86_64). (lldb) We've started the debugger pointing at the `main` executable and are prompted for action. To run the executable, we use the **run** command: (lldb) run Process 9879 launched: './main' (x86_64) Process 9879 stopped * thread #1: tid = 0x6b10, 0x00007fff88931ba4 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 164, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0) frame #0: 0x00007fff88931ba4 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 164 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 164: -&gt; 0x7fff88931ba4: movq %rcx, (%rdi) 0x7fff88931ba7: movq %r8, (%rdi,%rdx) 0x7fff88931bab: popq %rbp 0x7fff88931bac: retq Boom. It blew up. It may look scary, but it's really not. If we take the time to read this text, we can see `reason = EXC_BAD_ACCESS`. If you were to guess what `EXC_BAD_ACCESS` means, you'd probably be right: the program tried to access something bad. Our debugger stopped right when it hit this `EXC_BAD_ACCESS`, but we can still inspect the state of the program. To do this, we use the **bt** command, which is short for **b**ack**t**race, which prints out the stack frames where the error occurred: (lldb) bt * thread #1: tid = 0x6b10, 0x00007fff88931ba4 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 164, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0) * frame #0: 0x00007fff88931ba4 libsystem_platform.dylib`_platform_memmove$VARIANT$Unknown + 164 frame #1: 0x00007fff8f36e7e3 libsystem_c.dylib`stpcpy + 42 frame #2: 0x00007fff8f3dca44 libsystem_c.dylib`__strcpy_chk + 24 frame #3: 0x0000000100000f14 main`createCategory(cat_name=0x0000000100000f84, head_cat=0x0000000000000000, end_cat=0x0000000000000000) + 68 at main.c:14 frame #4: 0x0000000100000ec3 main`main + 51 at main.c:7 frame #5: 0x00007fff92eb85fd libdyld.dylib`start + 1 Wow, that's a lot of output. It may look scary, but it's really not. If we take the time to read this text, we can see the stack frames: * frame #0: `libsystem_platform.dylib`\``_platform_memmove$VARIANT$Unknown + 164` * frame #1: `libsystem_c.dylib`\``stpcpy + 42` * frame #2: `libsystem_c.dylib`\``__strcpy_chk + 24` * frame #3: `main`\``createCategory(...) at main.c:14` * frame #4: `main`\``main... at main.c:7` The first thing that looks like it relates to your code is `main.c:14`, where we called `strcpy(new_cat-&gt;name, cat_name);` --- Sweet, we found your first bug! What the heck caused it? Question everything: * Why is there a call to `strcpy(new_cat-&gt;name, cat_name);`? * Probably because you want to copy the string into the category. * What does `strcpy(dest, source)` [actually do](http://linux.die.net/man/3/strcpy)? * It copies the characters (up to and including the '\0' terminating character) at the string `source` to the buffer `dest` * `dest` needs to point to a large enough buffer to hold the data at `source` * What is `dest`? * `new_cat-&gt;name` * What is `new_cat-&gt;name`? * It's a `char *` pointer that lives in the `new_cat` category structure. * What does `new_cat-&gt;name` point to? * That's a good question! It never gets initialized to anything, so it contains whatever `malloc()` decides it should contain. * What does `malloc()` decide it should contain? * [It doesn't](http://linux.die.net/man/3/malloc). * So we used something that isn't initialized and got a bad access error? * Yeah, that makes sense, right? * So what should `new_cat-&gt;name` point to? * It should point to data that's large enough to contain the `cat_name` * How do I do that? * `new_cat-&gt;name = malloc(strlen(cat_name) + 1)` * Woah, how'd you know that? * Experience * http://linux.die.net/man/3/strlen --- Rinse and repeat and you'll find the second bug (it's actually much easier than the first). \*Edited for formatting and stuff
&gt; main.c:14 strcpy(new_cat-&gt;name, cat_name); -- new_cat-&gt;name is not initialized, you need to allocate enough memory to copy cat_name's contents to the new location. I take it simply doing new_cat-&gt;name = cat_name; would be incorrect for some reason, right? Is it because cat_name is allocated on the calling function's stack and will be freed before new_cat-&gt;name is no longer used?
Thanks man, you're just... GREAT.
I think you are correct. There's another issue: if you create two items with the same name (using the same char pointer) modifying one string would modify the other, so the items in the list would not be independent.
[Here you go.](http://www.slideshare.net/olvemaudal/deep-c)
Thanks a lot for being experienced and still helping freshers, instead of just telling them to get their basics right. Also +1 for the guiding towards the right approach of debugging. 
Please post your current code.
Man I was cranky when I posted that shit. My issue was passing an array into the function when it should have just been "char".
The array was my issue. I was intending to pass a regular char value through though. It was for project, and I had pushed it off to go to a funeral and ended up staying up all night and being a little bitch on here. I'm sorry guys lol
Please indent your code with four spaces so it appears in monospaced font.
fucken error handling in safe:ish code... status create_my_thing(my_struct** out_s) { status ret = UNKNOWN; status s = do_whatever(); if(s != SUCCESS){ ret = WHATEVER_FAILED; goto cleanup; } my_struct* s = calloc(1, sizeof(my_struct)); if(!s){ ret = ALLOC_FAILED; goto cleanup; } s = create_something(&amp;s-&gt;something); if(s != SUCCESS){ ret = s; goto cleanup; } *out_s = s; return SUCCESS; cleanup: if(s &amp;&amp; s-&gt;something) destroy_something(s-&gt;something); if(s) free(s); return ret; } So tedious. The lack of language standardized exceptions is really what I miss most when writing C.
You forgot FastCGI, which is probably the best option to write server side code in C.
Wow, I never knew there was such a debate over all this. (knew about the strlcpy thing, but not a lot of context). That's what I get for cutting my teeth on C++ programmings hard. http://randomascii.wordpress.com/2013/04/03/stop-using-strncpy-already/ https://www.securecoding.cert.org/confluence/display/seccode/API02-C.+Functions+that+read+or+write+to+or+from+an+array+should+take+an+argument+to+specify+the+source+or+target+size
Very interesting read. But if I were interviewing someone, I'd be more concerned that they know the essentials of C and that they know how to design and structure a program. Knowing these kinds of intimate details of a programming language doesn't necessarily mean someone is good at big-picture stuff.
In one interview I did, they had me implement `strstr()` on a whiteboard. I was given a copy of K&amp;R in case I needed it. Once I was done, we discussed its operation, worst-case running time, etc. They also asked questions about why I'd structured it the way I did, and how I might rewrite it (e.g., use structured programming techniques to avoid multiple return statements).
This is glorious, do you have anymore? Some recommended readings? EDIT: didn't realize it was 450 slides long, good stuff in here
If this is pure C, it won't work. Arrays in C have to be fixed length. IE: char tags[opening][100]; This is incorrect and will not do what you want. You can do it using malloc() and free(), but you'll need to allocate space for each entry, or do some trickery. A pointer to pointer is not the same as a fixed 2D array, so it'll take some work. char **tags = malloc( opening * sizeof( char *)); for( ii=0;ii&lt;opening;ii++) { tags[ii] = malloc( 100 ); } Now, some people say that you should check the return value of malloc(), however, on most modern OS's, malloc will never return NULL, even if there is not sufficient memory available. Instead, it will crash once you try to use the allocated memory. You could also malloc the memory as one large block, then assign the pointers to addresses within that block. That is left as an exercise for the reader. 
As a fellow "huge fan of C", I recommend reading **21st Century C** from O'Reilly Media. It won't all apply, depending on how you feel about (or are able to use) C11, etc. But there are good opinions in it, well justified. Nothing ground-breaking, but it's rare to see a new book written on plain-old-C. Skim the [table of contents](http://shop.oreilly.com/product/0636920025108.do) and see if the topics pique your interest.
I'm interested in that sort of thing, so I'll be sure to read up on it. Just off the top of my head though, it means that specific variable isn't kept in a register later, right? I'm still new so pardon me if I'm wrong.
From what I understand, every time the variable is used the processor updates the value before it's used. This is especially important if you have a variable or constant which defines a hardware input address, the value of the data at this point can change values without prior notice. Edit: this seems to better describe what i'm talking about: http://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c
I own this book, but haven't finished reading it. I can't quite put my finger on it, but something about the way he writes puts me off.
I think he could say a lot of what he wants to in less words. I guess I'm just excited when I see new/book attention given to a Perfectly Good Old Language. Even when I don't agree with all of it. I enjoyed being able to skip around a bit, and not read it straight through. Maybe that reduced the off-putting. :-)
he just got a 2nd edition out
I see, and what mysterious and exotic compiler collection might this be?
Ah, thanks for the clarification! Great link, too!
I should add my own experience. I've been asked to write a function to convert an int to a string, and a string to an int. I've been asked to implement a function to search a directory tree for files with a specific word, and talk about choices... would I cache the data for example?
Take a look at [Learn C The Hard Way](http://c.learncodethehardway.org/book/), it's an incomplete book, but has great content nevertheless.
Maybe a spell checker.
More specifically, the compiler is obligated to read the value freshly from memory each time it's used, but also write it to memory each time it's written (no putting it in a register and saying "it's written"). Memory-mapped registers on hardware require this, as you mentioned, but it has other uses as well. When communicating across multiple threads that may be running on different cores, some variables need to be volatile to ensure they get written out correctly.
C is good to learn as a beginner, although it is an unforgiving language. If you can write C, you will be able to learn the vast majority of other programming languages in common use today with a very small learning curve. Any CS department worth anything is going to have you write in low level languages at some point, especially C and assembly. To get started, you're going to need a good C compiler - I recommend GCC. [The C Programming Language](http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628/ref=sr_1_1?ie=UTF8&amp;qid=1413563014&amp;sr=8-1&amp;keywords=the+c+programming+language) is also a priceless resource for anybody interested in learning C. Finally, although this is optional, you should learn to use a "serious" text editor, such as emacs or vim.
Start with getting the XCode developer tools and the command-line package. C is an important language in Computer Science because it is pretty much *the language* for heavy duty Operating Systems, the type you see in Desktop OSes, Network OSes (the type that runs on a networking router/switch), Server OSes (Linux, BSD, Windows, etc.). I think C is a hard language to learn, but it is a great first *serious* language while also simultaneously learning an easier language like shell or Python to make yourself more efficient/productive. However fundamental to CS is about the *theory of comptuation* not really languages. Languages are just a way to *express* computation. Some languages are better than others for expressing computation to solve certain problems. I would highly encourage also looking into understanding computation from first principles, a great introduction is [Theory of Computation](http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X) (2nd edition is really really cheap used). The only background knowledge you need to know is highschool mathematics.
1. Okay so from what I understand the main things covered in computer science are programming, and understanding the theory behind the computation in a program. 2. I looked at emacs and vim...are they just like text editors with alot of functionality for progamming? 3. so yeah one of the big intimidation factors is that I would have to learn 1000 different languages to get a job or build something cool like a site or a game. But from what you guys are saying, if I learn C, I would just need to learn slightly different syntax to be good at the other languages? 4. also I appreciate the links to the books! definitely something to look into. 5. Thanks so much for the feedback, I am new to Reddit, and it's really cool to receive help from people I will probably never meet IRL!
Are you a freshman still? If not and you've taken a few engineering classes, then I would also consider switching to computer engineering. Similar classes and you won't have to start from scratch. But if you are just starting then go for it! 
(Just an aside comment: when I saw this post it was at 0 points. I have no idea why this post or the poster is getting downvoted -- it is legitimate curiosity to link C to computer science and garner interest in CS/programming languages. So what the fuckity fucking fuck?) 1. I think [this old post](https://www.reddit.com/r/compsci/comments/1cndqr/if_you_could_redesign_the_modern_computer/c9i75z0) is the *essence* of Computer Science. (I have it saved for quick referral.) 2. They are text editors. If you're not comfortable with command-line text editors use something else. Both are *incredibly powerful*. Emacs more-so. Both have steep learning curves. I'm partial to vim and there's a [great tutorial here](http://vi-improved.org/) (see the long IRC style tutorial). 3. No. You can learn basic constructs but each language is different. C++ is a completely different beast to C. I'm not sure if this was a joke but Bjarne Strousop (the inventor of C++) claims he his knowledge on C++ is 7/10. C is great to have on your resume because it assumes you have skills with systems-level and low-level programming. It is also used heavily in the embedded world. However if you're developing applications you might look towards using a different language such as C++, Java, Python, Cocoa, Swift, etc. If you're doing numerical/scientific work you might do it in Matlab. C is definitely not a good choice for writing a web application. You pick the language you use appropriate for the type of goal/task you're trying to accomplish 4. I recently learned about this book on this very subreddit and have been recommending it to real life friends. [Deital - C: How to program](http://www.amazon.com/C-How-Program-7th-Edition/dp/013299044X) is an accurate book on C with a *modern* introduction. Most people will say to read [K&amp;R C](http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628) which is considered the bible, but I find it a dull read (but a fantastic reference if you need to understand certain aspects of the language -- such as what is a `volatile` or a `register` keyword). 5. Good luck. I highly encourage Computer Science. However try to go into the field thinking about "solving problems with computation" rather than "learning programming languages." I feel like people miss the bigger picture of Computer Science. It is a wonderful field with a rich theory. Languages are *tools* to help you express those computations. In *theory* programming languages are computationally powerful as each other (or what we call [turing-complete](http://en.wikipedia.org/wiki/Turing_completeness)) and don't have a concept of *speed*. In practice the choice of language defines how you wish to express things and implementations of languages typically have different speeds (usually C is incredibly fast because it is closest to machine code/assembly).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Turing completeness**](https://en.wikipedia.org/wiki/Turing%20completeness): [](#sfw) --- &gt; &gt;In [computability theory](https://en.wikipedia.org/wiki/Computability_theory), a system of data-manipulation rules (such as a computer's [instruction set](https://en.wikipedia.org/wiki/Instruction_set), a [programming language](https://en.wikipedia.org/wiki/Programming_language), or a [cellular automaton](https://en.wikipedia.org/wiki/Cellular_automaton)) is said to be __Turing complete__ or __computationally universal__ if it can be used to simulate any single-taped [Turing machine](https://en.wikipedia.org/wiki/Turing_machine). The concept is named after [Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing). A classic example is [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus). &gt;A closely related concept is that of [Turing equivalence](https://en.wikipedia.org/wiki/Turing_equivalence) – two computers P and Q are called Turing equivalent if P can simulate Q and Q can simulate P. Thus, a Turing-complete system is one that can simulate a Turing machine; and, given the [Church–Turing thesis](https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis), which conjectures that any function whose values can be computed by an [algorithm](https://en.wikipedia.org/wiki/Algorithm) can be computed by a Turing machine, and therefore that if any real-world computer can be simulated by a Turing machine, it is Turing equivalent to a Turing machine. &gt;To show that something is Turing complete, it is enough to show that it can be used to simulate some Turing complete system. For example, an [imperative language](https://en.wikipedia.org/wiki/Imperative_language) is Turing complete if it has [conditional branching](https://en.wikipedia.org/wiki/Conditional_branching) (*e.g.*, "if" and "goto" statements, or a "branch if zero" instruction. See [OISC](https://en.wikipedia.org/wiki/One_instruction_set_computer)) and the ability to change arbitrary [memory](https://en.wikipedia.org/wiki/Computer_memory) locations (*e.g.*, the ability to maintain an arbitrary number of variables). Since this is almost always the case, most if not all imperative languages are Turing complete if we ignore any limitations of finite memory. &gt; --- ^Interesting: [^Turing ^reduction](https://en.wikipedia.org/wiki/Turing_reduction) ^| [^Prolog](https://en.wikipedia.org/wiki/Prolog) ^| [^Universal ^Turing ^machine](https://en.wikipedia.org/wiki/Universal_Turing_machine) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clc6tmy) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clc6tmy)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Not sure why you're being downvoted, as you're asking legitimate questions, although perhaps from a somewhat naive perspective since you are new to the field and new to reddit (no offense, you just don't seem to know the customs/procedures yet). First of all, why such a fixation on C? It is just one many languages, and while it is one of the more common languages you'll see in industry it isn't in any way foundational to CS (i.e. you can have Computer Science without C). Don't get me wrong, learning C is a great idea and I would highly encourage it, but it isn't necessarily a must. Also, I would take a look at /r/cscareerquestions, /r/AskComputerScience, or/r/compsci as many of your more general, not c related questions have probably been answered there. Moving on to your questions: &gt;how I can start programming in C on my mac don't own a mac but [this](http://stackoverflow.com/questions/9353444/how-to-use-install-gcc-on-mac-os-x-10-8-xcode-4-4) should help you get gcc installed. If you know what gcc is, what it does, and how to use it then great. If not, ask and I can give you the tl;dr essentials of how to use it. &gt;Okay so from what I understand the main things covered in computer science are programming, and understanding the theory behind the computation in a program. The main focus of CS is the theory underlying computation. Sure, programming is something we do (some of us more than others) but it is -- surprisingly to many newbies -- not a central tenet of CS. If you study CS you will probably have about two classes on programming itself. That is not to say that you won't program in other classes, just that it won't be the focus but rather a means to an end. What will you learn? You'll study computational complexity, algorithms, data structures, and logic at the very least. Depending on how your school's program is structured and what electives you choose you'll likely also delve into some of the following: computer networking and communication, computer architecture, artificial intelligence, parallel and distributed computation, software engineering, formal languages, compilers, robotics, and probably much more that I'm forgetting about right now. &gt;I looked at emacs and vim...are they just like text editors with alot of functionality for progamming? Pretty much. They're some of the most popular editors among programmers and the question of which one you use can be divisive. There's a so called holy war between the vim and emacs factions. However, it should be noted that not everyone uses two and that they (vim especially) can be intimidating at first with high learning curves. While I'm personally a member of the vimMasterRace, and enjoy using it as an editor, emacs and vim are not for everyone. Use whatever you're comfortable with for now. Don't anyone tell you 'real programmers use x editor' or anything like that. At this point I would be more concerned with your programming than what editor you're using. &gt;so yeah one of the big intimidation factors is that I would have to learn 1000 different languages to get a job or build something cool like a site or a game. But from what you guys are saying, if I learn C, I would just need to learn slightly different syntax to be good at the other languages? You will need to learn '1000 different languages' but you will probably end up learning quite a few if you end up going into CS. Personally, I have 3 or 4 languages I'm really solid in with several more languages that I'm familiar with but don't really know the intimate details of. Honestly, once you learn one the rest are generally much easier to pick up. &gt;also I appreciate the links to the books! definitely something to look into. I don't know where your knowledge level is so it's kind of hard to recommend good books for you. 
I've tried to call like createCategory(name, categ,...) but nothing changes... 
Do the `printf()`s in lines 4 and 7 give the right output? This will verify whether the variables `name` and `categ` are correct. What is the error message you get now? 
Both vim and emacs have rather high learning curves. I don't know about emacs, but vim will require a bit of setup along with a few plugin downloads to make it truly useful. I would personally recommend something like [Sublime Text](http://www.sublimetext.com/) along with the package control plugin. Try everything you can find and see what you prefer. For the most part picking up new languages isn't too difficult once you've got a couple under your belt. C is definitely a good language to learn as it is reasonably small and very low-level. A lot of major languages are syntactically based on C. You don't actually mention if you learnt object-orientation when you learnt Java, but that is a very important concept and it is something the majority of languages use, and it is something C does not have. As for programming C on a mac, you need to download XCode from the app store. You will also need to use XCode to install the Command Line Tools. You can either program directly in XCode, or you can program in a text editor and compile and run the code in a terminal. The latter is probably a better way to learn the basics.
Yes, they are giving the correct output. When I debug I see in my createProduct function there is a malloc, and it failes. But It doesn't fail when I call function by strings like createProduct("Coke", "Drink", 3, &amp;head_cat); Process terminated with status -1073741819. (The error I got.)
They are changing (I got them from a text file) but something likes Coke, Sprite and so on... 
Can you post the call to malloc that's failing?
Well, what does your `createProduct` function look like? If that's where the problem might be, then you need to show us that code.
Why not transfer to computer engineering? If you like engineering that is. 
Personally I DONT think C is a good language to *start* with. I think it's better to start with something like BASIC or Python to first get in the mindset of thinking algorithmically. Once you are comfortable with that, then take a deeper dive in to C. If you try to go straight to C you will have too many things to learn at once.
Please... Not BASIC... Anything but BASIC. But really, Python is a great first language, but C is also a really great language to start out with. As long as you can look up things on Google, you should be fine.
&gt; Please... Not BASIC... Anything but BASIC. Ok, fair enough =P. The reason I said it is because that's what I started with. But, that was over 17 years ago when QBASIC was actually cool... There are some modern BASIC languages now, but you won't find them in use out in the wild much. Python and Ruby are probably the closest thing to a 'new BASIC'. Ruby is a great language, but it has all kinds of little quirks. Python has less surprises so I'd say that's a little easier for beginners. 
For some reason your program ends up finding a chain of about 1186 items when n = 395 (which is wrong I think). I just wrote a program to do this and the longest chain below 1000000 is way less than that. Why are you bothering to store the chain?
for caching? wouldn't that increase the performance since I don't have to calculate it every time? take chain of 13: 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 with caching, it will be simply: 13 → 40 → 20 → 10 + chain _of_5 Also, I am not storing the chain, only storing chain length. 
If you're interested, I can post my solution.
please give me a few mins, I will try to fix.. I will post my code :)
but is there any better way to debug? I write my code and run `gcc mycode.c` and run `./a.out` so it never says anywhere I am trying to access the array beyond its limits. would be nice if there is some way to find out where the error is happening.
Two best ways are to print some info to the screen and to use a debugger. If you're using gcc, add the -ggdb flag to output debug symbols then run it in gdb. In my version I created an output() macro thusly: #define xFAST #ifndef FAST #define output(f,...) ({ printf(f,##__VA_ARGS__); }) #else #define output(f,...) ; #endif So I can print all kinds of debugging text with output() but when I want it to go fast I can remove them by defining FAST. 
Please indent your source with four spaces so it appears in monospaced font. It's really unreadable otherwise.
It works now. Thanks!
Your checks against `max_array_length` should be `x &lt; max_array_length`, `x &gt;= max_array_length` or `!(x &lt; max_array_length)` or the like. This is because arrays are meant to be accessed from `a[0]` to `a[n-1]`. Things like &gt; if (new_n &gt; max_array_length){ Would allow `new_n == max_array_length` which could make `collatz[new_n]` to mean `collatz[max_array_length]`, and that is not good.
Was there something unclear about the error?
Initializers for variables of static storage duration must be constant expressions in C. (Rule of thumb to remember this: no functions can be called before `main` is entered). Since C99, block-scope variables can have non-constant initializer too . 
Your pastebin is no longer available. Pay attention to compiler warnings; if you are making a type error (as suggested by frozensunshine's post) you should get a compiler message. Don't even start to think about running the program to debug until you have got to the bottom of all the compiler messages. That means fixing them properly, not throwing casts at your code to make the warnings be hidden. 
yup you are right!
On micro-controllers it is hardware dependent, so you're better off asking in more hardware specific sub reddits as C doesn't natively support it. But to answer your question. It's going to depend on which pin you put the button on, and there are multiple different ways. For buttons I recommend using an edge interrupt pin (Looks like any on Port 1 or Port 2). Under the [Peripheral support](http://www.ti.com/lit/ds/symlink/msp430g2253.pdf) look at the stuff for Port P1/2 interrupt enable, edge select, and flag. On a button press you can set up a timer than fires an interrupt every second and counts the seconds for you. If you don't have an edge interrupt, you have to poll the pin (all MSP430 pins can be polled), but this isn't as power efficient. For future MSP430 questions, I recommend asking in /r/msp430.
I thought you could use time.h with msp430? I only used nesC with it.
If you have some form of RTOS on it... use that. Otherwise you have to program the hardware timers as per datasheet and handle the interrupt.
Seems like a misprint. If you check the ISBN - that is your book http://phindia.com/printversion.php?isbn=978-81-203-0596-0 And that is the "answers .. " book with different ISBN and color http://phindia.com/printversion.php?isbn=978-81-203-0579-3
It was cheap as hell and shipped from the US (I'm in the UK and it was about £8 including postage). I figured it was an international edition as it pretty much says it on the cover. Still, I feel a bit scared reading from a book with a blatantly erroneous cover! What else could be wrong?
Don't worry, it's the same inside. Playing with the covers like that is common in international editions. I think they've studied it and found it scares people off these cheap editions. And I think you are a good example. Usually there'll be a step down on binding and quality of the paper used, but I've not heard of the content being different.
Mine is the same. Think this comes up from time to time and people get confused. It is simply advertising the answer book.
You can also fine a PDF version pretty easily...
I've seen this one come from India before.
Did you get it from Abebooks, perchance? I have the same copy of K&amp;R. my copy of The Unix Programming Environment is yellow instead of white, as well (also Eastern Economy Edition).
I have the same copy. Got it from abebooks. Fear not, the content is the same. 
if they all matter, use an array instead
But what if the operation is the total number of everything that was inputted?
The premise of the question is wrong. You don't want to track every time a variable changes; you want a new variable each time. You may need to dynamically allocate said variables.
I tried to find an assembly subreddit, but well...it doesn't exist. And for good reason! :P Thanks for your help. I was able to compile fine, when I run I get 1). An incorrect output 2.) a seg fault. I did what you said with -tui and the list of commands. I was shown a break point, and I have a list of registers. Is there any way to navigate this at all? Thanks again! edit: [This](http://i.imgur.com/qdLkU5c.png) is what my output looks like now.
Annotate the assembly with your comments/understanding of it.
In the process of doing this. It's 160 lines of code -_- (which may not be a lot, but we were just introduced to assembly) edit: finished the annotation! woot.
Use IRC, and ask ##asm on freenode.
/r/asm Yes, there is an assembly subreddit, if you were wondering.
Would you look at that. Thanks!
Connect to freenode's IRC network, and join the the channel ##asm.
I have the same book, purchased last week in India, at approx 1.25 $. This book is only printed for India and it's neighbouring countries and that's why it is so cheap.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Travelling salesman problem**](https://en.wikipedia.org/wiki/Travelling%20salesman%20problem): [](#sfw) --- &gt; &gt;The __travelling salesman problem__ (__TSP__) asks the following question: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? It is an [NP-hard](https://en.wikipedia.org/wiki/NP-hard) problem in [combinatorial optimization](https://en.wikipedia.org/wiki/Combinatorial_optimization), important in [operations research](https://en.wikipedia.org/wiki/Operations_research) and [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science). &gt;TSP is a special case of the [travelling purchaser problem](https://en.wikipedia.org/wiki/Traveling_purchaser_problem). &gt;In the [theory of computational complexity](https://en.wikipedia.org/wiki/Computational_complexity_theory), the decision version of the TSP (where, given a length *L*, the task is to decide whether the graph has any tour shorter than *L*) belongs to the class of [NP-complete](https://en.wikipedia.org/wiki/NP-complete) problems. Thus, it is possible that the [worst-case](https://en.wikipedia.org/wiki/Best,_worst_and_average_case) [running time](https://en.wikipedia.org/wiki/Running_time) for any algorithm for the TSP increases [superpolynomially](https://en.wikipedia.org/wiki/Time_complexity#Superpolynomial_time) (or perhaps [exponentially](https://en.wikipedia.org/wiki/Exponential_time_hypothesis)) with the number of cities. &gt;==== &gt;[**Image**](https://i.imgur.com/ZVH9YMS.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:William_Rowan_Hamilton_painting.jpg) --- ^Interesting: [^Bottleneck ^traveling ^salesman ^problem](https://en.wikipedia.org/wiki/Bottleneck_traveling_salesman_problem) ^| [^Travelling ^Salesman ^\(2012 ^film)](https://en.wikipedia.org/wiki/Travelling_Salesman_\(2012_film\)) ^| [^Tabu ^search](https://en.wikipedia.org/wiki/Tabu_search) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clgcchl) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clgcchl)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Oh, I find it interesting that you're doing this sort of problem in baremetal under a Zynq platform. There's nothing wrong with that, but it's just an odd focus for what seems to be an embedded programming course. Are you trying to find the distance from each "stash" to the closest neighboring stash? Or just find the distance from each stash to another. If it's the distance to the closest neighboring stash for each stash then you could create a search function that starts at each stash location in the 50x50 matrix and marches outward one block at a time looking for the nearest stash. Then just do this for each stash and store the results in another matrix or whatever data structure suits your needs. The Xilinx libraries include a baremetal malloc as well in case you're looking for some dynamic memory allocation, but this problem is simple enough you shouldn't need it, but it's good to know. That's definitely a fun board to play with, especially when you start interfacing with the FPGA and using the second core. Have fun!
clarification: shortest distance from &lt;n&gt; number of points would be the minimum of the sum of all distances from location to said points, correct? Also, it's not a travelling salesman problem, like boar's first knee-jerk reaction was. Also, this would really be a better problem for for http://www.reddit.com/r/compsci. There are a variety of things you could do: -Easiest way would be brute force. You have 50x50 possible locations, right? Go over each potential location, get the n closest points and sum the distances, and choose the spot with lowest total distance. That's really easy for a computer to brute force, and really easy to code. -or, take a random point, get it's distance_from_n_points_sum(), check whether the locations around are any better, repeat from new, better location. Guaranteed to find local minimum. Do it starting from each stash and you're guaranteed a global minimum too. side note: could you format your question better? dividing lines really help. Also, generalize the question, we didn't need to know the function input. If you're looking for someone to write your code (it kinda looks like it), then no one here or really anywhere would bother.
Isn't this the [closest pair of points problem](http://en.wikipedia.org/wiki/Closest_pair_of_points_problem)? You might want to watch two videos on this topic by Tim Roughgarden, originally part of his Coursera Introduction to Algorithms class: https://www.youtube.com/watch?v=em69u5UQNVQ and https://www.youtube.com/watch?v=T3T7T8Ym20M.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Closest pair of points problem**](https://en.wikipedia.org/wiki/Closest%20pair%20of%20points%20problem): [](#sfw) --- &gt; &gt;The __closest pair of points problem__ or __closest pair problem__ is a problem of [computational geometry](https://en.wikipedia.org/wiki/Computational_geometry): given *n* points in [metric space](https://en.wikipedia.org/wiki/Metric_space), find a pair of points with the smallest distance between them. The closest pair problem for points in the Euclidean plane was among the first geometric problems which were treated at the origins of the systematic study of the [computational complexity](https://en.wikipedia.org/wiki/Computational_complexity) of geometric algorithms. &gt;A naive algorithm of finding distances between all pairs of points and selecting the minimum requires O(*dn*^2) time. It turns out that the problem may be solved in O(*n* log *n*) time in a [Euclidean space](https://en.wikipedia.org/wiki/Euclidean_space) or [L^p space](https://en.wikipedia.org/wiki/Lp_space) of fixed dimension d. In the [algebraic decision tree](https://en.wikipedia.org/wiki/Algebraic_decision_tree) [model of computation](https://en.wikipedia.org/wiki/Model_of_computation), the O(*n* log *n*) algorithm is optimal. The optimality follows from the observation that the [element uniqueness problem](https://en.wikipedia.org/wiki/Element_uniqueness_problem) (with the lower bound of Ω(*n* log *n*) for time complexity) is reducible to the closest pair problem: checking whether the minimal distance is 0 after the solving of the closest pair problem answers the question whether there are two coinciding points. &gt;In the computational model which assumes that the [floor function](https://en.wikipedia.org/wiki/Floor_function) is computable in constant time the problem can be solved in O(*n* log log *n*) time. If we allow randomization to be used together with the floor function, the problem can be solved in O(*n*) time. &gt;==== &gt;[**Image**](https://i.imgur.com/wGO3IuW.png) [^(i)](https://commons.wikimedia.org/wiki/File:Closest_pair_of_points.svg) - *Closest pair of points shown in red* --- ^Interesting: [^Nearest ^neighbor ^search](https://en.wikipedia.org/wiki/Nearest_neighbor_search) ^| [^Set ^cover ^problem](https://en.wikipedia.org/wiki/Set_cover_problem) ^| [^Computational ^geometry](https://en.wikipedia.org/wiki/Computational_geometry) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clgh2is) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clgh2is)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Your post is unclear unfortunately, so this could actually be a variety of things. I have a few questions: The first question is about "shortest distance between 'n' number of points". My assumption is that you need to find a path connecting all "n" points. However if this simply means the shortest distance between two points out of a set of n points, this problem is easier (And you can ignore my next questions). The second question is whether or not 'n' is always equal to the number of points you have (IE. If you have 9 points, you need to connect all of them). The third question is whether or not the connections have to be in series. IE. Could you have a valid series of 4 points where you have one point directly connected to three others (And no connections between those other three points)? If you just have the find the shortest distance between two points on any set of 'n', then you could just do a brute-force search over all of them (You have a max of 30 so this isn't so bad), or you could do something more efficient like a [K-D Tree](http://en.wikipedia.org/wiki/K-d_tree) for it (But there is a huge jump in complexity when you go from brute force to something like a K-D tree). Now, assuming that you're looking for a series of points, if 'n' is always equal to the number of points (And possibly even if it's not), this is a minimum spanning tree problem - Finding the smallest graph across a set of points which connects all of them with the smallest total distance. You can find minimum spanning trees through algorithms like [Prim's algorithm](http://en.wikipedia.org/wiki/Prim%27s_algorithm) or [Kruskal's algorithm](http://en.wikipedia.org/wiki/Kruskal%27s_algorithm). However, if you're *not* allowed to have multiple connections to a single point, then this isn't a minimum spanning tree problem and it is the [traveling salesman problem](http://en.wikipedia.org/wiki/Travelling_salesman_problem) (Without the requirement of returning to the start, which doesn't actually increase or decrease the complexity of the problem). I think it's worth noting, everything listed in this post beyond the brute-force solution to my first guess on what they're asking you to do are decently high-level solutions to implement. They're not exactly hard, but they're not beginner level either (Unlike just doing a brute-force loop over every point to find the shortest distance). They're also all graph-theory problems at that point, which if you haven't done any real graph theory I wouldn't expect questions on (IE. I wouldn't expect a problem where the solution is a minimum spanning tree if you've never even talked about MSTs).
There are lots of great example programs written for the MSP430, id take a look around for those and just try to modify it to your use.
&gt; Ugh, AT&amp;T syntax Ugh, x86. After working with Blackfin assembly for a few years, looking at anything else is just an eyesore. For example, here's some of his x86 assembly pushl %esp movl %esp, %ebp movl 12(%ebp), %eax imull 8(%ebp), %eax popl %ebp ret And here's a rough equivalent in Blackfin (probably incorrect, but good enough to illustrate) [SP--] = R1 P1 = SP R0 = [P1 + 12] R1 = [P1 + 8] R0 = R0 * R1 R1 = [++SP] RTS
&gt; it's just an odd focus for what seems to be an embedded programming course Is it? I'd be disappointed in an embedded programming class that *didn't* run on baremetal, or something close to it.
No, that's not what I meant. I would too! But this particular problem doesn't really have to do with embedded programming. Interrupts and and task schedulers would be more of what I would have expected, but that doesn't mean you can do these sort of problems as well.
C books definitely still relevant. 
True. Somewhat like asking if old algebra books are still useful.
Thanks!! I saw these as well while I was annotating it, and it's nice to see someone else confirm-ish my suspicions. What do you think about line 6 being pushl %esp? I'm pretty sure it should be pushl %ebp. Also, a caveat to the assignment is that "lines can only be changed, not removed or added". So while I agree with point 2, the lines cannot simply be removed. They must perform some function...
That looks so much more manageable...
[For Reference](http://en.cppreference.com/w/c/algorithm/bsearch) Are you assuming your input array is sorted? If so why ? Bsearch only gives the element if found exactly you need to find the ones around it. In other words you need to implement this or create a compare function that would return the bounding values. Which isn't too bad to be honest.
Thanks, didn't know if there were any changes to C over time
Even the C89 edition of K&amp;R is still relevant. There have been changes in the language since then but it's still the dialect that is most widely used.
I saw your annotations via the /asm subreddit and you caught my points, good job! I admit that I didn't delve that far in your code because I find the [32bit calling conventions](https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl) hard to follow with all the indirect addressing off %ebp. The x64 calling conventions in Linux are so much nicer, everything is passed in registers. I agree that the `pushl %esp` is probably an error. Fix it and see! In assembly it's hard to say whether something is an error or flat wrong. Sometimes seemingly useless statements get put in for timing or pipelining concerns, or just to set the flags. The double error I saw was on line 62 and 63. Line 63 seems unnecessary to me, but it's probably just a case where GCC didn't optimize as aggressively as it could have. The cases that you marked as suspicious didn't strike me as such. The weirdness with large constants is usually some optimized method for division, multiplication or other numerical method that relies on [bit twiddling](http://graphics.stanford.edu/~seander/bithacks.html).
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 3. [**cdecl**](https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl) of article [**X86 calling conventions**](https://en.wikipedia.org/wiki/X86%20calling%20conventions): [](#sfw) --- &gt;The __cdecl__ (which stands for __C declaration__) is a calling convention that originates from the [C programming language](https://en.wikipedia.org/wiki/C_programming_language) and is used by many C compilers for the [x86 architecture](https://en.wikipedia.org/wiki/X86_architecture). In cdecl, subroutine arguments are passed on the [stack](https://en.wikipedia.org/wiki/Call_stack). Integer values and memory addresses are returned in the EAX [register](https://en.wikipedia.org/wiki/Processor_register), floating point values in the ST0 [x87](https://en.wikipedia.org/wiki/X87) register. Registers EAX, ECX, and EDX are caller-saved, and the rest are callee-saved. The [x87](https://en.wikipedia.org/wiki/X87) floating point registers ST0 to ST7 must be empty (popped or freed) when calling a new function, and ST1 to ST7 must be empty on exiting a function. &gt; --- ^Interesting: [^Calling ^convention](https://en.wikipedia.org/wiki/Calling_convention) ^| [^9front](https://en.wikipedia.org/wiki/9front) ^| [^Name ^mangling](https://en.wikipedia.org/wiki/Name_mangling) ^| [^Visual ^C++ ^name ^mangling](https://en.wikipedia.org/wiki/Visual_C%2B%2B_name_mangling) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clh2dhr) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clh2dhr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
There definitely were, just not enough to the fundamentals of it to make textbooks outdated.
1. You could recreate the command line utilities found in the linux shell. Something like `cat` for example. First just make the absolute barebones version of it, then start replicating functionality (command line options etc.) If you ever get stuck or don't know how to do something, there is a 'cheat sheet' available in the form of its source code, although because the source code can be... special at times, you are more inclined to figure it out on your own. 2. Work on replicating your past projects. Convert some of your python programs into C programs. 3. Do some of the challenges from here: http://adriann.github.io/programming_problems.html
fopen(), fgets(), strtok(), strtod()...
I found a newer one (2008) called "Let us C". I checked the index and it looks to be more comprehensive than the other two big ones they had on shelf.
3rd line of main() you dereference a pointer you just set null.
The fun thing about linked lists is that you only need to track the head node. From what I understand, struct `LIST` is used to keep track of this, have a NODE pointer prev used to build up the list and a size as a cache for the total number of nodes. The `prev` variable could be created alongside `current` in `creatL()` as it is only used there. It would also serve no other purpose unless you don't want to create any auxiliary pointers for functions such as searching for insertion. `freeL()` is freeing the node and *then* using it. This is not safe. You should be using an auxiliary variable to keep track of the next node and freeing the current node. The way you use `movies-&gt;head` could be replaced by the use of a `NODE *` so in your main() you could be doing (modifying the function signatures): NODE *movies = NULL; printL(&amp;movies); freeL(movies); And creatL() would have to become something like: void creatL(NODE **movies) { int i = 0; NODE *current, *prev; char input[MAXLEN]; while(1) { ... if (*movies == NULL) { *movies = current; } else { prev-&gt;next = current; } current-&gt;next = NULL; prev = current; } return; } PS: If you want to modify the value a pointer is holding from another function, you need to pass it the address of the pointer, not the pointer itself. To modify: int *p; *p = 4; From another function you need to: function(&amp;p); And there, int function(int **p) { *p = 5; }
reman have a segment problem run after input ID number.
Thanks! :) Update: So I'm getting correct output now! Yay! I am having 1 more issue though, and I can't pin it. When I run the program, it calculates the nth prime number, then the cursors moves down a line and hangs. I'm not sure where this is happening though...I think it's at the ending of main, but I'm not sure. [Here](http://pastebin.com/zMLSZgtt) is my revised code. Any suggestions? 
thanks
&gt;if(fgets(input, MAXLEN, stdin) == NULL &amp;&amp; input[0] == '\0') you probably want || here instead of &amp;&amp;
Reading reviews of that doesn't fill me with confidence ... 
The reviews I see are mostly positive, care to share where you see the bad ones?
Look on Amazon, someone who knows C and who has actually read it comments. The other reviews seem like shills or newbies. (Newbies are in no position to judge a book like this - they can't tell the difference between learning correctly and learning rubbish). 
I haven't read the entire code, but void addfriend(fri * finfo) { counter++; finfo= (fri )realloc(finfo, countersizeof(fri)); won't work. Finfo will only be changed in the scope of addfriend, instead, you need to pass the address of finfo and dereference it to change it
Any scheme you use to rename the symbols will result in symbols that can be conflicted with. You shouldn't be bearing the burden of handling integrating your library into your customer's code, at least not to the level of implementing some complicated symbol renaming scheme for their sake. You should prefix the functions from the public api with some meaningful token (something like ***foolib_***APIFunc1) to make it clear that these symbols are from your library, and leave it at that. Imho, it's each customers' responsibility to do the final integration, you can make it easier, but you also shouldn't be unreasonably burdened doing so.
I'm sorry, I really just didn't know how to format it properly other than physically doing the four spaces myself, and that seemed really time consuming, just to make the font all look the same. I'm very, very new to programming in general.
Specifically it's not just the font, but if you read it over you'll notice that Reddit ate some of your \*'s and turned them into italics. This is incredibly frustrating to read. Use a sharing site like pastebin (syntax highlighting on please!), link it and you'll get a much better response. 
Some linkers have support for symbol rewriting, and they can also hide symbols or remove them altogether. What platform are you on? Structs do not have symbols, so if you expose your API through a set of function pointers in a struct, you can drastically reduce the number of exported symbols. Berkeley DB does this, for example.
The language hasn't changed much, but the API to common libraries (like your OS/GUI) likely has changed.
yes, thank you 
Your `initL()` function doesn't do what you think it does. C always passes parameters to functions "by value". This means that whatever you pass, whether it's an integer, a struct, or a pointer, that thing is passed a *copy* of the value. The function can modify that copy all it wants, and the original is unchanged. Your `initL` function takes in `LIST *movies`. This means that the variable `movies` receives a *copy* of the pointer (the address). When `initL` does `movies = NULL`, you're setting **initL's *copy* of movies** to null. You're *not* affecting `main`'s variable, because you're only operating on a copy. What could you do to change this? * You could dereference the pointer (`*movies`). But then, you have a `LIST` instead of a `LIST *`, so you're dealing with a struct rather than a pointer. There's nothing to set to null, because it's not a pointer anymore. So this isn't a fix. * You could take in a double pointer (`LIST **movies`). Now you have to change `main` to do `initL(&amp;movies)`, because you need to take the address of your pointer to get a double pointer. And you need to dereference the pointer inside `initL` to get it back to a single pointer (`*movies = NULL`). This would work, but it's awkward. * You could skip using a function. Why use a whole function just to set a variable to null? C programmers know that this needs to happen anyway. In `main`, just declare the variable as `LIST *movies = null`.
Like these folks said, using a prefix is the least bad answer. We once had a library where we had to add "z_" to *everything* because one of our symbols fought with a customer library and we figured it likely wouldn't be the last one.
Just use a #define x to be your print statement? #define x a;\ printf(" world"); void c() { int x; }
Nah dude, why wouldn't you just post it on reddit? its obviously more effective. /s
 int main(int argc, const char* argv[]) { a(); printf("\n"); } void a() { b(); printf("hello"); } void b() { c(); printf("world"); } void c() { int x; } Is that what you are starting with? That should already print "world hello\n" 
Sorry i mixed it up, the print for "hello" should be in b and "world" should be in a.
I'm only allowed to write code in function c.
i forgot to add that i can only add code in function c.
The fastest way (and a way to avoid overflows with int or long) will be to use the following conversions (each hexadecimal digit can be converted to four binary digits): hexadecimal→binary 0→0000 1→0001 2→0010 3→0011 4→0100 5→0101 6→0110 7→0111 8→1000 9→1001 A→1010 B→1011 C→1100 D→1101 E→1110 F→1111 So if you get 1**A**C**2**, that'll be 0001**1010**1100**0010**.
Is this a homework problem?
If you create a shared library, use a mapfile to filter the dynamic symbol table. The dynamic symbol table is the symbol table that is used to resolve references between shared libraries. A mapfile is used to select which symbols end up in that table and which not.
Use this kind of function to read it, one character at a time. Doing it this way is easier to understand and complete for your level. -&gt; http://www.tutorialspoint.com/c_standard_library/c_function_fgetc.htm Then use something like this on each byte, ... c = fgetc(fp); // add after this place in the example for(i = 8; i &gt; -1; i--) { if (c &amp; (1 &lt;&lt; i)) { printf("1"); } else { printf("0"); } } printf("\n"); 
Make that i = 7...
This(2nd version) is the best C textbook I've ever read. I bought books like K&amp;R, Expert C Programming, Pointer on C and C traps and pitfalls. C programming: a modern approach 2nd edition is the one I would recommend if you are gonna learn C programming, it covers almost every topic in the other books mentioned above.
We did this with the libraries our team developed. All was well till one day, the customer, for reasons unknown, decided to name their variable with the same prefix that we were using.
I don't think it should be your problem if your customers decide to create symbol collisions, unless you happened to use some really common string.
The string we were using wasn't common, but they were quite upset with the errors - Apparently, we hadn't mentioned it anywhere in our programmer's manual/documentation that the customer shouldn't use variable names starting with that prefix (!)
Use a modulus (%) of 8 against the original position of the tab + 8 to figure out the number of characters to insert.
The King book is a gem. I alternate between that one and Deitel and Deitel's [C: How to Program](http://www.amazon.com/C-How-Program-Paul-Deitel/dp/013299044X/ref=sr_1_8/184-0021387-8358245?s=books&amp;ie=UTF8&amp;qid=1414160511&amp;sr=1-8).
So I should use a switch for all those options? 
Hi, thanks a lot, I could easily follow the code. I was trying to use only the concepts described in chapter 1 of K&amp;R to solve this problem. This is is also brilliant. I could not think of something like this so I can make use of it. Thanks a lot for taking out time and code this thing in. Really helps.
This book is also the C book used for the low level programming class at my university 
I used this book to learn C and i really think it's one of the best for beginners. The exercises are very realistically solvable (unlink many other books i've read). I did more than 150 of them which really helped me to get a solid foundation.
&gt; My code won't compile right now What errors are you getting?
First off, you do not need to cast the result of malloc() (and if your instructor is saying you must, that instructor must be a C++ programmer stuck teaching C). Second, since your error messages have "Windows said no", you must be using a Microsoft C compiler. Hate to say this, but the syntax you are using, declaring variables in hte middle of a block of code, is *not* C89 (the first C standard). It *is* C99, but Microsoft does not support C99 (or rather, it's kicking and screaming as it slowly is forced to support C99). You'll need to declare all your variables right after the opening brace. Other than that, it looks fine. 
&gt; First off, you do not need to cast the result of malloc() (and if your instructor is saying you must, that instructor must be a C++ programmer stuck teaching C) Of course checking the return value of malloc is also pointless these days - it will never return NULL, even if the requested memory isn't available. You'll just get a page fault when you try to access your memory. Don't tell your professor that, though! (and checking for NULL never hurts anything) 
Umm, I'd like to see you try that on a 32-bit machine after you've allocated about 3GB of memory. Or an embedded machine with &amp;lt;1MB of heap.
So that the linked list can persist across function calls. If you allocate the node in the function using what you suggested, it will be allocated on the stack. The stack frame goes away once the function returns (technically, it stays until overwritten). And hence the linked list will not be sane. That is why you generally declare a pointer and then allocate memory for it from the heap using malloc etc.
So if the ONLY function of the program is to make a linked list and add or delete nodes according to user input (the program only consists of the main function), then it would be perfectly fine to initialize it as node instead of node*? 
Don't delete your post just because your question has been answered.
On most systems, the memory allocation will be returned regardless of how much you asked for, and the pages won't be assigned until you step on them. On embedded systems, I don't use malloc anyway. Side note: At least it's not alloca().....talk about an evil function!
Ok, My bad.
You still have to be careful. For example, if your node is declared inside of a loop, then it only exists for the life of the loop. You're fine using a stack-allocated node if you know that while you use it it's not going to go out of scope, but if you're adding or deleting according to user-input I think it's unlikely that you know how many nodes to allocate ahead of time on the stack (So that approach wouldn't work). For example this is fine: int main() { struct node *list; struct node my_node, my_node2, my_node3; list = &amp;my_node; my_node.next = &amp;my_node2; my_node2.next = &amp;my_node3; printf("data: %s", list-&gt;next-&gt;next-&gt;data); } But this is not fine: (Code like this could happen if we don't know the value of 'count' until we run the program - Ex. inputted by the user) int main() { struct node *list, *last; struct node first_node; int x, count = 2; list = last = &amp;first_node; for (x = 0; x &lt; count; x++) { struct node my_node; last-&gt;next = &amp;my_node; last = &amp;my_node; } printf("data: %s", list-&gt;next-&gt;next-&gt;data); } This is because when I try to access the nodes at the very end for the printf, the 'my_node' node has already gone out of scope so I can't use it. This should be more obvious by the fact that I loop twice, which is obviously invalid when you consider that the second time through the loop, last == &amp;my_node, but the old my_node we stored there is *gone* because we're on the second round through the loop, so that's invalid to do. Now, replace the 'for' loop with your loop for user-input and it should be clear how they're similar and why simple stack allocation won't work when you don't know how many you're supposed to allocate (Unlike my first example, where I knew ahead of time I needed three nodes and declared them all separate).
Thank you for your answer. I used your alternative originally, but thought it might work more elegantly this way. I will try the double pointer method or revert to the alternative. 
Just out of curiousity, what makes you want to compile c code on an iOS device? What are you trying to accomplish?
I'm learning C at my university and I'd like to try some things during the lecture. Or after the lecture. However, my portable device isn't a laptop but an iPad ;)
As a general rule in C: * Change _what_ is in the memory the pointer points to - single pointer passed in foo (char *myPtr) * Change _where_ the pointer points - double pointer passed in foo (char **myPtr) My finger is pointing at a cake on the kitchen counter (single pointer) you can replace the cake with a pie - I am now pointing at a pie. My finger is pointing at a cake on the kitchen counter (double pointer) you move my arm so it is now pointing at the dining room table at a glass of wine. Mostly I see this used with linked lists and in situations where the called function mallocs some buffer space.
Or, alternatively stated: to modify anything belonging to the caller, you must add a layer of indirection. To modify a caller's int requires passing a pointer to int. To modify a caller's pointer to int requires passing a pointer to a pointer to an int. 
&gt; So my below code works Define what you mean by "works." Also what are you trying to accomplish? On the line: `FamCalc(person, location, ages);` you are passing pointers to person and location but the actual function is expecting type char. That's why you're seeing warnings. The function definition is incorrect. Also you're not using those variables. 
If you've heard of jailbreaking (which I hope this subreddit has no problem with me talking about it), I'll let you know it is possible to make your iDevice compile not only C programs, but also applications and more. If you're interested in this I'll invite you to give [iPhoneDevWiki](http://iphonedevwiki.net/index.php/Main_Page) a look. Feel free to PM if you have any questions.
Have you considered using something like [IDEOne](http://ideone.com)?
They pretty much are only there because I wasn't able to figure out a way to call the function without them. How do I go about passing a string instead of char? Thanks for taking a look at this. EDIT: I've changed void FamCalc(char A, char B, int C) to void FamCalc(char A[], char B[], int C) does this correct it?
That will correct the problems. You still aren't doing anything with those arguments, though—why do you have them? If you aren't going to do anything with those arguments, just declare the function as `void FamCalc(void)` and call it as `FamCalc()`.
Thanks. I thought it didn't make a lot of sense for me to have to arguments if I wasn't doing anything with them but I couldn't figure out a way around it.
I totally relate. I jumped pretty deep into things when I started, too. That excitement and desire to know makes it easy to get caught up. That said, sometimes the best way to learn is to dive in, and as you said you learned a few things in the process, which is always important. Mistakes are opportunities to further your knowledge. 
&gt; So my below code works &gt; Define what you mean by "works." Only in IT you can find this kind of gem. 
Thanks! I didn't know you could do this online! :D
segmentation fault
There actually is a jailbreak available, though not recommended for users yet. Just jailbreaking won't slow down your device. But I won't push you into doing something you don't want.
Note that scanf("%s", members[ctr].name); and scanf("%s", members[ctr].state); will cause buffer overflows if they receive strings of length greater than 29 or 3, respectively. You should either use width specifiers: scanf("%29s",members[ctr].name); or use fgets to limit the length of string you feed to sscanf.
My larger point is that checking for malloc to return NULL is not sufficient, and is only one of a number of potential failure points - and it's always taught that malloc will never return NULL unless it can actually satisfy the request. I'm in favor of teaching newbies how the system ACTUALLY WORKS, so they'll have a deeper understanding. Naively checking the return value of malloc and assuming that it will never misbehave can lead to problems. If you're using a really small embedded system, you really shouldn't use malloc anyway. There's almost always a better way. Most of the systems I write code for, on a daily basis, don't even have a heap to speak of.....malloc isn't included in their C libraries. 
&gt; checking for malloc to return NULL is not sufficient We're saying different things here. You're saying, "Sometimes malloc may return an address, but when you try to use that address, it isn't really there, and your program will be killed." That's true, if the kernel is allowed to overcommit. Although even if the system is overcommited, that could be only a transient condition. Maybe the user will soon turn on some additional swap space, which would relieve the memory pressure. What I'm saying is, "Dereferencing null is an error, and since malloc can and will return null, you must check for it and handle it." This could happen even without an overcommit scenario. If I ask to allocate 3.5GB of memory, I'm not going to get it. It doesn't matter if I have 8GB of physical memory; it's simply not possible for the Linux kernel to provide a contiguous allocation that big on a 32-bit machine. &gt; I'm in favor of teaching newbies how the system ACTUALLY WORKS, so they'll have a deeper understanding. Naively checking the return value of malloc and assuming that it will never misbehave can lead to problems. That's fine, and I agree with it. I'm not saying you're wrong about the behavior of malloc, but I *am* saying that your advice to skip checking malloc's return value is poor practice. It might be okay for a student doing a small intro assignment, but it's a habit they need to break before graduating. You're also getting at a more advanced concept. It's known, documented, and widely understood that malloc can return null if there isn't enough memory. The overcommit scenario is not as common (not all kernels are capable of overcommitting, and I had to research it to see what you were getting at), and requires a much deeper understanding of virtual memory and kernels. &gt; If you're using a really small embedded system, you really shouldn't use malloc anyway. There's almost always a better way. Um, that entirely depends on what you're building. Regardless, I work with what I'm given, and I was given an embedded system with a low amount of memory that uses malloc the same way that many other C programs do. Good habits are good habits on any platform.
I simply favor not using malloc() at all. As a side note, calloc() initializes the returned memory to zero, and so the pages must be assigned to your process before it returns. Of course the performance is much worse in that case - and I'm still not sure if it'll return NULL or just trigger an fault of some sort if you ask for more memory than the system physically has available ( including swap ). Obviously trying to get more memory than your address space has will not work, but it's a pretty rare condition. I'm not saying you should never check the return value of malloc - I believe you should check for NULLs in lots of places. I am saying malloc should not be used or trusted unless you understand what's going on underneath.
`person` and `location` are arrays of char, meaning they consist of several (30 and 4, respectively) individual char values which are contiguous in memory. The way you have declared your function void FamCalc(char A, char B, int C) implies that you will be passing it individual char values instead of the whole array. This is obviously not your intention. However, in C, you can't pass arrays to functions by value, so when you type a name of an array as an argument to a function, it *decays* (this is the standard terminology) into a pointer to the first element of an array. Therefore, when you pass arrays with elements of type `foo`, you're actually passing values of type `*foo` (pointers to `foo`), or in your case `*char`. So the correct declaration would be void FamCalc(char *A, char *B, int C) Your suggested declaration void FamCalc(char A[], char B[], int C) is correct since it's actually just a syntax sugar synonym for this. Some extra detail: when you tried to pass a pointer to a `char` into a `char` parameter, the compiler tried converting the pointer (which is basically a memory address) to a `char` (which is basically a small integer). The result of this operation is implementation-defined and shouldn't be relied upon. This explains the type error you have been getting. The reason it worked is that the conversion from `*char` to `char` and back to `*char` (upon passing it to `printf`) worked as expected on your platform. EDIT: I just wanted to point out that other comments saying you don't actually need the parameters are still applicable. My points are useful for the future cases when you will need the parameters.
You do `x_old = x_new`. That means `x_new - x_old` must be zero, so `fabs` of it is still zero . Since it is not true that `0 &gt;= acc` your loop finishes. You could fix this by moving `x_old = x_new` up to the start of the loop, and initialize with `x_new = -10` instead of `x_old = -10`.
You have several errors. The line scanf("%f", &amp;acc); should be scanf("%lf", &amp;acc); since `acc` is a `double` and %lf is `scanf`'s `double` specifier. Since `scanf` writes to memory, it needs to differentiate between `float` and `double` to know the correct size of the write. This is, unfortunately, *unlike* `printf` which uses the %f specifier for *both* `double` and `float`. This is because of promotion rules stating that floats are automatically promoted to doubles in functions with a variable number of arguments (such as `printf`). So the `printf` lines involving doubles should look like this one: printf("%f\n", x_old); Also, since `count` is an `int`, the line printf("Iterations required: %lf\n",count); should be printf("Iterations required: %d\n",count); since %d is the `int` format specifier. What's giving you the most trouble is the logical error in these lines: x_new = x_old - (f/g); x_old = x_new; Since you're immediately overwriting `x_old` with the value of `x_new`, their difference is always 0 and this is why your loop always executes only once. A solution could be to introduce an additional variable, e.g. `x_saved` and rewrite those two lines to look like this: x_new = x_old - (f/g); x_saved = x_old; x_old = x_new; And then test for the difference `x_new - x_saved` in the while condition. 
I like this solution better than the one I've suggested.
Brilliant, thank you. I hadn't even noticed the syntax errors.
Got it working perfectly now, I appreciate the help!
I overlooked the format string errors though! Probably he was executing the loop with garbage in `acc` as a result, which can't have helped.
In my projects for TI DSP's (TMS320F2812 for example) I do timing with the CPU hardware timers, an off-chip real time clock that we have on board, and via counting clocks using ASM NOP instructions in a loop to make 1us. I have microsecond and millisecond delay functions that accept a variable indicating the number of those intervals to delay, and both are based on: while(i--) asm("NOP"); Where i is initialized to a number known to provide as close as possible to 1us delay (as timed with code profiling tools). Since we vary the CPU speed throughout our application I have to be cognizant of that and adjust the value of i accordingly.
&gt;While I'm here I might as well say I absolutely hate putting braces on the same line. Same. It's just too information-dense that way, I like the sparseness that the extra line adds, it helps you identify the different components of the control structure intuitively and at a glance without having to think about it. It's the difference between someone talking to you really quickly as if he has to take a piss but has to get his last statement out first versus a normal conversation with appropriate grammatical pauses.
I use Whitesmiths. Same sparseness as Allman but braces are aligned with the other stuff in their block, instead of aligned with the enclosing material. I find this more logical--but it's also just the way I learned, 20 years ago. My progamming is hobbyist only at this point. One idiosyncratic stylistic feature I use: all my debugging code (usually printf statements) gets hard left-justified, even when it's nested 10 levels deep. This reminds me to take it out when I've finished debugging, and makes it easier to find when I'm scrolling through to comment or uncomment.
Thanks, good to know. You could also use a void pointer right? I don't think I've ever seen that but thinking about the problem it seems you should be able to assign the address of the u32 to a void pointer and then assign the value at the pointer to a float with a cast? Seems like it would be less code, though maybe harder to follow.
That's the right way to do it. One way you sometimes see is taking the address, casting to a pointer of a different type, then dereferencing. This generally appears to work, but doesn't give anti-aliasing guarantees. The compiler might warn you something like "Dereferencing type-punned pointer will break strict-aliasing rules". But that's the wrong approach. Use the union. 
Excellent, thanks. That answered my next question I asked the other respondent!
I like Allman as well (didn't know it had a name). But I'll follow conventions of any project I'm working on, and sometimes languages tend to have their own conventions. For example, I'm not sure why, but I almost always see JavaScript in [1TBS](http://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS), so I'll usually use that for JavaScript. Last project I worked on used 3 space indentation, which is obviously barbaric and akin to devil worship, but I went with it anyway. Only thing worse than a weird formatting style is no formatting style.
&gt; Last project I worked on used 3 space indentation Ow, my thumb! &gt;Only thing worse than a weird formatting style is no formatting style. Yeah that's true
I should add that the union behavior is not specified by the C standard, but you're already in the realm of implementation-defined behavior anyway, and compilers will almost certainly do what you want with it. Still, you may want to check you compiler manual. Here is gcc's promise about it: https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Structures-unions-enumerations-and-bit-fields-implementation.html 
I use Whitesmiths as well. I had been programming as a hobbyist since the eighties but when I had to put a real multi-module project through the doorknob the mid-nineties (on a Macintosh running MacOS 8) I was reading McConnell's _Code complete_, and his suggestions are very close to Whitesmiths.
This will probably work in most compilers, in most situations. It’s called “punning.” Per the C standard, it’s considered bad form unless one side of the pun is `char` or `void`, or unless the two sides are of compatible type (ignore signedness, constness, volatility, etc.). [See here for one look at this](http://blog.regehr.org/archives/959), although I believe you can cast through `char *` or `void *` in most cases to get around what they solve with `memcpy`.
You aren’t giving anybody enough info to solve your problem. Where is `movies` coming from? Is it allocated correctly? Are its fields initialized correctly, or at all? Are the strings you’re (purportedly) referencing terminated correctly? Are you using the right `printf` format specifiers for the corresponding field values? Also, this is quintessentially the intended purpose of `for` loops. for(index = 0; index &lt; count; index++) 
I use banner style it's easier to read in my opinion.
I personally prefer [the K&amp;R style](http://en.wikipedia.org/wiki/Indent_style#K.26R_style), because that's how I learned programming and I've no problems with it so far. Anyways, who cares about indentation styles? I can easily switch to any style that suits everybody. After 6 years of maintaining a huge codebase written by many junior and senior developers, I've developed the ability to read and write all sort of codes. IMO this is the stupidest thing programmers waste time on discussing, even worse than which code editor is best.
I have a hard time reading K&amp;R, it looks messy and disorganized to me. It takes longer for me to read and understand it. That's why I care. FWIW I've been a software/firmware engineer for 8 years and am the sole developer for my company where I've designed and implemented the firmware for over a dozen pieces of professional fiber optic test equipment as well as several different Windows and Android companion applications that they communicate to for file transfer and viewing as well as virtual instrument remote operation.
If you're doing any open source C programming, you'll probably need the linux style (kernel style in the wiki article). I used to use K&amp;R but then I ..adapted, except I put opening braces on the same line even in function declaration. And (only) in C, I tend to split function type from the name by a newline as in GNU style, it makes searching a bit easier (`/^foo/` is much more specific than `/foo/`).
Whatever you do, be consistent. Be consistent with other people's code that may be included, and with yourself. Because if I find another piece of code that has both tabs and spaces in it, I am going to pistol whip somebody.
Honestly what kind of an animal indents with spaces?
&gt; it looks messy and disorganized to me Followed by a para-sentence of: &gt; FWIW I've been a software/firmware engineer for 8 years and am the sole developer for my company where I've designed and implemented the firmware for over a dozen pieces of professional fiber optic test equipment as well as several different Windows and Android companion applications that they communicate to for file transfer and viewing as well as virtual instrument remote operation. As I read that sentence, I kept thinking "I've found the end!" and was proven wrong. If you care about code styles because they can look messy and disorganized, care enough about English to avoid run-on sentences. I know I prefer my co-workers who can explain something aloud without me worrying about them passing out to the ones who can't, regardless of their code style. You can always use a tool like astyle to fix it if need be, but someone who can't speak or write clearly hinders everyone.
I indent according to the [OpenBSD kernel source style guide](http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man9/style.9?query=style&amp;sec=9). In my opinion, it's one of the most sensible stylistic guides for C code out there. Here is an example of code I wrote formatted according to that style: https://gist.github.com/fuzxxl/a374850ed3c869731c14.
Just out of interest, how do you format code that uses K&amp;R-style function definitions?
Personally, I dislike this style unless you're going for having multiple different types of 'Disks', where it makes sense to have function-pointers in place of the correct functions. The big thing for me is that besides the indirect call being slightly slower, it makes things just a bit harder to read. This is especially true for situations where there's only ever going to be one set of functions. Having an extra layer means you have to dig a bit farther to figure out what code is actually going to get run, and then you need to make sure that it actually works correctly. It also feels a bit pointless when looking at the code I write because I would just get this: network_node-&gt;add(network_node, new_net); Instead of this: network_add(network_node, new_net); There's much less that can go wrong with the second one - Barring someone doing something especially nasty and swapping 'network_add' with a different function with the same name at compile-time, I know that network_add is always going to be called here and and at run-time it's never going to change where it's calling. With the first, I don't have that guarantee anymore since I have an extra layer that could end-up changing at some point unexpectedly, however unlikely. Obviously, if I'm the one writing the code, then *I* know it's not going to change, but the person reading my code isn't going to immediately know that. More-over, since it's not the common way of doing things, it implies that there's some reason for the extra layer (Such as different types of networks) when none really exists. That said, there are situations where the first case is much more practical, and in those cases it's worth the extra complexity. I'd say it's a good use in your case, it gives you a unified way of accessing the different types of disks. I wouldn't do it if you were never expecting any other types of disks though.
&gt; I wouldn't do it if you were never expecting any other types of disks though. Thanks for the input, that was mostly what I was wondering about because, while the specific example I gave does have the practical purpose of allowing multiple sets of functions to be used depending on the hardware in use, I have been starting to use this style in places where I never expect to need to dynamically change the functions being pointed to. I should probably stop doing that! &gt;however unlikely Heh, array overflows are a bitch... --- Mostly unrelated, but I struggled with what to name that class... "Disk" is what I settled on even though it's almost an archaic term these days. I was going to go with "Storage" or "Store" or "NV" (for non-volatile)... A trivial thing but I find myself getting hung up on those kinds of trivial things.
Wouldn't it be amazing if there was a language like C but with this sort of thing built in? 
 void func() { // a comment while ( 1 ) bar(); while ( 2 ) { // another comment foo( 1 + 2 ); baz( bar() ); } }
There's no single correct answer to this, otherwise it would have been done already :) For error codes, I tend to favour the global table, because then when a customer reports an error you can just ask for the error code . Windows uses the same sort of scheme. Also for any large project I would explicitly list each error with a code (or at least, explicitly reset the error number from time to time in an enum); otherwise source control merges could end up having a ripple effect and changing the values of other error codes. The downside of this is that it gets messy when you end up with too many error codes to fit in the part of the domain that you'd allocated to that particular error. The next topic is the file/line/func reporting. There's really no way to get around this, you have to use ugly macros. A work colleague has a setup where each important function is wrapped in ugly macros; but the advantage of that is that at runtime you can turn on and off debugging / datalogging level for each function by editing a text file; you don't have to recompile. 
Actually, I have to amend my last comment, there are a few subtle benefits to doing it this way even when the function never changes... When I type the dot operator in my IDE it brings up a list of available members, which not only reminds me what functions/variables are available in the class, what their names are (and how I spelled them), but also lets me type a few characters and then tab to auto-complete. Also, it expands the namespace by allowing me to have two function pointers with the same name but in different structs used for different purposes. Suppose I had a similar struct for the SPI bus, I could have SPI.Write() as well as Disk.Write() and even UART.Write() and LCD.Write()... I suppose it would be just as easy to replace those dots with underscores though... but this way helps reinforce that naming convention rather than relying on me to use a consistent naming convention across multiple years of development.
If I'm not having to follow someone else's style, "indent -kr -i8 -l80".
The only code that I consider 'hard-to-read' is one where there's no indentations whatsoever. Or, where a single function does so many things, I've to actually scroll up and down many screens just to understand what the fuck is this function trying to achieve. Believe me I've worked with code like that, and the day you have to deal with that kind of shit, you would love any beautifully crafted code, disregard of the coding style used.
Personally, my editor (vim) can autocomplete for me on '_'. So if I wanted to completely the 'network_' functions, I'd type 'network_' and then hit tab, and I'd get a drop-down of all the functions in that list. As you noted, with my naming it would be disk_write, spi_write, uart_write, and lcd_write. In this case, your usage may either have a practical benefit or just confuse the reader. It has a benefit if you're actually using the same struct for all of those setup's (In which case, it falls into the use case of a bunch of things using the same interface). If it doesn't though, then you're just left to keep the struct function pointer names constant instead of the function names (Which isn't exactly an improvement IMO. There's not much difference between the two). It also would then have the disadvantage of making them look as though they're compatible structs even though they're all actually incompatible. If you've ever written any code in an actual OOP language, the second case I'm talking about would be like having an identically named function across multiple objects, but never putting it into an interface. So it seems like should be able to use one object in place of another through an interface, but in reality it's impossible without some extra work. Also I have a question - Are you planning on putting the function pointers into each object of that type, or having one global struct for the function pointers for each type? I just ask because doing it the second way kinda defeats most of the possible benefits of this approach.
Yeah, there is C++.
This is permitted in C. In C11 there is a footnote [explicitly](http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_283.htm) permitting it. In C99 and C89 the language was unclear. Beware that the [strict aliasing rule](http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html) applies to all reinterpretation other than directly using the named union members, e.g. this causes undefined behaviour: Uint32 *p = &amp;u.my32; float *q = &amp;u.myFloat; *q = 5; printf("%u\n", *p); Another possible pitfall is that there may be trap representations. For example if your int's representation is not a valid float representation then it causes undefined behaviour to try and read the float. (I think this can't happen in IEEE754 though). In C++ , union reinterpretation is not permitted at all, and only the last-written member may be read. 
Dereferencing `void *` is not permitted! 
The pointer version causes undefined behaviour by violating the [strict aliasing rule](http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html). You can use `memcpy` to get around the rule,e .g.: uint32_t x = 5; float y; assert( sizeof y == sizeof x ); memcpy(&amp;y, &amp;x, sizeof y ); 
Linux kernel style, except that I indent with four spaces instead of a tab for easier alignment. Here's an example from a text editor that I'm writing: int u8_char_length(char c) { if (!is_u8_start_byte(c)) { return -1; } else if (is_u8_ascii_char(c)) { return 1; } else { int num_bytes = 1; int mask; for (mask = (1 &lt;&lt; 6); c &amp; mask; mask &gt;&gt;= 1) { num_bytes++; } return num_bytes; } }
The C99 final publication actually does include the same footnote. Only the n1124 draft lacks it.
The serial port driver in the Linux kernel uses something similar to this. If you want to implement your own serial port driver, you implement a few functions, and then provide a structure containing the function pointers to the basic driver. I’ve seen it in a few other places as well. It’s a useful tool, but you shouldn’t use it just to use it.
My style approaches madness. I only know a few people outside of my team who use this particular style - I don't even know its name, but here is what it looks like: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //============================================================================= // // NAME: somefile.c // // DESC: Does very little // // ARGS: stuff that goes in // // RETN: stuff that comes out // // HIST: dev13 - created 2014-10 // //============================================================================ // Copyright (c) - Widgets, Gadgets, Gidgets and Wadgets LLC, 2077 //============================================================================ //2345678901234567890123456789012345678901234567890123456789012345678901234567 //---------------------------------------------------------------------------- // // NAME: main // // DESC: program entry, functions get this flowerbox as a header // // ARGS: something that goes in // // RETN: - // // HIST: dev13 - created 2014-10 // //---------------------------------------------------------------------------- int main(int argc, char *argv[]) { //------------------------------------------------------------------------- // variable declarations are sorted by data type and then again by name. // non alphanumeric characters don't count. // // The assignments are then aligned. // // Depending on compatability rules, these comment declarations may // have to be done as /* */ but it doesn't matter so much these days. //------------------------------------------------------------------------- int i = 0; int rc = EXIT_SUCCESS; char count = 10; char *nothing = NULL; //------------------------------------------------------------------------- // always indent by 3's. // // switch and case statements indented 3 // then the contents are indented 3 more. // use plenty of whitespace //------------------------------------------------------------------------- switch(argc) { case 1: printf("Usage %s: &lt;something&gt;\n", argv[0]); break; case 2: printf("The argument as %s\n", argv[1]); break; } //------------------------------------------------------------------------- // important stuff should get a flowerbox like this. // always space out operators. // never more than a paragraph of lines without vertical whitespace. //------------------------------------------------------------------------- if (argc &gt; 1) { if(! strcmp(argv[1], "foo")) { printf("%s\n", "bar!"); } //---------------------------------------------------------------------- // don't cuddle elses, there should be a comment here //---------------------------------------------------------------------- else { printf("%s\n", "ack!"); } } //------------------------------------------------------------------------- // always compare with the constant on the left, it avoids the // accidental assignment. //------------------------------------------------------------------------- if (NULL != nothing) { printf("This shouldn't have happened\n"); } //------------------------------------------------------------------------- // the single semicolon loop. //------------------------------------------------------------------------- while(count --) ; return EXIT_SUCCESS; } 
Personally I use Kernel style, but with a tab width of 4 instead of 8. However, I'll adapt whatever style is used in the project if I don't have a say in it.
Animals who know that other people set their tabs differently.
That's commonplace in most linux drivers
Horstman (sp) 
God saw the light, that it was good. God divided the light from the darkness. Then he made the one true brace style and saw that it was very good. All joking aside. I've been programming for about 15 years now, and I use 1TBS. It's the most efficient in my opinion, which is the core of any good programmer. I evolved from Allman to GNU to K&amp;R to 1TBS. I must say I like 1TBS the most. I do scoff a bit at people who use any other style aside from Allman, GNU, K&amp;R or 1TBS. Because they all seem really weird. But using any style but 1TBS now is like wiping with a pinecone, it's painful. 
I don't, I don't use K&amp;R function definitions. But if I had to, probably something like this: char * foo(a, b) int a; char *b; { ... But then again, back when I still used K&amp;R function defs (I still have about 130kB of code in that style), I was using the GNU style indentation, dark days :).
By combining your example, with [this](http://snaipe.me/c/modules-in-c99/) one could write in such away that it could be bi-directionally translated between C99 &amp; C++.
Yeah, it seems pretty usable, although because you're doing it without pointers, there would be a lot of duplication if you had a lot of these structs. Normally I'd habitually make a single instance of the appropriate read/write functions for each type of disk, and then reuse that with a pointer for each instance of that type of disk.
Why use a custom comment block instead of something standard like the doxygen format? Also, why is there history and date information in your comment blocks? That's the whole point of source control.
I am also mostly using the 1TBS but it's because I mostly used C-like languages that suggest this style (Java, Javascript, C# ... ). Of course I appreciate the space efficiency of the style, but I could uderstand that for some of hte people that are reading my code the easiness in understanding the code is one word wrap away.
Because 1. Just because Doxygen is a defacto standard doesn't mean its not shit. Other things do exist you know. 2. Not everyone has access to the source control comments when the code is distributed. 
`#define` doesn't do anything with data types at all. It doesn't declare variables or anything like that. It is just a search-and-replace before the compiler gets your code. Saying `#define PI 3.14159` will literally just replace `PI`, everywhere that token happens to appear in your code, with `3.14159` before the code is given to the compiler. The compiler never sees `PI` at all: it just sees the number `3.14159` wherever `PI` had been.
It doesn't. #define is part of the C preprocessor; it simply replaces the source with the target, and after that the text is parsed. This is why macros should be used sparingly.
Fun fact, c++ internally implements classes like that. The data structure you're talking about is called a virtual table. It's a powerful concept. 
aaychat, it's also worth noting that this "search and replace" behavior can have unintended consequences... For example, the code [here](http://pastebin.com/fjiKJGkU) does not output: 4 40 as you might expect, see if you can find out why. The above code is compiled and executed with: gcc evil.c -o evil; ./evil 
GNU style ... *shudders*
The second call to printf prints -23 on the terminal. I have no idea as to why.
Got it. Thanks :)
Got it. Thanks :)
Because the line #define evil_macro_from_hell(x,y) x-y states that this code evil_macro_from_hell(i,j) is to be substituted by this i-j which results in this code output2 = i-j*10; i=7, j=3, which gives us 7-3*10 = 7-30 = -23 (since multiplication is evaluated before subtraction).
Nah, C++ is for kids, real programmers (who are not completely insane yet) use C.
In short... it doesn't. It is a direct replacement of code. You can do this... (but shouldn't!) #include &lt;stdio.h&gt; #define END ; #define OPEN { #define CLOSE } #define FUNC void #define L ( #define R ) FUNC main L R OPEN printf L "hello world!" R END CLOSE which will translate too... void main ( ) { printf ( "hello world!" ) ; }
How dos this handle situations where there are multiple I/O controllers of the same type on your chip? I assume that since this is C, "this" isn't passed into the callback functions, so how do you access the Address field inside Disk_Struct (without making it global) to know where the controller's memory mapped I/O is located? (sorry, maybe I'm not reading carefully enough) Otherwise it looks neat, I write a lot of C code meant to be generic in a similar fashion -- have you seen http://www.cs.rit.edu/~ats/books/ooc.pdf ?
Here's another example where preprocessor macros can behave unexpectedly: #define MIN(a, b) ((a)&lt;(b)? (a) : (b)) That's quite a typical way to implement the min function. Compared to `evil_macro_from_hell`, it has parentheses all over the place, so operator precedence is no longer an issue. Can you guess the problem? Hint: What happens when one of the arguments is a function or an expression like `variable++`? There's a fix for that (apart from defining a proper function), but it involves compiler specific directives. See [this](http://stackoverflow.com/a/3437484/182689) if you're interested in it. Edit: Here's some [sample code](http://ideone.com/jEG7LM).
I can't stand seeing function declarations/defintiions as: `void (*Flush)(); `. The caller can pass an unbounded(?) list of parameters. What you want is `void (*Flush)(void)` if arguments should not be allowed. Just irks me.
And in most non-trivial operating systems that's written in C. 
Huh... TIL. What physically happens if they try to pass parameters, they get loaded to the stack but never referenced? There is no compiler error/warning for this?
Bourne C, everyone's favorite...
Not exactly sure, have to pull out the standard, [but here is some discussion](http://stackoverflow.com/questions/5929711/c-function-with-no-parameters-behavior).
&gt; I'd habitually make a single instance of the appropriate read/write functions for each type of disk, and then reuse that with a pointer for each instance of that type of disk. Yes that's what I am doing. I query the hardware as a preprocess when the instrument turns on and depending on what I find I set the various read/write function pointers to the correct functions for that hardware.
Fixed that for you: &gt; network_node-&gt;add(new_net); &gt; &gt; Instead of this: &gt; &gt; network_add(network_node, new_net); 
It's the same way varargs works actually (for x86 anyway). Basically, for x86 calling convention, the caller handles the stack. So as long as you clean it up afterward (which the compiler does automatically) you can call a function with any number of parameters and it will still work. As far as C goes, the first parameter you supply to a function will be on the top of the stack, and then go in descending order with the rest of the arguments. Since the caller will only read from the top of the stack down until it has all the arguments it expects, you could give it any number of arguments and it wouldn't care. That said, there's no warning because there's an implicit assumption that you know how many arguments Flush is expecting and will call it correctly. So using `void (*Flush)()` then allows Flush to hold pointers to a bunch of different functions which may have different argument requirements (Though you'll have to do something like a switch() to make sure you call it correctly). It's also worth noting that we're talking about x86 calling convention, the C standard will give you many many less guarantees, as will other calling conventions. But a fun fact, this will probably work if you compile on an x86 system: #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; void bar(const char *arg1, ...) { va_list args; va_start(args, arg1); vprintf(arg1, args); va_end(args); } int main() { void (*foo)() = (void(*)())bar; foo("Test: %d\n", 20); return 0; } Where the above calls a varargs function by using a unspecified parameter list function pointer. I can almost guarantee you that it's an abuse of the x86 way of doing things and unlikely to be standards compliant code, but it does still work.
Sorry, you are right, was reading js code beforehand and probably mixed it up.
&gt;&gt; I'd habitually make a single instance of the appropriate read/write functions for each type of disk, and then reuse that with a pointer for each instance of that type of disk. &gt; Yes that's what I am doing. Umm... no? (I'm on a PC now instead of my phone, so I can respond more verbosely :-) ) You have this: typedef struct { void (*U8)(Uint16); void (*U16)(Uint16); void (*U32)(Uint32); void (*Structure)(void*, Uint32); void (*Flush)(); Disk_ReadWrite_String String; Disk_ReadWrite_Array Array; }Disk_Write_Struct; typedef struct { Uint32 Address; Uint16 Type; Uint16 Endianness; Disk_Read_Struct Read; Disk_Write_Struct Write; }Disk_Struct; Disk.Address = ADDRESS_USERFILES_START; Disk.Write.Structure(CurrentFile, sizeof(CurrentFile)); Disk.Write.Flush(); Disk.Read.Structure(LoadedFile, sizeof(LoadedFile)); But if you had hundreds or thousands of these `Disk_Struct`s, you'd end up wasting space because each `Disk_Struct` is 64 bytes (assuming 4-byte pointers). Instead, you could do this: typedef struct { void (*U8)(Uint16); void (*U16)(Uint16); void (*U32)(Uint32); void (*Structure)(void*, Uint32); void (*Flush)(); Disk_ReadWrite_String String; Disk_ReadWrite_Array Array; }Disk_Write_Struct; typedef struct { Disk_Read_Struct Read; Disk_Write_Struct Write; }Disk_IO_Struct; typedef struct { Uint32 Address; Uint16 Type; Uint16 Endianness; Disk_IO_Struct *IO; }Disk_Struct; Now you only need to allocate one `Disk_IO_Struct` per type of device, instead of duplicating the function pointers for every single device. `Disk_Struct` shrinks from 64 bytes to just 8. The code to use it isn't that different; it now becomes: Disk.Address = ADDRESS_USERFILES_START; Disk.IO-&gt;Write.Structure(CurrentFile, sizeof(CurrentFile)); Disk.IO-&gt;Write.Flush(); Disk.IO-&gt;Read.Structure(LoadedFile, sizeof(LoadedFile)); As far as whether it's a good idea... you're on an embedded system so I assume you are probably familiar with a lot of the pros and cons already. :-) Using a function pointer costs a few more cycles, but since you're using it for storage I/O, the cost is probably negligible compared to setting up and waiting on the I/O transfer. The biggest thing I'd be worried about is memory corruption. If somebody accidentally stomps on your `Disk` struct, they might overwrite the function pointers. Then the next time you try to perform I/O, at best you end up in the middle of a strange function, and at worst the whole system crashes because your `PC` register is sending you to an invalid instruction address.
The one my company tells me to use. It's not my favorite, but it's not going to change anyway, so no point wasting energy complaining about it. Much bigger fish to fry.
Oh, I see what you're saying, thank you for the clarification. It is more efficient but it's not a concern for me as I'll only ever have one instance of Disk_Struct, a global named "Disk". I populate the function pointers based on the installed hardware which I discover when the instrument turns on. &gt;If somebody accidentally stomps on your Disk struct Yeah that somebody would be me, I'm the only developer for my company. Not that that hasn't happened before...
Can we see a pic of your PC? I want to see what monitor is tall enough to fit all that on the screen. My company has function comment blocks that are similarly verbose, and it drives me bonkers. Nobody here likes them, and we've been slowly moving towards something closer to Doxygen style. * Putting the name of the function or name of the file is redundant. If I want to know the name of the fuction, I'll just look down a few lines. * Putting the history of the function or file is *very* useless. That's what source control is for. Since the file won't contain its own previous revisions, having a description of what changed seems of little value. * The flowerboxes and extra white space seem like a waste of space. Your function only has 28 SLOC, but it doesn't fit on my screen. I imagine it's a nightmare trying to read through source.
&gt;&gt; If somebody accidentally stomps on your Disk struct &gt; Yeah that somebody would be me, I'm the only developer for my company. Not that that hasn't happened before... That's no reason to not write more bulletproof code. :-) If you do this using a pointer to a struct of I/O functions for the driver, then the struct can probably be declared once, const. At a minimum, this will probably put it in a different area of memory where it's less likely to get stomped on. At best, it will put it in a region that's enforced read-only, so writing to it would cause an error which would immediately help you identify your rogue pointer. Of course, the pointer to this struct from inside `Disk_Struct` could still be corrupted, so it may just be putting off the inevitable.
&gt;(without making it global) It's global, and yeah the lack of a "this" member is an inconvenience.
You can specify which to use though, for example if I want to make sure a constant defined value is treated as an unsigned 32-bit value I would do this: #define VALUE 25ul Since this is a definition and all the definition does is replace itself with the value in code you can of course add those suffixes to any literal value in your code to force the compiler to treat the value in a specific manner.
Other than the added time the preprocessor will take and everyone who ever reads your code hating you is there a technical reason not to?
Afraid of looking like a dinosaur at age 30? WTF
The first person to ever use the TLDR correctly! It goes at the top.
A semaphore is a counter. You can increment V() or decrement P() from it. There are 2 types of semaphores (that I am aware of), counting and binary. Counting is essentially as the name says, it counts how many locks have been acquired. In this analogy, me and you can be playing a game with a pile of 5 jelly beans. You P() or take a jelly bean and I do the same. Let's say there are no more jelly beans, but you want one more, what will happen is you will wait until the pile has more jelly beans. In this case you have to wait until I am done playing with the beans (V()) and return one or more to the pile for you to use or eat. Binary is a subset of counting but you have 2 states, 0 or 1. There's only one jelly bean to play with.
https://www.youtube.com/watch?v=RYDsI5mP-V8
You might find [this](https://github.com/DSMan195276/cmips) project that I've been working on useful to look at. The Makefile does what you describe, allowing sub-folders containing .c files which then get compiled down and the entire thing linked together. This example is slightly more complex then what you're asking for since my Makefile compiles multiple programs by linking together different object files. The basic idea (Ignoring how the main Makefile works) is that every directory containing code contains a 'Makefile' (Like [this](https://github.com/DSMan195276/cmips/blob/master/src/parsers/Makefile)) which describes what is inside that directory (and how to compile it). In the linked example, we specify a single object (Which corresponds to a .c file - .c files will be compiled into .o files automatically) and also a subdirectory. The Makefile then looks in all the subdirectories specified and loads *their* Makefiles and runs them as well. The above just builds a 'tree' in the Makefile, which basically results in rules for every .o file being generated. There are also .o files generated from the objects in every directory. So for directory 'dir1', there is a corresponding 'dir1.o' object which is all the objects in dir1 linked together. Then it's just a matter of saying that executable 'a' is made of object files b.o, c.o, and d.o. Then when you compile 'a', it automatically compiles b.o, c.o, and d.o, which usually correspond to top-level directories which kick-off the compilation of everything inside those directories. As for design - You'll notice I have header files in several different places (The project folders like 'src' as well as the main 'include' directory). The main idea is defining which pieces should be able to see what. The main 'include' directory is accessible by all the code in the repo, where as the headers inside of the project folders are only accessible inside of those projects or folders. So the result is that the global functionality that each piece exports goes into the 'include' directory, and the internal functionality goes into the project directory. Examples: [internal](https://github.com/DSMan195276/cmips/blob/master/src/emu/syscall.h) (This short header is only for use inside of the 'src/emu' folder - You can't call op_syscall outside of this code because it isn't defined). [external](https://github.com/DSMan195276/cmips/blob/master/include/emu.h) (This header defines everything for using the emulator. Any piece of code in the project can include this file. Note this file is include internally in the emulators source as well.).
I have to admit, this is a very easy to understand explanation of semaphores.
Even the decimal value I get is negative when I use large numbers
Disregard the // Convert product to binary section * I only included it because I was getting what looked like decimal values for large numbers
I recently wrote an article about just this: [C Object Oriented Programming](http://nullprogram.com/blog/2014/10/21/)
&gt; if I want to make sure a constant defined value is treated as an unsigned 32-bit value I would do this: &gt; &gt; #define VALUE 25ul That literal has type `unsigned long`. An `unsigned long` is not necessarily a 32-bit value; in fact, on modern machines it is very rare for `long` to be 32&amp;nbsp;bits (often it is 64&amp;nbsp;bits).
Its because using [] is dereferencing the pointer.
This code looks correct to me. Perhaps file a bug report with the maintainers of TCC?
Just FYI, an array-name decomposes into the address of it's first element. So the line pcharacter = &amp;character[0]; could be written more concisely as pcharacter = character;
Just because you are entering a number in binary (e.g. you type "1010101" ) doesn't mean scanf is going to see it that way. As far as scanf is concerned, that number is in base 10, and will be stored in binary1 as the number 1,010,101 and not 85 as you might have intended. So the actual bit value that gets stored in binary1 would be 11110110100110110101. You'll have a similar problem for binary2. So, as you can imagine, you'll be looping/multiplying/shifting a lot more than you probably expect. That's the crux of your problem. Why not scan the binary numbers in as strings and then convert them to numbers that way? You know that a single binary number can't be more than sizeof(long) bits, so you can allocate a char array big enough to hold that many. Then just simply convert that to an int: char binary[65]; scanf(" %s\n", binary); binary1 = 0; i = 0; while (binary[i] != '\0') { binary1 &lt;&lt;= 1; if (binary[i++] == '1') binary1 |= 0x01; } * Edit: Thanks for the gold :)
Up until VS2013, virtually no C99 features were supported by the MS toolchain. VLAs still aren't supported even in VS2013. If you're using any part of the MS tools, you have to be very aware of what features you're using.
If it belongs at the top, why wouldn't it be TLWR - too long; won't read?
Thanks for the response! I think I understand it now. I realized (a + n)-&gt;b was being equivalent to a[n].b ,but I guess I just didn't understand why. It seems like writing a[n].b could be simpler in some cases, but is it better to write out the (a + n) -&gt; b? Or is it just a matter of preference?
&gt; but is it better to write out the (a + n) -&gt; b No. `a[n].b` is the idiomatic way of writing that, and you'd get funny looks if you used the other form. 
Compiled and ran fine on my machine with same TCC version. (Windows 7 x64) I did find out one thing though, it seems VLA in TCC is done via alloca, so maybe check that it works correctly too.
Personally, I've never actually seen sqrt(N) used for time complexity (Though it's possible it's just me). IMO, sqrt(N) and log_2(N) are so close enough that it probably doesn't matter a *ton*, but sqrt(N) does grow more rapidly then log(N) does, so there's that. I can definitely see how there would be confusion between the two though, for smaller values they look almost identical. The complexity of O(sqrt N) becomes a bit more obvious if you calculate a few of the loop iterations though: i = 0, j = 0 (Start) i = 1, j = 1 i = 4, j = 2 i = 9, j = 3 i = 16, j = 4 i = 25, j = 5 i = 36, j = 6 ... There's an obvious pattern here - i is always equal to j squared. With that in mind, you could write that algorithm like this instead: int i = 0, j = 0; while (i &lt; N) { i = j * j; j++; } When you look at it that way, the complexity of O(sqrt N) makes more sense because j is the sqrt of i and j is also the number of loop iterations you make. So with that in mind, since you're looping while i &lt; N, you'll always loop sqrt (N) times (rounded up). For example, for N = 15, you would loop until i == 16, at which point j = sqrt(i) which is 4. If you pick a bigger number, the same thing happens - We loop until i is the smallest square bigger then N, and then j (Our number of iterations) is equal to the sqrt of i. If you wanted to make a algorithm like the above that's O(log_2 N), you would actually have to use powers of two instead. So it would look like this: int i = 0, j = 0; while (i &lt; N) { i = power(2, j); j++; } Now we get this pattern: i = 1, j = 0 i = 2, j = 1 i = 4, j = 2 i = 8, j = 3 i = 16, j = 4 i = 32, j = 5 i = 64, j = 6 ... sqrt (N) and Log_2(N) are actually so close that for j == 4, they give the same answer. However, if I expanded this table for larger values of j, log_2 results in smaller values of i then sqrt (Because log_2 does actually grow slower then sqrt - meaning the j value is smaller for larger i values. [this](http://graphsketch.com/?eqn1_color=1&amp;eqn1_eqn=sqrt%28x%29&amp;eqn2_color=2&amp;eqn2_eqn=log%28x%29%2Flog%282%29&amp;eqn3_color=3&amp;eqn3_eqn=&amp;eqn4_color=4&amp;eqn4_eqn=&amp;eqn5_color=5&amp;eqn5_eqn=&amp;eqn6_color=6&amp;eqn6_eqn=&amp;x_min=-17&amp;x_max=100&amp;y_min=-10.5&amp;y_max=10.5&amp;x_tick=1&amp;y_tick=1&amp;x_label_freq=5&amp;y_label_freq=5&amp;do_grid=0&amp;do_grid=1&amp;bold_labeled_lines=0&amp;bold_labeled_lines=1&amp;line_width=4&amp;image_w=850&amp;image_h=525) graph should show it fairly well). You can tell this is a log_2 because we loop until i is the smallest power of two that is larger then N, and then j is equal to the log_2(i). So for 63, we loop until j = 6, and 2 ^ 6 = 64.
When you call a function, the value it returns is substituted for the function call in the expression where it was used, just as in mathematics. For example: int x = foo() + 42; If `foo()` ends with `return 10;` then it's as if you'd written int x = 10 + 42; If the function doesn't return a value (i.e. its return type is `void`) or if you don't care what the value is, then you write an expression that doesn't use that value: foo(); That's again equivalent to 10; That's a legal statement, but it does nothing, other than any side effects that executing the function might have produced. `printf()` for example returns an integer: int printf(const char * restrict format, ...); But it's very rare that you capture and use that value; the function is primarily called for its side effects only. FYI, you don't need parentheses around the expression you're returning. You can add them, but they're redundant. `return` is a statement, it's not a function call (which does require parentheses.)
The whole point is to save you the time of reading some wall of text. Do you really need a summary of what you just read after you just read it? Its redundant.
Thanks a bunch for the thorough and well-written explanation! I do understand it quite a bit better now. I'm still not sure that I would be able to easily tell the two apart at the exam, but I'll try to write out a number of iterations, like you did, in hopes that things become more clear. Again, thanks alot. 
It's worth noting, my algorithm was *similar*, but it was really a different algorithm because at the end 'j' is a different value (Of course it is - In the algorithm j is dependent on the iterations, and changing the complexity changes the number of iterations). I'm figuring you realize this, but I wanted to point it out that the two algorithms aren't the same in case any confusion comes from that. That said, I still see trying to change the complexity on these loops as a useful exercise and I'll try to answer your question. I do have to ask whether or not the '(i &lt; j)' was intended or not, and if it should be '(i &lt; N)'. (i &lt; j) is a bit more complicated, though strictly speaking in terms of time complexity it shouldn't *really* change anything besides putting creating a max time complexity (If we do nothing in the loop besides j--;, we'll only do a max of N loops, until the point that j == 0, so O(N) is a max complexity). So, now I'm going to cheat slightly, this is a similar algorithm but as O(sqrt N): int i = 1, j = N; while (i &lt; j) { i += (N - j) * 2 + 1; j--; } You'll notice that this is almost exactly like your starting algorithm - The only difference is I use '(N - j)' instead of 'j' to get the correct value to add, since 'j' is now counting down instead of counting up.
this is the source code I have so far. but it doesn't sort it or list them correctly.. #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define pause system("pause") #define cls system("cls") #define SIZE 200 #define MAXELEMENTS 200 //Prototype Functions Here void countArray(char character[], int numElements); //for case 3 void displayArray(char x[], int y[], char m[50]);//bubble sort function void doTheSwitch(int array[], int i, char*switchMade); main () { //Declare variables int choice; char c; int count = 0, i; char character[SIZE] = {0}; int position[SIZE] = {0}; int quantity[255] = {0}; int numElements = 0; int array[MAXELEMENTS] = {0}; int bottom, temp; char switchMade; bottom = MAXELEMENTS - 1; do{ cls; printf("\t*************************\n"); printf("\t MAIN MENU\n"); printf("\t*************************\n"); printf("\t1. Enter a single character.\n"); printf("\t2. Display quantity of character.\n"); printf("\t3. Display all characters and their counts. \n"); printf("\t4. Search for a character.\n"); printf("\t5. Quit.\n"); printf("Enter your selection: "); scanf("%i", &amp;choice); fflush(stdin); //flush switch(choice){ case 1: printf("Enter a single character: \n"); scanf("%c", &amp;c); character[count] = c; count++; quantity[c]++; fflush(stdin); break; case 2: printf("Display quantity for character: \n"); scanf("%c", &amp;c); printf("%i\n", quantity[c]); pause; fflush(stdin); break; case 3: do{ switchMade = 'N'; for(i = 0; i &lt; bottom; i++) { if(character[i] &gt; character[i+1]) doTheSwitch(character,, i, &amp;switchMade); }//end for bottom--; for(i = 0; i &lt; numElements; i++) { printf("Character - %c\n", character[i]); if(character[i] == c) { count++; } } }while(switchMade == 'Y'); displayArray(character, quantity, "The Sorted List"); pause; break; case 4: printf("Search for a character: "); scanf("%c", &amp;c); for(i = 0; i &lt; SIZE; i++) if(character[i] = c) //if character was found printf("%c was seen %i times.\n", c, count); else //if character was never seen printf("Character was not found."); fflush(stdin); pause; break; case 5: printf("Quit. \n\n"); pause; break; default: printf("Invalid Selection. \n\n"); pause; break; }//end switch }while(choice != 5); } // end main void countArray(char character[], int numElements) { int i; for(i = 0; i &lt; numElements; i++) { printf("%i", character[i]); } } //end countArray void displayArray(char c[],int q[], char m[50]) { int i, k = 1; printf("%s: \n", m); for(i = 0; i &lt; MAXELEMENTS - 1; i++) { if (c[i] == c[i + 1]) k++; else { printf("Elements %2i (%c) = %2i. \n", i + 1, c[i], k); k = 1; } } printf("\n"); }//end displayArray void doTheSwitch(int array[], int i, char*switchMade) { int temp; temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; *switchMade = 'Y'; } //end doTheSwitch
Thanks for the reaction. The (i &lt; j) was indeed intended! I took the algorithm you suggested with complexity O(sqrt N) and looked at it with concrete values like you did in your first reaction, to kind of see what's going on. O(log N) algorithm: i = 1, j = 20 (start) i = 2, j = 19 i = 4, j = 18 i = 8, j = 17 i = 16, j = 16 O(sqrt N) algorithm: i = 1, j = 20 (start) i = 2, j = 19 i = 5, j = 18 i = 10, j = 17 i = 17, j = 16 The O(sqrt N) algorithm does seem to go up quicker.. Thanks for all the help. I think I have a firmer grasp on the subject now :)
this is pretty unreadable in terms of formatting. if you want us to spend 5 minutes helping you, you can at least spend 5 minutes making your post display correctly. You also need to state what your problem is and what you have tried. Compile it with the proper flags and you will find syntax errors pretty easily: gcc -W -Wall -Werror -g -ggdb -o executable source.c 
You're definitely missing a brace (where does the while loop end?). After that, I can't help 'til you fix the formatting.
First things first: use four spaces indenting to get proper formatting of your code here. In your scanf statement put a single space before '%i' to also match the newline character that will be sent after you press enter. This is a mean catch that your instructor could have told you about. Or maybe you didn't pay attention. Either way see if it works.
Yeah, I get the logic. The wording is still incorrect for *before* the post if you use TL;DR, and that kind of wrongness cannot be tolerated.
&gt; In your scanf statement put a single space before '%i' to also match the newline character that will be sent after you press enter. This is unnecessary. All `scanf` specifiers except `%c`&amp;nbsp;and&amp;nbsp;`[]` skip leading whitespace.
The `%c` specifier for `scanf` does not skip leading whitespace.
Ah, I was 50/50 on that ;) You'll probably find telling the difference between sqrt and log easier if you look at some bigger numbers. Starting off sqrt and log are almost identical (Like what you posted - sqrt is only slightly higher) but if you keep going on your charts (even though the algorithms are technically over): O(log N): i = 32, j = 15 i = 64, j = 14 i = 128, j = 13 i = 256, j = 12 i = 512, j = 11 i = 1024, j = 10 O(sqrt N): i = 26, j = 15 i = 37, j = 14 i = 50, j = 13 i = 65, j = 12 i = 82, j = 11 i = 101, j = 10 They're close in the numbers you posted, but if you keep going it gets pretty obvious that log N's 'i' is going up much faster, with log N doubling every iteration. Like I noted, a bit bigger numbers may help. If you were to try to do this algorithm with N = 512, it'd be really easy with the log N, but you'd probably never finish if you tried it with the sqrt N. Beyond that, analyzing and looking for patterns in the number of iterations can be a good indicator of the O(). And no problem, I'm always happy to help :)
Yeah I confused it altogether. The problem was repeatedly using *scanf* and yes %c doesn't skip whitespace.
Semaphores aren't very complicated. It's just a counter that's bounded so that your thread will block if you try to decrement it below 0, and is thread-safe so that multiple threads can safely manipulate it at the same time. The question is, why would you want such a thing? The answer is that it's a very useful building block for implementing multithreaded code. If you're using threads, where all threads in the same process share the same address space and can see each other's memory, using a semaphore as your only primitive you can build: * mutexes * read-write locks * barriers * conditions/signals * thread-safe structures, like queues or pools
Discrete event simulation
Build a tool that parses something. `something' could be a subset of xml, ini files etc. A friend of mine wrote a parser that generated output in postscript to illustrate relationships between whatever it was he was parsing. Build a simple interpreter Build a compiler How would you find the shortest path to your destination (ie start the backend to Google Maps) Just use your imagination :)
&gt; Personally, I've never actually seen sqrt(N) used for time complexity [Grover's algorithm](http://en.wikipedia.org/wiki/Grover's_algorithm) for searching in unordered lists is O(sqrt(n)), but it only runs on quantum computers. That's the most interesting example I know of. Primality testing can be done in O(sqrt(n)) as well, if you consider n as the integer to be tested, though usually you'd rather use the number of bits, which then leads to an exponential time complexity (unless you're fine with doing it in a probabilistic fashion, in which case you have Miller-Rabin as an option).
I've always loved writing an equation interpreter. Basically, the idea is that reads in an equation like "1 + 2 * (4 - 23)" as a string and then spits out the answer. I've written a few of them, and the very basic idea is using the [shunting-yard algorithm](http://en.wikipedia.org/wiki/Shunting-yard_algorithm) to convert your input into RPN notation, and then from there evaluating it (Evaluating RPN is very easy). The useful part for you is that the Shunting-Yard algorithm uses a stack and a queue (Though the queue isn't exactly necessary, it's just for storing the output). After that, [RPN evaluation](http://en.wikipedia.org/wiki/Reverse_Polish_notation#Postfix_algorithm) is also stack based. Personally, I've found it to be a pretty fun to write back when I was just starting to learn about algorithms and etc. since the result is kinda cool and the algorithm is simple enough that you can get a good implementation just following the details on the Wikipedia page. It's also cool that it can be done in a relatively small amount of code.
Just to make sure I understand the question: you currently have: int arr1[3] = { 1, 2, 3 }; And want to output "123"? If all you care about is the printf, the easiest way is: printf("The string is "); for ( int i = 0; i &lt; 3; i++ ) printf("%d", arr1[i]); printf("\n"); On the other hand, if you really need a separate string with those numbers, you could use sprintf with the same results: char string[100]; for ( int i = 0; i &lt; 3; i++ ) sprintf(string, "%s%d", string, arr1[i]); This is kindof a stupid way to do it, though. I gave it a huge buffer (so that I wouldn't overrun anything), and using sprintf to concatenate like that is kinda unnecessary. A better solution would probably use snprintf and do some smart allocation so the buffer is always the right size. I'll leave that as an exercise to the reader. **EDIT:** So, I missed the undefined behavior of copying a string onto itself. Instead, here's a full version that does the allocation I described. *I dare you* to find something wrong with this one. I dare you all! int arr1[] = { 1, 2, 3 }; char *string = NULL; size_t length = 0; for ( int i = 0; i &lt; sizeof(arr1)/sizeof(arr1[0]); i++ ) { size_t count = snprintf(NULL, 0, "%d", arr1[i]); string = realloc(string, length + count + 1); length += snprintf(string + length, count + 1, "%d", arr1[i]); } free(string);
I'm confused about what you have. Does array[3] contain "1,2,3" or does each entry in the array contain a number: array[0] contains "0" array[1] contains "1" array[2] contains "2" ...?
Yo thanks man! You have no idea how much this helped me. Thanks! 
If `arr1` is defined as `int arr1[3] = { 1, 2, 3 };`, this won't work.
I thought they were character literals, my bad. So add 48 to them char str[4]; i=0; while(i++ &lt; 3) str[i] = arr1[i]+48; str[3] = 0; Fixed.
No, I meant what I wrote. but you could do something like `offset += sprintf(string + offset, "%d", arr1[i])` instead.
What happens when array[i] = 10, or any integer greater than 9?
Using `sprintf` like that is undefined behaviour, see §7.19.6.5(2): &gt; ... If copying takes place between objects that overlap, the behavior is undefined. Also, even if it were defined, you have not initialised `string` before passing it to `sprintf`, so there is undefined behaviour there as well.
"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)" Hmm. I wonder if I can just skirt by without reading this. Something's telling me it's a little bit important, though.
Just finished reading it. Thank you so much for the link! But I still don't know what to do. I have experience in C but I'm by no means an expert. Do I have to make my own header file that individually defines every possible Japanese character based on its Unicode value?
Preferably add `'0'`, then your code doesn't depend on the character set.
`sprintf(string, "%s", string);` causes undefined behaviour (similar to `strcpy(s, s);`). Standard ref is C99 7.19.6.6/2, &gt;If copying takes place between objects that overlap, the behaviour is undefined.
What, I forgot to initialize that string? I can't believe I did that. Ok, time to put in a full solution.
While interesting as an experiment, I think translating a language is a bad idea. Any code written for a japanese-C compiler will be incompatible with regular C compilers. Considering the low number of words (and assuming the purpose of translating C is to make it easier for people who don't know english) I think it's better to just learn that bit of english (or at least the shorter C adaptations, like int, char), to avoid fracturing a programming language. Unicode support in function/variable names sounds good though, as long as it works with the symbol names for linking.
So three things 1) I totally agree. I'm writing this both as a fun project, and as a tool for a seminar I will be doing next year. I want to demonstrate to my fellow students here in Japan that you don't need to learn English to program. This is only going to be for education purposes and no serious coding should be done on it. 2) What do you mean by "as long as it works with the symbol names for linking."? 3) Based on my new understanding of Unicode, C isn't the best language. D supports every Unicode character (yes /every/ last one) right out of the box, so while it isn't as commonly used of a language, I think it will be perfect for this project. I also hope this means I won't be fracturing C like you mentioned. Example1: http://ideone.com/M0Z1Gm Example2: http://ideone.com/AfoYN6
IMO you'd just be better off writing some preprocessing utility that takes C source code with the CJIK keywords, translates those into their English equivalent, translates every CJIK character in a function or variable decl to some sequence of Latin characters (according to some fixed mapping) and then running that through gcc or whatever you're using
Plan 9 C compilers [support Unicode out of the box](https://i.imgur.com/Zon0z8m.png) so you may want to look at those.
Having actually done this kind of thing before myself. It doesn't matter what language you do it in, since C also support wchar_t. First, you should be using UTF8 file formats. Everyone can support this these days, but you might need to adjust your display settings and make sure you have the fonts installed. Second, there is an escape sequence for everything for when you can't. http://www.rapidtables.com/code/text/unicode-characters.htm 
Semantics aside, even after you were told he is using an array of ints instead of chars, you corrected your code accordingly but only for the explicit case stated for 1, 2, 3. Your code snippet does indeed for for single digit integer values, and is a clever way to convert a single digit number to ascii. However, it would be more appropriate to handle all possible cases for the int values, not just 0-9. 
~~you mean '\0' for the null character.~~ Edit: nevermind, my brain processed the post wrong.
&gt;&gt; Putting the name of the function or name of the file is redundant. If I want to know the name of the fuction, I'll just look down a few lines. &gt; And if the comment block or function gets moved, you could have some confusion there. That's a spurious argument, which amounts to "If there's a mistake, it could be confusing." That's true of *any* mistake. Someone could also change the name of the function but not update its comment block. Or copy/paste a function or comment block to create a similar one, and not update the function's name in the comment block. &gt;&gt; Putting the history of the function or file is very useless. That's what source control is for. Since the file won't contain its own previous revisions, having a description of what changed seems of little value. &gt; Its not what changed, its what happened to it, including things such as validation and code audits. Okay, that's different. Although it still only has limited value... knowing the function passed a code audit 2 years ago doesn't tell me anything about its status now, because I have no way of knowing from just the source file whether the function has been changed since then. &gt;&gt; The flowerboxes and extra white space seem like a waste of space. Your function only has 28 SLOC, but it doesn't fit on my screen. I imagine it's a nightmare trying to read through source. &gt; That is close to their actual purpose; To break up visual space. Too much code too close together is harder to read and harder to work with, especially when the code becomes unfamiliar over time. So put whitespace in your code. These flowerboxes, aside from not being white, are relatively time-consuming to make. You truncate all of them at 80 characters, which means every time I want to type any single comment, I need to carefully hold the `-` key and type the correct number of hyphens, or find another flowerbox to copy/paste and then edit because it might be at the wrong indentation level. Compared to just banging Enter a few times, that's a pretty tedious way to get whitespace into some code. But anyway, you're right, it's a matter of preference. As I commented separately, I follow my company's style because that's my job... it's not my favorite, but I've got bigger fish to fry. :-)
The book most people recommend is K&amp;R2, which was released in 1988 and it's still relevant, because it teaches the language rather than best practices. Everything else could be learned from the standard, by experimentation and by reading good code.
\*ahem\* &gt; you don't need to learn English to program Respectfully... bullshit. Sorry if I'm about to come across as an ethnocentric American, but understand that I studied Japanese language for 4 years in college, including 6 weeks at Fukuoka University. And I currently work at a company that has a lot of Korean customers, who I regularly email with and sometimes work with in person. More than any other STEM field, English is *the* universal language for programming. Pretty much *all* programming languages use English as the basis for their keywords and names of standard library functions. Documentation for software libraries ranges from very good to poor, but regardless it's almost always written in English, and only if you're very lucky translated to other languages. I can't find a source for it, but someone once asked Linus Torvalds why he implemented Linux entirely in English (he's a Swedish-speaking Finn). He answered, it never occurred to him not to. It was a programming project, therefore it belonged in English. A few major projects have Japanese documentation, such as [iOS](https://developer.apple.com/jp/devcenter/ios/library/japanese.html) and [Linux](http://www.tldp.org/links/nenglish.html#japanese). Others have "unofficial" translations, like the [Windows API](http://wisdom.sakura.ne.jp/system/winapi/win32/). But many others have no Japanese translation at all. [Android](http://developer.android.com/intl/ja/reference/packages.html) has a menu for switching languages, but the only thing that changes is the navbar at the top of the page. Everything else is still in English! Bottom line, you *cannot* expect to be a good programmer without being able to read basic English. It might be helpful for introductory students to have a programming language just for teaching basic concepts like loops and structures, which could be usable in one's native language. I picked up programming naturally as a child, because "FOR I% = 1 to 10" was naturally understandable as an English speaker. That's an experience that non-English speakers don't get. But to have a career as a programmer, no... you *must* have at least a basic grasp of English.
No, '0' - '9' are contiguous, so adding a single digit number to '0' gives you the corresponding digit character. (Assuming you're not using EBCDIC)
Let's assume for a moment that you chose UTF-8 as your file encoding. It's widely used, it's compact, and it guarantees that you won't have null bytes in the middle of a string. C89 only allows ASCII characters in identifiers. This means A-Z, a-z, 0-9, and _. The UTF-8 characters would appear as 8-byte characters, even if (mis)interpreted in a native codepage, like "é". That's not valid in a C identifier. The C Preprocessor follows the same rules AFAIK, so doing something simple like #define メーン main isn't going to work. Even if it did, the preprocessor can't preprocess itself. You can't do #define SOME_FILENAME &lt;stdio.h&gt; #include SOME_FILENAME I don't know if later versions of C changed this, but I kind of doubt it. So you only have two choices if you want to support this: * Find a compiler that supports non-ASCII identifiers as an extension. But that won't solve your problem of wanting to change the preprocessor directives and names of header files. * Write a separate tool that reads in a file, and "translates" it to an output file that's all standard C and C preprocessor. Since it's just translating in place, no real parsing is necessary, so you could probably do it with sed or Perl. For translating variable and function names, you'd have to generate a swizzled name, unless you limit users to a predefined list of allowed variable and function names.
 arr1 [3] = "1,2,3"; That's not valid C, because there's no type specified. Let's change that. char arr1 [3] = "1,2,3"; That's still not valid, because you're declaring an array that holds 3 bytes, but you're giving it 6 bytes of data. Strings are arrays, so you're trying to assign { '1', ',', '2', ',', '3', 0} to an array that's only supposed to hold 3 elements. What you want is either char arr1 [] = "123"; or int arr1 [3] = { 1, 2, 3 }; If you do the first one, then you can just do `printf("The string is %s", arr1)` and get the output you want. If it's the latter, then you need to loop over the array and convert each value to a string representation, like `printf("The string is %i%i%i", arr1[0], arr1[1], arr1[2])`.
Remember that C has standards that evolve in a decade basis or so. This book might teach C89 standard. Aftar that, you'll have to update to C99 and C11, which is the latest.
Okay, szo you beat me to it ziss time. But chust wait, doctor Jones, Vee shall see who laughs last.
Right, I read the post wrong. I thought he was talking about terminating the string with the null character. Missed my coffee this morning.
IIRC at least C11 has provisions for supporting non-ASCII identifiers, possibly C99 as well. It’s not terribly well- or consistently supported, though.
If you change around the order of your tests, does it make a difference? I would test for !isalpha() first, then wrong case, and then for higher or lower. And I'll bet this will be informative as to the cause.
Yeah that does mess with it. Let me play around again and I'll come back with the results.
Ok so I took out the bufferGuard bit but it still doesn't work quite right. I think it still has something to do with newline characters. Any ideas?
Yes, if the user is pressing enter then you still need to consume the newline character(s) from the input stream. But you can't assume that the newline will be exactly one character for all systems. Do you know what character(s) to expect if newline is one character vs. if it is two characters? Understanding that is a good place to start.
I do not know. What is a better way to consume any extra newline characters? Is it possible to be prepared for multiple amounts of them?
That's precisely what's happening, I think. The solution is to clear out your input using something like: while((c = getchar()) != '\n' &amp;&amp; c != EOF) /* Just eat it */; Or you can change your `scanf("%c", &amp;guess)` to read in the whole line as a string (and then just use the first character).
on 2. I figured maybe symbol names need to be in ascii, so they would need to be mangled somehow. I don't really know what I'm talking about here though. good luck with the project and seminar :) (but I have to agree with /u/BigPeteB, a *lot* of existing code is in english, both symbol names and comments)
you could always do a porno simulator where you insert the dong into a queue and see how long you last until you dequeue
I'm not sure what your remaining problems are (if you'd like help with that, repost the code properly indented so Reddit displays it properly or, even better, upload it to a pastebin site), but lines like `fflush(stdin);` make no sense. See [this](http://c-faq.com/stdio/stdinflush.html).
The C standard does not (and did never) specify the source code character set, only which characters it is supposed to contain. Nobody implements a C compiler with UTF-8 as the source encoding though. For instance, IBM System-Z C compilers take sources encoded in EBCDIC.
I don't get it? what are those?
https://www.youtube.com/watch?v=0j74jcxSunY
I appreciate your comments, I really do but I think you're missing the point. This isn't "The Next Big Thing" in programming. I'm literally just presenting to a bunch of Japanese high school students about my career and I thought it would be fun if it was all in Japanese. If I just used plain C I'm sure they could all follow as they do all speak a little English, but wouldn't it be cool if they could read the words and understand them on their own as you an I can do with the words "double" and "main"? If any students come up to me afterwords and want to learn more I'll gladly explain the impracticality of using Japanese to code. Also, I'm in 福岡県行橋市! Small world, no?
Oh ok. Though don't all languages that use the subset of ASCII that is considered alphanumeric have the same order alphabet? Whatever. But what I was really getting at was i18n. What's that?
The more I learn the more this seems like the best solution. I was already going to have to try and do something similar since, as a personal challenge, I want to make my own syntax highlighter for it. So, on compile, since the highlighter will have already identified what all the characters mean, all I'll have to do is switch the words out for the proper Dlang counterparts. 
I refer you to my comment "Which alphabet?". *il18n* is an abbreviation for internationalisation; *l10n* for localisation. The numbers refer to the letters removed. Being more precise about to which things you are referring will help you with programming too. Ceci n'est pas une pipe.
I love C but I just can't recommended GTK. It's ok on Linux but if you need to port to Windows you're in for a world of pain. My recommendation and what I do at work is use FLTK.. Yes that means I am using a tiny bit of C++ for the UI but otherwise the rest of the app can be in C. Also, the type of C++ used in FLTK is not so complex compared to other C++ you might encounter.. and certainly less complex than Rust
Interesting. Thanks!
I don't think so.
Is it because a++ and b++ get executed twice because a and b are mentioned twice in the definition?
That is interesting.
The default is actually `gnu89`, not `c89`. `gnu89` contains C99 features.
I would choose C (or C++) over Rust because it hasn't hit its 1.0 yet. I know it's close, but being too early in a technology usually leads to pain. That said, I'm excited about it, so I'll be jumping in earlier than usual, instead of waiting a few years to see how the toolchain and ecosystem develops. In terms of how much easier it is to use something like perl, python, etc, it depends a bit on the problem domain. The productivity difference can be staggering for some domains, to non-existent or even negative in others. String munging and "scripty" applications of limited size are often a lot faster in the dynamic languages. There's a lot of perl one-liners or doing stuff with awk, etc, that take a lot of ritual to get done in C. As you scale up in complexity, the boilerplate that you are saved from is less true and having some type safety and flexibility start to pay off.
what kind of app?what should that do? I have experience with c development but I also have good experiences with python + PyQt4 for desktop apps, why are you considering c ?
For learning the basics? I would say no, it hasn't changed much. Also, if you like the style of the book, Deitel &amp; Deitel are onto their 7th edition, 8th edition is out in 2016.
Listen to this guy. Modern C++ gives you most of the advantages of Rust but the spec is stable, widely supported and the tooling is excellent. Just remember that if you are using raw ponters then you are probably doing something wrong. Stick to references and smart pointers. 
Agree 100%. I have used C/GTK, C++/FLTK, C++QT, PyQT, C++/WxWidgets, and C++/QT is by far my favorite for client-side GUI applications. QT has a very rich library of tools even beyond the UI features. In my opinion, programming in C++/QT is almost like programming in a higher level language due to the richness of the library and the abstraction of the Signal/Slot behaviors. 
&gt; What reasons would you choose C over Rust? It is a stable, complete language. Rust isn't 1.0 and still going through lots of changes. If your goal is to write apps (and not just have an excuse to play with a language) then the answer is fairly obvious. &gt; If experienced in C and making liberal use of modern 3rd-party C libraries, how much more productive is something like Perl|Python|Ruby, really, over C? You realize this is virtually impossible to answer right? Totally depends on the problem domain and what you are doing? If you are doing batch string processing, Perl might be 77x... if you are doing machine learning and can leverage the Python tools -- 117x... etc. &gt; Small desktop apps: C, Rust, or something else? I would probably use something else to be honest, maybe Nimrod &amp; IUP. 
In response to your second question, a scripting language is much more productive than C, simply because Python/Ruby/Perl also have many 3rd-party libraries which drastically improve productivity, much like C. Practically, C is best for system programming (not applications), but if you like to hack around in it for other uses (for fun that is, I would never suggest it for work), go ahead. I'd also suggest C++/QT4 if you want to develop a GUI in a system programming language.
But you first need to know what good code is. I'd suggest a book like [21st Century C](http://www.amazon.com/21st-Century-Tips-New-School/dp/1449327141) are really good for learning good C coding practice.
I hope very much that trigraphs will stay in the language. Breaking compatibility in such an important industrial standard just isn't worth the few hipsters you satisfy by abolishing trigaphs. Also, only the C++ guys talked about abolishing trigraphs. They will likely remain in C.
Qt/C++ is really good for GUI apps. Personally I prefer D, and `gdc` is now in many distro's repos, so GTK/D could work too. Qt bindings to D are not usable, though, which makes it a bit of a dillema (Qt is much better than Gtk, and at the same time I find D to be way better than either C or C++). For *small* apps, you might also consider Tk (with C/C++/D/Rust(?)/whatever), which is really simple to use if its features are enough for you.
If you are familliar with C and GTK+ you can be productive. But GTK/GObject creates lots of boilerplate code. Vala may be a good choice if you want to avoid that and stay close to C.
Your example isn't quite clear enough. Can you provide something with more than just commas and zeros and what you would expect the output to be?
how does one post a .c file into pastebin? lol. 
http://pastie.org/ 1. Select language in upper-right corner. 2. Paste code in text box. 3. Click "Create Paste" button. 4. Profit! :D
If you want to post code here, indent it with four spaces. This will cause the code to appear in mono-space font with indentation preserved like this: double fadd(x, y) double x, y; { return (x + y); }
Let's say the array is called A[], and 'n' is an int with the length of A. Something like this would work: int i; for(i = 0; i &lt; n; i++) { if (i != 0 &amp;&amp; i % 4 == 0) printf('' ''); printf(''%d'', A[i]); } You need the test for i=0 otherwise you'll get a space at the start. This loop will also work for strings of the form ''01011011'' if you change the %d in the printf statement to %c, although as an alternative to having a variable 'n' or using strlen(), use the loop for(i = 0; A[i] != '\0'; i++) This is because strings in C are simply arrays of char that are terminated with the escape character \0.
thanks gleon 
If you need help with your homework, perhaps you should talk with your professor/teaching assistant/other students. You are not likely to learn as much by asking strangers on the internet.
Rust seems to be everything that Ada already is; reinvent everything and foster hipster traction.
If you think that this is my first option, you are very wrong good sir. I leave it at that. 
Off topic: Is the K&amp;R declaration style still encouraged in general? In C11 code? (I spend more time in C++, so I don't tend to keep up on the C community much.)
Ah, it's been many years since I looked at C++. Thanks for the tip about smart pointers.
I like the idea of FLTK, but last time I looked it appeared to be split between multiple versions. Checking http://www.fltk.org/articles.php?L825+I0+T+P1+Q maybe things have settled on v1.3.2. No desire to port to MS Windows. 
Will take a look at Vala! Thanks!
I cannot figure out a way to format it the way that it shows up on my computer. It always corrects itself to that format for some reason. The size = size statement has been deleted. Do you see anything in either functions that would cause a bounds error though? Also space refers to an argument in the function that is a bool variable. True means that spaces are erased as well. the prototype for removeNonAlphas is: void removeNonAlphas(char arr[], int&amp; size, bool space); Thanks!
&gt; I cannot figure out a way to format it the way that it shows up on my computer. It always corrects itself to that format for some reason. It's probably some newline-character mismatch. You might try pasting your code into a different plain text editor first, then copying/pasting into the browser from there. Or put it in pastebin.com and put a link in. &gt; Do you see anything in either functions that would cause a bounds error though? Do you have more context here? Who/what is telling you you have a "bounds error"? What happens to them when they encounter it? What is their input data, and what output are they getting (or what error do they get)? What is the function prototype for erase? Also, the "int&amp; size" parm on removeNonAlphas tells me this is C++, not C (C doesn't have pass-by-reference, it is strictly pass-by-value). I assume it's declared the same way for function erase? That makes a huge difference, and another reason why you should post complete code.
Could you tell us what error you get? What exactly doesn't work? I've noticed that you include the header multiple times. Why do you do that? I've also noticed that you include the function definitions (`lb48341.c`). You shouldn't do this. Have you tried compiling separately?
Why do it in place? Why not simply copy all of the alphanumeric values in one array to another?
http://pastebin.com/tiYLefy6
Will post again soon, thanks !
You're pretty far off the mark with this assertion. Rust has a whole host of advanced type system and functional features that Ada doesn't.
&gt; the K&amp;R argument promotion rules. Ah. TIL. Thank you for the reply.
Indent your code with four spaces. It appears in mono-spaced with formatting preserved if you do that. If you clicked on the formatting help, you would know.
This is not C code. Please post C++ questions elsewhere.
Can you tell me why this code works: #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; int main() { char *command[] = {"ls","-l", NULL}; printf("This is the command: %s\n",command[0]); execvp(command[0],command); return 0; } But not this code: #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; int main() { int i = 0; char command[] = "ls -l"; char *token; token = strtok(command, " "); char *args[2]; args[0] = token; token = strtok(command, " "); args[1] = token; args[2] = NULL; printf("%s\n",args[0]); if (args[2] == NULL) printf("null"); execvp(args[0],args); return 0; } I dont understand how to take that new line character out, because I dont see how it is getting it? 
Also, I may not understand the strtok() function. When I call it with a string "ls -l", and use a space " " as the delimeter as in token = strtok(string, " "), what happens to string? Nothing? or does it only contain "-l" after the function call. How would I get this second part of the string? Is token an array too?
ls has format options as well so you 'read' into a pre formatted structure. The -w flag might be helpful See also: http://www.computerhope.com/unix/uls.htm Or man ls
Ok, so why doesnt this work? #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; int main() { int should_run = 1; while(should_run==1){ printf("osh&gt;"); fflush(stdout); char str[50]; scanf("%s",str); char *args[3]; char *element = strtok (str, " "); args[0] = element; printf("args[0]: %s\n",args[0]); element = strtok(NULL," "); args[1] = element; printf("args[1]: %s\n",args[1]); element = strtok(NULL, " "); args[2] = element; execvp(args[0],args); /* pid_t pid; pid = fork(); if(pid&lt;0){ printf("Error occured"); return 1; } else if(pid==0){ printf("executing..\n"); execvp(args[0],args); } else{ wait(NULL); printf("Child complete\n"); } free the memory allocated free (args);*/ } return 0; } I commented out the fork() and pid section just for testing..i type in at the prompt osh&gt;ls -l Output: args[0] = ls args[1] = (null) but if I use it with a hard coded char array, such as char command[] = "ls -l"; then it will work. Output: args[0] = ls args[1] = -l args[2] = (null)
are you sure you are not missing the point of this? The standard 'main' is: int main( int argc, char **argv ) {} The name of the program is argv[0] and you can use argc to see the other parameters. This is done automatically for you so if you passed ls -l at the command line and then did some pointer arithmetic you could just use the argv you passed in when passing to exec.
Ok, nevermind, I did myself. C is ridiculous when working with strings, that's all I have to say..this is all I wanted to do... char str[50]; fgets(str,50,stdin); i = strlen(str); str[i-1]=0; char *args[3]; char *element = strtok (str, " "); args[0] = element; printf("args[0]: %s\n",args[0]); element = strtok(NULL," "); args[1] = element; printf("args[1]: %s\n",args[1]); element = strtok(NULL, " "); args[2] = element; sorry if its bad formatting, Im frustrated..
Ok, so the scanf isnt a good way of doing it, I used the fgets() to get the input string now, got the strlen() and then used strlen()-1 to set the new line character to 0(null). I appreciate the help, it works now, however this is only part of my assignment ugh :/ I like C but I dont like C lol.
That was a bit of hyperbole mixed with sarcasm, but there's some truth in what I say. Ada has a fairly restrictive type system and while giving some rope, it is expected that you as the programmer know if you're about to hang yourself.
Indent your code with four spaces so it appears in mono-spaced font.
I guess I see no reason for them to continue existing as part of the language standards, TBH. Digraphs cover the useful i18n cases, and other than that the only case I’ve ever heard of them being used is w.r.t. EBCDIC, which has been justly dying since slightly before ASCII was standardized. (And of course, trigraphs can wreak syntactic havoc in non-trigraphiferous code, which among other things necessitated the addition of the `\?` escape. They’re mostly treated as odd leftovers and sources of great annoyance in modern compilers.) Basically, from my point of view it’s trivial (like, CS-101-trivial) to write a portable, standalone tool that eliminates or introduces them, and it would be trivial for the standards bodies to publish a C89 implementation of that tool with the next round of standards… in which case there’s really no reason to leave trigraph support embedded in compilers’ lexers any more.
Your claim is false. Automatically adding or removing trigraphs is hard, especially where there are no replacements for trigraphs. For instance, there is no other way to encode the backslash for encodings that don't have it except for the ??/ trigraph. I won't repeat the entire argument here, go through my comment history if you care.
&gt; Automatically adding or removing trigraphs is hard No it’s not. You can do it with a sed script. &gt; especially where there are no replacements for trigraphs because no compiler supports ASCII, and any EBCDIC-only compiler supporting ASCII would be a terrible idea, and converting between non-ASCII encodings and ASCII is just plain impossible. My web browser certainly wouldn’t do that transparently and without assistance.
Have a look at [this thread](http://www.reddit.com/r/programming/comments/2j4ch4/ibms_report_on_current_users_of_ebcdic_as_c17/) where I lay out lots of arguments why removing trigraphs is a bad idea. Changing the source encoding to ASCII is also a bad idea as this will change the semantic of the program: All string constants now have entirely different contents, some characters, like ¬, cannot be represented in ASCII at all. The people who use EBCDIC rely on high stability. C is an industrial-grade programming language and should not remove compatibility just because a few programmers haven't read the chapter in their textbooks that introduces trigraphs. Also, if you claim you can do this with a sed-script: It's not nearly as simple as you think. You have to be careful to change occurrences of `?` into `\?` and vice-versa where appropriate and making that decision is not easy. Also, I'd really like to see your solution for encodings that do not provide all necessary characters for trigraph-less C at all.
You are now entering the land of systems design, which is more of a social contract as opposed to something mechanical. A good case study in general is the rules defined by [Amazon](http://apievangelist.com/2012/01/12/the-secret-to-amazons-success-internal-apis/). Another is the [CERT C Secure Coding Standard](https://www.securecoding.cert.org/confluence/display/seccode/CERT+C+Coding+Standard), which is just a set of guidelines you should aspire to. Another is just the concept of refactoring, which is still relevant in C (and all languages really). Refactoring itself are techniques to rewrite sections of code safely. You can also always get started building a unit testing framework so you know where things fail and prevent personal regressions. The real key I find is loose coupling and well defined APIs. If there is a well defined interface that other components use it is that much easier to change something behind the scenes. Examine how you interface with other libraries aside from libc (like SDL, sockets and openssl), and understand that the reason they are able to make changes is *because* you are supposed to do things a certain way. Another project to look into is FreeBSD as BSD is designed to be built as a complete system compared to Linux, so there are some facts to be drawn from there. As always K&amp;R C is a good book because there is a bit of the 'why' included with the definition of the language. Whatever you do read though the goal is not to become a zealot but instead just incorporate it into the growing pool of good ideas you collect over your life. EDIT: Oh, and source control. Learn how to use it so you can try something crazy and then go back in time if it doesn't work out.
First of all, unless you have a specific reason, poking around in the kernel probably won't help you a ton. Those programmers are nuts (and are not fans of documentation within the kernel code). Plus to glean anything about the kernel structure by looking at the code itself is a beast of a task. Good, larger programs are written in layers. This maximizes reuse, flexibility and readability. For example, a driver layer, a medium level layer (there has got to be a better term for this), and an application layer. -The driver level handles the gritty details to get something to work at a very low level, maybe even at the hardware level. Maybe it allows your system to use two microcontroller pins as a serial connection. The driver provides nice function calls for your medium level layer. -Your medium level layer maybe has a queue or some data buffers to hold data before it's passed to and from the driver layer and to and from the application layer. -The application layer calls functions from the medium level layer and does the high level tasks. This application layer should not have to know the nitty-gritty details of what is going on beneath it in the other layers. Of course your programs don't necessarily have to have 3 layers. Some larger programs have many more. I was just giving a simple example. Learning about programming structural design patterns helped me learn about programming structure because I was able to wrap my head around encapsulation and making a program modular.
The medium layer you're talking about is often called a data layer. 
Debugging complex macros with arguments is a giant pain in the ass.
Also keep in mind that you are at the point where makefiles start getting more complex and borderline on "This must work by magic". Getting a grasp on the build system early will help you greatly later.
Yes I also like vala and gtk. For small application,I think it is at least as good as c++ and Qt. If you is planning something with a rich and very complex gui I also think Qt is a better solution. But for regular apps with simpler gui I think gtk is a nice solution.
&gt;the goal is not to become a zealot Don't listen to him. Join the church of Dennis Ritchie. C is love. C is life.
I hate when they give cryptic programs like this, makes it so much harder to do. The function takes a char, and a list, and returns the pointer in the list to the matching char. If there is none, it returns NULL. In the equate statements, it cleverly subtracts the pointer, giving the index in the array. Pretty clever. See if this helps
Let's talk about `fe()` first. (I wonder if you're supposed to take this on faith .... ) This is an implementation of `strchr()`, a standard C function. This function searches for a character in a string. The for loop iterates over the input string character by character and looks for a match. If it finds one, it returns a pointer to that character in the string. As an aside, the for loop could have been better written as `for ( ; *v; v++ )`, but maybe that's my personal preference. Now, let's talk about what `main()` is doing. It's searching for pairs of parenthesis and assigns the index where they were found to the variables a and b for the first pair and c and d for the second pair. How does it turn a pointer to a character into an index? Via pointer arithmetic: the difference between that pointer and the start of the array is the number of character between them, or the index. After that, it's pretty straightforward.
Thanks for the answer, got it now thanks to both replies! I was getting really confused on the a, b, c and d equations.
You can also include '\n' in your delimiters: cmd = strtok( string, " \n"); strtok works by changing the delimiter to NULL. The first time, your first delimiter is replaced by NULL. The next time, the next delimiter is replaced by NULL, etc. To get the next token, use NULL instead of passing in the string: arg = strtok( NULL, " \n"); Consider strtok_r() if you need reentrancy.
Please indent *all* your code with four spaces so it appears in a monospaced font. It's quite hard to read your code otherwise.
First of all, when testing divisors, you only need to test up to the square root of the number. Now to the problem, you could try the following: Write a function that tests if a number is prime. If it isn't, write back the first divisor, otherwise the prime number itself. Now do the following in a loop: Call the function with your number n as argument and store the result in an array. If the result was your number n, you are done. Otherwise, divide n by the result and repeat. For example, 12 when called will deliver back 2. Store the 2 in the array, then divide the 12 by 2. Call again with 6 and recieve another 2. Store at the next array position. Divide 6 by 2 and call again, the function will deliver 3. Store again and exit.
This sounds like a homework problem. If you don't know where to start, consult your professor or TA, or classmates. 
It's not homework, it's just a program I've been working on to work on my skills working with arrays in C. 
check the result of `strtok` is not NULL before printing it. You don't have to use the intermediate variable `element` either.
crap i meant to post the code - &lt;code&gt; @echo off title Compile .C files set NAME=test if not exist source mkdir source if not exist compiled mkdir compiled if exist {compiled/%NAME%.exe} ( rem compiled/%NAME%.exe ) if exist %NAME%.c move %NAME%.c ./source/%NAME%.c if exist ./source/%NAME%.c gcc ./source/%NAME%.c -o ./compiled/%NAME% move %NAME%.c source/%NAME%.c move %NAME%.exe compiled/%NAME%.exe pause &lt;/code&gt;
It looks like this is a question about Windows batch scripting, not C
You are trying to replicate a makefile with a batch script. Try reading a tutorial on makefiles: http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/ As bored circuits said, make tool, which is needed to run makefiles should be installed along MinGW, if not you can install it from Cygwin. 
What? That is horrible advice lol. I get the high level concepts of data structures. It's just implementing them into some code where I get a little confused or I over think specific things.
Segfaults are always a problem! In order to avoid them, make sure you're not freeing memory that you mean to use later or trying to use memory you haven't malloced yet. Check your for loops- there could be boundary problems. The way I avoid memory leaks where space-efficiency isn't an issue is to make a linked list of all the pointers I ever allocate with a function to replace malloc that adds to the list, and then a function that I call at the end that unwinds the list to replace all my free calls. Use valgrind and gdb to find out where your memory problems are. If you're on Linux, they should already be installed. If not, check out how to get them working in Cygwin. I hope that helps!
Please post your code.
Oh, there is no specific problem I'm having so far. I'm just looking for common ways to fix any seg-fault issues! Sorry for the confusion!
Ah, in that case compile with `-g -fsanitize=address`. It will make your life easier.
Line 30 &amp; 36 are wrong, because you are misunderstanding [unary operators](http://stackoverflow.com/questions/6637005/what-is-the-purpose-of-the-unary-operator-in-c) Also, there is no "%i" in C, you want %d. Thirdly, your loop (i = 0; i &lt;= AREAX; ++i) should be (i = 0; i &lt; AREAX; i++). Pre-increment instead of post would be fine as well, post-increment is just convention, but your bounds checking is wrong.
Btw, C let's you access memory as arrays, so you can simply change your loop to be for(i = 0; i &lt; AREAX; i++){ coordinateX[i] = i; printf("%d\n", coordinateX[i]); } and you will get your desired result, do the same for Y
A poor man's version of that could be to keep a simple counter instead of a list. Of course that wouldn't help you with finding the leak should you get one. It might be nice if you could call free at any time not just the end and not have the overhead of removing items from the middle of a linked list. 
~~I'm pretty surprised -Wformat isn't enabled by default for OP in the first place.~~ ignore me. %i is acceptable
Did you miss the part where /u/chasesan said &gt; You can do this... (but shouldn't!) &gt; 
I meant besides syntax, I know the syntax is correct and works.
It seems to me your problem isnt data-structures, but pointers. so you really need to learn that shit first, C wont hold your hand ;) 
&gt; It might be nice if you could call free at any time not just the end and not have the overhead of removing items from the middle of a linked list. Oh definitely- I'm just a fan of putting off work until later, and this was a way to carry my philosophy into C.
Let's dissect the loop: for(i = 0; i &lt;= AREAX; ++i){ coordinateX += i; *coordinateX = i; printf("%i\n", *coordinateX); } * You're not going to initialize the first element: you advance before assigning anything to it. * You're not moving the pointer by one each time, so you're skipping elements. * You're going to run off the end of the array with the bounds in your for loop. Here's some fixed versions of the same loop: for(i = 0; i &lt; AREAX; ++i){ *coordinateX = i; coordinateX += 1; printf("%i\n", *coordinateX); } for(i = 0; i &lt; AREAX; ++i){ *(coordinateX++) = i; printf("%i\n", *coordinateX); } for(i = 0; i &lt; AREAX; ++i){ coordinateX[i] = i; printf("%i\n", coordinateX[i]); }
Right you are, never seen it before
To help with data structures, read a book. Your local library will probably have some if you aren't able to buy a book. However your question text suggests that your problems are with how to allocate memory correctly, which is something you'll have to sort out before you get onto trying to work with larger data structures that require memory allocation. My advice would be *don't guess anything*, make sure you know exactly what each line of code is doing, and why. Learn to use your debugger. If your program has a segfault, debug it until you find what the cause of the segfault was. Make sure to understand exactly what went wrong, and then you won't make that mistake again. To help with avoiding mistakes you can use various coding patterns. For example, have a function which performs a task involving memory allocation (e.g. inserting a new node to a linked list) and can't possibly screw it up; instead of just going `malloc` wherever you need it. 
That is not the same thing though. If someone told me they were struggling with data structures, I would explain alignment, padding and marshalling, not malloc
I had to look it up. I knew `scanf()` accepted both ("%d" reads only decimal, "%i" can be decimal, octal, or hex), and figured `printf()` should probably accept it as well.
I've never seen this flag -fsanitize what does it do for a c programmer trying to work his way into intermediate levels of programming? 
alignment, padding and marshalling have nothing to do with data structures. I think you misinterpret "data structures" to mean `struct`. In fact it means lists, trees, hash tables, and so on. Ways to store data in a structured form.
Perhaps, but as one of the other posters pointed out, OP's issue is with basic use of pointers
&gt; fsanitize=address. It's fairly recent https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer
This. Thank you, buddy. btw I use '%i' because it is more relevant to 'int'. 
Use valgrind all day every day, especially when getting your dynamic memory handling set up. It will help you with freeing memory and boundary checking. .. and always remember that strlen() doesn't account for the '\0' character .. that one seems to always bite me when I haven't been working in C for a little while. 
use goto :D. but seriously, why not use an if statement instead of the while? 
Break the problem down into the tasks that you need to accomplish 1. Take input w 2. Create rhombus with width of w and diagonal of 2w Break step 2 down... determine how to create the rhombus 3. Loop 2w over the height 4. Create rhombus 'line' of width w Break step 4 down... determine what each w line looks like... 5. print some number of leading spaces (determined by the current outer loop variable or height) 6. print opening * 7. print w of '*' or ' ' depending on whether you are at the top or bottom or in the middle 8. print closing * 9. print newline int main(int argc, char *argv[]) { int w; int h; // use scanf to read input w // use outer for-loop with h to iterate over height { // use inner for-loop with h to print leading spaces // print leading * // use inner for-loop with w to print width of rhombus using either * or ' ' // print trailing * and newline } return 0; }
Yes, looking at the table here: http://en.wikipedia.org/wiki/%C3%96 UTF-8 195 150 C3 96 195 182 C3 B6 I suspect utf-8 file shenanigans? (Though 182 is -1 from 183... :/) 
On VS I don't get any errors when I build it and then run. If I go onto my virtual machine running Ubuntu compiling the same source file I get warnings and a different result. gcc --version produces: gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2 (...) Well I think that the problem is the code is not interpreted the same way by the terminal / VS - which would explain why it prints the same hex-values on both VS and in Ubuntu, but the 'ö' produces different results. However this is the part that I don't quite get, as well as why I don't get overflow warnings for c2 in Ubuntu and no warnings at all with VS.
It sounds like you want x to be a mutex, which you can then just wait for it to become set. 
Do you mean yield to another thread in the same thread group?
thanks! And yes, sorry that was indeed a typo.. (Edited above too)
You're obviously working with multibyte characters here. Depending how you need to go about it, you can work from the character string level or do it all using wchar_t. There should be some multibyte functions available for whichever platform(s) you intend to support but the base data structures are not portable to my knowledge. 
I found your explanation and your code example confusing. Your `while` loop will never run more than once, because you break out of it before it gets a chance to loop. Might as well be an `if` statement, and if you do turn it into an `if`, you can now use `break` to exit the switch. How about this: switch (r) { case 0: if (x == TRUE) { do_important_work(); break; } yield(); break; }
He just doesn't care about teaching. He's been teaching programing for non-majors for 14 years and this is one of the assignments? I would guess this assignment has changed very little in that time. Also why are you teaching non-majors c?
By format, do you mean the scanf format for inputting the numbers? (Hint: C doesn't have an "input a list" format. You have to use a loop to repeated invoke scanf) Post the last thing that you tried and failed... that at least will let us see what you're stuck on.
This sounds like homework to me, so I'm gonna stick to pseduocode here to start you off fn 1) i=q, i =&lt;p sum += array[i] fn 3) i=0,i&lt;size if array1[i] != array2[i] return false (assuming size is size of both arrays) 
You have no idea how to even start with any of these? You just want the answer delivered to you with no thought of your own?
Yeah, that is not the way this works. Provide us with a source code first showing that you at least attempted to understand functions, arrays and pointers, then we can go from there.
The `while` condition decides when to stop the loop. At the moment that condition is: (c == getchar()) != EOF which means it will keep going until reading a character fails. If you want an additional condition (say, stop after 20 enters) then you can add this into your condition via an "and": while( n1 &lt; 20 &amp;&amp; (c == getchar()) != EOF ) NB. If you are doing interactive input and don't know how to cause input failure, one solution is to press Ctrl-Z twice in Windows, or Ctrl-D twice in other operating systems.
C== get char() returns 0 or 1. You probably want to assign c the result of getchar()
Don't use online tutorials, use any of [these books](http://www.iso-9899.info/wiki/Books) instead. [This one in particular](http://books.cat-v.org/computer-science/c-programming-language/The.C.Programming.Language.2nd.Edition.pdf) would be the most recommended.
[This one](http://www.google.com)
No need to be an asshole.
I can set the array of char pointers to a different string using a string literal, but when using a variable such as str, it does not work. For instance: array[0] = "hello"; array[1] = "world"; but for array[0] = str; AND then changing str for input from keyboard, setting it to array[1] = str, it seems to set every element to the last string entered. What am I doing wrong? Ive searched the internet for hours and I can not get this to work. Please help!
You might want to invest in a copy of *Kernighan &amp; Ritchie: The C Programming language* and possibly *21st Century C,* which is full of little errors but quite nice otherwise.
I've heard mixed reviews of this, so YMMV. [Learning C the hard way](http://c.learncodethehardway.org/book/)
I've tried using scanf() as well, and it doesn't change the results. Also, I have used '\0' and that does not change the results.
You only have one string variable anywhere in this program. Every time you call `fgets()`, the contents of that char array is overwritten and replaced with another string. Every element of the array points to this same char array. It prints out the correct value inside the loop because the print occurs before the next iteration of the loop which modifies the string. Again, you need to allocate a separate string for each item you want to store. You're not doing that currently. If you assign an element of an array to point to a string literal, then that's a form of allocation, because each string literal is a different (statically allocated) string. 
Those are points of convention, not what's wrong with your program. /u/Rhomboid has explained it in more detail
Imagine if you were doing this manually. Let's say someone calls the function like this: sum(a, 10, 2, 4); Then you need to add: int sum = 0; sum += a[2]; sum += a[3]; sum += a[4]; return sum; Let's replace the sum with a loop: int sum = 0; for ( int index = ?; index &lt;= ?; index++ ) sum += a[index]; return sum; What goes in for the two question marks? the first one says where to start, the second says where to end. That's `i` and `j`! int sum = 0; for ( int index = i; index &lt;= j; index++ ) sum += a[index]; return sum; (Note that the &lt;= might need to be &lt; depending on your definitions.) You can simplify this code a bit: int sum = 0; for ( ; i &lt;= j; i++ ) sum += a[i]; return sum;
Probably your best bet is to use `localtime`. Convert your `struct dbdatetime` into a `time_t` (number of seconds since the epoch) and then use `localtime` to convert it into a more sensible `struct tm`
It changes the first *byte* to 0. If `temp` is of type `int8 *` (pointer-to-byte, I guess?), then any dereferencing operations are referring to bytes, so `temp[0]` is the first byte of that array.
Ok, I think I understand now. When I use the assignment operator = and say "array[index] = str;" it is not setting it to the string inside str but the memory location of str. Then I am setting a new string value to str, which is in that same memory location I set the array of pointers to. I believe this cleared it up. Now I did something like this: array[index] = malloc(50*sizeof(char)); strcpy(array[index], str); And this appears to work.
Firstly, in a two dimensional array, A[i][0] is a numerical value, not a pointer. You are returning an integer, not an integer pointer, see mismatch between prototype &amp; return value. You want to return &amp;arr. Seconds, the use of n depends on how A was defined. If you defined A as an array of integer pointers, each value in the array corresponding to the addresss of a row, then A[i] would work to get you a pointer to the row, and based on your function definition (assuming that is correct) this looks like the case. return A[i] instead of &amp;(A[i][0]) If your function definition is meant to pass in A as the address of a memory area allocated as sizeof(int) * n * n then A[i] has no meaning, you would need to return (*A) + n * i
adding on to what /u/OlderThanGif said, yes this is completely legal code. This is equivalent memset(temp, 0, 1)
I'm guessing this is a continuation of http://www.reddit.com/r/C_Programming/comments/2lg313/help_with_a_couple_arrays/ which you deleted. Couple of points : * your loops run from 0 to &lt;= size[AB]. An array of size n only contains elements from 0 to n-1. * please try and walk through your code. Your function terminates at i=0, j=1 in the example you have given ignoring the rest of the array. * Nitpicking : Nested loops need an indent
Thanks, and how would I return a column? If I do A[i], and it returns a row, is there a way to format it to get it to return a column
The following is definitely not the most efficient way, but it's what I'd do if I knew my arrays were going to be small and I wasn't worried about minimizing cycles, because I could write it in less time than it takes to figure out a better way: make a sorted version of each array and weed out duplicates, then compare these for equality. Each of your examples will produce [3,4].
I'm glad you've been enjoying it. I've now received a couple of remarks about the pace of the content, so I'm going to scale back submissions to just one or two every day (but others are of course welcome to submit more). I had been posting 3 to 5 each day to give people a reason to keep visiting, but I think I can do that with a slower pace.
The algorithm is quite easy: 1. guess a year 2. determine the day number of Jan-00 of that year, that is the day before the 1st of Jan 3. subtract your day number from the number in 2. so you get the day-of-year number 4. use an algorithm (for instance the trimester algorithm) to turn day-of-year into month and day See routines __yday_get_md() in lib/yd.c of https://github.com/hroptatyr/dateutils The algo I described above is in __daisy_to_ymd() in lib/daisy.c 
Sort both then use binary search. 
Will converting a epoch since Jan-1-1900 to time_t,which if I understand correctly is a epoch since Jan-1-1970, cause any problems I wonder. Also are there any built ins to handle this or would I be writing this conversion function.
Won't leap years throw this off? I believe there has been roughly 28 since Jan.1 1900. I know when I am dividing I use .2425 to represent a leap year every 4 years, but that isn't always the case.
Yeah you're going to have to figure out how many days are between 1900 and 1970 when converting into a `time_t`
No. It's all covered in step 1. See __daisy_to_ymd() in lib/daisy.c. The idea is to guess the year, by just dividing by 365, then adding the number of leap years between 1900 and the guessed year, then finding the day number of the 0-th of January in that year. In step 2. you'd then compare if the day number within the year is within bounds, i.e. &gt; 0 and &lt;=365 if the guessed year is not a leap year, or &lt;= 366 if the guessed year is a leap year. If the day-of-year number is &lt;= 0 then you misguessed the year, it's too big, if it's &gt;= 365,366 then the guessed year was too small. In those rare cases you'd correct the year and start over at step 2. 
remember that temp[a] is another way of writing `*(temp +a)`. because of this it is legal code, it changes the first 8 bits,(1 byte) to 0.
Thanks for all of the input everyone, here is what I ended up doing. * Convert dtdays to seconds, minus the offset of the number of seconds between Jan-1-1900(Serial Date) and Jan-1-1970(UNIX Time). Which is 2208988800, this leaves us with UNIX time. * Convert the hundredths of seconds into seconds and add to total. * Convert UNIX time using gmtime() to a tm struct.
First of all, ***NEVER EVER USE THE gets FUNCTION FOR ANYTHING EVER.*** It is literally impossible to use the `gets` function safely. You can't do it. Any program that uses `gets` is vulnerable to a buffer overflow. Use `fgets` instead. But actually you don't want to be using `fgets` anyway. You are trying to read an integer value, right? So why don't you use `scanf`? If you do want to read in a string with `fgets` and convert it to an integer, then the function you are looking for is `atoi` in `&lt;stdlib.h&gt;`, or `strtol` if you want more control (such as determining whether the string does represent a numeric value).
Also, the use of #define true and false is completely nonsensical. You can just use regular "true" and "false". And to check if an integer is three digits long, just check that its under 1000 :)
strdup(str) is a neat shortcut for that, which also only allocates as much memory as is needed I think (strlen(str)+1)
The binary search sound kind of overkill once it is sorted
Which area of C are you the most new to ? Memory allocation/usage, fie system/streams, general lib... ?
For the sake of learning, I would prefer to consider myself as a 100% newbie besides language syntax.
I'm on my mobile so I'm really not able to give this a full look - over but a cursory glance at your code leads me to believe that you may not have your counter/loops worked out as well as you believe them to be. Notice how you are starting one loop with 1 and the other with 0. Also think about your loop invariant especially with your increment statement. Putting "++" before the variable increments it BEFORE evaluation. And I think that may be the issue or at least contribute to it. I'll come back to this later tonight to give a follow up.
You've got some weirdness with your loops. First you call fscanf outside of a loop so it's only running once and reading in one number. i isn't initialized yet at that point, so it's unclear to me what value it might be. You probably intend to have that line inside a loop to read in all ten numbers. Then your first loop is printing all ten numbers ten times for some reason? I don't think you want nested loops there. 
I am experiencing similar issue. I am PHP, C++ and several other languages programmer, and I want to refresh on C. I am thinking to do something with systems programming on Linux regarding what C is used primarily for these tasks.
Here's a fun one, create a reverse polish notation calculator. Here's an example input/output: 3 4 + 7 and (1 - 2) * (4 + 5) is entered as 1 2 - 4 5 + * and do it for all the basic operators. This requires you pushing things onto the stack, popping them off it etc and really requires you to just generally interact with the stack and visualize how memory is being allocated. There's a good description exactly of how to approach this problem in K &amp; R on page 74, as well as code for each of the functions if you'd like to use that. It's a classic problem I had to do in my C class. 
 fscanf(file, "%d%d", &amp;x, &amp;y);
Ok, take a step back for a moment. You need to restructure your code. I won't do it all for you but I'll help by commenting what you need to do on each line. First, you want to read in all the grades from the file. Since you know there are 10 grades, you need to read them through a for loop. in = fopen("grades.txt", "r"); for(i = 0; i&lt;10; ++i) { //Read number into grade[i] } Now that that's done, loop through the array, print out each grade, and add it to a running total for(i = 0; i&lt;10; ++i) { //printf (i+1) : grade[i] //add grade[i] to total } Now all you gotta do is print the total and average //average = total / 10 //print total //print average
As a hobby, I would not suggest C. Python with Pygame, maybe, but I would not use C/C++ unless you're planning to write a game engine. C is *not* for games, and C++ is only for the fastest games (ie first person shooters, AAA titles of that sort). If you'd like to write games as a hobby, learn Lua, Pygame, or something of that sort.
&gt;C++ is C with a bunch of extra stuff added to make coding easier No. C++ adds extra functionality, particularly object orientation, to C. You should learn C first. It's much simpler. 
Thanks so so much! I'm still a real novice to this, but I sorta understand the code. I just needed to get a better idea of how to structure it. Here's what I've got now thanks to your notes. #include&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; FILE *in; int grade[10]; int i; float average; int main() { int total = 0; int counter; in = fopen("grades.txt", "r"); for (i = 0; i&lt;10; ++i) { fscanf(in,"%d", &amp;grade[i]); } printf("Test# Grade\n"); for (i = 0; i&lt;10; ++i) { counter = i + 1; printf("%d %d\n", counter, grade[i]); grade[i]+=total; } for (i = 0; i&lt;10; ++i) { total += grade[i]; average = total/10; } printf("\nTotal: %d/1000 ", total); printf("Avg: %.2f\n\n", average); return 0; } Edit: Forgot to say that now it's working perfectly!
Do you mean `int8_t`? Do it like this: #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; /* ... */ int8_t i = 123; char s[4]; sprintf(s, "%" PRId8, i);
Well they added complexity. Regarding the OO part in C++, I always like to quote Alan Kay: "I invented the term object-oriented, and I can tell you that C++ wasn't what I had in mind".
char str[10]; fgets(str, 10, file); fgets(str, 10, file); // at this point, str contains the line your want int value = strtol(str, NULL, 10); // convert your string to a number http://www.cplusplus.com/reference/cstdio/fgets/ http://www.cplusplus.com/reference/cstdlib/strtol/ edit: not using fscanf because someone is going to mess up your input file at some point. 
I would use snprintf and %ld 
fgets for sure
Why the `l`?
What do you mean by "convert it to decimal format"? What do you want your int8 to be printed as?
I get it. If I wrote grade[i]+=total it's like saying add the two together and make it 'i'. Right? Since that's not what I was really wanting I flip it and I still get the math I want, but store it in total instead. Tell me if I'm not getting the idea right. What I don't really understand is why it matters that the average is in or out of the loop. I'd really like to understand it better if you care to explain so that I can try not to make the same mistake again. Additionally, I was given the option to make up some points on this program by using 10 sets of grades instead of just the one. Using what I had I added a line or two and came up with this. #include&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; FILE *in; int grade[10]; int i; float average; int main() { int total = 0; int counter; int set; in = fopen("grades10.txt", "r"); for (set = 0; set&lt;10; ++set) { for (i = 0; i&lt;10; ++i) { fscanf(in,"%d", &amp;grade[i]); } printf("Test# Grade\n"); for (i = 0; i&lt;10; ++i) { counter = i + 1; printf("%d %d\n", counter, grade[i]); total+=grade[i]; } average = total/10; printf("\nTotal: %d/1000 ", total); printf("Avg: %.2f\n\n", average); total = 0; average = 0; } return 0; } I get the right output, so I assume it's all good, but since you've had such great input so far, if you don't mind I'd love your opinion. 
An `int8_t` is not a `long`.
Gotcha! Thanks for the information. Any answers for the first question? What program(s) should I be using?
I defer to you on int8 . My point was to use snprintf instead of sprintf.
Oh, sure, `snprintf` is a better idea than `sprintf`. Sorry, I was missing your point.
There are two reasons you don't want "average" in the for loop. Firstly, you overwrite the variable before you even use it. Secondly, the way you compute the average is dividing the "total" by the number of elements; i.e. there is no reason to attempt to compute average until you've computed total. And yes, that is correct code for running 10 sets, with one exception. You still only have a 10-int array for storing the scores (the "grade" variable). With every iteration of set, everything in "grade" gets overwritten. If you don't need to store anything in your array after you've printed it out to the screen, then it's fine. If you do want to store all the scores, however, you will need a double array: int grade[10][10]; Then, every time you want to access the grade, do so as follows: grade[set][i] Once you're done, the variable "grade" will store all the grades you've read in.
Awesome! Thanks a lot for giving me the crash course. Since I don't need to store the data I'll leave it as is, but I'll most definitely save this in the event I need it later. You really are a life saver. Enjoy the gold :)
It's definitely useful, but not really for games. Dwarf Fortress guy used C because he was comfortable with C. If you'd like to write a game like dwarf fortress, I would suggest Python + libtcod. I use rust + libtcod, personally, and it's a great platform.
1. You're going to need the gcc compiler if you're using Linux/Mac. You can install them with apt-get on Linux or by installing Xcode on Mac. On Windows you can use Visual Studio which comes with the C and C++ compilers. Alternatively there's another compiler called MiniGW or something (can't recall) which you can use. I like using Sublime Text when I program with C/C++ as it has a compile and run automatically built into the program, and you can customise your builds, but there's tonnes of other editors. 2. I started with C and then moved over to C++ (although I'd had a background of Python, Perl etc before that). C++ is a really big language, I've been using it for the past 6 months for a project I'm working on and I still feel like I've barely scratched the surface. My advice is to go through your book on C, but once you're done look into learning C++. C++ has lots of things built in which can make your work easier down the road (like vectors, etc). Using the object orientated elements of C++ will also make it easier to organise a big game program.
As someone who recently started out on C within linux, your first sentence sounds entirely correct, and I know that C in windows is a PITA. I don't know anything about OSX, but why the hell were you in the negatives? If this is going to be a downvote train I may as well voice an unpopular opinion. &gt; C is different than C++! The latter takes from the former and you can use them together, but they are distinctly different languages! C != C++
Oh are people voting my comment down? That's one thing I don't understand, if someone disagrees and can set me straight, please do, don't just be lazy and vote down without an explanation.
"No. C++ adds extra functionality" aren't you arguing semantics here? I mean you could easily say that OOP, vectors, etc are extra stuff added to make coding easier, which indeed they are.
Not that I'm saying C == C++, just that the purpose of C++ was to build on it and add a great deal of extra things on top of it. After all, I can still write a simple C program and compile it with g++.
I'm honestly curious if you're wrong about something, I know that I don't know much about what you're talking about, so I can't fathom really. I'm just trying to wrap my head around the examples for using the GNU Multiple Precision Arithmetic Library(bignum stuffs). My program breaks at around the 12th(?) factorial i think, so I'm def going to need it. I'm also supposed to create a program that'll do 100!, or was it !100?
Well I know everything I said about compilers on the different operating systems is 100% correct, I suspect it might be because I recommended C++ are there are lots of people who seem to really hate the language and love C with a passion so rather than debating the merits its easier to vote down.
Ugh, that's just petty. At least you're not negative anymore. It's not like the points matter, but it sets a poor example and hampers discussion. At the time yours was the most comprehensive post too. Since we're approaching the end of the line, what parts of C++ do you value the most? I think I'm a few good months(and a few bad months) away from moving up to it, I'm curious on your experience transitioning into it.
To get started with C in the traditional way, you need the following: * A UNIX-like operating system like Linux or Mac OS X * A shell (usually included in your operating system) * A C compiler (possibly included with your operating system) * An editor And that's all for the beginning. I would strongly suggest you to not use an IDE in the beginning as the IDE does a couple of things for you which you will not learn to do yourself if you never do so.
Try writing your own std library then (strtok, strcat, strdup, strcmp, printf, atoi, readline, malloc, etc etc). You'll learn a lot just with this
Get a book called "A tour of c++". In my opinion C++ is getting some new features that are really nice. C++ has a lot of traps and zaps. You have to be careful and boring most (99%) of the time. But OOP and the STL are too powerful to pass up. You get the speed of C with the productivity boost these provide you. You will go farther and faster with C++ and the code *if written correctly* will be easier to read.
What wouldn't you learn?
How the compiler is invoked, how to set up a build system, how the building process works, how to compile projects that don't provide Support for an IDE, etc.
Wait, what? How is C not useful for games? The industry is pretty heavily built on C and C ++? It might be a bit a bit ambitious but I wouldn't tell people it's not really for games. OP check out https://www.libsdl.org. That might help. In C you will need to learn to manage your memory. It's something that isn't always easy but you will make you a much better programmer. Starting with Python will work but learn C if you have the ambition. If you want to make a game with it, all the better. 
Save your 'hello, world!' program as 'hello.c' using notepad++. Then at your mingw command prompt, type in: 'gcc -o hello.exe hello.c'. Learn C. Learn C++. Don't get hung up on them though. If you want to make games there are a lot of options. Check out Unity, Unreal, etc. Usually you use C/C++ to make the engine, not the game. A common mistake that a lot of people make is getting hung up on the technology and forget they are doing this all to make games. 
Thank you very much for taking the time to write this up! That Tools section helped a lot.
Yes it is.
Glad I could help. Thanks for the gold :)
I didn't mean that. I meant its not useful for hobby games. Unless you're writing a game that *needs* speed (like a AAA title), or are already comfortable with C, you shouldn't use C++/C.
Yeah, the program comes from K&amp;R, iirc, the first C book. Its been used ever since for everything but assembly.
just want to add that PRId8 and other int printing macros are defined in inttypes.h, and exact width sizes are not required by the standard, but others like int_least8_t are
I see what your saying but a lot of the indie crowd uses C and C++. A lot of the green light stuff on steam and the indie stuff in the humble bundles commonly run C or C++. It's not as far out there to use C for hobby games as one might think.
It would, but at the call-site only. Being able to use the same name with differing types.
So here's your model: You have a math function that calculates a light beams max. deflection: **dMax(l, b, E, h, W) = ( (12 * W * l) / (3 * E * b * h) )** You want your computer to do that for you upon providing the parameters (l, b, E, h, W). In C/C++ ( you are actually programming in C++ here ) it could look like this: double maxDeflect( double l, double b, double E, double h, double W ) { // calculate max. deflection, compare to your model double dMax = ( (12*W*l) / (3*E*b*h) ); return dMax; } That is the implementation of your model. To use it you do this in your main(): double dMaxResult1 = maxDeflect(1, 2, 3, 4, 5); double dMaxResult2 = maxDeflect(0.2, 1.04, 5, 16, 50); // print the results cout &lt;&lt; dMaxResult1 &lt;&lt; endl; cout &lt;&lt; dMaxResult2 &lt;&lt; endl; You mention "functions within functions". This exists in a newer version of C++, but your confusion seems to stem from the term function in different context i.e as a math abstract and its code implementation as a C++ function. *In conclusion, here's your prototype:* double maxDeflect(double, double, double, double, double); // outside main() and here's your implementation of that prototype: // also outside of main() double maxDeflect( double l, double b, double E, double h, double W ) { // calculate max. deflection, compare to your model double dMax = ( (12*W*l) / (3*E*b*h) ); return dMax; } 
I will have to look into this, I was thinking about some sort of external pre-processor. However m4 syntax seems a bit more sutied to web development (all of 5min I spent looking at it).
This is clever. I would have never thought to do this. You can theoretically have a type enum that changes the function behavior based on the type. Nice.
C++ is not a full superset of C. Some C programs do not compile with a C++ compiler and some things (like the `auto` keyword) can have different semantic. It's usually a bad idea to compile C code with a C++ compile as the result may not be what you want.
As mentioned C11 _Generic can do this and imo it is probably the most elegant / least horrible way. I would create two structs named something like point_i and point_f and something like #include &lt;stdio.h&gt; void fn_i( int i ) { printf( "int: %i\n", i ); } void fn_f( float f ) { printf( "float: %f\n", f ); } #define fn(x) _Generic((x), \ int: fn_i, \ default: fn_f \ )(x) int main( int argc, char **argv ) { fn( 42 ); fn( 3.14f ); return 0; } 
This is the right answer if you can afford to require C11.
Why are you using `float` and not `double` variables?
I'm on mobile so this is less than ideal, but effectively you can just start main with scanf("%d", &amp;n) which would store the number of triangles you want (4) in integer n. Then you can just create a for loop up to that integer n so that you redefine all the sides of the triangle on each pass.
But not as a first example, which was what I meant. Assembly, it's much more common just to do a `return 0` example, at least in my experience. It's quite long winded to do a `hello world`: section .text global _start _start: mov rax, 1 ; write syscall mov rdi, 1 ; stdin mov rsi, hello ; buffer to write from mov rdx, 14 ; how many characters from buffer to write syscall ; call the Linux kernel mov rax, 60 ; exit syscall xor rdi, rdi ; return 0 syscall ; call the Linux kernel section .data hello db "Hello, world!", 0xA ; 0xA is the newline character (Linux x64) Edit: Forgot to exit... Assembly is difficult...
You know, you can simplify this by doing a #include &lt;sys/syscalls.h&gt; up front and preprocess the whole file with the C preprocessor. This allows you to use symbolic names like `SYS_exit` for the system calls.
If you can write `printf` in assembly, you are far from a beginner. `printf` is quite difficult to implement correctly. Please know that you shouldn't use direct system calls. It's better to call into the libc instead.
Which means [Visual Studio is out](http://www.infoq.com/news/2012/05/vs_c99_support). MS won't even support all of C99, and C11 is even less likely. The Intel compiler *might* support _Generic eventually, [but not yet](https://software.intel.com/en-us/articles/c11-support-in-intel-c-compiler).
I only know how to write printf from a *heavy* background in C.
Good luck getting varargs right on amd64. It's quite tricky. How do you deal with positional format specifiers like `%3$d`? I'd love to see your routine to convert floating point numbers into strings without loss of precision.
Floats are smaller and I don't need the precision right now. I may want doubles in the future, but I don't want to re-write a pos3d file like pos3f. Hence this post :)
Then I guess floats are next. Variable arguments actually turned out to not be too bad, at least in a printf implementation. I just looped through the string looking for arguments, and incremented r15, then decremented r15, pushing [rbp+(8*r15)], then pushed all of the register arguments in (reverse) order, then did the actual printf.
*This is a request for comments* This being my first non-trivial C project for Unix-like systems: sorry in advance for questions that were answered times and times before. - 1. Build systems I'm aware of GNU Autotools and CMake. I assume autotools are 'default' on Linux, but I find the whole idea of Makefiles and m4 files that make other m4 files and Makefiles... a bit insane. CMake looks better, but is an 'external' dependency. Are there any generally accepted guidelines as to what to choose? Or should I just make my single Makefile 'smarter'? - 2. Testing I'm sort-of using the check library here, and I like it. Check's docs have a number of other testing frameworks mentioned - any suggestions on what is worth checking out? - 3. Unicode on Unix I found it to be non-trivial to say the least. Are there any sane tutorials/articles that would do the job of showing the best practice (if there even is such thing)? - 4. Ncursesw Haven't stumbled upon anything on ncursesw specifically, it's like it almost doesn't exist. And the plain ncurses tutorials I've found are merely touching the surfaces - are there any advanced ncurses tutorials? I.e. touching upon topics like pads, the myriad of update functions, explaining internal representations, etc. - 5. My code It's rather crappy. Comments and suggestions are very welcome. Thank you for your feedback! Also you may give the app a try :)
The problem is that you need to support floating point arguments, too and these are passed in floating point registers. And just looping through the format string will no longer be enough when you implement positional arguments; each argument may have a different size and you need to get them off the stack in the right order.
It shall be done. However, positional arguments may never be supported (except as far as how many digits to print). It's unlikely that I will allow for anything but 64-bit numbers, and characters passed in as a 64-bit integer.
Well, good luck then!
Thanks.
Indeed it needs *a lot more* work. Thank you for a very good bug report - this is what I need to be motivated to polish this piece of software properly. I think there are (at least) two bugs here. First the blank screen - did you try running `./bin/snb help.md`? I use rxvt-unicode with a custom colour scheme. Also, what is your locale setting? As for the double-free on src/data.c:153 an immediate fix would be to change it to `if (line) free(line);`, though I believe the real problem will be somewhere else (heap corruption perhaps). I'll investigate both properly tomorrow. Thanks again or the feedback.
Oh right, when I run `bin/snb help.md` I get a screen with text that I can scroll through with hjkl. Now I see what you're getting at with this app. [Here](https://imgur.com/lWowYrf) is a screenshot. Locale is en_US. It looks like it centers an 80-column text area in the middle of the terminal. I didn't check the `scan-build` report for the details on the double-free, but it should have generated an annotated walk through the code that explains how it ended up at that point. Great tool, comes bundled with LLVM/Clang.
&gt; Oh right, when I run `./bin/snb help.md` I get a screen with text that I can scroll through with hjkl. That seems to confirm the double-free is caused by something else. &gt; Here is a screenshot. Locale is en_US. It looks like it centers an 80-column text area in the middle of the terminal. Check out `src/user.h` - screen width and bullets are configurable. Centring of everything is a feature here :) It gets somewhat confusing - multibyte strings vs. wide characters vs. unicode. It's clear from the screenshot that your locale is not UTF-8, as you've stated. Due to that you only see bullets for entries with sub-items. My understanding is that currently snb should display correctly stuff that can be expressed in your locale. I.e. in my case of `pl_PL.UTF-8`, rxvt-unicode and proper fonts it even displays Japanese properly (but editing doesn't handle it as it uses 'wide characters', i.e. one glyph takes two terminal cells). I find it hard to even accurately describe what it support/does - 'locale aware' seems to be the best description. &gt; I didn't check the scan-build report for the details on the double-free, but it should have generated an annotated walk through the code that explains how it ended up at that point. Great tool, comes bundled with LLVM/Clang. I'm aware of clang's static analysis. I will have fun with it as the next tool after valgrind and gdb to make sense of what is going on.
There's no array bounds checking in C. So while only enough memory for one element is allocated with malloc, you can keep adding to the pointer and access whatever is at that memory location. Until there's actually nothing there (the OS hasn't mapped anything in that portion of the address space) or you end up corrupting something important. Your process actually gets larger blocks of memory from the OS for heap allocations, which malloc/free then manage for you.
When you allocate memory, it just reserves it for use in main memory. Your program still is able to write to any spot in the memory given to your program. For example, you could do: \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; int main(int argc, char **argv) { int *array = malloc(sizeof(int)); *(array + 5000) = 10; printf("%d\n", *(array + 5000)); return 0; } which is doing exactly the same thing in your program. Your program still has access to the memory. 
I think that's the kind of question you ask Carl Solomon.
When you write outside of the bounds of an object, you invoke undefined behavior, which means you have no guarantee of what will happen. Maybe nothing will happen, maybe a crash, maybe something else unexpected. There's no point in trying to ponder the nature of undefined behavior, because it can change at any moment for any reason. A million various factors conspire to influence the outcome: the operating system, the libc, the compiler, the options used when compiling, what the program has done up until that point, the phase of the moon, etc. The loop will end with a segmentation fault when you eventually reach some address that has nothing mapped, or for which has something mapped without the write privilege. If happened to get some memory near the end of the heap, then maybe that boundary is close and the loop doesn't run for very long. Maybe you happened to get a chunk of memory near the beginning of the heap, and you're going to overwrite a bunch of other existing allocations before reaching an unmapped region. Who knows. It's pointless to worry about such things, because this kind of behavior is so volatile. 
Yes, of course. It would however, require some sort of library, since splash screens are obviously not part of any sort of standard (C standard/POSIX/etc) it would probably be some sort of GUI library, such as Qt or GTK or something of that nature.
As others have explained, what you're seeing is undefined behavior. You're writing to memory that your program doesn't own, but the memory happens to be present and writable, so it continues to work correctly. But there's more going on under the covers. Malloc doesn't allocate just the space you request. It generally rounds up, so that structures will be properly aligned. So there might be some unused space at the end that isn't really owned by anyone, and never will be. Or you might call `realloc()` to expand the allocation, and if it will still fit then it can be expanded in place without having to copy the data to a new location. Malloc also has to allocate space for its own data (the meta-data) that it uses to track where your allocated memory is, so that you can `free()` it later. As part of that, it may add some padding on either side of your allocation, so that if you overflow it by a few bytes, you won't cause a fatal crash. If you run your program using Valgrind, it uses this trick to detect buffer overflows and report them. When you request a large enough amount (which varies by platform, but on PCs is often a page of 4096 bytes) malloc may use OS mechanisms to request an entire page at a time. So that's why you start seeing different effects around sizes that are close to a multiple of 4096.
Assuming you're running on a PC (and not some embedded system), this is doomed to failure. Modern kernels are preemptive multitasking. Windows has been preemptive since Windows 95, Mac has been preemptive since OS 9 or OS X, and BSD and Linux have always been preemptive. What this means is that the kernel will run multiple threads or tasks simultaneously. If it has multiple CPUs or cores, it will use them. If not, it will "time slice" fast enough that it appears that they're running simultaneously. When you call `yield()`, you're making a *request* that the kernel find some other task to run. But the kernel doesn't have to; maybe all other tasks are blocked waiting on I/O. Or maybe they've used up their current amount of time on the CPU. Regardless, using `yield()` is a form of *cooperative* multitasking, which was okay on Windows 3.x, but isn't going to work on a modern OS. If you just want some other thread to get more time on the CPU than yours, then you should use the kernel's thread priority mechanisms. Either lower your thread's priority, or raise the priority of the thread you want to have more CPU time. If you intend to wait for some other thread to perform its computation, you *must* use multithreading primitives like mutexes, semaphores, signals, or barriers. You must also learn enough about memory and CPU instructions to understand proper use of the `volatile` keyword. Otherwise, your code is never going to be very good. It might work on your PC... if it's Tuesday and the full moon is out, and you aren't running too many tasks (or maybe only if you *are* running a lot of tasks). But it will be full of "race conditions", weird behaviors that depend on the order of execution between two or more threads as they're interleaved by the kernel on the CPU.
&gt; Though don't all languages that use the subset of ASCII that is considered alphanumeric have the same order alphabet? Well, that's sort of the point... if the character encoding is a superset of ASCII, then yes, but that's not true of all encodings. UTF-16 is a 16-bit encoding which can encode every character that's available in ASCII, but it doesn't use the ASCII representations to do so. And if you take a random 8-bit byte, it might correspond to an ASCII character, but may not have that meaning as half of a UTF-16 character.
~~Words~~ Symbols are hard.
Thank you. I'm extremely new to C.
Please note though, Qt is C++
I don't know. Arrays are somewhat new to me so it's a bit confusing at first.
Fix those two issues. You want to keep a counter of how many moves were done. At 9, the game has to end no matter if there is a winning condition. Next after each move, check of winning condition. Also, if you notice every single case of your switch case is the same, you don't need a switch case where an if-conditional will suffice.
The differences you are encountering are because of the *compilers* used, not the IDEs. The IDE just integrates all (or most) of the tools in your development environment, including compiler, build system, code editor and possibly more into one application (hence the name, Integrated Development Environment). Some IDEs are tightly coupled to specific compilers, others are more flexible and can be configured to use multiple compilers. Some examples of compilers are: * gcc (GNU compiler collection), mainly used for Linux * mingw (minimalist GNU for Windows), basically gcc for Windows * MSVC (Microsoft Visual C++), Microsoft's proprietary compiler for Windows Examples of IDEs: * Microsoft Visual Studio, comes with MSVC and, as far as I know, can't use another compiler. At least not easily. * Code::Blocks is more configurable, but on Windows, it's usually used with mingw * Eclipse CDT, also configurable Technically, there's even a distinction between the compiler and its accompanying standard library (the library that offers basic stuff like I/O, math functions and so on), but they are often bundled up into the term "compiler" because it rarely makes sense to use them separately anyway. Now, to address your problem, `flushall` is not a standard function. There's a [documentation page](http://msdn.microsoft.com/de-de/library/ms235367.aspx) about it for MSVC, but even that says it's deprecated (shouldn't be used anymore) and to use `_flushall` instead, **but** even that isn't standard C, as far as I know. At least my gcc version doesn't know it, so it's very likely to be an MSVC specific feature. The standard way to flush all streams is `fflush(NULL)`, so use this. It should work with all proper compilers. And to answer your question how to detect which compiler is used, yes, this is possible with preprocessor macros. See [this Stackoverflow question](http://stackoverflow.com/questions/4605842/how-to-identify-platform-compiler-from-preprocessor-macros) for examples.
This is your homework assignment and you didn't ask a question, you ask us to solve your homework.
I've just run `scan-build make`, viewed the report and went 'Oh Jesus' - and I'm by no means religious. Clang's Analyser is *great*, and my stupid overlook is right there in my face. I'm permanently adding it to my workflow.
Many good points brought up, also just want to point out that flushall() and variants (flush all streams) is telling the computer to do a lot of work when you intend to do a single thing, which is to flush stdin handle. This is inefficient and very bad code practice.
Just keep in mind, in C graphics is a little bit of an 'advanced' concept. You should probably initially write programs that just run on the command line.
What a great answer. Thanks very much! I already realised that the I get the error because eventually the program tries to overwrite some memory that's currently in use, but your answer explains how increasing the malloc argument can cause the error sooner. Thanks.
And you did a buffer overun! 
You should read [this](http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1052863818&amp;id=1043284351) before using fflush() on an input stream in code you want to be portable. 
In that case you should reformulate your question to not require you copy and paste your exact problem, but make it into more general problem that would answer a whole class of all similar problems. In your case that would be something like "How do I represent multiple objects containing same multiple variables in C". It should not mention your specific problem, unless requested. Also question about input is a whole different question, unrelated to first one. Also it seems like you didn't put any effort into trying to solve the problem yourself. These are reasons why you are getting downvoted. Take these into account if you gonna ask questions in future in any programming forum, not just this one.
&gt; The standard way to flush all streams is fflush(NULL), so use this. It should work with all proper compilers. Actually, `fflush(NULL)` flushes all **output** streams, not all streams. There is no standard way to flush input streams because flushing an input stream is nonsense, most of the time. If you want to clear the keyboard buffer, there are often OS-specific ways of doing that, but that's not quite the same as flushing an input stream. For OP, there *are* ways to do certain things that are specific for certain compilers. You could do something like: #ifdef _MSC_VER // it's a MSVC compiler _flushall(); #elif .... // some other compiler // some other non-portable way of doing things #endif You'll have to look at the documentation for your particular compiler to see what macros it has predefined that will allow you to recognize it. It's maybe a good learning experience to explore how `#ifdef` and its friends work, but don't get in the habit of using it. Too many C programmers use these things inappopriately and it's better practice to find the most portable way of doing what you want so that you don't need an `#ifdef`. I can't think of the best way to clear the keyboard buffer on Windows, though, since I'm not a Windows programmer (and, of course, even then, your code wouldn't be portable to other operating systems).
I recommend [reading this book](http://csapp.cs.cmu.edu).
Yes, it's an awesome tool. Try running it on some large-ish open-source projects some time :) For my personal projects, my gold standard is that the code should compile in both Clang and GCC in pedantic mode with all (non-silly) errors on, it should pass `scan-build` cleanly, and it should run under Valgrind cleanly without leaks. If I feel masochisctic I'll add const-correctness to that list. By the way, for code formatting there's `clang-format` from the LLVM guys, which might be a more standard alternative to 'Artistic Style'. I've not really used it.
&gt; You're writing to memory that your program doesn't own Not true at all- you *can't* do that by design (as long as your OS is doing its job right). He's still within his own address space and his own pages, but eventually he's going to write through the program break and get a segmentation violation, or corrupt some other metadata (in particular, there will be some metadata associated with glibc's slice allocation mechanism that will get stomped). Otherwise this is on the ball- the gist is that malloc will get memory from the OS in page-aligned batches, and then slice up these pages to service dynamic memory requests by the program. Because it wants to slice efficiently, these are often in fixed size chunks, and so you end up with 'padding' of unused bytes (and big regions of slices that are not yet used). As a fun experiment for the OP (and the other interested parties), print a few words *before* the returned address of a malloc() call. This is some of the glibc metadata!
Actually, that's not quite the source of the error- C will happily overwrite 'memory in use' because it doesn't have a concept of memory in use. R/W/X permissions notwithstanding, memory is memory. What happened was that you overwrote *metadata* which corrupted its semantics, or you overwrote what's called a canary, which is a datum that is used to detect overflow (if a canary is modified, a bad thing happened).
&gt;&gt; You're writing to memory that your program doesn't own &gt; Not true at all- you can't do that by design (as long as your OS is doing its job right). Depends on the definition of "own". From the kernel's point of view, you're absolutely correct... it uses hardware page tables to ensure that your program isn't permitted to read or write any memory that hasn't explicitly been assigned to it. (Assuming you have hardware page tables. I work on embedded systems which don't (not like this, anyway).) But within the task, there's no such protection. Glibc (or whatever malloc implementation is being used) has a whole page to divvy up, but not all of that page "belongs" to OP's application (although it does belong to the task in the kernel which is being used to run his application). So although glibc is putting its metadata in the memory just below the malloced region it's providing to OP's program, that doesn't mean that memory is "owned" by OP's program. It's "owned" by glibc, and if OP writes to it, it's going to cause problems.
Why on earth would you use a `switch` statement like that? `userTurn` is already a variable, and you're already using it to index the array. What possible purpose is the `switch` statement serving? Here's a hint: any time you find yourself copy/pasting code, *stop*, and rethink what you're doing. It's rarely the right way to solve a problem.
Flushing streams is hardly "a lot of work". When stdout is going to a console, it's flushed every time a newline is printed. If you're running the terminal in X windows, this means a lot of rastered font characters have to be grabbed, antialiased, copied to the application's window buffer, composited by the window manager, and sent to the graphics card. And all of that is happening every time you `printf` a newline to a console, because of an implicit flush.
Don't try do it all in one step. Run it through something like http://htmlcleaner.sourceforge.net/ first. ps: Trying to juggle XML with C is like inline skating down a busy road with chainsaw. Why That particular metaphore? I saw someone do it once and has stuck in my mind as a good example of what not to do.
Haha love this. I'm doing this more as a learning exercise, my primary goal is to use real-world problems -- like the ones I encounter at work everyday -- to learn C. I don't intend on using it in production. Onto the main suggestion: would something like htmlcleaner help me in this case? Would it not also declare `imgp` an invalid HTML tag? I attempted to use HTML Tidy and it just spat out an error or simply ignored it, which really doesn't help me in this case.
The horrible horrible hack that you absolutely wouldn't want to use is to scan the raw string and patch `&lt;imgp src="` into `&lt;img src="` (that's "img" followed by two spaces).