From... http://htmlcleaner.sourceforge.net/parameters.php omitUnknownTags false Tells whether to skip (ignore) unknown tags during cleanup. treatUnknTagsAsContent false Tells whether to treat unknown tags as ordinary content, i.e. &lt;something...&gt; will be transformed to &amp;lt;something...&amp;gt;. This attribute is applicable only if omitUnknownTags is set to false. Or could use.. http://htmlcleaner.sourceforge.net/parameters.php#transform .. to map all imgp to img
How else would anyone do it? 
I've seen implementations (in other languages, at least) which first "repair" the HTML to convert it to full-on XML. A cursory Google search seems to indicate that libxml2 does offer support for HTML in this way, though I have no experience with this myself. If the issue is that libxml2 has poor handling of HTML errors, then it might make sense to feed it into an HTML tidy library similar to [what is done in libcurl](http://curl.haxx.se/libcurl/c/htmltidy.html), before then feeding it in to libxml2.
I still don't understand the need for any and all of that when it's just simple programming. 
All points, most certainly agreed. Off the top of my head, the major compilers are GNU (GCC/Mingw), Clang, and Microsoft Visual C (MSVC). I know Borland Turbo C used to be used a lot, but not sure if it is anymore.
There's a html cleanup tool called tidy that's pretty helpful when it comes to this stuff. But if you want to do it manually there's a few other errors I didn't see mentioned here. &lt;br /&gt; must have a space in between start and end tag Unless I missed it the image tag is missing an end tag so you'll need to add that as well I recommend rigging up some sort of xml validator. I used to uses expat because it's error messages were helpful but I'm sure there's other tools out there 
libxml2 has included an HTML parser since aeons
Yes, but it expects the HTML to be in XML-like form. It is sadly not HTML5 compliant.
Classic off-by-one in this line: for (x = 0; x &lt;= strlen(grade); x++) If your string has length 4, then x in the loop will be 0, 1, 2, 3, 4. That's five repeats, or one too many. You should check for `x &lt; strlen(grade)`.
Ahh, that makes so much sense now! I made is so that I used a *less than* operator instead of a *less than or equal to* operator, but now the program crashes due to the atoi function - there is always one more problem... Thanks! 
Can anybody suggest anything to avoid the crash when I'm using the atoi function? I think it's to do with the '\0' being at the end of the string. I would prefer not to create another array.
How do you know it's crashing in the atoi function? How are you defining pass?
Actually, atoi needs the '\0' to be there. That is how it knows where to stop parsing the string - if the string only contains digits, atoi() will continue to parse characters until it reaches the '\0' and then it stops. Can you post more of the code? Where is the grade array declared?
I'm going to go out on a limb -- here is what I think is happening. If you are testing in Windows, it probably uses "\r\n" for newline. In your getchar() loop, you stop upon seeing '\n' but the '\r' makes it into your array. Then your validation loop runs. All of the the digits print out successfully, so you think it is working. But actually the '\r' at the very end is going into your "invalid input" conditional branch. Because your printf statements in that branch do not have any newline characters, they are being buffered by your OS so you do not see the print statements. Then you think atoi() is crashing, but actually your code is looping back up. You dangerously reuse the variable called "x" for all sorts of purposes, so x is not equal to 0 when it loops back up. But your code expects that it is. 
`%d` is for reading an int. `et` are not valid digits so I am not sure why you are surprised that they were not stored. Can you describe what you expect to happen for the input `45et89` ? 
Don't use scanf().
fgets, then strtol. You don't need to do everything in one function call and strtol will accept different radices
Usually there is a compiler macro. You'll have to look up the specific ones as they are compiler dependant Eg msvc is _MSC_VER
I would use "%c" as signed char due to them sharing the same range 
The *f* in **scanf** means that it is *formatted* input. It requires your input be exactly what you tell it to expect. If you want to make it safe for taking any old random junk that's typed, use **fgets** first, then parse it with **sscanf**.
if( scanf( "%d%c", &amp;n, &amp;c ) == 2 &amp;&amp; c == '\n' ) printf( "yay!" ); else printf( "boo!" ); I think that does it. These formatting tags kill me every time. 
Exactly what ralusp said. I'm not sure about the Windows newline escape sequence, but your using the x variable all over the place. If you happen to get invalid input and then decide to clear the string container by filling it with null bytes , you leave your x variable initialized at whatever strlen(grade) is. Not to mention your reading input into an unallocated buffer which definitely isn't safe. So perhaps set x = 0 at the beginning of this do while loop and try to preallocate some space using malloc and then extend or minimize the buffer after the newline is received. If you want to get rid of it and start over when invalid input is received, then just use the free function and pass it the pointer to your string. All functions mentioned are in stdlib just in case your wondering. Best of luck :)
Q) Embedded programming? A) Is there any other kind?
Why are you trying to embed \0 in your file name strings? Don't. You shouldn't really use seek functions on text files. It's going to give you the whole thing, because you aren't terminating the string you read in. Basically you read into an array, but you don't terminate that after you read, so it's not really a proper string. Is there some particular reason you aren't just using all the f functions? fopen, fclose, fread, fgets, etc?
I see a bunch of confusion happening here. * You're giving `lseek()` a line number, but it needs a byte offset into the file. It doesn't know what a "line" is. * You're passing an argument into each thread, but using it to access a global structure that isn't protected by a mutex. That seems both unsafe and unnecessary. Why not just pass a structure or arguments directly to the thread? It's a void*, so it can by any type or size you want it to be. * You're reading the file in both `main` and the thread's function. Not sure what the point of reading it twice is. * You're using a single variable in the `args` struct to return values from all 1000 threads, again with no locking. Totally unsafe! And also unnecessary, since the threads can return a value from their function anyway. * You're putting `\0` into the strings for your filenames. I'm not sure what purpose that serves, since all strings in C have a `\0` at the end anyway. What do you need an extra one for? First thing you should do is check the arguments to your thread. Inside the thread's function, as soon as you get that thread's values out of `args`, print them out. I bet they're not at all what you're expecting.
i can't, i have to use the system functions. Would make my life easier if i could.
&gt; On using U32 and I16 ... isn't &lt;stdint.h&gt; part of C99? Why have a separate, duplicate system? It doesn't say you have to, it just says "Typical definitions include..." Also, if they're dealing with legacy code, it may have already been written without stdint.h. The code I use at work still doesn't use it, because we need to be portable to wacky embedded compilers that may not have full (or any) support for C99.
Since /u/cQuaid already answered your question - the '~'-sign is called a tilde.
http://i.imgur.com/rcR9r1z.png
In the menu click View -&gt; Perspectives -&gt; Code::Blocks default
Well, those make sense.
Can someone explain how this macro works? #define c_assert(e) ((e) ? (true) : \ tst_debugging("%s,%d: assertion '%s' failed\n", \ __FILE__, __LINE__, #e), false)
To move a file, you can use [`rename()`](http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html) (specified in C90) but only if both the source and destination are on the same volume/filesystem. If they cross volumes, you have to manually create the new file on the new volume, copy the contents, and then delete the original. `rename()` will fail if you try to cross filesystems, so use its return value to trigger the manual copying. (You should be checking the return values of all library functions anyway.) To enumerate the contents of a directory requires using platform-specific APIs; there is no way to do this in standard C. For Unix, that's usually [`opendir()`](http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html)/[`readdir()`](http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir.html)/[`closedir()`](http://pubs.opengroup.org/onlinepubs/009695399/functions/closedir.html). For Windows, use [`FindFirstFile()`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364418.aspx)/[`FindNextFile()`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364428.aspx). To count the number of files in a directory, you have to enumerate its contents and then determine whether each entry is a file or directory. Again, this is platform-specific. On Unix, you'd use [`stat()`](http://pubs.opengroup.org/onlinepubs/009695399/functions/stat.html). The MS CRT has a [somewhat analogous function](http://msdn.microsoft.com/en-us/library/14h5k7ff.aspx) but it's really just a wrapper for the Win32 [`GetFileAttributes()`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364944.aspx) (or similar.) Remember that the directory entry contains only the name, not the path. You have to manually form the path to be passed to `stat()` or equivalent. Creating a directory is, you guessed it, platform-specific. On Unix, you use [`mkdir()`](http://pubs.opengroup.org/onlinepubs/009695399/functions/mkdir.html). Again the MS CRT has a [somewhat compatible version of that](http://msdn.microsoft.com/en-us/library/2fkk4dzw.aspx) but note that the signature is different; it does not take a mode parameter. And as before, the CRT is just wrapping the underlying Win32 APIs, in this case [`CreateDirectory()`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa363855.aspx). 
Just bought the game and am ready to go. Thank you for doing something like this. :)
/u/gniark's explanation is good. A few more things... \_\_FILE\_\_ and \_\_LINE\_\_ are standard, so it would work under other compilers other than gcc. Also, the #e bit is 'stringifying' the parameter being passed to the macro, which allows it to be passed as a string to tst_debugging() (which uses printf() style formatting) to be picked up by the second %s. So in /u/gniark's example (a == 5), the macro will expand to (imagining that this occurs on line 10 of foo.c): ((a == 5) ? (true) : tst_debugging("%s,%d: assertion '%s' failed\n", "foo.c", 10, "a == 5"), false) which at runtime, if a was not equal to 5, would format the string to: foo.c,5: assertion 'a == 5' failed
I also work on embedded systems, although not ones that have the same high-reliability requirements as these. :-) But by "esoteric requirements" I meant things like "you can get away with allocating all memory you'll ever need once during startup, because you have a well-defined mission that doesn't require keeping track of an arbitrary number of things that can't be known at once". If I had to follow that same rule in my products, I'd just have to allocate a big array of stuff and hand out spaces in the array, which might conceivably run out... making it no better than just using malloc.
How is it? 
According to the site, everything will be archived on youtube, and free even for non-buyers.
Haha. No worries. I am excited though :)
Using for loops.
i mentioned sscanf since he uses scanf now. You can use whatever you want for just the integer part, i think they'll all return 45 in the example. I thought the problem was that the whole string is not a number and he wants to check that. For that, fgets + a loop with isdigit or the complete example posted by u/LowBOb works out.
This question cannot be answered correctly without knowing the platform you are working on. Since you didn't specify one, I will now assume that you want this answered for Plan 9. &gt; How can I move a file? Have a look at [`wstat(2)` and `dirwstat(2)`](http://plan9.bell-labs.com/magic/man2html/2/stat). The source code of [`mv(1)`](http://plan9.bell-labs.com/sources/plan9/sys/src/cmd/mv.c) might give you some ideas about how to get this right. &gt; How can I read file names in a folder? Have a look at [`dirread(2)`](http://plan9.bell-labs.com/magic/man2html/2/dirread). &gt; How do I create a folder? Use [`create(2)`](http://plan9.bell-labs.com/magic/man2html/2/open) with a file mode that specifies `DMDIR`. &gt; How can I see how many files are in a folder? You need to read in the contents of the directory as mentioned before. You will see how many entries a directory has when you run out of entries to retrieve. &gt; By the way the files I am going to use this for are mp3. The type of file doesn't matter. 
Homework?
Send me teh codez plz Moderation sure is nice. /r/cprog
But strtol will tell you if it's a number or not AND handle different notations
/r/HomeworkHelp 
indeed, you are right. 'If endptr is not NULL, strtol() stores the address of the first invalid character in *endptr'.
Just worked it out myself, and found it a useful exercise. It did not take all that long. This was pretty well the approach I took. You need to think about the sequence of things you need to accomplish, and work out how the loop variables need to be manipulated to get it to print the numbers and new-lines the right way. The increment/decrement operators were tricky, and understanding how they work was key. You don't, however, need to work it all out at once. You can get small parts working correctly and add the bits of program together as you go. The process that you learn doing exercises like these; involving small, incremental, trial and error changes; is the way to go as you put programs together. I found I needed another loop for filling in those blanks, for example.
printf("123454321\n 1234321\n 12321\n 121\n 1\n);
 void* add(int a, int b, int c) { } This would be the prototype for your first code wish. int(2), ... This cannot be done in C as *int* is a reserved symbol. If you've already done this in C# and JS then it should be easy in C aswell. The same principles apply. Any tutorial will get you this far. If you need more help, you have to be more specific, this level of vagueness is almost offensive (jk).
Thank you for the response. Just thinking of a reply has helped me better understand how the structure of the C code may work. Ya. The example was bad with int(1). Should have done intM(1). And it is a high level of vagueness. :-) I'm not even sure where to start with C in terms of architecting a functional/object oriented design. So, I don't even know how to frame the question. But I think I've figured out something and will see if it works. Lot's of function pointers. Thanks again... 
I use Minunit, doesn't do mocking but it's very easy to use. I am thinking about branching out to something a little more heavy duty though.
&gt; Since you didn't specify one, I will now assume that you want this answered for Plan 9. *Slow clap*
Sorry I can't help but be skeptical. What are the credentials of this person (people?). There are so many 'how to make a game' videos on youtube that start and are never finished, why is this one going to be any different? And added to that is that we have to pay for it? However I am intrigued, especially since it's going to be in C. I'll wait until there are a few episodes first.
I've used http://cunit.sourceforge.net/ for a hobby project. Works on OS X and Windows (Visual Studio).
I really like [CuTest](http://cutest.sourceforge.net/).
Recently started using CMocka, it's based on Google's old c test framework called cmockery. I like it so far, writing mocks is pretty easy, and I've been able to use it both with GCC and my embedded compiler.
Yeah, somehow I seem to be incapable of using his website. I neither found this information nor did I see a game which I can buy. So thanks :) Seems like I have to take another look.
What's Google's new C test framework ?
I don't think they maintain a C specific one anymore, only GoogleTest, which is C++. You can make it work with C, but isn't very intuitive, because the framework is geared around testing object oriented constructs.
I'd bet 80% of all github listings are like three of the four linked to here. No one would have a clue what those things do by reading their descriptions/read me/introductions. 
Apparently he created [this](http://www.radgametools.com/granny.html) animation SDK in 1999, which is still in use today (the site lists Destiny as one of 2,600 games that have used it).
On a similar note: [https://github.com/eivinda/sctest](https://github.com/eivinda/sctest) Inspired by minunit. It lets you write testcode in your source file and removes it completely during normal compilation. Has a small tool *sctest* to extract test code only.
All variables have to be declared at the top of a block. The assignment to `valid` ends the declarations. Exchange the declaration of `points` and the assignment to `valid` to solve this problem. Second, you define a macro `FALSE` but refer to an identifier `false`. C is case sensitive. Use the same case for all occurrences of `FALSE`.
Lint.
Most likely you would just change your #ifdef #endif combo with some framework macro. The difference I can see is that assert exits on first failure forcing you to fix or remove the assertion before you can find the next error.
This looks like a good start, but let me give you a few pointers. Optimization: 1. Check out the possible return values of the atoi function, is the numerical function needed? 2. The for loop that iterates through every number could be optimized, do you need to check factors of 2 if you know the number is not divisible by 2? 3. Additionally, do you need to check every number leading up to result - 1, what is the minimum number you would need to check before you could determine it's prime? (hint: given the number 11, what number multiplied by 10 (result - 1) would equal 11? by 9 (result - 2)?) Readability: 1. Try to keep the spacing of your variable assignment statements the same. Either way is good, as long as it is consistent. ~~result=atoi(number);~~ result = atoi(number); 2. The tab spacing of lines 41-52 are off. Having proper spacing makes it easy to understand the scope of these statements. 3. I personally prefer having brackets wrap all of my blocks (if, else, etc.) even if they have one line bodies. I find it easier to make a mistake otherwise. 
Heh, so the advantage is to get "on error resume next" functionality? That's not a very compelling reason to learn a framework and introduce the build dependency. Thanks for your answer. I don't like feeling like I'm missing something.
#include &lt;stdio.h&gt; #include &lt;conio.h&gt; int main() { int i, j; for(i=0;i&lt;5;i++) { for(j=0;j&lt;i;j++) printf(" "); for(j=1;j&lt;5-i;j++) printf("%d",j); for(;j&gt;=1;--j) printf("%d",j); printf("\n"); } return 0; }
The program seems overly complicated. I'm no expert, but [this](http://pastebin.com/9aKuJp6S) is what I came up with in 5 minutes. Do you need to use a function? For a first assignment it seems like they threw you in the deep end.. 
Lint isn't a testing framework, it's a static analyzer. Both are useful, but separate.
&gt; a few pointers Heh. Another point about readability: It is generally cleaner to put comments on their own line(s), above whatever they are commenting. You can see this in the definition of the numeric(char*) function - moving the comment up a line would be much easier to read.
Good call! Additionally, If a comment can fit on a single line then use // (single line comment). If a comment needs multiple lines, then use /* */ (block comments). 
Not if your class is using ansi C though. // comments weren't a thing until c99.
 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; /* ... */ int **twoD = malloc(5 * sizeof(*twoD)); if (twoD == 0) { fprintf(stderr, "Out of memory\n"); exit(EXIT_FAILURE); } for (int i = 0; i &lt; 5; ++i) { twoD[i] = malloc(4 * sizeof(**twoD)); if (twoD[i] == 0) { fprintf(stderr, "Out of memory\n"); exit(EXIT_FAILURE); } } /* ... */ for (int i = 0; i &lt; 5; ++i) { free(twoD[i]); } free(twoD);
The disassembly process is the assembly process in reverse.
Well, 2^(0)&amp;nbsp;+&amp;nbsp;2^(1)&amp;nbsp;+&amp;nbsp;2^(2)&amp;nbsp;+&amp;nbsp;...&amp;nbsp;+&amp;nbsp;2^(k) = 2^(k+1)&amp;nbsp;−&amp;nbsp;1, so you don't need to use a loop here: just calculate 2^(k+1)&amp;nbsp;−&amp;nbsp;1. You can do that with [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring). Since you are interested in the result modulo 10^(9)&amp;nbsp;+&amp;nbsp;7, just keep the remainder after division by 10^(9)&amp;nbsp;+&amp;nbsp;7 at each step.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Exponentiation by squaring**](https://en.wikipedia.org/wiki/Exponentiation%20by%20squaring): [](#sfw) --- &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics) and [computer programming](https://en.wikipedia.org/wiki/Computer_programming), __exponentiating by squaring__ is a general method for fast computation of large [positive integer](https://en.wikipedia.org/wiki/Positive_integer) powers of a [number](https://en.wikipedia.org/wiki/Number), or, more generally of an element of a [ring](https://en.wikipedia.org/wiki/Ring_(mathematics\)), like a [polynomial](https://en.wikipedia.org/wiki/Polynomial) or a [square matrix](https://en.wikipedia.org/wiki/Square_matrix). Some variants are commonly referred to as __square-and-multiply__ algorithms or __binary exponentiation__. These can be of quite general use, for example in [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic) or powering of matrices. This method is also used for exponentiation in [groups](https://en.wikipedia.org/wiki/Group_(mathematics\)). For groups for which [additive notation](https://en.wikipedia.org/wiki/Abelian_group#Notation) is commonly used, like [elliptic curves](https://en.wikipedia.org/wiki/Elliptic_curve) used in [cryptography](https://en.wikipedia.org/wiki/Cryptography), this method is also referred to as __double-and-add__. &gt; --- ^Interesting: [^Modular ^exponentiation](https://en.wikipedia.org/wiki/Modular_exponentiation) ^| [^Addition ^chain](https://en.wikipedia.org/wiki/Addition_chain) ^| [^Shor's ^algorithm](https://en.wikipedia.org/wiki/Shor%27s_algorithm) ^| [^Factorization ^of ^polynomials ^over ^finite ^fields](https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm3viz7) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm3viz7)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Replacing *input[x]* with *input[x-1]* clips the last number entered in the input steam. The values print correctly too. Are you suggesting that a fix would be to something along the lines of comparing *input [x]* ('\n') with EOF?
The function is not called `GetChar()`. C is a case-sensitive language, please treat it as such.
Please do not cast the result of `malloc()`. Casting the result of `malloc()` is unneeded and might inhibit diagnostics from the compiler.
Run you program with valgrind. That will help you find allocations that you may have missed.
Is their a way to shorten the string so that the empty element isn't included (the one which has been assigned '\0')
I have never heard this. I've always heard the contrary. Do you have any references for this? 
First, I'd suggest looking into 'valgrind', which is a problem that can detect memory leaks for you. Second, you'll probably find it easier to understand if you go in with the knowledge that *every* pointer returned to malloc must eventually be sent to free() if you don't want any memory leaks. More-over, every call to free() will only free *one* block of memory returned via a malloc or realloc call. Looking at your code, we can see you make a total of 6 calls to malloc, one for 'twoD', and then 5 for the contents of the 'twoD' array. Thus, if you follow what I said above, you then need to have 5 corresponding calls for free() for the contents of the 'twoD' array, and then one call to free() for the 'twoD' array itself. If you only call free(twoD), it will only free the memory holding the twoD array of pointers, but it *won't* free the memory being pointed to by those pointers in the array (The 5 malloc calls you made). Worse yet, once you free the twoD array you're not allowed to access it's memory anymore, so once you do that you have no idea where those 5 malloc calls are so you can free() them. Thus, you have to call free() on every pointer in the twoD array *before* you free the twoD array itself.
I believe it gets worse every year, but this might just be my confirmation bias. I think people just don't understand what the machine they are working with actually does anymore because flashy GUIs remove the need to look under the hood.
in your loop : for(i=0; n; ++i, n/=10), maybe I am wrong but I would explicitely put i&lt;n as the exit condition, I suppose a bool is expected here.
Have you tried using a debugger or a program like Valgrind?
Run it under valgrind for starters.
Have you tried [Valgrind?]( http://valgrind.org/docs/manual/quick-start.html) Your problem is probably you exceeding the boundaries of the memory you have allocated. Malloc can catch this the next time you call it, but the problem will be before this call somewhere. The simplest example of this would look like char *p = malloc(10); // Lots of code here p[8000] = 'a'; // Lots more code char *d = malloc(20); //Fails, but where was the error? If you use Valgrind, it should be able to tell you where in your program you overflow memory, not just where malloc caught it.
I think the problem might reside in your freeTab function: //Try to free every elmt of an array void freeTab(char** tab){ int i=0; while(tab[i] != NULL){ free(&amp;tab[i]); &lt;---- NO!!! } //free(tab); } Get rid of the leading '&amp;'. Then uncomment free(tab) after the loop. You want to free the memory pointed to by the pointer stored in tab[i], not the memory that stores the pointer in tab[i], which having the '&amp;' in front does. That memory is part of the array of pointers in tab, which will be freed after your loop with the commented out free(tab). Also, you're relying on tab[i] == NULL to be your condition for breaking out of the while loop. This could be problematic too. Do you zero/NULL every pointer in tab when you first allocate the memory for the array of pointers in tab, before allocating memory for each individual pointer? Also, what happens if you end up using all the pointers in tab and allocating memory, such that none of them are NULL? You'll loop off the end of your array. It'd probably be better to keep track of the size of tab, and pass that in as a parm and use that as your loop bounds instead of the while loop. You can check if the array slot is null before trying to free it.
Also just noticed - you never increment *i* in your while loop. So presently, you're calling *free* over and over again with the same address, which is probably why you're crashing. Even if it didn't crash on the first call, it'll probably crash on subsequent calls because it's already freed that memory...
**_Bool** was introduced in the C99 standard. The header file **stdbool.h** defines the macro **bool** to be synonymous with **_Bool**, also defining **true** and **false**.
Try [these C FAQ entries](http://c-faq.com/aryptr/index.html), and [this point](http://c-faq.com/aryptr/pass2dary.html) specifically.
That is a great answer and I'm reading through the [Smallest x86 ELF Hello World](http://timelessname.com/elfbin/) and your link. 
I know this isn't really an answer to the question, but [gzexe](http://linux.die.net/man/1/gzexe) and [upx](http://linux.die.net/man/1/upx) (really only for large binaries) could make your hello world program much smaller and still executable. :D Also, [ent](http://www.fourmilab.ch/random/) is pretty cool. K, I'm done here. Gotta read these links.
For posterity: [core](https://github.com/mechanismsc/mech-core/blob/master/dist/mech-core.c). First C program as far back as I can remember. 
http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
First keep in mind that NULL is equal to 0. While you can do `if(x)` to make sure it's not NULL, I usually do it explicitly so people know I am checking for null `if(x != NULL)`. Checking null only really works for pointers. Assertions are useful only in places where you want to program to cease if a problem occurs, which is only useful for unrecoverable errors. The problem with checking for NULL is that when you free a pointer with free, it is usually not automatically set to NULL. So if you `free(x)`, then do `if(x != NULL)`, it will work, since x is not null. Also, values in C are not automatically initialized. So `int *a` could be any value, and is very likely not null. So you need to explicitly set `int *a = NULL` for it to be NULL. As far as C goes, checking for NULL is acceptable for no other reason then there are few other ways to check if a pointer has been set without using additional variables or a custom struct with extra code, which due to the lack of classes and member functions is something of a pain. Best practice is to return an boolean check value from a function, or set an error value which the user can check after the function (if you have other needs for the return value), or most ideal to do both. What boolean value you return on an error is often left up to the user, but many older libraries use 1 for an error, and 0 for normal return (similar to main). So for example, using your snippet. int mechFree(Mechanism *d) { if(d != NULL) { if(d-&gt;class == NULL) { MECH_ERRNO = ERR_MECH_CLASS_NOT_SET; return 1; } if(d-&gt;class-&gt;delete == NULL) { MECH_ERRNO = ERR_MECH_DELETE_NOT_SET; return 1; } (freeFuncPtr)(d-&gt;class-&gt;delete); free(d); return 0; } MECH_ERRNO = ERR_MECH_NULL; return 1; } Then later you can have something like char const *mechErrorStr() { /* code to return an error string here */ switch(MECH_ERRNO) { case ERR_MECH_NULL: return "Supplied argument is null."; //... } } 
I've found that Core Foundation (a framework for iOS and OS X) is rather unforgiving, in the sense that it expects the user of the framework to do most of the null checking and length checking etc. For example, mutable Core Foundation arrays can be created to have a specific maximum length. The framework does not stop you from adding too many items, instead the documentation says that doing so will invoke undefined behaviour. Basically, a *garbage in, garbage out* approach. Offsetting NULL checking and length checking to the user of the framework means that these tasks become optional, and if you know for certain that they aren't required, you don't encounter an unnecessary performance hit (however small that hit may be). Win32 on the other hand is very forgiving, you can often provide `NULL` where you think it isn't expected (and isn't documented to accept `NULL`) and *Nothing Bad&amp;reg;* happens. I even recall some functions explicitly documented not to accept NULL and all that happens is that GetLastError() is set to `ERROR_BAD_ARGUMENTS`. I think there are probably good arguments for both approaches. Win32 API may be very forgiving but at the same time, 99% of all API calls are probably made with valid arguments^([citation needed]) so 99% of the time, the checks are pointless.
Yes, the general way to do this is to enable assertions on debug builds, and to not have them enabled for regular builds. This is convention obviously, you can have debug builds as the defaults and require and explicitly required a disable debug just as well.
For best practices, [The kernel coding guide](https://www.kernel.org/doc/Documentation/CodingStyle) is a good start, though it a style manual, and not for design pattern reference. The [GNU Coding Standard](https://www.gnu.org/prep/standards/standards.html) is a great read, as is the (updated) [Indian hill coding standard] (http://www.cs.arizona.edu/~mccann/cstyle.html) Someone posted the [JPL C Coding Standards](http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf) here recently too
&gt; First keep in mind that NULL is equal to 0. A null pointer (NULL) does not have to be zero: http://c-faq.com/null/ The most common way to handle free of null pointers is to silently ignore them. And what is this cast `(freeFuncPtr)(d-&gt;class-&gt;delete);` supposed to do? I would write the function somewhat like this: void mechFree(Mechanism* d) { if (d &amp;&amp; d-&gt;class &amp;&amp; d-&gt;class-&gt;delete) d-&gt;class-&gt;delete(d); // assuming this is how it's supposed to be used free(d); // will not fail if d is NULL }
if it would actually be that only 99% calls are valid, then PC would crash every few seconds, because there are thousands of calls every second. Even if it's not 1%, not 0.1%, but 0.0001% that OS has prevented a crash, it is well worth it. For majority of the time CPU doesn't do anything anyway, just wait for user input, so checking for errors pays off in the long run.
&gt; The most common way to handle free of null pointers is to silently ignore them. In fact, all relevant standards guarantee that `free(NULL)` is a no-op. Notice that even though a `NULL` pointer might internally have a different represenation, casting the integer literal `0` to a pointer type either explicitly or implicitly (e.g. during a comparison) will yield a `NULL` pointer and vice-versa.
&gt; Notice that even though a NULL pointer might internally have a different represenation, casting the integer literal 0 to a pointer type either explicitly or implicitly (e.g. during a comparison) will yield a NULL pointer and vice-versa. Are you certain? http://c-faq.com/null/runtime0.html edit: never mind, missed the 'literal'
Even with proper variable definitions and such, this is invalid code :) There's no 'if loop', loops and conditions ('if's) are 2 very different things. You can combine them maybe for (i = 0; i &lt; Something; i++) { if &lt;condition&gt; &lt;do stuff&gt;; } but this doesn make them 'if loops'.
As with many things, the answer is "it depends". If you're hacking together a quick tool that you'll use once and throw away, you can probably omit most of them and not care. It only needs to work once, right? If you're writing software to run on satellites or Mars landers, you better do everything you can to make sure it's not going to crash. Check for NULL on every parameter in every function, even if you think it's only going to be called from someplace that's already checked it. Check every pointer before dereferencing it. I write software for an embedded platform, so we have to be kind of strict about it. Unlike a PC, if we dereference NULL, we'll get a nonmaskable interrupt, and we can't just kill the "application" to handle it. Our only recourse is to reboot the whole device. Would you like it if your desk phone rebooted? Probably not. So we have to check for NULL, and not just with asserts but by explicitly coding alternative behavior in case a NULL pointer is found.
or while loop?
Why don't you run it and see?
The output should be "don't use scanf." And some warnings about %d expecting int.
&gt; but by explicitly coding alternative behavior in case a NULL pointer is found. I agree with this. Errors in a computer program, like NULL returned from malloc, are no different than running out of bottles in a coke bottling plant. Both cases need to be considered by business and alternate plans provided. A lot of developers don't seem to realize this. It looks like, in C, it's best known practice to check before using. Thanks... 
While we're stuck with "errno" for the standard library, I would not write any new API that way. Return an error code, either as the return value, or in a separate "out" argument: int mechFree(Mechanism *d, int *err) { /* after an error is detected */ if (err) *err = MYERRORCODE; }
Your function should have documentation that specifies if NULL is allowed or not. If you document that NULL is not allowed, then you don't have to check. If someone calls you with NULL anyway, then that's their bug. You might check anyway with an assert or something similar, like glib's g_return_val_if_fail(). As for as how deeply you need to check, that depends on what's allowed. Remember that NULL is not just used for errors. It's often used to make things optional. You'll need to check the documentation to see whether or not certain fields may be NULL. (Or failing that, the actual code that creates the objects.)
The (freeFuncPtr)(d-&gt;class-&gt;delete) was a mistake in my copy-paste-edit. It should have been: freeFuncPtr funct = mech-&gt;class-&gt;delete; (funct)(d); 
Only the application dereferencing NULL would crash, not the entire system. And, if it is 0.0001% of API calls that are invalid, then that means 99.9999% of the time, the CPU is wasting cycles checking for what is already valid. &gt; For majority of the time CPU doesn't do anything anyway, just wait for user input, so checking for errors pays off in the long run. Citation needed. If you are writing a program where performance is paramount, then the CPU is not waiting for user input, and if you are calling all your framework/API functions with valid arguments then all the useless branching will slow your application down. If the documentation of a function says what arguments are valid/accepted, then it is up to the caller to ensure the arguments are valid, otherwise that is a bug in the application, not the framework/API.
&gt; If the documentation of a function says what arguments are valid/accepted, then it is up to the caller to ensure the arguments are valid, otherwise that is a bug in the application, not the framework/API. Not really, especially in windows case. What happens when a program crashes in windows? It's "windows fault". What happens when programs crashed windows by providing bad arguments? It's windows fault again. That's why their philosophy was to safeguard everything they can. That also means windows is probably a bad choice for performance critical software. As is proved by the majority of servers running linux. Why do you think they made that window pop up before shutting down showing which program is preventing it from shutting down? Because it was always windows fault for "slow computer". They can't just terminate programs, because then it becomes windows fault for corrupting documents. So they simply clearly put the blame on a particular program, so a user wouldn't blindly swear on "horrible garbage os". There are much more things at play here than simply a number of clock cycles "wasted".
Yes, this is probably ideal, I am just stating the way I have seen many libraries do it. I'm not sure what I was thinking really. This is a much more ideal error system, and you could pass that return to the mechErrorStr(int) if you wanted to. As for the NULL thing, well I guess the standard needs to be written better then, I wonder if you can honestly blame me for such a mistake.
Sure, it's possible, but you're going to have to implement it yourself, or find a library that provides a general-purpose implementation. C isn't a high-level enough language that it can easily provide an efficient `memoize` as a standard function.
You'll have to build a hash on the function arguments. That is, first thing you do upon entry is form an index into a hash table of previously computed results. In searching the table, you'll need to find an exact match against the function arguments (all of them). If a "hit" you return a prior result. This also requires that you save computed results if the search fails. This is done at the end of the function before returning a result. Finally, you can only memoize a function if it has no side effects (modifies static storage outside the function - the function has to be idempotent).
Check out redis - in memory data structure database: [redis](http://redis.io/). 
If your university teaches assembly, pray they teach you something simple like MIPS, before the behemoth that is x86.
I don't quite understand this - I know that hashing is an option but as soon as I leave the scope of the function call I don't know how to access the hash? Do you mean I should build a database?
Thanks for the suggestion.
I'm guessing you want the results to persist from execution to execution. This might be down and dirty, but I would just use something like fwrite to write the hash to file after a new entry, and fread to read it upon execution. 
&gt; Also, why use nested ifs? Because one of the tenents of [structured programming](https://en.wikipedia.org/wiki/Structured_programming) is that a function should only have one entry point (enforced in almost all languages) and one exit point. Having multiple `return` statements violates that. This is the point Dijkstra was making in *GOTO Considered Harmful*. Of course, it's all the same to the compiler. It doesn't care whether you use `goto` or multiple `returns` or nested `if`. Assuming the semantics don't change, the resulting code will be identical. It's all about making the intent clearer and the code more maintainable. In this case, I happen to agree with you. Certain violations of structured programming are okay, such as checking arguments at the top of the function, lend themselves nicely to early exit like this. But for the real meat of the function, following structured programming can be pretty helpful.
Dijkstra wrote his letter in the 60s. We've developed quite a lot since then, and blindly following rules is never good. Validating arguments like this is an idiom most C programmers will recognise. Returning early can lead to increased readability, because you don't have to follow a possibly deeply-nested, contrived function only to find out the function just returns an error code. `goto cleanup;` isn't bad in and of itself, and leads to lower indentation levels. Its meaning is clear. Everything needs to be considered in context. Dijkstra wrote his letter in the 60s, back when subroutines were implemented with gotos, often because languages lacked function calls.
Whenever you check for null, what is your action in the 'else' condition? If all you do is ignore the null, all you're probably doing is kicking the can down the road, so the code crashes somewhere else. That just makes problems harder to debug. So, in the case you showed, ignoring a null might be OK, but that's a decision that has to be made case-by-case. But don't just litter the code with checks for null: if it's an error, make sure to handle the condition: correct the condition, inform the user, or crash gracefully.
The program works fine. But when you repeat it, the loop for *pass* cycles once before user input is needed, right? I know it's a mess, but I've checked, this is how it's supposed to be. I have a chance to improve it (add functions) at a later date.
It is difficult, but not impossible, to provide memoization in C using the C preprocessor. I have actually written a paper on function memoization across languages. [You can find it here.](https://cs.uwaterloo.ca/~becassel/projects/cs842.pdf) See Section 3.8 ("C") on page 5, and Listing 9 ("Automatic Memoization in C") on page 9 in particular. Also note that it might be worth your time to switch to using C++ for this instead. Your code will likely compile and work in C++ with zero extra effort, and automatic memoization is far, far more convenient in C++11 than it is in C. In particular, std::unordered_map already provides a template hashtable for you to use, and templates, overloads and classes in general will make your life far, far easier for this specific purpose. Edit: Formatting.
It looks like you missed where I wrote &gt; In this case, I happen to agree with you. Certain violations of structured programming are okay, such as checking arguments at the top of the function
Oh okay I see what you mean. Pass: Your grade boundary for a pass must be greater than zero. Please input the correct grade boundary. Pass: I found the problem. It is on line 348. scanf(" %c", &amp;repeat); After reading a character, a `'\n'` is left in the input buffer, so when it goes back to the part where you ask for a passing grade, it reads that newline character. You can simply add something like `while (getchar() != '\n') pass;` to throw away any extra characters left after `scanf`. Or you can use `getchar` instead of `scanf` and make sure to throw away extra stuff. Try putting that after your `scanf` or in your `case 'y':`. Edit: By the way, you don't need to use `memset`. I didn't check all your code, but you do put a `\0` after the last character you read with `getchar` anyway, so the end of the string is always correct. If your string is `"Hello world!\0"` and you read `"Yes!\0"` into it so it looks like `Yes!\0 world!\0`, functions working on strings will stop working as soon as they see the first `'\0'`, and that is practically the end of the string.
Ah, that's perfect! I read many algorithm about the filesystems problem you refered too. I'm stuck with that structure so I'll simply make a function that loop and copy all data to the previous spot in the array. I wasn't sure if it was the right way I was doing thing, but it seems it is. Thank you for your input :D
This is a two-fold question. To memoize between calls, you will want to setup a function-scope data-cache (hash table based on calling arguments). This is accomplished by setting your hash table to be a static variable within the function itself. You can also use a file-scope global, but this is less desirable as you're not guaranteed a single point of modification. The second part is if you want persistence across program executions. This can be an external database which is loaded on the first call to the function. Over all, you will want to cache your results in memory (not hardware) as much as possible, or else you will be wasting a lot of time accessing the look-up table.
Welcome to the comma operator! But before we get into that, I want to make a point about the first one: I *believe* the result of this expression is unspecified! Compile it on one machine, and you'll get one answer. Compile it on another, and the answer might be different. The problem is the `++y` and the following `/y`. Which value should `y` be, the one before it's been incremented, or after? The compiler is free to interpret this however it wants. Avoid using `++y` or `y++` in the same statement as other uses of `y` (although there are situations where this is allowed, including the comma operator...) So, about that comma. It's an operator, just like +, -, /, ++, ?:, and so on. It's definition is to evaluate the left hand side (`a--` in the third example), and then evaluate the right hand side (`++b` in the same example), and then it returns the result of the right-hand side. So, let's look at the third problem. Let's say `a` starts with 5 and `b` starts with 10. `a--` reduces `a` to 4, and that's it. `++b` increments `b` and returns that result (since it's a pre-increment). So, `res` and `b` are both 9. When do you use the comma operator? The only common place you'll see it is in a for loop, like so: for ( a = 5, b = 10; a &lt; b; a++ ) do_something(a, b); Notice that other places where you might see a comma *are not* the comma operator, such as: int a = 5, b = 10; // Not a comma operator func(a, b); // Not a comma operator, either
That's the [comma operator](http://en.wikipedia.org/wiki/Comma_operator) which I don't see used very often in the real world, probably because it's not very reader-friendly. Essentially, it decrements 'a', then increments 'b' and stores that new '++b' value in 'res'. See the wiki article I linked above.
Happy to help. However: https://stackoverflow.com/questions/11604575/fflushstdin-ansi-c/11604639#116046392 Using fflush on input streams is undefined, so try not to use it.
&gt; And added to that is that we have to pay for it? Just to be clear, you don't need to pay anything to follow along his videos (they're on YouTube). You pay for the game which you will get when he finishes this project.
You need `strchr` and `strtok`. C doesn't have "strings". It only has arrays of characters, which can be used where most languages would use strings. But this means you can play tricks with them, such as sticking a NULL byte in the middle of one; this makes it look like a shorter "string", since a "string" in C is conventionally an array of characters with a NULL byte indicating the end of the "string". This is how `strtok` works. It looks for the delimiter characters you specify, and replaces them with NULL.
&gt; The problem is the `++y` and the following `/y`. Which value should `y` be, the one before it's been incremented, or after? The compiler is free to interpret this however it wants. You appear to be correct... I thought at first the operator precedence would resolve this, but that only applies to parsing, not execution sequence. The prefix increment operator doesn't introduce a sequence point, so the behavior is indeed undefined.
Also note strtok mutates the target, so you should make q copy if you might need it later 
Nice, thank you. I manage to make the ls command with a function to search for a specific file or folder and return if path is invalid, blockdata is a folder or a file or if path is valid but nothing of that name. Usefull for next command I must do (rm, mkdir, ln...). Its not the prettiest coding, but since it's not the point of the class, I won't bother too much. Thanks again
Nobody mentioned it yet, but don't confuse *the comma operator* with *the comma separator*. The separator separates function arguments, e.g.: call_func(exp1, exp2, exp3); Those are separators. However: (exp1, exp2, exp3); Those are operators. The grammar rule is that if it could be a separator then it is a separator, else it is an operator. So in the case of `func(exp1, exp2, exp3)` this rule says we are calling a fujnction with 3 arguments; we are not applying the *comma operator* and calling a function with 1 argument. 
Your C code contains a no no, any identifier starting with a double underscore is reserved for future language expansion, so you can't use them. Also why bother making the hash table functions customisable without ALSO doing it for the hash table type. Why bother capping the hash table size? The way it's written it needs to call malloc() at least once anyway and at that point you might as well be using a hash table that grows... 'course then you probably need a way to clean up... Plus the whole thing only works for single argument functions...
link it with pastie.org
http://pastie.org/9729561
ta, taking a look
No, I was just taking that point further.
yeah, I found that out when trying to output later. I've created a char path2[strlen(path)] and then using strcpy to copy it, then using path2 for the rest. THanks
Pay attention to your variable types. In C, there's no different between an array and a pointer (because that's how arrays work in assembly code, they're just memory addresses (pointers)). So you have `char path[FILENAME_SIZE]`. If you use `path`, that's of type `char*`, because it's a pointer to the first element of the array. If you take the first element of the array, you get just plain `char`. (This should make sense.) You need to do one of two things: * Since you only want to compare a character, you don't need `strcmp`, you can just use `==` and compare characters rather than strings. * Or, you can use `strncmp` (to limit it to only 1 character), and pass either all of `path`, or use the `&amp;` operator to get the address you need.
Wouldn't that be dynamic memory allocation? If that's what you're suggesting; we only learned that yesterday and technically can't use it for this lab :(
So the reason my program is crashing is because of my str_replace? This is only our fourth lab, and the class is built terribly, we do things in lab 2 weeks before we learn them in lecture.
There are plenty of resources, starting with the Wikipedia article. To be honest, I understand the concept but have never bothered to learn many specifics of what things in C cause sequence points and which things don't. Unless you're working on the compiler itself, you usually don't need to know because you should be structuring your code more cleanly to avoid it. (It's nice to know intimate details about C, but I also need to study design patterns and other concepts that are more important to the code I work with than the details of sequence points.) Here are the essentials of what you need to know: * `&amp;&amp;` and `||` short-circuit. Internally, this means there's a sequence point before each one. * Most other operators don't cause sequence points. If you do `f() + g()`, the compiler can legally choose to execute `g()` before `f()`. If you want to write `f() + g()`, but it matters to you whether `f()` or `g()` is executed first, then be explicit about it. Call them each separately, assign their values to variables, then add those variables.
Problem is, path isn't path[], it's a const char *, so when trying to do path[0], it doesn't work. I end up doing this: int parentPathLength; char pParentPath[1]; folderName = strrchr(pDirName,'/'); parentPathLength = strrchr(pDirName,'/') - pDirName; // Folder creation at root if ( parentPathLength == 0 ) { numParentInode = ROOT_INODE; // Folder creation in a subfolder, getting parent node }else{ memset(pParentPath, '\0', parentPathLength+1); strncpy(pParentPath, pDirName, parentPathLength); numParentInode = findFolder(pParentPath); } Might not be the prettiest, but it work. When I try to do [] with const char *, it always give me error, even when comparing with ''. Thanks again, I wish I had learned C at school and not Java; the move from Java to C is not as easy as people says...
I think you need to read up about pointers, malloc, the heap and the stack, also linked lists, because that is what this seems to be. And why write 0x00 instead of NULL? And I know, compiler messages can seem cryptic sometimes, but generally if you copy/paste the error message into google you'll find the answer pretty fast
In your header, you've defined `StudentRosterP` to be a pointer to some `struct StudentRoster` to be defined elsewhere. *You've never defined this structure*, you've only defined a `struct StudentRosterP`. Notice the extra `P` (which probably stands for "Pointer"). So, that's what you need to sort out, when to use `StudentRoster` and when to use `StudentRosterP` and when to use the struct keyword. Also, make sure your `malloc()` uses the size of `StudentRoster`.
Well, it's supposed to return a null pointer, so I don't know how else I would do that
Basically what you need to do is to determine the bit values of each bit that makes up int h. The way you can determine bit values is by doing a bitwise AND operation. Essentially loop through each bit value from 0-31 do a bitwise AND on that value with int h. That will tell you where all the one's and zero's are and from there it's just a matter of printing them out. Does this help?
First off, "octadecimal" would be base 18. You probably meant "octal" which is base 8. If you really needed octadecimal, the `%o` specifier won't work. There's no format specifier for binary. To convert to binary, you'll have to write the algorithm yourself and print it out one bit at a time. The solution is to use bit-shifting and masking (or alternatively, division and modulus) to get each bit. Wrap this in a loop, and you're done. Alternatively, you can convert to hex or octal and convert from there, as that's very easy to do.
i misread the notes in the .h file, and you are correct, thanks.
Thats an unnecessary complication. Fixed sized buffers suck.
I changed my entire str_replace function and used malloc to dynamically allocate the size of my arrays instead of using fixed size buffers. Originally I was using too small a size for my target array compared to my original that's why I had a stack overflow, so after changing that my program didn't crash anymore. I commented shit out to figure out where the crash was occurring and it was in my replace function. I also used strstr to implement the replace algorithm instead of trying to code that myself, which I didn't know how to do. Basically my program was replacing what I wanted replaced with the string I wanted, however, since my main was using a do-while to loop through everything I couldn't get my replacement to work after the first replacement. i.e my text file said "I am an electrical engineer". I replaced "electrical" with "computer" and it worked just fine. But when I tried replacing again AFTER the first replacement, then the second replacement would work for another string, but the first replacement would revert back to it's original string. I just turned the program in that way since I need to study for my Power Electronics midterm which is tomorrow. Anyways, I was the only one to figure it out in my class (especially using a function with "pass by reference" and using dynamic memory allocation) so I guess you're wrong buddy. Thanks but no thanks for the help, take your shit-talk to the Call of Duty subreddit.
Our professor is really old and extremely boring/monotone and has terrible slides and literally doesn't explain anything. Not to mention our lecture "teaches" concepts AFTER our lab is due, so yea I'm basically teaching myself all this shit.
And you didn't think any of that was relevant in your original post?...
for one thing all this terminology is new to me, I just spent like 6 hours on my program debugging and barely got as far as i did
Yes, making the file in a text editor and saving it as ex1.c is what you should do.
was bored so made one for unsigned only http://ideone.com/JG8QF9 rate me/10
The screenshot you linked doesn't say a thing about XCode. If you're doing this on a Mac, you need it so you have a compiler.
How is converting from hex or octal easier? Isn't it the same bits no matter what the representation? Or do you mean a string version of the integer in hex or octal?
Yeah, I glossed over that. You convert the number to it's string representation in octal or hex, and then parse that one character at a time to produce binary.
Why would one do that? Just uint64_t n; uint64_t msb = ~0; msb = msb &gt;&gt; 1; msb = ~msb; for (int i = 63; i != 0; --i) { if (n &amp; msb) putchar('1'); else putchar('0'); n = n &lt;&lt; 1; } It may say something about me that I think that is simple...
Well, you have a bug, first of all. And second, it's even simpler than that: for ( uint64_t mask = UINT64_C(1) &lt;&lt; 63; mask; mask &gt;&gt;= 1 ) putchar(mask &amp; n ? '1' : '0'); But not everyone thinks this is simple, just because they might not understand it. Doing a conversion from a hex or octal string is very easy to understand (even if the code is going to be slower and more verbose in the end).
You can just use XCode. File -&gt; New project -&gt; OSX -&gt; Application -&gt; Command Line tool -&gt; Language: C It will generate a project for you with "hello world" `main.c`. You will be able to run the project from XCode.
You might want to pick a more basic tutorial that doesn't assume any experience with programming. 
 double a=0; while( scanf("%lf", &amp;a) != EOF ) { printf("%lf\n", a); } scanf() return EOF upon error or EOF signal (STRG+D). EOF is a macro that evaluates to (-1), which you're comparing to a double value ( generally shoudn't work ). Still thinking about the "numbers barrage". Looks like some input is not being consumed and therefore feeds the loop. EDIT: Yeah scanf() only consumes matched input. If you input anything that doesn't match a double it will "barrage" you. [This might be useful aswell](http://c-faq.com/stdio/scanfprobs.html)
But that's SIGINT. OP wants to quit the loop on EOF. Sure, STRG+C if nothing else works. Also [this](http://i.imgur.com/6u3dd.png).
what about a row where it's: 1 1 3 4 5 6 7 9 9 ?
I *think* (it's been a while) that you're guaranteed that another row or column will be invalid in that case. That doesn't sound right, though, so maybe my memory is off and I'm just wrong on this.
Learn [Python](https://www.python.org/) first and do their tutorials.
Sounds like you are looking for the easy way, not the hard way &gt;.&gt;
You need to check both row, column and quadrant in order to know the correctness. It is possible to create a sudoku grid were any two of them passes the test without being a valid solution. 
as well as what everyone else said, you are mallocking the wrong number of bytes. Do this instead: `StudentRosterP thisRoster = malloc( sizeof *thisRoster );`
`EOF` is usually -1 but it's not guaranteed to be, it may be any negative integer.
It makes sense that the tutorial would be for people that don't need it.
It would in most cases, but "the hard way" tutorials usually has the point of filling the gaps that sometimes are very fundamental, but not always approachable in certain programming practices. C has especially many of these quirks. Of course you can start learning "the hard way" too, but certain prior knowledge is expected.
That second grid is a perfect illustration of why I'm wrong. I wonder what I'm remembering now, or if I just made this up. I think checking that everything adding to 45 (and making sure all numbers are 1-9) is probably a 99.9% check of validity, but not a guarantee for sure.
I'm not sure which of these two things you're trying to do: If you're trying to keep your user from knowing that `struct File` is really just a `FILE`, I'd say don't bother. Or if you want, `typedef FILE* myOpaqueFile`. But really, if `CloseFile()` isn't going to do anything other than cast to the correct type and call `fclose()`, then what's the point? Why would I want to use this instead of just calling `fclose()` myself? If you're trying to provide your user a `struct File` that they don't know the internal structure of, which *contains* a `FILE*`, then the cast you're doing in `CloseFile()` is wrong. It's not that `struct File*` *is-a* `FILE*`, it's that `struct File*` *has-a* `FILE*`.
 struct File; void CloseFile(struct File* file); the C file currently looks like this. struct File { FILE *myFile }; void CloseFile(struct File* file); { FILE* f = file-&gt;myFile; fclose(f); } You waste 4 or 8 whole bytes this way, but meh who cares. The alternative is without the pointer: struct File { FILE myFile }; but I can't remember if that's allowed with file and can't be bothered to check for you. Search for PIMPL.
I want to hide implementation details, prevent misuse, and provide flexibility when porting to a different platform. It works as it is now, but I think the casts are not very elegant. I challenged myself to try to write code with as little macros and casts as possible. :) 
Just curious, how do you see this as preventing misuse? Shouldn't anyone working with your API be able to use a FILE? If they can't even fclose correctly, I can't see how they can even be writing C code. FILE and fclose, etc are part of standard C, they are already platform independent. Not trying to be argumentative, just trying to understand your logic.
I think this is the right answer. Considering that fopen returns a FILE*, I think you pretty much have to waste sizeof(FILE*) bytes. The stdio family of functions are a part of the C standard library though, so there's not much reason to wrap them. Despite that, there's already quite a few libraries out that wrap IO calls, so you might want to use one of those.
&gt; At compile time there is no way to make sure that the argument is in fact a valid file desciptor. There's no guarantee of it at runtime, either. Maybe a different thread in your application closed the file. Maybe it's a pipe, and the other end closed the pipe. You also mention working with URIs that might involve network access, in which case you can *definitely* not assume that the "file" will continue to be accessible after first opening it. You're trying to provide a bit more typesafety, but C is not a particularly typesafe language. A `typedef` in C is merely a convenience for the reader, but doesn't provide any extra typesafety. To the compiler, a typedeffed name and the underlying type are completely interchangeable. And casting is not the answer to providing typesafety. It's the exact opposite. If you expect people to use your library because it provides extra typesafety, it should itself be written in a typesafe way. And that means no casting. &gt; It is also easer to do things like logging, check for read/write permissions and other system features not exposed by stdio The reason stdio doesn't expose them is that those operations are all *not portable*. Unix and Windows each have *very* different ideas about what constitute file permissions. Beyond a trivial "am I presently able to read or write to this file", I can't imagine what single API would portably let me manipulate file permissions.
For _very_ simple unit tests I use https://github.com/ThrowTheSwitch/Unity All you need to do is: 1. grab unity.h, unity_internals.h, unity.c, and generate_test_runner.rb 2. write a single test program that includes unity.h 3. that test program has no "main()", just independent test functions of the form "void test_this(void){...}" 4. within each function test your function results using macros like "TEST_ASSERT_EQUAL(0, r);" 5. run "ruby generate_test_runner.rb my_test.c" to generate a wrapper test runner program called "my_test_Runner.c" 6. compile that with unity.c my_test.c 7. run the resulting executable 8. fix your bugs 9. compile and run again 
This is the problem. A single '=' denotes *assignment*, while a double '=' (i.e. ==) denotes *is equal to* if(hour = 0)
1) if(minute&lt;60 || minute&gt;0 || hour &gt; 0|| hour&lt;24); this line does nothing 2) I think scanf will return everything up to the return key press, so you might be handling it wrong. 3) the hour=0 problem people have noted 4) hourangle += 0.5*minute; probably better to do minute/2 instead. 
In other words, use the -Wall compiler flag on clang or gcc to turn these warnings on.
You can increase the stack by means of the linker, but I don't think that will help much in this case. Trying to have two very large objects in memory (and apparently on the stack), is a very bad idea. Pointers are there specifically to solve these kinds of issues. Also, why are you using Visual Studio C++ for C? Last I checked MSVC only supported C89.
You can only overload the stack either through recursive/nested calls or (improper) local variable allocation. What is your algorithm actually doing? Is it recursive? You may have to [rewrite it to be iterative](http://rosettacode.org/wiki/Y_combinator). It also might be how you are allocating your matrices. 10000x10000x8bytes(64bit?) = 800MB. If that's going on the stack you're going to have a bad day. 
BLAS is the clear answer here *. You will get a fast and efficient multiplication. I highly recommend OpenBLAS, here http://www.openblas.net/ They even have Windows binaries built. * unless homework. 
Isn't it 2 * 800MB because you would be using both matrices?
Yep, but I thought that was implied :)
I just wanted to make sure I did the math correctly earlier, as I'm still in the beginning stages of learning programming and want to know I am looking at these things the right way. I had written up a post about how doing logic with 1.6 gigabytes of data in memory probably isn't the way to go, but never posted it in case I was wrong and didn't want his first response to be some noob bringing bad math and no help to the table :)
What problem are you trying to solve here? Why are you avoiding pointers/dynamic memory allocation? 
 for( r = 0; r &lt; ROWS; r++ ) for( c = 0; c &lt; COLS; c++ ) answer[ r ][ c ] = mata[ r ][ c] * matb[ r ][ c ];
Ah, sorry. :)
and likely a third one to store the results.
Can't thank you enough for the time you put into helping me out! Yop I guess that would be using random numbers chosen by the computer in that range.What we were told is to use this: i = a + rand() % (b - a + 1); in place of a and b putting the numbers.Is this the right way to do it?
actually you've got the definition of [matrix multiplication](http://en.wikipedia.org/wiki/Matrix_multiplication#General_definition_of_the_matrix_product) wrong, you need to sum the product of all the numbers that go across the first matrix and down the second one. The simple algorithm would look more like: for( r = 0; r &lt; ROWS; r++ ) for( c = 0; c &lt; COLS; c++ ) for( x = 0; x &lt; ROWS; x++) answer[ r ][ c ] += mata[ r ][ x] * matb[ x ][ c ];
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 3. [**General definition of the matrix product**](https://en.wikipedia.org/wiki/Matrix_multiplication#General_definition_of_the_matrix_product) of article [**Matrix multiplication**](https://en.wikipedia.org/wiki/Matrix%20multiplication): [](#sfw) --- &gt; &gt;If __A__ is an *n* × *m* matrix and __B__ is an *m* × *p* matrix, &gt;&gt; &gt;the __matrix product__ __AB__ (denoted without multiplication signs or dots) is defined to be the *n* × *p* matrix &gt; --- ^Interesting: [^Min-plus ^matrix ^multiplication](https://en.wikipedia.org/wiki/Min-plus_matrix_multiplication) ^| [^Strassen ^algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm) ^| [^Matrix ^chain ^multiplication](https://en.wikipedia.org/wiki/Matrix_chain_multiplication) ^| [^Cache-oblivious ^matrix ^multiplication](https://en.wikipedia.org/wiki/Cache-oblivious_matrix_multiplication) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmb2wp2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmb2wp2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
No clue, not very mathematical, me. I guess the rand function can create large numbers which you run through that formula to make more manageable, or in a specific range? If you know what a and b are supposed to be, the % in this case is the modulus operator. i is the remainder after the bit on the left side of it is divided by the bit on the right side of it. I guess you replace i with t[i] in your loop. Define two more integer variables with the others, e.g. int a=1, b=20; or whatever you were told to define them as, then just plug the formula in. t[i]=a + rand() % (b - a + 1);
That sounds about right. That should work for finding random integers within the range (a, b).
Wait, what? You want to have a list of all of the natural numbers? There's no point for that, you have access to the &lt; and &gt; operators.
It's not entirely clear what you're asking. It sounds like a bracketed tax system? So for 1,000,000kr you would have: 450,000\*.02 + 150,000\*.04 + 150,000\*.06 + 250,000\*.08 Is this what you're asking?
I know I didint explain it in the best way becuase I just dont know how, let me try again. We have Float taxValue1; In taxValue1 I want to store everything between 450 000kr and 600 000kr. Say we have taxValue2; there I wanna store everything between 600 000kr and 750 000kr. A user has to enter how much money he earns. If he earns anything between taxValue1, the taxes will be 2%. If anything between taxValue, tha taxes will be 4%. For example, I can set a variable to a specific number. int x = 5; But I want to know how to set this x or those taxvalues between 2 numbers. as in, x is all the values between 5 and 10. Im not sure if this is even possible. Maybe I read the task I got entirely wrong? If so, I can try and translate it to english and post it here.
I know I didint explain it in the best way becuase I just dont know how, let me try again. We have Float taxValue1; In taxValue1 I want to store everything between 450 000kr and 600 000kr. Say we have taxValue2; there I wanna store everything between 600 000kr and 750 000kr. A user has to enter how much money he earns. If he earns anything between taxValue1, the taxes will be 2%. If anything between taxValue, tha taxes will be 4%. For example, I can set a variable to a specific number. int x = 5; But I want to know how to set this x or those taxvalues between 2 numbers. as in, x is all the values between 5 and 10. Im not sure if this is even possible. Maybe I read the task I got entirely wrong? If so, I can try and translate it to english and post it here.
I'm still utterly confused as to why you wouldn't do something like if (value &lt; 450000 ) do_something(); else if (value &lt; 600000 ) do_something_else(); .... E: And to answer this: &gt; But I want to know how to set this x or those taxvalues between 2 numbers. as in, x is all the values between 5 and 10. Im not sure if this is even possible. The answer is that it is not possible to store many values into one variable, since memory just... works that way.
Dude. Use if statements. No need for variables. If you want, you could use #define or a constant variable (const double x or whatever) for each tax rate. Then just set it up like so: if(income == 45000) { tax = income * tax_rate } Edit: an example of in between rates... if(income &gt; 45000 &amp;&amp; income &lt; 75000) { tax = income * tax_rate }
The reason as to why I wouldnt do something like that is becuase Ive been programming for 12 days only and Im not so good atm for very obvious reasons. That being said, Thank you very much^^
It's fine :) everyone has to start somewhere. If statements and switch statements are the staple for problems like you're having.
No worries man, we've all been there :) This sort of thing is probably explained in your textbooks better than you'll find it here, I suggest you use the resources you have.
Yeh just trying my best to work my way up, is it okay if I keep contact, incase I get really stuck on something? Would always be helpful, thank you
A big part of being a developer is learning how to use *authoritative documentation*. Videos can be good for some things but for programming, I would not suggest that you rely on them. Instead learn how to read books, API specs, RFCs, man pages, all of that. The best answers come from the source. No, you can't do that :) That's what your teacher is for.
You would have lost the bet fine sir, becuase this task along with others was released a couple of hours ago, sunday, before weve had a single lesson on them! But yeh you are probably right :p I'll give them another shot thank you^^
fgets to read a chunk, then run through it until you find what you're looking for. I have no idea what you're trying to say when you say: &gt; then have it as a command line argument for the output. 
No. fopen opens a file, fclose closes a file. fgets reads stuff, like fgetc does, except it's not just a single character. The C is for character, the S is for string. 
Not at all hard, and you have half of it right. int main(int argc,char *argv[]) { FILE *in; FILE *out; in = fopen(argv[1],"r"); out = fopen(argv[2],"w"); /* rest of code */ } You'll also need to check to see if the file names are given (argc is the number of arguments to the program; it's always 1 or larger, as argv[0] is the name of the program itself) and check to see if fopen() succeeded. 
The problem is that you're stack-allocating your matrix *(it takes more than 2GB worth of stack memory)*: float a[10000][10000]; float b[10000][10000]; float c[10000][10000]; Don't do this! Heap allocate it instead: float*a = calloc(10000*10000,sizeof(float)); float*b = calloc(10000*10000,sizeof(float)); float*c = calloc(10000*10000,sizeof(float)); Of course, this means accessing indexes in the matrix is awkward *(without using pointers)*. No problem, simply move the access into a separate function: void mul(float a[10000][10000],float b[10000][10000],float c[10000][10000]) {...} mul(a,b,c); 
Quick question, when I use fclose() for those two, I only need to use it once correct? 
Guess you need eli5 treatment, sometimes folks learn best in different ways. //Set up constant variables for the percents, //const means a number that is fixed. float is a kind of //floating-point number which you will need if you want //to divide something accurately. //As they are floats you need the ".0" bit in the declaration/assignment. const float taxrate1 = 2.0; const float taxrate2 = 4.0; const float taxrate3 = 6.0; const float taxrate4 = 8.0; //You could just enter the numbers in the if statements below, //but if you do a whole bunch of things with these figures it makes //sense to define them once. //-edit-2 back to long int again... const long int taxthreshhold1 = 45000000;//cents const long int taxthreshhold2 = 60000000;//cents const long int taxthreshhold3 = 75000000;//cents //Set up variable for value which holds the income entered. //Where you get this from in your program is up to you. long int value;//in cents //Ask if the value is under 450000 or taxthreshhold1 if (value &lt; taxthreshhold1) { //Calculate percentage with taxrate1 and do something //with it, I chose a simple printf to print a calculated value //on the screen. //(no idea if the calculation is correct, it's just a default // percentage calculation of the values presented.) printf("Income is in band 1, percentage=%.2f.\n", (((float)value/100.0)*taxrate1)/100.0); } //Ask if the value is more than or equal to 450000 AND is less than 600000 if (value &gt;= taxthreshhold1 &amp;&amp; value &lt; taxthreshhold2) { //Calculate percentage with taxrate2 printf("Income is in band 2, percentage=%.2f.\n", (((float)value/100.0)*taxrate2)/100.0); } //Ask if the value is more than or equal to 600000 AND is less than 750000 if (value &gt;= taxthreshhold2 &amp;&amp; value &lt; taxthreshhold3) { //Calculate percentage with taxrate3 ... } //Ask if the value is more than or equal to 750000 if (value &gt;= taxthreshhold3) { //Calculate percentage with taxrate4 ... } HTH
You need to close each file once and only once.
Thank you!
Note that the struct should be "packed", i.e. tell the compiler to not add padding bytes for optimization. Without packing, the file will be larger than necessary and, more importantly, the same program on a different platform or even compiled with optimization options will produce different file formats. For gcc: struct unit { ... } __attribute__((__packed__)); For msvc: #pragma pack(push, 1) struct unit { ... }; #pragma pack(pop) 
Oh, nice one. I didn't know about that `__packed__` option. That solves alignment issues, I guess. But what about `sizeof (int)`? If I simply try to read `sizof (int)` bytes this might later bite me in the ass. I could be saving and reading data in different architectures. I mean, besides solving my specific problem, I am interested in learning the real-world solution for this problem. How do I save data so that I can load it 10 years from now when the word size is 16 bytes instead of 4 (wild example)?
Be careful here. Floats are tricky, and they also have endianess. Dump floats in binary form on one machine and read them on another machine and you will have a bad time! Storing floats in text form is also tricky. You will have loss of precision. Try writing and reading a float back and you will discover that they are not the same numbers when you compare them directly. The most practical recommendation I can give you is to save the floats in hexadecimal flormat. The `%a` format flag was added to printf in C99 and is even available for MSVC. It's more compact than `%f` and you have bit exact perservation of your values. edit: If space is a concern and you need a binary solution, you should look for a [marshalling](https://en.wikipedia.org/wiki/Marshalling_%28computer_science%29) library. edit2: Apparently there are no pure marshalling libs. What you need is a serialization lib that does marshalling. I think google's [protocol buffers](https://github.com/protobuf-c/protobuf-c) does this, but don't quote me on that.
&gt; I mean, besides solving my specific problem, I am interested in learning the real-world solution for this problem. How do I save data so that I can load it 10 years from now when the word size is 16 bytes instead of 4 (wild example)? In the scientific computing "real" world, this is done via HDF5. (A C library and file format.)
There's a bunch of typedefs available for you to use in `&lt;stdint.h&gt;`. For example, `int32_t` is guaranteed to be some sort of 32 bit integer, whatever that is for your platform. I don't know of any similar macros for floating point numbers (a `double` on some systems could technically be the same thing as a `float`), though this isn't a terrible problem in practice. If there's a chance that your data could be read by a system of different endianness, I would highly recommend converting each field to big endian before writing. The `hton` set of macros will do this for you.
First of all, never ever ever EVER store monetary values in floating point, it is considered bad practice. Now to the topic. You can't store ranges in a single variable (for the most part). If you want to store a range you need to use a struct. typedef struct range { int max; int min; } range_t; However in this case, you can just do the following. float getMoneyPercent(int money) { if(money &lt; 450000) return 0.02; if(money &lt; 600000) return 0.04; if(money &lt; 750000) return 0.06; //otherwise &gt;= 750,000 kr return 0.08; } //how to use int moneyFraction = (int)(getMoneyPercent(money) * money); 
Note that none of the responses so far provide any guarantee of portability. 
Could you please clarify why it is bad practice, I thought keeping track of the fractional part is important with currency. Thanks
Because of rounding errors. [See here for more details on this.](http://stackoverflow.com/a/3730040/1234970)
Here's the good news. I can use pointers, and now that I developed a badly working solution without them, I am more determined than ever to build a solution using pointers. When I am in front of a real computer, I will post my bad solution (don't run it for 10000 X 10000 - change it to 100 X 100 or your computer will become sad), and my efforts at a better one using pointers. My big conceptual gap is not in initializing the matrices as pointers, but translating from non-pointer arithmetic to pointer arithmetic. Now that the threat of a deadline has passed, we can even tackle a simpler problem first and then work up. Will be in touch.
Have you tried just compressing the files with a compression utility of some sort? That would at least be lossless - i.e., the input would exactly equal the output.
Indent your code with four spaces to have it appear in mono spaced font. This makes it much easier for others to understand the code you post.
Could you please indent your code with four spaces? This makes it appear in mono space font which makes the code much easier to read than it is right now.
Is the line beginning 26783 on your output the last line of the suture.dat file, or does the last line end in zero?
The easy way? system("shutdown");
Sorry! Done.
The last line of the suture file is four zeros. I have to make the program know that four zeros indicates the end of the document instead of using EOF, I think. I'm trying to figure that out now. 
&gt; any big endian PC Most PCs are little-endian. x86 and x86-64 definitely are, which covers more than 99% of computers this code will likely run on.
&gt; why are you using Visual Studio C++ for C? Last I checked MSVC only supported C89. So? It's a free IDE that's conveniently available, has pretty good editing and debugging tools, and compiles C code.
Thanks for clarifying, wasn't sure if that was one of the problems you had. I've been checking and it looks like fscanf returns EOF if it finds EOF or an error, so there shouldn't be a problem with it finding the end of the document.
Okay, so I fixed my problems and the program is running smoothly. However, I forgot to tell the program that when it reads four zeros in the suture file, that indicates the end of the data. Right now I'm using EOF but I need to change that but am not sure how, any advice?
maybe I'm missing something from just a quick glance, but can't you just do if(batchnumber==0 &amp;&amp; temperature==0 &amp;&amp; ...){break;} at the start of the loop?
So with this command, if for example I write something like system("taskkill firefox.exe"); it will close my firefow window?
It'll do the same thing it would do from the command line. If that's what it takes to get to close firefox, then it should work fine.
The portable and future proof way is to convert your floats to the standard IEEE 754 format then dump its binary components in the order specified in the standard. The good news is that on many computers the memory representation of a float is IEEE already, so you can just dump the bytes one by one. For other systems the C library provides accessor's for the IEEE number components, namely sign, exponent and mantissa so you can pack them as bytes yourself.
Okay thanks a lot :D
You guys are awesome! That worked! I am unfamiliar with {break} though (This is my first C class). Does that just break the loop and go on in the code?
yeah, the break keyword basically means "ok I'm done, don't bother with the rest of this loop (or switch statement)" it's just 'break' though, and a semicolon at the end just like with the 'return' keyword and function calls. the { and } are just a code block, like with the ones that surround your while-loop. they're actually not required here since it's just one command following the if-statement, but personally I prefer to use them anyway to avoid confusion. (there's also the 'continue' keyword that means "screw this iteration, but keep looping on the next one")
I'm very busy with this type of decoupling at the moment. Say you have a lower layer that you wish to vary (eg. ECOS RTOS vs Linux), (Intel CPU vs ARM) As soon as you pull in a header from that lower layer you are tightly coupled. The solution is the [Dependency Inversion Principle](http://en.wikipedia.org/wiki/Dependency_inversion_principle). Now the obvious and most common way of implementing that principle is via Dependency Injection... ie. You just pass pointers to the base class around, and the higher layer instantiates the concrete subtype. The problem with that and C is it doesn't play nice with stack allocation. Passing pointers around means somebody somewhere has to manage that memory, and in the absence of garbage collection and virtual destructors ala C++, it's hard to get perfect. So you want to do this so you can instantiate one of these objects on the stack or as a static. But as soon as you try that, the compiler has to know the sizeof() and the __alignof__() the actual concrete object. So this is what I've settled on... So in "my_type.h" typedef union { char __size[N]; alignment_type_t __align; } my_type_t; #undef my_type_t void do_stuff_with( my_type_t * t); So there are two mysterious things in there... the N and the #undef, I'll explain them later. The alignment_type_t is merely there to force the alignment of your opaque type to match the worst case for the concrete sub type or BAD THINGS happen. (bus faults on sparcs, slow down on intel) In your my_type_concrete_sub_type_A.c file you have... #include "concrete_sub_type_A.h" typedef concrete_sub_type_A_t my_type_t; #define m_type_t m_type_opaque_t #include "my_type.h" fileScopedCompiledTimeAssert( sizeof( m_type_t) == sizeof( m_type_opaque_t)); fileScopedCompiledTimeAssert( __alignof__( m_type_t) == __alignof__( m_type_opaque_t)); void do_stuff_with( my_type_t * t) { // t is a pointer to concrete_sub_type_A_t here! // That's why there is that #undef and #define! No nasty casting // things around! } If you don't know what a compile time assert is, that's the subject for another post. Now we need to think about that N and how we define it. We could make it exactly the size of the underlying concrete type, or the worst case maximum for all possible underlying layers, or vary it according to what the layer we using now is.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Dependency inversion principle**](https://en.wikipedia.org/wiki/Dependency%20inversion%20principle): [](#sfw) --- &gt; &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), the __dependency inversion principle__ refers to a specific form of [decoupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming\)) software [modules](https://en.wikipedia.org/wiki/Modular_programming). When following this principle, the conventional [dependency](https://en.wikipedia.org/wiki/Dependency_(computer_science\)) relationships established from high-level, policy-setting modules to low-level, dependency modules are inverted (i.e. reversed), thus rendering high-level modules independent of the low-level module implementation details. The principle states: &gt;&gt; &gt;&gt;*A. High-level modules should not depend on low-level modules. Both should depend on [abstractions](https://en.wikipedia.org/wiki/Abstraction_(computer_science\)).* &gt;&gt;*B. Abstractions should not depend on details. Details should depend on abstractions.* &gt;The principle *inverts* the way some people may think about object-oriented design, dictating that *both* high- and low-level objects must depend on the same abstraction. &gt; --- ^Interesting: [^Inversion ^of ^control](https://en.wikipedia.org/wiki/Inversion_of_control) ^| [^JVx ^\(Framework)](https://en.wikipedia.org/wiki/JVx_\(Framework\)) ^| [^Dependency ^injection](https://en.wikipedia.org/wiki/Dependency_injection) ^| [^Service ^locator ^pattern](https://en.wikipedia.org/wiki/Service_locator_pattern) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmc0nna) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmc0nna)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
getopt is what I use for command line flags. So ./program -I input -o output http://en.m.wikipedia.org/wiki/Getopt
'Network order', used for IP packets and common in other binary protocols, is big endian. Makes sense to use it for this sort of thing. It's a sort of standard.
Here is the bad code as promised - make absolutely sure you change N=10000 to a lower number, like 1000, or else you will be waiting forever: We can immediately improve it by removing the conio.h import and the getch() at the end. I am also dissatisfied with the timer (it has insufficient precision for smaller iterations), but we can absolutely use time.h. Also, change the format mask on the placeholders to %.2f so we can actually see a difference with smaller N's ... #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;time.h&gt; void main() { int i, j, k, N = 10000, product = 0; time_t time1, time2; double seconds; //with locality optimization printf("\nPlease wait... Processing large matrices takes some time.....\n"); time(&amp;time1); for(i = 0; i &lt; N; ++i) { for(j = 0; j &lt; N; ++j) { product = 0; //C[i][j] = 0; for (k = 0; k &lt; N; ++k) product = product*1; //C[i][j] += A[i][k] * B[k][j]; } } time(&amp;time2); seconds = difftime(time2, time1); printf ("\nTime required with optimization : %.f", seconds); // without locality optimaization time(&amp;time1); for(i = 0; i &lt; N; ++i) { for(j = 0; j &lt; N; ++j) { product = 0; //C[i][j] = 0; for (k = 0; k &lt; N; ++k) product = product*1; //C[i][j] += A[i][k] * B[k][j]; } } for(i = 0; i &lt; N; ++i) { for(j = 0; j &lt; N; ++j) { product = product*1; } } time(&amp;time2); seconds = difftime(time2, time1); printf ("\nTime required without optimization : %.f", seconds); getch(); } 
It sounds like you might want a shell script of batch file rather than a C program. While you certainly can use system() from a C program to do the same thing, if what you're doing is just chaining together other programs, a shell script is probably more appropriate.
And what is the syntax if I want to do this?
I thought you were suggesting me to launch this .bat file from my C program (if there is a way to do this could you explain it to me?)
Depending on just how complex your command needs are, you could either 1) do as everyone has been suggesting and use system() to start familiar command-line processes *or* 2) dive headfirst into the operating system and do whatever you need to do through Windows API calls. If your commands are all akin to "taskkill firefox", I strongly suggest the former.
 #include "header.h" int main(...) {...} Make sure to use [include guards](https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;uact=8&amp;ved=0CCkQFjAB&amp;url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FInclude_guard&amp;ei=EWt0VNusCcLUOaySgZgD&amp;usg=AFQjCNE-LLUHx6rseVMmcC0fY3qeVOBVDA&amp;sig2=h4n1TCC4aJxcWgsAiuhRWA&amp;bvm=bv.80185997,d.ZWU) Sorry, you probably meant this: gcc -I path/to/headers
Nope. Yells that no such file "header.c"
You know what else is free, convenient and easy to use with good C editing and debugging tools? Eclipse CDT, Code::Blocks, NetBeans, and CodeLite, among many many others. You know what else? They all have far better C support than Visual Studio does, and none of them are just a cut down version of a bigger bit of software. So... &gt; Why are you using Visual Studio C++ for C?
You have to either include header in C file (#include "header.h"), or (if you want to override system header) to include it (#include &lt;header.h&gt;) and specify "-l ." as gcc parameter. Replace header.h with your header name and . with directory where header is placed. As Mathyo said, don't forget about include guard. The common form is #ifndef _HEADER_H_ #define _HEADER_H_ /* definitions */ #endif
It sounds like you're confused about what exactly a header is. When you `#include &amp;lt;stdlib.h&gt;`, stdlib.h is a plaintext file containing C code just like your main source file. All the include directive says is "take the contents of that file and paste them in here." To create a custom header file, you just write a C file with whatever you want in it, save it as myheader.h (or, realistically, .anythingyouwant; the preprocessor is not picky about extensions), and `#include` it into your program *with* (important) "quotation marks" rather than &amp;lt;angle brackets&gt;. The quotes tell the preprocessor to search for the file in the directory of the program rather than in the system include path. You can place a whole filepath in there if you like. There is a way, as people have been saying, to tell the compiler where to look for extra header files, but for simplicity's sake it is far easier to just place the header next to your .c file when you're just beginning. No fancy tricks, no cryptic options necessary; just compile and go.
Could you please post the contents of your main.c and header file so we can see what you're working with? (At least, a simplified version of the contents). However, in general main.c should `#include ""` the header file by name. Then to compile, you would use `gcc -Wall ./main.c -o ./prog`, where `./prog` is your ending program.
Where does `header.c` come from? Please give some more context. If you want to include files, use the [include directive](http://en.wikipedia.org/wiki/Include_directive#C.2FC.2B.2B). #include "header.h" int main(int argc, char **argv){ return 0; } *Linking* is about linking object files together to make up a binary executable or library.
I'm not sure you know what 'header' means. A 'header' in c is a file with the extension .h. It does not include any code - just function definitions, preprocessor stuff, and sometimes global variables. There should also be a c file. For example, if you have a library you want to use called myLib, it might have myLib.c and myLib.h. To use it, inside your main.c, you would add: #include "myLib.h" int main( int argc, char * argv[] ) { return myLibFunction(); } To compile it with gcc, you would do this: gcc main.c myLib.c -o myProgram Of course, this is a very simplified version of things. Libraries are often released as a header file and a shared library ( .h and .so ), or other formats, depending on platform etc etc.
You can run the batch file like it was a program, this should work: system("mybatchfile.bat"); But I was actually trying to say that you might not need a C program at all, that a couple of lines of .bat file might be all you need. 
I'm just trying to learn new stuff and function, perhaps I'll find a use to this later ;)
If you want portability there is APR, part of the apache project which provides a good chunk of what you're looking for. For regular expressions you can use PCRE, which is pretty easy to work with. String handling is hit or miss, I don't usually find it important enough to actually look for something outside of a unicode library, which I usually use this -&gt; http://gears.googlecode.com/svn/trunk/third_party/convert_utf/ConvertUTF.c 
&gt; As for string handling, unless there's a special need I generally just stick to C style strings. Do you have any specific requirements? Just a pretty basic stuff like get user input and tokenize it by whitespace. A few lines with Glib, all the vanilla C solutions I see involve allocating a buffer of arbitrary size... thinking about it I guess I could keep a manual counter of the number of chars I get as input and realloc.
Yeah, that's generally the way it's done. I hate seeing arbitrary-length buffers in C code, but that's by far the easiest way. But then someone happens to install your software in a weird place, and all the path names get really, really long, and you overflow one of those buffers... (happened to me recently).
It steps through the string, every time it encounters a space, it doesn't increment the second pointer, meaning the character after the space is written to where the space was. After all this is done, it writes zero to the end, marking it as the end of the string.
PCRE works pretty much everywhere.
Just wanted to agree here. I'm using it on a project that compiles on Windows, Linux and BSD.
I highly recommended antirez's sds library. https://github.com/antirez/sds 
Dude, this is a simple comparison. I'm not going to write it for you because if you can't figure it out then you're probably not ready.
NOT READY OK THANKS
I don't know the Thomas algorithm but looking at the code, the last for in the MATLAB code should also be (j=n-2:-1:1). You correctly start at 1 rather than 0 for MATLAB indexing but to get the same result they both need knocking 2 off the end. Unless I'm mistaken on the value of N and the C indexing - which is quite possible!
The statement if (num== -999) { /*something*/} Should be in there. That's all I can tell you without giving it away.
Can you provide inputs (a,b,c,f,N) and what compiler you're using? What compiler settings? What does sizeof(long double complex) yield?
Find a canonical dataset so you can determine which one is giving the wrong answer. BTW you could simplify your code a lot by doing `long double complex v[N];` and the malloc can be written: `long double complex *y = malloc(N * sizeof *y);`
 *i = *(j++); 
Thanks lol it was more of WHERE I needed to put it haha 
That's for you to find out! Remember that programs need to interact with changing conditions using conditional statements. If, else, switch, for, while, break, and continue are all useful here. Ignore the C syntax for a bit- what do you want to be done to the variables? You want a loop where the user is prompted for input, the input is checked, and a thing is done based on the input. Write that out in English and then think about what statements could be used to build the loop to do what you want. I was where you are at- it held me back to copy answers from the Internet. If you want to become a proper programmer, you need to be able to express algorithms in code like you can express ideas in natural language. I'm not nearly there yet myself, but the only way to develop that skill is to force ideas into code.
An interesting approach might be to use Lua. Yes, it's a scripting language, but it's easy to embed in an existing project, and you don't *have* to use the scripting ability. It supports dynamic arrays, hash tables, string handling and a simplified regex-like expressions. It's also quite small and highly portable (C89). 
 if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0) goto fail; goto fail; ... other checks ... fail: ... buffer frees (cleanups) ... return err; &gt;The problem was the second (duplicate) “goto fail”. The indentation here is misleading; since there are no curly braces after the “if” statement, the second “goto fail” is always executed. In context, that meant that **vital signature checking code was skipped**, so both bad and good signatures would be accepted. The extraneous “goto” caused the function to return 0 (“no error”) when the rest of the checking was skipped; as a result, invalid certificates were quietly accepted as valid. I may be completely missing the point, but where is the "vital signature checking code", is it "other checks"? I personally find this to be a very vague explanation. 
Something like these neat cheat sheets: http://imgur.com/a/qdElm There are many appendices and references for a language as well-known and used as C (heck, even the wikipedia articles are superb), but I haven't found anything for self-entitled shits like me who want everything presentable in bitesize chunks on one large image/page/poster to search at a glance. This is potentially better for the newer programmers amongst us who aren't sure what we're looking for because of a lack of familiarity with the standard library. Plus, I think it'd make a great poster to hang up somewhere in a man cave. I'm somewhat confident that I'm not the only one who wanted this, so perhaps this has already been done.
&gt; I'm looking for something that focuses on the standard library more, though. Nearly the entirety of the second page is on the standard library. Just print off page 2...
That flag is pretty analogous to `-Wmissing-declarations` for functions. You want to either declare those as `static` if you only want to use them in the current translation unit, or provide a header file so other translation units don't have to copy-paste the function's declaration. The same with variables. Either declare them `static`, or provide a header file declaring them `extern`. That's no more a violation of DRY than the dichotomy of function declaration / definition.
[Did you Google for that?](https://www.google.com/search?q=%22c+cheat+sheet%22&amp;oq=%22c+cheat+sheet%22&amp;aqs=chrome..69i57.3943j0j4&amp;sourceid=chrome&amp;es_sm=0&amp;ie=UTF-8)
This is way better than *Java 8 in 8 Volumes*! Seriously tho, very cool. I love C more than anything but don't get to play with it a often as I like, so this will be great for all those times I need to refresh.
If you `#include` a header containing `int foo;` in multiple translation units, that's undefined behavior. You may not have known that, because many compilers implement global variables in such a way that multiple definitions do not cause an error, but it is still invalid according to the language specification. Try adding `-fno-common` to your flags if you want to see what happens when that implementation detail is not used; you'll get linker errors for multiple definitions. Global variables need to be *declared* as `extern int foo;` in included headers and *defined* as `int foo;` in *exactly one* translation unit. Anything else is undefined behavior. 
21st Century C?
you can look at cppreference http://en.cppreference.com/w/ it covers both c11 and c++11 its not 100% done for c11 but its close.
Is this one the best modern C-Book or are their any better C-Books?
21st Century C is hard to compare with other books. It's a manual for people with previous programming experience (preferably C) to get started with using C for modern computers. It's good for what it's written for, but it's neither a complete reference or a guide to C. Try Head First C or something like that if you'd like to get into C (I like the Head First-series, because they encourage you to solve issues by hand and thought rather by trial'n'error). I haven't found any C11 reference that's better than just using `man` and Google. Anyone has any hints on this?
I'd go with glib. It's much more portable than you think it is (part of the whole reason it exists). Even if you're only using its string handling, regex, and data structure implementations, I still think it's worth it.
Thank you. This makes perfect sense and helps immensely.
I'm doing a review of this book for my local Linux user group right now. I believe what it teaches is solid, but beware of the tiny errors it contains. Especially when the book mentions POSIX, a lot of things are incorrect in some ways.
C Primer Plus (Stephen Prata, ISBN 0321928423) is quite complete and more beginner friendly. Also, it doesn't confuse ADT with OOP as does 21st Century C.
I'd still really recommend K&amp;R if you're trying to learn C. Once you understand C itself, picking up libraries like glib aren't much harder. 
I already have K&amp;R and I've gone through it, and I also have my own data types library on me. I just want a bit more on C basically.
There's also King: A Modern Approach to C Programming, which I personally find to be the best one out there. 
Do you have a book recommendation aimed at people with previous C/programming experience that deals with the implications/intricacies of using C in an embedded environment?
I'm not good enough at C yet to judge it but it seems to get negative reaction when you google it. Personally, I really enjoy programming in it (like it better than the STL).
For me that already knew C I think it was a very good resource to learn about all new(ish) stuff in the language. I also found the C Pocket Guide book surprisingly useful, because it just gave a good overview of all the types and functions the standard libraries has to offer that I keep forget (and some I did not know about).
It sounds like this is more of a database problem then a C problem. I can't really help unless I know what kind of database you are using. But if SQL it's probably something like SELECT * FROM students WHERE name = "&lt;name here&gt;" and grade = &lt;grade here&gt; 
http://pastebay.net/1532875 Please consider using PasteBay, PasteBin or Github Gists to post code on the internet. So basically, you take the information about the student, and you store this information in an array. The way you search this information is surprisingly simple, you just check each and every student in the array to see if it is the one you want.
 switch (int menu()); Have you tried compiling this yet? This line will not do what you want (and shouldn't compile at all) First, you don't need the "int" there as you're calling the function, not defining it. Second, you are ending that line with a semicolon, which basically ignores the result. Instead, you should have something like switch( menu() ) { case 1: do_something(); break; ... } Also, if your functions don't take any parameters they should be declared/defined as int my_function(void)
The 4-th Edition of Stephen Kochan's "Programming in C" got out 2 months ago. You can check it out.
`stdout` is a buffered stream. Use `fflush(stdout)` to flush output. Alternatively disable buffering with `setbuf(stdout, NULL)`.
Sadly, no. I did buy "Making Embedded Systems" by Elecia White (O'Reilly 2012) a week ago, but haven't read through it yet. Might be interesting to check out, though.
Thank you! I figured it had something to do with stdout but I couldn't name it.
Can you please indent your code with four spaces so it appears in mono space font? It's barely readable otherwise.
[C reference card.](http://web.stanford.edu/~nwh/cme212/files/c-refcard.pdf)
Using difftime like this has several issues. 1. You're discarding the nanosecond portion of `timespec`. Maybe the first check happened at 23.998 seconds... it will only take 0.002 seconds for the whole-seconds value to increment to 24, so you're not getting 1 full second. 2. `difftime` returns a double, so you're using floating point math to deal with integral numbers, which means unnecessary work for the CPU. 3. You're polling, which wastes CPU and prevents other tasks from running at the same time. Unfortunately, it's sometimes necessary if you absolutely positively cannot tolerate any overshoot... but since you're a standard user process, you can't prevent that anyway. Overall, you're better off using `nanosleep` or something equivalent if possible.
I picked up [Test-Driven Development for Embedded C](https://pragprog.com/book/jgade/test-driven-development-for-embedded-c), which was an interesting read. I've yet to put much of it into practice, but even with the little I've used it's still been pretty helpful. Everything else I know about embedded C comes from experience and practice. And some of it will always be particular to your platform and code base. (For instance, we have our own flavor of `assert()` that we use liberally, except that on the embedded platform it just logs an error and continues, so we have to also explicitly check for NULL and other unsafe conditions and code alternate behavior, even though there's an assert.)
Thanks for the reply but i can't solve it that way. The text file will be provided by user. So, he will think of a NxN matrix and write it in file. It could be 4x4, 6x6, 13x13 i dont know that. With fscanf i have to know how many numbers are in the row and i can't know that. That's why i can't solve it using that function and have to read file line by line. Is there a way to do what I want?
Here ya go: https://gist.github.com/anonymous/69d96dc497f652340379
First do something about your code getting spaces(32) and '\n'(10) characters and then putting them again then you might want to solve the problem number 10 or any 1&lt; digit number is gonna cause,in the printing for numbers 0-9 you can just do arr[i][j]-48
To do it like this? //Filling the array: for(i=0; i &lt; row; i++){ for(j=0; j &lt; col; j++){ c=getc(fp)-'0'; //Here I added the subtracting part; arr[i][j]= c; } } But still it is not good. This is the output: 0 -16 3 -16 6 -16 7 -38 3 -16 0 -16 5 -16 1 -38 
I am sorry, I don't understand well what you are referring to. Can you please explain in more detail? 
It's still not working, it is producing the same output. Here is how my code looks now: int main() { FILE *fp = fopen("graph.txt", "r"); char c; int temp, col = 0, row =1; int i, j, arr[10][10]; //calculating the no. of rows and columns in the text file do { c = getc (fp); if((temp != 2) &amp;&amp; (c == ' ' || c == '\n')) col++; if(c == '\n'){ temp =2; row++; } } while (c != EOF); //ERROR IS SOMEWHERE BELOW HERE rewind(fp); //Filling the array: for(i=0; i &lt; row; i++){ for(j=0; j &lt; col; j++){ c=getc(fp); arr[i][j]= c-48; } } //Printing the array for(i=0; i &lt; row; i++){ for(j=0; j &lt; col; j++) printf("%d ", arr[i][j]); printf("\n"); } printf("Columns: %d; Rows: %d \n", row, col); fclose(fp); }
You can still use `fscanf()`, just don't have it look for whitespace. Since you know there's going to be some kind of whitespace between elements of the array, use `fscanf()` to read the elements, then use `getc()` to read the whitespace and decide whether it's a space (which means next element on the same row) or a carriage return or newline (which means next row). Or just read the whole line into a buffer and use `strtok()` to parse it. Also, you can't store an arbitrary array size, because you declared your array as `int arr[10][10]`. So the biggest size you can hold is 10x10. You either need to pick a maximum size that will be allowed, and put in error checking to make sure the user doesn't exceed it, or you need to allocate the array dynamically so that you can determine its size at runtime.
It sounds like what you want is not a disassembler, but a decompiler.
It may also be the case that the linker can't find the implementation of that function i.e. you have a header file with a prototype but no definition.
Several comments. 1. Stylistically, IMO, this is *terrible* C. I never do pointer arithmetic directly as in the example as it hurts my brain too. For example, IMO, it's much easier to understand "&amp;a[3]" than "a + 3". Also, doing pointer arithmetic to calculate the initial values for the array is obtuse an unnecessary- just simply initial the array directly. If your instructor provided the code, shame on him/her (IMHO). 2. I'd suggest that you don't muck with the original array once you have created it. Instead, use a secondary array of pointers to pointers. That is, for example, "int *pa[N]". This array then points into "a[i]" for the appropriate 'i, and you can then muck around with what each pointer points at the achieve the effect of reverse and even/odd. That way the original data is always there. 
I still don't understand how to do it. I'm not that good when it comes to reading files. In the past I only used fscanf(). Can you explain in more detail how to do it? Yeah, I am planning to implement a function that will check if matrix exceeds dimensions of array. I will limit it to 30x30 because this is part of a much bigger project and it will take a lot for a computer to calculate what it needs if matrix is for example 40x40.
It should be working. It is working if I make project file with codeblocks and include header file in header folder.
Is there an output.c? gcc output.c main.c -o myprog -I. 
Yeah, I agree with /u/imlight77 , this is terrible code. More importantly, there is no way this is going to work : printf("Original: "); for (idx = 0; idx &lt; N; idx++) { printf("%2d ", revElement(a)); } printf("\n"); revElement(a) does not have a reference to the idx loop in the first place, location pointed to by a does not change, revElement() will return the same value ever time(or alternate times, depending on logic). Why would you reverse individual elements ? Your int revArray() does not follow the definition used in the sample code. It should be revArray(int *foo) {}. You are printing the string in reverse, but the main function is expecting you to reverse array in place and the code after printf("\nReversed: "); will print the string. Instead it's going to print the original string now
You can do it like so... int *p = &amp;array[length - 1]; do { printf("%d ", *p); } while(p-- != array); Pointers are easy if you think of them in terms of memory addresses. Let me explain this code a bit. First we get the address of the last indexable value in the array, then we print that value, then we move the pointer back the size of the type with `p--`, which in this case is 4 bytes, (since the size of an int is 4 bytes). Anyway, since `--` here is a postfix operator, we will get the value that it was before we decremented it, we compare this to `array` which is the same as `&amp;array[0]`, that is the address of the first integer in the array. Eventually p will be equal to array, or rather the same address as entry zero, since we are decrementing p with each cycle, and the type size is the same. So once we get there, we have already printed the value for that (since this is a `do while` loop), we can just exit when we arrive at it.
Oh yeah. Fair enough. The size of int is 4 bytes when compiling on x86. But that's largely irrelevant, as this example will work no matter what size an int actually is. I just said that so that he might understand what's going on behind the scenes a bit more.
You say 2D array, but your code looks more like it's for an array of row pointers, each row being an array of integers - which is not something I'd call a 2D array, even though you can use [r][c] to access elements. If that's the case, then your column allocation needs to use sizeof(int *) not sizeof(int). If, on the other hand, you're really trying to use a 2D array, you have to allocate it as a single, contiguous block. I.e. not each row individually. Without seeing the definition of Block, it's hard to tell exactly what you're after. Note: using calloc (as opposed to malloc) give you memory that has already been zeroed. 
Well, off the top of my head: * Your allocation of spaces looks like it should be sizeof(int*), not sizeof(int). * What is allocate()? I don't recognize that call. * You really should be null-checking all of your allocations. Other than that, I can't see anything wrong with the logic of this code.
you are correct about an an array of row pointers. I am in an introductory class and mixed up the terminology a bit. changing to sizeof(int *) got the job done. and thanks for the tip about calloc Thanks a ton for the help!
My teacher said to use allocate() instead. I'm not too sure, but she said it was a wrapper for malloc. But changing to int * solved my problems so thanks!
Does it have to do with the way you increment both of the integers in the nested loop? 
First, look at asciitable.com. What's in the file are bytes. In this case, those bytes are representing printable characters. So when there's a printed digit `0`, the value of the byte is actually 48. (That's the "Dec" column from asciitable.com, which is the character's value in **dec**imal.) This is followed by a space character, the value of which is 32. If you have the printed value `10`, like in the 3rd row of your example, this is *two characters*: a `'1'` (value 49) followed by a `'0'` (value 48). So when you're reading with `getc()`, you're getting the ASCII value of the byte, not what it represents. And you're only getting one character, not a sequence of characters. This is what `fscanf()` does. When you put "%d" as its format string, the "d" tells it "look for a sequence of characters that form a number, and interpret that sequence of characters as a base-10 integer". So let's say you do that on the start of the file. That would read up to the "0", which it would interpret in base-10 and set the value 0 in the array. Now you need to know what to do next. Is the next character a space or a newline? `fscanf()` can't tell you that because it treats all whitespace equally, and doesn't return any of it. So now you switch to `getc()`. You read one character, and see what it is. If it's a space character, which you'd represent in C as `' '` (that's a single-quote, a space, and another single-quote), then you're still in the same row. If it's a newline character, which you'd represent as `'\n'`, then it's the end of the row, and you need to go to the next row. You should also check for `'\r'`, because on Windows or Mac that might be used to indicate the end of a line instead of (or in addition to) `'\n'`.
&gt; C language is extensible because it can easily adopt new features. [Only took 30+ years to get lambdas.](https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html)
Turbo C++, conio.h, void main(),getch(). Please stop.
Using a pointer to what? Don't you need to allocate something? Perhaps some memory?
Is your question what does malloc do, or what is malloc useful for? I'd be happy to help you find the answer, but those two questions are fairly different.
Whenever you declare (and initialize) objects (not in the OOP sense in this case) inside a function, they are put into a piece of memory called the stack. Once the function finishes, the stack memory is freed and not usable anymore. Malloc will allocate a piece of memory with which the programmer can basically do anything he wants. This memory is dynamic and can grow and shrink 'at will'. The downside to this freedom is that you will have to manage (and free) this memory yourself. Pointers have little to do with this. You can have a pointer to stack memory just as you can have a pointer to 'heap' (malloc'd) memory. The difference is that heap memory can be used until it is free'd. This means you can pass a pointer to this memory around in the program without worrying you'll get the wrong memory. A pointer to stack memory will become useless once the memory is free'd. **Edit: pointers do have something to do with this; malloc will return a pointer to the block of memory that was allocated.** I am not at all a C specialist and I'm hugely simplifying things here, but I hope you get the point.
https://www.youtube.com/watch?v=_8-ht2AKyH4 Videos are by no means a replacement for school or actual studying, but this one gives a good overview on the stack and heap (including malloc and other related functions). I mean, if you have 17 minutes to spare, it really isn't as overly complicated as you might think.
It allocates memory that will remain allocated until you call `free`. If you allocate via declaring an array inside a block of code, then that memory will be released when the current scope ends (i.e. the next `}`). (This is called *automatic allocation*). Malloc is necessary when you don't know how much memory you will need at compile-time, and automatic allocation won't work. (For example you are reading words from a dictionary file and storing them in a tree structure). 
But remember, `malloc` doesn't initialize data, it just allocates memory. It will be garbage data until initialized. `calloc` zeros the buffer after allocation, which gives you better data sanity at the cost of a few more `memset` calls.
This line causes undefined behaviour: *p++ = a + N - p; This is a serious blunder in your course material. You should fix it immediately before proceeding, otherwise you can't rely on what you are seeing when you run the code. They probably meant: while (p &lt; a + N) { *p = a + N - p; p++; } &gt; I'm not even sure if this is right as I can't compile anything until I've written the other functions. What you should do is write *stub functions*: Put the functions in but have them not do anything, or call `exit()`, etc. Then you can compile your code and check there are no compiler errors, and you can gradually add in the functionality you need. You must be able to solve and test one stage of the solution at a time, instead of trying to write the whole thing in one go. 
This code is wrong: int revArray() { int i, a[N]; for (i = N - 1; i &gt;= 0; i--) printf(" %d", a[i]); } You are using uninitialized values of `a`. It seems like you expect this `a` to be the same array as `a` in main, however that is not true. Variables declared in different scopes are different variables even if they have the same name. Instead you need to make your function operate on the variable `a` that was declared within `main`. The usual way to do that is to pass it as a function parameter. Your function could be: void revArray( int *a ) { // logic here } The function does not need to return anything so it should have return type `void`. In general you would also accept the array length as parameter, however in this code you are hardcoding `N` as the length so you don't need to. Finally, your code prints out the array contents in reverse. However , the purpose of the function is to reverse the contents of the array inside the array, not to do any printing. 
That is quite a bit of help you need. I will for the moment, assume you are using some kind of "magic" graphics system to display everything. You will need a rectangle struct. typedef struct rect { int x; int y; int width; int height; } rect_t; You will also need a struct for a single x/y coordinate point. typedef struct point { int x; int y; } point_t; Using this will help you define the bounds of the images, the location for the spots to 'click' and similar type rectangle requirements. //define your structs for whatever. rect_t left = {10,10,100,100}; //100x100 image at 10x10 rect_t right = {120,10,100,100}; //100x100 image at 120x10 rect_t difference = {10,10,20,40}; //20x40 difference at 10x10 inside the image Inside your main loop, get the values for your mouse coordinates. point_t p = {0, 0}; GetMouseCoordinates(&amp;p); //now check to see if they are inside the difference, if you have many differences, just use an array and a loop. if(p.x &gt;= left.x + difference.x &amp;&amp; p.x &lt;= left.x + difference.x + difference.width &amp;&amp; p.y &gt;= left.y + difference.y &amp;&amp; p.y &lt;= left.y + difference.y + difference.height) { //do whatever you do on success difference click here } // Do the same for the right image if you want them to be able to click on either for it. As for the timer, that really depends on your environment. In SDL or OpenGL you will need to load up a font (there are libraries for this), bind it to a texture (or surface), and then render that texture to the screen. Some libraries, such as SDL, has a timer mechanism that you can use to make a callback to update the timer for you, but in such cases you will need to use a mutex lock (or something else) to avoid rendering things that are being used by other threads. Alternatively, you can just sleep the required ms until the next second (less than ideal since you want to detect clicks), and then just update the timer.
malloc &gt; m alloc &gt; mem alloc &gt; memory allocation It's to reserve heap memory for something, since the stack is limited and limiting.
I really don't get why OP would delete his posting, especially after your detailed reply
I'm not sure if this is the bug but return playerCard1,playerCard2; cannot work. You can only return one value in C.
ok, should I create two separate functions for card 1 and card 2? edit:I tried eliminating playercard2 and it still has the same bug
Why ? Just call the same function twice. int dealCard(void){ int playerCard=0; srand((int)time(0)); return (rand()%13); } player1card = dealCard(); player2card = dealCard();
Well unless you update code and paste can't really help you there. You also need a forward declaration for dealCards(); since you call it before you define it.
Sounds like you're using dealtcard as a variable instead of a function. Are you missing the () at the end ? Again, if you don't show your updated code, no way to know.
thank you very much. I guess I am all over the place because I was trying wrap my head around how in the hell am I going to separate the numbers from the letters :(
I added the prompt to my edit. I maybe reading the prompt all wrong.. but then again.. I do get confused easily when the compiler just keeps giving me errors.
ooh. Okay. I'll recode this, will post again. Thank you very much for your help and time.
You're welcome !
Not sure either. Well, I tried.
Maybe it's a memory leak? They tend to become more apparent on systems with less available memory. You could try checking your program with Valgrind.
Code has been uploaded.
You just so happened to have used a site that's blocked for me.
a) Scoping. A constant defined with `const` is scoped like any other variable. Also, macros don't follow the general rules of C, which results in surprising behavior: #define CONST_SUM 2 + 3 int array[CONST_SUM * 4]; /* Results in 14, no 20. Whoops! */ You can fix this with lots of parentheses everywhere, but that just reduces readability. Type doesn't play into it. C literals carry a type with them: `3` is an integer, `3.14` is a double, `3.14f` is a float, `3ul` is an unsigned long integer, etc. b) Consider this code: do { printf("X\n"); } while ( 0 ); This will execute the loop exactly once. (In fact, this is a common idiom to make multiline macros safe.) c) Just to be clear we're on the same page: switch ( x ) { case 0: case 1: } `x` is called the "selection statement" or "controlling expression" can can be just about any statement. So, you can put a variable, a constant, or a function call in there, for example, as long as it results in an integer type.
B and c makes sense, but I still didint quite understand what you meant with a. could you do a little explain it like Im 5?
It seems you have a stack overflow. I could tell you where, but instead I'll point you to a compiler flag every C programmer should know: `-fsanitize=address`
Ohh I think I get it. in your example, it results in 14 becuase with define it first takes 3*4 and then adds +2 which is not waht we want. So the answer is scoping. thank you :)
ELI5: Macros don't work like the rest of C, it's actually a separate language. Getting them right can be tricky. First, let's talk scope. Let's say you have a constant that's only necessary for one function. Something like: void f() { const int SIZE = 10; int array[SIZE]; } void g() { const int SIZE = 20; int array[SIZE]; } If you used a macro, you'd have to have a different name for each array: #define SIZEf 10 #define SIZEg 20 void f() { int array[SIZEf]; } void g() { int array[SIZEg]; } This is confusing and unnecessary. And you can't use a local variable with the same name: #define SIZE 10 void f() { int SIZE = 20; /* Compile error */ } Now, let's talk about macro weirdness. For simple constants, macros are fine. But often a constant needs to be computed from other constants, which is what I showed in my earlier comment. `CONST_SUM` was computed from two other constants. After the preprocessor does it's work, this is what the compiler sees: int array[2 + 3 * 4]; Order of operations then dictates that 3*4 is first, then added to 2. That's probably not what you wanted. Had the code been: const int CONST_SUM = 2 + 3; int array[CONST_SUM * 4]; The result would be much less surprising. These problems can be fixed, though. Wrap your macros with parentheses: #define CONST_SUM = ( 2 + 3 ) If you want a scoped macro, you can do this: void f() { #define SIZE 10 int array[SIZE]; #undef SIZE } void g() { #define SIZE 20 int array[SIZE]; #undef SIZE } But this gets ugly and error prone.
My school's cluster is on 4.6.2, it doesn't support that flag.
Has anybody done this? I'm considering doing it over the holidays. 
you have three options: 1) find a linux with recent gcc/clang (or use a vm) 2) get a recent gcc/clang to run on you school's machine (build yourself, ask admins) 3) no idea if thiss will work but might be worth a shot: http://llvm.org/docs/GettingStartedVS.html
Does this help? Well it compiles, no idea if it works so it's good to ship. [oh and although your code has the four spaces before each line you need an extra return-space-space at the end of the paragraph above it.] #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; /*declare function as compiler needs to know about it before you call it*/ int dealCards(void); int main() { printf("112913656, Final Project\n\nWelcome to BlackJack! Begin with $500, ante is $2, press enter after inputing wager to deal the deck\n"); int i,playerCard1,playerCard2; int cash=500; int wager; int ante=2; int cardVals[13]; for(i=0;i&lt;8;i++){ cardVals[i]=i+2; } for(i=8;i&lt;12;i++){ cardVals[i]=10; } cardVals[12]=11; while(cash&gt;0){ printf("How much would you like to wager?\n"); scanf("%d",&amp;wager); if(wager&gt;cash){ printf("You dont have that much cash to bet!\n\n"); } else if(cash&lt;=0){ printf("Game over, you lost all your money!\n\n"); } else{ printf("wager:%d\n",wager); cash=cash-ante-wager; /*change these to two individual calls to dealCards*/ playerCard1=dealCards(); playerCard2=dealCards(); printf("Your hand is:%d,%d",cardVals[playerCard1],cardVals[playerCard2]); }} return 0; } int dealCards(void){ /*we only need one local playerCard variable... * edit- come to think about it, we don't even need that*/ /*int playerCard=0;*/ srand((int)time(0)); /*got rid of other playerCard assignment line and made the variable name match*/ /*playerCard=(rand()%13);*/ /*return playerCard;*/ return (rand()%13); } 
The `bzero` and `bcopy` functions come from the pre-standardization era. Basically, before C was standardized, the standard library for your system would have a different set of functions than would be available on other systems. `bzero` and `bcopy` were part of BSD, for example. But the standard functions that should be used are `memset` and `memcpy`, as of 1989.
pre-standardization of what, exactly?
check out the tool valgrind. 
ah. sweet. Anyplace I can go to read some history on this stuff?
This may sound stupid, but I'm really new to strings. I know strncmp() will compare strings, but I'm not sure how to use that in my current code. Can you give me an idea of how to write it in?
Here's an example: if (strcmp("avocado", "orange") == 0) { printf("The words are the same\n"); } else { printf("The words are different\n"); }
Thank you, now I can hand in this last assignment and never code in C again.
Because the types are actually different. The function is expecting a pointer to a pointer to a const int... You're passing in a pointer to a pointer to an int. If you want the variable itself, you need to have the function defined as: int foo(int ** const p) In this case, p itself will be const. It may be easier to understand if we move your const around, and read it from right to left: * int const * * = a pointer to a pointer to a const int. * int * * const = a const pointer to a pointer to an int. 
What He Said. I will only add you should get into the habit of using the "strn" functions rather than the "str", as sooner or later somebody is going to throw something larger at you than they should. And [Bad Things](http://heartbleed.com/) will happen. Just be aware if a "strn" overflows your strings are no longer null terminated and hence not usable. So _always_ check the return values. 
I was going to, but I changed my mind when I read the "[Stuff that should be avoided](http://www.iso-9899.info/wiki/Main_Page#Stuff_that_should_be_avoided)" section of the ##C freenode IRC channel's wiki, which mentions: &gt; [Build Your Own Lisp](http://www.buildyourownlisp.com/): Bad C and terrible rationales. I'll still probably do it eventually, though — if for no other reason than to see what they mean (or if I'm familiar enough with C to detect it).
some of it is probably due to the hungarian notion practice the MSFT uses. Edit, and by MSFT, I mean Intel and whatever naming convention they use. https://software.intel.com/sites/landingpage/IntrinsicsGuide/
Also macro's create issues when it comes time to debug depending one what tool you use; the value of the #define may not be shown so you might not know what value is being passed around (as opposed to a const which the debugger would know). And if you are being strict on type casting, the compiler can catch issues with 'const' because it knows what type it's dealing with, but that doesn't work with #define.
I just took a quick look and noticed: myOut=fopen("HighScores.txt","w"); for(i=0;i&lt;5;i++){ fprintf(myOut, "%c%c %d\n", scores[i].firstInitial,scores[i].secondInitial,scores[i].cash); fclose(myOut); } There's (possibly) your problem. You're writing to a file, then closing it with fclose. Then iterating through the loop and attempting to write to the file again. You need to move the fclose to after the for-loop.
For generating random numbers, [here's a starting point](http://stackoverflow.com/questions/822323/how-to-generate-a-random-number-in-c) As a general coding convention suggestion, I like making variables that are indexes have "idx" or "index" in the name somewhere, and variables that are counters have "cnt" or "count" in there somewhere. The code will be more intuitive to you to read if you follow some convention. Look at the meaning of "legal." Is it a count of the legal moves, or is it an index into an array that marks something, like the last available move. Look at what that innermost for loop is doing (using a as the loop variable). You have a buffer overflow bug. I'm not sure you have that part right either way, since you overwrite that array each time. If you have a debugger, step through that code line by line to see what it's doing. If you hate debuggers (some people do) and the loops aren't too long. then add little printf() statements within the loops to visualize how the loops is functioning.
Thank you, that's good to know. I think I'll do it anyways but keep it in mind. It would be interesting to know the reason, since I like courses similar to Shaw's LCTHW. Maybe I should substitute it with a book?
&gt; Ahh don't say that C is great. Commas. They can be your friend. (And to OP: so can C.)
the author's reply: http://theorangeduck.com/page/ready-fight tl:dr is https://www.youtube.com/watch?v=1t8kAbUg4t4
Actually I was looking into making sure that the function does not change the data it receives. I had a bug where I accidentally modified a value through a pointer... and then I remember functions like `strcmp` and `strlen` all take pointers to constant values and I though... hey, the least privilege rule might come in handy. 'xcept it didn't. :) Making the pointer itself constant will not really help me here, will it?
I'm usually more [skeptical](http://www.reactiongifs.com/r/obs.gif).
Thanks for the link! Here is my "review" on just reading the book this morning (although I intend to implement it this weekend!). I'm an out-of-college programmer and begginer Lisper (mostly Clojure), if that matters. The book seems intense, and I'm not sure how appropriate it is for a total newbie. However, I believe a not-so-noob (say, just finished their first intro to programming semester) will appreciate this a lot. The final projects are challenging (garbage collecting, hash table, static typing, etc.) and will surely instill some love for programming languages and provide food for /r/programmingforever projects :) To me, using libraries is a very good initiative! Yes, there's pumbling, but it rockets you to another level by not needing to write a parser. In real life you'll look for libraries to do minor tasks all the time while you focus on what you want to create. I highly recommend practising this in an introductory level. The Lispy language it presents is also a good "counter-example" to C, providing some high-level notions (closures, partial and currying) that is usually not presented in an introductory course, unless you are at MIT and uses SICP. I have yet to understand the reason for C-IRC's review ("Bad C and terrible rationales"). When I try it out I'll provide my own review on the "bad C" part, but I believe that the rationales are very good. **TL;DR:** 8/10, will try it out later.
Thanks a lot! I'll probably try this at some point - challenging projects are fun.
low + rand() / (RAND_MAX / (high - low + 1) + 1) Read about this : http://c-faq.com/lib/randrange.html
First of all thanks for the comment and sorry about the screenshot. Second i tried your suggestions and am still somewhat lost. What print statements should I have in there in order to test if the array is filling correctly? I am new to programming and am in somewhat over my head now so thanks for the help.
Learning a debugger like gdb is a very useful skill, much better the printing stuff. But for now, this is what I would do. If you want to print as the array is filled, you can modify the loop a bit: int *legalMoves = malloc(sizeof(int) * n-&gt;width); // NOTE: sizeof(int), not sizeof(int*) int count = 0; for ( int i = 0; i &lt; n-&gt;width; i++ ) if ( n-&gt;spaces[0][i] == 0 ) { printf("**** Legal move: %d\n", i); legalMoves[count++] = i; } Or you can use this to print after you fill the array: for ( int i = 0; i &lt; count; i++ ) printf("**** Legal move: %d\n", legalMoves[i]);
Yes it can help you, but you need to the rest of types const along the way.. (Note, I tested this with a C++ compile, not C). int foo(int const * const * const p) Will do what you want. Using the right to left idea, its a: const pointer to a const pointer to a const int. Compiles with no warnings (-Wall) on: vale:build garion$ g++ --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn) Target: x86_64-apple-darwin14.0.0 Thread model: posix
ok side question: I also have to make a function that tests if the game is over, which basically means if there are no legal moves left. I could do that using similar code and just add if (count == 0) maybe?
Sure, that seems reasonable to me. Since you'll probably want to see if the user has any legal moves, too, you might want to break out that logic into a separate function.
yes im putting it in a separate function and basically using the same code you put there. I am having trouble figuring out where to put the if statement though. I want to return 0 if there are legal moves and 1 if there are not. Am I correct in thinking that if count is 0 then there are no legal moves?
Precisely. `count` is the number of legal moves, therefore if it's 0 then there are no legal moves. Though you might find that having this function simply return the number of moves (while populating an array with them) is a better way to go.
I don't really see how this would be useful. Now if you could declare a destructor for a struct that would be nice, but there isn't any difference I can see between writing a function and throwing it in atexit(). Constructors I'm not getting the use of at all.
C doesn't have constructors. GCC has them. They're also not really constructors. I'm not sure there's really any point to changing the entry point to a program. How is this any better than simply having main() do all the setup for you? It just makes your code harder to understand for anyone that actually knows C.
Thanks! my function to check if the game is over works now. for the computerMove i still can not figure out how to use rand and srand. My teachers instructions were to use srand on a seed passed in on the command line so that the random numbers would be the same for everyone she grades. In my main function i use: int seed = atoi(argv[3]); srand(seed); I am unsure of how to use the rand to only pick from the range i want.
That's a good way to do the seed. You might also put in code so that if a seed isn't specified, it defaults to `time(NULL)` (the current system time). There's even better ways to generate a seed, but that's fine for an assignment. Be sure to only do the seed once, probably as one of the first things in `main()`. A common mistake is to reseed each time you need a random number, which is a bad idea. As for getting a number in a certain range, the easy way is: int value = rand() % range; This will give you a number in the range [0,range). Again, [there are better ways to do this](http://c-faq.com/lib/randrange.html), but this is probably what your professor wants you to do for consistency's sake.
ok i think it is my logic in my main function that is not working. im pretty sure it never actually calls to the computerMove function
There are plenty of memory debugging tools out there. Hopefully, your school has [valgrind](http://valgrind.org/) installed, which checks for both memory leaks and memory bugs. If not, you can download and link [libDuma](http://duma.sourceforge.net/) to your program. If you can't do either, use a C programmer's two most useful tools, gdb and printf, to figure out where your program is messing up.
I apologize if my formatting sucks. I wasn't sure how to indent the code correctly.
I understand his motivation: get some cool stuff running in order to hook the reader, and worry later about how you'd actually go about implementing it. C is a pretty minimal language. If you read the Perl book, as soon as chapter 2 it's talking about arrays/lists, hashes, arrays of hashes, hashes of arrays, filehandles, file input, and globbing. C can't do anything that complex without the using external libraries, or implementing it yourself. And let's face it, programming tutorials that start with "Here's how to implement your very own linked list" may be helpful and easy to understand if you've done them in other languages before, but they're not very exciting. I think this is a better approach anyway. The best way to use any programming language is to reuse solid implementations other people have already written. Instead of explaining the details of how to deal with keyboard input, command history, and other complexities, he shows how simple it is to defer to a library that takes care of it for you. It's not always that simple with other libraries, but this is a great example that makes C look as sexy and easy to use as Perl's CPAN, Ruby's Gems, or Python's PyPi.
I see calls to `fun` but no definition. Are you linking in all the correct files? Also, are there any further details in the linker error? That may be helpful.
I'm just going to say I like your explanation best, because it describes the lifetime of storage which is pertinent to C as opposed to the location (stack, heap, filing cabinet, etc.).
I am using visual studio so I'll be sure to enable warnings. Thanks for the tip. As for '"%s"' I understand now that some there are no strings in the file that it pulls that won't work, but what should I use to get all the data? Should I treat it like a char or am I over thinking this by trying to pull all the data at once?
I can only think of one good use case. A library can define a "constructor" to initialize everything it needs. No need to require the programmer to remember to do that for you.
Don't quit your day job.
Check out popen . Like fopen but for pipes
Firstly, the word 'system call' has a very specific meaning (namely, they are pieces of Kernel functionality made available to user programs via an interrupt) so you might not want to use that term here :) Also, 'casting' is a fairly specific term as well, typically meaning the conversion of data between two types. Anyways, rant aside, `popen` is indeed the way to go with this one.
Because arrays are contiguous blocks of memory. Accessing an arbitrary index in an array is just doing some pointer math. The three pieces of information you need to know are: * The index you're looking for. Call it `i`. * The starting address of your array. Call it `A`. * The size of each element inside your array. Call it `S`. Then, we can take the initial address `A`, and then we're going to skip `i` number of elements. How big is each element? `S`. Thus, `i` * `S` is how much memory `i` number of elements take up. We call this an offset from the initial address. This means that: A + i * S Gives us the location in which the element at index `i` is stored. Notice that for any index `i`, the process is the same. We take the same number of steps to go from our initial address, to our desired location. Compare this with something like a linked list, and you'll notice the the amount of steps you have to go through in a linked list is proportional to the index you wish you travel to, since you will start from the head node, and hop to the next, and the one after, and so on, until you reach your desired node.
The inner loop keeps adding the product of two elements of A and B to an element of out. += would work just the same. The current element of out is always set to 0 before that loop. Otherwise, it would be whatever garbage value is in that chunk of memory to start with. Using calloc() instead of malloc() would eliminate the need for that.
I did not know that shuffle trick for doing a horizontal add of a registers values. That'll come in handy for something.
Pretty much this. I was going to write a nice explanation, but this fits it just fine. Good work there Kristler.
Aren't they 22.5 degrees apart? N is 0, NNE is 22.5, NE is 45, ENE is 67.5, E is 90 and so on. Unless you also want the [quarter-winds](http://en.wikipedia.org/wiki/Points_of_the_compass) for a full 32 point compass rose. Anyway, I would divide the heading by the distance between the directions, then round to the nearest integer, and that modulo 16. That will give you a number between 0 and 15., where 0 is N, 1 is NNE, ... and 15 is NNW. Depending on what you want to do with that, you can then use that number to index into an array containing the strings corresponding to the directions or build a switch statement that does stuff depending on the direction.
 man popen 
That's commonly called a [Buffer Overflow](http://en.wikipedia.org/wiki/Buffer_overflow). Best case: the program crashes, making it obvious that something went wrong. Worst case: the program overwrites other data, causing weird errors later at a seemingly unrelated place.
Thank you very much :)
Is there a reason for doing that vs. just calling the 'init' or constructor after allocating the variable? MyType_t t; MyTypeConstructor(&amp;t); That's a pretty common idiom that I tend to use. I'm not sure what the advantage to using alloca here would be. Also, it can be handy to know that there is a GCC extension for a 'cleanup' function for variables. So you can do this: void aFunc(void) { __attribute__((__cleanup__(MyTypeDestructor))) MyType_t t; MyTypeConstructor(&amp;t); return ; } /* 'MyTypeDestructor' is automatically called right before 't' will be deallocated */ 
Sorry for not posting the exact error, i now realize that it has something to do with fun() The error was this [linker ld error](http://imgur.com/JQfKzBo) I thought I called it later on in the program with *fun(carddeck)* and others.
Slight modification: the cardinal direction needs to be centered within the range. So N should be 348.75 to 11.25, NNE should be 11.25 to 33.75, etc. This should be easy by biasing by 11.25 before going through that process.
You'll probably find it easier to do it lower-level then the standard library, since the standard library doesn't offer the best tools for the job. Perhaps most notably, you'll get the best result if you have both programs running at the same time while you feed the output of one into the other. And even nicer, you can make the OS do all of the work for you if you use fork(), exec(), pipe(), and dup2(), you won't need to keep any buffers. Since I'm sure that sounds pretty strange, I'll give you a high-level over-view of the idea. The fork() function 'forks' your running program into two copies, both running at the same time with copies of memory and open file decriptors, etc. they're both running the exact same code starting from the exact same position, but you can determine which is the parent and which is the child from the return value of the fork() function. On it's own, this isn't exactly useful, since both programs can't interact and it's still just running your own code. That's where pipe() comes in. The pipe() function gives you two file descriptors that are 'linked' to eachother - Anything written to one of the file descriptors can be read from the other. Remember, fork() copies open file descriptors, so if you use pipe() before using fork(), you can have the parent and the child write and read to the pipe to communicate with eachother. This still doesn't give you want you want though. Enter exec(). Using the various exec() functions you can basically replace the currently running program with a new program. By doing this, you can execute a new program. Thus, if you want to spawn and new program from your program, and you don't want to use system() (Which won't work for what we want), you can use fork() + exec() to create a new child process, and then use exec() to replace the child with a new running process. So using the above, we can communicate with a child process and execute a new process in it's place. We still need to capture the input and output to that process though. This is where dup2() comes in. dup2() allows you to 'duplicate' a file descriptor into a new file descriptor. It sounds basically useless, but it has a very nice function here - We can use it to duplicate an open file descriptor over the stdin and stdout file descriptors. The basic idea is that all programs get their standard input and output from two different file descriptors. By replacing these file desciptors with descriptors other then the defaults, we can redirect the input and output to other locations. Now normally, to make a program do that you would have to edit the program itself and recompile it. But we have a very handy detail that exec() doesn't clear everything out from the last program we had before we used exec(). So the result is that we can replace the stdin and stdout file descriptors *after* we call fork() but *before* we call exec(), and the result is that the process created by exec() will have our new file descriptors in place of the normal stdin and stdout. So then, the idea becomes: Create two pipes for your first child process ("ls") (One for stdin, and one for stdout). Use fork(), and then in the child process use dup2() to duplicate one file descriptor from each of the two pipes onto stdin and stdout. Then, use exec() to swap the process with 'ls', which will start running and send it's output to the pipe (Because we dup'd the pipe onto stdout). In the parent process, you'll want to use fork() *again* and execute the next process to recieve it's input from 'ls'. The nice trick here is that you already have a file descriptor that is the stdout from 'ls', which is just the other side of one of the pipes from before. So use fork() and then use dup2() and replace the stdin for the next process with the other side of the pipe which is being used as stdout for 'ls'. By doing this, we linked the stdout and stdin of the two processes via a pipe, and we don't actually ever have to touch any of the data. At this point, we're basically done besides deciding what to do with the output from the second program. I could possibly mock-up a simple example if it would be easier for you to follow.
It's a good habit. Most of the time, it won't make any difference, but if you make it a habit, it won't cause you problems in the cases where it will make a difference. To be clear, it could only make a difference if you have multiple translation units (multiple .c files) linked together, and even then, usually it doesn't come up that you have multiple symbols defined with the same name.
static? Are you sure you don't mean const?
Yes, I mean static. See example here: https://github.com/pebble/pebble-sdk-examples/blob/master/watchapps/feature_menu_layer/src/feature_menu_layer.c
This makes the C version look overkill
You should make things static when you know you're not going to need them in other translation units. It has a variety of benefits: - The global symbol table is not unnecessarily polluted. For large shared libraries this can have a beneficial effect on startup time, and it also makes linking faster on large projects. - In code compiled as position-independent (`-fPIC`, necessary for shared libraries) accessing static variables is more efficient as there is no need for indirection through the GOT as interposition is impossible, and similarly for function calls to static functions not requiring a trip through the PLT. - The compiler can more effectively optimize the code. For example, if it inlines every call site of a static function, then there is no need to emit an out-of-line function body. Small static functions are like catnip to the inliner. 
I think it helps the linker-level optimizations. For example, in some archs the jumper instructions have a limit, so big programs may have jumps to jumps if the code is not rearranged (optimized). Putting static in everything helps the linker give attention to what is needed and ignore the rest.
static functions are useful to avoid cluttering the global namespace. If I have two .c files that each have a function ``dump_debug_stuff`` but different parameters, I'll get a link error unless at least one is static. I think the same argument holds for global static variables (not declared in a function). So, unless you really need your global function or variable to be seen by others, static is nice, neat, and helps reduce future problems. Local static functions (I may have the name wrong -- variables declared in a function) have an entirely different purpose, they retain their value after the function exits. Again, this can be useful but can also be error-prone in some cases. So, unless you really need a function to retain its value between calls, and I mean really nead it, you should avoid local static variables. 
&gt; Is there a reason for doing that vs. just calling the 'init' or constructor after allocating the variable? I'm not JohnAndrewCarter, but the alloca() version is one line and looks a bit more like a C++ constructor. Sadly, it's a lot less readable. I try to avoid compiler-specific behavior, so I didn't know about ``__cleanup__``. I could see that being useful when compiler-specific behavior is acceptable. 
I admit that I am a novice in the language, but I honestly cannot figure out the source of the phantom 'P' and it's killing me.
Just before the lines that read "Run program". So it prints "PRun program 1", "PRun program 2" etc.
Right, and that tells you that the problem is with your clrs function, because you call it once every cycle. If you want to send straight ansi to the terminal it's often easier to just use printf, like so: printf("\033[2J"); printf("\033[;H"); return 1; EDIT: /u/zomgreddit0r gets it right as to *why* this is going wrong. My suggestion is just another way to approach clearing the screen.
You can effectively do the same with `pthread_once()` in POSIX and `call_once()` in C11.
Ha, I wanted to find the best way to clear the screen and I found the stackoverflow question that gave him the screen clearing funciton: http://stackoverflow.com/questions/2347770/how-do-you-clear-console-screen-in-c
This is why you're frequently better off doing something like const char CLEAR_SCREE_ANSI[] = "\e[1;1H\e[2J"; write(STDOUT_FILENO,CLEAR_SCREE_ANSI,sizeof(CLEAR_SCREE_ANSI)-1); Important points: * `CLEAR_SCREE_ANSI` is declared as an array (and not as a pointer) and its definition is available at compile time, which means the `sizeof` operator will return the size of the array (which is the number of bytes it takes up) and not the size of the pointer (which is 4 on 32 bit systems, and 8 on 64 bit systems). * Since it's initialized with a C string, it ends in a NUL terminator, so you need to use `sizeof(CLEAR_SCREE_ANSI)-1` to avoid printing out the nul terminator. If you need the number of items in the array, and not the number of bytes (which in this case are the same thing), you should do `sizeof(ARRAY)/sizeof(ARRAY[0])`. Again, *this only works* if the definition is available at compile time. If you couldn't go and count the elements of the array by hand, this wouldn't work.
Just to spell out what this means in full detail: Because CLEAR_SCREE_ANSI only has 10 bytes of interesting data, the call to write (which is passed 12 as the size) will walk off the end of CLEAR_SCREE_ANSI by 2 extra bytes. In doing so, it will write the terminating '0' character and it will grab and write whatever random byte happens to be after that in memory. In this case, it happened to get 'P' - possibly from the beginning of the string "Press Enter to Continue", which might just happen to be stored at that spot. Or it could be some other kind of data that when interpreted as a character, happens to be a 'P'.
I guess that's somewhat what I figured. IMO just allocating it on the stack and calling init is much better, but it is what it is. And same, I've never actually used `__cleanup__`, I just remembered it being a thing. Personally I'm not really convinced it's worth using even if it wasn't compiler-specific, but it does exist at least.
Others have already mentioned what is wrong with your code, but another thing to be careful of, `\e` is not a standard escape sequence in C, it's better to use either `\033` or `\x1B` instead which will be understood on all conforming C compilers.
If you don't need to link to any specific libraries, you can just use GNU make without a Makefile. % cat &gt;hello.c #include &lt;stdio.h&gt; int main(void) { printf("hello world\n"); return 0; } ^D % make hello gcc -O2 -Wall hello.c -o hello % ./hello hello world % 
I'll tell ya tho, I *const*antly forget to use static when I'm writing C... Edit: But actually :D
There's also *tcc* compiler which supports running application after compiling without creating actual file. In *nix you could also this as first line to make source code executable: #!/usr/bin/tcc -run
What do you mean by "it's not working"? Is it failing to compile, or are the results not what you expected? strcmpi is not a standard function, so you need to make sure it's defined somewhere before using it. How you do this depends on your compiler and development environment. If you mean you're not getting the results you expected, consider your cases for the result of strcmpi. You have a case for == 0, or for &gt; 0, but what if the result is &lt; 0? Check your documentation for strcmpi to see what this would mean. EDIT: See spamboymeister's comment, as it describes a more important issue
I checked it out here : http://www-01.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rtref/strcmpi.htm%23strcmpi Had never heard of it before so I got curious. Copy pasted OP's program to codeblocks and what doesn't work is that it returns that the string is a palindrome even if you give it something like "abc" as input.
Sounds like you left it wayyyy too late dude.
Fantastic got it working with this, thanks.
Sorry should have clarified what I meant, got it working now, thanks.
i know i fucked up pretty hard.
Can you clarify the questions a little more? Are you reading 4 lines from a file? What data do the lines contain? For the second question, is the task to take an input and print out the reverse?
Here's my solution for #2. Not sure where you're reading the numbers from, so I just had it read from the user. class ReverseText { static void Main(string[] args) { Console.Write("Enter input: "); string inputText = Console.ReadLine(); string reverseText = string.Empty; for (int i = inputText.Length - 1; i &gt;= 0; i--) { reverseText += inputText[i]; } Console.WriteLine("Reversed output: " + reverseText); Console.ReadKey(); } }
What is the full question for No. 1?
i am supposed to make the user write down numbers as many as they like. change the numbers to * , then make a box of * with length and width of how many numbers they wrote down And yes the other question is just the task taking input and writing them reverse. 
and it should just be empty space inside the box Like: 111 1 1 111 but with stars for numbers
So if the user entered 3452, would this be the output? \**** \**** \**** \**** Edit: Just saw your response, got it. Give me a second.
Here's my solution for #1 (I'm sure there's a more elegant way to do this, but I just threw something together quick at work): class Program { static void Main(string[] args) { Console.Write("Enter a number:"); string inputNumber = Console.ReadLine(); int boxSide = inputNumber.Length; for (int i = 0; i &lt; boxSide; i++) { string lineOutput = string.Empty; for (int j = 0; j &lt; boxSide; j++) { if (i == 0 || i == (boxSide - 1)) { lineOutput += "*"; } else { if (j == 0 || j == (boxSide - 1)) { lineOutput += "*"; } else { lineOutput += " "; } } } Console.WriteLine(lineOutput); } Console.ReadKey(); } }
Holy shit dude you just saved my life! thank you so much! wow im so happy dude thank you thank you thank you thank you
Why use `write` instead of `printf`? Then it wouldn't be necessary to know the length of the string.
Can we please have /u/TheirBadAtGrammar permanently banned? This subreddit should not be devoted to breaking academic integrity rules and helping students cheat.
gcc is the C/C++ compiler and linker a.out is the executable file created by gcc from your .c source code file 
I'm pretty new here, and just saw someone that needed help with a problem I was able to solve. I'm a successful programmer, and there were times in my schooling where a little help saved my ass. If that's against this sub's rules, I guess banning me is the only option. 
A typical OSX program that you would run is a .app - which is really nothing more than a directory. Inside is a plist file with some metadata, an executable (or several), and perhaps some scripts, config files, or other pieces the developer wants in the actual program rather than stored in ~/Library or elsewhere. Executable programs most typically don't have an extension, unlike on windows. If you've ever used the terminal, you're probably familiar with this and don't even realize. Commands are programs in the Unix/Linux world, ls, cd, grep, mkdir, rm, etc are all programs, written in C and compiled to binary, and stored in your /bin /usr/bin folders
In terminal: gcc filename.c -o output Then ./output To run
Well I'm angry mostly because I have to deal with these students on a daily basis who have little to no interest in understanding things and just copy-paste code they find on the Internet. It may be that I'm misunderstanding the situation a little bit, but I think I can say categorically that giving a student a complete solution 2 hours before the deadline when they haven't made any attempts on their own yet is unhelpful. I'd have preferred to just see this post deleted.
Please do not advise to call the compiler as `gcc`. This only works if the compiler actually is `gcc`. Invoking the compiler as `cc` is more portable.
Hes using GCC. You want me to write clang?
He is not using `gcc`. He saw a video where somebody used `gcc`. That does not mean that he should copy this bad habit of invoking `gcc` instead of `cc`. I have seen more than one newbie getting flustered when finding out the on some systems the compiler is indeed not called `gcc`. That's like always asking for a Heineken when you want a beer. If you never learn that the right way is to ask for a beer, you will be very confused when a bar doesn't have Heineken.
He literally SAID he used GCC and it made a.out
Upon reading the post again, I see that you are right. Still, it's not a good idea to call the compiler as `gcc` unless you specifically need `gcc`. And OP, as a beginner, does indeed not specifically need `gcc`.
I upvoted you since I didn't know this bit of information. So thanks for educating me! But in this scenario I don't think being overly pedantic helps OP a whole lot. The choice of compiler if probably the last thing they need to worry about, let alone if they call it with gcc or cc. 
Thanks! Hadn't seen that before. I think this quote summarizes why I found myself with an inkling desire to go through it anyway. &gt; Slammed in just five words.... Just a quick dismissal. Did they do any better? Nope. No rationales, and **no** (example) C. It's a missed opportunity to educate, but that seems like it might be the channel's modus operandi — if the author's reply is accurate.
&gt; I have yet to understand the reason for C-IRC's review ("Bad C and terrible rationales"). When I try it out I'll provide my own review on the "bad C" part, but I believe that the rationales are very good. Any update on this? Without any explanation of what ##C meant, it doesn't serve to hold it with any high regard.
You seem to have gotten what you came for, but next time post in the correct subreddt: /r/csharp Good luck on your exam.
Indeed. as a mac user, he might be more inclined to use clang. I personally use gcc because it comes by default on Ubuntu.
gcc is not, but `cc` was. In the latest few editions, you had to use either `c89` to get an ISO 9899:1990 compatible C compiler or `c99` to get an ISO 9899:1999 compatible C compiler.
Note that on OSX `gcc` is an alias for clang: % gcc -v Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn) Target: x86_64-apple-darwin14.0.0 Thread model: posix This is why some programs won’t compile because they use gcc-specific non-standard options (recent example: [BPG](http://bellard.org/bpg/)).
Note that on Mac and Linux it's much more common for executables to have no file extension. 
don't be angry man!. I'm trying my best, it's my first year in programming. 
This looks like an "HR coding test" problem, instead of homework. If it's homework, I'll expect the professor to criticise the use of library functions, but if it's an "HR coding test" consider reading the following: A naive implementation of this algorithm should take `O(n)+O(n/2)` time and `O(n)` space, but yours is `O(n)+O(n)+O(n)+O(n)+O(n)` time and `O(n)+O(n)` space. Now while most CS curriculums will omit constant coefficients and treat these both as `O(n)` but in the commercial world the reality of `O(5n)` being slower than `O(n1.5)` is often important so I'm highlighting it here. 1. `alphabetic()` is pointless. You're already reading characters one at a time so you can check if it is alphabetic at each character and set a flag if the string is invalid. 2. `strcpy()` and `strrev()` also take trips through the string. These are pointless as well, as you already know the length of the string (x) and can simply compare each character against the one at the other end of the string. This requires a trip through half the string. 3. It should be obvious at that point, you won't need the `strcmpi()` or `toupper()` operations that follow. That removes four trips through the array of characters `O(n)` and replaces them with one trip halfway through the array. By the way (assuming this is an HR test), if you *really* wanted to stand out and try "hard mode": Maybe you want to think about what a solution might look like that runs at `O(n)` -- i.e. only a single pass through the string.
Hmm. I see, and partially understand what you're getting at. However, your inclusion of the pointer only made me more confused. As you'll see, I haven't (and still mostly don't) the slightest clue on how to properly work 'em. 
First, thanks for the tip on stub functions. I knew about them, but it may have been clouded out due to my frustrations. Secondly, as for the line, I can't really comment. I've heard from both here (reddit) and a couple C geeks outside the web that the whole code is wonky at best, but after compiling it seemed to work fine... except for the broken functions I wrote. 
This is the kind of thing that drives me up the wall as a re-entry student programmer. So many things to fiddle with in terms of just setting up your work environment. So much "housekeeping"-type things to keep track of. How do you guys learn all this? I did 3 semester's worth of c/c++ programming &gt;15 years ago when Borland was still around. It was a cinch to use. Trying to work off the rust in my coding technique lately has been excruciating as I try to navigate MS Visual Studio. I feel like an idiot fumbling with the thing. Any advice?
Um, ( 0 &lt;&lt; anything ) will always be zero. What are you trying to accomplish with that line?
Does iprint take a uint64_t ? 
Thanks. This was the issue. When I now do a printf("%" PRIu64 "\n", hashValuesTable-&gt;bHashKey[row][col]-&gt;aliveKey); It prints correctly. Yeah, i'll probably take the 0&lt;&lt; out. Thanks again man. 
I defy you to find an example of where a byte is anything other than 8 bits.
It's mainly a leftover from a bygone era, and it's not a terrible idea to just assume 8 bits. However, even today many DSPs have other sizes for a byte (12 bits seems to be common, such as the TI C64x ). I was mostly pointing out a technicality in the standard, but some people do need to worry about such things.
The only point in using alloca is for things you don't know the sizeof at compile time but won't automagically cleaned up on going out of scope. Thank for the heads up on cleanup hadn't seen that one before. Not sure I'll use it, except maybe in a thing with dozens of exits.
It's 16 bit on quite a few of TIs chips, and some go all the way up to 60.
I don't recall anything bad about the C code presented in the book. I agree it would be nice if they actually gave their own rationales for suggesting avoiding this book.
The Digital Equipment Corporation called a half-word in their 12-bit PDP-8 architecture a byte. One particular instruction, called byte swap (BSW) would swap the two 6-bit bytes of the word with each other.
I believe [argc and argv](http://crasseux.com/books/ctutorial/argc-and-argv.html) is what you're looking for.
Sorry, but I don't want it to give me the numbers. You know once you make the program and then you enter it in the command line it asks you to give the you want to calculate, I need to be able to enter the variables along with the program in the command line and get the answer right away.
Yeah, that's what you do with `argc` and `argv`.
Please read the page I linked. It explains that argc and argv are exactly what you use to pass command line arguments into your program. 
Thanks, I see now. I'm really new to programming in c so my level is still very low.
If you plan to continue programming in C I highly recommend [CS50x](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x), a free course offered by Harvard through edX. 
"formatted", because it doesn't just print a string, it formats the other variables according to the 'format string' (i.e., the first argument to printf), which you can use to change the number of digits printed and such (see the manual for details). It's a very clever function, if slightly arcane in the modern world of programming.
You might be on windows, nevertheless... man 3 printf
Thanks! :)
Not that I want to seem too snarky, but: http://lmgtfy.com/?q=printf+history First result is http://en.wikipedia.org/wiki/Printf_format_string but you don't need to read that since the Google summary is "Printf format string **(of which "printf" stands for "print formatted")** refers to a ...".
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Printf format string**](https://en.wikipedia.org/wiki/Printf%20format%20string): [](#sfw) --- &gt;__Printf format string__ (of which "printf" stands for "__print f__ormatted") refers to a control parameter used by a class of [functions](https://en.wikipedia.org/wiki/Function_(computer_science\)) in the string-processing libraries of various [programming languages](https://en.wikipedia.org/wiki/Programming_languages). The __format string__ is written in a simple [template language](https://en.wikipedia.org/wiki/Template_language), and specifies a method for rendering an arbitrary number of varied data type parameters into a string. This string is then by default printed on the [standard output](https://en.wikipedia.org/wiki/Standard_output) stream, but variants exist that perform other tasks with the result, such as returning it as the value of the function. Characters in the format string are usually copied literally into the function's output, as is usual for templates, with the other parameters being rendered into the resulting text in place of certain placeholders – points marked by __format specifiers__, which are typically introduced by a [__%__ character](https://en.wikipedia.org/wiki/Percent_sign), though syntax varies. The format string itself is very often a [string literal](https://en.wikipedia.org/wiki/String_literal), which allows [static analysis](https://en.wikipedia.org/wiki/Static_analysis) of the function call. However, it can also be the value of a variable, which allows for dynamic formatting but also a security vulnerability known as an [uncontrolled format string](https://en.wikipedia.org/wiki/Uncontrolled_format_string) exploit. &gt; --- ^Interesting: [^Printf("shiver ^in ^eternal ^darkness/n");](https://en.wikipedia.org/wiki/Printf\(%22shiver_in_eternal_darkness/n%22\);) ^| [^Percent ^sign](https://en.wikipedia.org/wiki/Percent_sign) ^| [^C ^data ^types](https://en.wikipedia.org/wiki/C_data_types) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmppzdb) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmppzdb)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
addendum: there is a function to just print a string: puts
What is this?
Pro tip: you can do this in Google, too! The first link is almost always the correct man page. Just be careful looking up the absolute value function. True story: I typed in "man abs" once at work to look up which header it was in. The image results were ... well, it's obvious in retrospect. And yes, I was with some coworkers of mixed gender at the time.
No problem with the snark! I searched but didn't think of searching for printf history! Thanks! :)
`scanf` seems like a good idea.
I tried with something like this: int main(int argc, char const *argv[]) { char s_area = "area"; int area; char s_fq = "frequency"; float fq; char s_threshold = "threshold"; float threshold; scanf("%s %d %s %f %s %f", &amp;s_area, &amp;area, &amp;s_fq, &amp;fq, &amp;s_threshold, &amp;threshold); printf("%s %d %s %f %s %f", s_area, area, s_fq, fq, s_threshold, threshold); return 0; } And program is not working. It asks me to input them but freezes when it should print it. That's why I think scanf() won't work.
If on a linux box, man getopt_long. I switched over to long opts a few years ago and I will never look back.
i read somewhere that it's better not to use that
I think he means formatting after the fact. Today, for example, string concatenation is done with simple +'s. To print "the number is 2" in java, it'd just be, "the number is " + 2 but in printf you have to use %d
If you want a fun project, write an exception library in C (try-catch). It'll teach you about setjmp/longjmp and it'll teach you how to (ab)use the C preprocessor, both valuable (but somewhat advanced) skills.
Thanks man that's what I was looking for. Didn't know I can discard something in a single line when using scanf(). And yes, compiler showed a warning: initialization makes integer from pointer without a cast [enabled by default] but ti got compiled anyway. So I didn't think it was a big deal. If I wanted to make it more error-proof, for example: if the user enters arguments without spaceline between them, how can I do that? If(arguments entered in a wrong way){ do it again } It's just pseudo code but I think you understand what I am talking about.
Don't use scanf(). Read a line with fgets() and parse it, possibly with sscanf(). 
If you like learning from books, I strongly recommend "Expert C Programming: Deep C Secrets", by Peter van der Linden.
u read right
Being on Windows AND command line doesn't qualify as user friendly. It doesn't even qualify as programmer friendly. 
I just dont remember why. Something to do with compatibility, or maybe safety issues
I don't know that much about programming but I heard that Visual Studio is the leading standard when it comes to programming and it's on Windows only. 
You're most likely thinking of the standard gets() function, which receives a string input. This function has been deprecated since the 90s because there is no safe way to use it.
`system()` gives you no way to get the output of the program, so follow the suggestions for `popen()`
NOPE i can't read. puts is safe, gets() is the one you want to avoid
Thanks! I took an Intro to Algorithms course that used CLRS and can implement what I learned in C, which is nice. I'll check those books out. 
Reading about this now, thanks! 
Oh, didn't know that. But why MS won't upgrade it's C compiler? That could cost them a lot. Some new developer might emerge and make it better. What about Sublime Text? I have switched to it months ago simply because Visual Studio had many thing that I didn't need. Nice, clean and small. And finally, what program would you recommend/which program are you using?
yeah, that's what I'm asking too. Why is fgets() method better than scanf()?
Only reason I can think of is if you send a bad pointer or a pointer to a dodgy string (no \0 at the end) which... would probably be bad. That's pretty much true for anything involving strings in C that doesn't take a maxlength argument though..
[Herb Sutter's words on C99 and up](http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/). Basically, MS doesn't want to spend the time on it, spending their effort on the C++ compiler instead (and pulling in relevant upgrades to the C compiler where features are shared). Even Herb says to just use the Intel or GCC compilers if you need better support. You can use the Intel compiler with Visual Studio, if need be. Like I said above, I use vim (gvim if possible) for editing, and the command line for everything else (using bash as a shell). For compiler, I use gcc or clang. Under Windows, that means installing cygwin. Under Linux, everything's generally installed and ready (or an easy install from the package manager). This isn't a setup I'd recommend for everyone, but it's my favorite.
try writing some object oriented code in C, with inheritance and virtual calls. It's a blast, and tells you a lot about what is going on behind the scenes in C++. or write your own memory manager with garbage collection. That's a whole world of interesting. (NB: your sanity is your problem if you attempt these :)
I'd recommend learning to read. It's a very advanced skill that takes a great deal of practice. Consider [this example](http://nsl.com/papers/origins.htm): * It's not obfuscated; the author "writes" this way because he thinks this way * It's *correct*: It implements exactly what it sets out to do. Learning how to read this -- not merely decode it, but actually read it the way you might read a pageful of english prose, is a fantastic skill that you can develop, and it will drastically improve comprehension of programs.
So you're ready for advanced topics? Out of curiosity, do you know why the below program prints the letter H? #include &lt;stdio.h&gt; int main(void) { char str[] = "Hello World"; printf("%c\n", 0[str]); return(0); }
http://www.tutorialspoint.com/c_standard_library/c_function_toupper.htm
Sure, under the hood C's implementation of arrays really just returns a pointer to the array. Thus, 0[str] prints whatever is at the 0th point of the array. 1[str] would print e. 
try this, I didn't check it though. for(i=0; i&amp;lt;argc; i++) { j=0; while(argv[i][j]) { printf("%c", toupper(argv[i][j])); j++; } printf("\n"); } edit: accidentally bracket
I suggest you to have a look at the book “21st century C” which addresses all the things ordinary C text books don't teach, like these (in no particular order): * how to write build scripts using the GNU autotools * how to use version control * how to write documentation and what tools to use * how to design library APIs and headers * how to write parallel and concurrent software * some useful third party libraries * how to do object-oriented programming with C * how to use C libraries from other languages * how to debug your programs with gdb Beware though, the topics covered are important but there are some tiny errors in the book. Always double-check when the book claims something about the C language or POSIX, some things are incorrect in subtle ways.
`a[b]` is short hand for `*(a + b)`. Adding an integer to a pointer (in this case, an array is treated like a pointer to its first element) has the effect of incrementing the memory address pointed to by the integer times the size of the object pointed to, as you would expect. It doesn't matter which way round you write the two, *addition commutes.*
Great! Next, tell me which of the following expressions evoke undefined behavior when evaluated. Assume `foo` was declared as `int foo[1]`. * `foo + 0` * `foo[0]` * `foo + 1` * `foo[1]` * `foo + 2` * `foo[2]` * `foo + 3` * `foo[3]` Given the declaration `char bar[10]`, what do the following expressions evaluate to? Is there any undefined behavior? * `sizeof(bar)` * `sizeof(bar + 0)` * `sizeof(bar[0])` * `sizeof(&amp;bar[0])` * `sizeof(bar + 100)` * `sizeof(bar[100])` * `sizeof(&amp;bar[100])`
Ah, so I was overthinking it. The '0' in that expression does not refer to an absolute address after all. Thanks!
Any language that uses the Latin alphabet has the letter C. Russian uses the Cyrillic alphabet. It has [a similar letter](http://en.wikipedia.org/wiki/Es_%28Cyrillic%29), so maybe that works. The Phoenician alphabet doesn't have anything that looks like a C, though the equivalent would be the [Gimel](http://en.wikipedia.org/wiki/Gimel). Most languages will have something like a C, I would think.
Pro tip: the literal 0 casted to a pointer is special in that it represents the `NULL` pointer, regardless of whether the NULL pointer's value is actually `0`. There might be a pointer who's numeric value is `0` which is not the `NULL` pointer.
* `sizeof(bar)` returns 10, because `sizeof(char)` is always 1 and `bar` is an array of ten `char`s. * `sizeof(bar + 0)` and `sizeof(bar + 100)` both return the size of a pointer to `char`. because adding an integer to `bar` causes `bar` to decay into a `char*`. * `sizeof(bar[0])` and `sizeof(bar[100])` both return 1 as expected. * `sizeof(&amp;bar[0])` and `sizeof(&amp;bar[100])` both return the size of a pointer to `char` because we take a pointer. No undefined behaviour happens because `sizeof` does not evaluate its arguments unless the arguments contain a variable-length array. The first one is somewhat tricky. I hope you get it right.
Almost correct. (6) is actually not undefined since `sizeof()` does not evaluate its argument unless it is contains / is (?) a variable-length array. Your answer for the `foo` question is not correct, but I want to give OP a chance to post an answer, too, before I disclose the answer.
Makes error recovery a lot easier for one.
Error recovery is much, much easier. More robust. More flexible. 
int main(int argc, char*argv[]) &gt; insert if or case statement here to process arguments
I know about that method but I don't think I can use it because this is a part of a much bigger project which will include even more parameters that should not be entered in a single line. 
Thanks for your prompt reply! I have a bigger problem now, though. When I try and populate my array, then try to output them, it comes up blank. Would you be willing to help me out a bit? 
I can try. Can you show some code?
You'll probably have better luck if you actually post a question here. You could at least provide some details on what you're having trouble with - is it the math, the user input, data storage?
Not the OP, but interesting knowledge! How can `sizeof` tell if an array is variable-length?
Absolutely! That was what was going on :) So I fixed it [here](https://github.com/arcturus611/dailyprogrammer/commit/d575a7cb6e300693b6498cc1d0c55531aa56a4a7), and it now seems to work. And thanks a lot for looking through that mess of mine! Really appreciate it. 
I second this recommendation. I came from PHP and the K&amp;R deepened my understanding in programming in a few months. I'm still working through the exercises, but it's immensely rewarding to finally pull something off in a low level language. I want to learn Assembly and build little systems some day. Maybe dabble in the demo scene.
A book suggestion for you: *[21st Century C](http://shop.oreilly.com/product/0636920025108.do)*. The author gets into a handful of modern C features (C11, etc.) and justifies opinions on how to do and not do certain things in C today, based on how the language and libraries have advanced.
It is auto-generated.
You are an asshole. I like you.
Have a look at [my comment](http://www.reddit.com/r/C_Programming/comments/2orqxd/what_are_some_advanced_topics_in_c/cmq63wv) where I already suggest the very same book.
how about a toy implementation of malloc
Take a look at [libavl documentation](http://adtinfo.org/). This is how you do expert C (and cool data structures).
You replied to the wrong comment.
if you want to learn assembly, "Programming From the Ground Up" Is a must read. It assumes working on a linux system, but it's very well written, definitely comparable to K&amp;R, but covering a much more difficult subject.
I'm a Gentooer so that sounds like fun. Thanks for the book mention!
Not quite. It's because var[index] syntax is actually syntactic sugar for adding a value to a pointer and dereferencing, like so: var[index] is the same as *(var + index) Since addition is communitive, this is the same thing as the above *(index + var) which is the same thing as index[var] And my grand point is: even when you think you're ready for advanced topics there's still basics to be learned. I only recently learned about unions, which are super handy for MCU programming.
Learn how to [use polymorphism in C](http://nullprogram.com/blog/2014/10/21/) and [lock-free data structures](http://nullprogram.com/blog/2014/09/02/) using atomic primitives.
I am having issues initializing a struct which contains values that are read from a .dat file. The errors I'm getting relate to creating an instance p of my struct parameters. I am using a header file and think that might be the issue. How are header files organized and when and where should I declare the struct? Thanks!
Haha, good, more jobs for those of us who actually do know and use C! (Anyone in the embedded world is very likely to use C still)
What is clean and good for one person, is ugly and bad to another. Though there are some basic guidelines most follow, there is no unifying direction.
I was talking about the second edition. I don't own the first edition but I conclude it's worse.
It seems to me that whomever wrote the article is not very good with c. The point that c has very little abstraction for example; with very little effort and some function pointers, you can implement polymorphism enough to get the abstraction you need. 
Redditors seem to like to link to anything on the internet.
I'm learning C. That's really encouraging...sigh.
Ignore this article. C is still useful.
Generally speaking (there are lots of ways to do this, but I'll try to present the simplest), you would have the following: You define the struct in your header file, which might be called header.h struct my_structure { int number; char letter; int count; } In your code (e.g. main.c), you'll need to include that header so that the definition is available to you. Note the use of quotation marks to specify this as a header file you wrote, instead of a system header. #include "header.h" At some point in your program you declare a variable with a type of your struct like this: struct my_structure p; Later, once you've read the data from your file, you can modify the members of p like this: p.number = 1; p.letter = 'b'; p.count = p.number + 5; I also found [this site](http://www.tutorialspoint.com/cprogramming/c_structures.htm), which has some more examples. Note that defining the structure in the .c file is exactly the same as defining it in a header and then #including it. If you have questions about any part of this please let us know
Your code is awfully complicated. Why not generate 4 numbers between 0-9, then add them up? Like, num1 = rand() % 9; num2 = rand() % 9; num3 = rand() % 9; num4 = rand() % 9; return num1 * 1000 + num2 * 100 + num3 * 10 + num4; You still need to check if any of these numbers are same, but you could implement that in a much simpler way.
Your post says 1 - 6665, but your code is 1000-6665. In my opinion you have a lot of unnecessary code if it is really 1000-6665 (really both, but...). It might be easier to just do something like call rand() and % out the low digit as many times as it takes to get 4 non-equal digits, then mash them together in which ever order you like.
alright, I got it, thank you @SeriousBug and @motocali, I got now another problem: I was asked to make a function the gets a number from the user, without him inputting enter, just 4 numbers that eventually should be compared to the randomed number, so here's the thing, I'm stuck in the inputting, I uses getchar() and it doesn't get the number, it just keeps getting number. please help me fix it guys? Code: void game(int randomed_code){ char a ,b ,c ,d ; int i = 1; int scr = 0; int userin; while(i){ a = getchar(); _flushall(); if(a != 13){ b = getchar(); _flushall(); } if(b != 13 &amp;&amp; a!= 13){ c = getchar(); _flushall(); }if(c != 13 &amp;&amp; b != 13 &amp;&amp; a != 13){ d = getchar(); _flushall(); } if(a &lt; 55 &amp;&amp; a &gt; 48 &amp;&amp; b &lt; 55 &amp;&amp; b&gt;47 &amp;&amp; c &lt; 55 &amp;&amp; c&gt;47 &amp;&amp; d &lt; 55 &amp;&amp; d&gt;47 &amp;&amp; a!=13 &amp;&amp; b!= 13 &amp;&amp; c != 13 &amp;&amp; d != 13){ //If the user's input is correct, you end the loop, and start another attempt. i--; //exit the loop if the user's input is correct. printf("n\n"); }else{ printf("\nOnly 1-6 are allowed"); printf("\nWrite your guess ( only 1-6, no Enter is needed)"); } a = 0,b = 0,c = 0,d = 0; } }
I don't think you can do that, not with getchar at least. The input is buffered, and `getchar()` will also wait until the user hits enter. Edit: Perhaps [this would help](https://stackoverflow.com/questions/2984307/c-key-pressed-in-linux-console), though this is probably outside the scope of your class.
Thanks for the update. Have you read through "C of Peril"?
Nope, but since it's short I'll probably give it a quick read when I need a break from my current reading of "An Introduction to Scheme and its Implementation".
Maybe people think I'm kidding/trolling?
That's indeed possible. Iverson's source code is very terse but highly readable once you get familiar with the conventions.
&gt; Nope ... Dang. I was hoping you had, which would then imply that "I don't recall anything bad about the C code presented in the book" included the contents of "C of Peril". The contents are fairly well known, however, so it's still a possibility. &gt; ... give it a quick read ... It is definitely that. Certainly helpful to have on hand for a quick refresher.
Pet peeve: the `else` in your example is unnecessary. If the first branch is taken, we exit the function. If the branch is not taken, then obviously we're still in the function, no need to make that explicit with `else`. Sorry for the tangent. I think you found a bug there, but something subtle might be going on. Maybe they always want to call the function for logging/debugging purposes, and decide afterwards if they want to use its result. In other words, the function might have side effects.
I didn't think about the logging/debugging purposes. Thanks for the hint. I removed the else, meaning was still clear though. :)
The check was not written by me. It was already there by the X server devs. My question was not how to check for an overflow but when to check.
If you're not wedded to using C, there are several Python packages that can help you do this. * http://www.python-excel.org has some resources for handling Excel files in python * https://xlsxwriter.readthedocs.org/ this project let's you write to xlsx files, don't think it does the older formats If you really need C, I'm sure there are libraries out there. I'll warn you though, no matter what language you use, Excel files are a pain in the ass to work with. The old format is this funky thing called an OleContainer format which is kind of like a file system rolled up into a proprietary format. Excel stores all kinds of things relating directly to its own internals, which as you can imagine, makes things difficult for interoperability. Excel 2007+ files (xlsx) are a little better, but any Microsoft format is going to be a gigantic cluster fuck to do anything with, its just how they are. Python will be able to run on all your target OS's, but windows systems are going to need to have it installed, or you can do some interesting things with Freezing a python script, which rolls up the interpreter and any necessary library files and provides a native executable for invoking the program. * [http://www.py2exe.org/](py2exe) creates executables for Windows * [https://pythonhosted.org/py2app/](py2app) makes... Whatever the hell macs use to run stuff, I have no idea. Linux systems would need the relevant packages installed, but they almost always come with one version of python or another. Feel free to PM me if you want to discuss any of this further! Ive bashed my head against Excel files plenty of times in the past, enough to know I hate the format with a passion, but it can be worked with to do just about anything you may need to do. Cheers!
Since Excel can read CSV files, could you write a VB macro in excel to do all the work?
I'm sure there is a way to use programming in biology in some way. Is there something specific you're looking to do? Also, did you like programming even though your grade wasn't that good? If you liked it then I would stick with it and really put in the time to get better. If not then don't struggle, just drop the minor.
So something like this? int x, y, w, h, start; w = h = 10; start = 2; int array[w][h]; for(y = 0; y &lt; h; ++y) for(x = 0; x &lt; w; ++x) array[y][x] = (x + start) * (y + start); Keep in mind that indexing in C starts from 0. You only need an extra array element for strings, since it adds a zero after the text to mark the end of the text.
&gt; Technically it doesn't matter if you check before or after as long as you don't have visible side effects. That isn't true. Signed integer overflow is undefined behavior in&amp;nbsp;C. If the overflow check is done *after* the multiplication, then a compiler is allowed to optimize away the overflow check completely, because the multiplication has already been done, and if it overflowed then the behavior is undefined anyway. Read [What Every C Programmer Should Know About Undefined Behavior](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html) (and [part&amp;nbsp;2](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html) and [part&amp;nbsp;3](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html), especially the first code example in part&amp;nbsp;2).
Why don't you just keep them as csv files you append to? Excel has no problems opening csv files and then you can save it as an excel sheet when you're done with it if you need to.
I study Computer Science and involved with C since I was 11. I have learnt most of things on web. But this doesn't mean web can be replaced with university. Since you don't get A, thinking about GPA is better. Actually you'll need to dive deep to work with computers on Biology. 
Please do not make separate threads for no reason, continue your questioning on [the original one](http://www.reddit.com/r/C_Programming/comments/2ow1zx/begginer_retarded_question_i_accidentely_made_a/). Snippets out of context are doubly hard to follow
I am studying bio computing. If you are majoring in biology, then I would advise against learning c. When biologists "program" they use specialised tools in most cases (why reinvent the wheel if you only need to work on data). The programming done in biology is extremely niche and you wouldn't get any practical benefit out of it. Instead take something not related to biology maybe. You may look back on the experience and be proud that there is an area unrelated to your specialisation that is also a cool conversation topic 
Okay. I'll do it from my next thread. :)
&gt;is the [biology] degree worth pursuing the minor and lowering my gpa? This is a question for a biology subreddit and not a C Programming sub.
Either [K&amp;R's The C Programming Language](http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628) which is often considered "The C Bible" and is written by the authors of C, or a more recently published [C Programming: A Modern Approach](http://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1418301753&amp;sr=1-1&amp;keywords=c+programming+a+modern+approach) are both excellent and comprehensive learning resources. I personally recommend the latter because I believe it is more relevant and includes almost, if not all, the information in K&amp;R.
It's a good book, but not really for beginners.
Programming in C by Kochan C Programming A Modern Approach by King C Primer Plus by Prata Any of those three are perfectly suitable for a beginner with little to no programmer experience in any other languages. People will recommend K&amp;R aka The C Programming Language, 2nd Edition. K&amp;R is an amazing book but it isn't for a total beginner to programming. It is a great book to read after one of the above. Personally I have a soft spot for A Modern Approach. For references C in a Nutshell is really good. The GNU C Manual is also a fantastic resource. 
What is the content of `stdafx.h`? 
C Primer Plus (6th edition) The only book of my knowledge which covers C11 in its entirety
C was just the introductory course. I think next is Python and then we are allowed to specialize into what we would want to learn. I agree that I wouldn't use C to do any biological computing. I will definitely continue to learn programming becuase it interests me, I am just wondering if that should be classes that have the potential to harm me in terms of gpa, or if other sources, like the internet will suffice?
I do like it and I am not bad at it. I failed one assignent we had because I failed to get it done in the allotted time, and there was no partial credit. I will continue to learn, I am just wondering if I should do it on my own using the internet or something, or if college classes are the best way
I agree. I do not want to lower my gpa because currently I have a very good one. However, I also enjoy computer science very much. Do you think it is possible to learn computer science outside of classes? Maybe from the internet?
I know computer science isn't just programming, programming just happens to be the only part that has given me any trouble. So if I continue learning computer science without taking classes, will not having it listed as an official minor degree be detrimental to future job oppurtunities, assuming I learn the same skills I would have if I kept taking classes? Or is it more that if you can show that you know what you are doing, then thats all that matters?
Good question! I'll check to see what books are listed in the sidebar and get back to you as soon as I do. 
I will second this option. It will probably be the easiest way to get it done. 
My first book on C was Patrick Henry Winston's, [On to C](http://www.amazon.com/On-C-Patrick-Henry-Winston/dp/020158042X). I loved it. It's dated but very easy to read and acts as a wonderful springboard to some of the other titles mentioned here.
Well you could look here:https://stackoverflow.com/tags/c/info
Honestly. I learned using C for Dummies. It's straight forward and easy to read, and full with great example programs to follow along with. Great starter and reference book. That should get your noodle going until you can handle more "complex" written book's. By complex I mean boring as hell to read. 
I did. You have to study/work hard outside of class in order to master your skills. This is a wide area to make researches on it. When I was applied for uni. I had already known Object Oriented Programming. Probably without a class It will be hard to learn some key points like algorithms and data structures. But if you take these classes you'll have to study hard. For example CUDA is used in medical imaging. You can learn how to use that library but when it comes to make an algorithm and optimize/speed up code, you'd probably struggle a lot. I have faced problems like this before university and still getting.
Perfect. Can't go wrong with K&amp;R and I believe that's the tutorial I read that finally made pointers make sense to me.
Do you want to learn programming or how to program in C? Because this book teaches you programming. A programming needs to think and examples inside this book great to make your brain think.
I used [Head First C](http://www.amazon.com/Head-First-C-David-Griffiths/dp/1449399916) which has a friendly style. Just yesterday I found [Beginning C](http://www.amazon.com/gp/product/1430248815) which looks pretty good.
C: The Complete Reference by Herbert Schildt
Sure. PM me. I would prefer google hangouts, you can do screen shares on there.
I loved C/C++ How to Program by Paul and Harvey Deitel. Gave me a good overview and also offered a lot of deeper insight as well (especially in the exercises). 
&gt; Can't go wrong with K&amp;R You can if the person it is being recommended to is not a programmer. K&amp;R is amazing, but to someone who doesn't have a basic foundation of programming concepts it would be an insanely steep learning curve. If someone has no programming knowledge at all, it's best to start with something like C Primer Plus or Head First C, and then come back to K&amp;R. 
I think getting a good handle on pointers and then reading K&amp;R, you should do just fine.
K&amp;R is not only an excellent primer on the language, it is also very clearly written and includes numerous small exercises. 
With no knowledge of programming whatsoever? No understanding of any of the basic concepts at all, someone just explains pointers real quick and K&amp;R would be good? Sorry, I would strongly disagree with you, as would K&amp;R based on what they said in their own introduction.
Depends on how fast you want the interpreter to be really. But the dispatch mechanism (switch in this case) isnt the only factor here, the encoding of the instruction stream itself also plays a big role. From pure node walkers to bytecode virtual machines to jit compilers, you have some reading to do ;)
Well how ignorant are we talking about? I'm assuming someone interested in programming has a clue. If we want to go back far enough we should say you need to have a good grasp on basic English and a good understanding of--in the very least--algebra.
You might want to look into lexers and parsers. Perhaps a few chapters in the Dragon Book might help with pointing you in the theoretical direction. Edit: In theory though, it seems like an easy problem. * main sets everything up and calls the command parser * command parser sits in an infinite loop, * command parser takes input from the user and passes of to the lexer or grammar * lexer or grammar takes the input and calls the specific methods/libraries to handle the input * command parser quits out if the lexer or grammar detects the exit clause * control is passed back to main (with an error code?), and main returns
Let me know if this doesn't work, I'd be happy to help as well
Well, for starters, K&amp;R gives you no hints about how to run your code. You can't go from K&amp;R to a runnable executable without someone else's help because the book makes no effort to explain how compilation works (or what compilation is), how to run programs at the command line, what the command line is, and so on and so forth. The book is also really light on basic programming concepts like variables, functions and the like.
Same here -- if you want to google hangouts i'ld be happy to help. PM me.
Thanks a lot, this really helped! 
It's not about optimization, it's about code clarity. The "else" conveys no information. Compiler doesn't care either way, but the "else" takes up valuable screen space and brain cycles.
If on a linux box, check out lex and yacc. Both have a fairly low learning curve and work wonders. There are several good tutorials online to get you started. The basic idea is to break your raw string into a chain of tokens based on the defined grammar, that is then able to be evaluated.
Thank you all for the tips and advice. I think that I found my solution. I am pretty comfortable writing Perl scripts, and took some of your advice. What I am doing now is getting the data from all of the CSV files and writing it to a new CSV file (text is so much easier to deal with). This can then be opened in Excel, manipulated as needed, and can be saved as an Excel spreadsheet. What drove me to this solution was the advice that I received here, and looking at the person that will be using this data. He is using a Mac, and fortunately it has Perl loaded onto it. I am a Linux guy, so doing something with VB is pretty foreign to me. Once I get this working correctly, I still would like to learn how to do the same thing in C, just for my own education. Most of my C programming experience involves micro-controllers and doesn't involve handling text files too much. I thank you all for your input.
yeah let implement a jit compiler to insert nodes in a list!11!! are you serious or trying to appear smart?
Firstly, 'rand() % 9' will produce results in [0,8] range, not in [0,9] range. Secondly, it is easy to generate non-repeating random numbers in one shot, without making any trial-and-error iterations. But the tricky part in this case is that leading zeroes are allowed to repeat...
He IS making an interpreter, i just pointed him to the field. And he only specified a few instructions, i assume he would want to do more than just manipulating a stack. Ive made several compilers, virtual machines and jit compilers and its not really that hard, that you think one has to be "smart" for it is your problem not mine.
Likewise, pm me. 
What school is this, out of curiosity?
Is this homework because it certainly sounds like it? I don't think that anyone is looking to do your homework for you. That being said, if you can tell us where you're struggling then people will be more than happy to point you in the right direction.
Not gonna do your homework for ya, but this can be trivially implemented with rand (), modulus %, and left shift &lt;&lt;, if power of two growth is acceptable.
The field of biology makes heavy use of programming by lots of scientists who do not want to be computer scientists. A lot of biologists are Fortran fossils, but other languages like python and C++ are gaining in popularity. I think the OP would be well positioned by getting a minor in CS as the field of Biology is becoming much more CS heavy. Bioinformatics is a huge growth field right now.
Pretty sure a pointer is involved if you're using malloc non-ironically. Now I'm off to identify ironic uses of malloc....
Yes that would be a great way of learning of this teacher gave us some breathing room, he is throwing labbs after labbs, 2-3 at a time as well. in literally 1 month we went from hello world to using pointer mallocs structures and building some really hard programs for a beginner to even grasp. But I understand where you are comming from and thanks :) 
ah ye I can see how "maybe pointers" is a bit funny since they are involved in mallocs :p haha
I don't fully understand what you are trying to do, but I can tell you that your approach is going to have pretty terrible runtime complexity. You can do much better. If you want to impress your professor, code up a trie. It can be done in ~30 minutes and is super easy if you can constrain the problem to fit in main memory. If you want to handle every possible ASCII value, have each layer in your tree be an array of size CHAR_MAX. To sort, insert every string into the trie, then do a pre-order traversal on it.
A. Community College. 
No its not. It's a job from freelancer and i can prove it. I am struggling at the point where i don't understand the math behind this problem. But, I tried to learn it and failed and that's why i am asking like this.
It's not my homework. It's for a job from freelancer and i can prove it. What is left shift? What is power of growth? That's what I am talking about. I don't know math and because of that i don't understand it. If you were that stupid for math like me you would do the same..
yes .. i forgot to mention that .... i am trying to create 2dimentional windows in ncurses.
qsort()
There is a standard library function called [qsort()](http://pubs.opengroup.org/onlinepubs/9699919799/functions/qsort.html) which does what you want.
yes .. sure kristler .. http://pastebin.com/WKz0zCaa .thanx in advance
 while(true) malloc(0); //this will cause out of memory eventually :D edit: If you want to know why, it's because a zero-size allocation will still return a pointer that can be freed, and despite the allocated memory area being zero-size, there's a little bit of memory just before the pointer which says how big the allocation is (it's needed by the memory management system). Hence, eventually, this will use up all the available memory :)
in 1 month if you don't go from hello world to either pointers and malloc/free or file IO, then your teacher is coddling you, frankly. 
Here's something a bit [more readable](http://pastebin.com/b4yaL4NV). At line 29: WINDOW *win[n]; tile blank; for ( i = 0; i &lt; n ; ++i ) win[i]= (WINDOW *)(malloc(n * sizeof(WINDOW))); Instead of doing this, why not create a 2D array to begin with? WINDOW win[n][n];
I tried .. I did .. WINDOW ** win ;win =(win ** )malloc(n * sizeof(win * )); For(i=0;i&lt;n;++i) Win[i] =(win * )malloc(n * sizeof(win));
Exponential distribution, that's what it says..
You can find a method on Wikipedia: http://en.wikipedia.org/wiki/Exponential_distribution#Generating_exponential_variates
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 16. [**Generating exponential variates**](https://en.wikipedia.org/wiki/Exponential_distribution#Generating_exponential_variates) of article [**Exponential distribution**](https://en.wikipedia.org/wiki/Exponential%20distribution): [](#sfw) --- &gt; &gt;A conceptually very simple method for generating exponential [variates](https://en.wikipedia.org/wiki/Random_variate) is based on [inverse transform sampling](https://en.wikipedia.org/wiki/Inverse_transform_sampling_method): Given a random variate *U* drawn from the [uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous\)) on the unit interval (0, 1), the variate &gt;&gt; &gt;has an exponential distribution, where *F*^ −1 is the [quantile function](https://en.wikipedia.org/wiki/Quantile_function), defined by &gt; --- ^Interesting: [^Wrapped ^exponential ^distribution](https://en.wikipedia.org/wiki/Wrapped_exponential_distribution) ^| [^Q-exponential ^distribution](https://en.wikipedia.org/wiki/Q-exponential_distribution) ^| [^Hyperexponential ^distribution](https://en.wikipedia.org/wiki/Hyperexponential_distribution) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmstlki) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmstlki)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If you are doing what I wrote, `WINDOW win[n][n];` then there is no need for a `malloc` call because the memory is allocated for you already. Giving a similar example: int x[10][10]; int i, c; for (i=0; i &lt; 10; i++) for (c=0; c &lt; 10; c ++) x[i][c] = i * c; This will code would create an array of numbers that looks like: 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 0 2 4 6 8 10 12 14 16 18 0 3 6 9 12 15 18 21 24 27 0 4 8 12 16 20 24 28 32 36 0 5 10 15 20 25 30 35 40 45 0 6 12 18 24 30 36 42 48 54 0 7 14 21 28 35 42 49 56 63 0 8 16 24 32 40 48 56 64 72 0 9 18 27 36 45 54 63 72 81
I am specially puzzle by how they declare the first function. Not sure what is going on over there.
not working in that way ... ERRORS::&gt;&gt;&gt; test.c: In function ‘main’: test.c:34:5: warning: passing argument 1 of ‘init_win’ from incompatible pointer type [enabled by default] init_win(win,n); ^ test.c:12:10: note: expected ‘struct WINDOW *’ but argument is of type ‘struct WINDOW * (*)[(sizetype)(n)]’ void init_win(WINDOW *win, int n); ^ test.c:40:5: warning: passing argument 1 of ‘init_win’ from incompatible pointer type [enabled by default] init_win(win,n); ^ test.c:12:10: note: expected ‘struct WINDOW *’ but argument is of type ‘struct WINDOW * (*)[(sizetype)(n)]’ void init_win(WINDOW *win, int n); ^ In file included from test.c:3:0: test.c: In function ‘init_win’: test.c:56:19: error: subscripted value is neither array nor pointer nor vector box(win[i][j],0,0); ^ test.c:57:20: error: subscripted value is neither array nor pointer nor vector wrefresh(win[i][j]); ^ test.c:58:6: error: ‘startx’ undeclared (first use in this function) startx+= WIDTH; ^ test.c:58:6: note: each undeclared identifier is reported only once for each function it appears in test.c:60:5: error: ‘starty’ undeclared (first use in this function) starty += HEIGHT; 
i thinking without using pointer its not possible to work with ncurses... i can't able to troubleshoot it ...
Do you understand what the calloc() function does? Have you read its man page?
&gt; Do you understand what the calloc() function does? Have you read its man page? Yeah that part is fine. Is the definition of the function that I found weird: static int (**hnew())[2] { ... } It looks a lot like a function pointer but never saw one with a body statement next to it before. 
Thanks.. I just realized that with a couple of typedef you can go back to the normal &lt;type&gt; &lt;function-name&gt;&lt;parameter-list&gt; format declaration.
That is a function declaration. hnew() takes no parameters. That is all specification of the return type. I must admit I'm a little fuzzy on the parentheses placement, but you should note that an pointer and an array (particularly a statically sized array) are of different types.
I know, which is one reason it's really strange code. The whole thing just screams of somebody trying to be clever.
And that's my problem with it. You can't return arrays. Ah. Lightbulb. It's not returning an array. It's returning a pointer to an array. [edit] Now I'm not sure again after looking at the rest of that. It really is ugly code. 
[Learn C The Hard Way](http://c.learncodethehardway.org/book/) - [Zed Shaw's](http://en.wikipedia.org/wiki/Zed_Shaw) book
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Zed Shaw**](https://en.wikipedia.org/wiki/Zed%20Shaw): [](#sfw) --- &gt; &gt;__Zed A. Shaw__ is a software developer most commonly known for creating the [Mongrel web server](https://en.wikipedia.org/wiki/Mongrel_(web_server\)) for Ruby web applications, as well as his articles on technology, business, and technical communities. His most famous and well-covered piece was his article called "Rails is a Ghetto" which has since been removed from his site. &gt;==== &gt;[**Image**](https://i.imgur.com/MvG3FlY.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Zed_Shaw_in_Montreal_cropped.jpg) --- ^Interesting: [^Mongrel2](https://en.wikipedia.org/wiki/Mongrel2) ^| [^Mongrel ^\(web ^server)](https://en.wikipedia.org/wiki/Mongrel_\(web_server\)) ^| [^Newsbeuter](https://en.wikipedia.org/wiki/Newsbeuter) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmt2yje) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmt2yje)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
As an alternative to what has been posted, check out [Ragel](http://www.colm.net/open-source/ragel/). "Generate C, C++, Obj-C, C#, D, Java, Go or Ruby code with no dependencies." **What kind of task is Ragel good for?** * Writing robust protocol implementations. * Parsing data formats. * Lexical analysis of programming languages. * Validating user input. 
Awesome!
The first function declaration is equivalent to typedef int (**T)[2]; static T hnew() { return calloc(sizeof(int**), SIZE); } Type `T` is a pointer, which points to another pointer, which points to an `int[2]` array. Or, if you prefer, you might rewrite it as typedef int Int2[2]; static Int2 **hnew() { return calloc(sizeof(int**), SIZE); } The intent is to allocate an array of 1024 pointers, each entry being a pointer to an `int[2]` array. However, the `calloc` call inside this function is formally nonsensical, if you consider the relationship between the declared return type and the size specified in `calloc`. I.e. the size calculations in `calloc` suggest allocating an array of 1024 pointers of type `int **`, but the return type is actually `int (**)[2]`. It will "work" (see below), but it has no meaningful rationale behind it. The proper implementation of `hnew` function in that case would look as follows static int (**hnew())[2] { return calloc(sizeof(int(*)[2]), SIZE); } or, with the above typedef typedef int Int2[2]; static Int2 **hnew() { return calloc(sizeof(Int2 *), SIZE); } Note the type used inside `sizeof`. What they have originally "works" simply because all data pointer types on a given platform usually have the same size, which means that you can use *any* pointer type under `sizeof` and the code will still "work" properly. ====================== If you introduce a typedef typedef int Int2[2]; then the code might be rewritten as shown at this link http://pastebin.com/9Gzgy1Mt It is more readable, but still requires some skill with arrays and pointers to understand it. Note, BTW, that the author of the code got lost in their own multilevel pointer indirections and made a mistake in `hget` function static int(**hget(int(**t)[2], int k))[2] { for (int h = k &amp; (SIZE - 1); **t &amp;&amp; ***t != k; h = ((h + 1) &amp; (SIZE - 1)), t += h); return t; } The cycle condition checks the value of `**t`, but this expression is illegal to evaluate if `*t` is null. The author does not check for that. And if `*t` is not null, then `**t` cannot possibly be null either (for this specific type of `t`). For this reason it is clear that the author intended to check `*t` instead. The code will "work" in practice as is due to the relationship between these two expressions, but run-time code analysis tools should be able to catch this error as an attempt to dereference a null pointer. (Note that I did not fix this error in the pastebin version linked above.)
Keep your chin up, it just takes a bit of hard work to keep up and keep ahead. Your dilligence will pay off. When you go to work in industry (if you choose to do so), you'll generally be expected to learn new frameworks very quickly, so it's an extremely valuable skill to grasp new concepts. If you're new to University it might seem a lot, but in a year or two this will seem quite routine to you.
http://cdecl.org/ is a nifty little tool to help explain complex types.
Link is not working, can someone mirror what the original code was?
No, it's saying the function return a pointer to a pointer to an array of ints. 
Well, that's exactly what I say above in my post. However, in practice, as I said above, all data pointer types usually have the same size. I.e. numerically `sizeof(Int2 *)` is the same as `sizeof(int **)` and the amount of space the code allocates is actually correct. You can even use `sizeof(double *)` here, however nonsensical it might look at first, and still get the correct amount of space. But formally you are absolutely right. `sizeof` should use the proper array element type, not some random type whose size just happens to match.
hehe #include &lt;stdlib.h&gt; int main(void) { return system("ls -la"); } &gt; 
Thanks for your comments. Yes that should all be fixed now. 
Obviously, but it's still fun to break stuff :) Btw, when I ran bash it hang.
That's expected, it waits for input.
Why wouldn't I just use C++? Plus, doesn't Apple already have [Objective C](https://en.wikipedia.org/wiki/Objective-C)?
Someone once said: C++ is a horrible language. It's made more horrible by the fact that a lot of substandard programmers use it, to the point where it's much much easier to generate total and utter crap with it. Quite frankly, even if the choice of C were to do nothing but keep the C++ programmers out, that in itself would be a huge reason to use C. That someone was Linus Torvalds.
Precisely. And if you've ever waded into GNUStep, .. yikes. Good luck creating anything you could ever consider distributing.
Why use C++ for OOP? It's horrific, or to quote Alan Kay: &gt; I invented the term Object-Oriented, and I can tell you I did not have C++ in mind. 
You can program C and use a C++ compiler for virtually everything, right? So why wouldn't I just do that, instead of using this new thing? If I want single inheritance in C, I can just compile my "C + C++ Features I Like" on a C++ compiler. *"Well you'd be using C++ then so it wouldn't be C anymore!"* You're already going to be not-C anymore, so you can't use that as an excuse to use this new thing over C++. I just don't really see the benefit of using this. What would be the purpose? The fact that maybe you can still use malloc instead of new? I guess if it's like a hobby or class project or something, but for anything more, I just can't justify it.
Why does this have the URLSession stuff included? Given that the rest of it seems only to depend on stdlib and pthreads, [libcurl](http://curl.haxx.se/libcurl/) is a bit of a surprise unannounced dependency, for what isn't really "core" functionality, especially when you describe this project as "ultra-lightweight". Why not have a README section listing your dependencies? Maybe above "Adding objectively to your project". It appears you also need check.h as well for instance. Yes, I know autoconf will tell me, but its a bit annoying to have to find out that way. Other than that, pretty nice neat code, if somewhat lacking in comments. For instance, in Hash.c, I have no clue what hash function you are using, and there are no comments to say which. Just a single line "fast hash from http://....." would do.
This is considered light-weight these days?
You weren't asked to justify it. Also, this *is* purely C99, so I'm not sure where you got "not-C anymore." Further, the point isn't just to create a cute OO construct for C, it's also to port a lot of the rich functionality from Apple's Foundation framework to other environments. And lastly, it's nowhere near done -- it's something I've worked on for a couple months now in my spare time. So maybe wait to see how it evolves before discrediting it?
Well, Linus Torvalds is rather well known as an architect who has energy to drive large software projects, but he is not very highly regarded as a programmer, to put it mildly. His knowledge of C++ is virtually non-existent and he is not exactly an expert in C either. His "profound" statements about these programming languages typically cause programmers to facepalm profusely, which nevertheless does not stop him from continuing to embarrass himself with making them. In the professional programming world we wouldn't care much about it, if not for the brain damage his "prophesies" inflict on starry-eyed newbies. Every development team should have a person like Linus at the helm. Such people can drive the development process forward better than anything (even better than money). But the well-known flip side of that medal is that working in such team implies being able to calmly tolerate the endless stream of "prophetic" nonsense such prima-donnas generate.
Good points! URLSession is one of the core facets of Foundation, and that's why it's here. I can't remember the last time I wrote a non-trivial application that didn't need to access resources from the Internet. Having a very convenient API to asynchronously load URLs and then act on those resources is a huge leap forward for application development in C (in my opinion). As far as dependencies go, I don't think libcurl is very offensive. It ships on OS X and is pre-installed by many desktop Linux distributions. But check is only for unit testing, and you're right -- that one should be optional. I'll make it so in the near future.
Right on! I learned quite a bit in building it :)
Firstly, you are trying to put words in Alan Key mouth. The quote was never intended to mean what you are implying. Secondly, the quote is meaningless in 2014 simply because C++ has changed a lot since these words were said. (Not even mentioning that C++ did not really exist at the time.) The perfect suitability of C++ for OOP is not disputable.
I think the typeof storage type is a part of C11, and so it's pretty widely supported (GCC and Clang) already. The `$` is legal for symbol names again with both GCC and Clang, too.
Bullshit. He meant what he said and what I quoted. Did you attend OOPSLA '97 then? It was the same year C++98 was drafted. And he specifically related his intention of OOness to the then-present C++-98 draft. OOP in Kay's mind is: &gt; only messaging, local retention and protection and &gt; hiding of state-process, and extreme late-binding of all things. It &gt; can be done in Smalltalk and in LISP. There are possibly other &gt; systems in which this is possible, but I'm not aware of them. Taken from http://www.purl.org/stefan_ram/pub/doc_kay_oop_en I suppose you will argue next that C++ did not exist in 2003 either :) 
No, I'll simply argue that all that can be done in C++ as well :)
I wouldn't call it bloated. However it does more than just provide an object system for C. It also duplicates already existing functionality, or at least puts a new layer around it. For example, do you really need to put classes around "primitives" like double or mutex? I'm already familiar with the pthread api, so adding another layer around it gives me no advantage. In fact, it makes the code less flexible. Imho classes are appropriate where you have a true type hirarchy, for example in widget toolkits or maybe containers. But maybe I'm missing something here :) I have some ideas for an "object system" myself, and a few bits of code exist, but nothing on this scale. It involves lots of unions and function jump tables :D btw: isn't this a gcc extension? `self-&gt;fmt = fmt ?: NUMBERFORMAT_DECIMAL;` 
Nah, I'll just discredit it outright. As I've said, I don't see the point of it. I'm not saying you stop. I just don't see the purpose. Like I said, they already have Objective C, and C++. It's not purely C99 if you're adding inheritance and other language extensions. That's not a language standard, and it makes me question whether or not you actually know what "pure C99" even means. It's like trying to say that all of the GCC additions are "pure C99". No they aren't. If I have to use your specific compiler, or your specific libraries for it to work, it's not "pure C99". 
Who said anything about language extensions? The inheritance model I use relies on struct composition and alignment; nothing more. Compiler extensions? I use `typeof` and I used the `$` as a macro name.
Frankly, with `$` supported by both Clang and GCC, I'm not sure what practical values of "not portable" you're so concerned with. But, I may add some preprocessor directives to map the magic method invoker to another name for compilers that don't allow "$".
Object wrappers for primitives (like double, char *, _bool, etc..) are necessary (or at least extremely convenient) when dealing with data formats like JSON, or other applications where you might wish to store those values in collections such as arrays or dictionaries. A wrapper around pthread_mutex_t might not seem so useful, but when you extend it to also encapsulate a pthread_cond_t, and you can suddenly call `lock`, `wait`, `signal` and `unlock` all on the same object, it starts to feel a whole lot more useful, and the semantics of how to synchronize become simpler. http://jaydolan.com/projects/objectively/struct_condition.html The shorthand ternary is a GNU extension supported by both GCC and Clang. I'm compiling on Clang 100% of the time.
Then it's not actually inheritance, is it? If I make my new structure contain my old one, that's not inheritance. If I make it point to my old one, that's also not inheritance. Actually going and looking at that, I *really* can't justify it. It's ugly as sin; and if there's one thing I do hate, it's ugly code.
Uhm, you could just use this and include only the headers you want? #include &lt;Objectively/Object.h&gt; // your code here :&gt;
Which makes me giggle when he totes out the line: &gt; Also, this is purely C99, 
It's a tortured example to demonstrate both Class and instance method invocations. You got me. I'm not a good engineer and you are smart.
Replace the word *portable* with *standard*.
OOP has been proposed for C14. The proposal has been rejected by the committee two months ago. [N1816 Adding methods() to structures in C](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1816.pdf) from [N1820 Parks, minutes from Parma](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1820.pdf): &gt; **6.3 Adding methods() to Structures in C [N 1816], Max Abramson** &gt; &gt; Max was not there to present his paper. He has been talking to John Benito &gt; about it for about a year. It would have been great to have him there to &gt; champion his work. The committee believes it is important to listen to its &gt; constituency, they welcome their proposals, and they take them very seriously. &gt; &gt; There was concern about the name mangling issues this will introduce which will &gt; radically change C compilation. &gt; &gt; The paper combines about 5 concepts/proposals that could be separated. Some &gt; noted that it would be good to consider these individually. &gt; There was discussion about the motivations offered in the paper: improved &gt; compilation time and memory footprint, and increased interoperability with C++. &gt; Some were concerned that these changes could have the opposite effect. &gt; Another motivation might be that these features could enable other &gt; technologies. For example, adding member functions might enable us to add &gt; container classes cleanly. &gt; &gt; About 20 years ago, there was a serious effort to pull interesting parts of C++ &gt; into C. The effort was abandoned after a couple years. Language design is &gt; difficult; everything has to hang together. And the world loves C in part because &gt; of its simplicity. &gt; &gt; There was discussion about finding the committee documents from that effort. &gt; Unfortunately, these documents are not available from our document registry in &gt; electronic form. Looking at the document registry, very few of the documents &gt; older than N598 (06 Sep 96) are available on-line. And the most interesting &gt; documents in this area seems to begin with N298 (Jervis, Classes in C, 16 Nov &gt; 93). That was followed by a number of Jervis papers on constructors and &gt; destructors, virtual functions, and inheritance over the next couple years. [N1875 Adding classes to C](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1875.htm) [N1876 Access specifiers for structures in C](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1876.htm) [N1877 Single Chain Plus Link Inheritance for C](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1877.htm) from [N1884 Hedquist, Draft Minutes St. Louis, MO USA October 27 - 31, 2014](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1884.pdf): &gt; **6.7 Adding Classes to C [N1875] (Abramson)** &gt; &gt; The notes here apply to Items 6.7, as well as 6.8 and 6.9 below. Proposal to add C++ &gt; style classes to C. Max Abramson gave a presentation on adding features to C. &gt; Methods to structures, access specifiers, and single chain inheritance +link. College &gt; grads today are focused on object oriented programming. &gt; Today, the basic workaround is to use structures in place of classes. Java, C# and &gt; C++ are becoming too hard to learn. The issue revolves around inheriting someone &gt; else’s code, rather than using features of a language well understood by the &gt; programmer. Maintenance and reuse of legacy code. &gt; &gt; In terms of what this committee can do with this, the proposed features are new to &gt; C, and would require a revision to the Standard. As of now, there are no C &gt; implementations that have these features. That suggests an approach of developing &gt; a TS. What is the interest of implementers to do so? Does the C Community want a &gt; C language with OOP features? These features will work with gcc, clang, right now. &gt; Relatively clean, easy to implement. &gt; &gt; Are there any C/C++ compatibility issues? None have been found. The goal is to be &gt; compatible with a subset of C++. &gt; &gt; Are we interested in seeing more work on these topics in six months? &gt; &gt; Straw Polls – Would we be interested in: &gt; &gt; 1. Add namespaces in C: 1-5-lots: No &gt; &gt; 2. Member functions: 1-6-lots: No &gt; &gt; The straw polls above indicate there is no interest by the Committee to persue &gt; further development of the proposal presented. However, we would encourage the &gt; submitter to develop an implementation that gains user experience with the &gt; concepts presented, i.e. Modification of gcc or clang. &gt; &gt; **6.8 Access specifiers for structures in C. [N1876] (Abramson)** &gt; &gt; Proposal to add C++ style access specifiers for data members (instance variables) of &gt; C structures. &gt; &gt; See 6.7 above &gt; &gt; **6.9 Single chain plus link inheritance for C. [N1877] (Abramson)** &gt; &gt; Proposal to add single chain inheritance to C structures. &gt; &gt; See 6.7 above. 
You can code in Objective-C code for any platform supported by GCC or Clang.
And yet he wrote his own kernel and AT drivers to run on top of the minix file system before even distributing it to other people. This type of ability is rare in the industry these days; Probably 1 for every 200 bad developers you run across. His ability as an integrator itself tells you how well he can understand code. No, I have to disagree that he is not highly regarded. 
I'd disagree based on my personal experience. I don't see "yet, he wrote..." as a convincing argument in such cases. For one example, such people are abundant in industries that combine theoretical scientific areas and practical programming. I personally work in EDA (Electronic Design Automation), where most developers come from the backgrounds of theoretical physics, electronics and mathematics and have virtually no formal training in actual software development. Yet they manage to develop massively complex and extensive software products in C and C++. These products are typical examples of the proverbial "programs written by a theoretical physicist". From the software technology point of view these products so incredibly ugly... they would make Santa Claus himself vomit with rage. These products crash, they are incredibly hard to support, the code is unreadable, but at the end of the day the software does its job. The whole world's semiconductor industry uses our products. It basically demonstrates that one _can_ replace refined software development skills with pure stubbornness and perseverance. The replacement is terribly inefficient but it works. Do I have great respect to such people and their efforts? Yes. Will I listen to what they have to say on C and C++ languages? Hell, no. They barely know 30% of C language and their C++ is rudimentary. After listening to many Torvalds's infamous tirades on software development he struck me as exactly that kind of person. And I see that my view is in concert with how his outbursts are perceived by virtually all highly regarded people in the industry. 
Getting feedback can be pretty tough. If you want real feedback on your code that pretty much means someone more experienced than you would need to read through your code. That could be quite hard to find, especially if you want it for free. If you're looking for feedback on style, then you could look into using some sort of style checker. I've only really used the Linux kernel style checker, but I've heard of using indent and Vera before as well. If you're looking to improve the stability/portability/security of your code then enabling all the warning for your favorite compiler (-Wall for GCC, but there are even more flags for warnings than that...) can clue you into improvements you could make. Also, I personally have found [codingame.com](codingame.com) to be really fun and great practice for coding. You can choose your language and text editor. Which of course we would all choose C and vim, right? Right?!? :P Having an environment that is easy to interact with makes coding 10x better. I also love the competitive nature of the multiplayer games. Makes it much easier to push yourself.
Not inspired by Apple, inspired by Smalltalk and created by Brad Cox and Tom Love while they worked at Stepstone.
That's why you just create your own Objective-C STL. Strings, Arrays and Dictionaries aren't exactly tough to implement.
&gt; As far as dependencies go, I don't think libcurl is very offensive. Depending on libcurl ties the project to platforms that support libcurl. Also, libcurl is over 400 kB in size, which makes it unsuitable for embedded or otherwise constrainted platforms. Requiring a 400 kB blob is far from lightweight.
That doesn't change that it's not *standard.* This video game there also works on Windos Vista and Windows 7, so it probably works on all boxes out there. Stop being so ignorant, the languages gcc and clang understand are not exactly equal to C99, not even when you turn on `-std c99`.
`typeof` is *not* part of C11. There is more out there than just gcc and clang.
O_o it says what I'm saying right in the description, inspired by the apple core foundation libraries. Now maybe those were inspired by smalltalk, but that is a different argument entirety. 
I could use this on an embedded linux based board without the objective c runtime (libobjc.so)
If you can hunt down the correct Obj-C runtime, sure. Maybe. Distributing what you compile? That's another story. It's not pretty.
Exactly.
Yea, but for some reason, clients seem reluctant to pay for my time to make wheels. Which is too bad, because I make them *super* round and with tons and tons of shiny spokes. :(
4 MB? That's huge!
I think it's comical how bent out of shape a couple of you either are, or are pretending to be, over a macro name that could very easily be changed on a target where it's unsupported. HE USED `$`?? TEH HORROR!! Nevermind groking all of the interesting bits of the project and its features. Great example if bikeshedding, guys.
Such issues show that you have absolutely no clue about what the C standard contains. It's a symptom for a much deeper underlying cause demonstrating that the project will not deliver the promise (of being based on C99). It shows that you are still in your “everything in the world is a Linux with gcc” bubble, which makes your project useless for everything outside this bubble if you don't get rid of that mindset.
You could search (for example) github for open source projects and try to understand their code base and maybe even simplify some code, or implement new features. There are thousands of projects out there searching for contributions!
I'm on a Mac and compiling with Clang 100% of the time. I think, in order for the project to be as useful as possible (convenient, feature-full, etc), there has to be compromise between "the standard" and "practical application." Obviously, I'm trying to stretch what can be done without new tools and runtime extensions. And so embracing non-standard, but widely-supported, compiler functionality is forgivable in my opinion.
Mac provides a very similar environment in this regard. But try compiling on Windows (Visual C is a bitch), Solaris (the Sun C compiler is nice but somewhat different from gcc), or one of the BSDs using pcc. Then you will see that not everything is a gcc. Also, try to compile for any of these fancy embedded platforms where the only compiler is vendor-supplied and shitty in all imaginable ways. There is a reason for the standard. And you are too ignorant to understand it.
/r/dailyprogrammer has a lot of good challenges. The newer ones have gotten progressively harder (even if they're supposed to be [easy]) so if you want to start simple go back a bit. 
You are in err because you fail to leave your bubble. Many devices, such as routers or televisions run a variant of BSD today. Many servers run Solaris or BSD. Many embedded devices run other operating systems. The largest part of desktop systems is still Windows based. You run a Mac OS X. Some of the largest commercial computing systems in the world are IBM System Z based and run AIX or a variant of it. Other commercial servers use HP-UX. All of these systems are different in smaller or bigger details but most of them have in common that they ship their own compiler which speaks a different dialect of C.
Looks very clean and well written. Not sure why there's so much hate for this. While I wish it was 100% standard C, that's not a big issue given what you're trying to do. However, I agree that everything in the headers should be standard C to make it usable everywhere (mainly changing the $ macros, maybe O or _ ?).
If you're at all interested in game programming, I maintain an open source video game that's built in C and runs on Mac, Windows and Linux, and I'm always looking for more help. https://github.com/jdolan/quake2world PM me or drop by #quetoo on Freenode to chat!
thanks for response ;p I changed it but it works fine anyways. I'm not sure I described my problem properly. This program above works good. The issue is when I remove theLoop() function. For better or worse you found out another mistake :D
Yess.. that's what I wanted to 'hear'. I had read about it before I posted here. So.. my question is: how does the function theLoop() prevent it and after execution the b assignment works good?
Well think it through: printf("Enter value a to calculate a+b:\n"); 5\n int a = getchar() - '0'; a = 5 \n is sitting there in the input stream void theLoop(void) //the loop which I don't understand { char c = getchar(); c = \n while (c != '\n' &amp;&amp; c != EOF) c is \n, so this line fails, skipping this line: c = getchar(); jumping here, and returning: } to here: printf("\nEnter b:\n"); 
So, you are basing your entire perception of the person on people who are primarily not software developers. I can understand this view. Personally I work in the ICT department of a large automotive OEM, and I can sadly say pretty much the exact same thing happens here. Physicists, Mathematicians and Mechanical engineers writing software so dense no light of understanding can escape it. It is depressing as there are relatively few good computer scientists around me. The behavior you are observing in Torvalds however, is actually indicative of the personality type, and not of the quality of code they produce, as I have often seen it come from both the competent and incompetent alike. 
Owww... I think I understand it right now. And now I see my program doesn't work like I want to. When I type e.g. 13 to 'a', 1 is assigned to 'a' and 3 is assigned to 'c' (isn't it?). getchar() takes the first number and the second sits inside getchar() (in program above it's \n). Do I think right?
It depends on what you mean by "software developers". The people I'm talking about spend their waking hours writing massive quantities of code. It is poor quality code, but by spending a huge amount of effort they typically manage to whip it into some sort of working shape. So yes, they are software developers _by occupation_. But their software development skills are self-taught to the point of "necessary minimum" and are riddled with misconceptions. They learned to get by on that minimum and they learned to compensate for their misconceptions with additional counter-misconceptions. Their code is easily recognized by frequent crude attempts to manually reimplement features that already exist in the language (they simply never knew that such features existed). The code they write most of the time is the epitome of the proverbial "program with even number of bugs". Trying to explain their misconceptions to them is usually met with a blank stare and a complete inability to understand anything. I.e. no, they are not software developers _by training_ and they are not really interested in becoming ones. Can such developers create software products? Yes, in that narrow area of their specialization. Can these people meaningfully speak on general software development topics, like programming languages or software design? No. Most of them don't even know what these are. 
Yes, it *get*s a *char*. Also keep in mind that the enter key is actually a character (or pair) that also is entered into the input stream when you hit the enter key.
Your code contains one major and immediately obvious error: it attempts to store the result of `getchar()` in a `char` variable. This is always wrong. The range of return values of `getchar()` function includes all "normal" `char` values plus an additional reserved value of `EOF`. The latter is not guaranteed to fit into `char` range. **For this reason, the return of `getchar()` has type `int` and must always be stored in a variable of type `int`.** Only after you made sure that the returned value is not `EOF`, you are allowed to treat the result as `char`. It might "work fine as is" on your specific platform, but still it is a serious error from the language point of view. Here's the corresponding C FAQ entry: http://c-faq.com/stdio/getcharc.html Another weird thing about your code is a sudden switch to `getc`. You are already using `getchar`, which by definition is equivalent to `getc(stdin)`. So why are you suddenly spelling it out as `getc(stdin)` later in the code is not clear to me. Other than that, the code looks fine. If you have problems with it, you have to describe them in more detail. "Assigns some odd things" is not a meaningful description of a problem.
Without getc(stdin) my program was closing immediately and I wanted to stop it, so I randomly found out the expression what just do this without adding extra libraries. These 'odd things' were quickly typed in edit... you're right naturally ;p
 #include &lt;stdlib.h&gt; #define SIZE 1024 static int (**hnew())[2] { return calloc(sizeof(int**), SIZE); } static void hdel(int (**e)[2]) { for (int i = 0; i &lt; SIZE; i++) free(e[i]); free(e); } static int (**hget(int (**t)[2], int k))[2] { for (int h = k &amp; (SIZE - 1); **t &amp;&amp; ***t != k; h = ((h + 1) &amp; (SIZE - 1)), t += h); return t; } static void hset(int (**t)[2], int k, int v) { for (int (**a)[2] = hget(t, k); !*a &amp;&amp; (*a=malloc(sizeof(**t))); (**a)[0]=k,(**a)[1]=v); } // TEST DRIVER #include &lt;stdio.h&gt; int main() { int (**table)[2] = hnew(); hset(table, 10, 20); hset(table, 20, 30); hset(table, 30, 40); int (**a)[2] = hget(table, 10); int (**b)[2] = hget(table, 20); int (**c)[2] = hget(table, 30); printf("%d:%d\n", (**a)[0], (**a)[1]); printf("%d:%d\n", (**b)[0], (**b)[1]); printf("%d:%d\n", (**c)[0], (**c)[1]); hdel(table); } 
C is one of those languages where having that kind if workflow is a terrible idea for your overall coding. You need to understand how things work before you hack together something that "works" and come here with a billion questions and no direction.
EOF usually is assignable to a char, because `EOF` is usually `-1`, and `char` is usually signed. However, in this situation it is indistinguishable from the char with value `-1` so this code would incorrectly "detect" EOF when in fact it was not the end of the file.
&gt;The cycle condition checks the value of **t, but this expression is illegal to evaluate if *t is null. The code is bugged as a result, because `hnew()` sets the table to contain null pointers, but then `**t` is executed. The code should read `*t`: this function is looking for a table entry which is either `NULL`, or contains the key we're searching for. (It will add a new entry, or update the existing entry, respectively). When there is no existing entry, `**t` causes undefined behaviour by dereferencing a null pointer, as you say. I checked the assembly generated by gcc 4.9.0 -O2 ; what happens is that it does the same test for `**t` as for `*t` so the code seems to work! This is permitted by the C standard because `**t` causes undefined behaviour, however I'd only be guessing at what rationale GCC uses in deciding to permit this, instead of generating a segmentation fault or even optimizing the test out entirely (which would also be legal because `**t`, having array type, can never decay to a null pointer). 
The situation is actually more interesting. The key moment here is the fact that a *pointer to an array* is involved here. Consider a simpler example int (*p)[2] = 0; if (p) { /* do something */ } if (*p) { /* do something */ } Formally, the second `if` produces undefined behavior, since, as you correctly noted, it attempts to dereference a null pointer. However, if you inspect the code generated by the compiler for these two `if`s, you will certainly discover that it is exactly the same in both cases. And the code will not crash. Why? Let's take a closer look at that `*p` expression. What exactly does `*p` stand for? Since `p` has type `int (*)[2]`, expression `*p` evaluates to a value of type `int [2]`. It is an array. This array is immediately subjected to the standard *array-to-pointer conversion* (what is also known as "array type decay" in C and C++). This conversion generates the pointer to the element [0] of the array. But (!) the memory location of the element [0] is exactly the same (has the same address) as the memory location of the entire array. For this reason, purely *numerically*, the value of `*p` is exactly the same as the value of `p` itself. The only difference between expression `p` and expression `*p` is the *types* of these expressions. The former has type `int (*)[2]`, the latter has type `int [2]` before decay and `int *` after decay. But address-wise these two expressions evaluate to exactly the same address. (Note that my statement about numerical equivalence of `p` and `*p` applies only to my example above, where `p` is defined as a *pointer to an array*. In general case there's no such equivalence.) The compiler understands that perfectly well. In the above `if` context the compiler does not care about the types of these expressions, it only cares about their *values*. And since the value is the same in either case, it generates the same code for both `if`s. This is *exactly* what happens in the original code as well. In the original code expressions `*t` and `**t` are equivalent from the numerical point of view. This is why this bug does not cause the code to crash. This error essentially "auto-corrects" itself in the generated code. And even though the code formally contains a null-pointer dereference, that dereference ends up being "harmless": it essentially disappears from the generated code. But nevertheless it is still a bug. And formally, as you said, this code performs a null-pointer dereference and triggers undefined behavior. This bug has to be fixed.
This code attempts to form an associative array: it'll store key-value pairs. The test suite stores the following data: * key 10, value 20 * key 20, value 30 * key 30, value 40 The code has some bugs which are not picked up by the test suite. If those are fixed, then it could store up to 1024 separate key-value pairs. It cannot store more than one value for the same key. The bugs are (credit to other posters for finding them, in some cases): * In `hnew`, `sizeof(int**)` should be `sizeof(int(*)[2])` * In `hget`, `**t` should be `*t` * In `hget`, `t += h` instead needs to wrap around instead of falling off the end of the array (and preferably also have a condition to abort instead of going into an infinite loop if the table is full) Notes: * `hset` does not overwrite an existing value if present (but you could do that easily enough), and * It won't work if `SIZE` is not a multiple of 2; this could be fixed by changing `k &amp; (SIZE-1)` to `k % SIZE`. 
My work was kind enough to pay me to make these wheels, you may use them on your car. https://github.com/Qata/Tungsten
Also, the compiler would be within its rights to optimize out the `**t` test entirely, as either it causes undefined behaviour or evaluates to true. It could even be considered an optimizer bug that this test still occurs at O3! 
Unfortunately, "usually" doesn't cut it. Also, the *char* type is supposed to hold a member of the basic execution character set. Those chars are always positive. This is from the C99 standard: &gt; If a member of the basic execution character set is stored in a char object, its value is guaranteed to be positive. That is, there will never be a negative char that is part of the basic execution character set. And be careful with claims like: &gt; char is usually signed I really don't think you have the data to back that up. C has idk how many decades of history and several implementations, for idk how many dozens of different CPU architectures. What we are used to today may not be what is true for 5 years in the future, imagine 10 or 20 years ahead. Do you really *know* that in all that has already happened with the C language, char is usually signed? Even today, there are several CPU's and compilers out there.
What my answer says is that EOF doesn't have to be assignable to a char. And, yes, as far as I know, it usually isn't, but *I may be wrong about that* - that is why it's inside a parenthesis, and also why it has an "as far as I know" before it. But it should be clear that this isn't what my answer is about. The important part is "EOF doesn't have to be assignable to a char". &gt; so if "usually" doesn't cut it then please amend your post! My answer doesn't depend on "usually". The side note inside a parenthesis isn't the real answer, it's just a side note. &gt; If EOF is -1, and char is signed, then EOF is assignable to a char; that's a fact. We could debate the semantics of "usual" but I don't think that would be a useful discussion. And how is that helpful? What about when EOF isn't -1 or char isn't signed? What is the point of that statement? What matters is that EOF doesn't have to be assignable to a char, so programmers shouldn't write code that depend on it. That's the point of the answer. &gt; getchar() is not limited to reading only the basic execution character set. Fair enough.
&gt;The side note inside a parenthesis isn't the real answer, it's just a side note. My post is commentary on the side note, it shouldn't be taken as a challenge to the main part of your answer.
Thank you so much. I couldn't figure out what was going on. Much appreciated!
The Microsoft C compiler also does not support C99, so if you really want to rail about standards, I'm not sure that you have a point here.
I don't see how it can make any difference here, considering that *none* of C standards support `$` character in identifiers. Are you implying that C99 or C11 are somehow more "friendly" towards `$`? If so, let's see a quote.
Nice, but you're still reliant on an Obj-C runtime being installed on your target. What environments / applications were in mind did you decided to build this? Believe me, if I could just write Objective-C and ship it for Mac, Windows and Linux easily, I would!
Nope. You fail. *Read the post title.* This project targets C99. MSVC doesn't support C99. Therefore, whether or not this project can be compiled with MSVC is irrelevant. At any rate, for probably the 5th time in this thread, I will state that the method invoker `$` could easily be renamed to e.g. `_call` and then aliased to `$` on targets that support it. And I'll likely do it in the near future to shut trolls like you up. Not that you'll use the project or contribute to it either way. Cool? Great.
That's exactly what I'm doing, the Objective-C runtime comes with GCC, so whenever I build a cross-compiler I just statically link against the libobjc-4.a file that is also created. At work I'm creating software in Objective-C that uses the library I linked and runs on Windows, OS X and Linux.
In addition to the `exp` error your code contains other rather "weird" areas. This condition if (firstEquation[b] == '0' || firstEquation[b] == '1' || firstEquation[b] == '2' || firstEquation[b] == '3' || firstEquation[b] == '4' || firstEquation[b] == '5' || firstEquation[b] == '6' || firstEquation[b] == '7' || firstEquation[b] == '8' || firstEquation[b] == '9' &amp;&amp; firstEquation[b] != '\n' &amp;&amp; firstEquation[b] != '\0') is internally redundant. The `&amp;&amp;` operator has higher priority than `||` operator, which means that the last term in this complex condition is firstEquation[b] == '9' &amp;&amp; firstEquation[b] != '\n' &amp;&amp; firstEquation[b] != '\0' It the first comparison `firstEquation[b] == '9'` is true, the following comparisons are automatically true as well and the entire term is true. If the first comparison is false, the entire term is automatically false. This means that `firstEquation[b] != '\n' &amp;&amp; firstEquation[b] != '\0'` comparisons serve no purpose whatsoever. They never affect the result of the term. They just clutter the code. Your entire conditional expression can be rewritten as briefly as if (firstEquation[b] &gt;= '0' &amp;&amp; firstEquation[b] &lt;= '9') or, even better, through a standard function `isdigit` if (isdigit(firstEquation[b])) 
Thanks a heap, it's really appreciated. Answers like this are priceless. 
http://lwn.net/Articles/249460/ 
In C language passing pointers to functions is used extensively for many different purposes. For one example, it is an idiomatic, widely used method of passing "heavy" objects to functions. When the pointer is used specifically within that idiom, there's nothing wrong or unusual in passing pointers to local objects. If fact, most of the time this is exactly what one will do. And by looking at the function signature alone you will never be able to determine whether the function might decide to grab that pointer and store it long-term. The only way to know that is to read the function's source code or to read function's specification in the docs. If some function can grab and store a pointer passed form outside, it is a very big deal. It should be stated in the specification and stated very very clearly and explicitly.
Because it is mandated by the C standard. Now, why is it mandated by the C standard? Because the C standard standardized behavior of existing compilers and most (if not all) allowed main to return an exit code. Why did most C compilers prior to standardization do this? Because most C compilers were derived from the initial C compiler, or based on the definitive book describing C, _The C Programming Language_ by Kernighan and Ritchie. Why did this compiler do this? Because Kernighan and Ritchie wanted a way to return the program status code back to the operating system they were developing at the same time, Unix (also written in C). This status is then available by the shell program to determine if the program succeeded or failed (in fact, programs that run other programs can also get the information). Now, if you are asking why those particular values? 0, 1, -1? That, you might have to ask Kernighan or Ritchie. One thought is that all you need is one success value, but many possible error conditions. 
C language officially supports two kinds of execution environments: *hosted* and *freestanding*. Hosted environment is what we a typically dealing with in "everyday" situations, i.e. a C program executed under an interactive OS. The OS is the host in this case. Function `main` (as the initial entry point of a C program) has its special status only in *hosted* environments. It is a widely accepted and de-facto standard convention that a program executed under an OS should return a *termination status* to the hosting OS. The `int` return type of function `main` is how this convention is reflected in C language specification for hosted environments: the value returned by `main` is passed back to the hosting OS as the program's termination status. There are no restrictions on the actual `int` values returned by `main`. Your decision on what to return will depend on your knowledge about how this value will be interpreted by the calling environment. C standard library offers you two manifest constants - `EXIT_SUCCESS` and `EXIT_FAILURE` (defined in `&lt;stdlib.h&gt;`) - that you can use to indicate successful or unsuccessful termination. The values of these constants are implementation-dependent (and you don't have to use them). It is de-facto accepted that the termination status of `0` indicates successful completion of the program, but again you don't have to follow that convention. And for some programs the termination status might have a completely different semantics. (For example, you can write a program whose termination status will represent the current CPU temperature, with 0 value having no special meaning.) In other words, once again, you have the complete freedom to decide what to return from `main`. It is entirely dependent on your program's intended semantics. If the termination status of your program does not carry any special meaning, just use `EXIT_SUCCESS` and `EXIT_FAILURE` constants or simply return `0`. Note, BTW, that starting from C99 you don't have to write an explicit `return` statement in `main`. Just letting the control to flow off the end of `main` function is equivalent to returning `0` from `main`.
revelant: crt0.s from unix v5 (1974) and unix v6 (1975) http://minnie.tuhs.org/cgi-bin/utree.pl?file1=V5/usr/source/s4/crt0.s&amp;file2=V6/usr/source/s4/crt0.s&amp;side=Side+Scroll&amp;print=1 
&gt; If some function can grab and store a function passed form outside, it is a very big deal. It should be stated in the specification and stated very very clearly and explicitly. I think that's the big thing to note. The 'default' is that a function will never store a pointer that it received somewhere other then what you're providing to it - For the very reason you outlined. It has no way of knowing how long that pointer will be valid or how to free that memory when it's done. If a function is going to store that pointer somewhere else it'll explicitly tell you, and tell you how long the pointer has to be valid for (Or if it should be malloced or etc.)
Did you just promote yourself to being my "teacher?" That's precious. Rereading this thread, from where you claimed that Linus Torvalds is a below-average programmer onward, nearly everything you said has been universally rejected by the community (down-voted). You're a windbag, an egotist, and you're contrary for the sake of being contrary. Feel free to poll the people you interact with on a daily basis for confirmation, but by any popular definition, you are an asshole. Congratulations!
My understanding is that the Objective-C runtime that comes with GCC is _really_ old and not very useful. Doesn't GNUStep, for example, provide its own?
While it is true that type `void` did not exist in the nascent versions of C, it appeared in the language well before ANSI C. It was already used by some dialects as early as in 1979. By 1988 (the second edition of K&amp;R) it was used universally.
True. I was talking about very ancient versions of C in my comment.
I see that you are out of arguments, so you have to resort to ad-hominem attacks. The original points still stand though; you refuse to accept that C99 is only a subset of the language gcc understands. Either fix your issues or stop claiming your project is C99 based (spoiler: it isn't).
While the ability to specify the field width is indeed a very useful feature of `printf` function, it is often overlooked that `printf` also offers a convenient mechanism for using *run-time* values in `printf` format: the `*` specifier. For example, instead of embedding the field widths directly into the format string, you can do int w1 = 7; int w2 = 11; int w3 = 10; printf("%*d%*d%*d\n", w1, 100, w2, 1221, w3, 9348); This can be very useful when field widths are determined at run time. Without this feature, in order to use run-time field widths one'd have to do something like char format[256]; sprintf(format, "%%%dd%%%dd%%%dd\n", w1, w2, w3); printf(format, 100, 1221, 9348); which requires an extra buffer, prevents compiler-level format validation, and is much harder to read. P.S. It is unfortunate that such capability does not exist in `scanf`.
I would make the default the other way round.... It's unsafe unless explicitly documented as part of the API as safe. As is, someone could reimplement/refactor timer_create() and silently break a smallish subset of code... and it probably would be very hard to find by test. Actually, I'd invoke Postel's Law "Be conservative in what you do, be liberal in what you accept from others."
I wouldn't mind more explicit documentation, but it doesn't make sense to have anything else be the default assumption. In general you should *never* be storing random pointers passed as function arguments into some global data, that's a horrible design pattern and it's *going* to break code. The only case that it's acceptable is if you explicitly tell the user and tell them what to expect (IE. How long the pointer has to be valid, or if the library would take care of calling free() on it so it has to be malloc()ed, etc..). Without such an explicit statement, the code would be broken for the only reason that it's impossible to know what to do with this data. I have no doubt that any implementation of timer_create() that does what you're suggesting without documenting it would be considered completely broken - it wouldn't break a smallish subset, it would break basically every piece of code using it, because timer_create() never tell you how long that pointer has to be valid for. Thus, even code that's more 'conservative' and mallocs the sigevent would still break once it free's the sigevent. And the only solution to make sure your code doesn't break is to introduce a memory leak and not ever free the instance. IMO, that sounds like a pretty broken timer_create() implementation if it basically forces you to introduce a memory leak.
I have seen api's that held on to memory for the lifetime of the timer. (Actually that was a very broken API... not because it created leaks, but because the "life time" was very hard to define... as timer expiries could be "in flight" at the instance the timer was being destroyed and the resources freed!)
&gt; I have seen api's that held on to memory for the lifetime of the timer. If it was going to do that though, that would have to be documented. Without it being documented you don't have any way of knowing how long to keep the pointer valid. IE. If we're going to assume it may hold on to it for the lifetime of the timer, then there's no reason we can't assume it won't just hold onto it forever. Thus you can never have valid conforming code that frees that memory. Don't get me wrong, I wouldn't mind a bit more of a guarantee, but as it is I think it's more then fine to assume the pointer won't be stored.
Here's a good answer on stackoverflow: http://stackoverflow.com/a/5797186 **tl;dr**: floorf( num ) == num
Something like: #include &lt;math.h&gt; #include &lt;float.h&gt; double d = 1.234d; d = fabs(d); /* Sneaky fuckers passing negative numbers! */ if( (d - floor(d)) &gt; DBL_EPSILON) { // fractional part does exist } If you have a float instead of a double, cast it to double before doing the above. WARNING: I have not compiled this code, so compile it and see if it works.
Thanks. That worked! Funny thing, I saw that link but didn't see that solution. 
This is so you can tell the operating system if your program exited successfully or with an error. '0' is generally interpreted as a successful exit; other numbers can correspond to various errors.
oh... nifty... I need to remember that.
[Bjarne Stroustrup: Why you should avoid Linked Lists ](https://www.youtube.com/watch?v=YQs6IC-vgmo) [Are lists evil?—Bjarne Stroustrup](http://isocpp.org/blog/2014/06/stroustrup-lists)
Every point he makes applies to C, if not more so. (For example STL data structures will often use fixed sized allocators, _much_ more efficient than malloc/free (yes, I have benchmarked it).
Really dude? "Many servers" run Solaris? Ah yes, and the IBM mainframes.. just how many of those AIX boxes are having new software packages installed on them regularly? Get real.
&gt; P.S. It is unfortunate that such capability does not exist in scanf. No kidding. The \* is used to suppress assignment, which is very useful by itself, but specifying the width with an argument would have been nice. It's not just a problem at runtime, either. Consider: char str[9]; scanf("%8s", str); I want to put the buffer length in some sort of constant, so I can change it easier later. I have to store this in a macro, and then use fancy preprocessor magic to make it work: #define STR(x) #x #define XSTR(x) STR(x) #define MAX 8 char str[MAX+1]; scanf("%" XSTR(MAX) "s", str); Well, it's that or use `sprintf` to create the format string, as you did. Neither is a great solution to the problem.
 while (cont != 'y' || cont != 'Y' &amp;&amp; cont != 'N' || cont != 'n') { cont = '/0'; printf("Invailid option. Run Again? (Y/N):"); scanf(" %c", &amp;cont); } This is where the error in the code is located I think
&gt; while (cont != 'y' || cont != 'Y' &amp;&amp; cont != 'N' || cont != 'n') Look very carefully at that condition. Is that really the condition you want? Keep in mind that `cont != 'y' || cont != 'n'` will **always** be true. No matter what value `cont` has, it will always be true that it is different from&amp;nbsp;`'y'` or different from&amp;nbsp;`'n'` (or both).
What I want is it to be an error catcher for anything other than those two/four letters. I know the current set up there is wrong just not sure of the how
Solved it, made them all &amp;&amp; Thanks for the perspective!
Think about what that code actually says. You need to think carefully about the logic there. Choose a value for `cont` and think carefully about whether that value would make the condition true or false. Try it again with another value. Think about what is going on.
In addition to what is already posted, keep in mind that `&amp;&amp;` has higher precedence than `||`. Your condition is actually seen by the compiler as cont != 'y' || (cont != 'Y' &amp;&amp; cont != 'N') || cont != 'n' which does not make much sense. It is easy to remember that `&amp;&amp;` has higher precedence. Nevertheless, when you mix `&amp;&amp;` and `||` in one logical expression, it is a good idea to always use `()` to express your intent explicitly.
another good point. luckily this problem isnt so complex where this would be an issue. while (cont != 'y' &amp;&amp; cont != 'Y' &amp;&amp; cont != 'N' &amp;&amp; cont != 'n') ended up being the condition needed to get it working properly. Thanks again for the help!
Do read through all the answers, as rounding errors is an important concern and I would not expect the top answer to be reliable in practice. 
Many times the "accepted solution" is not the best one
swap what?
swap the the value zero to right ... if button left is pressed . and swap the value zero to left ... if the button right is pressed .. and so on for up and down arrows . pls see the image .. and compile the program and run once .. thanx in advance
Like those sliding tile puzzles? I'm in bed right now, but I promise to have a look tomorrow.
yes... that sliding tile puzzles .. thank you wish you good night ... tk cr .. and this is my rectified one ... its sliding now ... but making all the number zero .... link below &gt;&gt; https://pastee.org/f2p7s
No, it doesn't. The runtime itself is still GCC, GNUStep just provides core libraries that have never been provided by the system as a default. It's an Objective-C STL, which is what my github project was able to replace for very simple objects (so far). Foundation itself is also just Apple's version of an Objective-C STL. The only things that Objective-C actually implements itself is NXConstantString and Object.
The line temp = s_board[blank-&gt;x][blank-&gt;y]; is missing for case UP.
yes .. i noticed that.. but for LEFT i used ++blank.x .. so why is it moving in down direction
Very cool.
Did you mean: cont='\0'; // Set cont to NULL character Because cont='/0'; Does not set it to NULL. 
Number % 1
The `temp` buffer is only 10 characters long but "lorryCapacity" is 14 characters long. Even worse, this isn't guaranteed to crash! On my machine, this runs fine and produces the expected output. You have a couple of options: * Increase the size of `temp`. This isn't really a fix, as anyone can edit the config file and put an arbitrarily-sized value. * Use `fgets` in combination with `sscanf` to guarantee that you don't overflow the input buffer. * Use the "`%*s`" specifier to discard the string parameter, since you're not actually using it. Probably not a real-world solution. * Use "`%as`" (or "`%ms`", depending on your C library) to dynamically allocate a buffer. Don't forget to `free` it! Hope this helps.
I think in earlier C versions function pointers had to be explicitly referenced.
I don't make use of the latter, but I would imagine that the reason you can do so is for standards compliance. 
In addition to the excellent answer by BoatMontmorency, it's also allowed because syntactically `typedef` is treated like a storage-class specifier (alongside `extern`, `static`, `auto`, and `register`) which you can add to any normal declaration to change it into the definition of a type alias: int foo; // foo is a variable of type "int" typedef int foo; // foo is an alias for the type "int" char bar[12]; // bar is a variable of type "char [12]" typedef char bar[12]; // bar is an alias for the type "char [12]" int (*baz)(int); // baz is a variable of type "pointer to function taking int and returning int" typedef int (*baz)(int); // baz is an alias for the type "pointer to function taking int and returning int" Given that, it would be incongruous and would require some kind of special-case rule if you couldn't also write: int quux(int); // quux is a variable of type "function taking int and returning int" typedef int quux(int); // quux is an alias for the type "function taking int and returning int" On a side note, the fact that `typedef` acts like a storage-class specifier for the purposes of the grammar means that it's valid anywhere that a storage-class specifier can go, not just as the first token, e.g. struct { int x; } typedef foo; int const typedef volatile bar; There's no reason that I can think of to ever write things like that, however. 
As it has already been noted, your `temp` buffer is not large enough to store the string that you attempt to read. This is the reason for the crash. Additionally (albeit it is not an error), it is strange to see those `\n` characters at the end of each `fscanf` format string. Why did you put them there? Note that when you use any whitespace character in `fscanf` format string (space, `\n`, `\t` etc.) it is interpreted by `fscanf` in a special way: as a request to "skip all whitespace" before processing the next format specifier. Format specifiers that you used so far (`%s`, `%f`, `%u`) are already designed to automatically skip all leading whitespace, which means that your `\n` in `fscanf` achieves absolutely nothing. The same can be said about that space you have in the middle of your `fscanf` format string. Typically `fscanf` format strings for your code would look as follows fscanf(file, "%s%f", temp, &amp;LorryCapacity); Note: no space, no `\n` in format string. I guess you simply wanted your `fscanf` to look similar to your `printf`, which is why you included that space and that `\n`... This is not an error in your case, but it can easily become one in some other context. Remember that `*scanf` functions treat their format strings differently from `*printf` functions. And generally one normally doesn't use whitespace in `fscanf` format string unless one really has to.
From the language standpoint there's nothing ingenious there. The only truly obfuscatory technique used there is that beaten-to-death "`array[i]` is equivalent to `i[array]`" trick. The rest is just collapsing the entire code into a one-liner. If we unwrap and unobfuscate it, we'll get int main(int riguing, char**acters) { int i = *(int*) acters[1]; i %= 4796; i %= 275; i %= riguing; i = !i; i = ~i; puts(acters[1 - i]); } 1. It re-interprets the first 4 bytes of the first program argument (the "person's name") as an `int` value `i` (assuming `int` is 4 bytes). 2. It "hashes" that `i` by taking the remainders from sequential divisions by 4795, 275 and `riguing`. The latter is the program's argcount, which is 4 for all examples given at the link. This means that in those examples you end up with 0, 1, 2 or 3 in `i`. 3. Then it does `i = !i`, which converts 1, 2 and 3 to 0, and converts 0 to 1. 4. Then it does `i = ~i`, which converts 0 to -1, and converts 1 to -2 (on a 2's-complement platform). 5. Finally it prints either `acters[2]` or `acters[3]`, depending on the final value of `i`. Given the above we can further "unobfuscate" the code as int main(int, char**acters) { int i = *(int*) acters[1]; i %= 4796; i %= 275; i %= 4; puts(acters[i == 0 ? 3 : 2]); } Some conclusions you can draw from this include 1. Only the first 4 characters of the first argument matter. E.g. changing "obama" to "obame" will not affect the result. 2. The ordering of the 2nd and 3rd argument matters. If you swap "republican" and "democrat" in the "obama" example, the program will report "republican". 3. Number of program arguments matters. Adding a dummy argument can easily make the program to change its answer. The question I can't immediately answer is whether there's a clear mathematical rationale behind 4796, 275, 4 sequence.
Haven't figured it out 100%, but it looks like it's just playing some clever math tricks. If you deobfuscate it some, it's taking `argv[1]` (the name of the president), turning that into an `int *`, dereferencing it (I think that's the correct order), and then doing some math on that value. The resulting value is then inverted (yielding either 0 or 1), bitwise negated (yielding either -1 or -2), and subtracted from 1 (yielding either 2 or 3), then used to index `argv`. So it ends up printing out either `argv[2]` or `argv[3]` depending on what you enter as the first argument. Note in the author's description, it specifically only works for the last 31 US presidents. So I'm guessing to construct it, he looked at the affiliations of the last 31 presidents as a binary table (false for one, true for the other) and came up with a clever formula using a couple of modulus operations that happens to give the correct answer. The last modulus operation uses `argc`, which will always be 4 if you call it with 3 arguments. There's probably some mathematical reason why that's clever, but I don't really know it. It's tied to the string representation of the president's name; I think what ends up happening is that the characters in the name specified in the argument are reinterpreted as an integer value. So I bet if you change the capitalization of the name on the command line, it might give an incorrect result. If the name is at least 4 or 8 characters (not sure if this program works equally well on 32-bit and 64-bit machines), the rest of the characters should theoretically not matter; you could add extra characters to the name without affecting the result.
Compiled it. It works. (At least for 1.234.) li799-149:~/tmp&gt; gcc --version gcc (Debian 4.7.2-5) 4.7.2 Copyright (C) 2012 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. li799-149:~/tmp&gt; cat f.c #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;float.h&gt; int main(int argc, char **argv) { double d = 1.234; d = fabs(d); /* Sneaky fuckers passing negative numbers! */ if( (d - floor(d)) &gt; DBL_EPSILON) { printf("Fractional part of %f exists.\n", d); } return(0); } li799-149:~/tmp&gt; gcc -Wall -Wextra -pedantic -lm f.c -o f f.c: In function ‘main’: f.c:6:14: warning: unused parameter ‘argc’ [-Wunused-parameter] f.c:6:27: warning: unused parameter ‘argv’ [-Wunused-parameter] li799-149:~/tmp&gt; li799-149:~/tmp&gt; ./f Fractional part of 1.234000 exists. li799-149:~/tmp&gt; 
&gt; Only the first 4 characters of the first argument matter. ~~Only the first 12 bits i %= 4796 same as i &amp;= 0b111111111111~~
Um... Not true. `4796` is `0b1001010111100`. It is not a power of 2. `i %= 4096` would be same as `i &amp;= 0b111111111111`. 
`someType foo;` isn't an error. It's a function declaration. You can conveniently declare many functions with the same prototype this way. Also, many programmers prefer to avoid pointer typedefs as the code is more readable when it's clear that the thing being worked with is a pointer. 
I'd recommend learning how to do this in matlab or R if it's something you'll be doing more than once, the loss in performance will definitely be worth the ease
thanks for the int but I really wanna do that in C. 
It's a function declaration if it's at global scope, but it's an error to try to declare it as a member of a struct or (I think) inside a block. (I wasn't specific enough in my description.)
 char* dayName[6]; dayName[0] = "Monday"; dayName[1] = "Tuesday"; dayName[2] = "Wednesday"; dayName[3] = "Thursday"; dayName[4] = "Friday"; dayName[5] = "Saturday"; dayName[6] = "Sunday"; You've set the size of the dayName array to be 6, but you're putting 7 elements into it. The highest index in your array of size 6 is dayName[5] Also, objects aren't really a part of the standard C language. If you meant C++ then you might be better off going to /r/cpp_questions since this subreddit is primarily for C
It is indeed possible, but pretty redundant and quite cumbersome when you have C++, which is pretty much just C with Classes. There are things in C called [structs](http://en.wikipedia.org/wiki/Struct_%28C_programming_language%29), which are like really really basic objects, in that they can hold different types of data, pointers, function pointers etc. but they're [not objects](http://programmers.stackexchange.com/questions/113533/why-is-c-not-considered-an-object-oriented-language). Is there a specific problem you need to do that require objects in C or are you just curious about it?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Struct (C programming language)**](https://en.wikipedia.org/wiki/Struct%20%28C%20programming%20language%29): [](#sfw) --- &gt;A __struct__ in the [C programming language](https://en.wikipedia.org/wiki/C_programming_language) (and many derivatives) is a complex [data type](https://en.wikipedia.org/wiki/Data_type) declaration that defines a physically grouped list of variables to be placed under one name in a block of memory, allowing the different variables to be accessed via a single [pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming\)), or the struct declared name which returns the same address. The struct can contain many other complex and simple data types in an association, so is a natural organizing type for records like the mixed data types in lists of directory entries reading a hard drive (file length, name, extension, physical (cylinder, disk, head indexes) address, etc.), or other mixed record type (patient names, address, telephone... insurance codes, balance, etc.). &gt; --- ^Interesting: [^Composite ^data ^type](https://en.wikipedia.org/wiki/Composite_data_type) ^| [^Record ^\(computer ^science)](https://en.wikipedia.org/wiki/Record_\(computer_science\)) ^| [^C ^Sharp ^\(programming ^language)](https://en.wikipedia.org/wiki/C_Sharp_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmxy2oc) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmxy2oc)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Oh, I just need to provide an example of what an object would look like in C and explain it. Basically compare it to objects in java aswell
Strictly speaking, in formal terminology of C and C++ languages, the term *object* has a reserved and very specific meaning. &gt; **3.14** &gt; **object** &gt; &gt; region of data storage in the execution environment, the contents of which can represent values It has nothing to do with classes or structs, and it has nothing to do with object-oriented programming. By definition, _object_ is simply a region of storage (of memory). Every variable is an _object_. When you define `int i = 42;` in C language, that `i` is a basic example of an _object_. In C language the term *object* means the same thing as the term *lvalue*. It is true that OOP concept of an *object* is completely different from what that term means in C and C++, but that's just how things are. So, the question is: what kind of "object" was that teacher talking about?
Might be difficult to get something that is cross-platform and does 3D graphing all in one C source and header... At first google I would say that [Plplot](http://plplot.sourceforge.net/examples.php) seems like a pretty good place to start. I compiled a few of their sample apps and got them working (3D and 2D). I'm under Ubuntu 14.04 and used apt to get plplot, which included libplplot-dev so you can compile. I did have to find a header file for the demos and edit them a little to match my paths. And I had to use pkg-config to get the right flags when compiling. Other than that it wasn't too difficult. I'm sure there is a demo folder somewhere either in the source or with the dev files. I just don't know where they are. It would be nice to see some make or Cmake examples as well. I skimmed the documentation, but I'm sure it's buried in there somewhere on how to properly do it. EDIT: I mentioned cross-platform only because I wasn't sure what your system was. :P
It's always a function declaration; declaring a name via a typedef is always identical to declaring the name without the typedef, if the latter is legal. (Typedef'd identifiers become part of the grammar for future parsing of declarations). Function declarations are permitted at block scope, but you're right that they are not permitted as structure members in C. (It is permitted in C++ of course). 
A couple of major problems: 1. `dayName` should have 7 elements, not 6. Giving it a size of 6 means the maximum index is `5`, yet you assign to `dayName[6]`. 2. `day` is an array of pointers, but those pointers don't actually point anywhere. `scanf` expects you to provide a pointer to a valid `int` object. Instead, you should really just make `day` an array of `int`s, not `int*`s. Then, when you call `scanf`, do it like this: `scanf("%d", &amp;day[i])`. I'm not really sure what the other people are saying about objects. Both C and C++ have objects. Both languages are pretty much entirely about manipulating objects. When you declare `int x;`, for example, you are creating an object of type `int`. However, it's true that C doesn't support object-oriented programming . Object-oriented doesn't mean "has objects". It generally means that it supports abstract data types, encapsulation, inheritance, and polymorphism as language features (although this is still debated a lot). C doesn't have these features (but it can be mimicked), whereas C++ and Java do. If you want to make an object in C that represents a classroom and has some attributes, then you need to look at `struct`s. A `struct` in C gives you a way of grouping data together such that you can create many instances of that data. In C++ we have class types which also group data together, but provide extra features from the object-oriented paradigm and other C++ language features. C++'s classes are closely related in idea to Java's classes, but they're certainly not the same.
&gt;Im a C beginner Im working with visual 2013 on win8 I just loved that class I had and I looking to get more into it. I`m really looking into Linux but just not yet as I will have a class on it.. For now I would just like to be able too see live simulation (data) on a 3d chart or more than one...so if you have any source of online class that you like please tell me about it. 
&gt;Im a C beginner Im working with visual 2013 on win8 I just loved that class I had and I looking to get more into it. I`m really looking into Linux but just not yet as I will have a class on it.. For now I would just like to be able too see live simulation (data) on a 3d chart or more than one...so if you have any source of online class that you like please tell me about it. 
I'm not familiar enough with Windows or Visual Studio to really help you there. I know VS has some utilities to help you create GUIs, such as [Forms](http://msdn.microsoft.com/en-us/library/ms229601\(v=vs.110\).aspx). Forms probably has what you need in order to create a window and display your data. Or you can cheat and just call another program from within your C program that can display the data for you. Or yet just have your C program continuously write to a file and then have another program that just reads the file and displays it on a regular interval. There are countless ways... Now there are most definitely libraries that can do all of the things you mentioned, but the real trick is bringing the right libraries together and knowing how to build and link them properly under VS. Personally, I prefer learning how to use the compiler and Make to build my projects without an IDE like VS or what have you. Even if you won't end up doing it like that in the future you do learn more about what's really going and why it's complicated.
I base it on my personal experience with various company's "coding standards", as well on what I saw in such discussions as http://stackoverflow.com/questions/3781932/is-typedefing-a-pointer-type-considered-bad-practice http://stackoverflow.com/questions/750178/is-it-a-good-idea-to-typedef-pointers There's why I informally refer to it as a "popular guideline".
This is great information Sir thanks a lot!
I was considering using a typedef like this to ensure a function and a proxy function in another library had the same signature. I've also seen code on Stack Overflow that used "extern typeof(malloc) __libc_malloc;" to import a version of malloc usable in a wrapper. (typeof and __libc_malloc being GNU extensions) 
It's also the opinion of the Linux kernel maintainers, there's rationale in the link but I'm only going to quote the inflammatory part: |It's a _mistake_ to use typedef for structures and pointers. https://www.kernel.org/doc/Documentation/CodingStyle
Really good article indeed, it express beautifully why everyone should considering starting by learning C. You get a better insight on how things work when you had to do everything from scratch before.
Stick to standards. C (89, thanks to needing Windows support unless you want to require a different compiler than MS's), POSIX, etc. Avoid any OS specific syscalls or libraries.
Okay, didn't know I can do that...Do you have any idea why is not working?
Graph is formatted. It's NxN. This program works if I define filenames like this #define graph_file "graph.txt" this works perfectly. But my task is to do it this way..
Look, argv holds the parameters you pass to the command line. argv[1] holds the first parameter, but the lines 130-133 take *argv* only as an argument. So you need to pass *argv* only. Please try that and write back.
Thank you guys!
&gt; #define graph_file "graph.txt" graph_file is a FILE*. I don't see how that should work.
Use C89 and put unportable code (if any) between bunch of preprocessor directives. If it is not enough (I mean, if you can not determine platform by predefined preprocessor macro), explicitly specify such macro in Makefile. I'm pretty sure that crossplatformness is just when all portability issues are hidden. I also recommend to try and stick to both POSIX and Win32 API if possible: using POSIX is already a big step to crossplatform code.
I know this question gets asked to death in /r/learnprogramming but where is a good place to start learning C if it is your first programming language? I have K&amp;R but it is too complex for me as a total beginner to fully process. 
If you have to write platform specific code then try to make the headers portable and have the code files be platform specific. That way you simply include the file specific to the platform you want and ignore the rest. It really helps for readability and makes finding platform specific bugs or implementing platform specific workarounds really easy. [Edit] Example being.. let's say I want to make a window on the platform. I would have a platform_window.h file, and then winnt_window.c, linux_window.c, osx_window.c, etc.. For windows builds, you would only use winnt_window.c in your project, while on linux you would use only linux_window.c instead. It lets you isolate the platform specific code without any special preprocessor junk.
I think the best way is to dive right in. I have seen a lot of books starting to show pointers and memory usage until the last chapters and I think it is a mistake, you can not properly learn C without all of its tools. That being said, I would be happy to send you the exercises I did to learn C if you can PM me your email.
An 8-bit assembly language is obviously the best first language. How are you going to get anywhere in life if you are coddled along by a cushy C compiler? Why back in my day I learned to program in 6502 machine code and I liked it! &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ^^While ^^this ^^is ^^truly ^^the ^^way ^^I ^^learned ^^to ^^program, ^^I'm ^^not ^^really ^^advocating ^^that ^^everyone ^^do ^^the ^^same. ^^I'm ^^just ^^being ^^a ^^cranky ^^old ^^man ^^for, ^^hopefully, ^^humorous ^^effect.
The guy who made learn Python the hard way also has a version on C. It's not as polished as the Python course but it touches on all the basics and give you a great intuitive understanding of what you are doing in each lesson. I did learn C at my university in courses that were specifically designed to understand what the code is doing, like what this author explains in this essay. We started with Java and Python then C# and then C++ and finally C with some Assembly thrown in for fun . At the end looking back I felt like it would have been much more intuitive and fun to start with C and then move up from there, exploring and figuring out the reasons for the advances in the languages. Anyway, learn C the hard way is a great way to get started. It also throws in loops and while statement and other things for beginners that never coded before. Good luck and have fun!
Frankly there is no need to create code for ALL platforms, since POSIX already guarantees some portability. You'll need posix_code.h, winnt_code.h, other1_code.h, other2_code, otherN_code.h though (other_code.h means neither POSIX nor WinNt compatible platform).
For the build system, have you looked into CMake? That or something similar is probably what you want, because otherwise you end up with different build systems for different platforms (Makefiles for Linux, Visual Studio projects for Windows, etc.), and maintenance becomes a headache because every time you change something, you have to change it in multiple projects in multiple ways. (This is what I have to deal with at my company, and it sucks.) Configurations determined at run-time for binary compatibility? My first thought is, why do you need that? The main use of that I can think of is if you're shipping a single library that targets multiple chipsets (like a fat binary on OS X, iOS, or Android) or multiple optimizations (like optional MMX and SSE in media libraries). Otherwise, most run-time decision making is just flags or options that are part of your library; to me that's just code. I guess it's not much more than a semantic difference, but maybe there's something I'm not really understanding. For configuration management, some kind of config header file is the norm. The user is expected to provide a header file with a known name which your library's headers include, and that sets various #defines to indicate what features to enable, what settings to use, etc. Software that's built with Autotools usually just calls this "config.h", but you can really just come up with any consistent way of handling that fits your needs.
[Programming from the Ground Up](http://savannah.nongnu.org/projects/pgubook/): "[a free] introductory book to programming and computer science using assembly language."
Good to know that someone else thinks assembly is a good starting point. I doubt they do it without an assembler like I did though. :-)
In general your program will crash and the rest of the system will be fine. There are ways to take the whole thing down by accident though.
&gt; I have K&amp;R but it is too complex for me as a total beginner to fully process. Don't feel bad about this. The best description of K&amp;R I've read (probably here in /r/c_programming) was that it should be read to learn the C language, not how to program. So, if you don't already know how to program, don't dismay about getting stuck with K&amp;R. Where are you getting stuck? I recommend doing all the exercises in a chapter before continuing on to the next, and only using concepts introduced up to that point for the solutions. Feel free to ask questions here, in /r/c_programming, and articulating them in such a way that people don't get the wrong impression (that you're trying to get us to do your homework for you) and down-vote for no good reason. Chapter 1 of K&amp;R is a good starting point. If you complete all the exercises therein you'll be well off for the rest of the book. Start there, and ask here when you get stuck -- e.g., getting a build &amp; debug environment set up. Oh, and use a debugger. Don't use that printf approach. This is particularly true for the last five exercises (ex1-20 through 24). I recommend gdb: * [Using The GNU GDB Debugger](http://rsquared.sdf.org/gdb/) * A quick [overview](http://reverseengineering.stackexchange.com/a/1936) of gdb on stackexchange for use in reverse engineering.
I wouldn't worry about it. The only times I can remember crashing windows has been when I screwed up doing system stuff, so basically I was in the middle of some complicated interaction and then did something dumb. Just playing around with simple programs you would have a very hard time doing anything outside your protected memory section. 
&gt; I'm just scared to learn something with one compiler that wont work elsewhere. This is why you learn standard&amp;nbsp;C. Any good book or course about&amp;nbsp;C should be teaching standard&amp;nbsp;C. Standard&amp;nbsp;C is guaranteed to work the same way with any conforming compiler (within the limits of what is guaranteed by the C&amp;nbsp;standard). &gt; also, which compiler should I use? whats most popular/cross platform? Clang and GCC are both good compilers.
There are a few C compilers. Clang and GCC are popular. Clang's error messages are easier to read and understand. (And have colour). Most C compilers have some extensions that are not always compatible with other compilers. If you're just learning C don't use extensions and you will be fine. ICC is Intel's C/C++ compiler for x86, it produces very fast binaries but it cost money and is slow on AMD cpus. Microsoft's compiler is a C++ first and foremost. But it will compile C code, however there is a lot of C code that compiles in GCC that won't compile in MSVC (If you really want to compile on both GCC and MSVC use the `-std=c89` or `-ansi` flags) There is a GCC for windows (Mingw), which comes with CodeBlocks and Eclipse CDT. GCC/Clang are probably your best bet. (There are other C compilers, but they are normally for specific purposes, like embedded systems)
CS50, at least, teaches standard c99.
Cool. So mingw is a c compiler for windows. any other popular C compilers for windows besides the compiler that is "c++ first and foremost"?
Yes.
Good point of the string usage. But, the instructor does say that this is just to keep it simple for now and to provide an easier step of from "scratch" to C. Which makes sense... because all of the scratch examples look really close to C code. If they taught us without being able to use string I feel like a lot of people would be confused. But I appreciate the heads up.
&gt; My first thought is, why do you need that? So that we can run the same binary on multiple products, within the same OS / platform. My biggest configuration problem is that of the products. I have 50+ products to support (and more every week) each with their own hardware and settings. These can be complicated structures, such as "this struct member is only relevent when this GPIO pin is high" kind of thing. Managing and testing that is pretty hard.
Unfortunately, just sticking to standards isn't enough. Microsoft's C compiler refuses to move beyond C90, so you have to be very selective about which C99 and C11 features you use (some are available, specifically those used by C++, but many are not). Fortunately, there are other compilers available for Windows that just MSVC, so you're not SOL if you do want modern C features.
I heard the rationale: if you don't call it then it doesn't have to be linked in, saving space in your executable. Assuming of course that you are using `printf` for other things already. Not sure if this is actually true or not, I have seen gcc optimize `printf("%s\n", s)` to `puts(s);` for example.
Does char *x = "abc"; technically declare an array of type char * because of the relationship char arrays and pointers? Should I just use char x = "abc"; and pass x into a function as just x because x technically is &amp;x[0]? I've always had problems with that for some reason
nice. thanks
For all practical means and purposes: yes. The second edition of the book describes standard ANSI C. From the very formal and pedantic point of view: no, not really. K&amp;R book went through two editions. The first edition was published in 1978, the second in 1988. C language became standardized later, in 1989. It is true that the second edition was synchronized with the upcoming standard, but it was still based on a draft version of it. There are differences between the second edition of K&amp;R and standard C, but they are very minor. Some very minor differences exist even in later prints of the second edition, which were supposedly brought up-to-date. It is also worth noting that C standard was updated in 1995. The update focused on library features dedicated to wide-character support. The revision is formally called C95, but almost no one calls it that. It is very common to retrospectively consider these changes as part of C89/90 standard. K&amp;R book does not cover this subject even in later prints.
There are quite a few problems there. * Firstly, the incompatible pointer types in passing function arguments. What is that `&amp; ` operator doing there? To formally correct the error the call should look as follows xor(in, out, key); Note: no `&amp;` operator. * Secondly, even after the above update your code is still broken. The code attempts to modify string literal pointed by `out` pointer. String literals are non-modifiable. They generally reside in read-only memory. Any attempts to write anything to read-only memory will trigger a segfault. Your `in` and `key` strings are OK as string literals, but the `out` buffer must be modifiable. This is what your declarations should look like char *in = "test"; char *key = "abcd"; char out[20]; `20` is just an off-the-wall number for a buffer that should be "big enough" for the result. You can use a smaller number in your case. There's not much point in initializing the `out` array (since you will overwrite it anyway), but your can do it if you want to. * Thirdly, your cycle's continuation condition is broken ...; (++in) != '\0'; ... This condition actually compares the pointer's value to null pointer ('\0' is a valid form of null-pointer constant). And it prefix-increments `in` before the comparison. This does not make any sense for more reasons than one. Why do you prefix-increment the `in` pointer? Do you want to skip the first character of the `in` string? If you wanted to `xor` the entire `in` string, the cycle would normally look as follows for(i = 0; *in != '\0'; i++, in++, key++, out++) Variable `i` serves no purpose in the actual xoring algorithm... I guess you added it for debugging purposes. Anyway, the condition that you have in your original code makes no sense at all. You program might crash because of this error as well. * Fourthly, the explicit `\0` at the end of each string literal is excessive. The `\0` is already present in string literals implicitly. * Fifthly, your `xor` function does not explicitly zero-terminate the `out` buffer. If you want to `printf` it, you have to zero-terminate it yourself. Just using a zero-initialized array char out[20] = { 0 }; is sufficient in your specific example. But a better idea would be to do it inside the function. However, it should be said, that the whole idea of zero-terminating the result (and treating it as a string afterwards) is flawed. The xor-ed result can easily end up having zero bytes in the middle, meaning that you should not treat zero bytes as terminators. * Sixthly, develop a habit of using `const` wherever appropriate void xor(const char *in, char *out, const char *key) { // ... } const char *in = "test"; const char *key = "abcd"; char out[20]; 
&gt; Does char *x = "abc"; technically declare an array of type char * because of the relationship char arrays and pointers? Yes and no. The object represented by string literal `"abc"` is an object of type `char [4]` stored in static memory. It is an array. It is a nameless array. But what this declaration declares is `x`. It is a `char *` pointer, not an array. But this pointer is made to point to the first element of the nameless array `"abc"`. &gt; Should I just use char x = "abc"; That does not make any sense and won't even compile. You probably meant char x[] = "abc"; In this case you can pass `x` as `char *` argument. However, if you are not planning to modify the string value (only read it), then char *x = "abc"; will work just as well. I'd just recommend adding `const` const char *x = "abc"; 
GCC has color now (but not by default), and you need a recent version (4.9+).
Thank you! My last question is why to I not use the address of operator to pass the char variables into the xor function? I figured just passing in 'in' would pass in the first value of the char array
What are the differences? They would be interesting to know.
Oh, right. That makes sense. I don't know why I was confused before. But, as I said, that just sounds like ordinary code. Any kind of system library has to deal with that same problem: you want a single binary on the system that supports any set of options the user (meaning application) selects at runtime. So instead of defining your structs with a lot of #ifdefs, you have to keep everything around all the time just in case you need it. The obvious way to do it is what you're doing now, with `if`s and `switch`es. If it needs to be cleaned up, you might split out the functions so that the API-level function just says "if feature A, call thisFunctionWithFeatureA(), else call thisFunctionWithoutFeatureA()" just to keep from having enormous functions everywhere. Another possibility is using function pointers. When you enable/disable a feature, change the function pointers to the correct set of functions that have or don't have that feature. If features turn out to be fairly orthogonal, you may even just keep a table of function pointers, and swap the whole table instead of each function. Or maybe mix and match. I'd be curious to know a more about what you work on, just to try and understand it. I don't know if it would help me generate any genius ideas that would swoop in and save the day for you, though.
you have a number of problems but the one you are asking about is because "arrFirst []" is not a valid identifier. You declared an int array of size 10 and named it arrFirst. If you want to pass that to a function you do so with the name: "arrFirst". You also don't define _flushall or include a header that does. Edit: also, "pause" isn't a shell function (at least in bash). Maybe you meant the system call that sleeps the calling thread? 
&gt; If you want to pass that to a function you do so with the name: "arrFirst". Why doesn't it accept arrayname[index_size] and it does accept just the array name? In another file that I made it did accept in this format^.. (but the array had already values.) And isn't _flushall in the library &lt;stdio.h&gt;?
If you want to pass the array into a function, you refer to it by its name: `arrFirst`. If you want to pass a particular element, that's when you index it using the square brackets.
&gt; its name: arrFirst. If you want to pass a particular So why did it accept it here: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "printArrays.h" void ZeroArray(int array [], int index){ //input: array name and size, output: changes the values of each index of the array to 0 as we were asked in 1.d int i = 0; while(i&lt;index){ array[i] = 0; i++; } } int main(){ int i = 0, ex; int index = 10; //for exercise 1.d int ex2int [10] = {1,2,3,4,5,6,7,8,9,10}; char ex2char [10] = {'a', 'b', 'c', 'd', 'e' , 'f', 'g', 'h', 'i', 'j'}; float ex2float [10] = {1.011 , 2.022, 3.033, 4.044, 5.055, 6.066, 7.077, 8.088, 9.099, 10.1010}; //checking if exercise 2 works as it should printf("Enter exercise number: "); scanf("%d", &amp;ex); if(ex == 1){ int arrMyLuckyNumbers [3] = {3, 3, 3}; //1.a float arrHWGrades [5]; //1.b arrHWGrades [0] = 0; arrHWGrades [1] = 1; arrHWGrades [2] = 2; arrHWGrades [3] = 3; arrHWGrades [4] = 4; char arrName [12]; //1.c while(i&lt;12){ arrName [i] = getch(); putch(arrName[i]); i++; } i=0; int arrZeros [10]; //1.d ZeroArray(arrZeros[], index); while(i&lt;index){ //Checking that the program works as intended printf("\n%d", arrZeros[i]); i++; } }
It doesn't. Running that will give you a compiler error.
I believe that `_flushall` is a proprietary Microsoft function. Please do not use it; it will make your code unportable as this function is not available on most other systems.
&gt; But arrays degrade into pointers, so unless you care about the internals of the compiler, saying "arrays are pointers" is true enough for every case most people care about. It is not true when you are using the `sizeof` operator, it is not true when using the `&amp;`&amp;nbsp;address-of operator, and it is important to understand the difference between char s[] = "abc"; and char *s = "abc"; Those two declarations do very different things. Arrays and pointers are different, and it is important to keep that difference in mind. It is also important to understand that in most cases when the name of an array is used as a value, it decays into a pointer to the first element of the array. But that doesn't mean that arrays and pointers are the same thing. http://www.reddit.com/r/learnprogramming/wiki/faq_c#wiki_is_there_a_difference_between_arrays_and_pointers.3F
Yeah, it'll make it nonportable, but that's not always a problem. He said from the beginning that it's a homework assignment. Even if it weren't, some projects don't have portability as a design goal, or are fundamentally targeted to certain hardware and would never be portable anyway. Although, since `fflush(NULL)` will accomplish exactly the same thing and *is* portable, I guess in this case there really isn't much excuse...
&gt; Although, since `fflush(NULL)` will accomplish exactly the same thing and is portable, I guess in this case there really isn't much excuse... It seems like someone hasn't read the standard. OPs code looks like he tries to flush `stdin`, I'm not really sure why he uses `_flushall` for this though. Flushing input streams has undefined behaviour in general. The standard does not prescribe what shall happen when an input stream is flushed and quite a few platforms implement this as a no-op or program crash. The right thing to do here is to scan a number with a trailing newline like this: scanf("%d\n", &amp;array[i]);
\*sigh\* Dammit. I keep trying to strike a balance of "be correct and accurate" and "keep things simple for beginners". Apparently I haven't found that balance yet. I need to ponder harder on my wording the next time this comes up. Hang on, though, how do arrays behave any differently for the `&amp;` address-of operator? Doesn't the fact that you're taking the address of it mean the array will always degrade into a pointer?
Suppose you have an array: int a[5]; Then `&amp;a` will have type "pointer to array[5] of `int`." On the other hand, if `a` is a pointer to `int`: int *a; Then `&amp;a` will have type "pointer to pointer to `int`." Those are not the same. "Pointer to array[5] of `int`" is not the same type as "pointer to pointer to `int`." For a similar reason, suppose you have a two-dimensional array: int a[5][10]; You cannot pass that to the following function: void foo(int **a) { ... } Why? Because if you use `a` as a value, it will decay to a pointer, but it will decay to a pointer of type "pointer to array[10] of `int`," which is not the same type as "pointer to pointer to `int`."
C95 basically introduces all the `wchar_t` stuff.
ah that makes sense, i run linux
I had a list somewhere... Will find it. One particular detail that pops in mind right away is the treatment of `const` violations with regard to implementation-defined vs. undefined behavior. According to K&amp;R (2nd edition, late print, "2.4 Declarations"): "The result is **implementation-defined** if an attempt is made to change a `const`." According to ANSI C (C89/90, "6.5.3 Type qualifiers"): "If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, **the behavior is undefined**".
Why would you expect it to accept this syntax??? In C language expression `a[i]` is accessing *a single element* of array `a` at index `i`. And you already know that, since you are using it inside your function. So, why would you expect this expression to mean something else when passing your array to the function? The idea is to pass the entire array. Why are you trying to pass a single element instead?
Thanks for the help guys, I was having problems understanding my compiler messages and pointers in general but you guys helped me a lot! Thank you based /r/c_programming
One simply has to go to project settings and select SubSystem: CONSOLE in Visual Studio. It will prevent the window from closing prematurely. This `system("pause")` nonsense is a sure sign of low quality code.
Have you been writing any code in BASIC before moving to C? I ask because the syntax you used here is incorrect, but looks like the syntax you used to pass Arrays to functions in BASIC, and I'm wondering if that's where the confusion came from.
Thanks a lot for the thoughts and ideas, I really appreciate it! &gt; I'd be curious to know a more about what you work on It's a project with a few different components,all designed for embedded computers. In general it implements a built-in-test library and example application using said library. First theres an "os" library that abstracts common operations like file i/o, memory access, PCI devices, GPIO, and basically anything we can easily include on most OSs. This is where much of the nasty switch based configuration comes in. Nested in with that is a BIT (built-in-test) library of tests and test logic which utilizes the OS library. On top of these libraries are a number of applications, mainly the 'BIT apps' which is another configuration structure of product-specific device trees. The idea there is that the example application walks device trees and runs tests to validate that the devices that we expect to be present are, and are working properly. This side of things is actually implemented pretty well.
Before going to details, I want to give a quick feedback on this: &gt; If not is there some new approach i should take? I have not much experience with the Android platform, but a quick browse in their repository shows that they have built-in libFLAC already: https://android.googlesource.com/platform/external/flac/ I think it will be much better for you to just link with the built-in libFLAC rather than building your own version and packaging it with your app (which makes your app's file/package size much bigger). You can just grab the header files they use from their source tree, then in your build recipe, you will just add libFlac as one of your link libraries. If there are any dependencies needed (or some kind of naming convention that must be followed), then the system/built-in version of libFLAC must adhere to those. This will probably be less problematic than building it your own. But to answer your questions: &gt; One is .so, one is .so.8 and one is .so.8.3.0 something very similar. You can run a diff on all three files and will probably see that either (A) they are all the same files, or (B) two of the three files are probably symbolic links to one of them. These are indeed done to allow having multiple versions of the library. &gt; "java.lang.UnsatisfiedLinkError: dlopen failed: could not load library "libFLAC.so.8" needed by "libLibFlacWrapper.so"; caused by library "libFLAC.so.8" not found If what you said is true (i.e. Android does not allow for extensions other than .so), then you will most likely need to modify the way libLibFlacWrapper.so loads libFLAC. Because you mentioned this happens on runtime (assuming your build process succeeds without any linker errors), then you need to find how libLibFlacWrapper.so tries to load the libFLAC.so.8. It is most likely a code, so either search for instances of "libFLAC", or "dlopen" inside the libLibFlacWrapper.so's source tree and update it accordingly.
Thanks for the feedback. To answer your thoughts: Android has many versions in the market, and the built in libFLAC only supports decoding from 3.1+ as can be seen here: http://developer.android.com/guide/appendix/media-formats.html Encoding isn't mentioned there, but I believe it is supported in 4.1+. The problem is that only really covers a very small percentage of the market, and thus isn't viable for my application commercially. Thus the need for my own solution. As a follow up: ", then you need to find how libLibFlacWrapper.so tries to load the libFLAC.so.8. It is most likely a code, so either search for instances of "libFLAC", or "dlopen" inside the libLibFlacWrapper.so's source tree " This seems reasonable to me. Could you please give me some more information? I don't really understand how I would do this, and I'd really appreciate some guidance on how to figure that out. Thank you so much for the reply. 
Open the folder which contains the sources for libLibFlacWrapper.so, then do a search for "libFLAC" or "dlopen" within source files. When you get the list of results, look for the one that mentions "libFLAC.so.8" (or anything that looks suspicious), change this to "libFLAC.so". Rebuild libLibFlacWrapper.so with the changes made. Also, make sure that the libFLAC.so that you have built previously is not a symlink. Please note that I am making some assumptions and wild guesses here, so this solution might not work for you. If such is the case, then more information will be necessary.
Basically, search the contents of the source files and find those search terms. Taking a few steps back, I would also suggest that you check if you are bundling your app correctly. Before you make changes to any source files, did you make sure that you are bundling the correct libFLAC.so and not just a symlink file? Because if you only bundle a libFLAC.so and that file is just a symlink to libFLAC.so.8, then obviously, libFLAC.so.8 will not be found. If so, then you either replace libFLAC.so with the right file (and rename accordingly) or bundle libFLAC.so.8 with your app. 
if you want to search all the source files, The Silver Searcher (ag) is much better than grep by the way.
Aaah ..that's cool .. No I don't understand pixels .. Where should I start with ?
Maybe the Wikipedia article? https://en.wikipedia.org/wiki/Pixel
Okey.. Right .. I am updating my code shortly ... I think I did it correctly .. But its not showing . ....
Could you put some of the code up on pastebin or somewhere similar so I can take a look at it? It's hard for me to help without be able to see what it is.
Yes..sure.. Just give me 2 min..thanx..
i am a bad coder .. so forgive my writing manner ... i was just testing it ... https://pastee.org/54vz6
in panel[1] ,, i want to add subwin .. i think i added it correctly ..but i can't able to show it ....
For just using subwindws, this code is quite complicated. Try getting rid of the panels and init_win() to see if you can make a simple subwindow inside a window. Once you get that right, add the panels code and init_win(). 
Any reason why you tie yourself to a specific compiler? What platforms are you developing for? Any reason why you don't use the standard function `getopt()` to parse options?
yes... true .. let me try .. 
Thank you for your optimisation of the if/else if statement. As for not using Makefile, 1. I just don't really like `make`. 2. A bash script can be more fine-tuney, and I think it will be easier to understand if people don't know makefile syntax. 3. i don't have to edit `Buildfile` every time I add another c file.
Aah... This make sense ...thanx a lot ... I was trying this for almost 4hours ... This totally screwed me up ....
You might like to see this, this is a Makefile that can replace your 'BuildFile' script and does the same thing (And requires no editing when you add new .c files) (Set your 'CC' env variable to 'clang' if you want clang - It's probably gcc by default - You could set it in the Makefile if you want but I personally consider that bad practise): CFLAGS += -Wall -std=c11 SRCFILES := $(wildcard *.c) PROGS := $(SRCFILES:.c=) .PHONY: all clean all: $(PROGS) %: %.c @echo "$&lt; -o $@" @$(CC) $(CFLAGS) $&lt; -o $@ clean: @rm $(PROGS) By default 'make' will compile every program in the directory. If you want to compile single programs, use the syntax 'make ls' to compile 'ls.c', or 'make cat' to compile 'cat.c' (Exactly the same as your syntax, but leave off the '.c' extension). An advantage of this Makefile is that it also implements a 'clean' target, so 'make clean' will remove every program compiled by the Makefile. Also handy, typing 'make' will only compile the programs for which the .c file has changed since it was last compiled (This is simply a standard feature of 'make'). I also think you shouldn't simply say 'no header files', because not allowing header files means your programs can't share any code between themselves. I think it's highly likely that you'll find some code is useful in lots of separate programs for your coreutils - Without allowing header files and such, you'll have to include a copy of that code in every file which uses it. That's maintenance hell waiting to happen when you have a bug in it. With headers and a bit more complex of a build system you can let the programs share the code and use the same copy (compiled right into each program, so no extra dependencies or anything like that). I like the project, but long term I don't see this working out very well with the current design. It's also not very UNIXy really IMO - Your plan is to have a bunch of monolithic pieces of code that all compile separate into each program in the coreutils implementation. A UNIX design would really be to have lots of smaller pieces of code that do simpler things, and then combine those pieces of code into the programs (IE. the opposite of having single monolithic pieces of code). Right now the project is small enough that it really doesn't matter though.
Notice that this Makefile requires GNU make and may not work with other implementations of `make`.
Not a problem, and I think I've had the same problem before. IMO, the distinction between subwin and derwin is pretty annoying. There really aren't many times you'd ever want to use subwin instead of derwin.
Yes ...true .. DSMan185276 I am still a beginner keep on guiding me .. 
The Makefile can be even simpler than the script. Here's a Makefile (GNU Make, but it's worth using GNU Make) that doesn't require editing as you add files and works with what you have right now: all : $(basename $(wildcard *.c)) That's it. A more precise Makefile is just a few lines longer: CC = clang -Wall -std=c11 .PHONY = all all : $(basename $(wildcard *.c)) You now get the added benefit of recompiling only what changed, not everything, and when you get a significant number of files, "make -j" (make as many files in parallel, utilizing multiple cores) will just work. 
It's a fair point, I believe at least a few of those constructs are GNU only (wildcard, and possibly the suffix replacement and the pattern rule). I honestly can't recall which are and aren't, I never really use non-GNU make implementations. I'd be worth looking into if there is a requirement of using non-GNU make.
I do admit that standard [make](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) is not really powerful. I mostly use `mk` from the Plan 9 project these days. It's basically a better make without all the cruft GNU make has.
better *in that it is* simpler. also, as the project grows it will become more clear that this isn't a clone of the GNU coreutils, and there are a lot of programs that are completely new (like the `lnum` program is).
thanks very much for your feedback. * I will begin to use that makefile, thanks for sharing it * When the project gets bigger, and I actually need to use the same functions in multiple files, I will use header files. The current `README` only describes the project as it is *now*.
I strongly suggest you to implement programs which are specified by POSIX in the way specified by POSIX. We had large amounts of fragmentation (i.e. every Unix has behaves differently) in the userland 20 years ago and I will stab the next guy who tries to reintroduce that kind of fragmentation.
One letter variable names are fine if they have small scope. If you can easily see every use of a variable in half a screen or less, it really doesn't need more than one character.
Your `getopt` usage is still incorrect. It doesn't correctly handle `--` and does not behave like it should. A correct usage of `getopt` would be this one: int optchar; while ((optchar = getopt(argc, argv, "a")) != -1) switch (optchar) { case 'a': show_all = true; break; case '?': exit(1); /* getopt prints an error message for you */ } After control has passed through this piece of code, `optind` is an index into the `argv` array such that `argv[optind]` is the first non-option. You can iterate through the remaining arguments by either iterating until `argv[i] == NULL` (the last argument is followed by a `NULL` pointer or until `optind == argc`.
I started a somewhat similar project last year. I mostly abandoned it, but if you want to have the source code to study it, feel free to PM me. The code is not public but I can send you a copy.
I'm glad that it was some help, and that sounds reasonable. If you're interested I might fork this and submit some code back to you for some more utilities, this seems like a fun project to me.
No offense, but if you want to claim that your tools are better than GNU coreutils, you best be prepared for a lot of flak from the community. These have been in development for decades.
Don't worry, you haven't offended me at all. Perhaps I'll just change the description to "an alternative set of coreutils." The reason I think GNU's coreutils are problematic, in case you were wondering, is just the sheer bloat of them - just look at the [GNU Yes program](http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/yes.c)
nope. fixed!
I understand. There's nothing *bad* about using `f` for this specific variable. But I'd prefer to use `read_file`, and I'm not aware of any disadvantage stemming from that.
Thank you for this. As it says in the title, this is my first 'proper' time using C, so it is a lot of help to get all this advice and suggestion.
Could you be more precise? What do you expect to happen, and what happens instead? Try to write complete sentences so it's easier for us to understand what you mean. In your code the "subwin in the win[1]" is called s_win[1], but there is no code that moves it. You only move s_win[0] on line 73. Also, there are no calls to mvderwin() in that code.
i want to move the s_win[0] within win[1] ... here s_win[0] is a subwin of win[1] .. .. when u compile my code .. u can find that s_win[0] is moving, but outside the of win[1] ... i want s_win[0] to move inside win[1]
yeah sorry, both s_win[0] and s_win[1] are subwins of win[1]. Looks like a problem of mixing up absolute and relative values, like in your last post. Look closely at line 73: mvwin(s_win[0],b_y,b_x); In mvwin(), y and x (or b_y and b_x as you use them) are absolute values, not relative to the parent window win[1]. It would be useful for you to define some values, say parentwin_y and parentwin_x in init_win() or somewhere else. Then you could use mvwin(s_win[0], parentwin_y + 1, parentwin_x) or something like that. 
aaah.....ok .. i am trying .. but i don't see a hope ... 
This thread has been linked to from elsewhere on reddit. - [/r/titlegore] [:( :( :( ... another problem cannot move the subwin in the win\[1\] window ... if i cal mvwin() ,, it makes a move in stdcr .. and and if in touchwin() with mvderwin() then i makes a negative move ...](http://np.reddit.com/r/titlegore/comments/2pytrf/another_problem_cannot_move_the_subwin_in_the/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 