The proper format specifier for printing pointers is `%p`. Attempting to use `%u` will typically output an integer that may or may not fully represent the bit pattern of the pointer, but it may also cause any other format specifiers in the same string to output garbage, and may cause arbitrary unwanted side-effects as well. If you use a `%p` specifier, you should expect that `var1` and `var2` will output different addresses from each other. Since an object declaration asks a compiler to assign any convenient space to an object, it should not be particularly surprising if an implementation often happens to find the same space convenient, but nor should it be surprising for an implementation which often uses the same space occasionally uses a different location instead.
Thank you but I installed Version 3.4.6.
&gt; Should I worry about this? Or just carry on... Just carry on. Unless you're doing hardware manipulation (embedded) you wont be working with bitwise stuff very often.
Thanks. I suppose the book has a bunch of different audiences in mind, because at some times it treats you like a complete beginner, and other times expects you to know fairly complex stuff.
ok, im having trouble with setting up raylib to VS2019. do ye know how to help?
I'm well aware of how to code in C, thanks. ECS isn't difficult or impossible to implement in C; I've done it before. As have many. It just glues less into place (as described) than when done in something like C++/Rust/D/etc. I'm not coding my game engines in Rust or C++ though, so clearly I don't have an *issue* with it. I'm just interested in if and how *he* does it. So crawl out of your ass and go scream at a wall or something, you nutter.
It hasn't changed. From the [documentation](https://docs.opencv.org/3.4.6/d3/d63/classcv_1_1Mat.html), the Mat class is defined in the opencv2/core/mat.hpp file, not cv_mat.h.
Thank you. Then I try to replace it
I remember struggling with that section back in the day. Something clicked when I started treating integers as fields of bits rather than just their decimal values. For example, *~0* off of the top of your head might quickly evaluate to *1*, however *0* is actually a field of 32 bits (ymmv) that are all *0*s; so *~0* actually a field of 32 *1*s. Drawing out the bits for each step might help, although it’s rather tedious. I think it’s helpful to know. There are plenty of real world optimizations that are made at the bit level. Feel free to PM if you need more help
Note that integers are fields of bits in the language described by K&amp;R, but not necessarily in the language defined by the Standard. On a two's-complement system, given a negative number that is not below -INT_MAX/2, shifting all the bits left one would multiply it by 2, but the Standard categorizes that as Undefined Behavior.
Why don’t you post the examples you don’t get?
&gt;Unless you're doing hardware manipulation (embedded) you wont be working with bitwise stuff very often. The most common usage (for me anyway) is storing a set of boolean flags in an integer type.
You might be overthinking it just a bit. Have you written the examples out? Even if you code them yourself and step through with GDB it might help. Passing a “/t” argument to the debugger’s print routine will format your values in binary. It could also be helpful to add a specific example that you are struggling with to the post.
If you didn't already know, you can use semi-colon syntax in structs &amp; unions to help out with that. IIRC it's something like: struct { uint8_t myflag:1 uint8_t myotherflag:1 } And it'll pack them all in for ya.
&gt; `printf("猫"); works just fine. This depends on the implementation. They're not required to support any characters in source code other than the most basic set required to write a C program. And even if you use one that does support it, there's no guarantee of what encoding you'll end up with in the string.
In your code there are multiple serious issues. But you say you want to avoid using `wchar_t`, which obviously means you would not be using `wcs*` functions either. One approach is to do all of your operations in UTF-8, and require callers of your code to pass UTF-8-encoded strings already. Example: void foo(char const *s) { FILE *file = fopen("./a.txt", "w+"); fputs(s, file); fclose(file); } int main(void) { foo(u8"猫"); // Requires compiler support of non-ascii source code foo(u8"\u732b"); // Guaranteed to work on C11 compiler }
Compilers don't do much `restrict` optimization because there isn't much user demand for it. Also there is usually a backlash whenever a compiler starts doing a permitted optimization that it didn't before.
The representation for a two's-complement number -5 is ...1...11011. Shifting that bit pattern left 1 would yield ...1...10110, which is -10, but the Standard would regard any attempt to shift left a negative value as Undefined Behavior, even on two's-complement machines and even when the result of the shift can be represented within the signed type in question.
Thanks for pointing this out!
There can be a bit of a chicken-and-egg problem with optimization directives, but `restrict` makes it easy for programmers and compilers to work together to reap huge quantities of low-hanging fruit safely and easily. The backlash of which you speak usually occurs when the Standard decides that a useful construct should be left as a "popular extension" rather than a mandated part of a standard, but compiler writers who have never read the published Rationale for the C Standard believe the omission was intended to deprecate the construct rather than free any particular implementations *whose customers wouldn't find it useful* from the burden of supporting it. So far as I can tell, the notion that the Standard was intended to invite implementations to ignore the needs of their customers or limit what customers might "legitimately" require is pure fantasy which doesn't coincide with the history of the language nor with anything the Committee actually wrote.
You don't get layout control of the struct that way. Sometimes not an issue, but it can be if you're writing the values to storage or communicating with other code or processes.
Even so, it's still a field of bits, regardless of how they represent what they represent.
Just think of it as a deck of cards. What if I gave you a bunch of playing cards and asked you to tell me which cards and how many of them there are. Break down how you would do it into the smallest possible parts. How do you know which cards to count? You might look at the first one and say "I need to count this." How do you count it? How do you make sure you are not counting something you've seen before? And so on.
&gt; Just carry on. Unless you're doing hardware manipulation (embedded) you wont be working with bitwise stuff very often. Except bit flags which are used _a lot_. You need to understand what something like `if((flags &amp; some_mask) == FLAG_ONE | FLAG_TWO)` means. You cannot just skip this, it's used often.
Note that `uint8_t` is not a portable type for bitfields. Use `int` or `unsigned int` instead.
I believe the section assumes use of unsigned integers, which is usually what one uses when attempting bit logic
Very true. I remember I felt the same way with some of the beginning chapters. As you carry through though you'll find the ideas will just click. Great book nonetheless. You'll have quite a comprehensive knowledge of C once you're done with it :)
As they say in the nike ads, just do it. https://repl.it/@dullin/Pointer-adressing
I understand what it's doing, the &amp;'s result will have 1's where both bits are 1, and 0 other wise, and the | will result with a 1 in that bit's column if there's a single 1 or both ones. For example, I know that 1101 &amp; 0111 would be 0101, and 1101 | 0111 would be 1111, but I can't really wrap my head around how it's put together into something useful.
It's not really just one example, I just don't understand how it's all put together to make something useful. I understand what each of the operators do, but it's just hard for me to wrap my head around how it can be useful. Someone mentioned them being used in "flags", like FLAG1 | FLAG2. I just can't wrap my head around it. The one example I *did* get confused with used a bunch of them in combination. I just can't track what's happening with all of the bits. I could slowly read through it, and try to draw diagrams of each step, but even then, I don't think I'd be able to grasp how I'd use it on my own.
Not a C-specific example, but imagine you have a console, that has a controller with these buttons: A, B, Select, Start, Up, Down, Left, Right and when you ask for the status of the controller buttons, it fills 8 bits in a specific location (call it JOY\_STATUS) in memory like this: 76543210 ABSSUDLR To know whether a buttons is pressed, you'd have patterns like: A\_BUTTON\_MASK = 0xb10000000 then you could AND it with JOY\_STATUS. If the result is 0, that means A was not pressed, otherwise it was. This is generally how NES controller reading works, except it sends one button each at a time, but that's not relevant for this example.
OK, so in this case it's storing a number of flags into an integer value. You'll see things like this. enum { FLAG_ALIVE = 1, FLAG_PLAYER = 2, FLAG_MOVING = 4, FLAG_SHOOTING = 8 }; These are 4 flags, either true or false, that some object (in my quick example, a tank in a game) can have. Next, you store these flags in the tank's state. struct tank { int hp; int x, y; unsigned flags; }; This is so you don't have to have fields for each of these. Normal fields would take too much space, each is a single boolean value, having an 8-bit value for each would be wasteful. There is a thing called bit field that will help here, but it's often easier to work with a flag field like this. if((tank.flags &amp; (FLAG_ALIVE | FLAG_PLAYER)) == FLAG_OK) Here we're making a mask with `FLAG_ALIVE | FLAG_PLAYER`, we want to test the bits for ALIVE and PLAYER. We're &amp;ing with 0011, so we're just isolating the two least significant bits. We then compare with ALIVE, so we're testing if the ALIVE flag is set and PLAYER flag is not set. In other words, we're testing if this tank is alive and not a player tank. This could be done in other ways, but once you get used to this notation, you can mask you any bits you want and test for any combination of them in a simple single line. You don't have to sit there and analyze it once you understand the pattern, there are only a small handful of expressions and you'll learn to recognize them. Another one is like this. if(tank.flags &amp; FLAG_ALIVE) You're making out all the bits except the ALIVE bit. If it is alive, then the bit will be 1, and the if statement will be true. There are other uses of bitwise operators as well. For example, say if I've got a color packed in a 32-bit unsigned int. I could extract the colors like this. void unpack_color(uint32_t c, uint8_t *r, uint8_t *g, uint8_t *b) { *r = (c &amp; 0xff0000) &gt;&gt; 16; *g = (c &amp; 0x00ff00) &gt;&gt; 8; *b = c &amp; 0x0000ff; } Here, I'm using &amp; again to mask out only bits from c that I'm interested in, and then using the shift operator to get them into the least significant 8 bits. Bitwise operators do have uses, but you won't find that that often. As the other commenter said, this, they're _not_ just used in embedded devices. Keep studying until you understand them, you'll need to understand them.
It's annoying and harmful to pretend that OO and FP are not paradigms supported by C.
Thanks, I can kind of understand that. Would you have individual checks comparing the input value to a mask? For example, say you passed 0x10000001 "input", to a function, would you have checks like if (input &amp; a_button == a_button) and if (input &amp; right_button == right_button)? In that case I suppose it would run the code for both the a and right buttons. I suppose that makes sense. I was thinking that it would be one check, and based on that checking that input, it would somehow figure out everything. I didn't think of it as a bunch of individual checks. Is that how it would work?
Have you ever programmed an assembly language?
You'd check them individually, yes. If you wanted to check both, you'd do something like: if (JOY_STATUS &amp; A_BUTTON_MASK &amp; RIGHT_BUTTON_MASK) { move_upward_and_right; } assuming the directional buttons move and A jumps ;)
I asked this very question last year and got a great response. Check back it out https://www.reddit.com/r/C_Programming/comments/8b4mpa/eli5_bitwise_operators
C is lacking true generics. You can use the preprocessor to get similar functionality, but it's not a language feature. And considering I have projects up on GitHub and use OO-style C all the time, I'm well aware of it. But it's still not the same as a language that has object-oriented features from the ground up. You know, like a managed vtable, actual inheritance and polymorphism, etc. But you're clearly on some idiotic war path in your mind to convence yourself of many things that are incorrect ("C is a functional language"), so go be annoyed with your delusions elsewhere.
That's correct, yes :)
Okay, I can understand it. It makes sense if you choose values like 1, 2, 4, 8, since they're all just single 1's, amongst 0's. That makes a lot more sense. I was thinking that it'd just be any value, like 5, which seems like it would be difficult, because there's multiple 1's, but as you said, since they're all just single 1's, it's like they're either true or false. It actually seems quite useful and it's fairly logical. I'll probably continue reading on a bit more, though, and properly look into them when I need to. One thing that confused me was them using octal numbers in the book, since it just seems like they pulled them out of no where. But I suppose they're a convenient way of representing bits.
Not really. I've checked out 6502 assembly language, but wouldn't be able to do anything other than manipulating some numbers around. Now that you mention it, though, that seemed to use "flags", in a bit. Where each bit would correspond to something.
Sounds like you've got it. Octal numbers are something you can _almost_ ignore. They were used much like hex was, but only stored 3 bits. I _think_ this goes back to the PDP11 which had an 18-bit word size, 6 octal digits could represent an 18-bit word easily. However, they're very rarely used today. The only place I've encountered them in the past 30 years or so is file permissions on *NIX, where you have 3 or 4 groups of 3 permission bits, so octal is a convenient way to represent them. But if you can't do octal math in your head, or something, don't worry about it. As for the K&amp;R book, you may find that it's archaic or terse in some areas. It's a venerable text, but not the "best." I usually recommend the K. N. King book as it takes its time in explaining more thing, and then going back to the K&amp;R book for the programming exercises.
You should probably read up on regular expressions
Use the library function `strstr` to find the first location of the substring. If found, do it again from right behind that position. Repeat until no longer found. Increment a counter each time you found it.
Thanks, but I tend to get quite demotivated when reading big books, so books like k&amp;r kind of appeal to me. I might check it out at some point, though, since I've seen it mentioned a few times.
I did, but Dark Souls changed my life. lol
6502 assembly is a fun language to learn. :)
This is a common experience for many of us, primarily from seeing it in other peoples' code. I didn't understand any bitwise operations until I had to figure out the boolean flags in someone else's program.
Carry on my friend. You'll see.. should the rare scenario arise where you have to fiddle bits for some reason, you will remember that there are operators you could use to perhaps to whatever it is you have to do. And then you will play with them in a scenario that makes sense, and it will all come together. I'm a seasoned programmer, and in everyday applications this just very rarely comes up. In embedded systems, it comes up more often but not all the time either. If you understand it at the operator level, good enough. You're fine.
&gt; shifting all the bits left one would multiply it by 2, but the Standard categorizes that as Undefined Behavior. Hell, the standard allows prettyyy-good's innocent-looking `~0` to yield undefined behavior on a ones'-complement system that doesn't support a negative zero. And even if a one's-complement system does support a negative zero, `~0` isn't required to generate a negative zero instead of a normal zero, meaning the `~` operator in such a case may do nothing at all.
&gt; Someone mentioned them being used in "flags", like FLAG1 | FLAG2. I just can't wrap my head around it. The one example I did get confused with used a bunch of them in combination. I just can't track what's happening with all of the bits. I'll give you a simple example of how bitwise operations are used for things like flags. So the idea is that you have a collection of flags, each representing a single bit in an integer. Let's say we four flags: uint16_t FLAG1 = 0x0001; // Binary: 0000000000000001 uint16_t FLAG2 = 0x0002; // Binary: 0000000000000010 uint16_t FLAG3 = 0x0004; // Binary: 0000000000000100 uint16_t FLAG4 = 0x0008; // Binary: 0000000000001000 We can combine them into a single variable, using bitwise OR: uint16_t combinedFlags = FLAG1 | FLAG3 | FLAG4; // Binary: 0000000000001101 We can isolate flags by using bitwise AND: uint16_t isolatedFlag1 = combinedFlags &amp; FLAG1 // 0000000000001101 and 0000000000000001 = 0000000000000001 uint16_t isolatedFlag2 = combinedFlags &amp; FLAG2 // 0000000000001101 and 0000000000000010 = 0000000000000000 uint16_t isolatedFlag3 = combinedFlags &amp; FLAG3 // 0000000000001101 and 0000000000000100 = 0000000000000100 uint16_t isolatedFlag4 = combinedFlags &amp; FLAG4 // 0000000000001101 and 0000000000001000 = 0000000000001000 Checking whether a flag bit is set is useful for conditional operations. Like above, we use the AND operator to isolate the a particular flag's bit, and see whether it is set: if ( combinedFlags &amp; FLAG2 ) printf( "FLAG2 is set\n" ); else printf( "FLAG2 is clear\n" ); We can also unset a particular flag bit in combined flags. In this case, we need to use an AND operation with an inverted mask: combinedFlags = combinedFlags &amp; ~FLAG3; // 0000000000001101 and 1111111111111011 = 0000000000001001 Note how we apply a bitwise NOT on `~FLAG3 = ~(0000000000000100) = 1111111111111011`. This gives us the inverted mask for FLAG3 to knock out its corresponding bit in `combinedFlags`. That's the gist of it. It's quite powerful to use, and these are staple operations for a lot of low level stuff interfacing with hardware, or dealing with binary file format, etc.
You didn't mention all your picky requirements in your original post.
(d) is not necessarily correct, but you will likely have it marked as correct. None of those five answers is necessarily correct. Arrays are guaranteed to be contiguously allocated, but there are little to no guarantees about pointer representation -- you can have segmented, symbolic, etc., representations instead of linear representations. So for answer (d) to stand a chance, "the value of &amp;a[0] is 0x10000" really does have to be talking about some abstract, ill-defined kind of value (as given in a spec sheet or mental model perhaps) rather than a representation.
I think I felt the same way. It'll come with experience. At least it did for me. These kind of operations are useful if you're programming embedded systems or in general close to the hardware. Also you can do some really cool one liners with this stuff. You'll probably will have a moment where it just clicks. But even now I often simply start writing down some examples and test what such an expression does
Pretty much any 8-bit assembly is fun. 32/64-bit maybe not so much fun.
I don't believe there has ever been a ones'-complement or sign-magnitude machine upon which it would be particularly practical to support the \`uint\_least64\_t\` type which has been mandatory since C99. The only machines upon which ones'-complement or sign-magnitude implementation would be practical are those which lack support for power-of-two modular arithmetic necessary to efficiently support types longer than a machine word, and I don't think any such machines support a 65-bit or longer word necessary to accommodate a \`uint\_least64\_t\` without such ability. &amp;#x200B; I wouldn't have a problem with the fact that the Standard regards a left-shift of a negative number as undefined behavior if compiler writers interpreted that phrase as meaning "Process code in whatever fashion would best serve an implementation's intended purpose", and were clear about what their intended purposes are. It should be self-evident that a quality compiler which claims to be suitable for a particular purpose should refrain from behaving in a manner antithetical to that purpose even when the Standard would allow it to do so, but some compiler writers either do not understand that principle or are not making their compilers' purposes clear to their customers.
The PDP-11 was 16 bits, but earlier Programmable Data Processors used other sizes. BTW, I find it funny that "computers" like the IBM 360 were used primarily for data processing rather than computing, while many PDP machines lacked the I/O necessary to do serious data processing and would thus have been more useful for computing.
Agreed. The x64 instruction set is way over my head.
I would regard \`if ((flag &amp; mask)==mask)\` to be an anti-pattern. Either use \`if (flag &amp; mask)\` or, if you need to convert a bitmask to either a zero or 1, use an expression like \`result = !!(flag &amp; mask)\`. What code is interested in testing is not whether the numerical result of the \`&amp;\` operator is equal to the numerical value zero or the numerical value of the mask, but rather whether it has any bits set. The conditional-branching behavior of control statements, as well as the \`!\` operator, test for that without using the \`==\` operator.
&gt; I could slowly read through it, and try to draw diagrams of each step, but even then, I don't think I'd be able to grasp how I'd use it on my own. That’s you problem. There are only a few tricks to understand, and that’s done. Let’s say we are talking about groups of 8 bits. If you store boolean variables, you can store 8 of them. Let’s number them from 0 to 7. You count from the right. Let’s talk about the 3rd number. It maps to bit n=3, so the number looks like xxxxxVxx, with V being 0 or 1. The associated mask is 00000100. It means if you have a value V, doing V&amp;mask will give you 00000000 or 00000100 wether the bit n=3 was set or not. The mask is calculated by computing 2 to the power of (n-1). To ease the calculations, we count from zero, so from now on n is 2 (0,1,2, so 2 is the 3rd number). The mask is 2^n, which is computed as 1&lt;&lt;n. You can test if the flag is on by: ```V&amp;(1&lt;&lt;n)``` You can test if the flag is off by: ```!(v&amp;(1&lt;&lt;n))``` You can set the flag to one by: ```v |= 1&lt;&lt;n``` Those are normal Boolean operations. It gets slightly more complicated if you want to clear the flag: you want to mask out the bit, so you use the inverse mask 11111011. This mask is the opposite of 00000100. You create it by flipping the bits, so it is ~(1&lt;&lt;n). Setting the flag to zero is: ``` v &amp;= ~(1&lt;&lt;n)``` Flipping the flag is: ```v ^= 1&lt;&lt;n``` Thus is the basics and the only thing you need to understand. All the rest can be coded with this. You can do much more complex expressions where you can test and change of several values at the same time, but you need to understand the basics first. It would be easier for us if you could post the example that confused you, so we can pick it apart for you.
Ok I found the error. You need to ``define WIN32`` in the file Fl_Native_File_Chooser.H
&gt;there is no functional thing as "pure C." Since I'm not relying on programming to buy my food, I allow myself some freedom. I am currently making a molecular mechanics simulator and it uses NO library. Everytime I need a feature, I do it myself. Pure C style.
string arrays.
Thanks for posting the solution!
RISC-V assembly is pretty fun, too!
`s/global/declared with external linkage/` Similar to passing objects by reference vs. passing reference values by value, I'm pretty sure you're more than aware of the subtle nuanced differences and that I'm just nitpicking. This nitpicking is not for your sake, FUZxxl. Relax... there are people who might want to write things like compilers, you know? Say... have we met?
Can you post a snippet of your code? Paste it in here, and add four spaces before each line. printf("Putting four spaces in front makes your code more legible.");
Have you tried defining it _before_ including that header?
while((character = getchar()) != EOF){ if (character != ' ' &amp;&amp; character != '\\n'){ character\_counter++; } if (character == ' ' || character == '\\n') { state = OUT; histogram\[counter\] = character\_counter; character\_counter = 0; counter++; } if(state == OUT){ word\_counter++; state = IN; } }
ummm I don't think I did it correctly, but this is the loop i used to get the lengths and stuff
&gt;I don't think anyone aims for a strictly conforming ISO C program in practice. Hmmm, I think it might be possible to write a strictly conforming C compiler that targets a specific platform in C... and for that reason it's probably pretty important to have this definition, right? Imagine if you had to fight a compiler dev in court... and you didn't have the standard to hold them to? Imagine if the stakes were so high that one of you would end up being responsible for manslaughter... To be clear on this, you would agree that a C compiler should be able to compile a program that meets a minimalist set of requirements, right? &gt;Most of the world's most useful software hinges on the assumption that CHAR\_BIT is 8, for starters. That is one of the minimalist requirements. `CHAR_BIT` may be larger, if an implementation chooses to extend it. However, relying upon such implementation-defined extensions would render a program *non-strictly conforming* as the program then relies upon implementation-defined behaviour. I wonder if perhaps you're confused about the definition of this term? &gt;Whenever I've seen software written by committee members, it's invariably been of the 10-line-toy flavor, and even then it's often possible to find some way in which the code fails to be strictly conforming. Perhaps if you decouple the _standard library_ from the _program in question_ you'll come to some sense here. It's possible that a standard library targeting a hosted implementation with `CHAR_BIT == 16` and `INT_MAX == 32767` may need to rely upon some implementation-defined conversions, which might then result in a strictly conforming program using a standard library function that fails to execute correctly. In that case I'd say the standard library is non-conforming. It's also possible that `fgetc` might just return `EOF` every time, to ensure it isn't used in such a situation that would end up being troublesome; in that case the downstream programmer would need to use `fread` to read a byte instead (which actually turns out to be nicer, stylistically, F.W.I.W.). However, as far as I'm aware, there are no hosted implementations where this situation occurs... at least none that claim to be _conforming_... so... if you would please explain further? Note that I'm well aware of questions like [this](https://stackoverflow.com/questions/3860943/can-sizeofint-ever-be-1-on-a-hosted-implementation)... having written [my own similar questions](https://stackoverflow.com/questions/30825151/is-there-a-meaningful-distinction-between-freestanding-and-hosted-implementation) in the past... what I'm requesting is some example of an implementation-defined or undefined behaviour which you believe trivial _strictly-conforming programs_ must rely upon, along-side one of the ten-line-toy programs you mentioned, ideally.
I interpret the exercise differently: With "your dog is cute" the output would be 0 1 1 2. No single letter words, 1 twoletter, 1 threeletter and 2 fourletter words.
Yes as I said when I define WIN32 then it works
Post the part where you output the array.
So you would like undefined behaviour to be redefined as implementation-defined behaviour? ... but the rationale behind UB was... &gt;Undefined behavior gives the implementor license not to catch certain program errors that are difficult to diagnose. By causing these behaviours to be implementation-defined in effect (i.e. requiring that they be documented) this hampers optimisation. Suddenly compiler devs would have to document how they handle double-frees, race conditions and a whole host of other _errors_ that are really difficult to detect optimally... and if it ever came up in court they'd be taken to task on that. That's not just a waste of _computer time_, but also a waste of _compiler dev time_ and a waste of _court time_. &gt;some compiler writers either do not understand that principle or are not making their compilers' purposes clear to their customers. No, I think it's you who don't understand the concept of undefined behaviour... if you're still confused after my explanation, feel free to read [this c-faq page](http://c-faq.com/ansi/appalled.html) and [this c-faq page](http://c-faq.com/ansi/undef.html) for clarification...
Back in the days the standards committee was formed, there were ones complement systems with padding bits _in the middle of their signed integers_... in fact, those systems have 9-bit bytes, so... there's your `uint_least64_t` rationale, too... and if you bother to read the rationale, the reason the standards committee was formed was to _codify existing practices_. There's your bottom line, right there. Too many different compilers with different behaviours were popping up, calling themselves C, and they had to form a standard for what is actually C before it got too out of hand.
Eh, implying bitfields are portable... while I wonder if `int big_man\` `pig_man:1` has a sign bit or not... and if so, how many values this can portably store?
You should do all setup before forking, now it has a race: will the father reach the second signal() before it gets hit. Also, as it is so symmetric, just keep one pid, like static pid_t other; static void sig(int sig) { if (sig == SIGUSR1) { printf("hitting back %d\n", other); kill(other, SIGUSR1); } } int main(int argc, char **argv) { signal(SIGUSR1, sig); if ((other = fork()) == 0){ other = getppid(); kill(other, SIGUSR1); } for (;;) pause(); }
It has a sign bit and it can store 0 and 1. Bitfields are portable as long as you use portable types for their fields. Their layout in memory is not portable though.
I went through college spending countless hours playing cs:go and WoW. Do yourself a favor and schedule out your day to allow for roughly double the time you spend on video games for homework. Dark souls will get you a degree as fast as counter strike got me one :/
This is a good answer, but for an alternative explanation which has perhaps had more time put into it, see [this c-faq](http://c-faq.com/null/machexamp.html).
&gt;It has a sign bit and it can store 0 and 1. ... Oh, haha, that's hilarious! I thought you were serious for a second, there, the way you carried on into some sense of truth, too. Gotta watch that, someone will take you seriously hehe
sorry, I meant to say that it stores 0 and -1 but I forgot to type the - sign.
I think it's tedious and annoying.
Oh, so you were being serious... in that case, citation please? The reason I ask is because I could find multiple citations to the contrary...
Check out the standard. I can give you a better citation when I'm at work. It might be implementation defined, not sure right now.
Yes, indeed, a citation from the standard would be nice... you should find one somewhere around section 6.7.2... also, on the representation of integers, whether a sign bit of 1 corresponds to a `-1` value in this case... that should be around 6.2.6.2... good luck!
Okay, so the portable types for bitfields are `_Bool`, `signed int`, and `unsigned int` (cf. ISO/IEC 9899:2011 §6.7.2.1 ¶5): &gt; 5&amp;emsp;A bit-field shall have a type that is a qualified or unqualified version of `_Bool`, `signed int`, `unsigned int`, or some other implementation-defined type. It is implementation-defined whether atomic types are permitted. The semantic is given by ¶10: &gt; 10&amp;emsp;A bit-field is interpreted as having a signed or unsigned integer type consisting of the specified number of bits.¹²⁵⁾ If the value 0 or 1 is stored into a nonzero-width bit-field of type `_Bool`, the value of the bit-field shall compare equal to the value stored; a `_Bool` bit-field has the semantics of a `_Bool`. With footnote 125 saying: &gt; 125)&amp;emsp;As specified in 6.7.2 above, if the actual type specifier used is `int` or a typedef-name defined as `int`, then it is implementation-defined whether the bit-field is signed or unsigned. The relevant §6.7.2 ¶5 says: &gt; 5&amp;emsp;Each of the comma-separated multisets designates the same type, except that for bit-fields, it is implementation-defined whether the specifier `int` designates the same type as `signed int` or the same type as `unsigned int`. So there you have it. For portability, always use `unsigned int` to make sure the bit-field is unsigned. With gcc and clang, `int` bitfields default to being signed unless `-funsigned-bitfields` is passed during compilation. Other compilers may make different choices.
Ok, I get it. You said _you_ need to define ... _in_ the file ...
Yes
You gotta paste your code before anyone can properly help you here.
&gt;I have to create a program that will read a sequence of 15 numbers, and sort them between odd and even numbers. However, I have to use 2 arrays, both of size 5 (odd\[5\] and even\[5\]), and when they get filled up, i have to print the array and reuse it. [A example](http://prntscr.com/nyuxp5) Perhaps I'm having a slow brain day but I don't quite understand the problem or the screenshot. For example why would \`\`even\[0\]\`\` be 4 when the input is 1? I don't get it. Can you cite the text of the assignment/exercise exactly? What code do you have so far?
Delete line 15 of your code and you're good to go!
 for (int i = 0; i &lt; word\_counter; i++){ length = histogram\[i\]; for(int j = 0; j &lt; length; j++){ printf("."); } printf("\\n"); }
This is what the output would look like. Is the D the echoed \^D?
Because 1 isn't even. Notice that the 1 is in `odd[0]` instead.
Right, thank you. This confirms I'm having a slow brain day ;-) I would have probably seen it immediately if the "output" column was printed *below* the "input". But whatever. Still don't understand the point of the exercise though.
hey, ive edited the post
i've edited the post
Theres six elements in an array declared with [5]. Unless thats what you were told to write into your program maybe double check you are declaring the right sized arrays, it would be a silly thing to lose marks on. When in doubt just make a small test function to print out the arrays and make sure you've gotten the first requirements of your assignment correct before you dive straight into the meat of the assignment. (it also really helps to program using a pencil so you have to put real thought and effort into the logic of your program, coding with your fingers is easy but coding with your brain is how you want to do it) Without seeing the code in front of us we'd only confuse you even more by just guessing how youre doing any of your code.
In the array where you store the lengths: -what type is it? An array of integers? -if so, do you output it with printf(“%d”, array[*])?
I really wish I had read this before I took embedded C last year. This explanation of bitwise operations and their use is much clearer than the one I was given.
The way you interpret it is correct. That is what a histogram is.
I agree, which is why I typically pick a day during the week to do all of that and spend most of my time coding and going through textbooks.
I didn't quite get why you said there are sic elements in an array declared with 5, can you explain a bit further? Thanks. Yeah this is for an assignment, and using the pencil does help! I used it to organize how I would solve it myself, and then translate it to code. Also, i've edited the code in, thx for the help ;)
Implementations intended for different targets and tasks should offer different corner-case behavioral guarantees, based upon how much they would cost to offer on those targets and how useful they would be in fulfilling those tasks. Implementations targeting weird platforms shouldn't be required to generate extra code to shield programmers from such weird hardware, but programmers who are targeting only commonplace platforms shouldn't have to write extra code to guard themselves against weird platforms *that thy're not targeting*. Implementations intended solely for high-end number crunching should be allowed to assume that programmers won't do the sort of things that might be necessary when writing operating systems code. Suppose someone wants a function that behaves in all cases like the following: void copy_something(void *restrict dest, void const *restrict src, unsigned n) { if (n) memcpy(dest, src, n); } Should the programmer be required to include the zero check before the function call? Conversely, suppose that on some platform the most efficient way to handle `memcpy` for the cases where the source pointer is valid would be: void *memcpy(void *restrict dest, void const *restrict src, size_t n) { unsigned char *d = dest; unsigned char const *s = src; unsigned char const *srcend = s+n; while(s &lt; srcend) *d++ = *s++; return dest; } but the platform would trap if an attempt is made to add zero to a null pointer. Would it make more sense for the Committee to: 1. Require that a programmer include the zero check if the function might need to treat a request to copy zero bytes from a null address as a no-op. 2. Require that implementations of `memcpy` include an early-exit-if-zero test if they would not otherwise treat the copy zero bytes from null as a no-op. 3. Figure that if there are any platforms where the commonplace behavior would be really expensive, people writing implementations from those platforms would be better able than the Committee to judge the cost of having programmers manually include the tests where needed against the cost of having compilers automatically insert the checks without regard for whether they're needed or not. The only people who should need to worry about the issue, however, should be those who might need to make their implementations or programs work with such platforms. Note that if a compiler invokes an external `memcpy` function not supplied by the compiler vendor, and does not explicitly specify how that function must behave in the zero-size-null case, the compiler could not replace `if (n) memcpy(dest, src, n);` with `memcpy(dest, src, n);` Requiring that the programmer manually include such a check to handle such cases would thus reduce the efficiency of code that needs to handle them, even on platforms where such handling should impose zero cost. In this particular case, I would doubt that requiring that implementations handle the zero-size-null case would ever impose significant cost, and thus I would see no particular benefit to allowing implementations to do otherwise. If, however, handling the zero-size-null case would never impose any meaningful cost, then from a practical standpoint it shouldn't matter whether that case is mandated part of the language or merely a "popular extension" which happens to be universally supported.
&gt;Theres six elements in an array declared with \[5\]. It appears that I'm not the only one having a slow brain day ;-) `int bla[5]` has 5 elements, indexed 0 through 4.
Practice make perfect
Yeah I'm not quite sure myself, I think my brain just shit itself for a few minutes while thinking I was being clever. Ignore it all. (well maybe save the sizeof(array)/sizeof(array[i]); bit, thats a handy way to avoid hard coding your loops around changing arrays)
Looks like it. You type the line with Enter and press \^D on the second line. Terminal echoes the control character, and then the first printf overstrikes the \^. I see that often. I guess it depends on the system, terminal settings and shell. Irritating..
So far as I can tell, none of those systems were capable of supporting multi-word unsigned values in any reasonable fashion. The Univac that is given as an example of a 21st-century ones'-complement system supports a `long long` which can handle the range required for `int64_t`, but its longest unsigned type is only a single word. If one has a system on which n-bit word arithmetic operates mod 2ⁿ, then one can add a two-word value Ahi:Alo to value Bhi:Blo using the sequence: Clo = Alo+Blo; Chi = Ahi+Bhi; if (Clo &lt; Alo) Chi++; Many such systems can do even better using a carry flag, but even without a carry flag the above approach is still quite practical. On a platform where arithmetic is performed mod (2**N-1), however, things get much harder. If one doesn't care about whether numbers are stored using a straight binary representation (something the Standard requires for unsigned types but not signed types), the above approach would work even the sum of Alo+Blo is computed mod (2ⁿ-1), with the caveat that the upper portion will be scaled by (2ⁿ-1) rather than 2ⁿ. Since arithmetic operators are used more often than bitwise ones on large values, an implementation could keep `long long` values base-(2ⁿ-1) format except when performing bitwise operations on them, but that wouldn't be allowed for `unsigned long long` which must be stored in straight binary format. It probably wouldn't be impossible for a C implementation on that platform to support `unsigned long long`, but code using such a type would likely be less efficient than what would usually be possible if the code were written to use a combination of smaller types instead.
nnooberson1234 is confused. It hurt itself in its confusion.
even\[counterE++\] = number; would have advantages: you don't need magic numbers 4 and -1, just 0 and 5.
Unless I've misfigured something, the behavior of the following code is fully specified by the Standard as outputting 8000000000000001, save for the fact that the One Program Rule would allow implementations to behave in arbitrary fashion. #include &lt;stdio.h&gt; unsigned long long total; void foo(unsigned long long x, unsigned long long y) { if (x) { total = (total+1) &amp; 0xFFFFFFFFFFFFFFFFull; foo(x-1,y); } else if (y) foo(y,y-1); } int main(void) { foo(0,0xFFFFFFFFFFFFFFFEull); printf("%llx\n", total); return 0; } It would be impractical for the Standard to mandate that implementations actually be capable of handling 1E38 levels of function nesting, or that they be able to figure out that what value would end up in `total`, but the same rule that would allow implementations to behave in arbitrary fashion given the above would do so even if the function call were changed to `foo(0,1);`. Since the same rule would allow implementations to behave in arbitrary fashion when given almost any source text, conformance with the C Standard implies nothing about whether an implementation will be suitable for any particular purpose unless it makes additional claims beyond what the Standard would require.
That's a good suggestion, thx my man
&gt;That is one of the minimalist requirements. CHAR_BIT may be larger, if an implementation chooses to extend it. However, relying upon such implementation-defined extensions would render a program non-strictly conforming as the program then relies upon implementation-defined behaviour. What you apparently fail to grasp is that relying on `CHAR_BIT` being 8 also renders a program non-strictly conforming. &gt;I wonder if perhaps you're confused about the definition of this term? Oh, go away with your arrogance. Let's look at your most recent C post to see whether such arrogance is justified (bold mine): &gt;Generally speaking, an expression denoting an array is converted to a pointer to the first element **(and so sizeof would tell you the size of the pointer)** unless the expression is the operand of the &amp;address-of operator, **the sizeof operator** or **the Alignof operator**, or it's a string literal used to initialise a char array. You seem to have quoted a C11 draft without really understanding what you're reading (second text in bold making an array-decay exception for `sizeof`), which is why you've made the super erroneous claim that `sizeof` will tell you the size of a pointer (even though `sizeof` inhibits array decay into a pointer). How long have you *really* been programming in C? This is beginner material. Furthermore, the array-decay exception for the `_Alignof` operator (note the underscore) was in error. If you look at the syntax in 6.5.3 in that C11 draft you like quoting, you'll see that `_Alignof` requires a *type-name*.
Here is my implementation: https://repl.it/repls/SparklingBurlyCgibin You can do this entirely without pointers. I used only one pointer in setting up the program, the file descriptor pointer to load the numbers in, one per line.
FYI, FLTK is C++, but you're in the C subreddit.
If integers were merely fields of bits, that would imply that given `int *p,*q;`, if `p` and `q` identify the start of an `int`-sized regions of modifiable storage, then `*p = *q;` would copy the region identified by `q` to the region identified by `p`, regardless of how the bits associated with `*q` got their value, or anything the program might have done or may later do with the bits associated with `*p` and/or `*q`. The language described by K&amp;R may work that way, but clang and gcc make no attempt to reliably behave in such fashion.
Raylib is fun and easy to jump into. It's not a "serious" library, there are no commercial games written in Raylib, but it has what you need to get stuff on the screen with an API you can learn at a glance. It's what I would choose for an inexperienced team on such a tight timeframe.
`FILE *fopen( const char * arraytransferpipe, const char * 5);` does not do what you want it to. To explain it a bit, `fopen` returns a FILE pointer and takes two input arguments of type `const char`. `const char * 5` does not make any sense. What you wanna do is `FILE *filepointer = fopen(filename, mode);` Filename, is the file you want to open and mode is "r" for reading "rw" for reading and writing. [More info on fopen](http://www.cplusplus.com/reference/cstdio/fopen/?kw=fopen)
Would w+ work too? Because clearing all of the data from the previous round would be preferable.
You are using wrong syntax, check the other guy's reply. You should first learn the very basics of C through a tutorial (data types, pointers, arrays, loops etc) and then jump into code snippets and more advanced stuff. A good idea is to start using a text editor and compiling your code manually so you are forced to be careful about the syntax.
I think your reasoning is correct.
You are correct. It will evaluate to true 5 times, once each for H,e,l,l, and o. And then evaluate to false, ending the loop.
You have to declare the file pointer before opening. FILE * fp; then use fopen fp = fopen(const char *filename, const char *mode); As you can see, both parameters are C strings. So using a 5 like you did doesn't make sense. Putting a _ simply gets around the error with compilation but will not work correctly when running. It looks like the #5 somehow correlates to "w+", which is "Creates an empty file for both reading and writing." So for the 2nd parameter, use "w+" When using the function, you don't include the const char parts, because that would be declaring new variables. If the file name is stored as char *fileName = "fileToTest.txt"; Then you use fopen like so fp = fopen(fileName, "w+");
Thank you so much!!!! This was incredibly helpful!
That is excellent advice! Any suggestions on tutorials? I have found a couple but they are all kind of underwhelming.
Thank you!
Are you really sure you need to write this program in C, when you need to call a Python script? Maybe you can implement the whole thing in Python or C so you don't need to use pipes. Since you are using Cygwin, you must be on Windows. Interacting with Windows when using Cygwin subsystem is not a very smart thing to do. I'm sure there are many people saying it's fine, but there are also people sleeping on nail beds. My advice is sticking to one language to implement this or at least using OS appropriate environments (POSIX for Linux, VC for Windows)
1) First of all. Why on earth are you using *declarations* in the middle of the code? `type smth(x, y)` is declaration, it doesn't create any real code, it's just a way to tell the compiler "hey dude, it's a piece of code I call `my_function` and whenever I say `my_function` you better run &amp; do whatever written there, rrrright?". Kinda similar with variables. ``` int f(int a, int b) { return a * b; } // declaration + body of function ... int c; // declaration of a variable c = f(1, 2); // usage of function and of a variable c = f(c, 4); // I hope you can guess what \`c' in the end? ``` 2) Let me explain smth to you. The pointers. you have RAM. It consist of bytes. Each byte store some data. Every byte has it's number. When you create a variable - `int a = 5;` - `a` consist of 4 bytes, and start at location which can be represented as `&amp;a`. Operation `&amp;` returns the number of byte in where the value starts. Operation `*` is the opposite: it gets that number of a byte and returns whatever value is there, the length is considered from the type. so, `*(&amp;a)` gives you 5. You can store the result of `&amp;a` in another variable, which will be of type `int *`. ``` int *pa; int a; pa = &amp;a; // \`pa' now stores position where \`a' starts a = 5; printf("%d\n", *pa); // prints 5 ``` but if you do `pa + 1`, you'll move 4 bytes further in your memory. ``` ----|----|----|---- pa pa+1 ``` and `*(pa + 1)` will give you same result as `pa[1]`; yep, it's a de-facto array, and it can be returned, though you **cannot** use `int a[]` allocation here, but you can do ``` int *pa = malloc(sizeof(int) * 5); // creates memory for 5 elements, each of them is 4 bytes long ```
I wish I could do it in all C or python. The unfortunate thing about the piece of hardware I am using is the only way to interact with it to get the data that I need from it is through C. And then I need to use python to gain access to some features on the raspberry pi.
I personally like learning from books, I find them more complete than online tutorials. There are some in the sub's wiki.
&gt; how many times will the str[i] != '\0' expression be evaluated? When you mentally trace through code like this, you're performing the role of what the C standard terms the *abstract machine* ("In the abstract machine, all expressions are evaluated as specified by the semantics"). Real-world implementations tend to apply optimizations.
Can you elaborate more on the hardware and functionalities of RPi you are using.
I am using the [Leap Motion Hand Tracker](https://www.leapmotion.com/), and hope to turn the hand tracker data into two independent joystick streams over 2 USB cables to my computer to act a video game controller for flight sims most likely. At this point, however, I have only figured out how to send one stream of joystick data.
I didn't say *merely* fields of bits, but how else are they stored in memory, if not as a field of bits? That is after all the whole point of the bit-wise operators; to treat integers as fields of bits.
GCC (for either GNU C Compiler, or GNU Compiler Collection) is an compiler normally used on Linux systems. There is Visual Studio (not Visual Studio Code, which is basically another text editor/IDE), which is an IDE that includes an Microsoft compiler (not gcc), but it's a big download and might be overwhelming. There is also clang (which also mimics the gcc interface), but I am not sure if it comes with all required files. You can also use Mingw-w64 which incldues gcc for windows and the required files. You can also use cygwin and/or MSYS2, which mimics an linux/posix environment and you can also install gcc for it, and potentionally use other Linux/POSIX stuff more easily. And then there is WSL that can run linux-native binaries. AFAIK you can download a Linux distro in the Windows 10 store (Called like Ubuntu, Fedora, ...) and then you can use it, but the windows-integration might not be as great as Cygwin/MSYS2.
I still think both of the language alone should be suffice. If not, eliminating Cywin and using the native VC interface should make your job easier.
For specific questions like this, Stack Overflow is probably a better forum.
I will vouch for WSL here, it is just pretty important to remember that you can not access files inside WSL ( / directory) inside Windows (I heard they plan on adding some sort or server which would allow this, but I am sure I am running latest Windows and still do not have this feature.) . Instead of this, I just have directory in my User folder (C:/Users/username/over\_here, could be in Documents, even in Desktop). Then you can access the files both inside WSL and inside Windows (in Windows you usually want to switch line endings to \\n instead of \\r\\n). I also have command in WSL's .bashrc which will redirect me to directory I chose whenever I launch WSL (windows drives and files are accesible from WSL using /mnt/c/Users/username/over\_here). This allows me to use WSL without problem, yet I can still access files I work with with Windows programs without issue. Only problem I had so far was setting up C / C++ debugger inside VS Code when trying to use WSL's gdb, but even that is possible after a bit of configuration.
You want [Valgrind](https://en.wikipedia.org/wiki/Valgrind).
Maybe you could try [https://en.wikipedia.org/wiki/AddressSanitizer](https://en.wikipedia.org/wiki/AddressSanitizer), but it is not like GDB where you can go line by line, instead the program just executes and then it warns you about memory problems.
Try Asan, it should be able to detect a use-after-free. https://github.com/google/sanitizers/wiki/AddressSanitizer
You can also go to the raylib discord channel and ask for help. There are many friendly people around.
If it is your source code there is no need to use a debugger for call logging, just code your own malloc, calloc, realloc, &amp; free hooks and just log the info you need yourself: void* malloc2(size_t s) { void* p = malloc(s); mylog("p = %p, s = %zu\n", p, s); return p; } Repeat for all of the other functions you want to hook.
I'm a big fan of cygwin. Besides gcc, you have access to an absolutely massive collection of tools.
Put in a program and find out.
Pretty sure that's a syntax error.
I already did 🙂 But some sites agree with the first statment and others vice versa
IIRC you can access them, they are hidden inside appdata somewhere.
I’m Crally
You can, but according to Microsoft itself, you really should not, read here: [https://devblogs.microsoft.com/commandline/do-not-change-linux-files-using-windows-apps-and-tools/](https://devblogs.microsoft.com/commandline/do-not-change-linux-files-using-windows-apps-and-tools/) The only way to do that is the new fileserver, but I do not see that anywhere in my system yet (perhaps i need to activate it manually ?).
You may want to take a look at LD_PRELOAD. then you can overwrite malloc and keep track of the allocations yourself
Defensive programming? Setting a pointer to NULL after freeing will cause a segfault if it is subsequently accessed.
use fprintf to print the data to a file.
On FreeBSD, define the `MALLOC_CONF` environment variable to `utrace:true` and run your program under `ktrace(1)`, then use `kdump(1)` to see the result.
gcc's -fsanitizer=address seems to catch most of the issues for me. first have you tried enabling core dump and checking the call stack ?
The best way I can try to explain pointers is having a table of contents in a book. In the table of content you have the chapter name (the name of the pointer) that contains a page of a book (the address the pointer contains). //For example //number in the statement would be the name of the pointer. int *number; number = 10; //and the pointer contains the ram address 10. //Now if you do something like: int number2; number=&amp;number2; //the pointer number now contains the address of where int number2 is. Now at this point you can basically consider arrays to be pointers pointing to the first address of the array. I believe the c compiler deals with arrays in a certain way but I don’t know what it does. Maybe someone else here could explain.
What about line 16 :)
Gimmie that! Let's see here. . . .
Okay, I made the edit. But now when I type Hello Hello hello, it will only accept that Hello appears once. So I'm definitely on the right track, its just the offset arithmetic that needs to be fixed before I can move onto the next problem. Thanks so much man, this problem has had me depressed for the better part of a day.
GCC and Clang have them built-in. There's also ubasan, asan and a few others that deal with bug sanitizing. There's also hardening flags such as vtable-verify, stack-protector, stack-clash-protector, PIC/PIE, use after free also had a flag I can't recall and there's most certainly I've forgotten a few others here as well.
I'm not on any war path, you're just wrong and harmful. But, that's just my opinion. Let's agree to disagree.
There's clearly a misinformed person here, no opinion needed.
As would accessing freed memory. But passing the null pointer to free() wouldn't be a problem.
ctr is uninitialized.
I would recommend that you read the man page for \`strstr()\`: &amp;#x200B; DESCRIPTION The strstr() function finds the first occurrence of the substring nee‐ dle in the string haystack. The terminating null bytes ('\\0') are not compared. &amp;#x200B; The strcasestr() function is like strstr(), but ignores the case of both arguments. &amp;#x200B; RETURN VALUE These functions return a pointer to the beginning of the located sub‐ string, or NULL if the substring is not found. &amp;#x200B; This should give you a better idea of how to use \`strstr()\` . You current code looks like you are trying to write your own logic to to search for the sub-string and using \`strstr()\` to search for the sub-string. You might want to start off by just figuring out how to use \`strstr()\` to iterate over the string.
Wait, I can use strstr() to iterate over the whole string? But if strstr only returns NULL or the pointer to the position of where the string first occurs?
Note for future questions: “it doesn't work” is not an error description. Your questions should never contain this sentence. Instead, show what error you got. Do not paraphrase the error, but instead post the literal error message you got including line numbers. This makes it so much easier to find out what exactly went wrong.
Yes. In C a string is just a sequence of characters terminated by a '\0'. For example, if you do the following: #include &lt;stdio.h&gt; int main() { char str[13] = "Hello World!"; char *pos = str; while(*pos != '\0') { printf("%s\n", pos); pos = pos + 1; } return 0; } it will print out: Hello World! ello World! llo World! lo World! o World! World! World! orld! rld! ld! d! !
I'm also using a WSL install of Ubuntu to run GCC and Clang. I'm only using it for toy programs like working through code in textbooks/tutorials or trying solutions to leetcode problems. But it is a fully functioning linux cli. You can apt install other compilers and command line tools and do all the bash trickery you like. You can run git out of it and use that to share code to the rest of the Windows system if need be. In Windows 10 I use Clion and VS 2017 but they're overkill for running single file programs to test a concept so that Linux WSL thing is super handy. File server sounds interesting, will check out that link, thanks.
&gt; As would accessing freed memory. That's what I thought, so I wrote a simple program to test it. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char **argv) { char *p = NULL; int i = 0; char c = 'a'; p = malloc(200); if(p == NULL) { fprintf(stderr, "malloc() error\n"); return 1; } while(c &lt; 'z') { p[i] = c; c++; i++; } p[i] = '\0'; printf("p = '%s'\n", p); free(p); printf("after free: p = %p : : *p = '%c' : '%s'\n", p, *p, p); return 0; } When I compile this with gcc and run it I get: $ ./afterfree p = 'abcdefghijklmnopqrstuvwxy' after free: p = 0x561e8f28b260 : : *p = '' : '' If I set the ptr to NULL after freeing the memory: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char **argv) { char *p = NULL; int i = 0; char c = 'a'; p = malloc(200); if(p == NULL) { fprintf(stderr, "malloc() error\n"); return 1; } while(c &lt; 'z') { p[i] = c; c++; i++; } p[i] = '\0'; printf("p = '%s'\n", p); free(p); p = NULL; printf("after free: p = %p : : *p = '%c' : '%s'\n", p, *p, p); return 0; } I get these results: $ ./afterfree p = 'abcdefghijklmnopqrstuvwxy' Segmentation fault (core dumped) I don't know if this is specific to the gcc runtime or if common with other C compilers. &gt; But passing the null pointer to free() wouldn't be a problem. For defensive programming, I am recommending setting the pointer to NULL after the memory has been freed - as trying to access memory using a NULL pointer will always give cause a segfault while trying to access freed memory is, as I understand it, undefined.
That wouldn't have possibly answered my question, but I figured it out. LOL I figured it out, &amp;#x200B; [https://pastebin.com/VdFcn5tP](https://pastebin.com/VdFcn5tP) &amp;#x200B; However, I have a bug that I'm gonna put off. &amp;#x200B; If I type in Shibuya Shibuya Shibuya for my haystack and throw down Shibuya for my needle, I get 3 (YESSS) &amp;#x200B; However, if I type my haystack something more complicated oh say. . . .: "Th th Three of Hearts?! Three of Hearts?! GODDAMMIT MYSTERIO I KNEW IT WAS YOU, I'M GONNA \*\*\*\* KILL YOU!!!" &amp;#x200B; and put my needle as Three, I get a count return of 5. Which is bizarre, because Three only appears twice.
It's because the comment you're replying to is wrong. Segfaults only occur on modern operating systems if you try to access an invalid page. It's totally possible to access memory from a freed pointer that is held inside a valid page, as your program demonstrates.
&gt;the behavior of the following code is fully specified by the Standard as outputting 8000000000000001 With the caveat of the machine described by the standard being an _abstract_ machine, and the implementation... well, there's a reason the standard describes these two distinct from each other, right? it's worth noting that the _abstract machine_ formed in your head is likely far more capable than any _concrete implementation_. &gt;In the abstract machine, all expressions are evaluated as specified by the semantics. An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object). We'll get back to that... &gt;It would be impractical for the Standard to mandate that implementations actually be capable of handling 1E38 levels of function nesting Too true! This isn't precisely set-in-stone. In fact, I'd suggest that there are some [environmental limits](http://port70.net/~nsz/c/c11/n1570.html#5.2.4) we can probably draw reasonable *levels of function nesting* limits for concrete implementations from. In this case: * 127 arguments in one function call Given that you have *many more than 127 arguments in one function call* there, I'd suggest that this environmental limit might have been exceeded. I'm no expert, though I've never read any of this, for example, within the C standards: &gt; the One Program Rule would allow implementations to behave in arbitrary fashion I assume we're referring to the same section on *environmental limits*. In that case, keep in mind that the rationale for standardisation was to document the practices of historical C compilers. Also keep in mind that when we write C compilers, we generally do so with the intent for them to be at least somewhat *useful*. The limits above had to come from somewhere, right? That is to say, this environmental limit probably a historical implementation that only supported 127 arguments *on the stack*... if your C implementation can't do that, it's probably getting towards the *useless* end of the spectrum, right? &gt;the same rule that would allow implementations to behave in arbitrary fashion given the above would do so even if the function call were changed to foo(0,1);. I suppose you could read *six arguments in three function calls* as being greater than *127 arguments in one function call*... but in my eyes that implementation would be quite useless (perhaps even buggy), particularly given that we're referring to a *hosted* implementation here. Heck, to be clear, there's not even any guarantee that `printf` would succeed (it could return `EOF` every time), and if the compiler can deduce that `printf` fails every time then it could determine this entire program to be equivalent to `int main(void) { return 0; }`... _no needed side effects are produced_, after all, right? Thus for this program I think your best argument is not in translation limits, but in the definition/constitution of _needed side-effects_. After all, todays compilers tend to perform loop-invariant code motion optimisations to reduce those nested function calls into a linear loop (or hell, perhaps even hoist them into compilation time), and the rationale for standardisation is "to develop a clear, consistent, and unambiguous Standard for the C programming language which codifies the common, existing definition of C and which promotes the portability of user programs across C language environments". In any case I'd note that we're all losers, here, as the C standard has become anything but _clear, consistent and unambiguous_ as demonstrated by these kinds of discussions. That which once was is no longer, and the standards committee has actually failed to keep up... just keep in mind, the context that once was, while new features that don't fit are introduced ad infinitum. ;)
I was just dealing with this at work. There’s a pretty neat trick to log the file function and line that made the malloc and family and free call. You can #define your own malloc function to wrap the standard function. See here: https://stackoverflow.com/questions/9074229/detecting-memory-leaks-in-c-programs
You are close. Think about where loc points to when a matching sub-string is found and where you would want to resume the search for the next sub-string.
The OP needs to allocate a larger size here to observe what I described: &gt; p = malloc(200); Like you said, segfaults occur when you try to access an invalid page or page you don't own. Smaller allocations can land in a page you *do* own. Try running this code under tools to detect this sort of problem such as valgrind or libdislocator and you'll see drastically different results.
&gt; I don't know if this is specific to the gcc runtime or if common with other C compilers. It's simply the result of trying to use a null pointer as if it was something valid. I suppose it depends on what enforcement the kernel provides.
I just wrap the malloc/free functions with my own, and pad the beginning of each allocation with 4 bytes for an unsigned int where I can store the size of the allocation so that I can keep track of how many bytes I have allocated in total. EZ PZ
This is UB and the outcome describe cannot be relied upon.
&gt; With the caveat of the machine described by the standard being an abstract machine, and the implementation... well, there's a reason the standard describes these two distinct from each other, right? it's worth noting that the abstract machine formed in your head is likely far more capable than any concrete implementation. Outside of memory limits, the concrete machine is for many purposes much more powerful than the abstract machine. Most of my work is with freestanding implementations, where the abstract machine has essentially no useful behaviors defined. I've used not-quite-conforming C implementations on platforms with less than 100 bytes of RAM (code was stored in EPROM) which could control motors, lights, produce tones, etc. none of which the "abstract machine" can do. &gt; The limits above had to come from somewhere, right? That is to say, this environmental limit probably a historical implementation that only supported 127 arguments on the stack... if your C implementation can't do that, it's probably getting towards the useless end of the spectrum, right? In the 1980s, it was common for compilers to use fixed-sized data structures for keeping track of things. Most of the translation limits were intended to say that compilers should ensure that compilers should be expected to make such structures large enough to accommodate any reasonable programs. Further, some processors made it much easier to access the top few bytes of a stack frame than to access anything deeper than that. The limit of 127 was intended to suggest that implementations for such platforms should include provisions for accessing things deeper on the stack frame even if the code to do so would be less efficient than code to access the top few entries. I've never seen anyone suggest that the number was intended to be read as a limit for the total number of arguments on all nested stack frames; even if it were, such a limit would be impractically huge for some implementations but outrageously small for some applications. &gt; Also keep in mind that when we write C compilers, we generally do so with the intent for them to be at least somewhat useful. Anyone seeking to produce a quality compiler will seek to make it useful, but the Standard makes no effort to classify as non-conforming compilers that are of such poor quality as to be useless. &gt; In any case I'd note that we're all losers, here, as the C standard has become anything but clear, consistent and unambiguous as demonstrated by these kinds of discussions. Nearly all of the "ambiguities" involve situations where many implementations will process some construct in useful fashion, but it's unclear whether the Standard requires such behavior or it is merely a "popular extension". The only situations where that distinction would matter would be those in which it would actually be useful for an implementation to behave in unusual fashion, and the authors of the Standard thought those situations, if they arose, could be better handled by people who would be able to weigh the costs and benefits of the usual behavior versus alternatives.
Duh? I'm just saying you can't count on a free'd access to reliably crash the program.
&gt; Oh, go away already with your litany of arrogant posts insulting everyone you come into contact with on this sub. I'm just going to get the off-topic and emotionally charged stuff out of the way, first... but bear with me, here, because we'll come back to the topic which you seem to have ignored. **I'm not sure what you think "arrogant" means, as I humble myself to the pioneers who define technology before me.** I find it funny how you choose the post with the context where someone was asking for my advice exclusively, though... see [the context](https://www.reddit.com/r/cs50/comments/bxlocy/whats_the_point_of_using_dynamic_memory_allocation/eq9jo93/), since that matters... right? &gt; Yeah, no. Fuck off. **I'm not sure what you consider to be an insult**, but there are no personal attacks against you in this thread (or _that_ thread which you referred to, for what it's worth)... if you see any, I'd suggest you're reading some invisible ink somewhere... not something I have written. **That is to say, you're imagining it...** and then projecting your imaginations onto me. I'd appreciate if you'd refrain from doing that. Though I'm quite happy to psychologically profile you, if you'd like to continue! Thanks for pointing out the missing underscore, for what it's worth. That's my bad, and I'm not sure how it happened... probably an unfortunate consequence of the editor/markup language for Reddit... but it's a shame you had to sprinkle helpful criticism in unprovoked projection and ad-hominem attacks. &gt;If you look at the syntax in 6.5.3 in that C11 draft you like quoting, you'll see that _Alignof requires a type-name. Okay, thanks for pointing out the error in publishing. I merely quote them; I don't make their documents. I see that section which I quoted (within 6.3.2.1) hasn't been updated yet... perhaps if you wanted to be truly helpful in this matter you could get in contact with the person who translates the pdf files to html and request that he translate c17_updated_proposed_fdis.pdf into [this directory](http://port70.net/~nsz/c/c1x/)... &gt;The array-decay exception for the _Alignof operator (note the underscore) was in error and has been removed. Until I see an updated html file I can conveniently link into to cite, technically speaking, the _array-decay exception_ (as you like to erroneously state) in fact _does_ still exist, in at least some form... not that it matters because translation _won't be successful_. Do you want to be pedantic? That's okay with me, if your intention is to argue that the _array-decay_ occurs despite translation failure, your pedantic nitpicking is seen as a fantastic joke in my books! Hilarious due to multiple levels... &gt;**Update**: I've read more of your posts, and I'm warming to you, buddy. You remind me of myself. I'm a big fan of jackasses who choose to be jackasses. It's the jackasses who aren't aware they're jackasses who get under my skin. Nice... it seems like you've done a reversal of the valuation/devaluation/discard cycle of a cluster B personality here. That is to say, you chose to devaluate first with your projection of abuse onto my writing... then you chose to valuate... but this will be rejected unless you can respond indicating that you're capable of focusing on **the entirety of the context**, rather than merely picking and choosing pieces that fit your agenda. Now that I've responded to the off-topic stuff, let's see what substance you've got: &gt; There's a vast difference between a program that assumes `CHAR_BIT` is at least 8 (which is guaranteed) and a program that assumes `CHAR_BIT` is exactly 8 (which is not guaranteed). A great deal of software hinges on the assumption that `CHAR_BIT` is exactly 8 and therefore isn't strictly conforming. This software will break on systems with `CHAR_BIT` greater than 8. POSIX requires that `CHAR_BIT` be exactly 8. Maybe spend some time with the POSIX rationale to understand why. **I didn't ask you for non-conforming programs, or an explanation of what non-conforming programs are**. Nice to see you understand, but it doesn't really respond to my requests. I hate to repeat myself, but it seems like you've missed this... &gt; **what I'm requesting is some example of an implementation-defined or undefined behaviour which you believe trivial strictly-conforming programs must rely upon, along-side one of the ten-line-toy programs you mentioned, ideally.** &gt; **along-side one of the ten-line-toy programs you mentioned, ideally.** &gt; **one of the ten-line-toy programs you mentioned** In this case it would seem I'm left to assume that you've got no such *ten-line-toy program* to provide. Based on your language and my psychological profile of you, I think perhaps you're stretching the truth a little bit...
&gt; Outside of memory limits, the concrete machine is for many purposes much more powerful than the abstract machine. Most of my work is with freestanding implementations, where the abstract machine has essentially no useful behaviors defined. The _abstract machine_ defines the entire language! Without the abstract machine, you have no standard C. You have none of the semantics behind operators for example... &gt; I've used not-quite-conforming C implementations on platforms with less than 100 bytes of RAM (code was stored in EPROM) which could control motors, lights, produce tones, etc. none of which the "abstract machine" can do. Of course... but how can you learn to program if you don't first learn to read and write some formally defined language (such as English)? Now, which one's more powerful? I recall a thread postulating the cost of building a computer from scratch, assuming _none_ of the collective knowledge of society... this would be necessary prior to implementing your own programming language, right? So, get to collecting and processing your ores to create semiconductors and so forth... all without relying upon the knowledge passed down to you by your _abstract language skills_ during early infancy... since that's all useless compared to a _concrete implementation_, right? You'll have to rely upon _trial and error_ to determine what a semiconductor is, how to use it to build a computer and so forth... hundreds of years of progress, down the drain! Who needs any semblance of turing completion?! After all... "the concrete machine is for many purposes much more powerful than the abstract machine"...
Ironically due to the way `ptr[index]` translates to `*(ptr + index)` it is also possible to cause a null pointer dereference that doesn't crash... The easiest way to do this is to look at it more like `index[ptr]` translating to `*(index + ptr)`. Then you can look at `index` in the first example as `ptr` in the second. i.e.: #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; int main(void) { char *null = NULL; uintptr_t index = (uintptr_t) "hello world"; printf("First letter of %s is %c\n", (char *) index, null[index]); }
We use it all the time. Is very useful. Would recommend.
I wonder if it's even worth reading this... if we can't agree that abstract language is more important than concrete implementation? I think maybe we're speaking different languages. Peace!
&gt; Okay, thanks for pointing out the error in publishing. I merely quote them; I don't make their documents. Maybe try quoting the actual C11 standard instead of a draft? &gt;Until I see an updated html file I can conveniently link into to cite, technically speaking, the array-decay exception (as you like to erroneously state) in fact does still exist, in at least some form Drafts aren't normative, you ignoramus. &gt;I didn't ask you for non-conforming programs, or an explanation of what non-conforming programs are. You were responding to a comment I made about non-strictly conforming programs that assume `CHAR_BIT` is 8 and suggested that I was confused for believing them to be non-strictly conforming. You then introduced the red herring about non-strictly conforming programs that assume `CHAR_BIT` is greater than 8. See, the difference between a bad language lawyer and a good language lawyer is that the latter has situational awareness and knows when to quote the standard. &gt;what I'm requesting is some example of an implementation-defined or undefined behaviour which you believe trivial strictly-conforming programs **must** rely upon See, there's your lack of precision again, my new buddy. Has your reading of the C11 draft not taught you about the importance of precise language? Note the bold in my comment and compare it with the bold in yours: ". . . and even then it's **often** possible to find some way in which the code fails to be strictly conforming." Do you want to be merely a good 'autist', or do you want to be an exceptional 'autist'? Meditate and then destroy. &gt;In this case it would seem I'm left to assume that you've got no such ten-line-toy program to provide. My goodness. Here's a free tip: Familiarize yourself with the comp.std.c newsgroup and its age-old pastime of tearing apart toy programs proposed as strictly conforming.
But you're not dereferencing `NULL` there, you're dereferncing `[0 + index]` which is completely valid
See the following links for an extensive discussion of problems and solutions: https://en.wikipedia.org/wiki/Dependency_hell https://en.wikipedia.org/wiki/DLL_Hell &gt;Am I correct thinking that if it the library were linked to a static library the symbol and also the assembler to run the symbol would be packed in the library file The problem with this is that the libraries you mention, zlib and libpng, are libraries you typically don't want linked statically unless you're prepared for annoying work whenever a bug is found in those libraries. Those libraries are frequently targeted by security researchers. For the same reason, you typically don't want to maintain them downstream as private shared libraries.
Thanks for all the tips and tools everyone. Would you need to have access to the source code for these to work? What if you just had the binary itself? So, say, there aren't any debug symbols as it wasn't compiled with -g. Would using these tools still work? I know Valgrind is pretty good with catching memory leaks but sometimes runs into issues with ignoring the crashes that use after free bugs cause (at least on MacOS anyway, it tends to just carry on running the program and then when you run it outside of Valgrind, it crashes normally)
So let's simplify this a bit. Say you've got this: shared static A----------B----------D1 \ ---------C----------D2 That is, an executable A with two shared libraries B and C, each of which have statically linked to some version of D. There's a couple of things that need to be kept in mind to make something like this work. First, all of D1's symbols need to be hidden in B (and similarly D2's symbols in C). B needs to call D1 functions directly, not indirectly through the PLT (or whatever the equivalent to that is for Windows binaries). This is really part of the standard symbol visibility hygiene you need when creating shared libraries more generally. Symbols that are only used internally to a library should be hidden so that they cannot be resolved by users of the library. If a symbol from D1 is kept visible in the B library, then B will _resolve_ that symbol at runtime. That means B may end up calling an identically named symbol in some other library... D2 say. Another thing you need to keep in mind is that any pointers to objects created by D1 must never accidentally get passed to C or D2. You don't want A to get some pointer to a D1 object (perhaps wrapped in a B object) then have that passed down to C.
&gt; First, all of D1's symbols need to be hidden in B (and similarly D2's symbols in C). Here's a quick demonstration of this. First, we create two versions of a static library: $ cat static.c #include &lt;stdio.h&gt; void f() { printf("%d\n", N); } $ gcc -DN=1 -fPIC -o static1.o -c static.c $ gcc -DN=2 -fPIC -o static2.o -c static.c $ ar -r libstatic1.a static1.o ar: creating libstatic1.a $ ar -r libstatic2.a static2.o ar: creating libstatic2.a The `f` function in each of them should print out `1` and `2` respectively. Next, we create two different shared libraries, each using one of these static libraries. $ cat shared.c void f(void); void call_f() { f(); } $ gcc -Dcall_f=call_f1 -fPIC -shared -o libshared1.so shared.c -Wl,-Bstatic libstatic1.a -Wl,-Bdynamic $ gcc -Dcall_f=call_f2 -fPIC -shared -o libshared2.so shared.c -Wl,-Bstatic libstatic2.a -Wl,-Bdynamic Each library should only call the function from its own static library. Finally, we create an executable using these two shared libraries: $ cat exe.c void call_f1(void); void call_f2(void); int main() { call_f1(); call_f2(); } $ gcc -Wl,--rpath=. -L. -lshared1 -lshared2 -o exe exe.c But when I run it, you'll see that everything has resolved to only the function in only one version of the static library: $ ./exe 1 1 If, however, I were to change the visibility of the `f` function in the two shared libraries, say by declaring `f` as follows: void __attribute__ ((visibility ("hidden"))) f(void); then it all works correctly: $ ./exe 1 2 In practice you wouldn't actually set visibility to be hidden on a per-symbol basis. It's a lot simpler if you set the linker's _default_ visibility to hidden, then only make visible the functions you want visible.
Operating systems in three easy pieces. http://pages.cs.wisc.edu/~remzi/OSTEP/ Look around Chapters 28/29 on synchronization &amp;&amp; locks.
I thank you for your [love bombing](https://en.wikipedia.org/wiki/Love_bombing) but note that this discussion is getting mighty one-sided and so... this is where I bow out to do more interesting things...
**Love bombing** Love bombing is an attempt to influence a person by demonstrations of attention and affection. It can be used in different ways and can be used for either a positive or negative purpose. Members of the Unification Church of the United States (who coined the expression) use it to convey a genuine expression of friendship, fellowship, interest, or concern. Critics of cults use the phrase with the implication that the "love" is feigned and that the practice is psychological manipulation in order to create a feeling of unity within the group against a society perceived as hostile. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
* [Futexes Are Tricky](https://www.akkadia.org/drepper/futex.pdf) (how to build an efficient mutex on Linux) * [ABA problem](https://en.wikipedia.org/wiki/ABA_problem) (common problem when implementing lock-free, wait-free, and synchrinozation primitives) * [Memory Reordering Caught in the Act](https://preshing.com/20120515/memory-reordering-caught-in-the-act/) (about memory reordering gotchas)
Green Tea press has a free book [The Little Semaphore Book](https://greenteapress.com/wp/semaphores/)
I've always liked these 2 books since they focus on abstract operating system concepts as a whole, rather than focus on specific OS's. They may seem old but abstract concepts do not age-out of existence! Operating Systems Principles Hardcover – Nov 21 2002 by Lubomir F. Bic (Author), Alan C. Shaw (Author) The Logical Design of Operating Systems Hardcover – Nov 1 1987 by Lubomir Bic (Author), Alan C. Shaw (Author)
1) It's not a *command*, but a *function*. A command is interpreted by preexisting software, while a function *is* software. 2) RTFM. Let's see what `man sleep(3)` has to say: Name sleep - sleep for the specified number of seconds Synopsis #include &lt;unistd.h&gt; unsigned int sleep(unsigned int seconds); Description sleep() makes the calling thread sleep until seconds seconds have elapsed or a signal arrives which is not ignored. Return Value Zero if the requested time has elapsed, or the number of seconds left to sleep, if the call was interrupted by a signal handler. Conforming to POSIX.1-2001. Bugs sleep() may be implemented using SIGALRM; mixing calls to alarm(2) and sleep() is a bad idea. Using longjmp(3) from a signal handler or modifying the handling of SIGALRM while sleeping will cause undefined results. See Also alarm(2), nanosleep(2), signal(2), signal(7) Referenced By aio(7), clock_nanosleep(2), getitimer(2), perlfaq5(1), pth(3), sleep(1), time(7), ualarm(3), upslog(8), usleep(3) ------- Right off the bat, we can see it's a POSIX feature, and its usage implies including `unistd.h`. The `sleep` call won't work unless you are on a POSIX-compatible system (Linux, etc.) Going further: Description sleep() makes the calling thread sleep until seconds seconds have elapsed or a signal arrives which is not ignored. If your program receives a signal, it will "wake up" and execution will either resume or halt, depending on the signal and program. ----- That's the basics of the sleep **function** in C. I hope it was clear enough, I did nothing but paraphrase an explanation you already had.
Have you got an example? Some code? At a guess, you're not copying the correct includes. Each operating system will have a completely different definition of sleep (it might even be called something different - I'm only familiar with Unix-based ones). Also, how are you compiling it? If you're using something like MinGW or Cygwin, which emulate a Unix environment, you want to use the Unix implementation of `sleep` in `unistd.h`. If you're using a native compiler like MSVC, you need to use whatever the Windows implementation is from the appropriate header file.
sleep() is different than Sleep(). sleep() takes a second param while Sleep() takes a millisecond param. In both cases your thread goes to sleep for **at least** the time specified, but almost always a bit longer than specified. What are you using it for?
I've learned a lot after reading this, thank you very much
Note that there are no commands in C. The `sleep` you mean is a *function*, not a *command.* There is also a `sleep` command on UNIX, but it's probably not what you mean. When talking about programming, it is very important to use the right terms or people have trouble understanding you.
In the standard C, the [`thrd_sleep()`](https://en.cppreference.com/w/c/thread/thrd_sleep) function (which suspends execution of the calling thread for a time) was introduced in [C11](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf). In windows, it's possible to use [`Sleep()`](https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-sleep), [`select()`](https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-select) (this is somewhat unintended usage), or other windows specific functions that include a timeout. I recommend carefully reading the documentation of the function you are using, and if still unsure about how to solve your issue, post a self contained example of the code that behaves in a way you do not expect it to.
thank you, I am using it for creating some tention in my game.
Hmm you probably do not want to use it in that way since it blocks your entire game from processing **anything**.
What would be a better funktion to use?
Thank you I will try to better my knowledge to use the correct words.
On POSIX, simply use `nanosleep()`.
Thank you for your cooperation. You are going to find that people are much more willing to help you if they understand what you mean.
&gt; The abstract machine defines the entire language! Without the abstract machine, you have no standard C. You have none of the semantics behind operators for example... It is necessary to use an "abstract machine" concept to some extent, to support things like 32-bit math on 8-bit processors. C was invented, however, as a language for programming *real* machines. In the language described by the 1974 C Reference Manual, there is a very tight coupling between language constructs and real-machine constructs. Many tasks require such coupling to some extent, but few require that it be absolutely rigid. &gt; Of course... but how can you learn to program if you don't first learn to read and write some formally defined language (such as English)? Now, which one's more powerful? The language described by the 1974 C Reference Manual could easily be adapted to be suitable for use on a modern processor like an ARM by adding signed and unsigned `char` and `short` types. Excluding cases where the stack overflows, one could fairly easily easily specify the behavior of calling the following `test` function: struct foo { unsigned short x,y,z; int w; }; int test(p, int v) struct foo *p; { p-&gt;w = v; } Take the passed-in pointer, add eight (there would need to be two bytes of padding before `w` since the ARM requires pointers to be four-byte aligned), and use a 32-bit store to write passed-in value to that address *with whatever consequences result from that action*. The compiler wouldn't need to know or care whether `p` held the address of a `struct foo`, nor what consequences might result from performing the indicated store. A programmer who knows the consequences of performing that store would know the consequences of calling the above function. The language described by the C Standard is, by contrast, much more complicated. There aren't any cases in which the Standard would require implementations to behave in a manner inconsistent with the above description (assuming they synchronizes the states of the real and abstract machines before and after doing so), but there are many cases where it would allow them to behave in arbitrary fashion. Since there is no consensus as to exactly in which cases implementations should be expected to behave in "C74" fashion, and in which cases they should be allowed to jump the rails, a precise description of when behavior is or isn't defined would be impossible unless one recognizes that the Standard makes no attempt to specify all the cases where implementations should behave in C74 fashion. Which is easier to learn: a language in which behaviors are defined in concrete terms, perhaps with a behavioral model that allows a cache between the real and concrete machines but forces synchronization in certain cases, or one in which actions might behave as in the former language, or might do something entirely different, based upon rules which mean different things to different people? A Turing machine may theoretically be more powerful than a Commodore 64, but the range of *practical* tasks one could do in a reasonable length of time with the latter is much greater than would be possible in a Turning machine which used a 257-symbol tape, had as many states as the 6502 processor (somewhat less than 1E20), and ran at 1.02 million operations per second (about the speed at which the Commodore's CPU can access memory, which is about 2-4 times its typical instruction rate).
Short version: Suppose all known implementations process a construct a certain way, but the Committee acknowledges the possibility that some other behavior might be useful on some conceivable platforms in some conceivable circumstances. Should the committee: 1. make the language less useful on that platform in those circumstances by mandating the common behavior? 2. weigh the possible costs and benefits of mandating the common behavior on platforms and in situations where some other behavior might be more useful, even though it has no idea what those platforms, situations, and alternative actions might be? 3. figure that the presence or absence of a mandate should only matter to people who are doing specialized things on obscure platforms, and that those people would be better placed that the Committee to weigh the costs and benefits of the common behavior versus alternatives. Note that at least one of the Committee's decisions (having short unsigned values promote as signed) is predicated upon the fact that on the even if the values promote to signed, they expected the vast majority of then-current implementations (and presumably future ones as well) to process constructs where promotion to unsigned would make more sense, such as: unsigned mul(unsigned short x, unsigned short y) { return x*y; } in a fashion equivalent to the more sensible `unsigned` promotion even in cases where the Standard would impose no requirements.
These are great! Thank you!
I'm not sure why there is a for loop. Why are you checking if sum==i ? Shouldn't you check if sum == origional_n
The question asked to calculate all the numbers that are palindrome from 1 to n. So, I think the for loop and sum==i is correct. So, I am kind of stuck on what to do.
You understand that your while loop is destroying n.
There are many problems with the code given. Probably a good method would be to create a function to check whether a number is palindrome or not and call that function in a loop.
Do you understand what your algorithm is doing? There is a flaw here. Once you understand what you are trying to achieve, you should be able to find your issue.
Ok thanks y 'all, I'll try that.
No worries, boss. The entire textbook is fantastic.
"final year" doesn't tell us anything. What was covered in your most recent curriculum?
I don't know if it would be the easiest to implement in C, since when we did it we were looking at object-oriented design, but when I was in college one of our finals projects was to make a simulation of a fish tank. Basically create a bunch of subprocesses that represented different thing in your tank that changed the environment or moved around in space. Was a really great example of what creative things you can do with computer programming with some very simple rules.
the curriculum covered almost everything, it could be related to ds,cn etc.
Ok, I still could not figure it out. This gives the same output. \#include &lt;stdio.h&gt; int f(int irep) { int r, sum=0; while(irep&gt;0) { r = irep % 10; sum = sum\*10 + r; irep = irep / 10; } } int main(void) { int i, number; scanf("%d", &amp;number); for(i=1;i&lt;=number;i++) { if(f(i)==i) { printf("%d\\n", number); } } &amp;#x200B; }
Your function f() doesn't return anything.
Thanks man
Wait guys. Now the input is just repeating. How can I fix it? \#include &lt;stdio.h&gt; int reversenumber(int irep) { int r, sum=0; while(irep&gt;0) { r = irep % 10; sum = sum\*10 + r; irep = irep / 10; } return sum; } int main(void) { int i, number; scanf("%d", &amp;number); for(i=1;i&lt;=number;i++) { if(reversenumber(i)==i) { printf("%d\\n", number); } } &amp;#x200B; }
In many embedded systems, one can cheaply guarantee consistent memory ordering at the hardware level either because there's only one core (in which case the cost is zero) or because one can assign cores to different tasks that are almost completely independent and communicate sufficiently seldom that the performance of "sledge-hammer" approaches (e.g. flush caches when communication is required, or configure shared regions of memory to be non-cacheable) may be acceptable, and in some cases even superior to that of more complicated approaches (if all threads that use a shared region of storage will be run on the same core, any time spent on inter-core synchronization when accessing that region will be wasted). &amp;#x200B; Unfortunately, the authors of the Standard failed to specify that implementations intended for various purposes should implement \`volatile\` semantics that are as strong as necessary to serve those purposes without requiring compiler-specific syntax. Implementations intended only for tasks like high-end number crunching that have relatively few needs shouldn't be required to implement semantics that are as strong as would be required for someone writing interrupt-based device drivers, but implementations intended for tasks that require stronger semantics shouldn't make \`volatile\` so weak as to be useless for such purposes.
What's your current level when it comes to basic syntax, i.e. do you know how to to write functions and do basic control logic?
This may make things worse. That might be okay; sometimes things get worse before they get better. The "|" character is a binary operator. It has two parameters. So int a = 4; int b = 8; int c = a|b; printf("c=%x %d\n",c,c) prints out "c=C 12" The "|" operator performs a bitwise or. If any bits int the two arguments are set, then they are set in the result.
In my time studying C I made two pretty cool projects. One was a minesweeper game and the other was a shell, where you could input commands, pipe the output from one to the other, run CRON jobs, that kind of thing. I also did some linear regression using various AI libraries that helped analyze very large datasets.
There are a couple GitHub repos that have them, if this is what you mean. [Here's one.] (https://github.com/rby90/Project-Based-Tutorials-in-C) [Here's another.](https://github.com/tuvtran/project-based-learning)
make a simple text-based 4X game!
What kind of projects do you want to do? Do you already know the basics of C? I just finished writing a book with many C networking projects in it (a program to do a DNS request, send an email, download a web page, a web server, etc).
[Art of Multiprocesser Programming](https://www.amazon.com/Art-Multiprocessor-Programming-Revised-Reprint/dp/0123973376)
I have been programming in python and Go for about two years now. Most writing http services so pretty familiar with the basics
anks
 I would love to read that book, is it published already?
 nb = 0; do { puts("Submit a number: "); scanf("%ld", &amp;nb); } while (nb &gt; 1000 || nb &lt; 0);
Dude, draw a tree describing the hierarchy, it's really confusing otherwise. Program | | | | | ABCDE etc
`do/while()` vs `while()` * `do/while()` you want to always do the loop at least once. You will always drop in and make 1 pass * `while()` (and `for()`) you may not drop into the loop at all if the condition isn't met initially.
Your scanf doesn't consume the newline the user typed. You would have noticed there was a problem if you had taken the return value of scanf.
A do while loop might not be suited for your task, since it will execute at least once.
&gt;printf("%d\\n", number); You are always printing number
THANKS, compiling now! :)))))
The way I like to do input validation with a do/while loop is put the prompt/input statement in the loop and use a flag to control the loop: &amp;#x200B; int flag = 1; int i; &amp;#x200B; do { printf("Please enter a number between 1 and 10: \\n"); scanf(%d, &amp;i); &amp;#x200B; if( i &lt; 1 || i &gt; 10) { printf("Error: the number must be between 1 and 10\\n"); } else { printf("Thank you for the valid input\\"); flag = 0; } } while(flag);
Wow. Thank you so much for this link! Amazing resource, I wish I knew about it earlier.
It is absolutely not a problem, nor the problem. OP is using a ```do/while``` instead of a ```while/do```, so he reads the number twice (once before the loop, and one in the first iteration).
OO doesn’t make that problem easier or more difficult, it just makes the solution different.
sorry arent that good in reddit markdown, just a casual question
Would live to read it as well
thank you
thank you
thank you
Your book sounds cool
Sounds like smtg I would definitely read
[Build Your Own Text Editor](https://viewsourcecode.org/snaptoken/kilo/)
four spaces to make a code block. ```` to make a single line of code.
 わからない
I see you spamming the same question on /r/Clojure, /r/erlang (and quite possibly others) - are you trying to aggregate some sort of resource?
Well, the problem is that most C books/tutorials aimed at beginners don't stray from ISO C -- and they shouldn't -- but ISO C doesn't really allow sexy projects. Compare with a book such as *Head First Java*, where the beginner works up to a networked music-beats program with a GUI. With ISO C, the closest you can get to sexy is probably the world's millionth DS&amp;A library or some crypto code.
I think you're looking into it too much...
I noticed OP same post in /r/java as well. OP is really up to something.
As I was looking back over the code, what does sizeof(int) do? I know it returns the size of the value, but do I have to do anything about having the semi-colon and commas?
`isdigit` from `&lt;ctype.h&gt;` or use `scanf`from `&lt;stdio.h&gt;`
i've seen this code in the internet int input, temp, status; printf("Please enter a number: "); status = scanf("%d", &amp;input); while(status!=1){ while((temp=getchar()) != EOF &amp;&amp; temp != '\n'); printf("Invalid input... please enter a number: "); status = scanf("%d", &amp;input); } printf("Your number is %d\n",input); can you explain to me how this work?
How is the HWND struct defined?
Yeah it was word for word. Oh well.
 DECLARE_HANDLE (HWND); DECLARE_HANDLE is defined as. #if 0 &amp;&amp; (_MSC_VER &gt; 1000) #define DECLARE_HANDLE(name) struct name##__; typedef struct name##__ *name #else #define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name #endif
Try using the (.) member access operator to access member int unused instead of (-&gt;)
Since HWND is defined as a pointer to struct HWND__, if have to use arrow operator.
One more! for (;;) { printf("Enter a number between 0 and 1000: "); fflush(stdout); char line[100], junk; if (fgets(line, sizeof (line), stdin) == NULL) abort(); if (sscanf(line, "%d %c", &amp;input, &amp;junk) == 1 &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 1000) break; printf("Try again. "); }
Yeah I figured...I’d need to take a look your error output. Seems like what you’ve done should work as intended, although I’m not a fan of how you’ve defined your struct through a macro...messy and hard to follow.
That's a Microsoft-designed `struct`.
Its actually windows api. I'm trying to learn the internals of by trial and error. There is no error. The console opens, does not display any output and exits.
Sounds like hwnd isn’t always found; but either so, you shouldn’t really be trying to access members of hwnd as it’s just an abstract handle to a window. Plus why care about ‘unused’ sounds like it’s not used.
I'm trying to learn the internals of the windows api.
Might be hard unless you work for Microsoft to learn that.
`-std=c89` means you want ANSI compliance, not POSIX compliance. If you use `-std=gnu89` you'll get GNU extensions including POSIX. BTW unless you are on some antique system then use the latest standard (`c17` or `gnu17`). If you want ISO and POSIX compliance without GNU extensions then I believe the correct method with gcc is to use `-std=c11` (or whatever other ISO flag) and also [indicate via commandline switch which version of POSIX to support](http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html), for example compile with `-D_POSIX_C_SOURCE=200809L`.
Using `-std=cX` is almost always a bad idea, IMO. There will always be some edge cases where a particular system is noncompliant regardless. Better to just compile on the systems you wish to support and use whatever features are available. If you're writing a tool that just processes files with simple standard C I/O it might make sense, but otherwise it's just extra work.
the EUR/USD is now at 1.1330, what will it's price be in two minutes/days/weeks/months?
&gt; And then there is WSL that can run linux-native binaries. AFAIK you can download a Linux distro in the Windows 10 store (Called like Ubuntu, Fedora, ...) and then you can use it, but the windows-integration might not be as great as Cygwin/MSYS2. WSL is probably the easiest and best way to go about this for a student. This is the method I recommend. Just remember to keep your .c files in `/mnt/c/Users/your_user/Documents/c` or something similar so you can easily access them from Windows and use a native Windows editor. You also don't need to know much about Linux to use this command line, you just need to know how to change directories, run GCC, and run your programs after they're compiled.
instead of using that do/while stuff, just use a generic for(;;); block.. this, for example, is an endless loop: for(;;); unless i am mistaken, lol.. you can always use a bare for loop, like this, and you can put if statements anywhere into said for loop, like this: for(;;) { if(blablabla) break; //code here.. if(yadayada) continue; if(boinkyboinky) break; continue; break; }//end of for loop
Handles are just opaque pointers. That they appear to point to a struct with an int inside is an implementation detail, but that struct does not actually exist.
Hmm. This could be the reason why unused can't be read.
and /r/fsharp certainly some shenanigans going on.
Sizeof is a macro and on compilation the compiler will calculate the value of Sizeof(int), in that case 2 and insert it. You could put in 2 yourself there but then nobody knows "why did he put a two here" with sizeof you know that it's for defining the size of the input that you gonna use.
Sizeof is a macro and on compilation the compiler will calculate the value of Sizeof(int), in that case 4 and insert it. You could put in 4 yourself there but then nobody knows "why did he put a two here" with sizeof you know that it's for defining the size of the input that you gonna use. Also you'd don't need a semicolon because a semicolon would end the expression right there and then do the next thing, but you want to evaluate all the parameters first, then the expression and then move on to the next line. I hope that makes sense
Give it a couple of days and **bamm** new article released on Medium: “Here’s a list of project-based tutorials for each modern programming language just to get you started”.
`scanf` has a return value, it returns the number of substitutions it has successfully performed. So if you have something like `scanf("%s %f %d", str, &amp;dbl, &amp;num` and it returns 2, that means it has managed to read `str` and `dbl`, the first 2 conversions, but not `num`, which is the third. One of the cases when this happens is when the input is expected to be an integer, but is something else like a letter. You can use this return value to detect if something went wrong and handle the situation. See [man scanf(3)](https://linux.die.net/man/3/scanf) for more information.
I guess looking for people to submit resources so he can create content for his site? I don't mind the concept as it's generally not a bad thing to have someone go through validate and add more diagrams and descriptions for good tutorials, I just hope he provides a link back and sufficient credit to the tutorials he uses.
You can use `strtod()` for example. Remember to check the `endptr`.
What does the processing from negative to positive depends on?
Hey there, if you mean how the function works, it does this: \- check the array you just populated (X) to be sure its not made with the same element repeated 10 times; \- if its not than the function picks the number before the Max number in the array (lets call it N) ( so i.e. if a\[3\] = {1,4,7} it picks 4, but if a\[3\] ={5, 5, 5} it picks none); \- then it puts this number (N) into the first cell of the initial array (Y, the one made by -1, -1, etc) The function seems to work in the first iteration, but then instead of putting the elements in the other slot of Y, (so y\[1\],y\[2\],etc.) it keeps replacing the first item. The debugger showed me that the variable "j" - the one that controls the array Y - its incrementing correctly, so it should be another minor problem somewhere. If this was not the question let me know, so I can clarify more! Thank you for your time :)
I know it looks like a spam but I am on a sixth months vacation and I thought about learning multiple languages by doing 1-2 projects every week for no particular reason just curious and I have a lot of time on my hands. I am not going to use these to write some medium article, its only for my personal use although I might add some of these links to a github repo that lists such resources, if I do then I will give credit to the particular reddit user who provided that link.
I don't have a site.
don't have a medium account and hate medium ever since they recently introduced that paywall.
&gt; for example compile with `-D_POSIX_C_SOURCE=200809L`. While you *could* pass it as an argument to the compiler, note that the very page you linked says: &gt; You should define these macros by using `#define` preprocessor &gt; directives at the top of your source code files. That's the better way to do it since it keeps the feature test macro usage close to the source that needs it. #define _POSIX_C_SOURCE 200809L #include &lt;stdio.h&gt; /* ... */ (An issue I've had: Feature test macros in Solaris and its derivatives (illumos, etc.) are completely broken, and using `_POSIX_C_SOURCE` will actually have the opposite effect of actually *hiding* `getline(3)`.)
Hey. I'm sorry but I can't fully understand what are you trying to achieve. Let me put it this way I as try to figure out what you need: 1. You got array of integers (array\_y\[n\]) which is pre-filled with -1s and 1s ? or filled by user on some condition? 2. You need to enter values into array of integers(array\_x\[n\]) and send it to a function. 3. Iterate through the array\_x and find the largest value 4. After you find the largest value pick the previous number of the largest value? 5. Store the previous largest number in array\_y on position \[n+1\] This is all I understood so far, so I'm little confused. Try explaining step by step what the user needs to input, and what the program needs to output.
Note that the C standard used in POSIX is C99, so it's not a bad idea to work with that.
&gt; (An issue I've had: Feature test macros in Solaris and its derivatives (illumos, etc.) are completely broken, and using _POSIX_C_SOURCE will actually have the opposite effect of actually hiding getline(3).) I think that's because they do not actually support the POSIX revision where `getline` was introduced.
The headers just expose the interface. You'll find that the implementation is completely closed source.
Ok playing with the code a bit it appears to be working to fill the Y array completely but not with the value you are expecting. Say you enter the following sequence of numbers into the input 1 2 3 4 5 1 2 3 4 6 first thing that happens is your sort routine orders them as such 6 5 4 4 3 3 2 2 1 1 then you send that array into the PrimaDelMassimo routine to determine the value that should be the number before max, or in this case the value should be 5 (6 being max). However, the routine doesn't actually determine the correct value. int i, flag_uguali=0; for(i=0;i&lt;dim-1;i++) { if(a[i]==a[i+1]) flag_uguali++; } First, the function runs through the list of numbers to see if all are the same. In this case, **flag_uguali** will have the value of 4 so they don't all match. Then, you have this to do the return: if(flag_uguali==dim) *b=-1; else *b=a[dim-1]; Because the flag isn't equal to 10 it simply returns the last item in the list. Because your sort routine is sorting highest to lowest, it is return the value of 1 in my case. Then that is used to fill the Y array and I get the final result of Il vettore Y ora vale:|1||1||1||1||1||1||1||1||1||1| This is exactly what I expect to see. Now if your intention was to get the value of 5 then what you likely want to do is alter the routine as to do something like this: void PrimaDelMassimo(int a[dim], int *b) { int i, flag_uguali=0; *b = -1; for(i=0;i&lt;dim-1;i++) { if(a[i]==a[i+1]) flag_uguali++; else { *b = a[i+1]; break; } } } Then you get the result Il vettore Y ora vale:|5||5||5||5||5||5||5||5||5||5| The reason this works, because you have sorted from highest to lowest, as soon as you hit your first comparison that does not match you know you have the *next to max* value, you can stop looping at that point and return that value. Hope I understood the problem correctly.
First of all, your assignment says that you have to create a PrimaDelMassimo function that given an array finds the second largest number at writes it to a pointer. You are trying to write PrimaDelMassimo so it only works on a sorted array. This is not what is asked. If you want to use sort, do it inside PrimaDelMassimo. Second, you are putting the first risultato into all of y. I think you only want to put it into the first position. If I was you, I would focus on getting PrimaDelMassimo to work first by trying it out on different arrays to see if you get the right thing back. After you have done that, you can work on getting the loop to work.
1) Correct, the first array (Y) is autofilled with "-1" 2) Another int array (X) is filled by user, then this array is a parameter for the function 3) The function iterates trought the array and, unless and: \- if X has the same value repeated 10 times (like X = 5, 5, 5, etc. , 5) it writes "-1" into Y\[0\] \- else it writes in Y\[0\] the value of X that is before the max value - that's why I tought sorting the array with another function, so in our case X\[dim=10\] we have max --&gt; x\[dim-1=9\] and pre-max --&gt; x\[dim- 2=8\]. 4) repeats point 2&amp;3 till the entire array Y is filled with positive numbers;
Thank you very much, that logic you put into the function makes it way more functional, appreciate that a lot! But I'm not sure I've adressed the issue I'm having with the whole request, let me try to rephrase it. The point is that the function has to do the job you described, so, give the X array filled by user, it fetchs the highest value (that is not the max) of the array and it puts it into the first cell of Y. So, for example: x\[3\], y\[3\] 1st Application: X = {3, 8, 21}, Y = {-1, -1, -1} --&gt; function(x, &amp;result) --&gt; Y = { 8, -1, -1} --&gt; flag (that checks if Y is full of positives values) = 0; then it should do it again, with a new X array (always insert by the user) 2nd Application: X = {1, 28, 50}, Y = {8, -1, -1} --&gt; function(x, &amp;result) --&gt; Y = { 8, 28, -1} --&gt; flag = 0; and again 3rd Application: X = {65, 51, 70}, Y = {8, 28, -1} --&gt; function(x, &amp;result) --&gt; Y = { 8, 28, 51} --&gt; flag = 1 --&gt; program ends. &amp;#x200B; But what happens to me is that I get: 1st Application: X = {3, 8, 21}, Y = {-1, -1, -1} --&gt; function(x, &amp;result) --&gt; Y = { 8, -1, -1} --&gt; flag (that checks if Y is full of positives values) = 0; (fine) 2nd Application: X = {1, 28, 50}, Y = {?, ?, ?} --&gt; function(x, &amp;result) --&gt; Y = { 28, -1, -1} --&gt; flag = 0; (Here is the issue). Hope I explained myself better, and thank you a lot for the time you dedicated to me :)
how about the line while((temp=getchar()) != EOF &amp;&amp; temp != '\n');
That's true, I tried to cheese the exercise a bit doing the sort thing; your point is valid, could be considered not correct if the assignemet does not explicity to sort the array, and I can just let the function itself do it without resorting to another function. I'll take a look at the examples you posted, thank you very much for the time you dedicated to me. Enjoy your sunday :)
Ok that gives a bit more clarity. Where this is falling down is inside your while loop, after getting the 2nd to largest max value from the input list you are doing this: if(risultato&gt;0) { for(j=0;j&lt;dim;) { y[j]=risultato; j++; } } which means on your first loop you are filling the entire Y array with the first value. That is causing the next check condition for(i=0;i&lt;dim;i++) { if(y[i]&gt;0) flag_tuttipositivi++; } to always have the value of *dim*. I think what you need to do when setting the Y array value with the max number is something like this: if(risultato&gt;0) { for(j=0;j&lt;dim;) { if(y[j] == -1 ) { y[j] = risultato; break; } j++; } } So it stops adding to the Y array.
I can't belive I was that blind!! Thank you very much! Basically I was putting the whole Y\[j\]=value into a for loop that ofc bugged the whole thing! Now I see why I mislead you! That for loop means that each of Y's element is set = to the PrimaDelMassimo result! Well have a nice day and thank you again!!
This is a loop with an empty body, meaning the only code getting executed is the condition check. The loop extracts characters from the input stream until it reaches either the end of the stream or a newline character (created by pressing enter).
Don't use a pointer cast to read integers like this: int buffer_read_uint32(buffer_iterator_t *buffer_iterator, uint32_t *value) { /* ... */ *value = *(uint32_t*)(buffer_iterator-&gt;buffer-&gt;data + buffer_iterator-&gt;offset); buffer_iterator-&gt;offset += 4; return 0; } It's generally going to be undefined behavior. Even in the best case the behavior will differ between platforms, depending on the host's byte order. The correct way to parse these values is to [read them one byte at a time and assemble the value manually](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html). /* Note: reads as little endian */ int buffer_read_uint32(buffer_iterator_t *it, unsigned long *v) { /* ... assertions ... */ buffer_t *b = it-&gt;buffer; *value = (unsinged long)b-&gt;data[3] &lt;&lt; 24 | (unsinged long)b-&gt;data[2] &lt;&lt; 16 | (unsinged long)b-&gt;data[1] &lt;&lt; 8 | (unsinged long)b-&gt;data[0] &lt;&lt; 0; return 0; } This works correctly across all platforms, guaranteed, and I didn't even need to use a fixed-sized integer.
Thanks. :D
Made an issue. Calls to `malloc` are not checked for a `NULL` pointer return. Although `malloc` is not likely to fail on a large system with plenty of memory, in an embedded space `malloc` can and will fail on systems that run out of resources, so such cases need to be handled. Strictly speaking, this library may exhibit undefined behavior.
Simple question first. What did you use to create the input file.
That's a horribly inefficient way to byte swap, just use `endian.h` or the Windows/OSX equivalents. Googling "portable endian.h" pulls up a few million hits
That's [the byte order fallacy](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html) that I had linked. "Byte swapping" is the wrong way to tackle this problem and is completely unnecessary. It's not "horribly inefficient." Modern compilers [produce exactly what you'd want](https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:___c,source:'void%0Astore_u32be(unsigned+char+*p,+unsigned+long+x\)%0A%7B%0A++++p%5B0%5D+%3D+x+%3E%3E+24%3B%0A++++p%5B1%5D+%3D+x+%3E%3E+16%3B%0A++++p%5B2%5D+%3D+x+%3E%3E++8%3B%0A++++p%5B3%5D+%3D+x+%3E%3E++0%3B%0A%7D%0A%0Avoid%0Astore_u32le(unsigned+char+*p,+unsigned+long+x\)%0A%7B%0A++++p%5B0%5D+%3D+x+%3E%3E++0%3B%0A++++p%5B1%5D+%3D+x+%3E%3E++8%3B%0A++++p%5B2%5D+%3D+x+%3E%3E+16%3B%0A++++p%5B3%5D+%3D+x+%3E%3E+24%3B%0A%7D%0A'\),l:'5',n:'0',o:'C+source+%231',t:'0'\)\),k:50,l:'4',n:'0',o:'',s:0,t:'0'\),(g:!((h:compiler,i:(compiler:cg83,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'\),lang:___c,libs:!(\),options:'-Os',source:1\),l:'5',n:'0',o:'x86-64+gcc+8.3+(Editor+%231,+Compiler+%231\)+C',t:'0'\)\),k:50,l:'4',n:'0',o:'',s:0,t:'0'\)\),l:'2',n:'0',o:'',t:'0'\)\),version:4).
A second opinion: What you really should do if you're concerned about byte ordering in a buffer is abstract the reading into a set of inline functions. Don't do it inline as shown above, because that's just error-prone and confusing. Additionally, if performance is important, you're going to *definitely* want two versions of the reading function: one that reads the bytes in native order and one that reverses the byte ordering. If you need speed, by all means ***do*** use #if directives that ask whether you're running on a big-endian or little-endian system. In practice, it is actually perfectly safe to have endian-specific versions as long as you can trust your compiler to tell you the truth, or as long as you trust yourself to set the manifest constants properly at build-time. You can even add startup code that detects in on-the-fly by loading a uint32\_t value 0x12345678 from static memory and seeing if the result is 0x12345678 or 0x78563412. If you're writing a library that absolutely positively has to be as portable as possible, then have a third version (slow version) of each read/write function that makes no assumptions about byte ordering.
No, this is all wrong. &gt; if performance is important, you're going to definitely want two versions of the reading function ... then have a third version (slow version) What I wrote is not only correct, it's *perfectly optimal*: [Godbolt link](https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:___c,source:'unsigned+long%0Aload_u32le(unsigned+char+*p\)%0A%7B%0A++++return+(unsigned+long\)p%5B3%5D+%3C%3C+24+%7C%0A+++++++++++(unsigned+long\)p%5B2%5D+%3C%3C+16+%7C%0A+++++++++++(unsigned+long\)p%5B1%5D+%3C%3C++8+%7C%0A+++++++++++(unsigned+long\)p%5B0%5D+%3C%3C++0%3B%0A%7D%0A'\),l:'5',n:'0',o:'C+source+%231',t:'0'\)\),k:50,l:'4',n:'0',o:'',s:0,t:'0'\),(g:!((h:compiler,i:(compiler:cg83,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'\),lang:___c,libs:!(\),options:'-Os',source:1\),l:'5',n:'0',o:'x86-64+gcc+8.3+(Editor+%231,+Compiler+%231\)+C',t:'0'\)\),k:50,l:'4',n:'0',o:'',s:0,t:'0'\)\),l:'2',n:'0',o:'',t:'0'\)\),version:4) Messing around with `#if` is [the byte order fallacy](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html). Not only is "byte swapping" wrong, it's not even necessary for optimization. Stop telling people to do things the wrong way.
That should probably say `uint32_t` everywhere that it says `unsigned long`.
No need for fixed-with integers here. `unsigned long` is guaranteed to be at least 32 bits which is perfectly sufficient.
Not necessary, but would still be clearer as `uint32_t`, IMHO.
That's pretty awesome. :)
gcc 8+ is literally the only compiler that does that optimization, clang, msvc, and icc all screw it up. Far, far from all "modern compilers" produce exactly what you want. Use `endian.h` and its compatriots, it's literally what they're there for.
So it's a ripoff of my BitIO? So impressive.
so use `uint_least32_t` then so that it's fucking readable.
What the hell are you talking about? I don't even know what BitIO is.....?????
Thanks for the input :D
Here's a few comments I'd make if I were asked to do a code review: buffer\_init\_data(): I'd use calloc() instead of malloc(), the difference is negligible and it'll save you the memset() call after. buffer\_set\_data(): You're copying data to buffer-&gt;data without checking the size first. This is a potential buffer overflow. buffer\_set\_size(): This should be done only when also setting the data buffer. A user of the lib could get the buffer and size variable out of sync with each other. buffer\_set\_offset(): Bounds check it to make sure it's a valid value. buffer\_clear(): I wouldn't free the data, memset it to 0 instead. The action of freeing is different than clearing in the function name. buffer\_realloc(): This doesn't work how a caller would expect it to work. If the new size is smaller it does nothing and returns an error?! If it requests bigger, it grows it by that much instead of realloc'ing to that actual size. If you're going to use the realloc name like the lib function, match it's behaviour. buffer\_write(): It shouldn't be calling realloc like that. Create a new helper function to get the space left in the buffer (buffer\_get\_space() maybe) to check if there's room, then realloc if not. i see you have buffer\_get\_remaining\_size(). That belongs in buffer.c since it has nothing to do with the iterator. buffer\_write\_###(): Use sizeof() instead of hardcoded values of 1, 2, 4, 8. It's more portable.
As per the documentation, `LINES` is given a value by the call to `initscr()` so your code is bugged to try and refer to that value before said call. Also you probably didn't want to modify LINES (instead set `bottomWinPos` to `LINES - 1`).
I see you deleted your post. Don't do this. By deleting your post, you deny the answers we gave you to all future people who are now unable to find it. That's a really shitty thing to do. Do not delete your post after receiving an answer.
Also, make sure to not delete this post either.
That worked thank you very much! Good looking out on the LINES - 1. I assumed LINES-- would work the same as LINES -1 not modify LINES as a whole.
Snake_case REEEEEEEEEEE
Side note. the call to refresh(); was unnecessary. It would update stdscr and overwrite the boxes. At least that's my understanding.
[http://www.cs.kent.edu/\~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf](http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf)
yeah that is how i'm printing it
yeah, just realised I interpreted the exercise incorrectly... am going to rewrite it
Ok, so I have found a possible workaround but it very well might be excessively difficult. My workaround is instead of using a raspberry pi as a pass-through I just skip straight to my computer. But, that in and of itself becomes a whole different problem. To make that work, I would run the C program on my computer, but then the other problem arises of how to I get data from the program to become joystick data. Now, it does have to be a true joystick, it just has to be in a way to interact with programs such as video games or solidworks. Any ideas?
What you are describing is a driver. Nowadays they are installed automatically but you can write your own for a piece of hardware and change its behavior.
That sounds excessively complicated. The way my program worked (and how I assume many programs work) is that it basically stacked over top of the driver. Right now I am having some difficulty finding said driver. But how would you recommend as my next step?
&gt; The way my program worked (and how I assume many programs work) is that it basically stacked over top of the driver. But someone had to write those drivers, right? Don't get me wrong, writing a driver in not an easy job. If you'd like to refrain doing so, you are well within your rights. I just think that anyhing that concerns a hardware's functions should be a driver and shouldn't be inside a user software. If you ask my advice, focus on your previous method, finish and then try to improve on that. Driver development is a subject gigantic on it's own. Delving into that might drive you away from your original goal.
I'd really like to know why you are being down voted.
What is the question?
My way was counting the spaces and hashmarks, and trying to find a pattern in relation to the number of the row. If it's not that obvious for you, or the pattern is more complex I would recommend to start writing it down on a paper for example like this: n-th row | x #-s | y spaces | ... After this try to find a pattern, like x is always equal to n, y is always 10-n. Or there are n spaces, after that 3 #-s. But don't forget, that there are situations when you have to break it into groups of lines.
Use for loops to produce that pattern
I will assume that you are asking for the basics, not for optimizations. Try to think how you can describe these patterns algorithmic. Look at e.g. the X pattern and think about how the placement of '#' changes as you move around in the X- and Y-axis. You will essentially have two for-loops: for(int x = 0; x &lt; 18; x++) { for(int y = 0; y &lt; 9; y++) { if(somecondition){ //This/these conditions should describe the pattern printf('#'); }else{ printf(' '); } printf("\n\r"); }
Either `type` or `typedef` on a case by case basis. ASAE: typedef struct vec3d_t vec3d_t; struct vec3d_t __attribute__((packed)) { double x; double y; double z; }
It means that a typedef has been used, so you don’t need to use struct too, when accessing the type.
Start simple, work incrementally. Manually print the first five lines. Then look for a pattern, try and make those five lines the same code. Then add your loop. Then try and make the loop build the full picture. If you get stuck on a line not looking right, end the loop just before and do that line manually. Repeat, etc. It is a mistake when you are learning to try and jump directly to the final solution. You need to work your way towards it, slowly, incrementally. You will stumble along the way, but you will always be moving and progressing.
For better or worse... I tend to append "\_t" to my own types (anything but classes) just so that I know it's a type. e.g., vector\_t, matrix\_t, etc.
I'm so messy when writing code that I need to write ts, te, ta and tp to differentiate between struct, enum, array and pointer types.
Never do this on a POSIX/Unix/Linux system. “_t” is a reserved namespace by POSIX for the system at all times. [https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html](https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html)
So the answers already been given but they only work for small patterns like this. If you want to know how to do these correctly every time regardless of the size? Look up how to create a truth table. These outputs are simple n-bit truth table functions which when put into a karnaugh map will give you an optimized and or scheme for programming it. On the left side order each row decending from 0000 and the right is the expected full output of the row. Each right side column can just be named with a letter: a, b, c...
Very interesting! I learned something :) Thank you!
question: why are you putting a parenthesis around the return value? is it your personal style or is it one of the many styles out there?
None of the other answers have touched on the *reason* for `_t`, just when you'd normally see it. That suffix means "type", as in the name describes a *type* rather than something else. Why does this matter? Because variable names can mask types: typedef long size; size size; size count; // error It's very common to have a variable named `size` but not `size_t`, which by convention names a type. This is why some programmers either capitalize all type names (including class names in C++), or they instead capitalize all variable names. It puts them in a different namespace so they don't conflict.
You’re welcome! It’s an extremely common mistake. Programmers see the system using it all the time and think it’s a good idea for their own code too not realizing it’s a reserved namespace. Some programmers don’t even realize that there are reserved namespaces. That’s where I get to show them POSIX and the C and C++ ISO standards and how they work.
My personal style.
Sorry to be a pain with my questions, but what is the reasoning, please?
I think it looks cleaner
Fair enough. Thank you.
It seems perfectly fine to me. Why would you think it is UB?
This is known as a compound literal and I'm fairly sure it's valid in C99
I'm more used to C89 than C99 and up.
Ok. Why is it UB in C89?
There was no compound literals in C89. But I was confused by the dereferencing the structure part.
As an addendum, unfortunately this is but one of multiple conflicting conventions of naming variables, types, functions, classes, constants and macros. So for instance in C++ many libraries use CamelCase for their class/struct types, but the standard library uses snake_case for everything. And in plain C you have non-postfixed int, float,... while posix goes for the mentioned '_t' postfix. MPI's functions are all in CAPS_CASE whereas in many other places, only macros are written that way.
Ah right. Yeah dereferencing the struct is fine. It's no different to having a local variable followed be assignment.
Type
The problem is that your functions, `initializeMagicSq` and `printMagicSq`, don't know the dimensions so they can't treat their `magicsq` argument as a 2D array. Specifically, they don't know the number of columns. I know, "but I'm passing that info in as `sides`". True, but the functions just see `sides` as some int - they have no idea of its significance. In C99 there's a way to do what you want by taking advantage of VLAs: Try changing your function signatures: void initializeMagicSq(int sides, int magicsq[sides][sides]) void printMagicSq(int sides, int magicsq[sides][sides])
An array in C decays to a pointer to the first entry in that array when passed to a function. Therefore, "int x\[n\];" passed to a function becomes "int \*". This only occurs for the first dimension of a multiple dimension array. That means that "int x\[n\]\[n\];" passed to a function becomes "int (\*)\[n\]". What you told your functions to accept was "int \*\*", which is a pointer to a pointer, or an array of pointers to integers. You should change your functions to accept an "int \*" and then dynamically allocate your 2d array like this: [https://www.tutorialspoint.com/how-to-dynamically-allocate-a-2d-array-in-c](https://www.tutorialspoint.com/how-to-dynamically-allocate-a-2d-array-in-c).
Oh damn, I didn't know that. Will do some more research on VLAs. Thanks gang gang!
Oh I see I see. Will read the article you have referenced, thanks a lot.
There's a reason there's multiple pointer types: to discern the types of values at those addresses. So it really depends on what the type of the value is at address `ADDR_ONE_VAR`. All pointer types have the same size (usually), the type they point to don't matter to the pointer itself.
Okay thanks! So I guess if that address holds a value of type uint8, then I should be using uint8\*
I used MPI-3 recently and all the functions were "descending case", i.e. MPI_Comm_rank(). I also saw caps versions so I'm guessing there are a bunch of defines somewhere.
I didn't look at that link closely before posting. Personally I hate the index math of using just an int *. You can malloc an int** similarly.
`uint32_t`, I assume? And usually putting the `*` next to the referent type is a bad idea; it’s a C++ stylistic tradition that wasn’t thought through properly. E.g., int* x, y; does not declare two `int *`s, whereas int *x, *y; does. &gt; Does it matter what type to be using? Yes; the pointed-to type should (hopefully) be the kind of thing you’re referring to in memory. If it’s `uint32_t`s, then you should be using a `uint32_t *`. If it’s bytes, you can just use a `unsigned char *` or something along those lines. &gt; I saw that the address of a variable was assigned to a char*, which would also be 4 bytes on a 32-bit machine Maybe. It could also be six bytes (IA-32 supports 48-bit pointers), or 2 bytes (if a narrower ABI is in use, like x32 for x86-64). But the width of the pointer itself is mostly irrelevant. &gt; Moreover, why would you want to use a char* instead of a uint32* or even uint8*? You can cast an integer to any type of pointer. (In C++ this’d be done via `reinterpret_cast`.) I recommend only casting from ints to/from `void *` or `char *` for a couple reasons. First, `void *` and `char *` may (theoretically) be wider than other pointer types; e.g., an ABI may have `int *`s occupying fewer bits/bytes because of the required alignment of `int`. `void *` and `char *` can also freely alias anything unless they’re `void *restrict` or `char *restrict`. Once you’ve casted to a `char *` or `void *`, then you can safely cast to `uint32_t *` or whatever. `uint8_t` may or may not exist on all systems, and this is true of all `uintX_t` and `intX_t` types; the (`u`)`int_leastX_t` types are guaranteed to exist for `X` ≤ 32, however. `uint8_t` may or may not be the same as `unsigned char` or `char`; therefore `uint8_t *` won’t necessarily behave the same as a `char *` or `void *` in terms of aliasing. So again, cast through `void *` or `char *`, rather than directly to/from other pointer types. Note that the size and alignment of the pointer type (e.g., `char *` or `uint32_t *`) is entirely independent of the pointed-to type (`char` or `uint32_t`). The only rerquirements from the C standards are sizeof(void *) &gt;= sizeof(uint32_t *) &amp;&amp; _Alignof(void *) &gt;= _Alignof(uint32_t *) *Usually* `sizeof(void *) == sizeof(T *)` for any `T` (ditto `_Alignof`), but that’s not necessarily/always the case. &gt; Is this dependent on what that the memory location holds? Yes? The pointed-to type is what the pointer points to, which is what the memory location holds. If you’re using a `uint32_t *`, hopefully the memory you’re referring to can be treated as an array of zero or more `uint32_t`s. &gt; And would a uint32* and uint8* use the same amount of space? Usually, but not necessarily. Some platforms impose alignment requirements on all accesses (x86 *can* but usually doesn’t), so if you’re accessing a `uint32_t`, it must be aligned to a 4-byte boundary; `uint8_t` needn’t be aligned. This means that for a `uint32_t *`, the bottom two bits are always zero, which means that some exotic architecture could use a narrower `uint32_t *` than `uint8_t *`. (Alternatively, the exotic architecture may also make use of those bottom two bits.) &gt; If so, when would you use uint32* vs uint8*? Again, it depends on what you’re accessing. If you’re referring to an `int[]`, then you’d use an `int *`. Ditto for `uintX_t[]`. Slightly off-topic, but usually when you’re reinterpreting an integer as a pointer, it’s for some MMIO or other interface where the specific reads and writes that are performed matter. (As opposed to normal memory, where you can get rid of unneeded accesses without anybody caring.) For that sort of purpose, usually you want a `volatile T *`, so the compiler doesn’t cheat and get rid of accesses. (GNU compilers make `volatile` reads/writes into atomic reads/writes when possible, but that isn’t necessarily true for other compilers, which may issue several reads/writes for a single access in your source code.) Your pointer variable is also mostly pointless; it should be `const` (the var, not the ptr type) if it actually needs to hang around—i.e., const volatile uint32_t *const ADDR_ONE_VAR = …; but there’s no reason not to do #define ADDR_ONE_VAR ((const volatile uint32_t *)(void *)ADDR_ONE) and just use that instead. The only reason you’d need an actual variable for this sort of thing is if the address can vary at run time, but it won’t in this case. Similarly, your `get_VAR_ONE` thing has no reason to exist; you can just do `ADDR_ONE_VAR[i]`. Also, really weird naming conventions. And your `for` loop should really use `size_t i` or, if you’re sure it’s going to be small enough (≤65535 per standard) `unsigned i`. `uint8_t i` is asking for trouble.
Does the mechanism handling the suffixes (presumably using a regex) allow for suffixes like "_td" (for typedef, effectively), or would the internal regex match that and throw a fit?
Thank you for taking the time to write such a detailed response; this was very helpful!
There's no mechanism, the spec just says "don't use names like this, they are reserved". Thar's it, just some words in a document.
You can also declare those variables extern, use them quite normally, and give them the abs address when linking. Less fuss with C, but lots fuss with finding the right arguments for cc or ld. My cc happens to accept cc -Wl,--defsym -Wl,ADDR\_ONE=0x01000080
 #define NUM_OF_CELLS n * n I don't know if multiply binds so tightly, that there will be no problem, but preconditioning is so strong that I heard a virtual LAAAARM! Parentheses.
Why didn't I think of that, thanks a lot for the tip dude.
\&gt; Moreover, why would you want to use a char\* instead of a uint32\* or even uint8\*? Is this dependent on what that the memory location holds? And would a uint32\* and uint8\* use the same amount of space? If so, when would you use uint32\* vs uint8\*? &amp;#x200B; A while back I spent a couple hours debugging a crash in a microcontroller firmware that, upon taking a closer look at the manual, turned out to be because the CPU would raise a memory bus fault if you tried to access a certain hardware register with a memory access of the wrong size for a given configuration of the hardware in question. When you're dealing with very low-level matters, it's good to be aware of this stuff.
What should I be naming my types instead then?
Placing return values in parenthesis is standard in the FreeBSD kernel. I've always believed it's just a cultural thing.
&gt;Why does this matter? Because variable names can mask types: &gt; &gt; tss_dtor_t tss_dtor; // error &gt; &gt;It's very common to have a variable named `time` but not `time_t`, which by convention names a type. Do you like my meme?
To be fair, there are a lot of typenames in _standard_ C (i.e. not necessarily POSIX) that do use the `_t` suffix. `size_t`, `time_t` and `ptrdiff_t` are common... not to mention the `intN_t`/`uintN_t` family. To be clear, standard C doesn't seem to use any particular convention, as is demonstrated by `char` vs `char16_t`, `char32_t` and `wchar_t`... `int`, `long int`, `short int`, etc vs `wint_t` (_I kid you not_) and `intN_t`... `clock_t` and `time_t` vs `struct timespec` and `struct tm`... just to name a few glaring discrepancies...
So, if you'll pardon the paraphrase, it's more what you'd call 'guidelines' than actual rules.
Oh they are rules, they just aren't enforced by the compiler. Future versions of the spec might define things with those naming conventions and break your code due to name clashing.
&gt;Why does this matter? Because function names can mask types: &gt; &gt; double_t double(double_t n) { return n + n; } // error &gt; &gt;It's very common to have a function named `double` but not `double_t`, which by convention names a type.
&gt;It's very common to have a variable named `time` but not `time_t`, which by convention names a type. You hurt my fee-fee!
I take it then you just don't understand how standards work. I would not want you on my team where you work in a language covered by a standard. Living in a world of undefined behavior means your code works by luck, not by intent.
Fair point. Apparently my cheap shot of a joke failed.
Anything you want as long as you don't impinge on one of the reserved namespaces for the environment you're coding for. For me, I generally follow the Linux kernel coding style guide and avoid using typedefs. See [https://www.kernel.org/doc/html/v4.10/process/coding-style.html#typedefs](https://www.kernel.org/doc/html/v4.10/process/coding-style.html#typedefs).
Your development and standards knowledge is assuredly immense, as is your devotion towards enforcing them. Your lack of humour is what would concern me were I even to come remotely near your team.
C is a very old language, and it's impractical/impossible to go back and fix the mistakes from when it was originally designed in the 70s. They could deprecate "char" for "char_t", but as with most C deprecations, it's unlikely for people to ever actually stop using the old form. Especially as C programmers are conservative and tend to appreciate short names. &gt; `struct timespec` and `struct tm` You could make a type definition if you wanted; `typedef struct timespec timespec_t;` but the convention for the C spec is to make defined types as atomic as possible, avoiding the urge to hide from the programmer that a struct is a struct unless it is intentionally opaque like thread_t.
The likelihood of a name collision with a POSIX type is exceedingly low. There are a handful of new type names introduced every decade or so. This rule is like not assuming \`sizeof(char) &lt; sizeof(int)\` or twos-complement arithmetic. Technically, weird architectures/compilers exist for which that will bite you, but the likelihood is so low that it doesn't matter.
&gt; classes U FUCKIN WAT get the fuck out.
Maybe because it didn't answer the question and was, in addition, mostly incorrect?
I'm following a naming conventions I read in the amazing book [**21st Century C**](https://www.amazon.com/21st-Century-Tips-New-School/dp/1449327141) (or, [if you don't / can't respect copyrights](https://isidore.co/calibre/get/pdf/5556)), where the suffix is also informative: - `foo_s` for `struct` types. - `foo_en` (or sometimes `foo_e` for `enum` types. - `foo_i` and `foo_f` for integers and floats (i.e., an integer type for a specific type of flag / lock). I found these naming conventions very comfortable and effective when maintaining code over a long time period. Even if the types are opaque / incomplete and are always accessed using a pointer (i.e., always using `foo_s *`), **never** `typedef` a pointer. Knowing that the handle is a pointer allows for easier maintenance and readability. The only valid use I have found to `typedef` a pointer is to localy hide double / triple pointers (leaving only the last level exposed). i.e.: typedef char * string_p; string_p words[] = {"hello", "world", NULL /* list terminator marker */ }; Even this is highly questionable, IMHO.
oof
I agree. The issue there is that over time as we grow older, we become more passive, and so too I think has happened to the founding forefathers of C. Where they once cared about consistency and portability to the point where they created C and formed the standards committee to begin with, they're now more willing/tolerant of changes that I think they wouldn't have agreed with. Furthermore, this is just a side-note on the `struct` thing, in the case of those `struct`s, the `_t` would serve the same purpose as the `struct` keyword itself does (that is to say, `int timespec;` is a perfectly valid declaration because it doesn't clash with the type named `struct timespec`). If the type namespace were to be revised, I have a feeling `FILE` might become `struct file`, as well as some other obviously structure types (`div_t` and friends, for example, might be renamed `struct div` and friends in such a scenario).
Big oof
What is MPI?
It's like blowing through a stop sign in the dead of the night. Sure, most all of the time you can get away with it, but sooner or later you're going to be responsible for an accident, and you'll have to clean it up, or more likely some unlucky schmuck long after you're gone is going to have to clean up your mess. You never know how long lived or how many other applications code you write today may end up in.
These two types are incompatible. One is an array of (array of) `int`, all contiguously stored into one block without any padding between elements or references to external objects. The other is a pointer to pointer to `int`, of which the pointers at the first level may point at/into different objects, and the same goes for those at the second level. Since these two types are **vastly different in representation**, your compiler is (rightfully so) warning you that this code makes no sense. You could use a variable length array, as others have suggested. Another option is to just use `int *`, and pass a pointer to the first element of your array (e.g. `initializeMagicSq(n, *magicsq);`). Then you'll be treating your two-dimensional array as though it's a group of one-dimensional arrays, which is how C treats it internally; technically speaking you'd be overflowing each dimension (which is UB) but kinda like how we tend to treat _integer overflows_ (which is also UB) nowadays that should be realistically quite okay. Your functions would need to change to reflect... void initializeMagicSq(int sides, int *magicsq) { // Sets all elements of magicsq to zero for (int n = 0; n &lt; sides * sides; ++n) { magicsq[n] = EMPTY_CELL; } }
I thought that the SoloLearn app (free on Google Play) made learning C relatively easy.
 [https://developer.android.com/ndk](https://developer.android.com/ndk)
I'm downloading it now, thanks.
I have one quick question, how do programs like razer synapse work to change keybinds and such because I feel like that idea could be reconfigured to fit what I am trying to do.
https://en.wikipedia.org/wiki/Message_Passing_Interface
If I recall correctly, __func__, is NOT a macro as what and is not a function can’t be determined by the cpp, which can only deal in tokens.
Yep I also read it isn't a macro, but how can I get it to be recognized by the compiler?
The macro your using is incorrectly assuming that `__func__` is a macro. Either edit this bad macro or try `#define __func__ __func__` to trick it.
A friend of mine reasoned that stuff like `if`, `for` etc have parentheses surrounding their expressions, so it doesn't make sense to not treat `return` the same way. (My wording might not be the best right now as I've woken up a bit earlier)
It's a compiler generated thing. __FILE__ and __LINE__ are defined (as per my understanding), but __FUNC__ is a compiler created helper that happens to be common fairly across the board (though I've only used it in gcc, so grain of salt on how accepted it is)
https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html &gt; These identifiers are variables, not preprocessor macros, and may not be used to initialize char arrays or be concatenated with string literals.
But the why is GLib checking for it's existence? I just want it to exist
That would make sense. I just figured that GLib is so popular it wouldn't have an issue like this
but it doesn't when the preprocessor runs.
This has been an interesting discussion. Maybe I should talk to a GLib about it
It's one of the most poorly thought out clauses in POSIX and is almost universally disregarded. Pick a large production codebase and you're usually 50/50 if they use `_t` or their own convention. `_t` as a convention predated POSIX so to unilaterally declare it solely belonged to them in the *nix world was moronic. Off the top of my head both [nginx](https://github.com/nginx/nginx) and [libuv](https://github.com/libuv/libuv) (platform layer for node.js) are massive production servers that use `_t` and work fine despite "violating" POSIX.
Maybe glib does `#define __func__ __func__` earlier on if it detects C99? Who knows.
There are many because in c pre ANSI return had more priority than some operation, and now it stay
i think the word you're looking for is not 'definite' but '[definitive](https://en.wiktionary.org/wiki/definitive)'.
I would add this was a way to avoid namespace pollution in an era before namespace :). Also I would add for a period was common to add _s (structure), _e (enum), _u (union) to the types. I even seen _p for pointer. As far I can tell this was (and still is) a way to show the type when using typedef. Since the similarity in the concept, guess that was common stuff at the time of the Hungarian notation.
/n is like pressing enter, it makes a new line, %d tells you the format how a number should be displayed (in this case in dezimal)
/n is nothing in C
Oh..thanks
Not quite. `\n` is substituted with a linefeed character, which in decimal is 10. `/n` is not substituted for anything, so is the character `/` followed by the character `n` and can't be stored in a char.
size type
Hi! I leave an advice, not for the program itself. Always write your programs in English. Always make comment in your program in English. This help me a lot on my programming carrer, I´m not native English speaker as you may guess.
The differences between C89 and C18 aren't all that great. Just learn any version of C and then learn about the differences.
Thank you man appreciate the tip and I'll keep it in mind for the future questions in this sub :))
Can you print out whats inside pszOldWindowTitle ? before call FindWindow
It's not a video game reference, it's an Evangelion reference. Anime.
No, the string "/n" is not a value. The character '\n' has a numerical equivalent and it's decimal 10 or hexadecimal A. You can assign and int variable that value and it will have decimal 10 as it's value. int foo = '\n'; printf("printing as decimal: %d\n", foo); printf("printing as character: %c\n", foo); Output will be --- printing as decimal: 10 printing as character: --- This was a fairly easy question that you could try and test easily by yourself.
It´s only software or soft and hard? IoT is really hot topic right now
I have no idea what you want to do.
K&amp;K, "C Programming: A Modern Approach"
Is that supposed to be a joke? Void returns nothing.
How can I have then a function outside the main that returns a value?
You change void into the data type of the value you want to return. Start by watching some YouTube tutorials.
okay thank you
You can shout out this incantation and they beg Zalgo for information T͉̝̼̰̝̲̠̀o̧͙̩͈̫͙̙̹ ̨̬̦̤̞̭̰ͅi͖͕̮͚̠͈̟n͎̲v͏̮ó͎̦̞ḳ̳̮̟̹͈̜e͇̩̫̙̪ ̮̻͖̘̪t̹̮̘h͡ẹ̟̭ ͉̝h̼ì̮̯̩̪̱͕̘v̢̦̩̬̪̭͇̹e͇-̜̯m͝i̖̥̫n̥̩͔̩͝ͅd̫͈̻͙́ ͚̜͚̻͜r͜e̩̼͙̯p̢ṛ̠̪̥̣̲͘ẹ̀s̖͟ͅé̘͉̯̞̖n̶̗̲͉tị̵ͅn͈g̠̹͠ ̛̭͇̭̺ch̺̳a͏̳̳͚ͅo̻s͎͉̭͖.̼͖͎̼̣͘ ̘̣I̢̙n̸̺͖̫̱v̻͉͚̙̯̗o͉k̩̮͝i̹̥̬̜̩͟ṉ̲̙̫g̵̺̦ͅ ͏̱̩̲̣t̳̗h̸̻͕̟̗̦̙e͔͈͠ͅ ̶̩͕̮̣f͇e͕̩̯͎̰̖͜ͅḛ̜̟͈̖li̶̳̜͙͚̩̹ng̡̥̜̖̘ ơ̝̯̟̹̹͇f̺ ̢̝̗̟̱̹ch͈̪̳̳a̯̪͖͖̣͎̺͡o̺̱̪̟͜s̪̞̰͍̀.̬͎̻͍ ̘̣̱̦̞W͞i͇̼͓̹̩͕̼t͈͎̝͕͜h̵̘̺̻ ̰͕̯ó̰̯̞̖̦͈u̹̝͚t̮̮ ͍͉͖̤̩o̗r̶̤̙̺̟̼d̞̳̝e̲͎̞ṛ͖͇̲̗.̛̩͕ ̘̣̭͜T͔̜h̢e͝ ̰̱̟̠̮̝ͅN͔͙͕̥̞̹̟e̺͡z͍̣p̧͙̺ͅę̻̥̖ͅͅr̡d͔̲̼̙̣͚i̱a̗̰̳͓n̨̖ ̭͈̰̰h҉̗͕̭̦ͅi̵̼̯̙̫̹̬v̩̣̯e͍̺-̤̘̥̥͎̣m̰̥̜̼̙̘i̪̝̳͚n̞̦̻̼d̘͎͉̝̬ ͙͎͟o̠̹͈̪̼̫̩͝f͏̣̫̘̰ c̠̲͙̺̳̼̥h̹̣̦͔̰͞a̖̰͖̗̼̤̬o̷̪͓s̀.̳͕͉̣ ͝Z͓̥̟ͅa̧̟̠̟̦̖l̢̝͉͙̝̖̖̝g̢̠̥͍̝o̟̮.̯̹ ̘̣̗̀H̞̳̹͍͞e̤͔̯͈͢ ̸̙ͅw̮͘h̺o̲̤̠ͅ ̭̪̳͖̬̬̝W̸͔͔̗͉͈ͅa͖̥̠ͅͅͅį̠̰̺̺̺͔͙t̝̖̠̮̣s̞ ͠Ḇ͈̳͉͉̼e͓̬̬̼̗̤̱͟h͕͢i̵n̯̹͇̱̣̮͙d̲̗ ͍̯͇̙̩̟Ṱ̘̜̮̳͚̙ẖ̯͎e͍̳̥̱̺ ͍͘W̭̬̗a̸l̲̪̙l̗̟̥̣͕̩.̤͢ ̘̣̦̤͙̬̼͙Z̴̹͉̜̼͙͓A͉̭̟ͅL̰͢G̲͈̬O͙̘͉!̛ You can change the return type of the function to the type you want it to return. You shouldn't do this for system functions or functions of libraries, unless you know what you are doing.
On the contrary, the differences between C89 and C18 are huge. However, most of the major changes to the syntax (end-of-line comments, `long long`, flexible array members, designated initializers, compound literals, sized array arguments) occurred between C89 and C99, and some major implementations still don't support C11 or newer, so most large code bases target C99. C11 introduced two major but rarely used features (multithreading and bounds-checking versions of many existing functions) and a number of smaller ones (anonymous unions and structs, static assertions, explicit UTF support). C18 is just C11 with a few corrections.
Something along these lines should work. /* __func__ is guaranteed for C99+ */ #if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__+0) &gt;= 199901L # define G_STRFUNC (const char *)__func__ /* __PRETTY_FUNCTION__ is there for G++ */ #elif defined(__PRETTY_FUNCTION__) \ || (defined(__cplusplus) &amp;&amp; defined(__GNUC__) &amp;&amp; (__GNUC__+0) &gt;= 2) # define G_STRFUNC (const char *)(__PRETTY_FUNCTION__) /* MSVC(++) has __FUNCSIG__ instead of __PRETTY_FUNCTION__, and it’s * allegedly a predefined macro so `defined` should hopefully detect it */ #elif defined(__FUNCSIG__) # define G_STRFUNC (const char *)(__FUNCSIG__) #elif defined(__FUNCTION__) \ || (defined(__GNUC__) &amp;&amp; (__GNUC__+0) &gt;= 2) \ || (defined(_MSC_VER) &amp;&amp; (_MSC_VER+0) &gt;= 1300) # define G_STRFUNC (const char *)(__FUNCTION__) #endif #undef FUNCNAME_P #ifdef G_STRFUNC # define FUNCNAME_P(x, y)x #else # define G_STRFUNC (const char *)("&lt;unknown&gt;") # define FUNCNAME_P(x, y)y #endif
tried it, didn't like it. Not project based.
Another thing to look into is out-arguments, where the caller passes in a pointer to the storage area they want results dumped into and the callee fills that in for them. Out-args can provide for some extra behaviors like passing `NULL` to signal that you don’t need a result, and sometimes you can skip filling in the out-arg’s (referent) value if there’s an error. Out-args also make it cheaper to return larger values (e.g., a big `struct`) because they avoid the need for any extra copies. And of course, you can have as many out-args as you want, or even accept a variadic argument list with arbitrarily many out-args, whereas you only get one return value. With normal return values, you always have to (well, damned well should) return something valid, even if there’s nothing meaningful or useful you can hand off, and even if the caller doesn’t actually need everything being returned. For large return values, the callee often has its own completely separate copy of the return value from what the function returns, although most ABIs use out-args under the hood for large return values (usually &gt;2 words or so) so YMMV. An example function taking two out-args: struct Result {…}; void someFunction( int *restrict error, struct Result *restrict result); /* `restrict` because these two pointers should never refer to the same or * overlapping memory. C99 feature; alternate keyword `__restrict__` works * in any GNU compilers regardless of language standard or dialect—even works in * C++, despite C++ lacking a normal `restrict` analogue. */ int main(void) { int errorCode = 0; struct Result result; someFunction(&amp;errorCode, &amp;result); if(errorCode) { fprintf(stderr, "\x1B[0;31;1;5mERROR %d\x1B[0m\n", errorCode); return 1; } /* use `result` here */ … return 0; Because this sort of pattern is so common for error code + other thing returns, the usual thing to do is to return the error code directly and emit anything else via out-args: int someFunction(struct Result *); int main(void) { struct Result result; int err; if(!!(err = someFunction(&amp;result))) { … return 1; } … return 0; }
Have you tried making a html parser with regex?
I've done nothing but ~~teleport bread~~ parse html with regex for three days.
It is the title of the console window, which is just the path where the exe was run.
Not the answer we wanted, but the answer we needed.
Better by reading a book on programming in C.
On top of my head, if you don't want to use any libraries, you could try and find a polynom close enough to the gaussian.
Generate two uniform random numbers and then use the [Box–Muller transform](https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform).
"second edition"
&gt; but how do I generate normally distributed random numbers that are between 1 and 1000? The `rand()` function on most modern implementations of libc should be fairly equally distributed. int num = (rand() % 1000) + 1;
I'm not sure how effective this will be but try this. There's an introduction to computer science course on edx by MIT. They focus on python. You learn the concepts and try writing your code in C language
&gt; I don't even really understand what this problem is asking to be honest. Which bit of it? The recurrence relation you've got there is called the [logistic map](https://en.wikipedia.org/wiki/Logistic_map). It can be used as a simple population model. Under some circumstances it can exhibit interesting chaotic behaviour. It's a recurrence relation, which means its value for some time `n+1` is dependent upon its value at time `n`. This particular recurrence relation has a single free parameter, `r`. You are given the value of the population at time `0`: `p_0 = 0.02`. From this you can calculate `p_1`, `p_2`, and so on, given any particular, fixed `r`. Under certain values of `r`, this sequence `p_0`, `p_1`, `p_2` will approach a constant value. It looks like you will eventually be determining what this constant value is, for any particular `r`, and possibly determining which values of `r` do _not_ approach a constant value. For now, however, the question is just asking you to determine `p_n`, given `p_0` and `r`.
**Logistic map** The logistic map is a polynomial mapping (equivalently, recurrence relation) of degree 2, often cited as an archetypal example of how complex, chaotic behaviour can arise from very simple non-linear dynamical equations. The map was popularized in a 1976 paper by the biologist Robert May, in part as a discrete-time demographic model analogous to the logistic equation first created by Pierre François Verhulst. Mathematically, the logistic map is written where xn is a number between zero and one that represents the ratio of existing population to the maximum possible population. The values of interest for the parameter r (sometimes also denoted μ) are those in the interval [0,4]. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I don't think the Committee has really reached a consensus as to whether it is trying to define a core language whose semantics can be readily extended as needed to meet just about any purposes, or whether it is trying to define a language which is adequate by itself without extensions. This has created a Catch-22, as the Committee refrains from mandating semantics that implementations could provide for themselves when appropriate, at the same time as some compiler vendors regard such failure to mandate such semantics as implying a judgment that their customers shouldn't need them. What's bizarre is that in an effort to support "optimization" the language has gone from being very simple to being very complex. The semantics of something like: struct foo {int x, y; }; int read_foo_y(p) struct foo *p; { return p-&gt;y; } were very simple in the language described by the 1974 C Reference Manual. Under C18, the code would have the same meaning in all defined cases, but the rules for when the function would or would not be required to behave as it would have in 1974 are so complicated and ambiguous that there has never been any consensus about what they mean in all cases.
You might like this [UserLAnd](https://play.google.com/store/apps/details?id=tech.ula&amp;hl=en_US). Otherwise, it's cross compiling with the NDK.
Usually it's the type that's capitalized, not variables: Size size; Size count;
Awesome! Downloading it!
I do not think there is a single book that is the K&amp;R for C11/C18. I would recommend reading The C Programming Language 2nd edition, and then read [How to C](https://matt.sh/howto-c) as a supplement. TCPL is still the best book I have found in terms of the length to useful content ratio, and How to C covers most of the modern best practices not found in TCPL. You already have TCPL, but make sure that you're reading the 2nd edition and not the original 1st edition as the 2nd edition is ANSI C and the 1st is K&amp;R wild wild west old-ass C.
You cannot. A Gaussian distribution has no hard limits on the numbers generated. What you can do it specify that you want a mean of 500 and a variance which means that some large percentage of the numbers generated are in your range (like say 99%). You then clip the outliers. To do that you need to look at transforms which take a uniform random number and turn it into a Gaussian.
It is, full-ish environment. It's Linux so you can build DLL's and all that good stuff.
There seems to be limitations to what I can do on Android, so hopefully this solves them.
Well, it's given me ideas for projects, so I can't complain.
It's KNK (Kim N. King), not K&amp;K.
Modern C by Jens Gustedt, he's part of WG14 and the book is free.
Yeah unless you can root the phone it's a locked environment. this UML app tries to emulate enough of the system calls to fake it. I haven't seen if there is a full UML kernel to run on UML.. Naturally it'd suck for speed, but it'd be full root. And there is always Qemu..
WHERE HAVE YOU BEEN PARSING IT?!
He doesn't want them equally distributed, he wants them deistributed in a gaussia shape.
Huh, the more you know. I should've taken a stats course.
Seeing a TF2 reference made my day. Thank you! 😍
I think stats is a really important skill for the 21st century.
Ok, let's run with your assertion that the use of `_t` namespace is "one of the most poorly thought out clauses in POSIX". Can I assume that you have no problems with the concept of reserved namespaces in general in standards, it's just this particular one in POSIX-1003? Running with that assumption on my part, let's say I teleport you back to 1987 when the POSIX-1003 had the proposal for reserving a namespace for future identifiers using the `_t` suffix for review. Knowing what the committee knows then and what you know now, what would you tell them to kill the proposal? What would you have offered the committee as a better alternative?
The important point is that C18, C11, and C99 are all almost entirely backwards-compatible with K&amp;R TCPL 2nd ed. So if you learn from K&amp;R2, you will be fine "for the purpose of instruction" and well-equipped to learn all the new features from *How to C* or a multitude of other sources describing them, very few of which you will ever need in day-to-day typical work, in general.
The important point is that C18, C11, and C99 are all almost entirely backwards-compatible with K&amp;R TCPL 2nd ed. So if you learn from K&amp;R2, you will be fine "for the purpose of instruction" and well-equipped to learn all the new features from light perusal of *How to C* or any other of the multitude of sources describing them (very few of which you will ever need in typical day-to-day work, generally.) It's more important to get the errata and mark it into K&amp;R2 than mark in the very few incompatibilities which you're extremely unlikely to encounter in practice.
I have this beginner project and since I learned the basics of python first C for me now is super confusing any help is appreciated as I can barelly even start this simple program... also I am not allow to use the following: Use global variables Use the word goto Use the break command o utside a case statement
Damn. No question. No description. Nothing but a scanned assignment.
&gt; wild wild west old-ass C I've seen some code from the early 90s that conformed to this, and the preprocessor macro abuse was a sight to behold.
&gt; old ass-c *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
I aint doing your homework but I found reading your assignment fun. I particularly like a lecturer that allows me to "make up my own specification" for the word Dead. My specification is that the the string "Dead" is written to a randomly generated pointer address in the event that the current time at entry has an even second.
I would start here: http://www.catb.org/~esr/faqs/smart-questions.html
I have never heard of if (or any other control flow statements for that matter) being called "decision statement" before. Huh, the more you know.
It is weird that you would have the mean be potentially some value other than 500 as that is the middle of the interval, but assume that is what you want then do what /u/skeeto said (and rounding up if you want an integer) and if the value you end up with is something not between 1 and 1000 then toss it out and repeat the whole process until you get something that is.
My bad I thought I posted a comment by no means I want the answer just a direction as I have more assignments and there is no point of getting things done for me ( I know there are a site for things like his) the part that is tripping me is that I cannot use the break command and I am not sure where to start .
The Standard allows implementations to behave in a fashion consistent with the language described in K&amp;R's book, but in many situations does not require nor even encourage them to do so. In the language invented by Dennis Ritchie and described K&amp;R2, given something like: struct s1 { int x; float y;}; struct s2 { int x; double z;}; int read_s1x(void *p) { return ((struct s1*)p)-&gt;x; } int read_s2x(void *p) { return ((struct s2*)p)-&gt;x; } the behaviors of `read_s1x` and `read_s2x` would be interchangeable. Each would read an `int` from the passed-in address and return its value. The Standard, however--at least as clang and gcc interpret it--does not require that they be treated interchangeably. In Ritchie's language, if one has a pointer that is known to identify either a `struct s1` or a `struct s2`, one could use either of the above functions to examine field `x` of it without having to know or care which type the pointer actually identified. Among other things, this would allow a function to receive a pointer to either type and use field `x` to decide what kind of object it's dealing with. The Standard does not require--at least not unambiguously--that implementations support such functionality, and the authors of clang and gcc consequently make no effort to do so reliably. Anyone using K&amp;R2 as a reference must therefore be aware that compilers like clang and gcc will only process the language described thereby if optimizations are disabled, and that the maintainers of clang and gcc have indicated in their support forums that they view any code relying upon the K&amp;R behavior as "broken".
then check again the use cases for FindWindow( ) maybe is not answering as you think.
The long way around i could think of is to generate random numbers 0-1000 and include each of the random numbers only if they are lucky enough. For example the number generated randomly is 500, right at the mean. So you give it 98%. Then you just generate random numbers 0-99 and and if it is 0-97, it "won" so it gets to be included. It isn't efficient or nice, but will look the way you want it.
A doesn't sound like a struct, it sounds like an array.
A is a struct containing an array with a variable saying the number of B that are present. Anyway, how does this pattern work?
Other options might be termux; you can install Clang/GCC and compile stuff that way. On my phone, I run stuff like this every now and then: ``` pkg install clang clang hello.c -o hello ./hello Hello world! ``` You can also get make/cmake, a bunch of libraries, etc.
You have two sections in ELF files, .init and .fini. You have attributes (in GCC and clang at least) to put code in those sections (constructor and destructor). This code will be executed before .start and on exit of the program, or anything that links against your library. You can specify priority. It seems that it would be able to do what you need. You could use a constructor to initialize A with the relevant info. Search for __attribute__((constructor)). You can see an example of use in DPDK which is a framework here https://git.dpdk.org/dpdk/tree/lib/librte_eal/common/include/rte_common.h#n92
Ah ok! Well would you be able to better explain it, or whip out MSPaint and draw us a little diagram with boxes &amp; arrows showing roughly what it is you are trying to accomplish? And what is the reason for it's existence, what are the functions you picture yourself using with this pattern? PS: When designing things, especially when you don't even know what it is you want, use nothing but globals and arrays, skip structures entirely, until you get it working! It only takes a minute to turn a bunch of globals and arrays into structures. Get something working first, bug free, and then spend a couple minutes prettifying the code.
Most terminals simulate VT100, which lets you use [it's escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code). As always, Windows doesn't.
**ANSI escape code** ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators. Certain sequences of bytes, most starting with Esc and '[', are embedded into the text, which the terminal looks for and interprets as commands, not as character codes. ANSI sequences were introduced in the 1970s to replace vendor-specific sequences and became widespread in the computer equipment market by the early 1980s. They were used in development, scientific and commercial applications and later by the nascent bulletin board systems to offer improved displays compared to earlier systems lacking cursor movement, a primary reason they became a standard adopted by all manufacturers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Hey I learnt recently about of the \b character in Java, which "deletes" the last character in the Terminal. Maybe you could check this out as it is probably usable in C too. I remember using it to make a progress bar in the terminal.
[removed]
I'm trying to re-architect OVIA, my media library so that it's simplier to manage. Currently I include all of the "components" (PNG, BMP, PNM, WAV, AIF, FLAC, etc encoders and decoders) in the main OVIA file and I have wrapper functions that call the encoders and decoders for those formats and wrap it all up in a format agnostic way, BUT it rquires me adding a new if section to all of those files, and it's just not a sustainable architecture. so I'm trying to find out a way that I can have all of these encoders and decoders register themselves with OVIA automatically, but I'm just not sure how that would work. How can I guarantee the OVIACodecs struct (A in the original post) will have each codec register itself, when each function can't have a main function? I thought about using macros, but that would only allow me to build up a static, global array, which I really don't wanna do either.
I think it would help if you listed your qualifications. "I coded a mini game "plus or minus" i can show you the code and how i work!" is not a valid qualification.
WOW, just wow, where was Reddit when I did CS ?
We shall call it the backspace character!
You might need a website to show what you can do, or something
Now, if you said C11 I'd believe you. It would be a stretch if you said C99, but C89?? There's a huge difference between the two.
I guess you could put your command line parser in main(), but I think it's better practice in large programs with complex command line inputs to have that functionality off to the side somewhere. I want to be able to look at a main() function and have some outline of the program flow as a whole, without having to scan past whether or not "--help' works.
First off, this is C so Inversion of Control (IoC) and Dependent Injection (DI) aren't really a thing. They are fairly foreign concepts for C. That being said I would recommend looking at COM (or Mozilla's XPCOM). Basically each "class" (or struct in C) is registered in a registry and something like `QueryInterface` will return the class to you.
Installing it now, thanks!
The forward declarations are an unnecessary eyesore. Yes, the compiler should be able to resolve all symbols in a single pass, but the way to deal with that is to order the functions from the bottom up so that each function calls "upward". Main should be at the bottom of the file, then everything will resolve naturally. The `main` function is way too long and has way too much responsibilities. It's even opening files! It should be split into at least three separate functions: a options getter, an action taker, and a very small `main` function that just calls out to the other functions and handles their return values. Keep it simple and factor out the complexity. The best `main` function is a few lines long. As it stands, the `usage` function has the authority to exit the program. It can even do so after an output file has already been opened. I'd say that's bad design, the error should propagate back to `main`, and `main` should act as the program's only exit point.
Oooh that makes sense !
good bot
Between 89 and 99, yes, maybe, although I still wouldn't consider the differences that big. But after 99? only minor stuff.
What's the full code? Do you have perhaps : https://godbolt.org/z/UORx31
Maybe you have a line with unmatched quote earlier in the program
Just write in the spec what is the practical reality today, reserve the keyword/struct/macros when the relevant header is included. Also known as how the C language works for every single library and platform.
holy crap, that was it. Why in hell does the compiler not catch THAT error first?
Technically it's not an error, you can split string literals over multiple lines. Not a recommended practice though. If you use an editor with syntax highlighting, this would have been apparent sooner.
The differences aren't big? It introduced: 1. VLAs 2. Single line comments 3. Inline functions 4. Allowing scoped variables in loops 5. Boolean data type And that's just off the top of my head. Pretty sure there's more features that C99 standardized compared to C89. That was a huge jump in the language standards.
&gt; Technically it's not an error, you can split string literals over multiple lines. You cannot; a string literal cannot contain a newline character. You can generate the error with a line continuation as the link in my comment shows.
Thanks; this is why I wrote "almost entirely backwards-compatible" -- I believe there are three or four other reasons, but none of them are likely to be encountered by those seeking beginning instruction, and all of them have good errors or warnings from both gcc and clang surrounding them, as I understand the situation. (Having said that I'm a huge rust fan because of just this sort of thing.)
tcc is living up to its name. Sometimes, in order to squeeze a C compiler into just a handful of kilobytes, you have to forego certain niceties such as complex parse error reporting.
&gt;You cannot; a string literal cannot contain a newline character. True according to the standard (other than escaped newlines), although some compilers allow it as extension. (I have no idea how widespread)
&gt; Most Unix environments expect programs to return 0 (zero) on success and -1 (negative one) on failure. What has the author of this article smoked?
$5 is way too little for this. A good C programmer is paid about $100 per hour as a consultant.
Check out [Termbox](https://github.com/nsf/termbox) or search Google for [simple terminal libraries](https://www.google.com/search?q=simple+terminal+library&amp;oq=simpl&amp;aqs=chrome.0.69i59j69i60j69i65l3j69i57.1553j0j4&amp;client=ubuntu&amp;sourceid=chrome&amp;ie=UTF-8)
Instead of using ANSI escape codes, it's generally a good idea to use termcap or terminfo instead. This makes your code work on any terminal instead of just VT100 compatible terminals.
The Linux Kernel achieves this sort of thing via creating extra sections in the compiled output via C attributes. This is unfortunately GCC/Clang specific, but IMO very effective. There's lots of different ways you can do this, but the simplest way is to simply build up a "global" array via placing `struct`s into a custom section. IIRC, by default `gcc` will automatically create `__start` and `__end` symbols for you with the name of your custom section, so the idea is that inside of each codec you define a `struct` in something like the `codecs` section, and then in your `main` code you just make use of the `__start_codecs` and `__end_codecs` symbols to loop over all the `struct`s in that section, which corresponds to basically looping over a big array of codecs. The big thing this gets you over a regular "global array" is that the entries in the array can be located in the same file as the codecs, there is no global source you have to go back and add too. It also adds to the encapsulation since you can make basically *everything* for the codecs `static`, and then just include some function pointers in that `struct` in the section. So depending on your design, the codecs may not need to expose a single thing to the "outside" and can be completely self contained.
You can do this on windows, but it’s a bit more work as you have to put the console in vt100 mode. See [this article](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences).
&gt; Also known as how the C language works for every single library and platform. If you mean by how the C language as defined by ISO works, that's not true. There are global identifier namespaces reserved in ISO C too for future expansion without having to include any headers such as the prefix `_[_A-Z]`. In ISO 9899:1999 check out section 7.1.3. "Reserved Identifiers". C++ has a lot more global namespaces reserved, for example, you can't have `__` in any portion of an identifier at any time. POSIX 1003 does generally reserve namespaces by which header is included, but there are a few exceptions like `_t`. My assertion is that people nowadays simply use `_t` simply because they just think it's a convention not realizing it's a reserved namespace. Back in the late '80s before POSIX you'd be very hard pressed to find any application C code at all (even system headers for that matter) using the `_t` suffix. That's why they chose it because it wasn't being used much at all. I've had the same problem with devs not realizing what they were doing. For example, devs using ISO reserved `_[_A-Z]` prefixed identifiers in their own code thinking it was a convention as well. For example, using a macro starting with an `_` to protect a header from multiple expansion. They just thought that was what you did because the system did it. &gt; it's worth pointing out you have to try pretty hard to cause collisions with POSIX and the compiler will tell you immediately anyway. No, the compiler won't tell you immediately tell you and hence my point. Your code can have two types of collisions, now and in the future. Now may not be flagged by the compiler when you write your code if on the system you're on your `_t` type just happens to be compatible with the system's type. The "error" goes silently ignored until ported to a system where the type is no longer compatible. Only at that point does the person trying to port your code get a compiler diagnostic. In the future is that an identifier can be added hence the reason why there are reserved namespaces in the first place, to help your code from breaking at inopportune times.
You're checking if guess equals 10, not the number of guesses.
By the way, for future reference, the correct way to write "five dollars" is $5. Thanks.
Single step it and check that every variable is what you expect it to be as you go line by line through it.
Edited\^ am I going the right way
Sorry, but the “5$ is like a day of work” makes this post not believable for me. Where do you live that people make earn less than Albania?
VLAs were a mistake; aside from that, those don't change at all the way you write code.
Negatine
https://imgflip.com/i/3392uu
Should you collect received input back into lines by hand ? Put \\0 in place, at least.
In what respect? I apologize I don’t get what you’re referring to. The server will test the connection with PING &lt;serverDefinedResponse&gt; If I don’t respond with PONG &lt;sameResponse&gt; It’ll drop the connection. Since I don’t know the response ahead of time.. I test for the PING then switch the I for O and echo it back.
I’ve modified the check on that particular if statement to make sure it’s a PING from the server so it doesn’t start sending pings to it when a user pings me. If I comment out everything related to servIP it prints garbage instead of the contents of servIP at the same interval. I’m assuming this is whatever is at that same memory address?
recv will give you the bytes buffered so far, with no respect to newlines. You should make recv append into a reasonable buffer and then peel off complete lines. If a partial line remains, pull it to the beginning of the buffer for next recv. There will be no \\0, so the printf %s can show junk after valid bytes.
Ahhhh ok. Thank you! I’ll give that a shot.
Thank you!
Algeria my dude :) $1 = 119 Dzd . And in black market it much higher, its about 150 Dzd, and i get payed 800 Dzd a day (minimum by the law is 600 Dzd). So $5 = 750 Dzd (black market) Yes yes less pay but im in my zone in front of a PC :)
`printf()` replaces `%s` format control with the contents of a c-string. C-string is an array of `char` values terminated with a nulbyte (or `\0`, which is just another notation for a nulbyte). That terminator is important, because `printf()` (and many other string functions) will process the input string until it reaches the nulbyte. If your input string is not terminated correctly, the function will go past the end of array (your c-string) and will continue processing memory contents it should not touch. Remember, C runtime does not check array boundaries! That manifests itself by either printing junk until function stumbles upon some "random" nulbyte and/or by crashing if there is no nulbyte up to the end of your allocated memory. Literal c-strings have nulbyte appended implicitly. When you are building your own c-string (for example by copying bytes into an array) you have to take care of terminating it yourself. Just append 0 or literal `\0` to the end of your data (not the end of entire array) and that should be enough.
My guess is you haven't compiled correct.Try gcc -Wall -g anakin.c -o anakin
Android has protections in place to prevent arbitrary code exectution.
Try storing the source and the executable in internal memory, not the SD card. Apparently the memcard filesystem doesn't allow executable permissions.
Check also fdopen, stdio can do the reblocking for you. You'll lose a bit of control though. optVal does not seem to have a value, btw.
Oh damn. Have you looked into overseas contracting jobs? I think they would be much more interesting than any task some random person online could give you
It gave me an error message this time, but still "permission denied." The error is "implicit declaration of function," but the code has previously worked as a single file. What I am doing now is I removed a function from the previously-working code, put the declaration in anakin.h and the definition in anakin.c, and I've been trying to get that to work.
Do not post pictures of code. Instead, post code as text!
That's been my suspicion since the chmod errors. Any idea how to grant permission? I've been all over StackOverflow and other sites looking for anything.
No files are on an SD card, although I tried moving the executable there to see if the permissions might be different. They aren't.
Internal storage doesn't have execute permission, so you have to store the files in /system or something. The problem with most folders is that you need root to access them, unless you use a temp directory like /data/local/tmp, which you should be able to use without root. Note that you can't list files (ls) in that folder, but you can create folders there and see the insides of them.
Is that why all apps compile and run within the app? I'm trying to use a terminal because #include "anakin.h" doesn't seem to work inside apps.
Could be selinux. I don't recall off the top of my head what selinux tooling Android has. What happens if you run getenforce or "ls - Z anakin"?
-Z is an invalid option
Enforcing, and provides an email address.
Enforcing, and provides an email address.
I wonder if multiplying a Gaussian window of size 1000 against 1000 samples of white noise would get the OP there? One method might be to use MATLAB or Octave to generate a 1000 point Gaussian window, capture that as text to create ( in source code ) an array of doubles and "multiply" white noise ( as generated by rand() ) piecewise by that. I'd then research producing the window programmatically in C.
repl.it/languages/c
Checking it out now, thanks!
Online C compiler? Really? Why would you want something like this?
I use it when I'm on a Windows PC and just want to test something quick.
Get yourself a shell server somewhere and log into it. But if you want to “test something quick,” what is the point of allowing include directives?
That could be an option too, but that might be cumbersome for many. The things I usually test can be done within a single file. But people have different use cases so why not allow it?
How are you invoking the compiler and linker?
I think you're compiling main.c but not test.c so the linker can't find the function
What is the command you are passing to the compiler? You need to pass both your C files as arguments to the compiler.
what commands are you typing to compile and link it?
I'm guessing you forgot to take the high ground before compiling.
I think this is it. When I compile it manually on the terminal passing both .c files as arguments it's fine. I was kind of hoping Atom's gcc-compiler package would be able to do all that for me, lol. &amp;#x200B; Is there an easier way to compile C-programs than listing all of the .c files manually on the command line?
You may also want to save yourself some time and read up on Makefiles: http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/ An example one for your program would read: .PHONY: all clean CC=gcc CFLAGS=-g all: sudoku_solver sudoku_solver: $(CC) -o $@ main.c test.c $(CFLAGS) clean: rm -fv sudoku_solver
Because allowing this makes the design of the tool much more complicated and in all cases where you just want to do a quick test, you can copy the content of the file to be included into the file instead of using an include directive.
See my reply to myself in parallel to yours. The easiest way is make. You with this file you can just run "make" at the terminal to build and "make clean" to start fresh. It is not a super idiomatic Makefile, but if you read that tutorial you can learn to make a more purpose-built/idiomatic one.
Maybe, but if you want a real answer you should ask the creators.
Awesome, thank you!
Please read the sticky post which explains what to do when you need help.
Hard to troubleshoot an selinux issue if you don't have the version of the utilities with - Z. You could try "setenforce 0" to turn off selinux (requires a rooted phone) and see if that fixes your issue. I don't recommend running with selinux turned off on any device you care about, but it could help you troubleshoot and possibly rule out selinux as the source of your problem. If it does work after setenforce 0, then selinux is blocking your permissions and you'll want to try getting your executable into the correct selinux domain.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(void) { srand((unsigned)time(NULL)); int r = rand() % 100 + 1; int correct = 0; int guess; int counter = 0; int numberOfGuesses = 0; printf("Guess my number! "); do { scanf("%d", &amp;guess); if (guess == r) { counter++; printf("You guessed correctly in %d tries! Congratulations!\n", counter); correct = 1; } if (guess &lt; r) { counter++; printf("Your guess is too low. Guess again. "); } if (guess &gt; r) { counter++; printf("Your guess is too high. Guess again. "); } if (numberOfGuesses != 10){ r &gt;&gt; guess; numberOfGuesses++; prinf("\n\n### Maximum limit of atttempt finished, BAD LUCK !!!\n"); } } while (correct == 0); return 0; }
I am using an Android smartphone because my laptop died in a 3rd-world country and I don't want to buy a new one until I return to a 1st-world country. So, in the meantime, I am trying to determine the limits of what I can do with a smartphone. I already found notebooks.ai for Python, which I also use, so I'm looking for an equivalent for C.
Android is like the Jedi Council... everything is denied.
You probably want to surround your test.h with [include guards](https://en.wikipedia.org/wiki/Include_guard) as well. #ifndef TEST_H #define TEST_H int foo(int x); #endif
**Include guard** In the C and C++ programming languages, an #include guard, sometimes called a macro guard or header guard, is a particular construct used to avoid the problem of double inclusion when dealing with the include directive. The C preprocessor processes directives of the form #include &lt;file&gt; in a source file by locating the associated file on disk and transcluding ("including") its contents into a copy of the source file known as the translation unit, replacing the include directive in the process. The files included in this regard are generally header files, which typically contain declarations of functions and classes or structs. If certain C or C++ language constructs are defined twice, the resulting translation unit is invalid. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
How would I find the correct SELinux domain?
It should be printf("%d", foo(2)); as your returning and int and the verb for an int is %d. If you can use %u for unsigned, %l for long, and %ll for long long.
Onlinegdb , but it has an old compiler. But allows you to debug your code. Online.
Checking it out, thanks!
That depends on your policy and exactly how it's getting blocked. I'd look at what domains other executables are in. Typically it's "u:r:bin:s0" or something along those lines on android I think. On a regular Linux system you could try something like "chcon -t bin anakin" so switch the label. Not sure if that would work on your system or not since I don't know exactly what your environment is like. You can also check your system logs and see if there are any selinux denials. They would typically contain the string "AVC" and are a strong indication that you may be experiencing an selinux issue if there are relevant ones.
I apparently know nothing about Android, but I guess it would be helpful to know more about the platform I'm running on. Time to do some researching....
Writing reliable code with gcc and clang requires being aware that enabling optimizations will cause them to process a language which is not *reliably* compatible with the one described in K&amp;R. K&amp;R describes the behavior of integer overflow as "machine dependent". When the Standard was written, all compilers for silent-wraparound two's-complement machines that weren't expressly configured to trap on overflow would truncate in cases where the result was converted to an unsigned type of equal or lesser size, a fact the authors of the Standard took note of in the rationale when deciding that there was no need to have unsigned short values promote to unsigned int in cases like: unsigned mulshorts(unsigned short, unsigned short y) { return x*y; } because promoting to signed int would yield the same result. When compiled with gcc, however, that exact function, however, will sometimes disrupt the behavior of the caller if the arithmetic value of the product would be between INT_MAX+1U and UINT_MAX.
&gt; save time &gt; Makefile Unless you're working on very large projects, or you're already good at makefiles, nope
Or a shell script
Makefiles are BAEs
I will probably get lots of downvotes but perhaps it's time to consider another language, one with better support for object oriented programming. Don't get me wrong, you can certainly do OO on C but it's hard and ugly. The most obvious one here is C++, but if you hate c++, Rust is really interesting.
A shell script does not manage dependencies by default, which is extremely helpful for languages like C that has relatively long build times (and don't get me started on C++).
`%i` and `%d` have no difference when printing.
Yeah, do not rely on IDEs to compile programs for you.
The usual way to do dependency inversion in C is to use header files. * header files are interfaces (abstractions). * source files are implementations (concretions) -- they only depend on abstractions (the header files they include), not on other concretions, * "dependency injection" happens by linking the compiled source files together. Ironically modern C-based OOP languages (like Java, C#, PHP7) omitted the concept or header files, only to invent interfaces to achieve the same thing. The only shortcoming of header files is that there can be only one implementation of the functions defined in a header file in a single program, but this is usually sufficient -- in OOP languages you also have only one implementation per interface most of the time, apart from mock objects in unit tests (and this can be done in C simply by replacing a source file with a mock implementation when linking a unit tests).
Yes to add to that, I think this poster is a student. If you put C on your resume and don't know how to write a Makefile when you show up to work, you are going to have a very rough internship.
&gt; very large projects Rule of thumb: makefile when working with two or more source files or if you're invoking compiler options &gt; already good at makefiles It's not hard to get good at the basics and your mostly only need the basics
Yes, there is substantially no difference in verbosity or complexity between a Makefile and a shell script with equivalent functionality. Just that one is much more powerful and faster for big projects and also an industry standard.
This is also an example which a novice seeking basic instruction will not likely encounter. I appreciate your effort in explaining it, but it's not the sort of thing that argues against the brevity of K&amp;R2 for some larger tome covering all the corner cases for beginners.
What program is this?
What it argues for is a recognition that enabling optimizations on gcc and clang will cause them to process a language which cannot be relied upon to work the same way as the simple language described in K&amp;R2. It's not particularly likely that anyone would accidentally stumble upon cases where `mulshorts` would disrupt the behavior of the caller, but I would regard the reliability of a construct on a compiler qualitatively rather than quantitatively: if a compiler cannot process a construct 100% reliably, one shouldn't use the compiler to process that construct at all.
Good bot
Unless you use a proper IDE and not a souped-up text editor.
Switch statement: switch(op) { case 0: p.edit += 1; break; case 1: p.edit -= 1; break; case 4: editChar++; break; case 5: editChar--; break; case 6: out = ~editChar; break; case 7: out = cmdChar &amp; editChar; break; } OR maybe function pointers: opFunctions[op](userData); // opFunctions is an array of function pointers for different ops indexed with op.
Some compilers also understand a single-line include guard, GCC and MSVC6+ included: ```#pragma once```
You could use a `switch` there, pretty useful when you've got more than three `if/else` blocks, so you don't have to keep repeating an `if/else if` instruction so many times: switch (op) { case 0: p.edit += 1; break; case 1: p.edit -= 1; break; case 4: editChar++; break; case 5: editChar--; break; case 6: out = ~editChar; break; case 7: out = cmdChar &amp; editChar; break; }
This isn't ugly, it's nice and verbose. I would add {} braces.
I don't think that's so ugly, to be honest. &gt; Like maybe a list of functions or something? Idk if that's possible. Yes, it is possible, and it's a fine way to do this as well: typedef void (*opfunc)(void); void op0(void) { p.edit += 1; } void op1(void) { p.edit -= 1; } void op4(void) { editChar++; } void op5(void) { editChar--; } void op6(void) { out = ~editChar; } void op7(void) { out = cmdChar &amp; editChar; } // ... opfunc ops[] = { op0, op1, NULL, NULL, op4, op5, op6, op7 }; ops[op](); I assumed that `p` and other variables were globals. It might be better to pass them as function arguments instead. C doesn't have lambdas, a feature that makes code like this even more clean to write.
&gt;in OOP languages you also have only one implementation per interface most of the time, apart from mock objects in unit tests No you don't. If you do, you're doing it wrong. If you don't need more than one implementation of something, don't create an interface just because. Use the concrete class and be done with it. The reason for interfaces is to allow multiple implementations like the OP wants to do. Inversion of Control and dependency injection is all about multiple implementations of things. So you need some kind of polymorphism, which you can achieve in C with the header+implementation separation but it only allows a compile time kind of polymorph, which is only useful if you know at compile time which will be the implementation. If you need multiple implementations coexisting or you don't know at compilation time which implementation you need, it's useless for DI.
switch {case: } more better than if else
It’s nice because it’s easier to write. A switch statement however is better practice for readability and maintainability purposes.
Use a switch statement or an array of function pointers. Get rid of the magic numbers. Define them as macros named for what they're supposed to do. Other than that, it looks good.
This can be simpler, even - I think a single `sudoku_solver: main.o test.o` would do the trick here. Make figures out the rest with its default rules, and you get incremental builds for free :)
Why do you say that?
how are you compiling? are you running what does your gcc call look like? try: gcc -o foo main.c test.c also someone already suggested taking a few minutes to learn how to set up a basic make file. It might not be worth spending a week on but an hour or two would be plenty to get you going and save you time.
&gt; Like maybe a list of functions or something? That's what I would have done. A hash map consisting of values and **function pointers**. It would be much easier to maintain, update, and reuse than if/switch statements.
Thank you!
Several people mentioned function pointers, but I think that would make it harder for the compiler to optimize the program and give no real benefit.
if (op &lt; sizeof ops / sizeof ops[0] &amp;&amp; ops[op]) ops[op]();
It’s not online, but if your reason for asking is because you don’t want to compile, there is a CH tool which is a C interpreter.
This actually fixed it. recvSize = recv(sfd,buf,sizeof(buf),0); buf[recvSize] = ‘\0’; IRC uses /r/n to terminate lines, so printf would just keep printing the rest of the buffer because there was no null byte
I vote for the switch statement from BadBoy6767 combined with **symbolic constants** for the operation numbers. Compare readability: switch(op) { case 0: p.edit += 1; break; case 1: p.edit -= 1; break; case 4: editChar++; break; ... Versus switch(op) { case ADVANCE_EDIT_COUNT: p.edit += 1; break; case WITHDRAW_EDIT_COUNT: p.edit -= 1; break; case ADVANCE_EDIT_CHAR: editChar++; break; ... Make some #defines, or an enum, or something. And I've *no real clue* what proper operation symbolic constant names should be -- all I've got to go on is pairings like `(0, p.edit += 1;)` to haphazardly guess what the hell is *supposed* to be going on here / what action is trying to be accomplished. Give 'em good names and then an order of magnitude of documentation will be *pre-written*! Those bare, meaningless integers are a maintenance and conceptual liability. Could *you* even see the obvious bug with: case 1: p.edit += 1; break; as opposed to: case WITHDRAW_EDIT_COUNT: p.edit += 1; break; ?
Sorry, bit of a late response. But running `gcc.exe` says that it is missing `libwinpthread-1.dll`. I looked up what causes this, and I attempted to fix it by adding MingW's bin to my system PATH. However, it still throws the same error.
Um, `bin` should contain _executables_, not libraries, to my mind. Try adding MinGW's `lib` path to `PATH`. Also make sure that WinPthread is actually installed. I think MinGW should have a package manager.
(op == 0) ? p.edit++ : (op == 1) ? p.edit-- : (op == 4) ? editChar++ : (op == 5) ? editChar-- : (op == 6) ? out = ~editChar : (op == 7) ? out = cmdChar &amp; editChar : false;
 Alternately: p.edit += (op==0) ? 1 : (op==1) ? -1 : 0; editChar += (op==4) ? 1 : (op==5) ? -1 : 0; const char nout = (op==6) ? (~editChar) : (op==7) ? (cmdChar&amp;editChar) : 0 ; if ((op&amp;6)==6) out=nout; ... which is perhaps even uglier.
I’d use a hashmap, with the key being the OP code, and the value being a pointer to a function that should be ran.. this way you can easily add more to it as your code scales.
I want to compile on a smartphone, but Android security won't let me execute the compiled file. So, I'm looking for an online solution as a workaround. Yes, there are apps that compile and run, but none of them work with #include "myheader.h".
First, give names to these operations. It's really easy to get things wrong without names, so start with an enum like this: enum OP { OP_INCREMENT, OP_DECREMENT, OP_WHATEVER }; But then after that, I would do as the others are suggesting and use a switch statement. It looks fine, there's no real way to clean up a big list of operations like that. Most emualtors or virtual machines have a big switch statement at their core, it's honestly the best tool for the job.
I second this. Unless I know that I'll be targeting platforms that don't support this pragma, it's substantially more readable to use.
Do you just go around reddit threads being a dick to people instead of answering?
Some times. In this case though, I believe that learning C using only compilers forms bad habits and should be avoided.
I like ternarys, but chaining ternary statements together looks confusing and odd.
&gt;a fact the authors of the Standard took note of in the rationale when deciding that there was no need to have unsigned short values promote to unsigned int in cases like: I'm confused about what you mean here. Doesn't the standard mandate that arithmetic can never occur on types with rank less than int? And that some sort of promotion must therefore take place?
Before the Standard was published, there was some variation among compilers as to whether \`unsigned short\` should promote to \`int\` or \`unsigned int\`. I don't think there was ever any doubt, however, about whether commonplace compilers should be expected to process \`uint1 = ushort1\*ushort2\` in artihmetically-correct fashion for values from \`INT\_MAX+1u\` to \`UINT\_MAX\`. According to the Rationale, the authors of the Standard didn't it necessary for the Standard would need to make any provision for such cases \*because commonplace compilers would handle them anyway\*. As it is, however, gcc doesn't handle such cases reliably.
Answer is b, though I must ask why you're asking on Reddit instead of just trying it yourself?
This feels like homework. Username checks out? Regardless, it's (b). The -S flag stops after compilation, it doesn't assemble the binary.
It seems that the spheroid is bigger than we imagined
I see it a lot when working with verilog
 **int rand(void):** returns a pseudo-random number in the range of 0 to RAND\_MAX. **RAND\_MAX:** is a constant whose default value may vary between implementations but it is granted to be at least 32767. &amp;#x200B; So you can generate pseudo random between 0 and 1000, a lot of them, and with the law of great numbers you will get what you want...
The benefit with array of function pointers is that your method could be closed for modification and if more cases are added to that single method , the method may suffer from long method code smell and will always be open for modification. This will favor OCP principle.
Termux should work. It executes all programs in it's own app directory which has executable permissions.
void DoStuff (struct result \*a) { a-&gt;result = a-&gt;number\_to\_process \* 2; } on main: struct result res; res.number\_to\_process = 10; DoStuff(res); printf("result is: %d", res.result); before main: struct result { int number\_to\_process; int result; } ; and you are done...
I just don't want to rewrite it tho. The majority of the code is already written, I just wish I would've thought about the architecture a bit more upfront. Not sure what exactly I'll do, but I'm sure I'll figure something out, I always do.
This level of micro-optimizations are not worth worrying about in general. Write code optimizing for clarity. If it's too slow when you're done, use a profiler.
I find switches to be insignificant compared to if...else blocks, unless you're taking advantage of fallthrough behavior. I mean, I still prefer a switch; but I wouldn't call it ugly as an alternative to an all-break switch block.
you could try to use valgrind https://de.m.wikipedia.org/wiki/Valgrind
why are you using this "op" variable anyway? You need to get rid of it, you are using what looks to me like a side effect and it's quite hard to read and debug.
op seems to have 2 fields, direction in lsbit and variable in other bits. Maybe it would make things more clear if they were separated.
Why?
This is hardly micro-optimizations ... I think the original code is clearer than the function pointer version anyway. If the code for each "function" gets more complicated then I'd still prefer a switch with function calls.
This is the answer. I'd also add a `default` as a failsafe.
For many conditions, switch/case create much better binary code than if/else.
Clean and beautiful :)
TBH, I think people getting their homeworks solved online is good if they also learn other things being said here.
You may be an executable but you do not get the permission to run.
If it can optimize it down to a jump table, sure. But that requires dense, sequential cases. Otherwise, the generated code is pretty similar. In addition, an if...else sequence allows you to use ranges (some compilers, such as GCC offer their own support for this in switches) and complex conditionals to concatenate multiple cases in one. I'm not saying either is better. I'm just saying, an if this ... elif this ... else ... vs a switch block isn't necessarily code smell and there's only an obvious benefit with fallthrough logic. You're not saving many lines of code and they're both just as readable.
`man gcc`.
won't this make it absolutely unreadable long-term?
I think you may also benefit from a better structure. Some operations are very similar, for example +1 and -1, and could be merged into a single operation. int operation = op / 2 int direction = op % 2 : -1 : 1; switch(operation) { case 0: p.edit += direction; break; case 1: editChar += direction; break; case 2: out = direction == 0 ? ~editChar : cmdChar &amp; editChar ; break; }
I tried Termux but got the same permission error.
Yes, I have now reached that conclusion.
Yeah, that will work, though I prefer to set CFLAGS/CPPFLAGS for warnings/debug flags etc. My version would be somewhere between /u/tdaquino's and yours ;)
Beats me. Depends on the reader. I've become accustomed to that idiom so...
Oh, I agree that a switch statement is cleaner. I'm just saying no one should be worried about what the computer can optimize until (a) you know you need it, and (b) a profiler tells you to look at that function. Sweat big decisions like algorithm choices and don't waste time on trying to predict register allocations and helping the compiler lift common subexpressions and the like. You're unlikely to guess what a modem compiler is able to do anyway. You can always focus your attention on hotspots later if it matters.
A lot of the glib functions will look at first glance as though they are redundant with library functions. This is because they are meant to be platform agnostic - glib is primarily a cross platform standardization library. You can run g_printf on any platform glib is made for and get the same results. You don't have to worry about platform specific quirks or limitations.
That is the documented *potential* difference. GLIB is ported to more platforms than whose libc's `printf` implementation may conform to the Standard Unix Specification's (SUS) (what used to be known as POSIX) "new" (relatively in POSIX terms) refinement for `printf` to support positionally named parameters. Here's an example using glib: ``` #include &lt;glib.h&gt; #include &lt;glib/gprintf.h&gt; int main() { int x = 22, y=45; g_printf("%2$d / %1$d / %2$d\n", x, y); return 0; } ``` and here's the same example using `printf`, which works for me on OSX 10.13. ``` #include &lt;stdio.h&gt; int main() { int x = 22, y=45; printf("%2$d / %1$d / %2$d\n", x, y); return 0; } ``` The result of either: ``` $ ./a.out 45 / 22 / 45 ```
Just a little nitpick: SUS did not replace posix, POSIX is a (major) part of SUS. For many purposes you only need a POSIX compliant environment, not everything SUS contains.
Thanks! I was only aware that SUS came *after* POSIX, so figured that the standard lives on under a new name.
Most college programming classes (especially for nonmajors) are a basic introduction to a language or a set of programming techniques. They basically teach you enough to be able to learn on the job or to keep learning on your own with personal projects. Even after years of programming, you'll find commands and techniques that are totally new to you in your favorite languages. If you see things used here that are unfamiliar, that's a big green flag pointing you toward your next learning opportunities. Visit your favorite C sites and start digging around. If you're still not quite clear on the concept your learning, you can always ask for feedback and direction here in the sub.
So they should teach you, \- kernel development \- OS development \- driver development \- graphics development \- audio development \- microcontroller development \- networking development \- compiler development \- browser development \- games development \- mathematical and general scientific tool development \- database development \- data structures and algorithms And whatever other topics I've forgotten, in a C course in college. They do teach(or at least introduce) most of this over the course of a four year comp sci program but to deep dive any of it would take a decade of study.
It's not possible to teach everything in one class. Programming is a huge topic, and even those practicing for years don't know everything. Instead, now that you know the basics, you should be able to research and learn on your own what you're missing as you run into it. For example, if you're seeing `struct`s, then just do a search and learn about them. Here's the [Wikipedia article](https://en.wikipedia.org/wiki/Struct_(C_programming_language%29), but there are hundreds of free sources to learn about them online. You should be thankful that they don't teach everything, as that would take ten years and you would have to learn a lot of stuff you'll never use. This way you can learn just what you need. Besides, life-long learning is fun.
I agree, this does not seem possible.
**Struct (C programming language)** A struct in the C programming language (and many derivatives) is a composite data type (or record) declaration that defines a physically grouped list of variables to be placed under one name in a block of memory, allowing the different variables to be accessed via a single pointer, or the struct declared name which returns the same address. The struct data type can contain many other complex and simple data types in an association, so it is a natural type for organizing mixed-data-type records such as a hard-drive directory entry (file length, name, extension, physical (cylinder, disk, head indexes) address, etc.), or other mixed-type records (patient names, address, telephone... insurance codes, balance, etc.). The C struct directly references a contiguous block of physical memory, usually delimited (sized) by word-length boundaries. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
`struct`'s are an integral part of the C language and to not learn about them in a C language class seems like a pretty major fail to me.
An unsolved mystery!
probably some gnu embrace extend extinguish shit.
You didn't learn about fucking structs in college? What shithole of a college did you go to?
&gt; unless you're taking advantage of fallthrough behavior. This, Honestly I avoid switch statements unless I know before hand that I'll want to take advantage of fallthrough.
That's not at all accurate. The code is exactly the same: https://godbolt.org/z/QXzVPI
I’ve only taken a 2000 level course but we covered (in order) types, variables, if/if else statements, loops, arrays, pointers, strings, structures/typedefs, file I/O and multi-file projects. We briefly touched on unions and OOP concepts. I haven’t taken the 3000 level Comp Programming II course yet so I’m not sure what it covers but both courses use C as the language.
I prefer using an enum for constants like that. Then the IDE will auto fill out Switch statements for you, and it can check for overflow or things not existing in the enum as well.
What do you mean with “codes?” That's a weird word.
Go to "Settings -&gt; Debugger -&gt; Default -&gt; Arguments" and clear your `-G` flag. Done. If you meant to use the `-g` compiler flag to add debugging symbols you should restudy your compilers. But anyways, codeblocks already adds it if you build in Debug mode, but the option is here: "Settings -&gt; Compiler -&gt; Compiler Flags -&gt; Produce debugging symbols" and check.
Sounds good and sensible. You youngsters with your “Eye dee ees.”
We don't know anything about his class. It could have been a one week class for complete beginners, in which case it would make sense to omit `struct`s. On the other hand, if it was a semester-long class for people with previous programming experience, then yeah, `struct`s (and much more) should have been covered. In any case, OP's expectation that &gt;that they should teach us everything! is not reasonable.
Hello , thank you for answering I went in arguments and there's no -G flag 😓 I also wen on settings compiler and couldn't find any -g flag checked in the list... I don't know what else I could try. Do you know any more reason it could continue to have this error? Anyway thank you very much for answering since a lot of people are downvoting my post for who knows what reason
I've been using c on my own for two months and I'm already familiar with them. It's not the college it's the student
I'm also self-taught, that's why I asked lol.
 struct test_struct; This doesn't define a global object. It declares an incomplete type. `main` needs to know the complete type of the struct in order to access its elements. So `test.h` needs to contain something like struct talker { void (*say)(); }; extern struct talker test_struct; And then `test.c` can contain the definition of the function and the global.
That's odd. Check you are logging the full command line here: "Settings -&gt; Compiler -&gt; Other settings -&gt; Compiler logging: Full command line" Then: "Build -&gt; Rebuild" Paste your build log here. And print this window just in case: "Settings -&gt; Compiler -&gt; Toolchain executables"
Usually these ideas come when you need something to help you. Think of an everyday process you do that you can make faster (EDIT2: but beware of https://xkcd.com/1319/). OTOH, are you interested in any fields of computer science such as compiler theory or game development? You could try making a programming language or a fancy game with SDL2, or do something for any other field you may be interested in.
Some cool projects I did for fun over the past 5 years: **8080 suite**: A pack of three softwares: an assembler, a disassembler, and a virtual machine for the [Intel 8080 ISA](http://pastraiser.com/cpu/i8080/i8080_opcodes.html). I guarantee you will be on a completely different level after making this. You will gain a deep understanding of how computers work, and you will learn how to transcend the compiler and go beyond C. A must for the hard geeks striving for mastery of their machine. ----- **Raytracer**: A simpler program, which will challenge your ability to transform real-life mathematical problems into computer science problems. It is more "down to Earth" compared to the 8080 suite, but do not underestimate how deep the raytracing rabbit hole goes. If you're into maths, it is a beautiful example of how vectors are able to link what you see from what you write down. I highly recommend it. ----- **Memory allocation suite**: I won't beat around the bush. Aim for the stars, recode `malloc`, `calloc`, `realloc`, and `free`. This will greatly improve your understanding of the platform you're working on. While it seems daunting at first, **it is an essential step** in any programmer's quest for mastery. ----- **Small tools**. I can't stress this enough: At some point in your journey to mastery of programming as a whole, you will be yearning for tools to accomplish certain tasks. Some already exist. Some can be made in bash. Some must be tailored by yourself. Do you need something? *Make it.*
This is equivalent to: void test(struct tp *x) { memcpy(x, &amp;(struct tp) {22, 22.35}, sizeof *x); } ... which is a byte-for-byte copy from one object into another. The copy from the compound literal (which has automatic storage duration) into `x` (of unknown storage duration) is significant here. Undefined behaviour would arise if you were to return a pointer to the compound literal, on the other hand, because that'll cease to exist when `test` returns (where-as the object pointed at by `x` will continue to exist). I assume [that's the U.B. you're afraid of running into](https://wiki.sei.cmu.edu/confluence/display/c/DCL30-C.+Declare+objects+with+appropriate+storage+durations) in this case. On an interesting sidenote, it is legal to return a `struct` containing an array with automatic storage duration (but not either pointer), providing you don't access that `struct` beyond the sequence point terminating the expression being returned to. That is to say, given: struct array { char elem[42]; } struct tp test(void) { return (struct array) { 0 }; } The following are some well defined examples: - `struct array valid = test(); valid.elem[0]++;` - `char valid = test().elem[0]; valid++;` ... where-as the following are undefined behaviour: - `test().elem[0]++; // erroneous!` It is undefined behaviour to attempt to modify the result of a return value (you need to make a copy) - `char *fubar = test().elem; (*fubar)++; // erroneous!` After that first `;` the pointer points into what was once an object but is no longer guaranteed to be (again, copy the return value)
Truth hurts GNU-fanboys... _muh feelings!_ ;) It's pretty much the bottom line, though... `printf` is standard, where-as `g_printf` is (probably) GNU-specific.
I'll admit that I'm assuming a &gt;C language subject in college is a full term/semester course; I'm going off of my own experience with a C language college course on this. And I'd agree with your assessment regarding OPs expectations - you aren't going to learn everything about \*any\* programming language in a single course.
This is a common question by new programmers so I have a list of projects that can be done with basic IO facilities. https://www.reddit.com/r/cpp/comments/3kkjwf/some_c_projects_for_beginners/cuy6u5t/ Several of these demonstrate that basic IO is capable of more than just text based IO between the program and an interactive human user. Of course even the 'typical' uses of text based input and output can be put to endless, interesting uses. 1. A chat-bot using markov chains to construct new sentences from user input. 1. An old-style text adventure game. 1. A program to compute orbital maneuvers from one orbit to another (see the 2009 ICFP problem) 1. etc.
Wow, thats a great website, i havent seen that before. I see your correct with LLVM in that example, but add some more conditions, and switch to GCC [https://godbolt.org/z/OrIwwq](https://godbolt.org/z/OrIwwq) &amp;#x200B; (i might switch to LLVM)
It's not a micro-optimization, but it *is* a premature optimization. There is no purpose in optimizing something unless it is slow. And neither of those will be slow. I agree, though, that it's less readable.
Uh Yeah? It's a library providing a function. Is there something wrong with that?
The G in GLib comes from Gnome and not GNU. You fucking retard.
An oof of worth
A stupid Jordan Peterson taint licker like yourself is too dumb to code.
The G in GNOME stands for GNU
Thank you, tomorrow I'll send you the log!
we are interested in repeatability so no srand() and inputs neccessary.
Use a switch statement to keep track of each 1,2,3,4.5,6 roll.
create variables for the stuff you wanna store and increment the variables each time you get it. so for example long head_amount = 0; if (heads) head_amount++;
No of course not. They don't know the difference between glibc and GLib. Ignore them - they just spew some uneducated hatred
The G in GNU stands for GNU.
I know but that's not really relevant I think. "GLib is the low-level core library that forms the basis for projects such as GTK+ and GNOME" https://developer.gnome.org/glib/2.60/ No GNU monsters in there. Just a very useful library.
 uint32_t coins[2] = {0}; for (uint32_t i=0;i&lt;1000000;i++) { coins[rand()&amp;1]++; } printf("There were %u heads and %u tails\n", coins[0], coins[1]); uint32_t dice[6] = {0}; for (uint32_t i=0;i&lt;1000000;i++) { dice[rand()%6]++; } printf("Here are the dice rolls:\n"); for (uint32_t i=0;i&lt;6;i++) { printf("%u was rolled %u times\n", i+1, dice[i]); }
Is there any tutorial or through description of these things to get my feet dirty? I've looked into all project based C ideas but I feel like, at my stage, I still need some hand holding to go through them in a project.
I checked in C mode to see if it got better with gcc and it didn't, but with Clang, they're both still the exact same.
Maybe you want a [factory](https://en.wikipedia.org/wiki/Factory_method_pattern) ?
This is unreasonable. If you give a one-week course and don't have time to teach students about structured data, then you simply cannot make a one-week course to teach a programming language.
Neither glibc (which is an implementation of the standard library) nor glib are authoritative of the standard C programming language... u/Elronnd and u/prdolinosagrahom: Where are your books?
&gt;The G in GLib comes from Gnome and not GNU. Actually, all of the code came from GTK... and the G in GTK came from GIMP... and where do you think the `G` in GIMP came from? Get your facts straight. As for [GNOME](https://www.gnu.org/software/software.html), and I quote... &gt; Links to the home pages of all current GNU packages are given below, using their identifiers (rather than long names) for brevity. &gt; ... gnome Everything that comes from GNOME comes from GNU... _you fucking retard!_
Brackets do not matter with XOR since XOR is a logical mixing operation (which is also why it's so neat): (0x55 ^ 0xAA) ^ 0xAA = 0x55 No need for a calculator, the AA ^ AA cancels itself out leaving behind 55.
Is there a question here? It looks like you've worked out an answer yourself.
In general, xor'ing with the same value twice returns the original value. a = value; b = who_knows; a = a ^ b; // Some random yadayada a = a ^ b; // Well waddaya know, it's back to value This little principal has a lot of practical uses. Look up "xor cursor" for some interesting reading. As one super simple value, suppose a is a bigint (integer of unlimited size) and b is a bigint at least as long as a. Further, b is a closely guarded secret that your enemies don't know about. Further further, you never *ever* use the same value for b twice. Now you have the most secure crypto algorithm known: the "one time pad". An interview question you might get someday: How do you swap two integer variables without using a temporary variable? The solution: a = a ^ b; b = b ^ a; a = a ^ b; Try it yourself with a few assorted values for a and b. This has almost no practical use at all, but it's an interesting abstraction, and once you understand how it works, you'll understand the xor operation better.
All of the code came from the project formerly known as GTK+. Also, the page linked by your "citation" doesn't actually contain your "quotation", which makes me think you don't know what it means to "cite" something. Here's how I'd paraphrase "citation" for *complete fucking retards*: You take the original text, copy and paste it and wrap quotation marks around it. Then you put your source. For example: &gt; Original text: For more complete information about the GLib routines, see the GLib documentation. One source of GLib documentation is http://www.gtk.org/. &gt; Paraphrased: "For more complete information about the GLib routines, see the GLib documentation. One source of GLib documentation is http://www.gtk.org/." &gt; Source: &lt;https://developer.gnome.org/gtk-tutorial/stable/c2023.html&gt;
0x55 is 01010101 xor 0xAA is 10101010 Result is 11111111 Xor with 0xAA you get 01010101 (0x55)
*ad hominem*
Just put an if statement in the for loop that checks what is flipped and then increments another variable.
This is not a C question.
Everyone can write.
You're sort of missing the point of the question to be asking this, the idea is that you look at the given code and conceptually work through it on paper or in your head to learn how the variables are tied to memory. Just copying it into a program and picking the answer defeats the purpose.
This has absolutely nothing to do with the C programming language.
733 corresponds to -rwx-wx-wx So... Owner (cs1521) rights: Read, Write Execute Group (cs1521) rights: Write, Execute Others (everyone) rights: Write, Execute The answer is (e) -- everyone can write to the file.
In addition to this, it seems to me like this is just one of _many_ errors that would have been avoided elegantly by reading a book... but what do I know? I "learnt C by guessing and observing", up until realising how flawed that method was, and then it was incredibly difficult to correct my understanding, after all!
&gt;It's a library &gt; &gt;providing a function. Note how I addressed this argument with the following: &gt;Neither glibc (which is an implementation of the standard library) nor glib are authoritative of the standard C programming language... &gt; &gt;To be clear, if you want to write non-portable code, that's your choice, and there's nothing "wrong" with that choice... Thus technically your argument is an example of ab **appeal to false authority**. &gt; &gt;u/Elronnd and u/prdolinosagrahom: Where are your books? &gt; _ad hominem_ [Projection](https://en.wikipedia.org/wiki/Psychological_projection). My quote above was not ad hominem because it doesn't attack your character; it's merely asking where your books are (hint: pre-empting the following request for authoritative citation). The inductive reasoning behind the question is that if you had your books (which teach C programming) in front of you at the time you were looking for support of your own argument, you'd have noticed... _there is no support_! Want to use logic? That was my plan the whole time... **Show me a single book that claims to teach the C programming language which uses `g_printf` instead of `printf`...**
**I notice the 2nd rule for this group is as follows:** #(Only C is on topic) Since you want to use _ad hominem_... I apparently must be quite blunt with my argument. When I wrote the following: &gt; `printf` is standard, where-as `g_printf` is (probably) GNU-specific. ... what I really meant was... &gt; `printf` is standard, where-as **`g_printf` is NOT**. Please show me where in the C standard there's any mention of `g_printf`, my _retarded_ GNU/GTK/GNOME (they kinda go hand-in-hand) fanboy of a friend...
Off-topic for this group, has absolutely nothing to do with C programming. You probably want r/unix or r/sysadmin ...
*printf("%s", test\_struct.say);* You mean %p ?
Here's the manpage of chmod, it should explain your problem [https://man.openbsd.org/chmod.1](https://man.openbsd.org/chmod.1) &amp;#x200B; 4 = read 2 = write 1 = exec &amp;#x200B; The sum of that numbers combines the rights, so a 3 is 1 + 2 (write + exec) First digit: owner Second digit: group Third digit: the rest
&gt; I don't know how to make it count Head or Tails Seriously? This is a basic problem taught in primary school... I think you just need to think about it some more. &gt; ... and Count how many number 1,2,3,4,5,6 in percentage. Let's say the dice lands on side X 14 times out of 50. Work out the percentage. Again, this is fundamental mathematics. You probably just need to use your brain a little bit. Heaven forbid should we have to do that to learn how to program?
&gt;Thanks for doing my assignment for me... I'll take all of the credit, and come back to this group for more spoon-feeding later on! Hopefully I can get high distinctions without ever learning a thing, so if you and I are pitted against each other in a job interview, I'm sure to get the job, even though I technically cheated my way through the whole thing! Don't be a chump. You're not paid to do these peoples homework for them. All you're doing is making it worse for you, and for them, too... in fact, you're kind of insulting them by assuming that they're not actually going to understand the explanation, like... _ohh, you'll never get it... I'll just do it for you!_ Remember, the purpose of their homework is to exercise their minds... if you spoonfeed them, all they do is copy+paste, and hey... presto!
Hi everyone, I have started learning c programming in one of the workshops near by. They gave us a small interactive assignment a while back but I finally started to work on it. It is a ticket management system to queue people in a line, I made a flowchart on this but I have no clue what to do from here. Any input would be great to restart my learning
&gt;I have no clue what to do from here. Any input would be great to restart my learning I'd start with &amp;#x200B; #include &lt;stdio.h&gt; int main() { and end with return 0; } If you actually wrote some code and ask for specific questions, I'd really help, but that thread is the peak of lazyness
Could you tell us more about the assignment? I'm having trouble understanding the system your flowchart describes. Bit of stretch here without having more context; but you may want to look into state machines. They are a fairly simple algorithm to program and can give you a good structure to begin solving most problems.
lol... it seems a lot of answers here have this belief that _extra boilerplate_ makes things _less ugly_. Personally, I think there's nothing wrong with your solution as it currently stands... and I'd just move on to the next exercise. Function pointers aren't necessary unless you want the environment to be dynamic (for example, maybe you want to shuffle the actions around). `switch` isn't necessary unless you want to use cases that carry through into each other. Both of the aforementioned methods introduce boilerplate crud which you probably don't want. As I said earlier, I think your code is fine just the way it is... However, if you're a perfectionist seeking brevity and expressive power you might consider using the ternary operator here, as I see u/pigmonkey10 did below, but perhaps with a little more thought put into formatting... For example: ( op == 0 ? p.edit++ : op == 1 ? p.edit-- : op == 4 ? editChar++ : op == 5 ? editChar-- : op == 6 ? out = ~editChar : op == 7 ? out = cmdChar &amp; editChar : fputs("Invalid operation...", stdout) ); This example assumes the result is common (that is to say, they're all `int`). If that turns out not to be the case, this might not work out so well. On optimisation (since I have no doubt someone will interject on that matter), our compilers should be [more than capable of optimising this into a jump table](https://ridiculousfish.com/blog/posts/will-it-optimize.html) if necessary, though I really doubt this portion of code is likely to be responsible for a significant bottleneck in any kind of real-world scenario.
ok, ill post the codes within 3 days and ask for problems
It's pretty common if all you ever complete is a CS 101 course catered for non-CS majors. In my CS 101 class we were taught "C," but it wasn't until 6 years later that I realized we had actually learned a C-like dialect of C++. (think C89 plus iostream) We never covered structs or pointers. If I remember correctly, our programs were just incredibly long main.c files without any other headers or sources. I only learned control flow and basic io/math.
yes, we dont have to code any UI for this one. It is a queue system where i have to have a person at a hospital press a number to produce a token, a counter will call the token number when it is free and the counter has to save the token number, date, and the number of people served. The token number should not exceed 1000
for counter 1,2,3,4 you can write a function as all are same and use queue ds for it. Your left side diagram is incomplete/unclear, yes/no on many branches is missing.
&gt; &gt; _ad hominem_ &gt; [Projection](https://en.wikipedia.org/wiki/Psychological_projection). Edit: Also, [paraplaxis](https://en.wikipedia.org/wiki/parapraxis). Do tell. &gt; My quote above was not ad hominem because it doesn't attack your character; it's merely asking where your books are The only *reasonable* (or, given you seem to like it so much, *logical*) inference that could be drawn from that (rhetorical) question was that it was an attack on our respective characters, implying that we were insufficiently well-read to express an opinion on the matter. &gt; The inductive reasoning behind the question is that if you had your books (which teach C programming) in front of you at the time you were looking for support of your own argument, you'd have noticed...[sic] *there is no support*! Nope. Uh-uh. Not buying it for a second. Or are you implying it's a reasonable expectation that before commenting on anything at any time, we must all refer to relevant books? Because—no. Obviously, *no*. You replied to me about 3 hours after my comment; did you spend those hours poring over the c standard. You appear to be woefully misguided as to what my argument is; it wouldn't be very logical, would it, to try to argue against it? Since we're bandying around fallacies, care for a [strawman](https://en.wikipedia.org/wiki/Straw_man)? &gt; Want to use logic? That was my plan the whole time... **Show me a single book that claims to teach the C programming language which uses `g_printf` instead of `printf`...** Again, with the scheming and the plotting. If you had a \`logical' point to make, then you should have made it as soon as it was relevant. Anyway, will you do me a favour and look up to the top-left corner of the page? You will note, I am sure, it says 'C_programming'. We are c programmers here, not c standards body members. Most of us use libraries in some capacity or another and, if you'll recall, since the reason `g_printf` was made in the first place was to accommodate broken `printf` implementations, where portability is concerned we're not overly reliant on implementations to conform.
thank you very much, I will try what you said
&gt; #Only C is on topic &gt; &gt;`printf` is standard, where-as `g_printf` **is NOT (nor is it on topic for this group)**. &gt; Please show me where in the C standard there's any mention of `g_printf`, my *retarded* GNU/GTK/GNOME (they kinda go hand-in-hand) fanboy of a friend... Oh, dear. No need for fancy latin roots here, this is just good old-fashioned hypocrisy. In any case, I will humor. `g_printf` is a function, written in c, within a c library, usable from c, compiled with a c compiler, not really useful when using any language other than c. So, tell me how is that not to do with C?
Active debugger config: GDB/CDB debugger:Building to ensure sources are up-to-dateSelecting target: DebugAdding source dir: C:\\Users\\{{FILEPATH}}Adding source dir: C:\\Users\\{{FILEPATH}}Adding file: C:\\Users\\{{FILEPATH}}\\bin\\Debug\\{{PROGRAMNAME}}.exeChanging directory to: C:/Users/{{FILEPATH}}.Set variable: PATH=.;C:\\Program Files (x86)\\CodeBlocks\\MinGW\\bin;C:\\Program Files (x86)\\CodeBlocks\\MinGW;C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath;C:\\Windows\\System32;C:\\Windows;C:\\Windows\\System32\\wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0;C:\\Windows\\System32\\OpenSSH;C:\\Program Files\\Calibre2;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Users\\{{USERNAME}}\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\{{USERNAME}}\\AppData\\Local\\atom\\bin\[debug\]Command-line: C:\\Program Files (x86)\\CodeBlocks\\MINGW\\bin\\gdb.exe -G -lines -2 -y C:/Users/{{FILEPATH}}; -srcpath C:/Users/{{FILEPATH}}; C:/Users/{{FILEPATH}}/bin/Debug/{{FILENAME}}.exe\[debug\]Working dir : C:\\Users\\{{FILEPATH}}Starting debugger: C:\\Program Files (x86)\\CodeBlocks\\MINGW\\bin\\gdb.exe -G -lines -2 -y C:/Users/{{FILEPATH}}; -srcpath C:/Users/{{FILEPATH}}; C:/Users/{{FILEPATH}}/bin/Debug/{{PROGRAMNAME}}.exedone\[debug\]C:\\Program Files (x86)\\CodeBlocks\\MINGW\\bin\\gdb.exe: unrecognized option \`-G'\[debug\]Use \`C:\\Program Files (x86)\\CodeBlocks\\MINGW\\bin\\gdb.exe --help' for a complete list of options.Debugger finished with status 1
A few _minor_ points of criticism... typedef void opfunc(void); // don't mask levels of pointer indirection behind typedef opfunc *ops[] = { op0, op1, NULL, NULL, op4, op5, op6, op7 }; // put that here instead The difference is clear when you're coming at it from a _maintenance_ perspective... putting the pointer in the variable declaration makes it _more immediately_ clear what the base type of the array is, and also simplifies the `typedef` drastically. --- &gt; if (op &lt; sizeof ops / sizeof ops[0] &amp;&amp; ops[op]) I see a problem here... `ops[op]` [needn't convert meaningfully to an integer value](http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3p6). The conversions here could result in some implementation-defined (that is to say, not necessarily portable, could even be _undefined_) behaviours. You're better off implementing your own `invalid` function, like: void invalid(void) { } ... and then you've got: opfunc *ops[] = { op0, op1, invalid, invalid, op4, op5, op6, op7 }; if (op &lt; sizeof ops / sizeof ops[0]) ops[op](); else invalid(); Or, to refactor the `if/else` and function calls: (op &lt; sizeof ops / sizeof ops[0] ? ops[op] : invalid)(); Having said this, the solution in this thread is more complex than the code in the question, even from the very beginning, so I'm not really sure how it answers the question.
Hmmm... maybe use the difference operator? p.edit += (op==0) - (op==1); editChar += (op==4) - (op==5);
\#include&lt;stdio.h&gt; \#include&lt;conio.h&gt; &amp;#x200B; int token, no, no = 0; token = 1; main() { while (no != 2) //so that number keeps looping instead of using return function { printf("1.Get Token\\n2. Exit"); &amp;#x200B; scanf("%d", &amp;no); &amp;#x200B; if (no == 1) { if (token &lt;= 1000) { printf("Your Token number is %d", token); token = token + 1; &amp;#x200B; } else { printf("sorry, we are out of tokens today, please try again later"); } } &amp;#x200B; else if (no == 2) printf("Thank you for your time"); //want to put a return fuction here to repeat the option else printf("Please select an option displayed"); &amp;#x200B; } } &amp;#x200B; after going through my materials and youtube, i made this for the collecting token. But i cant figure out why my ouput for token is 11 instead of 1.
\#include&lt;stdio.h&gt; \#include&lt;conio.h&gt; &amp;#x200B; int token, no, no = 0; token = 1; main() { while (no != 2) //so that number keeps looping instead of using return function { printf("1.Get Token\\n2. Exit"); &amp;#x200B; scanf("%d", &amp;no); &amp;#x200B; if (no == 1) { if (token &lt;= 255) { printf("Your Token number is %d", token); token = token + 1; &amp;#x200B; } else { printf("sorry, we are out of tokens today, please try again tomorrow"); } } &amp;#x200B; else if (no == 2) printf("Thank you for your time"); //want to put a return fuction here to repeat the option else printf("Please select an option displayed"); &amp;#x200B; } } &amp;#x200B; after going through my materials and youtube, i made this for the collecting token. But i cant figure out why my ouput for token is 11 instead of 1.
/u/jeremycw I'd love any pointers you have on this if you have the time!
By this logic, any project written in C is relevant here. If we allow everything that is simply written in C to be on-topic, there are many questions people will pose that are _actually on-topic_ which get drowned out in a whole lot of noisy spam. For example, a Python compiler has been written in C, thus Python is here-by relevant in this subreddit, by your logic. &gt; not really useful when using any language other than c. Nor is `g_printf` useful when using any system other than a GNU-based one (since it needn't exist for those systems)... thus, `g_printf` is irrelevant for ISO-C, perhaps tangentially relevant for GNU-C (which is not really C). &gt; The only _reasonable_ (or, given you seem to like it so much, logical) inference that could be drawn from that (rhetorical) question was that it was an attack on our respective characters, implying that we were insufficiently well-read to express an opinion on the matter. Please refrain from changing the topic (or moving the goalposts, as it were). This group is strictly about the C programming language and nothing else. If you want to discuss the legitimacy of the logical arguments I'm posing, then you should ask r/logic or something. &gt;implying that we were insufficiently well-read to express an opinion on the matter. You aren't an authority on what C is. There's that appeal to false authority again. The only true authorities are our textbooks and standards, which I humble myself to. The standard documents defining C don't care about your feelings. Nor do they care about your opinion. You don't get to have an opinion here; what is C is C and what you think C is is really just one implementation in a vast ocean. &gt;Nope. Uh-uh. Not buying it for a second. This is stone-walling. &gt;Or are you implying it's a reasonable expectation that before commenting on anything at any time, we must all refer to relevant books? It's either that, or we might not be communicating in the same language. Are we communicating in the same language? I use **the English dictionary** to determine what your words mean, and I use **the C standard** to determine what your C code means. &gt;Because—no. Obviously, no. More stonewalling. I'm starting to build a psychological profile of you. You probably don't want that. Grow the hell up! &gt;You replied to me about 3 hours after my comment; did you spend those hours poring over a copy of the c standard? Over the course of my lifetime, sure... I've been developing a C compiler, after all. You have to know the language pretty well to be able to do that. Immediately prior to posting here? No, I'm not a social outcast with nothing better to do with my life than mash F5 on reddit all day long. I've got better things to do; if you don't, I feel sorry for you. &gt;You appear to be woefully misguided as to what my argument is; it wouldn't be very logical, would it, to try to argue against it? Sure. I can argue against it using citations from [the C standard](http://port70.net/~nsz/c/c11/n1570.html#4p5)... I can also argue against it using [actual implementations](https://www.arduino.cc/en/Reference/Libraries), since you seem to like focusing your tunnel vision on a single particular family of implementation... need I repeat that by your logic _any_ library that has ever been written in C can be spammed here? Heck, I could even point you at [some internal documentation](https://github.com/GNOME/glib/blob/master/glib/glist.c#L147) which indicates that [this project uses potentially undefined behaviour (null pointer dereference)](https://github.com/GNOME/glib/blob/master/glib/glist.c#L264)... &gt; Since we're bandying around fallacies, care for a [strawman](https://en.wikipedia.org/wiki/Straw_man)? (Yes, I'm being (slightly) facetious.) By moving the goalposts and essentially executing a form of straw-man yourself, you've again demonstrated [paraplaxis](https://en.wikipedia.org/wiki/parapraxis)... watch out for those Freudian slips! &gt; &gt; Want to use logic? That was my plan the whole time... **Show me a single book that claims to teach the C programming language which uses g_printf instead of printf...** &gt; &gt; Again, with the scheming and the plotting. Why haven't you shown me a textbook yet? I feel like I'm repeating myself... **Where is your textbook?** &gt; If you had a `logical' point to make, then you should have made it as soon as it was relevant. My point is that you need to start citing authoritative references. I was clear about this the moment you started prompting me. Please **start talking about C** and *stop talking about projects that are written in C (but aren't required within C)*. &gt; We are c programmers here, not c standards body members. Some of us, sure... but there are many who _pretend_ that they know C, when they really only know a particular implementation that has subtly different and non-portable semantics to standard C. &gt; Most of us use libraries in some capacity or another That seems like an excuse a spammer will try to use at some stage... &gt; ... the reason `g_printf` was made in the first place was to accommodate broken `printf` implementations ... 1. You'll need to start citing your resources... since I looked up the rationale behind `g_printf` and they don't say this... this is another one of those things *you don't get a say in*... the reason `g_printf` was written was someone elses decision, *not yours*! The world doesn't revolve around you, little sycophant! Grow up! 2. The answer to OPs question is... `printf` is required within a hosted implementation, where-as `g_printf` is not. Technically speaking, in the realm of C, `printf` is more portable than `g_printf`. Not to mention those undefined behaviours I mentioned earlier, eh? &gt; where portability is concerned we're not overly reliant on implementations to conform. Indeed... what's a null pointer dereference between implementations? Grow up. Learn to stay on topic. Learn to read and write English (I have my doubts based on what you're telling me you think defines a formalised language). I've presented my evidence. If you want to refute it, you can start with that standard reference I linked to.
Nice... but it's hard to see what your question is here. I suggest less pointless asking of non-questions and more writing of code. You'll get this task done faster, that way. Let us know when you have some question to ask... and make sure you've put lots of effort into giving us all of the details we need to determine what you're asking so we can answer it. Otherwise, if you keep this, we might just assume you are the boy who cried wolf and *completely ignore you every time*...
thanks for the input. If i can ask you this from my code i did till now #include&lt;stdio.h&gt; #include&lt;conio.h&gt; int token, no, counter no = 0; token = 1; main() { while (no != 2) //so that number keeps looping instead of using return function { printf("1.Get Token\n2. Exit"); scanf("%d", &amp;no); if (no == 1) { if (token &lt;= 255) { printf("Your Token number is %d", token); token = token + 1; } else { printf("sorry, we are out of tokens today, please try again tomorrow"); } } else if (no == 2) printf("Thank you for your time"); //want to put a return fuction here to repeat the option else printf("Please select an option displayed"); } printf("Please select the Follwoing options \n1.TP Card Inquiry\n2.Course Assistance\n3.Payments\n4.Others"); scanf("%d", &amp;counter); switch (counter) { case(1): } } i did this after looking at the course material i recieved online from the workshop, but for some reason, the token produced is 11 instead of 1 and the first digit gets added up, what's going on here?
 long coin[2] = {0, 0}; coin[result]++;
 nullOp(void) { } opfunc ops[] = { op0, op1, nullOp, nullOp, op3, op4, op5, op6, op7 }; ops[op&amp;7]();
Testing a pointer as in ‘ops[op]’ is the same as eating it against NULL. This has been legal in C forever.
Step one: post some code. No idea your ability or even any context (this isn’t a free labour market). Step two: revisit your flowchart, the logic is flawed from the get go. I get what it’s trying to do but if you’re writing code while following their logic you’re not going to have a good time.
The data layout behind handles like HWND is undefined (or you should treat it as such), so you must not read from them directly. Use the appropriate win32 functions.
&gt; Aim for the stars, recode malloc, calloc, realloc, and free. *looks at malloc source code for Linux* Nope!
My specialty is scientific computing, I can't really help you if you're going for the system programming route. My advice would be to recode the `libc`, as well as the `malloc` family. If you need inspiration, I did it and it's available on [Github](https://github.com/Garuda1/unixlib)
&gt;A program to compute orbital maneuvers from one orbit to another (see the 2009 ICFP problem) That one sounds so sweet. Not OP but how did you tackle the n-body problem? It's a real pain to solve efficiently
Whatever the fuck you want.
Fix the formatting of the code so we can help you
Nice!
He's not particularly wrong - for Windows you can install the Mingw toolchain. If you can't do installs on the computer, then possibly not.
C libraries are on topic, too. There is no point in being that pedantic. You two, /u/prdolinosagrahom and /u/cbasschan be civil.
&gt; By this logic, any project written in C is relevant here. As a moderator of this subreddit, I can confirm that every project written in C is on topic here if the post is about the language choice, implementation, source code, or similar.
Be civil.
No yeah, GNUp's allocator is pretty fancy. For an intro systems course, we had to reimplement all of those but calloc, but using a different bookeeping method that isn't as practical, but still helps understand what's going on. Learning the different ways to skin the cat and how GNU does it is helpful to optimize how you yourself use the allocator.
You're passing the data, unless you explicitly pass a pointer using '*'.
In that example, you are passing the value of `i`, not the pointer to it. If you want `i` to be incremented by one, you'll have to use a pointer: void change(int *i) { *i += 1; } ... change(&amp;num);
oh cool this just filled in a gap in my C knowledge I didn't even know I had
And even then, the pointer is passed by value. In fact, C knows only “call by value.”
Never mind, the 11 instead of 1 is gone after I added a switch case for the counters.
The really interesting part of this question is when you dig 1 level deeper. C is (mostly) call by value, the interesting part is, where are those values? On CPUs with plenty of registers, the values are usually placed in registers, and then on the stack when registers run out. On CPUs with limited registers (like x86), some registers are used, but the stack is mostly used. The discussion of which registers are used and when is called the “C calling convention”, it’s a really important part of how C is implanted in a given CPU architecture by a given compiler. See https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019
i have decided to skip the loop between counters and go with a switch case to choose a counter which have been assigned various departments. Seems much simpler. Now i'm trying to learn how how to store the token number for each counter as well as the date and number of people served by each counter. &amp;#x200B; \#include&lt;stdio.h&gt; \#include&lt;conio.h&gt; &amp;#x200B; int token, no, counter, services; no = 0; token = 0; main() { while (no != 2) //so that number keeps looping instead of using return function { printf("1.Get Token\\n2. Exit"); &amp;#x200B; scanf("%d", &amp;no); &amp;#x200B; if (no == 1) { if (token &lt;= 255) { token = token + 1; printf("Your Token number is %d", token); break; //not sure if i need this but i will check it before sending to counter &amp;#x200B; } else { printf("sorry, we are out of tokens today, please try again tomorrow"); } } &amp;#x200B; else if (no == 2) printf("Thank you for your time"); //want to put a return fuction here to repeat the option else printf("Please select an option displayed"); &amp;#x200B; } printf("\\nPlease select a service"); printf("\\n1.Accomodation Services\\t\\t2.Tuition Services\\t3.Course Services\\t4.Documentation Servies"); scanf("%d", &amp;services); &amp;#x200B; if (services == 1) { printf("\\n\\Accomodation Services has been selected, Go to Counter 1"); } if (services == 2) { printf("\\n\\Tuition Services has been selected, Go to Counter 2"); } if (services == 3) { printf("\\n\\Course Services has been selected, Go to Counter 3"); } if (services == 4) { printf("\\n\\Documentation Services has been selected, Go to Counter 4"); } }
For future edification, Google "Pass by reference" and "Pass by value"
As others have said, you're passing the data - the value in question. The actual value gets *copied* into your function, which is why modifying it in function scope doesn't alter the value of the variable in the outer scope. The concrete mechanism by which this happens is platform dependent, and may vary both by compiler and the exact situation (like number of function arguments) even from one function call to another. Using x86 architecture as an example, arguments could be pushed onto the stack, or passed in registers to the function being called. In either case though, the semantics of "mov", despite the implications of the name, copy the argument to the destination. In the case of stack-based parameter passing, the "local" stack frame for the function is discarded either as part of calling "leave" or explicitly after a "ret". (Technically, these values still exist in memory until overwritten, but they are no longer being tracked by the compiler, or in scope for your program). For register-passed arguments, eax (or rax) is generally overwritten on function return, but other register values again may persist briefly, but are not still being tracked by the compiler for your use, and will likely be overwritten shortly. I hope the foregoing didn't just muddy the water for you, but it's a more complete answer as to "how" your data is passed.
That's... All a pointer is, the value of the memory location. I'm confused by what you think would qualify as pass by reference with that statement.
You push `i` to the stack, divert execution to `change`, and pull it back. In assembly code: push eax call change ... change: pop ebx
Both you and me know what the intent of your statement is. A beginner might not and could think (I have actually seen that) that `&amp;` is a magic character that switches the compiler into call-by-reference mode for this one argument, or something equally nonsensical.
If you are passing a pointer as argument, the pointer's value (=address) is pushed to the stack, and the called function will pull the data at that address into a register. You are **always** passing data.
Why do you say “mostly” ? AFAIK, C is always pass-by-value. Even if you pass a pointer, you pass the value of the pointer.
To be even more specific, a pointer is "pass by value reference" since the pointer can be changed and it wont effect the callers pointer.
Oh we can go deeper, it's C, pass a pointer to a pointer and we're getting into really fun territory, lol.
&gt; what are the things we can do with here C Not sure what you mean here (or the entire post, really). C is a turing-complete language with full access to the device, it can do anything.
From the MS x64 calling convention link above: __m128 types, arrays, and strings are never passed by immediate value. Instead, a pointer is passed to memory allocated by the caller. Structs and unions of size 8, 16, 32, or 64 bits, and __m64 types, are passed as if they were integers of the same size. Structs or unions of other sizes are passed as a pointer to memory allocated by the caller. For these aggregate types passed as a pointer, including __m128, the caller-allocated temporary memory must be 16-byte aligned.
The way I see it, arrays and strings are passed as pointers values (ie “an array name decays as a pointer to its first element”). For __m128, it is an implementation detail, the fact that the compiler passes a pointer to the data is not something that the user of the language can see.
The details depend on the architecture and platform. Look up for the calling convention for your CPU arch/execution environment. Wikipedia has a good overview: [https://en.wikipedia.org/wiki/Calling\_convention](https://en.wikipedia.org/wiki/Calling_convention)
**Calling convention** In computer science, a calling convention is an implementation-level (low-level) scheme for how subroutines receive parameters from their caller and how they return a result. Differences in various implementations include where parameters, return values, return addresses and scope links are placed (registers, stack or memory etc.), and how the tasks of preparing for a function call and restoring the environment afterward are divided between the caller and the callee. Calling conventions may be related to a particular programming language's evaluation strategy but most often are not considered part of it (or vice versa), as the evaluation strategy is usually defined on a higher abstraction level and seen as a part of the language rather than as a low-level implementation detail of a particular language's compiler. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
How and when did you move from learning just C to a scientific computing specialty? Forgive me for asking too many questions, I just want to learn how each of these path work - how do people move from just learning to move into a specialty.
I felt like a slave in computer science. Like someone supposed to be treated like a disposable asset and expected to find a new job every month. I dropped out, got depressed, looked into what I truly loved doing. I went to a new uni and started studying chemistry 6 months later. I'm now looking at potential grad programs in computation chemistry, and working at this very moment on computation chemistry software. In the end, the only way to "move" between fields is to do what you love. You love system programming? Then go for it.
Not sure what the question is. The syntax gives you a pointer to an initialized string constant for use in anything that wants to operate on a pointer to a string. It could be passed directly to printf(), for example, or any other arbitrary library function that operates on strings. It could be used as a building block to construct bigger strings. It could be used for any number of different things.
Function arguments are the same as local variables, they're just defined within the arguments part of a function definition and receive values from elsewhere upon execution of the function. If it were passing the original variable definition then you wouldn't be able to do something like this: change(5); It couldn't modify a literal value. Instead it just copies the value - wherever it comes from - to the called function's local variable, being that it's an argument. Meanwhile, local variables are stored on the stack, so what's happening is you're copying the value either from the current executing function's stack to another part on the stack for change to execute on - or from a value on the heap (i.e. malloc/new allocated memory) to change's stack. To modify the value within a called function you'll either want to do something like int change(int i) { return i + 1; } ... int num = 0; num = change(num); ...or pass the address to the value you want the function to modify: // receive the address to an int, deref and increment void change(int *i) { (*i)++; } ... int num = 0; change(&amp;num); // pass only the address to num In this case 'i' is still a local variable but now it only stores an address value to an integer (as far as the C compiler is concerned, but it's still just storing an address value and the fact that it's an integer doesn't matter to the CPU, only to the compiler generating instructions to make the CPU do something meaningful). Once the function stops executing the local variable will disappear and the address will no longer be stored anywhere (unless residually in stack memory, but quickly overwritten by other executing functions), but the original data stored at that address will still exist, as the original variable. As an aside: if you don't have the parentheses around the dereference then what it will be doing is incrementing 'i' as just an address, so if the address to 'num' == 0x12345678 then the 'i++' will simply increment the address that is stored and will then be equal to 0x12345679 and the asterisk will not be doing anything at all, and would just be ignored by the compiler - or possibly produce a warning. Though there are instances where you might want to do not put the pointer deref inside parentheses, such as: int src[sizeofarray], dst[sizeofarray]; int *i = (int *)dst, *j = (int *)src; int x; for(x = 0; x &lt; sizeofarrays; x++) *i++ = *j++; Here we are incrementing a pointer while simultaneously dereferencing it inside a loop to copy one array of values to another - and handling the arrays via just a pointer to the first element in each array. It would be the equivalent of doing this: for(x = 0; x &lt; sizeofarrays; x++) i[x] = j[x]; In the first example i and j will point to the end of the arrays after the loop finishes, while in this example they will still be pointing to the start of their respective arrays after the copy loop.
As strings are char arrays and arrays in C are the same as strings, the notation cost char* is used to express strings in C.
Afaik if you wont plan to alter the string, you can assign the address of the first character of the string literal to a char pointer. So, when you use printf it will start to print the string, character by character until it sees a '/0'. So printf knows the starting point and how many bytes (char = 1 byte) to process each time and where to stop since char* name = "name" is given. If you plan to alter the string you need char name[] = "name". I'm not sure but I guess the first version is stored in the heap and the other is stored in the stack. Please correct me if I am wrong
&gt;If you plan to alter the string you need char name\[\] = "name". I'm not sure but I guess the first version is stored in the heap and the other is stored in the stack. Please correct me if I am wrong As far as I know it doesn't have to do with heap. The following snippet creates a pointer to the string literal which is stored in read-only memory and any attempt at modifying it will result in UB. char *s = "hello"
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
There's always a base payment, so: const float BUSINESS_BASE_PAYMENT = 99.99; const float REGULAR_BASE_PAYMENT = 29.99; Then, there's the number of free minutes you get before stage 1: const int BUSINESS_FREE_MINUTES = 600; const int REGULAR_FREE_MINUTES = 200; There's the stage 1 rate and amount: const float BUSINESS_STAGE1_MINUTES = 100; const float BUSINESS_STAGE1_RATE = 0.45; const float REGULAR_STAGE1_MINUTES = 250; const float REGULAR_STAGE1_RATE = 0.55; Then, you wrap up with stage 2 const float BUSINESS_STAGE2_RATE = 0.99; const float REGULAR_STAGE2_RATE = 0.88; Alright, we got the constants out of the way. I'll just deal with regulars, but it's the same for business. We start off with the base payment int minutes = 476; // this is variable float cost = REGULAR_BASE_PAYMENT; Then, we subtract the free minutes, but we'll get negative minutes if minutes is within the free-minutes range. We'll make sure it doesn't go negative: minutes = max(0, minutes - REGULAR_FREE_MINUTES); Now, we need to get the cost of the number of minutes spent in stage 1, so we'll do the same thing again, but with min: cost += min(minutes, REGULAR_STAGE1_MINUTES) * REGULAR_STAGE1_RATE; Finally, we do the same thing for stage 2: minutes = max(0, minutes - REGULAR_STAGE1_MINUTES); cost += minutes * REGULAR_STAGE2_RATE;
Just FYI, this sub is for C Programming, but... if TempTotalMinutes is less than or equal to BaseMinutes { BillCharge += (TempTotalMinutes * BaseRate); TempTotalMinues = 0; } else { BillCharge += (BaseMinutes * BaseRate); TempTotalMinutes -= BaseMinutes; } if TempTotalMinutes is less than or equal to Stg1Minues { BillCharge += (TempTotalMinutes * Stg1Rate); TempTotalMinues = 0; } else { BillCharge += (Stg1Minutes * Stg1Rate); TempTotalMinutes -= Stg1Minutes; } if TempTotalMinutes is greater than zero { BillCharge += (TempTotalMinutes * Stg2Rate); TempTotalMinutes = 0; }
You’re a life saver! Thank you so much for taking the time to help me out! Been dealing with anxiety and this class for the past week. Thank you thank you THANK YOU!!!!
I'm bored. &gt; By this logic, any project written in C is relevant here. If we allow everything that is simply written in C to be on-topic, there are many questions people will pose that are actually on-topic which get drowned out in a whole lot of noisy spam. So far, that hasn't happened. &gt; For example, a Python compiler has been written in C, thus Python is here-by relevant in this subreddit, by your logic. No. The python language, in the abstract, has nothing to do with c so it wouldn't be on-topic. The CPython implementation of it is absolutely on topic. Is that so hard to understand? &gt; Nor is `g_printf` useful when using any system other than a GNU-based one (since it needn't exist for those systems)... thus, `g_printf` is irrelevant for ISO-C, perhaps tangentially relevant for GNU-C (which is not really C). Wat. `g_printf` has nothing to do with gnu c, [nor does it require it](https://wiki.gnome.org/Projects/GLib/CompilerRequirements). In fact, . On an unrelated note, I do believe gnu c is on-topic in this subreddit; fancy that now! Oh, also, I never realised that [freebsd was a GNU system](https://www.freshports.org/devel/glib20). Huh, TIL. &gt; &gt; &gt; The only *reasonable* (or, given you seem to like it so much, logical) inference that could be drawn from that (rhetorical) question was that it was an attack on our respective characters, implying that we were insufficiently well-read to express an opinion on the matter. &gt; Please refrain from changing the topic (or moving the goalposts, as it were). This group is strictly about the C programming language and nothing else. If you want to discuss the legitimacy of the logical arguments I'm posing, then you should ask r/logic or something. I wasn't changing the topic, I was staying *on* topic; the topic was your rhetorical question. &gt; &gt; You aren't an authority on what C is. There's that appeal to false authority again. The only true authorities are our textbooks and standards and you, apparently. &gt; The standard documents defining C don't care about your feelings. Nor do they care about your opinion. You don't get to have an opinion here Alright, let's establish something here. We're not talking about what is part of the C programming language. That was established long ago. We're talking about what constitutes 'on-topic' in this subreddit. &gt; what is C is C and what you think C is is really just one implementation in a vast ocean Again, with the assumptions and ad hominems. Yeeeesh. &gt; I've been developing a C compiler, after all. You have to know the language pretty well to be able to do that. Have I mentioned I'm also working on a C compiler? I didn't bring it up, because it's actually completely irrelevant to the validity of my argument, but since you seem to want to get into a pissing contest, here; take the piss. &gt; I can argue against it using citations from [the C standard](http://port70.net/~nsz/c/c11/n1570.html#4p5)... I can also argue against it using [actual implementations](https://www.arduino.cc/en/Reference/Libraries) Unclear what the arduino c library is supposed to show or do. Also, neither of those are arguments. But I will humour: g_printf is a standards-conforming c function. &gt; I could even point you at [some internal documentation](https://github.com/GNOME/glib/blob/master/glib/glist.c#L147) which indicates that [this project uses potentially undefined behaviour (null pointer dereference)](https://github.com/GNOME/glib/blob/master/glib/glist.c#L264)... I had low expectations, but I'm *still* disappointed. ***What does some random blob of code in the middle of glib have to do with `g_printf`***?? &gt; [shaved yaks] &gt; &gt; Most of us use libraries in some capacity or another &gt; That seems like an excuse a spammer will try to use at some stage... I believe you said something about stonewalling? &gt; You'll need to start citing your resources... since I looked up the rationale behind g_printf and they don't say this... this is another one of those things you don't get a say in... the reason g_printf was written was someone elses decision, not yours! https://wiki.gnome.org/Projects/GLib/CompilerRequirements#C99_printf_and_positional_parameters indicates it's for libcs who don't support c99. &gt; The world doesn't revolve around you, little sycophant! Grow up! \*yawn\* &gt; The answer to OPs question is... printf is required within a hosted implementation, where-as g_printf is not. Technically speaking, in the realm of C, printf is more portable than g_printf. Not to mention those undefined behaviours I mentioned earlier, eh? No one writes for technical compilers, people write for actual compilers on actual systems. Where g_printf is more portable. Point me to a single undefined behaviour in g_printf.
Whatever C++ reference do?
Looking at this. It helps greatly. I’m a bit lost on how to input the cost of stage 1. Right now I have it set like this. cout&lt;&lt;“Enter the minutes used: “; cin&gt;&gt;minutes; cout&lt;&lt;“Monthly Base Payment: “&lt;&lt;REGULAR_BASE_PAYMENT&lt;&lt;; cout&lt;&lt;“Cost of stage 1 units: “&lt;&lt;
You might like the [Three Star Programmer.](http://wiki.c2.com/?ThreeStarProgrammer)
Annnnyyyttthhhiinggggggg
Is it so hard to use Google? =) [https://www.geeksforgeeks.org/whats-difference-between-char-s-and-char-s-in-c/](https://www.geeksforgeeks.org/whats-difference-between-char-s-and-char-s-in-c/)
&gt;The G in GNU stands for GNU. [https://media1.tenor.com/images/1c50bdbc44d5433fa3c67758dde775d2/tenor.gif](https://media1.tenor.com/images/1c50bdbc44d5433fa3c67758dde775d2/tenor.gif)
could you suggest what kinda feature i need to add,to look its super cool
First and second represent the frequency of the ABC letters in the first and second strings, respectively. a[c-'a'] is simply the index of the current letter (c). Think of it as a counting array - where in index 0 is the frequency of 'a', 1 corresponds to 'b', and so on.
\`a\[c\]\` is a char and so is \`a\`. So you're offsetting the value by \`a\` (0x61 in hex) in order to index into the char array. \`\\0\` is checking for the end of the array, indexed by \`c\`.
I'm assuming what your having trouble with is the expression `a[c] - 'a'`. Basically, as characters are `char`s and are thus integers, we can use them for arithmetic like anything else. But for example, `'a'` will have a value of `97`, which isn't right as `first` only has 26 elements. `'z'` is even worse as it is 122, but the difference between the two (`'z' - 'a'`) is `25`, so using the subtraction we change the range from 97-122 to 0-25 to comply with C and make sure we don't get undefined behaviour.
Does that just devolve into a strange argument about why you want programmers to understand the abstract concept of how to manipulate memory under various conditions?
so i get how the range is reduced from 97-122 to 0-25 using a\[c\] - 'a' in a while loop. But i still dont know how the program calculated the frequency and what the ++ increment is for in this: first\[a\[c\]-'a'\]++;
my reply legit just answered my own question. that was a eureka moment. &amp;#x200B; Thank you kind sir for the quick and adept reply! :)
you are basically repeating code 5 times, so instead of repeating, just put a single piece of code and stick it into a for loop for ( syntax ) { ​ printf("Enter the number of goals for game #1: ", s1); scanf("%i", &amp;s1); while ( (c = getchar() != '\n') &amp;&amp; c != EOF); ​ printf("Enter the number of saves for game #1: ", s2); scanf("%i", &amp;s2); while ( (c = getchar() != '\n') &amp;&amp; c != EOF); sum1 = s1 + s2; ​ per1 = (s2 * 100) / sum1; ​ printf("The percent saves for game #1 is %.1f%% ", per1); }
Maybe something like this? (untested) int main(void) { int s[8]; int sums[4]; int total_sum = 0; int i; float percents[4]; float total_percent; char c; for (i = 0; i &lt; 4; i++) { printf("Enter the number of goals for game #%d", i + 1); scanf("%d", s[i * 2]); while ((c = getchar()) != '\n' &amp;&amp; c != EOF); sum[i] = s[i * 2] + s[i * 2 + 1]; total_sum += sum[i]; percents[i] = s[i * 2 + 1] * 100 / sum[i]; printf("The percent saves for game #%d is %.1f\n", percents[i]); } total_percent = total_sum * 100 / 400; printf("\n\nThe percent saves for 4 games for this goalie is %.1f\n\n", total_percent); return 0; } basically all I did was use arrays and an iterator to stop myself from ever copy and pasting.
 Aur Aur y66 ppp a
You can try rooting.
`&amp;` literally is a magic character that switches the compiler into call-by-reference mode for this one argument. c's call-by-reference mode is pointer indirection, and those pointers can be used for other things, not just as arguments to functions. at the end of the day, though, `&amp;` is a magic character which tells the compiler, "take a reference to this thing," and those references can be passed to functions.
Nope. `&amp;` merely converts an lvalue into an rvalue by taking its address. The argument is still passed by value, but what is passed is a pointer to the lvalue. And pointers are not references because they are not guaranteed to refer to anything.
you're working with a very different definition of "reference" than i am, and i don't think your definition is particularly useful in conversations about c. the c language is designed in a way that equates the concept of a pointer with the concept of a reference. when someone asks, "how can i do call-by-reference in c?" the right answer isn't "c is always call-by-value," it's "use `&amp;` to create a pointer (i.e. a reference) to the thing you want to pass."
Affect
That is correct. Take the address and pass it by value.
Sounds similar to the [producer-consumer(https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem). Also, you will probably want FIFO to keep track of which customers (tokens) are waiting in which line.
**Producer–consumer problem** In computing, the producer–consumer problem (also known as the bounded-buffer problem) is a classic example of a multi-process synchronization problem. The problem describes two processes, the producer and the consumer, who share a common, fixed-size buffer used as a queue. The producer's job is to generate data, put it into the buffer, and start again. At the same time, the consumer is consuming the data (i.e., removing it from the buffer), one piece at a time. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
How much experience do you have with Programming in general? Have you worked with Java, Cpp, etc?
What’s your recommendation for someone already well versed in another language, say Java?
If one is already have experience with another C like languages like Java, I recommend these quick set of notes - [http://cslibrary.stanford.edu/101/](http://cslibrary.stanford.edu/101/) and working through linked list problems to get a handle over C pointer manipulation.
I'm not sure if it's against the rules to advertise subreddit's here, but this one is a good place to start: https://www.reddit.com/r/C_Programming/
It is a elective class, my major have nothing to do coding. I just want to learn coding because i want to try something new.
thanks
I will use switch statement for rolling dice to track 1-6.
I see. Thanks.
Zero.
To make learning C easy, first learn assembly language. 8-bit assembly language would be good because it's simple, easy, and will allow you to understand why C exists and how C works.
https://publications.gbdirect.co.uk/c_book/
This should be generating compiler errors. Please post them, and think about what they mean.
1. Please format your code properly. 2. You pass "amount" to the "greedy" function, but "amount" is never declared? You declare "r", but you never pass it to "greedy", so "greedy" can't use it or change it.
In function 'int main()': \[Error\] 'time' was not declared in this scope \[Error\] 'amount' was not declared in this scope In function 'void greedy(int)': \[Error\] 'r' was not declared in this scope
Adding another case statement is simpler than adding another else if condition imo. Also, if the variable being checked were to change, you would have to change it in every if condition rather than making one change at the start of your switch statement.
 How about something like this ( I am still getting error (r was not declared scope) and I believe I am declaring it as random number from 1 - 99...am I right? srand((unsigned)(NULL)); int amount = r; int r = rand() % 99 + 1; greedy(amount);
You don't need to do that... I learned C on my own without a degree or really any programming before.
Every function has its own local scope. Here you are declaring "amount" and "r", but you are declaring them in the "main" function's scope. Therefore, "greedy" can't use or change them. In the greedy function, you are using the amount variable, which is in scope because it is one of the "greedy" function's arguments. However, you are also using the "r" variable in the "greedy" function, which is not in scope because 1. it is not one of greedy's arguments, and 2. it is not declared in the "greedy" function's scope. So you need to either remove the "r" variable from the "greedy" function, or have the "r" variable be one of the "greedy" function's arguments. Hope this helps. :)
I got 0 percentage, is it the type cast? or my fomular was wrong? &amp;#x200B; \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; &amp;#x200B; int main() { int Count, Count1, RollNum, Start, Stop, coin, dice; float percentage1, percentage2, roll1, roll2, roll3, roll4, roll5, roll6; int one=0, two=0, three=0, four=0, five=0, six=0, Heads=0, Tails=0; Count=0; Start=0; Stop=5; /\*run5times from-- 10, 100, 1000, 10000, and 100000 \*/ RollNum=1; /\*first start with 1. \*/ for(Count = Start; Count &lt; Stop ; Count++) { RollNum \*= 10; /\* R = R \* 10 so it will start 10, 100... 100000\*/ for(Count1 = RollNum; Count1 &gt; 0; Count1--) { coin = rand()%2; if (coin == 1) Heads += 1; if (coin == 0) Tails += 1; dice = (rand () %6)+1; switch(dice) { case 1: one += 1; break; case 2: two += 1; break; case 3: three += 1; break; case 4: four += 1; break; case 5: five += 1; break; case 6: six += 1; break; } } percentage1 = (Heads / RollNum)\*100.0; /\*find percentage how many heads had been flips \*/ percentage2 = (Tails / RollNum)\*100.0; /\*find percentage how many tails had been flips \*/ roll1 = (one / RollNum) \* 100.0; roll2 = (two / RollNum) \* 100.0; roll3 = (three / RollNum) \* 100.0; roll4 = (four / RollNum) \* 100.0; roll5 = (five / RollNum) \* 100.0; roll6 = (six / RollNum) \* 100.0; &amp;#x200B; printf("Coin:\\n"); printf("---\\n"); printf("\\tFlips: %d\\n", RollNum); printf("\\t\\t\\tHeads: %.2f%%\\n", percentage1); printf("\\t\\t\\tTails: %.2f%%\\n", percentage2); printf("Die:\\n"); printf("---\\n"); printf("\\tRolls: %d\\n", RollNum); printf("\\t\\t\\tOne: %.2f%%\\n", roll1); printf("\\t\\t\\tTwo: %.2f%%\\n", roll2); printf("\\t\\t\\tThree: %.2f%%\\n", roll3); printf("\\t\\t\\tFour: %.2f%%\\n", roll4); printf("\\t\\t\\tFive: %.2f%%\\n", roll5); printf("\\t\\t\\tSix: %.2f%%\\n", roll6); printf("\\n\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\\n"); } return 0; } &amp;#x200B; Here is the out put. &amp;#x200B; Coin: \--- Flips: 10 Heads: 0.00% Tails: 0.00% Die: \--- Rolls: 10 One: 0.00% Two: 0.00% Three: 0.00% Four: 0.00% Five: 0.00% Six: 0.00% ... untill Coin: \--- Flips: 100000 Heads: 0.00% Tails: 0.00% Die: \--- Rolls: 100000 One: 0.00% Two: 0.00% Three: 0.00% Four: 0.00% Five: 0.00% Six: 0.00% &amp;#x200B; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ &amp;#x200B; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
As an example of the concept this is correct, but as an example of the mechanics, this is in far from most cases how it works. &amp;#x200B; The first thing that happens when entering a function is usually setting up a stack frame, which is simply storing the old stack base pointer (ebp) and then setting a new one `change:`
I got 0 percentage, type cast? thanks if you can take a look and may give me more advise like formating or new function so it make the code look nice. * source code [https://codeshare.io/50wj3g](https://codeshare.io/50wj3g) &amp;#x200B; and here the out put look like Coin: \--- Flips: 10 Heads: 0.00% Tails: 0.00% Die: \--- Rolls: 10 One: 0.00% Two: 0.00% Three: 0.00% Four: 0.00% Five: 0.00% Six: 0.00% &amp;#x200B; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ &amp;#x200B; ..... until 100000
Thank you and everyone for helping ( I am glad that programming is not my mayor and its only 1 class and if it was my mayor C would not be my first choice for sure)
C is a nice programming language once you understand it. It's simple and very "close to the metal." Although it's probably not a good first programming language to learn, for sure. There are much easier ones out there, like Lua or Python.
As an example of the concept this is correct, but as an example of the mechanics, this is in far from the most cases how it works. &amp;#x200B; The first thing that happens when entering a function is usually setting up a stack frame, which is simply storing the old stack base pointer (ebp) and then setting a new one. A more accurate (and very unoptimized) function would look a bit more like this: `change:` `push ebp` `mov ebp, esp` `add esp, 4; make room for one local int variable` `... Function Body ...` `sub esp, 4; remove local int variable` `pop ebp` `ret` ebp is used in the function body as the base address to access local variables, including passed argument: `mov eax, [ebp + 8]; This gets the last pushed argument` `mov ebx, [ebp + 12]; This gets the second last pushed argument` `mov [esp - 4], 0; This sets our local variable` &amp;#x200B; Of course a lot of this is optimized away, but on architectures with limited registers, and functions with a lot of arguments and local variables there is only so much you can do before resorting to this method.
I know this old school but I would start with [K&amp;R](https://en.m.wikipedia.org/wiki/The_C_Programming_Language). This was the original C specification. While some (lots) of the content is out of date, it is a solid fundamental into programming logic. The programming examples are challenging. While you may never need to manipulate an array of characters in a modern language - you will learns lots. I’ve met many good programmers, but every great programmer I know has this book on their shelf.
**The C Programming Language** The C Programming Language (sometimes termed K&amp;R, after its authors' initials) is a computer programming book written by Brian Kernighan and Dennis Ritchie, the latter of whom originally designed and implemented the language, as well as co-designed the Unix operating system with which development of the language was closely intertwined. The book was central to the development and popularization of the C programming language and is still widely read and used today. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I would start at the beginning.
This is a really damn smart way to do it with the arrays.
...what do you think references are?
Thank you for helping, but I already did my way and it will take longer time for me to fix and do your way.
These lectures from Harvard’s CS50 course is exceptional: https://www.youtube.com/playlist?list=PLhQjrBD2T382eX9-tF75Wa4lmlC7sxNDH
Thank you for your advise, i'm just learning coding and I am very appreciated your advises.
 Thanks.
Javascript... would be a good idea in your case.
This isn’t exactly what you’re looking for, but I found it a great place to start, so you might find it useful right now nonetheless. It helped me with the syntax and it gives brief background on some of the more technical stuff like pointers and memory (re)allocation. Just a great introduction that I found both effective and short. https://github.com/accre/Cprogramming Credit to the ACCRE supercomputer at Vanderbilt University
I will give it a try for next semester. Thank you.
&gt;We're talking about what constitutes 'on-topic' in this subreddit. Haven't you read the rules? There are only two of them. &gt;Oh, also, I never realised that freebsd was a GNU system. Irrelevant. Neither FreeBSD nor GNU nor GLib are C. **Can you please stay on topic?** &gt;I wasn't changing the topic, I was staying on topic; the topic was your rhetorical question. &gt;Alright, let's establish something here. We're not talking about what is part of the C programming language. ... then you're off-topic and breaking rule #2. I want to stay strictly on-topic and comply with rule #2. Got it? **Psychology is not on-topic**. Grow up, and learn to stay on topic. &gt;https://wiki.gnome.org/Projects/GLib/CompilerRequirements#C99_printf_and_positional_parameters indicates it's for libcs who don't support c99. I'm glad you acknowledge what OP said (that `g_printf` is an extension). Now we're back on topic. &gt;No one writes for technical compilers, people write for actual compilers on actual systems. Where g_printf is more portable. So... arduino doesn't have an actual C compiler then? Why is it that you would pick and choose (I never mentioned FreeBSD) and simultaneously ignore my mention of the arduino implementation? Please let me know when you get GLib support using the arduino compiler...
It's still passing by value, you are describing how the ABI implements pass by value for those objects.
&gt; Point me to a single undefined behaviour in g_printf. &gt; [snip] &gt; **What does some random blob of code in the middle of glib have to do with g_printf?** lol...
Oh, it's _not spam_ so long as someone _asks a question about it_ and _it's written in C_? So I could for example ask... "What's the difference between {closed-source product written in C containing adware bloat} and a C compiler?"... and then via a sock puppet begin listing all of the things that are better about the closed-source product written in C? Is that an on-topic dialog?
Fuck it, I didn't subscribe for that nonsense. I'm outta here. Have fun in your cesspit. Don't respond to me in r/CProg either. You're on the verge of being blocked.
- Build a cookbook - Write tutorials
Good bot
Wonder when was the last time you did bitwise shift math with C?
Learn C the hard way is a very great book to learn from. Since the book is more “modern” it also explains things that are optimized by modern compilers that older books can’t tell you.
Tic tac toe is a classic next step An address book or anything that’s keeps a record of something ( I saw cookbook suggested) Build a maze game with a grid in the screen and a random generator A text adventure game helped me restore my c knowledge complete with a “map” (randomly generating beginning and end found in a 5x5 grid, items, enemies, locked doors, keys, and bosses, oh and character classes) Simple TCP Server and Client examples to exchange data
Make a GitHub account. Start a repo of random notes about things Start a repo with minimum demonstrable example of the new concepts you learn. Work through Advanced Programming in the Unix Environment. That should keep you busy for a while.
I think a post on blog or forum about a specific task you have accomplished and how you did it, but the boundaries should be well defined for readers.
In front of your laptop 😉
Hi guys, Yesterday i posted a flow chart on a token system c program. For now, I have come this far &amp;#x200B; \#include&lt;stdio.h&gt; \#include&lt;conio.h&gt; &amp;#x200B; int token, no, counter, services, password; no = 0; token = 0; password = 0; &amp;#x200B; &amp;#x200B; main() { while (no != 3) //so that number keeps looping instead of using return function { printf("\\n\\nPlease Select an option displayed"); printf("\\n\\n1.Get Token\\t\\t2.Login Admin\\t\\t3.Exit\\n"); &amp;#x200B; scanf("%d", &amp;no); &amp;#x200B; if (no == 1) { if (token &lt;= 255) { &amp;#x200B; token = token + 1; &amp;#x200B; printf("\\nYour Token number is %d", token); &amp;#x200B; printf("\\n\\nPlease select a service"); printf("\\n\\n1.Accomodation Services\\t\\t2.Tuition Services\\t3.Course Services\\t4.Documentation Servies\\n"); scanf("%d", &amp;services); &amp;#x200B; if (services == 1) { printf("\\n\\nAccomodation Services has been selected, Token %d Go to Counter 1", token); FILE\* pFile; pFile = fopen("Counter1.txt", "a"); if (!pFile) { printf("Error: Couldn't Write to File\_Counter1"); return 1; } fprintf(pFile, "\\n%d", token); if (fclose(pFile) != 0) { printf("Error; File was not close\\n"); } &amp;#x200B; } if (services == 2) { printf("\\n\\nTuition Services has been selected, Token %d Go to Counter 2", token); FILE\* pFile; pFile = fopen("Counter2.txt", "a"); if (!pFile) { printf("Error: Couldn't Write to File\_Counter2"); return 1; } fprintf(pFile, "\\n%d", token); if (fclose(pFile) != 0) { printf("Error; File was not close\\n"); } } if (services == 3) { printf("\\n\\nCourse Services has been selected, Token %d Go to Counter 3", token); FILE\* pFile; pFile = fopen("Counter3.txt", "a"); if (!pFile) { printf("Error: Couldn't Write to File\_Counter3"); return 1; } fprintf(pFile, "\\n%d", token); if (fclose(pFile) != 0) { printf("Error; File was not close\\n"); } } if (services == 4) { printf("\\n\\nDocumentation Services has been selected, Token %d Go to Counter 4", token); FILE\* pFile; pFile = fopen("Counter4.txt", "a"); if (!pFile) { printf("Error: Couldn't Write to File\_Counter4"); return 1; } fprintf(pFile, "\\n%d", token); if (fclose(pFile) != 0) { printf("Error; File was not close\\n"); } } &amp;#x200B; } else { printf("\\n\\nWe are out of tokens today, please try again tomorrow"); break; } &amp;#x200B; } &amp;#x200B; else if (no == 3) printf("\\n\\nThank you for your time"); //want to put a return fuction here to repeat the option else if (no == 2) //password section parts { printf("\\nPlease Enter Your Password\\n"); scanf("%d", password); printf("%d", password); } else printf("\\n\\nPlease select an option displayed"); &amp;#x200B; } } &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; Now, this is the problem i am having right now, &amp;#x200B; else if (no == 3) printf("\\n\\nThank you for your time"); //want to put a return fuction here to repeat the option else if (no == 2) //password section parts { printf("\\nPlease Enter Your Password\\n"); scanf("%d", password); printf("%d", password); } i am able to print "Please enter your password" and asks me to enter using scanf, but the program doesnt work after that. What should I do? i am using visual studios 2019 community.
I'd recommend getting into gui programming, or game programming, someone else mentioned SDL in the comments, which is an api for game development, but you can really do anything that involves graphics/input/sound with it, but a lot of SDL tutorials are in c++, you should be fine, though. libsdl.org There's also GTK for gui programs. There's one tutorial here : [GTK tutorial](https://developer.gnome.org/gtk3/stable/gtk-getting-started.html). The [official website](https://www.gtk.org/) is probably a good place to start.
It checks if the value of `c` is equal to the value of `n`.
You're passing the wrong thing into scanf. Compare it to your other uses of scanf and the error should be obvious.
In scanf and printf, you need to pass a pointer. Ie `scanf("%s, &amp;password)`
This is incorrect. Only scanf always requires pointers. printf requires pointers for strings, not for ints.
thank you for your advice dude, looks like i left out &amp;password from the scanf.
In my case c has the value initialized 2 and it is finding out the prime number so if I give "n as 5" is a prime number .If it is really checking c is equal to n then it should get an error cause 5 does'nt equals to 2 but it isn't. Im confused right now
You are incrementing c in the for loop. c++ equals to "c=c+1"
Yeah, I had a brainfart.... Oops!
Your compiler should be issuing warnings for doing this, iirc.
but I had closed the braces for{}loop and it ends there so there's no meaning of for loop here at this line
The loop increments c until it's equal to n. If that happens, then n % c was never 0 and n is thus a prime number. If it isn't prime, the loop will stop early and c won't reach the value of n, so we know n isn't prime.
The statement is after the for loop has been terminated. Which means it has incremented c in the loop.
&gt;’t exactly what you’re looking for, but I found it a great place to start, so you might find it useful right now nonetheless. It helped me with the syntax and it gives brief background on some of the I do not think K&amp;R. Is for beginner in c. For someone who never programmed before.
Hi Noah Samba If you have never programmed before. Then 1. You should start with HelloWorld Program. Then, you should start learning programs like how to use operators sum of two numbers, etc. then you should work with variables how to change their You should google search these terms. "How to add two numbers in c" "What are variables in c" and so on.. there are couple of programs. You should know.
&gt; I personally don't get this. Is it something you should be able to do? Anything done with arrays involves pointers, in some form or another, since array indexing is _defined_ in terms of pointer arithmetic. But that wiki entry is making the point that just because you _can_ use pointers explicitly doesn't mean you should. A so-called Three Star Programmer would be someone who overuses pointers. &gt; Is this somehow more efficient? Nine times out of ten, the most efficient code is also the simplest and clearest code. Reversing an array in place can be done with ordinary array indexing, no use of the `*` unary operator, and I dare say it would be the most efficient way to do it.
\&gt;60 money is a lot of ash for someone who just wants to get familiar a bit with C
&gt;iirc nope, it didn't pop up in the error, just the picture i posted
The code's just something I threw together. I can see the problem now, if I passed an array with an even number of elements it wouldn't work.
I agree with Drac 88 Set up your own reddit account make some repositories, something that you will be interested to work on. Arrange and compile your portfolio. :)
Have you turned warnings on, though?
https://archive.org/details/CProgrammingLanguage2ndEditionByBrianW.KernighanDennisM.Ritchie
Couldn't you have send me this before I bought it? \^\^ Is this legal? What is archive.org ?
Literally yesterday? Shit, last night as I was falling asleep I was thinking about a new algorithm that replaced divides with shifts...
That one's going to be closed as spam.
How could the function detect an invalid argument?
References are a kind of lvalue which refer to the storage location of a different variable instead of its own variable. There are a number of differences to pointers: * references behave like other lvalues in that interpreting them as an rvalue yields the content of the object they refer to. This stands in contrast to pointers where interpreting them as an rvalue yields the address of the object they point to and a dereference operator is needed to yield the object they point to. * likewise, assigning to a reference assigns to the variable it refers to. Assigning a new variable to refer to is generally not possible, just like you can't make a variable be stored at a different location. * references always refer to something whereas pointers may point past the end of an array or be null pointers. Typically, references are implemented as pointers. But this is not guaranteed.
It was the IDE what detected it. It's a fairly common mistake so IDE developers added a rule to linter that checks this specific scenario.
I see. I thought it was a runtime error
I once found out that return i++; /* and */ return ++i; Do different things. One actually ignores the increment. So I understand why some people don't trust the return command
I mean, that is the first thing you learn when you find out about *pre*-op increment and *post*-op increment....
It is literally *in the book*
Maybe you get how it is supposed to work, but for me it is far less obvious With `a = --i` i will be decremented and then assigned to a. But after this oberation, the value of i has changed as well. Now `return` is not assignment. You could very well assume that first the crementing operation is performed on `i` – and then i is returned. And by the way `return i--` doesn't work as you think it would. I looked at the assembly and the decrement is never executed (how could it, as the stackframe is dropped with the return command?) If the post-increment is ignored, `return a+b` could as well just return a in my mind. It's basically the same: Return a, then add b. It's definitely not expected behavior in my mind and one of the little pitfalls C has. Note that most other languages don't offer post- and preincrement operators; maybe there is a reason.
&gt; you get how it is In Soviet Russia, it get how **you** is! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
&gt; you get how it is In Soviet Russia, it get how **you** is! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
Take a look at your post and ask yourself if you'd read this shit for free. Either learn some basic markdown or post this on pastebin or gist with proper formatting. Help us to help you.
SDL is not for game development, it's a window management library.
Once you get through the basics, the next step is generally to try project based learning. A few suggestions are: 1. simple http server 2. Write a gui 3. Write a TIM to png converter 4. Make a simple game 5. Make a tetris clone on the console 6. Make a pixel art editor
C programming for Dummies
I've worked with Java, Python, PHP, CSS and HTML Python I can make basically anything and so it's difficult to progress any further Java I've got all the basics down PHP, CSS, HTML is at a level where I can make a relatively nice looking website
But where :|
Thank you!
Yeh, I've coded before, just not C. Do you know any websites that show tutorials done by professions in C?
 &gt;= ? Maybe, but what is on each side? And what do you expect to happen when the pointers are equal?
Sounds like you don’t know nearly as much as you think...
ohk then please teach me.. I really want to learn how to make a simple application in windows.
The best thing to learn something is to start doing it. So, just start writing the snake game for windows.
yeah but i have no idea .. what to write ?.. like where will be the environment .. etc.
Look at SDL, it's a fairly easy to use graphics and sound library written in C. There are lots of tutorials for games using SDL floating around the internet.
can you give a link to one
https://www.youtube.com/watch?v=JPAyj85tJ5E&amp;list=PLT6WFYYZE6uLMcPGS3qfpYm7T_gViYMMt
don't encourage their purely psychological allergy to googling.
One thing that immediately sticks out to me is the condition of the while loop. While this would probably work for an array with an odd number of elements, what about an array with an even number of elements? If you have an even number of elements I don't think p1 and p2 would ever point to the same element since both are modified in the body of the loop. When they get to the middle p1 is incremented to n+1 and p2 is decremented to n, they skip over each other. &amp;#x200B; &amp;#x200B; On a side note, there is \_nothing\_ wrong with using pointers (if you stop and think about it is is really \_hard\_ not to use pointers even in high level languages!), there is nothing wrong with bitwise operators. What \_is\_ wrong is abusing these things. The author calls them "three star programmers" because you have to dereference multiple levels of pointers to get where you want to go. That just means the programmer \_sucks\_ at creating data structures and simple abstractions. Similarly, bitwise operators are invaluable for low level work. But just because a left shift is effectively multiplying by a power of two does \_not\_ mean you should be using this as a substitute for actual arithmetic. They are for setting individual bits in a bit field or otherwise manipulating raw bits, not integer arithmetic.
Well it has good support for gamepads built right in, and is commonly used for game development, and most of the tutorials they have linked on their site are gamedev related. Obviously it's not strictly for gamedev, like I said, you can use it for anything that would use graphics/Input etc.
Yeah, I edited it in the post a while ago, &gt;= should be correct, I think. Did you start writing this comment hours ago? And come back to post it before seeing my edit?
Well that's what the = part of &gt;= is for. Once p1 is greater than or equal to p2, that means they've either overlapped, or are pointing to the same thing, which means we shouldn't keep swapping, I think.
Currently going through a level 200 Uni course and we're using "C How to program" written by Paul Deitel and Harvey Deitel. I have prior experience in programming and I am enjoying this book. Every chapter builds on the last and you def need to have learned the last chapter to execute the problems of the following chapter. You can get the pdf book online for free. It also leads you into C++ at the end of the book but I haven't gotten there yet so I can't comment on that portion.
Hmm. Did you place your edit in the middle of your original post? I read it as you did not understand why changing the condition to &gt;= worked.
I made the edit when it crossed my mind that &gt;= might work, so I suppose it came across as a bit vague.
If you like to do it from scratch i.e., without external libraries and sticking with windows API and pure c..you better checkout [Handmade Hero](https://handmadehero.org/) PS: The language is C++ but most of it is C code. He also had introductory C videos covering pointers, which is worth checking.
Thanks for the suggest, I posted the code here, is this ok? [https://pastebin.com/s1TY93M7](https://pastebin.com/s1TY93M7)
Just reiterate what u/BarMeister said, we can't even read this code, because it's not formatted correctly. Put it on a paste bin. Google "paste bin" if you don't know what that is.
 [https://www.lynda.com/C-tutorials/Learning-C/718661-2.html](https://www.lynda.com/C-tutorials/Learning-C/718661-2.html)
&gt;https://pastebin.com/s1TY93M7 I posted the code, is the formatting still unpleasant? I am very new to this to begin with.
C is used mainly for system programming. Your best bet is to pick up a book like THE LINUX PROGRAMMING INTERFACE ( you can get it online for free). Before you read the book learn a bit of bash and about the linux operating system. If your running a windows machine download virtual box install ubuntu server on it and play around with it.
Isn't that the point of asking for pointers and guidance? OP isn't asking for the answers, they just want to be pointed in the right direction. What's wrong with that?
So... what's the difference between `g_printf` and `printf`? ;) P.S. Piss off... you've got nothing on me now that I've left. Bye!
Unix
That is so much better. Your question consists of "how do I serialize a date/time in C?". "Serialize" is the key word there. Turning the objects in your program into a text/binary format that can easily be converted back into a usable object for your program. I'm short on time (Father's day weekend), so all I can do is tell you that if you Google "how to serialize a date in C" you will get many results to comb through and figure out how you want to do it.
According to the authors of the Standard, **C code can be non-portable** [emphasis in original]. I don't know who came up with the idea that the C Standard was intended to deprecate the myriad "popular extensions" that allow dialects to serve so many purposes, but the C Standard was never intended to do anything other than define a core language which implementations intended for various purposes could readily extend as needed to fulfill those purposes. While the behavior of non-standard libraries would generally fall outside the realm of a proper C discussion, the way things in the standard library are implemented and may affect the design of other things would be very much tied in with the language that became popular in the 1990s even if not the extension-free subset that some people prefer.
The SDL2 documentation.
One is a function supplied by the host with questionable semantics, the other one has an interface with well-defined crappiness.
Can you post your code to a proper code sharing site like (GitHub Gist)[https://gist.github.com/] or [Pastebin](https://pastebin.com/)?
I came from a similar background. I think it's best to fly through the Coursera course (Pointers, Arrays, and Recursion by Duke) and you should have enough to take a more advanced C course. I would recommend at least taking a minute to read up on headers and all that as well; they are simple enough to not need a whole course.
 [https://pastebin.com/spLhtrt5](https://pastebin.com/spLhtrt5) here you go, bro/sis. i also posted here (in reddit, this post) that the outcome i need and the outcome i am getting. the problem is after removing an employee, thn adding a new one, if i print the list of employess, the new added one does not show up.
First you need to know what all you need to make the game. Research the web about making games in C. Check out GitHub code of other people who've made short games in C and you'll have an understanding on where to start. Now it's upto you to get creative. Pick up a pen and paper and design the structure and flow. That is the game concepts, what happens when and how you're gonna do it. You can always use Google when you're stuck. Then slowly build up your design into code. You'll make a lot of bad decisions and errors on the way but that's the process. Don't be demotivated :) Enjoy the process and you'll get there. In the end you'll learn a hell lot.
I agree. Reading your code in that format and without a proper text editor is tormenting lol.
\&gt;= should work in this specific case, but just be careful with pointer comparisons in general. They don't always work the way you expect them to.
Another note: *Do not* under any circumstances use a `char` to receive the return from `getchar` or `fgetc`. They return `int`s, not `char`s. `EOF` is explicitly outside the 0–255 range for `char`s, so it’s possible that (a.) you’ll never see `EOF` if you’re looking at `(char)getchar()`, and (b.) you’ll see a spurious `EOF` from a normal/-ish character in the stream. Also, check all return values from things like `scanf` where you rely on them actually having read the data. One slight fuckup on the user’s side will send your program into a cascade of undefined behavior unless you do basic error-checking.
I think you need to rethink how you're expanding and contracting your `emp` array. As it stands now, your remove code shouldn't work correctly unless the record being removed is the last one in the array. This is because you only ever increment and decrement your `new` variable which doesn't make sense if you're removing something in the middle of the array. My suggestion would be to change your array of `struct Emp` to an array of **pointers** to `struct Emp` and then when something is removed from the beginning or middle you shift the entire array over by one.
It's not just tormenting -- it's impossible. Reddit's formatting removed entire bits of OP's code.
array of pointers? what do you mean? Sorry to tell that its been 1 month since i started coding. Started wit C lang. just finished Structures and Arrays in my last class. this is the assignment for the classes of structure and array. will be doing pointers next week. So yea i did not get what you meant by array of pointers. sorry im dumb lol. possible to write the edited line here ? if no thanks, if yes, THANKS!!
When you add a record, find a zero slot, just like when you find a record by id elsewhere.
If you don't want to use pointers, then I would nix the idea of your `new` variable entirely. Instead, when something is added, loop through the array to find the first available slot and use that.
will do thanks a bunch bro, srry for disturbing.
 [https://pastebin.com/spLhtrt5](https://pastebin.com/spLhtrt5) here is my code in pastebin
Nice answer after you probably looked it up. Sure not everyone needs assembly to learn C, but since you're r/iamverysmart you learned everything you need to know without assembly. My point is that a lot of people would gain a lot of insight from first learning assembly. Too bad you don't understand that, and probably never will.
idk whether it's legal but archive.org is not a piracy website it just hosts stuff from the internet for archiving purposes so if it is not legal then they probably would have taken it down already if anyone had complained about it so 🤷 Honestly I prefer paper books anyway and can never finish a pdf.
did not get what you meant, care to elaborate pls? and if you want to see a clear view of my code here it is [https://pastebin.com/spLhtrt5](https://pastebin.com/spLhtrt5) the main problem is after removing an employee, then adding a new employee. after the new employee is added, when printing the list of employees, the new added employee does not show up. &amp;#x200B; Is it possible for you to write the line I'm missing (Im not understanding what Im missing)? Im not familiiar with poiters yet, so its better to answer my question without pointers (just saying lel). and Thanks!.
I mean you could just look up some of my open source projects instead of getting angry and jealous, but ok. do what you do.
&gt; you could just look up some of my open source projects In Soviet Russia, my open source projects could just look up some of **you**! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
I'm seriously hoping this is a joke :).
I'm not jealous at all about what you lack in knowledge and wisdom. But sure, you are very smart.
You can definitely create a mapping from string -&gt; whatever. struct Entry { const char *name; void (*func)(); }; struct Entry entries[MAX_SIZE]; If the array doesn't need to be larger and you aren't looking things up all that often, a simple linear lookup should suffice. But if that isn't true, you should look into using a more performance data structure (hash map, red-black tree, etc.)
A string can be hashed into a fixed length integer which can be used to index an array of function pointers.
I'm not sure I'd go the hashing route, as there's a non-zero chance of a collision, and by the time you've written your collision-reconciling code, you've written yourself a fully-fledged hashtable (which the problem probably doesn't necessarily warrant) My approach would be to make a array of structs which contain keys and function pointers, and simply iterate through them. To make things easier, the final (dummy) element would have a NULL pointer for a simple termination check to end the loop in the event that the key isn't found. It's linear time complexity rather than constant time, but there are probably so few entries that it really doesn't matter.
Unless you know all the keys ahead of time and can implement a [perfect hashing function](https://en.wikipedia.org/wiki/Perfect_hash_function) that is not safe as it's possible for two strings to hash to the same integer especially when you reduce the range to something small enough so the array does not take a large amount of address space.
**Perfect hash function** In computer science, a perfect hash function for a set S is a hash function that maps distinct elements in S to a set of integers, with no collisions. In mathematical terms, it is an injective function. Perfect hash functions may be used to implement a lookup table with constant worst-case access time. A perfect hash function has many of the same applications as other hash functions, but with the advantage that no collision resolution has to be implemented. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Hey OP, approximately how many function pointers are we talking about? 1, 10, 100, 1000? More?
Cool project idea. One thing I noticed: cards.c Line 307: char *filename = malloc(sizeof(error_text) + sizeof(ctime(&amp;current_time)) + 1); There is no corresponding free for this malloc, which could lead to a memory leak.