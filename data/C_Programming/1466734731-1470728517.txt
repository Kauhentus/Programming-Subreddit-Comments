This is actually quite a big deal. This means you can, for example, ship a commercial QT/POSIX app and never have to make any Windows calls, and not have to pay any licensing fees. I wonder if this has anything to do with soon being able to run regular Linux binaries on Windows...
lockf(), flock(), fcntl() locks...
Can you explain this to me? How does open-sourcing Cygwin help avoid paying licensing fees on QT? I'm sorry I don't get this 
That's looking great! Any recommendations to read open source programs? What do you think of libuv ?
Thanks. You're right. I didn't think about knowing the time.
Hey I figured out it was because I was running Cygwin through conemu and I had to mess with the ordering of predefined tasks (move Cygwin higher) in order to fix this. If I run through the Cygwin terminal I can input onto the terminal, however using (gdb) run &lt; input.txt doesn't automatically use what's in the file. But I can deal with it until I can find a fix. edit: I just looked at your link. I thought you were saying the error was impossible haha . Thanks!
Plants touched on the main pieces of the code itself, but something to think about in the approach is it's possible to copy between file descriptors without allocating any memory, using `sendfile(2)` on Linux (2.6.33 or newer). Without error handling for brevity: #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/sendfile.h&gt; #include &lt;unistd.h&gt; int main(int argc, char *argv[]) { int i; for (i = 1; i != argc; ++i) { int fd; struct stat stats; fd = open(argv[i], O_RDONLY); fstat(fd, &amp;stats); sendfile(STDOUT_FILENO, fd, NULL, stats.st_size); } }
[linked list basics](http://cslibrary.stanford.edu/103/)
My take at it: https://gist.github.com/Garuda1/74ce4134d73c11dcf727401182da97a6 Note: I didn't compile it, chances are high it may not work
&gt; You basically can't correctly concatenate files that have '\0' in them. Derp. I suppose that I should print the number of read bytes. Are there any that could potentially be unsafe to print to the console? &gt;You have continue; after you malloc. So it is possible for that allocation to never be free'd. Whoops, nice catch. &gt;You don't need to hold each file entirely in memory. Why not read like 1024 bytes at a time? Right, I thought about that. Is there any particular reason for reading 1024 bytes at a time or is that just a random suggestion?
Can you elaborate a bit with some examples? I'm not sure what I would do differently if I used those.
If you have any questions, feel free to ask them.
Super super informative, thank you! 
Here's an example (C99) that uses perror(). #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; static int cat(FILE *fpin) { while(!feof(fpin)) { char buffer[BUFSIZ]; size_t inbytes = fread(buffer,1,sizeof(buffer),fpin); if (ferror(fpin)) return EXIT_FAILURE; do { size_t outbytes = fwrite(buffer,1,inbytes,stdout); if (ferror(stdout)) return EXIT_FAILURE; inbytes -= outbytes; } while (inbytes &gt; 0); } return EXIT_SUCCESS; } int main(int argc,char *argv[]) { if (argc == 1) { fprintf(stderr,"usage: %s files...\n",argv[0]); return EXIT_FAILURE; } for (int i = 1 ; i &lt; argc ; i++) { int rc1; int rc2; FILE *fp = fopen(argv[i],"r"); if (fp == NULL) { perror(argv[i]); return EXIT_FAILURE; } if ((rc1 = cat(fp)) != EXIT_SUCCESS) perror(argv[i]); if ((rc2 = fclose(fp)) != 0) perror(argv[i]); if ((rc1 != EXIT_SUCCESS) || (rc2 != 0)) return EXIT_FAILURE; } return EXIT_SUCCESS; } 
You can't. C doesn't allow you to do such a thing. And how should the compiler know that this happens anyway? Consider if the programmer wrote int foo = scanf("%d"); my_rand(foo); the compiler can't know if `foo` is one of `RAND_POS`, `RAND_NEG` or `RAND_MIX`. Your only chance is to check such invariants at runtime. You can use `assert()` for that.
Now that /u/cym13 has explained why this is a really bad idea—one solution would be to write three separate functions: `my_rand_pos()`, `my_rand_neg()`, and `my_rand_mix()`. Since you're not using a flag argument, there's nothing for the user to get wrong.
I removed your submission as it isn't really about C programming.
You don't have the right header included. `gotoxy` isn't a standard function. edit -- downvoted by people who ~~have no idea what a linker error really is.~~read better than I do.
First of all, please make your readable by putting four blanks in front of every line of code. Otherwise, it's very hard to read.
At least for developing in Linux, Google the "POSIX thread API", and things having to do with "pthread", ie, pthread_create
Word of advice for you, you'll get a significantly better response if you show that you've made an effort already. You reap what you sow - if you show up saying "I need help" without being specific, then giving horribly formatted code and saying you've done literally nothing in trying to answer your own question, then you'll get a similar response in return. If you're expecting answers on a silver platter, then you've come to the wrong place.
After some debugging,I noticed that the problem only arises when I use %s in printf statement. So I replaced it with puts and the problem is resolved. 
Thanks for posting this. Right when this came out I decided to switch from SDCC to another compiler for working with PIC18s. Maybe I'll give SDCC another try now. 
Thanks for the correction!
1) It's almost certainly not worth switching operating systems _just_ to learn a programming language. If you want a linux-like environment on Windows, you can use something like [Cygwin](https://cygwin.com/) or [MinGW](http://mingw.org/). 2) Linux and Windows use different executable formats, so an executable compiled for one will not, generally speaking, run on the other. However, you can write C code that will _compile_ on both Linux and Windows, as long as you avoid relying on OS-specific libraries.
There is one thing for which having a development environment in linux can be interesting: most programming courses I find good use it. It's already hard enough to get into programming without having to constantly search for the equivalent function on one or the other system. On the other hand it's hard enough to get into programming without having to discover a whole new environment... On the other hand learning linux will always be beneficial for you no matter what you end up doing... Just do whatever you want ;-)
&gt; if I learn on linux, will I have issues programming if I come back to windows? You might (and probably will) think "wow this is messy and not convenient and not efficient and...". But in the end you'll never have any trouble compiling your stuff, there is just more fancy stuff between you and the compiler. That's if you use an IDE, you can still use the "editor and compiler" route on Windows but it makes less sense. &gt; 2) What's program compatability between OSs like? If I write a program on linux or windows, compile and link it into an executable, how well will the program work on the other OS, if at all? There are some libraries that are platform dependent, but you always have cross platform alternatives. If you don't use anything platform dependent, you just need to recompile for the target platform. Not much trouble. 
A pointer to an array is not a pointer to a pointer. Arrays decay to pointers in many cases but not that one.
Why is "modify" taking a double pointer? It doesn't need that. modify( int *a ) { a[5] = 5; } It only needs a double pointer if it intends to modify where the pointer goes.
That won't modify the original version of *a*, inside *main()*. It will only modify the local copy of *a* created inside *Modify()*.
Alright so I tried "B" and I got the sam array aside from element 8. Which is now 10163024 and element 10 remained 4210736. So I would think that is representing the "\0" because that's what "A" and "B" have in common but isn't the code for that 0 which also happens to be element 9?
Something along the lines of: int a[10]; int *b = a; Modify(&amp;b); Though as already mentioned, no need for a pointer to a pointer in this example.
The way I usually learn a new language is to write some simple programs and work up to more complicated ones. The thing is, I've been programming for a very long time, so my idea of what's simple might be different from you. That's why I asked about your prior experience. No matter what your skill level, try to come up with little programs that you find interesting and that you know how to write most, but not all, of. One that I always enjoy writing is a program to generate all of the permutations of an array. It's not an especially useful program most of the time, but it's an algorithm I figured out on my own after I'd been programming for a few weeks. Other little programs that I enjoy writing are solutions to little puzzles like tic-tac-toe or the triangular golf tee puzzle. For being a relatively straightforward, simple language, C has a lot of nuances that aren't obvious to begin with. I'd suggest taking a reference and trying out all of the operators to make sure you understand them. Anything that had a footnote associated with it is worth spending time playing with until you fully grasp why the author thought it was worth bringing up. Look at the standard libraries and make sure you try most of the library functions or at least representative functions from all of them. Knowing what's already available can save you a lot of time. Have fun! Good luck!
You need to use single quotes (') to get a character, not double quotes ("). C will convert the character to an integer, but a string is different.
You can also use: modify( a ); Which is exactly the same thing as: modify(&amp;a[0]); 
Oh! Sweet!
True, but more detail than OP needs. Still, edited......
&gt;&gt;You basically can't correctly concatenate files that have '\0' in them. I mean you assume the contents of the files will never include the '\0' byte. Treat files as binary data. Don't fprintf their content to stdout. fwrite them.
what do you mean with the localize comments?
I want to localize the program later on so I added comments above every string that needs to be localized.
The error messages.
&gt; I should have total fundamental knowledge of programming, the language and the tools. From the source code, to compiler, to the linker. Admirable, but maybe overreaching a bit. I have a Master's in Computer Science, and I didn't really understand the linker and loader until after I'd worked on some fairly difficult embedded projects in industry for several years. &gt; total fundamental knowledge of programming The most important thing for you to learn right now is that *programming is not the language*. Programming is the math and science and skills you use; a language is just one way to express those. A good programmer should not be tied to a particular language. Sure, C is very common today for a lot of kernel development, Unix tools, portable software, embedded software, etc. 40 or 50 years from now when I reach the end of my career, that may have changed, and another language may have taken its place. And that's fine, because the skills and knowledge I have apply to any language, not just to C.
Upvoted for the spot-on info about games and languages. C is not the common language for games, nor is it a particularly good language for them. C++ is the *de facto* language, precisely because of its object system being much more powerful than even C with an object system.
That sounds like a better question for /r/cscareerquestions or /r/embedded. Knowing C is certainly helpful, but there's a lot more to embedded programming than that. Knowing a lot of algorithms, theory, and OS details are also very important (depending on the specific embedded work that you're doing).
&gt; But what if the user calls my_rand(1234)? I'd like to cancel the compilation if it happens. How? Well, you can't. This is one of the fundamental concepts in computer science theory, [undecidability](https://en.wikipedia.org/wiki/Undecidable_problem). For undergraduate students, they don't need to know the proof, but they should at least know the concept, understand its implications, and be able to recognize situations where it applies. Basically, a computer or algorithm *cannot* determine *for certain* whether someone is going to call `my_rand(1234)` *at compile time*. Yes, it can determine it *in certain cases*, but there will be other cases where it is provably impossible to be able to do this. That's not an exaggeration. I don't just mean it's difficult, or improbable. I mean we've proven it's *impossible*. There will *always* be a way to write a program such that it's possible for someone to call `my_rand(1234)` in a way that you won't be able to detect at compile time. What this means for your library is that you have to accept that you may receive `my_rand(1234)` at runtime, and deal with it then. That's why a lot of other APIs are pretty consistent about always using the return value to indicate success or failure, and returning their actual result through other means like an out-parameter. (For example, the Windows [CryptGenRandom function](https://msdn.microsoft.com/en-us/library/windows/desktop/aa379942(v=vs.85\).aspx).) &gt; So I'm not really fond of the standard lib, which looks really bloated to me. I prefer to use my own lib. No offense, but you sound very inexperienced. If you don't recognize the halting problem, and don't understand how to deal with a function being passed an invalid parameter, I don't think you have the experience needed to fairly judge the quality of the C stdlib or any other library.
Which textbook? Is there a good one?
You brought up a lot of good points. My original desire to learn C came from my want to understand the essentials/fundamentals of programming. I always try to avoid tools or things that do a lot of the work for me because, because I am afraid I am going to hurt myself by not learning how everything works. I avoided using programs like Unreal, Unity, and Game maker because I despised that they made making games "easy", I tried them all, and I couldn't understand what was going on under the hood, so i felt like I was cheating myself. Sure I could make a game, but I wouldn't be satisfied with that. I've never considered any other career other than game development. I'm not sure I would even want to program if I wasn't using it to make games. I just can't see myself enjoying any other aspect of professional programming. The other types of work just don't sound appealing to me. Maybe I'm just naive and I'll learn about it all eventually and sing a different tune. I never planned to work for a company, but it would be incredibly difficult otherwise, I was aware of that much. Maybe time to reevaluate me career choices. I've been hearing a lot of conflicting information about which language is good to start with. But I guess it doesn't really matter which language I choose, as long I know the science behind it, which is something I've already been pursuing. Thank you for commenting, I'll think about what you said.
I will try this, thank you very much.
oh! I thought you meant localize for platforms, or for local directories or something
no, look carefully at the order of operations and the type of operands. 
int a = 5/9; // a == 0. 0 * (far - 32) = 0; 
The formula is not correct; remember 5/9 is not .55555 with integer division 
from now on ill never forget that lol
Read [C Programming: A Modern Approach](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504) by KN King. It's one of the best introductory C books available.
Remove the ampersand from the last printf().
Try inputting chars. Then type either 0 or 1 and see what happens.
Is this a valid answer: int main() { int c; c=getchar(); while ((c=getchar())!=EOF) { printf("%d", c!=EOF); putchar(c); } printf("\n%d\n", c!=EOF); } We are just printing the value of -&gt; c!=EOF; Is that the way we verify the expression? 
Firstly, check out this sub's sidebar. Secondly, ["Don't Learn C The Wrong Way"](http://hentenaar.com/dont-learn-c-the-wrong-way).
CS50 is amazing!
&gt; Recently, I came across an e-book written by Zed A. Shaw entitled Learn C The Hard Way, and while I can commend the author for spending the time and energy to write it, I would NOT recommend it to anyone seriously interested in learning the C programming language. In fact, if you were one of the unlucky souls who happened to have purchased it. Go right now and at least try to get your money back! I have to disagree with this statement, I found his book to be VERY helpful in giving me small bite sizes to chew on and think over. Ot helpers me grasp the fundamentals of the language. 
Also the Side bar was of no help, hence me asking here.
So you've already checked out "The C Book", by Banahan, Brady and Doran? You've read through the comp.lang.c FAQ? You've already considered the CS50 C programming course? If so, what issues did you have with any or all of those, so that people can try to offer you suggestions that address those issues?
Did you actually read the entire article, and note the various technical issues the book has? Quoting from just slightly further along in the article from the section you quoted: &gt; some of the opinions and analyses he offers are just plain wrong. I've tried to view this book through the eyes of a novice, but unfortunately I am biased by years of experience writing code in C. It's obvious to me that either the author has a flawed understanding of C, or he's deliberately oversimplifying to the point where he's actually misleading the reader (intentionally or otherwise.)
hooooooooly shit thank you! that fixed it!
Do not link to C++ documentation for C questions. Even though C++ appears to include the C standard library, there are minor differences and you should really link to the C documentation only. Standard documentation can be found e.g. here: http://pubs.opengroup.org/onlinepubs/009695399/functions/fscanf.html
While I agree in general, I do like the site he linked for their style of documentation(much more readable than the alternative you linked). Could you give an example of one of those differences? As far as I can tell their reference for C library functions uses purely C terminology and examples. For example they wouldn't say reference instead of pointer. (looking at you /u/if_then_end_if)
For example, in C++, `sin` and `cos` from `math.h` are overloaded for all floating point types. This is not the case in C unless you take the functions from `tgmath.h` where the `_Generic` construct is used to make a generic `sin` macro.
They're pretty clear in the documentation about that: http://www.cplusplus.com/reference/cmath/sin/ Including a mention of the tgmath.h macro. 
Do people not use macros any more? I assume C is at a point in its life where we won't be seeing any more MAJOUR changes to the language?
Thank you very much. I didn't fully understand the usage of the '&amp;'. I believe I do now. 
Learn C the Hard Way isn't going to teach you the fundamentals of C. There is a ton of missing and misleading information in there and valid reasons those with experience find faults in it. And as a novice it's important to do some research and find out what's really worth reading and what's not. If you want to be a good C programmer you need to have a strong grasp on the fundamentals. Which is more than just know how to write a loop and what the basic syntax is.
Bit late to this post but sendfile looks really useful, will keep that in mind for future projects. 
Well I haven't found anything thats better then the Learn C the Hard way. I mean ya I have "The White Book" but thats like 1970's C and I'm sure much of C is still very similar to the old days, but - the way he broke it down in the "Learn C the Hard Way" made it easy for me to grasp concept s with out computer "jargen" that (ya I have to know because hello, managing memory your selfm and no GC among others) can get in the way and confuse the hell out of a novice. I come from PHP, Javascript and "The Web" My main background is in Java. So coming this "low down" is very new and I basically need an idiots guide almost hahaha.
No. EOF is a negative value.
As /u/raevnos said, EOF is negative. Also, "character" literals like `'a'` are actually of type `int` in C. (This is one of the areas of slight incompatibility with C++, in which they are `char`, as one might intuitively expect, and also why the C standard library always takes or returns a character code as an `int`).
As you didn't say what platform your programing on, note that if you are not on linux newlines aren't necessarily '\n': see https://en.wikipedia.org/wiki/Newline for more details.
Hm wow I'd always assumed char was a unique primitive. Learn something every day.
Still reading, but I wanted to note the correct capitalization of "Godbolt". The domain "godbolt.org" is not a reference divine smiting powers. It's registered by [Matt Godbolt][1]. [1]: https://twitter.com/mattgodbolt
See also [this question](http://stackoverflow.com/q/5243012/417501) and [this one](http://stackoverflow.com/q/29844298/417501) for which I almost filed a defect report.
I am using Xcode. but the thing is I cant get a total of lines/tabs/blank spaces because when xcode pops out asking for the input I enter and do some tabs and nothing. I might be making some dumb mistake but I cant see what.
I would use the string library. And remember to null-terminate each string you use.
Just out of curiosity - how would one new to operating systems benefit from the UNIX system V manual? Did you learn it on the original UNIX or recently? I'm curious because I would also like to take on a C project.
EOF depends on the OS. In Windows it's Ctrl + D twice. Maybe in Mac OS it's something similar such as holding Ctrl and typing 'D' twice at the beginning of a line? Also you can view current terminal settings with the command 'stty all' and modify them if you want. 
Thanks mate!, A part of the problem is solved but there are more errors hehe :( I will brain-storm and get back to you with edits.
Same in line 94, 105, 116, ...
You should turn warnings on for your compiler, it should have been able to tell you that, and can probably help you catch other mistakes too. What compiler are you using?
I read it while on a modern linux system. First of all most functions described are standard POSIX functions and those haven't changed (or in really small ways). For the file format parts... Let's just say that most ideas still used in computing were invented in the 60's. We grew our systems into more complex things but their bases are the exact same, so while those file formats are outdated you will in most case find modern ones to be just like their elders but with different additions. In other word the old ways possess the essence of what they're doing and that's what's important when learning. Allow me to illustrate using a real example. In the UNIX Programmer's manual we find the definition of an "ar" archive, the standard at the time to bundle many files into one: &gt; A file produced by *ar* has a magic number at the start, followed by the &gt; constituent files, each preceded by a file header. The magic number and &gt; header layout as described in the include file are: &gt; #define ARMAG 0177545 struct ar_hdr { char ar_name[14]; // File name, up to 14 chars long long ar_date; // Time of last modification char ar_uid; // ID of the owner user char ar_gid; // ID of the owner group int ar_mode; // File permissions long ar_size; // File size } We can draw conclusions from this alone: making an archive isn't hard: just put the magic number ARMAG then header for the first file, then the first file not compressed in any way, then repeat for the next file... We see that we keep some metadata, most of whiche are there because we can't infer them from the content of the file itself (the permissions for example). This hints that a procedure to extract files from the archive can be: * Check the magic number to be sure it's an *ar* archive * Create a new file of name ar_name * Setup permissions and modification time for this new file * Read the first ar_size bytes following the header and write them in the file * If there is still data do it again Now let's compare with a more modern archive format: *ustar* (POSIX tar). There are more modern archive formats but let's not see too big for the moment. This is taken from “man 5 tar”: This format man page isn't as easy to read so I'll summarize it a bit. The file is still composed of a succession of headers and file content, no magic number is present at the beginning. struct header_posix_ustar { char name[100]; // File name, up to 100 chars long char mode[8]; // Permissions char uid[8]; // ID of the user owner char gid[8]; // ID of the group owner char size[12]; // File size, or other if not a proper file char mtime[12]; // Last modification time char checksum[8]; // Integrity check char typeflag[1]; // Type of file (regular file, link, directory...) char linkname[100]; // Name of link... used with hardlinks char magic[6]; // Magic number "ustar" char version[2]; // Format version char uname[32]; // Name of the user owner char gname[32]; // Name of the group owner char devmajor[8]; // Major number for char/block device entry char devminor[8]; // Minor number for char/block device entry char prefix[155]; // If name wasn't big enough a prefix can be set char pad[12]; // Padding }; The first thing we see is that all fields that were present in *ar* are still present in *ustar*. The name allowed is longer which reflects the evolution of memory and usage of our computers. The other fields are more interesting : * *checksum* shows an understanding that the file might be corrupted * *magic* being part of the header and *version* hint at the possibility to have different versions of tar archive in the same file * *uname* and *gname* reflect changes in the way UNIX/Linux manages users. * *padding* allows all headers to have the same size which helps parsing * Other fields reflect the evolution of file systems and the need to archive more than plain files but also symlinks or whole directory trees If we were to write an *ustar* extractor we would use a method very much like the one we described for *ar* archives. Some complexity is added because we now have different kind of files to deal with and we must check their integrity but the main ideas are unchanged. From this little experiment we can see why I think reading old manuals is beneficial even for modern programers as we were able to: * see quickly what's essential for an archive format * learn more about how systems evolved * easily devise how to extract archive files * understand how the initial system was flawed * understand much more easily the tar format 
Thanks, I fixed it but I think there still is a logical problem in program. Gotta solve that.
Oh I am using DevC++. I just started so someone suggested this. 
If you go into Tools =&gt; Compiler Options, tick the box `Add the following commands when calling compiler:`, and in the box below write `-Wall`, the compiler will give you more help, warning you when you're doing something that might be incorrect.
An alternative approach to /u/TheCatastic (with whom I agree) would be to use void pointers. #include &lt;stdio.h&gt; void test(void* v) { // carelessly cast to both int* and char*, because reasons int* i = (int*)v; printf("%d\n", *(int*)i); char* c = (char*)v; printf("%s\n", c); } int main() { int i = 42; test((void *)&amp;i); test((void *)"Hello\0"); return 0; } I would never recommend doing what I've done above for your case, but anything can be a void*. In the real world, you can have your function accept only strings, and if you happen to have an integer that you need to pass to your function, you can use itoa(i); (though that's not part of ANSI-C or C++), or snprintf(target_string, size_of_target_string_in_bytes, "%d", source_int); which is by far the more portable option, albeit clunkier.
Use http://dl.acm.org.sci-hub.bz/citation.cfm?id=2884799&amp;preflayout=tabs to get around the paywall
I believe this is possible if you debug the code using an IDE like CodeBlocks or Dev-C++, not really sure, but I do remember something like it, it may be worth a shot. If it does work, I'd love it if you replied, since that would give me confirmation:p 
I believe this is possible if you debug the code using an IDE like CodeBlocks or Dev-C++, not really sure, but I do remember something like it, it may be worth a shot. If it does work, I'd love it if you replied, since that would give me confirmation:p 
Sorry, too late. Anyway, you can't just claim what book you want. You also need to do the other things mentioned in the post.
You are the highest rated post that wanted *Elements of Programming Style.* Send me a PM with your address and I'm going to send you a book.
Did you have a look at the previous threads asking the same question?
Thanks for replying, already found this answer but was hoping to come up with a somewhat more elegant solution. 
Yes. There are many books recommended. Its become more confusing. So I thought may be I will ask one person and follow his advice. I want book/books starting from easy level and going to advanced level. Including gui and network stuff and how one can create fully functional Application using C.
looks like you're missing a ~~colon~~ comma between the two `KEYMAP(...)`, basically the macros expand to { {...}, {...}, {...} } { {...}, {...}, {...} } and it should be { {...}, {...}, {...} }, { {...}, {...}, {...} }
I don't see the problem. The order you showed already runs flex before compiling lexer.c, and bison before compiling parser.c. If it generated the C files, it must have generated the H files as well, right? Make doesn't need a detailed list of every dependency... just enough that it gets the order right, which it already is with what you've got. By the way, you don't need to add a command to rm the lexer.h and parser.h. Make automatically deletes any intermediate files, which is why it's deleting lexer.c and parser.c even though you didn't specify this in the file. Get rid of the `rm` line, and it should delete them anyway. If you want it to *keep* those files, you can add a special target: .PRECIOUS: &lt;files you don't want Make to automatically delete&gt; There's also `.SECONDARY`, which is similar. But you can specify `.PRECIOUS: %.h`, which I don't think you can with `.SECONDARY`.
You meant "comma", not "colon".
I took your advice and with a little finagling, I got it working. In case anyone in the future happens upon this post, I'll post the Makefile that ended up working as expected: # Tell make to stop removing intermediate files .SECONDARY: CC = gcc CFLAGS = -Wall -O0 -ggdb3 -Wextra -Werror -pipe -fstack-protector -Wl,-zrelro -Wl,-z,now -Wformat-security -std=c11 EXE = marcel LIBS = -lreadline -lfl SRCDIR = src OBJDIR = obj $(shell `mkdir -p $(OBJDIR)`) CSRCS = $(wildcard $(SRCDIR)/*.c) BSON = $(patsubst %.y, %.c, $(wildcard $(SRCDIR)/*.y)) FLEX = $(patsubst %.l, %.c, $(wildcard $(SRCDIR)/*.l)) SRCS = $(BSON) $(FLEX) $(CSRCS) HDRS = $(SRCS:.c=.h) OBJS = $(addprefix obj/,$(notdir $(SRCS:.c=.o))) all: $(EXE) %.c %.h: %.y bison --defines=$(@:.c=.h) --output=$(@:.h=.c) $&lt; %.c %.h: %.l flex --header-file=$(@:.c=.h) --outfile=$(@:.h=.c) $&lt; $(EXE): $(OBJS) $(CC) $(CFLAGS) -o $@ $^ $(LIBS) $(OBJDIR)/%.o: $(SRCDIR)/%.c $(HDRS) $(CC) $(CFLAGS) -MMD -c -o $@ $&lt; -include $(wildcard $(OBJDIR)/*.d) clean: rm -f core $(EXE) $(basename $(FLEX)).{h,c} $(basename $(BSON)).{h,c} rm -r $(OBJDIR) 
sad that no one could come up with a non OS specific answer, but thanks for updating your question
You can find large lists of words, made for use by spell-checking software, at http://wordlist.aspell.net/
Arrays in C are of a fixed size. The simplest way to do what you want is to use malloc () to make another array and copy the elements out. Or you can have a special length variable that your accessors use, and move reassign all your other elements "down" a step. If you were using C++, which despite the name is effectively another language entirely nowadays, a vector can do what you want. But it just does memory copy fanciness under the hood. 
This is awesome!
works perfectly. before knowing that I used to put like: while(c=getcharacter()!='.') Would work perfect. By the way why do the example even use that? what is the point? Not using a special character so we can use that same character for the count? I dont know lol. Thank you!!
 const uint16_t PROGMEM fn_actions[] = { [1] = ACTION_LAYER_TOGGLE(1) }; The middle line there is not valid C. What are you trying to accomplish? Maybe remove the "[1] = " part.
As /u/MaurauderIIC says, C arrays are of a fixed size, and using malloc() to make a modified copy may be the simplest way. You may also want to look into linked lists, which are a simple implementation of an ordered, dynamically-sized list that can easily be made to have functions capable of insertion and deletion.
 a[1] = a[2]; /* and the length should be truncated to 2 ... */ This can be generalised, /* a -- pointer to the first element of the array * i -- index of the element to remove * n -- length of the array */ memmove(a+i, a+i+1, (--n - i) * sizeof *a); 
The linux kernel does clever things with their container_of macro.
I'm trying to figure out what this has to do with emitting warnings...
I'm trying to build a keyboard firmware for the custom keyboard I built. I'll put a link at the bottom to the thread I followed. I've re-done the process to hopefully eliminate errors, but I'm still getting them. What you suggest is different from what is on the guide. I'll test it out later once I get back to my desktop. Here is the tutorial i've been following. https://deskthority.net/workshop-f7/how-to-build-your-very-own-keyboard-firmware-t7177.html
I'm sure there is `strip` for Windows. Anyway, the same situation exists when you write libraries in assembly, so I wonder why you think that C is doing something wrong.
The program exhibits *undefined behaviour.* Read [this answer](http://stackoverflow.com/a/949443/417501) for more details.
Even ignore the undefined behavior if we're not give `i` as well as `I` then we can't say what the output is.
That's great news! PM sent.
http://madebyevan.com/obscure-cpp-features/ : "operator overloading and evaluation order" shows another cool example to get a python style print in c++ using the comma operator
How about trying it out and seeing what it does?
Looking more closely it might not. It does allow you to place the first entry of the structure elsewhere, though. 
Arrays are not as modular as you think they are. What you're trying to do is *removing a node from a linked list*, a basic data structure opperation. For your computer, everything is made of bytes. A character is a byte, an `int` is a sequence of 4 bytes, etc. Let's say your array was declared like this: `int a[3] = {1, 2, 3};` `a` is an array of 3 integers. To make life simpler, they are all next to each other in the memory layout. It means that `a` is in fact a sequence of 3 integers, and given that an integer is a sequence of 4 bytes, `a` is a sequence of 12 bytes. Now, you're trying to remove bytes from the sequence (more specifically, the 4th, 5th, 6th, and 7th bytes). It's impossible: even if you used dynamic memory allocation (don't worry if you don't know what it is, you'll understand as you'll learn more) you can't remove (or `free` as we call it) parts of a sequence. If you're into challenges, know about pointers / malloc / etc., you should definitely look into linked lists which are exactly what you're looking for: arrays on steroids
Please, check the r/learnprogramming out, especially the side bar.
 out[str_size - i++] = charset[(k % 26) - 1]; Have another good look at this line, because I don't think it's doing what you expect. Try adding this line immediately before: printf("Trying to set out[%d] to charset[%d] \n", str_size - i, k%26-1 ); Here's what I get with that (with 2028): Trying to set out[2] to charset[-1] Segmentation fault (core dumped) 
A nice start would be Codecademy, they have a nice Python course that I think is a good place for starters. But remember it's really just a starting point, soon you'll need to start seeking more. For a follow-up try books, C and C++ are awesome languages to learn, though or maybe precisely because they are harder than your average.
So, do you have any sources I can look for on how write() works?
It'd be something like this: #include &lt;unistd.h&gt; // for STDOUT_FILENO, write #include &lt;string.h&gt; // for strlen int main(void) { char string[]="hello, world!\n"; write(STDOUT_FILENO, string, strlen(string)); return 0; } The right "write" manpage took me a while to find (a lot of manpages have "write" in the name). Eventually I figured out you have to use '**man 3p write**' to pull it up (at least on my system, Gentoo). 
&gt;you can learn C perfectly fine in both environments You won't ever learn about how wonderful `unistd.h` is on Windows. C was made to make the first UNIX systems, there is a strong bond between the two.
Hey dont worry about the formatting, its understandable!! Ya i see my mistakes now, im really new to this and im having abit of a hard time transitioning from matlab to cp,matlab is so much easier.Thanks for replying, you've been a great help!
&gt; matlab is so much easier That's just because you already know how to use it (and it's probably more suited to this type of work than C) It's good to expand on your knowledge!
Qt is very much a C++ framework. It is quite nice and well documented, but perhaps not quite the library that OP is looking for.
The plain C cross platform gui libraries I'm aware of are [GTK+](http://www.gtk.org/), [IUP](http://webserver2.tecgraf.puc-rio.br/iup/), and [Libui](https://github.com/andlabs/libui). GTK is more or less the standard, although it's heavy and LGPL (No static compilation in closed source projects). I've used IUP personally, and found it fairly simple and easy to work with. Libui is the new kid on the block, and has caught my interest for potentially having better native OSX support than IUP. I'm not immediately aware of simple tutorials for using any of them, but that should at least give you some idea what libraries are out there!
Ive corrected most of the errors, but there are still some i cant identify and correct. The error occurs in the for loop, on all the 'f=' s, it says its got to do with semicolon and brackets. #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define F(x,y) (3*(x) - (6*exp(-(y))) void main() { int y0 = 3; int x0 = 0; float y1, h, f, k1, k2, k3, k4; printf("\nPlease enter value of h:\n\n "); scanf("%lf", &amp;h); for (; h &gt;= 0; h--) { k1 = (h)*(f); f = F((x0 + h / 2), (y0 + k1 / 2)); k2 = (h)*(f); f = F((x0 + h / 2), (y0 + k2 / 2)); k3 = (h)*(f); f = F((x0 + h), (y0 + k3 / 2)); k4 = (h)*(f); y1 = y0 + (k1 + 2 * k2 + 2 * (k3)+k4) / 6; printf("\n\n y(%.4lf) = %.3lf ", x0 + h, y1); } } 
Well, aside from with VLA's.
Have you considered terminating your strings?
I'm having a little trouble working through your algorithm, and I'm away from my whiteboard right now so I can't really see what the issue is off hand. I would recommend temporarily putting print statements in your loops though. Print something like "Loop {0} Variable {1} Value {2}" inside each loop. That will help you find the issue. Or use a debugger. Gdb was my favorite on Linux.
This subreddit is about C programming only. Please post Java content elsewhere.
Thank you very much, with your and /u/Causticlnc help I have finally managed to fix it! I'm sorry for the troblesome format that I used here, next time I'll try to be cleaner
so C doesnt know 3(x) is 3*(x) so you have to actually put all the arithmetic signs in expressions (ie in your define F line)
Well, when I plug it in and load the hex file It only automatically types [-[-[-[-[-[-[--[-[-[-[-[ and similar things. Teensy 2.0 pins/columns and rows. Col : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 pin : b3 b7 b2 d0 d1 d2 d3 c6 c7 f7 b6 b5 b4 d7 Row : 0 1 2 3 4 pin : f6 f5 f4 f1 f0 Here are some photos of the underside and topside... http://imgur.com/a/Ulcbh
Here it is! int main(int argc, char *argv[]) { int A[4]; int B[4]; int i,k,a; int writevector() { for(i=0;i&lt;4;i++) { scanf ("%d", &amp;A[i]); } ; } writevector(); int printvector(int pA[4]) { for (i=0;i&lt;4;i++) { printf ("%d ", A[i]); } printf ("\n"); ; } printvector(A); //it works until this point for(k=0; k&lt;4; k++) { for (i=k;i&lt;4;i++) { if (A[i]&lt;B[k]) {B[k]=A[i]; a=i;} } for (i=k+1; i&lt;4; i++) { if(i==a) B[i]=A[k]; else B[i]=A[i]; } for (i=0; i&lt;4; i++) { A[i]=B[i]; } for (i=k+1; i&lt;4; i++) { B[i]=999999; } } printvector(A); return 0; }
The `␣` character is a visual representation of whitespace. Hit the space bar once for every `␣`. Note that you forgot one space in front of every line, everything needs to be indented by at least four spaces, not three. --- What is the error message you get? “I can't compile it” is useless without knowing what the compiler says.
Oh, you didn't have to delete your thread! You can click “edit” to change your post after you made it. The title however cannot be changed.
`c` is not a string, so `strchr` will not work. The program is counting characters in three categories, one of which is "other," so skipping around in the input might not be desirable either.
&gt; I generally steer away from "let me teach you x language" Just personal preference. You should check it out anyway. Having a decent grasp on C, I still learned something valuable. Not willing to watch a videos by someone with years of experience programming games in C? Whats the real reason you can't grasp C? 
Small suggestion, try to name your variables so they read better. A, B, i, k, a, is just going to look like nonsense when you get back to it a couple months down the road.
Look up strchr(). The first parameter takes a string (char *); the second, a char (int). It works because c is the second parameter. Trust me, it works.
Thank you for your tips, I have rewritten the functions outside the main() (yes I wanted to put them outside from the beginning, but the first code I wrote had no functions at all, so I used portion of the original code to make the function, but I forgot to put it outside of the main)
My bad. I was thinking of `strstr`.
As with the other 2 (so far) comments, I'm not sure what's so complicated. I also am not entirely sure how you can get faster or simpler than what that powf function currently does. More information would be nice. :D
Having looked up the rules Conway's Game of Life on Wikipedia, it seems like being next to the edge of the grid is treated the same as being next to a dead cell. So the easiest way to handle it would be to have `cell_state` pretend that anything out of bounds is just a dead cell. In pseudocode: char cell_state(uint32_t *world, int x, int y) { if ( /* (x,y) is out-of-bounds */ ) { return CHAR_DEAD; } /* The rest of the function goes here. */ }
This. I would compare it to kids in school that learn how to sum and subtract instead of being teached how to use a calculator (in this case the powf)
The behavior of calling `memcpy()` with a null pointer as the first or second argument is undefined, regardless of the value of the third argument (the one specifying the number of bytes to copy. So don't do that.
You can re-write the `neighbour_count` function to use loops instead of writing out each case individually. Then you only need to write a single statement to determine if the coordinates are invalid. I am not a fan of the clamping solution /u/Snarwin proposed, because I don't believe in behavior that silently clamps like that. That's liable to hide bugs - failing fast is preferable to not failing at all.
Contrary to popular belief code doesn't rust, the design and ideas in there still work. It's a good start but get some more modern education at some point in the future, just so you can learn the new language features and better ways to do things.
I'm willing to buy the new edition if people think it's worth it, or I could go for a different book (I do have the latest edition of Stephen Kochan's book as well, but didn't look at it cause I heard this one was superior).
Mostly yes, the basics don't change but it won't really be ‘Modern Approach’, new features of the language will be missing.
Yup! But even though I'm using my own recoded standard lib, which sounds kind of hard, it doesn't use many system calls: `write`, `read`, `open`, and `close` being the main ones.
Install MSYS2 and use gcc or clang. Or just install Visual Studio 2015...
Visual Studio Community Edition will compile C. MinGW is a Windows port of GCC.
There's always MinGW. I can't see any reason for any C compiler that worked in previous Windows version to not work. There's nothing magical about Windows 10.
Theoretically you could do all this even in assembly, meaning that the language itself doesn't stop your ability to implement all this stuff with it. The language is just the tool. As far as C goes, you could do all this stuff using winAPI on Windows (I don't know what the graphics.h header is but winAPI has other 2D rendering engines, such as Direct2D and GDI/GDI+). This is a lot of stuff to implement though so you might be a bit unproductive in C. C is a very bare language and takes a while to get something right. It's not a managed language (python, java, C#) that depends on a VM. It's unforgiving and small mistakes could prove to be fatal. I think that it's clear, that your program could be implemented faster in a managed language. But to depend on such a language, which gives you productivity and automatic memory management, you have to give off a few things first. One of those (the biggest tradeoff at least in my opinion) is speed. There's no doubt that C programs that are compiled and run natively on the OS, are a lot faster than programs which are compiled in a bytecode format or are not compiled at all and interpreted by a VM which runs on top of the OS. If you're doing all this in your free time and you don't have any deadlines or anything like that, you could go with C. However you have to get used to it first, real well. In C you have to do tons of other error checking and memory leak management, that you don't have to do with a managed language. Maybe you could do it with a combination of two languages like you said yourself in the end, although that's gonna be tricky to implement.
Most of these don't really depend on your language and are probably solved by a few Google queries. About C itself I can say that you can do almost everything with it, since most of the important libraries are written in C first and then ported to other languages. And the things you mentioned should be possible with C, except for the AI and weather data thing, cause I don't know myself. The main reason why anyone would not use C is that it's very low-level, and therefore might make it harder to do very abstract things. Moreover, it's easy to introduce the weirdest bugs if you're not programming carefully. As an ASM programmer, you probably won't suffer as much from these disadvantages, so C is definitely an option.
for learning, most of the basics and core ideas of C haven't changed. if you're unsure, I recommend you check out the "gentooman library" its a giant torrent of programming books compile by #/g/sicp and contains a plethora of books (on C too) to learn programming
I know the functions need to be called before using it..I understand now the program. thank you for the time
I tried the Harvard course but they insist you install some crazy version of C that works on Windows and has some commands that aren't actually in C. I don't understand why they don't just use Linux. 
Unless you really want to learn C. Do it in something simply like Python. I really don't see much of a reason to code in C for a project like this. It will just slow you down. I only use C if I'm working on something embedded. Otherwise, I'll stick to whatever is the most popular so that finding support/libraries/tools/examples is easy. Either way, it sounds like a fun project. I've done a few home automation projects myself (lights, thermostat, some server monitoring, webcams, etc...). Have fun! And if you really haven't programmed in several years... I really wouldn't start with C. Start with something easy and then go to C if you're still interested after your first project.
If you're looking to make your Makefile even more streamlined / clever / unreadable, GNU Make has [implicit rules](https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html) for building these files already. It knows that to turn a %.c into a %.o it should do `$(CC) $(CPPFLAGS) $(CFLAGS) -c`, to turn a %.l into a %.c it should do `$(LEX) $(LFLAGS)`, to turn a %.y into a %.c it should do `$(YACC) $(YFLAGS)`, and to turn a bunch of %.o into a % it should do `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS)`. All you'd have to do is get rid of the commands you're specifying, and change a few variables: LEX = flex YACC = bison CPPFLAGS = -MMD LDLIBS = -lreadline -lfl
MinGW if you don't want all the trouble with MSVC
&gt; Contrary to popular belief code doesn't rust Best practice in C++ is a fairly different animal to what it was 20 years ago.
 void function(void) { int keep_running; char buf[512]; keep_running = 1; while (keep_running) { puts("Exit? [y/n]"); scanf("%s", buf); if (!strcmp(buf, "y")) keep_running = 0; } }
Maybe C# would be better. Then you can use xamarin to reuse the code for other platforms such as Android and iPhone. 
Your code doesn't account for when k is a clean multiple of 26: while (k) { out[str_size - i++] = charset[(k % 26) - 1]; k /= 26; } So when k is a clean multiple of 26, (k % 26) = 0, which results in you accessing element [-1]. You can see this in action when running the code: $ ./test 25 24 -&gt; "X" $ ./test 26 Segmentation fault $ ./test 27 27 -&gt; "AA" You approached the problem from a slightly different angle to how I would, so I've written my solution here: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define RADIX 26 int main( int argc, char * argv[] ) { unsigned long number = strtoul( argv[1], NULL, 10 ); unsigned long digit = 1, limit = RADIX, pow = RADIX; while ( limit &lt; number ) { ++digit; limit += ( pow *= RADIX ); } char * buf = calloc(( digit + 1 ), sizeof( char )); do { unsigned long index = ( number % RADIX ); if ( index == 0UL ) { index = 26; --number; } buf[ --digit ] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[ index - 1 ]; } while (( number /= RADIX ) &gt; 0UL ); printf( "%s\n", buf ); free( buf ); } Testing it: $ ./test 1 A $ ./test 26 Z $ ./test 27 AA $ ./test 702 ZZ $ ./test 703 AAA $ ./test 18278 ZZZ $ ./test 18279 AAAA $ ./test 475254 ZZZZ $ ./test 475255 AAAAA Note the "trick" you can do with accessing a string literal as a character array, so there's no need to manually fill out your charset array. Hope that helps.
Pointers, pointers pointers!
I think that networking and different kinds of exploitation should also be included in the list.
Understanding of compilers in general. Different optimization methods etc.
Is a lot of this not strictly C, but actually OS knowledge, hardware architecture, etc?
An expert in "C" is not the same as an expert in "computer science". And an expert in C or in computer science does not need to know all of these things. Knowing how an ELF or EXE file is structured, how linker scripts work, or how to use a PLL is not necessary for working on baremetal software, for instance. You could be an "expert", but still only work on the library- and application-level code on a baremetal platform, where those underlying details are not relevant to you. A lot of this stuff you can learn as you go. For current students, I always recommend they study two things, because you *cannot* do them without understanding the underlying theory: concurrency (threading and multiprocessing), and networking. Both are indispensable and nearly omnipresent in today's technology, and both are things that you cannot fake: you either know the theory and math behind them, or you don't.
You may have caused the fault earlier and had it manifest here. 
Why do I have to change it to char? I know my void cipher used char, but that char letter is not related to the argument though, it is char letter from the user input, not the command line argument. to make it more clear: void cipher(int code, char letter); int main (int argc, string argv[]){ if (argc == 2 &amp;&amp; isdigit(argv[1])){ int k = atoi(argv[1]); string name = GetString(); for (int i=0, n = strlen(argv[1]); i&lt;n; i++){ cipher(k, name[i]); btw it is from cs50 course, and they have a library which have GetString() 
Alternatively, try this if (argc == 2 &amp;&amp; isdigit(argv[1].c_str())){ int k = atoi(argv[1].c_str()); //... for (int i=0, n = strlen(argv[1].c_str()); i&lt;n; i++){ It would be easier to work with the strings either as C++ string objects or as C-strings (null-terminated character arrays). It gets confusing when you start mixing them all around. e.g. Using length() instead of strlen() for string objects. There's no point in having string objects, when you are converting them to C-strings anyway.
This isn't causing your segfault, but you should be using logical instead of bit operators for OR and AND. Replace | with || and &amp; with &amp;&amp;.
A "C" Expert should be good at C. You may specialize in a specific version of C, such as C89, or C11 (recommended). But you should know C forwards and backwards. Pointers, struts and the preprocessor as well as the C standard library.
I'm guessing you're getting the segfault because the fopen() fails, and you don't check for it. You then end up passing in a null pointer to fgetc() which causes it to segfault.
Depends on if you are a system guy or an application guy, and what expert means to you. Basic Programming. Logic, process, and Version control. Version Control. Unit testing. General: **Pointers**. Pointer Math. Structures. Struct Packing. Difference between Functions, and statements. Preprocessor knowledge. Fixed Point math (if embedded) Deep familiarity with the standard libraries. **Application programmer:** How to interact with the kernel. High Level memory mangement. (malloc/calloc/free behavior) Other stuff probably. I'm not an application guy **Systems or embedded programmer.** The Application Binary Interface. ABI The Memory Protection System. MPU The CPU modes. Abort/Assert/Undefined/User/System The Event System. FIQ/IRQ Emulation or debugger. Depending on if you are embedded or on host machine. Knowledge of the machine language and asm identifiers you use. If ARM you should know basic stuff like MOV, BL, MUL, etc. If x86 or AMD64? I don't know, go to Hogwarts. That shit is impossible. 
The mistake wasn't there but indeed I should check for it before using it, thanks!
An expert knows four things: * Roughly how the things he works with operate * Where to look up the details * How to design complex software * How to solve problems he encounters Everything else is secondary.
It's not about being more careful. Bitwise operators are completely different from logical operators. 
char ch will never equal EOF. This is why fgetc returns int. 
Your makefile shouldn't define `CC`. The variable exists so the user can define it. By default, `make` sets `CC` to the system's C compiler which is usually what you want. For example, on my system there is no `gcc` binary so your makefile would fail. You shouldn't include your own header files with `&lt;foo.h&gt;` syntax. Always use `"foo.h"` syntax for your own project's header files. The difference is that the first kind is also lookup up in certain system directories which is not what you want. Your makefile should be in the `source` directory. Otherwise it's kinda weird. Use `M_PI` from `math.h` instead of defining your own wrong constant. Why did you write your own `putc` and `puts` routines? They are kinda useless and less efficient than the standard routines. I'm not sure what your program is supposed to do. It doesn't seem to trace any rays. 
A string in C is a block of memory, either `malloc`'d or an array on the stack, that is guaranteed to contain the null character (0) before the end of the allocated memory. If you pass something to any string function, you'll get undefined behavior. You might get lucky and the memory happens to contain a byte with value 0, in which case your program probably won't crash (though it's technically allowed to) and you'll just be operating on garbage data. If the memory doesn't have a byte with value 0, the string functions will try to keep reading past the end of the allocated memory to find one, which will most likely cause a segfault (though that isn't guaranteed). C strings can be dangerous if you aren't careful. Besides the obvious fact that your program can crash if you do something incorrectly with a string, buffer overflows are also a security concern. Functions like `strcmp`, `strcat`, and `strcpy` don't know or take into account how much memory is allocated for the string. Trying to read or write past the end of the allocated memory causes undefined behavior. Your program can crash, set your computer on fire, or open a portal to a demonic realm. 
&gt; concurrency (threading and multiprocessing), and networking. I kind of disagree, but definitely see where you are coming from there. I'd wager most developers can go through a large portion (if not all) of their career without worrying about either of those, even in networking and concurrent code, due to established team coding practices, wrapper libraries, working on unrelated portions of the code with a narrow focus, etc. But, I think the hugely more valuable skill to master that directly relates to your 2 items would be memory management. Specifically layout of structs/unions, byte ordering, and serializing of data. If they can't visualize what the memory looks like they aren't going to be able to send it to different threads or servers, yes, but they aren't going to be able to deal with files, displaying data chunks meaningfully, and related. Plus, the number of bugs that come down to pointers just pointing somewhere other than they should... It's a basic skill in C, true, but I still find myself explaining the concepts to coworkers with 10+ years experience and making the same errors myself (until I slow down and stop being dumb)
C hasn't changed much since 1989.
Do you know what some of the biggest changes since then are?
Well they came out with 2 other standards (C99 and C11), which probably changed a lot... I'm assuming they don't release new standards and only fix grammar ;)
https://en.m.wikipedia.org/wiki/C99 C11 hasn't been fully adopted.
Please don't delete your post after receiving an answer.
feature you should add: * produce an actual image, look into something like libpng * draw multiple objects * handle objects besides spheres * have a camera * reflections/reefractions * texturing * lighting * shadows
In draw_sphere it uses the quadratic formula for line - sphere intersection, and puts out an ASCII-rendering I think. I haven't compiled it and tried though.
Congratulations :D I was so happy when I wrote my first one. My first suggestion would be to move all the hard coded "image size" constants out of the inner code, so you can tweak them. Especially when debugging, it can actually be useful with a 1 pixel image. But architecturally, you are very constrained as it is. You can't really adapt to new shapes. Your sphere-code is actually firing the rays, that relationship is usually the other way around. As in: you fire rays, then ask the shapes if they intersect. The ray-firing code doesn't really know what shape's it is dealing with, just that they have a standard interface. Likewise, would you change to actual image output and want anti-aliasing you actually have to change the shape drawing code. Basically you have coupled two things to the detriment of both :) Other than that and FUZxxl's comment, it seems to do the job, but I would probably make it spit out .ppm images or something, so you can play around with shading and such :)
Aside from the first element of the list and the "compilation tools" one, I wouldn't lump any of the others definitively together with C expertise. If you want expertise in any of the other areas, ask for it explicitly! Most C experts are going to have a variety of other things they're good at, and there will probably often be some overlap with your list, but I'd guess the exact mix will vary a lot because C has been very widely used for a long time, and its usage can take on a very different character depending on the context of its use.
"Other stuff probably" -&gt; architectures, design patterns commonly used for the type of application in question. You need to have a written a given type of system several times over before you really approach any level of "expertise" in that area.
I'm a generalist across a few languages / platforms. Why I don't consider myself anywhere near an expert in C: * Barely any knowledge of the standard * Toolchain knowledge is intermediate (Clang / GCC) * No particular platform focus - I aim for cross-platform so my knowledge is no deeper than it needs to be to cover that base * Focus on performant applications, not systems - so minimal need to know much underlying technical detail as mentioned in OP's list IMO, basic-to-intermediate level C knowledge consists primarily of: * syntax * standard libraries * memory management, struct alignment/packing, endianness, etc. * preprocessor From a cross-platform applications perspective, I'd consider someone who covers the above and has ample knowledge of one or two toolchains, the C standard, concurrency (threading and vectorisation), plus a deep understanding of at least one or two broadly-applicable architectures (e.g. x86, ARM) to be reaching some modicum of expertise. Also, there is expertise and then there is mastery.
c# and .Net core (windows, linux, mac)
Add some image rendering and a feature list to your repo.
Your article got caught in our spam filter. I apologize for the inconvenience.
Decades ago, I'd use `rep movsb` (a 2 byte instruction to copy CX bytes) and think that was good enough. Or movsw/movsd for bigger things. It's funny how something so simple on the surface is so hard to do well, optimizing for all different odd alignments on various processors, without adding too much overhead shorter lengths, and making sure to still handle overlapped moves properly.
&gt; Thinking that it's possible to avoid the issues that networking and concurrency bring to the table is, to put it bluntly, naive. eh... different professional experiences I guess. In my time I've seen far more problems in far more basic issues than your concerns. 
Excellent, thanks for the reassurance.
A couple things here. First of all, when you compile with: `-Wall -Wextra`, you get: ppp.c: In function ‘getToken’: ppp.c:9:13: warning: suggest parentheses around comparison in operand of ‘|’ [-Wparentheses] while (ch == ' ' | ch == '\n' | ch == '\t') { ^ ppp.c:9:38: warning: suggest parentheses around comparison in operand of ‘|’ [-Wparentheses] while (ch == ' ' | ch == '\n' | ch == '\t') { ^ ppp.c:19:17: warning: suggest parentheses around comparison in operand of ‘|’ [-Wparentheses] } else if (ch == '(' | ch == ')') { ^ ppp.c:24:15: warning: suggest parentheses around comparison in operand of ‘&amp;’ [-Wparentheses] while (ch != ' ' &amp; ch != '\n' &amp; ch != '\t' &amp; ch != EOF &amp; ch != '(' &amp; ^ ppp.c:24:40: warning: suggest parentheses around comparison in operand of ‘&amp;’ [-Wparentheses] while (ch != ' ' &amp; ch != '\n' &amp; ch != '\t' &amp; ch != EOF &amp; ch != '(' &amp; ^ ppp.c:24:53: warning: suggest parentheses around comparison in operand of ‘&amp;’ [-Wparentheses] while (ch != ' ' &amp; ch != '\n' &amp; ch != '\t' &amp; ch != EOF &amp; ch != '(' &amp; ^ ppp.c:24:65: warning: suggest parentheses around comparison in operand of ‘&amp;’ [-Wparentheses] while (ch != ' ' &amp; ch != '\n' &amp; ch != '\t' &amp; ch != EOF &amp; ch != '(' &amp; ^ ppp.c:25:15: warning: suggest parentheses around comparison in operand of ‘&amp;’ [-Wparentheses] ch != ')') { ^ ppp.c:29:12: warning: suggest parentheses around comparison in operand of ‘|’ [-Wparentheses] if (ch == '(' | ch == ')') { ^ ppp.c: In function ‘main’: ppp.c:82:14: warning: unused parameter ‘argc’ [-Wunused-parameter] int main(int argc, char **argv) { ^ ppp.c:82:27: warning: unused parameter ‘argv’ [-Wunused-parameter] int main(int argc, char **argv) { ^ In general, you should aspire to have your program compile with no warnings with `-Wall -Wextra`. When your compiler warns you that your precedences aren't necessarily what you think they are, you should take notice. The unused parameter warnings aren't really a big deal, but you might as well declare main as `int main()` anyway just to get rid of the warning. Running valgrind produces: ==4811== Memcheck, a memory error detector ==4811== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==4811== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info ==4811== Command: ./ppp ==4811== ==4811== Invalid read of size 4 ==4811== at 0x4EAC501: getc (getc.c:37) ==4811== by 0x400830: getToken (ppp.c:8) ==4811== by 0x400AA6: parseTxt (ppp.c:57) ==4811== by 0x400C5D: main (ppp.c:85) ==4811== Address 0x0 is not stack'd, malloc'd or (recently) free'd ==4811== ==4811== ==4811== Process terminating with default action of signal 11 (SIGSEGV) ==4811== Access not within mapped region at address 0x0 ==4811== at 0x4EAC501: getc (getc.c:37) ==4811== by 0x400830: getToken (ppp.c:8) ==4811== by 0x400AA6: parseTxt (ppp.c:57) ==4811== by 0x400C5D: main (ppp.c:85) ==4811== If you believe this happened as a result of a stack ==4811== overflow in your program's main thread (unlikely but ==4811== possible), you can try to increase the size of the ==4811== main thread stack using the --main-stacksize= flag. ==4811== The main thread stack size used in this run was 8388608. ==4811== ==4811== HEAP SUMMARY: ==4811== in use at exit: 180 bytes in 2 blocks ==4811== total heap usage: 3 allocs, 1 frees, 732 bytes allocated ==4811== ==4811== LEAK SUMMARY: ==4811== definitely lost: 0 bytes in 0 blocks ==4811== indirectly lost: 0 bytes in 0 blocks ==4811== possibly lost: 0 bytes in 0 blocks ==4811== still reachable: 180 bytes in 2 blocks ==4811== suppressed: 0 bytes in 0 blocks ==4811== Rerun with --leak-check=full to see details of leaked memory ==4811== ==4811== For counts of detected and suppressed errors, rerun with: -v ==4811== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Well, ok, so you didn't check the output of `fopen()` and it returned `NULL` because there's no file there. When you dereference `NULL`, obviously you crash. That's the first bug you should fix. `touch "test2.mxif"` and valgrind produces: ==5086== Memcheck, a memory error detector ==5086== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==5086== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info ==5086== Command: ./ppp ==5086== ==5086== Conditional jump or move depends on uninitialised value(s) ==5086== at 0x4C315BC: strcmp (vg_replace_strmem.c:842) ==5086== by 0x400AFE: parseTxt (ppp.c:61) ==5086== by 0x400C5D: main (ppp.c:85) ==5086== ==5086== Conditional jump or move depends on uninitialised value(s) ==5086== at 0x400B01: parseTxt (ppp.c:61) ==5086== by 0x400C5D: main (ppp.c:85) ==5086== ==5086== Conditional jump or move depends on uninitialised value(s) ==5086== at 0x4C315BC: strcmp (vg_replace_strmem.c:842) ==5086== by 0x400B8F: parseTxt (ppp.c:71) ==5086== by 0x400C5D: main (ppp.c:85) ==5086== ==5086== Conditional jump or move depends on uninitialised value(s) ==5086== at 0x400B92: parseTxt (ppp.c:71) ==5086== by 0x400C5D: main (ppp.c:85) ==5086== ==5086== Conditional jump or move depends on uninitialised value(s) ==5086== at 0x4C3044F: strcpy (vg_replace_strmem.c:506) ==5086== by 0x400BCA: parseTxt (ppp.c:75) ==5086== by 0x400C5D: main (ppp.c:85) ==5086== ==5086== Conditional jump or move depends on uninitialised value(s) ==5086== at 0x4009DE: addChild (ppp.c:38) ==5086== by 0x400BEC: parseTxt (ppp.c:76) ==5086== by 0x400C5D: main (ppp.c:85) ==5086== ==5086== ==5086== HEAP SUMMARY: ==5086== in use at exit: 180 bytes in 2 blocks ==5086== total heap usage: 5 allocs, 3 frees, 4,908 bytes allocated ==5086== ==5086== LEAK SUMMARY: ==5086== definitely lost: 180 bytes in 2 blocks ==5086== indirectly lost: 0 bytes in 0 blocks ==5086== possibly lost: 0 bytes in 0 blocks ==5086== still reachable: 0 bytes in 0 blocks ==5086== suppressed: 0 bytes in 0 blocks ==5086== Rerun with --leak-check=full to see details of leaked memory ==5086== ==5086== For counts of detected and suppressed errors, rerun with: -v ==5086== Use --track-origins=yes to see where uninitialised values come from ==5086== ERROR SUMMARY: 6 errors from 6 contexts (suppressed: 0 from 0) Which is a *lot* of uninitialized values. The funny thing about uninitialized values is that they're super unpredictable. The *really* funny thing about uninitialized values is that in many VMs and debugging environments, they're often zeroed out, which means they work the way you expect them to. But when you compile them with full optimization, the compiler won't clean up before or after you, so when you barf all over your stack it just dies with a segfault. If you expect a string to be an empty string, it's enough to just set the first byte to zero if you're using the standard tools in `string.h` and aren't doing manual string manipulation yourself. Learn to use your debugging tools. The clang static analyzer found five bugs, there are a bunch of problems found by valgrind. gdb is also invaluable. You got some valuable feedback in this thread about what your specific problem may have been, but this is a great opportunity for you to learn how to isolate and fix problems in your own code.
Yes, this is funny because it's the first mistake I made when I learned C at school. I thought since the purpose of getchar() is returning a char, I should declare my variable as a char. At that time (around 1992) my compiler did not emit any warning when doing this.
`fscanf` will probably be useful here.
And using "loose" when he meant "lose" in the opening paragraph! Astounding! 
Seems to work for me. What output are you getting, and how is it different from what you expect?
Output: Ingrese el numero de personas2 Cual es su peso34 Cual es su sexoF Cual es su altura1.80 Diga su edad18 El peso de la persona 1 es 34.000000 El sexo de la persona 1 es: F La altura de la persona 1 es: 1.800000 Cual es su peso35 Cual es su sexoM Cual es su altura1.90 Diga su edad18 El peso de la persona 2 es 69.000000 El sexo de la persona 2 es: M La altura de la persona 2 es: 3.700000 El peso promedio de una persona es: 34.500000 La altura promedio de una persona es: 0.950000
You're using the `pes` variable in your "El peso de la persona" output, but that's the sum of all the weights. You should be using the `peso` variable, which is what you read the value into.
Ok, thank's :D. The output: weight = 34 + 60 promWeight = (34+60)/2 ¡ERROR! weight = 120 promWeight = 120 / 2
Please fix your formatting. `␣` is meant as a visual representation of whitespace. Hit the space bar once for each `␣`.
Better use the [libnetpbm](http://netpbm.sourceforge.net/doc/libnetpbm.html) as it's standard.
The examples are loaded with errors, undefined behavior, inaccuracies, important omissions, and use of non-standard headers/functions. It seems like it was written by someone with a decent amount of experience writing C on Windows, but who learned everything through trial and error or experimentation. There are gaps in the author's knowledge. 
Well, if you put it that way...
&gt; We can all agree with the fact that this structure should be 8 bytes long, just like a uint64_t That may be the case on some systems when `int` is a 32 bit type, but that isn't the case everywhere. For example, on some systems, int is a 16 bit or 64 bit type. &gt; That means we can bitshift structures, or perform operation on what would normally be two different variables. No you cannot, that's undefined behaviour as you violate the strict aliasing rule. &gt; What is the physical reality behind a structure? That's implementation defined. The C standard merely says (ISO 9899:2011 §6.2.5 ¶20 #2): &gt; A *structure type* describes a sequentially allocated nonempty set of member objects (and, in certain circumstances, an incomplete array), each of which has an optionally specified name and possibly distinct type. &gt; is there a clear hardware-level distinction between its content? Typical hardware does not know what the data stored in its memory represents. Typical hardware does not know if two bytes belong to the same integer or not. However, there are some systems where the hardware does know. For example, C programs can be compiled for LISP machines where this is the case. Such implementations of C are very weird though.
Your example is totally invalid because it violates the aliasing rules. But assuming that it didn't, all you're doing is manipulating the bytes at those addresses as if they were a 64 bit integer. That's it. You can't really say anything more than that. Memory is memory, it doesn't have any structure. You can treat a chunk of bytes as if it was eight 8-bit integers, or four 16-bit integers, or two 32-bit integers, or a single 64-bit integer, or anything else. The hardware doesn't know or care; it provides instructions for doing operations in each of those sizes and it's up to you to tell it what to do. (Also, no, we can't agree that the structure should be 8 bytes long. The size of `int` is platform-dependent.) 
&gt;(Also, no, we can't agree that the structure should be 8 bytes long. The size of int is platform-dependent.) that's why I said "should", most people here are using Linux x86_64
&gt; ptr &lt;&lt; 1; You cannot perform bitwise arithmetic on pointers. Does your compiler really accept this statement?
Usually in C you don’t return a structure directly, especially if there’s anything important in it. You have three “C-like” options: 1\. Make `init` and `deinit`functions and an `INIT` macro to manage the `struct`’s state: void structName_init(struct structName *t) { t-&gt;... = ... } void structName_deinit(struct structName *t) { ... } #define structName_INIT {...} Now, you can use these to explicitly manage the state of a structure, and this lets the user control its storage and disposition on their own, though not that of its referents. This separates concerns nicely. Alternatively: 2\. Make a `create` and `delete` pair that allocate and deallocate everything at once: struct structName *structName_create(void) { ... } void structName_delete(struct structName *) { ... } This is usually a better idea if `structName` is opaque (e.g., a handle). Fiinally, *only* for simple-ish structs that require no extra management, you might 3\. use the structure as an extra temporary output from a function: int do_something(int a, int b, struct structName *out) { ... if(out) { out-&gt;... = ...; } return 0; } I suggest going with option #1 for this, since it does well with preventing undefined pointers and leaks. So in that case: #define myStructure_INIT {0, NULL} void myStructure_init(struct myStructure *p) { p-&gt;num = 0; p-&gt;array = NULL; } void myStructure_deinit(struct myStructure *p) { if(p-&gt;array) { free(p-&gt;array); p-&gt;array = NULL; } } The caller would do struct myStructure data = myStructure_INIT; ... do_something_to_fill(a, b, &amp;data); ... myStructure_deinit(&amp;data); 
I have a hard time deciding what exactly you're trying to ask, but if you're asking about if the hardware knows what specific bytes represent, the answer is no: At the hardware level, the concept of a `struct` really doesn't exist - you just have bytes, and more bytes. A `struct` in the hardware context is just an organized set of bytes. There's generally no difference between two different sets of 8 bytes - their meaning is defined by how you use them. In a way, you can think of the hardware as being "type-less" - the hardware doesn't know what an `int` is, but it does know how to manipulate a set of 4 bytes in a way that it is treated as a number. If you want to go and treat that same 4-byte value as 4 characters instead, the hardware will just again manipulate that set of 4 bytes as through they are 4 characters. Ignoring the problems with actually attempting to do what you wrote in C, as far as the hardware is concerned it doesn't care where the bytes are coming from or what you do with them. So if you do what you did in assembly, it would simply do a bit-shift across the first 8 bytes being pointed too - which is the same 8 bytes occupied by the contents of the `struct`. It should be noted that the compiler has some free range to do various things with `struct` layout before it ever touches the hardware - namely padding. What you wrote would still work theoretically (Though not be legal C), but part of the 8 bytes modified by the shift might be padding bytes inserted by the compiler (Though in this case it is obviously unlikely). But in the end they're still just bytes, so the hardware doesn't care. As far as the compiler goes, the way you wrote it won't work because it breaks C rules. That said, there are ways to accomplish what you wrote using compiler extensions. First, the `__attribute__((packed))` can be used to ensure the `struct` will contain no padding: struct s_mystruct { int a; int b; } __attribute__((packed)); And then, to get around strict-aliasing rules, compile with `-fno-strict-aliasing`. Utilizing those two things, the code you wrote should function like you'd expect and shift your `struct` as one 64-bit integer.
Try running this code - it should give you some ideas. I would also suggest that you start by writing a function `printLine( char c, int size)` that just prints the first line of your square. char x = 'm'; printf("%c %c %c\n", x -1, x, x+1);
Characters in C are actually (as far as the compiler is concerned) stored as integers based on their ASCII value, so this is legal: c += 1; //c starts as 'a', now it is 'b' Therefore, something like printf("%c", (c + i)); would work inside a for loop with i as the iterator.
Thanks for the image, that helps.
&gt; We can all agree with the fact that this structure should be 8 bytes long, just like a uint64_t First, and I guess that's obvious but just to be clear, signed int isn't a fixed-width integer type and only guaranteed to be 16 bits wide, uint64_t is, and is exactly 64bit. Two signed int could be between 32 and 128 bit. Second, you can and should not assume that a structure occupies the assumed sum of its members' size on a certain platform. Often the compiler will add unnamed members in order to maintain proper alignment of the 'actual' members, that's called padding. Something like struct some_struct { char a; int b; }; May or may not look like that: | some_struct.a | * | * | * | somestruct.b ... Assuming that int is 4 bytes and char 1 byte, sizeof(int)+sizeof(char) Will be 5, but sizeof(struct some_struct)); might be 8. You can only assume that there isn't any unnamed member added before the first member of the structure, that the address of the structure's first member is the same as the address of the structure, if you try to access padding bytes, their value is not specified, members will be layed out in the order you declared them within your structure. 
you could either include some meta data inside of each struct that would describe the layout of the struct or you could write a program that would generate the required serialization functions from the struct definitions.
Please don't try to manipulate the voting behavior of others. That's against the reddit rules. Never indicate how others are supposed to vote, just leave that out.
I wrote [this](http://github.com/fuzxxl/memf) a while ago. Maybe it's useful for your purpose.
Are you pointer-chasing when you serialize the structs? Otherwise, why not just memcpy the size of the struct? You could just use a generic function and a macro that calls it, something like \#define serialize(struct) do { bufferedWrite(struct, sizeof(struct)); } while (0); and then have bufferedWrite memcpy to your buffer, and keep track of the position in the buffer with a static variable. Then, you can write to flash a page at a time, if you have access to doing that.
I code on a Dell Windows 7 64 bit work laptop for a 16 bit ARM processor...
That is possible but makes the file format platform-dependent.
I know how to get input and print the alphabet, I'm just lost on how to finish it with printing the rest of the alphabet after the letter and how to say "that's not a lower case letter" after they input anything other than a lower case letter.
If you're on linux, I'd use the builtin islower and scanf functions. The manpages should show you how they work.
Sadly I'm on windows.. 
The most important skill for a programmer is knowing how to go about finding answers to questions. You will only learn this by doing. Here are a few relevant questions. Have you tried google? Do you know what ASCII is? Do you know what a while() loop is and how to implement it? Do you know what the standard library is and what is in it?
chars in C just numbers which when printed, print a specific character stored in a table. For example, 'a' is 97, but if you print it using printf with %c it will print out as the letter a, but if you convert it to an int and print it out with %d it will print as 97. So to check if something is a lower case letter you can just compare against the lowest and highest lower case letters, since ASCII represents the chars in continuous order as they appear in the alphabet. bool isLowerCaseLetter(char x) { return (x &gt;= 'a') &amp;&amp; (x &lt;= 'z'); }
&gt; how to say "that's not a lower case letter" Have you tried googling that? Try this term: &gt; [How to tell if a character is a lower case letter in C](http://google.com/search?q=How+to+tell+if+a+character+is+a+lower+case+letter+in+C)
Can you explain the type id more? Never seen this in C before 
could you post the solution after you're done, I just randomly saw this and started working on it myself. thanks
There are really only two things you can assume about the layout of a struct: 1. The struct can be treated interchangeably with its first field. E.g., this will print out 10: `struct s_mystruct test;` `int *ptr = (int *)&amp;test;` `*ptr = 10;` `printf("%d\n", test.a);` 2. The fields are placed in memory in increasing order. I.e., `&amp;test.b - &amp;test.a` is a positive number. Beyond that, it's up to the implementation to decide. Notably, there can be padding between `a` and `b`.
computer systems a programmers perspective is a good book and primarily uses C. it is however way too advanced for a beginner.
CapnProto -- its in memory layout is the same as its on-disk layout. https://capnproto.org/
Have you considered macros? #include &lt;inttypes.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #define SAMPLE_STRUCT(ENTRY) \ ENTRY(a, uint8_t) \ ENTRY(b, int16_t) struct sample { #define MEMBER(name, type) type name; SAMPLE_STRUCT(MEMBER) }; int main(void) { uint8_t buf[256]; unsigned i; struct sample x0 = { .a = 230, .b = -4096 }; i = 0; #define ENCODE(name, type) \ for (unsigned name##_i = 0; name##_i &lt; sizeof(type); ++name##_i) \ buf[i++] = (x0.name &gt;&gt; (sizeof(type) - name##_i - 1) * 8) &amp; 0xFF; SAMPLE_STRUCT(ENCODE) for (unsigned k = 0; k &lt; 4; ++k) { printf("%02x ", buf[k]); } printf("\n"); struct sample x1; i = 0; #define DECODE(name, type) \ for (unsigned name##_i = 0; name##_i &lt; sizeof(type); ++name##_i) \ x1.name = (x1.name &lt;&lt; 8) | buf[i++]; SAMPLE_STRUCT(DECODE) printf(".a = %" PRIu8 ", .b = %" PRId16 "\n", x1.a, x1.b); return EXIT_SUCCESS; } It should be easy to extend this to more complicated structs.
please learn to copy paste complete example in text form first
+1 for GTK+. It's got extremely widespread adoption and is widely available, and most of the major compilers (at least GCC and Clang, haven't tested MSVC) let you link to it easily. It's well-documented, and because it's been around for so long, there's tons of reading and tutorial material out there for it. Be warned though, if you've ever done GUI programming for the web, or using something like Electron, GTK+ may have a bit of a learning curve to it. There's also a more modern, and very popular GUI toolkit called Qt. It's nominally a C++ library, but has bindings for dozens of languages, including C, although these are largely not maintained as well, or as actively, as GTK+. 
Literally 0 documentation, except for a few dev comments here and there. Not even the functions in the header file are annotated at least. What's the point in making a library if you don't document it? I'm not gonna spend a week trying to figure out your library.
&gt; As far as the compiler goes, the way you wrote it won't work because it breaks C rules. That said, there are ways to accomplish what you wrote using compiler extensions. ... Note that even that might not be sufficient as `struct s_mystruct` might not be sufficiently aligned for an `uint64_t`.
Note that the other de-facto standard is Qt. The de-jure standard is Motif by the way.
Adding to this, if you're looking for something like Qt but more modern and with much better support (the creator of the library goes online every night to answer questions about it), try [JUCE](http://www.Juce.com). It's C++, but there are also C bindings. For pure C, probably stick with GTK+.
god forbid, a programmer forced to read source code!
How used is Motif? Other than the common desktop environment I haven't heard of anything that uses it, and CDE is ancient. 
My mistake, seems like they aren't online anymore (they were called QtC, but I can't find a repo to them anywhere -- just the odd reference on some old forums). Nowadays using Qt with C involves [writing non-GUI logic in C, a GUI layer in C++, then probably using C++'s CFFI to integrate one with the other](https://stackoverflow.com/questions/1728509/does-qt-have-a-c-interface).
Why would I have to decrypt your source code, just to use your library? Doesn't that beat the entire point of using a library which is to abstract from the implementation?? If I wanted to learn how networking works in C I'd study libcurl's source code, but I'm not gonna look at libcurl's source code if I want to download a file from my program. Besides what you're asking is even harder in cross-platform libraries like libui, because the underlying implementation differs on each OS and you need to have knowledge on each GUI toolkit they are basing it upon (GTK, WinAPI etc) to truly grasp how this mess works. Maybe unix tools should stop coming out with manpages, by your logic. Maybe we should all just read their source code and figure out their command line flags and what they do, on our own. Maybe we shouldn't even write libraries at all and just go back to programming from 0 all over again, every time we want to write a program. Who needs abstraction amirite :P
Very good catch! That didn't occur to me, I supposed I'm a bit too used to x86. Interestingly, after doing some tests it turns out that `__attribute__((packed))` sets the `struct`s alignment requirements to 1 regardless of its content, so the alignment of `struct s_mystruct` is definitely not good enough in that case. I suppose in some ways that makes sense, since without padding you can't do both unless the size of the `struct` happens to be a power of two (IE. If you make an array out of 7-byte packed `struct`s, you can't align them all to 8 or 4 bytes unless you insert an extra byte in-between to make the elements 8 bytes long). Has interesting implications on the size of a `struct` - imposing alignment requirements can result in padding at the end of a `struct`, even if the `struct` is marked as `packed`. All that said, simply adding a `__attribute__((aligned(8)))` fixes the issue (Assuming I haven't forgotten any other details): struct s_mystruct { int a; int b; } __attribute__((packed)) __attribute__((aligned(8)));
quick and ugly hack job, should work(Comments welcome). int lev(const char * str1, const char * str2){ int str1_len = 0; int str2_len = 0; if(str1) str1_len = strlen(str1); if(str2) str2_len = strlen(str2); if(str1_len &amp;&amp; str2_len){ return lev_tr(str1, str2, 0); }else{ return str1_len + str2_len; }} int lev_tr(const char * str1, const char * str2,int diff_c){ /*if one string is longer than the other*/ if(*str1 == 0) return diff_c + strlen(str2); if(*str2 == 0) return diff_c + strlen(str1); if(*str1 == *str2){ return lev_tr(str1 + 1, str2 + 1 , diff_c ); }else{ return lev_tr(str1 + 1, str2 + 1 , diff_c +1 ); }} EDIT: I am still still learning about tail recursion so if this function is not quite there please forgive me. EDIT2: now that I actually look up what the Levenshtein distance is I see my function will not work.
What is #/g/sicp? EDIT: I think I found it. Is it this? https://g.sicp.me/books/
If your are targeting embedded platforms you should differently have some gcc exp. At least my experience, linux / *nix experience is highly desirable. 
Thanks, I guess I'll get comfortable with the environment.
I do wonder what the chances are that anybody ever hit this bug in production. I don't think that unstable btrfs on Itanium had many users.
It doesn't look good. The 1990s OOP/C++ hype meant that most efforts to create cross-platform GUI toolkits went into toolkits based on C++ instead of C, which are slowly dying now as C++ bloats into oblivion. If you are still willing to deal with something C++-like, Qt is the best option. You can still use the win32 API, it may be an option when writing simple GUIs for small Windows-only tools. However, Microsoft doesn't seem to encourage this, they have long abandoned and been fighting against the C language; they want you to use their C# and .net stuff instead, and treat C and the win32 API as legacy. So you should probably use GTK+. It has a good, well-documented API and works reasonably well on Windows, even if you will have to ship a few megabytes of gtk-related libraries with your applications. It's somewhat sad that there aren't any real alternatives to GTK+, and probably won't be for a while because the attention has shifted to web and mobile platforms and the enterprise world seems to be content with ugly Java solutions. 
I've seen a lot of commercial software using Motif. It's not a bad toolkit, it's lightweight and portable.
its an irc chasnnel, who together compiled a shit load of programming books into a torretn
Hmmm `markdown`? On GitHub you can specify the code highlighting scheme by adding a language specifier after the code segment indicator... Here's a test ```ruby class MyRubyClass def this_is_a_test val puts val end end ``` I thought Reddit had syntax highlighting, now I tested it out... ...hmm, disappointing. I'm voting this one up! B.
Yeah I wish it was that simple
No. I don't like syntax highlighting, and I think it makes it harder to read. I hope that if it gets enabled there is a way to turn it off without also turning off user-styles. * http://www.linusakesson.net/programming/syntaxhighlighting/ * https://medium.com/@MrJamesFisher/your-syntax-highlighter-is-wrong-6f83add748c9
Definitely used a lot but I think it would be a good idea to have an understanding of using Emacs/Vi(m) + gcc/clang + valgrind. I don't think it's necessary to switch but you should educate yourself on how to use these tools should you ever need to
The second article suggests you to delete comments if they look ugly &gt;Damn right it’s ugly! It should be ugly! Get rid of those comments! 
For me, the answer is pretty clear. The C standard says (ISO 9899:2011 §5.1.2.4 ¶27): &gt; NOTE 13 Compiler transformations that introduce assignments to a potentially shared memory location that would not be modified by the abstract machine are generally precluded by this standard, since such an assignment might overwrite another assignment by a different thread in cases in which an abstract machine execution would not have encountered a data race. This includes implementations of data member assignment that overwrite adjacent members in separate memory locations. We also generally preclude reordering of atomic loads in cases in which the atomics in question may alias, since this may violate the "visible sequence" rules. I wonder why nobody has cited this section yet.
Hey, I do most of the CSS on the sub. If I can figure out a way to get syntax highlighting I'll do my best to implement it. 
This is such an arrogant point of view to be honest, considering yourself superior because you don't use syntax highlighting. I would say people who prefer plain text never actually worked on large projects, it not about being hardcore and oh I don't use assistance, instead it helps you being more productive. I can also pretend to be superior and claim text editors are for kindergartens, real programming is done on paper and punch cards. Oh and also C is a kindergarten language along with all other high-level languages because the real programming is done by writing machine code directly.
&gt; This is such an arrogant point of view to be honest, considering yourself superior because you don't use syntax highlighting. Son, I just said I don't like it, and provided examples of other people who don't like it. I never said anything about "superior". You think that you needing a tool that I don't, makes you inferior? Are you worried I might think you're inferior? Why do you care? I've been programming professionally for only about thirty years at this point, but I can promise when you've been programming for thirty years, you will stop caring what anyone thinks of you as well. Real programming is solving problems, and a good way to measure the tools you use to program is not by their popularity -- [most people are average](https://en.wikipedia.org/wiki/Chebyshev%27s_inequality), after all -- but by whether these tools help you make shorter faster programs, quickly and correctly. Syntax highlighting interferes with that for me because it makes me stop at the colour boundaries and I find it makes me miss bugs. Turning of highlighting forces me to read the code and makes it easier for me to resist skimming, so *now* I think it's distracting and annoying. You find you're actually able to read by christmas lights? Good for you. I can't do that. Now do you feel superior?
I don't believe there's any superiority in that but you did say syntax highlighting is kindergartners to programming which seems to imply that. I believe this is a preference and some people probably might prefer plaintext for the reasons you mentioned but that certainly does not mean that people who use it are somehow newbies to programming.
Nobody knows how to program. Don't take it personally: Programming is less than a hundred years old. Imagine how people built bridges in the first hundred years of bridges. Now, syntax highlighting is popular, but *is it good*? Who knows. It's not good for me, and it's not good for other people. If you want to convince me it's good, one way to do that is to do something I can't do so that I'll take the leap of faith and study what you're doing. Right now, everyone I have met who can do things that I can't, don't use syntax highlighting. What about you? However, try the "popular" argument? Most people simply don't know how to program, so why would I think syntax highlighting would help? Why do I want to be able to do what "most" people can do? If you imagine my intention is to offend, then you'll be offended, but if you consider that I'm not trying to offend, but I'm defending an unpopular position, then maybe you'll be able to understand what I'm saying.
The point is you (and Douglas) put forth the assumption that "most people like syntax highlighting because most people don't know how to program", as if we're relying on the different-colored text to reveal us the semantics of a piece of code. I use syntax highlighting (granted I might be a mediocre programmer by some standard), not to help me understand what's written but because looking 8+ hrs a day at black-colored text on a white background strains my eyes. Having colored text over a black background helps me a lot. I'm not offended, why would I? In the end of the day, syntax highlighting is just a tool. I wouldn't dismiss someone who uses the Eclipse's GUI to compile/run his/her Java app as someone that doesn't know how Java works just because I can do the same thing with a terminal. They (I) like it that way. But, in all honesty: &gt;I don't get a lot of value out of that because I am more of a grown up, and I'm a professional programmer. And I really don't need the colors to figure out what's a variable and what's a comment. is so condescending, it's almost unbelievable a professional can even think it, not say it in a talk. (Edit: quote formatting) 
&gt; Even the third example uses I knew someone would say that, even though I put in /* function pointers avoided, but I could do them. Just not use them as much */ Third example doesn't use function pointer, but it can. TBH, I don't see much point to them apart from encapsulation of everything (like a poor-mans namespace) and a runtime change of functionality. Something I don't need apart from special cases. I do codepaths at compile time. What I want to do is to follow an idiomatic approach, if there is one, since I'm in a position to start this anew. So, is there an idiomatic approach to good library design? 
What I would call most idiomatic is something closest to approaches two and especially three. If there's a struct of the library state and a `create_library` function then the definition of the struct is usually not part of the public API. This way you can change the implementation without having to recompile the client code. Whether or not you use function pointers in your implementation is not very important to the users of your code, so the API is just a bunch of functions and a few incomplete `struct` types. There's no forced grouping of the functions like in your first approach and this is easy to extend later. Or is it your intention to be able to switch the implementation at run time (with several variations of `library_init`)? If you for this reason end up with a lot of *getters* and *setters* (often avoidable/unnecessary) then you can split your struct into a public part and a private part and offer a function to retrieve (possibly a copy of) the public properties. Think `stat(2)`. Honestly, I think most C programmers would say that your ideas are very interesting and useful in special cases, but not worth the trouble for general library design. But hey, it's your code and it's hard to make useful code unusable to others, even with perceived quirks. Also, I'd love to be proven wrong. Finally, regarding your first approach, I've never seen it used in a library API, but I've used something similar to it in normal application code. I designed part of my program to be data driven, and as such I had a few global `const struct` variables with parameter values and pointers to simple functions which others data structures used to declare part of their behavior. I think it made things simpler for me.
&gt; is it your intention to be able to switch the implementation at run time (with several variations of library_init)? In this case no. There are some places where I need that, but in general no. I do codepaths as part of a build process. What I get that you and /u/FUZxxl are saying is to KISS and expose as little as possible. #3 seems to be something what 'looks natural' to my style anyways. Something like pthreads API looks like, I guess. I do need to keep a state of certain things which are common across library, but I can always do a struct, or a couple, which I pass around when needed. I do not mind passing vs keeping a magic global state, even though I am not anti-globals as people tend to be. Thanks, I'll think about it some more and I think this will just nudge me towards keeping it all in functions with a name prefix for library. Choosing a short prefix will be the toughest part :)
*I want to say something about the comments.* *You've all seen code comments, right?* *That's something we put in our code to make it easier for kindergartners to do programming.* *Because each of the lines of code is explained, and so it's easy to recognize, oh that's a magic variable, and that's a ugly hack, and so on.* *I don't get a lot of value out of that because I am more of a grown up, and I'm a professional programmer. And I really don't need the comments to figure out what a function is doing* Wanker. 
Yes. There is an implementation-defined limit to how much data, in total, you can allocate on the stack, and/or in a given stack frame. The program you posted below puts everything on the stack, which is likely the problem. You can work around that limit by allocating your arrays on the heap using one of the malloc() family of functions, provided you free() them when you're done with them. Alternately, if you just DGAF, you can make them global variables. 
Does C++ have a better way to deal with this?
I don't know. Maybe. Define “better.”
malloc sounds great but index acessing seems like a pain? Can 'mallocated' array be put through a void method? 
What's a `void` method?
`dlsym` is pretty fast and you only need to call it once per function. When you put the functions in a structure, the runtime linker calls `dlsym` behind the scenes to fill the structure anyway so there isn't any performance difference.
Not my specific use case (I'm doing a static library), but an interesting point. So one tradeoff is then that you have a dereference to a struct and a function pointer ahead of your function call vs a direct function call, but you get a flexibility if you want to pack it all into a dynamic library and not worry much? 
On my phone. I just Crashed my windows xp. Didn't free the memory. (I know im a genius) Crashed after ~100 iterations thanks anyways. So memory keep accumulating rzther than overwriting?
wow, that's quite the feat to crash your entire system, even if you leaked memory (unlikely)!
I know literally nothing about what how a CPU chooses what to store in its caches but I do know that multidimensional arrays are actually a one dimensional array in memory. Something like `A[i][j]` would be replaced by `A[i*j+j]` I think.
 &gt; ReadPack(pack); &gt; PrintPack(pack); Should be... ReadPack( &amp;pack ); PrintPack( &amp;pack );
Your ReadPack and PrintPack functions expect a pointer to a `struct tPack`, however, you're passing a `struct tPack` directly. How would you change your calls to ReadPack and PrintPack so that you're passing a pointer to pack (or the address of pack)? Within those two functions, the `pack` variable is a pointer to a `struct tPack` and that requires using a special operator in order to access its elements. That operator is `-&gt;`, and replacing something like `pack.msgID` with `pack-&gt;msgID` will allow you to access the msgID member with a `struct tPack *`. `gets` should not be used. An alternative method would be to write a loop which calls `getchar` and then appropriately assigns the result of that into the msg array. Also, don't forget to account for the NUL terminator that should be at the end of a string. Lastly, look again at the format specifiers you're using in relation to what is being passed to them. `%s` expects to be passed a pointer to a string of characters and it will print from the first character pointed to until it encounters the NUL terminator. You should be passing a pointer to the first character in the array, but you're passing the value of the 10th character in your `msg` array (how many elements are actually in the array?). How can you change this to instead pass a pointer to the beginning of the `msg` array? Take a look at these things and comment back with your progress. Feel free to ask more questions.
The other answers here have answered your question but it should be said: you should consider `gets()` deprecated in C as it is horribly unsafe. If you want to scan 9 bytes into a buffer (called `buf`) you should do it as such: fgets(buf, 9, stdin); You should also check to make sure the output of `fgets` isn't NULL.
Thank's for the detailed answer. I had never heard of "-&gt;" before, lel. Here is how my code looks now: ReadPack(&amp;pack); PrintPack(&amp;pack); } return 0; } void ReadPack(struct tPack * pack){ scanf("%3d", &amp;pack-&gt;msgID); scanf("%3d", &amp;pack-&gt;pacID); gets(pack-&gt;msg[9]); scanf("%4d", &amp;pack-&gt;errorCode); } void PrintPack(struct tPack * pack){ printf("Pack: %d,%d,%s,%d\n", pack-&gt;msgID, pack-&gt;pacID, pack-&gt;msg[0], pack-&gt;errorCode); } This code is crashing certainly because of an error in the message which I'll have to look closely later, when I remove that part the code works as intended. The array should have 9 elements at most. I have to go to bed now because it's pretty late here, I hope this thread is still 'visible' tomorrow, thank you!
I don't use it. I don't subscribe to the not useful argument -- whatever floats yer boat -- but I don't find it useful at all with two exceptions: I (un)highlight comments so they don't distract. I use brace matching highlights to help locate ends of blocks. It's all just a bunch of noise to me, but to each his own. 
quite some time ago I participated to a coding contest online (no prizes ), which one of the contest was implementing the levenshtein distance. Results : http://cplus.about.com/od/programmingchallenges/a/Programming-Challenge-39-Calculate-Levenshtein-Distance.htm 
go like this in your shell ulimit -s unlimited then run the code
It might help to enable the address sanitizer and debug symbols in gcc: gcc -lasan -O -g -fsanitize=address -fno-omit-frame-pointer
Very over simplified example: If you access byte #100, the CPU will load bytes 64 to 127 to cache. Accessing data in cache can be 20x faster than data from memory. If you now have an array A[10][64] and access A [5][10] after that A[5][11] the memory addresses will be: 64*5+10(+offset) and 64*5+11(+offset) fo next to each other and it will be very likely that they are both in cache at the same time. Accessing A[5][10] and A[6][10], the address will be 64*5+10(+offset) and 64*6+10(+offset). So 64 bytes appart. Array A[X1][X2][X3][X4] can be accessed A[x1][x2][x3][x4] =&gt; A[sum(xn*(multiply(all sizes to te right)))]
Actually in that video, he goes on to mention that he would like a different type of syntax highlighting.
For embedded programming, you'll be using toolchains specific to the hardware you're developing for. Visual Studio does not have any easy way to switch out toolchains, which makes it not a good fit for embedded programming. Keil is fairly common for ARM-based devices, though I haven't personally worked with it. I have used Altera's tools, and their C IDE is just a version of Eclipse with a plugin for their toolchain. It is also common to use a gcc-based cross-compiler and related command-line tools.
A std::vector lives on the stack but its data lives on the heap. The syntax for declaring a multi-dimensional std::vector is regrettable; boost::multi_array is available but I've never used it.
Please don't do this. void doit(double phi[M][N][O]) { ... } doit(malloc(M*N*O*sizeof(double))); Works just fine with one malloc, and the indexes will be correct.
GCC has this great feature called [nested functions](https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html) that you can use: void foo(int m,int n,int p) { void doit(double phi[m][n][p]) { ... } long long bytes = m*n*p*sizeof(double); void *array = malloc(bytes); doit(array); free(array); } GCC produces very sensible code if you do this, and you don't have to do any special calculations, or extra allocations which will keep the memory addresses cache friendly. You might also note that you can save the array to the disk trivially: FILE *file = fopen(...); fwrite(array, bytes, 1, file); fread(array, bytes, 1, file); Note however, this is a GCC extension: Clang supports something similar but does it *very badly*, so if you work with OSX you'll need to advise people to use actual GCC.
You can also make them static if you don't want to allocate memory. Static variables live in data/bss sections, not in stack.
Automatic highlighting is almost certainly impossible, but it should be possible to create a tool that takes in code and spits out some unholy combination of Markdown, which you'd then be able to style using CSS. It's also possible to build a bot that automatically does that. /r/math for example uses userscripts to turn inline TeX into nice images. All in all, it's probably quite a lot of work, and I'm not entirely convinced that it's worth it.
My cursory poke around online confirmed that it's *very* difficult to syntax highlight. However it's apparently trivial to add line numbers to multi line code blocks, so look out for that in the near future. 
Forgive me if I am wrong but could it be more efficient to use something like memset instead of individually setting each element?
`gets(pack.msg[9]);` is an error. Your compiler should give multiple complaints about this line. If you aren't seeing anything then you need to figure out how to invoke your compiler properly. 
&gt; you should consider gets() deprecated in C `gets` is already removed from C. OP is either using an old compiler, or a compiler in historical compatibility mode. It would be good to use a modern compiler in modern mode. 
Yes changing it back to 3 fixes it even when I'm using 5 years. I don't understand why.
I think you have 40 bit longs, don't you? At least some processors in that family do.
I tried your code works fine with me. How are you compiling it?
I'm running it in C99
That could be the issue, but it works for me on ideone aswell. Just reload the ide or better download PellesC if you're on Windows or use GCC if you're on Linux or Mac.
32bit longs on mine, but int is 16
Excellent answer. In orders of magnitude, do you have a guess of how much slower it would be?
Parameters are still passed in registers for variadic functions on x86_64 Linux. $ gcc -xc - -S -o - &lt;&lt;&lt;'void f(void) { printf("%d %d %d", 1, 2, 3); }' -include stdio.h -masm=intel -fno-asynchronous-unwind-tables -O2 .file "" .intel_syntax noprefix .section .rodata.str1.1,"aMS",@progbits,1 .LC0: .string "%d %d %d" .section .text.unlikely,"ax",@progbits .LCOLDB1: .text .LHOTB1: .p2align 4,,15 .globl f .type f, @function f: mov ecx, 3 mov edx, 2 mov esi, 1 mov edi, OFFSET FLAT:.LC0 xor eax, eax jmp printf .size f, .-f .section .text.unlikely .LCOLDE1: .text .LHOTE1: .ident "GCC: (Debian 4.9.2-10) 4.9.2" .section .note.GNU-stack,"",@progbits 
I couldn't say for sure. Depends on the memory speed, processor speed, whether the section of the stack is in the cache, and other variables.
Thanks for clarifying u/Nirenjan 's post. In general, should I expect similar performance between variadic and normal functions?
Technically this is true in that it can spill to the stack (though see the comment below too), but that's a wash mostly - other functions with many arguments or of certain types will also spill. Additionally, the last stack frame is almost certainly in L1, which is one cycle slower than registers, so completely negligible for program performance. Probably the biggest issue is inlining is much trickier and the functions generally need to do some fairly heavyweight parsing to recover the types (think parsing the printf format string). All else equal, I would be very, very surprised if simply using variadic functions was a perf hit in a real program. However, variadic library functions do end to be expensive - so caveat emptor. 
Both functions do not look like they are correct. Have you tried merging two lists like `0 2 4 8` and `1 3 5 7 9` which have to be interleaved? Your function doesn't look like it handles such cases correctly.
People put effort into writing an answer to your question. This effort is useful for future readers. By deleting your post you remove it from the index, thus making it impossible to be found by future readers thus destroying the work of all the other users who answered to your post. Don't destroy the work of others. Have respect.
Good read! Thanks is for sharing.
Can You try rephrasing this into a coherent question? If you are on Linux, /var/share/dict if a huge file with a list of words. 
Very good stuff! I admittedly don't know nearly as much about the amd64 SysV API as I would like. Would I be right in guessing that the prologue is the creation of a `va_list` on the stack? It makes sense it would have to happen early, since the registers the arguments could be contained inside of are probably about to get trashed.
Because amd64 has more registers than i386 and passing arguments in registers is usually faster than passing them on the stack.
&gt; always recommend they study two things, because you cannot do them without understanding the underlying theory: concurrency (threading and multiprocessing), and networking. I've been a professional firmware engineer for 9 years, the only one in my company, doing everything from the lowest level hardware interface programming to the highest level GUI / custom file systems / RTOS programming and I have never needed to know either of these.
Thanks for the clarification.
This site looks like it is either a reboot or borrowed heavily [from this one](http://www.cquestions.com/).
Should be obvious, but you're missing a comma. There are other problems with your code as well.
What's funny is that he did put the comma in the error message all right :-)
thanks for the correction. what else is wrong please tell me. I am new to c
 while(first=num/10) {first=num/10}; It will only exit the loop if what is inside the parenthesis is 0, i.e. only if `num/10` is 0, i.e. only if `num` is &lt; 10. Thus your algorithm is wrong.
Yep! malloc returns a void*
I'm gonna say yes, but obviously better means a different thing depending on the goal (speed, memory efficiency, etc). Check out std::vector. In terms of dynamic allocation (aka on the heap), C++ makes it a little easier with the "new" keyword: float* array = new float[250000]; // do stuff with array; delete [] array; The above code is the c++ version of malloc and free. At the end of the day, it's whatever works for you though.
Windows XP? Wow. Yeah you definitely want to free your memory.
I actually wrote while (first&lt;10) {first=num/10;} typo while posting it on reddit. is the whole program correct correct? after the error correction i put input as 1234. the sum is supposed to be 5. but the output shows 1238. Idk whats going on 
You never initialize first to any meaningful value before using it. That is undefined behavior; first could be any value. It's probably something greater than 10. Fix that, and then realize that you're setting first to the same value every time the body of the loop is executed.
[No](http://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm). Even if POSIX only defines thirty two signals, it doesn't assign them [all numbers](http://pubs.opengroup.org/onlinepubs/000095399/utilities/trap.html), and it doesn't limit systems to only allowing 32 signals. Why would you even care? If you want a data type that can store a list of all signals, use [sigset_t](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html).
The POSIX standard says: &gt; The &lt;*signal.h*&gt; header shall define the following macros that are used to refer to the signals that occur in the system. Signals defined here begin with the letters SIG followed by an uppercase letter. The macros shall expand to positive integer constant expressions with type **int** and distinct values. The value 0 is reserved for use as the null signal (see *kill*()). Additional implementation-defined signals may occur in the system. So, you can assume they're greater than 0, but you can't make any assumption about the maximum value (other than it of course being no greater than INT_MAX). Also, NSIG is a GNU extension, not part of the POSIX standard.
Do not fully declare the structure in public headers. Instead, only provide functions that lookup a key. To allow easy future extensions, make the keys strings if performance is not critical.
 int first, last, sum, num; printf ("Enter 4 digit number"); scanf ("%d", &amp;num); //to find the first digit first = num; while(first&gt;10) first=first/10; //to find last digit last=num%10; sum=first+last; printf("sum of first and last digits = %d\n", sum); Here you go fixed it for you.
Ah, I see. `new` is supposed to be only a single link.
You also can't do this: char string[6]; string = "Hello"; printf("%s", string); So obviously there's nothing special about using a struct. When I try, I get the following error. If you're getting something similar, it tells you what the issue is incompatible types when assigning to type ‘char[6]’ from type ‘char *’ What you're seeing is the difference between initializing a string (in your first example), and assigning a string (in the second). In your first example, the compiler will copy the characters from the word "Hello" into the stack space allocated for `string[6]`. In the second, it will try to copy a pointer to a static string into a space intended to hold 6 `char`s. Since these are different types, you get a compiler error
I have no idea what you're asking. First, put four spaces before your output lines so Reddit doesn't eat the asterisks Next, what exactly is the actual/current output of the program, and what exactly do you want the output to be instead?
It's 3x6, 4x8, 5x10 ... ix2i ... 10x20
so it seems youre trying to print the numbers 3-10 multiplied by their doubles, 6-20. since the second number is double the first, you dont actually need the second for loop. instead, within the first loop, use: printf( "%d * %d = %d\n", i, 2 * i, 2 * i * i ); the second for loop is fine assuming step=2, though the second loop is unneeded. if you do want to keep the second loop, use: printf( "%d * %d = %d\n", i, j, i*j ); i think whats tripping you up is that within the string "%d * %d", nothing is actually multiplied. in the string, "*" is just another character, not an operator.
Ah, and then it's just `printf("%d * %d = %d", i, j, i*j);`
Type `man 7 signal` for an overview of the different signals, including the standard definitions for various operating systems.
&gt; In terms of dynamic allocation (aka on the heap), C++ makes it a little easier with the "new" keyword: &gt; What about multidimensional array?
It looks like you're trying to prototype the function setupWindow() but you don't need parenthesis around the return type. Also, make sure GLFWwindow is a type (typedef) vs a struct. Either way, you may need that line to read: GLFWwindow *setupWindow(int width, int height, char *title, GLFWkeyfun *key_callback);
&gt; you don't need parenthesis around the return type That seems to be it, thanks. Of ***course*** I would think I already tested the one thing I didn't test that fixed it... [expletive] debugging :D 
&gt; How did that even get in there? C isn't my native (programming) language, so I'm still making basic errors on a semi regular basis. 
You should take a look at www.codesdope.com. It contains every step to step tutorial. You will be guided at your every step.
As far as I know I'm trying to set it up for C code. so I want gcc and not g++ but something that I haven't been able to figure out yet is going wrong. I do assume there is some configuration errors and that's what I'm looking for help with regards to.
I don't like `for` int i; int j; i = 3; while (i &lt; 11) { j = 6; while (j &lt; 21) { printf("%d * %d\n", i, j); j += step; } }
Herbert Schildt's books are notorious for being inaccurate and misleading. See for example [https://www.seebs.net/c/c_tcn4e.html](https://www.seebs.net/c/c_tcn4e.html) and [http://www.lysator.liu.se/c/schildt.html](http://www.lysator.liu.se/c/schildt.html). 
The reference by Harbison and Steele is highly reviewed and may serve you better if you're looking for a reference text specifically. http://amzn.com/013089592X
`^L` is the form-feed character. When printed to an old fashioned line printer, it causes the printer to feed the roller until the top of the next page is reached. Most editors display this as some kind of horizontal rule, which is a visual break between functions. [This is covered in the GNU coding standards](https://www.gnu.org/prep/standards/standards.html#Formatting): &gt; Please use formfeed characters (control-L) to divide the program into pages at logical places (but not within a function). It does not matter just how long the pages are, since they do not have to fit on a printed page. The formfeeds should appear alone on lines by themselves. As the formfeed character is considered whitespace, and as whitespace is not significant in C, it's ignored by the compiler, just as a space or newline or tab would be. 
I don't understand what you're asking at all. This function can only be used on a string that can be parsed as a series of decimal digits (optionally with a sign), not any arbitrary string. If you try to convert a string that's not in that format, then it fails and returns zero. That's also why this function is deprecated and should not be used, because you can't tell the difference between a successful conversion of the string representation of zero and the failure case of an invalid string. 
Attempt to use const-correctness where possible. Restrict pointers, using references rather than pointers (in C++), register variables, using const on both data and pointers where applicable, and static variables where it's proper to do so. The const keyword is a lot more important than using the static keyword. But regardless, the more you restrict what a variable can do, the more freedom the optimizer has to do it's job, as it knows what scenarios the variable may encounter and what valid operations may be performed on it. Const is VERY IMPORTANT to do on pointers, especially in low level applications where optimization is critical. Worrying about static strings won't do you too much good compared to the gains of const-correctness, but I'm certain there are scenarios where it can save a cycle or two.
It's working as intended. ~~As Rhomboid mentioned, the function returns 0 as a failure, or 0 when the input is 0, which means the failure case is hard to detect. So you should not use this function when 0 is valid content in the string.~~ You should be using **strtol()** instead of atoi, as it has proper error checking functionality. Your question: "so where is this function converting a string to an int?" is poorly phrased, as you appear to have answered your own question: "So I insert letter it gives me back 0 I put numbers it gives me back numbers". So, if this isn't what you're looking for, what are you looking for? please rephrase your question, or try writing a function yourself to accomplish the desired effect.
Do whatever you are more comfortable with.
I don't care what C++ says about `atoi` (and please don't link to C++ documentation). Here is what [POSIX says](http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoi.html), which is aligned to the content of ISO 9899:1999: &gt; The call atoi(str) shall be equivalent to: &gt; &gt; (int) strtol(str, (char **)NULL, 10) &gt; &gt; except that the handling of errors may differ. If the value cannot be represented, the behavior is undefined. In the *Application Usage* section, it is clarified: &gt; The atoi() function is subsumed by strtol() but is retained because it is used extensively in existing code. If the number is not known to be in range, strtol() should be used because atoi() is not required to perform any error checking. Nothing about “atoi() returns 0 when the input cannot be parsed.” Behaviour is simply not defined. 
You cited the important part already, here, let me highlight it: &gt; The atoi, atol, and atoll functions convert the initial portion of the string pointed to by nptr to int, long int, and long long int representation, respectively. **Except for the behavior on error**, they are equivalent to ... So why do you then claim that the behaviour on error is like that of `strtol`? It doesn't clarify any further, so the behaviour on error is not specified at all. Though, it seems to be intended that it's simply undefined.
Because of context. The standard wouldn't just say that something is different and leave it at that as a mystery for the ages to ponder. It's different in the specific aspect that was previously stated in the prior section. If they had meant to say that the behavior was undefined they would have said that. (Edit: although, yes, any behavior that's not explicit stated as defined is undefined, so they technically don't have to, but that still means you have to read the standard in an uncharitable way, i.e. that the authors were setting up a logic puzzle, and not that they were simply referring to a previous statement.) 
If this was the intent, why does POSIX state something different, even though this section is explicitly in alignment with ISO 9899? Perhaps a look at the C99 rationale would help, but I don't know where to get it.
That appears to be correct. I said that due to many sites documenting it also claiming zero error behavior. The source appears to be the misinterpretation of the following: &gt; 7.20.1 Numeric conversion functions &gt;1 The functions atof, atoi, atol, and atoll need not affect the value of the integer expression errno on an error. If the value of the result cannot be represented, the behavior is undefined. --WG14/N1124 Committee Draft — May 6, 2005 ISO/IEC 9899:TC2 Well, either misinterpretation or purely the blind leading the blind. Thanks for the correction. I have modified my posts accordingly.
I don't see POSIX saying anything that's in disagreement with the standard. I checked the [2004 edition](http://pubs.opengroup.org/onlinepubs/009695399/functions/atoi.html) and the [2013 edition](http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoi.html). It only mentions the case where the value cannot be represented which to me is in reference to the fact that values greater than INT_MAX or less than INT_MIN invoke undefined behavior via the cast from long to int. That doesn't say anything about conversions that can't be performed because of an empty subject sequence. The wording is seemingly more vague here because the context that's present in the standard is absent, but they explicitly state that they have no desire to deviate from the intended semantics of the standard. I guess it's possible that the standard was actually trying to convey the idea that `atoi()` functions as they existed in the old days prior to standardization did no error checking at all and could really have done anything in the presence of invalid input, and that undefined behavior is required here as an escape hatch for that. But I still think they would have said that if that's what they meant. 
Errno not being set is what I've been saying all along. That does not mean that the behavior is undefined. 
Rather than focusing on what isn't defined, what IS defined. If you find a standard that explicitly says that zero error behavior is defined, than that is the case. From what I've found it implies that there is no error handling defined what so ever with regards to atoi. Also, it's important to note that undefined behavior doesn't mean unpredictable, as zero return may be the case for the vast majority of scenarios and environments; but that still doesn't mean it's standard.
POSIX quite explicitly says (in the 2013 edition you linked): &gt; (...) except that the handling of errors may differ. &gt; &gt; The atoi() function is subsumed by strtol() but is retained because it is used extensively in existing code. If the number is not known to be in range, strtol() should be used because **atoi() is not required to perform any error checking.** Anyway, I asked a [question](http://stackoverflow.com/q/38393162/417501) on Stack Overflow because I'm not quite sure what document is correct.
I feel like I've already explained my position. The standard says "except in the case of error", which I interpret as being in reference to not having to set errno, which was established a few paragraphs earlier, since the standard would not point out a difference and leave it as a mystery to be filled in as to what is different. Everything else about the equivalence still applies, and as `strtol()` is obligated to return zero when a conversion cannot be performed, so therefore must `atoi()`. 
And if you want to type \\\^L then you have to type \\\\\\\^L
The digits you enter goes into the string, and that is converted to an int. That's the whole point of the function in question. It's for reading stuff in the form of a string and then converting it to an integer as needed. What do you imagine it should do with a string of letters? What number do you feel would correspond to, say, "srjhg"?
And if you want to type 🍌 then you have to type \\\\\\\banana`•®¢\£
[Nope.](https://i.imgur.com/7lpLqfd.jpg)
Many people may know this as a page break.
Emacs has commands for moving through and manipulating [pages](https://www.gnu.org/software/emacs/manual/html_node/emacs/Pages.html), and several modes that can display them in various ways such as horizontal rules. Seems like it's something Emacs users (like Stallman) use more than vi users.
If you're learning, it might be instructive to try filling out the structure manually. But in general, you should use getaddrinfo. For one, you can't fill out the structure manually in a portable way; if you're on Linux, you don't know what the structure will look like on Windows or BSD some other network stack. But it's also just simpler and easier to use. It does all the work for you in a simple but powerful API, it's completely portable, and it's completely futureproof if someone wants to use IPv6 instead of IPv4 in your application, or even some new protocol that hasn't been invented yet.
&gt; Most editors display this as some kind of horizontal rule, which is a visual break between functions. Really? I just tried a few editors (nano, vim, gedit) on my linux system and none of them treat it as a horizontal rule. I'm curious to know which editors do have this support ...
Emacs does, maybe not by default but it does. (And is probably the editor used by most people that hack on Emacs source code...)
Very interesting. Thank you for the info. 
Fun fact: You can use \^L (CTRL-L) in Terminals to clear the screen, doing essentially the same as the character did back in the day for physical printers.
So Stallman may have printed the source code. Interesting.
I've known I could use ctrl-l for 'clear' but hadn't realized it's because it's a line-feed character. Thanks!
Your printf() at the end of print_strings() is accessing out of bounds (temp[2]).
Thanks.
You only get one level of indirection, i.e. virtual pages map to physical pages. Therefore physical pages not being contiguous is not an issue, but virtual pages do need to be contiguous. You can't re-arrange virtual pages, because you've already used up your one level of indirection. When the heap manager needs to satisfy a request for an allocation, it needs to find a section of contiguous virtual address space. If that virtual address space becomes highly fragmented, then there will be lots of small holes that can't be used for large allocations and end up wasting memory. 
Huh?
Wut
You could us a scripting language to call the C program 20 times. That'd be simpler than trying to write some other C program to call that C program. Python is an obvious choice, but Ruby, Bash, Pearl, etc are all options as well. 
I was actually wondering if there was a way to add a for loop inside of the C code so that I don't have to execute the program multiple times. I've never written a script before.
It seems you are doing the following: for (int i = 0; i &lt; 20; i++) { /* ... */} The `int`-part says that you are declaring `i` in the for-loop, which is valid in C99 (and higher), but not lower (C89/C90). Your choice: * Declare `i` before the loop (see above in my comment) * Set the compiler to use a newer standard (in gcc, add `-std=c99` on the commandline)
It has absolutely nothing to do with the Raspberry Pi. What is the error message, *exactly*?
Then you are trying to do `for (int i = 0...`. Just declare the loop variable before: int i; for (i = 0...
Well, this might not be the answer you're looking for, but I hope it helps anyways. One way to run a C program(though not the easiest, even when you've no prior experience) is the following: Firstly, you'll need a terminal environment (e.g iTerm2 or Terminal) and a Text Editor (e.g Sublime Text 2). After that's been taken care of, you start by writing your program in the text editor.When the program's finished, you save the file as [program name].c, where [program name] is whatever you want to name the file.Then, you go to the terminal interface and after you've found the 'path' in which the file lies(e.g /Users/me/c_programs), you type in the following: gcc [program name].c &amp;&amp; ./a.out This command automatically executes the program without creating an object file.If I left something unanswered PM or reply me and I'll be glad to explain. 
Interesting. You're running on a Pi? What's the setup/environment?
EnglishAngel, next time post the error like this. It'll clear up a lot of confusion! :)
Really sorry, so do you know how to fix it?
It's not as simple as doing that. If you look at the code in the link I provided you will see what I mean.
error: for lep initial declaraions are only allowed in C99 mode.
Is it really as simple as declaring it outside of the loop? Do you by any chance know why this is the case?
I'm not familiar with Xcode or even macs for that matter. But, as a stop gap until someone else answers, you can use an online compiler like one to play with C. http://www.tutorialspoint.com/compile_c_online.php 
The error message literally tells you exactly why.
I think this will require the `markdown` parser to attach a class name to the code segment when using a ` \`\`\`language ` notation. Most markdown parsers support this GitHub "flavor" (I actually think it's practically standard). Even if the class name is ignored by the highlighting engine, this will allow developers to use the shared syntax we tend to use (practically) everywhere. In any way, highlighting will require javascript to analyze the code blocks and assign class names to keywords and language identifiers by wrapping them in a `span` object... ...These things have been done before and are quire easy to implement using existing open source libraries (they're a headache to write from scratch). The great thing about implementing this using javascript+CSS is that it's all client side code, so there's no real server side resource impact. I've implemented something like this on [plezi.io](http://www.plezi.io). You can [have a look at the code here](https://github.com/boazsegev/plezi-website), the automatic highlighting is performed by the [client initiating this javascript](https://github.com/boazsegev/plezi-website/blob/0c6edb8b584d9d0746119085237c5bddd55d643c/docs/layout.html.slim#L92-L94), which is a library I found on GitHub and that I'm very happy with - it even came with a bunch of optional styles for code highlighting, emulating different text editors and IDEs.
&gt; You only get one level of indirection Is this for simplicity? Since virtual fragmentation doesn't really mean anything, the heap manager can just look for a group of small holes and package them together as a chunk of memory
I see, thanks
Not really cause I'm not sure where to enter the commands and because it doesn't specify where to do so. Or maybe I can't read :P idk
gcc and cc ~~are both C compilers~~ both contain C compilers. Whichever you already have you can probably just use that. 
Is there any reason the Op's comments are being down voted, when he/she clearly stated they don't know C? Ops questions should be up-voted for visibility, and the statements that are wrong even more so.
It looks to me like the function itself is not located at 0x100000. Instead, 0x100000 holds the address of the function. So, she's first treating "loaderStartAddress" as a pointer to a 32-bit unsigned integer and dereferencing it to get the actual function address and then casting that to the function pointer. Put another way, this would call a function that starts at address 0x100000 (the program counter would be set to 0x100000): tfunctionPointer fp = (tFunctionPointer)loaderStartAddress; (*fp)(); But the function doesn't actually start at 0x100000. It starts somewhere else and the address of that "somewhere else" is stored at 0x100000. It might have been a bit cleaner to do this: uint32_t const *loaderStartAddress = (uint32_t const *)0x100000; tfunctionPointer fp = (tFunctionPointer)(*loaderStartAddress); (*fp)(); At least, I'm guessing that's what going on. Had to say for certain without the full context of the example. As an aside, she's using a verbose way to dereference the function pointer. It's unnecessary in C. You can just do this: fp(); 
`cc` is the program name of the system's standard C compiler. `gcc` is the GNU C compiler. Typically, `cc` is a symbolic link to `gcc` or some other compiler. For portability, you might never want to explicitly refer to `gcc` in your building scripts so the code compiles on systems that don't use `gcc` as the standard C compiler (such as FreeBSD). OS X is even more special as there, `gcc` is actually a symbolic link to `clang`, a different C compiler.
This line is simply stating that the variable `dir` is set to an initial value of `true`. If you were to then test `if (dir) { printf("True"); } else { printf("False"); }`, then "True" would be printed.
Oh, so whats the ;//gre mean? *edit: this was my question from the start
; signifies the end of an expression. // gre is a comment.
Damn I'm dumb, I totally forgot I was in C.
Actually it's a form feed character... A line feed is ^J
I just edited the post to add an example.
But i now have another problem with DDD. In the status bar Openning session "2323923989ajdkajdkajdkjadd" 
There is a problem with that code in the if condition, but you don't seem to understand how for loops work.
Without more details (and I'm not sure exactly even if with more details), I wouldn't know how to change this to avoid the repetition. One thing you maybe can consider is to see if you could change the data types for the 64 bits stuff and for the 32 bits stuff so that the common stuff go into a common struct type and the size specific stuff go separate: struct size_independent_header_piece { ... }; struct header32 { struct size_independent_header_piece indep; ... }; struct header64 { struct size_independent_header_piece indep; ... }; And then you'd only need to switch on the type in the case in which you have to go on the type specific parts of the headers. You may even be able to write the header readers/modifiers as macros that "switch on the type", in which C11 _Generic can help (as far as I can see).
corner cases might trip me up, I never use the increment prefix. Where did I go wrong?
DDD is a front-end to gdb, and my experience with it has been that it frequently doesn't know what state gdb is in, or times out the connection to it ("underlying gdb is busy", etc). I've never liked it or got it to work for me, and I'm wondering if anybody is seriously using it as part of their daily work? If you're doing development in Linux, I think you should get comfortable with plain gdb and gdb commands. It removes a level of indirection and a source of problems, and there are probably more people who can help you out when you run into trouble. 
Fixed that function for you: https://gist.github.com/ennorehling/e9e2854326b747d517a1856655f6f76c You have similar issues in freeDatabase, mind you.
&gt; OS X is a UNIX. But OS X users, by and large, are not like other UNIX users.
By the way, since you're learning C you might as well give UNIX command-line (terminal) lessons a shot!If you manage to learn how to use the terminal then you can combine it with C and do awesome stuff! Some of the books I remember reading that helped me understand most of the concepts of a terminal are the following: • http://guide.bash.academy/ (not really a book, but it's free and it's very easy to read) • http://linuxcommand.org/tlcl.php (this one is free as well) 
Thanks! I'll try it out :)
Here you go: https://msdn.microsoft.com/en-us/library/bb384838.aspx 
If you don't want to use visual studio, MinGW will give you a GNU type compiler for Windows, enabling you to create Windows binaries. Last I checked, the Microsoft C compiler is still a little dated as far as modern C language support, but I haven't looked in a while so that might not be accurate. There is also now a Linux subsystem for Windows 10 which allows you to run Linux binaries in an Ubuntu environment. https://msdn.microsoft.com/en-us/commandline/wsl/about They call it Bash on Windows, but it's really a complete subsystem. You can use apt-get to install GCC and whatever you need just like on Linux. The thing here, you would be actually compiling x64/x86 Linux binaries here. 
You don't need anything to run C, as it's compiled to byte-code that will execute assembly instructions on the cpu without the need for a run-time environment or interpreter (simplification). Though it is operating system specific as each OS has it's own conventions. Personally, I use MinGW and GCC stuff. If you're just starting out and don't want to deal with the hassle of learning makefiles and the like, just get an IDE like [Code Blocks](http://www.codeblocks.org/downloads) with MinGW, and learn how to modify project compilation flags/options. At the time of posting their website is down... But really, you don't need to be that fancy if you don't want to be. All you need is a compiler and a text editor (technically, a linker, assembler, and compiler, but often these are all wrapped into one package called a 'compiler'... simplification, again). Write code into a text file, point the compiler at it in command line and pass some arguments (or write a makefile which is essentially a script that automates this process), and you can write C without a heavy-weight IDE. Side-note: When you start getting into it with whatever text editor or IDE of your choice you end up using (which I still suggest codeblocks for its ease of use for newbies); I recommend a light-gold main text on black background color theme. Really takes the stress off of the eyes when programming for a long period of time.
what kind of robot are you programming, out of curiosity?
Hello EE, I meet the same problem. Did you resolve it? How?
No, I did not. I tried to work around it, but my solution leaks memory in some weird way.
Considering how splint hasn't been touched in going on 10 years now and never bothered to support C99, I've never been a fan. I've been looking for a quality, free static analyzer to replace it, though.
I don't have access to a roboRio out of the build/competition season, but we do use roboRios when we assemble our bots. I haven't downloaded the FRC tools for C++ yet. Honestly, I didn't know they existed. Im hoping to get into programming because my teams only programmer graduated this summer. From your experience, should I be using Eclipse for FRC programming?
I'll be programming robots for the FIRST Robotics competition. Its a STEM-oriented program for high school students. Here is a simplified video on what it is; https://www.youtube.com/watch?v=ZlsBEoN1M6Y
Thanks for reply. I did measure the voltage by an oscilloscope which confirmed that there is only one High-&gt;low. No bounce. So the signal is clean. I think it's something wrong with wiredPi.
This begin thing isn't the only issue, there are a lot of other false interrupts.
I just received a reply from the author of WiringPi: Yes I know and it does, is the simple answer. I have a fix and will push it in the next release. Meanwhile, just ignore the first interrupt if you can.
It's called IPC and there are a number of ways to do it. Are you on linux/mac or windows? 
Yes because that's the supported IDE for the competition. I'll give you a link to get started on installing FRC C++ tools and Eclipse. https://wpilib.screenstepslive.com/s/4485/m/13810 Should be the top section. 
This is off-topic. Please stay on topic.
Agree with the above. Two further comments. Firstly, if your current greatest feat is tic-tac-toe (assuming just two-player and not AI playing against you effectively), then the from-scratch method programming at the socket level will be a *significant* challenge for you. I say this not to discourage, but to give you a realistic context. Beej's guide (as mentioned by /u/pat_trick) is definitely a great starting point for learning this stuff, but it's far from trivial. Aside from the sockets themselves, you still need to pore over things like HTTP RFCs to do what you're talking about. Second item: libcurl is likely to be a great starting point for you. Alternately, you could use an external process via fork/exec() or popen() to drive a command line tool like curl to gather the data you need.
 for(c=-1; c&lt;=n; c++){ If n is 4, this is going to execute 6 times where c takes the values -1, 0, 1, 2, 3, and 4 Then, once you've found the sum and average of the first n numbers, and enter a new `n` what has happened to the variable `sum`?
It works to a degree, but you have to be careful about rounding error. A better way t compare would be `fabs(a-b) &lt; epsilon` where is epsilon is a small enough value, like 0.000001. floating point numbers don't overflow, they saturate to positive or negative infinity. All operations on floating point numbers produce well defined results. see http://steve.hollasch.net/cgindex/coding/ieeefloat.html for more info
Not exactly, because there's also a `c = c + 1` inside the loop. If I had to guess, it seems like the OP has been hacking around with these values until they got something that appeared to work.
So did I write out code that doesn't really do what I intended it to do? The program seems to work when I plug in 3 integers and values...
Which makes sense, because if n is 3 you get 3 different values of c (-1, 1, and 3). But with n of 4, your c values are -1, 1, and 3 still so your program isn't looking for all the input you've supplied.
How do I adjust my parameters so that it looks for the n "number of integers" based on user input? (eg... 5... 6...7)
Just take out the `c = c + 1` and change your loop conditions: for(c=0;c&lt;n;c++)
Seconded. Works great. I still prefer code::blocks because of the easily available themes (bright white is painful).
If your parameters have different types then I don't think there's much you can do.
Then why don't you say that in the first place? There is a standard library function for this. If `s, e, m` contain sign, exponent and mantissa, write s * ldexpf((float)m, e); The compiler likely compiles this to something reasonably fast.
To elaborate: It's not *dangerous* to compare doubles for equality, but often it's not what you want. It's perfectly fine from an undefined behaviour point of view.
&gt; Is it OK to compare doubles in C? As others have said, likely not. One case it does work is where you compare it to a value you have set previously as you can be sure the same literal will be converted to the same machine number every time. double d = 0.0; if(rand()&gt;0.5) d += rand(); if(rand()&gt;0.5) d += rand(); if(rand()&gt;0.5) d += rand(); if(d==0.0) printf("You're lucky!");
[This book](https://mitpress.mit.edu/sicp/full-text/book/book.html) might be useful at your level. If it's too easy, try reading the dragon book and build your own compiler. That's a fun exercise and you are going to learn a lot.
Programming is just a tool. Build things with it. Look into microcontrollers, SoC, RTOS, etc. You're still a student, talk to your professors to do an independent study. Some of them may have projects available.
A very interesting read, I will use some of the techniques in the game I'm developing right now. 
Are you in the kernel? From the userland, I would `mmap()` the file `/dev/mem` to do that. No idea how to do that from the kernel though. I believe you need to map the the physical page somewhere into the kernel address space to interact with it.
Next week: embedded haskell.
Back in the day, ya you could kludge yourself a pointer to any place in memory: #define bios_data ((unsigned char far *)0x00400000L) ...and treat it like any other pointer: memcpy(buff, bios_data, 55000); //back up your bios in minimal code But nowadays, all that memory is in protected space, and how you access it (do-able) is very very OS-specific (system APIs). //Just to get you started -- coders been creating lots of hacks for same - not hard to find http://stackoverflow.com/questions/1402388/common-way-to-get-bios-information-via-c 
I had read somewhere that you could use dev but that post said if you're trying to use a memory mapped peripheral the proper thing is to write a module, so I want to learn to do that
I believe you want ioremap and friends. The physical-to-virtual mapping is getting in your way. From userspace, there's a very handy program called devmem2 that will let you access one address at a time (8, 16, or 32 bits) for either reading or writing. 
I'm a big embedded fan. Get yourself a $20 development board for some 32-bit Cortex-M4 or something, or even an 8-bit system if you want to go a little more old school and get an easier intro to some assembly language stuff. Put yourself through the paces of starting from the bare metal. You should be able to write a "hello world" program and follow along from the reset vector to the end of the program in assembly language and see just how the C ended up that way and how the linker got everything where it needed to go. Honestly I think every program should at least once write a program for a microcontroller where every bit of code on the device was written by them, by hand. Like on graph paper, looking up opcodes to go with mnemonics, and they keying that all in to memory. Once you absolutely understand what's going on at that level, you can see exactly how every other layer of complexity fits over that.
Semicolon after the while shouldn't be there.
I would suggest looking at the RIOT-OS source. Compared to other RTOSs made for embedded, it has a very linux-inspired design and organization (it was designed to be largely POSIX compliant). They also have an extensive issue tracker and wiki system through GitHub. https://github.com/RIOT-OS/RIOT
Thanks, wow..I feel like an idiot. 
Over the past few years I happened to work with quite a few microcontrollers and always starter with an example projeft given by the chip vendor. Maybe this could be a good starting point? They may be a bit far from moderate complicity however. Try taking a look at cc3200 sdk, I think they wrote and organised their examples and libraries well. Atmel also have good examples for their wifi chips. I think what your saying though is something I also find hard. There isn't exactly a huge community for embedded developers and online resources for more experienced developers is lacking I think. 
Off the top of my head, Busybox, sqlite for Linux level embedded, and FreeRTOS for more embedded than that.
Being in EE, I'm already heavily into microcontrollers. I will try asking my professors for potential projects.
Apart from what everyone else said, are you sure `#define BASE_ADDR = ...` is what you want instead of `#define BASE_ADDR ...`? Same for `OFFSET`.
Ah, right. I did it correct in my actual code
Furthermore: If there is any deinitialization that must be performed before your program terminates, then it's not crash proof and you should consider fixing this problem.
FreeRTOS gets my vote. Probably the only open source RTOS out there that was so easy to get into, just include a few source files into the project, modify the source config header, make some platform(portable) code changes, create a few tasks, and you're good to go. The code is really small yet has a lot of functionality. Look over the source code I'm surprised just how seemly simple it is to do lock free queues and context switches. 
Yer, I thought it looked good. Didn't get to use it in anger though.
Maybe the Rockbox project? http://www.rockbox.org/
Visual Studio is okay, but C on windows is still horrid. Personally, I can't stand Visual Studio, either, but that's a matter of opinion.
I think that's exactly why. A lot of windows users use VS for c++, hell I used it back in the early 2000s for just that. I would assume that few C devs use windows so MS has no incentive to move to C11.
"*Isn't C obsolete?*"
C++ is just better.
K&amp;R is garbage and you're garbage for reading it
C/C++
Java.
"I love scripting programs in C!"
It's useless in C. I think it was a carry over from the B language.
The only places `auto` is allowed as a storage class specifier, the default storage class is automatic anyway; so, it's completely redundant to use it. C++ kept the `auto` keyword but changed its meaning, maybe they're just keeping it as a keyword in C in case they want to do that. 
Think of it like 'signed'. If you declare: int foo; This is the same as: signed int foo; But different from: unsigned int foo; Signed is to Unsigned as Auto is to Static. 
I knew someone would chime in with a counterexample. It's not a perfect analogy. :) 
* You can use four spaces at the beginning of a line to prevent the silly formatting that you're getting. * You're missing any kind of meaningful instrumentation. Try peppering your code with `printf("on line %d x = %x\n", __LINE__,x)` and see if that helps you follow what's going on. * You're missing a `&amp;` address-of in calling `fonk2` i.e. `fonk2(&amp;x)` not `fonk2(x)` so even if your code compiles it's still likely not what you intended. 
can you write the truth please still mistake
for serious replies ou can provide at least more serious info, is it for novices (because looking at CS50 it looks like), what are you waiting from people who can/want join you? 
I'm using notepad++, nppexec plugin for it and tiny C compiler, like here http://docs.notepad-plus-plus.org/index.php/Compiling_Source_Code 
Sounds like core wars. How do you prevent the simple strategy of just writing the memory front to back on repeat? As long as the next memory address you write to is the one you didn't write to for the longest time, your opponent will have a hard time catching up as he can only write to memory with the same speed you write to it.
&gt; Sounds like core wars I already implemented my own CoreWar game, but I didn't really enjoy it and decided to make this one! &gt; How do you prevent the simple strategy of just writing the memory front to back on repeat? From `source/mem.c`: uint8_t read_mem(int address) { while (address &lt; 0) address += MEM_SIZE; return (mem[address % MEM_SIZE]); } void write_mem(int address, uint8_t val, uint8_t _owner) { while (address &lt; 0) address += MEM_SIZE; mem[address % MEM_SIZE] = val; owner[address % MEM_SIZE] = _owner; } The memory is circular. The programs can write to the program counter (which keeps track of the current address) using the `jmp` instruction (defined in `source/op/jmp.c`) &gt; your opponent will have a hard time catching up as he can only write to memory with the same speed you write to it. That's why there is the `jmp` instruction, as well as the (not implemented yet) `fork` instruction, which will create another thread (which belongs to the same player) at a given memory location which has its own program counter.
So int has a default sign/unsign but char does not and is platform specific? Seems like a language wart.
Note that auto now has a new meaning in C++. So if there is a likelihood that your code might be ported to a C++ project, or compiled with a C++ compiler, there's another reason to avoid it.
Like all things it has a reason. The standard requires `char` to be promoted to `int` in lots of situations (for example, doing any kind of arithmetic operation.) It depends on the hardware as to whether a given architecture can efficiently sign-extend or zero-extend a byte to a machine word. Some might be able to do that for free, others might require an extra instruction. If you had a hypothetical architecture that can zero-extend for free but requires an extra instruction to sign-extend, then it would really be awful writing a C compiler if `char` always meant `signed char`. Instead you can choose to make `char` mean `unsigned char` and avoid the overhead. This is irrelevant for `int`, which is why `int` always means `signed int`. I suppose it's also a concern for `short` which also undergoes promotion, but the idea there is that you're probably working with characters in every program ever written, whereas for some people using `short` might be a relative rarity. 
my bad man , the example was wrong in the end its 8 not 12, i edited it.
nvm guys, i solved the problem! thx anyways
It's the opposite of `static`. But it's the default, there's no reason to ever write it. I'm sure there's some reason that ISO included it in the standard, but I don't know what that is. It's so not useful that C++ has now repurposed it starting with C++11. It's actually very useful in C++ with it's new meaning. It's a placeholder for a type name, and makes the compiler figure out what type the variable should be.
I'm just wondering, why is 'counter' a parameter? It seems like you immediately set it to be zero, so why send it in? Why not just make counter a local variable that returns? 
Alright, putting aside for now the fact that you left out significant pieces of your code so we can't test it, 1. When the `while()` loop finishes, `token` is necessarily NULL. You then immediately attempt to dereference it. 1. Your program won't accept the number 0 as an input despite it being a valid value. 1. You're popping values from the stack inside your while loop but not doing anything with them, so those values will be lost. 1. `StackInit()` presumably allocates some memory but you never free it. 1. `myStack` is of type `struct Stack` but you're passing it to `printf()` as if it were a float for the final result. In the future, when you submit a question like this you should always provide a sample that [demonstrates your problem](http://sscce.org/). You should include the actual results of running your code on some given input, and what you expect to be happening instead.
Sorry this is my first time posting on this subreddit. Is this better? struct Stack { float stackItems[STACK_SIZE]; int currentItemIndex; uint8_t initialized; }; int main() { char myString[60]; char *token = NULL; float result; float x; float y; struct Stack myStack; StackInit(&amp;myStack); BOARD_Init(); printf("\nWelcome to my RPN calculator.\n"); printf("Enter floats and + - / * in RPN format: \n &gt;"); fgets(myString, (sizeof (myString)- 1), stdin); token = strtok(myString, " "); while (token != NULL){ printf("\n%f", atof(token)); token = strtok(NULL, " "); } if (atof(token) != 0) { StackPush(&amp;myStack, atof(token)); } else if (*token == '+') { // if token is addition StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x + y; StackPush(&amp;myStack, result); } else if (*token == '-') { // if token is subtraction StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x - y; StackPush(&amp;myStack, result); } else if (*token == '*') { // if token is multiplication StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x * y; StackPush(&amp;myStack, result); } else if (*token == '/') { // if token is division StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x / y; StackPush(&amp;myStack, result); } while (1); } My Push and Pop functions : void StackInit(struct Stack *stack) { stack-&gt;currentItemIndex = -1; stack-&gt;initialized = TRUE; } int StackPush(struct Stack *stack, float value) { if (stack-&gt;currentItemIndex == STACK_SIZE - 1) { return STANDARD_ERROR; } else if (stack-&gt;initialized == 0) { return STANDARD_ERROR; } else { stack-&gt;currentItemIndex++; value = stack-&gt;stackItems[stack-&gt;currentItemIndex]; return SUCCESS; } } int StackPop(struct Stack *stack, float *value) { if (stack-&gt;currentItemIndex == -1) { return STANDARD_ERROR; } else if (stack-&gt;initialized == 0) { return STANDARD_ERROR; } else { *value = stack-&gt;stackItems[stack-&gt;currentItemIndex]; stack-&gt;currentItemIndex--; return SUCCESS; } } expected output: http://imgur.com/K0QGXU4 my actual output: http://imgur.com/chZmLXn 
Sorry this is my first time posting on this subreddit. Is this better? struct Stack { float stackItems[STACK_SIZE]; int currentItemIndex; uint8_t initialized; }; int main() { char myString[60]; char *token = NULL; float result; float x; float y; struct Stack myStack; StackInit(&amp;myStack); BOARD_Init(); printf("\nWelcome to my RPN calculator.\n"); printf("Enter floats and + - / * in RPN format: \n &gt;"); fgets(myString, (sizeof (myString)- 1), stdin); token = strtok(myString, " "); while (token != NULL){ printf("\n%f", atof(token)); token = strtok(NULL, " "); } if (atof(token) != 0) { StackPush(&amp;myStack, atof(token)); } else if (*token == '+') { // if token is addition StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x + y; StackPush(&amp;myStack, result); } else if (*token == '-') { // if token is subtraction StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x - y; StackPush(&amp;myStack, result); } else if (*token == '*') { // if token is multiplication StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x * y; StackPush(&amp;myStack, result); } else if (*token == '/') { // if token is division StackPop(&amp;myStack, &amp;y); StackPop(&amp;myStack, &amp;x); result = x / y; StackPush(&amp;myStack, result); } while (1); } My Push and Pop functions : int StackPush(struct Stack *stack, float value) { if (stack-&gt;currentItemIndex == STACK_SIZE - 1) { return STANDARD_ERROR; } else if (stack-&gt;initialized == 0) { return STANDARD_ERROR; } else { stack-&gt;currentItemIndex++; value = stack-&gt;stackItems[stack-&gt;currentItemIndex]; return SUCCESS; } } int StackPop(struct Stack *stack, float *value) { if (stack-&gt;currentItemIndex == -1) { return STANDARD_ERROR; } else if (stack-&gt;initialized == 0) { return STANDARD_ERROR; } else { stack-&gt;stackItems[stack-&gt;currentItemIndex] = *value; stack-&gt;currentItemIndex--; return SUCCESS; } } expected output: http://imgur.com/K0QGXU4 my actual output: http://imgur.com/chZmLXn 
Do you get warnings when you complie this? Fix the warnings.
It's translating the linefeed character (0x0A) because you're hitting 'enter'. That's a character picked up by getchar(). 'a' = 0x61 'A' = 0x41 0x0A + 0x61 - 0x41 = 0x2A 0x2A is the '*' character. EDIT: As an aside, you probably want to re-evaluate your conditional c&lt;='A' &amp;&amp; c &lt;='Z' is logically equivalent to c&lt;='A' I'm guessing that wasn't your intention. Ref: http://www.asciitable.com/
Alright, it looks like you can ignore point 4 above and you've avoided (but not really fixed) #3, but you still need to fix the others. That output makes some sense based on the code you showed. Also based on this new code, I can say that your `StackPop()` function is wrong. You should put some `printf`s inside your Stack functions and see they're being run the way you expect them to be.
tbh , it doesnt matter , i get the same result , but yes i can do it as u mentioned . but i check the value of the retrun in IF in main function, i can do it like that 2 , i mean instead of if(counter =...) i can do that if (check coloumn (...)==...). thx for the advice tho! 
You're allowing any characters lower than 'A', I don't think you want that. For example, it's going to accept and return characters like "!@#$%", and shift them up by the difference between 'a' and 'A', resulting in "A`CDE". Plus it's accepting the linefeed character because it too is lower than 'A', which is where the '*' is coming from. So change this... return c&lt;='A' &amp;&amp; c &lt;='Z' ? c+'a'-'A' : c; To this... return c&gt;='A' &amp;&amp; c &lt;='Z' ? c+'a'-'A' : c;
what do u mean excatly ? to describe the method that i want to solve the problem here ? or are u talking in general for personal use ? 
true. thank you for the explanation.
i just made the change but, i understand that the expression: return c&gt;='A' &amp;&amp; c &lt;='Z' ? c+'a'-'A' : c; must be written the way it is in order to work, but why doing: c+'a' - 'A' gives you back a lower case? I mean we have to do variable 'c' and then sum 'a' and subtracting 'A' kind of confusing. what is the " why " behind this?
I already did and i know its not working but i dont know why?
Putting single quotes around a single character returns an integer value between 0 and 255 -- what is commonly called a keycode -- the characters 'a' through 'z' have keycodes of 97 through 122, the characters 'A' through 'Z' have keycodes 65 through 90. The difference between any given lower case character and its upper case equivalent, is 32. So entering an 'L' (keycode 76), this code is executed... return (76 &gt;= 65 &amp;&amp; 76 &lt;= 90) ? 76 + 32 : 76; Which returns 108, the keycode for 'l'.
i will use tolower() then.
Thanks for the link. I read through that and it was very helpful. I like this function, however I'd rather use doubles. public static boolean nearlyEqual(float a, float b, float epsilon) { final float absA = Math.abs(a); final float absB = Math.abs(b); final float diff = Math.abs(a - b); if (a == b) { // shortcut, handles infinities return true; } else if (a == 0 || b == 0 || diff &lt; Float.MIN_NORMAL) { // a or b is zero or both are extremely close to it // relative error is less meaningful here return diff &lt; (epsilon * Float.MIN_NORMAL); } else { // use relative error return diff / Math.min((absA + absB), Float.MAX_VALUE) &lt; epsilon; } } I'd replace abs with fabs in the above code. What is the C equivalent to MIN_NORMAL? I know MAX_VALUE is going to be something like DBL_MAX. 
Quoting the man for `tolower()` on OpenBSD: &gt; The tolower() function converts an upper-case letter to the corresponding lower-case letter. The synopsis for `tolower()` is: int tolower(int c) This means, if you want to use the code above, you should write your own function that will take a string as its argument (and you can decide whether you want to modify the original, or return a lower case copy of that string) and internally loop over all characters from the string, replacing each one with tolower(). Finally, your function should return the converted string (or, to be precise, a pointer to a string). It could be something as simple as: char *convert_to_lower(const char *string, size_t length) { char *out; out = malloc(length); memset(out, 0, length); for (int i=0; i &lt; length &amp;&amp; string[i] != '\0'; i++) { out[i] = tolower(string[i]); } return out; } Do note, I didn't include any error handling in the function above. You should ideally check if `malloc()` is not returning NULL. You can then in your last line use: char *name_lowercase = convert_to_lower(name); printf(" your name is (in lower case): %s\n", name_lowercase); free(name_lowercase); Please note, your last line in the original code **didn't** have the `%s` token, which means even if `tolower()` did do what you thought it does (it doesn't), it wouldn't have worked. Please also note, I've used a separate variable to assign the pointer to char returned by `convert_to_lower()`, so that it can be `free()`d later. Otherwise, you would have a memory leak. Finally - my code above should work, but I've typed it in without actually testing it. As with any advice on the Internet, use at your own risk and don't sue me if it causes all your data to be lost or your computer to set on fire. 
Not sure what the question really is. The standard says (I highligthed a few sentences): &gt; Successive subscript operators designate an element of a multidimensional array object. If E is an n-dimensional array (n ≥ 2) with dimensions i × j ×...× k, then E (used as other than an lvalue) is converted to a pointer to an (n − 1)-dimensional array with dimensions j ×...× k. If the unary * operator is applied to this pointer explicitly, or implicitly as a result of subscripting, the result is the pointed-to (n − 1)-dimensional array, which itself is converted into a pointer if used as other than an lvalue. It follows from this that **arrays are stored in row-major order (last subscript varies fastest).** &gt;EXAMPLE Consider the array object defined by the declaration int x[3][5]; **Here x is a 3 × 5 array of ints; more precisely, x is an array of three element objects, each of which is an array of five ints.** In the expression x[i], which is equivalent to (*((x)+(i))), x is first converted to a pointer to the initial array of five ints. Then i is adjusted according to the type of x, which conceptually entails multiplying i by the size of the object to which the pointer points, namely an array of five int objects. The results are added and indirection is applied to yield an array of five ints. When used in the expression x[i][j], that array is in turn converted to a pointer to the first of the ints, so x[i][j] yields an int. A test program for the memory layout, with pointer access, perhaps ? #include &lt;stdio.h&gt; int main(void) { int array[2][4]={{1,2,3,4}, {5,6,7,8}}; int *p=&amp;array[0][0]; int i; for(i=0; i&lt;8; i++) { printf("%d -&gt; %d\n", i, *p++); } return 0; Result: $ ./a.out 0 -&gt; 1 1 -&gt; 2 2 -&gt; 3 3 -&gt; 4 4 -&gt; 5 5 -&gt; 6 6 -&gt; 7 7 -&gt; 8 ` 
thank you for your time...
hmm yes, I was trying to access the variables without using []s ever, pointer math basically.
Nope, if name is a `char *` then using `tolower` won't work because it accepts an `int` (so passing in normal `char`s work fine). You need to print out each letter of the string in lower case individually, or convert each letter to lower case before sending to `printf`.
You're always printing 5 accounts, regardless of how many were populated. Change the conditions of your final `for` loop to only access the entries that were filled.
Great, I had typed a long answer, and now when I try to send it, the comment of OP to which I was answering is deleted, as well as the original question :-(
 for(int i = 0; i &lt; strlen(name); i += 1) { printf("%s", tolower(name[i])); }
Check the man page for open(). You are looking for references to "blocking", as that's the behavior you're seeing. There's a special flag that will prevent it from blocking, but it's not turned on by default. Hint: Be sure to look at what it will return if you try to open a FIFO with O_NONBLOCK and O_WRONLY set. 
**tl;dr** Your program is not getting stuck in an infinite loop. The thread is being blocked on (i.e. put to sleep waiting on) a reader for the FIFO that it's opened in write mode. Once the FIFO is opened for reading (either by another thread in the same process or a thread in a different process), the writing thread will become unblocked. When you open a FIFO for writing, the writer is blocked until there is a reader opened as well. If you want to perform a write, close the file descriptor (and continue execution), and then later perform a read (on the same thread or another thread), you should just use a regular file. `pipe` returns an object which is already prepared for I/O (the reader and writer are both opened). There's no reason to block (and you don't have to worry about it). In contrast, when you open a FIFO for writing, the reader isn't necessarily already set up. Why must the writer block until a reader is opened for the pipe object created by opening the FIFO for writing? Well, assume the writer didn't block. Assume that the thread wrote it's data to the FIFO, closed the descriptor, and then exited (and assume the associated process exited as well). However, since there is no reader open for the FIFO, the pipe object that gets created by the kernel when you open the FIFO for writing now has no references and gets freed. But the data that was written never had a chance to be read! So if the writer doesn't block, there's no guarantee that the data that's written will have a chance to be read before it's freed by the OS. You can pass an argument to `open` that will cause it not to block, but I'm fairly certain that if you do so and attempt to open a FIFO for writing without a reader, it'll fail with `ENXIO`. When the docs say to "be careful to avoid deadlocks," it's referencing this behavior. It may be easy to get in a situation where two separate threads are blocked waiting on each other (or one thread is blocked waiting on itself) if you're using a FIFO for intra-process communication. Hope that helps, let me know if you have any more questions!
If you use floats only, why is your variable `data` a double? Please try to answer my other question, too: Does the mantissa contain the implicit leading 1?
Still wrong (Use `%c` for characters). Also, calling `strlen()` for every loop iteration is pretty slow.
well, i do kw what the program should do :D , how u got the feelings that i dont XD?
What are you trying to achieve by doing that? The post you linked is the typical "shitty answers to common homework" blog spam. The code is not even correct. I recommend you to disregard it.
Yes, but then nonblocking IO is enabled, which is certainly not what OP wants. It's better to understand how named pipes work than trying to apply `O_NONBLOCK` as a bandaid.
Your problem is in this part: x*sizeof(arr); Try printing that out, and see if it's what you expect. You want the number of bytes. Where is 'arr' declared? If it's a pointer, sizeof() will not work like you expect. If it's an array with a declared length, then you don't need to use x*sizeof(arr). If 'x' is the length of the array, you probably meant: x*sizeof(*arr); 
...which is why I directed him to the man page that exactly describes the behavior he's seeing, AND told him specifically in that man page which parts to pay attention to. 
That well explained!
I did make an edit, just forgot to mark it as such.
I don't see any edit, except the one from yesterday.
Oh boy, I remember my programming in C++ classes. I bet you're making this into a calculator next, if that hasn't already been assigned. Lucky that they're telling you the steps though (like doing Reverse Polish Notation), we had to figure it all out with nothing given.
You'd want to use the OR operator `|`, which I tend to think of as a copy operator. If the bit is set in either value, the new value has it. That's as opposed to the AND operator `&amp;`, which is more of a test/match. In that case it matches only if the bit is set in both. Often you'll see an OR operator used in combination with a mask. A mask is basically every bit set except what you're masking. The result is that every bit that's set gets copied except whatever is being masked. You can create a mask by taking the variable or whatever and using the NOT operator, eg `~foobar`
Oh, I see. So if, like, I run my program stub and it freezes, then I run another program that opens the read end of the pipe, it will continue? I already tried to look at the man page for open, by the way, and it just gives me openvt - start a program on a new virtual terminal which is apparently some kind of bash program, and not what I want. giving it man open() or man open(2) results in some kind of syntax error. Help?
 man 2 open Or just google it and you'll find it :) But yes, it's not in an infinite loop - it's blocked, waiting for the other end of the pipe to be opened for reading. 
cool, I would be interested once session support is implemented..
&gt; I need to determine the signed byte stored in an array of unsigned bytes. This is meaningless. What is the actual problem you're trying to solve for which you think this is the solution?
If you need to interpret your page as a page of signed bytes, then make the array an array of signed bytes struct page { signed char buffer[256]; };
thank you 
Although it would probably be frowned on I would just use mmap and go through the address.txt via a crapton of strtol masking the bits you don't need and reading that part.
strcpy() is unlikely to do what you want there.
I admit I don't understand the motivation behind this at all.
&gt;On a side note, would it be preferable to use a `#define` or a `const` in place of magic numbers? I prefer to use const but it doesn't matter. A define doesn't require type specification whereas a const you typically will specify one. I'll still use both but make sure it has type. My applications typically demand leaving little up to the compiler imagination if possible. #define MAGIC 10 Vs #define MAGIC ((uint8_t) 10) const MAGIC = 10; Vs const uint8_t MAGIC = 10; Some pre processors/compilers/linkers also don't put debug symbols for defines since it's technically not a variable. If your app doesn't require extremely high space optimization, it's nice. 
&gt; Is it considered good style to [use `const` and `restrict`] at every possible opportunity? `const` is absolutely invaluable in function declarations. If your function accepts pointers as arguments, and the function doesn't modify the values it points to, and you don't declare the argument `const`, you're doing it wrong. Period. I like to use `const` variables as much as possible because it demonstrates the programmer's intent. When you're reading some unfamiliar code, and you're trying to figure out what a variable does, you care about where it gets modified and where it gets used. If it's `const`, half your job is done for you already: you know it never gets modified. `restrict` is a performance optimization. Take it or leave it. &gt; On a side note, would it be preferable to use a `#define` or a `const` in place of magic numbers? Doesn't really matter. `#define` has more mindshare in C, `static const` has more mindshare in C++. I typically use `static const` for magic numbers, but at the end of the day it's just personal preference.
I would say there are 2 use cases for `const` 1. Declaring a variable as `const` (e.g., `int * const x = whatever;`). This is only a matter of personal preference, as it just provides a little static safety to the programmer, and that static safety only exists as far as the local scope. It shouldn't have any effect on the code generated (under a sane compiler) 2. Declaring a variable as pointing to `const` (e.g., `int const *x;`). This is really important for two reasons. The first reason, it affects the prototypes of your functions. `void foo(int)` and `void foo(int const)` are identical. But `void foo(int *)` and `void foo(int const *)` are *not* equivalent. In the interest of good software design, you should *always* be setting sensible interfaces between components in your code, which means setting up your function prototypes to be const-correct. ~~The second reason why this is important is that it affects the code generated under an optimizing compiler. Where performance matters, `const` should be used out of habit.~~ As for `restrict`, it's a tough because it's less commonly used due it being added late to the language (C99). Consequently a lot of popular libraries don't use `restrict` as part of their API, which means that *your* code (which is using these libraries) can run into problems if you try to set up your own interfaces to be restrict-correct. It's also easier to make mistakes with `restrict` than it is with `const`, which can lead to really nasty bugs. That said, `restrict` can be a big deal from a performance standpoint. `restrict` is the keyword which (when used correctly) *finally* allowed C optimizing compilers to overtake Fortran optimizing compilers as being the compilers of choice for insanely performance-sensitive applications (like scientific computing). If performance is very important to you, it's worth using `restrict` because it *so* heavily affects the code generated under an optimizing compiler. Optimizing compilers become absolute wizards with code generation if your pointers are `restrict`
&gt; Although to be honest I'm not sure if restrict affects this at all. It does. If you have a toy function that does this: void add(int *a, int *b, const int *c) { *a += *c; *b += *c; } ...the machine code will do something similar to this: void add(int *a, int *b, const int *c) { register int accumulator = *a; register int add_value = *c; accumulator += add_value; *a = accumulator; // the compiler can't tell that this line of code won't modify *c accumulator = *b; add_value = *c; // *c doesn't change, but we have to reload it. accumulator += add_value; *b = accumulator; } ..because the compiler doesn't know that `a` can't point to `c`. If you instead write: void add(int *restrict a, int *restrict b, const int *restrict c) { *a += *c; *b += *c; } ...the compiler is allowed to do: void add(int *a, int *b, const int *c) { register int accumulator = *a; register int add_value = *c; accumulator += add_value; *a = accumulator; // the compiler knows this line won't change *c accumulator = *b; accumulator += add_value; *b = accumulator; } Which is one line of code shorter and one fewer memory load. In this toy function, it's not a big deal, but in real world examples it can permit use of autovectorization in floating point code which might result in *significant* (roughly four times as fast) speedups.
In small embedded systems const is absolutely essential. Without it, your initialized variables will all be placed in non-volatile memory (usually flash) and copied down to RAM at startup. I had to fix some vendor-provided USB driver code that had USB descriptors declared const, but had a table of pointers to those that wasn't itself declared const, despite that clearly being the intent. That saved dozens of bytes of RAM, which was significant on a device with 4k of RAM. Can't say I've seen restrict used much if at all, but I've spent a lot of time working with 8-bit compilers where C99 is still new territory.
You're not supposed to have to cast the `const` away. If so it sounds like the function actually mutates its arguments after all. Of course you cannot use `const` everywhere but many functions only read from their arguments, and conveying this information through the function signature is very useful. I can be sure that `strlen` won't write arbitrary characters to my string. That the compiler prevents mistakes in the implementation is a bonus.
it's been a minute since I've used a debugger, but const has value over #define that the debugger will/can show you it's value. Sometimes #define is displayed with a value, sometimes not (depending on the debugger). Const seems to be a bit more consistently shown (at least in C++ and in my experience, which may be outdated)
&gt;In small embedded systems const is absolutely essential. Without it, your initialized variables will all be placed in non-volatile memory (usually flash) and copied down to RAM at startup. Can you explain this some more?
 If I recall correctly, const is not used by gcc for more then throwing warnings. Do you have an example where the usage of const affects the assembler?
I think you're right. I can't get `gcc` or `clang` to generate different code no matter what I do with `const`.
Not sure what you want. A quick google search is all you need. And about Visual Studio, Microsoft is focusing on C++, so you will not get all the latest C features (C99+). If you never used visual studio there are tutorials on MSDN on how to create projects.
For magic numbers, use enumerations as enumerations produce debugging symbols and do not have a run time cost as opposed to global variables (even if they are declared `const`, storage is still allocated and the compiler might decide to load the variable instead of inlining it). Otherwise, use `const` and `restrict` where semantically correct.
Note that C is not C++. A tutorial that claims to teach both is most certainly flawed and should not be relied on as a teaching source.
On modern virtual memory systems ("real computers"), you're probably used to a single flat address space that consists mostly of what can be treated as RAM. The operating system fills the virtual address space with chunks of RAM and code and memory-mapped files, making sure that stuff that needs to be in RAM is in RAM and what doesn't need to be there is on disk. Microcontrollers don't have that luxury (unless you get the super fancy ones and pay out the nose for them.) The OS, if there is one, can't alter the memory layout. RAM is RAM and flash is flash. In some microcontrollers, they [aren't even in the same address space](https://en.m.wikipedia.org/wiki/Harvard_architecture); there's a special "read from flash" instruction. So the compiler has to do the job of divvying up the RAM and flash. Now, RAM is scarce on microcontrollers. You've got a handful of kilobytes. That means you want to put variables that aren't written to into flash. But the compiler can't actually make that decision. If a variable isn't declared const, it *has* to be in RAM. Even if it isn't modified within the file, the compiler can't assume it's read-only. What if another file that does modify it gets linked into the program? You'd get some sort of wacky erroneous behavior, depending on the hardware. (As for the "copied down to RAM at startup" bit: the data to initialize variables has to be stored somewhere, and flash is the only real option.) But if a variable is declared const, the compiler can load it from flash directly. This frees up memory for variables that do need to be modified, as well as the stack and the heap.
You're mixing up `int const *` with `int * const`? Your 3 examples should be: int * const // unchangeable pointer to int int const * // changeable pointer to unchangeable int int const * const // unchangeable pointer to unchangeable int `int const` and `const int` are synonyms.
There's a trade-off to both of them, and the ultimate answer is that (like so many other trade-offs in C) the answer will mostly be a question to be resolved by a per-project or per-company style guide. The `const` keyword is trading some extra typing at the keyboard and thinking about how parameters are used in order to gain some extra compile-time safety checking and expressing more information in function signatures. This is usually a pretty good deal; although the bugs it would catch are the sort that would be relatively rare with experienced programmers, they are also the sort that could be pretty difficult to debug, as they can lead to very non-local effects. Additionally, `const` can be used in embedded systems to indicate that variables of static lifetime can be stored in ROM rather than RAM; while this is true, it's one of those implementation-specific behaviors that is not terribly explicit, and I usually prefer to use implementation-specific behaviors that are explicit instead, such as using a pragma to instruct the compiler to put variables in a specific memory region and using linker scripts to ensure that region is mapped to ROM. Using `const` as well, however, can help catch bugs since attempts to write to these variables would fail. I'm not saying that using const to ROM your variables is *wrong*; I just prefer to be explicit about it. Now, the `restrict` keyword is a bit of a different animal. Its purpose is largely to *reduce* checks that the C compiler would otherwise have to make before performing some optimizations. When you use it on pointer parameters, you're telling the compiler that you promise that none of the pointer parameters of the same type are to overlapping allocations. If you violate that promise, the C compiler isn't obligated to tell you about that violation, and is allowed to emit code that won't behave according to specification in the face of the violation. I.e., it's introducing another possibility for undefined behavior in exchange for some additional freedom in performing optimization. So, this also gives more information to the caller about valid parameters, but it introduces an unchecked obligation on the caller rather than a checked obligation on the called function. It thus reduces safety (in a sense, anyway; it's not a huge reduction considering all the other possibilities for undefined behavior in C), but can in principle sometimes increase performance. It's something you should probably think hard about and measure the results of before using.
`sed 's/ +/ /g'` 
&gt; Am I wrong in thinking the C standard allows an implementation to &gt; assume that the variable x will be unchanged by the function foo? Yes. A compiler cannot make the optimization you're expecting. [`const` doesn't mean "constant."](http://yarchive.net/comp/const.html) In this case it means access through that particular pointer is read-only. In different circumstances, other functions and threads may modify memory behind a const pointer. If it's aliased with another variable, the function with the `const` pointer might even modify the value itself. Rule of thumb: Don't expect `const` to be relevant to optimization. It's only there to catch programmer mistakes. Edit (more): With the way you're calling `foo`, it would be legal for that function to cast away the `const` and modify the value anyway. This is because the original object isn't const-qualified and therefore the rules about modifying a const-qualified object don't apply (C99 §6.7.3¶5). This particular rule allows implementations to store const-qualified objects in read-only storage. Edit 2: After some more thought, I tried changing it to `const int x = 0` and gcc finally performs the optimization you're expecting. In this case, if foo were to cast away the `const` and mutate its argument, it's undefined behavior, [so the compiler is free to assume it doesn't happen](http://nullprogram.com/blog/2016/07/25/). However, gcc still allocates `x` on the stack even though the specification permits a compiler to put it in `.rodata` or `.bss`. 
Is there a specific reason why are you against the old school approach? #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ROWS 32 #define COLUMNS 16 int main(int argc, char** argv) { int* array = malloc(ROWS * COLUMNS * sizeof(int)); int i = 0; for(int x = 0; x &lt; ROWS; ++x) { for(int y = 0; y &lt; COLUMNS; ++y) { array[x * COLUMNS + y] = y; i++; } } for(int x = 0; x &lt; ROWS; ++x) { printf("%d:\t", x); for(int y = 0; y &lt; COLUMNS; ++y) { printf("%d\t", array[x * COLUMNS + y]); } printf("\n"); fflush(stdout); } free(array); exit(EXIT_SUCCESS); } I mean, you COULD do it with pointer arithmetic. You can even use them interchangeably. Here's the same, but pointer arithmetic in first loop: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ROWS 32 #define COLUMNS 16 int main(int argc, char** argv) { int* array = malloc(ROWS * COLUMNS * sizeof(int)); int i = 0; for(int x = 0; x &lt; ROWS; ++x) { for(int y = 0; y &lt; COLUMNS; ++y) { *(array + (x * COLUMNS + y)) = y; i++; } } for(int x = 0; x &lt; ROWS; ++x) { printf("%d:\t", x); for(int y = 0; y &lt; COLUMNS; ++y) { printf("%d\t", array[x * COLUMNS + y]); } printf("\n"); fflush(stdout); } free(array); exit(EXIT_SUCCESS); } It shouldn't matter when compiler gets to it, but this way it's more prone to bugs. I don't code for a living anymore (for quite some time now), but I've used these types of linear arrays for image processing in VFX a lot. There were always bugs like forgetting to rewind a pointer if using ++ and stuff like that. Nothing wrong with it, I even prefer that approach since it's simple and efficient, but you have to be extra careful. But then again, I do not code for a living anymore, so there are certainly smarter responses than this one.
&gt;Exactly right. For global variables that are initialized to zero, the startup code (called before main()) will have a list of addresses, provided by the linker, to simply fill with zeros. That way they don't take up extra space in flash. This sort of confused me. The global variables initialized to zero (i.e. .bss) still need to be stored somewhere... what do you mean by "extra space"? That only one copies exists and it's in the flash?
Who doesn't want to write websites in C? :P
This is straight out of C&amp;R. Exercise 1-9 p. 20. C'mon. Points to you for using Cunningham's law with your homework.
A global initialized to zero gets space in .bss of course, but it doesn't also get a copy in .data like if it was initialized with a value. In the ARM startup routine I'm looking at, there's a function called zero_fill_bss() that clears everything from __START_BSS to __END_BSS. On the other hand, if you set 'int foo=123', foo gets space in .bss but the value 123 gets copied into .data and (in the implementation I'm looking at) .romp is created by the linker and contains a list of address ranges to copy from ROM to RAM. The __copy_romsections_to_ram() function goes through that list and copies everything down. My point is that zero-initialized globals don't take up any non-volatile storage. Initialized ones do. In fact, I once had enough global data initialized that way that the system watchdog timer would force a reset before the copy-down could finish. This was mostly because the watchdog was running from an independent clock and the CPU started up in a slow mode. Having it set up the CPU clock before the rest of the startup fixed the problem.
There seems to be a misconception around ... I wouldn't say "common" but I have seen it, that if you write: int x = 5; const int *p = &amp;x; then `*p` always evaluates to `5` for the rest of the block. (In fact it doesn't, it evaluates to whatever the value of `x` is as the time of evaluation). Also, I think `void f(const int * restrict p)` does allow the optimizer to assume that `*p` will not be modified by `f`, although I'd want to double-check that against the formal definition of restrict. 
The third one has the pointer itself being const. As a general rule the const qualifier binds to its left, even in the case of multiple pointers (`int * const * foo` being different from `int ** const foo`, with the top most pointer being the asterisk on the right).
nr1 thing that I don't like about C.
This was changed, now `main` (and `main` only) implicitly returns zero when the end is reached without a `return` statement inbetween.
No, there's one: &gt; Write `s/ */ /g` instead. 
~~Oh yeah, I slipped up there.~~ Note that in the line above (where I invoke `ed`, which uses mostly the same syntax as `sed`) it is correct, as I intended. **Edit** I didn't even slip up: The comment's source code clearly shows two spaces, it's just that reddit ate the second space while rendering it. I have no idea how to make this work correctly though. Maybe like this? `s/&amp;#x20;&amp;#x20;*/ /g`?
So you're essentially integration testing from a given point all the way down to the last turtle? Integration testing is fine and dandy, but actually unit testing modules with faked/mocked dependencies is what gives you tight feedback loops during development. You should be able to take your target module, link in your fakes/mocks one abstraction level down and run the tests on it.
Yikes! https://github.com/reddit/reddit/issues ?
What have you already done? Where are you stuck? Please show us your code.
That's definitely not how this works. You will learn nothing from seeing someone else's code without trying it yourself.
What do you expect the user to type if they think the Earth is/isn't round? Because right now you're looking for them to type in a number, and then comparing that number to 0 (the value of the variable `yes`). Because of the way the `scanf()` function works, if you type a word (like "yes" or "no"), then the value of `answer` will be 0 Can you show us what the current input and output are doing, and what you'd like it to do instead?
I think you're misunderstanding what scanf does. Right now, you're trying to scan in a signed number and store it in answer (that's what the "%i" format code is, a signed integer). So when you enter something into the console it needs to be a number, for example "1234" or "0900" or "0x1234". "yes" is not a number, scanf can't resolve "yes" into a number". I'm not sure how scanf deals with arguments that don't match the format code, but I'm assuming that it doesn't modify it. Since answer is initialized to zero, as is yes, the "Yes, the earth is round" string will always be printed. Try typing "0" and "1" into the console (minus the quotation marks, of course) and seeing what is printed.
Thanks! I didn't know it only scans numbers. What could I use to scan words? I tried with getchar but I don't know how to make it work.
You can still use `scanf()`, but you need to tell it you want a string. the `"%i"` that you have there now tells it to look for a number. Have a look at some of the other options [here](https://en.wikipedia.org/wiki/Scanf_format_string#Format_string_specifications) to see if you think they could help.
I don't think you said anything wrong. I'll try to answer your questions I can identify as questions. &gt;How are people going to know I am apply this to identifier f, like this int (*) f(), or like this int (*f) ()? I don't think the ~~second~~ first parses as a declarator according to the grammar. &gt; Last, how do people actually read C standard. Well, it's pretty difficult to do so. Especially the more modern ones. It's best to read the beginnings before the middles, since you have to get a basic understanding of C's memory and computation model before going in the details. 
I don't think cache contention is a problem: Each thread only ever updates one part of the array and that from front to back. Though, each thread does random reads all over the place. I don't care if these reads return old or new data though, coherency is not important as long as all updates eventually end up in the array when one iteration is finished. That's also why I try to avoid atomics, as the compiler emits barriers when writing to those.
Well, yeah, they kinda do. It's a read/write race, not a write/write race and it doesn't matter for what the program does as I don't care if I get the old or the new value.
`int (*f)();` is correct, any other placement of `f` is an error. 
Sorry, I meant first.
Edit: It's apparent that it's been too long since I've used C daily and so had forgotten this aspect of arrays. See /u/FUZxxl's answer.
Not true.
So, arrays are a bit strange. If you take the address of an array, you get a pointer to the beginning of the array, which of course compares equal to a pointer to the first element of the array. Thus, if `a` is an array, `&amp;a == a` as an array is usually implicitly converted to a pointer to its first element (one notable exception being if you take the address of an array) and there is no difference between your two examples except that the compiler is likely going to warn about an implicit cast in `int *x = &amp;a` as `&amp;a` has type `int (*)[8]` (pointer to an array of eight integers), not `int*`. As a rule of thumb, you never want to take the address of an array. If you want to make explicit that you are taking an address, write something like `&amp;a[0]` which is clearly the address of the first element of `a`.
This isn't right. See /u/FUZxxl's answer below. 
If you want easier then strings, you can always ask them to put Y/N. ans check for a character instead of a string In your If statement, you can assign the earth is round to true if the user types in Y or y. anything else would be the earth is not round I'm not sure if you learned how to use "or" yet but if not then just specifiy them to type the answer Y/N in capitals. You want to baby the user into giving the answer the computer is expecting.
please check "while (i = 5)" this line. i don't think this is so perfect.
The value of PR1 and PR2 do not change so I set it to print at the end of the loop. How could I improve it?
Got it. Thanks!!
C89 is in the back of K&amp;R, basically. I've looked up things in it.
I thought I set i=0 in the for loop? How is it i=5? That could be why it's not working. 
scanf isn't populating answer when the input is not a number. You can check how many arguments it filled using scanf's return value: while (! scanf(...)) printf("My useful feedback\n"); 
 **Expert C Programming: Deep C Secrets** |||| --:|:--|:-- Current|$35.19|Amazon (New) High|$40.53|Amazon (New) Low|$27.78|Amazon (New) |Average|$33.55|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/FrcbCrj.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
I've been writing embedded C for so long that I can't remember the last time I had a return from main()...
Well, malloc returns a pointer only, never an entire array
What a fantastic program! However, I feel that the Caesar Cipher Algorithm is too easy to Decrypt!! Don't you think so? 
Well, you're partly correct! If you apply a difficult encryption algorithm in the program, it would be difficult for anyone to crack it.
&gt; An array is fundamentally a pointer to its first element, and this uses some pointer arithmetic. Please, don't spread this rumor.Arrays decaying into pointer automatically does not make them the same, especially not fundamentally. There is far more attached to an array than just it's pointer to the first element. (scope, size, potentially initialization, potentially read-only)
I think he is entirely correct, not partly. Yes you are correct in saying that it would be difficult for someone to crack if a different algorithm was used... but the cipher is the core of your program. Nonetheless, you have stated in your article that it shouldn't be used in security systems.
That const does not mean constant.
Don't use that title for questions. Usually, you should try to do your homework/task alone, and ask questions for specific problems, like "Why this book list raise segmentation fault when I try to add a new book?". More [here](http://www.catb.org/esr/faqs/smart-questions.html). You need to create two simple *linked lists*. Reading this [page](http://www.cprogramming.com/tutorial/c/lesson15.html) should be enough to go through your assignment.
There's a few different ways to branch using conditionals (if) but the 3 basic things to remember are: 1) if (THIS) { then that } 2) else if (THIS) { then that } 3) else { that } In your example you posed an "else if" by providing a condition but used the keyword else which is the catch-all for any condition that hasn't been matched yet.
You can't have (and don't need) a condition after an `else` statement in an `if`...`else` clause. By definition, the `else` codepath will be executed if none of the conditions in the preceding `if (...)` (and possibly `else if (...)`) statements are met. To be more explicit, it should look like: if (...) { ... } else { ... } Note the lack of a conditional after the `else`. One more note of caution: be careful with your `else` statements! That codepath will be executed *whenever* the conditional in the `if` isn't met. Consider all edge cases (hint: what should happen when thorY == lightY?)
Too bad playing video games is more fun than doing homework. You definitely want to use pointers to solve your problem- that's the easier way.
Thank's that fixed it! I should of known that haha. However my character still does not move. I think the reason is that game is getting 0E as movement. Thor only has to move on the X axis and hence the game does not add or remove a Y value so it makes directiony = 0 I took a peak at the solution and what they do is use pointers, however I have not really gotten as far as pointers yet. Is there a way to solve this without pointers? Game information: Expected a movement (one of N, NE, E, SE, S, SW, W, NW) but found '\0E' Thor position = (5,4). Light position = (31,4). Energy = 100 
I think I just ran into an edge case. (first day trying to program with C lol) thory==lightY so my code outputs /0E as the direction of where thor should move instead of simply /E. So after all that he still does not move :S. I put it in eddit
You never initialize `directionX` or `directionY`, so they'll default to whatever garbage is on the stack if they're used before they're assigned (in your case, this "garbage" appears to be zero). When `thorY==lightY`, none of your `if` expressions match, so `directionY` remains unassigned and that garbage gets printed. What you should do is either convert one of your expressions to match equality: if (thorY &lt;= lightY) { } else (thorY &gt; lightY) { } or add an explicit `else` for this condition: if (thorY &lt; lightY) { } else (thorY &gt; lightY) { } else { } What you actually do will depend upon your desired functionality.
If you're just starting out with C, I wouldn't worry too much about the pointers yet, since you'll likely dive into pointers and strings later. However, here's a quick explanation. Your code is using the character type `char` to assign a single character to your variables `directionX` and `directionY`. You've correctly set up your `printf()` call to print these single characters. What you're doing is very, very similar to assigning an integer variable. This: char directionX = 'W'; is a more readable way of saying this (0x57 is the ASCII code for 'W'): char directionX = 0x57; The pointer code is using entire strings instead of individual characters. Note that their `printf()` call uses "%s" instead of "%c", which tells `printf()` to print a string. When they declare and initialize `directionX` with: char *directionX = ""; They're saying, "create a char pointer named `directionX` and point it to an empty string". The compiler creates an empty string that's 1-byte long and contains nothing but a null terminator character '\0'. It then points `directionX` to the address of this string. Later, when the string is reassigned via this: directionX = "W"; They're saying, "re-point the char pointer named `directionX` to a string containing the character 'W'". The compiler creates a string that's two bytes long and contains the character 'W' followed by a null terminator character '\0'. It then points `directionX` to the address of this string. Using this method, if directionX points to a string with a character in it, `printf()` will print that character. If directionX points to the original empty string, `printf()` will print nothing because it doesn't print the null terminator. This allows them to achieve outputs like "N", "S", "E", "W", as well as "NE", "NW", etc... Using strings would be very useful if you ever needed to print more than a single character; for example, if you wanted to print the string "North" instead of "N". But your method of using single characters is also valid. EXCEPT, you currently have no way to print an "empty" character. When you use `printf()` with the "%c" formatter, it will render a null character as "\0" as you've seen (it will render any non-printable character similarly). You have a couple of options for fixing this. For starters, you could initialize your directions to a space: char directionX = ' '; char directionY = ' '; Then, your `printf()` will print a space if the direction is unassigned in your conditional logic. However, this does have the downside that your output will include spaces ("N ", " E", etc.). If that's not acceptable, you can initialize your directions to something like '\0' and then add conditional logic around your `printf()` to exclude any unassigned direction: char directionX = ' '; char directionY = ' '; . . . if (directionY != '\0') { printf("%c", directionY); } if (directionX != '\0') { printf("%c", directionX); } printf("\n"); Or you could move to the strings approach. Edit: formatting
Thanks for the detailed reply! this is what I was looking for!
Functions can't return arrays, but they can return a union containing an array. C will copy the array values, and the expression `&amp;a == a` will be true in some compilers. typedef union { int a[10] } a; a f(void) { a d = {1,2,3,4,5,6,7,8,9,10}; return d; } main() { a d = f(); printf("%p v. %p\n", &amp;d.a, d.a); printf("%p v. %p\n", &amp;d, d); }
You need to compile your program using a compiler. Setting up a compiler can be a bit annoying depending on your environment (Windows? Linux? Mac OSX?). If you want to just start trying code right away I would play around with an online compiler: - https://ideone.com/ - http://cpp.sh/
This may be relevant to your interests. http://c-faq.com/decl/spiral.anderson.html
Note that your code exhibits undefined behaviour as `d` does not have the type `void*` as expected by the `%p` formatting specifier. I'm not sure what this code is supposed to do.
Very good point.
Unlike interpreted languages like Python, C gets compiled to asm and eventually some gibberish that only your OS understand. During this compilation process, that's when it checks for syntactic correctness. They call errors during this process "compile-time errors", as opposed to "run-time errors" for errors when you run your program. How you use the compiler really depends on what OS you are on, and what OS you are targetting it for.
What operating system are you using? Are you on Windows, Linux, or macOS? 
we should have a weekly thread in which people try to come up with a sort of valid reason to use `char * const (*(* const bar)[5])(int )`
As the other replies have mentioned, you are going to need a compiler. If you're on Windows, Microsoft's C compiler is absolutely horrible, especially if you're new to C. Install Cygwin and start teaching yourself POSIX, and use GCC. If you're on macOS, you should have Clang installed with Xcode. You can just invoke it from the Terminal with `clang`. If you're on another operating system such as GNU/Linux, you should use any package manager that your operating system provides. If you use APT (Ubuntu, Debian, Trisquel), you should be able to install GCC with `apt install gcc`.
Off-topic tip: usually, it is better to use `int main(void)` rather than `int main()` to comply with the C standards. Also, C99 introduced the implicit return type for `main()`, which means that `main()` will return `0` by default once it has finished. Therefore, you can safely remove the `return 0;` at the very end of your code, assuming that you are using a C99-compliant environment.
Does Ubuntu not have GCC preinstalled?
Or use "sudo apt-get install build-essential" on ubuntu to get required packages for C/C++ dev (gcc, make, etc)
the time is null and it says printf is not safe cant run it
Why do you say MSVC is horrible? I typically see significant better performance (with and without optimisations, up to 60% sometimes) over GCC, usage is more or less the same as GCC and it is, in some sense, the native compiler for Windows.
C needs to be [compiled](https://en.wikipedia.org/wiki/Compiled_language). This is a different requirement to python, an [interpreted](https://en.wikipedia.org/wiki/Interpreted_language) language. If you are using linux there will be a package containing the GCC and other tools for you. Debian for example has 'build-essential'. If you are using Windows you can install Code::Blocks to get an environment up and running quickly. The download page [here](http://codeblocks.org/downloads/26) provides mingw-setup.exe which will have GCC in it. This is assuming you are new to C and have some exercises you want to get on with. Code::Blocks is pretty painless to install and get you typing in some code. Good luck! 
Apart from what people already said about having to compile the code, it is good practice to also enable compile *warnings* as opposed to only errors. This makes the compiler warn you about code that *might* cause issues. For instance, using `-Wconversion` warns about implicit conversions that might modify a value: int foo = 10; // Lots of code, at some point foo becomes zero size_t bar = foo - 1; printf("%zu\n", bar); `bar` is unsigned, it cannot hold the value `-1`. In my computer `4294967295` is printed instead of `-1`, which one might expect. But the compiler does not warn me about that, and if I don't print the value at some point, I might spend a lot of time debugging this. It only warns me if I use `-Wconversion`. Since you're starting, it would be good to enable various warnings right away so it becomes a habit. I usually start every project with a a default (large) amount of warning flags and remove them as I go if I don't need them (for instance, `-Wfloat-equal` only makes sense in some contexts). To enable all baisc warnings on gcc, use `gcc -Wall myapp.c`. There are a lot more warnings that are not enabled on `-Wall` (`-Wconversion` is not even enabled by `-Wextra`, for instance). For warning flags and more, read the manual page for your compiler (`man gcc`).
It's horrible as a C compiler. The last I checked it only fully supports up to the C89 standard. Microsoft only recently started adding non-library C99 features.
Best answer 
Nothing wrong with reading a char for its numerical value. As long as your final for loop prints out what you were expecting, what's the problem?
/u/theboxingfox is right, if it works good for you. If you have a problem ask about it. `atoi` would not be able to handle a string that long. But would perform `- 48` on any valid digit to convert character to int. Normally atoi would the current result by 10 until reaching something that isn't a digit, which is why it can't handle your large number. `sscanf` would effectively call `atoi` if you gave it the `%d` modifier. `sprintf` writes to a `char buf[SOME_SIZE]` instead of the console window. `fprintf` writes to a file handle (`stdout` is a file handle for the console, `fopen` creates a file handle to a "normal" file) FYI low level C doesn't care if you write 48 ,'0' , or 0x30. Whatever you find easiest to remember digits[i] = str[i] - '0'; /* My lazy way of not needing to remember ASCII values */
The output of the program is the index of the value x in the array arr. The return value of 4 means that v[4] = 9 which is the correct conclusion. Remember that indices start at 0. 
lol true!! thank you..
Yes, doing `someInt = someNumChar - '0'` is the most portable way to do this and works under most locales. I say most because I've only used a handful + one of the unicode locales and it worked fine for them. Can't say the same about locales I haven't tried!
Is `n` (the third parameter) supposed to be the number of elements in the array? You are passing 10 but there are 11 elements in `v`. You can replace the "magic number" 10 with something like `sizeof v / sizeof v[0]`. Also, I think the program will fail to return a correct index in certain cases. Consider a simple case where `v` has only one element, 9. Then, you will have `low = 0` and `high = 0` in the `binsearch` function. The loop will not be taken even once and you will return -1, instead of 0.
I verified it and yes, that's pretty much all there's to it.
Thanks! That definitely helps on setting it up. Now I'm able to find out which numbers are odd/even but would you know how I could print how many are odd/even?
If your professor doesn't care about efficiency, simply loop through the array and use a counter and an if/else statement to increment the counter. 
Okay I'll try and figure out how to do that, thanks for the help!
No worries. My hint would be to look up the '%' operand. 
When I, instead of 10, put sizeof v / sizeof v[0] nothing prints out. And actually return -1 instead of 0. What would you do to go around this problem?
I'm curious; what would be the efficient way? I can only think of adding `i % 2` to the counter (thus avoiding the `if`).
That's because there are some issues with your code. One is that you never change `mid` in the loop. Another is that your boundary conditions are not correct. One way to fix that would be to move `int mid = ...` line inside the `while` loop, change `high = n - 1` to `high = n`, and `high=mid-1` to `high=mid` (untested).
Linked lists ... typedef struct _book { bool status; char title[MAX]; char author[MAX]; char subject[MAX]; int uid; struct _book *next; } book; ... You can save them realy easily directly with write(f_handle, p_book, sizeof(book)) in a loop geting over like for (temp = books; temp-&gt;next != NULL; temp = temp-&gt;next), don't forget to init them with NULL in book-&gt;next ;) or you get in some trouble.
It's good to be on top.
You're lacking a `return` in many of your `else if` clauses; either add one to each of them, or add a general `return` at the end of the function. Edit: that error appears when you have a function that should return something (i.e., it's not `void`) but you have a path in your code that may lead to reaching the end of the function without getting to a `return` clause.
We need a revival of Pizza Or Not http://pizzaornot.tumblr.com/
I know it's not popular these days, but IMO there should be a single return statement, and it, of course, should be the last statement in the function.
Yes and no. It's good to have a marketable skill that's on top. It is also good to take on a skill that will be marketable in a year or three's time. I know it's irritatingly hipsterish to say "I learnt Ruby before it was cool", but it means I had a marketable skill before I had floods of competitors. So yes I wrangle C (and Ruby) and a bunch of others.... But I'm picking up D because I'm betting (like I bet on Ruby) that it will be up there in a few years.
This is a subreddit about C programming. Submissions on C++ are off topic here, please post these to /r/cpp or /r/cplusplus. I removed your post because it is off topic.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* run this program using the console pauser or add your own getch, system("pause") or input loop */ struct students{ char name[10]; char surname[10]; int no_id; }; int main(int argc, char *argv[]) { struct students *student = (struct students *)malloc(sizeof(struct students) * 2); struct students ogr1; struct students ogr2; struct students ogr3; printf("%p", student); printf(" %p", student+1); printf(" %p", student+2); /* ogr1 information*/ strcpy(ogr1.name, "jane"); strcpy(ogr1.surname, "neon"); ogr1.no_id=2356; /* ogr2 information */ strcpy(ogr2.name, "jack"); strcpy(ogr2.surname, "cany"); ogr2.no_id=2456; /* ogr3 bilgiler informaation */ strcpy(ogr3.name, "martin"); strcpy(ogr3.surname, "kuun"); ogr3.no_id=2152356; return 0; 
how can i do it
You are not being specific enough. What _exactly_ are you trying to accomplish? struct students *student = (struct students *)malloc(sizeof(struct students) * 2); That line does not allocate enough memory for 3 `struct students`.
actually, I just noticed it already got four upvotes! Let's do this. Look at the original article please (I am its author) and let me know what to add or change to make it extremely clear that most people code Arduino in a straight C style. (I mean I would modify the blog post, though it's a forum not really a blog.) the other thing is that many, many C programmers are highly interested in embedding computers or getting into them. so, for anyone who has never so far programmed an embedded computer, they can begin to do so immediately, using no C++. it's a 35 second tutorial on a new career option where they can program in C. and as you iknow, programming microcontrollers in C goes very, very deep. let me know!
The point is, C++ is not C. Yes, people may program in C++ in a style that looks very much like C, but the language still remains C++. Confusing the two is dangerous as there are subtle differences that are a constant source of confusion and strange questions from people who are unaware of them. For this reason, I have a strict policy of not admitting posts about C++ to this subreddit, unless the post is also about C (but then it's usually not a good one as these tend to gloss over the differences). Perhaps you might find a more welcoming audience in /r/cpp or /r/cplusplus.
I've emphasized the difference. You will admit that embedded programmers are C programmers - not C++ programmers. They do not use classes or other C++ constructs. They are not built like C++ programs. **One question is that you say that "there are subtle differences"? Could you provide a link to a reference?** I thought that C is a strict subset of C++ and all complying C++ compilers will compile C?
&gt; I thought that C is a strict subset of C++ and all complying C++ compilers will compile C? You are sadly mistaken. See [here](http://stackoverflow.com/a/31505447/417501) for a list of examples.
Within `main()`, the address of the first `struct student` is `student` (equivalently but more explicitly, `&amp;student[0]`). The third `struct student` does not exist and therefore does not have an address.
What I want to know is, who teaches these kids to use system("pause")? This isn't the first time I've seen it on here.
Hey! First, you made the right choice! Welcome to the world of C programming, the best language in the world. I'm 200% objective. Trust me... I'm... Someone? Anyway, Python is an interpreted language, that is it is translated on the fly into something executable from your machine. C, however, is compiled. That means you first need to turn your source code into an executable file before running it. Setting up such a program (called a compiler) is a nightmare on Windows, but Linux and MacOS come with one preinstalled (look up GCC on the Internet)
Depending on the warning level/strictness of your compiler, `int *x = &amp;a` is a type error, because a pointer to an int (`int*`) and a pointer to an array of 8 ints (`int(*)[8]`) are incompatible types. Let me illustrate with a [screenshot](http://i.stack.imgur.com/ADB2E.png). Note how `p` points to `a[0]`, whereas `q` points to `a`. The distinction becomes more apparent if you add 1 to those pointers: `p1` points to the next `int`, whereas `q1` points to the next (in this case non-existent) `A`.
Provide a constant that you can use to shift the value into place: #define BIT_FIELD_OFFSET 8 and then do register = 0x15 &lt;&lt; BIT_FIELD_OFFSET to set the register.
I know it is, and that's what's making me angry about this. getchar() exists in the standard, use it. And even it is assumed that everyone uses Windows, either start your program from a command prompt, where the output does not vanish, or run it from Visual C++, where it doesn't close the console window until you press a key (Ctrl-F5 behaves different from F5 in that way).
That's exactly what I'm doing at the moment. The problem is, it does not satisfy my condition, that it would be independent of changing bit fields, i.e. if I change the bit field, I also need to change the offset manually. Is there any way to extract the offset automatically?
~~Your program is crashing from the sort function~~. This probably isn't causing your problem, but by accessing values[i+1], you are trying to read and assign values[10] on the last iteration of the for loop. Since your array only has 10 elements, it crashes. Your for loop line should look like this: for (int i =0; i&lt;n-1; i++) Side note: Printf prints to stdout on the console which is buffered, so if your program crashes, it will just not print the rest, and delete the buffer. stderr is not buffered, so it will always print, even if you crash. Edit: Accessing out of bounds on an array wont always cause a crash, but it will give you nasty behavior. 
It depends. Sometimes it will only output on new lines (`\n`, linebuffering) or it will directly output it. Try to append an `\n` into your string in `printf`. Or you can flush the output buffer: `fflush(stdout)`. If your application exits, then the output is flushed, thus you see it. But if you are in an infinite loop, then it is still in buffer and won't be displayed in the terminal.
That's actually the opposite of what I want to do. Since I have the bit fields supplied by the manufacturer in a header file, I would like to use only the names of the bit fields while coding and avoiding hard codded stuff, like the `BIT_FIELD_OFFSET` in your example.
It's a funny list. Arduino and Visual Basic are both ranked higher than SQL. SQL is one of the most pervasive languages out there and people are steadily hired for their SQL skills. I agree that it doesn't have much traction on the github criteria, but it's not a language that lends itself to open source projects. Likewise, R is listed higher than C#. I get the trending aspect, but its ceiling is not as high as C# because it's not general purpose at all. I guess I just don't like the IEEE spectrum bucket. The criteria are too different to combine.
It's just much harder to refactor a function with gotos and multiple returns. As a result, over time, it gets bigger and bigger and ever more convoluted. Net result is high maintenance costs.
It started from this http://www.davidmihm.com/blog/google/world/
This solution doesn't really improve my current method (the one you posted first) by that much. I was afraid it's not doable. Thanks for your comments.
Buffering. When you print to `stdout`, `libc` often won't print immediately. It will put the data you want to print aside, and wait until it has gathered a larger amount of data to print, and will print it all at once in a later call. (this is called "flushing" a buffer) But if the buffer flush is never triggered, (perhaps because the program is killed without being allowed to clean up, for instance, if there's an infinite loop...) the buffer will never be flushed. This is a potentially significant performance enhancement. There are a few strategies to work around this. * It looks like you're using print statements to debug; try to avoid doing this. Use the debugger instead. * You can disable buffering on `stdout` by doing `setvbuf(stdout, NULL, _IONBF, 0);` From then on, writes to the console will happen immediately rather than gathered up and printed all at once. * Print to `stderr` instead of `stdout` by doing `fprintf(stderr,"finish getting");` `stderr` is unbuffered, specifically because buffering often mucks up debugging. (as you've noticed) * `stdout` is often line buffered; that is, it will flush the buffer every time it gets a complete line of text. So if you do `printf("finish getting\n");` it might flush the buffer immediately. This is not necessarily portable though; some other `libc`s might behave differently. * Use a lower level I/O function, such as `write()` on linux. (not sure what the equivalent would be in Windows) You almost certainly don't want to do this, but you should be aware that it's an option.
You have to go `i % 2 == 0`. Leaving out the `== 0` quite literally reverses the meaning. Also, you initialise `i_even` and `i_odd` to `argv[2]` for some reason. They should be set to 0, since they are the amount, and you always start with nothing.
In `fonk`'s `printf` calls you need to reference a particular instance of `struct as`. One of: `abc`, `target`, `source`, or `ogrt`
If you can rely on the bit field always being 8 bits (and always being aligned with the natural byte boundaries of the uint_32 - i.e. not something like 0x00000FF0 or 0x00007F8) then there is a way. Copy the 1 byte value you want to set into the bitfield, into all the bytes (i.e. turn 0x00001500 into 0x15151515) and then combine it with BIT_FIELD to get them set in the right position. Then use the compliment of the BIT_FIELD to clear the bits in the destination. Finally, "or" them together. Something like: register = (BIT_FIELD &amp; 0x15151515) | (register &amp; ~BIT_FIELD) As for how to turn 0x00001500 into 0x15151515, you'd need to do something like: value | (value &lt;&lt; 8) | (value &lt;&lt; 16) | (value &lt;&lt; 24) | (value &gt;&gt; 8) | (value &gt;&gt; 16) | (value &gt;&gt; 24) You can do it with two fewer shifts by breaking it up into a series of assignments (whether this actually results in more efficient code is anyone's guess): uint32_t value1 = value | value &lt;&lt; 8; value1 |= value1 &lt;&lt; 16; uint32_t value2 = value | value &gt;&gt; 8 value2 |= value2 &gt;&gt; 16; use: (value1 | value 2)
It means constant. You should just remember context. There are several qualifiers which behave differently depending on type of objects they are applied to. When you write const int* you are just declaring pointer without permission to modify data. While data itself can be changed and even pointer can be reapplied to point to different data. So there is nothing surprising in behavior of compiler.
Yes, `virConnectPtr` is a type. It's documented [here](https://libvirt.org/html/libvirt-libvirt-host.html#virConnectPtr) and defined as typedef connectPtr *virConnectPtr; I got to that documentation by clicking on `virConnectOpen` and then `virConnectPtr`.
Thanks so much. Hey I see it's directly listed under Functions but not Types. Is it a function and not a type? Is this at all comparable to a Java Class/Object-Instance?
[I can't seem to reproduce the error](https://godbolt.org/g/RDQ8jv), both versions are compiling. Which compiler are you using?
Well that makes it clearer. You have 25 int **f, *n, *mu; 541 double *x_ = NULL, *f_; 623 f = malloc(sizeof(double *)*Q); 624 f_ = malloc(sizeof(double)*Q*P); 625 for(q = 0; q &lt; Q; q++) { 626 f[q] = f_+q*P; 
OH FOR STUPID I HAD THEM SET TO INTS FOR TESTING PURPOSES AND I COMPLETELY FORGOT TO CHANGE THEM BACK HURR DURR DURR
That's my point... The passed int does not stay constant. And const_cast is a C++ thing. In C it's called cast. Not sure if you answered my question.
typedef is a keyword to introduce a new name for another type. Yes, it's a typedef.
It is not pointer to const int. It is pointer of type "const int". Type of pointer in no way qualifies object itself. It is two separate entities. *pointers to const int* const int x=1; int* p1 = &amp;x; const int* p2 = &amp;x; *pointers of type "const int"* int x=1; const int y = 2; const int* p1 = &amp;x; const int* p2 = &amp;y; If you want to ensure that objects are unchangeable then create const **objects** not pointers. Pointers are just glorified "ints" storing addresses.
`int nDigits[]={10};` This makes an array of int of length 1, containing the number 10. So the rest of the 9 numbers you're reading is just random other data in memory. You want to write: `int nDigits[10];`
Please consider updating your [previous post](https://www.reddit.com/r/C_Programming/comments/4v1up2/subscripted_value_is_not_an_array_pointer_or/) instead of making a new post for follow-up questions.
Thanks!!
Clang C returns 0. from C reference &gt;Objects declared with const-qualified types may be placed in read-only memory by the compiler. &gt;... &gt;Any attempt to modify an object whose type is const-qualified results in undefined behavior. const int n = 1; // object of const-qualified type int* p = (int*)&amp;n; *p = 2; // undefined behavior C99 standard &gt;If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined. If your compiler doesn't enforce *const* and you adhere to use of constructions clearly declared as "undefined behavior" it is your problem. 
What error do you get? Also, format your code with four spaces before every line; using back quotes (?) only works for inline code, `like this`.
Phew I sorted that out, give me a moment I'll pull out the compiler errors.
I just tried with your edit and it compiles fine (with c99)
I've fixed everything please take a look now. Thanks in advance!
Since a prime number is only divisible by one or itself, the second loop is to check whether the remainder is zero when dividing the number by all the numbers between 2 and itself. 
Also, why would the return type be int in this case? I'm a beginner and I don't yet understand the whole void and int thing for the main function.
Is there a command I can use on their terminal to check my version?
Because the c standard requires it to be int. In fact gcc should warn you about using a "wrong" return type if you compile your code with warnings enabled (the `-Wall` flag) 
`gcc --version`
I'm fairly new to C, but shouldn't main be written as int main(void) not void main(void) ?
Oh crap that was it!! Thank you so much, it actually had to be equal to, a silly error on my part that I somehow failed to see. Thanks a lot!
Than the `gcc` command on you system doesn't refer to the GNU C Compiler, but to a different (hopefully C) compiler. (Or there is a typo somewhere)
Well my initial problem is solved not and the code runs fine so the compiler should be fine. Though of possible I'd like to fine out what I'm using.
You'll probably get a warning for it, but in reality `int main() { return 0; }`, `main() { return 0; }` and `void main() {}` all work the same.
Go? Swift? Swift has two or three web frameworks now and is shaping up to be a general-purpose successor to Objective-C, with no ties to iOS or OS X. Instead of a GC it has Automatic Reference Counting, and it can easily call down into C libs like everything else (and C can inline assembler, so the language stack will never pose a fundamental performance or resource problem). Although Python is popular, I don't blame anyone for staying away from it. The Python2 to Python3 transition has been a disaster and will continue to be one for the foreseeable future. Perhaps one of the functional languages other than Erlang? 
Though I have no love for Apple, Swift looks interesting, will take a look. Thanks for the recommendations!
Everyone's probably going to say Arduino, but if you're already a C programmer I'd say skip it and learn in a proper development environment. There are a couple of O'Reily books that I've heard good things about. 'Making Embedded Systems' by Elicia White, for starters. She does the embedded.fm podcast, too. (You can find an interview with me on there from about a year ago.) I got my start on a Heathkit 6800 trainer, but my son says they're using the LC-3 simulator for that kind of low-level training now. It's definitely worth spending the time to learn assembly language on a simple 8-bit architecture so you have a solid foundation to build your C knowledge on. I'm not sure what forums would be best. I honestly try to stay away from the ones frequented by beginners unless I'm there to answer questions because the signal to noise ratio is too high. Edit: I'd probably choose a platform before looking for a forum, or at least look at the platform-specific forums while you're making your platform choice. General embedded forums might not be as focused as you want when you're trying to get up and running. I hang out in Freescale/NXP's forums and it's a mix of beginners and pros, but in most of the forums the traffic volume is not high.
&gt; It almost looks like they put the semicolon in the macro by mistake and then just took out semicolons elsewhere until it compiled. I had not thought of this explanation but now that you say it... :-) &gt; The mixed use of signed and unsigned longs when bitwise shifts are being used makes me very nervous. It looks like only the unsigned are being shifted (`y`, `z` and `sum`), so there should be no problem in that respect. &gt; As far as I can tell, long m isn't used at all. There is an 'm' in the text description. Perhaps it was used in the previous version of the routine that this version corrects/improves. For the explanation of the algorithm, perhaps it was provided in a text or math form along the previous version too? That would somehow justify the short variable names, the arbitrary constants, and the gibberish macro. 
&gt;For the explanation of the algorithm, perhaps it was provided in a text or math form along the previous version too? The [first](http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=C08E8409ADF484095568965A1EBF3E5E?doi=10.1.1.45.281&amp;rep=rep1&amp;type=pdf) version is a lot more readable. The [second](http://www.cix.co.uk/~klockstone/xtea.pdf) was starting to get bad. It does explain some things, but it's still awful. I suppose I feel about this like a contractor probably feels about the typical architect's carpentry skills. I'm sure they've got a far better grasp on the big picture than me, but the implementation makes me cringe. Right at the moment I'm rewriting code I wrote 8-9 years ago on a small 8-bit system that suffered a lot of architectural decay from feature creep, so I've got a fair number of my own WTF code bits to deal with. I suppose I can at least consider that a sign that my skill level has improved over the years. The biggest WTF so far is that I totally *forgot to finish writing* an ADC sample buffer mechanism that feeds a DSP algorithm, yet it's worked for all those years. It just crams samples at it as fast as they come, but it turns out the algorithm still works because the power saving code meant that it *usually* woke from sleep at twice the intended sample rate. The Goertzel filters were actually operating on the first subharmonic of the intended frequencies but it only cares about the relative magnitudes. That had me scratching my head for a while, and I don't dare touch it in the production version because everything else was carefully optimized for the results it was getting.
So what have you done so far? Do you have any questions, or do you need some kind of clarification? Without writing any code, do you know what the solution would be for `10 4 2 18`?
If you want to learn how things actually work, don't use Arduino or Raspberry PI. I will recommend how I learned, which went very smoothly. Torrent [this](https://www.amazon.com/MSP430-Microcontroller-Basics-John-Davies/dp/0750682760) book, buy an [MSP430 LaunchPad](http://www.ti.com/ww/en/launchpad/launchpads-msp.html#tabs) from TI and get to work. Note: MSP**430**, _not_ MSP432. They are not the same thing. I use PICs mostly now and I can tell you that 95% of the stuff in that book on the MSP430 will carry over to any platform. The MSP430 is great MCU for learning because it's simple (but powerful), cheap, popular, and it's actually used in commercial applications. Whatever you do, don't start with a PIC--you will hate life.
Yeah, we don't do that here. Good luck!
If possible could you link me to this code challenge website you speak of please?
You are right about that actually it was a tiny little error... And I agree I should've walked through my algorithm it would've been a more productive experience but some of the guys here already pointed it out for me. Next time I come across an error I'll be sure to recheck my algorithm before coming here. Thanks for the info! &gt; `int main(int argc, char **argv)`. By the way could you please explain the line that I just quoted I don't understand it at all.
How can it be a compiler problem if the language literally says I don't give a shit.
Yeah, never cared for the PIC and Harvard architecture in general. I've never worked with the MSP430, but Cortex parts dominate the market so much that that's the direction I'd steer anyone once they're ready for a 32-bit platform. I still think learning an 8-bit MCU is good for getting the basics - something with a Von Neumann architecture and a flat 16-bit address space, without an overly complicated instruction set.
wait, is that one dash or two dashes? It's unclear on my screen...
Yeah, it's a good practice. Though if you're using C99, I think it's OK not to use a `return`, as long as your `main` function is `int` (which it should), because it returns 0 by default.
That's only needed if your program takes arguments. You're better off sticking with void for now. 
Two dashes.
We still don't do that here. Not without you showing us that you've done any work at all, at least.
No complaints about the hardware thus far (I use the PIC32). The datasheets and family user guides are good. However, their documentation for libraries and drivers is shit. The code in the libraries and drivers is shit. Their example code is shit. I have also encountered numerous configuration bugs in their Harmony platform. If you decide to make something non-trivial with the PIC32, be prepared to invest a lot of time getting up to speed. I am only using PICs because the manufacturer I am partnered with exclusively uses Microchip components. 
That's from 1998. I recall a lot of C developers doing crazy code like that in that era and immediately before. I distinctly recall a debate on whether macros should include semicolons.
Not sure what your programing level is, but I started embedded stuff with an arduino. If you're a little more advanced, I'd skip that and try an avr chip directly. I haven't purchased a dedicated programmer but you can use an arduino to flash an atmel chip and I've don't a few fun projects with that. I'm certainly no expert though and I'm sure the people doing this in industry can offer more sage advice
&gt; I've got a DEC Alpha that's years older than this code that wouldn't work since its long is 64 bits. Back before 64-bit PCs were common that gave me some porting headaches. Some people refused to accommodate 64-bit machines prior to AMD64, and a few even rejected patches for endianness issues.
OK, so at least it says it assumes 32-bit words.
It's hard to respond to this question without knowing what operating system you are on and which compiler you are using. If you post the info about that, I would be glad to help you compile your code step-by-step.
Right, I encountered that error, created the directory and then pushed except that I forgot that bin is in the gitignore file... lol. I'll fix those. I checked with valgrind, there are no leaks I'm just not sure if I'm committing any horrific crimes in my code(style-wise, things not being idiomatic, etc.). Thanks for the feedback, I'll fix that Makefile!
I cannot post the code here as its too long and will become confusing! I found the code here: http://www.codingalpha.com/sort-array-elements-in-ascending-order-c-program/ Hope this helps you!
I saw and read those discussions outside of safety critical areas, like you said. Much of it was in areas where programming was secondary to the "real " problem. A lot of the Software was throw away, single use
`fflush(stdin)` is AFAIK undefined behaviour. (Althrough i once read that Windows and Linux define their behaviour)
I actually have only ever used it on my mac so I am not sure what the limitations are for using fflush(). But I have also heard to avoid using it since it is not very portable. Overall I was trying to follow clear_buffer() since the while loop will keep calling getchar() as long as "\n" or EOF is not encountered. I would think that this would not clear the buffer but rather fill the buffer up? EDIT: I just researched this and see that by performing this while loop you are grabbing one and only one character.
Hello! As /u/Neui pointed out using `fflush()` on a input stream is undefined behaviour, my `clear_buffer()` function takes one char at a time until it hits '\n' or the EOF but I think you figured that one out already!
You are right, I'll remove that! 
Thanks! It's nice
thanks for all the help people. I am now set up and working just fine for now :)
You need to declare NULL_VALUE extern in the header and put the definition in the .c file. As is, every translation unit that includes the header has its own copy of NULL_VALUE that won't necessarily compare equal with others. The best option is to use NULL when possible instead of making up your own. Don't use recursion to search the "hash" table. Even a small table can blow your stack. With optimization your compiler is probably performing tail call optimization and turning it into a loop, but don't rely on it. Don't use \_t for your own types. It's reserved for POSIX. For completeness, handle everything in [RFC 4180](https://tools.ietf.org/html/rfc4180), especially quotes and mulit-line values. These are what make CSV tricky (and very flexible). The later won't play nice with your fgets-driven design. 
I disagree, it would be safer to have it return the keys it retrieved. What if "line" was modified by another thread and the number was different. It should probably take in the maximum length of keys as well for safety.
True, really the scope of my assignment was to read three fields separated by commas(it's an introductory course). In this case I kinda trusted compile optimizations which I shouldn't 
AFAIK, the compiler can't really optimize this because there's no such thing as a pure function in C, and strlen() is most likely already-compiled code in the standard library. The compiler has no way of knowing that two calls to strlen() on the same pointer will return the same value.
Oh right :-) 
Strictly speaking, a source file *must* be terminated with a newline character, as per the C specification §5.1.1.2/1/2: &gt; [...] A source file that is not empty shall end in a new-line character, which shall not be immediately preceded by a backslash character before any such splicing takes place. Most compilers really won't care, but it's easy enough to do and many editors ensure there is a blank line at the end of the file anyway. If you crank the warnings up to 11 (and/or enable `-pedantic`) this is the sort of thing you'll be warned about.
You're right that there isn't a such thing as a pure function in C, but `strlen` is likely replaced by a compiler intrinsic. Since the argument to `strlen` isn't volatile, the compiler should be able to determine that both `strlen` calls should return the same value, since there is no modification to the argument between calls. I checked the assembly output of the `strip_newline` function when compiling with `-O2` and clang does indeed optimise to just one call. If I break the rules and declare `str` as `volatile` (which doesn't *really* make sense because `strlen` expects `const char *`), then the assembly shows that the compiler resorted to two calls.
Good job! You are a truly great c programmer.
I don't think thread safety was part of the design decisions. Let's not pretend in one place that it was when everywhere else it was not.
Because at first I wanted to implement value_t as a variant type but that was too hard so I gave up, I really should just use char* and get rid of NULL_VALUE and value_t The equal function is also a reminiscent of that, in my head I wanted an extensible design where I could extend value_t and the equal function to add data types without messing up with everything else 
I am not pretending anything. I literally just read those two lines of code, and pointed out potential flaws and bad practices with them. No need to create another gets() function.
One more thing: CSV files (that I know of) sometimes use double quotes for strings, so you could be looking at a file like this: name,age "Matt Smith",40 "Snow, Jon",50 Mordekai,70 Your code works fine with Mordekai, keeps the quotes around "Matt Smith", and fails to read the Jon Snow entry, because of the comma in the name and how you use strtok. If you're looking for a challenge, you could try and add support for that. For bonus points, handle this, too: "Dwayne ""The Rock"" Johnson",23 
I believe it makes it easier to parse if every line is terminated with a newline character. Normal lines are distinguished via the newline character, so that's how they are recognized. If the last line has no newline character then it becomes an exception to that rule, so it is harder to spot. In practice, most compilers don't care and you'll probably only get a warning if you do it anyway.
Yeah I've had that warning, probably using -Wpedantic
I think vim does it, there must be a plugin for sublime if there isn't a setting for it. It's probably worth enabling, you'll never have to think about it again.
Do not delete questions after receiving an answer. The answer might be useful for future readers, by deleting the question you remove that resource. Don't do that.
If you like the MSP430, check this out https://microcorruption.com/
The flowchart-&gt;http://imgur.com/LMigU7T Reddit suck at embedding links..
printf has format specifiers. %s prints a string. %f prints a float. You are also reassigning the value of php twice, and printing out (the address of) the conversion rates, which never change. you need three other variables. Get rid of the ampersands in the printf variables.
Where to start... ? * you don't `scanf()` anything; * you should `scanf()` `php` as a `float`, with `%f`, not a `char` (`php` should be a `float`); * you have a single `php` variable and you successively multiply this variable by all 3 conversion rates, that's not what you want to do; use the (`float` ) variables you listed in your flowchart; * you should `printf()` those variables (and not `php`) as `float`s with `%f` and not as strings with `%s`. And you should `printf() their value, not their address, hence no `&amp;`.
Most of the help you've received tell you the answer but not really why. Since you're obviously quite new to programming, let me try help you get your head around a few things. First thing is first, *char* only refers to strings. If you want to do any sort of maths equations with the variable *php*, you're going to have to initiate php as a float along with the conversion rates (since you want decimal points, you can't store it as an integer either). Secondly, you need to look up how *scanf()* and *printf()* work. *%s* and *%f* etc. are called *format specifiers*, and they can be placed in strings as a placeholder for a value. %f is the format specifier for a floating point number, so you want to use that. php = php * USD; php = php * BP; php = php * JPY; The problem with this part of the code as others have pointed out, is that you are assigning php the value php * USD, and then immediately after you are multiplying the result by the value BP, and then again by JPY. If you want each value seperately (which you do) you need to create a new variable for each. e.g. convertedUSD = php * USD; printf("Your value for CVUSD is %s\n", &amp;USD); This has several issues. The first we have already discussed, if you wish to print a float you need to use %f. Secondly, you're referencing the value USD, which is the number 0.02 (first line of your main code states that). You actually want the value *USD* * *php*. However, you need to go away and read about pointers and addresses. The ampersand symbol (&amp;) tells the computer to give you the address, **not** the value. So, by saying: printf("%f", &amp;USD); what you're actually saying is "print the location in memory that the value USD is stored at". This is the reasoning for the strange symbols that result in your executed code. **Conclusion** I would recommend that you make it practice to comment each line of your code as you go along, and write out exactly what you think each line does. Then, when you are futher down your program, it will help you know where you've gone wrong. For example, the section where you rewrite the value of *php* three times could have been avoided if you had commented the first line with "set the new value of php to php * USD". This may have helped you realise that the second time you ran it you were changing the same value. 
I started learning C so I can learn to program AVR because I figured they were the easiest to start with. Would I be better off reading that book and getting the MSP430 instead?
I really appreciate your answer. :-))
Give it a try. I don't imagine it's any more challenging that an AVR.
Kind of amazing that it still builds and runs if you think about it...
Switch fase look those up.
I mean no disrespect to OP. We all started somewhere, and we've all made mistakes like this before. But I love this image. It's magnificent. Every time I look I notice something new.
Why would you ever use float? Use a uint8_t for cents, and uint64_t for dollars.
Have you tried taking CS50 yet? This is one of the things they go over IIRC
It would be neat to see this implemented into a simple equation parser that could handle powers, square roots, etc. 
This is spam. Please don't spam.
There is no standard way. Traditional toolchains did not distinguish between `text` and `rodata`, so there is nothing like `edata`, `etext`, or `end` to find where the `rodata` section begins or ends. As always, when asking questions about non-standard things, you should absolutely state what platform you are programming for as a portable solution is out of question.
On ELF systems, you can `# include &lt;link.h&gt;` and then do `dlopen(0, RTLD_LAZY);`. This will get you the ELF header, which describes where all of the sections are. (See [this stackoverflow](http://stackoverflow.com/questions/8875876/getting-the-elf-header-of-the-main-executable#8876887).) The specification for the ELF format can be found [here](http://refspecs.linuxbase.org/elf/elf.pdf). Note that you should probably work on making sure you can get the entry point address from the ELF header because you already know it (`_start`) before trying to get rodata.
Note that `dlopen` is in `dlfcn.h`, not `link.h`. I don't even know what `link.h` is supposed to contain, it's not a standard header.
You're right, but `link.h` is available if `_GNU_SOURCE` is defined and defines functions like `dl_iterate_phdr` for navigating ELF headers.
Other languages have developed control structures to provide canned solutions for common `goto` usages, partially in the hope of catching [the occasional mistake](https://www.imperialviolet.org/2014/02/22/applebug.html), partially to prove that you don't need `goto`. However, especially the try/catch approach bears serious potential for sloppy programming: You see, try/catch is a block statement. As such, it encourages the programmer to put a series of statements inside a single `try` block, catching errors only in sporadic `catch` blocks. However, that erases one of the two important pieces of information an error provides, that is, where the error occurred. For good error handling you want to know where exactly the error occurred so you can react appropriately or report the error precisely. Ideally, each try-block should only contain a single statement accompanied by a single catch block to react to errors, but then try { something; } catch (someError e) { some error handling; } isn't any better then plain old C-style error handling err = something(); if (err != noError) { some error handling; } try/catch tells the programmer that it doesn't matter where an error occurs. However, you still need to think about that. Here is a common pattern I've seen: try { resource = acquireResource(); do something with resource; do some other thing with resource; do third thing with resource; } catch (someError e) { some error handling; } finally { release resource; } even though the “use finally to release resources” instinct is hardwired, the programmer does not consider if any invariants of the resource are violated when an exception occurs inbetween two operations. Some internal state could be messed up, simply releasing the resource might not resolve these problems. This can lead to rarely occurring but difficult bugs, especially when the operations you do rarely fail (think of “resource” as a database connection without transactional semantics and “something” as a query you execute). C-style error handling instead encourages the programmer to think about the state of the program at each place where an error could occur. Forcing the programmer to think about the consequences of error makes writing the program a bit more tedious, but at the end of the day less bugs occur. This is one of the reasons why the Go team decided against using exceptions for error handling. The other reason is that exceptions are just setjmp/longjmp in disguise and liberal use of these functions is often seen as a sign of horrible code. Though, if you call these “exceptions” instead, everybody praises you for your modern code.
&gt; As is always said in these cases, you cannot blame the tool only because people may and will misuse it. This is even more appropriate to say when discussing C, a language in which 90% of what you do can cause all sorts of terrible things, very much unlike the sandboxed approach most modern languages utilise. My statement is not “try/catch can be misused.” My statement is “try/catch is designed to encourage misuse.” It's like with PHP: You can write safe software in PHP, but you have to go out of your way to do it. If you just do what comes naturally, you end up with an insecure mess. It's not that bad with try/catch, but my criticism of the control structure stands. Don't encourage the programmer to do stupid things. Make good things easy and nice, bad things uggly and tedious. &gt; As I understand it, exceptions should only be thrown when something really fatal and/or unexpected has happened. That's the right way of thinking about exceptions. Sadly, languages like Java and C++ give people the impression that using exceptions for normal error handling is just fine. &gt; But as as you said, knowing what caused the exception is just as important as recovering from it. And exceptions are pretty good at this too. When used well, they can give you a hell of a lot more information than anything you could code up easily in C ever would: stack traces, error messages, inner exceptions... The very type of the exception itself is great information too! No need to learn and maintain error code tables or just accept that all you're going to get is a 0 for "everything OK" and a 1 for "something went wrong" when a fatal error occurs. Of course, I'm sure people will have built and made available really comprehensive error-handling libraries that solve this problem in C, but the fact that you have all that help built into the standard language libraries themselves is very helpful. There are two parties that need to care about where an error comes from *exactly,* that is, the program (to handle it correctly) and the programmer (to correct the program if the error was generated wrongly). The user is not particularly concerned. Indeed, the user does explicitly not want to know where an error was generated he just wants to know enough to resolve it, if that's possible. For example, the user doesn't want information of the form “disk full error encountered while writing second block of the third transaction inside &lt;30 layers of call stack here&gt;.” the user wants an information of the form “cannot save: disk full.” Stack traces are very useful while developing and debugging a program, but they are truly useless when the program runs without developer supervision. Neither can the program react to it in a useful way (i.e. in a more useful way than if it didn't have the stack trace) nor is it at all useful to the user. Yes, the user could take the stack trace and write a bug report but nobody ever does that. &gt; No need to learn and maintain error code tables or just accept that all you're going to get is a 0 for "everything OK" and a 1 for "something went wrong" when a fatal error occurs. I prefer error codes because they are much more lightweight than differently typed exceptions. An existing set of error codes also forces programmers to use an existing error code instead of making a new exception type for their own code. It's much easy to be future compatible if you (roughly) know in advance what kind of errors something could return. Go is particularly guilty of that, people use `errors.New()` all over the place, making good recovery from errors very tedious. &gt; Don't abuse try-catch blocks, throw exceptions only when you have no other choice, and when you do so, bubble them up the exception chain correctly, without violating the external interfaces of the routines/classes they originate from, etc. All in all, educated and disciplined usage of exceptions can get you a very long way towards writing stable and robust applications. The intended use of try/catch blocks (wrap a paragraph of code in them) is already abuse. So why do we bother having them at all? Most programs do not need to consider exceptions at all. Rarely there is the need for a strategy when an exception occurs other than crashing because exceptions should only occur in unforeseen circumstances (e.g. a bug or out-of-memory). Few programs can recover from that kind of thing, so why bother with a complex control structure like try/catch that only encourages sloppy code? Better provide a mechanism like Go's `defer`/`recover` that is more geared towards the useful use-case (i.e. shutting down gracefully when an exception occurs). &gt; C doesn't have them though, I'm OK with that. It's been proven over and over again that you can write applications of unparalleled robustness and safety in C, and that's great. C has exception. See `setjmp.h`. You register an exception handler with `setjmp`, you throw an exception with `longjmp`. Very easy to use. No stack traces though.
&gt; Don't encourage the programmer to do stupid things. Make good things easy and nice, bad things uggly and tedious. Yeah, I think, with the exception of C, most languages are fairly patronising in that regard. They strip you of some freedom for the sake of safety. It's more difficult to shoot yourself on the foot but sometimes they also make it harder to do things nicely. There's always this trade-off between freedom and robustness that one must consider when picking a language for a job. &gt; The user is not particularly concerned. Indeed, the user does explicitly not want to know where an error was generated he just wants to know enough to resolve it, if that's possible. Indeed. That's one of the best uses of inner exceptions. You throw an exception that contains all of the gory details about the problem. Then you catch that exception higher up in the call chain and throw it back, but this time with a much nicer high-level message that may be suitable for an end-user to see or at the very least, painlessly translated into a friendly error message of some sort. An example of this could be a `UnauthorizedAccess` exception thrown which is then rethrown as the inner exception of a `FileException` or something like that. I think that's a neat way to handle errors at several levels if needs be and gloss over the implementation details of a class or routine. I think this approach benefits both the end-user and the developer. &gt; I prefer error codes because they are much more lightweight than differently typed exceptions. An existing set of error codes also forces programmers to use an existing error code instead of making a new exception type for their own code. That's a good point, I give you that. Although in an OO language you could always declare the class final/sealed/non-virtual so that it can't be subclassed. But yeah, having an immutable list of error codes that can ever be returned is nice. The problem is that it makes your routines slightly more bloated, since you have to either return the code from a routine that'd be otherwise `void` or pass it by reference from the caller so that it can be set and checked after returning. No big deal, sure, but it's something else to worry about. &gt; Rarely there is the need for a strategy when an exception occurs other than crashing because exceptions should only occur in unforeseen circumstances (e.g. a bug or out-of-memory). Few programs can recover from that kind of thing, so why bother with a complex control structure like try/catch that only encourages sloppy code? As ugly and incorrect as it may be, abusing exceptions is really not that harmful if the application runs nominally most of the time. However, when things go south, they can really help. Imagine a daemon/service that receives periodic status messages over the network from another host, like an embedded device. These messages are transferred in pure binary format directly through sockets, no high-level encoding or upper OSI layers to your rescue. How do you handle malformed messages, when this may entail off-bound array accesses? You assume you'll find the start of the payload section of the message at byte 45, for instance, but turns out the payload was corrupted along the way... Sure, you could detect this somehow and just return an error code. But, what if connection is dropped whilst you're receiving the message through the socket or trying to set up a TCP/IP connection to it? To me, a well placed, clear exception helps me a lot, as I can just catch it, stop processing that message I just received and carry on with the next. No need to panic or abort; just keep calm and carry on, as they say. That is one real legitimate use I've found for exceptions.
The main programming errors are in format strings and variadic argument functions. Unless you are using a compiler with gcc extensions (thus giving you hard coded type checking for printf and scanf style functions), you cannot check format parameters at compile time. And [here](http://c-faq.com/stdio/scanfprobs.html) is an explanation for why to avoid using the scanf family of functions. If you need a specific input format, it's best to parse the input stream manually, converting strings to numbers via [`strtol`](http://www.cplusplus.com/reference/cstdlib/strtol/) for integers and [`strtod`](http://www.cplusplus.com/reference/cstdlib/strtod/) for floats.
There's no real "portable" executable. Are we talking MZs? PEs? COMs? ELFs? COFFs? Whatever the hell Macs use?
Can you comment on why we should take your survey? Don't just dump an unmotivated survey in here. Also, The word “C” does not appear a single time in the survey. Are you sure this is not off topic? Note that C is not C++.
Mac uses Mach-O.
I disagree about simple checks like NULL pointers being pointless as a blanket statement. In your example it will generally be caught anyway by the memory controller, but that assumes you have a memory controller and something to handle it. In bare metal context even simple mistakes are worth asserting on. Additionally, depending on your development environment, debugging an assertion may be a lot easier than debugging a SEGFAULT.
"Before beginning a more technical discussion I should confess that the title of this article was chosen primarily to generate attention." Even Donald Knuth is guilty of click bait
I check for NULL pointers vigorously. We don't always have memory protection, and back in the days of DOS, writing to NULL would very likely just hang the CPU. Would you rather have an assert that you can catch in the debugger, or have to reboot your machine and guess what happened?
What I've seen in some code (mozilla for example) is to have the debug checks done in a header and have two different macros, one where the assert basically does nothing. edit, here's an example from mozilla's mfbt/Assertions.h: #ifdef DEBUG # define MOZ_ASSERT(...) MOZ_RELEASE_ASSERT(__VA_ARGS__) #else # define MOZ_ASSERT(...) do { } while (0) #endif /* DEBUG */
Though, he actually delivers.
50-100 is hard, but less than 500 you can look into the great book [500 lines or less](http://aosabook.org/en/index.html).
This is the answer, if you are doing echo "teststring" | md5sum you are actually getting the result for "teststring\n". Your code is probably fine, it's your control test case that is wrong.
Ken Thompson famously said "if you want to go somewhere, goto is the best way to get there." It's not that "goto" should never be used, it's that it's a very sharp tool that can be easily misused.
The typical idiom to get a rotation is to write var &lt;&lt; i | var &gt;&gt; (CHAR_BIT * sizeof var -i); The compiler picks this up and emits a `rol` or `ror` instruction if you compile with optimizations turned on.
try http://www.clearsilver.net/
The most important thing to remember about assertions: *they go away in non-debug builds*. That is, if you compile with *NDEBUG*, assertions vanish. So never rely on them being there. Anything that you check for in an assertion that you expect to have to handle at runtime also needs a check outside of assertions. Assertions are just there for validating your assumptions. As for when to use it, here's my personal philosophy (borrowed heavily from Eiffel, though I've never written a line of Eiffel and I've written...at least several hundred thousand lines of C over the years): At the top of every function, every argument should appear in at least one assertion that verifies your assumptions about it. For example: int openfile(const char *filename) { assert(filename != NULL); assert(strlen(filename) &lt; PATH_MAX); assert(strlen(filename) &gt; 0); assert(validchars(filename)); /* validchars is a custom function that ensures all characters in the filename are valid filesystem chars */ Now, in the real world all those would be part of the same assertion or stuffed in a "validopenfileargs" function or something similar. At the "successful" exit points of the function (which should be few), I use assertions to verify the postconditions of the function, e.g.: assert(fd &gt;= 0); assert(fd &lt; NR_FILE); /* in reality this would be checked by dynamically querying using getrlimit or whatever */ assert(lseek(fd, 0, SEEK_CUR) == 0); /* if I assume elsewhere in the code that we should be at the beginning of the file */ At the "error" exit points of the function (which should also be few), I use assertions to verify that things are in fact broken: assert(fd &lt; 0); assert(errno == EACCESS || errno == EISDIR || ...); /* make sure we got a meaningful error that we know we were prepared for */ Again, if there's going to be more than one assertion I tend to wrap it in its own function or macro. I try to write these pre- and post-condition assertions before I write any code, so that I find bugs more quickly if my assumptions are invalid or if my code doesn't meet my assumptions. Remember that you can be as slow as you want with the assertions, because when you do a production build, they go away. (Also, if I were being completely honest with myself, I don't do this every time, especially not on "trivial" functions...but when I don't, I often regret it.)
so to access the bitwise operators, I need to essentially *trick* the compile into compiling to them?
I know you can, its just that its more efficient to use the one op, than to string several operations together. 
Yes.
We can't do that because we don't know for sure that all computer architectures support rol operations. If we did have a rol operator, processors without the opcode would be really hard to deal with, so the usually accepted solution is to write it idiomatically, like FUZxxl said, and let it to the compiler to optimize it based on the processor's architecture.
The kids today with their long hair and their rock music all like JavaScript. Perl is for old folks in their (shudder) thirties.
Depends. Eventually everything comes down at the hardware level, and who knows how they implement it there? Maybe it uses the same logic as if you used C's bit operators, but bundled up in a single opcode. You'd have to look into the processor's specification guide to see how (and if) it's implemented.
Why don't you try it on your own system? Look at the generated assembly code and compare them. What did you learn? Try various ways of getting to zero. For example, multiply and divide and add and subtract and see what happens when you start getting rounding errors. Maybe you don't actually care if it's exactly zero, just if it's close enough to zero. Your job, then, is to determine how close to zero is "close enough" for your application. 
“try on your own system” is not a good way to find out things in C, espcially when undefined behaviour could be involved. It's legitimate for OP to ask.
The language in ISO 9899:2011 §6.8.4.1 says: &gt; ##6.8.4.1 The if statement &gt; &gt; 1&amp;emsp;The controlling expression of an if statement shall have scalar type. &gt; &gt; 2&amp;emsp;In both forms, the first substatement is executed if the expression compares unequal to 0. In the else form, the second substatement is executed if the expression compares equal to 0. If the first substatement is reached via a label, the second substatement is not executed. I hope this clears up your question.
You want to be careful with exact equality and floats. There are numbers that can't be represented exactly with floats, and thus you should always ask if a number if greater than or less than your target number, with some wiggle room. As for the implicit integer conversion above, i.e. float f = 0.0f; if (f){ The C99 standard states (in section 6.3.1.4): &gt; When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). The definition of if statements (section 6.8.4) states: &gt; In both forms, the first substatement is executed if the expression compares unequal to 0. Note that it doesn't mandate that the float be cast implicitly to an integer, only that the expression compare != to 0. Now your second example, i.e. if (f != 0.0f) ... Would appear to do exactly that, except that there's a subtlety there. The "!=" operator produces an integer result, either 1 or 0. Anyway, so, long story short: in your first example, f is checked to see if it "compares != to 0", meaning 0 is first converted to a floating point value by implicit type promotion and then compared. In the second example, the result type of "!=" is integer, and will either be 1 or 0. In the second example, there are problems like I said with exact (in)equalities, meaning you should probably test for values with within epsilon of the desired value (which if it's zero simplifies things but if anything is dynamically computed becomes more complicated). So, the first example is problematic because you're silently promoting an implicit zero to a float and then comparing, and things get wonky depending on the compiler and so on. Implementations are allowed to have multiple representations for zero in floating point numbers, and it's not guaranteed that whatever integer zero gets silently promoted to is the same thing as what you have for a literal 0.0f. So...don't do it. :)
Usually they don't get that far. Usually the process of thought is “I tried on my own system and it did X so obviously it does X everywhere. Also I can't understand how someone would not want to use gcc.”
I tried again doing that, but it still gives different outputs than the actual md5sum program. I did realize that length I use in padding was wrong because a) it was length in bytes instead of bits b) i forgot to mod that by 2^64. After fixing those, it still doesn't get the same sums as md5sum does, but it is consistent. The sums change if the files have even one byte difference too. So I think for now I'm just going to use it as is, it does do some kind of summing. I'll just come back and look through the whole thing again later and compare it to other sources. I would like to compare it to the source of md5sum, but programs (major linux/unix tools, etc.) like that are kind of hard for me to read. 
That's not a compelling reason. C can support early RISCs like MIPS which only have very basic addressing modes, which do not have incrementation mechanisms, etc. and it is not a problem to emit more instructions for that. And those "early" RISCs, which didn't have rotate instructions, appeared only after K&amp;R C. Computers in K&amp;R C days were CISC and had rotate instructions. Even the CDCs, which are sometimes considered as the first RISC, had some limited rotate instruction. C was typically developed for PDP-11, which had rotate instructions. In those days, 8080, Z80, 6800, 6502 all had rotate instructions. Heck, the earliest Intel processors did have rotate instructions, but no shift instructions... 
Since you're using Linux I would suggest using Zoom from RotateRight: http://rotateright.com - it was a commercial product but it is now unsupported and free to use.
Are all of your malloc()s being free()d properly?
solved..please visit the thread
note that the type is called `uint8_t`, not `uint8`. Furtherly note that typically, this kind of type-punning is in violation of the *strict aliasing rule,* but as an exception, pointers to signed or unsigned character are assumed to alias with every other type, so the code is fine because if `uint8_t` exists, it is an alias for `unsigned char`. Generally, you should write such code like this though: /* Returns 1 if the system is little endian */ uint8_t isLittleEndian(void) { union { uint16_t u16; uint8_t u8[2]; } u8_16; u8_16.u16 = 0x0001; return u8_16.u8[0]; } More specifically, I strongly recommend not to write code that depends on endianess. Such code is a code smell and can always be replaced by portable constructs, even if people tell you otherwise. Case in point: The Plan 9 operating system (kernel, drivers, userland) source code does not depend on byte order anywhere.
Depending on how portable you are hoping for, most compilers will indicate the endianness. [GCC for example](https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html) has `__BYTE_ORDER__` defined as `__ORDER_LITTLE_ENDIAN__`, `__ORDER_BIG_ENDIAN__`, or `__ORDER_PDP_ENDIAN__`
Thanks. I'm not planning on adding to any code/production, just wanted to know the method as a learning exercise
I agree with you (and in this case a union seems safer and less error prone) but to justify the choice of pointers: MISRA 2012 dislikes unions (Rule 19.2); and generally dislikes changing pointer conversion (Rule 11.3) Rule 11.3 has a specific exception allowing for changing a pointer into a pointer to *char*, *unsigned char*, and *signed char* 
It's cute. It's limiting you to architectures with 8-bit and 16-bit integer types, which is fine for POSIX systems. Maybe more notably, it's assuming the world is either big or little endian. It wouldn't detect the PDP-11's middle-endian (aka "fucked-endian").
Skip over the Python2/3 mess and go for something really hip. Something newer than Javascript, even.
Relevant username
Is this (the quote from your link) new to C11, or is it one of the edge cases where C++ and C do not share behaviour? In the C++ community (and I believe historically in the C community) I've seen this use of unions widely decried as UB (with a lot of excellent citations, including the standard). The quote you posted does not allow for aliasing different integer types through a union unless the type doing the aliasing is a character type.
I wasn't going to bring up encodings, but you're right, of course. The input format didn't seem like a matter of debate here: answering a thread titled "please review my CSV parser" with "you should use YAML or JSON" seems like missing the point ;-)
C is much more static than you're expecting. The latest revision was published in 2011, K&amp;R ("The C Programming Language") is for the first spec for the language and is still considered an excellent resource for learning C. Definitely check out some C99 / C11 resources, because the revisions are powerful, but you don't have to worry about resources being out of date.
Alrighty, good enough for me. Thanks.
In addition to the suggestions in other comments, have a look at [Learn C The Hard Way](http://c.learncodethehardway.org/book/) - made for programmers with experience in other languages. 
&gt; And then I will also tell people to never write another C program again. It won't be obvious. It won't be outright, but my goal will be to move people right off C onto other languages that are doing it better. Go, Rust, and Swift, come to mind as recent entrants that can handle the majority of tasks that C does now, so I will push people there. &gt; But C? C's dead. It's the language for old programmers who want to debate section A.6.2 paragraph 4 of the undefined behavior of pointers. Good riddance. I'm going to go learn Go (or Rust, or Swift, or anything else). Not sure a site written by somebody who's shilling Go (lol no generics), Rust (well done on reinventing the wheel already put into place by Ada, but doing it in a language steered by webdevs and hipsters and where 95% of the things written in it are the software equivalent of shitposting) or Swift (Objective-C without one of the better bits of Objective-C, namely the C bit) is a good link to teach somebody C.
After a quick glance over your code and library: * Do not use the `_t` suffix for your own type. This suffix is reserved by POSIX for system types. * In your install script, why do you randomly use command substitution (i.e. putting backticks around commands)? I don't quite understand the purpose of that. Also, your script looks very complex for the little work it does. * Don't hardwire the compiler to be `gcc`. There is more than one C compiler. My computer doesn't even have a `gcc` binary. By default, use `cc` (which is often an alias for `gcc`) and allow the user to change the compiler by setting a variable. * Do not store compressed files in your git repository. If you store compressed files, all the tools that display what changes you did stop working. Just store the uncompressed man pages instead of compressing them. * Do not expose functions like `SU_strcpy` that have absolutely no relationship to what your library does. * Section 7 is not really appropriate for `findf`. It's a C library after all. Consider merging `findf.3` and `findf.7`. * Do not use `pragma` unless you really have to as `pragma` is not portable to other C compilers. visibility specifications belong into the source files, not the header files. Consider using a *version script* instead of a visibility attribute as that is more portable. Otherwise, your code looks pretty okay (though I didn't look at it too much). You might want to have a look at Jörg Schilling's libfind (which you can find in the cdrtools distribution) for some inspiration.
Your project got caught in our spam filter. I apologize for the inconvenience.
To the person who reported this post: Self-promotion is not forbidden in this subreddit. If you make a program and want to sell it, you can of course post about it here. The moderation reserves the right to alter the rules if spam takes overhand. If you want to advertise to the visitors of this subreddit, I recommend you to [buy advertising](https://www.reddit.com/advertising/).
The first thing I'd do is get yourself into a proper head space. Realize that C is a significantly lower level language than those other languages. You're working much closer to the hardware, and IMHO it's a good idea to have a firm grasp of some hardware details. In the embedded world that's critical - and if you start on an 8-bit system with no MMU it's a lot easier to understand. It helps to know how your CPU handles things like the stack and indexed addressing modes. C sits at a level not far removed from those details. There is relatively little 'magic' that happens in the language itself. Concepts like associative arrays are far beyond its scope. Many of those features exist in the standard libraries, but the core language is lightweight and static and lacks just about all of the run-time safety features you might be used to. That makes it extraordinarily fast and efficient - for the CPU. The language will make you work harder for the higher-level constructs you're used to. Before suggesting any particular reading material, I'd ask what you intend to do with the language. That makes a difference in how you learn and use it. If you're working on embedded systems, you'll probably want to focus on a more restricted subset of the language and learn somewhat different coding practices. I can't remember the last time I used malloc() on an embedded platform, and recursion is frowned upon (or outright prohibited in safety-critical standards like MISRA-C).
Thank you very much I will make the changes you indicated as soon as I have a chance to sit with my laptop! 
In `libfindf_std.c`, in function `findf()` char **temp = NULL; /* * Create a temporary array of string, of filenames to search. * Users of findf() are allowed to input only 1 filename. */ if ((temp = calloc(1, sizeof(char *))) == NULL){ findf_perror("Calloc failure."); return NULL; } if ((temp[0] = calloc(F_MAXNAMELEN, sizeof(char))) == NULL){ findf_perror("Calloc failure."); return NULL; } if (SU_strcpy(temp[0], file2find, F_MAXNAMELEN) == NULL){ findf_perror("SU_strcpy failure."); return NULL; } if ((findf_param = intern__findf__init_param(temp, Couldn't you just do: char temp[F_MAXNAMELEN]; // ={0} not needed because SU_strcpy does it if (SU_strcpy(temp, file2find, F_MAXNAMELEN) == NULL){ findf_perror("SU_strcpy failure."); return NULL; } if ((findf_param = intern__findf__init_param(&amp;temp, ? Same for `rtemp`. Oh, and giving more explicit names than `temp` and `rtemp` would be cool :-)
[Go](http://golang.org) might be interesting for you. Though, it won't get rid of error handling. You always have to do that. You can choose not to but then your program burns and crashes on error (or silently gives the wrong result!). What do you think makes you "type a lot to get very little done."?
Maybe not the great idea you expect, but have you thought about creating a set of macros for all your projects for error handling (or use assertions for errors that should never happen, no matter the input) and using aliases for your editor, to type less? It gives you perfectly written C but letting you write less.
Yes it is sufficient. The commentary on § 6.7.3 plainly says: *Another way of expressing the idea behind these rules is that compatible types always have the same representation and alignment requirements.* Since § 6.5.2.3 provides this guarantee, they are type-compatible. You may also take comfort with ¶ 650 which clearly says: *Two types need not be identical to be compatible.*
I've heard a lot of good and ~~a lot of~~ some bad things about Go, but so far I haven't looked into it too deeply, but I will do so now. About the errors: I understand that I can't just ignore errors, it's just that for example if((returnvalue = function(...)) == NULL) { /*print error message (and exit)*/ } is quite a block of code if done repeatedly. I try to minimize the effort with macros, but it's still not as simple as I'd like it to be, at least for a quick side project.
I wasn't going to mention it until I saw you'd broached the topic of CSV complexity. Couldn't resist tossing in a corresponding recommendation.
Modern C++ can do *a lot*. It's become a very capable (or, if you're feeling less generous, *unwieldy*) language. The Standard Template Library gives you a huge collection of type-safe data structures with very little effort, reference-counting smart pointers relieve most of the burden of manual memory management, and exceptions simplify a lot of error handling. (Note that I still strongly prefer C because I can fit the whole language in my head at one time, but that's just me.)
Arthur's [B language](http://kparc.com/b/readme.txt) is similar to C, compiles (x86_64), and is very dense, so you do not have to type very much: Here is some [B code](http://kparc.com/b/t.b) and some roughly equivalent [C code](http://kparc.com/b/t.c).
You start with "yashwant kanetkar" for C. It's famous book for beginner. most of the engineering students refer this book. this is complete book for best practice of C programming. 
I just finished this [MOOC from the Aalto University](http://mooc.fi/courses/2016/aalto-c/en/). This is a beginners course covering C. I am normally working with C++11/14 and wanted to refresh my C knowledge as I want to do some microcontroller related stuff. The course was really good and helped me a lot. But be warned the exercises aren't that easy and you have to invest quite a bit of your time. 
Expert C programming - Deep C Secrets, by Peter Van Linden: https://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298 You won't need much else after adding this and K&amp;R to your bookshelf ..
It appears that you have been shadow banned. Talk to the admins to rectify this issue.
they “typical” for-loop usage int i, j; for (i = 0; i &lt; 8; i++) { for (j = 0; j &lt; 8; j++) { /* code */ } } is as if you wrote int i, j; i = 0; for (; i &lt; 8; i++) { j = 0; for (; j &lt; 8; j++) { /* code */ } } `j` is initialized every time the inner loop begins. However, in your code, `j` is only initialized *once,* so after the inner loop completed for the first time, `j` is stuck at 8 and won't be initialized anew. That's why the inner loop doesn't run the other seven iterations of the other loop. I hope this clears up your question.
&gt; This will loop through the second for loop all 8 times, but will only loop through the first once. The outer loop gets executed 8 times. The inner loop only runs on the first iteration of the outer loop since j is never reset.
I laughed. But actually, I got halfway through that book, decided it was shit and went through K&amp;R instead. Much clearer to follow along with, and much more insightful.
Inside the implementation of `malloc()` there can (and most likely, will) be both reads and writes, because the heap manager has to update the bookkeeping information that it uses to determine which regions are free and which are allocated, and possibly make syscalls to get more memory from the operating system. But this is all implementation-dependent. 
I can't see this website. It says “plugin missing.”
Strange. It worked for me on Firefox and on Chrome. Maybe you don't have Adobe Flash Player?
There's different ways of representing colour; Red/Green/Blue, Hue/Saturation/Lightness, and many others. It could be iterating through 1 space, but converting to another for display. Or it could just be deliberately jumping around to make the display more interesting than a very gradually lightening of a single colour. Send an email to the author to find the real answer.
It depends on your MPU (Memory Protection Unit). In C the pointer returned is a general pointer and you can read or write to it.
Good call. I contacted the owner, hopefully they reply!
[removed]
There are two formats that I stick to when creating for loops and nested for loops in C. 1. This only works if you are using C99 within the compiler for (int i = 0; i &lt; 8; i++){ for (int j = 0; i &lt; 8; i++){ /*Code Here*/ } } 2. Is the most common preference (to understand how the repetitions works I'll include a couple more lines of code and a ln output display) int i,j; for (i = 0;i &lt; 8;i++){ printf ("%d. ", i); for (j = 0; j &lt; 8; j++){ printf (" %d", j); } printf ("\n"); } //OUTPUT 1. 1 2 3 4 5 6 7 8 2. 1 2 3 4 5 6 7 8 3. 1 2 3 4 5 6 7 8 4. 1 2 3 4 5 6 7 8 5. 1 2 3 4 5 6 7 8 6. 1 2 3 4 5 6 7 8 7. 1 2 3 4 5 6 7 8 8. 1 2 3 4 5 6 7 8 //in total, the code within the j(columns) for loop will execute 64 times while the i(rows) for loop executes 8 times. Hope this helps!
Then take 2 time samples of RGB values, compare with the known times, and stare and compare and try stuff until you land on it. That, or there is an algebraic solution too -- I forget what this is called -- method of inequalities or something?? Way off, I know, I know -- but it's used when you have 2 equations, like so: 15X + 22Y + 21Z = 97 11X + 89Y + 25Z = 54 ... and then you do this process, which involves subtraction and such... and from that, you can arrive at precise values for X, Y and Z. If the color manipulation involves nothing more complex than the four basics (add, subtract, multiply, divide) then you stand a good chance of re-working this algebra into the R, G, B problem, and getting a solution. Heads up -- no guarantees this will get you there either. EDIT: Kudos to /u/SonOfParent - who gave the answer i was initially planning to give. A tiny bit surprising that's not it. 
You could check out project Euler. 
My messages are more remarks than recommendations. I haven't tested nor even compiled them (I haven't even run the program, just browsed a few bits of the code on gtithub) . So you'd better take them with a grain of salt, think about them, and double-check them. A small extra one. In `libfindf_Putils.c`, function `findf_read_results()`. You declare: unsigned int i = 0; while in the rest of your lib, you have rather consistently used `size_t` for numbers and indices. I guess there is no peculiar need for an `unsigned int` here and it can be replaced by a `size_t`. (I think `to_read-&gt;numof_elements` is already a `size_t`.) Then you have a: fprintf(stdout, "Result[%d] is at [%s]\n", i, to_read-&gt;res_buf[i]); For an `unsigned int`, the format should have been `%u` and not `%d`, which is for (signed) `int`s. For a `size_t`, the format should be `%zu`. 
This is amazing. Immediately signed up! Thank you!
FUZxxl, you've got me thinking about how to simplify the install script. One way I can think of right now is to split the 'compilation part' and the 'file moving part' by adding a makefile and having the install script call on make but I'm not sure how good of an idea that is. Also, maybe making a second makefile for the man-pages to ex: compress the sources to .[1-8].gz and including this makefile at the end of the first one ? Where can I find a complete yet simple example of an efficient install script? I don't know yet how to make a makefile but it seems a useful skill to have so I don't mind getting into it. About backticks..... I've got no excuses I fixed it
Thanks for your time! You were correct about the remark regarding the findf\_adv() function, the intern\_\_findf\_\_internal() function does already handle NULL valued 'custom argument'. Once again correct with my format strings, which I just changed in all source files. The unsigned int was a left over from before I make the switch to size\_t for all my sizes and counters and could have been a problem eventually, thanks!
Point taken. Now that you say it, its pretty obvious that possible users of my library are going to be familiar with UNIX . I will replace the install script with a simple makefile, but first will learn how to make one and also look into 'proto trees' which is the first time it's brought to my attention. Thank you very much. 
Well, if that's from the standard, it seems much more readable than I thought (I admit I was scared to look at it). It's very true that the amount of space saved by using char instead of size_t is very minimal. Plus, for the library to work on systems with bigger restrictions on memory a lot more than 2 simple constant would need to be changed. I'll make it a size_t type. Thanks a lot :) 
Fair enough, I'll keep the idea not too far in memory :) 
I recommend the admins sort out their reasoning behind banning people left and right without notice, I have a life. It's not a repost, the URL is clearly pointing to a different segment of the document. And if I catch you stalking or threatening me again; I'm going to report you, again.
So simply calling Malloc doesn't do anything but you can read and write using the pointer it returns?
In `libfindf_utils.c`, function `intern__findf__free_node()`. int intern__findf__free_node(findf_list_f *to_free) [...] /* Null all fields. */ to_free-&gt;size = '\0'; to_free-&gt;position = '\0'; to_free-&gt;list_level = '\0'; to_free-&gt;list_lock = NULL; to_free-&gt;next = NULL; to_free-&gt;pathlist = NULL; /* Release resource of the findf_list_f object itself now. */ free(to_free); to_free = NULL; 1. Since you are about to release (`free()`) the block of memory that contains all these fields, there is no use in resetting their values, they won't be accessible after the `free()`. (And it was weird to put *null characters* into `size_t` fields :-).) 2. All parameter are passed by value. `to_free` is the value of the pointer. You cannot modify it (I mean, it will not affect the pointer outside of the function). There is no difference with a simple: . void f(int a) { a=0; } int b=5; f(b); // b still is 5 So, `to_free=NULL;` is useless; once back in the caller, the pointer that was passed as argument to `intern__findf__free_node()` still has the same value, the address of the structure it pointed to. Should you want to modify this value, you would have pass the *address of the pointer* as parameter. int intern__findf__free_node(findf_list_f **to_free) and then add one level of indirection each time you want to use it in the function.
In `libfindf_utils.c`, function `intern__findf__init_node()`, and probably plenty of other places. We have of memory management *vs* error management issue. Let's take this code: /* Init the findf_list_f object. */ if ((to_init = malloc(sizeof(findf_list_f))) == NULL){ perror("malloc"); return NULL; } /* Init the list's array of strings. */ if ((to_init-&gt;pathlist = calloc(tempsize, sizeof(char*))) == NULL){ perror("calloc"); return NULL; } for (i = 0; i &lt; tempsize; i++) if ((to_init-&gt;pathlist[i] = calloc(F_MAXPATHLEN, sizeof(char))) == NULL){ perror("calloc"); return NULL; } There's no problem with the first code block. But with the second, imagine the `calloc()` fails, so we call `perror()` and we brutally `return` from the function. The problem is that the memory allocated for `to_init` is still around, it was not de-allocated. And the caller will not have the possibility to clean it either, because it received `NULL` from the `intern__findf__init_node()` function; the address of the memory block that was recorder in `to_init` inside the function is lost, there is no more available reference to that block. So, you should `free(to_init())` before you `return NULL`. And in the third code block, the problem is the same, but worse. In addition to `to_init`, you should also `free(to_init-&gt;pathlist)`. But it gets nastier, because you may have successfully called `calloc(F_MAXPATHLEN, sizeof(char))` N times and failed the N+1 times, which means you should free the first N memory blocks as well... So we see it gets ugly real fast when there is more than 2 blocks of code which allocate, and especially when there is a loop. One way to keep the situation under control is to gather the cleaning code in one single place, near the end of the function, and jump to it (with a `goto` when an allocation error is detected). In this case, it could look like: char *error_message; /* Init the findf_list_f object. */ if ((to_init = malloc(sizeof(findf_list_f))) == NULL){ error_message="malloc"; goto error; } /* Init the list's array of strings. */ if ((to_init-&gt;pathlist = calloc(tempsize, sizeof(char*))) == NULL){ error_message="calloc"; goto error; } for (i = 0; i &lt; tempsize; i++) if ((to_init-&gt;pathlist[i] = calloc(F_MAXPATHLEN, sizeof(char))) == NULL){ error_message="calloc"; goto error; } And in the end of the function, we clean in reverse order: return to_init; error: if(to_init) { if(to_init-&gt;pathlist) { for(i=0; i&lt;tempsize, i++) { if(to_init-&gt;pathlist[i]) { free(to_init-&gt;pathlist[i]; } } free(to_init-&gt;pathlist); } free(to_init); } perror(error_message); } /* intern__findf__init_node() */ (I did not take into account the `ISGLOBAL` parts, it took me long enough to type this ;-) ) Of course, if the program must always abort after such an error, you don't have to clean properly, but when the functions may be reused elsewhere (and, well, for a library, that's the whole purpose), one should make sure they don't leak memory. 
The "terminal" gives you access to the "shell", correct? It's where you give the shell commands and instructions? 
Don't be a dumbass, fuzxxl gave you sound advice to avoid getting banned and you spit back in their face. Perhaps it was for a reason?
You have to detach your concept of the actual physical machine the C program runs on with the theoretical virtual machine which C is defined to run upon. Each architecture may implement different features in different ways. C is defined as an abstract idea, so that it could run on some unknown computer. The details of how that particular computer implements it isn't important. The behavior of the virtual machine as it is documented by the C standard is the only important consideration. The actual practical answer though is... The implementation of malloc in all implementations of C both read and write to memory. malloc, realloc and free etc must read and write to memory to remember where things are to be remembered.
Haha fair point.
&gt;I can construct implementations where malloc doesn't read or write memory at all. With respect, I don't believe you can. There must be some book keeping mechanism. Unless your implementation of malloc simply returns a null pointer.
The warnings pretty much give the reasons for your problems. In C, there is a big difference between "+" and '+'. The first is a pointer to a constant char '+'. It would be very useful to study the concepts of pointers.
char* operators[3]; This makes an array of 3 character pointers You want an array of 4 characters char operators[4]; Keep in mind that there is no "wrong" way to learn. You're actively working to learn to code in a not very user friendly programming language. Trying is what matters, keep it up and you'll be fine. Also think about your input loops, the conditions you check for and the exit criteria for the loop are related. Make sure they agree with each other. Think through it, make sure you understand what each line is doing in addition to what purpose it serves. Keep at it! 
So, after the calls to intern\_\_findf\_\_free\_****, setting the pointer to a Null value won't prevent dangling pointer issues? Regarding the fields reseted, I understand it's pretty useless so I will fix it as soon as I got a coffee down my throat :) Thank you! 
Actually, not only there's no reasons for the - 1, but the variable's size is actually F\_MAXPATHLEN, and not F_MAXPATHLEN - 1. I will correct this now thanks! 
&gt; Lol I don't know about the translation but I do get the point (I'm french after all ;) ). I hoped you'd be Canadian and kind of bilingual. &gt; Ça étant dit, programing is much easier done in English and usualy Standards are so vague and cryptic that a regular user has no advantages in reading it. It seems I was wrong for the C standard :) Well, old standards are generally quite readable. It's only in "recent" years that all those texts (it is the same for texts of laws in real life) became both lengthy, inaccurate and cryptic. In electronics, I consider PCI 2.1 the last readable standard, so the turning point must have been around 1995.
Please pick one programming language. This subreddit is about C (not C++ and not C#), so I pick C. Both the `scanf()` function and the `strtoXXX()` family of functions indicate when the string they attempt to parse was not a number. You can use that indication to check if the user actually inputted a number: int i; printf("please enter a number.\n"); if (scanf("%d", &amp;i) != 1) printf("you haven't entered a number!\n"); else printf("your number is: %d\n", i);
Wow I never thought it like that. I will try to rewrite the program again using suggestions. Thanks :)
Ah, thank you for explaining this. I'm not very well-informed about Windows toolchains.
Hello again FUZxxl, Even though I will remove the script eventually, I can't seem to be able to run it properly without back-ticks arround both GCC's commands (Lines 147 - 171 respectively). I commented out my attempts to remove the back-ticks in case you could (or any other kind soul) spot what I did wrong. Thank you !
Cygwin
Why did you add double quotes in random places? Just remove the backticks and everything should run fine: gcc $CFLAGS -fPIC -c $newlib$sfile$src $CLIBS Double quotes force what is inside them to be considered a single argument. However, that's not what you want. `CFLAGS` and `CLIBS` both contain multiple arguments to gcc, so double quotes are not appropriate. The only place where they might be is around `$newlib$sfile$src` as that should definitely be a single word.
That's a bogus warning, I filed a [bug report](https://llvm.org/bugs/show_bug.cgi?id=20356) about something similar against clang long ago but the gcc team (if you are using gcc, that is) seemingly hasn't gotten the memo. `%zu` is both a C99 and a POSIX feature, unless you want your code to run on very old (older than about 1990) computers, there is little reason not to use `%zu`.
`scanf` returns how many items it was able to scan. An item is something like `%d` or `%f`. In my example, I wanted to scan one item. Then I compare the return value of `scanf` with 1 to check if `scanf` did scan that item. If it wasn't able to scan the item, it would return 0 instead. If there is an IO error, `-1` would be returned. Note that you can call any function you like inside the controlling expression of an `if` statement. There is no restriction or anything.
That if() statement will evaluate the return value of scanf and compare it to 1. Take a look at [scanf's description](http://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm) to find out what that returned value actually means. On a more general note, any function can be used inside of the parenthesis there, and whatever value it returns will be used in the comparison. The disadvantage to this is that you can't store the returned value, but if all you care about is that it succeeded/failed, then there's no need to keep it around anyway.
I thought it could have been introduced because you were sure the string was always 0-terminated and so you didn't have to zero the last byte.
&gt; Double quotes force what is inside them to be considered a single argument. My interpretation of double quoting was flawed. I saw it as simple variable substitution but now it does makes perfect sense why I couldn't make it work. Thanks. About %zu, I am indeed using GCC, I have yet to try another compiler really, GCC seems very complete in terms of features, even then I know only very little about them. Once again thanks I will replace format strings asap.
Variable substitution is done with the `$` character, not with quotes. Quotes don't affect variable substution at all, they only affect wort splitting. It also seems that you have misunderstood what the backticks mean. They do *command substitution,* which means that the command inside the backticks is executed and the output of the command is parsed into a word. For example, to get the current date you could write DATE=`date` This executes the `date` command and saves the output into the variable `DATE`. For example, on my system (the leading `$` being the prompt): $ date Sun Aug 7 15:15:25 CEST 2016 $ DATE=date $ echo $DATE date $ DATE=`date` $ echo $DATE Sun Aug 7 15:16:16 CEST 2016 
&gt; So, after the calls to intern__findf__free_****, setting the pointer to a Null value won't prevent dangling pointer issues? Nope, the copy of the value of the pointer inside the function will indeed be set to NULL (so as long as you stay in the function you cannot access the original memory zone any more through this pointer), but not the original pointer. Just like the `int` example. In the caller, the pointer will still hold as its value the address of the now-released structure. If you wish to set it to NULL, you must do it outside of the function (or, as I said in the previous post, pass the address of the pointer to the function so that the function is able to modify the pointer content). You can use `printf("%p\n", your_pointer);` to follow the value of your pointers at different points before, inside and after the function.
&gt; I guess my Github user name kinda sold me out .. haha Yep, it definitely sounded French but, to my ears, it sounded very slightly more French-Canadian (or French-Swiss).
Weird, I believed that GCC default dialect was *gnu99* or something like that, but a quick googling seems to say it was *gnu90* until recently and jumped straight to *gnu11* for the newest versions. Personally, I prefer to specify what language my code is written in, rather than relying on whatever default the current compiler has. So I'd recommend to use `-std=c99` (because C99 has some interesting and now rather widely used features compared to C90, and is probably finally better supported than C11 (and I don't really care about C11 features)). Well, that's my opinion.
You're right, I will add -std=c99 to the CL arguments. I've seen interesting stuff from 'Secure Coding in C and C++' regarding C11 (most of the _s functions) but I've yet to try any and for now I've much to play with using the C99 standard.
Yea from a few hours north of Quebec city. Deschanel sounds European, but not as much as the articles in your profile does ;) . 
Was about to post this as well. Have some programming challenges from /g/ instead, I do those in every new language I learn: http://liquidthink.net/uploads/2014/12/a6fN92L1.jpg
Arduino? aren't they normally programmed in Python? What does this have to do with C? The core question is how time is represented in some strange web app...
It uses a lot of the same runtime support as MinGW, but it's a completely different set of patches to the compiler. 
The first or 2nd version? I've never read that, I always thought it would be outdated and the changes would only confuse me, but now i'm curious...
In your case, you don't really care about the result, but for the sake of completeness: int i; int result; printf("please enter a number.\n"); if ((result = scanf("%d", &amp;i)) != 1) { printf("you haven't entered a number!\n"); // DEBUG printf("Scanf returned %d\n", result); } else { printf("your number is: %d\n", i); } 
It doesn't do what I expect it to do. It A) Cuts off the rest of the string if there's a space between words and it adds a weird char at the end of replacing the tab
Thanks, much appreciated. Had to add 1 thing and fix the last line, but it works :D
You can't return stack-allocated memory from functions, so if you want to do that, take a look at using dynamic memory allocation (malloc(), free(), and friends). Glad I could help!
With the Windows Subsystem for Linux, it is possible. However, if a C compiler were to be installed in the subsystem, it would produce GNU/Linux executables, and not Windows executables (unless you installed a cross-compiler, but doing that would be silly when the host OS is Windows).
Yes, my first thought as well as to ignore most error handling and use asserts, or to macros some of the usual error-handling boilerplate. The nice thing is that if you ever want to change the quickly-implementable code into robust production code, you can just add the error handling and the result is still in fast, clean C without needing to translate. 
Use code blocks. 
Yes, if you don't want a 'realloc' or 'free' to be implemented. But I concede you can implement a 'malloc' with nothing but a register to maintain state.
You aren't changing which worker you point to during the loop. I think you meant to use `workers[i]` instead of `workers`. Also, I believe `fflush`ing `stdin` is undefined behaviour.
Yes, it does work with pointers. `ptr[index]` is semantically equivalent to `*(ptr + index)` so they can be used interchangably on pointers (and arrays decay to pointers, so it works on arrays too). What error do you get? It should work as expected if you just do `workers[i]`, no need to increment as that is already getting done in the `for` loop.
As said before: `scanf` returns the number of *items* it was able to scan, not the number of *bytes.* &gt; scanf("%*[^\n]"); /* presumably */ Not sure with that. I've never needed code like that. If you need to discard input, your program is incorrect.
my apologies, scanf does indeed return number of items read. however, if you are reading a number from stdin, if input is not a number and you 'scanf("%d", &amp;var)' it will read nothing, so the input remains there. this is a classic newbie mistake, create a for loop that reads numbers, then input a word, and your console will keep printing "please enter a number" non-stop. this is why you must discard an incorrect input. &gt; scanf("%*[^\n]"); '*' means that anything read will be discarded (so no extra variable is needed), the syntax '[^X]' means "read until X", in this case i use the new line, which is the end of input on stdin. &gt; Not sure with that. I've never needed code like that. If you need to discard input, your program is incorrect. well, scanf hasthis feature for decades, if a program never needed it, it wouldnt be there. also if a programis incorrect using it, how are you supposed to discard input that your program doesnt accept?
Realize that `scanf` is not a function made for interactive input. `scanf` was made to parse simple textual file formats. For interactive input, you should use a two-step approach where you first read a line with `fgets` and then parse that line.
Interesting, but it would be way more efficient in time and memory to use a simple loop.
Excellent, thanks.
To whoever reported this: We don't usually remove links just because they are horrible blog spam as long as they are on topic. Click “downvote” if you don't want to see these kind of links.
If you ignore white spaces, you can't know what's on the right side (new line is a white space too). Read my other comment.
I've always viewed the statement 'ignoring the white space' more to do with, so there's four spaces between this word: program only sees one. Of course spacing is important, else 'ifthisthenthat' wouldn't work vs 'if this then that' which is the same as 'if this then that' 
Good remark, it might be more appropriate to either remove the comment or replace it with "fail on very few occasions" ;) Thanks!
I think the code you suggested might improve SU_strcpy()'s performances. (The empty block of code that is). I'll change it right now. Thank you :)
Well it's not that easy. Code is a series of tokens and in most cases, you don't need white spaces to signal end of token, but sometimes you do. White spaces are necessary in variable and function declararions. So white spaces are sometimes needed.
What happens if you have a left to right mark?
Thanks.
To expand on /u/StenSoft: Be aware of operator precedence within a line (a line ends with a `';'`) https://cs50.harvard.edu/resources/cppreference.com/operator_precedence.html
push at bottom is completely against the way stacks are supposed to work which is why pigeon768 says this is O(n^2). The proper recursive solution is to create a new stack and use recursion to pass the index,old stack,new stack into itself with index starting at the number of entries, pushing the old stack value onto the new stack and then calling itself with the same values with index-1, until your index reaches 0.
What error does it exactly throw? At compilation or at runtime? By the way, `"abc123\0"` is a string that you shouldn't modify, because it might be in read-only memory, so you may not/can't write to it. So you would allocate some memory first and copy the string to that location with `strcpy`. Also, the last `\0` in the string at `my_array1` (`"abc123\0"`) is not needed, a `\0` is automaticly appened to the string.
When you use "a string" (also called a string literal) in your program, the array the compiler gives you is read-only. The type it's actually giving you is a const char* which means you can't change the contents. I'd recommend reading on the subjects string literal, const correctness, and generally "where is my memory getting allocated?"
He is starting to learn C programming, I do not care what system you are on windows or linux. Codeblocks will not set you wrong. I have been using it professionally on and off for over fifteen years. It installs mini-gw as a compiler if you are using windows. It helps you buils console apps, it allows you to get used to make files. I do not do c pc apps but I have used it for embedded linux with cross compiler tool chains on and off for different projects for years. 
Why are you doing `free(array); array = NULL;` instead of just `free(array);`? What is the purpose of setting `array` to `NULL`?
This is not necessarily always true. The order of evaluation of parameters in function calls is not defined, so some compilers evaluate left to right, and others right to left. I fixed a bug at work last year that was due to this difference between msvc and clang. 
If you call `free` on memory that has already been freed then you have undefined behavior. If you call `free` on a pointer to `NULL` then there is no action taken. It's just a good habit to form.
For future questions: If you receive an error, always tell us what the error is. Not knowing what the error is makes it very hard for us to answer your question. Typically, the error message tells you a lot about what is wrong so you should definitely show it.
I like the products from microchip. Consistent register names, good documentation and user manuals/datasheets. They have their own ide and a in-curcuite-programmer, which supports debugging. I'd take a simple 8-bit mcu, and begin reading the data sheet of it. It might be a little bit hard to grasp so much at the beginning, but Google is always your friend.
The Arduino IDE uses C! Maybe you're thinking of Raspberry Pi? I'm not sure what that is coded in, possibly python. I'm using an RTC module to keep track of time on my Arduino.
The article doesn't elaborate on this point, but even the following be incorrect (where passing NULL is permitted): snprintf(buf, 20, "%p", 0) While a 0 literal usually has the same effect as writing "NULL", in a varargs function like this the compiler doesn't know that the 0 is actually in a pointer context and so the behavior is undefined. A cast corrects it. snprintf(buf, 20, "%p", (void *)0) 
In C a newline is just another kind of whitespace, like a space or tab (except in the preprocessor where it does matter). Statements are separated by semicolons. Statements will always be (logically) be executed in the order they're written. Saying code is executed from left to right would be incorrect, however. Let's consider this line of code: x = func1(func2(i + j), func3(k), func4(m) + func5(n)); We can't say anything about the order that `func2`, `func3`, `func4`, and `func5` will get called in. They'll all get called before `func1` is called because the arguments have to be evaluated first, but there is nothing that says what order the arguments get evaluated in. The fully technical explanation is what /u/lorddimwit said about sequence points. 
Any particular reason you can't just use NULL? 
That's fine. Each code statement should be completely executed such that the behavior is as anticipated here. It's the compiler that determines the order the instructions are physically executed on the machine, but it can tell which operations require the previous values. If array is a pointer to 0x01234567 before being set to null after the free call, the compiler can tell free is supposed to be freeing 0x01234567 and won't reorder the instructions. If the compiler designer wanted they could run both the frees first (out of order) and then set the pointers to null. For anything that isn't critical like this, compilers might alter the order depending on which one you're using. Especially if you use the -O, -O2, -O3, etc options in gcc. The only thing required is that the codes end behavior is as you expect looking at the code you actually wrote. If the compiler changes that from the language spec, you've got a bad compiler or found a bug.
Writing code that doesn't rely on endianness doesn't work when you're working on networks or anything that transmits messages around. You always need it to be big endian for the internet and many embedded systems rely on incoming messages to be as well. That's what htons, htonl, ntohs, or ntohl functions are useful for in C though.
Hmm, it *can* be defined as `(void *) 0` (or `(char *) 0`), but it doesn't *have to*. It may also be defined as just `0` and you're back to the problem #1. You can't rely on that. 
JavaSuck has a point here, all setting that pointer to NULL afterwards might do is add an instruction for the CPU to execute and only prevents the double free error Genmutant mentioned. (Assuming calling free on a null pointer doesn't actually result in an error.) If your code relies on inspecting that pointer later, for example if it was a node pointer in a binary tree or something I totally get it. Otherwise it can be a wasteful habit to form if the pointer whose memory you just freed is never going to be used again. If you wrote a double free, that's your problem. You should be getting that error and you should be fixing that double free. The only time you want to set it to NULL after freeing it when the purpose is purely to avoid tracking down a double free problem... Is if you're an amateur hack writing bad code or severely underpaid working with a badly written codebase and your boss doesn't want you to spend the time fixing it. A double free is a sign of bad code, error or not. So just have a real reason for it!
If you're in EE, you'll only need Windows or Mac and Notepad++. You may even want to get Cygwin to emulate UNIX on your Windows machine. No need to get a dedicated Linux machine or even partition any hard drives. In EE we use the GLUE UNIX server and we do everything on the command line. You remotely connect to this server via PuTTY. Honestly, if you're going into EE, then I would just wait until the semester starts and you begin ENEE 140/150 which are the first-year programming classes you take to learn C. Since you already have programming background, you'll do fine. I went into 140 without any programming experience and did very well. Once you learn a programming language, it's all about learning how to design programs. It's not about how many languages you know--languages are just syntax.
I disagree with you. By making the marshalling explicit you can easily avoid any dependency on endianess.
You know what, you're right. I wanted to verify for myself. Here's part of §6.3.2.3¶3: &gt; An integer constant expression with the value 0, or such an &gt; expression cast to type void *, is called a null pointer constant. And then in §7.17¶3: &gt; The macros are &gt; &gt; NULL &gt; &gt; which expands to an implementation-defined null pointer constant; Since 0 is "an integer constant expression with the value 0", it's a null pointer constant, making it a suitable definition for NULL. 
Will collaboration be posted on your website? As in, does my name go up as contributor? If so, I'm definitely up for this. 
Try sending out a little endian formatted packet on the internet and let me know how it goes then. The absolute standard on the internet is big-endian or network byte order. Don't trust me? Look it up or take a networked systems class that makes you program a router. Otherwise I have no idea what you're actually talking about in the first place. You can't disagree with me. Packets sent out over the internet in little endian format will never (or be inconsequentially unlikely to) reach their destination. At the very least they would not be formatted properly. You have to care about the endianness. If you don't, you have no career in networked systems. I've taken the class with Professor Alex Snoeren at UCSD and programmed this stuff in C before. You would fail his class if you didn't care about endianness and didn't use some equivalent to ntohs, htons, etc. There are cases where your code will have to rely on endianness. It's usually standardized but there's no escaping it in certain fields or projects. To suggest you can always avoid worrying about it no matter what you're doing is just ignorant. It's generally unimportant if your code doesn't have to talk to other machines that may not be in the same format but once communication is involved you have to line that stuff up. Period. No disagreements, it's fact.
Again: You have to do the marshalling explicitly. the Plan 9 kernel does this and gets away with not a single use of `htonl` or any endianess-specific code. The idea is to clearly separate the packets you send out and the datastructures your program uses. Before processing a packet, you explicitly marshal it from the buffer you received it in into the structure your process it from. You can then use inline functions like these to portably read a 32 bit little endian number: static inline uint32_t ri32(const uint8_t a[4]) { uint32_t x; x = (uint32_t)a[0] &lt;&lt; 0; x |= (uint32_t)a[1] &lt;&lt; 8; x |= (uint32_t)a[2] &lt;&lt; 16; x |= (uint32_t)a[3] &lt;&lt; 24; return x; } The compiler picks this code up and emits a single read on little-endian architectures or a byte swap and a read on big-endian architectures. This also has the advantage that it works on platforms that do not support unaligned memory access. If you do it right, of course you can write endianess-independent code.
1. How is the function wrong? As far as I'm concerned, it isn't. 2. No, it's not what htonl does. It's what htonl would do if it was a sane interface (read: one that can be used without relying on implementation-defined or undefined behaviour) as it combines the read from the marshalled buffer with the endianess conversion. 3. I'm arguing that you can do so without relying or even knowing your platform's endianess. For someone who believes he is right you surely seem to be agitated.
Check the code for inet.h. Unless what they're doing is identical to what you're doing, you're wrong in saying that function reads in a 32 bit little endian number into big endian. Which is the whole point and is in fact exactly what they do. Look at it before I show you the "read ****er read" meme from Boondocks. Have you taken a networked systems class in your life? Do you even know how to properly convert 32 bit integers from big to little and back on paper? Because I do, and it was on my final. If you don't know your platforms endianness, these functions are for you. And yes, I happen to be triggered by idiocy pretty easy. Being argued with by a moron who shows me a function almost completely the same as the ones I'm talking about and keeps using code words nobody uses to try and act like he's smart doesn't work on me. I've been doing this stuff for more than seven years, if you're gonna argue with me and you can't be specific enough or understand the key point you do have to worry about endianness when it comes to sending or receiving information on a network that requires a specific endian format... Which the internet does, or else you can get off the internet... No. Go away amateur.
Yeah, I was thinking of the Pi, sorry for the mixup.
Copy to where? You might look into `strstr`. It finds substrings, which is more than sufficient to test for existence.
Checkout redis : http://redis.io/documentation
My impression is that nobody reads the sidebar or the submission text (e.g. it says in the submission text to indent your code but many newbies don't do that). I believe it should be common sense to provide error messages. But maybe this can change.