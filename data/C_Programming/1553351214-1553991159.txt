C lets you break stuff and keep both pieces like u/YoloSwag9000 illustrates you can handily break stuff that other languages will scream at, you might or might not get an error, or odd behavior like different execution while debugging or any number of unexpected things....
He is very wrong, the optimizer does not reorder anything, it just does stuff in a more clever way, if you know at least a little bit of assembly I recommend you read this article: [https://cs61.seas.harvard.edu/site/2018/Asm3/](https://cs61.seas.harvard.edu/site/2018/Asm3/) Even though it's aimed on x86 it should give you a basic understanding of what the optimizer actually does to increase performance and/or binary size Good luck on your project.
never lol i cant read kernel code 
for using exponents quickly with good perfomancr without the pow function good for crypto bc a lot of math
Oh yeah I'm definitely understanding that there's a time and a place for everything. My issue is that my instructor straight up doesn't do it and instead declares global variables throughout different source files (and headers) with seemingly no pattern. It just results in variables we've never seen before suddenly appearing in functions with no explaination. It doesn't take too long for anyone who is comfortable with programming in C to figure out where they're coming for, but this is the first project many of the students have seen before and it's very clear that it causes them plenty of issues.
Try playing with simple text input and output. Getting something working with the `stdio` and `string` libraries is a common task in introductory courses, and there's *a lot* of room to learn more advanced details from there. Using functions in those libraries, you can learn the basics of character arrays (and arrays in general), then follow that up with a ton of useful stuff: pass-by-"reference" using pointers, preventing buffer overflow attacks, checking `errno` to find out if a result is valid, and more!
Thanks for mentioning the book. I wasn't aware of this comprehensive guide :)
Think you would need to check official documentation for that. Visual Studio is an amazing IDE, but it can be fairly resource hungry. If you find out that Visual Studio is asking too much of your hardware, you can always install Visual Studio Code which is a lighter and a (much) more neutered yet fully functional and customizable version of VS. Also, to be honest, if you're just going to run C programs you can easily get away with an extremely light IDE like CodeBlocks which will serve you perfectly well and could probably run on a 1990s digital Casio watch.
Just install the c++ components. Nothing else.
The problem with me, what all should I make before I can read someone else's C code properly? I need that kind of proficiency particularly when there are so many ways to do things in any language to be honest but lets stick with C here.
If you pick the C++ Desktop workload you will also get C support. Keep in mind that VS has limited support for the newest C standards (C11 and C17), it has almost complete C99 compiler support.
That will be enough thank you!
Here are a few examples to get you started: * Using the latest C standard: clang -std=c17 -Wall -Wextra -pedantic test.c -o test * Using the latest C++ standard: clang++ -std=c++17 -Wall -Wextra -pedantic test2.cpp -o test2 
Bit shifts occur in almost every hash function you've ever used. Another use is for encoding. Suppose you have a tuple of numbers, where one can be stored in 9 bits and the other is guaranteed to be storable in 22 bits. Well instead of allocating two ints (or an int and a short) which would be 64 bits, you can instead just allocate a single int, and store the first number in the 9 most significant bits and then the latter 22 bit number in the least significant bits.
Honestly, about a decade before I actually got good. Looking back at some of my old code makes me cringe really hard. I was exactly the wrong kind of clever before I got enough practice with security-critical code.
It's an efficient way of doing multiplication *under specific conditions*. &gt;Um... `-4 &lt;&lt; 2` is `18446744073709551600` which is not exactly what you are likely expecting when dealing with multiplication and division. Its right, but its not integer multiplication. &gt;And thus be wary of premature optimization. Let the compiler optimize for you - it knows what you're really trying to do and will likely do a better job of it, with fewer bugs. https://softwareengineering.stackexchange.com/a/234970
Thank you for the examinations. Personally I'm going to stick with my C++17, but I'm glad I was able to learn more about the C99/C11 landscape
&gt; Dialect 2 is non conforming because it can't support unions. Direct operations on lvalues of the form `someStruct.member` or `someUnion.member` are operations on an object of the aggregate type, much like operations on bitfields. For consistency with the existing gcc/clang dialect, use of the array subscripting operator on a struct or union member should likewise be considered an operation on the struct or union, and the formation of union member address via `&amp;` or array decay, as with e.g. union U {uint16_t h[8]; uint32_t w[4];} u; uint16_t test(int i, int j) { *(u.h+i) = 1; *(u.w+j) = 2; return *(u.h+i); } should be officially unsupported and issue a diagnostic, rather than silently producing meaningless code (which is what gcc and clang presently do). Under the present Standard, given something like: int test(int *p1, float *p2, int mode) { *p1 = 1; *p2 = 1.0f; if (mode) *p1 = 1; } an implementation would not be allowed to elide the `if` from `test`, because both of the following callers would have defined behavior when passed the address of a suitable chunk of allocated storage: int test1(int *p) { test1(p,p,1); return *p; } float test2(float *p) { test2(p,p,0); return *p; } Under dialects #2 and #3, `test` could be optimized to unconditionally assign to `*p1` and `*p2` in either order, ignoring `mode`, because nothing between the accesses to `p1` and `p2` would create a relationship between them or their associated types. While the present Standard would specify that each write to `*p1` or `*p2` would set the Effective Type of the target, situations where that would be necessary in the absence of anything between the operations to suggest a relationship are extremely rare in most kinds of code. 
It's my 6th month in programming in C professionally, I may not be on the level of other people in the thread but I had my moments that I felt better at programming in C like I leveled up. One of them is when I finished Kerrisk's Linux Programming Interface and learned how to make use of man pages. Next is writing a huge block of code and it compiling and running at the first try. Next is when I created a pull request and it got accepted without any kind of criticism. Next is proposing an approach to the team and it getting accepted. The last one is overhearing the senior dev I work say to our chief "let BeardedWax handle it, he can do it" about a fairly huge and complex part of our project. What really helped me get better is to understand is's really easy to fuck up in C. I mean, most languages gives you a small switch blade so you can stab yourself in the leg. C gives you a sawed off shotgun with explosive shells loaded so you shoot yourself in the foot, lose the whole leg and die of blood loss. It really pays off to be careful where you pass your pointers and what you point them to, and you are dandy.
Pointer aliasing isn't part of the standard, so no guarantee! GCC provides a '-fno-strict-aliasing' which allows you to get away with it: [https://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict\_002daliasing-825](https://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825)
When I started using the man pages more than tutorial sites. 
The kinds of optimizations described in that article are low-hanging fruit which do not affect any behaviors that would typically be described by implementations' documentation. Unfortunately, there's no way I've found to make gcc enable such optimizations without also breaking constructs whose behavior would be described by the Standard or a platform's documentation if the Standard didn't *also* proclaim that an overlapping set of constructs invokes UB. Many individual optimizations can be disabled if one knows to explicitly specify the option to disable them, but at least one (reordering ordinary loads/stores performed outside a function across volatile loads/stores performed within it) cannot be disabled so far as I can tell except by disabling function inlining altogether. BTW, as an example of a situation where "optimizations" can be subtle, consider something like: unsigned mul(unsigned short x, unsigned short y) { return x*y; } According to the published Rationale document, the decision to make short unsigned types promote to `int` rather than `unsigned int` was motivated in part by the fact that it wouldn't affect the way commonplace implementations would process code like the above when the mathematical product of `x` and `y` is between `INT_MAX+1u` and `UINT_MAX`. The Standard would allow implementations to behave arbitrarily in such cases, but commonplace implementations would simply yield an arithmetically-correct result. While gcc will usually behave in that fashion, it isn't reliable. Sometimes the fact that certain `x` and `y` values would cause a signed `int` to overflow will cause the compiler to infer that such values cannot occur, even though the code would--in the absence of such assumption--generate a numerically-correct (and quite likely useful) result given such values.
Flags
Did you receive a precopy of the book? The release is July 2019
Then I guess I'll have reason to investigate adding ICC to our battery for the first time in a dozen years. 
We're indeed using Vivado, however, we're not using the FPGA for the control software. We're running our C code controller on one of the Cortex-A9 cores, and Linux on the second core, separately. That Linux core runs some cryptographic software that uses the FPGA for hardware acceleration. As far as I know, all FPGA stuff is written directly in Verilog, so no compiling from C to Verilog/VHDL.
No, I downloaded it for free on the Internet. Just Google it :)
Good use of macros, double pointers, link lists, consistent success in unit testing functions, error handling
So, in that case I'm thinking a few remaining options: 1. Your TA isn't a CS guy, and is stating something based on previous experience with the FPGA compiling that has bitten him in the past. 2. Your TA is working towards you doing your own assembly review, at which point the instruction reordering will make things harder. 3. Your TA is worried about a real-time system misbehaving. Remember, "Real time" doesn't mean "real fast", it mean "predictable", which in a control system is quite important. And you really don't want a compiler doing crazy things to subfunctions while experiments are ongoing (as in, add function X, measure, tune, add function Y, measure, tune, add function Z, measure, tune, etc... Not that the compiler works while the system is running). 
What a small world!
Digital Signal Processing exercises, plus you'll learn about FFTs, importance of radix and zero padding
Re: bitshifting--it really helps to nail down the fundamentals of two's complement representation from a mathematical perspective . Bryant and O'Halloran give a solid treatment in their Computer Systems book. I'll try to screencap it from my digital copy and post it here when I get home. 
How are you storing the data that you are reading from the input files? It looks like you are reading the input on record at a time, but not storing the data in memory for further processing.
What did you got so far?
I'm storing it in the variables with sscanf but it only stores the variable for that particular line, so is there a way to store all of the variables for p2Courses.txt into one array and then when reading the studentReg.txt line by line, compare that particular course they are requesting with the whole list of courses?
You know you're "good" at C when you don't think about C anymore. When the translation between your ideas to the C code representing those ideas feels instantaneous. That is when you understand C on a philosophical level. There is also the deeper level, where you understand what your code will compile to. And there is the deeper deeper level, which is when you understand how your code will run on the CPU / GPU. I would call those the three levels of mastery: the language level, the assembly level, and the architecture level.
I started learning C when I was 10 ish, so I'm going 20 years ish now. From youth through high school, I was just concerned with getting things to go, not super serious about programming. When I got to college I noticed I wasn't good, but curiousity helped push me beyond a lot of barriers. &amp;#x200B; The first phase came when I started to work with digital circuits and had to do deep dives into assembly and platform specs. Learning how C might compile into assembly, how to work with the devices with little or no abstraction. During this phase I started to learn how to write things that were memory, time, etc performant. A little while later, I started having to mess around in functional programming. I like a lot of what that mindset offers, and dipping into Haskell and ATS changed how I wrote C. I look at things and evaluate what needs some degree of mutability, how to make functions more preditcable. Adopting some of the functional mindset made multi-threaded programming a lot more clean, though I don't insist on fully functional style; I'm judicious. &amp;#x200B; The weird thing is every three years or so now, I do deep dives and get to a point where I feel that three years eralier my code was trash, but I tend to be super self critical
&gt; so is there a way to store all of the variables for p2Courses.txt into one array and then when reading the studentReg.txt line by line Yes. You can use an array of structs. 
&gt;The first is thoroughly understanding C itself. As someone who has been programming for around the same time, i would add a bit of detail 1: Learn the language 2: Proclaim you thoroughly understand the language. 3: Confess your sins and GOTO 1 I still get hung up on pointers, i can use them confidently in practice, but if have to think about them too much, i feel like i need to GOTO 1. &gt;The second is mastery of programming itself. This is design, programming is in part an expression of how you choose to solve a problem, so it will never be 100% logical, if it was a compiler would do that bit as well. A programmer needs a creative side to decide the extent of the problem, how to break the problem up, interesting names for variables that nobody will ever read, etc. The job of a programmer is translate a real world problem into the domain of a machine, its supposed to be an unnatural, alien environment. I dont think we need to master it, we need to accept it, and survive.
What do you mean by that? Aren't I already doing that with cs.szCourseId, cs.dFee, etc.?
I advice you to check about data structres (such as arrays, linked list and so on) and then continue to solve the problem. What you have done is to save the data of one course/student at the time because in the next iteration of the loop the new data replace the old ones.
Try! And let me know what you get.
Took a long time. Maybe 10 years to feel truly at home in C/C++. But I still need to refer to man pages, google, stackoverflow, etc. In terms of worrying about overflowing and memory issues the following will help you. 1. Become familiar with pointers. Fully understand them. Write small programs to demonstrate what *, **, &amp;, [] all mean and do. Remember that if you have a buffer of char buffer[16]. Trying to read or write past the end of it will cause problems. 2. Try to structure your programs in such a way that you don't need to allocate and deallocate memory all over the place. This is good to help prevent leaks and overflows. 3. Become familiar with using valgrind. This will help you detect and diagnose memory issues.
I wont post all of my code here because it's messy and not working but here is the code i was testing and was not working well : 1. In the `main()` I would create `n_threads` and a pipe for each of them: `int n_threads = 4;` `int n_multiples[n_threads];` `pthread_t pthread_ids[n_threads];` `int* pipes_array_write = (int*) malloc (n_threads*sizeof(int));` `int* pipes_array_read = (int*) malloc (n_threads*sizeof(int));` `printf("Creating threads\n");` `for(int i = 0; i &lt; n_threads; i++)` `{` `// Create the pipe` `int fd[2];` `pipe(fd);` `pipes_array_write[i] = fd[1]; // place the WRITE-END` `pipes_array_read[i] = fd[0]; // place the READ-END` `// Pass the complete pipe to the thread` `pthread_create(&amp;pthread_ids[i], NULL, read_function, fd);` `}` `printf("Finished creating threads\n");` 2. The read\_function() would close the writing-end of the pipe and start reading on the pipe : `void* read_function(void * args` `{` `int *pipe = (int*) args;` `int status, read_value;` `close(pipe[1]);` `do {` `status = read(pipe[0], &amp;read_value, sizeof(read_value));` `printf("Value is %d and status is %d\n", read_value, status);` `} while(status != 1);` `pthread_exit(0);` `}` 3. The main thread would then write simple values (1,2,3,4,5) to each pipes and wait for each thread to finish : `printf("Sending values\n");` `for(int pipe_i = 0; pipe_i &lt; n_threads; pipe_i++)` `{` `int pipe_to_write = pipes_array_write[pipe_i];` `close(pipes_array_read[pipe_i]);` `for(int i = 1; i &lt; 5; i++)` `{` `int value = i;` `write(pipe_write, &amp;value, sizeof(value));` `}` `}` `printf("Finish sending values\n");` `printf("Joining...\n");` `for (int i = 0; i &lt; n_threads; i ++)` `{` `pthread_join(pthread_ids[i], NULL);` `}` `printf("...Done\n");` `exit(0);` `return 0;` &amp;#x200B; So here I am realizing that i actually posted all of my code. Hope it's clear. But here is the weird output I have : `Creating threads` `Value read is 0 and status is 0` `Value read is 0 and status is 0` `Value read is 0 and status is 0` `Finished creating threads` `Sending values` `Value read is 0 and status is 0` `Value read is 0 and status is 0` &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
I was reading an email thread about this just this week. Usually when someone writes an essay at the compiler engineer and doesn't provide an example, there's a bug in the code they haven't found yet… The usual undefined behavior issues are with signed overflow, null pointers or type aliasing. These are all very important optimizations if you want to write code with any abstraction - which obviously people do since C++ was invented. And defining some "safe behavior" for overflows is still incorrect, if you didn't intend it to overflow in the first place! If you're upset about it use UBSan and then verify your code doesn't trap at runtime. You need to be doing this level of testing in the first place.
\-O3 means optimizations that could produce a larger program. This is usually not worth doing, but they aren't buggier. It's irresponsible to ship a compiler with misoptimization bugs of any kind.
This can be written more safely using memcpy or \_\_attribute\_\_((may\_alias)) on individual operations. That way you don't have to rely on turning off optimizations - esp since new optimizations could still break you.
 [https://www.tensorflow.org/tutorials/keras/basic\_classification](https://www.tensorflow.org/tutorials/keras/basic_classification) check it
&gt; interesting names for variables that nobody will ever read Currently I work for a Japanese company. I frequently have to read someone else's code, and I find it to be A LOT harder when the person's primary language isn't English. Variable names are very important from a maintenance perspective, and people **will** likely read your code long after you've left the company. 
Here's the harsh truth: photo analysis and letter detection is very complex. If you need to ask where to start, I have serious doubts you'll be able to tackle the project. I'm not sure if it's allowed for your assignment, but your best bet would be to do some research yourself into finding an open-source library that does what you're looking for... and reach out to your TA's or professor ASAP for guidance.
Neither C++ nor C# are on topic in this subreddit which is exclusively about C. Please post elsewhere.
I know it's for C but could not find one for C++ and C# can you show me if there is one, I wanted to post in Programmers sub but it did not support text posts so here was my only option If I'm mistaken please let me know
&gt;I know it's for C but could not find one for C++ and C# can you show me if there is one, I wanted to post in Programmers sub but it did not support text posts so here was my only option If I'm mistaken please let me know &amp;#x200B;
You are the only one I guess who's not complaining about my post so thank you
&gt; What do you mean by that? Aren't I already doing that with cs.szCourseId, cs.dFee, etc.? That is a struct and it represents a single student record. You need an array of structs that can hold all of the records. An example might make this more clear: // a struct that can hold one student record struct student_record { int id; char first_name[20[; char last_name[25]; }; struct student_record one_student; one_student.id = 100; one_student.first_name = "Alan"; one_student.last_name = "Turing"; // an array of student records that can hold multiple student records struct student_record class[100]; class[0].id = 101; class[0].first_name = "Lisa"; class[0].last_name = "Simpson"; class[1].id = 102; class[1].id = "Bart"; class[1].id ="Simpson"; 
- I code in C and Python. C is a compiled language. So every runtime bugs or errors that you can find in Python do not exist in C. - It is fast, easy to learn. - It is minimalist, very small. It's incredible how with just a few features you can build everything. - It is the best language for microcontrollers and systems, especially Linux. - It works on every platform without any other software where interpreted languages such as Python, Java or Ruby require the interpreter. - The smallest c compiler, tcc, is only 100KB while the average size of an interpreter is several MB. - It is everywhere. ... 
For C++, try /r/cpp_questions. For C# try /r/learncsharp. For programming in general try /r/learnprogramming.
I will use it
Thank you! I was able to make it work with an array of a struct.
Do you know how to only capture the available seats from the p2Courses.txt? &amp;#x200B;
That’s fine. Just hard to answer without getting a precise question. Could you post a minimal example (e. g. Your code) in a formatted way ?
IIRC if the struct is allocated on the stack you can just do `s.a = 24`, but if you have a struct pointer, then `s-&gt;a = 24` is syntactic sugar for `(*s).a = 24` i.e, you need to dereference the struct pointer to assign the value to a field.
Off the top of my head, I cannot think of other cases of using pointers to structs rather than passing them as arguments. Did you see that particular example in someone's code?
You seem to close the file descriptors of the pipes. Unlike processes, threads share their file descriptors. What You do is basically closing both ends of the pipe. Remove the close() invocations. For the future, running your code with Valgrind or a debugger would show you stuff like this. In your case it terminates with a „Broken file descriptor“ Signal. 
No, admittedly I just wrote that on the fly to give an example but I indeed do not believe I've seen this method used except in the case of passing them to functions.
It outputs to C, and I just think it's interesting, I didnt even know you could basically create a state machine automatically.
Use [`strtok`](https://en.cppreference.com/w/c/string/byte/strtok), separate each 'field' from delimiters (whitespaces), then apply [`strtol`](https://en.cppreference.com/w/c/string/byte/strtol) to get the integer value.
If you're working with a struct that is allocated on the stack, then it's really up to you if you want to grab a pointer to it and use the pointer struct syntax or if you want to just use the dot syntax. However, for most libraries you're going to be using a pointer-to-struct is all that the API will expose to you, so your only option is the pointer syntax in that case. Also, if you want to do dynamic memory management with your structs, you're going to be allocating them on the heap which means you're going to have to use pointers. 
Because passing aa whole struct is a LOT slower than passing a pointer and dereferencing what you actually need. What you're talking about involves a lot of pointless copying.
The simplicitly of not having to deal with all the bullshit C++ throws at you.
In this case makes no sense to have a pointer to the struct. Dereference it whenever you want to pass it as an argument.
I see, so speed and memory conservation really is the main motivation behind it?
`_Generic` and decent build times
That's part of it, but another concern is data propagation. with your example struct up there, st, let's say we increment a during a function call. if you copy the struct, your local version, with the incremented variable is only incremented in your copy, the original version's copy will not be incremented. and with concurrency, atomic variables come into play for the same reason.
Apart from the other answers for program speed and using less memory, when you pass a struct by value (as in, without the pointer), a local copy is made in the function that you called. Any changes made to that struct will exist locally, but will not be copied back to the original struct. So if you need to change anything in that struct within your function, you better be passing it by reference.
an IDE that works
C17 fixed threads.h so chill with the FUD.
Hahaha
Ah of course that would extend to structs too. I'd actually never thought of that as a use case before but now that you mention it, it does seem quite obvious. 
Yeah, another commenter also mentioned function scope as a main reason why it's used and that does make a lot of sense. Frankly I'm kind of embarrassed that it slipped my mind initially but that's why I'm here I guess.
No need to be embarrassed dude, we ALL forget details about things, no matter how experienced.
While it would be possible to save only the available seats, I would just read the whole course record and save each course record in a struct in a array of structs. You would then find the available seats in a course by reading that field: courses[i].iAvailSeats; You will want the other fields so you can search for the desired course. 
`setjmp()`/`longjmp()` can be used to implement an exception system. Easy to create memory leaks with it, though.
It's not just a scope issue - you might be working with a dynamically-allocated struct, for example, and it'd be inefficient to dereference it. I can't think of any place in any of my code where I pass a struct by copy. Almost all of my C programming is in the embedded domain, though, and it's a much bigger deal there. On a Cortex M4 you could call a function that takes a single struct pointer and it'd cost almost nothing to make the call because the pointer fits into a register. Passing the whole struct requires it to be copied on to the stack first, and stack space is precious - and stack overflows are a perennial headache for embedded programmers.
Closest thing C has to try/throw/catch is building your own using setjmp() and longjmp(). Some good info here: https://en.wikipedia.org/wiki/Setjmp.h
As in things C has that C++ doesn't? Designated initalizers is the only thing that comes to mind. Though IIRC they'll finally be in C++20.
Okay thanks and one last question. I have a typedef struct that has been defined already. Is there a way to make this typedef struct like the struct you gave above to hold multiple records? typedef struct { char szCourseId[12]; char szRoom[15]; char szDays[15]; char szTimes[15]; int iAvailSeats; double dFee; } Course; &amp;#x200B;
Huh? I didn't say anything about not using threads.h, I was just trying to explain why the other person may have said so. I just recently implemented the threads.h interface for windows (though it's not perfect, due to my initial implementation, conditional variables don't work) and while not perfect it seemed perfectly suitable for 99% of situations. So if it's available to you, unless there's something very specific you're needing, definitely use the standard library. Also, where can I see the C17 changes? I used en.cppreference as my resource and it has no mention of it.
Take a look at the c library as a good place to start thinking about this. &amp;#x200B; In general, there are two conventions in C is: 1) * return 0 for success * return a non zero number if there's an error (and the number indicates what the error was) &amp;#x200B; 2) * return some number for success (e.g. the number of bytes read, or the file descriptor) * return a "sentinel value" (e.g. -1, or 0, or similar) when an error occurs, and set the global value "errno" to indicate what the cause of the error was. &amp;#x200B;
There are a few different kinds of error handling. The easiest is just return `int`, all other outputs via out arguments. (E.g., `posix_memalign`). You can flip that and do whatever_t func(OTHER_ARGS, int *error); but there isn’t always a good bogus `whatever_t` to return. You can formalize the error code qua `enum`, although if you’re just passing back `errno` values `int` is probably as specific as you should be. You can take a callback, either in pieces or wrapped up in a structure: typedef int error_callback_f(void *p, int error); whatever_t foo(OTHER_ARGS, error_callback_f *cb, const volatile void *p); // or struct error_callback { error_callback_f *callback; void *p; }; whatever_t foo(OTHER_ARGS, const struct error_callback *); If an error happens, call the callback. It can return an abort-retry-continue sort of code, or it can return `void` and deal with things however it sees fit. Or you can do `setjmp`/`longjmp` as others have mentioned (rare, not usually a good idea).
Yes, `typedef` is used to help make your code more readable and self documenting. For example the following do the same thing: // structs without type def struct Courses { char szCourseId[12]; char szRoom[15]; char szDays[15]; char szTimes[15]; int iAvailSeats; double dFee; }; struct Courses cs[100]; // structs with typedef typedef struct Courses { char szCourseId[12]; char szRoom[15]; char szDays[15]; char szTimes[15]; int iAvailSeats; double dFee; } Course; Course cs[100]; 
I'm a c++ guy that migrated from c when I was a young lad, _Generic looks neat. I'm honestly surprised that any generic programming features made it into the standard at all.
As soon as possible in your C programming career, I would strongly recommend putting aside `scanf` (and it's variants) and learn to use `fgets` and it's variants. `fgets` is great for reading an entire line. When tossed in a while loop it can be extremely powerful for grabbing text to parse with strtok or whatever other string manipulation functions you care to use. If you decide to use it in a loop, you can effectively scan through the entire input file by using its return value to check for a loop-breaking condition.
Linked lists are usually structs pointing to other structs, as are some sorts of table.
You might also try to have a function like `GetLastError()` that actually calls a function to return the last error number, along with an `ErrorString()` function that converts the error number to an error message string. I've seen SDL use this sort of approach - not sure if use of a global `errno`-style variable was seen as more of a nuisance compared to a function. I actually have done iteration on this sort of design that I'm not sure I've seen anywhere else. I didn't want an error deep in the stack (for example: file not found) to be obscured by an error higher up (for example: resource load failure). So I put errors into a FIFIO queue backed by a fixed-length circular buffer. That might be a bit overkill, however.
Bit shifting is used a lot in fields like cryptography (e.g. Stein’s algorithm) or also for embedded systems to make multiplications or divisions. You see embedded systems don’t do multiplication or division like some other machines would do, they do it by shifting the bit position. As far as I can tell that’s at least what bit shifting is used for.
It feels good to have this validation. 
Yeah I know every byte counts down at that level. Embedded development is actually what I eventually want to be doing so this is really interesting to me. Thanks for sharing your wisdom. 
From a design point of view, everything should be in classes and have interfaces, yet I do like C more as I think it's more interesting to not do it (while when I write in python or other high-level languages I do take time to build a design).
Also see: re2c, and even good old lex.
You can get the same effect with constexpr if and `std::is_same_v`, but `_Generic` is certainly more concise.
You are wrong because c is pass by value. Therefore you need to pass the address of struct to actually modify the value in that memory address. 
Something I often do is return a character pointer that points to an error message. Return a NULL pointer if no error occurred. I find that if you simply return an integer you lose a lot of context. What exactly went wrong? What file did you try to open? How much memory did you try to allocate? If you construct the error message where the error occurred you can include all these details. Makes for much more useful error messages, in my opinion.
[https://github.com/Qqwy/c\_exceptional](https://github.com/Qqwy/c_exceptional)
Another way to handle errors would be to use what is known as a *Maybe* or *Optinal* type. This is _the_ most common way errors are handled in Rust and it is getting more common in C++ as well, but they have historically seen very little usage in C.
Soo sad that my school taught me c++ as the first programminganguage
The proper way to declare pointers.
The problem with the `GetLastError` approach is that your API (which you control) breaks when your caller (which, in general, you don't) is multithreaded.
Sentinel value interfaces are a common source of bugs. Especially when the result type has no impossible value. Take a look at a correctly coded call to `strtol` for example: it's cumbersome to distinguish overflow from the correct conversion of `LONG_MAX`.
I'm not sure what you are referring but errno is defined on a thread scope, so each thread has its own.
In addition to what all the comments do, it's sometimes common to use `goto` directives to jump to the end of a function in case it needs to release resources in the event of an error (memory, files, etc)
If you want something slightly more informative than return values, you can check out STDERR
The reading loop looks odd, where does the 1 come from ? while (read(pipe[0], &amp;read_value, sizeof (read_value)) == sizeof (read_value)) do_something_with(read_value);
&gt; everything should be in classes and then you end up having to have everything inherit from everything else and it turns into a giant clusterfuck of spaghetti.
Exactly THIS, I hate Rust, C++ and many other languages which pretend to be "safe" when C is actually safe as well. All depends on your code.
Not everything. There are ways to do it the proper way. 
There's a fair point that in terms of features, C++ is mostly a superset of C (though it distinctly is not one, language-wise). So, I know one C++ fan who tells me that I should just "write C" (or the C++ subset) with a C++ compiler and profit from things like the string handling. However, you cannot view some feature in C++ as a distinct feature you can just "pull in". If you use C++ strings (but nothing else) you end up gnawing your fingers since it pulls in much of the other parts of the language too. Also, I didn't really have issues with strings although it's definitely not C's strong point. But I usually use other languages for that, I really don't see the point in needing one language than handles every use-case. My experience with C++ is other C++ coders (usually even "fans") asking me to fix their code because at some point they stop understanding what's going up. Recently one guy had a C++ lib using some older kind of name mangling GCC ABI&lt;4 which wouldn't link against his newer compiler, especially not against clang. He didn't have the code for said library. He didn't understand why the stuff wasn't linking because his IDE basically said that the library exported symbol A (demangled) and his code referenced symbol A. However the mangled versions where A' and A''. In the end I wound up writing C code that basically was an ABI-compatibility layer. He still calls C a language from the last century. But at least I can work with it and have a stable ABI.
MPI and OpenMP are used in different scenarios. With OpenMP you work with shared memory (e.g. one computer) and with MPI you're working with distributed memory (e.g. cluster). I would suggest you just look at some courses and tutorials to have a better understanding and learn the vital components of each library because it sounds like you need to first understand the basics. I can link you the following university course, you have some slides with basic explanation as well as examples and exercises with solutions : [http://hpac.rwth-aachen.de/teaching/pp-18/](http://hpac.rwth-aachen.de/teaching/pp-18/) And for PP it's good to know how to get around with C so practice, practice, practice is what I can recommend regarding that Cheers
Simplicity. C is remarkably small and simple. Very little to wrap your head around to become productive. Amazing how I do not need to continually look up how write something. When I do, it's the standard library functions and I always have a shell with `man` for those open. You can learn the language in a couple weeks and most of that is groking pointers. And, it was surprising how far you can go before actually needing to use pointers and how little you actually use (outside of function parameters and multidimensional arrays) at my level of expertise (advanced beginner.) 
C++ doesn't pretend to be safe, and in Rust the meaning of the word "safe" is a specific thing they have defined, and neither C nor C++ lives up to the standards of safety in Rust. (although considering they don't have an equivalent of the unsafe keyword, the meaning of "safe" in Rust arguably does not even make sense in C or C++)
How c is safe? It's simply not. Or what is your concept of safety? 
Funny enough, C exception handling is one of the places where it's often considered acceptable to use GOTO. If you look at the Linux source it's all over the place. setjmp/longjmp are an abstraction over this (they use the same mechanisms internally).
isn't that a way to shove/retrofit exceptions in C, tho?
Please format your code correctly. For correct formatting, turn off the fancy editor and indent every line of code with four space. Do not add backticks to blocks of code.
FYI, I resolved the performance issue [here](https://github.com/VKoskiv/c-ray/issues/42).
Your description of the resulting behavior is confusing and unclear. The code you posted isn't sufficient to diagnose the problem.
Don't be. Your first language has no bearing on your future learnings. My first school language was Java. I later self-taught python and JavaScript, then I went back to school and learned C, then later C++. Don't get caught up in dogma or labels -- you have plenty of time to learn whatever the heck you want to.
I'll try to be more clear, my apologies. I'm attempting to implement I/O redirects within a C shell. I have successfully parsed my input string into separate tokens and I am able to execute commands based on these tokens. For example 'ls' or 'echo hello world' perform correctly. In my attempt to implement redirects such as 'echo hello world &gt; test.txt', my shell creates a text file called echo and the text inside it is 'echo hello world &gt; test.txt' and on a newline, my shell prompt which displays the current time. When I parse my input, I check to see if one of the tokens is '&gt;' if so, I call the redirect function. Below I've included all my functions thus far for the shell. [https://pastebin.com/1yfRet5V](https://pastebin.com/1yfRet5V)
Can you typedef a callback type that way? I somehow thought that you could only use function pointer syntax.
That is really wild. You open a file for writing, truncating it to empty file. Output is redirected to that file. Then you execute the same file. If your O/S understands empty files to be shell scripts, then a shell gets started, getting input from that file and outputting also into the file. And all that in 5 lines :)
If we're talking about programming errors (such as failing to handle some valid input domain), or user errors (signalling that the input domain is *wrong*) there simply isn't anything you can do except abort, either by signalling an error sentinel (like -1, 0, NULL, or even special symbols which are possible in other languages), or some kind of dynamic unwind (including exceptions and crashing the program!) However *most* of the things people think of as "error handling" is actually transient: Running out of disk space, or a network connection failure. These "failure states" don't have to be terminal at all, and simply pausing to ask the user to deal with them is almost always preferred. while(-1 == write(fd, buffer, x) &amp;&amp; errno == ENOSPC) { puts("out of disk space?"); sleep(1); } This sort of thing has a bad reputation[1] but most people who look unkindly on this trick are looking at a strawman; foolishly compare "not handling errors" with "handling errors" (i.e. more code and more work), instead of "ask the user what to do, giving them some opportunity to save their work" versus "crash and explode definitely destroying all their work". If you wanted to see a "good" implementation of this, you'd need to look into Common Lisp's condition system -- whilst possible to write in C (and actually quite easy) it is *not* the way most C programmers code. [1]: https://en.wikipedia.org/wiki/Abort,_Retry,_Fail%3F
**Abort, Retry, Fail?** "Abort, Retry, Fail?" (or "Abort, Retry, Ignore?") is an error message found in DOS operating systems, which prompts the end-user for a course of action to follow. The message has been cited as an example of poor usability in computer user interfaces. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
it might not be what you're looking for: but it's cool stuff :P I advise you do your best to ignore the assholes: unless you're getting threats doxxed and shit.... \*had to quit facebook\*
Where are you learning from ? 
A lot of issues with your code as-is. Note: this is obviously static-analysis, as your code (as provided) can't be run.... In your redirect function: On line 17, you set a variable `r` which is not used. What's the point of looping through the token? On line 21, you're opening the file that corresponds to the first value that is provided. On line 25, you then execute that file. I don't think any of the above logic is what you're looking for... Tracing that back to where redirect gets called in `executeCommand`. Line 79, you're looking for the "&gt;" in `token` by loopin through a character at a time, then you're passing that entire token to redirect on line 80. Is that really what you're trying to do? Later in the same function (line 83), you `fork`, then on line 85 you `exec`. You should realize that if `redirect` gets called, your control flow will never hit line 83, so the process that is going to execvp is the shell process itself. Of course, everything provided here is simply a set of standalone functions with no `main` function defined, so it's really impossible to dig deeper, other to say that it looks like your logic across-the-board is a bit wonky. I'd wholeheartedly recommend tossing in a bunch of debugging statements so you can make sure that your control flow is going where you hope its going and that your variables are being assigned the way you hope they're assigned. I think it'll be a bit eye-opening.
It's my source file of functions, I can include the header and main file if you like. On line 17, I thought that it I would have to find the index which the redirect occurs and execute that in the later execvp. I'm not quite sure what you mean later on. When it spots that a redirect is present, shouldn't the control flow stop and not execute the fork on line 83? 
From another comment somewhere I wrote: People always struggle with C when they start from scratch or come from a higher to lower level of abstraction. I struggled with this for a long time till I did these 4 things: 1. Read [Code: The Hidden Language of Computer Hardware and Software](http://www.charlespetzold.com/code/) 2. Watched all 41 videos of [Crash Course in Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo) 3. Grabbed a copy of [C programming: A Modern Approach](http://knking.com/books/c2/index.html) and used it as my main course on C. 4. Followed this [Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/~tjensen/ptr/) until I fully understood pointers and memory management. The first two really helped by approaching C from a lower level of abstraction (actually the absolute lowest level and gradually adding layers of abstraction until you are at the C level which, by then is incredibly high!) The third is just the best tutorial on C. By far. The 4th is a deep dive into pointers and by far the best tutorial on pointers out there.
Many programs are subject to the following behavioral requirements: 1. When given valid data, produce valid output. 2. When given invalid--possibly malicious--data, produce arbitrary output without doing anything harmful. In many cases, meeting those requirements most efficiently would require a guarantee that integer operations will never have side effects *other than optionally signalling errors or terminating the program*. Most of the useful optimizations that would be disabled by `-fwrapv`, however, would not introduce side-effects. Suppose, for example, that one needs functions that will behave like the following if the program receives valid data (and no overflow occurs), and may arbitrarily return 0 or 1 when the program receives invalid data (and overflow might occur). int addcomp(int a, int b, int c, int d) { return a+b &gt; c+d); } int addcomp2(int a, int , int c) { return addcomp(a, b, c, b); } If a compiler knows nothing about the values of the arguments given to `addcomp`, the most efficient code meeting those requirements would likely be equivalent to: `return (int)((unsigned)a+b) &gt; (int)((unsigned)c+d)`. If, however, a compiler knows that `b` and `d` will be equal (as would be the case if invoked via `addcomp2`) then `return a &gt; c;` would be faster while still meeting those requirements. If there were a category of implementations that promised (e.g. via predefined macro) that integer operations other than divide/remainder would either complete without side-effects, signal an error via implementation-defined means, or terminate the program, and a program would refuse to compile on implementations that don't offer that promise, then programmers could meet their requirements using simpler source code than would be necessary without that guarantee, and compilers given that simpler source code could generate more efficient machine code than would be possible if programmers had to avoid overflows at all cost. 
The best way to learn C is learn assembly. Once you understand how it works, pointers and anything else will be pieces of cake
Because effective types can transfer through `memcpy`, it can only be safely used to import data of unknown type. Data which is exported via `memcpy` may have its Effective Type set to the type used to manipulate it, thus leading to UB if the data is read using anything else. Given that practically every compiler has a mode (e.g. `-fno-strict-aliasing` for gcc or clang) that can support type punning, at least in cases not involving aliasing of seemingly unrelated lvalues/pointers, and given that `restrict` is a standard means of enabling most of the optimizations that `-fstrict-aliasing` would, code which requires the use of such a mode would seem more portable than code which uses compiler-specific directives for such purpose. 
&gt; It's my source file of functions, I can include the header and main file if you like. At this point, I've already put about as much effort into debugging this as I care to. As a general guideline, the more code you post the better because *if* someone wants to debug your code for you, they can actually run it. Otherwise, all they can do is look and point out things. &gt; On line 17, I thought that it I would have to find the index which the redirect occurs and execute that in the later execvp. That's not what you're doing. You never use `r`, and you never modify `token`. You pass token to `execvp` precisely how you get it from the arguments. &gt; I'm not quite sure what you mean later on. When it spots that a redirect is present, shouldn't the control flow stop and not execute the fork on line 83? I don't know (precisely) what you have planned, but I'm assuming that your shell's process is calling `executeCommand`. Let's call this process PID 101. When `executeCommand` gets called, it's getting called from PID 101. On line 83, you fork, so you have the parent (PID 101) and the child (PID 102, for example). PID 102, execs on line 85 and becomes a different program. PID 101 waits on line 94 for (any) child to terminate, then continues its flow. (I assume that it's going to go back to prompting the user for a new command?) If `redirect` gets called, the shell process (PID 101) becomes the new program. The shell program that was running as PID 101 no longer exists, therefore it can not prompt for a new command. I'm making a lot of assumptions here, of course, but this doesn't seem like the desired behavior.
When I wrote a c compiler which compiled itself.
For the next time: do not delete your post after receiving an answer! This denies future readers the help you received here and erases the work of those who helped you. Please be considerate and do not delete your posts!
So what you did was you changed stdout to point to that file. Save the original stdout? dup2(1, old\_stdout\_fd); perhaps?
Here is an alternative approach with an offset based on frames: /* * This code is based on the example program sio_sine.c, * created by Andrew Kelley. * Argument processing and error handling has been stripped out. * Sinus wave generation has been slightly changed to show alternative approach. * Explanatory comment has been added. * Additional minor changes. * As the original, this file is MIT licensed. * * See http://opensource.org/licenses/MIT */ #include &lt;soundio/soundio.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;math.h&gt; static double frames_offset = 0.0; static int sample_rate = 44100; static double pitch = 440.0; static double wave_frames_count; static double int16_range = (double)INT16_MAX - (double)INT16_MIN; // Called asynchronously by soundio. static void write_callback(struct SoundIoOutStream *outstream, int ignore, int requested_frame_count) { for (;;) { // The actual number of frames to be written between "begin" and "end" is set by soundio // Thats why we are in a loop because we might not be able to write the full number // of requested frames after one "begin" call. int frame_count = requested_frame_count; struct SoundIoChannelArea *areas; soundio_outstream_begin_write(outstream, &amp;areas, &amp;frame_count); if (!frame_count) break; for (int frame = 0; frame &lt; frame_count; frame += 1) { double sample = sin(((frames_offset + (double)frame)/wave_frames_count) * 2 * M_PI); double val = sample * int16_range / 2.0; for (int channel = 0; channel &lt; outstream-&gt;layout.channel_count; channel += 1) { int16_t* ptr = (int16_t*)(areas[channel].ptr); *ptr = (int16_t)val; areas[channel].ptr += areas[channel].step; } } frames_offset = fmod(frames_offset + frame_count, wave_frames_count); soundio_outstream_end_write(outstream); requested_frame_count -= frame_count; if (requested_frame_count &lt;= 0) break; } } int main(int argc, char **argv) { wave_frames_count = sample_rate / pitch; struct SoundIo *soundio = soundio_create(); soundio_connect(soundio); soundio_flush_events(soundio); int default_device_index = soundio_default_output_device_index(soundio); struct SoundIoDevice *device = soundio_get_output_device(soundio, default_device_index); struct SoundIoOutStream *outstream = soundio_outstream_create(device); outstream-&gt;write_callback = write_callback; outstream-&gt;sample_rate = sample_rate; outstream-&gt;format = SoundIoFormatS16NE; soundio_outstream_open(outstream); soundio_outstream_start(outstream); getc(stdin); soundio_outstream_destroy(outstream); soundio_device_unref(device); soundio_destroy(soundio); return 0; } 
Oh, thanks for replying ! Actually I was about to rant about my frustration with learning C in the previous post, haha. So, after making us learn basics of C, my uni throws a Python course at me, so I'm left with half-assed understanding of C. Which, is hilarious, as my 'understanding' is of only stuff before pointers and pointers are what C is about, isn't it? The main problem I face is: I'm not in an CS program but Electronics actually. But, I have decided to study as much CS alongside as possible. Also, after I learn pointers how do I practice them a lot, so they stick in my brain, I was following Head First C and K&amp;R, but got bored after first-few chapters. So, I'm clueless and confused about what to learn and how much/deeply to learn, evaluate how good I am at XYZ, when to move on, how/when/which to do projects. This problem is compounded by the fact that the uni I'm in is really low-tier so I can't expect much from the people and courses here are shit/watered-down. Maybe my issues need a post in itself on some relevant sub, don't know which, maybe cscareerques or learnprogramming. Anyway, thanks! 
Stick with the tutorial. Head First C is great but you must do it the Head First way. No skipping anything. Take frequent breaks. Write a LOT of code. Open up a GitHub/Lab account and push often. There are no shortcuts. This takes time and effort. Maybe switch to Python and get comfortable with all the tools. I use Emacs and appropriate modes. Linux and Zsh. Etc.. then come back and go through the steps above when you are ready to learn C again. Either way, just keep plowing ahead, keep writing code, as long as it's fun and challenging. 
&gt; profit from things like the string handling. C++'s string ecosystem is an even bigger clusterfuck than C's. you've got basic_string, wstring, u16string, u32string, and all the string_view variants as well, and I'm probably forgetting some more.
As u/raevnos said, it can be done, but in general it's better to avoid it unless you absolutely need it. In general you should keep your code as simple and idiomatic as possible, only adding complexities the language doesn't provide when necessary. The C community already has a relatively standard and robust means of error handling without exceptions, so their use should be reserved for instances where there is no other way.
Underrated approach. Although I'd say learn C and assdmbly concurrently. It'll likely be rough for a new programmer to start with assembly since it can be a bit of a slog. 
I ment that why so complicated, and not the normal tone handcrank, like static int sample_rate = 44100; static double pitch = 440.0; static uint32_t phase, phase_increment = pitch * 0x100000000 / sample_rate; int16_t val = sin(2 * M_PI / 0x100000000 * phase) * 32767; phase += phase_increment;
Best way to practice is to write programs. There are a few types of programs that need pointers such as ones that involved linked lists or other data structures, but unless it's a project you feel like working on for funsies it can be a bit boring. If you're just looking to practice the general concepts of pointers rather than specifically how to use them in C, you could always go and try to learn some assembly programming. It makes understanding how pointers and other types of memory based concepts very, very clear. Even a simulated one such as LC3 will give you a similar level of familiarity and may even be a bit faster to learn (albiet less applicable) than x86 or something. I understand your pain though. I'm an electrical engineering student who loves learning about CS topics on my own time. I have found that just finding like minded friends to do simple projects with such as games using "lower level" libraries like SDL2, simple chat programs using some networking library, or whatever else sounds interesting to you can be a great way to get comfortable with the process.
Not knowing any C and rushing through projects is a recipe for disaster. Going from python to another object-oriented language is fairly straightforward -- ie you could half-learn JavaScript, Java, Ruby C# etc and do okay. C is not like that -- you absolutely need to understand what you're doing.
Sigh... Now I'll never be able to put this thread on my resume... :( On another note, were you just recently modded?
Nope. I've been a mod here for three years now. Moderators have to manually turn on the `[M]` distinction on their comments if they want to have them stand out. 
Ah ha -- gotcha, makes sense!
Where do you get to use all of them though? I only use std::string most of the times although that is mostly for my personal projects. I would like to read up on those other types and their usages.
It's a bigger clusterfuck, but streams are kinda nice. But you can work around that on POSIX platforms with C too, so it's not worth the hassle to import all the other clusterfuck. But nothing's as bad as `wchar_t`.
I think they’re working on proving that rust is actually safe as they’ve defined it. C is about as unsafe as it gets. Doesn’t mean it’s bad, sometimes you want that, but it puts the burden of managing memory on the fallible programmer, instead of the restrictive (used loosely) type system. You can write c code which is correct, but c is so far from safe. 
Do you mean file input/output? Or tying multiple C files together into the same build? If it's the first, try googling that for C (also called "file I/O"). If it's the latter, you'll want to google up some basic introductions to header files and makefiles for C.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Sorry, my crystal ball is broken so I can't tell without seeing your code.
That's the kind of error that sometimes pops up on a line number that actually means the real syntax error is on the line right before that one, FWIW. But yeah, we ain't psychics. :p
C has diverged into some dialects that can be used as a form of high-level assembler and some that can't. An understanding of assembly language will help one understand the more "traditional" dialects that are suitable for low-level programming (the purpose for which the language was invented), but making code work with more aggressively-optimized dialects will require dealing with an extra layer of complexity.
I'm fairly certain I've seen C code using jumps this way which predates the publication of Java, which arguably made the try/catch pattern more widely popular. C99 did some retrofitting, if I recall correctly, but the idea was already there.
Can you give an example of what you're trying to do?
You need to include the library stdio.h that provides functions for input/output. Then you want yo create a filepointer var, and make that variable point to the file you want to work using fopen(). When the file is opened you can go character by character or line by line. You also need to create an structure to hold the data that you read from the lines of the file. Work on it, its a really interesting exercise.
I suspect this involves writing and reading a struct to a file. If so, this used to work in the good old days since compilers didn't optimize as good. Nowadays a structure has padding and so you can't simply write a structure to a file and read it back. There are two options to consider, a dirty way is telling the compiler to not add padding (so called packed structs). A better way is to read the data back and rebuild the struct. More work but portable and correct according to the standard.
And to follow this, what you need to search for is "Serializing and deserializing structs in C".
Iterate through the lines, on each iteration, create a new node in the list and store the line in that node.
So something like? while(fgets(line2, sizeof line2, pFileCourses) != NULL) { CourseNode* head = NULL; CourseNode* var1 = NULL; CourseNode* var2 = NULL; CourseNode* var3 = NULL; CourseNode* var4 = NULL; CourseNode* var5 = NULL; head = (CourseNode*)malloc(sizeof(CourseNode)); var1 = (CourseNode*)malloc(sizeof(CourseNode)); var2 = (CourseNode*)malloc(sizeof(CourseNode)); var3 = (CourseNode*)malloc(sizeof(CourseNode)); var4 = (CourseNode*)malloc(sizeof(CourseNode)); var5 = (CourseNode*)malloc(sizeof(CourseNode)); lineNumber++; sscanf(line2, "%s %s %s %s %s %s", head-&gt;szCourseId, var1-&gt;szRoom, var1-&gt;szDays , var3-&gt;szTimes, &amp;var4-&gt;iAvailSeats, &amp;var5-&gt;dFee); head-&gt;pNext = var1; var1-&gt;pNext = var2; var2-&gt;pNext = var3; var3-&gt;pNext = var4; var4-&gt;pNext = var5; var5-&gt;pNext = NULL; } &amp;#x200B;
I haven't written C in a long time, so let me try by showing you some pseudocode. If that doesn't work I can take a shot at the C ``` head = (Node *) malloc(sizeof(Node)); current = &amp;head; for line in lines { current-&gt;text = line; temp = (Node *) malloc(sizeof(Node)); current-&gt;next = &amp;temp; current = &amp;temp; } ``` That's how the basic layout should work. After all, you don't know how long your file may be and therefore how many nodes you'll need. I left out a lot of implementation details, this is just the basic framework.
Thanks alot! But how would I do it to store in separate variables for each line. 
Just roll over and cry
&gt; But how would I do it to store in separate variables for each line. What do you mean? Different fields in the Node struct for different lines? How is your data structured?
I have updated my main post which describes my situation some more, includes my variables, and also the contents of the txt file.
Ok, instead of doing `current-&gt;text = line;` just do `current-&gt;varname = part of line corresponding to varname;`
Whenever you just want to write a struct to a file and read it back, wrap your struct definition in: #pragma push #pragma pack(1) // struct declaration goes here... #pragma pop I don't see how this wouldn't be portable when using types like uint_8 instead of unsigned char.
I did this for my program: int getCourses() { CourseNode* head = NULL; CourseNode* current = NULL; CourseNode* temp = NULL; head = (CourseNode *) malloc(sizeof(CourseNode)); current = &amp;head; while(fgets(line2, sizeof line2, pFileCourses) != NULL) { count++; current-&gt;pNext = line2; temp = (CourseNode *) malloc(sizeof(CourseNode)); current-&gt;pNext = &amp;temp; current = &amp;temp; } return 0; } And I'm getting the errors: example2.c: In function ‘getCourses’: example2.c:57:10: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types] current = &amp;head; ^ example2.c:64:18: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types] current-&gt;pNext = line2; ^ example2.c:66:18: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types] current-&gt;pNext = &amp;temp; ^ example2.c:67:11: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types] current = &amp;temp; &amp;#x200B;
I must spend a few words to defend my colleague, since I am also a TA of that class for the wireless part. First of all, we are not professional programmers. We are PhD students who are overloaded already with plenty of other stuff on top of which must also fulfil the duties of assisting the professors for these kind of projects. When you have to do these things in your spare time (and for spare time I mean evening after 7 and weekends), I can imagine that the result is a big mess. Consider also that many of my colleagues TA, do not have any professional experience outside of academia and are fairly young. Their path was high school-&gt;bachelor-&gt;masters-&gt;PhD. When I came in a couple of years ago and started speaking about licenses, unit testing, documentation, minutes of meetings, most of them where looking at me like an alien, but I am happy that things are improving. Last point: Eagle started as a mess and most of the original people who worked on the project are no longer there, but... Lennert, the new architect, is making a fantastic job at cleaning up things and make everything up and running in the cleanest way possible. Of course, there is a lot of work to do and we are trying our best to clean up and have everything as good as we humanly can. For the OP: ask your colleagues of last year what a mess was the Wireless Video Link compared to this year, for example. In short: don't expect from us perfection, we do not have time and experience to make production grade / ultra reliable and well documented code and hardware, but believe me when I say that we put our hearts and souls in it to make the students experience as good as possible. 
Again, haven't written C in a while and also I can't see the types of the Node fields because you didn't include that. Just figure out how to assign the pointer correctly. Maybe you have to exclude the &amp; sign or something.
Oh sorry I thought I did in my main post with the typedef struct and the contents of the text file
I don't understand what packed instructs is. Can u give an example?
nh_cham explained how to use the pragmas needed in another reply. When it comes to compiler optimization, code like this: uint16 x; uint32 y; uint16 z; Might actually be optimized (in a 32bit compiler) to put the variables on the stack in x, z, y order, so the 32bit boundaries line up and there's no wasted space. Or not! The point is, there's no guarantee. So if x, y, and z are in a struct, and you write it to file, and then read it back from another program whose compiler optimized things differently, the order of your data is going to be unpredictable. What you read back as x might be half of y, what you think is y might be (x &lt;&lt; 16 + z). Packing just sets a standard way of doing the optimization; the details don't matter as long as x, y, and z are in the same order no matter what. I don't know if I'd trust it myself (what if you have a 32bit machine talking to a 64bit machine? Heck, what about endian issues?), and I kind of doubt anyone in their right mind outside of a classroom would write structs directly to file on purpose and expect it to work OK. The safest thing to do is write and read the elements of the struct one by one explicitly, imo.
This is the correct response.
I'm not sure if you're using C++ or C, but just in case I want to make sure you know that C++ is off topic in this subreddit and C++ related questions are best directed to r/cpp_questions. &amp;#x200B; Moreover, your question is so specific that you would likely do better to check out one of the Vex Robotics specific subreddits: r/vex and r/VEXRobotics. &amp;#x200B; I've never used vex before, but I feel like you should be able to access a system clock with `#include &lt;time.h&gt;`. Are you trying to have an event trigger the motors for a period of time where cosine of the relative time from the event dictates how they work? Or is it that the behavior of the motors will change depending on system time?
Your CourseNode should only have single Course, not an array of 100. For a typical linked list, you would need to malloc a new CourseNode for every Course.
Is there a way to create to create a loop or something to loop through all iterations of my variables since I have multiple szCourseId, szRoom, dFee, etc.
I don't understand your question. You already have a loop that iterates through the file. The loop reads in one course line at time, which you then parse into variables with sscanf. That's the only loop you need.
I'm sorry I should have been more clear. The reason why I have a 100 is to store the all of the same instances of the same variable. So for example I need to take and store szCourseId for every line because I need to compare all of the courses that are available to another text file that contains student registrations in which a "student" registers for a class. I basically need to see if what they requested matches any of the courses in p2Courses.txt so I need to store all of the szCourseId separately. I was directed from a guy on an earlier post to create an array of structs which I did with 100 (I know 100 is Overkill but I just did that to be sure). Earlier post: https://www.reddit.com/r/C_Programming/comments/b4mq07/how_to_compare_arrays_from_two_different/
Maybe I don't understand your original question. You're trying to get rid of the array and use a linked list instead, right?
Yes instead of an array I need to use a linked list. And I need to store the contents of each line in a sperate variable and then store all of the contents of the next line in different variables than the first so I can reference the same variable (szCourseId for example) for all of the lines, to compare it. 
Sounds like homework
Here's pseudo-code of what it sounds like your assignment is: for each course in course file allocate new course-node and store course data in node add course-node to course-linked-list for each student in student file for each course the student is taking search for matching course-node in course-linked-list if course-node found, adjust available seats You don't need an array of courses if you're using a linked list. The linked list node holds all the data for one course. // Node for course list typedef struct CourseNode { struct CourseNode\* pNext; Course course; } CourseNode; 
Allocate the node and put the results of the sscanf in the fields of the Course in the CourseNode. You'll allocate a new CourseNode each time through the loop, so you'll have unique space for each course.
Sounds like OP has demonstrated an understanding, been working on solving it, a little stuck and reaching out for another perspective. 
Yea no.
`error_callback_f` is the function type, so `error_callback_f *` would be the function pointer type. There is an oddity around function typedefs, in that you can use the typedef to declare a function (e.g.:) static error_callback_f callback; but you can’t define a function with the `typedef`, you have to state args and return type.
If you’re writing something to a file that you intend to read back into a program using the same ABI, you should have no problem reading/writing structs directly, as long as there are no pointers in there. The problem comes when you dump something over a network socket from a 64-bit little-endian thing to a 32-bit big-endian thing, in which case all bets are off.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define BUFFER 1024 struct node { char string[BUFFER]; struct node *next; }; int main(int argc, char **argv) // input { if (argc &lt; 2) // exit if there's no input return -1; int i; char buf[BUFFER] = {}; struct node *hd, *cr; // 2 struct node pointers hd = cr = calloc(1, sizeof(struct node)); // generating the first memory for a struct node printf("Insert here ('0' ends the process):\n"); while (fgets(buf, sizeof(buf), stdin) != NULL) { // input loop if (buf[0] == '0') break; snprintf(hd-&gt;string, BUFFER, "%s", buf); // filling the char * in the struct for (i = 0; buf[i]; i++) buf[i] = '\0'; hd-&gt;next = calloc(1, sizeof(struct node)); // new struct node memory on "struct node *next" hd = hd-&gt;next; // let hd point on struct node *next } hd-&gt;next = NULL; // last hd-&gt;next set point on NULL FILE *write_file; // FILE pointer write_file = fopen(argv[1], "w"); // output loop while (cr-&gt;next) { fwrite(cr-&gt;string, strlen(cr-&gt;string), sizeof(char), write_file); hd = cr; // to get a pointer to free the memory cr = cr-&gt;next; free(hd); } fclose(write_file); // closing the file return 0; } I did both with comments, perhaps it'll help. I didn't check for errors to keep it readable &amp;#x200B; Usage: ./progname output.txt Example with input: ./progname output.txt Visual + input: Insert here ('0' ends the process): hello world this is just a test garbage: skjdfjlskdjf weruioweuf sdjfklsdjfl 0 cat output.txt: hello world this is just a test garbage: skjdfjlskdjf weruioweuf sdjfklsdjfl &amp;#x200B;
I'm not sure why more people are not recommending books, but Linux Programming Interface by Micheal Kerrisk is a must read for C programming. Your question is answered in 60 pages and you' never feel inadequate for the rest of your C programming career. I highly recommend the book.
You can make an array from 0-6 and do array[thenumber]++ for every number, and then in each position you will have the amount of how many of each number there is. 
The way I did something like this was to make an array of ints of a size equal to the number of integers you were randomly generating (in this case 0 - 6) and then each time a number was generated I'd increase the corresponding index. So each time I generated a 6 I'd do something like Array[6]++; Then at the end you can iterate through it and count the results. I hope that made sense!
You should read the rules of the sub, and format your code, if you want people to actually help you ;) Also - what you're writing there is clearly c++ not c otherwise you could just make an int count[6] and then just add 1 to count[0] for every time you roll a one, add 1 to [1] for every time you row a 2 and so on ...
Firstly, your `max - min + 1` in rollDie works out to be `6 - 1 + 1 = 6`, so you can just do `% max` and get a correct answer. Secondly, technically your array isn’t a valid C program as you’ve used C++’s std::cout... you can replace this with `#include &lt;stdio.h&gt;` and `printf(“%d”, rollDie());`. *To answer your question*: you’d want an array of however big you want to store - so if it’s 10000 then you need `int randomNunbers[10000];`. For every iteration of the loop, store that number in the array like so: `randomNunbers[i] = rollDice();` Finally, you should have something like this: ``` // inside loop randomNumbers[i] = rollDice(); printf(“%d”, randomNumbers[i]); ```
Alright thank you very much. I'll be more careful next time.
I don't think you can initialize a 2D array with \`= {0};\`. Try using memset instead like this code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; static int gameState[4][4]; void gameplay(void) { for(size_t i = 0; i &lt; 3; ++i) { for(size_t j = 0; j &lt; 3; ++j) { printf(" %d ", gameState[i][j]); } puts(""); } return; } int main(void) { puts("This program plays a game of tic-tac-toe."); memset(gameState, 0, sizeof gameState); gameplay(); return 0; }
Thanks! I would love to but its much beyond the scope of the book I am studying with (Schaum's Outline of Theory and Problems of Programming with C, Gottfried, 2nd Edition.) Is there a simpler, newb-ier way of dealing?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
If you plot this you should get a bell curve.. :\^) I think..
Gotcha. Actually I was totally wrong, you can use `= {0};` to initialize a two dimensional array. The bug in your code was that you didn't intiialize `i` to `0`, you only initialized j. `int i, j = 0;` needs to be `int i = 0, j = 0;`
Thank you for your explanation 😁
Oh wow. Thank you! This worked... I feel very foolish now :-)
I needed this thank you 
Ah yes, that's true. I was thinking about overlaying a struct to an existing file. For instance to read in a header or something.
Bad advice. The existing way of `max - min + 1` is good. It allows one to change the range of random numbers quickly. The minor optimisation of using only max is not worth the missing features. Of course, generating random numbers in a range using modulo arithmetic has its own set of problems. But if you're a beginner, it doesn't concern you right now. Just remember, when you are looking for proper randomness, this is not a good method. To make a count of how many of each number were generated, you can make an array of `max - min + 1` elements and then increment your the value at the index you generate (`arr[rollDie() - min]`). Also, remember doing this means you're using a Variable Length Array (VLA) which is supported only in C99. Many compilers don't support VLAs and if you're on Windows the MSVC compiler does not. I'm such a case, you have to use malloc and dynamically allocate heap memory instead. The only correct thing is the reply above is the fact that using `cout` means this is CPP and not C.
A packed struct is a struct without any padding bytes. How to do that is depends on the compiler, /u/nh_cham has given an example of it.
If your dice roll has a bell curve distribution, you are in a shady casino.
rand() is uniform
There's a decent example of this in the K&amp;R book. Chapter 1.6 Arrays talks about counting digits in input. It's even easier in this for-loop. 
Rand is uniform, but not rand % num. 
Compile your program with debugging symbols enabled, then run it through a debugger such as gdb. This will show you where the segfault is occurring, and you can inspect variable values and the path taken through the code to see why it happens.
You would need another vector that holds how many times each number came up unsigned int numberCounter[max - min] = {0}; and then in your code, you would edit your code like so: int randomNumber = rollDie(); numberCounter[randomNumber - 1]++; // increases the value for the current number by one printf("%d\n", randomNumber); // but that many outputs would be really slow once you are done with your loop, you could display those numbers like so for (unsigned char i = 0; i &lt; (max - min + 1); i++) { printf("#%u: %d times (%f%%)\n", i+1, numberCounter[i], (float)numberCounter[i]/100000.0); }
It is something to do with the index or something but I don't know if that's it 
Did you run it in the debugger yet? At which line is the segfault occurring?
I don't have a proper debugger for c :/
 int i, j = 0; while(i &lt; 3) That's undefined behaviour, you test i without giving it a value &amp;#x200B; I'm not a professional programmer, but I don't think global variables are the way to go: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define fir_D 3 #define sec_D 3 void gameplay(int (*)[]); int main() { printf("This program plays a game of tic-tac-toe.\n"); int *ptr; ptr = calloc(sizeof(int), fir_D * sec_D); gameplay((int (*)[])ptr); return 0; } void gameplay(int ptr[fir_D][sec_D]) { int i, j; for (i = 0; i != fir_D; i++) { for (j = 0; j != sec_D; j++) { printf(" %d ", ptr[i][j]); } printf("\n"); } } I would use for() in the function and get my space with calloc() (then it is all zero, too).
You probably do have one already! Which compiler are you using?
vs Code
[https://imgur.com/a/IUvdOHl](https://imgur.com/a/IUvdOHl) &amp;#x200B; this happens. the test file has this: A B B D D D C C C C
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/0DJ8XBe.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20ejbssl0) 
I’m not going to keep helping you - I’ve told you how you can easily debug this on your own, which is a skill you will need to learn eventually and really isn’t that difficult, but you seem to be dodging this for whatever reason. I don’t have time to pick through your code or run it myself.
https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools https://code.visualstudio.com/Docs/editor/debugging
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define MAX 6 int rollDie(unsigned long ptr[MAX]) { int i = rand() % MAX + 1; ptr[i - 1] += 1; return i; } int main() { unsigned long count[MAX] = {0}; srand(time(NULL)); for(int i = 0; i &lt; 10000; i++) { printf("%i\n", rollDie(count)); } for (int i = 0; i != MAX; i++) { printf("[ %i ]\t%lu\n", i + 1, count[i]); } return 0; } That subreddit is C, not C++ I stored the counter in an unsigned long array (see above)
I wrote a quick c program and checked - memnovf is right, to my surprise the was not a clear bell curve even with 100,000 dice rolls. :\^( my bad I guess. &amp;#x200B; I have another program that generates random x and y and increments random elements in a 20x20 grid until one of the elements reaches 9 - that generates a bell curve histogram of the values in the grid.. &amp;#x200B; I wonder if I throw dice until I have 100 of a single kind if that would be a bell curve....
still not too bell curved...
You need to be summing the outputs to get a bell curve. One die has a uniform distribution. Two or more dice summed have a bell curve.
For the sum of many dice rolls, you'll get a bell curve. With two dice, you'll get a triangle shape. 
Alright thanks! I'll work on it and tell you if I have any trouble with it. 
LOL you need to sharpen your statistics skills bro. It doesn't have anything to do with bell curve
I would claim that's a degenerate bell curve but I guess you can make the same claim for a uniform distribution.
Only on reddit have I ever read anyone state they wish to "call" an array.
&gt; to my surprise the was not a clear bell curve Why did you expect a bell curve? It's supposed to be flat, although the modulo operation will introduce a slight bias unless `RAND_MAX + 1` is a multiple of 6.
&gt; `int` is usually 16-bit Assuming OP is working on a desktop or laptop computer, `int` is almost certainly 32 bits wide.
&gt; The minor optimisation There is no performance advantage. Any decent compiler will see that the values of `min` and `max` never change, replace `(max - min + 1)` with 6, and optimize both variables out.
I assume /u/waspentalive misunderstood the [Central Limit Theorem](https://en.wikipedia.org/wiki/Central_limit_theorem).
**Central limit theorem** In probability theory, the central limit theorem (CLT) establishes that, in some situations, when independent random variables are added, their properly normalized sum tends toward a normal distribution (informally a "bell curve") even if the original variables themselves are not normally distributed. The theorem is a key concept in probability theory because it implies that probabilistic and statistical methods that work for normal distributions can be applicable to many problems involving other types of distributions. For example, suppose that a sample is obtained containing a large number of observations, each observation being randomly generated in a way that does not depend on the values of the other observations, and that the arithmetic mean of the observed values is computed. If this procedure is performed many times, the central limit theorem says that the distribution of the average will be closely approximated by a normal distribution. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Sum types. Like C, C++ also kind of supports them, but constructors make them borderline impossible to use. The only sane way is using them with just POD types.
You never initialize `i`, so its value is whatever happened to be in that memory location when `gameplay()` was called. It might be ≥ 3, in which case nothing happens, but it might also be negative. You should simply use `for` loops: for (int i = 0; i &lt; 3; ++i) { for (int j = 0; j &lt; 3; ++j) { printf(" %d ", gameState[i][j]); } printf("\n"); } 
0-6? Or 0-5 with array[num-1]++ Kinda strange to have an unused slot in the array imo. Or am I missing something obvious?
Agreed 
What algorithm does your textbook "describe in section 8.3"?
It's just easier and more comfortable to to use 
But it's wasteful, and definitely not good practice. When learning a language, easy (to understand) solutions for beginners are good so long as they don't form bad habits. Wasting 4 stack bytes or more to be more understandable is not a good habit, especially in memory critical applications, which is what C is normally used for.
shady casino .. they all are .. they all are. Also this whole "random" number thing won't ever be random unless a RNG source exists.
Thank you very much for the insighful recommendation! 🙂
wtf is WordStruct ? camelcase ? what ?
its the second picture in the link
You’re using = instead of == Keep in mind this is a C subreddit, not C++
You are assigning in the if statement. Use == to compare equality.
I haven't worked with C++ before, nor am I really any good at coding in general. So take my information with a huge grain of salt. I think your "else if" statements are redundant. If you just say if(I = x) then {} for all of them, it should work. Maybe. Also maybe not. Sorry I can't be any real help!
 1) https://www.take-a-screenshot.org/ 2) `=` and `==` do very different things. Unfortunately for you, due to wanting be backwards compatible with C, accidentally using `=` like that in a place where a condition is expected is legal and generally doesn’t even generate a compiler warning.
There are two ways: if (i == 0) { // 2 "=" is very important do_stuff; } else if (i == 1) { do_stuff; } else { do_stuff; } For simple uses, there's a "better" solution: switch(i) { case 1: do_stuff; break; case 2: do_stuff; break; default: do_stuff; break; } It has a "better" readability, but you can just check if the outcome is true or not (switch() {} can't do calculations to test is something is true or not).
It also requires less calculation. Throw an extra int onto your array and your loops becomes simpler.
Tres not trees
1. Since this is a C subreddit, I suggest you ask questions in r/cpp_questions 2. Don't take pictures of code with your phone's camera, take screenshots or put the code in pastebin(as another user has mentioned). 
Remember that in C/C++ the "=" assigns something to a variable and **also returns that value**. So you could also do something like: `int x;` `int y;` `x = y = 10;` x and y will both be 10 &amp;#x200B; &amp;#x200B;
Not really from what I can see: in most simple cases gcc optimizes them to be the same because it optimizes out the array, but when prevented from doing so, the first example actual does 3 more calculations, 2 being inside a mov-from-address instruction. (roll uses volatile ints because it simplifies reading the bodies of the counters which inline it, the changes are still present) https://godbolt.org/z/K35HM9
The data structure you are looking for is called an Histogram. Knowing that magic word, you 'll be able to find many implementations of one, based either on maps, vectors, arrays, or yet another enumerable type eith random access. :-) 
= is assignment == is comparison Also :- #define s scanf Don't do that.
The Standard requires that the members of structures be stored in memory in the same order as they appear in source code, even when this would make things less efficient. This requirement was imposed, among other things, for the purpose of allowing functions to be written using one particular structure type but then also be able to to perform a limited range of actions on an arbitrary variety of other structure types that share a Common Initial Sequence. The Standard fails to specify when if ever implementations are required to actually allow for the possibility that CIS members of one structure type may be used to inspect corresponding members of another, and some compiler writers thus see no need to usefully support that construct. The requirement that structure members be stored in source-code order is independent of support for any constructs that would allow programmers to benefit from it. 
It worked! Thank you very much! Also why shouldn't I do #define s scanf ?
Yeah, it's crazy, who calls anymore? I usually just text or Snapchat my arrays.
I might add, turn on warnings.
It doesn't gain you much - you type 4 less characters. But it costs you a lot in readability - the first thing I had to do when looking at the code is work out what the hell `s` meant instead of working out what the problem was.
How to turn on warnings? sorry i'm new to this subreddit and to programming in general
ohh okay thanks!
It depends on your compiler. You should Google for it.
Ah! Good info :)
I'll do. thanks!
Remember these are not random numbers but pseudo-random. Big distinction here so ensure you use the correct terminology going forward.
Sorry for interjecting. The link youve provided for the pointer stuff is broken and the page can't be found. Is there any chance of updating or knowing where to look for the material? Thanks buddy
This sub is for C. Your code is in C#. You'll get better help if you post in /r/csharp or /r/learnprogramming.
This looks like C#. This sub is for the C language. You're not likely to get good support here. Try a sub which is relevant to C#.
In addition to what others have already said, turn on compilation warnings. You should get warnings about using the result of assignment as a conditional. 
Sorry 
Thanks, sorry for my mistake 
He took it down I guess. Weird. That link has been up for years. He put in in the public domain so I think I will add it to my GitHub repo. For now, try http://www.cs.ucsb.edu/~mikec/cs16/misc/ptrtut12/pointers.htm
No problem. It happens all the time in this sub.
Not related to the problem you're currently having, but you want to get out of the habit of leaving unassigned variables 
It's a (printf format specifier)[https://en.wikipedia.org/wiki/Printf_format_string].
**Printf format string** printf format string refers to a control parameter used by a class of functions in the input/output libraries of C and many other programming languages. The string is written in a simple template language: characters are usually copied literally into the function's output, but format specifiers, which start with a % character, indicate the location and method to translate a piece of data (such as a number) to characters. "printf" is the name of one of the main C output functions, and stands for "print formatted". printf format strings are complementary to scanf format strings, which provide formatted input (parsing). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It's a [printf format specifier](https://en.wikipedia.org/wiki/Printf_format_string).
**Printf format string** printf format string refers to a control parameter used by a class of functions in the input/output libraries of C and many other programming languages. The string is written in a simple template language: characters are usually copied literally into the function's output, but format specifiers, which start with a % character, indicate the location and method to translate a piece of data (such as a number) to characters. "printf" is the name of one of the main C output functions, and stands for "print formatted". printf format strings are complementary to scanf format strings, which provide formatted input (parsing). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
First question has been answered. For your second question: this is the [C Preprocessor](https://en.wikipedia.org/wiki/C_preprocessor) at work. The C preprocessor is very simple: it replaces text with other text. `#define A B` is a preprocessor operation that tells the preprocessor to replace all occurrences of the token `A` with the text `B`. In this case, `#define false 0`, the preprocessor will replace all occurrences of `false` in the text with the text `0`. Similarly, `#define BOOL char` will replace all occurrences of `BOOL` with `char`. So the difference between `int false = 0;` and `#define false 0` is very big. No variable is defined or assigned to.
**C preprocessor** The C preprocessor or cpp is the macro preprocessor for the C and C++ computer programming languages. The preprocessor provides the ability for the inclusion of header files, macro expansions, conditional compilation, and line control. In many C implementations, it is a separate program invoked by the compiler as the first part of translation. The language of preprocessor directives is only weakly related to the grammar of C, and so is sometimes used to process other kinds of text files. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
1$ and 2$ mean 1^st and 2^nd argument (16 and 17 respectively (non-standard extension)) # means use the alternate format
Aren't you a legend! Thank you so much. On the back of the this request filling, I'm currently reading the C A Modern Approach and would like some advice if you didn't mind. I'm currently working my way through (currently on chapter 7) and working through the examples. My goal is to pick up as much from this book (learning the concepts and knowing what to use and when to use the tools). Is this the best way or should a programming language be used as a 'tool' rather than learning 'everything' about it? I also go through days where my mind simply stops functioning and can't even complete the exercises! Normal? Thanks again bud
Which format is d? How is %d different from $f? Which alternate format is x? It gives me 0x11 and 0x10.
This is literally from the [wikipedia page on printf fomat]([https://en.wikipedia.org/wiki/Printf_format_string#Format_placeholder_specification](https://en.wikipedia.org/wiki/Printf_format_string#Format_placeholder_specification)) (see the Parameter Field subsection). &amp;#x200B; The format string %&lt;number&gt;$&lt;type&gt; prints the &lt;number&gt;'th parameter as a &lt;type&gt; value. So `%2$d` prints the second parameter as an integer, and `%1$d` prints the first parameter as an integer. The `#` character is used with the `o` (octal) or `x` or `X` (hex) types to print the cannonical '''0" (for octal) or "0x" (for `x` hex) or "0X" (for `X` hex) number prefixes. &amp;#x200B; &gt; how do I know which number goes into which printf format string? Not sure what you're asking. &amp;#x200B;
Was wondering which number outside the double quotation goes into which % locator part.
%d prints an integer. %f prints a float %x prints 10 (sixteen) %#x prints 0x10
Usually its by order. For example `printf( "%d %d %d", 10, 11, 12 );` prints "10 11 12". Here, the parameter field (`&lt;number&gt;$`) is used to specifically pick which number to print. For example `printf( "%3$d %2$d %1$d", 10, 11, 12 );` prints "12 11 10". Its worth noting that `printf( "%d %d %d", 10, 11, 12 );` and `printf( "%1$d %2$d %3$d", 10, 11, 12 );` are the same (since the parameter fields used are in order).
For the format types, I would review this documentation: (printf - C++ Reference)[http://www.cplusplus.com/reference/cstdio/printf/) (dont worry, its the same printf)
d is a signed integer, f is a float. x is hexadecimal. You're asking questions that would be really, really good questions to learn to answer yourself. You're going to get flack here because questions like "which format is d" is what many consider to be a "lazy question". It's a question that absolutely screams "I can't be bothered to Google things or read documentation" Don't look for shortcuts -- read the man pages for printf, and teach yourself what each part of that format string does.
What if I want to print the symbol % yet print the numbers accordingly? I tried printing printf("%2$d; % %d; %d",16,17,18); But it gives me 17; %d; 16 instead of 17; 16; 17.
To print a `%` put `%%` in the format string 
Before anyone else helps this guy -- please take a look at his post history and ask yourself if this person deserves your effort.
Ah I get it. when I ran that code, % % worked like that %% and d was isolated as a string value rather than decimal format.
 for(p1money=50;p1money!=0||p1money!=100;p1money+=0) wtf &amp;#x200B; for (p1money = 50; p1money || p1money != 100;) didn't test but should do the same &amp;#x200B; I get it when ppl do: #define ERR(x) err(EXIT_FAILURE, "%s: %s", __func__, x) because it saves a lot of work and stays readable, but #define s scanf #define p printf That's too much, but if you really want to do that, use capital letters, because then most people know that it's a macro &amp;#x200B; s("%d",&amp;p1); If someone is just giving a letter as input, your programm goes nuts &amp;#x200B; while (scanf("%d", &amp;p1) != 1) printf("A number please\n"); is an easy way to prevent wrong input (please test it, because scanf() is able to do crazy stuff). I really don't know if the return after typing a number is going to loop twice &amp;#x200B; &amp;#x200B; I didn't test any of my code here, so you have to if you need it :)
 int false = 0; // is a integer with the value 0 #define BOOL char // preprocessor macro which changes every "BOOL" in the code to a the word "char" #define false 0 // preprocessor macro which changes every "false" in the code to a 0 a float is a floating point number, for example 1.34
And to add to this, I recommend checking out \`puts\` instead of \`printf\`. \`printf\` takes a format string as the first argument, and most of your strings are not format strings. It also has the bonus that you can skip the \`\\n\`-character :) 
Brace for very opinionated people yelling at you for even thinking about using C11 threads...
What's with all those wierd underscore characters in your sample code?
I didn't even realize Win32 had threads... That just saved me a ton of time. Thankfully is is a Windows only program. As for the opinionated people, guess I'll just have to let them yell. Thanks
I think he's trying to create a loop. for (p1money = 50; p1money || p1money != 100;) is in my opinion better as: p1money = 50; while(p1money!=0 || p1money!=100)
The C language parser automatically concatenates string constants together if they are next to each other. You can use that feature to do something like this: printf( "====================================================\n" "|LET'S PLAY ROCK, PAPER, AND SCISSORS WITH A TWIST!|\n" "====================================================\n" ); You might find that this lets you avoid typing `printf` so often without resorting to questionable macros.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
If you're using GCC, this is a good start: gcc -Werror -Wall -Wextra -pedantic Note that you definitely want to use `-Werror`, which turns warnings into errors. Most of the time in C you should consider warnings to be errors. Once you start to see what warnings the C compiler gives you, you'll be very happy about this.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
You already posted this [two weeks ago](https://www.reddit.com/r/C_Programming/comments/az7qmc/meson_project_templates/) and some time before that. While this subreddit has no rules against reposting, I think posting the very same project that often is not very interesting to our readers.
pthreads is a standard threading API. It's part of the POSIX standard.
I have been alerted, sorry for my mistake 
What is pedantic for? I use the 3 W's on a daily basis but im curious about pedantic
I am acutely on my way to clean them out now. Thanks for the tip. 
Done.
That's not what I meant; you are not fooling anyone by removing your old posts. What I mean is that you might want to turn down the rate at which you post the same project to maybe once every six months or so.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Sure thing I will only post every six months. However I did not mean to repost so soon it's just I am afraid that the post misleading to programmers from other community. Sorry for the miscommunication. 
It can also fail in interesting ways. For instance, if you do a ```int s=2;``` you’ll get a very confusing error message. Or if there is a struct somewhere with a « s » member...
As for fooling anyone it's not April fools day yet.
That's why I wrote it &amp;#x200B; The problem with that loop is, it's always true and won't break, he needs a &amp;&amp; between
I saw it just now: I think you don't really get the difference between &amp;&amp; and || &amp;#x200B; for(p1money=50;p1money!=0||p1money!=100;p1money+=0) If I'm not totally confused, that loop should be infinite &amp;#x200B;
When dealing with things like embedded file systems or streams, it may be helpful to have each "file" or stream maintain a latching error state, and have three kinds of function return values: success, transient failure, and latched failure, with "transient failure" only being an option for call that indicate that they are expected. Using this approach will make it possible to write code that performs a sequence of read or write requests and then check whether the sequence as a whole succeeded without having to check the results of individual operations. Note that it even if calls which could return transient failures would not latch failure conditions themselves, the return values should still distinguish latching and transient failures to ensure that loops that would retry operations in case of transient failures don't get stuck repeating endlessly because of an earlier latching failure. 
It enforces stricter adherence to the relevant C standard. I couldn't tell you exactly what warnings it gives.
Some people delete their old posts before reposting to pretend that they don't repost. That's not fooling me.
Maybe Op should code more and be a [nazi-loving holocaust denier](https://old.reddit.com/r/conspiracy/comments/b4kszy/holocaust_genocide_is_a_jewish_conspiracy_rudolf/) less.
Maybe Op should code more and be a [nazi-loving holocaust denier](https://old.reddit.com/r/conspiracy/comments/b4kszy/holocaust_genocide_is_a_jewish_conspiracy_rudolf/) less.
Holocaust deniers are logical; Jews have no proofs. Hence, I agree with them and dislike Jews bullying Nazi.
No, you do not allocate memory for the members of the struct. When you instantiate a struct, the struct itself consists of the memory used to hold the members of that struct. (ie. without padding, a struct that contains two `int`ss is the same size as two `int`s) If a member of the struct is a pointer, you might allocate memory that the pointer points to.
Oh, okay. Cool! Thank you very much!
[tinycthreads](https://github.com/tinycthread/tinycthread) implements C11 threads with POSIX or Win32 threads. There are also other pthread implementations for Windows too. I’d say use Win32 if you’re already using Win32 things like LWORD, etc. Otherwise C11 or pthreads may provide a nicer API to work with.
Oh shit, thanks for the heads up. I need a "This is a Nazi, don't give them help" bot.
The 2nd and 3rd will overflow on 32/64bit, so the behaviour is undefined 
actually you can write it like that : int *pointer_to_n; pointer_to_n = &amp;n; In c there is two steps, the declaration who tell the program which type of variable it is, here a pointer to an int and the initialization, here to stock the address of n in the pointer. Actually, if we were following your point of view we don't need to declarate the variables because the initialization will do the job. It's the case in python, but not in c
I think I'll stick with the Win32 for now. It isn't imperative that it works on other system besides Windows. That being said, I'll probably still play around with wrapping them in the pthreads API as suggested above. &amp;#x200B; Thanks.
So, it's a quirk in C language. int *pointer_to_n = &amp;n is like the summary of int *pointer_to_n; pointer_to_n = &amp;n
&gt; when saving a value (memory location) to \*pointer\_to\_n, it saves the memory location to pointer\_to\_n? No, it saves the value to the memory with the address in pointer\_to\_n
&gt; Shouldn't that be `int pointer_to_n = &amp;n` without the \*? Nope. What is `&amp;n`? Is it an `int`?* When you declare a variable in C it looks like: `&lt;type&gt; &lt;name&gt; [= &lt;initial value&gt;]` A variable of type `(int *)` is a "value that dereferences to an `int`", which you might also think of as a "a variable that can hold the address of an `int` variable". Pointers have to be (well, okay, SHOULD) be stored in variables that are declared as the same pointer type, or `(void *)` (AKA, "a pointer to some memory but I don't really know or care what it is"). *I guess depending on your compiler and platform, `int` and `uintptr_t`/`void *` might luckily happen to be the same type, but what if you were taking a pointer to a char or uint8? Or a float/double? Or a struct? They're not going to be the same size.
you should use pointer, not variable, but I believe compiler warned you about wrong assignment rectangle cube = (rectangle*) malloc(sizeof(rectangle)); // wrong rectangle *cube = (rectangle*) malloc(sizeof(rectangle)); // OK
You have to think of it like this: the * symbol has two different meanings. In variable declaration it means 'this variable is a pointer to whatever', when applying to an existing variable it means 'give me whatever this pointer variable points to'. The first line is a declaration that declares a pointer to an int it can at the same time be assigned. The second line is taking an existing variable and 'dereferencing' it with * operator which gives you whatever the pointer variable points to.
No, that gives me an error. prog.c: In function ‘main’: prog.c:9:20: warning: initialization makes integer from pointer without a cast [-Wint-conversion] int pointer_to_n = &amp;n; ^ prog.c:11:1: error: invalid type argument of unary ‘*’ (have ‘int’) *pointer_to_n = 5; ^~~~~~~~~~~~~ 
because you changed you original code. int \*pointer\_to\_n; to int pointer\_to\_n; Use pointer and my example will work.
Yeah, that's what I thought. 2 different meanings in that symbol.
Didn't quite understand that (I have almost 0 programming background). So, you are saying, when I declare a variable using int *, it makes sure that the memory location has an integer value which I want to use pointer to?
FYI this guy ^^^ is a massive antisemite. Check his profile, where he runs a holocaust denial sub.
Get fucked, retard.
Retard.
This Jew (he says he is a Jew. Whether he really is a Jew or Japanese or whatever, whatever, not my problem) pretends as if people are not supposed to be anti-Jewish. As if it is a crime. And he doesn't like it that his ancestors lied and made up fantasies to ruin the reputation of their enemy Nazi. History is about proofs.
Fuck you, you schizophrenic nazi asshole. Get AIDS.
Thank you for following up.
There are several things wrong. Start here insertCourseNode(pHead, ptr); You're passing the wrong type for the 1^st parameter and ptr will always be NULL
I haven't checked anything in your code but can you actually do fopen on a NULL pointer ?
I honestly couldn't tell you. 
&gt;If I say int pointer\_to\_n = &amp;n, then it doesn't specify what type of value I want to read from &amp;n by using \*pointer\_to\_n? \`int pointer\_to\_n\` says you want to declare a variable named \`pointer\_to\_n\` of type \`int\`. So it can only hold \`int\` values (on most platforms, 32-bit signed). \`&amp;n\` is of type \`(int \*)\` , a pointer-to-an-\`int\` or address-of-an-\`int\`. Those types are not the same. The memory address of a thing is not the same as the thing itself.
What should I pass in then? And so far my compiler hasn't given any warnings
It did, I should correct the post. Thanks :)
I downvoted you, but then... looked at that poster's comments. WTF.
&gt; I know this isn't a good post but I have tried looking up what I have done wrong and I can't find anything to help me out. Hey, at least you posted formatted code. Half the posts here can't even bother doing that much. The one thing you're missing is the input file. In `main`: allocateNode(); You call this function, but never use the result. This is a memory leak. (But not the cause of your problems.) void insertCourseNode(CourseNode **pHead, CourseNode *ptr) Why are you passing `ptr` to this function? That should just be a local variable instead. (But still not the cause of your problems.) insertCourseNode(pHead, ptr); Your compiler should be giving you a warning here. If not, up the warning level until it does. You should be passing `&amp;pHead`. This could be causing you a problem. char *pszCourseFileName = NULL; pFileCourses = fopen(pszCourseFileName, "r"); And here we have a serious issue: what file should it be opening? You never gave it a file name. This is guaranteed to be a problem.
pHead is a CourseNode \*, while the function takes a CourseNode \*\* (which makes sense, you want to be able to modify pHead's pointing address). Call insertCourseNode(&amp;pHead, ptr) I'm not sure what else is wrong, but that was obvious to me. Also, I was just curious enough to compile it and I got a ton of errors. Are your makefile or project options suppressing errors?
No, you can't. You need to fix this before looking at the line I said you should start at.
Not being a Holocaust denier for fun. History is about proofs. Holocaust deniers are logical while Jews don't have any other proof than "Jewish witnesses saw the entire concentration camps and Nazi documents ordering so". It's ridiculous. (The other account got suspended for denying Holocaust.)
Yeah no kidding. /u/khalkhapolarbear is an untreated schizophrenic who doesn't understand any subtlety and thinks all Jews lied about the holocaust because the gate at Auschwitz said "work sets you free" and nothing about death. He's dumb as bricks.
`&amp;pHead`
Thank you so much! The problem was fixed by passing &amp;pHead instead of just pHead. And sorry about the file it's referencing, I didn't paste the code that allows for me to pass a file with command line arguments, I only wanted to put the necessary code to make it easier to debug. 
No, Jews lied about the Holocaust because there is no official Nazi documents (including Final Solution) ordering killing Jews but only deporting Jews. Also, Hitler made a speech AFTER Final Solution that he wants to deport Jews. Also, Himmler ordered concentration camps not to kill Jews AFTER Final Solution. I understand subtlety fine (the fields I have background knowledge on). Objectively, Jews are lying about Holocaust genocide. Some rogue Nazi officers killing Jews voluntarily doesn't represent all concentration camps nor Nazi's central order. Holocaust deniers are logical. I reject all Jews; Jews are not likable.
Ah I see it's your alt. Eat shit and die.
I would point you at https://en.m.wikipedia.org/wiki/Criticism_of_Holocaust_denial , but if you’re flatly denying first hand accounts of survivors of concentration camps I’m not sure what evidence you *would* consider.
And what fancy fucking ethnicity are you? How would you like it if someone shat on your people?
The SUM example you gave is an expression and has no problems. The problem with the ERROR_RETURN example is it's a statement, not an expression. Imagine if you had something like: if (x &lt; 5) ERROR_RETURN(10); else do_something_else(); Which, after macro expansion, becomes: if (x &lt; 5) { if (10) return -1; }; else do_something_else(); The problem is that semicolon after the closing curly brace. That semicolon causes a syntax error during compilation. That semicolon is the entire reason why the do-while(0) idiom flourished.
Put your version into a conditional and you'll get a compiler error: if ( some_test ) ERROR_RETURN(true); else ERROR_RETURN(false); The problem is that semicolon. Your version only works if the user is told to not use a semicolon after it (which looks weird) or by always adding braces (not a terrible idea anyway). But the do/while trick avoids any such caveats. You can also write it this way: #define ERROR_RETURN(CODE) \ if ( CODE ) return -1; \ else (void)0 This will have the same effect. Or, more generally for multi-line macros: #define ERROR_RETURN(CODE) \ if ( 1 ) { \ if ( CODE ) return -1; \ } else (void)0 But the do/while version is more popular in my experience. It's easier to prove to yourself that it always works and doesn't have interactions with nested conditionals.
Survivors can only speak for their own experience, not for all concentration camps nor official Nazi's order. Also, the fact that there are survivors says that they are bullshit. Official Nazi documents did not order killing. It's ridiculous to claim that they intentionally avoided using the word killing while ordering to kill Jews because they were counting on other countries reading them. https://en.wikipedia.org/wiki/David_Irving https://en.wikipedia.org/wiki/Category:American_Holocaust_deniers Many people deny Holocaust genocide for a reason. 
I'm Korean. Someone shat on your people? Jews deserve the reputation of liars. You are just bullying Nazi with made up nonsense.
Ah, this makes a lot of sense. Thank you for the answer
Cool. Let's talk about the habit of eating cats and whatever the fuck Juche is. Also that spycams in hotels expose was pretty funny. Why do you eat cats?
I hope Kim Jong Un attacks your house and puts you in a camp.
There’s actually a whole discussion of that, in the section that starts: &gt; Historians have documented evidence that as Germany's defeat became imminent and the Nazi leaders realized they would most likely be captured and brought to trial, great effort was made to destroy all evidence of mass extermination. ...
Yeah, Jews claim that. That's a wishful thinking, not a "proof" why they have no proof. Like I said, there are many Holocaust genocide deniers (not denying the entire holocaust but only the genocide part) for a reason.
I'm trying to see if an array szCourseId exists in a linked list that contains multiple CourseId's. How would I iterate through a linked list and compare each node to see if it matches? This is what I have so far, it compiles with no errors but it doesn't work. 270 for(k = 0; k &lt; 50; k++) 271 { 272 while(ptr != NULL) 273 { 274 if (strcmp(ptr-&gt;course.szCourseId, courseRequest.szCourseId) == 0) 275 { 276 printf("\t%s\n", courseRequest.szCourseId); 277 } 278 ptr=ptr-&gt;pNext; 279 } 280 } &amp;#x200B;
That was a wrong condition. Thanks for noticing. I couldn’t get out of the loop because of that.
Depending on what compilers you need to support, you might want to look into the GNU extension "[Statement Expressions](https://gcc.gnu.org/onlinedocs/gcc-3.2.3/gcc/Statement-Exprs.html)" as well. `do {} while (0)` is more universal, but these are just so nice for macros, and allow for local variables!
Yeah i couldn’t get out of the loop and just replaced the for loop with a do while(p1money&gt;0||&lt;p1money&lt;100) I still don’t get why the for loop becomes an infinite loop though. 
Uh... so, normally, stuff like eyewitness testimony of victims and people who took part in crimes admitting it under oath at trial is considered “proof”. There’s healthy skepticism and then there’s ignoring all the evidence because you don’t like the conclusion it leads you to. From that same link: &gt; In the spring of 1942, Heinrich Himmler ordered all traces of murdered Russian Jews and prisoners of war to be removed from occupied territories of the Soviet Union.[23] As one of many examples, the bodies of the 25,000 mostly Latvian Jews whom Friedrich Jeckeln and the soldiers under his command had shot at Rumbula (near Riga) in late 1941 were dug up and burned in 1943.[24] &gt;In mid-1942, SS-Obergruppenführer Reinhard Heydrich, through SS-Gruppenführer Heinrich Mueller, Chief of the Gestapo, ordered SS-Standartenführer Paul Blobel in Sonderaktion 1005 to remove all traces of the mass executions in the East carried out by the Einsatzgruppen. After Blobel and his staff developed a special incineration process, destruction of evidence at Belzec and Sobibor followed in late 1942.[23] In February 1943, Heinrich Himmler personally visited Treblinka and ordered the commandants to destroy records, crematoria, and other signs of mass extermination.[23] With the links following back to documented sources.
The outer loop makes no sense. Once the inner loop finished because `ptr == null`, since nothing resets `ptr`, doing it again will not help. 
I will ask those to deniers. But probably a distortion in translations as usual. (It happened many times including Final Solution document.) Also, there were dead Jews at the concentration camps. (No one denies that.) They were just killed by rogue Nazi officers voluntarily or by diseases (no central order by Nazi). I doubt Nazi put in any effort to destroy "evidences". If they put in any effort to destroy something, it was probably something else, not evidences. But I will ask around. There's a community called CODOH devoted to this.
Try this. 1. Write a "printf("%s\\t%s\\n", ptr-&gt;course.szCourseId , courseRequest.szCourseId);" online 273 just inside the brace and check the output. 2. You say it compiles with no errors. How about warnings?
Is this rust? /s I'll check it out, thanks!
Not related to your question, but do the author really recommend putting return statements in macros like that? I would argue it is considered bad practice by many, including me. Horrible to debug etc.
&gt; They were just killed by rogue Nazi officers voluntarily or by diseases (no central order by Nazi). There’s a whole bunch more linked off there specifically about testimony of German officers saying they were told by their commanding officers to do exactly that. Go read the sources. &gt; I doubt Nazi put in any effort to destroy "evidences". If they put in any effort to destroy something, it was probably something else, not the evidences of massively killing Jews. That’s... exactly what I just pasted above. Orders to cover up the killing of prisoners. Go read the sources. &gt; Also, if "evidences" were destroyed, there's no evidence anyway. "Destroying evidence" is not a proof for Jewish claims. Well, when you have millions of civilians that went missing, thousands of people saying they saw mass killings happen, soldiers admitting they did it, and officers saying they were told not to keep records and to destroy the evidence... at some point you might start to think there’s something to all this, right?
&gt;printf("%s\\t%s\\n", ptr-&gt;course.szCourseId , courseRequest.szCourseId); When I ran the code I got a repeating error cs1713p3.c: In function ‘processRegistrations’: cs1713p3.c:273:37: error: ‘(Course *)&amp;ptr-&gt;course’ is a pointer; did you mean to use ‘-&gt;’? { printf("%s\t%s\n", ptr-&gt;course.szCourseId , courseRequest.szCourseId); ^ -&gt; I don't know if I want to reset it (sorry I'm still new with this stuff). All I want to do is just iterate through the linked list and see if the szCourseId exist in any of the nodes. I also updated my main post to show the function that this code is in to give you better context especially with the error. 
So I need to reset ptr?
If there is an error here, did you see any warnings while compilation previously without my printf? 
Okay sorry about that. I ended up getting an error due to me switching from laptop to desktop and I didn't update my .h file. I ran your code and it compiled and ran but didn't print anything (from your printf statement). &amp;#x200B;
Again I'm sorry, I am new to pointers and linked lists so I might even be passing the wrong pointer because I have multiple pointers. I put up a post a little earlier about a problem I was having and posted pretty much the rest of my code [here](https://www.reddit.com/r/C_Programming/comments/b5hl5z/i_have_been_working_with_linked_lists_and_only/).
I don't think the author recommends it, although he doesn't recommend against it either. All they say is to make control structures in macros explicit. &amp;#x200B; I tend to agree with your argument though, and personally wouldn't write a macro like this.
Can you show how you are calling this function? Your other code does not mention the function. &amp;#x200B;
In main I put `processRegistrations(ptr);`
If your code is exactly just that, then it won't work because you initialized `ptr` to NULL and never updated it. 
Did you see my other post that I linked to you in a reply? (not being a smart ass I just want to know if you did). If not [here](https://www.reddit.com/r/C_Programming/comments/b5hl5z/i_have_been_working_with_linked_lists_and_only/) it is again. I took ptr and assigned it to some variables in the function `void insertCourseNode(CourseNode **pHead, CourseNode *ptr)` &amp;#x200B; I don't know if that makes a difference or not.
I figured out how to do it now. I just used this loop CourseNode* current = pHead; // Initialize current while (current != NULL) { if (strcmp(current-&gt;course.szCourseId, courseRequest.szCourseId) == 0) printf("%s\n", courseRequest.szCourseId); current = current-&gt;pNext; } &amp;#x200B; But I have another question (I'm sorry for bombarding you with these questions). Do you know how to alter a node, specifically one that stores an integer?
&gt; I figured out how to do it now. Good. &gt; Do you know how to alter a node, specifically one that stores an integer? Sure. If you want to set iAvailSeats to a variable var, you could do the following in the above loop. current-&gt;iAvailSeats = var; Also, I have a recommendation. Change void insertCourseNode(CourseNode **pHead, CourseNode *ptr) to void insertCourseNode(CourseNode **ppHead, CourseNode *ptr) You will find it easier to use the variables in the functions.
At least it has return in the name.
&gt;The SUM example you gave is an expression and has no problems. What, but shouldn't actually be written: #define SUM(A, B) ((A) + (B)) ?
Maybe Op should code more and be a [nazi-loving holocaust denier](https://old.reddit.com/r/conspiracy/comments/b4kszy/holocaust_genocide_is_a_jewish_conspiracy_rudolf/) less.
Ok but why would anyone do that?
Maybe Op should code more and be a [nazi-loving holocaust denier](https://old.reddit.com/r/conspiracy/comments/b4kszy/holocaust_genocide_is_a_jewish_conspiracy_rudolf/) less.
Maybe Op should code more and be a [nazi-loving holocaust denier](https://old.reddit.com/r/conspiracy/comments/b4kszy/holocaust_genocide_is_a_jewish_conspiracy_rudolf/) less.
Maybe Op should code more and be a [nazi-loving holocaust denier](https://old.reddit.com/r/conspiracy/comments/b4kszy/holocaust_genocide_is_a_jewish_conspiracy_rudolf/) less.
Yes, you're right. There are a couple things lower on the order of precedence totem pole that could mess things up. E.g., `SUM(x &lt; 2, y &lt; 3)` would expand out to `x &lt; 2 + y &lt; 3`, which would not be right. You should have parentheses around (A) and (B). Good catch.
I had the same thought, but I'm having trouble finding an example to demonstrate the difference. I think it's because + has such a low priority. Now, these two are not equivalent #define PROD(A, B) (A * B) #define PROD(A, B) ((A) * (B)) Just try `PROD(2+3, 3+1)` to see the difference. 
&gt;There are a couple things lower on the order of precedence totem pole Yup! &lt;&lt;, &gt;&gt;, &lt;, &lt;=, &gt;, &gt;=, ==, !=, &amp;, \^, |, &amp;&amp;, ||, ?:, and 11 assignment operators. It's kind of amazing how many!
&gt;but I'm having trouble finding an example to demonstrate the difference The examples I gave above with &amp; and ?: both demonstrate the difference. Also anything with &lt;&lt;, &gt;&gt;, &lt;, &lt;=, &gt;, &gt;=, ==, !=, &amp;, \^, |, &amp;&amp;, ||, ?:, and the 11 assignment operators will demonstrate the difference.
Yeah, I didn't bother to pull up a reference. Great answer! 
Given I'm not a C guy and mostly lurk here, couldn't you just shrink it to `if(code) return -1` and then you don't have the problem of a dangling semicolon?
Might be loop-&gt;course.iAvailSeats = loop-&gt;course.iAvailSeats; or loop-&gt;course.iAvailSeats--;
What do you mean by “similar?” I think C# shares way more in common with Java, and think it’s a world apart C. There are a couple attributes that languages have—strictly vs loosely typed, compiled vs. interpreted, object-oriented vs functional, etc. Comparing those different attributes might help you find languages similar to each other.
C++, why?
Unfortunately then you have the dangling-else problem. if (x &lt; 5) if (10) return -1; else do_something_else(); This will not give a syntax-error, but it will do the wrong thing. In this case, `do_something_else()` can never happen due to how the ifs are nested.
lets make the loop simpler: &amp;#x200B; infinite loop: for (i = 0; i != 0 || i != 100; i++) It reads: i shouldn't be 0 OR shouldn't be 100 But it won't break if one side is not true, because no matter what integer it is, the other side is always true &amp;#x200B; for example with 0 for (i = 0; 0 != 0 /* false */ || 0 != 100 /* true */; i++) &amp;#x200B; Not infinite: for (i = 0; i != 0 &amp;&amp; i != 100; i++) It read: i shouldn't be 0 AND shouldn't be 100 &amp;#x200B; #include &lt;stdio.h&gt; int main() { for (int i = 0; i != 0 || i != 100; i++) { printf("%i\n", i); if (i == 101) break; } return 0; } Here's some code to proof my point, it'll printf 0 to 101 before it breaks.
 allocateNode(); It returns a pointer, but you don't use it &amp;#x200B; insertCourseNode(pHead, ptr); void insertCourseNode(CourseNode **pHead, CourseNode *ptr); pHead is a (CourseNode \*) but you try to fit it in (CourseNode \*\*)
The C++ standard library is almost literally a superset of the C standard library (http://www.cplusplus.com/reference/clibrary/). The C language is pretty close to being a subset of the C++ language as well. They are still totally different languages. There is no such relationship with C#.
++ # is only vaguely similar
I get it now. I still have a lot to learn. Thank you
C++, obviously. C# Microsoft's Java, just a bit better. 
As of C#7, the unsafe keyword lets you do anything in C# that you can do in C. So, they are not as far apart as you think.
Keep in mind this is a subreddit for C, not C#. That aside, I've found Code Wars to be a fun way to pass the time and practice random coding problems.
The same homework question as I saw here the other day!!
So does being able to use the FFI of language X to access C imply that language X is not that far from C?
I will have to google that... I don't think I have ever heard of it.
Not a syntax error, but it should give a compiler warning/error unless somebody is ninjaing around without all warnings turned on.
timing-strict, such as embedded systems, don't want a delay between performing repetitive tasks. Calling a function, passing its parameters, and returning cause delays 
That makes sense. With low frequency processors this delay will be even more significant and may affect timing constraints.
This is no longer true since the existence of function inlining. static inline functions behave completely identical to macros from a performance perspective. Some other things that can be achieved with macros can't be achieved with inline functions however: * Return from the function * Get access to the function name/line number (ASSERT etc) * Macro that accepts multiple types and calls a different function depending on the type There are more valid use cases to use macros, performance should no longer be one since C99. 
&gt; it should give a compiler warning/error Why?
In the comments, you mentioned making init() more concise, how about for (size_t i = 0; i &lt;= 360; ++i) { if (i &lt;= 90) lookup_table[i] = taylorseries_(deg_to_rad(i)); else if (i &lt;= 180) lookup_table[i] = lookup_table[180 - i]; else lookup_table[i] = -lookup_table[i - 180]; } But cachewise, is it really good to replicate the information 4 (or 8 times in fact) ? Folding the angle to first quadrant or octant in sin\_() could be more efficient. I didn't try it in practise, though.
No, it's perfectly consistent: `int *pointer_to_n` means “`*pointer_to_n` is an `int`”.
I mean, you just did.
You should also drop the cast and use the size of the object you're allocating rather than the size of its type: rectangle *cube = malloc(sizeof(*cube)); Otherwise you're needlessly repeating the same information three times and increasing the amount of work required (and the possibility of errors) if you decide to change the type of `cube`.
&gt; Can someone elaborate on this as to why a function call needs to be avoided sometimes? Just a guess: #include &lt;stdio.h&gt; #define SUM(a, b) (a + b) int sum(int a, int b) { return a + b; } int main() { int a, b; for (a = 0, b = 10000; a != 10000; a++, b -= a % 100) printf("%i\n", sum(a, b)); for (a = 0, b = 10000; a != 10000; a++, b -= a % 100) printf("%i\n", SUM(a, b)); return 0; } Without any compiler optimization, the macro should be faster, because everything gets done while compile time (or am I wrong)? The function has to pass two int and has to return one and passing data should take some time.
Well, I use multi-line macros very seldom if I need some kind of very rudimentary template engine. So when I need to write a function twice where just the type is different, I consider that. But this comes with severe drawbacks regarding readability and debugging. I second @heknar that performance is not anymore a reason for for using those multi-line macros. Modern C compilers inline quite aggressively.
A compiler can detect that the meaning of 'else' is *possibly* ambiguous because of the lack of parentheses when the macro is expanded. On GCC you get this warning with `-Wparentheses` (part of `-Wall`). With warnings set to errors you'd get an error (that can be annotated away if it's wrong).
If you're concerned with performance, why would you be building with optimizations disabled? 
It's not an FFI. This is direct language support. Raw pointers and function pointers, for example, are available.
I've been playing with this on train journeys in the morning (so I may not be at my sharpest), and while there is (very) formal documentation, there are very few online examples which you can use to get going quickly. Even as a kdb+ programmer, it's pre/post/on-each operator syntax is ... uncommon. I couldn't find any easily accessible documentation about `fnext`, `fexec` and `fgoto`: its man page has a few lines for each but there wasn't a CompSci prof around to explain it LI5. I imagine that quite a few users will be interested in how to use it for non-regular languages (e.g. recursive structures), but a clear example of how to do that with state charts is elusive. The docs describe having to preserve state between invocations if you're working on streaming data, but the closest I've got to nailing down exactly what needs doing where, is a pithy three-line comment on the mailing list. If I had had time to read the docs completely I would probably not be writing this, agreed. I like the tool, am happy to persevere, but it's hard going.
The function and macro is too simple... that's why I said "without optimization". The compiler would built exactly the same code with them. &amp;#x200B; See my example as theory, because I kept it simple that everybody is able to read it without taking 5 minutes of their time
Ah okay - so can you describe how it differs from [the NativeCall functionality in Perl6](https://docs.perl6.org/language/nativecall), which provides access to [pointers](https://docs.perl6.org/language/nativecall#Basic_use_of_pointers) and [function pointers](https://docs.perl6.org/language/nativecall#Function_pointers)?
C# is off topic in this subreddit. Please post C# questions to /r/csharp instead.
Keep politics out of this subreddit. This is your first and final warning.
I don't care what people do in other subreddits as long as they keep it out of this one. This is not a political subreddit and I'd like to keep it this way.
? I don't know anything about Perl man. I'm telling you that if you use the keyword \`unsafe\` you can use raw pointers and declare function pointers just like in C. I don't understand why you're putting the burden of proof on me, or whatever. You can google it.
Because you made the claim that being able to work with pointers and function pointers brings a language closer to C. Perl6's NativeCall functionality includes working with pointers and function pointers, but i don't feel that somehow brings Perl6 closer to C. (And i don't think that Java, for example, would be brought closer to C in any substantial way by the addition of an equivalent to C#'s `unsafe`.)
Wherever you're dealing with strings, you're not allocating memory to hold the string itself, you're just setting a `char*` equal to wherever you're *temporarily* storing that value (ie on the stack). Memory on the stack can only be relied upon within the enclosure that it was defined -- generally speaking, within it's function. If you want a value to persist beyond the function, you must allocate it to the heap.
&gt; Can someone elaborate on this as to why a function call needs to be avoided sometimes? If you're in a hot loop function call overhead can be quite sigificant. For example I've seen it used to implement a Duff's device for surface blending in a graphics library. But that old pre C99 code. In new code don't do it unless you have a good reason to. **If in doubt, run benchmarks**. I can't stess this enough. Especially embedded compilers might stilll benefit from that.
This book popped up on the current Humble Bundle. Not having seen it before, I of course came to Reddit to see what people think of it. Anyway, it's there for $20 if anyone's interested - and you also get a whole slew of other books that look interesting. https://www.humblebundle.com/books/coders-bookshelf-books?linkID=&amp;mcID=102:5c917d0eddb8293c0c0b68bd:ot:56c3e63a733462ca89426d12:1&amp;utm_source=Humble+Bundle+Newsletter&amp;utm_medium=email&amp;utm_campaign=2019_03_25_codersbookshelf_bookbundle&amp;linkID=&amp;utm_content=cta_button
Of course, you're right. But, at least in my mind, that's a fairly advanced check. I would imagine some of the less sophisticated compilers (e.g. for a micro controller) would not have that warning. I can also see some older, kind of sloppy, code having to be compiled without `-Wall` because of the number of false positives. I'm a huge fan of, whenever feasible, writing code that *doesn't* trigger a warning. Especially if it will come at a very small cost. 
Very lambda-esque. It's interesting that "Statement expressions are not supported fully in G++". 
Try using `-Os` in your compiler flags; this flag optimizes for size. This works for both clang and gcc. You may need to disable any other optimization flags (`-O3` in particular). Clang also has an additional `-Oz` flag.
What is the output of arm-none-eabi-size on the binary? If the link step doesn't fail, and assuming you are using an ld file for your target memory sizes, then it will fit. Alternatively, run V=99 to see what got garbage collected. You might try using lto (-flto passed to compile and link steps), but it doesn't normally reduce size that much.
First off, you may be better of making this a new post so more people can see it. I only came by to see if there were any new responses since I replied yesterday. Include all of your code in the new post. For one thing, you don't want a `for` loop around your `while` statement. This makes the search run 50 times, and it will fail at least 49 times since it reaches the end after the first iteration and isn't reset (`ptr` becomes `NULL` after the first run and stays `NULL`). It might fail all 50 times if there's no `ptr = pHead` before the while loop starts. Is `ptr` already `NULL`? Otherwise the while loop and string comparison look OK.
The library is basically one C file: https://github.com/Derecho/stm32-hd44780/blob/master/hd44780/hd44780.c. From experience I would say that compiles down to a kilobyte or two. Don't worry about the size of the elf file, which has all kinds of debugging information added in. You can use arm-non-eabi-size to see the actual binary size. arm-none-eabi-objcopy will extract a bin or hex file from the elf file, should you need to do so. But good tools will let you work with the elf directly.
Statement expressions were included very early in gcc, if not in the initial versions, and IMHO are something that should have been included in C99. Given something like `someVariadicFunction(whatever, ({int q[4]; ... (someStruct){ [initialization involving q] }));` a compiler would ideally place `q` deeper on the stack than the space that would be needed for the structure that would be passed to the variadic function, but a one-shot compiler would have to compute a stack- or frame-relative address for `q` before it could knowing how much space would be required for the value generated by the statement expression. Even those situations, however, could be accommodated by having the compiler allocate `q` on top of the stack, and then later create space for a `someStruct` temporary object deeper on the stack, populate it, and copy it to the storage that had been used by `q` when evaluation of the statement expression is complete. Incidentally, on a broader note I find it somewhat sad that the preprocessor language of C has historically proven just barely capable enough to escape efforts to improve it and eliminate the need for so many bodges. While it can be useful to have function-like macros that are able to interact with the invocation scope in ways that inline functions cannot, it would be much more useful to have a macro feature within the compiler proper that could understand and respect scope and could evaluate expressions. It would also be helpful to allow some limited looping structures within macros. *NOT* Turing complete, but sufficient to allow many kinds of static const data tables to be populated at compile time. If a program is running from RAM, it may be more efficient to say e.g. uint16_t myArray[256]; void init_myArray(void) { for (int i=0; i&lt;256; i++) myArray[i] = (i &amp; 1) + (i &amp; 2)*2 + (i &amp; 4)*4 + (i &amp; 8)*8 + (i &amp; 16)*16 + (i &amp; 32)*32 + (i &amp; 64)*64 + (i &amp; 128)*128u; } than it would be to use a `static const` array which is populated at compile time, but in most embedded systems read-only storage is more plentiful than RAM, so moving tables whose values will never change into read-only storage will free up precious RAM for other things. While there are some really nasty ways to accomplish such things by writing a macro which compute 4 values, one which uses the previous macro 4 times to produce 16 values, one which uses that 4 times to produce 64, and one which uses that 4 times to produce 256, that's an excessively severe bodge. 
An ELF file typically contains a lot of information beyond the code that needs to go into a device. For example, it will often contain the names and addresses of all the non-static objects and functions used in your program. Attempting to program an ELF file into a device with a program that doesn't understand how to extract the relevant parts of the file isn't likely to work usefully even if the ELF file is small enough to "fit". I would expect that whatever build tools you're using should either have an option to generate a .hex or .bin file directly, or include a tool which can take an ELF file in which all addresses have been resolved and produce a .hex or .bin file from that. &amp;#x200B;
You mean the macros of *st* that handle argv ? It looks like the particular programmer just used those as a habit.
We use Apache for something similar to you, and regret doing so.
Empty lines cause trouble, (strlen() - 2) and also make the process replicate itself.
Just the one time not again, A new post every six months seems like a good idea thanks.
Maybe, but I just thought that there is something more to this than just a old habit.
Compilers designed to be suitable for low-level programming can generally be configured to offer semantic guarantees beyond those mandated by the Standard. For example, given something like: extern volatile * volatile ser_buffptr; extern volatile ser_buffcount; int ser_output_busy(void) { return ser_buffcount; } void start_ser_output(void *buff, uint32_t buffsize) { if (ser_output_busy()) FATAL_ERROR(); ser_buffptr = buff; ser_buffcount = buffsize; } void test(void) { unsigned char mybuff[17]; while(ser_output_busy()) {} for (int i=0; i&lt;10; i++) { myBuff[0] = i; getDataSomehow(myBuff+1, i); start_ser_output(myBuff,17); while(ser_output_busy()); } } the Standard has never defined any practical syntax(*) to demand that each write to `myBuff[0]` be performed between the previous access to `ser_buffcount` and the next access to `ser_buffptr`, but since the Standard has always allowed implementations to guarantee such semantics should they see fit to do so, many implementations have neither defined nor required the use of a special syntax to achieve such semantics. Some optimizing compilers such as MSVC can be configured (e.g. via "-volatile:ms" option) to support such code with optimizations enabled, without needing special syntax. Others like gcc can only be configured to support such code either by disabling in-lining of functions or by disabling optimizations altogether, with the former option generally being much less expensive. (*) Declaring `volatile mybuff[17];` would make it necessary to also create an additional buffer which isn't qualified `volatile`, pass that to `getDataSomehow`, and then copy that a byte at a time to `mybuff` without using `memcpy` (which doesn't work with `volatile` arguments). While that wouldn't be entirely impossible, I wouldn't exactly call it "practical" either. Note also that even if code were to precede each call to `start_ser_output` with a call to a dummy function whose address is stored in a `(void *volatile)(void)`, a clever compiler that knows that `getDataSomehow` doesn't access any `volatile` objects and that repeated calls won't have any effect could still legitimately replace the function with something like: for (int i=0; i&lt;100; i++) { (void*)(void) func = dummy_func_ptr; if (func != func_that_does_nothing) { myBuff[0] = i; getDataSomehow(myBuff+1, i); } if (ser_buffcount) FATAL_ERROR(); ser_buffptr = buff; while(ser_buffcount) {}; } A proper solution would be to define a standard intrinsic that would behave as a call to a function which would be synchronize the states of the abstract and physical machines in the same way as would be required when calling to function the compiler knows nothing about, but which need not generate an actual function-call instruction. Reliance upon such semantics without the intrinsic could then be deprecated at the same time as the Standard recommended that implementations provide a means of supporting such code until it can be adjusted to use the new intrinsic. Unless or until the Standard does such a thing, I don't see code which requires the use of a compiler-specific syntax as being any more portable than code which requires the use of command-line options that most compilers will support, even if inefficiently. 
If you're asking what OTHER languages are like C, C# and C++, then Go might be close. It's written by the same people who developed C.
With regard to your last paragraph, if the only thing that matters about a program's behavior when it's given invalid data is that it refrain from doing anything harmful, does it make more sense to try to generate test cases for every form of invalid data the program might receive, or would be more useful to be able to focus on computations that are used to compute memory addresses or control the boundary conditions of loops that compute addresses incrementally, without having to worry about computations that are never used for such purposes? Suppose a function accepts an `uint64_t` and computes a value `y` which does not exceed 57 for any known input, but could theoretically get as large as 255. Code then performs: uint32_t test(uint64_t x) { uint8_t y=mystery_function(x); if (y != 247) launch_missiles_if_argument_is_247(y); return y*y*y*y; } Short of testing the function with all 1,85E+19 values of `x`, how would you suggest using UBSan to detect the possibility of some input causing `launch_missiles_if_argument_is_247` to be invoked with an argument of 247? 
Just curious, but may I ask why you regret doing so? I'm curious to hear your experience.
&gt; One reason I have heard is to avoid function call overhead. Can someone elaborate on this as to why a function call needs to be avoided sometimes? That's a shitty reason. Compilers are better at doing this than programmers are. For the most part, the only reason worth using multiline macros is to do C++ things without using C++. e.g. people have mentioned making function templates via macros. 
&gt; if the only thing that matters about a program's behavior when it's given invalid data is that it refrain from doing anything harmful This sounds good to me - it's how Erlang and Swift work. No safe behavior is specified for "undefined" behavior and instead the program crashes. No exception handlers either. There's reasonable objections if your program has no side effects, you somehow don't mind wrong behavior, or you just can't update the program after shipping it. In that case you'd want it to make something up and stay up at all costs. But I think that just turning on `-fwrapv` Java-style is not a good answer, because nobody actually wants integer overflow. If you calculate the wrong array index because overflow created a wrong but safe value, it could corrupt the user's data. &gt; Short of testing the function with all 1,85E+19 values of x, how would you suggest using UBSan to detect the possibility of some input causing launch_missiles_if_argument_is_247 to be invoked with an argument of 247? Statically: turn it on, compile and disassemble your program, and see if there are any crash instructions. Dynamically: yeah, you have to actually run it. Advanced fuzzers will help, like AFL, because they'll actually read your program and invent inputs to try to reach the crash. Obviously this one "may" fail, so it's not statically safe, but it also may not fail. It also may not terminate (if `mystery_function` is an infinite loop) or it may end the program (if `mystery_function` is `exit`). Btw, your launch missiles example exists in gcc/clang as `__builtin_unreachable()` - it just produces "undefined behavior" and you can use it to tell the optimizer that this code path won't happen. There's also `__builtin_trap()` for a lightweight instant crash.
Do you have some other struct or variable named "Course" that's not shown here? on line 8 or 9 you have Course.iAvailSeats - 1; it looks like that should be loop-&gt;course.iAvailSeats instead.
try a switch statement?
I mostly agree with what's already said, but thought I'd add my two cents to this conversation anyway. The most important reason boils down to legacy code and old compilers. There was a time when compilers were bad at optimizing code -- either it didn't optimize at all, or the optimizer was buggy (changing the semantics of the code), or it made very poor choices for optimization. So programmers took this into their own hands. The relevant optimization here is inlining. Functions are handy as an organizational tool, but there's a slight overhead to each function call you make. Registers have to be saved off and restored, stack pointers have to be manipulated, instructions to jump and return, the instruction cache probably doesn't have that function, and there are missed optimization opportunities that might only happen if the code is inlined. By defining a macro instead of a function, you're forcing the compiler to inline that bit of code, reducing that overhead. This became a common practice, when a programmer thought the compiler needed some help. Sometimes things went a bit overboard, though. You generally only want to inline "small" functions, and the size of the function you inline into matters as well. And if your code ends up sticking around for a few years, technology can change what the right decision. It ends up that compilers are generally better at deciding when to inline. C99 introduced the `inline` keyword to help. This lets you define a function in multiple translation units so the compiler can inline it if it wants. The keyword can sometimes serve as a hint that it should be inlined, but compilers take other factors into account (such as the number and type of instructions in the function). While 1999 seems like a long time ago, many programmers are still using C90. Maybe because they can't upgrade their compiler, or their compiler doesn't have a C99 version. Some have C99 or even C11, but don't know about this feature (C has a boolean type, but nobody seems to know about it...). Or they (mistakenly) think they know better than the compiler and inline the code themselves. Or they know about the new feature, but haven't refactored their code to use it (common with legacy code). And so multi-line macros persist. There are other reasons for multi-line macros, though. Some macros do things you can't do in a separate function, like declare variables that can be used in that function, `break` or `return` from the enclosing scope, etc. Not that these are necessarily *good* things to do, but they do this. Also, macros are an easy way to make generic functions that work with multiple data types. The `_Generic` keyword deals with most of the cases when you'd want to do this, but not all (and not everything has been converted that could use it; see above for reasons why).
It doesn't make sense. Realtime systems need to be predictable, not fast. Anything as fine as long as it's always the same. Also, function calls don't have overhead in any reasonable optimizing system, and forcibly embedding more code in the same function could be slower with a bad compiler. For instance the stack space could be too much, and some JITs like C# won't optimize a large function.
Look at OPs post history
Nondescriptive title! Post some code and some context -- we're not flipping psychics...
As others have said, the biggest remaining reason is type-independence (e.g. generic programming, or template programming). The Linux kernel uses macros for some of its data structures for this very reason. See [this page](https://kernelnewbies.org/FAQ/LinkedLists) for an interesting description of how it's used. 
TIL that I don't have good tools. STM32 toolchain+documentation sucks in linux. 
gdb works fine for that.
Hence all the removed comments....
&gt; Can anybody help me? Maybe.
Doesn't something like: *((volatile unsigned char*)(&amp;(myBuff[0]))) = i; do that? A write through a volatile pointer should have to be resolved before the next sequence point (the call to `getDataSomehow()`) whether or not the code is inlined, shouldn't it?
We might be able to help you...But based on what you describe (Printing a word based on dial location), you can do it how you describe (with if statements) or use switch. &amp;#x200B; There is no magic single line of code to monitor an analog signal and perform 25 different functions without having 25 different code routes.
Programmers and compilers know different things. Compilers often know more than programmers about the relative costs of doing different things different ways, but programmers often know more about compilers about what a program will need to do and how often. The attitude that "the compiler knows more than the programmer" goes against the Spirit of C described by the authors of the Standard (whose first principle is "trust the programmer") and overlooks the fact that programmers often know things that compilers can't. To be sure, letting compilers make decisions that would be appropriate for "typical" inputs is often more convenient than examining every such decision personally, but in situations where it would be obvious to a programmer that inline-expanding a piece of code would be the right thing to do (e.g. because large parts of it will collapse out as constants), but it might not be obvious to a compiler, it seems rather condescending to suggest that programmers would be mistaken in thinking they know better than compilers. 
Create a ring buffer of chars and move a pointer around it when the encoder is incremented/decremented.
One could add a `volatile` qualifier to the write to `myBuff[0]`, but the same problem would also exist for all writes performed within `getDataSomehow()`, and adding a `volatile` qualifier to those would likely be more difficult or more expensive, especially since the function would then need to use volatile semantics for all callers, not just `test()`. Besides, there's no need for accesses to `myBuff` to be performed precisely relative to each other. What matters is that operations which occur between a read of `ser_buffcount` and a write of `ser_buffptr` not be reordered *past those points*. If reordering operations between those points would improve performance, the optimizer should do it. To be sure, many tasks on multi-core systems may require the use of memory-barriers instructions in addition to compiler-based memory barriers, but the programmers should know what's required for the particular environment being tested. Programmers will often know things about the runtime environment that a compiler can't possibly know (among other things, the programmer might have designed and created the runtime environment sometime after the compiler was written). If a programmer knows that treating `volatile` accesses as global barriers to compiler reordering of all objects whose address has been exposed to the outside world would be the most efficient way to accomplish a particular task, a compiler that supports such semantics should be recognized as more suitable for the task than one that does not. 
vim
Is there any chance you are using windows? Afaik unlink and (l)stat should both run on windows as suggested by https://stackoverflow.com/questions/25999193/unlink-deletes-file-but-returns-false and Windows's _stat should be like linux's stat, but some say it's broken(2nd answer) https://stackoverflow.com/questions/12085761/what-is-lstat-alternative-in-windows So if you are running Windows, try compiling and running it inside a Linux VM. regards
/thread
I am not, running on Arch Linux. I honestly don't know why anyone would put themselves through programming on Windows lol
emacs
please dont take any advice from u/pixelbot he is a pathological liar. 
Then I'll try looking at it tomorrow, it's 10:50PM here and I'm on a phone. Thumbs up for following the Arch master race, it will be dead easy to reproduce it tomorrow.
Will do, thank you.
But learn c++ to some point before. It could be confusing to explore two fields with such spread.
Good point. And to be honest, Netbeans or Eclipse can be quite handy too!
Not everyone can afford a high end Xenon dev machine... 🙃
&gt;Besides, there's no need for accesses to myBuff to be performed precisely relative to each other. What matters is that operations which occur between a read of ser_buffcount and a write of ser_buffptr not be reordered past those points. If reordering operations between those points would improve performance, the optimizer should do it. I would think any sane C compiler would do exactly that if you force the write to `myBuff[0]` to also be volatile. I guess *maybe* a very aggressive optimizer could try to reason that "assigning a pointer to a buffer to an extern volatile" doesn't count as actually "reading" that buffer, but that seems like a rather dangerous assumption to make. OTOH, you could potentially write code such that the "external" thing already has the reference to the buffer, and then the `ser_buffptr = buff;` line doesn't exist. THEN I could see you getting into trouble, which then requires a compiler that has a way to tell it not to reorder any writes across a particular line of code (which C/C++ `volatile` doesn't do).
I've had success with codelite, which is very similar to codeblocks
Visual Studio Code. A bunch of my co-workers is it under Ubuntu.
Emacs with Spacemacs is probably the best of both Emacs / vim worlds and includes all sorts of fancy IDE features.
Clion? 
&gt; high end Xenon dev machine I've found that most people are running on lighter Argon machines, with some people stuck on Neon or (god forbid) Helium.
Give [Geany](https://www.geany.org/) a try. Other options are: + Anjuta + Gnome Builder + Eclipse + QDevelop + Visual Studio Code + Atom
I'm leaving the typo :D Your mention of Helium reminded me of this video of an i9-9900K with a stock cooler. https://www.youtube.com/watch?v=UtXM71tw5fk
Good joke
I'm new to Linux too. I used VS Code. It felt very difficult to get the gcc compiler working though. Atom is also a good choice I think. I wish Visual Studio were here too. I miss it more than I miss games in Linux.
Why?
Vim. C developers rarely use an IDE Linux, and if they do, it's the IDE they use for every other language.
Have you double-checked that the file isn't being removed by some other process in between the `lstat` and `unlink`? You may want to avoid the issue altogether by not performing `lstat` at all. Simply try `unlink`ing the entry regardless. If it returns `EISDIR`, then you can attempt an `nftw` on it. This still doesn't avoid all [TOCTTOU](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) races. Even doing things this way around, `nftw` can be called with a non-directory argument, or a missing file altogether, so your callback needs to take that into account.
I'll add that people should compile it themselves if they want the 'open source' product that Microsoft proudly advertises about VS Code
This thread has probably more answers than alternative.to
No, the files are not being removed in between lstat and unlink. After my program runs in fact, the files are left completely intact because of the supressed ENOENT error. Also I'm not manually calling lstat, but nftw does on each directory entry it encounters.
&gt; Also I'm not manually calling lstat Your code certainly does have an `lstat` in it. &gt; but nftw does on each directory entry it encounters. That's just so it can pass a `struct stat` to the callback. It doesn't change whether the callback is invoked or not.
Since you're using `FTW_CHDIR`, you have to consider the `base` field in the `struct FTW`.
Except it isn't free
That lstat is performed before the affected code, and is only used to check for existence before performing more expensive operations. I am not sure what you mean by the second part, but what I'm getting at is that there has to be some sort of stat call from nftw on each directory listing - and if the directory passed to nftw is valid, then the files it returns and stats should logically exist.
&gt; That lstat is performed before the affected code, and is only used to check for existence before performing more expensive operations. Yeah, you really shouldn't do that. Those "expensive operations" by their very nature "check for existence": `unlink` will correctly return an error code if the entry to be unlinked does not exist. So by doing your own check, you're _doubling_ the number of checks. &gt; I am not sure what you mean by the second part, but what I'm getting at is that there has to be some sort of stat call from nftw on each directory listing - and if the directory passed to nftw is valid, then the files it returns and stats should logically exist. There should be no need to ever call `lstat`. Simply try unlinking the entry. If that fails, handle the error condition accordingly.
While this is safe on Linux, it is dangerous on some UNIX variants where root is allowed to unlink directories with destructive effects.
I'll remove the lstat, but even if I do it still doesn't solve the original problem of two standard functions disagreeing about whether a file exists or not given the exact same file path
No, but that's addressed in [my other comment](https://www.reddit.com/r/C_Programming/comments/b5vcx4/possible_unlink_bug_lstat_says_the_file_exists/ejgeu7z/).
VS Code is getting popular with C/C++ dev. You can set it up to build code with Task, and it even has build in debugger. Just need to download a few extensions. CLion is the best paid option.
QtCreator
Le sigh. I thought `EISDIR` for unlinking directories was guaranteed by POSIX. Turns out it isn't.
If it wasn't clear, the intended presumption was that `getDataSomehow` would be some kind of function that puts data into `buff` somehow (hence the name), but the details of how data gets put into the buffer shouldn't need to matter. On larger projects, the code for the `getDataSomehow()` function might be written by, and under the control of, someone other than the person writing the calling code. You may think that compilers should recognize that the act of storing a buffer's address into an external `volatile` pointer should be recognized as suggesting that something might happen to the buffer, and MSVC would agree with you, but the only ways I've found to get the same semantics from clang or gcc is to either disable optimizations *entirely*, or disable inlining while passing the address to a function. The documentation for clang suggests the existence of a `-fms-volatile` switch to enable the necessary semantics without disabling optimization altogether, but I've not managed to make that work when testing on godbolt. If one makes good use of `restrict`, and a compiler recognizes that anything accessed via `restrict` pointer need not be treated as exposed to the outside world if the compiler can see everything that's done with the pointer, the cost of having a compiler treat `volatile` writes as global reordering barriers to any preceding accesses, and `volatile` reads as global reordering barriers to any following writes will be minimal except in cases where it would be necessary to ensure proper semantics (in which case the "cost" would be irrelevant). It's too bad that compiler writers assume the Committee intended for compilers to do the minimum necessary to be "conforming", rather than recognizing that some tasks require more precise semantics than others, and that the authors of the Standard thought people writing compilers for various tasks should be better placed than the Committee to make cost/benefit analyses with regard to what semantics would best serve those tasks. 
I also made the jump from C::B to VSCode a while ago. I do not regret it, the editor is great! I am also using it on Linux and its really a good too to work with since the command line/terminal is integrated already by default, which is great. Some useful addons are: Better Comments, Bracket Pair Colorizer, Hexdump, Rainbow Brackets, Todo Highlights and Trailing Spaces
What were your issues if I may ask? All I needed was gcc to be installed under linux and /bin/bash was the default shell.
git used to have a bug where it would first try to `unlink` a file and only if that failed try to recursively remove a directory. This caused some fun issues when people deployed it for configuration management on Solaris running as root.
 git: 'used' is not a git command. See 'git --help'.
I've been using Eclipse for years on large C projects on Linux; native and cross compilers. It's a bit clunky and slow sometimes (ram pig), but it's pretty good. Using git, svn or cvs within it is very handy as well.
TBH, you should be compiling everything from source that isn't handled by your distro's package manager. 
YES
It's possible OP is a university student and for those the whole jetbrains suite is free.
Vim and Emacs can be turned into IDEs, with little trouble.
emacs + ccls + eglot = c/c++ developer heaven
For IDE stuff, there's also KDevelop
Sublime Text and VSCode. Both require you learn a little about your compiler but it's worth it. I use both but for C Sublime Text seems to be my favorite of the two. Vim is good too, as others have suggested. It's a little bit of a learning curve but it's not bad. &amp;#x200B;
Netbeans has functionality similar to Code::Blocks. I've just it on occasion. It has a clean and consistent interface over different platforms.
Dammit, who said C++? Get off my ~~lawn~~ sub! (Please note, the aforementioned was intended in lighthearted jesting manner. It's also not actually my sub. As it happens, it's also not a sub for C++. Discussion focus is C.)
I use Vim, with ALE and clangd you get pretty decent code completion and linting
Simple text editor like mousepad, make for building, cgdb for debugging. I tried using several advanced editors like vscode or exclipse, they are not for me. Also I think that too much convenience features dull the mind and encourage bad code structure.
Agreed
Op asked for an environment, so vim + tmux + Makefile
you're right
Gcc and Visual Studio Code. And CMake for generating the build files if you want your program to be cross-platform.
vim + clang
Thanks
i setup my fellow classmates and helped them is coderunner &amp;#x200B;
I rather like KDevelop. It feels the most "Code::Blocksy" to me. QtCreator is really nice, but is intended for Qt develop. If you don't use KDE and don't want to install the dependencies for KDevelop, Geany is a good alternative.
+ zsh + oh-my-zsh
You forgot the &amp; operator at the first scanf.
Ohhh thank you!! Didn’t notice that. 
 test4.c:5:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int] main() ^ test4.c:16:13: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat] scanf("%d",game); ~~ ^~~~ 2 warnings generated. Turn your warnings on...
Visual Code.
Yeah, I'm moved from brackets to vs code a while ago, and I never looked back. It's so fast.
Of course, pardon. I automatically relate c++ with code::blocks, thats why. I will behave in future!
Why so?
Vim with CQuery, tmux and GDB works really great
This needs to be higher, its (or was) an excellent IDE, I've used it back when CLion wasn't a thing.
Well, I've used those for a while but when I wanted to make a simple change, going over the oh-my-zsh doc was a nightmare, the amount of code involved is ludicrous. I went back to bash with a custom bashrc that behaves almost exactly like zsh but with way less code. But apart from the massive code base involved in oh-my-zsh, zsh is great. I won't take part in a shell war.
Even if that's the case, he will get used to work on an expensive proprietary software. Plus, I'm not sure that the fancy auto-completion is good for learning. Getting errors, reading documentation, searching in the standard library might be harder but it might help to build solid foundations.
Just joking. Compatibility mode sucks 
I had a similar problem yesterday, looking for an IDE for Windows (I didn't want visual studio). After a lot of IDEs I tried, I finally chose visual studio code (I use MinGW for compiling). It has the best suggestions while in code (except for clion maybe, but it's not free), which is very important to me. 
Visual studio code is great: https://flathub.org/apps/details/com.visualstudio.code all you need to do is install flatpak from apt :)
Oh okay, I was scared for a second. Guess I got my first /r/woooosh !
Bad bot
Jokes on you. I run Gentoo so even the stuff that _is_ handled by my distro's package manager is built from source code. Like RMS intended.
Yes, while technically I'm not sure if it counts as an ide, depending on OP's understand I'd highly suggest this, there's a certain level of understanding it gave me at least that it's 100% worth it. 
Another option that I have found very useful is to return an enum value (similar to returning an error code) which indicate the particular problem. You get more information then a -1, and you can make a unique value for each error case so you know the exact location where the error occurred. This is especially good for self-contained libraries, where you can have a single enum for the whole library and have every function return its values. This helps in documenting error conditions for a function (you can easily see which conditions occur by which code are returned, and in unit testing, where you can make sure you have a test with each enum value returned from a function.
I dont understand why are you using code blocks in the first place ,it is a bug fest.
There are a ton of plugins for vim, for example: [https://valloric.github.io/YouCompleteMe/](https://valloric.github.io/YouCompleteMe/)
Because if you use iostream, you are not writing in C.
`iostream` is part of C++ and use Classes and Objects to work, which *will not work* in C. `stdio.h` is pure C. `printf()` and `scanf()` are kinda faster, though you can output only a limited range of types of data with them (because no OOP and no polymorphism).
When you use `#include`, the contents of the file are simply pasted in-place. All C needs in order to perform a function call, is a declaration and ONE definition. Your definition is in print.c and the declaration used is the one found in the first line of main.c. If instead, you had included print.h it would have used the declaration in that file. &amp;#x200B;
&gt; i find pintf and scanf harder to use rather than cin cout. I've always felt the opposite.
In c++, there's no real benefit of using cstdio. Maybe if you're using a library that expects you to work with c file pointers. There's also r/cpp and r/cpp_questions that would be more appropriate for asking c++ questions. 
(I don't actually know, hence why I'm asking but) Is including stdio.h in print.h necessary? I'd assume not but I don't know anything about header files so if someone could answer that that would be greatly appreciated. &amp;#x200B;
&gt; What I don't understand is that I never included the print.h in main.c, but it compiled and ran properly, I just provided the function declaration in main.c. When you build the program, there are two things happening: The compiler parses and generates intermediate byte code (an object file) for each .c file, while the linker hooks up functions between object files and makes the executable. In your case, the linker "connects" the `print()` function call in `main.c` with the implementation detail in `print.c`, because you forward declared `void print(void);` in `main.c`. This has the same effect as if you included `print.h` in `main.c`.
It’s not necessary in print.h. However, it should be moved to main.c for the calls to printf. 
&gt; Is including stdio.h in print.h necessary? It's not necessary. Better practice would be including `stdio.h` directly by `print.c`, because you're including stuff you actually need in a local scope.
It’s not necessary in print.h because that header file doesn’t use any symbols from stdio.h. It is necessary however in print.c due to the call to printf()..
You didn't include Print.h in main.c
How does OP's code work given that it's not in print.c, though? No part of the program included stdio.h, right? Is gcc just forgiving about that?
I have the same problem. I’ve been using geany on raspberry pi. It’s good. I think you can use it in any Debian/Ubuntu Linux 
&gt;Get access to the function name/line number (ASSERT etc) I think there's an attribute in GCC that solves this.
print.c included print.h which included stdio.h
are there any resources where I can read more about this?
I don't know what your `TEXT` macro does, but here's the general idea char fnamebuff[7] = {0}; //Allocate space for the filename snprintf(fnamebuff, 7, "%d.wav", i); //Generate the filename for this iteration PlaySound(fnamebuff, NULL, SND_SYNC);
I was in your situation before. I've switched to CodeLite. 
thx man .
&gt;SYNC); nah dude didnt work.ill give it a few more tries though.
&gt;char fnamebuff\[7\] = {0}; //Allocate space for the filename snprintf(fnamebuff, 7, "%d.wav", i); //Generate the filename for this iteration PlaySound(fnamebuff, NULL, SND\_SYNC); yes yes it worked just had to close code blocks the 2nd time thx so much bro.
Modify your code so that any time it does something with a pathname (be it `lstat()` or `unlink()` or whatever), it first logs what it is about to do. For instance: fprintf(stderr, "unlink(%s)\n", filepath); if (unlink(filepath) != 0 &amp;&amp; errno != ENOENT) { /* ... */ } You will quickly find the error. BTW, you should use `stat()` instead of `lstat()`.
I'm going to remove the lstat() anyways as it's a bit redundant. I'll show you what happens when I put what you did. Again, weird behavior. &amp;#x200B; ~ ./rm test rm: remove regular empty file 'test/foo7'? y unlink(test/foo7) rm: remove regular empty file 'test/foo4'? y unlink(test/foo4) rm: remove regular empty file 'test/foo5'? y unlink(test/foo5) rm: remove regular empty file 'test/foo9'? y unlink(test/foo9) rm: remove regular empty file 'test/foo10'? y unlink(test/foo10) rm: remove regular empty file 'test/foo8'? y unlink(test/foo8) rm: remove regular empty file 'test/foo6'? y unlink(test/foo6) rm: remove regular empty file 'test/foo3'? y unlink(test/foo3) rm: remove regular empty file 'test/foo1'? y unlink(test/foo1) rm: remove regular empty file 'test/foo2'? y unlink(test/foo2) ~ rm -iv test/foo7 rm: remove regular empty file 'test/foo7'? y removed 'test/foo7' &amp;#x200B;
The code runner extension should help alot. The only exception to this is my requires everyone to use system("pause") because every machine in our classroom is windows but two of classmates have macs and visual studio is not available to them so I setup vscode with code runner for them they only catch is they have to use cin.get() because only windows with command prompt or dos has pause. 
What's weird?
Can you show us what your .c file looks like after you've made the typedef change? Also, it seems you dropped a `class;` at the end of your last code block?
If you remove the `&amp;&amp; (errno != ENOENT)` part from the code, then unlink will fail with ENOENT. However, as you can see, the file path does exist, is valid, and is stattable and rm from the shell can see it. So how is it that unlink cannot?
Yeah there is an auto system pause on windows version. That might be it 
&gt; it seems you dropped a class; at the end of your last code block? I did, thank you for pointing that out. The .c kind of changes like crazy when I do change to s_class and t_class. Everything errors, and I mostly just try replacing class with t_class, or s_class in the different locations in the .c file, but regardless of which I use, it seems to still error. I can't get anything going at all. 
It doesn't really scale well due to thread-per-connection, and the whole multi-process thing (that nginx also has) means you may have to deal with shared memory at some point, which is a real PITA.
Using header files would not be necessary if you wanted to include within each source file a declaration for every function it invokes from other source files. The advantage of using header files is that if one writes the code as: // print.h void print(void); // print.c #include &lt;stdio.h&gt; #include "print.h" void print(void) { code of print goes here } // main.c #include "print.h" int main(void) { print(); return 0; } then even if `print()` is called from 30 different source files, it will only be necessary to have one declaration (in print.h) in addition to the definition (in print.c). Further, if print.c contains the `#include "print.h"` as shown the compiler will compare the definition of `print()` against the declaration and squawk if they don't match. Otherwise, if one of the source files that used `print()` had a declaration that didn't match the definition, the compiler wouldn't complain and on most systems the linker wouldn't either, but an attempt to invoke `print()` using the wrong declaration would likely to malfunction in potentially-weird ways. 
&gt; The .c kind of changes like crazy when I do change to s_class and t_class. &gt; &gt; Everything errors, and I mostly just try replacing class with t_class, or s_class in the different locations in the .c file, but regardless of which I use, it seems to still error. Can you show us what your .c file looks like after you've made the typedef change? What errors do you receive? We are unable to help you without this information.
Maybe there is an issue with encoding.
[https://www.math.utah.edu/docs/info/cpp\_1.html](https://www.math.utah.edu/docs/info/cpp_1.html) Helped me tons when I was in school since the language was relatively simple. [https://gcc.gnu.org/onlinedocs/cpp/](https://gcc.gnu.org/onlinedocs/cpp/) This is documentation directly from gnu, its a bit more dense but it should answer any more questions
My two cents here are only that MSVC does not support compound literals.
&gt; as you can see, the file path does exist, is valid, and is stattable No, I can't see any of that from the output you provided. And your code is really hard to follow, partly because you appear to have bought a truckload of parentheses on clearance. This, for instance: if (!(((statStruct -&gt; st_mode) &amp; S_IFMT) == S_IFDIR)) should be written as if ((statStruct-&gt;st_mode &amp; S_IFMT) != S_IFDIR) or even better, if (!S_ISDIR(statStruct-&gt;st_mode)) 
It does. And if it didn't, the code wouldn't compile.
*class* is a dangerous word to use. You are probably clashing with something in your C library that uses t\_ or s\_class already.
I disagree. It's easier to read code that consistently uses `printf()` than code that mixes `printf()`, `puts()`, `putchar()` etc. The compiler will choose the best solution regardless.
I tend to use C++ more often than C but I don't like iostream . [Fmt](https://github.com/fmtlib/fmt) is a much better option! &amp;#x200B;
Looks like a bug to me, too.
My guess is that compiler evaluates the second operand first, because your function always returns true, so it was optimized this way.
It looks like that was literally all it was. Thank you.
root is not changing, the strings are. All strings live in main:line\[\] and get overwritten in every fgets. Use strdup().
JustMicroSoftThings
There's something about compound literals that really trips up compilers. I [found a similar compound literal bug in GCC](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79351) (now fixed). Honestly it makes me scared to use them.
Thank you so much
If (negative){ Break } 
Ohh thanks. Just curious is there another way of doing this, without using break.
From `scanf` man page: &gt;On success, these functions return the number of input items successfully matched and assigned; this can be fewer than provided for, or even zero, in the event of an early matching failure. &gt; &gt;The value EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs. EOF is also returned if a read error occurs, in which case the error indicator for the stream (see ferror(3)) is set, and errno is set to indicate the error. &amp;#x200B; Thus, in your code, `scanf` will always return 1 and your `while` loop will not end. Assign `number[index]` to `reading` after the `scanf` and you should be good, or even better, use a `do while` loop: do { scanf("%d", &amp;number[index++]); } while (number[index - 1] &gt;= 0);
I can also recommend Atmel ATmega328 Xplained for this. Not as sturdy as the good ol' arduino but way more freedom pin-wise if you wanna build it into a bigger project. Works well with self-driving projects just keep them away from the stairs or old usb ports. Few spikes over 5 volts and it starts getting a bad case of dead. (at least did with me when I used an older laptop to program it with) but it still opens up a lot of possibilities. &amp;#x200B; But yes its a lot of fun. I can highly recommend it.
Often it translates directly like you would describe it in english: while there less than 100 numbers, and there is a number in input, and it is positive, then accept the number. while (index &lt; 100 &amp;&amp; scanf("%d", &amp;number[index]) == 1 &amp;&amp; number[index] &gt;= 0) ++index;
tysm for explaining i got it.
&gt;Thanks for explaining so clearly, the translation from English clarifies it all.
Yeah I'm wondering why you need the struct to create the bug too. Probably means that there's a bug when determining if a function is pure with respect to an expression *specifically* when the expression involves making a struct, which is weird. Also, I don't have the VS compiler but I'm wondering if the same bug would occur if the b variable was placed inside of main and a pointer to it was passed to foo instead. 
Ah, I see. Thanks for the input.
Same thing happens. You can check with the [retester](https://rextester.com/YVVD90682)
I applaud the clean, tidy formatting and conciseness of your post.
Without the header file, C was forced to guess at the declaration of print(). It probably assumed `int print();`. I believe the latest generation of C compiler no longer lets you get away with this.
 foo() ? (bar) { b } : (bar) { 0 }; Is this a legit syntax? Sorry just clarifying because I haven't seen something like this before. If yes, how is `b` being used inside main when it's defined inside `foo()`?
It's declared outside the function
BTW, `reading` is not initialised. That's gonna give you problems.
Oops, my bad.But what's with the `{` braces? Is that a way of referring to the first member of the struct?
GNOME Builder is up and coming. Many are using it for GTK development, but it is also a general IDE.
They're compound literals
Personally, I think compound literals would have been much more useful if they had been `static const`. In cases where the values are compile-time constant, having them be `static const` would offer better performance than can be achieved with the Standard as written, since the Standard presently generally requires the creation of compound literal objects at run time even in cases where the values never actually change. If one needs to generate a struct at runtime for the purpose of passing its address to another function, a compound literal doesn't do much that couldn't be done via: struct foo{int x, y;}; typedef struct {struct foo dat[1];} foo_wrap; foo_wrap make_foo_proc(int x, int y) { foo_wrap result; result[0].x = x; result[1].y = y; return result; } #define make_foo(x,y) (make_foo_proc((x),(y)).dat[0]) By contrast, a static const compound literal would have semantics that really can't be emulated any other way. 
Why the correct result is not 1?
Because writing compilers is notoriously easy /s
Personally, I prefer to build software from source using a text editor. Saving the file with a .c extension should allow you to execute with your favorite C compiler from the terminal. If you choose to go this route, just know you may have to become familiar with "make". \- 19 yo compsci/cybersecurity student 
Apparently Netbeans 10 doesn't support C anymore.
I took enough Compiler Construction Lectures to know it's not easy. But this does not mean such a big company can't get it right.
Submit a proposal.
Google 'external linkage'. Wikipedia has an article about it. Your example is a demonstration of functions in C having `extern`al linkage by default.
If wasn't really happy with any editor/IDE since the great NEdit stopped being developed in the mid-2000s and tried nearly everything (vim, geany, eclipse, netbeans, gedit, kate, sublime, Kdevelop, Atom, Qt Creator, Anjuta, CLion, Code::Blocks, emacs, CodeLite, Gnome builder) except Visual Studio Code until recently, but it actually seems to be pretty good despite being Electron-based and coming from micros~1.
You can have static compound literals. Just store them in a static object. It’s really just a syntax. Calling them “literals” is weird. They’re nice when you want to pass an anonymous object. Since it doesn’t have a name, someone reading code can keep it out of their mental map.
That's disappointing. I didn't know that.
Awesome name haha
Crazy. The function `foo()` isn't even required to demonstrate the behavior: https://rextester.com/GZCOR33181 I copied `(bar) { b }` to the `else` side since it seems to always execute that side. It seems like it's ignoring the ternary operator sequence point at `?`; however, if that were the only problem, I'd expect the pre-increment operator to work--yet it still doesn't: https://rextester.com/WMS73987 Strange.
Crazy. The function `foo()` isn't even required to demonstrate the behavior: https://rextester.com/GZCOR33181 I copied `(bar) { b }` to the `else` side since it always executes that side. It seems like it's ignoring the ternary operator sequence point at `?`. The pre-increment operator doesn't help: https://rextester.com/WMS73987 Strange.
I don't know why you're bringing Perl or Java into a conversation about C and C#. Yes, being able to work with pointers and function pointers allows C# programmers to write code in a C-style dialect, which brings the languages closer together. IDK why you're persisting you were just mistaken in thinking that C# has a C FFI like any other language, and I indicated to you that you were wrong, so now you're saying oh well Perl has something similar and Perl is nothing like C# so C# can't be like C. Yeah, nice man. I'm not replying to you anymore.
If you do not want to learn C, this is the wrong place to post about this question. If you want to learn C, pick up the C Programming Language 2nd Edition by K&amp;R and start learning. Then ask specific questions. &amp;#x200B; For very quick results, please use Google or other appropriate search engines to search for "C code to Java code converter". 
bro, converting this to java, is the quickest way for me to learn... so i know the equivalent is in C
 int main(){ char *str; str="Testing a string"; printf("%s", str); } Or you could use a char array like so char str[]
Not to sound like any ass, but from my own experience, you should not start with C. Go download python instead, its going to make learning programming much more fun
haha i know, the thing is that my courses in college use c instead of python, unfortunately. Even the professor told us it would be better if we first learned how to code in python, he tried to change it, but the institution or whatevers the name didnt want to change it from c
Can you answer the following questions? That way it will be easier for me to help you. 1. Do you know Java? 2. Do you know C?
I know more Java C only the basic, i always write down on a notebook ,how to write implement code on both languages, 
uhh, but how do i compare it exactly? say my input is called strIN and i wanna take a certain path if the used types BINARY, for example. Can i do something like: if(strIN == BINARY){...}? this might be horribly wrong, sorry.
Well then, i'd suggest to look on how to handle strings in C, its a little more complicated than most languages but its a good thing to learn. 
Great. Then, ask specific questions about your code. We are not here to do your job for you. &amp;#x200B; Ask questions like "How would you represent a C struct in Java?". I will say use a class. &amp;#x200B; And other (maybe even better) subreddits for such questions would be r/java, r/learnjava, r/AskProgramming, r/javahelp since they are more focused Java equivalents of this subreddit.
Don’t do that, when you use the == operator on pointers it won’t ever return true unless the POINTERS (ie the address ) are the same . You want to use strcmp() (look it up and read in the c standard library)
hey i managed to do it, thx for the help man
Np!
Np!
&gt;I don't know why you're bringing Perl or Java into a conversation about C and C#. The top-upvoted comment in this discussion, and the comment which started this subthread, [states](https://www.reddit.com/r/C_Programming/comments/b5l4fi/which_language_is_most_similar_to_c_c_or_c/eje8k5f/): &gt;I think C# shares way more in common with Java, and think it’s a world apart C. which, from my experience, seems to be the general consensus on this sub; cf. comments such as [this one from a month ago](https://old.reddit.com/r/C_Programming/comments/at9nuf/new_to_programming_and_looking_for_some_help/egzv11o/): &gt;Apparently they're so close \[i.e. Java and C#\] that when C# came out, it would compile straight Java code. I'm sure that doesn't include dependencies, and probably not a lot of the standard library, but still. Readers befuddled why this would be are invited to read about how Microsoft tried to embrace, extend, and extinguish Java. C# was their own Java, with a few changes. Given this, when you write: &gt;Yes, being able to work with pointers and function pointers allows C# programmers to write code in a C-style dialect, which brings the languages closer together. i think it's very relevant to consider whether Java would become "closer to C" by the addition of C#'s `unsafe` functionality. And given that there are more fundamental differences between Java and C than the use of pointers / function pointers, and given that being able to drop some C into your Java code wouldn't suddenly make programming in Java more like programming in C in any substantive way, i'm interested to know why dropping some C into C# would make programming in C# more like programming in C in any substantive way. &gt;IDK why you're persisting you were just mistaken in thinking that C# only has a C FFI like any other language, and I indicated to you that you were wrong .... which i acknowledged by [writing "Ah okay"](https://www.reddit.com/r/C_Programming/comments/b5l4fi/which_language_is_most_similar_to_c_c_or_c/ejeq47l/). &gt;so now you're saying oh well Perl has something similar and Perl is nothing like C# so C# can't be like C. Further to what i wrote earlier in this comment, i'm arguing that: * *if* C#'s `unsafe` functionality brings it closer to C, and * *if* Perl6's `NativeCall` functionality is similar to C#'s `unsafe` functionality, then the use of `unsafe` in C# makes programming in C# more like programming in C only insofar as doing something analogous in Perl6 makes programming in Perl6 more like programming in C. And yeah, i am indeed not convinced that this would then mean Perl6 could be be considered "closer to C", given the significant differences, at a fundamental level, between the Perl6 approach to programming, and the C approach to programming. Again, it was you who [made the claim that](https://www.reddit.com/r/C_Programming/comments/b5l4fi/which_language_is_most_similar_to_c_c_or_c/ejeeh7d/): &gt;the unsafe keyword lets you do anything in C# that you can do in C. So, they are not as far apart as you think. Since you're the one making that claim, the burden of proof *is* on you to provide evidence for your claim, including dealing with the arguments made it against it. But if you don't want to do so, so be it.
Comparing an interpreted language to C# and comparing two compiled languages, one of whom has the other as its namesake, are two completely different things. You are acting like a buffoon. Good day.
Okay, so you apparently agree that a language's ability to work with pointers / function pointers is not the only dimension via which to determine how alike a language is to C. And it seems to me you're saying that, since Perl6 is interpreted by default, it's quite unlike C, and that being able to work with pointers / function pointers in Perl6 doesn't change that. If so, i agree. C# is fundamentally much more Java-like than it is C-like (even though both languages are compiled by default). You continue to fail to address the question of how adding `unsafe` to C# substantially changes this, and are instead resorting to ad hominem. Finally, i'm not sure what you're getting at when you refer to: &gt; two compiled languages, one of whom has the other as its namesake Are you referring to C# having C as its namesake? If so, are you claiming that C# having C as its namesake makes makes the language C-like? If so, then i disagree; just as i would disagree that JavaScript having Java as its namesake means that JavaScript is Java-like. JavaScript was named that for marketing reasons - riding on the coattails of the visibility of Java - and it looks like C# has been named as it has for similar reasons. (MS calling the language something like 'NewJava' would obviously run into trademark issues.) 
This is C++ code. Try /r/cpp_programming
Oops ty
That's C++. And your output stream handling is wrong. As is your loop.
I've been cycling through different combinations of using eg. ofstream vs fstream with fstream::out argument based on/ copypasting what I'm seeing online. The alternative involving while(!olddata.eof) and getchar goes on an infinite loop printing garbage characters. This is day 1 of playing with any kind of C. I'm trying to make an excecutable for my classmates based on the python program I made for myself to clean up garbage data from my chemistry class tools. 
This is the wrong sub as this is C++ code. However, the issue with your code is the following: time(0) returns the number of seconds since Jan 1, 1970 UTC. You call it four times in a row one after the other. This happens really quickly, i.e. less than a second. Therefore, it's giving you the same seed every time because a second hasn't even passed since the first time you called it. If you add a call to sleep(1000) (or Sleep(1000) if windows) after each call to spinwheel, you'll see the effect.
&gt; In c++, there's no real benefit of using cstdio Debatable. When I write c++, I use stdio.h because I find std::cout hard to read, it has a lot of visual noise.
The bigger issue is "don't reseed the RNG". Seriously, don't do that. Seed it once.
I would check out the book called "the c programming language". Im sure you can get a free pdf of it. 
Agreed, as that is the root of the problem that I was hoping OP would see.
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int spinwheel(); int main() { srand_deterministic(time(0)); // same as your srand() spinwheel(); spinwheel(); spinwheel(); spinwheel(); return 0; } int spinwheel() { int y; int MAX_VALUE = 38; int MIN_VALUE = 1; y = (rand() % (MAX_VALUE - MIN_VALUE + 1)) + MIN_VALUE; printf("%i\n", y); return 0; } I made C out of your C++, but the problem should be the same. The srand_deterministic() function is an OpenBSD extension. The rand() function returns a result in the range of 0 to RAND_MAX. By default, this result comes from arc4random(3). If srand_deterministic() was called, the result will be computed using the deterministic algorithm. Google what srand() does and why you shouldn't call it in every function-call again.
"My frend say push buton on computer wat I do now?"
anybody knows any good resources that can help me understand how to deal with lazy rude reddit posters? time is running out. SEND HELP
Beginner questions are not off topic and beginners have often not yet learned how to properly ask questions.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I get it, but there's way more than I've ever seen here. Literally 21 of the top 42 posts.
&gt; So how is it that unlink cannot? These are all relative paths. At the point at which `unlink` is called, the process's working directory is different.
Offtopic
Alright mate chill out, so what if people are hitting deadlines and want some help? lets help people.
If this bothers you, then go and post better content!
Congratulations, your post fits that description nicely. 
How so?
At this point you have to be a troll.
 1 #include &lt;stdio.h&gt; 2 3 void print_2d_array(int rows, int cols, int *a) { 4 for(int i = 0; i &lt; rows; ++i) { 5 for(int j = 0; j &lt; cols; ++j) { 6 printf("%d ", a[i * cols + j]); 7 } 8 printf("\n"); 9 } 10 } 11 12 int main(void) { 13 int arr[][3] = { 14 {1, 2, 3}, 15 {4, 5, 6} 16 }; 17 18 print_2d_array(2, 3, arr[0]); 19 } Spot the error. Also, please try to use size_t to pass array sizes; on many systems it is possible to create an array with indexes beyond what int can handle. size_t has been created specifically for this purpose.
Do the resize when you get KEY\_RESIZE from wgetch() or similar.
Your program will be sent a `SIGWINCH` signal when the terminal is resized. ncurses can be compiled to handle this itself; if it is, it will handle it when refreshing the screen or reading a character. The character read will be `KEY_RESIZE`. If ncurses is not compiled with this feature, you need to handle `SIGWINCH` yourself. Note that you should simply have your handler set some flag, then perform the `resizeterm` as required in your program's main loop.
Now I can finally make my Photoshop-killer: Imageshop!
So... A guide on how to use pointers? 
What kind of post is this? Cmon now let people ask questions - that is the point of this place. I can feel your gatekeeper vibes and nobody cares how experienced you are, sir. 
i can't stop you concluding that, of course, even if your conclusion is incorrect (unless you define 'trolling' as "asking that someone provide data in support of their claims"). On the other hand, although i've taken the time to clarify my points, and given you opportunities to demonstrate how i'm incorrect (which i very well might be), you've not done so, but have instead claimed i'm ["acting like a buffoon"](https://www.reddit.com/r/C_Programming/comments/b5l4fi/which_language_is_most_similar_to_c_c_or_c/ejjnoze/) and that i'm a troll. \*shrug\* Okay.
Think for a second about how you expect someone to answer this question with the amount of context you've given. 
You need to decode the mp3
`#include &lt;psychic.h&gt;`
[https://github.com/asantoni/libaudiodecoder/](https://github.com/asantoni/libaudiodecoder/) is one option, so is [startpage.com](https://startpage.com) ....
Whats that ? 
I use the code PlaySound(TEXT("music.wave"),NULL,SND_SYNC); will it work directly if i do .mp3 and use the header file psychic?
Okay thx man im about to give this a shot i hope i understand.
Sorry
Don't you have a textbook?
Try these [Computerphile](https://www.youtube.com/user/Computerphile) videos: * [Essentials: Pointer Power!](https://www.youtube.com/watch?v=t5NszbIerYc) * [Linked Lists](https://www.youtube.com/watch?v=_jQhALI4ujg)
Not really, j just Google everything. Is there a good site or a good textbook that I could download the pdf you would recommend?
Five years, and still no support for [Makefiles](https://youtrack.jetbrains.com/issue/CPP-494)? Jetbrain, why are you ignoring your paying customers? We understand that you think cmake is better (and you might be right?) but come on - a lot of us have multiple large code bases built with plain make and switching to cmake is not going to happen.
[best side](http://lmgtfy.com/?q=how+to+deal+with+pointers%2C+linked+list%2C+file+io)
I thought you said you were learning C for college? Didn't your professor assign, or at least recommend, a textbook? And did you bother to look at the sidebar before posting?
I’m not a JetBrains employee, but give a look to the issue comments, especially those from JetBrains. Also compilation database + Makefiles plugin + custom build command do the job pretty smoothly. Not as good as a real support, of course, but I personally don’t know how they could handle it.
Format. Your. Code.
I started computer engineering this year, I have a class that teaches computer science and it uses C. The professor assigned a textbook but they don't have it in the library, and I don't wanna buy it. Also, I didn't find the pdf for it. By the sidebar, do you mean the subreddit rules?
**I ONLY DID SOME FORMATTING** int main() { while (times &lt; rWant, times++) { printf("Player one what would you like to choose?(Rock=1, Paper=2, Scissors=3)?\n"); scanf("%i", &amp;pick1); printf("Player two what would you like to pick?(Rock=1, Paper=2, Scissors=3)?\n"); scanf("%i", &amp;pick2); if (pick1 - pick2 == -2 || pick1 + pick2 == 5 || pick1 + pick2 == 2) { printf("Player 1 wins!!\n"); } else if (pick1 == pick2) { printf("Draw\n"); } else { printf("Player 2 wins\n"); } } return 0; } &amp;#x200B;
Look at this [https://www.tutorialspoint.com/cprogramming/c\_while\_loop.htm](https://www.tutorialspoint.com/cprogramming/c_while_loop.htm) and [https://www.tutorialspoint.com/cprogramming/c\_for\_loop.htm](https://www.tutorialspoint.com/cprogramming/c_for_loop.htm) &amp;#x200B; Now look at your code. You see the problem?
&gt; I don't wanna buy it How mature of you. &gt; By the sidebar, do you mean the subreddit rules? https://i.imgur.com/T9N2cvV.png
You forgot to ask a question. And please format your code.
In the country we don't really buy our books. We either use the ones from the college's library or we read it from the pdf. I didn't notice that sidebar, thx man.
This mad me LOL. 
Format your code.
/u/STL I'm only tagging you because I don't know of a more direct person to tag.
https://en.wikipedia.org/wiki/MP3#Encoding_and_decoding
I acually thought he wasnt joking and i typed in psychic as header file and then i realized it was a joke . He got me there.
There is no such thing as a “TLS socket.” TLS is a protocol that is spoken by programs. The kernel is not involved in it. If you want to speak TLS, you need to use a TLS library such as OpenSSL. The only way around this is writing your own TLS library, which is pretty hard to do.
Sure I'll do it. My fee is €100 upfront.
Here you go: https://pastebin.com/qD0DS6wZ
I understand. But it is very hard to use openssl, and tutorials on the web are old. &amp;#x200B; Do you have a good tutorial ?
&gt; You can always ask others to teach you how to do something, however they shouldn’t write your code for you. Really? You didn't even bother to take that part out? Fun story -- I did a similar project back in High School. I'd already been programming for a few years by then, so I did above and beyond the requirements, making a supervisor mode where the prices could be modified. Of course, you don't want any employee getting into this menu, so I password protected it. And since you don't want passwords to be visible as you type, I wrote some code to read the password in and print asterisks instead. But I messed it up: typing in a long password, larger than the buffer, would allow the user to overwrite the prices on the stack anyway. That was the day I discovered buffer overruns and bounds checking.
Programs done. I will upload it after work. 
You're in the wrong sub, we talk about C here, not C++. You want /r/cpp_questions instead. In the meantime, I would recommend trying to solve a simpler problem. Don't worry about adding up or counting anything, just read the numbers in the file and print them out. Once you can do that, adding those numbers up, counting them, and calculating an average will be much more clear.
[removed]
line editors fit in quite well if you consider even older workflow with punch cards. Basically you write your programme on a piece of paper, then type it in, then look over for typos, compile and fix errors, first on paper, then in the file. You can also print out the file (with line numbers too!) to pore over it at your leisure.
Grab the OpenSSL source, extract, and checkout the directory demos/ , it has simple applications with lots of comments and explanations for using all the parts of the library. demos/easy_tls has a TLS wrapper. There's also some nice little programs stud ([https://github.com/bumptech/stud](https://github.com/bumptech/stud)) and hitch ([https://hitch-tls.org/](https://hitch-tls.org/)) you can use to wrap your connect with TLS (it hooks the calls to standard socket/bind/etc and hides all the details). Unless you need TLS specifically and just want to encrypt your network connection, I'd suggest SSL 2.0. It's new and supposed to better. More important, I find it much easier to use. Check out dems/ssl in the openssl source code. 
I never programmed C using line editors, but I did do BASIC in a similar fashion. [This video](https://www.youtube.com/watch?v=seM9SqTsRG4) does a pretty good job of showing how things worked in that world. There is a big difference since BASIC has line numbers and you can't really shift things around without a lot of extra work, but it should give you a feel for the workflow.
Love CLion. I let my susbscription run out but looking to get into embedded stuff so might have to sign up again for this version...
Compiler bugs should be reported through [Developer Community](https://developercommunity.visualstudio.com/spaces/62/index.html).
I'm honestly surprised there isn't a rule against posts like this. We are not here to give you answers to work **you** should be doing.
i think this is the wrong subreddit for this question. You are using C++. This is a C subreddit. You should try r/cpp_questions. You will get help there.
line editors allow listing so you would list ranges and perform edits. Usable on both teletype (typewriter) style terminals and CRTs. If you look at the mechanics of vi you'll realize that it was simply extending this experience with it's two modes of operation. I started coding on punch cards. Had the joy of working on [an 029 keypunch](https://en.wikipedia.org/wiki/File:IBM_card_punch_029.JPG) and for upper level projects an [IBM 1130](https://en.wikipedia.org/wiki/IBM_1130#/media/File:IBM_1130_concole.ms.jpg). The 1130 was as close as you can get to being on Star Trek's Enterprise. It made sounds and flashed lights as it worked. Was really a blast at the time. For cards you just relied on getting a printout. To answer your question, it's an entirely different mindset. You did all of your work and design on paper and would basically have a complete solution documented before entering any code. The coding part was just the final step in the process and the expectation was your program was going to be pretty close to working. You might only get four of five attempts at even compiling and running the program depending on how busy the data center was. Wouldn't wish this on anyone, but I think the art is a bit lost with today's rapid edit / compile / try loop. We tend to be OK with something working without understanding why and jumping straight in to the editor without any prior thought seems pretty commonplace. 
Do you think up front design yielded better programs? Are there other things younger programers could learn from that mindset? 
You have to understand that in the days were `ed` was used, people mostly programmed on real teletypewriters. These are basically printed with keyboards attached that would type out the responses from the server. Programming in `ed` is not really difficult if you can just look at the printout from the previous commands.
&gt;This video Do you think you could productively write C today like this? 
I think we understood our programs better and I think it produced people who had better design sense. You couldn't succeed without it. To this day I still consider my time at the terminal just the typing part. I'm just remembering one of my first jobs there was a programmer that actually had a secretary type his code. (and to be fair, the rest of us peons rolled our eyes even then) Next time you write a small academic application try allowing yourself only one compile and run an hour and see how it changes your way of thinking and your style of coding. You will ponder every line and you will make sure every avenue of execution is checked for correctness. To do this you will have to know up front what 'correctness' even is. If it doesn't work you will want the code to tell you what isn't working. I understand the complexity and nature of today's software demands a more iterative approach, but I only allow this to some degree. When I work with inexperienced programmers the single biggest issue I see is the complete lack of planning. The "it's way to complex, we're just going to code up tiny bits for now and see where it takes us" mentality only goes so far. Their code quickly becomes a creaky mess with zero foundation. You really can understand complex systems prior to starting and it is far cheaper to do so at that point. The same iterative approach we currently assign to the coding phase can also be done in the design phase. It just isn't as fun and doesn't give you any immediate gratification. Unfortunately, the need for immediate feedback is what draws many to our profession. 
I have some code for this here: https://github.com/schibsted/sebase/blob/master/util/lib/tls.c and https://github.com/schibsted/sebase/blob/master/util/lib/tls.h It's MIT licensed. There's other similar libraries around. I believe OpenBSD has one they call libtls. 
&gt; I'd suggest SSL 2.0. It's new and supposed to better. You're joking, right?
Amen, brother!
I’m gonna guess that the prefixed functions where named so to not clash with the unix standard ones. But rewind didn’t need it. But totally a guess.
Because the name was chosen back in the day without a clear naming convention. It's only `fopen` because `open` was already taken, `fseek` because `seek` (now called `lseek`) was already taken and `feof` to distinguish it from `EOF` on caps-only teletypes. There is no other `rewind` function; file descriptors are rewound with `lseek` on UNIX. Thus, the name was used. Maybe also because there was a limit of 6 characters for external identifiers on some platforms.
CLion's reliance on CMake is what really stops me from using it. I love all of JetBrain's other IDEs. I really can't stand CMake, so when it comes to C I stick to Vim. 
with unit tests frameworks, it is always useful to be able to execute a certain test case. Do you plan something similar? Like, \`./myexec --unittest --testcase=NameOfTestCaseWhichIamDebugging\`
I would definitely be less productive. But I mainly use vi, so I could probably manage.
I've read the paper by Stephen Dolan, and didn't get the conditional branching. I see how the comparison is done; but how do you branch based on the result of this comparison?
I have a few questions about those: 1. Was running out of paper an issue? Could you change out the paper while the machine was connected? 2. Was it connected via a serial port? 3. How fast was the printer? Could you print out a lot of output relatively quickly to draw something? 4. Was this the kind of thing that people used to interact with the original Unix?
Sounds like they went through a lot of paper. With C, there's a lot of indentation. Was that a problem back then compared to BASIC which seems more flat? That's crazy that you had to write programs down on paper. I can't write a single program without getting 10 compiler warnings in C++, I would go crazy.
If I'm mixing up my protocols (certainly likely) say so. A snide comment isn't helpful for anyone. It terms of cleaner code, definitely know I'm think of SSL2. 
In the past, Jetbrains has made reference to a developer poll they did where cmake was the single most popular build system, and that's why they chose it for CLion. As someone who's never gotten around to putting a modern IDE through the paces, I'm only vaguely aware of how the integration works. Isn't forgetting to add dependencies and then fixing them right away a large part of the fun? 
It helped greatly to write on paper with a pencil. Functions and headers on different pages. Spiral notebook or binder-clip. It's pretty fast when you have a good grasp of syntax, and you could always look in your books for function calls. Or skip over with a comment, double back later, the usual. It's like writing the first draft of a letter or thesis on paper, thinking deeply about it in the process, then if you have a better idea while you're later typing it in, all the better! C isn't a REPL language where half of the value is the immediacy. Also, having found paper to be a perfectly acceptable way of organizing thoughts and doing a first draft, I'm not very sympathetic to those who refuse to code at all on a whiteboard. I don't want to automatically dismiss their concerns, but I'm always going to start by assuming that they need an IDE in order to manage the most trivial operation. 
It's like revising a paper. Almost everyone revises the smallest paper with fresh eyes at least once, but it seems like they don't always do the same with code today. Putting it on paper and then typing it later can force a marvelous clarity of thought, sometimes. It's not literally better than taking the same time to look at it on a screen, but the paper method sometimes forces you to be rigorous, like reading out loud forces you to pronounce every syllable instead of bounding forward in a blur. 
Note that the K&amp;R coding style is frugal in the amount of paper used.
https://www.youtube.com/watch?v=E4IztV7M3jI 1. Have you ever used a printer with continuous-feed paper, like a dot-matrix or daisy-wheel? 2. Yes. 3. You would consider it slow. 4. Yes. Glass terminals hit the tipping point where they began to be cheaper than teletypes in 1974. Like any other disruptive innovation, within a few years they had become predominant by far. Faster, cheaper, more pleasant, zero consumable cost. 
&gt; With C, there's a lot of indentation. Look at K&amp;R style and cuddled `else`, compared to Allman style. 
&gt; There is no such thing as a “TLS socket.” In Linux [there is](https://github.com/torvalds/linux/blob/master/Documentation/networking/tls.txt), since two years ago or so. 🙂 (It doesn't support handshakes so you still have to do that with OpenSSL or the like, but once that's complete it behaves much like a regular TCP socket to the user)
&gt; Is there any way to do it without using openssl There are other implementations, such as GNU TLS or [mbed TLS](https://tls.mbed.org/) or [WolfSSL](https://en.wikipedia.org/wiki/WolfSSL). On Windows (only) there's SChannel. If you're asking this question, you're going to need to use a library; TLS isn't a standard library in the C language. 
**WolfSSL** wolfSSL is a small, portable, embedded SSL/TLS library targeted for use by embedded systems developers. It is an open-source implementation of TLS (SSL 3.0, TLS 1.0, 1.1, 1.2, 1.3, and DTLS 1.0 and 1.2) written in the C language. It includes SSL/TLS client libraries and an SSL/TLS server implementation as well as support for multiple APIs, including those defined by SSL and TLS. wolfSSL also includes an OpenSSL compatibility interface with the most commonly used OpenSSL functions.A predecessor of wolfSSL, yaSSL is a C++ based SSL library for embedded environments and real time operating systems with constrained resources. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
SSLv2 is an ancient and unusable protocol that has been obsolete and actively deprecated for about 20 years. In this particular case, I find the snark forgivable. 
Thank you very much. WolfSSL has a concrete example with sockets. Seems quite simple compared to openssl. So thank you.
Right, I should have mentioned that OpenSSL has a notoriously weird API, for historical reasons. A great many people dislike OpenSSL's API and prefer to use something else, so feel free to do the same. 
I saw that. Very verbose and weird.
I sometimes use cat... does that count?
&gt; Was it connected via a serial port? Yes, but not via RS232. Rather, a V.20 current loop was used back in the day. &gt; How fast was the printer? Could you print out a lot of output relatively quickly to draw something? An ASR33 (a common model of that time) could print 10 characters a second which is equal to 80 Baud. Later hardcopy terminals could print faster; for example, my TI Silent 703 can print 37.5 characters per second (300 Baud). &gt; Was this the kind of thing that people used to interact with the original Unix? Yes. Hard copy terminals were gradually replaced by glass terminals by the mid seventies.
SSL 2.0 was released in 1995 and almost immediately proven to be unusable. The latest version is TLS 1.3 which was released last fall.
Snarkiness for me mixing up my TLA, particularly in this regard, is reasonable. However, snark without a clear correction is purely insult without value.
I had never heard of current being used for signalling. Thanks for sharing! This [Apple \]\[+](https://i.imgur.com/62cbAI7.jpg) is my only computer from the 70s!
It wasn't pleasant. You basically had to keep an image in your head of what your file looked like as you typed. You *very* frequently used some variant of the "print" command to look at all or part of your file. Back before we had CRT displays, we consumed an insane amount of paper doing this.
&gt; We tend to be OK with something working without understanding why and jumping straight in to the editor without any prior thought seems pretty commonplace. The only real programming on paper I've done was in school when we had to write code in 6800 assembly and then hand-assemble it and key it in to a Heathkit trainer - unless you count the period in junior high when I was banned from the computer and filled up a binder writing C-128 basic code. Both were good exercises. But today... I was just lamenting yesterday how you *can't* always do that now. I'm working with NXP's Kinetis SDK and the documentation is so lacking in most areas that you simply couldn't write a program with it. Even something as simple as toggling GPIO pins is not documented enough to be usable without some guesswork, or without reading through the SDK's own source. They give some examples, but the GPIO example uses maybe two out of a dozen functions. Things are faster and cheaper now and programming in general is more productive and less of a chore, but god damn do I miss the days when they wrote real documentation, even if you had to order it by mail.
I love coworkers that "refactor" my code to make it shorter. The compiled version is exactly the same but now the code is unreadable.
Running out of paper was a huge issue. Teletypes held a huge roll of cheap yellow paper that would spool down behind the printer. There was a sharp edge where the paper came out that let you tear off sheets as you went, but it wasn't uncommon to keep as much intact as you could. Then you could gather it up and re-use it by printing on the back. Or even by turning it around and printing along the other side. With care, a roll of paper could be used four times. More modern terminals such as [Decwriters](http://www.columbia.edu/cu/computinghistory/la36.jpg) and such used stacks of fanfold paper, but the same principles applied. Typically connected via serial port. Teletypes were 110 baud max. Decwriters at 300 baud. If you weren't located in the computer center, the serial ports typically connected to [acoustic modems](https://cdn.hackaday.io/images/8374421484063667441.jpg). If your house only had one line, you had to make sure nobody picked up the phone to make a call while you were on-line. At 300 baud, the printer was quite slow. You could print a graph or something if you had a couple minutes to spare. This was, indeed, how we interacted with the original Unix. Frankly, I still do; the command line is ten times as powerful as a GUI, if you know how to use it.
Upvoted for your username alone. Many years ago, I was at the Computer History Museum, giving a younger co-worker a tour. When we reached the PDP-10, I said "This was the machine I truly learned to program on. It was the most elegant machine of its day." The old guy with white gloves who shows you things in museums butted in and said "This was the most elegant machine *ever*!" Turned out that back in the day, he was one of the engineers at DEC who first invented it. And honestly, I have to agree. By modern standards, it's a dinosaur, but we'll never see its like again.
We not only wrote the programs down on paper, but we "bench tested" them first. CPU time was hella expensive, you you'd typically go through your logic line-by-line, essentially pretending to be a computer, and only typed it into the real computer when you were satisfied the logic was good.
&gt; older workflow with punch cards Those were days I hope to never see again. Even though I'd had access to interactive computing with Teletypes and Decwriters in high school, my college was so behind the times that they were still using card readers and printers. And the campus computer was an old IBM 360/67 named "Godot". During crunch times, you gave your deck of cards to the operator on Friday afternoon, and came back Monday morning for the printout. A friend told me that when they'd had the 360/50 previously, you dropped your cards off on Monday, and came back for the printout on Friday. I actually learned to program an 029 card punch to improve my workflow. Never again.
The last of the thirty-six bitters. Well, not counting Unisys MCP and OS2200 line, which, irrespective of their best qualities, nobody does. 
We did a lot of .-15,.p and saved vertical space by putting related statements on the same line, as long as that didn't affect readability too badly.
The legends told by some of the old timers suggest that the early Unix programmers that used ed were not human.
Openssl is not hard to set up. If you have trouble with this then I think you should look to hiring an expert.
&gt; people mostly programmed on real teletypewriters. Or, if you were lucky, [Decwriter 120](https://www.vaxbarn.com/index.php/other-bits/373-dec-la120) as opposed to the ever painful [KSR-33](https://en.wikipedia.org/wiki/Teletype_Model_33) teletypes. Source: I started programming in 1971. 
1: Make sure to compile in Release mode, if it is, use the size optimize release mode switch (-Os in Clang) 2: Use LTO (full LTO is better than thin, but either is an upgrade from none)
I started in 1971. At that time I was on IBM 1620 then 360. We only had punch cards. Later got PDP 11 and [CDC 6500](https://en.wikipedia.org/wiki/CDC_6000_series) where we used punch cards, Decwriter 120s, and KSR-33s. I think punch cards were a hair easier then ed, though. Hallelujah for the creation of glass teletypes as we called them! White or green text on black background, 80x24 text only display. Not much later we migrated to [Textronix 4010](https://en.wikipedia.org/wiki/Tektronix_4010) family - actual vector graphics! Mainly I remember 'ed' as a Huge Pain In The Posterior. Mostly I wrote programs on paper then typed them in; I don't miss those days one bit.
Compile it and look at the disassembly. To quickly and easily do this for other compilers use &lt;https://godbolt.org&gt;
Well, I just have tried at the page you linked and it seems like there is no dereference in the assembly. (Even after I deepen the nest of sub-struct.) &amp;#x200B; Thanks.
What version of Visual Studio?
 .text .file "opt.c" .globl main # -- Begin function main .p2align 4, 0xcc .type main,@function main: # @main .cfi_startproc # %bb.0: movq __retguard_1942(%rip), %r11 xorq (%rsp), %r11 pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp pushq %r11 pushq %rax .cfi_offset %r11, -24 movq FuncSet@GOTPCREL(%rip), %rax callq *(%rax) xorl %eax, %eax addq $8, %rsp popq %r11 popq %rbp xorq (%rsp), %r11 cmpq __retguard_1942(%rip), %r11 je .Ltmp0 int3 int3 .Ltmp0: retq .Lfunc_end0: .size main, .Lfunc_end0-main .cfi_endproc # -- End function .hidden __retguard_1942 # @__retguard_1942 .type __retguard_1942,@object .section .openbsd.randomdata.retguard,"aw",@progbits .weak __retguard_1942 .p2align 3 __retguard_1942: .quad 0 .size __retguard_1942, 8 Your main.c is named opt.c on my machine. I am not able to read it, but perhaps it helps :)
You will never pass the exams without reading the texts and papers prescribed. You are stuck at something thats on like page 5 of any textbook about programming. I would seriously reconsider what you are doing.
Do you thing is feasible/recommended for one who is learning C with K&amp;R to use this method? You used to write the program in paper in some form.is psuedocode? Or literally the program source code and then just copy?
Please post your whole code and format it If your code is too long, post it here: [https://pastebin.com/](https://pastebin.com/) and send a link
Weren't the Symbolics Lisp machines 36-bitters? Since I recall that Symbolics derived from former MIT AI hackers, and MIT AI was "36-bit heavy" in that they had a lot of PDP-10 systems.
&gt; ASR33 I'm very slightly miffed that we in the computing field have the name/designation backwards. It's a "33ASR". properly. Because it's a "Teletype Model 33, Automatic Send-Receive"; because there were other models of Teletype machine (for ASCII, the main alternates are the beastly Model 35 family, and later the Model 37 that supported lower case).
I remember my algorithmic teacher, he would teach us basic procedural imperative stuff (conditions, loops, records, subroutines...), And have us write the algorithm on paper. Then he would do the same on the blackboard and implement it in VB.NET directly after. This man was an analyst programmer for the French military and then IBM, if memory serves, and the whole process back then was apparently one team writing the algorithms, and the other typing the code, corrections, testing ... I was taught programming this way more or less 5 years ago and it took me at least 4 of "write first, debug later" to realize how efficient the "design first, write later" method was... Nothing beats (for me) the notebook+pen technique before the buffed up IDE. Too many times have I trapped myself in my own code, forced to rewrite because I didn't do that
Publicly admitting that you write monolithic functions is brave.
/r/showerthoughts
I don't get what you're referring to but a line over heard a few times is "i did it in one line".
I have used TECO on an ASR33 to edit FORTRAN and BASIC on a PDP-10 compute.. You kept a vision of the few surrounding lines in your head. If you needed refreshing, you could print a few lines below your current position and a few lines above. I used forward search to move to the next bit of code to work on. Every now and then I printed the file out to get the complete picture. File sizes were necessarily smaller.
Current-loops are used for signals in MIDI cables, standardized in the early 1980's (https://en.wikipedia.org/wiki/MIDI#Electrical_specifications). Allows them to isolate the receiving device to avoid ground-loops, which is very important for musical instruments, but I do not know if there are any similarities with earlier cables used for terminals.
I read through much of this thread to get here, and only now realized that I also grew up learning to program in BASIC and essentially line-editing programs. GWBASIC was like a line editor integrated with a BASIC interpreter. Fun thing I remember was there was a built-in command to re-number lines, because even if you started out and with using lines 10, 20 30 etc , sometimes you had to stuff in more than 9 new lines between old lines, so you typed in something to make it change all the numbers to space them out to multiples of 10 again. I guess if you were editing C in a line-editor you would have something more like a proper "insert new line" command instead, since there are no linenumbers in C.
This sounds interesting, but I don't understand the constraints of your problem (for instance it's unclear which arithmetic operations are allowed/disallowed) and even if I did it sounds like you understand the gist and just haven't coded it out yet. In general, we're happy to help when we see that you're trying, but this looks an awful lot like you want someone to do your homework for you. We're more willing to help if you show code, or detailed algorithms in pseudocode, accompanied by specific questions that point out where you're encountering problems. In the future please put code and pseudocode in code blocks by prefacing each line with 4 spaces. 
There are two extremes here, and we don't have data to show which one is which case. &amp;#x200B; In one, you have hundreds of lines of duplicated code that were refactored to make better use of repeated logic. That's the case you are mentioning, and there are very, very few cases where a monolithic function like that is a good idea. &amp;#x200B; Then there are examples like: &amp;#x200B; printf("I'm an unrelated thing.\n"); while (i &gt; 0 ) { printf("I'm just something that's doing work in the loop: %d\n", i)); i--; } That could be rewritten as: for (printf("I'm an unrelated thing.\n"); --i; printf("I'm just something that's doing work in the loop: %d\n", i)); Which is "shorter", yet less readable. &amp;#x200B; &amp;#x200B;
Sure. I would (and still do) start with mad scribbles on scraps of paper and a white board* followed by a rough pseudo code treatment of the data structures and the interaction of each of the modules. From there you would commit the actual code to paper. You would then play computer and run the program by hand writing down intermediate values as you went. This is the moment where you consider if you are checking error conditions, inputs and arguments for reasonable values. If something goes wrong you want to know the place where your model has broken. Once sure it was good to go you would walk (uphill in the rain) to the data center to type it in and give it a run. Given the availability of an editor, I would suggest doing the final bit in the editor, just resist the temptation to keep trying it out over and over as you go. The point of the exercise is to drive home the need to really understand what it is you are about to produce or make changes to. This understanding will help you identify what is wrong when the results don't line up to the model you have initially put forth. When debugging, resist the urge to just try stuff out until it works. You need to be able to understand what the problem is and that with some certainty the change you are making will address it. And just to make sure it is understood, in the Real Work^tm we're not writing entire programs by hand any more, so understand this exercise is intended to build good habits early while you are learning -- it's not a recommendation to hand write all your code. Once you grock a language and [are able to follow basic coding principles](https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style) (get this book) you will be able to go straight from a design document to code. I do strongly advocate a thorough design before beginning, regardless of your level of experience. A final note, given this sort of training I landed my first job as a C coder having only read the K&amp;R book. I had never executed a line of C code prior to getting that job, but I had written many C programs. \* my little 8 1/2 x 11 inch white board I bought in school is probably the best thing I ever purchased in regards to programming. I only recently retired it and started using a Surface as a white board. You can't walk through a program or understand data structures without a white board.
&gt;spaces The arithematic operations are as follows +,-,\*,/,(,) and these 4 numbers 1,2,3,4 can be used only once. Now this part is the most tricky part. And this is not my homework. I tried looking up and people suggested me to watch Object oriented programming and algorithms. How would that help? There is no place on the iternet that explains how to do permutation using c. So...i thought i could ask here. 
&gt;used Like if you have used 2=(3\*2)-(4\*1) ...See here the numbers have been used only once. 
Yes, the CADR, Symbolics, and MIT machines were 36, though Symbolics or TI later extended that. It was why Symbolics couldn't port Genera to typical machines, and had to go from the MacIvory to the 64-bit Alpha. I never had a licensed Genera for my Alphas in the 1990s, though. But those were all single-user machines. OS2200 was/is multi-user, though it's still not a very good timesharing operating system from what I'm told. I was actually misremembering on MCP, which is/was 48 bits, like OS/400. 
I heard about WolfSSL, but never had enough motivation to switch to it from Openssl. Please tell how easy it was for you to start with it, once you try this out
Check out [this](https://en.wikipedia.org/wiki/High-level_synthesis) and [this](https://en.wikipedia.org/wiki/C_to_HDL).
Thanks, I saw those. My problem is that there’s too many to try out. I dwelved into GCC2Verilog, read documentation, etc... and then found out that only documentation about how nice it is is available online. I work full time as a developer and my time is limited, that’s why I was hoping to find someone who has dealt with this and can give me a heads up. Thanks tho! 
I'm pulling this out of thin air, so it could be completely wrong, but if I recall correctly, the fastest teletypes were 300 baud. 
Have you tried to run the snippets in HLS? Have you looked at the HLS tutorials from Xilinx? Have you tried Google?
Well, if you want to use OOP you likely want a different language than C, but frankly I don't see how it would make this job any easier. A basic understanding of algorithms and algorithmic efficiency would help you here though. The internet has plenty of resources for what you're trying to do, and this subreddit is one of them. It's just that we're not super excited to help people with non-trivial problems when it seems they haven't even written a single line of code. What I will say is that I'm not sure how you expect to permute these operators and operands in a meaningful way that still allows you to calculate a value. C doesn't allow you to store operators in variables, and while you could make functions out of them and manipulate function pointers to them, you will likely have a hard time doing that with `(` and `)`. The alternative would be to write an interpreter for strings containing your operands and operators, but that's also a lot of work. Moreover, iterating through permutations looking for a specific value is relatively inefficient. It may be better to store values and permutations together to be looked up later so that values that don't match the value you're on weren't wasted calculations. Most importantly, this is a non-trivial problem that if you're absolutely new to programming will be difficult to do, especially with C. You will likely want to work on other things first before you tackle this.
I think you may be asking the right question, using the wrong terminology. What you’re asking for used to be called “C to gates”, but is now called “High Level Synthesis” (HLS). It’s a huge focus area in FPGAs, particularly from Xilinx. Take a look at https://www.xilinx.com/products/design-tools/vivado/integration/esl-design.html
Yeah, I’ve tried Google which results in many things, which most are not available online or are for commercial use, hence not free. Isn’t Xilinx’s Vivado environment pay to use? 
Thanks, I will check it out. :)
It depends - some versions are somewhat free - but if you’re used to the “everything is free” software world, you’ve got a bad time coming. The FPGA world is all locked up and proprietary. It sucks, it’s what it is. 
Problem is the proffessor is used to everything being free, so it is a requirement here, he even hopes that I find a tool which would work under windows. lol
Professor might need some "re-educating"... Regarding windows - most of the tools work in the space on Windows (it's the commercial world after all...). 
Looks like "webpack" (the free version of Vivado) may support HLS (see [https://www.xilinx.com/products/design-tools/vivado/vivado-webpack.html](https://www.xilinx.com/products/design-tools/vivado/vivado-webpack.html)) 
Yeah, I didn't write C back then, but I did some machine language without an assembler, just a monitor. Did a lot of it on paper first with comments and labels, then worked out what things would be in machine code.
Fascinating read, thank you. 
Additional question, was the "write" function in unistd.h built before or after stdio.h and is printf built using the write function?
You could probably write books on some of those topics, so I'm going to skim over your list: &gt; How is the C of 40 years ago different from the C today? You can go look up what's been added in the language specs, but the core language hasn't changed a whole lot. This is... actually kinda problematic in some ways, as C does not have built-in support for things that are now standard on almost all computers (graphics, networking, multicore/multithreading, Unicode/foreign language strings, etc.) &gt;How did they output “Hello, World!” because nowadays we have the &lt; stdio.h &gt; library. You write the library, probably in assembly at first and then maybe a mix of C and assembly once you have your C tools working. You can go look up how something like `printf()` actually gets implemented under the hood. &gt;If C is so close to assembly in performance why isn’t it used to make large open world games like GTA 5? C (often with assembly for really performance-critical bits) was the standard language for game development for a long time. I think the source code for DOOM and Quake is available online if you want an idea of how games were written back in the 90s. As C++ compilers and tools have gotten better, it's generally possible to get very very close to C/ASM performance as long as you avoid using certain C++ language features (exceptions, RTTI, parts of the STL). Some engines use custom libraries, like EASTL (an STL implementation designed for game engine use, originally by Electronic Arts.) The extra few percent of performance you might wring out by writing all your code in C is generally not worth the headache. Although I imagine there might still be a few very-performance-critical pieces of code in Rockstar's engine that are written in C or even directly in ASM. &gt;How is C so so good that someone made it 40+ years ago and we still use it? The lower-level a language is, the less it will change over time -- if you want "portable assembly" with essentially zero runtime overhead, and that can run on almost anything, it's hard to beat C. &gt;(I heard that security is a big concern, can someone explain why?) C was not designed to prevent you from making mistakes. It's tedious and error-prone to correctly handle memory allocation and really robust error checking, and when things go wrong in a C program it can go really off the rails. A lot of higher-level languages automatically check many many things for you, or provide built-in language support for things you have to do yourself in C. &gt;Why did this not become the de facto programming language for all tasks? It was very popular for general application programming for a long time. But as computers got faster, making programming easier and faster became way more valuable than the (often slight) performance gains you'd get by writing things in a lower level language. Many newer languages also make it easy to call into something like C/C++ code when you do need better performance -- so you can write most of the application in a high level language like Java/C# or even a scripting language like Python, and call high-performance libraries when you actually care about what you're doing being fast. Maybe your GUI would be twice as fast if you wrote it in C... but unless you absolutely need to squeeze every ounce of performance out of your computer it's not worth it.
So I'm not perfect on the origins of C, but stdio.h was standardised very early. And all that really is is the compiler vendor writing a bunch of functions that everyone can call. It's not significantly different than a library in any other language is. The only difference is that stdio.h is defined in the C standards to have certain functions that must do certain things. The reason C isn't commonly used at all levels is that it simply isn't necessary to have your entire application (be it a game, an IDE, a website) written in the most performance-critical way. Most of the time you aren't bounded by the speed of the processor, you're bounded by human interaction times, file or network read and write, etcetera. The need for faster performance is only necessary in a few areas like graphics processing. And that sort of thing will all be done in low level languages, which the higher level languages can call. That's basically what things like OpenGL or DirectX are, they're just high level wrappers around low level code written for performance. Regarding performance, some early (and maybe some current, haven't played in years) version of Minecraft were notoriously badly performing. This was commonly blamed on it being written in Java. That's not the whole truth; the real situation is that Notch wasn't the greatest programmer and Java makes it easier to shoot yourself in the foot in certain areas like memory management and garbage collection. It was slow because it was badly written, not necessarily because it was a higher level language. C doesn't have OOP but can implement it. It just involves manually creating jump tables of functions and loading the right ones. It's a right pig to keep track of in general, and its a lot easier to screw up as the compiler will do much less for you. The problem with C is that is is a lower level language. In general it will probably take longer to do something in C than it would in a higher level language (until you build up a large collection of utility function to perform those kind of high level abstractions. And congratulations, you've effectively just written a higher level language). The trade-off for this is that the C code is likely to be more performant, or at least easier to tweak so that it can be. For embedded systems, you probably want to look at things like bitshifting, which are much more common in low-memory and low processor speed environments than they might be in other C applications. Probably best to ask others about that though, I'm not an embedded C developer. 
The main issue with C is it is too close to the metal. It is efficient but it also means you can shoot yourself easily. When you work in a large project, this kind of power is like giving everyone a nuclear bomb instead of a say a batton. It is hard to manage such code with C, without a lot of rules of coding and having everyone follow the rule. Modern languages like Java and Python are designed to curb the destructive powers while offering human-friendly programming construct that allows us to organize complex ideas. So that we can think in complex ideas without reducing everything down to the machine. This is why we have OOP for example. 
Thanks. I’ll check it out after work! 
&gt; How did they output “Hello, World!” because nowadays we have the &lt; stdio.h &gt; library. That depends on the specific system you are targeting. **stdio.h** is not magic, just a relatively thin abstraction layer that allows you to handle I/O in the same way for different systems. &gt; If C is so close to assembly in performance why isn’t it used to make large open world games like GTA 5? Because of the lack of OOP? If you want to write a complex program (such as GTA 5), you want abstractions that can hide away as much complexity as possible. C has very little in the way of abstractions (for instance, it all but requires you to manage memory by hand), so writing complex stuff in C is usually harder than, say, C++ or C#. &gt; What is OOP really and what are the issues primarily C programmers face because of the lack of it? OOP essentially means encapsulating functions and the relevant data in entities called objects, in such a way that the code that uses a given object only has to worry about what it can do with the object, rather than how (for instance, you can have different objects that expose functions with the same declarations and different definitions). You CAN do OOP in C (https://stackoverflow.com/questions/351733/can-you-write-object-oriented-code-in-c), it's just that the language itself doesn't make it easy. &gt; I heard that security is a big concern, can someone explain why? Because of the relative lack of abstractions, most implementations of the C language allow you to read and write anywhere in memory with little to nothing to stop you. If you make a mistake, you might allow an attacker to fool your code into reading and/or writing whatever they want. &gt; C seems like the kind of language that can be used to make just about anything(big or small) work. Why did this not become the de facto programming language for all tasks? You can use most programming languages to make anything you want. It's just that some languages are better in certain areas. C is pretty good for low-level work, but you wouldn't want to write the next GTA (or even a web page) in C.
I'll do my best I guess. 1. I'm not an expert here, but in general there wasn't as strict a spec 40 years ago and differences in implementation caused some problems in regards to making code portable across platforms or compilers. A lot of what I just said is likely wrong. 2. It isn't used because responsible C++ has comparable performance and more features. C is used for some games, some of them pretty huge. For the ones where C++ is used (and in general where C++ is used for high performance systems) the programmers stick to a style that is much more reminiscent of C. For more information on modern, performant game development google Data Oriented Design. Performance improvements would likely be marginal if you switched over, but for a large enough system it may be noticeable. 3. OOP isn't super well defined in my experience. Inheritance seems to be a must, along with a handful of other useful things, but I tend to avoid OOP so somebody else will have a better answer. In general C programmers don't face that many issues from a lack of OOP. Many of the features can be implemented in C with enough work, but usually the best tactic is to use the language as it is to tackle your problem. If you find yourself in a situation where you're considering OOP with C you probably need to either rethink how you're approaching your problem, or use a different language. 4. C was developed in tandem with UNIX and we've kept it as a basis for all our operating systems. It's "so good" because nobody has wanted to take on the monstrous task of replacing it with a whole new system from the ground up, and if anyone has they weren't very successful. I wouldn't say there are issues so much as there are limitations; no OOP, limited generics support, etc... It's not that C is bad or lacking, just that its creators couldn't see the future, the committee is careful with new features, and software development has evolved rapidly over the course of 40 years. Security issues with C is largely due to the language trusting the developer completely. As a result it doesn't check for certain possibilities, like buffer overflow which can allow malicious actors to write over areas of memory to which they are not meant to have access. It's simple enough to combat by being aware and up to date on vulnerabilities and implementing safety checks in your code. 5. It's an exceedingly simple, but powerful language. You can make anything with it, but there are many instances where you need to prototype rapidly, or where performance isn't your main goal, or where your bottleneck isn't going to be the performance of your software, and in these instances it's more reasonable to use languages that aren't as performant in exchange for ease of use or maintainability. That's not to say that you can't do things rapidly with C, but it's a less common skill in the work pool. 6. This area is not my forte. A lot of people will tell you to get an Arduino which (as far as I know) will teach you how to program in a modern dialect of C++ meant for embedded systems (where you use a C standard library with C++ to leverage lightweight procedural programming with the added benefits of OOP when you need it; see answer 2 above). There is nothing wrong with Arduino, but if you want to use C and only C you may wish to pursue a different path. Hope that helps. Please feel free to correct me below; I'm sure I've spouted a bunch of false or misleading nonsense.
Write is a system call, printf is not. This is a large enough difference that they end up in different sections of the manual (2 vs 3). When printf flushes it's buffer it does indeed call the write system call to send the data to the file descriptor. There isn't really any other good way to do it. As to what came first, I don't know. Write is Unix-specific, printf is not. All systems with a C compiler have printf but some do not have write. 
Looked into Vivado and it turns out it’s really good, but I consulted the professor and I need a universal tool. Vivado’s HLS is for Xilinx devices only and even if you have bought it, it’s illegal to even try to use it for a non-Xilinx FPGA, so it’s a no-go. Thanks a lot for the suggestion, tho. 
[removed]
I finally learned how to use ed a few days ago and I can see myself writing a program in it.
&gt; This is... actually kinda problematic in some ways, as C does not have built-in support for things that are now standard on almost all computers (graphics, networking, multicore/multithreading, Unicode/foreign language strings, etc.) It is not problematic; rather, it's a strength of C that these don't exist as it makes the language easier to port. Networking, multithreading, and advanced locale support are out of scope for C. That's the job of system-specific libraries; a standard for these exists with POSIX. 
OK, let me try... &gt;How is the C of 40 years ago different from the C today? How did they output “Hello, World!” because nowadays we have the &lt; stdio.h &gt; library. C is different than it was 40 years ago in many ways, but the basic gist of it is still the same. We are now at C18 (published standard by the ISO), before that we had C11, C99, etc. stdio is almost as old as the language itself (and has similarly evolved as well). Before there was stdio there were other low level libraries that developers would either create for themselves or that were specific to the computer / operating system they were working with. &gt;If C is so close to assembly in performance why isn’t it used to make large open world games like GTA 5? Because of the lack of OOP? If a game like GTA 5 was made in C instead of what I assume was C++ what kind of performance improvements could be estimated? I know nothing about GTA5, except that it is a popular game. But I know that for large complex projects like it, developers will always use a variety of programming languages and tools. I would be somewhat surprised if there wasn't any assembly and C in there, even in GTA, especially to optimise the most math-intensive parts of the program. &gt;What is OOP really and what are the issues primarily C programmers face because of the lack of it? "What is OOP really" is a matter on which many books have been written. Essentially it is just a way to organise software. Many programming languages make it easy to work with object oriented concepts by providing specific features. C doesn't have these features per se but that doesn't mean you can't program in an object oriented manner in C. You would just have to do a little more work yourself and apply some discipline. Please understand that OOP is not magic. There are other ways to organise code too. &gt;How is C so so good that someone made it 40+ years ago and we still use it? What are some known issues about it that we know today? (I heard that security is a big concern, can someone explain why?) 40 years ago people were using binary digital computers, we are still doing that so in a sense nothing much has changed. Even if everything is faster now, moving more bits around per cycle etc., the basic principles remain the same. So that's how a programming language from that era that was continuously updated can still be going strong. Security in software should be a concern of every programmer, but in many cases C programmers are more directly responsible for it because they are working so closely with the operating system and the computer. It's easy to make a C program crash by incorrectly using memory. It's also very easy to overlook conditions under which your otherwise perfectly functional program can be made to crash (or be exploited) by others. Some basic "best practices" will help prevent this. &gt;C seems like the kind of language that can be used to make just about anything(big or small) work. Why did this not become the de facto programming language for all tasks? For many tasks, doing them from scratch with C would just be too much work. If you want to quickly make something with a user interface for example, you don't want to have to write the routines to put pixels on the screen to form buttons that a user can click on. You use a language and a toolkit/library that has already done this work for you. In quite some cases that language and toolkit will have been made with (you guessed it) C. &gt;Once I am done with all the basics(variables, functions, pointers, etc) how can I step into programming for embedded systems? A. Get yourself an embedded system. B. Ask yourself what you want your system to do, make a plan. C. Start programming it. &amp;#x200B;
A commercial quality game may take, say, six years to finish writing it in C but may only take four to write it in C++ and you might not even be able to tell the difference in performance when you sit down and play it.
&gt; Many newer languages also make it easy to call into something like C/C++ code Can you elaborate more on this? I did this by compiling my library into a shared object/dll and used python's `ctypes` to call my c functions. Is this method the "right" aproach? I looked on how to do it on other languages and was kinda lost.
It's not entirely problematic, but it is problematic *in some ways*. For one, it makes a very large segment of a lot of the software that gets written require more up front decisions before any business problems can be solved. Want to write a web server? You're going to need to write a lot of stuff yourself that you wouldn't need to write in other languages, as well as pulling in libraries to do a lot of what other languages do in their STL. But it's not entirely problematic either, as you say it makes it easier to port C. Every language has tradeoffs to picking it, and every project is going to be different. If you need to eke every last bit of performance you can, and you want to run on a bunch of different devices, you basically want C. But if you're writing a web server you probably don't want to use C. 
How do you create any kind of static-const object other than a string without having to create a new identifier name in that scope? I suspect that Microsoft's balking at some of C99's features may have stemmed in part from their semantics are murky enough to limit how they can be used efficiently. Given something like: int boz(struct foo const *p); void test(void) { for (int i=0; i&lt;1000; i++) { boz(&amp;(struct foo){1,2,3,4,5}); boz(&amp;(struct foo){i,6,7,8,9}); } } a compiler that can't see the definition of `boz` would have to generate much less efficient code than it could generate for: int boz(struct foo const *p); void test(void) { static struct foo const s1 = {1,2,3,4,5}; struct foo s2 = {0,6,7,8,9}; register int i; for (i=0; i&lt;1000; i++) { boz(&amp;s1); s2.firstField = i; boz(&amp;s2); } } because it would have to allow for the possibility of `boz` might casting the received pointer to a non-const one and using it to modify the passed-in object (an action which would have defined behavior if the original object was not const-qualified). In many if not most of the situations where one could use compound literals, their use would compel compilers to generate less efficient code than would be necessary if code were written using the other pre-existing forms. If the authors of C89 had recognized gcc's statement expressions as an optional-but-recommended feature, that would have made it possible to do something like: void doSomething( ({static const struct foo it={1,2,3}; &amp;it}) ); to invoke `doSomething` with a pointer to a static const instance of `struct foo` which held the proper values, without creating a new identifier in the current scope. A bit ugly syntactically, but fixable via macros. The biggest semantic weakness is the lack of any way to invite a compiler to merge multiple such delcarations all use the same object, something that could be done by making `register` a type qualifier rather than storage class, so one could write the above as: void doSomething( ({static const struct foo register it={1,2,3}; &amp;it}) ); A `register` storage qualifier could maintain its semantics, and its usefulness for single-shot compilers, by defining the following semantics in cases where its address is taken: 1. If the address is ignored, the `register` qualifier would have no effect. 2. If the object is `register static const`, the address may be assigned to an object of a `const`-qualified pointer object; the compiler may substitute the address of any `static const` object which holds the same value. 3. If the object is `register` qualified but not `static const`, the address may be passed as an argument to a function; when this is done, a compiler may at its leisure pass the address of a temporary object which is initialized to match the register-qualified object and, if the object was not `const`-qualified and its value will be used later, copying the value back after the function returns. Such semantics would allow some useful optimizations not possible with `restrict`, especially if compilers were allowed to assume that a `register` qualifier in a prototype would also appear within the definition, so that given e.g. void foo(int register *p); void bar(); int test(void) { int x; foo(&amp;x); x++ bar(x); x++; bar(x); return x; } the compiler could substitute: void foo(int register *p); void bar(int x); int test(void) { int register x; int temp; foo(&amp;temp); x=temp; x++ bar(x); x++; bar(x); return x; } without having to allow for the possibility that `foo` might store the address of `x` somewhere accessible to `bar`. If such semantics had been employed, the semantic problems associated with the lifetime of compound-literal objects would be eliminated. 
&gt;Why did this not become the de facto programming language for all tasks? One thing none of the other answers seem to point out is that C pretty much *is* the de facto programming language. Unix, Linux, and Windows were all written in C. Most scripting languages themselves (Python, PHP, etc) are written in C. C++ started as pre-processor macros that converted the source code to valid C, and almost any C code is valid C++ code (there are a few exceptions). Pretty much any language that is used for anything non-trivial will have a way to call libraries that were written in C. As others have pointed out, there are usually better languages for the job that make things easier on the developer. Even if you go your whole career never programming in C, you are using it indirectly every day.
Actually FORTRAN is faster than C in many cases, though I almost hesitate to call it human readable. C has a much nicer syntax for sure though, and printf doesn't use 4 spaces in between arguments.
It's worth noting that unless you're some sort of super compiler wizard who is also very knowledgeable about the platform you're writing code for, C/C++ will sometimes if not often be *faster* than writing straight assembly. The compiler knows all sorts of tricks for doing things like maximizing the CPU's ability to pipeline instructions or make use of other features of the hardware that take more foresight to fully capitalize on.
Unfortunately it has become clear that for threading to work properly the language needs to to be defined for it. This is why c11 has threading in it and a memory model defined that says how threads are allowed to share memory. 
c language is function oriented language where we create functions call them and so on. On the other side OOP which is not in c is a way of programming by creating objects . we can have class that contains methods and this can be accessed with objects. like consider it this way that car is class. it has attributes like color ,tyres etc and methods like driving, braking etc. Now this can be called by creating an object of class car as "ABC" . now ABC is your car model with all the features of car. this is raw idea od OOP and there are much more.using C this is not immposible but it becomes more complex. and becasue C resembles nearly both system and humans i guess its still working after 40 years 
This is bullshit; threading in C worked fine before C11. And they could have defined a memory model without defining their weird `threads.h` API.
That was a great SO read 
C++ has a better structure than C and can do the same things C can do if you have a compiler for the target platform. C++ header files are just so much better in and of themselves. I would most times prefer C++ over C if the rest of the ecosystem for both was equally good. If you are a really good C programmer, then you can reach assembly level performance. This mostly depends on the programmer tough, not the language (except some virtualized, garbage collected, languages like Java). C++ can also use C header files almost seamlessly.
That sounds like the correct thing to do. Other languages often have to deal with the "managed to native" issue, where the higher level language (the "managed" language) has to deal with calling out of its own environment and into C's environment. This gets pretty messy pretty fast. Python doesn't have that issue as it effectively runs in C under the covers.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Can you post the first 20-something lines of the file you're reading (enough to cause the problem)?
tconst titleType primaryTitle originalTitle isAdult startYear endYear runtimeMinutes genres tt0000001 short Carmencita Carmencita 0 1894 \N 1 Documentary,Short tt0000002 short Le clown et ses chiens Le clown et ses chiens 0 1892 \N 5 Animation,Short tt0000003 short Pauvre Pierrot Pauvre Pierrot 0 1892 \N 4 Animation,Comedy,Romance tt0000004 short Un bon bock Un bon bock 0 1892 \N \N Animation,Short tt0000005 short Blacksmith Scene Blacksmith Scene 0 1893 \N 1 Comedy,Short tt0000006 short Chinese Opium Den Chinese Opium Den 0 1894 \N 1 Short tt0000007 short Corbett and Courtney Before the Kinetograph Corbett and Courtney Before the Kinetograph 0 1894 \N 1 Short,Sport tt0000008 short Edison Kinetoscopic Record of a Sneeze Edison Kinetoscopic Record of a Sneeze 0 1894 \N 1 Documentary,Short tt0000009 movie Miss Jerry Miss Jerry 0 1894 \N 45 Romance tt0000010 short Exiting the Factory La sortie de l'usine Lumière à Lyon 0 1895 \N 1 Documentary,Short tt0000011 short Akrobatisches Potpourri Akrobatisches Potpourri 0 1895 \N 1 Documentary,Short tt0000012 short The Arrival of a Train L'arrivée d'un train à La Ciotat 0 1896 \N 1 Documentary,Short tt0000013 short The Photographical Congress Arrives in Lyon Neuville-sur-Saône: Débarquement du congrès des photographes à Lyon 0 1895 \N 1 Documentary,Short tt0000014 short The Sprinkler Sprinkled L'arroseur arrosé 0 1895 \N 1 Comedy,Short tt0000015 short Autour d'une cabine Autour d'une cabine 0 1894 \N 2 Animation,Short tt0000016 short Barque sortant du port Barque sortant du port 0 1895 \N 1 Documentary,Short tt0000017 short Italienischer Bauerntanz Italienischer Bauerntanz 0 1895 \N 1 Documentary,Short tt0000018 short Das boxende Känguruh Das boxende Känguruh 0 1895 \N 1 Short tt0000019 short The Clown Barber The Clown Barber 0 1898 \N \N Comedy,Short tt0000020 short The Derby 1895 The Derby 1895 0 1895 \N 1 Documentary,Short,Sport tt0000022 short Blacksmith Scene Les forgerons 0 1895 \N 1 Documentary,Short tt0000023 short The Sea Baignade en mer 0 1895 \N 1 Documentary,Short tt0000024 short Opening of the Kiel Canal Opening of the Kiel Canal 0 1895 \N \N News,Short tt0000025 short The Oxford and Cambridge University Boat Race The Oxford and Cambridge University Boat Race 0 1895 \N \N News,Short,Sport 
You don't need to tell me much about pre-360 machines; I'm a classic computer nerd and pre-360 is one of my fields of interest (7094 is "neat" in a word); though my main "love" is DEC's minis ('11s, '10s, '8s, and '15s; with some VAX on the side). Interestingly, you can emulate Burroughs MCP as it existed on the B5500 in SIMH, as you can also emulate ITS on the SIMH KS10. I also know a guy (Richard Cromwell, the one who contributed the B5500 sim to the SIMH project) that's working on bringing the KA10, and KI10 (and maybe in the future the KL10) to SIMH. I find the architectures that are not "normal width" to be interesting (where "normal" is defined as 8, 16, 32, or 64).
It's good and bad, I guess. You don't end up with a bloated language or insanely complex required libraries (looking at you, Java). But then you either have to roll your own version of just about everything, or find libraries to handle stuff for you. Some things (3D graphics, say) seem reasonable to leave out of a low-level language/its standard library... others (networking, for instance) are much more questionable these days. Not having a good memory/threading model built in also kinda sucks. Even if you don't want to use C++'s `std::thread`, `std::atomic` makes writing portable thread-safe code a lot easier in my experience. Not to mention things like generics... I had to write a high performance buffer-based lockless queue in ANSI C once. It would have been a lot less ugly in C++.
It's lightly modified pthreads, and locks need to interact with the memory model and so need to be defined with it.
So why didn't they just standardise a proper subset of pthreads then? It's modified so much that it can't be implemented as a thin wrapper on top of pthreads in some regards, making it annoying to implement and to maintain.
Smarter people than I are answering your questions, but I just wanted to chime in that I am impressed by your curiosity. A lot of people come to this subreddit and outright ask homework questions, but you appear to have a real enthusiasm and thirst for knowledge about computer science. Keep that enthusiasm - it will serve you well in your professional life!
This subreddit is about programming in C only. Please spam your product elsewhere. Or preferably, don't spam it at all.
I've never seen the getline function before, but if it's taking the address of the variable n, it is probably assigning a new value to it, possibly the count of chars read. Then you are using n below it thinking it holds the value 2048, which causes problems somewhere else. I didn't inspect the code further but I'm confident that getline function is the perpetuator.
Here's the situation in your tree right before the crash: Un bon bock (L) The Sprinkler Sprinkled (L) The Sea (R) NULL (R) NULL Your code then tries to rebalance this, but crashes in the process. It tries to do a `leftRotate` on the "The Sprinkler Sprinkled" node, but that doesn't have a right node.
&gt; how is fread populating the structure with data? It isn't. The code is wrong and `fread` will be writing somewhere it isn't supposed to.
So the above example is writing to a garbage pointer, pointing to some arbitrary location in memory, overwriting whatever is already there?
yes, or crashing with a page fault / segmentation fault
`getline` is a [POSIX function](https://linux.die.net/man/3/getline). The way OP is using it is fine (though I'd initialize the pointer to `NULL` instead of pre-allocating a buffer ... and the return should be compared against -1, not `EOF`). OP needs to `free` that buffer and the (dubious) copy made with `strdup).
Just tried running again to look at the tree before the crash and now it's crashing after 7 lines rather than 21 lol...it's also run to 39 lines a few times before crashing which makes absolutely no sense to me. What would cause it to crash earlier if I changed literally nothing about the program?
Run in a debugger and it'll stop exactly at the point where something went wrong.
Jesus if you can't Google this and come up with an answer, you're fucked for using HLS. 
What’s interesting here is ‘the platform you’re writing code for.’ Even if you’re such a whiz at your platform, the compiler is a whiz at *all the platforms.* There are some situations where code is guaranteed to run only on one platform ever and never need porting, but the vast majority of programmers will probably find more value in the flexibility to let the compiler give them 95% performance on all the platforms rather than 100% on one platform and 0% on the others.
&gt;It is not problematic; rather, it's a strength of C that these don't exist as it makes the language easier to port. Networking, multithreading, and advanced locale support are out of scope for C. That's the job of system-specific libraries; a standard for these exists with POSIX. I agree with this wholeheartedly. It's not the job of a programming language to provide all solutions. Libraries are a better way to do that.
&gt; The main issue with C is it is too close to the metal. One of the major strengths of C is that you can account for every little detail. One of the major weaknesses of C is that you must account for every little detail.
Conversion specifiers. They tell printf/scanf which types you'd like it to attempt to convert strings to/from.
Oh, derp, of course, string conversion. Thanks.
I tested under GCC, Clang, and MSVC. Under all three this indirect call is optimized if, and only if, you use link-time optimization (LTO). clang -flto -O3 main.c foo.c gcc -flto -O3 main.c foo.c cl -GL -Ox main.c foo.c 
C11 has a memory model and atomic types. 
&gt;Please understand that OOP is not magic. There are other ways to organise code too. "C++-like" OOP is when you put the first parameter of a function call to the left instead of the right. You can write it in C using function pointers and a big ol' struct as the first parameter. This is commonly found in OO systems like glib, ffmpeg, etc. Message-based OOP (Smalltalk, Objective-C) is much more powerful and not quite as easy to write by yourself.
Are you a wizard?
Also a C programmer here. Do you use C at work? What's been your most "unique" application of the quirks of C? Do you feel, like I do, that most C is actually very clean and "idiomatic" and a lot of the reputation C gets for being scary and weird comes from corner cases with publicity? 
When and how will I ever get pass pointers? :( On another note, people keep saying the best way to learn is getting yourself involved in a project. I need to finish fundamentals to take up projects. Yet C's fundamentals and super frustrating at times and to my knowledge, I have not seen any project based fundamental book/course. I'm going through C primer plus right now and am stuck at pointers. Losing motivation every day.
I find that C code gets a bad rep because people over engineer the shit out of everything they do like they're on a quest to make their software worthless.
If you can't get through pointers you're gonna have lots of trouble man. Hit them books!
There’s no such thing. All FPGA tools are highly proprietary. 
Chocolate or vanilla?
Assuming you've posted all of the relevant code. If I saw this, I'd assume there was a malloc() call in there between those two that's allocating memory for the pointer.
Take a step back from the code and focus on understanding how memory is laid out.
Re: pointers, try to get away from coding a bit, and instead work on understanding what your program's memory looks like. Practice reading code and sketching out what the memory looks like as you step through the execution. To diagram: draw a line down your page. The left side is for the stack, the right side is for the heap. As you work your way through your code, draw boxes for each new item that your program adds to memory along with it's type. Try to draw it in a meaningful way based on size, or whether or not the memory is contiguous (ie. an array). Each new item you add to your diagram should be labeled with a type. Each item in your diagram should be given a value if applicable. If the item you add is a pointer, draw an arrow to the thing it points to. (That arrow *is* the pointer's value). If the pointer's value gets reassigned, re-draw the arrow. If a pointer gets dereferenced, follow the arrow to the box it points to, and so on. Once you start to visualize memory (rather than just trying to understand it abstractly) understanding the code becomes much easier.
K&amp;R or C89?
C99 all the way. Designated initializers are just to good to pass up.
C is a simple language *semantically*, in that it is fairly easy to track what it is doing. The difficult part that scares people off, I think, is the syntax. As a beginner it is easy to get lost among all the ampersands, asterisks and tildes.
The secret to "getting" pointers is to realize that everything in your program has an address, and that that address can be stored in a variable. That is what a pointer is.
Are you strcatting to newString, that's missing a \*newString = '\\0'; ? Is 32 bytes enough ? You are losing track of the strdupped memory, in main(). &amp;#x200B;
Thank you very much!
Precisely.
I should note that I use ctrl+c to break the program, but I did this in both cases.
Did you press Control+C there? I strongly suspect that was rendered by your `cmd` application directly, and that it has nothing to do with your program.
&gt; I should note that I use ctrl+c to break the program, but I did this in both cases. In the second case, you must have signalled an end-of-file condition. On Windows I think this is Ctrl+Z.
Watch [this video](https://youtu.be/t5NszbIerYc) and try solving some [Advent of Code](https://adventofcode.com/) or [Codewars](https://www.codewars.com/?language=c) problems.
And compound initializers, anonymous member structs or unions, local loop variables, boolean types, explicit-width integer types...
Hello fellow dvorakee! Thank you for your response. I didn't know ctrl+z triggers the EOF, thank you; I've just been using ctrl+c. Why does ctrl+c work in some cases but not others? Why would in one case it breaks the program and returns \^C and in the second case it break the program and returns the expected value (i.e. number of characters)?
&gt; Hello fellow dvorakee! Sorry, I qwerty. &gt; Thank you for your response. I didn't know ctrl+z triggers the EOF, thank you; Nor did I, as I don't use Windows. But that's what Google tells me. &gt; I've just been using ctrl+c. That _should_ simply terminate the program.
Well it's not very C related ...
There will be C courses! 😊
Cool, thank you. And yeah, your name would be aoeui in dvorak anyway haha. Thanks for the info.
Or the function is allocating memory internally, though this is less common.
There's no actual content here. You have to sign up with an email address. The first address I tried never got an email. The second address I tried gave me a big, fat error page: SQLSTATE[22001]: String data, right truncated: 1406 Data too long for column 'email' at row 1 (SQL: insert into `mailing_lists` (`email`, `updated_at`, `created_at`) values (&lt;redacted&gt;, 2019-03-30 13:39:40, 2019-03-30 13:39:40)) The site has debugging enabled so the crash gives me a very detailed stack trace including source code, app key, server configuration, database configuration **including password** (you should really choose a better password, and it probably shouldn't start with "xLearno"), etc. Using that information I confirmed I was able to connect to your database, too. This does not inspire confidence for a site that's all about teaching exactly these technologies! 
Your using notepad. . . What a god
Nailed it. My other point is (and I didn't test this) that they are probably identical as byte code.
Sometimes I think that maybe all of the embedded C stuff I do is a giant conversion specification -- we're always converting some crap into some other crap. Other C language naming thing I heard: Kernigan and Ritchie invented the term "initializer" as the name for the thing that's the equal sign and value after the variable declaration. As in the trailing parts of char foo = 'X'; char bar[] = "This is a string"; int foobar = 2112; This is why nobody understands what we're talking about: we're making up the words too.
Cool, good to know :-P Initializer gave me a second's pause (K&amp;R is what I'm learning from), but it was close enough to 'initial condition' from my math days that I caught that one. Going back to school for comp sci, hoping to get into embedded stuff myself! 
*you're
I'm cursed with dyslexia 
chocolate
I agree, pointers are a pain in the balls. I got past pointers by just playing around with pointer management functions (malloc,memcpy,memchr, etc.) a lot.
abracadabra!
Have sympathy and pity on those who's required compilers don't support C99, at least.
I still deal with some. It's such a trip how tiny they are, and yet so delecate. And through modern CPUs how insanely fast. Remember when pre-compiled headers were going to save C++? Lol like it even matters anymore. It is so cheap to build a 40 core monster to absolutely rip through builds. It's great. But so much time running stuff through parsers to strip // and making k&amp;r prototypes. 
&gt; Do you use C at work I'm an unemployed high school student. &gt;What's been your most "unique" application of the quirks of C? Not mine, or really an application, but I think [toledo nanochess](http://www.nanochess.org/chess3.html) is pretty neat. This 1257-character C program is a fully functional chess engine. I think C's "strongly typed, weakly checked" paradigm made it possible to create this program using such little lines of code. &gt;Do you feel, like I do, that most C is actually very clean and "idiomatic" and a lot of the reputation C gets for being scary and weird comes from corner cases with publicity? I do! Although C gets hate for having many [obscure features](http://www.ioccc.org/), it's possible to create functional programs without them. I think C has a reputation for being scary because it's very minimalist. Most people start out with a high level language and get used to the luxury of having pre-coded "vectors", "exceptions", or "stringstreams" at their fingertip. When they move to C, there's none of that. Either you download an external library, or you code your own.
That's not how this works
printf is a variadic function (it means it can take 'n' argument , Check "man stdarg"). for example ! : printf ("%d - %lf - %c ...", 10, 15.23, 'X' ...); using stdarg "va\_arg", we can keep getting from one argument to the next until there are no more ! For example : int a = var\_arg( ap, **int**); so they are called conversion specifications, cause when printf iterate over the first argument to get the type of the comming ones ! if it find %f, it automatically know that the next "va\_arg()" call will be : float b = va\_arg(ap, **float**) ! i hope i explained well ! and sorry for my bad English ! &amp;#x200B;
Fuck off you dirty spammer. I have already removed your previous post. Don't spam this garbage again!
That’s better than avada kedavra. Which I kinda deserved for such a cockamamie question. 
 const int main = 12790448; Try it out!
Does it require a specific OS or C runtime?
We have a client who uses an aging 8 bit architecture and a compiler from a french company I'll not name. My guy on that project has that as one of his gripes. Never used much C++: Always doing too much bare-metal microcontroller stuff. Another unnamed IDE company makes an IDE that they charge for that uses GCC for ARM (Client's choice, most definitely not ours). Somehow that IDE cripples the build speed. I think they must have used oxygen deprived squirrels to implement their make-equivalent build manager in there. (Oh, and you can't reliably goto definition / declaration in the IDE either.) &lt;/gripe&gt;
This is /r/c_programming. 
Only works on x86 processors, your mileage may vary.
Man, if you're having trouble with this ..
That semi-colon
The short answer is no. The long answer is please show us the actual code, because this has clearly been modified, and we can't know if your modifications actually broke something.
Hi, thanks for replying. my code is not 'broken' per se, Im just stumped how I can show two different options in **chooseOperationType()** if the calling function is from **showOptionAdmin()** or **showOptionEmployee()** If i write the chooseOperationType() options, it should look like this void chooseOperationType() { ////IF CALLING FUNCTION IS FROM showOptionAdmin() if( from showOptionAdmin() ) { printf("ADMIN OPTIONS"); printf("\n[1] View Client Balance"); printf("\n[2] Deposit/Withdraw"); printf("\n[3] Activate/Deactivate Client Account"); printf("\n[4] Close Client Account"); printf("Choose number: "); } ////IF CALLING FUNCTION IS FROM showOptionEmployee() else if ( from showOptionEmployee() ) { printf("EMPLOYEE OPTIONS"); printf("\n[1] View Client Balance"); printf("\n[2] Deposit/Withdraw"); printf("Choose number: "); } }
What about global variable?
This kind of situation is a good sign that you actually need two functions (maybe with a common function they call), or your function needs another parameter to identify which behavior to follow. The simplest case in the context of what you're wanting to do would be a "caller" param with known values. Personally I would instead choose to refactor here. A trick such as caller-dependent behavior might be neat in a language like Python, but with C, while technically possible, it's a more complex pattern and fraught with peril. But also usually not necessary.
Its sadly restricted, but if this comes down for naught, I might just use a global variable and just take the deduction in points, on a side note: Declaring a struct outside the functions is also considered "global variable" right? [pic for reference](https://imgur.com/a/MhXWKFf)
Yes
Does creating another function take away the main action of the prescribed functions by the created function? sorry, its the teachers "restriction" &gt;You may add more functions as aid to this functions, but do not take &gt;away the main action of the &gt;Prescribed functions by your created functions void chooseOperationType(); - THIS FUNCTION IS FOR PROMPTING USER TO SELECT DESIRED VIEWING CLIENT ACCOUNT. WHEN IN ADMINISTRATOR ACCOUNT, THIS WILL SHOW THE [4] FOUR OPTIONS AND WHEN IN EMPLOYEE ACCOUNT, ONLY [3] THREE OPTIONS ARE SHOWN
You can walk the stack and find out who is calling you. This is platform dependent. There is no feature such as reflection in C. You have to provide that functionality. In C though, why do you want it? What are you trying to do with it? 
Doesn't the for loop have to take a statement? 
in the code im supposed to create, chooseOperationType() should have no passed variabled but it needs to show two very different options if its called by either **showOptionAdmin()** or **showOptionEmployee()**. So the question above popped in my head 
Gonna offer constructive advice or just make fun of a beginner? 
Writing a single semicolon on the next line is a very common way of showing that the body of the loop is empty on purpose and not by accident.
I see now
Your terminal will print `^C` when Ctrl-C is pressed, it isn't from your program output.
Thank you. It's still weird though that in the first instance I pressed ctrl-c and the program ended and display the count but did display ^C, and that in the second instance I pressed ctrl-c and the program ended and did display the count and did not display ^C. Any thoughts as to why? 
Haha, thanks. Was told years ago that when learning a language/principles to not use an ide until you're comfortable doing it long form. So here we are :-P
1. 40 years ago we only had no standards for C. It was quite a bit different and worked on UNIX only. K&amp;R tried to standardize the language but different platforms had slightly different features. The preprocessor became the first thing that was tandardized. We used #ifdefs every where depending on compiler and target. Prototypes and headers could be a pain in the rear. There was no #pragma once or anything like it. Today we have ANSI C. Prototypes, headers and the preprocessor work a little differently. 2. The reason you're not going to develop GTA 5 in C is because C it is horrible at high level abstraction. You can make GTA 5 in C, but what a mess of a code base it would be. 3. C is not an OOP language, though you can do OOP with C. You need to develop a brokering system. 4. "How is C so so good that someone made it 40+ years ago and we still use it?" This is honestly a stupid question. Why is the notation we use in mathematics today still so good? Age has nothing to do with somethings utility. 5. In the late 80s, C and Pascal were the defacto language for PC software development. You can develop what ever you want in any language. 6. If you learn C and basic computer architecture, you will have no issue moving to develop software for embedded systems. You will need to learn about the hardward and/or OS you're targeting. These are really API and system specific issues. As far as addressing hard, set your pointer and go.
&gt; without passing on the char choice variable since I 'cant' do that because of the restrictions my teacher placed Are you *certain* that `main()` can't pass `choice` on to the `showBlah()` functions? Has your teacher directly told you so? Because that is the right way to do this. (Well, okay, the whole "having the same function to print help for both admins and employees" violates [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns). And you're violating [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) by having multiple functions be the exact same code to print a menu and take a number as input. So the overall design of the program is not great. But anyway...) If `main()` isn't allowed to pass parameters to the `showBlah()` functions, can the `showBlah()` functions pass a parameter to `chooseOperationType()`?
I just want to clarify the restrictions since info is all over this thread 1. No global usage 2. No parameters passed to chooseOperationType (it must be `chooseOperationType(void)`) What functions are you not allowed to modify? In your OP you state "I cant modify the given function". Which function are you referring to? I ask this because it seems like you're referring to chooseOperationType, but it also seems like you are going to have to modify these lines to have a functioning program: if( from showOptionAdmin() ) else if ( from showOptionEmployee() )
The return has nothing to do with the preprocessor. That's for the compiler. 
&gt; Compiler the code with gcc's -E option How do I do this? The only compiler I used was in leetcode, do I need the terminal for this?
Hello, actually the void main shoud have been a log-in page with a preset values for admin/employee accounts but I changed it to the one above to make it 'simpler' but yes, my teacher gave us a pdf file with a list of functions needed for the program together with it's passed parameters and showOptionAdmin() , showOptionEmployee() and **chooseOperationType()** have no passed parameters in the pdf. this is a simplified version of what void main() should be in my code, void main() { char admin[50]="admin"; char apassword[50]="admin123"; char employee[50]="employee"; char epassword[50]="employee123"; char username[50]; char password[50]; printf("\n\n\n\t\t\t\tUsername: "); gets(username); printf("\t\t\t\tPassword: "); gets(password); if(strcmp(username, admin)==0) { if(strcmp(password, apassword)==0) { showOptionAdmin() } else { printf("\n\n\t\t\t\tINCORRECT ADMIN PASSWORD"); getch(); } } else if(strcmp(username, employee)==0) { if(strcmp(password, epassword)==0) { showOptionEmployee() } else { printf("\n\n\t\t\t\tINCORRECT ADMIN PASSWORD"); getch(); } } else { printf("\n\n\t\t\t ERROR! INCORRECT USERNAME"); } }
The questions youth asks. Line editors were birthed out of the teletype days. Once CRT's became popular, the line editor for development died quickly. ed was a hold over command from Multics. I never saw anyone use it for anything other than email or editing configuration files. To load emacs could take 1-3 minutes. ed took 4-10 seconds. 
Yes.
Hello, my teacher gave us a pdf file with a list of required functions together with its passed parameters. We are not allowed to modify the functions and its passed parameters that are in the list. showOptionAdmin(), showOptionEmployee() and chooseOperationType(), All have no passed parameters so I cant modify them to let "char choice" to be passed on the chooseOperationType(). &gt;if( from showOptionAdmin() ) &gt;else if ( from showOptionEmployee() ) Sorry, that was just an 'example' "if statement", if knowing who the previous function who called chooseOperationType() was possible, 
You may have pressed Ctrl+C twice the first time. Try it a few times and you should be able to figure how it exactly behaves.
Use a global variable, and if you're not allowed to use a global, then check for the address of the calling function. Every function has its own address, just as every variable. void* func_ptr = (void*)(&amp;my_function); if (func_ptr == &amp;showOptionAdmin) { } if (func_ptr == &amp;showOptionEmployee) {} There you go. 
Or you can try this one: https://www.tutorialspoint.com/compile_c_online.php It will let you set the -E compiler option (remove -o) in the Project dropdown under "Compile Options". Then you can see on the right hand side what gets fed to the compiler itself. 
If you can't use a global, then use function pointers. 
I simply cannot believe that your teacher would forbid the passing of parameters. If I were in your shoes, I'd email them and directly ask if they are sure that function parameters aren't allowed.
I'm getting the following error: $gcc -E main *.c gcc: error: main: No such file or directory What must I change the execution command to? Also the thing at the top, here `$gcc -E main *.c` is what gets accessed first right, that's the compiler I guess
Remove "main". 
Do you know how to use the address of function? Every function has an address, just as every variable. I don't want to give you the code, but this is relatively easy. This sounds like an assignment you're supposed to completing on your own, without the help of the internet. 
Lol I just want to test out C code, never even heard of preprocessor macros until today when I came upon this solution. Any brief guide to those? I guess I'll download the windows GCC. Also does the #else or (#if 0 if available) act as the "main.c"? Because how else are you executing this function without a main?
I don't want to anger either fanbase so I'll go with C99
If you don't know what the preprocessor does or how to use it, just remove use of it. And I think that little sandbox app. adds it's own main. Not a great way to learn C, IMO. 
Hey man, if you dont wanna help, then it's fine. Im just here to ask the question above since Im trying to stick to the "restrictions" set by the teacher. I've already finished coding the program but with 1 global variable just to differentiate between Admin/Employee Accounts. Now Im just trying to remove the global variable as to not violate the restriction.
I took a course in this winter on C, but we did not cover preprocessors, it was mostly focused on the memory model. Rather than looking at leetcode solutions right off the bat, would it be better to use something like CP:AMA and start off where we left in the course?
I don't know what that is. 
C Programming: A Modern Approach
 for(nc = 0; getchar() != EOF; ++nc); he was probably expecting something like this
To stay within the requirements, you could let the user select admin/regular from within chooseOperationType(), instead of main(), which is called by main() and then displays the appropriate menus and calls your other functions. No globals or params that way and you get the desired behavior.
That's awful advice
C11 &gt; C99 &gt; K&amp;R &gt; C89 &gt; C90
What are your restrictions set? No passing choice, and also no globals? Pass the function you need as a function pointer. void showOption(void (*fptr)(void)) { ... fptr(); } void main() { ... if (choice == 1) { showOption(&amp;showOptionAdmin); } else { showOption(&amp;showOptionAdmin); } } 
It doesnt really matter. 
What are your restrictions? No passing choice, and also no globals? Pass the function you need as a function pointer. void showOption(void (*fptr)(void)) { ... fptr(); } void main() { ... if (choice == 1) { showOption(&amp;showOptionAdmin); } else { showOption(&amp;showOptionEmployee); } } Function pointers are your friends. 
Is it? Doesn't that mean I'll learn good form without the good form being externally imposed? 
No, please use an ide or at the very least notepad++
&gt; as you need to declare and set the enum to each of the values you need. If you use consecutive values then you don't have to specify each value in the enum declaration. 
Sounds like you want a struct.
Wouldn't I need to declare a variable of the enum type, and then set that variable to one of the enum states before using it as the index? I can't do something like "int age = x\[2\]\[myEnum.AGE\];" for example?
 struct indices { int FNAME = 1; int LNAME = 2; int AGE = 5; }; Something like that?
No, I mean use structures instead of arrays for your data.
No... that's not even valid C. Use a struct to store your data, not an array.
Isn't it `x[2][AGE];`? Or use a structs as other have recommended. 
I think you are getting the idea of what the #if, #else and #endif is doing in some parts, but missing some others. So lets do a quick recap. So take this example below. Just like /u/ahminus suggested you can run this in the compiler at [https://www.tutorialspoint.com/compile_c_online.php](https://www.tutorialspoint.com/compile_c_online.php) #include &lt;stdio.h&gt; //Try changing this to DEBUG 1 #define DEBUG 0 int main() { printf("Main Start\n"); #if DEBUG int test = 20; printf("DEBUG ON\n"); #else int test = 30; printf("DEBUG OFF\n"); #endif printf("test is [%d]\n", test); printf("Main End\n"); return 0; } So what is going on in this example? well we have a simple main, a few prints and this pre compiler syntax #if DEBUG, #else and #endif. If we check above we set that DEBUG is equivalent to 0 so this is equivalent as what you have in your section above. You will notice it also has two declarations of int test, which normally you would be unable to do since they are inside the same scope. The reason that this will compile is because part of this code will be compiled, and part will not be based on if the #if is true or false. Running it as is gives us the result $gcc -o main *.c $main Main Start DEBUG OFF test is [30] Main End So back to why is there a return NULL; at the very end of the github you linked. When the #endif is reached, it is not ending the compilation of the code as a whole, it is just the end of the pre compiler section. Because it is not the end of the code, we must have a return type because the function int* twoSum requires a return of a pointer to a int. In this particular function, reaching this return means that they wanted to return NULL as a fail safe and it didn't get to one of the "return indices" on lines 38 or 61. This last one is needed because there is a chance they will never make to to those lines and a function that returns something has to be able to get to at least one guaranteed return. You can do some very interesting and powerful things with the pre compiler options. Here is another more interesting example. I hope this helps! #include &lt;stdio.h&gt; //Try changing this to DEBUG 0 #define DEBUG 1 #if DEBUG int add_stuff(int a, int b, char* debug_message) #else int add_stuff(int a, int b) #endif { #if DEBUG printf("This message was called from [%s]\n", debug_message); printf("a: [%d]\n", a); printf("b: [%d]\n", b); #endif return a + b; } int main() { printf("Main Start\n"); #if DEBUG int test = add_stuff(10,10,"Main()"); printf("DEBUG ON\n"); #else int test = add_stuff(10,20); printf("DEBUG OFF\n"); #endif printf("test is [%d]\n", test); printf("Main End\n"); return 0; }