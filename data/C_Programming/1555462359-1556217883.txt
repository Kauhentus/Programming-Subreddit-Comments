I would recommend installing Xcode (It's free). You can write generic/UNIX C apps using it.
I‚Äôve been through this hours and hours before. With the newer macs (I think Sierra onward?) it‚Äôs impossible to get GDB going. Just switch to lldb or use VSCode‚Äôs in app debugger using lldb. Sorry :/
Noted. Thanks for the additional suggestions. Improvisation will make this feel like a greater accomplishment, if I can get it to work.
&gt; But, there‚Äôs a problem. Python allows objects, as in Object-Oriented Programming (OOP), but C does not. Therefore, I have to figure out how to emulate objects using C. This sentence from the article is not correct. It should state that Python supports ~~supports~~ OOP while C does not. It is also worth mentioning that Python was originally written in C. Which means that the objects in Python had to be implemented in C.
I tried to get gdb working on Mojave around a month ago. After going through the whole codesigning snafu, I pretty much ended up with the same issue you're having, at which point I gave up. If you're really keen, you might want to try submitting your results to the [gdb mailing list](https://www.gnu.org/software/gdb/mailing-lists/) and hopefully a dev might see it and assist, but I wouldn't hold your breath. If you're not attached to gdb, I'd suggest you use lldb instead which is well supported in OSX.
Aims to replace C... that is a tall order, and I hope it succeeds!
Thanks for the help. Yeah, my professor has it running on his Mac but it‚Äôs possible he just hasn‚Äôt upgraded his os.
It does, eclipse doesn‚Äôt support it is all.
No problem. The only other thing would be to use a VM with Linux if you absolutely need GDB. I did that with my courses (especially when I need Valgrind)
How does lldb compare to GDB?
You really need to pay attention to this thread - carefully look at who said what - take your foot out of your mouth - then delete the above comment.
Have you thought about switching over to Visual Studio? I know learning a new IDE can be daunting, but VS is a really good IDE. Personally I found it auite intuitive as well, but it was my first IDE so maybe it set the standards for me.
&gt; Zig intends to be so practical that people find themselves using it even if they dislike it. Oof.
Visual Studio or VS Code? Are you on a Mac?
Full Visual Studio for me is a much better experience, Visual Studio Code is still good but somehat clunky at times. Currently not a Mac user but am literally on a train to buy one because I need it for iOS apps, since I'm an Android dev who is branching out. If everyhting goes smooth with my Mac purchase I can contact you when I get settled and install everything, I do use VSC seldomly for PHP, last time I used VSC on Linux for it.
No, fuck that. Install Xcode, and use lldb.
Yeah, so uh quick correction. Visual Studio and Visual Studio Code while technically available, don't support writing C or C++ on Macs. MacOS's native IDE is Xcode, which is free in the app store.
Yeah, so uh quick correction. Visual Studio and Visual Studio Code while technically available, don't support writing C or C++ on Macs. MacOS's native IDE is Xcode, which is free in the app store.
I feel your pain. I'm running High Sierra with a working copy of GDB but it was _painful_ to make happen. OP may want to just run a Docker container for debugging or learn lldb.
Thank you for the correction. To give you proper credit, I took a screen capture of your comment and inserted it into the article.
The `atoi` function is for converting srtings (that is, `char*` to numbers. A `char` is not a string.
Sorry. Didn't explain well. I have to take every decimal input typed and use atoi to turn them into integers. If the input is not a number I want to ignore it. That's why I'm using atoi. I know about the num thing, but was specifically asked to use atoi.
It's frustrating when teachers teach their students bad habits. If you must do this, you could use a `char [2]` and copy the single digit of interest into it. Don't forget to terminate it. But that's all unnecessary make-work. In C, by definition the decimal value of a digit `c` is `(c - '0')`.
The first would be a valid octal literal without the underscore.
Since you're asking about pointers in C++, rather than in C, you should try asking in /r/cpp_questions instead.
A good place to start would be getting the latest set of XCode Commandline tools. Check [this link](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/) for a quick rundown. If you have already installed the brew package manager on your machine, you already have this. This will provide you with all the executables you need to make your program. Not sure what you‚Äôre doing in C that requires environment virtualization. If you could explain your situation in more detail I might be able to help.
Why do you want us to do your homework? Refer to your class notes to solve this exercise.
 cc -O2 -pipe -o test3 test3.c test3.c:6:21: error: unknown type name 'string' int main (int argc, string argv []) ^ test3.c:27:22: warning: incompatible integer to pointer conversion passing 'char' to parameter of type 'const char *'; take the address with &amp; [-Wint-conversion] int num1 = atoi(num); ^~~ &amp; /usr/include/stdlib.h:101:23: note: passing argument to parameter here int atoi(const char *); ^ 1 warning and 1 error generated. *** Error 1 in xy (&lt;sys.mk&gt;:85 'test3') I deleted cs50.h because I don't know what that is. &amp;#x200B; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; int main (int argc, char *argv[]) { if (argc != 2) { printf("Usage: ./caesar key\n"); return 1; } for (int i = 0; i &lt; argc; i++) { for (int k = 0, n = strlen(argv[1]); k &lt; n; k++) if (isdigit(argv[1][k]) == 0) { printf("Usage: ./caesar key \n"); return 1; } else { int num1 = atoi((char *) &amp;argv[1][k]);// a string ends with a '\0', if you use a char, it's not the same printf("Success\n %d \n", num1); // changed to num1, because num makes no sense to me return 0; } } }
Zig got uninteresting to me when they got rid of `goto`. The reason being that they don't want any redundant control structures. I mean, wtf?
Try using all four in a program and ask the compiler which one is a syntax error.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
An object is a region of data storage in the execution environment, the content of which can represent values (cf. ISO/IEC 9899:2011 ¬ß3.15). It is very difficult to program without using any objects in C. Clearly, this is not what you meant when asking for objects in C. So what do you mean?
Pretty much everything the above comment says. I program in C on a Mac and haven't had any issues so far. Installing XCode commandline tools gives you gcc and make using which you can build C programs.
You can also get GCC (or a different compiler) trough Brewüç∫
https://www.youtube.com/watch?v=rX0ItVEVjHc http://voodoo-slide.blogspot.com/2010/01/amplifying-c.html
I guess you failed to read just before my 'minimalism' line.
Good luck, here's the pile for you (feel free to add yourself): - C++ - D - Rust - Go - etc - etc - etc
Not a single one of the languages you mentioned intends to fill the same niche as C. Zig does.
I don'tunderstand your question. Also, it seems you forgot part of your code. Also, please indent each line of code with four blanks to format it as code.
Nim. Rust. D. C++. Objective C. All of these do.
So if I am right in understanding the challenge here you need multiply all even number within a range from N to M together.. If that's all you are doing you can just add a result \*= i inside your if statement. Expanded that statement is result = result \* i; in case you weren't aware. Then print your result.
C/C++ is not a language. C is a language and C++ is a language. This sub is for C. If C++ is what you want try r/cpp or r/cpp_questions
*this time it's different, trust us, TM*
Just curious, why? What is a major pain point for you that c has that zig fixes?
&gt; printf("Usage: ./caesar key \n"); &gt; &gt; return 1; &gt; &gt; } &gt; &gt; &gt; &gt; else &gt; &gt; { &gt; &gt; int num1 = atoi((char *) &amp;argv[1][k]);// a string ends with a '\0', if you use a char, it's not the same &gt; &gt; printf("Success\n %d \n", num1); &gt; &gt; return 0; &gt; &gt; } &gt; &gt; } Ok. Don't really get you but I'll take a look more. Thanks.
Thanks. Can you please explain what you did. Thanks again.
Rust, D, and modern C++ definitely don't share the approach to development of C and they belong to wildy different categories of languages. Nim and Objective-C admittedly do, but OP didn't mention them.
No blog spam please.
Well I'm not saying Zig will be successful in the long run (it probably won't be). My point is that you can't think of it as another Rust or D, which mostly compete against C++ rather than C.
Specifically, I have Python code with a class. I want to convert the code to C as a self-imposed academic exercise.
Check out vtables. That's how you typically implement class-based polymorphy.
 int main (int argc, char *argv[]) I changed `string argv [] to char *argv[]` , because there is no such thing as a string command in plain C. `char *argv[]` is a char pointer collection, pointing on strings &amp;#x200B; char num = (char) argv[1][k]; int num1 = atoi(num); printf("Success\n %d \n", num); return 0; `char num = (char) argv[1][k]` sets a singel character into 1 byte of space defined as a char. atoi() won't read that, because atoi wants a pointer to a char-array. If you put a &amp; before num, it won't stop reading until it reads a '\\0' or a letter, because strings are defined to end with a '\\0'. &amp;#x200B; atoi() returns an int which outputs all the numbers on the start of the string to the end or first thing which isn't a number. &amp;#x200B; Example: char *exa[] = "12a"; // same as: char *exa = { '1', '2', 'a', '\0' }; printf("%i\n", atoi(exa)); // will return 12, because it stops the moment it reads 'a'
 int main (int argc, char *argv[]) I changed `string argv [] to char *argv[]` , because there is no such thing as a string command in plain C. `char *argv[]` is a char pointer collection, pointing on strings &amp;#x200B; char num = (char) argv[1][k]; int num1 = atoi(num); printf("Success\n %d \n", num); return 0; `char num = (char) argv[1][k]` sets a singel character into 1 byte of space defined as a char. atoi() won't read that, because atoi wants a pointer to a char-array. If you put a &amp; before num, it won't stop reading until it reads a '\\0' or a letter, because strings are defined to end with a '\\0'. &amp;#x200B; atoi() returns an int which outputs all the numbers on the start of the string to the end or first thing which isn't a number. &amp;#x200B; Example: char *exa[] = "12a"; // same as: char *exa = { '1', '2', 'a', '\0' }; printf("%i\n", atoi(exa)); // will return 12, because it stops the moment it reads 'a'
I found some code online. I'll compare its functionality to the Python code I want to convert.
Don't copy some random code you found on line. Instead, read the [Wikipedia article](https://en.wikipedia.org/wiki/Virtual_method_table) and understand the underlying principle!
I read that first, actually. It makes sense because I've used classes before.
Im a huge advocate for innovation and creativity. Its not that i dislike C, but I also realize C is almost 50 yers old. The fact that it still is extremely popular today os the reason why I said its a tall order to fill. It looks like Zig is very young in its development, and I personally, wont be using it anytime soon, but I am giddy that their are people who took the challenge to see if it can be done.
&gt; Visual Studio and Visual Studio Code while technically available, don't support writing C or C++ on Macs. Visual Studio Code supports writing C or C++ on macOS. You can also use the llvm debugger from the Visual Studio Code interface.
`char *wtoken[50];`
You don't seem to be assigning anything to wtoken[I].
`tt=wtoken[i];` ??
That's assigning the value of wtoken[I] to tt. The thing you are assigning to needs to be on the left hand side of the =
Guessing isn't really the optimal approach here. Try something more reliable.
Cool, thanks for explaining
Oh shit, i forgot! Thanksss
How are they separated in your string? Say each letter is separated by a space. Then use get to add the dashes/dots to a temporary char until you hit the separator, then translate that char into a letter and add it to a different variable.
I got bad news. This is the C reddit, not the C++ reddit.
C doesn't have binary integer literals. [C++ does](https://en.cppreference.com/w/cpp/language/integer_literal), though, and some C compilers might support that syntax as an extension.
Even though they are different, they still want to fill the same space.
ok i will remembered that, thanks for the justify
Purely off the top of my head, you could do it using a state machine. Assuming each char is a dot, dash, or space, you'd have states in an enum of {none, seendot = 'E', seendash = 'T', seendotdot = 'I', seendotdash = 'A', seendashdot = 'N', seendashdash = 'M', etc.}. If you see a space, you are already pointing at the char to output. If you see a dot or a dash, you use a couple of nested switch statement to go to the next state based on the state you are already in. E.g. if you see a dot and you are in state none, you got to state seedot. If you see a dash and you are in state seendashdash, you go to state seendashdashdash. The main downside is there will be a lot of typing. The upside is it will be fast and fairly easy not to screw up.
So what happened to the c-amplify project?
Easy, objects are structs: typedef struct { int ID } Person; and methods are functions, which take the struct as the first argument: int get_person_ID(Person person) { return person.ID } Most OO languages just provide the first argument for you, which is what a method is. A method is just a function which has the pointer to the struct filled in automatically. The way this is done can vary, but the point is that the only difference is that you have to provide the struct explicitly as the first argument. I've personally never used inheritance, so that would be a non-issue for me. Encapsulation in C can be achieved by exposing an "interface" as a shared header (.h) file, which only contains declarations (not definitions) of the functions you want the files which include that header to be able to see and use: ;in interface.h int get_person_ID(Person person); &amp;#x200B; ;in API.c #include &lt;interface.h&gt; &amp;#x200B; and then in the actual implementation .c file, you'd have the "private" functions which the public functions rely on, but aren't explicitly exposed to the user. For example, if you didn't want the user to be able to directly call "get\_person\_ID" you could leave it out of that header file. Any functions that *were* exposed that use it, could obviously still use it because they'd be defined in the .c file which also contains those functions. Opaque pointers (google for an explanation) can also be used for encapsulation. Sorry if the code is incorrect in some places, I haven't done much C for a while.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Thanks, this is great. I actually plan on doing 2 exercises: 1 without pointers (new to me), and then 1 with pointers (to figure them out). Baby steps!
Aight, thanks for the reference
I have to ask: is there any reason people rush to create new languages rather than extend existing ones? I've always liked the idea behind ratfor as an example. I'd also note that what C lacks might be the languages strong points, at least in my opinion.
No, those languages intend to fill the void created by them.
Because if you extend C you get Objective-C or (imho even worse and no true superset) C++.
I presume as the code isn't in English this isn't their first language, be nice
This is cool, but not as useful as the ability to parse C header files. Now that's seamless interoperability: https://ziglang.org/documentation/0.4.0/#Import-from-C-Header-File - maybe worth having to depend on the moving target that is LLVM I don't understand the reasoning behind bundling libc versions. Why deal with updating unrelated packages when security issues appear?
Everyone fancies themselves a language designer. When Zig had goto, people complained about it. Take away goto, people complain about it. A programming language can't be exactly what everyone wants. Conflicting desires require it has to be a compromise for some people. And that's why: &gt; Zig intends to be so practical that people find themselves using it even if they dislike it. That includes you - I look forward to seeing you again, when you find yourself using Zig despite losing interest over not having goto.
 double cpu_time_l = ((double) (end-begin))/CLOCKS_PER_SEC; end = clock(); You're calculating your run time with an uninitialized `end` variable. Swap the order of these statements.
I think the point is that no one likes pictures of code (especially hand written) and no one cares for straight up copied code, just link the stack overflow and add your own commentary on top of it.
Xcode CLTs does not install actual gcc. `/usr/bin/gcc` is a symlink to `clang` on macOS. Just FYI.
Name your variables better when you're just starting. &amp;#x200B; You might not be collaborating with anyone else, but you sure are collaborating with the you from tomorrow, or a week later.
Oh I see, thank you
Here's your problem: printf("%10.4e ",cpu_time_l); Change that to `%11.4e` and things will line up.
I might be wrong but I'm pretty sure the first letter of variables need to be lowercase.
why is mine negative but theirs positive? I included a screen shot of my fixed codes output, it's no longer negative but I'm wondering why it's not positive
is this also the reason mine is negative instead of positive or is that due to the header items field widths?
Case does not matter for variable names. http://www.c4learn.com/c-programming/c-variable-nameing-rules/ There are however a lot of different conventions for naming variables and a lot of them say that variable names should be in lower case, upper case reserved for constants and firs letter uppercase for classes (c++ or other oop languages). Try looking up snake case or camel case
Do not use the `gets` function. Under no circumstances should you make reference to that function in any context other than with ‚Äúfuck‚Äù before it or ‚Äúmay [] burn in hell‚Äù around it.
There‚Äôs a common subset of code that works between the two languages without change, and it‚Äôs not especially hard to come up with a shim macro layer that makes code work regardless of which language or standard. System headers do exactly this, which is why your compiler doesn‚Äôt shit itself if you `#include &lt;stdio.h&gt;` from C++.
Yeah, there‚Äôs been a bunch of code referring to `cs50.h`, which apparently has typedef char *string; in it because fuck teaching anyone remotely good habits.
I am no expert in this topic, but I think os functions such as\`poll\`, \`epoll\`, \`select\` etc is worth studding. i.e. how to best utilize them in relation to sockets, what to avoid etc.
Why don't you start by learning the tcp/IP protocol before you go into programming it? Make sure you know which concept falls under which osi layer
I recommend you to find something open sourced on [github.com](https://github.com) or somewhere else, the code will inspire you\~ no need to fully understand everything, but the structure or architecture, and then, return to the books, you can find more\~ enjoy\~
pthreads are computationally expensive, so many modern implementations use polling instead. The server polls client connections to determine which are readable, reads from them, and handles them as needed. Rinse and repeat.
'epoll' for linux. 'kqueue' for unix. 'wsaasyncselect' for win32. And fallback to 'select' for everything else. And even then 'select' has non consistent behavior across platforms. I tried writing an abstraction layer around those APIs and had a miserable time of it. I gave up.
Thanks for the information!
I thought I had a good understanding of those concepts. Did I say something in my post that was outright incorrect?
Thanks - I've been doing a lot of that, so you have validated my approach. It feels good to connect the dots from the code I've read in the Sockets textbook and the code in actual programs. It is inspiring and informative.
I'm not sure I totally understand your question, but if you want to multiply all the even numbers between N and M together, you could do something like this: int result = 1; for (i = N; i &lt;= M; i++) { if (i % 2 == 0) { result *= i; } } Link to the [whole program](https://gist.github.com/michael-grunder/a56868659a37722d993201be70f42acc) that also prints out the equation.
Understandable. I was looking at text and wondered how I could decorate it. Long, wordy blog articles (not that this one is terribly long) can be boring. I wasn't expecting anyone to actually look closely at the photos. I expected everyone to see a notebook as a sign of learning taking place. And, to that end, the important thing is that I received many helpful comments on this post.
Nope, the concepts themselves are deceptively simple at first, but it isn't as easy as just syn/SYNACK/ack. You have to understand how packets flow, for example what a gateway/router is and how it comes into picture etc. Most importantly you're gonna want to learn and understand the packet structure. Especially differences in OSI layer. For example what information does a tcp packet contain vs an ipv4 packet and how do they relate/differ?
It honestly depends on what you want to learn but as others have commented, pick a project and do it.
Reason I said you should start learning is not to be like "you're retarded". I meant it as "there might be more to it than you realise, why don't you try reading again and see how much more you can learn?"
[Beej's guide](https://beej.us/guide/bgnet/) might be a useful reference for beginners.
Or Cyclone, and look where that ended up.
Use ZeroMQ.
You need to have knowledge in variety of topics such as threads, gui programming, security and os's api, etc.
I've been recommending Beej's guide for over a decade to people who want to learn network programming. This is the best guide for network programming.
Microsoft has the best socket programming guides and tutorials I've read over the years, with very simple code examples: https://docs.microsoft.com/en-us/windows/desktop/winsock/getting-started-with-winsock https://docs.microsoft.com/en-us/windows/desktop/winsock/high-performance-windows-sockets-applications-2 Equivalent tutorials can be found for Linux using the same keywords. Note that socket programming techniques are very similar between Windows and Linux, so what you learn for one will carry over to the other.
Can't the people that don't like it just not use it?
When they say seamless, will things like macros work and will I be able pull in and use random libs that depend on macros?
I'm still skeptical, but from what I've read it avoids most of the biggest issues with those and is literally a drop in replacement for C. It doesn't add OO features, it doesn't add a borrow checker, it doesn't add a GC. It's aiming to be a better C, not C with more features.
I was considering generating with srand using the current time, ten times then a 1-10 rand to pick one of those as a seed for the final rand.
I considered that, but I can't help thinking that there must be a better way.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { printf("%i\n", arc4random()); return 0; } Multiple execution: ./test5 &amp;&amp; ./test5 &amp;&amp; ./test5 &amp;&amp; ./test5 -1628367109 1825833276 -1887053725 2142475327 OpenBSD &lt;3 (I think you are able to use it on linux, too)
If that happens then zig isn't compelling enough and I will have failed.
I mean the people that don't like Goto can avoid using Goto, not avoid zig altogether.
Read a string and compare it to a table, it's really not that hard... &amp;#x200B; No code, no help
For my intended program (just a small something to make npc creation faster for a dnd setting I‚Äôm slowly working on) I would be having between hundreds to thousands of numbers run at a time, I figure that initial seeding process would set me for the batch
I'm getting errors.
It seems so. But, I need only 1 very random number.
&gt; I‚Äôm getting errors. That is not a helpful description of your problem.
I'd bet you don't use a \*BSD? For linux it's not pre-installed and I don't think it's available for windows at all.
If you want pseudo random numbers seed with the current process ID. If you want just one truly random number check getentropy() from bsdlib.
I‚Äôm not near a computer right now to debug, but there‚Äôs a few alarm bells going off. Have you ever heard of the ‚Äòthree star generals‚Äô of C programming? It‚Äôs not a compliment. There is virtually never that you‚Äôll need a triple pointer, and the only one I can think of right now that I‚Äôve seen in professional code is scandir(). Allocating and using a dynamic array isn‚Äôt as hard or complicated as you‚Äôre making it. Let‚Äôs say I had an int array that I want to be expandable. I‚Äôd start with an empty array: unsigned int elems = 0; int *arr = malloc(sizeof(int) * elems); Now, every time we want to add a new element, we can reallocate the memory needed for the array and add a new element: elems++; arr = realloc(arr, sizeof(int) * elems)); arr[elems - 1] = val; To free, iterate through the array, freeing each element first, then freeing the array itself. Again, I‚Äôm not near a computer to debug, but if you free a variable and valgrind still says it‚Äôs in use, you have a dangling pointer problem. Implementing it in void style is up to you. This is just the simplest way of showing a variably sized array. Linked lists are a bit different, but even still don‚Äôt need triple pointers. You shouldn‚Äôt even be going over 1 level of depth for those.
 struct List { void ***data; int element; int maxElements; }; int list_init(struct List*); void list_free(struct List*); int list_init(struct List* list) { list = malloc(sizeof(struct List)); list-&gt;element = 0; list-&gt;maxElements = 10; list-&gt;data = malloc(sizeof(void**)); *(list-&gt;data) = malloc(sizeof(void*) * list-&gt;maxElements); return 0; } void list_free(struct List *list) { free(*(list-&gt;data)); free(list-&gt;data); free(list); } Formatted your code, please post your main, too (or a short example of it)
In your list_init function, your first assignment `list = malloc(sizeof(struct List));` will discard the value of `list`. Then when the function returns, `list` goes out of scope. Calling list_init will therefore appear to do nothing, except for leaking some memory. When you call list_free later, you are not passing it anything meaningful because your created list never left list_init.
Sorry. The error messages are so much longer than the code that I just assumed that I'm missing something obvious.
Worse, I'm using Android.
I've got the PID working and I switched to doubles. Is getentropy () Linux-specific?
I've never seen or used Android on anything, but a phone, I'm not able to help with that problem :)
It originated in OpenBSD but was [adopted in Linux](http://www.man7.org/linux/man-pages/man3/getentropy.3.html).
That's OK. kloetzl's PID suggestion in another thread works great. Thank you for your suggestion.
PID is doing what I wanted, so thank you very much. The difference in the randomness is incredible.
While not suited for cryptographic purposes as it is pseudo-random, I can personally vouch for the quality of prng generated. http://www.pcg-random.org
main is just calling init and free
Should I be passing a double pointer then? I thought passing by pointer solves the issue of scope since the list is dynamically allocated on the heap, even when it goes out of scope it's still there.
&gt; I thought passing by pointer solves the issue of scope since the list is dynamically allocated on the heap, even when it goes out of scope it's still there. That's not exactly how passing by pointer works. You should treat all variables in function arguments as local to that function. Whatever you pass as argument is copied. If you pass a pointer it is also copied and overwriting it inside the function changes only local copy. However, you can use that copy of a pointer to change the thing it points at and that's what you want here - modify something that "lives outside the function" by referring to it by memory address. If you want to modify the pointer in function, so your change happens also outside of it, you have to pass a pointer to pointer and dereference it in function. ``` void bad_function(struct list *pointer) { pointer = malloc(sizeof(struct list)); /* only local copy of the pointer has changed */ } void good_function(struct list **pointer) { *pointer = malloc(sizeof(struct list)); /* pointer outside the function has changed */ } ```
Is your good function supposed to be dereferencing the pointer?
Then everything you do is undefinded behavior after list\_init. You don't return the address, so you try to free pointers without an initialization value!
Then include it. No-one should have to guess. Having a fully contained ready to execute program is a) a guarantee that you‚Äôll get an answer and b) shows that you value the collective time of the 47777 subscribers more than yours.
This makes me want to look into cryptography....
Try echo back again. And I think this is cpp
Try a C++ subreddit
Post your whole code please
Obligatory mention of [https://en.wikipedia.org/wiki/W.\_Richard\_Stevens](https://en.wikipedia.org/wiki/W._Richard_Stevens) :)
**W. Richard Stevens** William Richard (Rich) Stevens (February 5, 1951 ‚Äì September 1, 1999) was a Northern Rhodesia-born American author of computer science books, in particular books on UNIX and TCP/IP. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; Zig intends to be so practical that people find themselves using it even if they dislike it. This arrogance makes me want to use Zig even less.
Pthread implementations do not scale well at all.
Best place to start.
&gt; will things like macros work I see two mechanisms at work: - using Clang to generate AST from C headers: https://github.com/ziglang/zig/blob/4e2f6ebf398f5d84aa630c4a9ab40c0de3980a72/src/translate_c.cpp#L5020 - macros shouldn't be a problem here - custom parsing for C snippets, probably inside `cImport()`: https://github.com/ziglang/zig/blob/fa9fcab620ada24d9bb7c51a86a1a8944056da02/src/c_tokenizer.cpp#L173
Specifically for dealing with asynchronous network operations, I think most people choose an already-existing library that covers the platforms (Linux, Windows, OSX, etc) they use. https://github.com/libuv/libuv is my favorite for this purpose. Here's some documentation: https://nikhilm.github.io/uvbook/introduction.html . Even if you don't want to use it directly, surely you can learn something from the code and the concepts in the docs.
This makes no sense. rand() operates by keeping an internal state and using a specially chosen algorithm to produce the sequence of random numbers. Which is terrifically vague, I know, but for the sake of illustration, imagine rand() looked like this: int last_rand = 0; int rand() { last_rand = last_rand + 1; return last_rand; } This behaves how rand() behaves except that the sequence of numbers it delivers isn‚Äôt random at all. If you start calling it, you‚Äôll always get 1, 2, 3... what srand does is allow you to set the algorithm‚Äôs internal state, like this: void srand(int s) { last_rand = s; } So if you seed on the current time, your random sequence will start counting from the current time stamp. Seeding ten times in a row doesn‚Äôt make it ‚Äòmore random‚Äô it just changes the starting place (and in a proper algorithm, the order, so you don‚Äôt always get 1000 immediately after 999 unless you use the same seed because you want the same sequence). Similarly, seeding and then reseeding with the first result of rand() doesn‚Äôt make it more random than just seeding once because the algorithm is (should be) designed so that the random characteristics of the sequence generated are maintained regardless of the seed. Seeding once on a time stamp is adequate for 90% of applications. Another 9% are handled by seeding on a stored/known seed because you want to reproduce a particular sequence. If you‚Äôre doing something in that last 1% you probably already know exactly why you‚Äôre doing it and don‚Äôt need my advice.
Do you mean machines that have received a IPv4 address via DHCP. The Windows Server DHCP server supports the following API: [https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-dhcpm/8eeb2e87-1580-4883-8bc3-448f8642f7ab](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dhcpm/8eeb2e87-1580-4883-8bc3-448f8642f7ab)
Before commenting, why don't you start by learning that TCP/IP has nothing to do with the OSI layers, as the OSI project failed and the Internet project won?
That‚Äôs a fair point I had not thought through, seeding from current time then re-seeding sounds unnecessary now. Thank you
You may be able to ping a broadcast address for the LAN to get a list of the machines that answer. That‚Äôs not going to get you machine names but it may be a good start ‚Äî assuming that sort of thing even works anymore.
Yes but they correlate a lot. Firewas are still measured by their layers of inspection like Layer 4 firewall or Later 7.
They have correlations. Firewalls are still defined by the OSI layer they inspect. So I don't think tcp IP has totally won.
ping -6 ff02::1 &amp;#x200B; You are welcome.
&gt;If you want pseudo random numbers seed with the current process ID. This sounds like awful advice if you're trying to get good random numbers. The PID might be only 15 bits, and it's predictable. You can run a program repeatedly and only get no more than 32,768 different results. You should at *least* be mixing the PID and the time, if you don't have a better entropy source available. &gt;Specifically, using the Process ID (PID) allows much smaller numbers to be generated than using the current time seems to allow. Can you explain what you mean by this? Are you saying that your PRNG is biased toward larger numbers when you seed it with the current time? If so, that's a sign that something's really wrong. For Android, have you looked into SecureRandom?
ya -- this is really awful and can be pretty deterministic if, for example, this technique is used by a daemon process that starts with the system. using the PID actually seems like a profoundly stupid idea. &gt; Specifically, using the Process ID (PID) allows much smaller numbers to be generated than using the current time seems to allow. That sentence doesn't make any sense. It is gibberish as far as I'm concerned.
To save my neck here, I have a few things to add. `rand` is infamous for its bad randomness. I suggest using \[PCG\]([http://www.pcg-random.org/](http://www.pcg-random.org/)) instead. You apparently totally ignored my last sentence. *‚ÄúThere is no simple way to produce random doubles without bias.‚Äù* I stick to that; the following code will not give you perfectly distributed floating point numbers. double weights = ((double)rand())/RAND_MAX; For one I doubt that it is uniformly distributed. Secondly, there are a vast number of doubles this method simply cannot produce, e.g. 1e-1000. A few months ago, in some other thread, I went into more details on why computing a random float is hard. Maybe I should write a blog post of my own so I can link to it.
Please please don't use that for anything that has any value. Picking random background colors is fine, using that to generate keys, tokens, any kind of secret, any kind of identifier, any kind of anything remotely valuable is **not**.
but the expression `((double)rand()/RAND_MAX` isn't meant to be uniform across all of the values that a double can represent. why include that code here? its inclusion makes me feel like you don't understand what you're talking about.
&gt;using the PID actually seems like a profoundly stupid idea. &amp;#x200B; Seeding a PRNG with just \`time(NULL)\` is problematic if many instances of the same program will be spawned simultaneously. Adding the PID solves that.
but that's not what the article says. there is this bit of code in the article: ``` srand((unsigned int)getpid()); ``` that's dumb. on some systems, you can actually force a process to be assigned a particular PID or you can even tell what seed is being used just by checking its PID. i think this is much worse than the prospect of two independent processes coincidentally sharing a seed.
&gt; there are a vast number of doubles this method simply cannot produce, e.g. 1e-1000. On most platforms that's not a representable double. ISO C only requires `DBL_MIN_10_EXP &lt;= -37`. On the particular machine I write this on, `DBL_MIN` is about 2.22507e-308, way larger than 1e-1000.
Agreed. I eventually want to look into cryptography, but this is just for a simple neural network.
&gt; but the expression `((double)rand()/RAND_MAX` isn't meant to be uniform across all of the values that a double can represent. I know that, you know that, but apparently the author of the blog post doesn't. So let's make it clear for any future readers: # A simple divide is not as good as you may think.
I'll look into comments 1 and 3, thanks. Using the time, my code was not generating numbers less than .1. After switching to PID, I saw numbers below .1. Using time, I was missing 10% of potential numbers.
Sorry, brainfart. Meant to say something like 2\^-1000 as that fits into an 11bit mantissa, but there are no 64bit numbers to produce it.
Using the same code but with time, no numbers were being generated less than .1. The bottom 10% of potential numbers were missing.
Using PID still works much better for the purpose that I'm using it for than using time. I'm not exactly launching astronauts to Mars.
&gt;even worse, you can tell what seed is being used just by checking its PID. Which might be a feature when doing reproducible scientific simulations.
I'm just generating random weights for a simple neural network.
Someone else has suggested PCG, too. I was just trying to show appreciation. I wasn't happy using time, and PID is working for what I need.
I'm a student. Using PID is working much better than using time. Are there better methods? Apparently. But, this works better than anything I found searching the Internet.
I still appreciate the help, and I apologize if I have somehow damaged your reputation. The best code that I found on the Internet, using time, was not random enough for what I need. PID solved the deficiencies that I observed. I'm continuing with my project.
Although I don't know that `int` has a trap representation on any platform that would be capable of efficiently supporting the `uint_least64_t` type required for C99 conformance, only type `unsigned char` and the optional "fixed-sized" types are forbidden from having trap representations (I suspect the authors of the Standard intended that if `signed char` could have a trap representation on some platform, that platform's `char` type would be unsigned, but they didn't mandate that).
&gt;there are a vast number of doubles this method simply cannot produce Right. I've found for some practical purposes I can solve that problem by [merging multiple calls to rand()](https://stackoverflow.com/a/37761274), but I'm sure there's a better way.
&gt; 2^-1000 as that fits into an 11bit mantissa I'm not sure what you're trying to say there about the mantissa. 2^-N clearly only has one nonzero digit in the mantissa for `FLT_RADIX==2` (or, for that matter, any other power of 2). So, 2^-N will also fit into a **1 bit** mantissa, provided N is small enough. Given that even `float` normally (i.e. in IEEE 754) has 23 or 24 bits of significand, I'm not sure why we're talking about an 11 bit mantissa.
Brainfarts all over. I better stop posting now.
The biggest thing C lacks is clarity about whether the Standard is trying to fully describe a complete language which does everything necessary for a wide range of purposes, or whether it is trying to describe a "core" which most implementations should be expected to supplement with additional defined behaviors to make them suitable for most purposes. Either approach could be useful, if the Standard was clear about the approach it took, but as it is many parts of the Standard are worse than useless, and have caused far more strife and confusion than would have occurred if it had simply said "To allow the authors of specialized compilers to best serve the needs of programs written for specific narrow purposes, the Standard generally refrains from efforts to forbid implementations from behaving in ways that would make them useless for most other purposes. The fact that the Standard allows a compiler to do something in no way implies any judgment that such action would not make the compiler unsuitable for any particular purpose."
In C, types are in many situations implicitly converted to the required type. This is expected behaviour so you don't get a warning.
This. But you are right OP. Usually code analysis programs will tell you that this is not recommended and suggest you cast instead.
But it even won't complain if I use g++!
Is there a gcc option to stop this behaviour?
C++ does this much more than C.
Same thing in C++.
dude ... maybe drop the class bro?
This is /r/c_programming. And do your own homework.
- This subreddit is for C. C++ is not C, it's a different language - No-one's going to do your homework for you, especially not for $10.
 #define calculate(a) _Generic(a, int: calculate)(a) You could do something like that, but I think the treatment kills the patient...
Note that there is the `-Wconversion` (for gcc and clang) that would warn on such usage.
You're this desperate and are only offering $10
-Wpedantic might complain about this and if you pass it with -Werror, your warnings will become errors.
C++ gets a little bit more strict and doesn't allow some of the common C conversions. I think enum to int is one such case.
C is statically but not strictly typed. A lot of implicit type conversions do happen
You're missing something else.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
How much are you willing to pay? My rate is ‚Ç¨100/h.
But you're (potentially) taking a cache miss on every access, sure, algorithmic complexity is the same as on an array but you're still going to be orders of magnitude slower.
Same dude looking to get someone to do his homework lol
If you are on a Unix system, you could try: unsigned int s; FILE *fp; fp = fopen("/dev/urandom","rb"); if (fp) { fread(&amp;s,sizeof(s),1,fp); fclose(fp); } else s = (unsigned int)time(NULL); srand(s);
I've used timespec.tv_nsec (the nanosecond portion of the struct) before and passed it to srandom(). I prefer using random() over rand(). I went with the theory that it's harder to guess the exact nanosecond than it is to guess the exact second something will start, especially if it's not the first function called. I don't know if the resolution is good enough to get a large number of values though. I never really tested it in that way.
Arithmetic types are magical. You're allowed to convert a float into a char even (not a \_Bool, though). The behavior is documented in the 6.3 of the Standard. [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf) To cause undefined behavior in your example, set \`a\` to 1e50 or something.
If you are using `getpid()` then you might as well read the seed from `/dev/urandom`.
Try with: gcc test.c -Wall -Wextra -Wpedantic -Wconversion
You could try something like this (but be aware that if you execute this code on Linux or a system like it very frequently, for example in a program that gets started several times a minute on the same machine, it will exhaust the system's entropy pool and may cause security-related programs to be slow to start up). /* This might be a bit over-engineered for seeding rand() ... and it is likely unsuitable for use in a security context */ #undef USE_AUXVAL #undef USE_GETTIMEOFDAY #undef USE_GETPID #include &lt;inttypes.h&gt; /* requires C99 or newer. */ #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #if defined(__unix__) # include &lt;sys/types.h&gt; # include &lt;sys/time.h&gt; # include &lt;unistd.h&gt; # ifdef _POSIX_VERSION # define USE_GETPID 1 # define USE_GETTIMEOFDAY 1 # endif #endif #ifdef __linux__ # include &lt;sys/auxv.h&gt; # define USE_AUXVAL 1 #else #endif /* MurmurHash64A is taken verbatim from https://github.com/hhrhhr/MurmurHash-for-Lua/blob/master/MurmurHash64A.c */ uint64_t MurmurHash64A ( const void * key, int len, uint64_t seed ) { const uint64_t m = 0xc6a4a7935bd1e995LLU; const int r = 47; uint64_t h = seed ^ (len * m); const uint64_t * data = (const uint64_t *)key; const uint64_t * end = (len &gt;&gt; 3) + data; while(data != end) { uint64_t k = *data++; k *= m; k ^= k &gt;&gt; r; k *= m; h ^= k; h *= m; } const unsigned char * data2 = (const unsigned char *)data; switch(len &amp; 7) { case 7: h ^= (uint64_t)(data2[6]) &lt;&lt; 48; case 6: h ^= (uint64_t)(data2[5]) &lt;&lt; 40; case 5: h ^= (uint64_t)(data2[4]) &lt;&lt; 32; case 4: h ^= (uint64_t)(data2[3]) &lt;&lt; 24; case 3: h ^= (uint64_t)(data2[2]) &lt;&lt; 16; case 2: h ^= (uint64_t)(data2[1]) &lt;&lt; 8; case 1: h ^= (uint64_t)(data2[0]); h *= m; }; h ^= h &gt;&gt; r; h *= m; h ^= h &gt;&gt; r; return h; } uint64_t mix(uint64_t a, uint64_t b) { /* We might often call this function using values of b which have been cast * from a much narrower type, so we need to ensure that not every value of b * gets mixed only with the low-order bits of a. */ return MurmurHash64A(&amp;b, sizeof(b), a); } size_t minsize(size_t a, size_t b) { return (a &lt; b) ? a : b; } uint64_t make_seed() { int used_time = 0; /* We can't really know how many low order bits are predictable in &amp;used_time here; even C11's maxalign_t would only give us a hint (so it's not worth requiring C11 to use that). We just guess at how many bits to discard. */ uint64_t s = ((uint64_t)&amp;used_time) &gt;&gt; 6; /* make use of ASLR, if it's in use */ #ifdef USE_GETTIMEOFDAY if (!used_time) { struct timeval tv; struct timezone tz; if (gettimeofday(&amp;tv, &amp;tz) &gt;= 0) { s = mix(s, (uint64_t)tv.tv_sec); s = mix(s, (uint64_t)tv.tv_usec); used_time = 1; } } #endif if (!used_time) { /* time() is quite a poor source but we can always use it, which prevents us returning a constant as the seed. */ time_t t = time(NULL); if (t != (time_t)-1) { s = mix(s, (uint64_t)t); used_time = 1; } } #if defined(USE_GETPID) /* getpid has a limited range and on many systems has a predictable sequence. */ s = mix(s, (uint64_t)getpid()); #endif #ifdef USE_AUXVAL if (1) { /* We use an auxiliary buffer here because MurmurHash64A wants to cast its key argument to uint64_t*, so the address must meet the alignment constraints of the relevant type. We don't know that that's true of the result of getauxval(), so we use malloc() to be certain. */ void* buf = malloc(16); if (buf != NULL) { void *sixteen_bytes = (void*)getauxval(AT_RANDOM); memcpy(buf, sixteen_bytes, 16); s = MurmurHash64A(buf, sizeof(buf), s); free(buf); } } #endif if (1) { FILE *f = fopen("/dev/urandom", "rb"); uint64_t x; if (f != NULL) { size_t n = fread(&amp;x, sizeof(x), 1, f); if (n == 1) { s = mix(s, x); } fclose(f); } } return s; } int main() { /* for demo purposes */ uint64_t seed = make_seed(); return printf("seed: %" PRIu64 "\n", seed) &lt; 0 ? EXIT_FAILURE : EXIT_SUCCESS; }
Enum to int is allowed, but C++11 introduced strictly typed enums that won't convert to their underlying type.
-Wconversion I think
If you have the router admin rights then you can head to the router page and list all the Mac addresses of the machine and the IP address alloted to them under DHCP client list If you don't have the rights then you can download [Ettercap](https://www.ettercap-project.org) it will sniff all the IP address with their Mac on the network it is connected.
That should definitely not be happening. The seed value just determines the starting point for the pseudo-random sequence. The statistical distribution of values should be the same for any seed.
How do I do that?
I'm auditing a class, and this question popped up in class. I have no idea which one it is, and I was hoping for an explanation of how this works.
Write a program that uses each of these numbers. The compiler is going to indicate a syntax error for one of them. That's how you are going to know which one is incorrect.
I compile ALL my code with `-Wall`. There has been *one* time (in 15+ years) when it warned me about an issue, and it was wrong. Literally every other time `-Wall` pointed something out to me, I had either just straight screwed up or I had done things in a way that was way less than optimal. `-Wall` is your friend. Use it religiously. When it flags a bit of code, take the time to understand why. It will make you a **much** better programmer.
Have you started learning binary and it's related shorthand hexadecimal? unsigned int bitmask0 = 0x00000001; /\* mask for bit 0 (lowest) \*/ unsigned int bitmask1 = 0x00000002; /\*mask for bit 1 \*/ ... unsigned int bitmask31 = 0x80000000; /\*mask for bit 31 (highest)\*/
https://graphics.stanford.edu/~seander/bithacks.html is a great resource
strncpy is a terrible function. https://en.cppreference.com/w/c/string/byte/strncpy | f count is reached before the entire array src was copied, the resulting character array **is not null-terminated**.
I have, but Im kind of confused. I got \*port\_bits | = 0x11110000
Your ID variable is not large enough to hold "302611". The terminating null will go off the end, most likely into code[], and then when you copy anything into code[], it'll overwrite the null and id[] will read as a continuous string with the same end as code[].
Thank you! This fixed it
I agree, and always add `-Wall` to my compiler arguments, but OP said he compiled with `-Wall` and didn't get a warning.
Please format your code properly. It's even one of the examples in the quick help formatting. &gt; Lines starting with four spaces are treated like code
Your code is hard to read, could you take a look at the sticky post, an follow the guidelines, then someone might be able to help you solve the problem ‚ò∫Ô∏è
Yes if you start numbering from zero. Windows calculator can do binary OR's. Also you can combine them *port_bits |= (0x10000000 | 0x01000000 | 0x00100000 | 0x00010000); You can even assign the individual bit masks to #defines, constants, and/or enums \*port\_bits |= (BIT28 | BIT24 | BIT20 | BIT16);
Yes.
Perhaps you are already familiar with [https://libevent.org/](https://libevent.org/) . Never tried it but seems to solve portability issue. I think chrome uses it.
This is a C Programming subreddit. The languages are different.
The s specifier writes out of bounds, you need to make the buffer big enough to hold the null terminator
That's why I posted a question in this subreddit. I could tell that the code I had was insufficient.
Do your homework. We all struggle at first. But we're not here to help you cheat.
Interesting, thank you.
I'm trying to learn and understand how everything works, so I'm testing all suggestions, thanks.
I understand the concept and will try it, thank you.
I see what this is doing, thank you. The recurring theme in everyone's comments seems to be predictability.
try: `uint8_t bitmask = 0b01000101 // bit positions where you want to set the values, bits 0, 2, 6 in this case` `uint8_t values = 0b01000001 // values you want to set those bits to` `*port_bits = (*portbits &amp; ~bitmask) | values` This will zero out the bits in `*portbits` by anding with inverted `bitmask` and set those bits to the bits in `values`
I didn't realize it was even a problem until I switched from time to PID.
It's pretty straight forward once you have the idea in your head. I will try to show you the different operations you will use when using bits. unsigned long u32 = 0UL; // An empty bit mask u32 = 1UL &lt;&lt; 16UL; // set bit 16 in the bit mask // The operator &lt;&lt; is shift left u32 |= 1UL &lt;&lt; 20UL; // set bit 20 in the bit mask // The operator |= is the "or equals" and is the same as u32 = u32 | (1UL &lt;&lt; 20UL) // you can set all your bits in a single assignment u32 = (1UL &lt;&lt; 16UL) | (1UL &lt;&lt; 20UL) | (1UL &lt;&lt; 24UL) | (1UL &lt;&lt; 28UL) // and you can clear bits with the &amp; operator and ~ for negation u32 = u32 &amp; ~(1UL &lt;&lt; 16UL) // what this is doing is easier to understand in binary so I will explain in 8 bits unsigned char u8 = 0U; // set bit 0 u8 = (1U &lt;&lt; 0U) // u8 = 00000001 in binary // set bit 4 u8 |= (1U &lt;&lt; 4U) // u8 = 00010001 in binary // clear bit 0 u8 &amp;= ~(1U &lt;&lt; 0U) // u8 = 00010000 in binary // this is doing the following u8 &amp;= ~(00000001) // I have expanded this as binary // ~ means the negation of 00000001 u8 &amp;= 11111110 // so if u8 = 00010001 u8 = 00010001 &amp; 11111110 u8 = 00010000 &amp;#x200B; So you need to understand these operations in binary As Binary As Decimal Representation the OR operator | 0000 | 0100 = 0100 [ 0 | 4 = 4 ] the AND operator &amp; 0000 &amp; 0100 = 0000 [ 0 &amp; 4 = 0 ] the negation ~ ~0000 = 1111 [~15 = 0 ] the left shift &lt;&lt; 0001 &lt;&lt; 2 = 0100 [1 &lt;&lt; 2 = 4] the right shift &gt;&gt; 1000 &gt;&gt; 2 = 0010 [7 &gt;&gt; 2 = 2] &amp;#x200B; Hope that helps
With all due respect, pointing them in the right direction would be a better comment. The point of the sub-reddit is to answer C related questions. Yeah? Not to tell people to go away. I do realize this isn't a C question, but you get what I mean.
What does it mean? Is this just a weird way to promote your programming courses?
Fair enough
That has absolutely nothing to do with what value you seed with. The seed is just the starting point for the random number generator, it doesn't have any effect on the quality of the numbers that will be generated. Seeding with time vs seeding with PID will both produce the same quality of random numbers, but seeding with PID guarantees that you will only have ~10,000 random "paths". Basically, when you start with the same seed, you generate the same random numbers after that point. Seeding with PID means you will start from the same point INCREDIBLY more often. Seeding with PID is generally so egregiously wrong its just baffling. If you don't know exactly what you are doing and are not familiar with some basic internals of PRNGs (which no offense, but you make it clear you are not), I can guarantee you should not be seeding with PID.
Here's a real life example of why its bad (from 1996 btw, that means its known to be bad for over 20 years). https://people.eecs.berkeley.edu/~daw/papers/ddj-netscape.html &gt; The seed generated depends only on the values of a and b, which in turn depend on just three quantities: the time of day, the process ID, and the parent process ID. Thus, an adversary who can predict these three values can apply the well-known MD5 algorithm to compute the exact seed generated. The paper then goes on to demonstrate an attack to determine a seed generated from PID, PPID, and time. Interesting read. That aside, heres a quick and dirty python example of how easy it is to attack PID-only seeding. Its a snippet that bruteforces itself to discover the seed: import random import os import time def rolling_xor(data): ret = bytearray() for c in bytearray(data): ret.append(c^random.randint(0,255)) return ret known_plaintext = "Hello World" random.seed(os.getpid()) encrypted = rolling_xor(known_plaintext) def crack(): start = time.time() for i in xrange(0,999999): random.seed(i) check = rolling_xor(known_plaintext) if check in encrypted: break stop = time.time() print("Discovered seed: %d" % i) print("PID: %d" % os.getpid()) print("Time to crack: {}s".format(stop - start)) The output: &gt;&gt;&gt; crack() Discovered seed: 11512 PID: 11512 Time to crack: 0.31200003624s
Number formats are basic stuff, usually covered at the first lesson. OK, "0x" means it is a hexadecimal notation, that can contain digits and letters from "A" to "F". All letters (including "x") may be of any case, so `0x1f`, `0X1f`, `0x1F` are all the same number (31). Hexadecimal notation is often used to indicate a binary value, meaning it may not be printable and we should treat it as a "raw" number. Whenever you'll see a bunch of "0x...." it's a sign you are dealing with binary data. We could use decimal notation, but it's a convention to write "raw" data in hexadecimal. For example: ``` #include &lt;stdio.h&gt; int main(void) { char word[] = { 0x68, 0x65, 0x78, 0x61, 0x64, 0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x00 }; printf("%s\n", word); return 0; } ``` prints "hexadecimal" on output (not very binary data, but it's just an example). "02_00011111" is not allowed in C.
Thanks! Just downloaded the standard!
Given r as your register, you can set bits 28, 24, 20 and 16 by doing: r |= 1 &lt;&lt; 28 | 1 &lt;&lt; 24 | 1 &lt;&lt; 20 | 1 &lt;&lt; 16;
Sorry I'm not really good at explaining lol Heres what I have so far I want to input the morse and I want the output to be in English but I just can't figure out how to match my input with the morse so it knows which more characters to convert into letters. I don't want the answer code I just want to understand how it could be done. Link to code==&gt; [https://ibb.co/Z1F9myp](https://ibb.co/Z1F9myp)
Sorry I'm not really good at explaining lol Heres what I have so far I want to input the morse and I want the output to be in English but I just can't figure out how to match my input with the morse so it knows which more characters to convert into letters. I don't want the answer code I just want to understand how it could be done. Link to code==&gt; [https://ibb.co/Z1F9myp](https://ibb.co/Z1F9myp)
Hold up there chief, shifting a 1 means you have to subtract that one from the target bit. so, 1 &lt;&lt; 27, 23, 19, 15.
My biggest complaint with C is that most of the "innovation" and "creativity" applied to the language in the last 20 years has been focused toward making it competitive with various application languages in the fields that are better served by those other languages, rather than toward maximizing (or even *preserving!*) its effectiveness in the fields where it is uniquely suitable. While gcc has always had a mixture of good ideas and bad ideas, I can't think of many good things the language has today that gcc didn't have in the late 1980s.
FYI, the notation for showing a binary number like that is 0b1111000. 0x is used for hexadecimal.
&gt; Rust, D, and modern C++ definitely don't share the same approach to development of C and they belong to wildy different categories of languages. https://dlang.org/spec/betterc.html
Bit nomenclature is inclusive of zero. Setting bit 28 means 1&lt;&lt;28. Setting bit 0 means 1&lt;&lt;0.
Bit nomenclature is inclusive of zero. Setting bit 31 the msb of 32bit unsigned int means 1&lt;&lt;31. Bit 28 means 1&lt;&lt;28. Setting bit 0 means 1&lt;&lt;0.
(not the down voter..) But the c language does not have a standard binary notation.
I'm not offended. I'm learning. Using PID solved the issues I was having using time, which I thought was great. Now I know PID has issues, so I'll I need to explore even better options.
You know, I *almost* was going to mention that. I was counting from the 0th bit, with the OP's leftmost bit being the 31st bit. Thanks for pointing out the possible discrepancy.
-Wall actually covers very little, you probably want to add -Wextra and -pedantic. Also, at work, in addition to that, we also run clang with -Weverything, in addition to GCC.
Maybe you should try posting this on a board that has literally anything to do with C++.
This formatting made my eyes bleed. Indent your shit plox
/r/cpp_questions
https://idownvotedbecau.se/unreadablecode/ Also, don't use scanf. Use fgets.
You're right. We wouldn't get very far if we couldn't use enums as ints. It was the other way around. If you declare a variable of enum type, you cannot assign an int to it without a cast.
VIsual Studio Code is a very nice IDE. Supports many languages as well.
It certainly can and does. Thats what optimization is for. Compilers can rearrange, eliminate, add code. Try compiling your code in O0 and O3 and see the difference in assembly output.
So it can improve the runtime?!? My professor said only three of these were true, and one was definitely false.
It cant fix logic errors. If you tell it to start indexing at 1, it won't correct it to 0.
Okay. So for another example, if I wanted to clear bits 31, 29, 23, 7, 5, 3 , 2 , and 1 , with the same port bits. I'd write : \*port\_bits &amp; = \~0xA08000AE &amp;#x200B; Would that be correct?
Oh then it's probably the first one. Compilers don't know what ur thinking. It just compiles what you give it and tries to optimize it. You might want to print a number with 3 digit precision but unless you write that in code, the compiler has no idea lol. So that's a logic error. But sometimes, really good compilers can detect patterns like `if (something); {/* code */}` and warn you but I'm not sure/don't remember if gcc or clang does it. Try it.
Are you removing the redirection character and the input/output file from 'args'?
I use this as well. It's perfect with vim keybindings.
Yeah, I think I‚Äôm going the lldb route. Just wish eclipse had support for it.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
That's a tricky way (for your professor) to phrase the question, in my humble opinion. I'd prefer the word "performance" or even "optimality" ;) When I saw "runtime", the first thing I thought was, as opposed to compile time, rather than literally the amount of **time** your code **runs** for before completing.
By any chance, is the project called the `42sh`?
I see. Just think, how could a compiler detect or fix logical errors? It doesn't know what problem you're solving, it doesn't know what it's supposed to be doing. All it knows is that you've given it these instructions and as long as they're syntactically correct, it will compile them. It can't know that you used &amp;&amp; and you meant ||, or + when you meant -. As for improving the runtime, then yes. C compiles absolutely do that. A quick example, imagine you call a function that does a lengthy mathematical computation and store the result in a variable. If you never use that value from the variable, the compiler may never even call that expensive math function. It isn't needed, you never used the result. An optimizing compiler (and all modern compilers are optimizing) can detect things like this and remove them from the final code. Another simple and common example is "inlining" functions. Say you have a function that just adds two numbers together. There is some extra processing that goes on when you call a function, so the C compiler might just take the body of that function and put it where the function call used to be. if the function is small enough, it won't make the code much larger.
&gt; A compiler can detect logical errors in your thinking where do I download this one
Programming with POSIX Threads by David R. Butenhof
Keep in mind binary notation is a GNU extension, it isn't in the C standard.
I suspect your professor is talking about time complexity. Enabling optimization is mostly about improving the code generated by the compiler, not changing the program's time complexity (e.g. O(n^(2)) vs O(n log n)). That's generally the right way to think about compiler optimizations. However, this isn't strictly true. In some cases, both GCC and Clang will actually change your algorithm to something with better time complexity. For example, here's an O(n) sum of integers: /* Sum the numbers from 1 to n */ long sum(int n) { long sum = 0; for (int i = 1; i &lt;= n; i++) sum += i; return sum; } Under `-O1` and higher, Clang will [optimize this to constant time, O(1)](https://godbolt.org/z/hv4-ov). I've translated the output assembly back into C: long sum(int n) { if (n &gt; 0) { long a = n - 1; long b = n - 2; return a * b / 2 + a * 2 + 1; } else { return 0; } }
Yes, though I'm doing it very quickly in my head right now.
&gt; A compiler can not try to improve the runtime of the code, right? Oh yeah! Some compilers are amazing at it. &gt; A compiler can detect logical errors in your thinking No. Not at all, except by accident.
What makes you assume OP's wanting the value 0xF0 and not 0x11110000?
Please edit your post and indent all of your code by an additional 4 spaces.
also in the 2nd box i want it to print illegal input if the input was anything else than a,b,c,d and this is the code i got to so far #include &lt;stdio.h&gt; #include &lt;conio.h&gt; #include &lt;math.h&gt; int main() { char letter; int sum = 0, num, i = 1, c, num2; printf("enter number of digits:"); scanf("%d", &amp;num); num2 = num; printf("\nenter the digits:"); if(num&gt;7){ printf("Illegal input"); } while (i &lt;= num) { scanf("%c", &amp;letter); if ((letter == 'a') || (letter == 'A')) letter = (int)10; if ((letter == 'b') || (letter == 'B')) letter = (int)11; if ((letter == 'c') || (letter == 'C')) letter = (int)12; if ((letter == 'd') || (letter == 'D')) letter = (int)13; if ((letter == 'e') || (letter == 'E')) letter = (int)14; if ((letter == 'f') || (letter == 'F')) letter = (int)15; c =(int)letter*(pow(16, num2-1 )); sum = sum + c; i++; num2--; } printf("the decimel number is:%d", sum+55); getch(); }
Did you have a question, or are you just asking reddit to do your homework assignment for you?
I‚Äôm going to start out a bit dickish. The single word ‚Äúruntime‚Äù usually refers to the library that ships with the language (or other framework), which coordinates the higher-level language activities with those of the host platform. `printf` is part of the C runtime, for example, and `mmap` is (usually) part of the POSIX runtime. ‚ÄúRuntime‚Äù can also be used as an adjective to mean ‚Äúruntime-related,‚Äù as in ‚ÄúThe runtime `printf` takes twice as much memory as our custom implementation.‚Äù Run time (noun phrase, two words, no hyphen) refers either to the amount of time your program takes to run (‚Üêusually informally), or to the period of time during which your program is running. Run-time (adjective phrase, two words, hyphenated) basically means ‚Äúat run time,‚Äù and is roughly synonymous with ‚Äúdynamic,‚Äù as opposed to ‚Äústatic‚Äù which refers to things happening at/before link time. So under normal circumstances, the compiler can improve the runtime (one word) only when it‚Äôs compiling/linking it (e.g., when building libc.so from source). For example, it might improve the size of the runtime by dropping some dead code intended for use on other host platforms. The compiler can improve the your program‚Äôs eventual run time (two words) when it‚Äôs building your program, which is one of the usual goals of compile-time optimization. It might do this by vectorizing a loop, for example, or by replacing a `malloc`+`free` pair with a stack allocation. In theory, your language implementation could adopt a similar approach to the JVM, meaning there would be a JIT compiler/optimizer that could improve the run time of the runtime at run time. Or stated differently, it could make run-time runtime run time improvements. The actual answer to your professor‚Äôs question is probably ‚Äúdetect logical errors in your thinking,‚Äù although that‚Äôs not entirely true. E.g., if you mistakenly believe that `int` arithmetic will overflow in a strictly two‚Äôs-complement way, leading you to write something like int a = f(); if(a + 4 &lt; a) complain(); in an attempt to detect it, the compiler would potentially be able to warn you that the `complain()` call is dead code because `a + 4 &lt; a` is always false. (‚ÄîOr rather, the compiler can treat it as always false because the case where it might be true is undefined behavior.)
Why all the casts? And what on Earth is this: c =(int)letter*(pow(16, num2-1 )); BTW, a tip: what is the value of `letter - 'A'` if `letter` is between `'A'` and `'F'`?
c to convert from hex to decimal with 16 power to something and 10?
Can you repeat that in English?
&gt; `unsigned long u32 = 0UL; // An empty bit mask` $ cc -x c - &lt;&lt;EOF int main(void) { return 8 * sizeof(unsigned long); }' | cc -x c - EOF $ ./a.out; echo $? 64
That's cheap.
That's my special reddit rate.
Honestly I learned the most working on a highly concurrent parallelized product written in C.
I think concurrent programming has the same problems in all the languages. I used the art of multiprocessor programming by herlify and shavit when I was trying to get better at work. The rest was learned on the job working on our product, which happens to be a distributed highly concurrent file system written in C.
I think the structure of your code is weird. It looks like you have a dedicated function for processing each element of the array? OpenMP is really meant as a simple annotation around loops. --------- Another thing, stack space is very limited; an array of 50,000 "Points" (who knows how large that is) will probably not work very well, you should allocate that data with calloc. --------- `for (int i = 1; i &lt;= number; i++)` So you're just gonna skip the 0th element? also, using signed integers in a loop rarely makes sense.
it's called static analysis, Clang supports it for sure; tho it's only about 50% right.
As G. K. Chesterton once said: don't ever take a fence down until you know the reason it was put up. Specifically, 1. Are you sure you understand what people use `goto` for? 2. Does Zig provide alternative mechanisms for *all* of these uses? And instead of trying to make a language that people find themselves using even though they dislike it, shouldn't you be trying to make a language that people actually like?
&gt; OpenMP is really meant as a simple annotation around loops. Yup, it's not a good fit for this problem since loop iterations aren't truly independent. A better solution will need to be more explicit about what each thread it is doing. I'd manually break the input up into chunks, have each thread look only at its own chunk and nothing else ‚Äî so no synchronization is required. Then once all the threads are done, merge the results together, which is essentially the same problem again on a smaller dataset. &gt; also, using signed integers in a loop rarely makes sense. Strongly disagree. Use an appropriately sized integer ‚Äî e.g. don't use `int` when the number of iterations is a `size_t` ‚Äî but do prefer signed integers as the loop variable when possible. This gives the compiler the most freedom because signed overflow is ruled out. When producing code, the compiler won't need to replicate any particular overflow semantics and can potentially use a more appropriate integer size.
LOL You have this literally backwards. A compiler can absolutely improve the runtime of the code. In fact, I can't think of any programming language that guarantees how fast your code will run. (Sometimes a function may specify a *maximum* runtime, such as C++ algorithms like `std::sort` and `std::vector::size`, but I'm not aware of any function or language that specifies a *minimum* speed, beyond which the compiler or computer aren't allowed to make it go faster.) Compilers can detect errors in the syntax or grammar of what you input. But as long as the source code you give the compiler meets the syntax and grammar of the language, it has no choice but to assume that what you wrote is what you meant. How would it know otherwise? It would have to read your mind, which it obviously can't do. If I give you driving directions like "Turn left after the third light", what would you do with that direction? You'd assume I knew what I was saying, and try to follow it. Until you actually try to drive it, you have no idea if I made a mistake or not. Maybe I meant "right" instead of "left". Maybe I meant the fourth light instead of third. Maybe I meant "at" the third light instead of "after" it. But in the absence of any other knowledge, you don't know beforehand (i.e. at compile time) whether that's what I meant, so you have to assume that it is. There are probably a *few* logical errors that can be found, such as if you do `int *p = NULL; *p = 42;`. That would trigger undefined behavior in C (which has a specific meaning, and means the compiler *could* error out, but also that it *could* output machine code to do exactly what you wrote, or *could* make up any other code that it wants, or *could* output an empty function, or *could* prank call your ex), but many other languages have stricter specifications that may make that a hard error that can be detected at compile time. But *most* of the time, a "logical error" in your code means "this is valid code, but it doesn't represent what the programmer meant to do or *should* have meant to do", and compilers have no way of detecting that.
I'll think about it. Something with strcmp() or putting the morse into int should work, the real problem is the reading and comparing... If I have some time on sunday, I'll post something
&gt; optimality There's a great paper (which I can't remember enough details to find) that points out that "optimizing" compilers don't generate *optimal* code; they should more accurately be called *improving* compilers. The paper then shows an actual *optimizing* compiler that generates code by picking a small block to optimizing and trying every possible set of 1 machine instruction, then every set of 2 instructions, and so on, until it finds a shortest set of instructions that performs the same work as that block. And even so, in modern CPUs it's hard to say that that's optimal. It might be optimally small, but with superscalar out-of-order processors and multiple levels of caching, there's no guarantee that it's optimally fast.
I am not sure the point you are making here. 8 * sizeof(unsigned long) == 8 * 4 == 64 which is correct.
do u know how to just find day of week by given date?
Any concrete example where using size_t in a loop results with a worse perfomance compared to a signed int assuming a modern compiler? As a regular size_t user i would be interested to know.
&gt; Are you sure you understand what people use goto for? Yes: https://github.com/ziglang/zig/issues/630 &gt; Does Zig provide alternative mechanisms for all of these uses? No. For example computed goto: https://github.com/ziglang/zig/issues/2162 &gt; And instead of trying to make a language that people find themselves using even though they dislike it, shouldn't you be trying to make a language that people actually like? Not only are the two goals not mutually exclusive, they are harmonious.
No, that's not how it works. In the same way that you can't just not use C++ features that you don't like. If the features exist, then they get used, and when you read other people's code, you are now using the features yourself, because you have to understand the semantics.
Typo on the loop there, sorry. I just am unsure as how to proceed. I know that openMP is meant as a simple annotation around loops and just don't know how to design my program to use openMP for this problem. Time complexity is a non-issue so an efficient algorithm isn't a design problem, it's mainly with how to use openMP in the proper way that I'm stuck on. Thanks.
I don't think performance is the main reason why size\_t is preferred. When using signed types as sizes or indices you are [welcoming potential security risks](https://stackoverflow.com/questions/3259413/should-you-always-use-int-for-numbers-in-c-even-if-they-are-non-negative/3261019#3261019).
This example has nothing to do with signed vs unsigned, but rather it's about the size of the loop variable. It's a function that sums up a buffer of floats. The number of floats is always small enough to fit in an `int`, but I used a `size_t` in one version of the function: float loop_int(float *x, int n) { float sum = 0; for (int i = 0; i &lt; n; i++) sum += x[i]; return sum; } float loop_size_t(float *x, int n) { float sum = 0; for (size_t i = 0; i &lt; n; i++) sum += x[i]; return sum; } Compile with GCC `-Os` on x86-64 and see how big each function is with `nm`: $ nm -S temp.o 0000000000000000 0000000000000014 T loop_int 0000000000000014 0000000000000018 T loop_size_t Or with `-O3`: $ nm -S temp.o 0000000000000000 0000000000000091 T loop_int 00000000000000a0 00000000000000a1 T loop_size_t In both cases the `int` version resulted in smaller code (0x14 vs. 0x18, 0x91 vs. 0xa1). That's less pressure on the instruction cache. The reason behind this is that most x86-64 instructions involving 64-bit operations requires a prefix byte, making the instructions larger. So it's the same number of instructions, they're just larger. In theory an optimizer could produce the same code for both by ignoring the `size_t` and using a 32-bit integer for the loop, but right now that doesn't happen. Extending this to signed vs. unsigned: float loop_uint(float *x, int n) { float sum = 0; for (unsigned i = 0; i &lt; n; i++) sum += x[i]; return sum; } With Clang and `-Os`: 0000000000000000 000000000000001d T loop_int 000000000000003f 000000000000001e T loop_size_t 000000000000001d 0000000000000022 T loop_uint The worse one is the `unsigned int` loop because it spends extra instructions [implementing unsigned overflow semantics](https://nullprogram.com/blog/2018/07/20/#signed-integer-overflow) which can be ignored in the `int` version. (Again, in this contrived example Clang *could* be smart enough to see that it cannot overflow anyway, but then I'd just use an example where that fact can't be proven at compile time.) The `-O3` case is interesting: 0000000000000000 000000000000008f T loop_int 0000000000000120 0000000000000023 T loop_size_t 0000000000000090 000000000000008f T loop_uint Both the `int` and `unsigned int` versions are much bigger (and identical). Why? Because it triggered loop unrolling, which will make it run faster. I can't get the `size_t` version to do it, even with `-funroll-all-loops`.
Thank you for an elaborate answer. I find it quite interesting, as using size_t for indexing felt natural to me. Honestly i expected the compilers to be "smart" about it with -O3 but seems like it is not guaranteed. I really appreciate that you took your time to explain, cheers.
I was thinking of using strcmp() but it was just applying it was the problem lol , Thanks man
An object is actually just a heap allocated struct under the hood, whereas object references are actually just struct pointers. OOP languages also allow "methods" which operate on object instances by reference, but internally they're actually just static functions whose first argument is a struct pointer to the kind of struct to work on. struct super_cool_object { int a; int b; } struct super_cool_object *super_init(int a, int b) { struct super_cool_object *new = malloc(sizeof(struct super_cool_object)); if (new) { new-&gt;a = a; new-&gt;b = b; } return new; }
There's various caveats, but, your first problem is that you're searching in unsorted data, which is going to be n^2. So....sort your data first. Which conveniently you can just use qsort, and the compare function your write to pass into it, can also be reused to do a final pass through the sorted data to pick out your points and write to elsewhere. As far as using openmp: you want to do everything you can to avoid any data dependencies where you need synchronization between threads. The simplest method would be to allocate a result container for each thread e.g. #include &lt;math.h&gt; struct points { float one; float two; float three;}; points *results[numThreads] ; int counters[numThreads]; for(int i =0; i &lt; numThreads; i++){ //ceil to ensure we won't go out of bounds results[i] = malloc( ceil( numDataPoints / numThreads) * sizeof(points)); } Now, assuming you've sorted the data first using qsort(): #pragma omp parallel for shared(dataPoints) for(int i = 0; i &lt; numDataPoints; i++){ int tid = omp_get_thread_num(); for(int j = i+1; j &lt; numDataPoints; j++){ if( compare(dataPoints[i], dataPoints[j]) &lt; 0 ){ // i is smaller results[tid][counters[tid]++ * sizeof(points)] = dataPoints[i]; } else{break;} } } //merge data into one container here? Somtimes simplest is best. There's other ways you could do it, but, start simple, first and see if it meets your needs before you start trying to optimize.
I mean, why not simply do `#pragma omp parallel for` the line above the for loop?
About loop counter variable size, I agree, I default to `uint64_t` unless I know there'll only be X iterations, for example reading UUIDs or something, in that case I'll use `uint8_t` or whatever type is appropriate.
How'd you manage to get `nm` to show each variables size? I can only get function size...
Oh boy.
For the next time, please don't delete questions after receiving an answer.
Those *are* function sizes in my listing. There are no global variables in my code. Though to `nm` they're just symbols, and it doesn't know the difference between functions and variables. The `-S` switch print the size for each symbol.
Given the way my comments were addressed, you have clearly not understood why people use goto.
Why are you worried about efficiency? Clearly, the slowest part of this is waiting for network. The rest really doesn't matter.
While perhaps a little lateral to your original question, which has been well answered by others in thread, I thought I would share some bit-mask macros that I am using in a current project. In this project, I am using these macros for defining bit-masks associated with packed integers. Hopefully these will also be of use to you. #define _B16(n) \ ( ( uint16_t )( ( ( ( (0x##n##LU) &amp; 0x000000000000000FLU ) != 0 ) ? ( 1 &lt;&lt; 0 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x00000000000000F0LU ) != 0 ) ? ( 1 &lt;&lt; 1 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x0000000000000F00LU ) != 0 ) ? ( 1 &lt;&lt; 2 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x000000000000F000LU ) != 0 ) ? ( 1 &lt;&lt; 3 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x00000000000F0000LU ) != 0 ) ? ( 1 &lt;&lt; 4 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x0000000000F00000LU ) != 0 ) ? ( 1 &lt;&lt; 5 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x000000000F000000LU ) != 0 ) ? ( 1 &lt;&lt; 6 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x00000000F0000000LU ) != 0 ) ? ( 1 &lt;&lt; 7 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x0000000F00000000LU ) != 0 ) ? ( 1 &lt;&lt; 8 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x000000F000000000LU ) != 0 ) ? ( 1 &lt;&lt; 9 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x00000F0000000000LU ) != 0 ) ? ( 1 &lt;&lt; 10 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x0000F00000000000LU ) != 0 ) ? ( 1 &lt;&lt; 11 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x000F000000000000LU ) != 0 ) ? ( 1 &lt;&lt; 12 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x00F0000000000000LU ) != 0 ) ? ( 1 &lt;&lt; 13 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0x0F00000000000000LU ) != 0 ) ? ( 1 &lt;&lt; 14 ) : 0 ) \ + ( ( ( (0x##n##LU) &amp; 0xF000000000000000LU ) != 0 ) ? ( 1 &lt;&lt; 15 ) : 0 ) ) ) #define _B(n) _B16(n) enum _BYTECODE_OP { OP_NONE = _B(00000), /* 0 */ OP_NOP = _B(00001), /* 1 */ OP_PUSH = _B(00010), /* 2 */ OP_POP = _B(00011), /* 3 */ OP_LD = _B(00100), /* 4 */ OP_ST = _B(00101), /* 5 */ OP_S = _B(00110), /* 6 */ OP_R = _B(00111), /* 7 */ OP_AND = _B(01000), /* 8 */ ... };
GCC and MSVC allows 0b00011111
Ctrl+D?
In C, chars are really just ints. Try and evaluate 'F' - 'A' in C, something like printf("%d\n", 'F' - 'A'); The advice from /u/a4qbfb is that you can try and reduce the number of if statements by utilizing the above suggestion. Also, you don't need to put (int) in front of 10, 11, 12, etc. They are already integers.
Maybe there used to be an option in gcc when that Phrack was published, but you need to terminate each line with a double quote: https://stackoverflow.com/questions/10205691/strange-error-message-about-gcc-inline-assembly You also might have trouble compiling if your gcc is 64-bit, in which case use the -m32 option.
Crazy that ‚ÄùSmashing the stack...‚Äù is almost a quarter of a century old.
 movl %esi,0x8(%esi) That program is intended to run in RAM., it pokes itself.
I think you need to put quotes in front and back of each line of asm.
The program is ran in a VM with buffer overflow protections off, so the stack is executable. This is for a security class btw and we're learning about buffer overflows attacks.
[https://pastebin.com/CDZw9ApG](https://pastebin.com/CDZw9ApG)
This. Inline C assembly code has each line inside quotes if you are using gcc compilar. Here is an style example: __asm__( "movl %edx, %eax\n\t" "addl $2, %eax\n\t");
As another folk is saying here, Inline C assembly code has each line inside quotes if you are using gcc compiler. Here is an style example: __asm__( "movl %edx, %eax\n\t" "addl $2, %eax\n\t");
If you intend to copy the byte sequence and not run that main(), wouldn't it be better to do it all in assembly as \_start entry symbol? No hassle from C runtime and main entry/exit.
Thank you! I had to use the -m32 flag as well.
Thank you!
Thank you!
THANK YOU SO MUCH!
Sorry I'm not very good at C so I didn't even know _start existed.
Faster than which implementation of STL?
C++ Standard Library (Alexander Stepanov, Meng Lee), but it was even faster then the Boost Library (mostly).
Interesting! If you ever do remember the name of the paper (and, somehow, this exchange) I'd appreciate you letting me know.
Which implementation, though? GCC? Clang?
Both, but the benchmarks shown were made using GCC (8.3.0).
Why not - O3?
`jmp 0x2a` seems extremely dubious.
I heard it was buggy at the beginning so I went for the safer approach with -O2, but I tested it with -O3 too, there was no difference in the results (at least the things I have tested).
\-O3 is only buggy if your code invokes undefined behavior.
What makes you think it's faster than STL? Show me your benchmarks. And it better be VERY comprehensive, in order to claim such a thing.
There are some benchmarks in the link. You might argue that they‚Äôre not comprehensive of course.
Just open the link and scroll down, I just made a few which I thought to be more important. I used hyperfine to measure it.
It does work with -O3, there are no undefined behaviors, I wrote unity tests to confirm it.
The benchmark source codes are also in the link, you can test it for yourself.
There are a bunch of compiler bugs that only appear in higher optimization levels even if your code doesn't have undefined behavior.
Very interesting, but that license.
What‚Äôs with that REPEAT macro which apparently does nothing?
Whats wrong with it ?
I didn't like the look of a nested loop, it gives the focus to the REPEATED action. Since I measure the whole program I repeat the focused action N times then divide the measured time by N making the rest of the program execution time small compared to the focused action.
Well, for me, you mention microcontollers. The chances of my customers releasing build/install instructions for their device is zero.
Makes sense, I will probably change it later.
Not so much C, just unix arcana (if it's a word). IMHO pure assembly would be handiest here, like #include &lt;sys/syscall.h&gt; .globl _start _start: ... pushl $ SYS_execve popl %eax ... and cc -c shellcode.S objcopy -O binary shellcode.o shellcode.bin That's for FreeBSD, Linux should not be too different.
What happened to the poor jmp 1f :)
am i missing something? it's GPL3.
what is `i` in the example? it doesn't seem to be declared. and is `vec` declared by the SGC_INIT?
It was `jmp 0x1f` which is just as dubious.
Please do something about the formatting on your site. C code is not meant to look like this.
Agreed. I've been tinkering with the WordPress HTML, but everything looks awful.
You need to format your code as code instead of just pasting it into the article. Refer to [this article](https://codex.wordpress.org/Writing_Code_in_Your_Posts) for how to do this; basically, put sections of code into `&lt;pre&gt;` tags and snippets of code into `&lt;code&gt;` tags.
If I understand the problem correctly, linking your program with GPL code automatically makes your code GPL, which means you must publicly disclose the source code. This is pretty much a no-no if the source code is considered trade secret.
i understand some people don't like GPL, but what does that have to do with microcontrollers?
A few random samples: 1. In `set.h`, `sgc_exp_two()` is basically a left shift and `sgc_log_two()` can be implemented with `flsl()`. Both should be declared as `static inline`, not just `static`. 2. In `static_queue.h`, `N##_move()` can be rewritten as if(++*flag == S) *flag = 0; 3. In `string.h`, `N##_copy()` can be rewritten as *first = *second ? strdup(*second) : NULL; 4. Are you sure `N##_equal()` should return false if both arguments are `NULL`? There is no documentation, so I can't tell if it's intentional or if you just didn't think about it. 5. Why are strings even parametrized? The only variable in those macros is the name; the size isn't used anywhere except to declare `static_##N`, which isn't used anywhere either. 6. You don't provide a constructor for strings, so the caller has to allocate them themselves, which breaks the encapsulation. 7. You consistently cast the return value from `malloc()` and `realloc()`. This is unnecessary.
I will look into that, thanks. In the meantime, I made the code public in SoloLearn and linked to it. It's still a little hard to read, but at least it looks more like code.
Embedded code does not typically see the light of day.
It looks less awful now, I think, but I'm still fighting the WordPress theme. I've still got the link there as an alternate viewing option.
Please don't. GPLv3 is a fine license for FOSS.
For the second box, if you get a character c from stdin, it's valid if: - '0' &lt;= c &lt;= '9' - 'A' &lt;= c &lt;= 'F' - 'a' &lt;= c &lt;= 'f' otherwise, it's invalid.
The problem is that you use `&lt;code&gt;` tags which are for snippets of code inlined into a paragraph. For whole sections of code, use `&lt;pre&gt;` which also conveys indentation correctly.
Looks like a rumour: original jmp 1f got changed into 0x1f by someone who took it as a typo, then someone determined the jump offset by hand or google, 0x2a, and inserted it into assembly where it now is taken as an address by gas and still lands a bit off.
How is `echoBuffer` declared?
Looks like very impressive work - will definitely make use of this next time I‚Äôm writing something in C
\#define RCVBUFSIZE 800 &amp;#x200B; char echoBuffer\[RCVBUFSIZE\];
That should be long enough. Note that `strncpy` is not the function you want in 99% of the cases. It's meant for the special use case of NUL padded fixed-width fields in file formats and you already use it incorrectly. Just use `strcpy` after verifying that the space is sufficient or use `memcpy` if you know the length of the source. You might also find `strlcpy` from BSD useful. That said, none of this should cause your program to malfunction and I don't quite see the issue. Please post your full code so I can try to run it on my own computer.
First, thanks for the share as this looks really good! As others have mentioned, if your goal is for this to see widespread use, I'd go with a more permissive license like MIT, Apache License 2.0, or even LGPL. Nothing wrong with regular GPL, but in general it's really restrictive for libraries. For example, and I am no lawyer here, but I believe any application that uses your code that gets distributed would be forced to license the *entire application* as GPL -- meaning it would need to be open source among other things. This would prevent many users from being able to use your code in many companies. Not hating on the GPL or anything, just adding my $0.02.
 void HandleClientTCP(int clntSocket) { char echoBuffer[RCVBUFSIZE]; /* Buffer for echo string */ int recvMsgSize; /* Size of received message */ /* ------Step 5 recv from the client ------- */ /* Receive message from client */ if ((recvMsgSize = recv(clntSocket, echoBuffer, RCVBUFSIZE, 0)) &lt; 0) DieWithError("recv() failed"); printf("Received from the client: [%.*s] \n",recvMsgSize, echoBuffer); /* Send received string and receive again until end of transmission */ while (recvMsgSize &gt; 0) /* zero indicates end of transmission */ { /* ------Step 6 send to the client --------- */ /* Echo message back to client */ printf("%s\n",echoBuffer); char nquote[] = "C"; char* cquote; int val = strcmp(echoBuffer,nquote); printf("%d\n",val); if (strcmp(echoBuffer,nquote) == 0) { cquote = Quote(); } else { printf("Country stuff \n"); } //strlength = strlen(cquote); printf("%s\n",cquote); strncpy(echoBuffer, cquote, sizeof(echoBuffer)); echoBuffer[RCVBUFSIZE + 1] = '\0'; printf("%s\n",echoBuffer); if (send(clntSocket, echoBuffer, RCVBUFSIZE, 0) != RCVBUFSIZE) DieWithError("send() failed"); else { /* Print on the server what the message was after echoing to client */ printf("Sent to the client: %s \n",echoBuffer); } memset(echoBuffer, 0, sizeof(echoBuffer)); /* See if there is more data to receive */ if ((recvMsgSize = recv(clntSocket, echoBuffer, RCVBUFSIZE, 0)) &lt; 0) DieWithError("recv() failed"); printf("Received from the client: [%.*s] \n",recvMsgSize, echoBuffer); } /* ------Step 7 close when program is terminated ------- */ /* Close client socket and clean up resources*/ close(clntSocket); #ifdef _WIN32 /* IF ON A WINDOWS PLATFORM YOU WILL HAVE TO CHECK THIS */ WSACleanup() #endif } Here's the first part
What others said. I won't be able to use GPL code at work, so that's that.
 void HandleClientTCP(int clntSocket) { char echoBuffer[RCVBUFSIZE]; /* Buffer for echo string */ int recvMsgSize; /* Size of received message */ /* ------Step 5 recv from the client ------- */ /* Receive message from client */ if ((recvMsgSize = recv(clntSocket, echoBuffer, RCVBUFSIZE, 0)) &lt; 0) DieWithError("recv() failed"); printf("Received from the client: [%.*s] \n",recvMsgSize, echoBuffer); /* Send received string and receive again until end of transmission */ while (recvMsgSize &gt; 0) /* zero indicates end of transmission */ { /* ------Step 6 send to the client --------- */ /* Echo message back to client */ printf("%s\n",echoBuffer); char nquote[] = "C"; char* cquote; int val = strcmp(echoBuffer,nquote); printf("%d\n",val); if (strcmp(echoBuffer,nquote) == 0) { cquote = Quote(); } else { printf("Country stuff \n"); } //strlength = strlen(cquote); printf("%s\n",cquote); strncpy(echoBuffer, cquote, sizeof(echoBuffer)); echoBuffer[RCVBUFSIZE + 1] = '\0'; printf("%s\n",echoBuffer); if (send(clntSocket, echoBuffer, RCVBUFSIZE, 0) != RCVBUFSIZE) DieWithError("send() failed"); else { /* Print on the server what the message was after echoing to client */ printf("Sent to the client: %s \n",echoBuffer); } memset(echoBuffer, 0, sizeof(echoBuffer)); /* See if there is more data to receive */ if ((recvMsgSize = recv(clntSocket, echoBuffer, RCVBUFSIZE, 0)) &lt; 0) DieWithError("recv() failed"); printf("Received from the client: [%.*s] \n",recvMsgSize, echoBuffer); } /* ------Step 7 close when program is terminated ------- */ /* Close client socket and clean up resources*/ close(clntSocket); #ifdef _WIN32 /* IF ON A WINDOWS PLATFORM YOU WILL HAVE TO CHECK THIS */ WSACleanup() #endif } here's the whole section, it runs properly except when its copying any string over 40 characters then i get the random characters
I'm in the same boat.
What is function Quote() doing? Something tell me you are returning a pointer to data that has been freed. (also please use lowercase for function name, it looks like a C++ constructor)
Yeah this code is a mess atm but heres the quote function. &amp;#x200B; char *Quote() { char *str; srand (time(NULL)); int lineNumber = (rand() % (43 + 1 - 1) + 1); static const char filename[] = "Quote_File.txt"; FILE *file = fopen(filename, "r"); int count = 0; if ( file != NULL ) { char line[256]; /* or other suitable maximum line size */ while (fgets(line, sizeof line, file) != NULL) /* read a line */ { if (count == lineNumber) { str = line; break; } else { count++; } } fclose(file); } else { printf("File does not exist!\n"); } return str; }
This code is pretty different from the code you originally posted. Especially, your `strncpy` call is different (though it is still not wrong).
My bad, I‚Äôve been trying to fix it and still no luck :p
It looks even worse with pre.
Your `str` function returns a pointer to an automatic variables. Automatic variables are released when the block they have been defined in expires, so the return value of `Quote` always points to released storage. There are three ways to fix this: * you could make `line` a static variable. preventing it from beinig released. This is the traditional solution but comes with a bunch of caveats. Notably, `Quote` is no longer reentrant if you program this way and each time you call `Quote`, the same buffer is being overwritten. * you could modify `Quote` to receive a buffer as an argument into which `Quote` is supposed to write its text. This seems to mesh well with your application. * you could modify `Quote` to dynamically allocate `line` with `malloc()`, giving the responsibility for releasing `line` to the caller.
How do you use `&lt;pre&gt;`?
Ill try that out, but why does the issue only happen with strings over 40 characters? Anything below it does not have the random characters at the end
The issue is that since `line` is a stack variable in a stack frame that has expired, its storage is overwritten by stack variables of subsequently called functions. It's hard to say what or how exactly this happens, but it is clear that it happens. The reason why only the end of the string is overwritten is because the stack grows downwards in memory, so functions that use less stack space than `Quote` only overwrite the end of the stack frame and thus likely only the end of `line`.
That's exactly the issue the license wants to fight against.
That's mostly a historical note though. Nowadays there's not much difference when it comes to bugs between O2 nd O3.
Thanks for the feedback, you are right mostly, I do have to make it a bit more simpler and elegant. 1.) I think most would optimize the left shift on their own, and `inline` did nothing looking at the performance even without optimization, the compiler does what he wants anyway, as far as I know `inline` is just a suggestion for him. 5.) Strings are parametrized because there may be other types of strings in the code so you can change the name of yours, look at that as a namespace. 6.) I don't know what you mean with string constructor, `N##_init` sets it to `NULL`, the `N##_init` functions is not allowed to allocate anything. 7.) I tried to make it C++ compatible so I did the casts.
Your test/Makefile is completely redundantly written. On mobile but you can basically do this: CFLAGS=-Wall -Wextra -flto CPPFLAGS=$(UNITY_INC) # or whatever it js LDLIBS=$(UNITY_LIB) # ... TESTS=test_foo test_bar #... all: $(TESTS) # ---- # pattern rule, replacing built-in implicit .c-suffix rule %: %.c $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $(LDLIBS) clean: @$(RM) -fv $(TESTS) # don't use any implicit rules .SUFFIXES: # these rules won't actually build the targets they're named after .PHONY: all clean Although, actually even the first 5 lines would suffice, as everything else will be picked up by make automatically, since it knows how to build executables from .c files automatically. Just run `make A` in a directory with just a file called A.c and it will do: cc -o a a.c If you use `make CFLAGS=-Wall LDLIBS=-lm a` it will do cc -o a -Wall a.c -lm Note, that all options come *before* the input files and the libraries come *after* the input files, as is mandated actually.
The `i` is declared by the macro itself in the for loop, declared as `N##_type` and will not be visible later on. Yes, `vec` will be declared by SGC\_INIT and all its functions too.
Thanks, I will try to improve it even more.
Yep!
I knew it xD classic beginner error, let's all hail rust :)
I'm not a huge fan of Rust. Yes, it prevents these kinds of beginner errors, but these are not the kind of errors experienced programmers have trouble with. And the kinds of errors experienced programmers have problems with are not addressed by Rust at all. For me, the whole security theatre of Rust pays a lot of attention to irrelevant details, catching bugs that are already caught by a pleothora of other tools, while not adding anything of value in actually error-prone situations.
Thanks, I will probably change it for the microcontrolers.
Why? It‚Äôs a very straightforward language. I personally struggle more with the various languages used for a web stack. C++ is well documented and has plenty of libs that you can use for specific tasks.
There is a lot of assumptions in this library that the code using it would have to follow. Usually when designing a library you should try to minimize assumptions. For example you do not allow custom allocators and that is a non-starter for my project which allocates a block of memory at the start and carved out custom blocked with custom allocators for the portions of code I need. It looks like a great library but if you‚Äôre looking for honest feedback, this is my 2c.
Allowing custom allocators is one of the things I intend to add, but I have to change a lot of code. Any idea is welcome, thanks.
 char *Quote() { char *str; str = (char *) malloc(sizeof(char)*100); srand (time(NULL)); int lineNumber = (rand() % (43 + 1 - 1) + 1); static const char filename[] = "Quote_File.txt"; FILE *file = fopen(filename, "r"); int count = 0; if ( file != NULL ) { char line[256]; /* or other suitable maximum line size */ while (fgets(line, sizeof line, file) != NULL) /* read a line */ { if (count == lineNumber) { str = line; break; } else { count++; } } fclose(file); } else { printf("File does not exist!\n"); } return str; } I allocated memory on str, but it still gives me the random characters when its returned
`strdup` may not be available.
Well, you still do `str = line`, overwriting the pointer to the memory you carefully allocated with a pointer to an automatic variable. Perhaps you meant to copy the content of the string instead?
 char *Quote() { char *line; //char *str; line = (char *) malloc(sizeof(char)*200); srand (time(NULL)); int lineNumber = (rand() % (43 + 1 - 1) + 1); static const char filename[] = "Quote_File.txt"; FILE *file = fopen(filename, "r"); int count = 0; if ( file != NULL ) { /* or other suitable maximum line size */ while (fgets(line, sizeof line, file) != NULL) /* read a line */ { if (count == lineNumber) { //str = line; break; } else { count++; } } fclose(file); } else { printf("File does not exist!\n"); } return line; } My bad, ive been working on this project for too damn long. now it only passes the first work of a sentence
Counting beans: In string.h char buff\[S\]; fgets(buff, S - 1, f);
That's because you pass `sizeof line` to `fgets`. `line` is a pointer, it's size is 4 or 8 depending on your architecture. Try passing the number of bytes you allocated.
I mean that was just one assumption. You could just take a block of data and allow the collection to exist only in that block (which avoids allocating during runtime) while using asserts and proper error handling if you run out of memory. if the user doesn‚Äôt provide a block of memory maybe they provided an allocator. If they haven‚Äôt provided an allocator maybe they don‚Äôt care how it allocates. The point is to give the user an abundance of options that work for their use case and not force them to work with yours.
I know what you mean, I was even thinking of writing an allocator that uses a single array as a pool, then the library could be totally independent. As for the custom allocator part, I will add the support sooner or later.
Rare bugs though
Nah, it catches a lot of issue also skilled developer does. Use after free, garbage, concurrency in general, off by one(or more) are all issue that all project has to face and are not always easy to spot, that compromised security of so many project, even with skilled teams. A quick look at the most severe CVE by type speak by itself. Plus, arm-gcc-none (I am mostly embedded) has no sanitizer at all.. But even if you have their are runtime, is like debuginng a JS, you must be sure to get in runtime in all cases. Still have to see a static analizer on par, feel free to give me a hint if you know some good ones (even commercial)
&gt; Nah, it catches a lot of issue also skilled developer does. Use after free, garbage, concurrency in general, off by one(or more) are all issue that all project has to face and are not always easy to spot, that compromised security of so many project, even with skilled teams. A quick look at the most severe CVE by type speak by itself. These problems are easily catchable with existing analysis tools and fortification options. Think about the billions of lines of C code that are written every year and look at the number of CVEs you find for C projects. I think that number is actually pretty low given how much C code is around that has only now been probed for issues. Almost every single catastrophic bug begins with the same situation of no testing, no fortification, no analysis and a build process that spits out hundreds of warnings and no process of quality control in place. And many of the more devious ones like *goto fail* are bugs that could occur in more or less the same way in Rust code. Note lastly that for complex data structures and non-obvious concurrency models, you are still very much required to turn off the borrow checker in Rust because it can only check very simple models of how memory is managed. Of course, these models are how most code is written (which is a good thing), but good programmers make very few errors with that and those made are quickly caught by tools that are not as intrusive as the borrow-checker of Rust. So why bother with that in the first place? I want to write down my algorithmic ideas, not constantly pay attention to irrelevant desires of the programming language. That's why I stopped programming in Haskell, too; too much attention to solving irrelevant typing issues, too little implementing algorithms.
A constructor would allocate the string as well as initialize it.
Kinda new to C, what's the benefit of using macros and keeping it all in a header file, as opposed to normal functions?
For example, you can't have a vector for any data type, it depends of the size of the data type and many other things, a vector of integers is not the same as a vector of strings, so you always have to create a new one for your purpose. The macros generate code needed to operate with your data type. You can always use `void*` as elements witch can store any type, but that is way slower and harder to use.
I don't see the purpose of an empty allocated string, the other containers don't allocate anything either on initialization, nor does C++ as far as I know, it will allocate space when needed.
What does counting beans mean? Is it like writing a while loop to find the length of a string?
Thanks, I must admit I am not that good with makefiles.
You have sample code that `malloc()`s a string before using it. That `malloc()` call should instead be a call to some sort of constructor, even if all that constructor does is call `malloc()` (although I would recommend using `calloc()` instead). That same code also uses `strcpy()` to fill in the string, which also violates the abstraction. BTW, ‚Äúuntil‚Äù and ‚Äúmeasure‚Äù are spelled with a single ‚Äúl‚Äù and a single ‚Äús‚Äù, respectively.
My spelling is bad, I know. I forgot I made a function that creates a string from C string, `N##_create` ,should have used it, maybe I created it after I wrote the example, I can't remember.
They are easily catchable but many big issue slept and stay in code for decades. And "small" is still way much more than 0, especially in critical code like kernel, encryption and secure communication. Why switching off the borrow checker? If it gets in the way is because you are not writing in another language using rust; a language is not only itself but also its guidelines; while C/C++ are much more flexible, that flexibility can turn against you. Is like using C++ and passing void* everywhere; well *technically* you are not writing C++.
Practice. Actually code things. Over time you'll get better because you'll have more experience dealing with different situations. Research how problems have been solved in the past as well. Pretty much every "how do I get better at X" posts here can be solved by doing X.
&gt; Why switching off the borrow checker? If it gets in the way is because you are not writing in another language using rust; a language is not only itself but also its guidelines; while C/C++ are much more flexible, that flexibility can turn against you. The borrow checker is useless if you write linked data structures where it is not trivially provable if all other links to an object have elapsed when you release it. It is also useless in situations where you use a memory pool paradigm where some threads operate on a pool of objects that get shared all over the place but you know that when all threads are done, all references have elapsed and you can release the pool. It is also useless when you do lock-free concurrency where you can prove mathematically that each possible ordering of operations is well-defined but you cannot prove so to the borrow checker or when you have any sort of concurrent mutation that is not obviously locked out. All these are things I do regularly in my job. Yes, I make a ton of mistakes doing that. Yes, I'd really like to have a tool that makes this easier (Go's race detector for example goes a long way in this regard) but Rust's tooling is just completely useless in this regard. &gt; They are easily catchable but many big issue slept and stay in code for decades. And "small" is still way much more than 0, especially in critical code like kernel, encryption and secure communication. We have only in the last ten years developed automated tooling to find such issues in large code bases without a lot of manual work. That's why all these issues creep up now. In the meanwhile, the attitude of programmers have changed and the way C programs are written has changed. I don't think that there is too much of a risk with programming in C. &gt; Is like using C++ and passing void* everywhere; well technically you are not writing C++. Well, duh. Just like you are not programming Haskell when you don't make all functions as generic as possible. Which is one of the reasons why I eventually ditched Haskell: I just don't want to think about this when implementing algorithms. &gt; Also I suggest you to look at stackoverflow result this year: more than half (like almost 3/4) of programmer said they felt to be "above average" in skill. Stack Overflow is also known to be a place that eats beginners for lunch, so I'm not too surprised about this assessment.
This looks really cool! I'm currently working on something exactly like this, I'm pretty new to C so I might use your work as a guideline.
u/Karma_Kills: **Do not delete your posts once you get an answer.** It robs other people of learning, and it's rude to those that answered. We didn't write my responses just to help you. We wrote them so that everyone could learn. By deleting your post you've effectively deleted all of our comments.
Wait why is void* slower? Missing compiler optimizations?
_start is the symbol usually assigned as the entry point of ELF executables. I dont think C actually specifoes anything about it, and ELF definitely doesn't but the symbol is that by convention.
One quick suggestion: Don't use the GPL for a library. if you want anyone to use it at all, at most, use the LGPL. that said, BSD, MIT, Apache, CC0 are strongly preferred.
it's not about "some people", that license will instantly kill any external use quicker that shooting it in the face would.
Lets say you have an array of integers and an array to `void*` to integers, if you want to access an element in the first case you would just do `array[n]` where in the other case you would have to dereference it too `*(int*)array[n]` , this can't be optimized out I fear. More memory is needed for the second one too since you have to allocate the array of `void*` and the elements them self, witch is another performance loss because of the need to allocate every element individually. And lastly `void*` array is not cache friendly. I hope you get the concept.
Thanks, feel free to do so, although it's quite hard to understand, macros are not easy, but you will learn a lot doing so.
Thanks, I heard that a lot, I will change it soon.
Really what happen is that is pretty hard to write code without UB and optimization level will make them jump out. For example, Odin Holmes had a nice talk on how ST HAL has some bug that will break their "locking" mechanism, but only if you enable LTO.
It need to be GPL if you statically link the code.. Which is a must on a MCU, so it can be quite restrictive. But also I see usage of malloc(), that also Ade quite a no go on MCU world (fragmentation is the big deal), much better have statically sized container.
splitting big Problems into smaller ones or literally drawing a map of your Programm before writing it. Apart from that i think you are f..... .
The GNU Make Manual is rather good, although it really takes reading through it completely to understand it. There's also POSIX make but the lack of assignment (rather than macro definition + expansion), pattern rules and some automatic variables is kind of a bummer. I'd also like some improvements to GNU make, like specifying that one rule has multiple outputs (most useful when using YACC and LEX). But eh, ramblings.
I don't have any numbers specifically for bugs that only appear in O3 and not O2. Over the last few years my professor and his colleagues discovered around 1500 bugs in gcc and LLVM, so I assumed there must also be several bugs in between O2 and O3.
I agree that generally you probably have UB if you experience issues with O3. I just didn't like the `only if your code invokes UB` qualification.
Sure, there are bugs, but you cannot say that there are decidedly more in O3, it might was well be, that with more optimizations you get less bugs because of some weird happenstance of options.
I am personally finding stuff like C# a lot easier to follow, but that should be obvious since it is a higher-level language. I hope to learn C++ later on, but the higher languages are a lot easier to get started with it seems, to me at least.
Ok i had something different in mind when i asked about void*. Usually when i do stuff like this i create a void* which represents the array(instead of array of void*).
I'm putting the tags around the code, of course. But, WordPress reformats everything as soon as I press "update."
That is weird.
It's a pain in the ass. I've tried quite a few ideas, but then the HTML disappears or gets mangled as soon as I update.
This could work partially for array type containers, node type containers would have to use `void*` too as their element instead of the data type itself since the size of the node is the same for any type leaving the above stated problems. Every insert in the container would need to know the size of the element so you would need to pass it as a parameter, furthermore sometimes you would need a function pointer passed as well that would tell the inserting function how to copy the elements since everything is `void*` Freeing the elements would be a pain too if the data type is not a primitive one. Some of those things would be optimized out but it would still be quite a bit slower.
Can you upload the exact html you type onto a paste service so I can have a look? Perhaps you are making a mistake somewhere.
&lt;pre&gt; code more code even more code &lt;/pre&gt; It's worked for more than 2 decades!
Did you make sure to close the `&lt;p&gt;` tags of the preceding paragraphs?
Especially in an embedded environment.
WordPress does not display those tags, even if you add them manually. It's meant to be an easy way for non-technical people to publish blogs. So, it controls the formatting behind the scenes, allowing you to tinker with HTML in a very limited way.
With the same logic you can also argue that you cannot say that there are *not* decidedly more in O3. [Here](https://arxiv.org/pdf/1610.03148.pdf) is a paper by said professor from 2017 which found and confirmed 217 bugs in gcc and clang. Interesting is section 5.3.2 and figure 10, it shows that they found 51 `-O3` bugs and 40 `-O2` bugs. This seems to suggest that there are indeed more bugs in `-O3`. Of course this is virtually unknowable, it could also be that the technique used, just happened to uncover a bunch of `-O3` bugs.
Then switch your blog from wordpress to something that is not as braindead.
I think a big part is really understanding what you‚Äôre actually trying to solve, and really figure out everything you already know about it. Honestly just writing out everything you know about the problem space can be really helpful. Going from there, the biggest thing is don‚Äôt be afraid to really try weird approaches. A lot of time they don‚Äôt solve the problem, but understanding why they don‚Äôt solve the problem can be _so_ helpful. Behind every solution, there were many paths that were tried and failed.
I've messaged them first. They're so big, they must have a solution. I can't possibly be the first blogger to ever want to publish C.
I've seen other blogs manage. Perhaps a plugin is needed.
* [Mind Maps](https://imindmap.com/articles/how-to-use-mind-maps-for-problem-solving/) *[Think Laterally](https://www.lifehack.org/articles/work/think-laterally.html) * Regular mental exercises like word games/puzzles and math puzzles * Regular exercise * Dance, play music, paint, juggle * Play a sport * Get a good night sleep
Oh, I agree, "only" is too strong. I normally use Os and so far so good :)
Perhaps. At least the link is there in the meantime.
If you ever use the small device C compiler (SDCC) - sometimes it will "simulate stack" to "save resources" and the results are often disastrous.
You may be interested in [the International Obfuscated C Code Contest](https://www.ioccc.org/).
This was a winner of the [first International Obfuscated C Code Contest](http://ioccc.org/years.html#1984): short main[] = { 277, 04735, -4129, 25, 0, 477, 1019, 0xbef, 0, 12800, -113, 21119, 0x52d7, -1006, -7151, 0, 0x4bc, 020004, 14880, 10541, 2056, 04010, 4548, 3044, -6716, 0x9, 4407, 6, 5568, 1, -30460, 0, 0x9, 5570, 512, -30419, 0x7e82, 0760, 6, 0, 4, 02400, 15, 0, 4, 1280, 4, 0, 4, 0, 0, 0, 0x8, 0, 4, 0, ',', 0, 12, 0, 4, 0, '#', 0, 020, 0, 4, 0, 30, 0, 026, 0, 0x6176, 120, 25712, 'p', 072163, 'r', 29303, 29801, 'e' }; You may notice that `main` is an array rather than a function. The contents of this array would be executed as machine instructions when the program starts. However, this means that it only works on a PDP-11 or similar.
* Passing large data structures between functions * Passing multiple variables to a function to be modified * Direct access to memory locations (embedded hardware with memory-mapped I/O) * Building complex data structures such as linked lists
Let's say you have two big tables of data that determine how your car works. The engine control computer needs to use the one table while the car is warming up, but then uses the other table to control the engine once it is warmed up. When the engine computer (ECU) detects that the temperature condition is met, it changes the pointer from pointing at the warmup table to the full-temp table and everything keeps operating normally. This is grossly simplified, but you can see how it can make this situation easier than if the program had to change the state of a bunch of table values before it could swap modes.
Thanks guys much respect.
This was an entertaining, yet incredibly helpful answer.
https://en.m.wikipedia.org/wiki/Duff%27s_device
The fact that does not catch all problem, does not means is useless. At least you don't have to worry about on depart of the problem. Automated tooling can do so much; especially when it work with the runtine. And they can do so much because rust is basically born around a static analizer, so of course it has the best integration/functionality :) Then you may not like the language, but that is an objective point of view.
Just a sad attempt at humor. Unnecessary -1 in the buffer size.
you have to add -lmath
Add -lm to tell the linker to link with the math library
sry -lm
 if (0) case 1: statement; SKIP instruction :)
It works but that's even more confusing. If I call sqrt() from a single source including math.h I don't need to specify that option to the compiler. This is also the case when I use a single source and one header. Any idea why?
It works but that's even more confusing. If I call sqrt() from a single source including math.h I don't need to specify that option to the compiler. This is also the case when I use a single source and one header. Any idea why?
It works but that's even more confusing. If I call sqrt() from a single source including math.h I don't need to specify that option to the compiler. This is also the case when I use a single source and one header. Any idea why?
hmmmm okay never ran into that... c comes from the olden times... üòã. where floating poi t units where rare and precious. so to preserve programm space the math library isn't part of the stdc library.. do you compile the single programm as c++. because the c++ compiler includes the c++ runtime whuch has lubmath in it
Sure, but in the days of gcc 2/3(?) there were explicitly some things in O3 which did optimize more than "allowed" and it was notoriously breaking valid code. These times are over and the numbers are more fluctuating. What I wanna say is: There *might* be more bugs when you optimize further or less. But the historical thing of O3 being completely riddled with bugs is decade-old anecdote which won't die.
We seem to be making a different point ;)
Yep\^\^
You probably want to licence it under LGPL which means that anyone can use it without requiring their code to be licenced under LGPL, but anyone that modifies your library is required to release it under LGPL.
Non-mobile: https://en.wikipedia.org/wiki/Duff%27s_device
**Duff's device** In the C programming language, Duff's device is a way of manually implementing loop unrolling by interleaving two syntactic constructs of C: the do-while loop and a switch statement. Its discovery is credited to Tom Duff in November 1983, when Duff was working for Lucasfilm and used it to speed up a real-time animation program. Loop unrolling attempts to reduce the overhead of conditional branching needed to check whether a loop is done, by executing a batch of loop bodies per iteration. To handle cases where the number of iterations is not divisible by the unrolled-loop increments, a common technique among assembly language programmers is to jump directly into the middle of the unrolled loop body to handle the remainder. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&lt;math.h&gt; is a header but no code.... \-lm links in a library which has the actual code &amp;#x200B; any clearer ?
&gt; What cool, obscure, or **outright hideous** usages of syntax have you seen in C? C has a silent conversion from "array of T" to "pointer to T": int a[6] = {4, 8, 15, 16, 23, 42}; int * p; p = a; // You can assign an array to a pointer... a = p; // ...but not the other way around! ++p; // You can increment a pointer... ++a; // ...but you cannot increment an array! This leads to all kinds of confusions about arrays and pointers: "Arrays are pointers", "An array is a pointer to its first element", nonsense like that. Many C programmers have a completely warped mental model about arrays and pointers.
I always like this abuse of array syntax: int a[3] = { 1, 2, 3 }; int b = 1; printf( "%d\n", 2[a] ); // prints '3' printf( "%d\n", b[a] ); // prints '2'
Find problems and try to solve them.
Does your if statement mean if (variable == 0)? Bit confysed by your question.
No lol, I just made a pseudo code to simplify things, but I guess it's made things more complicated. The only "real" variable in that code would be "variable". Does it make sense now if you don't read it literally?
You're if statement is a bit jacked. It should use the comparative operator (==, or the double equals, if you will). You also don't put a semi-colon at the end of your if statement. So it should read something like this. int variable = 0; if (time == night) { variable = 1; }
Truuue, thanks. Fixed.
I have set it to the MIT license.
Every five seconds, someone on reddit asks this question. Every 10 seconds, someone replies with the same answers. It's too bad there aren't any references or tutorials or articles or blog posts about this subject on the internet.
Yes haha, I have seen a lot of videos and books that example the concept, but it‚Äôs a bit difficult to imagine it‚Äôs use without imagination haha. Pointers are complex indeed but thankfully I understand why they are important now
I'm not quite sure what you mean I'm afraid. If time is equal to "night", do you want the variable to still be 1 after the if block is exited? because it will be, so I figure that can't be what you mean. #include &lt;stdio.h&gt; int main() { char *time = "night"; int variable = 0; if (time == "night") { variable = 1; } printf("%d", variable); return 0; } That will print 1 as the value for variable. Is that not what you want? Apologies if I'm getting this completely wrong, I'm admittedly quite tired. If you want the value to update dynamically, you'd need day and night to change dynamically, but in that case why not just use day and night directly? #include &lt;stdio.h&gt; int main() { char *time = "night"; int variable = 0; while (1) { time = get_time_of_day() if time == "day" { //do day stuff else: //do night stuff } } Provided you had some kind of function which gave the string "day" or "night" -- perhaps by using a library function to get the actual time of day and returning night if it's between a certain range and day otherwise -- this would loop infinitely (that's what the while (1) means, 1 is always considered true) and for each iteration of the loop, the time value would be updated (via the function get\_time\_of\_day) and then certain actions would be carried out depending on the value by either the if or else statement.
Pointers are not complex. They're one of the simplest things in programming. Especially if one understands how computers work.
It is totally possible. That's why we have if statements. I recommend reading up on scope. If you have a variable that won't stay changed, try using 'static', like 'static int variable'. That makes it so 'variable' will stay no matter where you change it.
Thats exactly what an if statement is. After your if statement is ran the value of the variable has been changed permenantly unless that block of code is ran again.
I see you have deleted your post. Please don't do this. I have spent a lot of time helping you with your problems. I don't do this just to help you but also to help all future people who stumble over this post. By deleting your post, you deny those people this resource. Please don't be inconsiderate. Please do not delete your posts.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions instead.
Really? I just tested it with a few different things. For example, I am making a game where you collect objects. So I made a test with: int apples = 0; int swords = 0; If (potions == 5) { swords = 100; } Which means when you collect 5 potions, your sword inventory should go up to 100. But then when you get 6 potions, your sword inventory goes back down to the initial variable of 0 again. Is my code completely screwed somehow, or is that supposed to happen?
Some compilers recognise `sqrt` and turn it into a single machine instruction, avoiding the need for the math library some times. Do not rely on this. Always link with `-lm`.
&gt; where floating point units have been rare and precious. so to preserve programm space the math library isn't part of the stdc library.. That's not the reason. From the beginning, the linker would pull in only those parts of static libraries you actually needed. So extra functions in a library do not make your program larger.
Yrah theres something else wrong with your code and understanding of if statements here. All that would do is when you get 5 potions your sword variable is now set to 100, if you then get another potion it wont touch the swords variable this will stay at 100. What i think is happening here is your setting your variable every frame, wherever this code is is being ran every frame so it is setting swords to 0 at the beginning every time. You need to create and set these initial variables somewhere else, in some sort of setup code which is only ran once. If your using unity this will be something the run() or initialize() and the rest of the code will be in update which is called every framr
[Oh my god, thank you.](https://www.youtube.com/watch?v=5uUuRD_atfI)
What do you mean by cannot incrementing an array? Let's say I will write this: int x = *(a++) ; After this line x =8, this is not legal in C90 C99?
I see no problem in here. Considering assembly, all stack variables are treated as some position in the stack; the contents of `a` will be placed on stack as well, and the compiler will know the position of the first (and others) elements )converting `a` and `a + x` to pointers during compile time). This way it can access them as "`x` bytes from the peak of the stack". When memory is allocated in the heap, it's necessary to store the address somewhere; but the elements gonna be found by taking several bytes from that stored value. Ofc it requires use of `[]` while contents of the stack may be reached with `push` / `pop` only, but any array is just several pieces of data of the same size, and it's only necessary to know the position of the first element to access it (which is either stored somewhere or can be calculated considering the nature of the stack).
No, because you cannot modify array-types (however you can modify the contents). The correct way would be to write int x = *(a+1); // equiv. to a[1] Think of arrays as labels in assembly, you cannot modify labels. But you can have a variable with the same value as the label (a pointer to that address) and modify that variable.
You are correct, I was trying to modify the 'label' and not the address I wanted to dereference.
Without all the black magic, I never knew I could reference an array backwards like that. 2[arrayName]
The following macro, you are using a null pointer to access the member of struct `#define member_size(type, member) sizeof(((type *)0)-&gt;member)`
Please indent your code with 4 spaces so that it formats correctly in reddit. Like this
math.h doesn't contain the implementation of the square root function on Linux, it only declares it. Adding -lm will import libm.so, which contains the actual implementation.
 I'd just like to interject for a moment. What you're referring to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX. Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called "Linux", and many of its users are not aware that it is basically the GNU system, developed by the GNU Project. There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called "Linux" distributions are really distributions of GNU/Linux.
done.
that's because a[n] is syntactic sugar for *(a+n), which is the same as *(n+a)
Programming works in sequential order, very specifically. The only reason swords became 0 is because you told the computer to do so. What you linked us is a part of a loop that you didn't include in this post. Whether that be a time based loop in unity, or a for loop of your own creation. It goes to the top of the loop, sets potions and swords to 0, and then checks if potions is 5. Once potions becomes 6, it of course sets potions and swords to 0 again, but does not meet the criteria to make swords = 100. All changes to a variable are permanent, until you specify otherwise.
&amp;size. And ptr.
fixed, same error
C# is a lot easier to learn. I learned C#, followed by C, and can honestly say that learning C is the most advantageous to learn by a large margin. Using C# tends to prevent you from actually improving as much as you would by learning C. Not entirely because of the language, but because of the support for it, and the libraries. In C#, if you want to make a basic window, and put a user interface on it, you can dish it up in literally seconds in VS without having to even open a .c file. If you want to handle scaling the interface automatically in some way, they also handle that for you without you needing to code at all. Everything is just so streamlined that you don't have to actually think about how anything works. This goes for a lot more than just the UI, this was just the example I picked. When challenged by an obstacle in C# itself, there's usually a function that solves most of the problem for you, rather than you having to write much code of your own. Don't get me wrong; programming will always help you learn, but I do think C# slows the growth of a programmer. Especially when they are new.
&gt; Once potions becomes 6, it of course sets potions and swords to 0 again, but does not meet the criteria to make swords = 100. So for you, what would be the most intuitive and basic way to keep the amount of swords at 100 (even after the potions becomes 6).
‚ÄúIntuitive and basic‚Äù ‚Äî not setting it to zero. You are explicitly setting swords to zero before every potion test.
I can't tell on mobile but is there any whitespace between "file.txt" and "32" in your file?? If not fscanf will be reading the whole thing as a string and you might be attempting to read past the end of the file. Could you tell me what the output is if you print the result of your attempted string read??
the file.txt has a space with 32 with gisfile I manage to successfully obtain file.txt oops I copypasted the wrong thing by accident sorry haha
That makes sense. Would I have to put "int swords = 0;" somewhere else, because the amount is printed to the screen and it does start at 0 every time the program begins.
I think you meant you can assign a pointer to an array (which get translated to a pointer to the first element of the array) but not the other way around. What really bakes my noodle is array decay, https://stackoverflow.com/a/1461580
Is there any extra code between you opening the file and the error occuring?? Even if it seems unrelated it could be helpful to post it, currently I'm not sure where the error is
Without seeing all the source code I guess the preceding fscanf functions read everything up to a white space and there's nothing left to read in the stream. Hence the sigsev.
this may be related or no but after the printf size statement, I tried to declare an array of pointers pointing to a struct called "Location": Location* hashed = malloc(sizeof(Location)*size); I had used typedef struct _Location Location. This syntax seems to be consistent with the online resources... and at the end of the program, I free(hashed) to ensure memory isn't leaked. When Valgrind debugs the program and it exits out, it says 1,136 byes are still reachable but none are lost, so I don't think that's the problem.
when I print out the str it prints out each "word" (even if nonsensical) up to the white space so you're right about that.
So the gisfile buffer end in 54?
Try ending the program after the fscanf statement and see if you still get the error, you might be incorrectly freeing your memory We can't help you properly if you're only describing your code, we need to see it
&gt; simulate stack Could you elaborate a bit for a less knowledgeable audience (me)?
no, it ended at data.txt and didn't display 32
I tried return 1 immediately after the printf(size) but it still didn't manage to print it out. This is the (new) entire code now.
https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C
How is VB.NET so high on that list?
Wow this is pretty amazing, thanks for introducing me to this!
This actually cleared some things up for me, thanks!
Because TIOBE is a pretty meaningless metric. I think better rankings are [the one from IEEE Spectrum](https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2018) and [the one from Stack Overflow survey](https://insights.stackoverflow.com/survey/2019#technology-_-programming-scripting-and-markup-languages).
That doesn't help me, where is the entire code?? The code you posted mentioned other code and it certainly isn't a complete C program. Until you post the rest of your code no one can help.
its a little complicated - are u familiar with stack?
 I've managed to comment everything else out in my code except the following int main(int argc, const char* argv[]){ FILE* ptr = fopen(argv[1],"r"); //I have a statement afterwards that ensures it isn't null char str [256]; char file [256]; int size; while(strcmp(str, "unique_identifier")!=0){fscanf(ptr,"%s",str);} //this line works correctly and when I print out str it matches what I expect, and even prints out the unique specifier fscanf(ptr, "%s", gisfile); fscanf(ptr, "%d", &amp;size); //this causes an error return 1; }
This subreddit is about programming in C, not C++, not Python. I have removed this article as it is off topic. Also, do not post blog spam.
If you enter make sure to let us know. I have a friend that won many years ago. It's a lot of fun.
This looks very Windowsy. It's for specifying the linkage (e.g. whether it is exported or imported from a DLL) and the calling convention ( cdecl or stdcall)
Thanks)
&gt; can be either char** or a char*. Not really; they're 2 very different types. Show the code of the function(s)
Can you tell me the output of adding a printf statement after the fscanf to read into gisfile and print the return value of the fscanf to read into gisfile??
It's rather long but part of it is like `while((c = fgetc(instream))!=EOF){` `c = toupper(c);` `if ((c &gt;= 33) &amp;&amp; (c &lt;=90)){` `toStop = 0;` `char* m = *(MorseCode + c - 33);` `mcmsg_ptr = realloc(mcmsg_ptr, strlen(mcmsg_ptr) + strlen(m) + 1);` `if (!mcmsg_ptr){` `flag = -1;` `break;` `}` `strcat(mcmsg_ptr, m);` `strcat(mcmsg_ptr,"x");` `}` Also MorseCode is an array that contains all the morse code for ascii letters. As mentioned before, the code itself calculates the morse code correctly. But it doesn't save it. Also I can't change the header of the function, which is int toMorse(FILE \*instream, char\*\* mcmsg\_ptr)
Because you pass `m` by value, the value will not be changed outside the function.
ah, never found, found the problem, I mixed up %s and %d when I tried printed out size (it should be print %d and not %s)
&gt; It's rather long but part of it is like The internet isn't full yet. All of a function is relevent. int flag = toMorse(instream, m) .... printf("length of m %s\n", m); This doesn't change m. If realloc changes where the memory is, then `m` is left dangling. You need to pass a pointer to m to the function.
I've never seen someone make a clone of the `command.com` shell.
I'm sorry, how can I pass it by reference then? m is already a pointer?
\`case\` statements can be used alone without \`switch\` statements? :-o TIL (What's the use case for this trick, btw?)
You can pass a pointer to your variable: void foo(TYPE *x) { *x = ...; } TYPE t = ...; foo(&amp;t); Due to the way we call `foo`, we can modify `t` itself in the function.
It's only program you can't do real stuf with it. Only for exercise
Are switch/case fallthroughs not very well known? Personally they were one of the first things I remember learning.
&gt; the internet isn‚Äôt full yet. Tell that to IPv4 !
It's not the fall-through that's the magic behind this. It's the clever and perhaps not entirely intuitive combining of the \`switch\` and \`do while\` statements that allows you to jump into the middle of the loop.
Ah, yes, that part is a little weird. What made it click for me was transposing the loops and switch/case statements into assembly language with conditional branches.
Not really because, as I said, you don't have to specify the linking option when using only one source or one source and one header. Including &lt;math.h&gt; is enough in those cases.
Interesting, but if it recognizes the function by simply including the header when using one source or one source and one header, why is it different when using two sources and one header?
I have no idea. I haven't even seen your code.
This blew my head open.
There should be a function - perhaps ‚ÄúnewGame()‚Äù - which will reset key variables such as swords, scores, number of potions, etc. to zero.
They can‚Äôt, I think s/he meant that you can use it in a `switch` statement to skip, which is useful if you need a common fallthrough for several cases: switch(foo) { case 0: puts("This case here"); /*[[fallthrough]]*/ if(0) { case 1: puts("And this case here"); /*[[fallthrough]]*/ } puts("uses the fallthrough"); break; If you don‚Äôt need the a `switch`-`break`, you can use `do`-`while` also: switch(foo) { do { case 0: puts("This case here"); break; case 1: puts("And this case here"); break; ‚Ä¶ } while(0); puts("uses the fallthrough"); break; but that‚Äôs even less legible and good luck indenting it clearly.
My bad man, didn‚Äôt even think about this
Since there‚Äôs no need for you to take a buffer as input, don‚Äôt require a prior `malloc`, just start with a large-ish buffer and shrink it before you return if it‚Äôs too big. (Also, do not attempt to take the length of a newly allocated thing. Reading before you write or accessing a size-zero buffer is undefined behavior.) Return the buffer you allocated and make sure your caller either passes it to a dual API function that frees it, or frees it themselves. And cache your lengths. Every time you call `strlen`, you‚Äôre likely to walk the entire length of the string again. The compiler can sometimes optimize away a `strlen`, but if it can‚Äôt you‚Äôre multiplying your run time by the string length. You‚Äôre generally going to want+have to track the string length separately from the string content, if not the buffer length as well (which would avoid needing to reallocate for every single input character). `strcat` has the same problem as `strlen`, and if you already have the string length you can just `strcpy` or `memcpy` or assign.
When you pass an array as an argument it magically becomes a pointer. void test(int foo[]) // This is NOT an array { foo++; // This is perfectly legal } int main() { int a[6] = { 4, 8, 15, 16, 23, 42 }; // This is an array //a++; // This is illegal test(a); }
I'm familiar with the stack as a data structure.
`(fscanf(file, "%[^,]s", v[count].array[0]==1)` Is this supposed to be `((fscanf(file, "%[^,]s", v[count].array[0])==1)`?
https://en.m.wikipedia.org/wiki/Call_stack Placing things on the call stack is much more optimized than in the heap (malloc).
strlen() takes a null-terminated string, and there's nothing in this code to terminate it.
A zero length string should contain one null character.
I don't think that's the problem. Segmentation fault happens in \*(s+x) = c; There is something wrong with this code. I just don't know how to fix this one!
If only there was a place to upload workable code snippets with proper formating
ah yes, I missed that when I tried to rewrite the code to Reddit. Still the same problem, though.
&gt; Digraphs_and_trigraphs But...why?
&gt;I don't think that's the problem. If not that, what's your hypothesis? &amp;#x200B; Answer this: What is then length of the following string s? char *s = malloc(0); &amp;#x200B; or in other words, what the value of x on the above s (as in your code)?: int x = strlen(s);
Have you made sure your fscanf format string is actually matching your input file's contents?
Do you check if realloc returns a null pointer?
Undefined behavior, or a race condition or something. Show the code.
Do you really want that s in the format string?
With out even a general idea of what your code does it's hard to give much help. The fact that you have a different value for array[0] makes me think that you might be reading uninitialized memory.
hard to tell without seeing the code but are you waiting on your threads to be finished before they get printed?
Keyboards and terminals didn't always have the complete ASCII set
Edited
Edited
Edited. Yeah, I'm pretty sure that's what the pthread\_join function does, but if not feel free to correct me.
Threads can add a lot of indeterministic behavior because of how they are scheduled. Unfortunately, running under gdb can change the scheduling so it runs differently. Has the teach taught you about mutexes or semaphores? Most likely your code needs to use those so they can work together without stomping on each others feet.
Nope, we just learned about threads. Although I see the issue now with my code, my pthread_join line is commented out lol
`strlen` is from `&lt;string.h&gt;` so you might want to write your own implementation of it.
`s` is not a string. It is a pointer. Since it was initialized to the result of `malloc(0)`, it is quite likely to be `NULL`. Passing `NULL` to `strlen()` invokes undefined behavior. (I say ‚Äúlikely‚Äù because `malloc()` is permitted to return a non-NULL value for a zero-length allocation.) /u/kfor1996, you should post the complete code.
This code will not compile.
&gt; we have to change the values of an integer array from all 2's to all 0's using a variable number of threads. 99 lines of codes.. structs... you are really over-complicating this assignment...
Some help would be greatly appreciated. The main function is not allowed to be changed.
Why use a struct at all? `pthread_create` just needs a void pointer. You can cast an integer pointer to void,...
I also need to pass the number of threads to use, and where to start in the array for each thread. That's why I decided to use a struct.
line 56 is incorrect; there's no need for the `sizeof`
To add, it was used somewhere to catch '%X' or '%x' in printf().
I‚Äôll tell professor J Wong you said hi
offsetof(type, member) is also sometimes made like that
This. You need to be separating the lines of code that initialise the variables from the if statement that is comparing them. There would be no point in the comparison (if statement) if the instruction right before is to set that variable to zero. Those initialised variables should be outside of whatever loop you‚Äôre using to count the variables E.g Int potions = 0; Int swords = 0; While(game running){ If(potions == 5){ Swords = 100; } &lt;code to change potion count&gt; } Something like that but obviously modified to suit your game. As Original_Sedawk said having a function that initialises all the variables would not be a bad idea so you know where everything is going to be initialised in comparison to the rest of your code.
Anything shared must be locked before use as it's possible to read/write incomplete data due to thread timings (thread may switch "within" a code line, as the processor sees some lines as several lines of machine opcodes). So you use pthread_mutex_lock and pthread_mutex_unlock to protect those shared resources.
You give the same struct for each thread, changing it while you spawn them. If some thread is delayed before it gets past the variable initialization, to line 25, it will see wrong data, for the next thread.
Thank you very much for your answers, I will check Swedophone answer because I think it's what I need.
up
Initialize, and declare your variables outside of the loop. This should be done with all variables in general.
If you're developing threaded code, use TSAN.
I mean, why do you even delete your post in the first place? There is absolutely zero point in doing so.
And yet I got downvoted into oblivion for criticizing array-to-pointer decay. Should have seen it coming, must be Stockholm Syndrome or something :)
Unrelated to your actual problem, but those sizeof expressions are likely wrong. Can't tell for sure without seeing the `Vehicle` typedef.
Also no linker on a modern platform will mark the data segment as executable.
No idea if this is conventional or unconventional or even a bad practice. I used this in a C++ project, but is pretty much C: &amp;#x200B; struct rlong { union { long; char data\[8\]; }; }; I implemented a random string generator in a c++ project for a customer that needed unique random strings generator for 8-character strings to be printed as number IDs on a manufactured parts. Uniqnuess is guaranteed on database level, c++ part generates strings. So to be short I use random number generator to make random longs which I then just read one byte at a time. Later I use std::map to guarantee uniqness within batch 10 000 strings in current impl, but is really customizable per call, and later on when I insert those 10 000 strings the database will tell me how many insertions failed (duplicates) so I generate new ones untill I inserted 10 000 strings into database (it's just a birds overview, there are manny more constraints and demands on that project). The unusual part is maybe that I treat longs as bytes. Doing this in Java or Python might not be as straightforward as in C/C++. Here I can just write and read bytes as it suites me. When I wish I can see my stuff as long, and when I wish I can see them just as bytes, without any casting and arguing with the compiler.
Another cool thing you can do in C/C++ and any lang with pointer arithemtic really: some\_type \*a\[SOME\_SIZE\]; some\_type \*iter = --a; &amp;#x200B; You know have 1 to SOME\_SIZE indexed arrays, instead of 0 to SOMZE\_SIZE-1. Depending of what algorithms you are implementing it might be easier to write and read code where loops are from 1 to SIZE, than 0 to SIZE-1. Learned this some 20+ years ago in first edition of numerical recipies. Interestingly they didn't used it themselves C++ edition.
[https://github.com/chriscamacho/cLogicFun](https://github.com/chriscamacho/cLogicFun)
maybe if you're using just some defines in math.h and maybe if the compiler is smart about some simple math, but if you're using math.h just link its library in....
what's the problem? It worked on my end.
I've tired it without the "s" but it still outputs nothing ü§∑
just a thought this is a C sub-reddit (not C++) and give people a clue which book(?) you're talking about...
I have always used it when you don‚Äôt need to modify the actual pointer just being used.
Well the answer is pretty straight forward: when the chars that the pointer points to should not be changed. This is especially important when declaring a string literal such as: const char *str = ‚ÄúHello‚Äù; The reason is because string literals are placed in read only memory and if you try to alter/write to them you will ultimately get a segfault.
In my experience, when you use `const char* s = "abc";` the string that is being pointed to is not copied into data space. This is very useful for embedded systems with limited RAM because allows the string to be accessed directly from flash memory and doesn't waste RAM.
It's always been my policy that all pointers should be const until they're required to not be
Suppose you are passing your string, in a custom function. You want to calculate it's length. Now, while doing so, you do not want to change it in any way. for eg., You passed "My name is Aman" and you calculated it's length to be 15. But somewhere along the line, you mistakenly changed it to "My game is Aman". It's not good. And that's where const keyword comes into action. If you pass the string literal as **const char \*str**, then no matter what you can't change it by mistake or knowingly. It will make sure that string remains the same. If you try to change it anyhow, an error will be thrown. It's actually a good practice in C programs to prevent the mutilation of strings. Hope you understood it well. Feel free to ask, if you didn't get anything.
There's a concept called "const correctness" that basically means that variables should be declared "read only" (const, or *constant*) if they are indeed read-only. It's basically an additional type in the typing system, which lets the code and compiler help you make optimally-correct programs. It can be a good exercise to go back to your code and find out where you can add `const` and where you can't. Some functions can't operate on a read-only buffer, like the popular `strtok()`. If you constructed a program where everything passed between functions was `const`, meaning that it all got copied instead of sharing mutable structs by passing around pointers to those structs, then you'd have constructed a program using (at a high level) the "immutable pattern" favored in "Functional Programming" today. In general, you'd have done that at a cost of performance and by being less idiomatic in the C language, though there's significant room to isolate and encapsulate state within idiomatic C.
the small device c compiler is meant for devices with very little resources - e.g. there might only be room for less than 1k of stack. In such a case, it is easy to get a stack overflow. As a result, the SDCC tries to analyze the use of variables on the stack and see if it can optimize them with other storage methods - like direct values. The objective is to minimize stack overflows, but the result is often your variables behave in other unexpected ways.
If you don't want swords to get set back to zero at this point in your code, then don't do that. It's hard to tell without more context, but you probably want to set swords=0 at the beginning of the game, and then only change its value when it makes sense in the game to do so.
`typedef` can be quite flexible. typedef *&lt;returntype&gt; name(args)* makes *name whatever* be a function prototype. sizeof works with strings (sizeof "string") and instead of *p = malloc(sizeof(whatever)), you can do malloc(sizeof *p) this #define const is a magic incantation.
You mean when you don't need to modify the memory the pointer addresses, right?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Exactly. You can still change what the pointer points to in the sense that I can make char *ptr point from string literal ‚ÄúHello‚Äù to now point to string literal ‚ÄúTaco‚Äù. However, if you tried to dereference ptr and change one of the characters of ‚ÄúHello‚Äù, you would get an error. Ex: *ptr[2] = ‚Äòz‚Äô would give an error because you are trying to change a character of a const char*
"Weak typing" is orthogonal to the much-ballyhooed [Undefined Behavior](https://en.wikipedia.org/wiki/Undefined_behavior). UB, as it's often known, is predominantly the result of platform portability, maximum flexibility for implementers, and some significant backward compatibility. Weak typing means that we can explicitly bend variable types, or use them interchangeably, as when a string is conventionally a pointer to an array of `char` and also a pointer to the first (zeroth) element of that array. A language with "strict typing" and a separate "string type" wouldn't allow us that flexibility without explicit conversion through functions. Strict typing tends to add complexity, add Lines of Code, and add some degree of implicit security. Whether it's worth it is a continual debate, and is something of a [Goldilocks issue](https://en.wikipedia.org/wiki/Goldilocks_principle): de gustibus, we might say. But dynamically typed languages were in fashion 10-20 years ago and are out of fashion now, and functional languages with strong typing are relatively fashionable yet not used nearly so often.
**Undefined behavior** In computer programming, undefined behavior (UB) is the result of executing computer code whose behavior is not prescribed by the language specification to which the code adheres, for the current state of the program. This happens when the translator of the source code makes certain assumptions, but these assumptions are not satisfied during execution. The behavior of some programming languages‚Äîmost famously C and C++‚Äîis undefined in some cases. In the standards for these languages the semantics of certain operations is described as undefined. *** **Goldilocks principle** The Goldilocks principle is named by analogy to the children's story The Three Bears, in which a little girl named Goldilocks tastes three different bowls of porridge and finds that she prefers porridge that is neither too hot nor too cold, but has just the right temperature. Since the children's story is well known across cultures, the concept of "just the right amount" is easily understood and applied to a wide range of disciplines, including developmental psychology, biology, astronomy, economics, and engineering. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
As a parameter? you really shouldn't. All it does is get the compiler to bitch at you, it does not improve the compiled code's quality one bit. The machine code instructions are literally the exact same, it offers no benefit at all. The ONLY case i use the const qualifier is when I want to create an array that is read only, and then i'll use `static const TYPE` in the declaration, in a private header that's only included specifically where it's needed https://godbolt.org/z/tVISiV
just makif statement like this if(potions &gt;= 5) swords=100;
You'll catch certain bugs while compiling, instead of never or later while running.
&gt; In C#, if you want to make a basic window, and put a user interface on it, you can dish it up in literally seconds in VS without having to even open a .c file. If you forget about portability for a moment, and set aside LoC, you can technically [do the same thing in C by grabbing some boilerplate code](http://www.winprog.org/tutorial/simple_window.html). Or [here for another Win32 example, this time with the GCC toolchain](https://www.transmissionzero.co.uk/computing/win32-apps-with-mingw/). I can *understand* why having certain things built into a language is seductive, as opposed to some boilerplate, but I find that the seduced tend to find it harder to understand any reason for someone to go the other direction. Part of it is the bigger picture of the toolchains and ecosystems and portability. And a lot of it is "Program Refinement" -- progressively improvement of the code. We can start with some boilerplate and some modules and get an MVC up and running relatively quickly, without boxing ourselves in by using a language of limited portability or with other baggage. I'm a big fan of multi-language programming, but C# lends itself to this somewhat less than others, on account of assumptions about being bytecode and running in a CLR. It can call C ABI, but the ecosystem and proponents seem to want the native environment to be CLR, as in Java it's JVM. All the world an idealized virtual machine.
Practice &amp; experience is the only way.
Well, I can't find a paper using the phrase "improving compiler" like I described; maybe that was actually just a professor's paraphrasal that I'm quoting. But I finally remembered that the term for this kind of compiler is [superoptimizing](https://en.wikipedia.org/wiki/Superoptimization), which will definitely help you find papers about it including [the first superoptimizer, from 1987](https://web.stanford.edu/class/cs343/resources/superoptimizer.pdf).
**Superoptimization** Superoptimization is the process of automatically finding the optimal code sequence for one, loop-free sequence of instructions. It is performed in and by a type of computer software termed a compiler. Real-world compilers generally cannot produce genuinely optimal code. While most standard compiler optimizations only improve code partly, a superoptimizer's goal is to find the optimal sequence, the canonical form. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Thank you very much! This was incredibly informative, and well-written. I'll definitely be trying to actually put this into practice in future, as this is quite good information to have,
Thank you for this. The straight-forward answer is definitely helpful, and simple.
It should be formatted properly, it shows fine on destkop..
I wasn't. I still don't have it working properly but I think I've made some progress. Here is what I'm doing to parse the command line string into a char* array: ``` char* args[MAXLINE]; // array to store argument strings char delimiters[4] = {' ', '&lt;', '&gt;', '|'}; char* token = strtok(str, delimiters); // token for the first arg /* Putting the args into an args array */ int stepindex = 0; while (token != NULL) { args[stepindex] = token; stepindex++; token = strtok(NULL, delimiters); // get the next token } args[stepindex] = NULL; ``` Here is the code for the fork and removing arguments: ``` int executeExternalCommand(char* args[1026]) { int pid = fork(); /** Forked processes **/ /* Child process */ if (pid == 0) { /* I/O Redirect */ int stepindex = 0; while (args[stepindex] != NULL) { if (strcmp(args[stepindex], "&lt;") == 0) { freopen(args[stepindex + 1], "r", stdin); } if (strcmp(args[stepindex], "&gt;") == 0) { int outfd = open(args[stepindex + 1], O_CREAT|O_RDWR, 0600); close(1); dup2(outfd, 1); args = removeToken(args, stepindex); args = removeToken(args, stepindex); } stepindex++; } execvp(args[0], args); // first parameter is the file descriptor (command), second is args array perror(args[0]); exit(127); /* Parent process */ } else if (pid &gt; 0) { int exitStatus; wait(&amp;exitStatus); if (exitStatus != -1) { return 127; } else { return exitStatus; } } else { perror("Fork failed!"); } return -1; } char** removeToken(char** arr, int index) { int i = index; while (arr[i] != NULL) { arr[i] = arr[i + 1]; i++; } arr[i] = NULL; return arr; } ```
C++ is off topic in this subrreddit. Please post C++ questions to /r/cpp_questions instead.
Oh I am sorry. Thanks for the comment!
I think you need "12345" and not 12345, as scanf is returning a string.
Code quality isn't just for the compiled code. Source code readability and making your intent clear is also important. Using const here lets others who want to use the function know that the parameter you pass won't be changed. That person could also be you in the future ;)
Are you sure you don't want the second byte in `0x00 0xff` to overflow as `0x01 0x00`? To do this without an `if`, load the bytes into a 16-bit integer (or larger), increment it, then store the individual bytes from the result.
Is there a reason you need to store these as a char array, rather than as a single 16-bit unsigned integer? If you use the latter, you can take advantage of bitmasks and right-shifts to get the individuals bytes.
My bad you are correct. If arr[0] = 0x00 and arr[1] = 0xFF, and I do arr[1]++, it should be arr[0] = 0x01 arr[1] = 0x00. as in... _uint16_t temp = arr[0] &lt;&lt; 8 || arr[1]; temp++; arr[0] = temp &lt;&lt; 8; arr[1] = temp; ?
I'd like to store it into a char array, so that I can set the end of another char array... so another approach could be... unsigned int x; otherArr[10]; otherArr[9] = x; otherArr[8] = x &lt;&lt; 8; ?
Yup, you've got the right idea. But make sure you use `|` (bitwise or).
It isn't, and it doesn't.
Get a real job and stop grifting
It does on all of my devices https://puu.sh/Dinto/52ee21db36.png
O. M. G.
By read only memory do you mean it actually ends up in the data section of the program with the globals, or it's just put on the stack and somehow flagged as read only?
For this purpose you have a division operator (/). Just try to divide 10 by 3, or 55 by 25 with this way and you'll see just what you want.
Would `const char * const str` be better?
Same ‚Äî but I *think* what you really mean here is that it's your policy that all *data pointed to by pointers* should be const unless otherwise required, yes? 1. This is a non-const (e.g., modifiable) pointer to const data (the data that p points to cannot be changed, but p *can* be changed): const char *p = &lt;pointer to const data&gt;; 2. This is a const pointer to modifiable data (p cannot be changed, but the data that p points to *can* be changed): char *const p = &lt;pointer to non-const data&gt;; 3. This is a const pointer to const data (neither p nor the data that p points to can be changed): const char *const p = &lt;pointer to const data&gt; The first one is the most common, in my experience.
If you dont wanna use the division operator you could subtract the result of your modulo operation with your base value. And afterwards you can divide 9 with 3 but why do you want to do that? With your second example it would look like this: 55 % 25 =5; 55-5=50; 50/25=2
Thanks!
Thanks for the help!
But why?
Or just write your code so that you don't modify any of the input even put that in a header comment.
Only if you want your pointer itself to be const rather than just what is pointed to...
How about stepping away from the keyboard and taking a course on arithmetic? Seriously, learn arithmetic before learning to program.
If you have a constant literal don't you want it to have a constant pointer?
There are plenty of situations where all your strings will be string literals but exactly which one you use is determined at run-time.
Do you have a take on why you'd want const data types versus #defines?
I think you need to ask your professor for clarity. If I was to guess, he wants you to replace the for loop with a while loop and exit the loop when the user uses the sentinel (i.e. q or Q) to end the input loop and print out the results.
Not a smidgen of C code to be found.
Yes! Try this explanation and see if it helps! https://www.reddit.com/r/Cplusplus/comments/b6kxvh/a_simple_question_about_memory/ejlgojj?utm_medium=android_app&amp;utm_source=share
No, because you may want to reassign the memory. char a[] = "UwU"; Looks something like a: .string "UwU" ;where a is readonly To access 2nd char: movzx eax, BYTE [a+1] ;stores 2nd byte of a in eax And char const * a = "UwU Looks like .L0: .string "UwU" ;where .L0 is readonly a: .L0 ;a is reassignable To access 2nd char: mov eax, DWORD [a] ;loads address of 1st byte (.L0) into eax movzx eax, BYTE [eax+1] ;stores 2nd byte of .L0 into eax
What the actual fuck. All you've done on Reddit is spam your Patreon, go away. No one is going to give you a handout for being a "computer science student."
In C const types are less likely to be optimized out so define can be more efficient.
That exact code, no. Absolutely not. Try it yourself.
Modern terminal emulators support arbitrary window sizes. You can figure out the window size using the `ioctl` call `TIOCGWINSZ` (though, in the future you might be able to use `tcgetwinsize()` for this purpose). Whenever the size of the window is updated, you receive a `SIGWINCH` giving you the ability to repaint the screen to the new dimensions.
Come on, no blog spam please. You know the rules.
It has 239 comments in /r/programming from a post yesterday, and for what it's worth it's not any site of mine.
The physical VT100 video memory was 3K plus an optional 1K for a few extra lines. 132 x 14/24 was all that would fit. Just being faithful to the spec.
Yeah, that is what I figured. But that's just it, if Nano uses the same specs, how does it bypass that limitation?
They are extending the original in their emulation. You are at the mercy of what the emulator allows. As /u/fuzxxl has suggested, you query the device to see what is supported.
I did it the as [/u/fuzxxl](https://www.reddit.com/u/fuzxxl) talked about. The tutorial did it the same way. Having the terminal filling up half of my screen I get 91 rows with 179 columns. which leads me back to the original question How does Nano do it in the same terminal when it seems to use the same escape sequences?
Awesome! Thanks!
It doesn't matter how many comments it has elsewhere. It's a fluff piece with an unhealthy amount of advertisements and if you look at the blog, it is full of such fluff pieces. That is called blog spam.
It surprises me that someone with such an inept knowledge of the innards of C (who doesn't need books or manuals) would fail to notice that their hosted implementation automatically links in other parts of the standard library... I suppose that's to be expected when we don't use a textbook to learn about the difference between a "freestanding implementation" and a "hosted implementation"... *usefulness &amp; reliability* of your response aside (despite it being terrible in general), I notice that you've got a big phat 0 points with this one... I suppose I could just downvote it and move on, eh? &gt;any clearer? What's with the rudeness? Or is it that you get a free pass in misinterpreting my motivations while I get none in misinterpreting yours? Who is to blame more... you for making the mistake in your words, or me for misinterpreting them, hmmm? ... and how does this go when the shoe is on the other foot? I hope you've learnt something.
I don't quite understand your question. Nano does basically the same thing you do (though it does uses `ncurses` as an extra layer of abstraction).
&gt;in the long run pedantic actually saves time Haha, this is a nice joke you tell... making a call forward here... you're going to claim this is a joke, right?
Which textbook are you reading? The reason I ask is because this doesn't seem like an exercise you would find in a reputable textbook, nor does it seem like the kind of question I see from people who read reputable textbooks...
My bad if the question is poorly worded. And mean while I tried to describe the problem better I found the problem. The problem was that my "renderer" truncated the long strings weirdly. However I just tried printing a string using VT100 that is 158 characters long. It would seem at least Konsole ignores that the spec says either 80 or 132 columns maximum.
&gt; an unhealthy amount of advertisements Oh? I wouldn't know.
I think it is often the reverse.
How so?
Actually, my concern is more what Stallman wrote about `-Wall`... When I implemented the -Wall option, I implemented every warning that anyone asked for (if it was possible). I implemented warnings that seemed useful, and warnings that seemed silly, deliberately without judging them, to produce a feature which is at the upper limit of strictness.
Yes, string literals (and potentially other static const data) could be placed in the data/executable segment of your program and (depending on the OS) be flagged as read-only when loaded. Trying to write to them might cause some kind of exception. "The stack" is somewhat of an abstraction, so potentially const "stack" values could also be truly read only, but I'm not aware of any compilers that actually do this. The current x86 architecture doesn't provide any efficient way to mark small areas of memory as non-writable.
In what way is the stack an abstraction? I haven't gotten that impression in my operating systems class
Allocation of the array is incorrect. There only needs to be 1 loop - so you do one allocation of `col` ints per row. At the moment, each row ends up with space for 7 ints (after doing 6 leaked allocations) fin &gt;&gt; gameArr[i][j]; This won't deal with the `,` that separate each number in the file
But what about when functions return const char*, like string::c_str()? The compiler headache comes when you mix const correct and incorrect code.
so trying to understand exactly what you're saying my problem lies in my declaration step? and should be formatted in declaration: for(int i = 0; i &lt; row; ++i) { gameArr[i] = new int[col]; } ?
Strictly speaking though if you know it will never be altered it doesn't really matter. So it's like a syntactical prophylactic.
After reformatting my array declaration to exactly what's specified above, it's outputting 64 0's
Yes, that's right. Now you need to fix the `&gt;&gt;`
do you mean in the declaration or what exactly are you referring to?
`&gt;&gt;` to an integer will fail when it sees a comma in the stream
so what do i use instead, this is all iv been taught in the class so far...
Stacks are the defacto standard in general purpose computing, but they aren't strictly necessary. Many basic embedded environments don't support stacks, for example. It also isn't necessarily a facility provided by the OS (unlike general memory allocation and page protection), but by the compiler or interpreter. The OS just gives the process a chunk of memory, and the process decides how to use it. That said, it is something of a semantic difference for most, unless you work in compilers or hardware.
Since you know the `,` is there you can skip it with `fin.ignore();`
Oh my God, thank you so much, I was just looking through the libraries for fstream
So the const refers to the underlying data, not the pointer address? Does this mean that the pointer address *could* be changed to something else?
I don't think `scanf` supports regex. You could use `regexec` if you are on a POSIX machine.
Say, we read a file with morse in it: You have to read the file and fill each char into a buffer, if you read a space or newline, you fill a '\\0' into the buffer and proof if the buffer == some\_morse\_string (with strcmp()). If so, printf the letter with the same index. &amp;#x200B; This will work if your letter and morse-array share the same index &amp;#x200B; Sorry, I don't find time to actually write something
`%2[ABCDEFGHIJKLMNOPQRSTUVWXYZ]` Note that this is not %s, it is %[.
&gt; It would seem at least Konsole ignores that the spec says either 80 or 132 columns maximum. Yes of course it does. The actual number of lines and columns depends on the terminal and you can't just assume that lines are 80 characters long. That's why the `TIOCGWINSZ` call exists in the first place.
[https://www.reddit.com/r/C\_Programming/comments/b9nq18/for\_loop\_in\_while\_loop\_printing\_an\_array/ek5z27x?utm\_source=share&amp;utm\_medium=web2x](https://www.reddit.com/r/C_Programming/comments/b9nq18/for_loop_in_while_loop_printing_an_array/ek5z27x?utm_source=share&amp;utm_medium=web2x) Here's an example in C &amp;#x200B; You are in a C subreddit and posting C++, I'd help but sadly I don't know the libraries
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
call forward ?
True, but as you said &gt;132 x 14/24 was all that would fit. Just being faithful to the spec. I would assume that would adhere to it. It does however make sense that it is ignored on modern implementations. Moral of the story is: don't assume shit XD
The spec does not say that a line break occurs at exactly 132 columns. It says that a line break occurs at the end of the line and that the terminal has two modes, one with an 80 column line and one with a 132 column line. Terminal emulators just add extra modes with more or less columns per line.
The stack and the heap can use the same physical memory cells
Alright sure just downvote without proving me wrong, that makes sense. Who needs facts when you can follow your feelings.
Back then, perhaps. Today, absolutely not. Stallman has not been involved in the development of gcc in over two decades.
You can statically link the library to your code. The relevant bits of the library will be incorporated into your executable. No need to manage dependencies or install libraries.
&gt; spending hours isolating the specific functions I need This might be easier than you think. The GSL code is quite readable. I‚Äôd give it a try
I would statically build the gsl library into your project and just distribute precompiled versions of it. It also isn't unusual for there to be external dependencies in a project, you could just have users install gsl. I would advise against copying the functions into your own code, that might make things complicated and messy
I think you might have the same problem asked here: https://stackoverflow.com/questions/13653287/how-do-i-statically-link-iconv-on-windows-using-msys
On many embedded platforms, support for recursion will impose a 2x or worse penalty on speed and code size, regardless of whether any functions are actually invoked recursively. Further, the Standard would allow implementations to generate code which malfunctions if it tries to call itself recursively, since main() need not support recursion, and any recursive call to anything other than main() would be nested at least two calls deep. An implementation that would reject programs containing recursive calls would seem more useful, especially if it would reject *any* program whose memory usage could not be statically verified, but the Standard would suggest that a program which contains recursive calls but never actually executes any nested function calls should execute with defined behavior, rather than refusing to execute because of the presence of recursive calls.
As long as your program is GPL itself (and you couldn't use GSL at all if it weren't,) then as others have said you can statically link the library in, that will only include the functions that you use (and the functions that those functions use, and so on).
The language spec doesn‚Äôt really promise where anything will be stored. While most compilers use the stack pointer features of modern CPUs, create an adjacent stack frame per function call, and store function-local variables in those frames, there‚Äôs no *requirement* to do any of that. Casting away `const` and modifying the underlying memory is undefined behavior regardless of where the variable is stored.
The cumulative distribution function of both t- and F-distribution can be calculated with [incomplete beta function](https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function), and [here](https://github.com/attractivechaos/klib/blob/f719aad5fa273424fab4b0d884d68375b7cc2520/kmath.c#L374) is an implementation of incomplete beta. It is not complicated.
You need to add an explicit library linkage with `-l`. At first I guessed that your autoconf script (`./configure`) doesn't know about MinGW-w64 on Win32. However, libiconv doesn't seem to be part of the standard MinGW-w64 install. I can see references to the `iconv_close` and `iconv_open` functions, but none are from a `libiconv*`. When you have it, you should be able to compile with `-liconv` or similar. But `./configure` will probably handle that for you, once you get it installed! A `.a` file is a static library, used when building static excutables. It's only used at compile-time. A `.dll` is Win32's version of a `.so` -- a dynamic library, linked into the executable at execution time by the loader `ld.so`.
Alright where here's an example of it. https://godbolt.org/z/8xYuwf The unused "a" stays inside the output in C but not C++. This should not happen with define since define is a literal. And to my knowledge, doesn't. I'v tested this stuff, as well as constexpr, out of curiosity before. I'm on my phone and the first example was already a pain in the ass to make.
If the functions are somewhat well contained, sometimes you can get the linker to exclude the unused parts. You might have to recompile the library special for this to work. People usually only bother with this for embedded systems. For instance I use avr-gcc, and it has a pretty good C library... But the linker discards functions you don't use. Don't use snprintf... It's not included in the final image. If you are in Linux, and since Linux is often a embedded is, and some people are obsessed with making things as small as possible, it's probably possible to compile things for x86/x64 in a way the linker throws out stuff.
You can build the functions yourself maybe ....
Thanks! I managed to find what was wrong.
Thanks! executing `make LDFLAGS='liconv'` worked!
Well, the OP seemed to indicate that they would like it to be easily *compiled*. Depending what they mean, this sounds like they'd prefer to avoid needing GSL at compile-time as well as run-time.
First, thanks for considering the details, like dependencies. What's your platform, and do you want to avoid dependencies at run-time only, or also at compile-time? Linux platforms are going to have `libgsl-dev` in repos, so it's *relatively* minor to install it. On Windows, I understand these things are much more cumbersome. If you're distributing mostly binaries for Win32, you can get away with cross-builds using Clang/LLVM or MinGW-w64. There are some potential disadvantages to stripping out the functions that you need. As a GNU project, not only is that code under GPL, but it's under the less-permissive GPLv3. Therefore your code needs to be compatible with GPLv3, and possibly your institution needs to approve something. Is it possible that you can find more-permissive implementations, that might also be less intertwined with their own library?
Static builds always exclude unused functions, no?
That might be true... I just haven't noticed that behavior. The super small executable size for AVR makes it very obvious.
`scanf` is usually not what you want to use in real life. For something like this, you could always `fgetc` or `getchar` in a loop.
You are probably getting a stack overflow. Try heap allocating your matrices and see if the problem goes away.
Thanks, I‚Äôll give that a go!
Yeah I guess I didn‚Äôt mean to be so specific. I‚Äôd either like to share source code that can be compiled by a standard C compiler (i.e. a compiler without GSL installed), or I could send a ready compiled executable
Yeah that doesn‚Äôt look too hard, thanks.
If possible, I'd find minimal implementations of the functions elsewhere, and "vendor them in" directly as one or a few individual files.
As I mentioned I don‚Äôt have the maths background to do that quickly and I‚Äôd quite like to push on with my project!
I‚Äôm on a windows PC using Cygwin which comes with GSL. It‚Äôs precisely because it was quite hard to set up that I want to make sure my code doesn‚Äôt require GSL for compilation (the people I‚Äôll be sharing it with will be on windows too). I‚Äôm not that familiar with GPL, as I understood the code is freely modifiable and I only intend on sharing my code with a couple of people (and not for any professional or academic reason) - I assumed that‚Äôs ok?
It's OK, but technically your code has to be under GPL as well, which may not be your intention. And then, anyone who gets a binary version is entitled to get a source-code version. For Windows, probably just compile it static 64-bit and you'll likely be happy with the result.
Good to know, thanks!
We need a bit more. Either: (1) give us the csv files so that we can run it and debug on our end, or (2) tell us where it segfaults using your favorite debugger (here is a link about how to do that: [https://www.open-mpi.org/faq/?category=debugging#serial-debuggers](https://www.open-mpi.org/faq/?category=debugging#serial-debuggers))
The CSV files are randomly generated matrices. Here is the n=500 ones: 1.csv: [https://ufile.io/71mzhhmu](https://ufile.io/71mzhhmu) 2.csv: [https://ufile.io/m2gu2ep0](https://ufile.io/m2gu2ep0)
You can grab the relevant file from the library and modify it such that it compiles without the rest of the library. However, make sure to keep the library's license in mind while doing so.
Ok. I was able to get it to run (though, after removing the code reading from the csv files). I was seeing the segmentation fault *inside* of MPI\_Init, which is very strange.
They don't necessarily have to, but they usually do outside of maybe debug builds. In, for example, Visual Studio, it's a linker switch - if you pass it the correct parameter, unused functions will happily reside in your final static build, because you said so
They've responded that they do not support C. Other languages, yes, but not C.
`a`, `b` and `c` are [VLA](https://en.wikipedia.org/wiki/Variable-length_array#C99)s, probably the source of your error - gcc allocates them on the stack. Dynamically allocate them with `malloc`. On a side note you're doing some operations on the first input file handle (`inOne`) when it should be the second input file (`inTwo`).
What code have you got for concatenating two strings?
See the man page for strncat. Function comes from the &lt;string.h&gt; library
you can always use sprintf(fullname,"%s %s %s",first,middle,last); but make sure fullname is big enough!
Or do something similar with snprintf, which does some size-checking for you.
Is this correct? Because I am still getting a segmentation fault. And now it won't work with any N value. #include &lt;stdio.h&gt; #include &lt;sys/time.h&gt; #include &lt;stdlib.h&gt; #include &lt;mpi.h&gt; struct timeval tm1, tm2; long long t; MPI_Status status; double **a; double **b; double **c; int main(int argc, char * argv[]) { //Get our matrix size from args int N = atoi(argv[1]); //Allocate memory for matrices a = malloc(N * sizeof(double *)); b = malloc(N * sizeof(double *)); c = malloc(N * sizeof(double *)); int z; for(z = 0; z &lt; N; z++) { a[z] = malloc(N * sizeof(double)); b[z] = malloc(N * sizeof(double)); c[z] = malloc(N * sizeof(double)); } int numtasks,rc,taskid,numworkers,source,dest,rows,offset,i,j,k; double a[N][N]; double b[N][N]; double c[N][N]; //Initialize MPI MPI_Init(&amp;argc, &amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;taskid); MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks); numworkers = numtasks-1; //Input our first matrix from file 1.csv FILE *inOne = fopen("1.csv", "r"); if (inOne){ size_t i, j; char buffer[4096], *ptr; //Skip the first line fgets(buffer, 100, inOne); for ( i = 0; fgets(buffer, sizeof buffer, inOne); ++i ) { for ( j = 0, ptr = buffer; j &lt; N; ++j, ++ptr) { a[i][j] = strtod(ptr, &amp;ptr); } } fclose(inOne); } //Input our second matrix from file 2.csv FILE *inTwo = fopen("2.csv", "r"); if (inTwo) { size_t i, j; char buffer[4096], *ptr; //Skip the first line fgets(buffer, 100, inTwo); for ( i = 0; fgets(buffer, sizeof buffer, inTwo); ++i ) { for ( j = 0, ptr = buffer; j &lt; N; ++j, ++ptr) { b[i][j] = strtod(ptr, &amp;ptr); } } fclose(inTwo); } //For master if (taskid == 0) { //Begin timing gettimeofday(&amp;tm1, NULL); offset = 0; //Get the rows per worker value int rows = (N + (numworkers - 1)) / numworkers; //Send data to workers for (dest=1; dest&lt;=numworkers; dest++) { MPI_Send(&amp;offset, 1, MPI_INT, dest, 1, MPI_COMM_WORLD); MPI_Send(&amp;rows, 1, MPI_INT, dest, 1, MPI_COMM_WORLD); MPI_Send(&amp;a[offset][0], rows*N, MPI_DOUBLE,dest,1, MPI_COMM_WORLD); MPI_Send(&amp;b, N*N, MPI_DOUBLE, dest, 1, MPI_COMM_WORLD); offset = offset + rows; } //Recieve the results from workers for (i=1; i&lt;=numworkers; i++) { source = i; MPI_Recv(&amp;offset, 1, MPI_INT, source, 2, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;rows, 1, MPI_INT, source, 2, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;c[offset][0], rows*N, MPI_DOUBLE, source, 2, MPI_COMM_WORLD, &amp;status); } //Get end timing gettimeofday(&amp;tm2, NULL); t = (tm2.tv_sec - tm1.tv_sec) * 1000000 + (tm2.tv_usec - tm1.tv_usec); //Output to file 3.csv FILE *fp; char comma[2]; fp = fopen("3.csv", "w"); fprintf(fp, "%d\n", N); for (i = 0; i&lt;N; i++) { sprintf(comma, "%s", ""); for (j = 0; j&lt;N; j++) { fprintf(fp, "%s%f",comma,c[i][j]); sprintf(comma, "%s", ",");; } fprintf(fp,"\n"); } fclose(fp); //Get the total time in microseconds and print printf("%lld microseconds occured\n",t); } //For workers if (taskid&gt;0){ //Recieve pieces of matrix to work on source = 0; MPI_Recv(&amp;offset, 1, MPI_INT, source, 1, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;rows, 1, MPI_INT, source, 1, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;a, rows*N, MPI_DOUBLE, source, 1, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;b, N*N, MPI_DOUBLE, source, 1, MPI_COMM_WORLD, &amp;status); //Multiply a &amp; b portions and send back to master for (k=0; k&lt;N; k++) for (i=0; i&lt;rows; i++) { c[i][k] = 0.0; for (j=0; j&lt;N; j++) c[i][k] = c[i][k] + a[i][j] * b[j][k]; } MPI_Send(&amp;offset, 1, MPI_INT, 0, 2, MPI_COMM_WORLD); MPI_Send(&amp;rows, 1, MPI_INT, 0, 2, MPI_COMM_WORLD); MPI_Send(&amp;c, rows*N, MPI_DOUBLE, 0, 2, MPI_COMM_WORLD); } //Free the memory for(z = 0; z &lt; N; z++){ free(a[z]); free(b[z]); free(c[z]); } free(a); free(b); free(c); MPI_Finalize(); return 0; }
Is this correct? Because I am still getting a segmentation fault. And now it won't work with any N value. #include &lt;stdio.h&gt; #include &lt;sys/time.h&gt; #include &lt;stdlib.h&gt; #include &lt;mpi.h&gt; struct timeval tm1, tm2; long long t; MPI_Status status; double **a; double **b; double **c; int main(int argc, char * argv[]) { //Get our matrix size from args int N = atoi(argv[1]); //Allocate memory for matrices a = malloc(N * sizeof(double *)); b = malloc(N * sizeof(double *)); c = malloc(N * sizeof(double *)); int z; for(z = 0; z &lt; N; z++) { a[z] = malloc(N * sizeof(double)); b[z] = malloc(N * sizeof(double)); c[z] = malloc(N * sizeof(double)); } int numtasks,rc,taskid,numworkers,source,dest,rows,offset,i,j,k; double a[N][N]; double b[N][N]; double c[N][N]; //Initialize MPI MPI_Init(&amp;argc, &amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;taskid); MPI_Comm_size(MPI_COMM_WORLD, &amp;numtasks); numworkers = numtasks-1; //Input our first matrix from file 1.csv FILE *inOne = fopen("1.csv", "r"); if (inOne){ size_t i, j; char buffer[4096], *ptr; //Skip the first line fgets(buffer, 100, inOne); for ( i = 0; fgets(buffer, sizeof buffer, inOne); ++i ) { for ( j = 0, ptr = buffer; j &lt; N; ++j, ++ptr) { a[i][j] = strtod(ptr, &amp;ptr); } } fclose(inOne); } //Input our second matrix from file 2.csv FILE *inTwo = fopen("2.csv", "r"); if (inTwo) { size_t i, j; char buffer[4096], *ptr; //Skip the first line fgets(buffer, 100, inTwo); for ( i = 0; fgets(buffer, sizeof buffer, inTwo); ++i ) { for ( j = 0, ptr = buffer; j &lt; N; ++j, ++ptr) { b[i][j] = strtod(ptr, &amp;ptr); } } fclose(inTwo); } //For master if (taskid == 0) { //Begin timing gettimeofday(&amp;tm1, NULL); offset = 0; //Get the rows per worker value int rows = (N + (numworkers - 1)) / numworkers; //Send data to workers for (dest=1; dest&lt;=numworkers; dest++) { MPI_Send(&amp;offset, 1, MPI_INT, dest, 1, MPI_COMM_WORLD); MPI_Send(&amp;rows, 1, MPI_INT, dest, 1, MPI_COMM_WORLD); MPI_Send(&amp;a[offset][0], rows*N, MPI_DOUBLE,dest,1, MPI_COMM_WORLD); MPI_Send(&amp;b, N*N, MPI_DOUBLE, dest, 1, MPI_COMM_WORLD); offset = offset + rows; } //Recieve the results from workers for (i=1; i&lt;=numworkers; i++) { source = i; MPI_Recv(&amp;offset, 1, MPI_INT, source, 2, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;rows, 1, MPI_INT, source, 2, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;c[offset][0], rows*N, MPI_DOUBLE, source, 2, MPI_COMM_WORLD, &amp;status); } //Get end timing gettimeofday(&amp;tm2, NULL); t = (tm2.tv_sec - tm1.tv_sec) * 1000000 + (tm2.tv_usec - tm1.tv_usec); //Output to file 3.csv FILE *fp; char comma[2]; fp = fopen("3.csv", "w"); fprintf(fp, "%d\n", N); for (i = 0; i&lt;N; i++) { sprintf(comma, "%s", ""); for (j = 0; j&lt;N; j++) { fprintf(fp, "%s%f",comma,c[i][j]); sprintf(comma, "%s", ",");; } fprintf(fp,"\n"); } fclose(fp); //Get the total time in microseconds and print printf("%lld microseconds occured\n",t); } //For workers if (taskid&gt;0){ //Recieve pieces of matrix to work on source = 0; MPI_Recv(&amp;offset, 1, MPI_INT, source, 1, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;rows, 1, MPI_INT, source, 1, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;a, rows*N, MPI_DOUBLE, source, 1, MPI_COMM_WORLD, &amp;status); MPI_Recv(&amp;b, N*N, MPI_DOUBLE, source, 1, MPI_COMM_WORLD, &amp;status); //Multiply a &amp; b portions and send back to master for (k=0; k&lt;N; k++) for (i=0; i&lt;rows; i++) { c[i][k] = 0.0; for (j=0; j&lt;N; j++) c[i][k] = c[i][k] + a[i][j] * b[j][k]; } MPI_Send(&amp;offset, 1, MPI_INT, 0, 2, MPI_COMM_WORLD); MPI_Send(&amp;rows, 1, MPI_INT, 0, 2, MPI_COMM_WORLD); MPI_Send(&amp;c, rows*N, MPI_DOUBLE, 0, 2, MPI_COMM_WORLD); } //Free the memory for(z = 0; z &lt; N; z++){ free(a[z]); free(b[z]); free(c[z]); } free(a); free(b); free(c); MPI_Finalize(); return 0; }
No. double *a = malloc(N * N * sizeof(double)); Not sure why you think you need double pointer indirection and a second conflicting local declaration of your array. It would help to under heap versus stack storage, pointers, and arrays. I would study that stuff in a relevant C language primer.
 double a[N][N]; double b[N][N]; double c[N][N]; This was kept in by mistake, I took it out. Isn't this: double *a = malloc(N * N * sizeof(double)); A single dimensional array? When I changed my code for this I get compilation errors.
I just came across this, I'm not sure if it's great, but it's free, and from the looks of it, it seems quite nice. The comments say that it uses an old version of gtk, but I suppose that's not a huge problem for an intro. It'd be cool if any C pros could share their opinion on this book.
You can use a contiguous chunk of memory as a two dimensional array. Just compute the index. I haven't look at the rest of the code, nor do I know what your API expects.
‚ÄúThat got a compiler, off you go!‚Äù
Are you the author? I want to do a chapter on streaming WebRTC to and from C.
Thankyou im working on GTK C for HMI project, it will help me
No, sorry. I just came across it on google.
I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well? I‚Äôm interested in learning C++. I don‚Äôt really have knowledge or experience in my background regarding programming. Other than some YouTube videos (that I have already started to follow along with), what is out there that is good to help me self-learn C++ until I can get into some college classes? Also, anyone with dyslexia (like me) and knows C++ have any advice with learning this as well?
Why the downvote? Ever heard of getting the word out? I'm amplifying your message so it can get out there
I didn‚Äôt down vote...
 static double a[N][N]; double (*a)[N] = malloc(N * N * sizeof double); Other options, if it's the stack problem.
c != c++. literally any book/tutorial on c++ will teach you the basics and beyond.
I remembered this from something I read a long time ago. Fortunately there's still a web site: http://numerical.recipes Maybe the books can provide the information you need.
Without trying the code, shouldn't you ask for the value of count before entering the loop? Also, it seems contradictory to be asking for both the value of count _and_ a sentinel value.
K&amp;R C - https://en.m.wikipedia.org/wiki/The_C_Programming_Language
**The C Programming Language** The C Programming Language (sometimes termed K&amp;R, after its authors' initials) is a computer programming book written by Brian Kernighan and Dennis Ritchie, the latter of whom originally designed and implemented the language, as well as co-designed the Unix operating system with which development of the language was closely intertwined. The book was central to the development and popularization of the C programming language and is still widely read and used today. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Ask in /r/cpp_questions. This subreddit is about C, not C++.
It‚Äôs not what‚Äôs wrong, but I‚Äôd strongly recommend using `strtoul` or `strtoull` to get `N` from `argv`‚Äîif you type something slightly wrong `atoi` will return nonsense, and `int` is a very bad type for a size anyway. You should also bounds-check `N` so that a large value doesn‚Äôt confuse the royal hell out of things if it overflows `size_t`. #include &lt;stddef.h&gt; #include &lt;stdint.h&gt; #include &lt;limits.h&gt; #include &lt;math.h&gt; ‚Ä¶ size_t n; if(!argv[1]) { fputs("error: too few arguments\n", stderr); return 1; } do { // dummy scope to contain intermediates #ifdef __GNUC__ __label__ invalid_dimension; #endif char *p; #ifdef ULLONG_MAX # define T unsigned long long # define FMT "%ull" # define strtoT strtoull #else # define T unsigned long # define FMT "%ul" # define strtoT strtoul #endif T nval, nmax; errno = 0; if(!*argv[1]) goto invalid_dimension; nval = strtoT(argv[1], *p, 10); if(*p || (errno &amp;&amp; errno != ERANGE)) goto invalid_dimension; nmax = sqrt(SIZE_MAX / sizeof(double); if(errno || nval &gt; nmax) { fprintf(stderr, "error: dimension outside allowable range [0," FMT "]: %s\n", (T)nmax, argv[1]); return 1; } n = nval; break; invalid_dimension: fputs("error: invalid dimension argument\n", stderr); return 1; #undef strtoT #undef FMT #undef T } while(0); So that gets you a clean `n` that you can square safely, and whose square you can then multiply by `sizeof(double)` safely. For allocation &amp; access, you can either do what ahminus said, or you can (in ‚â•C99 because VLA, not ‚â§C89 or C++) use a pointer-to-array type like this: #define matrix (*matrix_p) double matrix[N][N] = malloc(sizeof(matrix)); if(!matrix_p) { fputs("error: insufficient memory\n", stderr); for(;;) abort(); } Then you can use `matrix[i][j]` to access elements of the array pseudo-normally. `#undef array` it before the closing `}` of the function body; no reason to leave it lying around cluttering up the namespace and ruining any later code that uses the `array` identifier. Alternatively, you can wrap the matrix up in a `struct`: enum {A, B, C, NR_MATS}; struct matrix { double data[N][N]; } *matrices[NR_MATS]; unsigned i; for(i=0; i &lt; NR_MATS; i++) { matrices[i] = malloc(sizeof(*matrices[i])); if(!matrices[i]) { while(--i) free(matrices[i]); fputs("error: insufficient memory\n", stderr); for(;;) abort() } } matrices[A].data[1][2] = 0; // or even #define mat(name) (matrices[(name)].data) mat(A)[1][2] = 0; You can simplify alloc/release by allocating all `NR_MATS` matrices in one big block (after bounds-checking `N` against `nmax / NR_MATS`)‚Äî struct matrix {‚Ä¶} (*matrices)[NR_MATS]; matrices = malloc(sizeof(*matrices)); ‚Ä¶ ‚Äîbut technically it‚Äôs possible for the C runtime to fail on the larger alloc when it would‚Äôve succeeded with three smaller ones; e.g., under x86 + real mode + large memory model `SIZE_MAX` was 64 KiB but the total amount of RAM you had access to was ~640 KiB, possibly +64‚Äì128 KiB for HMA and optional expansion-slot memory. If you need to allocate/free in high-performance stuff, you can choose a stack-based allocation if it fits and dynamic allocation otherwise; e.g., use a forwarder function that passes array pointers into a callback. enum {A, B, C, NR_MATS}; typedef uintmax_t callback_ft(void *p, size_t n, double (*const mats[static NR_MATS])[n][n]); uintmax_t call_with_matrices(size_t n, callback_ft *callback, const volatile void *callback_p);
Since GSL is under the GPL, not the weaker LGPL, your program must be distributed under the GPL regardless. Or, to be precise: *if* you distribute copies of your program, as long as it uses GSL, it must be under the terms of the GPL.
Ok.. what‚Äôs the difference?
Yes. But there may be better ways to do this. What is that array supposed to represent?
Apologies, my lame ass posted it before putting up my code. Code: \#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; &amp;#x200B; int main (int argc, char \*argv\[\]) { &amp;#x200B; int ch = getchar(); while (ch != EOF) { int alt\_ch; if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { alt\_ch = argv\[1\]\[ch-'0'\]; } else { alt\_ch = ch; } putchar(alt\_ch); ch = getchar(); } return 0; } &amp;#x200B; This code actually take in an input of 10 through command line and then turns the numerics to that letter.
Just put all the code inside main except the return in void myFunction(char* argv[]) { } Then add myFunction(argv) in main. Is this all your asking? You should try read up on how to write functions.
They are two different languages.
I thought that C++ was built off of C and had more functions...?
C and C++ diverged 30 years ago. They share a common subset but are different languages.
Please edit your post and insert the *complete* code, properly indented, with four additional spaces at the beginning of each line so reddit formats it as code.
Pointers are not a low-level feature. In fact, they are a high-level abstraction!
I guess today is my lucky day because just yesterday I gave up finally and felt frustrated. I tried gui with c on windows by studying from petzold's book and even the hello world window takes around 50 lines of code and win32 api has really weird variables. It felt a bit like a different language. The book was written for windows 98 and after compiling the code it didnt work on my windows 10 pc. I guess I ll try this book now. Thanks
I remember writing c++ gui over 20 years ago, wow was it hard work, I imagine this is about the same. Just don't, this is like trying to use a table spoon to dig road ditches. A table spoon is excellent for serving up dinner but..
if you have to write a GUI in C++, I advise to use the Qt framework. it is very well documented and easy to work with
This. It‚Äôs cross platform, and very stable / well documented. By far the best option IMO
1. yes 2. depends on the library, but generally yes
Hi, to answer your question : 1- Yes, you have access to everything to could do in Python or Java, but it would probably not be as easy. 2- There are some network libraries written for C out there, but if you want to specialise in C maybe you could try to work with your operating system's standard network interface so you can familiarise yourself with low level network programming.
So I have to learn Python first?
&gt;library which library is?
[Here](https://stackoverflow.com/q/118945) is a Stackoverflow answer listing a bunch of C and C++ network libraries you may choose from.
I don't think so, you can learn everything from C.
This looks interesting. I didn't know GUI programming was possible in C.
I think I still have my copy of "C For Yourself" around here somewhere!
I'd help you but its not formatted. Please post to github/pastebin or format it
@FUZxxl actually, give it a try, seriously, Zig is the language that should have been there before Go, Rust and the other languages announced in the past 10 years. Coding in Zig is such nice experience. &amp;#x200B; There is no arrogance, just attend one of Andrew's (Zig creator) live coding sessions and follow the GitHub issues and you will see how humble and open minded Andrew is, he listens, consider suggestions and discuss them openly.
Of course it's possible! It's a complete programming language, I believe you can pretty much do anything that you can do with other languages. It might not be as easy as other higher-level languages, but you can still use it for the same purposes. I'm only just interested in C at the moment, so I'm definitely no expert, but I'm pretty sure anything you can do with C++, and most other languages, you can do with C. The python interpreter was written in C, the early quake and doom games were written in C. Rollercoaster tycoon was written in damn x86 assembly language, with a tiny bit of C code! If you can make stuff like operating systems with C, then you can make a GUI with C. (Sorry if this came off as me being pissed off, I'm not at all. I understand the way I've worded things, it sounds like I'm shouting at you a bit, sorry.)
Hahaha it's no problem. You actually came off as being excited :P. Last complicated thing I tried to do with C is just to port my C code on Linux to Windows. I struggled a lot though and eventually just ditched it for being too difficult and too many compilation errors occurred because Windows didn't have Linux libraries or something.
 char a, b, c ,d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s , t, u, v, w, x, y, z; char submessage[100]; char alphabet[26] = {a, b, c ,d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s , t, u, v, w, x, y, z}; char cipher_alphabet[26] = {q,w,e,r,t,y,u,i,o,p,a,s,d,f,g,h,j,k,l,z,x,c,v,b,n,m}; &amp;#x200B; You declared many char variables and you put them into "alphabet" array. Same in the cipher\_alphabet. But you didn't put any values in this variables. You can assign values to char variables like: char a = 'a'; or you can skip this and put chars into alphabet array: char alphabet\[26\] = {'a', 'b', 'c' ,'d', 'e', 'f','g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's' , 't', 'u', 'v', 'w', 'x', 'y', 'z'}; Later you print alphabet array (?), but it don't print anything because there is nothing in alphabet. &amp;#x200B; switch(scommand) { case 1: //Encryption case for(count = 0; (count &lt; 50); count++) { alphabet[count] = cipher_alphabet[count]; submessage[count] = alphabet[count]; printf("Encrypted text: %s", alphabet); ] break; &amp;#x200B; You could make this with "switch" but simple "if" would be better I think. "Switch" is better when you have multiple choices (in your program you have just two), like 10+. Secondly where do you have decryption part? &amp;#x200B; for(count = 0; (count &lt; 50); count++) { alphabet[count] = cipher_alphabet[count]; submessage[count] = alphabet[count]; printf("Encrypted text: %s", alphabet);] &amp;#x200B; And now this. I have absolute no idea what you trying to do here, but this is what i can understand: 1) You put value from cipher\_alphabet array with index "count" to alphabet array with the same index. 2) Then you put value from alphabet array (which you change in previous line) to summessage with index "count". 3) Next You try print each time a alphabet array. Buy probably you tried to print encrypted submessage. &amp;#x200B; So you basicly every 50 time you put value from cipher\_alphabet to alphabet and then to submessage. Even that you get out of alphabet and cipher\_alphabet arrays. Example: your loop ends when count &lt; 50, so what happens when "count" have value 32? alphabet[32] = cipher_alphabet[32]; You take value from cipher\_alphabet\[32\] but cipher\_alphabet is only have 26 length. Then you put it to alphabet\[32\] which is, same as previous array, only have 26 length.
What type of program was it? Just a console program? If you're not making GUI's in C, I don't know what problems you would have. Were you maybe using curses, or ncurses? I'm pretty sure that's linux exclusive.
It was an encryption function that I think was exclusive to Linux
(Just add a smiley face and then it won‚Äôt sound like you‚Äôre shouting. This is why we have emoji üôÇ)
Buy an Arduino, they are a great way to learn low-level hardware programming (i/o, device drivers, interrupt handling, context switching, hardware timers, etc). There's no book associated with it, just a website and all of the included source code.
Last time i had issues and didn't understand, i just clicked solution to see the answer and then kept working with it to see how i could get there and eventually I did. This one however, for whatever reason, will not allow me to see the solution, so I am not actually able to see what i'm doing wrong by putting it directly in front of me instead of telling me gibberish that i don't have the knowledge to understand yet.
What‚Äôs the problem? From the snippet I see `int grades[3];` is not defined. Add the definition, set it to zero, and it should work.
`TODO: define the grades variable` You need to define an array called grades.
Pthreads w/ locks are pretty low level. If you want to ear under that, look up uthreads on github. Developed by a prof at UBC iirc. Someone‚Äôs posted past assignments there I‚Äôm sure.
A lot of languages are "built off of C." For example, Python's CPython interpretter was written in C. If we restrict ourselves to languages which tried to maintain source compatibility with C, that leaves only a few candidates like: Objective C, C++, Cyclone, D, etc. However not all valid C programs can compile as C++ so it has lost its backwards compatibility in this regard. For example, the line "int \*foo = malloc(2)" is valid and idiomatic C, but an invalid construct in C++. If anything, [Objective C is a truer superset of C](https://stackoverflow.com/questions/19366134/what-does-objective-c-is-a-superset-of-c-more-strictly-than-c-mean-exactly).
so you are using linux, it is written in C, and so are many of Desktop Environments like GNOME, XFCE, LXDE with the GTK library
I'm not sure then, sorry.
exactly what way would i type that out? I've been messing this this forever now. I was pretty serious when i said i was a moron
You can do it relatively easy in win32api even in assembly but it's a giant pain in the ass any way you do it.
I can maybe try it out if I have the time
You don't even need to do maths to get the answer, but if you don't understand: You have `(80 + x + 90)/3 = 85`. Solve for `x` and you get `x = 3*85-80-90 = 85`
GTK is easy for a native C programmer. If your underlying code base is C then it would most likely be the best choice. I am curious though, in your analogy what are the "road ditches" and what is your alternative to the "table spoon". I know there's some java thing people talk about, but I don't think I would consider that for embedded applications, industrial control, vehicle control, etc. There are different tools for different types of ditches.
Tried that. I know the basic math of it. Its the language i'm not getting. This is what it tells me once i put that in. prog.c: In function ‚Äòmain‚Äô: prog.c:7:3: error: ‚Äògrades‚Äô undeclared (first use in this function) grades[0] = 80; ^~~~~~ prog.c:7:3: note: each undeclared identifier is reported only once for each function it appears in
You never actually declare or instantiate the variable `grades`, you only tried to assign values to members of the array. Unlike languages like Python, C requires you to define a variable, and arrays must have memory allocated to them. You have two options. You can do `int grades[3];` at the first TODO line, or you can do `int *grades = malloc(3*sizeof(int));` at the same spot. If you haven't covered pointers at all, I would advise going with the first option. After that, you just have to figure out what grades[1] is supposed to be.
In that case I'd recommend fasm if you go the pure asm route. include 'macro/import32.inc' .section 'idata' readable import data Library kernel32, 'kernel32.dll' Import kernel32, YOUR_NAME, 'API_NAME',... Is all you need to link with and use a dll. With C and C++ just use windows.h But imo doing it in C/++ is even more complicated than asm.
The clue is in the error, the variable ‚Äògrades‚Äô is undefined. Put this above the main calculation: Int grades[10];
That tells you that you have not declared `grades`. In C, each variable must be declared before you use it.
The Win32 API has not changed very much at all, so Petzold's book should work fine. You might find this video ([Handmade Hero Day 002 - Opening a Win32 Window](https://youtu.be/4ROiWonnWGk?t=36)) very helpful.
Oh ok, I was using the example it gave me and was putting int numbers\[10\]; because i thought it was having to pick out from a range of ten numbers from because the answer lied within 80-90. Oh god it worked, thank you so much. I definitely still have a lot to learn. I appreciate it, thank you.
I'd definitely have a shot at it thank you
Ok, thank you, I kept putting int numbers\[10\]; because my understanding of what that line meant was.....not accurate. I think i was looking at that as an actual value.
It seems like the tutorial you're following doesn't do a good job of explaining the actual syntax. You should look at [TutorialsPoint](https://www.tutorialspoint.com/cprogramming/) for their C programming tutorial, if something doesn't make sense look there first.
Not knowing anything about the field, aren't you getting a lot of different NaNs from the random source and turning them all to default NaN with cos ?
You get garbage out because you're putting garbage in. Not every 64-bit string is a valid `double`. Try reading a `long long` instead.
No problem, what that‚Äôs actually doing is declaring that ‚Äúgrades‚Äù is an array of integers. In C, all variables must be defined first as it‚Äôs a strictly typed language.
Mhm. The thing is, I'm concerned about using integers only. Wouldn't that drastically reduce the number of possible outputs?
Just curious, how does the Qt licensing affect your work? The choice between GPL and a commercial license is not particularly enticing to me.
Since I am not a professional developer, GPL doesn't affect me at all. I licence my public projects under it
Advanced Programming in the Unix Environment is a fantastic old book that might meet your needs
As others have answered: 1) Yes. 2) Yes, but at least in Unix, 95% of all network programming will use the functions `getaddrinfo()`, `socket()`, `bind()`, `listen()`, `accept()`, `connect()`, `recvfrom()`, `sendto()`, `shutdown()` and `close()`. There are other useful functions useful for network programming (such as `read()`, `write()`, and one of `select()`, `poll()`, `epoll()` or `kqueue()`, depending upon the particular Unix variation you are using).
You mean LGPL. It should only affect you if you modify and redistribute Qt itself. If you just use it you should have no issues.
[Nope](https://math.stackexchange.com/questions/448883/proving-or-disproving-that-the-sine-and-cosine-of-integers-are-always-unique). On a scale as large as 64 bits you shouldn't have much of a problem, but you may wish to verify a lack of bias using the MC pi computation you listed above. Hope that helps.
OK, thank you. Ya my issue really is understanding what its telling me when there is an error. but i feel thats something that gets better with experience. I'm glad i was able to see what i was doing wrong. I was trying everything, and each time i tried i got even farther and farther from the correct answer. I do wish it was more thorough in explaining stuff to me. I am going back to review everything i've covered so far to try and get a better grasp of what its saying so i can hopefully avoid rookie mistakes like that but I imagine i'll encounter more issues before the day is done, but that's the process i guess. Thanks for the help!
Ya, when it was telling me it was undefined i thought it was referring to the actual values, but as i had actually typed them out i was confused and didn't quite understand what it meant. I am going to try tutorialspoint as i was told it would go into better detail and im hoping i can avoid getting stuck on pebble like its a boulder. I am definitely going to be more thorough and take my time. I've only just started and i can already tell patience and thoroughness is key here. Hopefully, I can stick it out though. Thanks for the help! appreciate it.
&gt; I'd like to store it into a char array, so that I can set the end of another char array... You can also use bit math to set arbitrary bits/byte offsets. int main(void) { uint16_t x = 0; x |= ((uint16_t)1) &lt;&lt; 8; printf("%d\n", x); } That'll give you 256. (IE `{ 0x01, 0x00 }` on a little endian CPU
There are more valid 64-bit integers than valid 64-bit floating-point numbers.
Pthreads is about as low as you should usually go, and *Programming with POSIX Threads* (Butenhof) is a solid overview. To learn a lot about synchronization, read [*The Little Book of Semaphores*](https://greenteapress.com/wp/semaphores/). If you want to go lower than that on Linux, you can [create threads using clone(2)](https://nullprogram.com/blog/2015/05/15/). It's messy, and here be dragons.
Please indent it with spaces so it's formatted correctly.
I‚Äôm sorry I didn‚Äôt specify but I meant as low as the fork() function.
One thing you'll learn as you go is that a lot of programming is simply looking up error messages on Google. Sometimes you'll find the answer instantly, sometimes you'll find nothing at all, but no matter what you'll have to search for a solution at some point. Don't give up, you're just starting out but most of us have been there at some point or another.
Don't `read(2)` every time you need a number. Instead, use it to seed a quality PRNG like [xoshiro256\*\*](http://xoshiro.di.unimi.it/) or [PCG](http://www.pcg-random.org/download.html), then draw the rest of your numbers from the PRNG. When you need to generate a uniform random float: unsigned long long rand64(void); // your PRNG double uniform(void) { return ldexp(rand64() &amp; ((1ULL &lt;&lt; 53) - 1), -53); }
I just checked out the Little book of Semaphores and man it‚Äôs just what I needed, thank you! Oh and what I meant by low was using fork(), but nonetheless your second link was an interesting read.
Yo, study other programming languages. Being good at any programming is going to be hard if you limit yourself like that before you can even answer those questions yourself.
Oh, for some reason I thought it was GPL. That's good to know
I was more referring to the viral nature of GPL which prevents it from being used in a lot of open-source software. (for example, in a BSD licensed project) But another user clarified that Qt is LGPL, so I was wrong, it actually doesn't have that problem.
Never heard of xoshiro. It seems it fits all of my needs and more. Thanks a lot !
Win32 always sucked. I was horrified by it when I came to Windows from RISC OS. I was relieved to see the back of it when I could finally completely remove it from my life for GNU/Linux. Only thing is, I will forever know it now.... Though I deny it when I can. ;-)
If it makes you feel better, some addon modules are GPL.
GTK is easy for Python and others too. C interfaces can be imported to all languages and GTK has a neat object retrospective system aiding being sucked into object languages. It is popular beyond the C world for good reason.
This is not strictly accurate. If you are using QT on an embedded device you have to jump through a few hoops to adhere to LGPL.
You mean running bare metal without an OS? Is that because in that case you're statically linking it into your application?
Yes. Even with an OS you would have to provide an upgrade path for QT.
Thank you for explaining that! That helps me understand more.
Just finished one for my senior design project. If you have any questions let me know. I can also link the repo if you are interested.
The only non-biased RNG you can be sure of are [Cryptographically secure pseudorandom number generator's](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator). They follow [Strict Avalanche Criterion](https://en.wikipedia.org/wiki/Avalanche_effect) and have been heavily tested to ensure each bit appears with a 50/50 chance over a massive (universe ending) period. For my sims &amp; models I use SHA2-512 hashing in counter mode. Depending on how many bits you'll need, you can hash a 64-bit unsigned long 2^64 times for 2^73 bits before period wrapping. Or a 128-bit number for infinite :) Basically ... hash the number 0, then the number 1, then the number 2, etc etc The output of each hash is 50/50 random with no patterns to be found or detected.
I haven't read Petzold's book but i remember him mentioning in some article that he was told that "hello world is too long" often and his reasoning was that while he could just write `MessageBox(NULL, "Hello, World", "Hello", MB_OK);` (which together with the windows include and winmain would be around 4-5 lines of code in total) and technically be correct that this is a hello world application for Windows, that wouldn't be helpful to anyone wishing to learn Windows programming and his "Hello World" program is actually trying to show all the details that go into making a Windows program without taking any shortcuts. BTW standard C Win32 code should compile with any C compiler that targets Windows 95 or later, the API is fully backwards compatible both on binary and source level, so i'm guessing that your compilers might be misconfigured or something. What code did you try and didn't compile? Also note that the Win32 API is kinda low level in that it gives you only the barebones functionality for making a GUI and in general most people build some mini framework or some sort of 'scaffolding' around it. It isn't necessary, but for any project of any moderate size you'd need it. And btw, Gtk2 isn't milk and honey either, there are tons of warts with it and often it can be even wordier than Win32 (e.g. try to make a list box with a few predefined items in it) especially when you want to make your own widgets (e.g. try to measure and draw a line text for your custom control).
* Lesson 1: Write a C compiler. * Lesson 2: Teach your C to deal with Unicode. * Lesson 3: Create the graphical user interface from scratch.
but first, you must invent the universe
Consider putting the read into it's own function, and the cos math stuff into its own pure function. That way you can test each. part independently. As someone a else pointed out, you're problem is your making invalid doubles.
sorry about the formatting hopefully its fixed now. Im gathering that this approach is pretty stupid then. Could i use a 'strchr' function inside a loop to say search for B and replace it with K and so on for the string message that i want to encrypt? And how would i go about doing that because at the moment i can only manage to change 1 specific letter, i don't know how to do it multiple times for different letters.
Do you know whether it covers SDL?
Why not have both? Here are the PDFs, for free![Algorithms in C](booksdl.org/get.php?md5=C4BCC4380A33DF1330ED60FFEFB7B1BA) [Data Structres: An Advanced Approach Using C](http://booksdl.org/get.php?md5=5bd9dcd830da6257f4b401d8405bac8e)
I'm pretty sure it just uses gtk2. The cs50 YouTube channel has a tutorial for the basics of SDL with c, which is probably decent.
Fyi: https://www.pcjs.org/pubs/pc/reference/microsoft/mspl13/c/c4yrself/
For molecular dynamics simulations it is more than sufficient to use an off the shelf implementation of any common PRNG. Most libraries have a long long or a `uint64_t` function that will be suitable. Generally, for molecular dynamics the rng is the least of your worries when it comes to errors.
There's just too many good C books. Data Structures is written in K&amp;R, but it looks more intentional in it's choice to use C.
Not all heros wear capes.
Grep for it in the Linux source
Gotos should be used only to create organized control flow structures that aren't already part of the C language. Examples include: breaking out of a double-nested loop (C doesn't have labeled breaks), and error laddering (C doesn't have exceptions or Go-like defer). If you look at the Linux kernel source code, you'll see judicious use of goto.
Avoid at all costs unless you absolutely must.
&gt; cs50 https://www.youtube.com/watch?v=yFLa3ln16w0 Thank you!
&gt;http://booksdl.org brilliant site - many thanks for posting
it has its uses
&gt; Back then, perhaps. Today, absolutely not. [Even today](https://ideone.com/2SQFqJ), some of these switches actually prevent valid C code from compiling... if you require further evidence, feel free to see [ISO 9899:201x/6.5.14p1](http://port70.net/~nsz/c/c11/n1570.html#6.5.14p1). In the future, I'd appreciate if you'd refrain from making authoritative statements regarding a programming language if you've not yet familiarised yourself well enough to write a standard-compliant compiler...
I use goto to jump to cleanup parts (freeing stuff) at the end of a function if I want to abort what the function does
Unless you are programming operating systems or the like avoid them like the plague.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Don't do this.
Ken Thompson, says: ‚ÄúIf you want to go somewhere, goto is the best way to get there.‚Äù And that's the advice I can give you, too. You might want to read [this article](http://fuz.su/~fuz/spwgts.pdf).
There was a famous whitepaper called "goto considered harmful" which basically killed it's reputation(rightfully). Just Googled it and remembered it was Dijkstra. Link: https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf It is also the origin of the "X considered harmful" meme amongst software engineeers. https://en.wikipedia.org/wiki/Considered_harmful
**Considered harmful** Considered harmful is a part of a phrasal template used in the titles of at least 65 critical essays in computer science and related disciplines. Its use in this context originated in 1968 with Edsger Dijkstra's letter "Go To Statement Considered Harmful". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Another way to say this is that goto is okay in forward-facing uses only. For error handling gotos that usually means a label shortly before the return statement, where you can clean up any resources assigned in that function. Don't use gotos to jump back to some earlier part of the function, instead use for or while loops to better express why you'd loop, and to be clear to readers where exactly the start and ends of the looped bit are. Using gotos at random is the cause of speghetti code and the reason for goto being so maligned in some circles. But just like any other tool, use it correctly and you won't shoot yourself in the foot.
Not a good idea. Type punning via unions is undefined behaviour. Why not just using `memcpy()`?
Goto can be very useful. Some people just follow the "rules" by the letter and avoid it under all circumstances because they were told to. But once you understand why the rules exist in the first place, you start to see when it's useful to break them. One idiom I like is using it to implement a sort of "else" for a loop. Like this: // find x in array a for(i = 0; i &lt; alen; i++) if(a[i] == x) goto found; panic("not found"); found: ; // do something with a[i]
Yes and no. It's discouraged because it's easily abused, but in two cases it's really the only thing for the job. The first is a multilevel break. C doesn't have a multilevel break statement, so to break out of a nested loop or switch statement, you either have to have convoluted logic and extra variables just to test to break out, or use a goto statement. The other is jumping to the end of a function, and this is especially true when resources are allocated and need to be deallocated. Say you open a file with fopen at the start of the function. If this function has multiple return points, you'd have to fclose at all these points. If you forget even one then you have a memory leak. However, if you goto the function when where you fclose the file and return, you'll never have a resource leak. All the goto hate mostly comes from the dark ages. Programming languages often didn't have good looping constructs and people used goto statements to just jump anywhere. You can do anything you want with goto, and it can result in extremely difficult to read and debug programs. This is what's frowned upon, not _all_ uses of goto.
That's reasonable, but I'd prefer this. int i; for(i = 0; i &lt; alen &amp;&amp; a[i] != x; i++); if(i == alen) panic("not found");
lol
&gt; Generic ... This can't be considered generic when it forces one particular form of allocation upon downstream programmers. That's rather specific and restrictive. Also, if it works for some systems but not others, then it's not generic, but rather specific. I think your library might work fine on POSIX systems, where it's largely unnecessary to begin with. &gt; as similar as possible to the C++ STL If you want C++ STL, use your compatible C++ compiler. If a compatible C++ compiler doesn't exist, write one... ideally to standard specification... so that you don't end up in court fighting over some subtle yet chaotic bug which you managed to miss. &gt; I tried to make it C++ compatible so I did the casts. You're using gcc to test this, and gcc comes with a C++ compiler... same goes for clang. Both of these compilers have linkers facilitating linking from other languages. If you want to link C code into your C++ project (or vice-versa, which is somewhat more cumbersome) then I would suggest reading your linkers manual pages to find out how to do that. I notice you are using `-flto` and guess that you've selectively read only this part of your compilers manual... if I'm correct, that's a shame. &gt; a bit faster I guess you can make this assertion if you rely heavily upon anecdotal evidence. Judging from your *benchmarks* (which are effectively premature optimisations in the form of highly inaccurate *profilers* that you've rolled yourself) it seems you've only compared *your* system, using a *hosted* (*not freestanding?*) implementation... most likely with only one compiler, with which we don't know version info, on a single machine with which has a particular kind of CPU (we're also not privy to that info), running an OS which we've not been told the name of... all of this makes me think you're confusing your *concrete implementation of C* to be authoritative of the *abstract language*. C doesn't have an authoritative *concrete implementation*, and neither does C++. Let us be clear that **you can not measure speed objectively this way**. In real world applications we struggle with cache misses due to bloated code and/or data (which your profiler should be able to measure for you, thus helping you to optimise on a per-application basis)... yes, the cache misses can occur in both *code* AND *data*. I don't think your tests measure this. Furthermore: &gt; 1. The semantic descriptions in this International Standard describe the behavior of an abstract machine in which issues of optimization are irrelevant. &gt; ... &gt; 4. ... An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produce ... These are likely to be the clauses [from the C standard](http://port70.net/~nsz/c/c11/n1570.html#5.1.2.3) that make your assertions regarding speed most difficult to prove... and within the C++ standard, you can find similar clauses within the section indexed as \[intro.execution\]. Some other issues that might affect the credibility of your measurements include assumptions regarding [process](http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_08.html#tag_02_08_04) and [thread](http://pubs.opengroup.org/onlinepubs/007908799/xsh/threads.html#tag_000_010_003) scheduling on your POSIX-compliant system (assuming POSIX-compliance, which is another issue as I see below others have mentioned `strdup`)... Some of these variables are likely to incur biases in your measurements... which is why you *shouldn't* roll your own profiler (a.k.a. *benchmarks*)... in fact, you really need to un-learn everything you've learnt about optimisation if you want to optimise most effectively. &gt; there are no undefined behaviors Throughout your code you use these functions which it seems could easily return `NULL`, and then you attempt to read from and write to objects pointed to by these *null pointers*. Perhaps if you remove all of the safety checks from the C++ STL, the C++ STL might be *faster*... but *much less secure*. You can only really claim that an optimisation is *valid* if it isn't *buggy*, right? Your code invokes undefined behaviour in some circumstances... pretty much everywhere, too. I wonder if you're familiar with the exploitation vector of a null pointer dereference. Namely that `ptr[x]` is functionally equivalent to `*(ptr + x)` which is in turn functionally equivalent to `*(x + ptr)` which we can thus rewrite as `x[ptr]`. That is to say, if we let the user control `x` and `ptr` is `NULL` then the user has a highly reliable vector to access (read or write, depending on the operation) anything in your address space. It's not so nice when an allocation function fails, and rather than handling it as a failure you let the code just keep chugging on as though success was had, the entire system could end up compromised... just sayin', we need less complex heartbleed-like bugs, not more. While we're on null pointers, the following pattern is *almost always* wrong: `X = realloc(X, /* SNIP */);`... In the event of a failure, you end up overwriting an address pointing at an allocation (still) with a null pointer. Thus, [this](https://gitlab.com/ado0/sgc/blob/master/lib/string.h#L152) contains a memory leak... followed by a null pointer dereference... neither of which are particularly good news (the latter is undefined behaviour and could result in security issues as mentioned earlier). You know, you can use some compiler switches to point out some of these *undefined behaviours*... but I'll leave you to read your compiler manual and find these switches... you'll learn far more interesting things that way. ... and F.W.I.W. `sizeof (char)` is *always* 1 in C and C++. If your book is teaching you otherwise, you need a new one. There are identifiers used which are reserved for the implementation; perhaps your implementation doesn't use identifiers such as `_data` or `_size`... but that doesn't mean every implementation is required to follow this example. Just as using `_asm` as a variable name in some compilers is illegal... you get my point now surely, right? Please see [ISO 9899:201x section 7.1.3](http://port70.net/~nsz/c/c11/n1570.html#7.1.3) for a list of identifiers that are reserved. &gt; as far as I know `inline` is just a suggestion for it. I wonder what your book says about the extra constraints of `inline`... if it mentions `inline` but doesn't tell you what you *can't* do to an `inline` function (which you otherwise *could* to a non-`inline` function), then... you might need a new book. This is the problem with the "learning by unguided trial and error" method of learning. You don't get to learn the nuances of the languages. You'll likely get a slightly better hash distribution (a.k.a. less collisions) if you use a mersenne prime as your multiplier rather than 33, when hashing, particularly if you reduce the result modulo some larger mersenne prime at the end. For example: // XXX: for each character: hash = hash * 31 + c; // ... and then at the end: return hash % 2147483647; Also, in this day and age where our compilers can detect and eliminate unused code for us faster and better than we can manually... why is it we still see shifts manually-optimised in? That's a waste of your time, and a code-rot for maintenance... Ultimately I would say stop programming like we used to back in the 1980s; it's not necessary thanks to significant advances in our compilers. If you want to use C++, use a C++ compiler. If you want to use C, use a C compiler. Don't try to program C in C++; if you restrict yourself to the worst of both worlds then ... you live in hell.
Here you can find basically every science textbook: [http://gen.lib.rus.ec/](http://gen.lib.rus.ec/)
Ohhh... and then there's the `FILE *` implementation... we've not covered the distinction between unbuffered/line-buffered/fully-buffered yet... and that'll also affect your measurements. What does your manual say about `setbuf`? Suppose the buffer size changes from one implementation to the next... doesn't that mean the speed also changes?
I think this implementation is nicer. But Goto is still great for error handling. I don't know anything else as suited for such a task.
Before diving in to any libraries I'd recommend going through at least some of [Beej's Guide to Network Programming](http://beej.us/guide/bgnet/).
Rather than thinking in terms of allocators, which I guess is a C++ism, I suggest borrowing influence from the first and arguments of `snprintf`. This latter idiom is immediately familiar to anyone who utilises these C standard functions, and thus the useability of your code increases dramatically in their eyes. It's also not specific to any one form of allocation. From here it's trivial to write a dynamically allocating version of `sprintf` for example (typically called `asprintf` on Linux, IIRC). If you want to go the reinvention-of-C++ route, with an hour or so of research and twenty or so minutes of development I think you might be able to complete the first three phases of translation, that is writing your own compiler (or interpreter, as it were, the standards don't seem to explicitly forbid those)... to be clear I'm expressing confidence in you with this regard, and once you finish the first three phases, well... in C++ there are six remaining. I think there's a slight difference between C and C++ in how `pp-number` is parsed... this particular type of token is the most difficult part of phase 3 from my experience. You might find a pair of stacks to be useful for phase 4 onwards up until about... well, I haven't got that far myself yet. There's something I love about pushing/popping between stacks as a mechanism to perform loop-invariant code motion optimisations, though... particularly on an implementation with which we know to be hosted.
I still prefer mine because of what Brian Kernighan calls idiomatic code. if you have `for(i = 0; i &lt; n; i++)` you don't have to parse the code. It's an iteration idiom that you can parse as one. The additional `a[i] != x` isn't too hard to understand of course but I would but it into the for body with a break. As for the second if, the reason I don't like it is that you already found what you were looking for, checking again and having to mention the length of the array again feels clunky to me.
See also [MEM12-C. Consider using a goto chain when leaving a function on error when using and releasing resources](https://wiki.sei.cmu.edu/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources), from [SEI CERT](https://en.wikipedia.org/wiki/CERT_C_Coding_Standard)'s standard.
No. Just... no. *Go To Statement Considered Harmful* was a letter to the editor, not a paper. Dijkstra did not choose the title, nor did he approve of it. And it did not ‚Äúkill the reputation‚Äù of `goto`; it was merely one of many contributions to a long-running debate. But most importantly, it predates C by four or five years. It also predates Pascal by two years, which is significant because the editor who came up with the infamous title was none other than Niklaus Wirth, the designer of Pascal, which has a `goto` statement.
This is not a good example of the need for `goto`. The common idiom here is to check if the loop reached the end, i.e. if `i == alen`.
Please don't steal books or encourage others to do so.
Please don't steal books or encourage others to do so.
Well you could use 'strchr'. I could be used for determine on what position in alphabet searched letter. With that information you could replace value from message string with value from cipher alphabet.
Did you read any of the other threads under this? Due to being a beginner, I didn‚Äôt know there was a difference and I have now been educated on the differences. Thank you for being the 20th person to tell me this.
I have been watching his videos for a while and you are right he is very helpful. Thank you
You are completely right thanks for the advice.
&gt; as I have typecasted data-&gt;ptr There is no such thing as "casting a variable" (or, in this case, a struct member). _Values_ are cast to new types, not variables. In: (Point3D *)malloc(...) the `malloc` function returns a value of type `void *`. You then cast that value to the type `Point3D *`. The value doesn't change, only its type does. You assign the newly-typed value to `data-&gt;ptr`, a struct member of type `void *`. The behaviour here is _exactly_ as if you had simply written: data-&gt;ptr = malloc(...) Indeed, this is even valid if `data-&gt;ptr` has some other data pointer type.. A `void *` value, as returned by `malloc`, can be freely converted to any other data pointer without the need for a cast.
It‚Äôs rare, but sometimes `goto` could be used to go backwards. This is helpful when different errors cause a loop-back to a different state/position - it‚Äôs like jumping to the middle of a loop. It could occur when trying to recuperate from errors.
It's OK in some cases. Usually you can avoid it by using other syntactic features of the language, and when you can avoid it you usually should. There are some times, though, when goto ends up being less confusing than the alternative. There are also some important uses of goto in generated code, such as in regular expression engines (e.g. [re2c](http://re2c.org/about/about.html)). Generated code isn't really meant to be read anyway, so readability isn't a priority. There's also [computed goto](https://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables), which can be useful as an alternative to switch statements in some cases, particularly (again) in generated code.
Several replies are spot on for the (relatively few) cases where it's good. I will add that keeping the logic surrounding the goto - and its impact - as simple as possible. If you're using it for error ladder, do the check as early as possible, and be very clear that all preceding state (hopefully none) is accounted for.
Goto is very useful and those saying different are just regurgitating things they heard without forming their own valid opinions
As a lover of goto, albeit very rarely, I also prefer this
Goto is very useful and those saying different are just regurgitating things they heard without forming their own valid opinions Personally the only times I tend to commonly use it are in large switch statements where some cases share an epilogue, instead of break;ing and repeating logic or more overhead with functions
This is a program to visualize sorting algorithms, written in C and SDL. I would appreciate any feedback regarding coding style, Makefile or whatever :)
I am a moderator of this subreddit. I prefer to let people know why I have removed their threads. If you prefer not to know why your post has been removed, I can arrange that.
Great replies from everyone here and this is why professors teach people to *never* use them. They are useful but you really need to be careful. For the record I think professors should teach it instead of scaring students.
If you do that, you introduce a situation where you check for the same condition twice. This is error-prone because you could change one of the abort conditions while forgetting to update the other one. For the same reason, people should write something_t *foo = malloc(sizeof *foo); instead of something_t *foo = malloc(sizeof(something_t)); as they could change the type of `foo` without changing the argument of `malloc` appropriately.
&gt; Goto is very useful and those saying different are just regurgitating things they heard without forming their own valid opinions Clearly, all opinions are invalid until they come to the same conclusion as yours.
So clearly then, you should compile with `-O0` to avoid both classes of bugs!
Precisely^^^/s, but I see you write elsewhere in favour as well
This is explicitly not about my own opinion on that matter. This is about you excluding the possibility of an informed opinion arguing against goto.
&gt; This is about you excluding the possibility of an informed opinion arguing against goto. I've yet to see this, they usually just cite Dijkstra or say their professor said so and don't back it up.
Ok, so i got the rotation encryption working using heaps of switch statements... `printf("Enter the cipher assignments\n");` `fgets(ciph, 26, stdin);` &amp;#x200B; `printf("Enter a string:\n");` `fgets(str, 100, stdin);` &amp;#x200B; `for(i=0; i&lt;100; i++) {` `if(str[i]&gt;=65 &amp;&amp; str[i]&lt;=90) {` `switch( str[i]) {` `case 65: str[i] = ciph[0];` `break;` `case 66: str[i] = ciph[1];` `break;` etc. etc, through another 24 cases. But now I'm getting a different problem :\\ Im using if and else if statements to allow the user to pick to either use rotation cipher or substitution cipher. But its just ignoring their conditions and going through the first line of code. `printf("Test 'Rotation Cipher' or 'Substitution Cipher'?\n");` `printf("Rotation = 9\nSubstitution = 0\n");` `scanf("%d", &amp;type);` `getchar();` &amp;#x200B; `/*-------Rotation Encryption/Decryption Cipher (Given key)-------*/` `if(type = 9) {` //... code to rotate string by x amount. `/*------------Substitution Cipher (Cipher text given)--------*/` &amp;#x200B; `else if(type = 0) {` `char str[100];` `char ciph[26];` `int i;` &amp;#x200B; `printf("Enter the cipher assignments\n");` `fgets(ciph, 26, stdin);`
Your choice of typeface is interesting.
When you want use a void pointer (rather than just assigning memory to it) you need to cast it to something non-void first. e.g. instead of: data-&gt;ptr[i]-&gt;y = 9.0; You need to do something like: Point3D *p = (Point3D *) data-&gt;ptr; p[i].y = 9.0; It's the same when you want to access it.
Why should I usememcpy when I get my byte conversion for free? : -) Runtime cost 0. The code is proprietary and not ment to be shared.
Then do what yo do...
Thanks! &amp;#x200B; But isn't that already done when I cast Data-&gt;ptr to type Point3D: &amp;#x200B; data-&gt;ptr = (Point3D *)malloc(50 * sizeof(Point3D)); ?
I don‚Äôt think it stealing if the person you take the book from still has a copy. Use another word.
No it is not. `data-&gt;ptr` is still `void` as in your declaration of `struct DATA`.
Thanks! &amp;#x200B; &gt;*Any* void \**value can be converted to any data pointer type without a cast* &amp;#x200B; so, is `Point3D *p = (Point3D *) data-&gt;pt` just as valid as `Point3D *p = data-&gt;ptr`?
Thanks!
Aha, I am not sure if I understood what you ment first time. You mean why didn't I just malloced a bit memory region and red it like a byte array. It would have random content in it? Indeed, I probably could have done it, but I have no idea what might be in that region. &amp;#x200B; There are some requirements on those numbers and seed used, so I opted for a custom random generator. But yes you are probably right, I could have just malloced 8 \* 10000 bytes and read in those as chars. If that is what you ment.
[I will just leave this talk](https://www.youtube.com/watch?v=otAcmD6XEEE&amp;feature=youtu.be&amp;t=1245) that always ressonate with me. It starts with the Dijkstra's goto letter misconception and a point against early returns/goto's although I heavily use them.
Taking the Dartmouth C Programming class on EDX. This will help me a whole lot. Thank you.
No. "Unlike C, the C++ compiler allows implicit conversions TO a void * type, but to convert FROM a void * type requires an explicit cast." https://embeddedartistry.com/blog/2017/2/28/c-casting-or-oh-no-we-broke-malloc
Note that I've created a new variable `p` which is a non-void type, rather than using `data-&gt;ptr` itself - this is what you need to do to access struct elements stored in a void pointer.
goto Usage; when the usage is so simple it really does not warrant a function.
That message means that it can't find `xlsxio_read.h`. If that's not part of your project then you don't want to list it as a dependency.
I need to include it though to use the functions. Not sure what to do so I'm able to do so
&gt; C doesn't have a multilevel break statement Wait... If I have a nested loop, but its nested in an IF condition. Once I want to break, couldn't I make my IF break?
Is this part of an external library or a file you created. If it's external you don't need to include it in your Makefile dependency list. `mycode: test.c xlsxio_read.h` means, when make mycode is called, if ./test.c and/or ./xlsxio\_read.h have changed, mycode must be rebuilt. If xlsxio\_read.h is not a local file, it's full path must be specified. If you never plan to change it (because) it's an external library, you don't need to include it in your make dependencies list.
The book Think Like a Programmer takes lots of problems and shows you how to break them down into smaller pieces. It‚Äôs one of the best books I‚Äôve read on this subject.
How about ‚Äútheft‚Äù?
Be aware that, if at all possible, it is a good idea to encapsulate a particular use of goto in its own abstraction, such that you can reason about your code in a more high-level way and are restricted to obly using the gotos in the way intented by that particular abstraction. (like e. g. other kinds of loops or exception throwing/catching). I have also seen gotos used to implement directly-threaded interpreters. Essentially the gotos are used as a poor man's tail recursion here.
Try r/csharp
C# isn't C, they are different languages.
My bad.
ooo this is only for C? my bad
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
I‚Äôve been using rakefiles instead of makefiles ever since I learnt ruby. I‚Äôm not good enough at c to give feedback yet, however I always love to put people onto rake because makefiles are notoriously difficult to debug. I suggest checking them out.
Where did you place that header file?
&gt; not a paper Semantics &gt; But most importantly, it predates C How is this relevant? OP asked about goto.
Teaching goto instead of scaring students only works if you can trust the students to pay attention to the "don't use this until you understand the pitfalls" part. It's hard enough just to get students to read the entire homework assignment, so that's probably why many professors avoid it even in 300-level courses.
&gt; How is this relevant? It shows that Dijkstra did not kill `goto`.
Looks interesting but I will have to learn ruby syntax for that. Seems good for ruby users but alas, I don't know anything about ruby
A goto is an unconditional jump. There‚Äôs nothing intrinsically evil about it. C in general is not a good idea unless you‚Äôre extremely disciplined and that includes goto. It‚Äôs a great way to jump out of super nested loops or to centralize clean-up code. Use it when the alternative is a lot more code or copy-pasta. You‚Äôll ‚Äúknow‚Äù when you need it, eventually.
Lucky you aren't talking about the opposite. Someone once tried to break from an if statement nested in a loop. You can't break from if statements, so it broke from the loop. Unluckily for everyone on the east coast, this programmer worked for AT&amp;T and this one bug brought down the entire long distance network. Talk about a bad day at work. But yeah, if you have a loop inside an if and you want to break out of loop and go to the end of the if statement, you can use a goto.
It is considered harmful.
`continue` can be seen as a backwards `goto`, I suppose.
&gt; if you have a loop inside an if and you want to break out of loop and go to the end of the if statement, you can use a goto. Optional correct? I have gotten away with not using GOTO in my decade of programming. Curious if there is any cases where If statements wouldnt suffice... Maybe I'm picturing my own state systems.
&gt; `continue` can be seen as a backwards `goto`, I suppose. Yes, it could be considered that way. However, `continue` won't allow you to jump backwards to the middle of a loop or out of a nested loop to restart the container loop.
Check this one https://github.com/cesanta/mongoose Small, elegant, no dependencies, have examples for most usecases.
I remember when goto and spaghetti code was the norm. There were great debates on using goto and studies showing the number of bugs generally increased with the use of goto. &amp;#x200B; Every college prof would fail any project that had a single goto in it. &amp;#x200B; As a manager I have adopted that same mentality, if you use a goto, I will make you rewrite, or fire you. &amp;#x200B; For your personal projects goto if fine. But don't use it on my projects. &amp;#x200B; If you are not skilled enough to write without using a goto, you are simply not skilled enough to be on my team. &amp;#x200B; BTW, if you cannot explain a Duff's device to me, you are also not skilled enough to be on my team.
I'm just saying it's an example of one way that backwards `goto` can be useful. It has significant restrictions, and for good reason, but there could be specific cases when a more general backwards `goto` is desirable.
1) C can do more than what either python or java can do. Python itself is written in C so that goes without question. C is significantly more difficult than either, but it gives you more flexibility to work with networking stuff, because most libraries for either userspace or kernel networking are initially written in C. If you don't find a library to do what you want, you can write a simple implementation yourself. Networking requires top top speed. Like squeeze out every millisecond you can. This is where C works best in modern day.
I can't install your program, in the directory where the Makefile is, when I do 'make' it returns 'no rule specified to build...'
Did you git clone the project? Do u have the folder "master-makefile"?
No I downloaded the zip. The master-makefile was empty. I added the file to it and it worked! Thank you for your help. Nice project. I'm just learning sorting algorithm at school.
If your code just needs to refer to it but you aren‚Äôt supposed to build it, you might need to make sure your `CPPFLAGS` has a `-I` option referring to the directory it‚Äôs in, so you can `#include&lt;&gt;` it. If you‚Äôre supposed to build it, you‚Äôll need a rule for it. If you want things to autodetect what headers you need to depend upon, use something like Automake, which uses the compiler‚Äôs `-M` options to dump dependencies. Also, when you‚Äôre pasting a block of code on Reddit, indent each line by 4 spaces; intralinear code delimited with backticks. That way you don‚Äôt have a bunch of stray `*`s and `\`s and whatnot scattered about, and your makefile rules appear as such. It‚Äôs unclear whether you intended to make your code italic, but it didn‚Äôt come out so hot.