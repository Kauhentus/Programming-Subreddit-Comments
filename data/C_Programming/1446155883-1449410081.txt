Your logic is sound. Your syntax is wrong. You wrote `=` when you needed `==`
Thanks, I changed it. It's still showing the same error though.
Then you missed one. if ( a==3 || a==7 || b==3 || b==7 || c==3 || c==7 || d==3 || d==7 ) compiles and does the correct thing
I'm stupid. Thank you so much!! Jc do you know how I would count these
&gt; Note that while some CPUs like Intel will let us access unaligned memory locations, certain others like ARM CPU will fault. So, always remember to keep the pointer pointed to an aligned location before dereferencing. Well, yes do that, but do it because otherwise *you're pointing at the wrong location*, not because of alignment issues.
Nope, that's what's so lovely about --prefix. You're using it exactly right.
Is that true for `void **` as well as `void *`? Because I've got a compiler that will implicitly convert other pointers to `void *` and vice versa, and will also convert `void *` to `void **` and `void **` to `void *`, but won't convert an `int **` to `void **`. Anyway, if C "allows" the implicit conversion, doesn't that mean it's optional? If it were mandatory then it should "require" the implicit conversion.
Wow, that's an impressive looking project. I took an OS class where we hacked on Linux (typically by removing some part of the kernel and rewriting it to use a different algorithm or something), but this sounds like a lot of work. Looks like it'll require a lot of knowledge about hardware and stuff that would normally be considered "drivers", too. That said, I imagine the class will teach you most of what you need to know. They're not going to hand out a semester-long project like this and expect you to learn on your own how an OS is supposed to do its job. So I wouldn't worry too much about it. Just make sure to get some practice with C; you should be at a point where pointers feel like a totally natural way to get things done.
Ever heard of that guy called Boehm?
Unless your in C99 (and C11 if your compiler decided to support VLAs).
When you recurse, you need to pass `types+1` You mustn't use types[20] as your temp - how do you know types is long enough?
Yep, my bad... I'm thinking old school... However this fragment doesn't work due to i not being initialized int i; char letters; int numAccts[i]; int acctBal[i]; 
&gt; A pointer to void may be converted to or from a pointer to any incomplete or object type. A pointer to any incomplete or object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer. Note that a `void**` is *not* a pointer to void.
you should post these kind of things on freelancer.com
Hm... I don't know any good introductions to `make` either. I believe “The Unix Programming Environment” has a chapter on `make` but I'm not too sure about this.
Your post got caught in our spam filter, I just unblocked it. I'm sorry for your inconvenience.
Good catch, didnt notice that one hehe
Maybe he got shadow banned. I have no idea, honestly.
Looks like the conditions are checking, respectively, if: * We're currently printing in the first column, * We're currently printing in the last column, * We're on the first row and not printing the first or last column * We're on the last row and not printing the first or last column. * Otherwise we're in the center of the grid (that's the '.' in the final else). With those conditions in mind, we can indicate what we want to print to the console. In each case, respectively, * Print a '%' in the first column, * Print a '%' in the last column, * Print an '@' in the first row, so long as it's not either end (first or last column, * Print an '@' in the last row, so long as it's not either end (first or last column). * Everything else (the center of the grid) gets a '.' The key to understanding the conditions is to understand what 'i' and 'j' are. Notice those two are being incremented within nested for-loops - That's a good indication that the we're doing something on a 2D grid. In the first pass through the outer loop, 'i' will remain the same (0) the whole time. Meanwhile, the inner loop will undergo several iterations. Essentially, each run through the conditions in the inner loop will have a different set of coordinates: [(0,0), (0,1), (0,2), (0,3), (0,4)], at which point the inner loop finishes and the outer loop can increment.
Thanks. Any guidance on how linking works?
No linking happens when you create an object (.o) file. What exactly would you like to know about linking?
I thought that when you compiled using a .o file as an input, you where linking. I want to know what generating .o files are for, and how do you use them (I thought the process of using .o files was called linking)
Thanks! Right now I'm looking as this: [basic compilation guide] (http://courses.cms.caltech.edu/cs11/material/c/mike/misc/compiling_c.html) I'm interested in C from a reverse engineering / security point of view, so I want to experiment with these kind of files and know the low level diferences :)
Here's an abbreviated guide. Let's pretend you have 2 C files, a.c and b.c. You run `cc a.c b.c` to produce the executable file `a.out`. Here's what happens in many C compilers: 1. Preprocessing. The C preprocessor (`cpp`) is run on each C file. The input to this stage is a.c or b.c and the output of this stage is C code which has all preprocessor directives removed. 2. Compiling. The C compiler (`cc`) is run on each C file, which emits assembly code specific to your platform/architecture. The input to this stage is C code without any preprocessor directives. The output of this stage is assembly code files, specifically `a.S` and `b.S` in this case. 3. Assembling. The assembler (`as`) is run on each assembly code file, which translates from assembly code to machine code. The assembler also packages the machine up into the proper file format (called an object file). The input to this stage is `a.S`/`b.S` and the output of this stage is `a.o`/`b.o` 4. Linking. The linker (`ld`) takes multiple `.o` files (and other library files such as `.a` files and `.so` files) and links them together into one larger file. It is also at this stage that unresolved symbols are resolved. E.g., if `a.o` has a reference to a function which is defined in `b.o`, that link is resolved in this step. The input of this stage is `a.o` and `b.o` and the output of this stage is a single executable file (such as `a.out`) To stop after stage 1, run your C compiler with `-E`. To stop after stage 2, run your C compiler with `-S`. To stop after stage 3, run your C compiler with `-c`. Without any extra flags, your C compiler will probably do all 4 stages automatically for you, and delete any intermediate files that were produced (such as temporary `.o` files) (Edit: it's very rare to explicitly break up the first 3 stages. Often the first 3 stages together are referred to as "compiling") When building (large) projects with a build tool such as make, it's common to compile files using `-c` (to produce `.o` files) and then explicitly link them together at the end. The reason for breaking this up into two steps is that make will only recompile files which have changed, which speeds up the build process.
What do you mean with “low level differences?”
This is too much for me to explain in a comment, read a tutorial on linking.
Woah! This is great. Thank you very much! Lastly, do you know where can I read about the differences of a .o file and an executable file? Both are binary files, but one isn't executable. Has it got to do with the headers of the file? The entry point?
Unless you're on Windows or OS X, you're using an operating system that uses [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format). (Windows uses [COFF](https://en.wikipedia.org/wiki/COFF) and OS X uses [Mach-O](https://en.wikipedia.org/wiki/Mach-O)). Assuming you're using ELF, you can see on the ELF Wikipedia page that offset 0x10 in the header specifies whether it's executable. Play around with tools like `readelf` to dump out information from your .o headers or executable headers.
I've been going through a series of blog posts, but I can't find it on my phone. I've heard good things about [this book](http://www.iecc.com/linker/), and it's on my list of books to read.
I'm on Arch linux. Thanks for the info, I will be playing with this :)
Very true, but isn't all that important in practice.
Just a simple example that you can expand. Lets say your little toy project consists of the source files main.c hello.h and hello.c and main.c includes hello.h. The Makefile would look like this and output the binary named "hello". I’m assuming you use gcc and hello uses the "math" library. Make sure you use a TAB character for indentation, this is part of the make syntax. Eight spaces won’t work. Not tested, may contain typos. # Default target when you just run "make" from the command line. # all: hello # Link main.o and hello.o into the output binary "hello". # # The -lm linker flag is used to link the program against libm, # the math part of the standard C library. Add other libraries # using the -lname flag, e.g. if you use libpthread, you need the # linker flag -lpthread. # hello: main.o hello.o gcc -l -lm main.o hello.o -o hello # main.c depends on hello.h # main.o: main.c hello.h gcc -c main.c -o main.o # hello.c depends on hello.h # hello.o: hello.c hello.h gcc -c hello.c -o hello.o # Use "make clean" to remove all build files. # # We pass the "-f" argument to "rm" to ignore any error messages # about non existing files. # clean: rm -f *.o hello 
"make" handles the build process itself via a Makefile recipe, which typically consists of first compiling source code into object code and then linking the object code to create an executable binary. With gcc, you can actually pass flags to the linker (-Wl,--some-flag) eg, "gcc -Wl,--verbose -o helloworld helloworld.c" passes the verbose option (if you want to really see what's going on).
Interesting. If I understand correctly this is used in the [ebtree implementation](http://1wt.eu/articles/ebtree/#impl) by willy the haproxy author guy.
[This Stack Overflow post](http://stackoverflow.com/questions/413477/is-there-a-good-valgrind-substitute-for-windows) asks for tools similar to valgrind on Windows. 1350 lines isn't that much, consider putting it in a [gist](http://gist.github.com) so we can have a look at it, too. You could also try to run your program on Linux, there you can use valgrind (which is really easy to use).
http://www.amazon.com/Unix-Network-Programming-Volume-Networking/dp/0131411551 this one? It's from 2003, but that doesnt care? 
The only thing new since then, is IP6 IP addresses. But from a programming perspective, this is the best you'll ever find.
Hmm I have rewritten it with the same indices as they did but das not seem to many any difference void multiply_blocked(double *a, double *b, double *c, int n, int B) { int i, j, k, i0, j0, k0; for (i0 = 0; i0 &lt; n; i0+=B) for (j0 = 0; j0 &lt; n; j0+=B) for (k0 = 0; k0 &lt; n; k0+=B) for (i = i0; i &lt; MIN(i0+B-1, n); i++) for (j = j0; j &lt; MIN(j0+B-1, n); j++) for (k = k0; k &lt; MIN(k0+B-1, n); k++) c[i*n + j] += a[i*n + k] * b[k*n + j]; } The difference is they refer to the element on the second row and third column as c[2,3] where I would do c[2*n+3] since i'm storing the matrix in a one dimensional array. 
Could it be that the multiplication is done the wrong way round, i.e. with rows and columns swapped?
It should make a difference as you used incorrect indices before (you used the indices from the outermost three loops in the loop body instead of the indices from the inner three loops). Did you remember to recompile? Could it be that the multiplication is done the wrong way round, i.e. with rows and columns swapped? Did you make sure to zero out `c` up front? 
I highly recommend looking into running Linux and using both valgrind, gdb, and jemalloc. Those are the best tools I have ever used. 
If you swap them everywhere you would, but in your original post you didn't do that. 
TLPI is awesome. I haven't gone through the whole thing front to back but it seems very comprehensive and well written. Tons of example code and overlapping information. There's also a chapter on TCP/IP so it might actually be a good place to start. Then if you find it lacking pick up the Stevens. Or just get them both right away, because the Stevens is one of the best tech books ever. 
Yeah TLP is one of those books you should buy if you're doing _any_ linux systems programming. A year or so ago I was writing a client server model program which used shared memory to communicate and I pretty much jumped around relevant parts of the book until I finished the whole program, I found everything I was looking for in there, ranging from shared mem, to inotify, daemonizing, and everything else I needed for that project.
Perfect! These two books it is then. Then i will have 1 year of some instance study..!
[Dr. Memory](http://www.drmemory.org/) works similarly to Valgrind on Windows.
Hey, please don't delete your post after getting an answer. How are future readers with the same problem going to get help?
Depending on your skill level, you could hack a simple - and far less elegant - memory tracker using wrappers around `malloc` and the related functions. Basically, store a table of every allocation's address with who allocated it. When it is deallocated, mark it as such (or remove it). At certain points - like when the program exits - dump the data. Real tools are better, but if they aren't feasible, much can be learned from writing your own. I'm thinking of soenthing like the following API (I'll only do the allocation): void *dbgmalloc(int line, const char* file, ) /* remaining params for malloc() */ #define DBGMALLOC(SZ, CNT) dbgmalloc( __LINE__, __FILE__, (SZ), (CNT)) Then you replace all of your calls to malloc with DBGMALLOC. Note that this can only track memory that you are explicitly allocating. It won't track allocations from things like strdup() I apologize for the incomplet and maybe inaccurate use of malloc - I'm on mobile and my memory is fuzzy from a cold.
Thanks for the reply.
Is this what you're taking about?(https://msdn.microsoft.com/en-us/library/windows/hardware/ff558947(v=vs.85).aspx) This looks nifty.
Thanks.
Yes! It's awesome. Even just enabling the stack trace for the process with gflags lets you see the stack in windbg. It's also useful since it groups by stack so you can see that most of your memory is coming from one function etc rather than always needing to compare snapshots. 
This might be exactly what I need.
Iirc mingw links to msvcrt which uses HeapAlloc so it should work great. Best of luck. Make sure you have symbols set up :) maybe build with out FPO in case you have trouble getting call stacks. 
For those who don't want to read the article, the rules are: 1. Restrict all code to very simple control flow constructs. Do not use GOTO statements, setjmp or longjmp constructs, or direct or indirect recursion. 2. All loops must have a fixed upper bound. It must be trivially possible for a checking tool to statically prove that a preset upper bound on the number of iterations of a loop cannot be exceeded. If the loop-bound cannot be proven statically, the rule is considered violated. 3. Do not use dynamic memory allocation after initialization. 4. No function should be longer than what can be printed on a single sheet of paper (in a standard reference format with one line per statement and one line per declaration.) Typically, this means no more than about 60 lines of code per function. 5. The assertion density of the code should average a minimum of two assertions per function. Assertions must always be side effect-free and should be defined as Boolean tests. 6. Data objects must be declared at the smallest possible level of scope. 7. Each calling function must check non-void function return values, and the validity of parameters must be checked inside each function. 8. Preprocessor use must be limited to the inclusion of header files and simple macro definitions. Token pasting, variable argument lists (ellipses), and recursive macro calls are not allowed. 9. The use of pointers should be restricted. Specifically, no more than one level of dereferencing is allowed. Pointer dereference operations may not be hidden in macro definitions or inside typedef declarations. Function pointers are not permitted. 10. All code must be compiled, from the first day of development, with all compiler warnings enabled at the compiler’s most pedantic setting. All code must compile with these setting without any warnings. All code must be checked daily with at least one—but preferably more than one—state-of-the-art static source code analyzer, and should pass the analyses with zero warnings. 
This is probably beyond my ability at the moment.
I can't understand what exactly they mean in 3. Other than that, they're really good as rules of thumb. Only remember that *sometimes* there might be very good reasons to break one or two of them.
Not universally. NASA trades productivity and ease of development for extreme safety because they have billions of dollars of hardware and multiple human lives relying on their software. If you're in that situation, you should be equally meticulous. If you're making video games or something, you can probably save yourself a few years of development time by not being so pedantic. Most software probably falls somewhere in the middle in terms of the tradeoff between safety and development time/ease.
That would be *very* unpractical. What I think is that they mean you should do dynamic allocations as early as possible inside functions.
I didn't think of that. Thanks for the insight.
http://dmalloc.com/
Thanks.
strtok("/n") is all you need
I'm wondering if these rules wouldn't be good for open source security software (or security software in general). Do any open source security projects have such rules?
3 effectively means that you define the memory allocations you need at the time the process starts. This is in contrast to memory allocation that can occur during the time the process is actually doing work. The objective is to prevent the process from being capable of dynamically allocating memory space in way that could result in memory exhaustion.
No. That's not what it means. It means that the space your program needs is defined in a way that prevents it from looping allocations and exhausting memory. This is performed during process startup and even then not inside functions that can loop.
I have another question for you if you don't mind. Your comment about double free is interesting. If I malloc() and then free memory and then set the variable that pointed to that memory = NULL. What would happen if I freed a pointer that was equal to NULL?
This is the [whole JPL standard](http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf) of which this article lists an incomplete excerpt. I do not recommend using it for your own code as many parts do not make sense outside of super safety-critical applications. For example, the passage “All loops shall have a statically determinable upper-bound on the maximum number of loop iterations” makes sense in safety critical applications but is very restricting in real-life: many data structures are hard to implement with such a rule. The other rules are similarly restrictive and fairly masochistic for application code.
&gt; But my question is if you were in that situation, would you be confident in your software enough to push it into production if you followed these rules? I'm not acwaters, but yeah I'd be reasonably confident. The majority of those rules seem to be designed around avoiding problematic memory issues on embedded devices, stuff that isn't likely to become a problem for application development with modern computing, but can have very detrimental ramifications when taken to the embedded level. I'd be much less confident if it was programmed without those restrictions.
The aphorisms provided in “Elements of Programming Style” (Kernighan &amp; Plauger) form a very solid basis about how to write good programs.
Thanks.
Excellent, thank you.
For 1. banning recursion is not to do with the difficulty of the algorithm, it's because without recursion it is easy to statically analyse the maximum possible amount of stack a program will need.
More checks saves development time because you don't have those day-long (or week-long!) sessions of trying to find a Heisenbug.
Spaceships don't getchar. Growing arrays is dangerous as you might run out of memory, it's more robust to have all allocation done at compile-time. 
What happens if the `assert` does not exist? Silently wrong behaviour? Failure can be handled by restarting the failed process. Silently wrong results are much harder to deal with.
3 is to ensure any calls to malloc or similar dynamic memory allocation routines happens at start up, which prevents unpredictable delays during the operational period. Real-time systems need to meet critical deadlines when operating, and dynamic memory allocation can be less predictable and it can disrupt the scheduling quite a bit, which is why it often isn't used in embedded real time controllers. So, if the program absolutely needs a varying size of memory, it must request it at the very beginning and only then to prevent delays in more important time periods.
I've been burned by shipping products with a defective subsystem that locked up the entire device due to this. An I2C thermopile went out, and the master comms went into an infinite loop waiting on an ack. That was not a fun recall.
This slams the rabid "goto is always bad" yammering! [An empirical study of "goto" in C code](https://peerj.com/preprints/826v1.pdf) - 2015 paper - [250KB pdf] 
Ordering those two books now(Living in Sweden so will take a while...). Which one do you suggest i start with? TLP or Unix Network Programming?
nvm found a post.
 for (i = 0; i &lt;= 10; ++i) { Because of this line. I think you want %f for printf and %lf for scanf, when using doubles. Not sure if %lf is valid for printf.
&gt; Not sure if %lf is valid for printf. It's fine. If you aren't sure about something, look it up before you give advice.
One advantage I can see is if you wanted to be able to run the same binary on different machines with different amounts of memory. In that situation, you have to 'dynamically allocate' your structures to correctly use the memory you have at hand. Since the code could run on one of several machines, you can't make an assumption about the memory size before-hand. It also doesn't really define 'initialization' very well. If your program has multiple threads, for example, it could have several initialization points that it encounters, and use dynamic memory to get a different amount of memory each time. I'm not *really* sure if that's allowed though, since this list isn't very specific on the details.
&gt; scanf("%i%i", a, b); The `scanf` function requires *memory addresses* specifying where it should store the values it reads. So you should be passing it the *addresses* of the variables `a`&amp;nbsp;and&amp;nbsp;`b`, not the *values* of those variables. You need this: scanf("%i%i", &amp;a, &amp;b); Turn on all warnings in your compiler, and pay attention to what they say. A good compiler should warn you about mistakes like this. $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o johndoe johndoe.c johndoe.c:5:19: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat] scanf("%i%i", a, b); ~~ ^ johndoe.c:5:22: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat] scanf("%i%i", a, b); ~~ ^ johndoe.c:7:19: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat] scanf("%i%i", c, d); ~~ ^ johndoe.c:7:22: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat] scanf("%i%i", c, d); ~~ ^ johndoe.c:5:19: warning: variable 'a' is uninitialized when used here [-Wuninitialized] scanf("%i%i", a, b); ^ johndoe.c:3:10: note: initialize the variable 'a' to silence this warning int a, b, c, d, numerator, denominator; ^ = 0 johndoe.c:5:22: warning: variable 'b' is uninitialized when used here [-Wuninitialized] scanf("%i%i", a, b); ^ johndoe.c:3:13: note: initialize the variable 'b' to silence this warning int a, b, c, d, numerator, denominator; ^ = 0 johndoe.c:7:19: warning: variable 'c' is uninitialized when used here [-Wuninitialized] scanf("%i%i", c, d); ^ johndoe.c:3:16: note: initialize the variable 'c' to silence this warning int a, b, c, d, numerator, denominator; ^ = 0 johndoe.c:7:22: warning: variable 'd' is uninitialized when used here [-Wuninitialized] scanf("%i%i", c, d); ^ johndoe.c:3:19: note: initialize the variable 'd' to silence this warning int a, b, c, d, numerator, denominator; ^ = 0 8 warnings generated.
thank you!
Will do. Thanks
hmm interesting ill try it out, im thinking an if else statements w/ return 0;
Inputchar is uninitialized. You're storing characters at an undefined location. Use malloc to get yourself some memory at which to store the input
Turn on all warnings in your compiler, and pay attention to what they say. $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:3:5: error: 'main' must return 'int' void main (void) { ^~~~ int program.c:8:8: warning: implicitly declaring library function 'printf' with type 'int (const char *, ...)' printf("Enter a sentence&gt;\n&gt; "); ^ program.c:8:8: note: include the header &lt;stdio.h&gt; or explicitly provide a declaration for 'printf' program.c:11:27: warning: implicit declaration of function 'getchar' is invalid in C99 [-Wimplicit-function-declaration] inputChar[x] = getchar(); ^ 2 warnings and 1 error generated.
Thank you so much. It now works exactly as expected. I found a video explaining how to use malloc and implemented it into my code. I am very close to hitting my size limit and I still have more to add to the program but your advice definitely helped. &gt; #include&lt;stdio.h&gt; &gt; &gt; #include&lt;stdlib.h&gt; //included to use malloc &gt; &gt; void main (void) { &gt; &gt; char* inputChar = (char*) malloc(1*sizeof(char)); &gt; int x=0; &gt; int y; &gt; printf("Enter a sentence&gt;\n&gt; "); &gt; &gt; do { &gt; inputChar[x] = getchar(); &gt; x=x+1; &gt; } while (inputChar[x-1]!='\n'); //inputChar[x-1] is used to check &gt; //if the last character is the return charcter &gt; x-=1; //used to omit the return as a counted charcter &gt; &gt; printf("%i",x); //This statement prints the value &gt; //of x to verify its counted each character &gt; &gt; printf("\n&gt; "); &gt; for (y = 0;y&lt;x;++y) { &gt; printf("%c",inputChar[y]); //this will output what the user has typed &gt; } &gt; printf("\n"); &gt; while(1); &gt; } I'm getting two warnings but it seems to work perfectly. *** WARNING L16: UNCALLED SEGMENT, IGNORED FOR OVERLAY PROCESS SEGMENT: ?PR?_INIT_MEMPOOL?INIT_MEM *** WARNING L16: UNCALLED SEGMENT, IGNORED FOR OVERLAY PROCESS SEGMENT: ?PR?_INIT_MEMPOOL?INIT_MEM
It won't work as expected if you enter more than 1 character because you've only allocated room for 1 `(1*sizeof(char))` What size limit are you referring to?
the problem persists even when i start a new project. http://imgur.com/gxfhqUN
I've tried it with full sentences. I'm not sure if its due to the compiler I'm using. I originally wrote it to allocate enough space for 20 characters then when I saw that it worked, I intentionally went over 20 characters to see if it would still work since I won't know how long the sentence will be that the user enters. When that worked I assumed I could cut it down to 1 character to save space. My compiler has a size limit of 2000 bytes for a given program.
You can't put statements outside of functions. Your `printf("test");` statement should be inside the `main` function. And take out `system("pause");` completely. That is nonportable and unnecessary. If you are including it because your IDE is not configured to keep the console window open after the program terminates, then reconfigure your IDE. Don't put ugly hacks into your code to compensate for the fact that your IDE is badly configured.
Correct. Although I would say you got unlucky ... if it had crashed then you would have known right away that something was wrong.
Haha very true. I've adjusted it to (50*sizeof(char)) and noticed that it doesn't affect the size of the code so hopefully the user doesn't encounter any issues when running the program. Thank you again for your help.
&gt; 'main' must return 'int' Is it possible this is due to the compiler? I'm not receiving this error on my end.
Codding, or to cod, to make fun of, to tease, or to play a trick on. :D 
Codding, or to cod, to make fun of, to tease, or to play a trick on. :D 
If you're using `clang`, why not just use `-Weverything`? 
Since this doesn't allocate more memory as needed, wouldn't it just make more sense to use a regular fixed size buffer instead? char *inputChar[100]; 
Everything is inherited except as specified.
Because I'm used to gcc, I guess, and I didn't know `-Weverything` existed. Thanks for the tip.
I agree but i didnt want to change OPs code much. Just trying to help fix whatever issues OP was running into. But then again forgot that OP was new to C and should learn proper ways of handling c strings. Only reason to use malloc is to create dynamic cstrings. Other than that, a constant array is best, with the constant being the max length of chars the system will allow. 
If the answer a string or a word? 
Can you show us your source code so we can understand how you use `scanf`?
From the compiler warnings, I'm guessing you're using some compiler by Keil?! If not, you can ignore this post ;) If this is an embedded environment you should _not_ use malloc, but instead use a fixed array. unsigned char inputChar[20]; // adjust size as needed Malloc has some serious issues if you're not on a system with a decent OS and lots of RAM (fragmentation...). If you still want to use malloc and I'm right with the Keil compiler+libs, you should call init_mempool() before allocating memory, to set up the memory pool correctly.
To clarify : you have several different threads; each of which needs to read data from some files. And sometimes different threads will need to read from the same file at the same time. The question is should you have 1 thread doing all I/O, or should each thread be responsible for its own. The former is a lot simpler, each thread is in control of its own I/O. As you allude to at the end, each thread will need to open its own handle to the file and specify FILE_SHARE_READ to allow other threads to access the same file at the same time. If you go with the latter model, look into IO completion ports - they're designed for this purpose. Basically you associate all I/O with the same completion port, and have all the threads in the pool wait on the port. When I/O completes, the O/S chooses a thread to handle it. There's not going to be much of a difference in speed between the 2 methods. By the time I/O gets through the filesystem everything looks pretty much the same - requests for blocks are sent to the disk and they're completed in the order the disk driver or hardware decides is best. Which to choose depends more on the purpose of the threads than performance - does it make sense for a thread to understand requests to process specific files, or to understand requests to process blocks of data regardless of the file it came from? 
C has a lot of rules that state that things are allowed, but induce undefined behavior; this is one of them. So in the case of `main` and other functions that *should* return values, you’re perfectly allowed not to return a value, but the compiler’s allowed to leave whatever garbage data it wants as the return value. Maybe zero, maybe a fixed value, maybe the last return value from a function you called, maybe a pointer value, anything. Since `main` should normally return 0 and programs that call it may be expecting this, just letting `main` fall through means the calling program has no idea about whether your program finished correctly. `void main` is a C++ feature, and you should never use it in C. Also, you’re grabbing characters from `getchar()` unsafely. It *can* return a `char`-compatible value from 0 through 255, but it can also return a −1 (`EOF` from `&lt;stdio.h&gt;`) if there’s no more input. That means that just dumping it into a `char` loses you that information; (a.) you have no idea whether half of your resulting string is invalid, and (b.) if you hit EOF, you’ll get infinitely many −1s coming out of `getchar()`, which will overflow your array and bork your program badly. What you should do is something like this: char inputChar[ARRAY_SIZE]; int ch, x = 0; while((ch = getchar()) &gt;= 0 &amp;&amp; ch != '\n') inputChar[x++] = ch; This - reads from `getchar()` into temporary variable `ch` and then immediately tests that value twice; if we’ve hit EOF or a newline, we’re done. - If not, then we dump `ch` into the array at position `x` and then add one to `x`. If you want to make it remotely safe, you should also put some size limit on `x` since you have a finite buffer size and it’d be easy to blast past that. (Doing that is known as stack-smashing out in the wild, bad idea to let it happen.) while((ch = getchar()) ...) { if(x &gt;= ARRAY_SIZE - 1) { fprintf(stderr, "error: input is too large to fit in buffer (max. %u bytes)\n", ARRAY_SIZE - 1); return 1; /* Indicate error to shell or caller */ } inputChar[x++] = ch; } inputChar[x] = '\0'; /* which is why it's ARRAY_SIZE - 1 and not ARRAY_SIZE */ Also, never ever ever just leave a loop with a semicolon after it like your `while` at the end there, and especially a `while` since it just looks like you missed cleaning up the end of a `do`/`while` loop. If you want a “forever” loop (one of the rudest things your program can do, BTW), do `for(;;) (void)0;` or something similar. `for(;;)` is the “forever” part and `(void)0` is a way of explicitly saying/doing nothing that the compiler won’t complain about, and that makes it clear to the reader that the spin is intentional. Although you should really be using a setup where your terminal doesn’t just die when your program finishes anyway, ’s like programming in Notepad.
Nothing you do in `malloc` will affect the size of the code noticeably. The call to `malloc` happens when your program runs and not before (barring undue compiler optimizations), so you could have a `malloc(1000000)` in there and your code size wouldn’t budge an inch.
Yeah. I want to get decent in C before doing any other language.
Have you gone through it by hand?
Source: http://www.iso-9899.info/n1570.html#6.5.7p4 * The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. * If E1 has a signed type and nonnegative value, and E1 × 2E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined. 
Ok so let's go through this line by line, from y = (int)... y = shifts your input value 'n' places to the right. You'll notice some bits will drop off the end, an underflow. This is fixed in the next line. z = takes your input, x, and shifts all the bits to the left '32-n' bits. If you don't understand why '32-n', write it down and look what happens. This puts the bits that fell off the end on the previous line as the MSB bits, effectively rotating them from one end to the other. A rotation operation. g = runs an OR operation on y &amp; z, giving you the final value of your rotation.
You haven't got a `char[]` anywhere in your code. `*` is different to `[]` .
`void main` is ill-formed in C++.
Convince yourself that "rotate right by N" is the same as "switch the last N bits with the first (32-N) bits"
Imagine the bits as written down on a strip of paper. Now cut off 1 bit on the right, and move that piece to the left. That is bit rotate right.
Sounds like a good job for a shell script that does some fiddling with `sed` or `awk` and then calls `gnuplot` to do the plotting. Anyway, I suggest you to start with something else, this task is a bit too complex for someone who has never programmed in C before.
Would you say it's useful for someone who's already done a few projects in C but want to go a more formal route with learning?
i would say so BUT i'm not a CS major so I'm cant speak for pro C programmers. I'm in the science/engineering field so I happen to use C quite a bit on embedded systems. check out this link at stackoverflow. they talk about some recommended books. http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list if you look at the third answer, another reviewer recommends it as well and you can read his perspective on it. there is a html version of the books on Zed's website. i would just check it out and see if you like it. http://c.learncodethehardway.org/book/
 for(i=0;i&lt;*(s+i)!='\0';i++) You don't want the `i&lt;` in the middle Implement this portion as your own strlen function, then you can unit test it.
i thought so already but i didn't think of the stack, thanks for explaining why!
*Converting* the function pointer to a pointer to a function of different signature is legal, but calling a function pointer with incorrect signature is undefined behaviour (cf. ISO 9899:2011 §6.3.2.3 ¶8). In practice, the kind of conversion you attempt is likely going to work when the exchanged function signatures do not cause a change in memory layout and as return types of type `int` or smaller are passed in a register, this should be fine. However, you should not rely on this behaviour as it may stop working in the near future when compilers get smarter.
yes it worked on several architectures, but i can imagine if there was a difference in size for a void* compared to int* it wouldn't since it will smash the stack as u/Meefims pointed out if i understand correctly. Thanks for the reference!
[This article](http://wiki.osdev.org/System_V_ABI) and [this specification](http://www.x86-64.org/documentation/abi.pdf) might be useful for you.
indeed, thanks for the links :)
I'm currently learning C through K&amp;R. If you want a beginners view on it, I can read this next. It seems to be the next logical book. I would get to it in 2-3 months.
I agree with this 100%
`r[i]` is not *function notation,* it's called *array subscription syntax.* You can choose not to use it, but doing so bears no advantage and makes your code harder to read for anybody else.
Thanks for the link, downloaded. Will definitely check out!
Honestly after reading that post and Zed's rebuttal, along with Tim's re-rebuttal, all I can conclude is that they each have very different priorities when it comes to learning, and that neither of them seem to be able to interact in a professional manner. The one point that I agreed strongly with is that Tim does not seem to have a solid understanding of how teaching-oriented material should differ from reference-oriented material. Zed has taken the top-down approach to teaching in LCTHW, which conflicts with Tim's position that a bottom-up understanding is the only way to go. I don't *personally* agree that Makefiles or an explanation of the responsibilities of each component in a compiler are effective starting points when introducing C to someone with a background in interpreted languages.
To be honest, the sort of jobs that are a good fit for an inexperienced freelancer aren't usually in C. I'd suggest finishing the C course and then learning JavaScript. It uses C-style syntax so you should be able to pick it up fairly quickly, and combined with some HTML could find you some decent entry level front end gigs. I'm not disparaging C, it just isn't usually used for entry level positions.
I'm not sure how you came away thinking that Zed and Tim are equally unprofessional. Tim's blog post is snarky in parts, but the majority of his criticisms are quite valid. Zed's rebuttal, on the other hand, is absurd. Instead of talking about the content of Tim's post, Zed spends most of his rebuttal criticizing Tim. Tim is not a teacher. Tim is arrogant and hubristic. Tim is intellectually dishonest. Tim lacks qualifications. Tim is a beginner. Etcetera. Even if these allegations were true, so *what*? I don't care if Tim is an imperial stormtrooper who eats babies. All I care about is whether his criticisms are valid. There's only *one* criticism that Zed addresses head-on, and that's NULL-terminated strings. Zed gives an example of how Tim's `copy()` could fail if the source string was corrupted. First, I know of few programs that work correctly when their data is corrupted. Second, Zed's original criticism of Tim's `copy()` was wrong. That should tell you something about Zed's C expertise. He didn't even take the time to compile and run his example code. Someone else had to correct him. This is a *huge* red flag. If Zed can't correctly refute this example, what are the chances he'll write a quality book on the subject? 
I don't know what your deadline is for this project but I could probably do this for you in six to eight months. 
Embedded help screens and a built-in configuration in case the normal configuration file can't be found. I only quoted the shorter of the two strings (the other one is 20,857 bytes in size). 
I absolutely agree. You need the basics of one to understand the other.
The fact that Tim Hentenaar has the Confederate flag as his twitter profile pic speaks volumes about him. I doubt LCTHW is more incorrect that any other learn C book. The focussed criticism of LCTHW is a result of Zed's crime of saying mean things about the K&amp;R book rather than the actual content.
Is it so hard to separate a person's politics (however distasteful) from technical arguments they make? I'll repeat what I said in an earlier comment: &gt; I don't care if Tim is an imperial stormtrooper who eats babies. All I care about is whether his criticisms are valid. So far, nobody in this thread has addressed the technical arguments. People have criticized tone, attitude, political beliefs, teaching style, and more... all of which are orthogonal to whether or not the book is an accurate and comprehensive guide. 
I just read this. Its the best book on C for a beginner imo. It goes into more detail than K&amp;R. It is well-written and has exercises at the end of each chapter to refresh your memory.
Saying it's distasteful is like calling Kim Davis "a bit of a dick," but I think the criticism of the book itself was rather well-formed. I do agree with what Tim said about Zed and K&amp;R, but besides that, I wouldn't want to start learning programming with this book - for all the reasons Tim listed. To each his own, I guess? To me, the criticism is valid, but there are probably plenty of people who learn just fine with Zed's book.
Can you please copy-and-poste output as *text* instead of linking to images? And, what is your problem?
Indent every line of your code with four spaces so that Reddit formats it properly as code.
The Problem is, that A_approx_big and A_approx_small are wrong. They should be added in the end, than devided by 2 to get the approx. real Area of the circle. But my A_approx_big does approximate the real Area on its own. I dont need the A_approx_small for my code - but I have to use it, because my Prof. says so.. :( Here the Output: What is the Radius of your Circle? 12 [Input via scanf] I understood: 12.000000 Amount of triangles: 4561 [Input via scanf] //precision /* Deg and rad output is correct and not important here*/ Big: 452.389413660531 Small: 113.097353415133 Total: 282.743384 -------- Which is wrong, since the the real value should have been 12 * 12 * PI = 452.3893, which is almost the same as my A_approx_big. The problem is somewhere in the function for A_approx_big and A_approx_small 
I think your formula for both `A_approx_small` and `A_approx_big` is wrong. How exactly do you try to compute these areas?
Most likely your problem is this: int height[n]; Unless you're using C++ or a very specific version of C, that is unlikely to be supported. You should use malloc() to assign memory to height[].
A_approx big currently looks okay to me (included below, not sure if it's changed). It's not well commented though. A_approx_big = (r*tan(rad / 2)*r) *q_tri; A_approx_small is definitely wrong, and does not appear to be using the correct trig function. /u/zjk758, have you tried using a smaller number of triangles? That's when you would see the most impact. Try numbers like 4-10.
Yeah, I tried - it "should" give me a more precise A when I use a higher number of triangles.. The Problem is that it seems like as if the numbers of triangles is of no importance in my equations.. It does not affect anything. What formular could I use for A_approx_small? I thought it would be the same as A_approx_big, just with half the radius :8
How much do you know about trigonometry? Do you know what the tan() function actually does?
`A_approx_small` should be the surface of that square if I understood the question correctly, so `r*r*(4/sqrt(2))` and `A_approx_large` should be the sourface of the large square, so `4*r*r`.
That's the correct formula for the large estimation, your problem is in the smaller estimate. Hint: You should not be using half the radius for anything.
I don't think either of those is correct. The area of the larger square should be `2*r*2*r = 4r^2` (calculate the area of the square instead of the triangles). The area of the smaller square should be `(r/2)*r*4` (4 triangles with base r and height r)
the smaller triangles do not have a height of `r`. Where do you get that from?
Okay, that's a point.
There are many different ways to do that, read any introductory text on stack smashing or exploitation for explanations.
I can't give you the answer entirely, but I can help you get there. The function strcpy() is not very secure because it will keep writing from argv[1] into buf until it sees a null character in argv[1]. Now here's the issue...once you pass in something to argv[1] that's greater than 699 characters, you're going to start overwriting various things on the stack, such as the score. The exact number of bytes, and what those bytes are, will vary, and I will leave that up to you. But that's the basic premise. Good luck!
For `score`? Not easily in this case. But if it would be: char buf[700]; int score = 0; Then simply providing 703-characters (for 32-bit `int`s) long input will overwrite it.
Wow! Thanks alot to everyone! I kind of solved it :D Had to just write all the stuff down.. I assumed at first that I could use pretty much the same formular for both, which is not true, since every side of the triangle changes when we change the angle. So I solved it like this: http://pastebin.com/yUeFqJLY Its a very bad program I wouldnt program anything like this.. it need about 150k triangles to be somewhat accurate.
Your small estimate isn't multiplying by `q_tri` and it looks like you changed the large estimate so it isn't correct. Does your program work as expected when you pass in 4 as the number of triangles?
Your old large estimate was fine, so go back to that. For the small estimate, try looking at it this way: If you align the triangle in the same way as in the large estimate, you will have a right-angled triangle entirely within the circle. Using the variables `hyp`, `opp` and `adj` for the relevant trig functions, you should see the following (I hope this works). B hyp / | /s | opp A ----C adj Point A is the centre of the circle, point B is along the circle itself, and point C is the intersection of a horizontal line from A and a vertical line from B. I'll use `s` to represent `rad/2` The area of this triangle is `0.5*base*height`. You know that base is `adj` and height is `opp`. That leaves you with `Area = 0.5*adj*opp`. You also know that the length of `hyp` is `r`, since that's a line from the centre to the edge of a circle. You should be able to come up with simple formulas for the values of `adj` and `opp` based on the variables `r` and `s`. Just plug those into your area calculation and simplify to find `Area = f(r, s)`. Then replace `s` by `rad/2`, multiply the area by 2 (because you divided the triangle in half) and again by q_tri (to cover the full `2*pi` radians of the circle. 
As the number of triangles increases, both the correct upper bound and the correct lower bound approach the real area. Your output seems to show that your formula for the upper bound is approaching the real value so you can provisionally take that to be correct. However your lower bound is nowhere near the expected area, so you can be certain your formula for the lower bound is not correct. I'm not sure how you derived your current formula but go back to Figure 2c and redo your derivation for the area of that triangle. As a hint, the answer will use `sin()` and `cos()`, but not `tan()`. Also you can simplify your code a bit by avoiding repeated operations. Both limits have a term `q_tri*r*r` and use `rad/2` so you can do: double half_rad, N, A_approx_big, A_approx_small; half_rad = pi / q_tri; N = q_tri * r * r; A_approx_big = N * tan(half_rad); A_approx_small = /* left as an exercise for the reader */ ; return (A_approx_big + A_approx_small) / 2; 
Well, put in the for loop, printing out the array obe element at a time in main(). Then once that's working, put it in the printIntegerArray(), and put the function in your main. One step at a time. Your array is being filled correctly, right?
I never used K&amp;R. I got through the first chapter and there are a couple challenges that I just went "damn, that's hard" and other people kept slamming me with "That's super easy! Pooh! You'll never learn C!" so I dropped it and moved to other books. See Exercise 1-13 and 1-14. Nothing inherently impossible about the counting lengths of words (or occurrences of characters), but printing the histogram was completely lost on me. Especially to do with what had been taught by that point. Maybe now it'll be easier, having used other books? I guess I can always skip some of the challenges. 
21st Century C comes to my mind as a title on that topic.
I remember the first time I read K&amp;R2 I didn't like chapter 1 because for a beginner programmer (as I was then) knowing only what chapter 1 teaches, some things become very difficult. Exercise 1-13 I think is a good example of that. It's possible to solve it with only what was taught so far in the chapter (however with considerable amount of "buts", "howevers" and restrictions -- the only way I *now* think of how to do it isn't something I'd find pretty or even would do), but what I have in mind is not something intuitive for a beginner. In the 80's and 90's, maybe the situation was different. Exercise 1-14 isn't obvious, but you should be able to do it, I guess. I don't remember exactly what chapter 1 teaches up to that, but there is somewhat of a hint on how to do Exercise 1-14 in the "counting digits, white spaces and others" program (see how the ndigits array is used). I also remember not having an issue with (actually rather liking a lot) chapters 2 and on. If you're a beginner in the programming world, you can try another C book. You surely can go on and study from K&amp;R2, but it some people find it difficult indeed. You can check other books in here (http://www.iso-9899.info/wiki/Books#Learning_C) like C Programming - A Modern Approach (http://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504/).
Well, seeing as the books I went through in the past were 2x the length of K&amp;R and C Programming - A Modern Approach *combined* I might just go ahead and go through K&amp;R then consider going through CP-AMA.
I intend on learning other languages, as mentioned. Just at the moment focusing on C.
Right. Maybe I explained myself wrong then. I didn't mean learning other languages alongside learning C. I meant learning other CS topics (or even Math topics, or maybe even other things) while learning C. SICP uses scheme, but it's mostly an introduction to computer science course. It doesn't have to be SICP. A linear algebra course will do as well (there are courses on linear algebra out there focused on its applications). You can try learning introduction to mechanics (which is the usual introduction to physics course), and attempt to simulate events in the computer with what you learn from studying C. The advice was "a parenthesis". It had nothing to do with C. It's just that it's a generally good advice.
That surely can work well as a course on learning C. Good luck.
I started going through an algorithms book before my little hiatus. Probably going to start that over from the beginning (Cormen, for anyone wondering).
Seriously, K&amp;R? No. It's a great historical reference, and we've all read it back to front, but it's dated. K.N.King or Harbison/Steele. Much better for learning.
Take a look at the first strncat call, because it's representative char slots[slot_number]; if (slot_number==10) strncat(slots[10],"o"); And have a look at the [man page](http://linux.die.net/man/3/strncat). I assume you actually meant `strcat` because that's what you use everywhere else and you haven't provided enough arguments for `strncat`. Either way, both functions are documented in that link. Now let's look at the problems. &gt; char *strcat(char *dest, const char *src); &gt; char *strncat(char *dest, const char *src, size_t n); Oh, in both cases `dest` and `src` are of type `char*`. Your second argument ("o" is acceptable because it's equivalent to a `char[2]` which degrades to a `char*` Your first argument, however, has type `char`. This is what the compiler is warning you about. `slots` can be used as a `char*`, but `slots[x]` is a plain `char`. Carrying on... &gt; The strcat() function appends the src string to the dest string, overwriting the terminating null byte ('\0') at the end of dest, ... Hold on here. Even if you were passing in a pointer to something in `slots`, that argument would not be a string. In C, a string is a 0-terminated array of characters. Since you haven't initialized `slots` to anything, you don't know that it has a null byte to find. It actually looks like your whole `if...else if...` block could be replaced with the following: if( slot_number &gt;= 0 &amp;&amp; slot_number &lt; 21 &amp;&amp; slot_number % 2 == 0 ) slots[slot_number] = 'o'; The bottom two compiler errors are because of this: int position(int balls) ... return slots; position is defined as returning an `int` type, but you're trying to return a `char*`. Furthermore, `slots` is a local variable so once you've returned from this function it will have an undefined value. It's not clear to me what you're trying to accomplish with this, so I'm not sure how to fix it. Some other issues: for (ball_number=0;ball_number&lt;=balls;ball_number++) ball_number++; You're incrementing ball_number twice on each loop, this is probably not intentional. printf("-10:%c\n -8:%c\n -6:%c\n -4:%c\n -2:%c\n 0:%c\n 2:%c\n 4:%c\n 6:%c\n 8:%c\n 10:%c\n"); `printf` requires an argument for each `%` format specifier in the format string. You haven't included any. leftOrright=2*rand()%2-1; You're not recalculating this within the loop, so `slot_number` is effectively going to be a fixed value based on `balls`. Also, this same code is in the `ones()` function, which is never called. int position(int balls) You never call this function either. int main() You're not returning an int from main. Technically this won't cause an issue (the standard says it will assume 0), but you should be aware of it. There's definitely some more work to do, but focus on fixing these things first.
Thank you very much. I have fixed the silly errors you pointed out, but am struggling to understand exactly how I would go about concatenating "o" into an array. After looking at the link you showed I am realizing I do not understand pointers that well. From what I am gathering is in order to use strcat I have to make a pointer to slots? I changed position to just deal with ints because that is all I need from that function in particular. Also I am having trouble understanding how to use the output from a function as an input for another. Would that be the reason for function prototypes? What I am trying to do is get a random direction for each drop. This should tell me where a dropped ball will end up. That position should tell me in which location of the array to put an "o". This all seems a lot simpler in python or java. My thoughts are a bit scattered so excuse the lack of cohesiveness.
It's not all that C specific, but have you read Microsoft Press's Code Complete? Some handy tips for not tripping over yourself as a project scales up. I think they do use C in the book (it's been a while), but the tips are more general. The Joel on Software blog has some good stuff, too. Design patterns tend not to be language specific. The big gotcha with C is that any OO is not a formal part of the language, so it can take a bit of creativity to use object-centric patterns. I agree with whoever said that looking at other successful large projects is a good idea, and would suggest that the BSD source codes tend to be cleaner and easier to follow than their Linux and GNU counterparts.
First of all, you should probably come up with a rough design sketch for how you think your program ought to come together. Figure out some natural dividing lines in the functionality you need to create and how those parts need to interact with one another. How will your program interface with the world? A GUI, a command line, just file or network I/O? What sort of processes are going to be going on inside? You may need to write some throw-away code to see whether some of the design ideas will work. Don't be afraid to throw it away before it gets too big, or maybe it'll turn out nice enough that it can be cleaned up for your real program. As part of your design process, at least come up with some rough notes and diagrams that capture your design ideas. Use some UML-style diagrams if you're familiar with them and they fit, or just some boxes and arrows if that makes more sense for you. As for actual code ideas, I second the recommendation of C Interfaces and Implementations, and I'd also recommend looking at the style enforced by the [CMod](http://www.cs.umd.edu/projects/PL/CMod/) tool, which is used by the [vsftpd](https://security.appspot.com/vsftpd.html) code base. Do unit testing of your code from the beginning; I use [cpputest](https://cpputest.github.io), which is designed to work with both C and C++ code. Also start from the beginning to document your code interfaces with something like [doxygen](http://www.stack.nl/~dimitri/doxygen/). If you don't start doing both of these from the beginning, it will be only get harder to do a good job with them. In addition to unit testing, as soon as you have any bits of functionality in place, write test programs that exercise the APIs you designed together in the way you imagined your final program to work. This will help you find where your interfaces are weak and need to be reworked or extended before you get too far along down a bad design path. Get a solid build system in place early on that will track build dependencies properly and automatically run your tests and documentation builds. CMake, tup, or meson might be good choices. If you use regular old GNU Make, do *not* use recursive makefiles and make sure you have your compiler generate and track all the dependencies. Use a source control mechanism religiously. This will give you the freedom to tinker with design ideas without fear of not being able to get back. It will also let you mercilessly delete code that's not being used. Don't let dead code hang around in comments or preprocessor exclusions. In fact, use preprocessor conditionals as little as possible; they turn your C program into a family of related and interleaved C programs that may or may not all work. When you have any test program written, run it under [valgrind](http://valgrind.org) and the [clang static analyzer](http://clang-analyzer.llvm.org) and similar tools that will help you find the bugs your unit tests didn't catch. Don't fool yourself into thinking you won't find any; you'll find lots. You might consider embedding a scripting language in your application for prototyping parts of it or just for flexibly gluing the parts written in C together. The [lua](http://www.lua.org) language was designed for this; it adds a tiny bit of code to your program and lets you mold the language to your needs rather than coming with a lot of baggage. It's also a very clean, well-designed C program that's worth looking at as an example. Unless you're writing a game, I'm not sure a game would be the best example code to draw your design from. They tend to have very different performance constraints than other programs and also very different lifetimes/maintenance needs. Hope these tips prove helpful to you!
King is more gentle to the reader than Harbinson/Steele. King also has exercises at the end of the chapters. King is a tutorial/reference book whereas Harbinson/Steele is just a reference book.
&gt; am struggling to understand exactly how I would go about concatenating "o" into an array You don't concatenate into an array, you concatenate two strings. You can't do that if one of your strings (in this case, the destination) doesn't contain anything. Given that you never call `position()` in your code, I'm still not clear on what you want it to do. Can you provide some sample inputs into the function (values of `balls`) and what you'd like the results to be? Either what `slots` should contain or what integer you would want to return? If you can write the same function in python or Java it's fairly easy to convert that one function to C. Feel free to try that, and I can help you with the conversion. &gt; I am having trouble understanding how to use the output from a function as an input for another. Exactly the same as in Python and Java. If you have two functions `add` and `getnum` you can call `add( getnum(), getnum() )`
I wouldn't skip any challenges. You learn a lot from challenges that are difficult. The harder it is for you the better you get from having worked through the problem. Some of the problems in K&amp;R I wrote and rewrote until I figured it out. If you find them too difficult, break them down into smaller steps. &gt;"That's super easy! Pooh! You'll never learn C!" You'll never learn C if you give up. If you stick with it and work through hard challenges, you'll get better at it.
I've been working through K.N. King's book for the past year or so (in my spare time, and doing every single exercise/programming project), and it's very comprehensive. I had the experience of starting with K&amp;R, getting stuck in chapter 1, and then switching to this book. But I haven't read Harbinson/Steele, so maybe it's pretty good too. I will say that CPAMA is pretty long, but the length is worth it for getting a complete understanding.
It's good to point out that H&amp;S is a reference. As such, it's unlikely to be good place to learn C (not that one can't use to do so).
I am aware that VLAs are supported in C99. The OP didn't indicate whether or not he was using C99.
Omitted `return` in `main()` is correct in C, there is implicit `return 0;` since C99. I don't see why you would describe something that is "accepted without complaint only by a handful of C++ compilers" as "a C++ feature". There's probably more C code that uses `void main` than C++ code. Moreover, the C standard allows `void main()` as an implementation-defined extension, however the C++ standard specifically prohibits any return type except for `int`. I guess the Stroustrup code you refer to was written before the first C++ standard was published. 
By reading code :-) e.g. SQLite is widely considered to be "well written", or maybe Lua. Next step is to write code - the only source of knowledge is experience (yada yada). Might help if you can find a pet project to have clear(er) goals; open ended ones (how will you judge whether you _really understand X_) lack the joy from having achieved something.
This is a very useful bit of functionality, actually. And it's not just width specification, you can also specify which argument to use for the format specifier. Instead of each specifier and argument being taking in order, you can flip it around or even reuse arguments: printf("%1$d %1$05d\n", 42); I believe this is a GNU extension, though. The one bit that is standard is just a simple `*`, which still lets you get the width dynamically, but you can't specify which argument to use (it just takes the next one in sequence).
&gt; I believe this is a GNU extension, though. The *&lt;num&gt;$ style in general is an extension from the single UNIX specification, but you may be right with you hypothesis, because the manpage does not specify this any further.
It's in POSIX but not in standard C. Use with caution if you can't assumr POSIX.
Positional arguments [are POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html). However, what a lot of people don't realise is that you can't mix and match, either all format specifiers have to specify an argument index, or none of them.
Another thing is that there can't be gaps in the arguments you want to fetch due to the way `stdarg` works. This means, something like `"%1$d %3$d"` is not valid even though it appears to be very useful for localizations where one item is just not required.
2 words: Id Software. Doom and Wolfensteien 3D source codes are lovely. Like you pretty much said, the only real way to learn a programming language is to write programs in it. So, in addition to the fine reading material mentioned in this thread (K&amp;R, etc), and trying to read other existing source code, writing lots of smaller and then larger programs is going to be key. 
King is more educational. H/S is the reference when you have questions about something in King (and just to read after). Both are great, well written, easy to comprehend and I still use both as references.
You found the gold mine! Best book for learning C in my opinion.
I find them very complimentary. Each covers a few things the other doesn't. Work through King, and if you want a clarification (which is pretty rare), you'll probably find it in H/S.
Having gone through King in the past it's coming pretty easy to me. I could have it done in a week or so and probably be back where I was in regards to knowledge. Looking at H/S it looks like it'll be a good book as well. Shame neither of my PDFs are searchable; I do like searchable PDFs.
In C99, 6.9.1.12: “If the `}` that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.” So only “correct” in the sense that a compiler will accept it without error, but not “correct” in the sense that it should ever be used. (I just tested both `void main` and `int main` with fallthrough and the results were identical, so it definitely doesn’t just return 0. That *was* added in C++, though.) W.r.t. `void main`, it’s implementation-defined whether it’s allowed in C, which isn’t really any more “correct” in practice, just non-standard-violating. Defining `main` as `void` will, in most cases, get you the same result as just not returning anything, which is undefined behavior. (The C99 rationale also states that the “other implementation-defined” declaratons for `main` were to permit other arguments, more than change return value, although that’s nonnormative too.) Stroustroup’s `void main`s were in older versions of a book and were mostly fixed, but some `void main`s lingered into later versions (post-C++03, I know, possibly post-C++11 too? I can probably dig ’em up). It was also dirt-common in C++ code before 2003—I had a Borland compiler whose documentation recommended it, in fact—whereas C-wise I’ve only ever seen it in embedded C code for freestanding (i.e., thoroughly unhosted) programs where it’s expressly permitted by the compiler. Perhaps “artifact” would’ve been a better word? But then the same argument would’ve ensued.
Just a heads up, you need to double newline to not include the quote from the rest of your text. It was confusing at first when I thought you were just quoting his post without any comment.
You're overlooking C99 5.1.2.2.3/1: &gt; a return from the initial call to the `main` function is equivalent to calling the `exit` function with the value returned by the `main` function as its argument; reaching the `}` that terminates the `main` function returns a value of `0`. Then you wrote: &gt;in C [...] Defining main as void will, in most cases, get you the same result as just not returning anything, which is undefined behavior. Actually it is implementation-defined what the behaviour of `void main` is, as you pointed out in your previous sentence. 
We need more information. What you're saying is not nearly detailed enough. My engineering professor showed us a motor. How did the spark plugs rotate?
You're not asking anything. Your professor could have changed the font colors with anything. Powerpoint, Word, a sharpie? The question is nonsensical because something's missing. What are you trying to accomplish? What is a 'card'?
It's spelled *Wolfenstein*, just if someone tries to find this.
* Never ever use `gets()`, that function cannot be used safely. Every use of `gets()` introduces a bug into your program. It's so bad, `gets()` is the only function ever removed from the C standard. * What is the type of target? I think you forgot to specify it. Right now it defaults to `int` for reasons to complex to explain right here. * What is the type of `health`? `printf` expects a string for its first argument, if `health` is an integer, this causes your program to crash. Read a C tutorial or your system's manual on how to use `printf()` correctly. The same applies to `energy` and `weapon`.
It is a pleasure to me!
 else { (*q)-&gt;back-&gt;next; (*q)-&gt;back=temp; } You're not assigning `(*q)-&gt;back-&gt;next` to anything, so you won't be able to find a second entry when traversing. else { (*q)-&gt;front-&gt;next; } Same thing here when you're popping items. data_fetched = temp-&gt;data; You never check if temp is NULL before this dereference. Due to the issue in `fetch()`, the second time you try to remove an item `temp` will be NULL, so you'll get a SEGFAULT
Thank you for this!
You can check scanf's return value: http://en.cppreference.com/w/c/io/fscanf (yes, this website is about C++ reference, but it __has__ a section on C, as defined by the C [not C++] standard). You can use scanf's return value to tell if it was a valid read or not. That said, for many things, I prefer to write my own reader function in terms of simpler standard library functions other than using scanf. I find scanf interesting for when I know what is the input format, and I __know__ that it'll be valid. Maybe reading through log files I created.
thanks for the advice. Mine is for an assignment though, so it's specific to what it asks. I know it will be a float and a char variable that will be inputed. I know how to read in the comma separated data using scanf, it's just i can't quite get how to loop it so that it displays an error if not valid and prompts for the input yet again.
Loop indefinitely, reading lines from input. `break` out of the loop once you get a valid line. That's the gist of it.
http://pastebin.com/FDg80qGq Is that any better? I am just learning this stuff. I am not aware of conventions and things. I thought it was pretty readable before.
Looks like it works as written. Here is a session: Calculator on... 0.0 +4 0.0 + 4.0 = 4.0 +5 4.0 + 5.0 = 9.0 r result is 9.0 again?(y/n) y+25 Calculator on... 0.0 0.0 + 25.0 = 25.0 -1 25.0 - 1.0 = 24.0 It's admittedly a little squirrelly and probably doesn't work quite the way you intended. That's a result of mixing the `getchar()` and `scanf()`. You might consider using `scanf()` for all your input. If that doesn't appeal to you, you could use `getchar()` to read everything and concatenate and parse the input using your own routines or `sscanf()`.
Look at [my response](https://pay.reddit.com/r/C_Programming/comments/3ruclt/calculator_program_help/cwrihwa) above.
Don't use the != for comparison to a floating point value. 
Similarly you can print out a specific number of characters from a string: char buf[10] = "abcdefghij"; printf("%.*s\n",2,buf); printf("%.*s\n",4,buf); printf("%.*s\n",6,buf); It's handy when debugging buffers that aren't null terminated.
Neither. Use Rust ;)
Why would you say so? I have no idea what is Rust..
/r/rust
I did ask for your opinion &gt; Why would **you** say so? thanks anyway
It's a low-level, lightweight, and memory-safe replacement for c++ with good syntax, modern features, and a powerful type system.
Objects in C are called structs. They can be composed of or [inherit](http://modelingwithdata.org/arch/00000113.htm) from other structs. They can also contain function pointers (though, no magical `this`). That's about everything plain C gives you. And it should be enough for most simple use cases. If you need more advanced OOP features, you have to use a library (or write your own). e.g. [talloc](https://talloc.samba.org/talloc/doc/html/index.html) provides destructors.
structs are not objects. Don't spread misinformation.
A modulo translates to more instructions and is less clock cycle efficient than just using bitwise AND. Granted the CPU isn't the real bottleneck these days the modulo also puts extra pressure on available registers and thus very often the stack. Stack adds cache operations and possibly (worst case scenario) actual memory pressure. Of course the compiler **might** optimize this into a bitwise AND anyway, but that's not to be guaranteed.
Please put four blanks in front of every line of code so your code comes out readable. Right now, it's really hard to read some of the lines. Also, some times you use typographic correct quotes (”). Why?
&gt; That is a hack and bad practice It's how things work under the hood anyway, and it's the way you would implement a OO language in C. Not a hack, just programming. Surely not bad practice. &gt; something you should not be telling someone new to the language Shield the babies from how the world really works! I totally disagree: a programmer should be always aware of how the gears spin behind the curtains of his chosen abstraction. Not in details, but just the vague idea. I wouldn't take a *definition* in a biblical way. ## Post scriptum The downvotes make me think this place is not frequented so much by seasoned or experienced programmers. About doing OO in C, take a look at this [Stackoverflow question](http://stackoverflow.com/questions/351733/can-you-write-object-oriented-code-in-c) and its answers. The sentence “*That is a hack and bad practice*” **is a bullshit**. It's also **true**, rather than false, that **not every object needs methods**, because an object *is an abstract and wide concept*, if not for other reasons. And let's look at the [definition on Wikipedia](https://en.wikipedia.org/wiki/Object_(computer_science) which, according to KatsumeBlisk, says that “every Object does” need methods: &gt; An object can be a variable, a data structure, or a function. In the class-based object-oriented programming paradigm, "object" refers to a particular instance of a class where the object can be a combination of variables, functions, and data structures The object **can be a combination of** variables, functions and data structures; that is: even an object without “functions” (methods — here is just a matter of nomenclature) is still an object. Unless you pretend to interpret the sentence like this: all three elements must be present… Then, if there are functions but not variables, it wouldn't be an object! It's clearly the wrong reading. 
Floating point values aren't 100% accurate, so (float)2 isn't the same as (float)2. they might be 2.0000000000152 and 2.0000000003551. http://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison For a better explanation
Depends on the kind of object-oriented programming you do. Personally, I would never, under no circumstances trade C for C++.
I read your blog entry on using pthreads with Ag and was disappointed you didn't see a significant performance boost :(.
Before dereferencing the `void*` you have to cast it to a useful type. If that type is unknown to you, you cannot to anything sensible. It doesn't prevent you to `int* ip=sth.internals; *ip = 42;`. But its an obvious error, and if you really want to shoot yourself in the foot there is easier ways to do that (also in C++). ☺
GUYS, how do you actually use the lockless allocator?? Do I have to change all my malloc statements? The documentation is poor on the website and has lots of info how to INSTALL but now how to use the code ? I need to know how to actually use it once its installed, someone please point me in the right direction. Google is no success
C actually does have a concept of "objects," but it's probably not what you mean. Rather than get into that, I'll answer the question you want answered, not the question you asked. In terms of object oriented programming, objects usually have methods and inheritance. Structs have neither. What they both have in common is members (or fields).
Thank you! Please do answer the question I accidentally asked as well if you feel. I'm always down to learn more.
C is procedural, not OO. In an OOP language, objects can have methods, but in C, there is no direct analogue. If you want to mimic OO you can throw a function pointer into your struct, as a method of sorts. 
The following is a struct declaration, it defines the type 'struct point'. struct point { int x; int y; }; There are no objects with this type at the moment. To define an object called pt, you can write: struct point pt; An object needs a definition to be an object. For example, the following code declares an identifier that refers to an object, but does not define one. extern int t; If you compile this code without defining t, you will likely get an error message saying 'undefined reference to t' -- there is no object called t because an object called t hasn't been defined. A struct, like struct point, is an object type just like int. It isn't an object, but you can define an object with that type.
Be careful with terminology. In C++, in which you can use structs to do OOP, a struct still isn't an object. A particular struct is a data type, not an object. Still in C++, what people would call an object in the OOP sense is an instance of a struct type (or class type, to be more general). In C, there is no language support for OOP. You can do OOP, but it'll be in terms of mechanisms built on top of the language. As a side note, C has its own notion of what "object" means, which is also the case for C++. It basically means a region of memory that can hold a value of a type. Pretty much, if you can take the address of it, it's an object. The formal definition can be found in the standard. Objects, in more pure OOP circles is something you use only through operation requests. Given you know the set of operations an object can perform, you can request the object to perform these operations. The logic of how to perform such operations are thought to be contained within the object. So, given an object O, and knowing that O can perform operations A, B, and C, the only things then you can do with O is request O to perform operations A, B, or C for you. Structs are nothing like that. To be more precise, I like to use Alan Kay's definition of OOP: &gt; OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things (http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en) State retention means that one cannot, ever, look at the implementation aspects of any object. The only exception here is when an object is looking at its own implementation aspects to perform some internal computation. In practice, many people do this on a type level. They design types that are implemented without looking at implementation aspects of other types, but on the object level, it's somewhat common to have people programming objects to look at implementation details of other objects of the same or somewhat compatible types. In Alan Kay's definition of OO, you need encapsulation at the object level, not class level. Message passing is what I called requesting an operation. It means that the only way to interact with an object is by sending it a message (i.e. requesting it to run an operation). There is no other way to interact with an object. In practice, this is done through singly dispatched method invocations, which is a somewhat limited way to do message passing, but can be implemented somewhat efficiently. Another thing that happens in practice is that you often can interact with an object in ways which isn't by sending that object a message. Late binding of all things mean that whenever you send a message to an object, the decision of what to do with that message is done at runtime by the object receiving the message. That is, it's not something decided and fixed at compile time for example, as it is with most function calls in C. In practice, static binding of calls is very common, for example in C++ a method call is only late bound if you have a virtual member function. Alan Kay's definition is pretty strict. From his definition point of view, most of what people do calling OO isn't really OO, but just a way to organize code that maybe is similar to OO in some aspects. The reason why his definition is good is because the interesting things that you can do with OO come from it (this needs a better explanation, but I'll leave it alone or else this text would become huge). For example, all of the design patterns in the GoF book can have their benefits explained only in terms of those 3 points. All of the benefits of OO to design large systems come from those 3 points, etc. Again, this is not similar at all to structs. And this is not even like anything that is an instance of a struct.
&gt;What do objects need to be objects? All objects are objects ! The formal definition of "object" in C is "region of data storage in the execution environment, the contents of which can represent values". &gt;What are structs in that case? Structs are a *type*. A type is like a blueprint for an object. Given a type, you can make objects of that type. It's not really any different to using primitive types. int x; // "int" is a type, "x" is an object struct S { int a, b, c; }; struct S s; // "struct S" is a type, "s" is an object There's a "trick" interview question: Which keyword in C is used to create a new type? The answer is `struct`, whereas people who don't understand the language so well might answer `typedef` (which actually creates an alias for an existing type). 
&gt; Pretty much, for example, if you can take the address of it, it's an object. Well, there are functions which you can take the address of which aren't objects, and there's register objects which you can't take the address of but which are objects. 
Thanks. Those are good counter examples. I didn't mean for that to be a rigorous definition. It's just the overall idea. The way I like to think is that the rule is like I said there, and cases like you mentioned are exceptions to the rule.
Do you have experience with C++ on embedded systems?
recommend using lex and yacc, not going to say much more other than there's quite a few tutorials out there.
Depends on the compiler. It's a matter of taking the object code and outputting them to a library. 
Would a structure that has some of it's members as function pointers be considered an object?
C11 standard - 3.15 - object: region of data storage in the execution environment, the contents of which can represent values 
Win32 does this.
I don't know what i would be missing in the declarations? it seems right to me, which is the problem. I can tell i am missing a division step again though, which is what i'm trying to fix now. Thanks for the help!
I'm getting at that `*numerator` appears as `numerator`, which may be a typographical error from the incorrect formatting. The error in the algorithm lies in my second paragraph
Close. What I would do is something like int i = 2; while ( i &lt;= *numerator){ if (*numerator % i == 0 &amp;&amp; *denominator % i == 0){ *numerator /= i; *denominator /= i; } else ++i; } Do you see why this is different than above? Edit: `i = 0` changed to `i = 2` for obvious reasons...
Exactly, so the reason we keep dividing down is so that if I have two numbers like `n = 9, d = 18`, and step through the loop we get: 1. i = 2 implies the if statement is false ( `9 % 2 != 0`), so we proceed to else statement and increment i. 2. i = 3 implies we divide both `n` and `d` by 3, resulting in `n = 3, d = 6`. From here, the else statement is *not* executed. 3. i = 3 again implies we divide once more to get `n = 1, d = 2`. This is our fully reduced fraction and the while loop terminates, since `i &gt; n`.
i suppose i still have to implement another division of itself in the loop
ahhh now it is functioning correct! I am going to have to study more as to what you suggested as my logic and math are not my strong points.
You need to pass &amp;remote rather than remote to the init function. Right now it's setting the addr and port on a separate copy of remote.
Even if it is a inline function? I thought they expanded like macros. Anyway, I should read more about the features before use them. Your solution worked, thanks.
Well, it breaks one of the more useful things you can do with arrays.
say I want to read in a line such as " 15, 12, A' and make sure that the user doesn't make a mistake such as a char other than A or B and the first 2 values one is higher than the other. I would think scanf("%d, %d, %c", &amp;i, &amp;j, &amp;c) would work but when i play with that and add some if statements to check validity it doesn't function right and goes into infinite loops. Also it can't tell the difference from a period and a comma..
Try looking into comparing chars, similar to how you would compare ints. Don't worry so much about the period or comma issue until you get that sorted. 
Wouldn't recommend personally, it craps itself with consecutive delimiters like ,, strsep is a much better function although it isn't standard but its easy enough to write
inline is just an optimization suggestion to the compiler that it might or might not pay any attention to. As such, it does not change the syntax or structure of your code. You can just pretend it's not even there. C99 spec 6.7.4p5: &gt; A function declared with an inline function specifier is an inline function. The function specifier may appear more than once; the behavior is the same as if it appeared only once. Making a function an inline function suggests that calls to the function be as fast as possible. The extent to which such suggestions are effective is implementation-defined. For the purposes of writing code, you should write it just the same as if "extern inline" were left off. Hands up everyone who knew that you could declare "inline inline inline void foo(void)"... I didn't. :)
The question is whether you are going to retry bad inputs. Should the program process input interactively or not? scanf's unsuitable for interactive input, but it works sufficiently well if the program aborts on bad input. fgets and something like sscanf are suitable choices for both situations. 
You can think of *inline* as basically the same as *register*. 
I'm guessing in your main you do something like this &gt;mynode* reversed = reverse_recurse(original); In the case the original only has one node, reversed will be void, as reverse_recurse doesn't return anything when the root node has no next element. As for why it works (barring the above case) even without returning anything is the fact that you don't use the return value within your code. By not returning anything, you're effectively returning void. Which works, as you don't use that void.
beej, is that you?
It looks like you and /u/theboxingfox got the bug(s) figured out, but it's also worth noting that when reducing a fraction you want to find the greatest common divisor, not the least common denominator. Your code is attempting to do the correct thing, but you should change `lcd` to `gcd` to more clearly indicate what's going on.
On Linux the usual process is the lock file method: * See if /var/run/programname.pid is present. * If it is, quit with an error. * If it isn't write the current process's pid into /var/run/programname.pid * When the program terminates, unlink /var/run/programname.pid To handle crash scenarios and lock files hanging around, if the file exists, you can check to see if the process is still running by checking the pid in the file. If it isn't you can safely start a new instance. I have a couple of things that I've written that do this. If you want to get clever, the first process can create a fifo in /tmp called /tmp/programname-pid-pipe and the second process to come along can write commands down that pipe to execute in the master process. On Win32, you usually create a named mutex using CreateMutex. That has the life time of the process and subsequent attempts to create a mutex with the same name will fail and you can detect that. Edit: see child comments from FUZxxl for corrections.
Good plan. TBH I was unaware of O_EXCL safety semantics (just checked the manpage) so I'm going to rewrite my code around that now :)
&gt; I have a couple of things that I've written that do this. If you want to get clever, the first process can create a fifo in /tmp called /tmp/programname-pid-pipe and the second process to come along can write commands down that pipe to execute in the master process. A pipe is not really suitable for this purpose. Pipes are not made for multiple processes writing into them concurrently and do not guarantee that data arrives on one piece. Use a Unix domain socket if you want to do something like this.
probably a better example: #include &lt;stdio.h&gt; int printString(char *ourString); struct __member { int (*method)(char*); }; struct __class { struct __member member; }; struct __class class = { &amp;printString }; int main() { char *data = "hello world!"; class.member.method(data); return 0; } int printString(char *ourString) { printf("%s\n", ourString); }; edit: formatting
Either you have to specify a fixed size (fixed = a constant that is known at compile-time): double y[42][84]; or alternatively you can dynamically allocate using, e.g. `malloc`, to any size you want.
I went over the whole thing, and sort of reworked your code a little to come up with this. It's basically everything except the "display" portion: #include &lt;stdio.h&gt; #include &lt;math.h&gt; main() { double dx = 0.01; double c = 300; double dt = dx / c; double L = 1; double r2 = ((c*dt/dx)*(c*dt/dx)); int nmax = L/dx; int i; double storage; char y[10001][4]; // init for (i=1; i&lt;=nmax; i++) { y[i][1] = 0; y[i][2] = 0; y[i][3] = 0; } for (i=0; i&lt;=nmax; i++) { storage = -1000*(i*dx - .03 * nmax * dx); storage*=storage; y[i][2] = storage; y[i][1] = storage; } // propagate storage = dt * c / dx; storage*=storage; r2 = storage; for (i=1; i&lt;=nmax-1; i++) { y[i][3] = r2 * (y[i+i][2] + y[i-1][2]) + 2*(1.0 - r2) * y[i][2] - y[i][2]; } for (i=1; i&lt;=nmax-1; i++) { y[i][1] = y[i][2]; y[i][2] = y[i][3]; } return 0; } I had some ideas for how to print the data, something like this: // display printf("gnuplot -e \"set term png\""); printf(" -e \"set output \'/tmp/plot1.png\'\""); printf(" -e \"plot 0,0-%e,0\"", dx*nmax); printf(" -e \"plot 0,%e\"", y[0][2]); for (i=0; i&lt;nmax-1; i++) { printf(" -e \"plot %e,%e\"", i*dx, y[i][2]); } printf(" -e \"%e,%e\"", nmax*dx, y[nmax][2]); which just prints out one giant gnuplot command to plot the data, but I'm not sure that's the best approach (I've never really worked with gnuplot before).
Using a setuid wrapper is in many cases the wrong option. Why not create a small shell script, like /opt/apache2-reload.sh and add it to /etc/sudoers with NOPASSWD set for the specific user? That is, IMO, more clean and less error-prone.
You might want to pull that return statement outside of the if statement (putting it after the else statement). If I'm reading this correctly, this function will never actually reach the return, so the function will return void every time. By putting the return at the end, you'll get a pointer to the head of the list when the function finishes every time
thank you!
Try experimenting with this program, see what it prints for the inputs you want to handle. #include &lt;stdio.h&gt; int main(void) { char s[8192]; int a, b, r; char c, end; while (fgets(s, sizeof s, stdin) != NULL) { a = b = 0; c = '?'; end = '\0'; r = sscanf(s, "%3d, %3d, %c%c", &amp;a, &amp;b, &amp;c, &amp;end); printf("%d: (%d, %d, %c) %d\n", r, a, b, c, (end == '\n')); } return 0; } 
First he is reviewing a beta version of the book, and make comments about things that are clearly placeholders, such as "... I have to look this up" with regards on how to setup the environment on Windows. He makes a big deal about not having a makefile and that basically people won't be able to compile his examples with make. However, when compiling a single c file, like "ex1.c" Shaw uses the command "make ex1" which will work fine without a makefile. So the reviewer just needed to actually follow instructions as laid out in the book. Most of the problems he complains about in the review have already been fixed and updated in the released version of the book. Zed Shaw should take his beta version offline, or update it, so that people will not be confused about this. The biggest offense of the review author, imo, is reviewing beta material as if it was a finished product. Feedback is great, but the reviewer doesn't present his arguments that way.
That code looks like some variation of BASIC to me.
Sorry, no idea. Windows is not my forté.
I can't believe the lack of documentation for Windows for any allocator. Just goes to show everyone will be using *NIX systems and Windows is dying as a developer platform.
This looks almost correct. There are two mistakes, if you fix them it's going to work: * You loop should go `for(i = 0; i &lt; 6; i++)`, not `for (i = 0; i &lt;= 6; i++)` * Do not put an `&amp;` in front of the thing you want to print with `printf`, just `printf("%d", k[i]);` is fine.
thanks its should be something like this: #include &lt;stdio.h&gt; int main{ int k[]={1,2,4,5,6,8}; int i; for (i=0,i&lt;6,i++) { if(k[i]%2==0) printf("%d",k[i]); } } 
Forte. Forté is a music term. As to OP, check out Rust (the programming language)? They use jemalloc on Windows, so they have to compile it when they compile their compiler.
The lost art... except if you are an embedded developer. Noted by the author: "The only good reason for #pragma pack is if you have to exactly match your C data layout to some kind of bit-level hardware or protocol requirement, like a memory-mapped hardware port, and violating normal alignment is required for that to work. If you’re in that situation, and you don’t already know everything else I’m writing about here, you’re in deep trouble and I wish you luck."
The article speaks of Clang having `-Wpadded`. It looks like gcc has the same option. I like that the author speaks of other optimizations dealing with cache. Would a tool like cachegrind (one of the valgrind tools) be useful to identify areas to optimize for this? 
And even then, unless performance is absolutely critical, you are usually better off manually marshalling your data as packed structs are a huge source of importability and are notorious for breaking every once in a while.
Don't forget that you've declared [16][16], therefore the last one is: [15][15].x [15][15].y and not [32][32]
Lost? I always optimize (or manually pad) my structs. 
In C, every argument is passed by value. This also applies to structure types. Thus, your function `testerfunction` receives a copy of `ship` and your assignment `ship.tester[0] = 9808;` only assigns to the copy, leaving the original untouched. If you want a function to receive something by reference, you need to explicitly pass a pointer: int testerfunction(struct ships *ship){ ship-&gt;tester[0] = 9808; printf("%g\n",ship-&gt;tester[0]); return ship-&gt;tester[0]; }; /* ... */ testerfunction(&amp;ship);
You're passing `ship` by *value* when you want to pass it by *reference*. What `testerfunction` is getting is a binary copy of the `ship` object in `main`, which is modified in the function and then destroyed when the function returns. What you want to pass it is a *pointer* to `ship`, so that the modifications will be made to the object in `main`. Change your function to look something like this: int testerfunction (struct ships *ship) { ship-&gt;tester[0] = 9808; printf("%g\n",ship-&gt;tester[0]); return ship-&gt;tester[0]; } // . . . testerfunction(&amp;ship); Here, you're modifying your function to take a `struct ships*` rather than a `struct ships` -- a pointer rather than a value. Inside your function, you'll access the members using the special dereference-and-access operator `-&gt;`, which is just a nicer shorthand for `(*ship).tester[0]` -- dereference the pointer to get a structure, then access a member of that structure. That shorthand exists because pointers-to-structures are extremely common; `struct`s can get quite large and copying them around can be expensive, so passing around pointers (even if you're not modifying through them) is typically much faster. In `main`, rather than passing `ship` directly, you use the address-of operator `&amp;` to pass a pointer to the `ship` object in `main`. And that's that.
The lost art… unless you have been hanging around here for a few months or more. #repost
Passing by reference simply doesn't exist. There are just different levels of indirection. You either pass a copy of a value, or a copy of an address of a value, or a copy of an address of an address of a value, etc. Either way, whatever the argument to the function is, it is copied into the called function's stack frame. 
Exactly why would a developer with biases towards Linux and Mac want to help Microsoft out? 
y I understand MS's motivations, but as a Linux and Mac SW developer (sample of 1 admittedly) I have zero interest in anything MS has to offer there. 
You are right. I already know this. I have clarified some things in a comment above. It would be easy to do it if it were a string but i am limited (using dynamic memory stuff such as arrays, strings, pointers is off limits). I was hoping someone has a solution using mostly bitwise operands.
Ah, I see. I don't think there's going to be a way to get around parsing the int into an array of some sort, there's just no other way to know the individual digits. If the mask and number of digits in the int are the same length, you could use one loop and bit shifting. for(i = 0; i &lt; INT_DIGITS; i++) { if(( int_digits[INT_DIGITS- (i+1)] &amp; ((mask &gt;&gt; i) &amp; 0x1)) { result[INT_DIGITS- (i+1)] = int_digits[INT_DIGITS- (i+1)]; } } This operates on the idea that any nonzero value in C is considered True. However, this would only work if digits were ascii represented, as if they were decimal and you have a 0 as a digit in the int it would evaluate false. Could probably get around this with another conditional, though.
Traditional C? then use vim and make.
First of all, if I understood your example what you want to do is an AND mask, not an OR mask. Having said that, it's not too difficult. The following code is not tested, but should give you an idea... n = 12345; mask = 0x09; // 01001 in binary res = 0; factor = 1; while (n &gt; 0) { if (mask &amp; 1) // LSB is non-zero { res = res + (n % 10) * factor; // use LS-digit factor *= 10; } n /= 10; mask &gt;&gt;= 1; } So folowing your example n = 12345 mask = 01001 res = 0 factor = 1 after 1 iteration n = 1234 mask = 0100 res = 5 factor = 10 and then... n = 123 mask = 010 res = 5 factor = 10 n = 12 mask = 01 res = 5 factor = 10 n = 1 mask = 0 res = 25 factor = 100 n = 0 mask = 0 res = 25 factor = 100 and we're done HTH 
I do more complex masking and the general form is: if ( ( field &amp; MASK ) == BITS ) We could use this for fields that are more than one bit in size (we use a word length of two bits). Each word could have several fields. It's usually convenient to represent the numbers in hex.
Sure, but for this example a non-zero value is enough. As I said, code is not tested just a quick example (variable declaration, potential return statement are also missing). OP can change it to `if (0x1 == (mask &amp; 0x1))` (yes, I use yoda-ifs) if he wants "production code" :)
I have a co-worker that uses CLion. 
emacs
I think we should ween the newbies slowly. Let them learn one thing at a time and focus on the fundamentals
Check out the Eclipse CDT! It feels like you are writing Java with auto complete and realtime syntax errors. https://youtube.com/watch?v=AkPKyubBqio
understanding arrays, pointers and functions
I should also note, that for this class the instructor has specifically stated we are only allowed to use ANSI C 89, in case that makes a difference for any recommendations. 
I will definitely check this out, thank you. 
CLion all the way. I do recommend you do a HelloWorld or another simple program over command line and vim for the sake of learning though.
Vi
Maybe, but C++ would be more efficient: there are statically linked functions, virtual function tables, etc.
&gt; find declaration of this symbol You don't need that in the beginning. Also, having this feature as a beginner tends to make you too lazy to actually read the documentation (which you should really do).
CMake is not a tool like make. CMake is a program that generates makefiles for make, it can also generate different kinds of build scripts. CMake does not replace make though.
Why do you write `&amp;*(accountNums+i)`? Please undestand that `&amp;` and `*` cancel one-another out, so `&amp;*(accountNums+i)` is exactly equal to `accountNums+i`. You can also write `&amp;accountNums[i]` to make your intent clearer, as `a[b]` is defined to be equal to `*(a + b)`.
I use textmate on os x 
Please put four blank lines in front of every line of code so your code comes out in a monospace font. You cannot use backticks (`) to put whole paragraphs in monospace font.
Visual Studio or Netbeans. To be completely honest, I'd avoid an IDE to begin with and learn how to use a text editor (like Sublime, I recommend, there is Sublime for Windows, Linux, Mac). And then using Terminal or Command line to compile. Sounds stupid and complicated but then when you learn all these things, an IDE will seem like magic. Or you'll hate them like me.
Couple of weeks ago, i wrote a small blog article about some C Tips for newcomers: [8 Tips for People that have to deal with C all of a sudden](http://julianloehr.de/8-tips-for-people-that-have-to-deal-with-c-all-of-a-sudden/) Maybe that'll help you. *Be aware, that stdint.h and stdbool.h is not availabe in C89*
I use netbeans at work for C and Java, works pretty well
Well I know that you may not have a lot of time in your disposal, but I found [Casey Muratori's "Intro to C" videos](https://www.youtube.com/playlist?list=PLEMXAbCVnmY6RverunClc_DMLNDd3ASRp) (and all of the rest of his series to be honest) to be the most practical and pleasantly educational resource I've ever come across. In the end of these videos I remember that I started to really love the language and couldn't wait for the start of his game dev series to begin. Besides that, If you want a more "book-with-examples" approach on C, check out Zed Shaw's [Learn C the Hard Way](http://c.learncodethehardway.org/book/). Some have badly criticized this series as being inaccurate and not as precise as other academic books down to the technical level. I'll have to say that I oppose strongly to such claims. The book may contain some over-simplifications and sometimes in some sense "wrong" information, but no other book I've read follows the kind of educational style that this book (and other books of Zed) uses. It will be a different kind of experience but I assure you that it will be enlightening, and you will learn to think in ways programmers do.
What are the advantages of CLion over other IDEs?
An excellent MIT licensed alternative to Sublime is [Atom](https://atom.io/).
K&amp;R is pre ansi. It's a good book, but more appropriate after you've learned ANSI. K.N King'S "C - a modern approach" is great
The link you posted is giving me a problem establishing link error, you may want to look into this. 
Or emacs and make.
There is a 2nd edition K&amp;R that covers ANSI C.
You too, kind sir. 
&gt; Note: It needs to be traditional C and not CMake. &gt; CLion does not support anything besides CMake, does it?
What platform are you programming on? Windows? Linux? Mac? Beos? SunOS? A custom OS you built out of paperclips and chewing gum? 
For compiling and linking, yeah it uses CMake. Super easy to do if you've ever edited your own make files.
This is entirely system-dependent. The C language says nothing at all about it.
As zifyoip says, this is entirely platform-dependent. There's no one universal answer. &gt; How many different types of addresses are there? On some early ancient Intel platforms there was a distinction made between near pointers and far pointers, but those systems are long dead and you aren't using one of them. All modern platforms that you're likely to encounter don't have different kinds of addresses. &gt; How do I differentiate between them, say one in cache and one in main memory? You don't. The cache is an invisible implementation detail. Alternatively put, the cache is not directly addressable. You ask the system to retrieve memory address X, and either that address already lives in cache, in which case the value is read from the cache and returned; or it doesn't, in which case it's fetched from main memory and stored in the cache before being returned. In either case, the instruction to fetch from X was identical. There's no "read from main memory at location X" instruction and "read from cache memory at location Y" instruction. There's just "read address X." &gt; Of what parts are these addresses made of? (offset bits, tag, index etc.) Using tagged pointers is a technique that an individual program can choose to implement if it wants to, but it's in no way universal. For example, if you know that every pointer in your program is going to point to something aligned to a 4-byte boundary or better, then you're free as a programmer to use the 2 least significant bits for your own use, as long as you always remember to clear them before actually using the value as a pointer. This is commonly used to implement [language runtimes](http://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations). But again, that's just something that you decided to do, it's not inherently part of the structure of a pointer. 
I'm pretty sure the pdf is free.
If you are having trouble with pointers take a look at [Understanding and Using C Pointers](http://shop.oreilly.com/product/0636920028000.do). They really go into detail on how the memory management stuff works. 
http://beej.us/guide/bgc/output/html/singlepage/bgc.html - cool guide http://c.learncodethehardway.org/book/ - cool online book https://www.youtube.com/watch?v=6pmWojisM_E - pointer fun with Binky
&gt; I have to write a program in c language that finds and prints all minimal primes with at least 4 digits. Any ideas on how i can achieve it? [Sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) &gt; I know how to find the primes but i have a hard time on "investigating" if they are minimals. What do you mean by "minimals"?
You can split a number into individual digits using division by and modulo 10. int digits = number % 10; int tens = (number / 10) % 10; int hundreds = (number / 100) % 10; etc. So you can break 109 into 1,0,9 And then check all lower primes against this list. E.g. break 19 in 1,9 and see that 1,9 is an ordered subset of 1,0,9 
This does not help OP nor is what he asked.
You don't find sample output useful?
You are giving him the answer rather than the tools to solve it for himself
so, if I read the second book it will apply to my class? (ansi c 89)
sorry, side bar?
the part about using objects actually really helps, I think part of my problem is c isn't oo like java.
the beej guide is very good so far thank you. I have actually seen binky lol, my problem isn't with single pointers though. It's when you have ***PPP = **qq , **qq = **pp, q=p, *p = ***ppp and then a bunch more assignments and then asking what the output value of all of them is in a print statement.
Seems like a fun way to learn gdb. I have to admit that I've been pretty lazy with learning it beyond basic break points, even after having coded in C and C++ for many years now.
Newer version is only $12, or ~$16 shipped: http://www.amazon.com/gp/offer-listing/9332549443/ref=tmm_other_meta_binding_new_olp_sr?ie=UTF8&amp;condition=new&amp;qid=&amp;sr=
I have no idea what's going wrong, but it's only outputting 5 7 4 I've reviewed this code many times through gdb too. I just can't figure out what's wrong with it.
How is queue defined? Because doing `(*q)-&gt;front` implies you're using pointers to pointers, and I don't think that they are very useful to implement priority queues...
i jsut used typedef struct endpointer { node_pointer front; node_pointer back; } *queue; and node_pointer is just another typedef. 
This defines `queue` as a typedef of `struct endpointer *`, so `queue*` is in fact a pointer to a pointer, but, as was said, this isn't very useful. Either take out the asterisk from the typedef or from the `queue*` parameter.
The thing on the right of the screen.
&gt; Maybe different eyes could help me? :) * Replace the 2nd btree_node_add_left() in buildTree() with btree_node_add_right(). * Fix the recursions in btree_traverse_infix() and btree_traverse_postfix(); both call btree_traverse_prefix().
Learn C. See books on right. Then look at SDL which is a library that handles input, graphics and audio.
Or ed(1) and make FFS.
Maybe an anti-virus issue?
The more levels of indirection your code has, the more bugs your code has. Exponentially. You have a useless pointer indirection there. It's really confusing to deal with it. So my advice is that you remove that pointer to pointer. Maybe by doing so you'll end up fixing your code without even noticing. 
Have a look at Casey Muratori's [Handmade Hero](https://handmadehero.org/), where he live streams writing a complete game from scratch. You can find all the videos on YouTube. He does use some C++, but that's limited to function overloading, operator overloading and a few other convenience features, no full blown classes or templates.
"Codes"
Optimizing out your variables isn't a great reason to go without optimizations :P I would add some code to trick the compiler into thinking you used them (printing a variable generally works), or just turn off the optimization for removing unused variables. But in production code, you probably want the compiler to remove anything unnecessary. For the instruction cache, I think most modern CPUs have a separate icache and dcache at the L1 level, and then L2 and L3 are unified caches. But I could be a bit rusty on that, been awhile since I've thought about that. -O0 and no -O flag being different is news to me, but honestly I've never tried to use -O0. Not even once haha. I'm sure if you check the docs it will detail exactly what they do.
I shall reinvent the wheel before I build a track car 
So, *that's* why the object-oriented version of Cobol is called: "Add 1 to Cobol and store the result in Cobol" (Yeah, I know, old joke, but I still find it funny)
Yeah, I quoted OP. Problem? 
I think renaming your list pointers to something more meaningful will help you out, as you're getting temp and temp2 mixed up in your else section. I've renamed temp to new_node and temp2 to walking_node here (where a node is an item in your list): // start at the second node from the front (guaranteed to exist if you've checked front and back) walking_node = (*q)-&gt;front-&gt;next; // walk the list until we find the first node with a lower priority than our new node while (walking_node-&gt;priority &gt; new_node-&gt;priority) walking_node = walking_node-&gt;next; // link our new node into the list new_node-&gt;next = walking_node-&gt;next; walking_node-&gt;next = new_node; The way you're thinking is correct, you've just got a bit turned around with the implementation.
There is no `conio.h` on Linux and there won't be because terminals on Linux and Unix work differently from the DOS console, so many of the things you can do with `conio.h` have to be done differently on Linux. Many of the simpler functions from `conio.h` (like `getch()`) are provided by the curses library, try to include `curses.h` instead of `conio.h` and link with `-lcurses'.
Oh, that makes it easier to keep track of. Managed to get it to working, slowly but surely I'm starting to understand why the program doesn't work and how to go about fixing it. But yeah changing the names helped
Graph isomorphism is not known to be NP-Hard (in fact, it has been thought for awhile that it's not). Also, it's always been solved, this (assuming it's correct) does it in quasipolynomial time. So the title is misleading. This is a super important though result. See the [math subreddit's post](https://www.reddit.com/r/math/comments/3skjyu/a_quasipolynomial_time_algorithm_for_graph/) instead I'd say.
Of course [getch() is part of curses](http://linux.die.net/man/3/getch).
gdb has a lot of useful stuff you can do, like 'disassemble', 'info functions' (or var/args/locals/scope), 'step', 'return', and 'x'. 
I have a more general question for you if you don't mind. When do I have to worry about funny things happening when I do calculations where some of my variables are integers/longs and some are floats? When is type casting implicit and when do I need to be explicit? If this is too broad of a question, can you point me in the right direction where I can read about this? [Is this all I need to know about type casting?](http://www.tutorialspoint.com/cprogramming/c_type_casting.htm)
Not that it's really helpful for your purposes, but there's something I realized when I was playing around with some code regarding this. It seems to me that every number that's not prime is evenly divisible by at least one prime. You can actually start building a list of primes using the first two (2, 3). 4 is evenly divisible by 2, 5 isn't evenly divisible by either (so it's added to the list), 6 is divible by 3, etc.. I threw together some code to illustrate my point. It'll compile a list of primes valid up to the square of the next prime not on the list (121, or 11^2 ): #include &lt;stdio.h&gt; int main() { int i; int check1 = 0; int check2 = 0; int check3 = 0; int check4 = 0; printf("2 "); printf("3 "); printf("5 "); printf("7 "); for (i=5; i&lt;=150; i++) { while (1) { check1 = i % 2; check2 = i % 3; check3 = i % 5; check4 = i % 7; if (!check1) { break; } else if (!check2) { break; } else if (!check3) { break; } else if (!check4) { break; } else { printf("%d ", i); break; } } } printf("\n"); return 0; } the result being "2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 121 127 131 137 139 143 149"
The book [How Computers Work: Processor and Main Memory by Roger Young](http://www.fastchip.net/howcomputerswork/p1.html) helped me immensely to understand what's physically happening inside your processor and memory. The book is an easy read and you can easily get through it in a couple days if you know nothing about computers. If you already know a little about what's going on then you could easily read it in a couple hours. Young offers his book for free on his website. [Here's a link to the PDF.](http://www.fastchip.net/howcomputerswork/bookbpdf.pdf)
yeahh..
Please flag posts you deem as off-topic (click flag to do so, make sure to provide a proper reason). Post removed because it's not about C programming.
Oh thank you that helped a lot :)) 
Thanks for the link, shame all the formatting is shot on it (loads of parens everywhere)... though the `doc` file is fine so I'll just convert that. nice one
Ok, this is so unrealistic, that people think you're trolling which is why you're being downvoted. I think you just don't understand just how much you don't know. Someone made the analogy of "re-invent the wheel" to build a car. I would say this is the equivalent of re-inventing the Linux kernel to print "Hello world!"
You mean print 4 as four? You could use a switch statement.
Yes. switch (x) { case 1: printf("one"); break; case 2: printf("two"); break; /* etc. */ default: printf("%d", x); break; }
You want a logical shift, not arithmetical shift. Read the documentation again.
Why no arrays?
i suppose that would be easier, trying to make a word match user input that is unknown 
So not allowing us to use an elementary tool of the C programming language makes answering this question easier? Please try not to arbitrarily restrict your questions. A restriction like “no arrays” must be carefully justified, otherwise someone might think that this is just homework you try to pass as something else. If you are uncomfortable using arrays, that's a valid reason. Please tell us if this is the case so we can write our answers appropriately.
"one" is an array of chars and the question said no arrays! ;-)
Some libraries aren't available on every platform, so you could design an interface that is meaningful to your program and implement it for each platform you want to support. For example, you might only need coloured text for your program, and you might only need blue and cyan. So you might write a header file called putcol.h, enum { DEFAULT, HEAVY, LIGHT }; int putcol(int c, int colour); Then you can implement it for MS-DOS (untested): #include &lt;stdio.h&gt; #include &lt;conio.h&gt; #include &lt;graphics.h&gt; static int value[] = { -1, BLUE, CYAN }; static int dfl = -1; int putcol(int c, int col) { if (dfl &lt; 0) dfl = getcolor(); if (value[col] &lt; 0) textcolor(dfl); else textcolor(value[col]); return putchar(c); } And terminals supporting ANSI escape sequences (most Linux terminals): #include &lt;stdio.h&gt; static char *format[] = { "%c", "\x1b[34m%c\x1b[0m", "\x1b[36m%c\x1b[0m" }; int putcol(int c, int col) { return printf(format[col], c) &lt; 0 ? EOF : (unsigned char) c; } Then these features can be accessed portably in your program: #include "putcol.h" void putcols(char *s, int col) { int i; for (i = 0; s[i] != '\0'; i++) putcol(s[i], col); } int main(void) { putcols("hello", LIGHT); putcols(", ", 0); putcols("world", HEAVY); putcols("\n", 0); } This is just a rough example that works with colours, but a similar approach can be taken for any other functionality that your program needs to utilise. ncurses and termbox are libraries you could look into for terminal features that extend beyond colours. 
C doesn't deal with such low level stuff but you can look at the assembly language produced by compiling a C program if you're interested in what goes on at the processor level. You can follow through that and watch the values in each register in the debugger. C code doesn't have any awareness of or control over that stuff though. One of the main reasons for creating C was so you *wouldn't* have to think about registers or the internal goings on of the processor.
What is the previous IO operation that happened before this? You have to remember that when you type Y and then press enter, that adds two characters to the input stream. With the `%c` format specifier, `scanf()` will only remove a single character from the standard input stream. This is different than the other specifiers like `%s` and `%d` which consume any amount of whitespace characters before the token they are looking for — this tends to paper over problems with understanding how IO actually works. So if the last thing that you did prior to this was to ask a yes or no question and use `scanf()` with `%c`, then that means you only removed the Y or N character from the stream, but not the newline. The newline character is still in the stream and is returned by the next use of `%c` without having to wait for any new input. If you want to avoid this, there a number of ways of doing IO properly. I always tell people that when they're dealing with interactive input, always read a line at a time. That means using `fgets()`, not `scanf()`. You can still use `sscanf()` to parse the line that you read, but the point is that you only ever actually interact with the input stream a line at a time, which means you never get out of sync, because interactive input is line-buffered. (If you google this problem, you will see people suggesting horrible things like `fflush(stdin)`. If you see somebody say that, you should close the tab and never visit that site again because they are clueless. First of all, `fflush()` is for output streams, not input streams. Calling `fflush()` on an input stream invokes undefined behavior. But more importantly, it represents a fundamental misunderstanding of the problem and how to deal with it.) 
In that case could you post your entire code, or at least a shorter programme which should work the same? I can compile and run the following fine: #include &lt;stdio.h&gt; int main() { char pc2 = '\0'; printf("Player 2, do you still want to continue playing? Press Y for Yes or N for No.\n"); scanf("%c",&amp;pc2); if (pc2=='Y') printf("Noice!\n"); else printf("Player 2 has exited the game.\n"); return 0; } 
 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int main(){ srand((unsigned int)time(NULL)); unsigned int p1, p2, p3, b=100000, pm1=20000, pm2=20000, pm3=20000, pb1, pb2, pb3, d1, d2, ans, ctr; char pc1, pc2, pc3; d1 = rand() %6 + 1; d2 = rand() %6 + 1; ans=d1+d2; printf("%u",ans); do{ if (ctr==1) break; else ctr=0; printf("Both of the dice have been rolled. A number ranging from 6 to 12 has been generated.\n\n\n"); printf("Press any key to continue.\n"); getch(); system("cls"); if (pm1!=100){ printf("Player 1, what's your guess? \n"); scanf("%u",&amp;p1); printf("Please enter your bet:\n"); scanf("%u",&amp;pb1); pm1=pm1-pb1; printf("Remaining funds: P%u\n\n",pm1); b=b+pb1; ctr++; } if (pm2!=100){ printf("Player 2, what's your guess? \n"); scanf("%u",&amp;p2); printf("Please enter your bet:\n"); scanf("%u",&amp;pb2); pm2=pm2-pb2; printf("Remaining funds: P%u\n\n",pm2); b=b+pb2; ctr++; } if (pm3!=100){ printf("Player 3, what's your guess? \n"); scanf("%u",&amp;p3); printf("Please enter your bet:\n"); scanf("%u",&amp;pb3); pm3=pm3-pb3; printf("Remaining funds: P%u\n\n",pm3); b=b+pb3; ctr++; } printf("Banker's money: P%u\n\n",b); printf("Press any key to continue.\n"); getch(); system("cls"); if (p1==ans || p2==ans || p3==ans){ if (p1==ans){ printf("Congratulations Player 1! You got it right.\n"); pm1=pm1+pb1*2; printf("Total funds: %u\n",pm1); b=b-pb1; } if (p2==ans){ printf("Congratulations Player 2! You got it right.\n"); pm2=pm2+pb2*2; printf("Total funds: %u\n",pm2); b=b-pb2; } if (p3==ans){ printf("Congratulations Player 3! You got it right.\n"); pm3=pm3+pb3*2; printf("Total funds: %u\n",pm3); b=b-pb3; } } else printf("Sorry, no one got it right. The correct answer is %u.\n",ans); printf("Banker's new funds: %u\n\n",b-(pb1+pb2+pb3)); printf("Player 1, do you still want to continue playing? Press Y for Yes or N for No.\n"); scanf("%c",&amp;pc1); if (pc1=='Y') printf("Noice!\n"); else printf("Player 1 has exited the game.\n"); printf("Player 2, do you still want to continue playing? Press Y for Yes or N for No.\n"); scanf("%c",&amp;pc2); if (pc2=='Y') printf("Noice!\n"); else printf("Player 2 has exited the game.\n"); printf("Player 3, do you still want to continue playing? Press Y for Yes or N for No.\n"); scanf("%c",&amp;p3); if (pc3='Y') printf("Noice!\n"); else printf("Player 3 has exited the game.\n"); printf("Press any key to continue.\n"); getch(); system("cls"); }while(b!=10000); return 0; }
So this should result in 70 right..? Its printing 1606, because the left shift i think.. num=50 nbits=3 int rotate_right(int num,int bits){ return ((num &gt;&gt; nbits) | (num &lt;&lt; (8-nbits))); //num &gt;&gt; nbits = 0000 0110 } //num &lt;&lt; (8-nbits) = 0100 0000 //OR = 0100 0110 (=70) So i made this: int rotate_right(int num,int nbits){ int rshf = 255; int z = (num &lt;&lt; (8-nbits)); int res = rshf &amp; z; return ((num &gt;&gt; nbits) | res); } applied a mask to the shifted number to get all the bits except the ones &gt; than 8, and its working
Ok there's quite a lot to comment on here so I'm gonna split it up into chunks. First off, which compiler/IDE are you using? You should turn on the maximum amount of warnings and endeavour to fix all of them. Learning how to listen to your compiler is *the* most important thing, *all* of the things I'm about to tell you were picked up by my compiler for me. --- unsigned int p1, p2, p3, b=100000, pm1=20000, pm2=20000, pm3=20000, pb1, pb2, pb3, d1, d2, ans, ctr; char pc1, pc2, pc3; If you're careful you can get away with uninitialised variables, in practice no-one (not even experienced developers) is that careful. The issue is that if you just declare a variable (`int x;`) then then it'll be filled with junk data; at best this is a bug waiting to happen, at worst this is a security hole, so get into the habit of initialising all your variables to a sensible default value like so: unsigned int p1=0, p2=0, p3=0, b=100000, pm1=20000, pm2=20000, pm3=20000, pb1=0, pb2=0, pb3=0, d1=0, d2=0, ans=0, ctr=0; char pc1='\0', pc2='\0', pc3='\0'; Also typing speed is much less important than code clarity so don't call your variables things like `p1`, call them things like `player1`. --- d1 = rand() %6 + 1; d2 = rand() %6 + 1; ans=d1+d2; You say that this produces a number between 6 and 12, actually it produces a number between 2 and 12. --- if (ctr==1) break; else ctr=0; I would avoid this way of formatting if-else statements with a passion because it often leads to people adding a second line without adding the brackets. Either use brackets (my preference): if (ctr==1) { break; } else { ctr=0; } or put the statement on the same line: if (ctr==1) break; else ctr=0; --- getch(); I'm guessing this is a Windows function? If so [it's deprecated](https://msdn.microsoft.com/en-us/library/ms235446.aspx) and you should use [`_getch`](https://msdn.microsoft.com/en-us/library/078sfkak.aspx) instead, if not it's part of ncurses and you should use `getchar` instead. --- system("cls"); Again I'm guessing this is a windows thing? --- printf("Player 3, do you still want to continue playing? Press Y for Yes or N for No.\n"); scanf("%c", &amp;p3); `p3` has type `unsigned int` but you're trying to put a `char` in it. My guess is that you meant to put `&amp;pc3` instead. --- if (pc3='Y') printf("Noice!\n"); else printf("Player 3 has exited the game.\n"); `pc3 = 'Y'` is an assignment, not an equality check. You probably want `pc3 == 'Y'`. ---
Maybe use a language that's better for string manipulation?
Ah, you've run into an unfortunately difficult thing to debug if you don't know what you're looking for. My compiler (`clang`) gives the following error: test.c:159:2: error: expected '}' } ^ test.c:9:7: note: to match this '{' do{ ^ test.c:159:2: error: expected 'while' in do/while loop } ^ test.c:9:5: note: to match this 'do' do{ ^ test.c:159:2: error: expected '}' } ^ test.c:4:11: note: to match this '{' int main(){ ^ From this we can tell that somewhere you've got unbalanced brackets somwhere. Your IDE or editor should have some way of visually showing which brackets match up (should be fairly easy to find via google), which is very useful and using it I quickly figured out that on line 65 you've put a `{` where you should have put a `}`. --- I've never programmed in Windows I'm afraid so I can't be much help with which IDE to use. Having said that, I've heard very good things about Visual Studio so maybe give that a go? Or maybe try some others in the C++ section (most C++ IDEs work with C) of [this](https://www.reddit.com/r/learnprogramming/wiki/tools#wiki_c.2B.2B) page. Once you've found an IDE to use go through *all* of the settings and turn on anything that is to do with warnings, errors and debugging. This will help sooooo much!
Not sure why they downvoted you, my go-to language for stuff like this is Python... Sure you can do it in C, but my motto is, use the right tools for the job.
I mean, you could just count the number of characters in a line, and use that as the line break? there's 65 characters in that line...
Well, that's a pretty arbitrary assumption. The easiest method would be to use a lookup array. char *words[] = {"zero", "one", "two" , ....}; if (i &gt;= 0 &amp;&amp; i &lt;= 9) puts(words[i]);
because it interpreted it as an int. 100 is an int; 100.0 is a float. C will cast to int for some calculations if one of the operands is an int.
Even though value[] is a double float?
I don't know that I'd ever recommend strtok. fgets+sscanf is much better here.
So I really really have no idea how to install clang. I went to their website, downloaded the "Clang for Windows (64-bit) (.sig)" and installed it, but a command prompt appeared and said the installation failed. I didn't even touch anything, wtf.
OK, thanks for the explanations. A bit scary that a tiny change can mess up the whole thing.
I can't help you there I'm afraid, as I say I have no knowledge of windows.
Shelling out to `clear` instead of using termcap and printing the clear escape sequence on *nix systems is sort of eh.
If you like Python for this, try Perl; it'll blow your mind.
I understood it as plain Make instead of CMake. Others IDEs, like KDevelop, do support plain Make projects.
Emacs + gtags + cedet is a nice "IDE" if you're comfortable using the console (nice side effect, you can use it remotely via ssh).
For most applications, C programmers tend to use arrays instead of more complicated data structures, reasons include the difficult memory management for linked data structures and the fact that it's tricky to implement them correctly. C programmers tend to write simple code with few memory allocations and mostly simple structures. When complex data structures are needed, they are often needed only for that particular instance and aren't written in a generic fashion. Another thing you could try is to use [`queue.h`](https://www.freebsd.org/cgi/man.cgi?query=queue&amp;sektion=3) from FreeBSD. The header contains a bunch of macros that already implement single and doubly linked lists. For more complicated data structures I would use `void*` pointers for the things you want to store in the data structure, not making the data-structure itself generic. Inside the code for the data structure, you could make a type definition like typedef void *element; to remind yourself of what that `void*` actually means but please don't pollute other file's name spaces with that by putting this definition into the header file.
A string is an array of characters.
I'm a professional programmer that deals with a large C code base. We use a lot of macro-based generics, and we use a lot of auto-generated code. I don't find maintaining the macro stuff is too bad. Once you have lists, sets, and hash tables, you pretty much cover 99% of the use cases. Other than the data structure stuff, I do A LOT of macro programming, and looking at the post-preprocessed output (-E if using gcc) usually finds any problems. At the same time, this is one of the reasons why people start looking at C++. Even without any of the object-oriented stuff, C++ has strong generics support. &lt;rant&gt;You'll only spend a couple of man years learning how to make a slightly cleaner linked list interface &lt;/rant&gt;. 
My response to this is always to look into `container_of`. It allows you to use intrusive data-structures in a very clean way. The most obvious (and common) example of it's usage is [list.h](http://lxr.free-electrons.com/source/include/linux/list.h) in the Linux Kernel, which is a generic doubly-linked list using `container_of`. There's tons of tutorials on `container_of` on the web, but the general idea is that `container_of` allows you to take a pointer to a contained object, and get a pointer to the container. For example, take these structures: struct ll_node { struct ll_node *next; }; struct container { int foo2; struct ll_node link; }; Normally, if you had a pointer to the `link` entry of a `struct container` object, you don't have a way to get a pointer to the outer `struct container` object from the pointer to the `link` object. Thus this doesn't work: #include &lt;stdio.h&gt; struct ll_node *list_next(struct ll_node *k) { return k-&gt;next; } int main() { struct container cont; struct container cont2; struct ll_node *next; struct container *next_container; cont2.foo2 = 10; /* Link the containers together */ cont.link.next = &amp;cont2.link; next = list_next(&amp;cont.link); next_container = next; /* ???????? */ printf("%d\n", next_container-&gt;foo2); return 0; } The line with the question-marks is the issue - `list_next` returns a `struct ll_node` object, but we need the `struct container` object. Since we were the ones who linked the `struct ll_node` object's together, we do know that every entry in the list of `struct ll_node` objects is *actually* part of a `struct container` type object. But even though we know that, we don't have a way to 'convert' `next`, which points to `link` in `cont2`, into a pointer to `cont2` itself. We want this program to print `10`, but without that conversion we can't do it. The obvious solution is to change the definition of `struct ll_node`and `list_next`: struct ll_node { struct container *next; }; struct container *list_next(struct container *k) { return k-&gt;link.next; } This works - It gives us a pointer to the `struct container` object. But it's really not satisfactory, because it's not generic - We would have to write a `struct ll_node` and `list_next` function for *every* linked-list we want, even though they're all going to be the same and do the same thing. And the only problem was the conversion from the `struct ll_node` type to the `struct container` type, which we *know* would be fine anyway. `container_of` fixes the problem: next_container = container_of(next, struct container, link); Where `container_of` take the original pointer, the new type, and the entry in the new type that `next` points at. It returns a pointer to the outer object, or the `struct container` that `next` currently points into (In this case, `next_container` will point at `cont2`). The nice part is that it means we can reuse `list_next` as much as we want and it has no need to have any knowledge of what the `struct ll_node` object is actually inside of. We can even put `struct container` on multiple lists. *and*, there is no `void *` ugliness, and no extra dereference needed to use the list (because it is intrusive and the links are contained directly inside of the `struct container`), and you can put the `struct ll_node` anywhere in `struct container` (Or anything else) that you want.
Thanks for chiming in @jnwatson. Yes, that "99% coverage" was my initial thought when I started this project - that it would save time. -E helps a _bit_. Maybe the whole "macros via generics" works okay when you are coding in the right sort of environment, but for one guy writing a game - engine, everything - from scratch, and as a relatively recent returnee to C, I don't have time to write / maintain potential messes like that. If I had a team - no problem - but I don't. After a good few years of coding in a good number of languages, I prefer C's simplicity and flexibility to C++. I guess what I'm saying is - without real changes to how I do things with macros, they're off the table for now. So if further advice comes to mind on managing that in C, I'm all ears.
So this boils down to: `container_of` uses an `ll_node`'s instance address minus `offsetof(struct container, link)` to get the address of the containing structure. Handy! Took me a little bit to get it but I think I see now: the actual topology / connectivity is contained in `ll_node`, but the container "piggybacks" on this by wrapping a `ll_node`, thus getting both the connectivity and the additional payload. Clever. `container_of` simply lets us get back to the specific payload type from the generic node type without yet another pointer. I'm still thinking on how this would be used outside of a node-based structure...
Your bug is here (same bug in 4 places - 2 scanfs, 2 printfs): scanf("%d", &amp;num); printf("\n The smallest number is: %d", min); Depending on what compiler you have, if you turn the warning level it, it may tell you exactly what's wrong.
`%i` and `%d` are for `int`. To `printf` a `double`, use `%f`. To `scanf` a `double`, use `%lf`.
Please let's keep it on-topic with regards to C - I'm not interested in other languages - thanks for responding.
&gt; Resizeable arrays thus really don't fit into this design. Object composition, and node-based structures tend to be what it's best at. On that note though, I find myself using both of those quite a lot. It's not great for everything, but for the things works well for, it really works well for them. I agree about composition. I live by it, avoiding traditional inheritance much of the time (but not always, as evidenced by my use of `gcc -fms-extensions` to get "fall-through" struct members!). Appreciate your discussing limitations of this approach. What I've learned with C so far is to default to composition using pointers wherever you're as yet uncertain that values are required. One can refactor later, but pointers are much more flexible during heavy dev. I have little doubt this will be put to good use soon. Many thanks.
A) arrays are making a comeback in general, because of locality of references. Arrays are faster than anything else, and getting faster. B) there is no performance penalty for (void *). What are you talking about?
If you are alone, there is no downside of using C++ as "a better C". Just use the features you want, keep the rest as c-like as you wish. For instance, Quake3 source code is quite minimal C++ and extremely easy to read.
If you're fine with using the heap, sure. If you don't want to use the heap, then you're on your own. Heap use in an inner loop is generally bad for performance. And if you try to use a custom allocator, well, then you get into the gritty details of some of the new parts of C++11 with move constructors and the like. libstdc++ deprecated (then removed) their non-standard array_allocator because they couldn't get all the properties right.
Why do you not recommend using strtok? 
To repeat myself: I prefer everything about C, particularly the extremely short compile times compared to C++. I am a year into a project that is written in C. Are you going to continue to argue in favour of something I explicitly asked you to avoid, in my question, which I have now bolded for those with selective vision?
Use this to export only the symbols you want : https://www.gnu.org/software/gnulib/manual/html_node/Exported-Symbols-of-Shared-Libraries.html
Or alternatively use map files which are more portable.
Would you please stop drawing the discussion towards C++? OP specifically asked about programming in C, saying “just use C++” is counter productive. Please also remember that C++ is off topic in this subreddit.
Semi-related (or unrelated?) but I'd be curious about reading and writing to file descriptors (sockets actually) via multiple threads. I believe it is allowed on Linux but what about other unixes?
Reading and writing to raw file descriptors concurrently is completely legal.
 if (weight &lt;= 10) rate = 2.00; if (weight &lt;= 50) rate = 4.5; If you have a weight, say, 8, it is &lt;= 10, so rate is first set to 2.0 and then immediately is set to 4.5 (as 8 is also less than 50). You could look at using "else if" to avoid this.
 if (distance % 500 == 0); segments = (distance / 500 + 1); There are a few issues with this code segment 1. You have a semicolon at the end of your `if` statement, which ends up ignoring the condition and always executing the next line of code 2. You have no `else` block, so (once you've fixed #1), you won't be setting `segments` if the distance is not an exact multiple of 500. 3. Why are you adding 1 here? If the distance is 500 miles, this will result in 2 segments. if (weight &lt;= 10) rate = 2.00; if (weight &lt;= 50) rate = 4.5; `rate` is declared as an `int`, so you can't use fractional values. Change `rate` (and `charge`) to use `float`s or `double`s (Also look into why you shouldn't use floats or doubles for money, but I assume that's outside of the scope of this assignment) printf("The shipping cost is: %lf\n", &amp;charge); 1. Look at the options for `printf` format specifiers. You can use `%.2lf` to only display two numbers after the decimal. 2. You're passing in the address of `charge`, not the value. Your compiler should be warning you about this.
As others have pointed out, the GCC documentation talks about this, but it's a bit meandering. Here's an the executive summary of (what I believe to be) best practice: 1: In your public header, define API macros like: #ifdef FOO_SHARED # ifdef _WIN32 # define FOO_LIB_IMPORT __declspec(dllimport) # define FOO_LIB_EXPORT __declspec(dllexport) # else # define FOO_LIB_IMPORT __attribute__((visibility("default"))) # define FOO_LIB_EXPORT __attribute__((visibility("default"))) # endif # ifdef FOO_INTERNAL # define FOO_API FOO_LIB_EXPORT # else # define FOO_API FOO_LIB_IMPORT # endif #else # define FOO_API #endif 2: Put FOO_API in front of all public functions (stylistically, think of this as the opposite of `static`). You only need to do this once on the declarations in your public header. FOO_API FooThing* foo_thing_new(); Internal functions can be unadorned, though of course file-local functions should be static as always. 3: Add `-fvisibility=hidden` to your CFLAGS, and define `FOO_SHARED` and `FOO_INTERNAL` to build your shared library. CFLAGS="-fvisibility=hidden -DFOO_SHARED -DFOO_INTERNAL" 4: Build, and check that the symbol table is what you expect, e.g. `nm -g libfoo-1.so` 
&gt; Is that possible? Try it and find out. Then come back with the compiler errors that you get and I'll explain how to fix them.
Yes, but with one little bit of syntax you're missing. This works just like with a linked list: typedef struct node_s { struct node_s* next; } node; Notice that there's two names for this structure: `struct node_s` and `node`. I could have used the same name (`struct node` instead of `node_s`), but I didn't for clarity. Within the structure definition itself, there's no knowledge of `node`, just `struct node_s`. So a pointer to the next node needs to use `struct node_s`. Likewise, the same applies to your function pointer: there's no knowledge of `ex`, just `struct ex`. So the magic code is: typedef struct ex { void (*func)(struct ex*); } ex;
But how do you get the 10 strings into the array without using string literals?
Run it and find out. Here's Microsoft's description of "#define": https://msdn.microsoft.com/en-us/library/teas0593.aspx What this accomplishes is to replace any occurrences of the word "SIZE" with the number 10. So you'll have x = WhatIsThis(a, 10); 
When they remove the semicolon after the if statement, only exact multiples of 500 miles will have the additional segment added. But fixing that requires considering the edge cases as well. Edge cases: 1) If a package goes exactly 500, 1000, 1500 miles is it charged one segment or two? 2) If its shipped less than a mile is it free or one segment? /* Exactly 500 miles is two segments Less than a mile is one segment*/ segments = (distance / 500) + 1; /* Exactly 500 miles is one segment, Less than a mile is free */ segments = distance / 500; if( (distance % 500) != 0) { segments++; } /* Exactly 500 miles is one segments Less than a mile is one segment */ segments = distance / 500; if( ((distance % 500) != 0) || (distance == 0) ) { segments++; } 
I already finished the project. I presented it today and it's fully functional, except that I can't store the manipulated data in the file. That's the only thing missing. I did even create a log file using the append ("a"), which works fine. But if try the same, I would have "dead record". I tried what /u/FUZxxl said, using vectors. But I stopped. I gotta focus on Maths and other subjects right now. &gt; But why not get on with the times and use a proper external library, for example SQLite, to handle those details. I could have tried that at the beginning, but this is a group project, where I am the only person doing it, and I kinda have to think about the others. Hilarious, right? 
I feel compassion for you. That's always a shitty situation.
I suspect the issue is that you are trying to do random access (writes) on a file format designed for sequential. I am no C programmer, but I am certain that [sqlite3 has the API](https://www.sqlite.org/c3ref/intro.html) to do what you want. Include those libraries and then you can create fetch / update / delete etc. If you don't you will be re-inventing the wheel. Maybe [GDBM]( http://www.gnu.org.ua/software/gdbm/manual/gdbm.html) offers what you need, but that's even further away from my area of familiarity.
thank you this is golden! 
The first line is actually redundant; `typedef struct ex ex;` declares `struct ex` as well as `ex`. 
Ill pay you to do the damn assignment. At this point I just need to submit something. 
I see, like a function prototype. Thanks.
We all missed how you declare main, and the correct way to end int main(void) { ... return 0; /* 0 means no error */ }
Could you post the errors then, please?
these are the ones I get usually: LNK1120 1 unresolved externals (Line 1) LNK2019 unresolved external symbol _main referenced in function "int __cdecl invoke_main(void)" (?invoke_main@@YAHXZ) any help here is greatly appreciated!
Ah I though it would work as a global constant, thank you!
The main point of this problem seems to be that it's testing whether you understand recursive function calls or not. You're correct in thinking that #define is declaring a global constant, but that's inconsequential. Also, yes, an array is being passed as a function parameter, but again that's inconsequential. All you need to know about that is passing an array as a function parameter is equivalent to passing a pointer to the first element in the array, but that opens a whole bag of worms if you haven't learned about pointers yet. So just ignore that for now. I see someone already posted the answer for you, so I guess you have no reason to continue reading this thread, but learning recursion is important if you plan on becoming a programmer. So Google "programming recursion," or actually read your teacher's class notes, as I'm sure you're learning about recursion right now, if this is the problem you're getting. [This lesson on recursion seems to be good](http://www.cs.utah.edu/~germain/PPS/Topics/recursion.html).
Do you want to convert a string into an integer? [atoi()](http://www.tutorialspoint.com/c_standard_library/c_function_atoi.htm) is your friend.
&gt; Do you want to convert a string into an integer? No, I guess. In the demoapp, they are doing this: for(vars = response-&gt;variables; vars; vars = vars-&gt;next_variable) { if (vars-&gt;type == ASN_OCTET_STR) { char *sp = (char *)malloc(1 + vars-&gt;val_len); memcpy(sp, vars-&gt;val.string, vars-&gt;val_len); sp[vars-&gt;val_len] = '\0'; printf("value #%d is a string: %s\n", count++, sp); free(sp); } else printf("value #%d is NOT a string! Ack!\n", count++); } I need to do the same thing when vars-&gt;type == ASN_INTEGER and the data is in val.integer. For some reason, it does not work, I get the wrong number. 
It looks like you understand the allocation part. There is at least one bug though -- you need to initialize i to 0 in your for loop. Also, I might avoid typedef-ing Coord_t and simply leave it as 'struct coord'
It's undefined behavior. That means anything can happen. Part of "anything" means it can appear to work fine. Except that one day the phase of the moon is just right and it stops working. You absolutely can't draw any conclusions on what happens when you invoke undefined behavior. It's simply forbidden to access memory in any way after it's been freed. This is called a use-after-free bug, and in some circumstances it can lead to exploitable vulnerabilities. 
Your test program isn't covered by C99 since `__asm__` is not part of ISO C. If you are using the `-std=c99` switch, and the program `int main(void){}` returns a non-zero value to environment, which you test by checking the return value in the shell or whatever, then that would be a compiler bug. Implementation-defined isn't equivalent to undefined, because undefined behaviour makes no guarantees at all (it could format the hard drive or whatever). I guess you could argue that the implementation could define that it defines no behaviour .. 
Similarly, POSIX reserves the right to use any type sending in _t
I dont know either SNMP or ASN1, but from what i could gleam from the sources `ASN_INTEGER` is encoded as a signed 32-bit number and `val.integer` is a pointer to the actual data. Someone more knowledgeable should correct me if im wrong :p
The program closes the window once it finishes. If you want to keep the window open, you need to force it to stay open somehow. The easiest way to do this is "while (1);" at the end of main. Of course, this isn't a great solution as you would need to "x" the window to terminate. A better solution is to wait for input. Try "std::cin.get();" at the end of main. You might need to add #include &lt;iostream&gt; at the top of your program to use it. This will cause the window to wait for input before ending. std::cin.get()
NO, once you call free(), then you should NEVER use that memory again. Just because your version of free() didn't clear the memory doesn't mean that OTHER versions of free() won't clear the memory. Some secure versions zeros the memory and debug versions fill the free'd memory with a non-zero value to help you find these types of problems. 
rule of thumb, always make the pointer NULL after you free it. 
Piggybacking this to say: it's not like nothing happens! The allocated area will be marked as free for reallocation. The change is transparent to you. Calling `free()` is like telling your coworker that she's free to erase a whiteboard and use it for something - the resource becomes available, but the data you put there isn't immediately destroyed. Instead, it persists until someone else has use for the resource.
nice! and if you would add: const char* folks=["Bob", "Joe", "Eddie", "Martha"]; why do I need to declare a reference to a person with: const char* ref; i.e. again using const?
that is a nice post. to me, one of the differences between C and other languages is the low-level control over code. this makes it hard, but in the end, a computer basically reads instructions and data as bits and bytes. 
sometimes more context can help you make sense of abstractions of computer science. while not related to directly related to C, this section on "why language matters" might provide some help about bits and bytes http://eloquentjavascript.net/00_intro.html . In contrast to other higher level languages, control over structures in memory is much better.
&gt; but it's not erased or anything. And neither does malloc, which means you can allocate a chunk of memory and read it as-is. But the chance of finding anything interesting should be close to zero. 
I never used const until I started doing C++, but const tells both the programmer and the compiler that "this stuff isn't allowed to be changed." Since your char \*folks[] array was declared const, it's gotta be pointed to by a const pointer. If you pass a pointer to folks[] into a function that, say, converts a string to uppercase, the compiler will yell at you, to the effect of "waitaminute! this function *changes* the stuff pointed to, and you declared it as CONSTANT!" 
To make it even worse, he told me to run PHP on the rPi, call the PHP using AJAX and use the exec() command on PHP. To my knowledge, that's totally not done.
Little tip if you write struct coord *foo = malloc(sizeof(*foo)); you can't screw up the type in the sizeof.
nodejs or python are not "less professional." I say this as someone who works in C++ at work 90% of the time as well, so I am not a dynamic language evangelist. You can definitely parse http in C, but this would literally be a few lines of python+a library. 
So python is unprofessional... is nodejs also unprofessional? Does it have to be C/C++? If it must be C or C++ then I agree with the CGI solution. If you can use node then you can do the same thing as CGI, except remove the additional Web server software requirement.
You also don't have to use json to talk to your C code. You could probably just pass a simple text string (like a list of numbers with spaces between the numbers) from JS to your C based CGI script and use the basic C standard library to parse the string. It's far less flexible than using json but it doesn't require setting up as much stuff so you might be able to get things going quicker.
What have you done so far? Which bit do you need to hint to solve?
Why don't you show us what you have so far?
Include the line where you declared the variables you're using. What errors or warnings is your compiler giving you? What do you mean by "doesn't work"? Your biggest issue is with one of those variables, and your compiler should be telling you about it.
Also, the answers in your other thread: https://www.reddit.com/r/C_Programming/comments/3s2xqn/input_validation_with_scanf_or_getchar/ Should have covered this. Why didn't you reply there rather than create a new thread?
don't see the return of scanf being 0 as working there.... this is the code sniper i had printf("Enter today's high, low, and condition separated by commas: "); int rval = scanf("%f, %f, %c", &amp;dailyhigh, &amp;dailylow, &amp;conditions); if(rval == 0 || NULL){ printf("ERROR!Try again!\n"); clear(); } 
they are floats and 1 char inputted into scanf
Please address my other questions as well. Please provide an error description. Please provide the rest of your code, not just a useless fragment.
What do you think `rval == 0 || NULL` does? Please show me the rest of your code.
using `" %f , %f , %c"` seems to work, notice the extra spaces. Just dont forget to clear stdin on errors or youl be reading the same line over and over.
Sounds like something I certainly will have to look at, thanks a lot!
Rough outline * Work out the min value. * start with the highest expected integer value (9) - that's your accumulator. * read each char using getchar() until a newline. * take '0' from the char value to get the integer value * work out the min of that and the accumulator * Loop from the min value down to zero and print each one followed by a space. * Print a new line on the end. This is close to a solution but you'll have to fill in the gaps and write it in C. I just wrote and tested this. C is about cheating. There are some not so obvious ways of doing things that really make sense.
You can use `sizeof(array) / sizeof(array[0])`. However, *this does not work when you pass an array to a function*. In that case you need to pass the length as another parameter (use `size_t`, not `int` for this).
I'm too lazy to research, so I'll ask here. Didn't C11 introduce a way to get the length of a variable length array (VLA)? 
Hints: atoi, strlen, scanf's "%[" format specifier. Also, as above mentioned, it's much easier to iterate over each character in a character array than in an int (as you do in your existing code). Good luck. 
That's the opposite of what it does. It loops until it finds a character that IS the newline character.
The block of code in the while loop executes as long as each subsequent character input in the getchar function do NOT equal \n (newline). 
I don't know what __STDC_WANT_LIB_EXT__ does, but I expect you want it before your #includes since it is going to affect something in them. Points[i].x - points[0].x; Doesn't do anything - you need to assign the result to something.
Exactly, my question is how does that help not having a \n character in the buffer? Because the problem which caused us to write this piece of code was that the \n we type in after our input was being held in the buffer and being read as an input for the next round of the loop. How does this solve that?
This backs up my comment from the other day: /r/programming/comments/3sitao/the_working_from_home_slack_bot/cwxp2ei Email me or call me or fuck off.
I would be okay with a Skype meeting, but the available times are not acceptable for me (one is 10:00 PM and the other is 02:00 AM in my time zone).
Oh. Sorry, by implement I meant emulate part of its function. Our instructor told us to modify the client.c function, again from Beej's Guide, so that it would be able to send and receive messages to and from other clients. Just text only, up to 140 characters.
Oh, cool! Thanks. Now I just have to revisit fork()... Any tips?
Oh yeah. I was thinking that there was something special about the syntax, but I haven't used a vla so I couldn't remember the details. I'm surprised I don't see them used more often 
Just... `fork()`. Any specific questions?
Okay dokay. I thought I'd ask as I remember seeing some people talking about microcontrollers on here. Thanks for the tip.
I'm not removing this post, maybe someone knowledgeable can help you after all. I just want to say that it's unlikely.
Ah, sorry. I'll just check the man pages. Thanks!
You might also ask in /r/embedded 
Why do you think you need to implement a linked list? All the pointer overhead will kill you. Why not just implement a simple circular queue? All you need to maintain is the index of the head and tail; everything else is then usable as data. All queue operations can be implemented in terms of that, for example `push_back()` is `arr[tail++] = elem`, and `pop_back()` is `return arr[--tail]`. (In actual code, all modifications of the indices would be modulo the size, and you'd have to check for empty/full conditions when the head recedes behind the tail or the tail advances beyond of the head, respectively.)
You only need 14 bits for addressing sine 2^14 = 16834 = number of elements in your array - your pointer just needs to be a index into your array. So you can fit everything into a 32-bit entry.
Thank you! This worked and is already implemented, if anyone wants the code: http://pastebin.com/1uCduvSk I'm aware it's not even a queue it's a stack but it worked so I can't complain!
Indent every line of your code with four spaces so that Reddit formats it properly as code.
Write down all your variables on paper step through the commands one by one and update the values as you step through line by line and observe how it operates so you can fix it. Set it to breakpoint/pause just after the print out and then resume stepping through as it attempts to produce the next prime and examine variable values and observe why it can never print out another message. Run the software in your head and observe what's going on. 
oops forgot to change the first lines ty :D Is it better now?
C does not have references. You might be thinking of C++.
like /u/grable said, I am personally a proponent of putting the asterisk next to the type. eg. int* foo = &amp;bar; This is semantically correct, because the "pointerness" of a variable is associated with its type, not its variable. Putting the asterisk next to the type conveys the meaning better than having it next to the variable name. As for declaring multiple variables in the same statement: don't. There's no point in saving a few characters here and there and have to work around a stupid design in the compiler. Yes, the way C/C++ parses it, the asterisk is taken as "part of" the identifier, which doesn't make sense. Hence, declaring multiple variables of pointer type necessitates that. It's a poor design that can't be changed due to 30+ years of backwards compatibility issues, but it is worthwhile to keep in mind that it's not the *right* way.
Pointers in general can be confusing to people new to C (they were to me), but FILE pointers are a special type of pointer specific to files. They are easy to learn and use. You used one on this line, FILE *inputFile = fopen("points.txt", "r"); The "r" stands for read. If you want to write to a file then you would use "w" for write. The first example on [this website](http://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm) gives an easy explanation of how to use fopen(). You could learn FILE pointers on your own in a short amount of time (couple hours or couple minutes depending on how much you already know about C).
Yes, it is! :) Sorry, I'm horrible at looking at my notifications.
No changes to selectserver. Also, to make our work easier, we were told to modify client.c so it would follow specs. And yeah, select() would make it quite easier. If I understood the guide correctly, I would just need to create an fd_set *readfds and use FD_ISSET() to check if a new message comes in, then loop recv() from each file descriptor that's ready. The guide also said to make a master copy of the fd_set because select() modifies the file descriptors for some reason. Also, thanks for the guide! The humor makes it a lot easier for a student with a short attention span to understand. 
Doesn't that kind of fall apart with array and function declarations?
You're welcome! Glad it's useful. :) select() modifies the set in-place, so you can use FD_ISSET() afterwards to test to see which descriptors are ready for reading. Because it modifies the set, the original is effectively mutilated. To recreate the readfds from the original, you can either store another complete set and assign it to readfds before each call to select(), or you can just recreate the set with calls to FS_SET before the select(): fd_set readfds; FD_SET(fileno(stdin), &amp;readfds); FD_SET(socketfd, &amp;readfds); select(...) In selectserver.c, the reason we make a copy of the master set is because there are so many file descriptors in play that it makes no sense to try ti set them all in a loop of FD_SET() calls. Might as well just assign them and make use of C's ability to copy arbitrary objects that way. But if it's just two, might as well set them as in the code, above. :)
Wow, I actually understood that. Thanks!
No, the pointerness is associated with the variable, not the type. The declaration syntax of C has the general idea “a type and then an expression that yields something of that type.” Thus, the `*` is part of the expression, not of the type. This is also the reason why the brackets are after the variable name (because they denote an index expression) and not after the type name.
[This is potentially the only thing I could think of that might help.](https://lwn.net/Kernel/LDD3/) However, I don't know much about this microcontroller and what kind of protocol you might need to use or prefer to use, so this might be a bit too generic/old for your intent.
 yval = ((magscale * sin(x)) + magscale); image[yval][x][blue] = 255; What mathematical units and C types do you think each of those variables are? Try coming up with some sample input and output from just those two lines. For example, with `magscale` defined as 64 and `blue` as 2, what do you think happens with an `x` value of 4?
Both of legal. In my experience, C people tend to prefer it on the variable name, while C++ people tend to prefer it on the type name. As /u/FUZxxl pointed out, watch out when declaring multiple variables with a single type, because the * only applies to the variable it is right before. And remember, even if you never declare more than one variable per statement, someone might come along and change you code later on. In C++, you also have this issue with &amp; and &amp;&amp;.
It doesn't even look like he's using degrees. As far as I can tell, `x` and `y` are being used as pixel coordinates, not angles.
I can see now that it could be interpreted that way, but that was certainly not my intent. I've tried to clean it up a little now. Trying to follow the variables was throwing my brain for a loop. I guess it's a little too late, but sorry OP
This whole idea violates the strict aliasing rule; so make sure you compile with `-fno-strict-aliasing` or your compiler's equivalent.
It's probably remnants of what was in that location before. Which could be code or data. Similar usage patterns lead the same values to be there, but can easily change so it can't be relied on which is why it's called "garbage." This can vary depending on the operating system and compiler. If it's x86 and code, it's probably a JLE instruction and something else.
If it’s something leftover from another process, your OS is very bad at its job. But you can see exactly why the value is what it is with a debugger, or by dumping assembly code and analyzing it.
&gt; If it's x86 and code, it's probably a JLE instruction and something else. Unlikely. There is no reason why a register should contain x86 instructions.
What OS is this? Hypothesis: This may be stack smashing protection dropped in by the compiler.
An int is not a register. While some routines may compile down to using registers, that is not a guarantee by the C language. (Even with the register keyword it's not a guarantee, you can run out of registers). For all I know his int could be globally scoped and all the routines may be loading it from memory into a register first. As for it being a JLE instruction, I am merely speculating what it is. 
Of course, you are perfectly valid when talking about C and C++. Unfortunately, poor compiler design does not mean that it's right. Does it even make sense that the type of a variable has anything to do with its name? Or that the declaration of an array puts the square brackets after the identifier? It makes no sense whatsoever from a semantic standpoint. Most other (new-ish) languages associate the pointerness or the array-ness of a variable with its type; "int[] foo" in things like Java or C#. EDIT: reread your comment, missed the bit where you talked about "a type and an expression that yields that type". You have a point there, and it's valid when applied to C declaration syntax. That's still really odd though.
Automatic variables (the only variables that can be uninitialized) are typically held in registers, thus my comment. Tell me, when does the processor load machine code into registers in a user process?
Exactly
See http://www.mingw.org/wiki/HOWTO_Specify_the_Location_of_Libraries_for_use_with_MinGW
The links [here](http://controls.ame.nd.edu/microcontroller/main/node22.html) might be useful but you have to tell us what SW you are using. 68hc11 is ancient. Check out this [link](http://www.freescale.com/products/more-processors/8-bit-mcus/hc11-legacy:DRMCRHC11FAM). Find the version you are using, and see if any of the app notes or the documents can help you out.
hmm ok, so I added -L with the path to the dll. Now the code compiles (thanks!), but something strange happens: When I run the exe, nothing happens, no error, no printing to console (first thing in the .c file). I can't even cancel by ctrl+C or close the process in the taskmanager.
Maybe you can make the "while" loop value 10 instead of 0 (since you're dividing by 10) then just increment it one more time when "while" finishes. Also, I think the "for" loop's "i" value should be decreasing for each iteration, and it's condition would then be while it's greater than 1. So, you start with your count (like 3 digits), and your iterations are 3, 2, 1, then it stops.
I'm not sure I understand the question, but you can change the value of a variable at any time from within the loop. It's not a separate function with an isolated scope or anything. For example: for(i=0; data[i]&lt;limit; i+=stepSize){ if(some condition met){ i=0; //you can change i to start again from any point } if(some other condition met){ limit=newLimit; //you can change the condition } if(something){ stepSize=2; // you can change the iterator } } I don't know exactly what you're doing but each part of your for statement can be changed from within the loop like this.
They initialize as 0x00000000 on my machine. Doesn't explain what yours is doing, but does suggest you didn't try that many before declaring 0x7EFDE000 "a thing".
 if(var='@') Your if statements should be using `==` to check for equivalence. `=` is the assignment operator. char sen[100]; printf("enter a string\n"); scanf("%c", &amp;sen[100]); `sen[100]` is not a valid location. The highest address you can access is `sen[99]`
I changed it, still the same output. ./a.out "&amp;.,?" Error in input Error in input Error in input Error in input Error in input Error in input enter a string Is there a way to have it create an array the size of what was entered? Like if I left the array blank like sen[] would that do anything?
In C, the common pattern is to provide just an initialization function, leaving the task of allocating the object to the caller. This makes it possible to place the object on the stack among other possibilities. When the object requires complex allocations, it's common to not give the caller any way to control the approach to memory allocation as `malloc()` is sufficient for almost all applications and for the few applications where it isn't, the caller probably won't use a generic data structure anyway. 
&gt; I've got the file "input.txt" in the same directory as the .c program. But are you running the program from the same directory as "input.txt"?
You need to provide all of the source for me to be more helpful, but you have single quotes in that assignment and I don't know why. You also probably need to use strcpy() instead of just assignment.
"it says it can't open the file." You have FILE *file=fopen("input.txt", "r"); if(file==NULL); { return 0; } which doesn't print anything if the open fails. Is the message actually the operating system saying it can't run your executable? Or a different error message somewhere else in the program?
Linked lists are a particularly bad example as you really want to use a specialized allocation scheme for them to be efficient: Calls to `malloc()` can be painfully slow when done frequently and linked lists are, due to the uniform and small size of list cells, well-suited for a specialized allocation scheme.
Why do you write `*(x+i)` instead of the ordinary `x[i]`? 
I have not currently used any strings in my program
Also, for some reason, it's not printing the array at the end. It might be because the array doesn't have any content, but I don't know why that would be
Then what are names and rounds? If you want help, post the entire source. In C, strings are also called character arrays.
I'm looking through it. Is this a homework assignment? It seems kinda complicated for only knowing C for a couple of weeks.
It is a program one of my lecturer's recommended every try to make as we have just finished learning about arrays, its been about 4 weeks since I started learning
Well you always use the same space or blanks between parameters. So when a parameter is longer than other it moves more than short ones.
Is there a simple work around to have clean formatting with every output?
Ouch the slydig. Thank you
+/u/CompileBot C --date --memory --time --version --include-errors #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // Will this work? typedef struct { void * ptr; }recursive; void recursive_struct(recursive *); int main() { recursive * ptr = (recursive *) malloc(sizeof(recursive)); recursive_struct((recursive *) ptr-&gt;ptr); printf("%lu\n", sizeof(*ptr)); free(ptr); return 0; } void recursive_struct(recursive * ptr) { ptr = (recursive *) malloc(sizeof(recursive)); recursive_struct((recursive *) ptr-&gt;ptr); } 
Poor /u/CompileBot will never get out of this one :(
Well, I don't want to change `ptr`, I want to change the value of `ptr-&gt;ptr`. &amp;nbsp; I thought that `recursive_struct((recursive *) ptr-&gt;ptr);` passed the value that `ptr-&gt;ptr` contained, namely the address that `ptr-&gt;ptr` points to. This value is copied to the pointer to `recursive` called `ptr` in the scope of `recursive_struct()`, and thus `ptr` points to the same memory location that `ptr-&gt;ptr` points to. &amp;nbsp; **Edit:** &amp;nbsp; Actually. Since the parenthesis operator `()` and the struct pointer operator `-&gt;`, have the same order of precedence, and that order of precedence, namely the 'postfix' order, has an associativity of left to right, surely the type cast is going to be evaluated before the deference of the `recursive` struct's member `ptr`.
I changed the number in the array-when I do %s instead of %c, I get this error: p3.c: In function ‘main’: p3.c:65:1: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=] printf("%s\n", sen[90]); ^ http://pastebin.com/cnkRJKgn 
`sen[90]` is a `char` type, not a string. Can you provide a sample of input and what you want the output to be?
It sounds like your instructor is compiling C code as if it were C++ (i.e. using a .cpp suffix for C code). This is bad practice and needlessly confusing for students. I suggest sticking to C idioms for C, and C++ idioms for C++, in order to keep the concepts of each language separate and distinct in your mind. 
Do not use cin and cout. C doesn't know these. I would buy a different book, the author seems to have pretty weird ideas.
&gt; will raise an error in compilation time [...] Warning, not error.
Close enough ;) But yeah, you're right: It's just a warning, not an error. It would be better if the instructor would mention that and tell everyone to use -Werror (turn warnings into errors).
Your instructor does not understand C.
I love this kind of exercises. Thank you very much for the link! I'm going to try it out this weekend. Got any more exercises like this one? Thanks EDIT: better if it is for 32 bit :)
If you don't put `-Werror` on your makefile, people will tend to ignore them. And when they do this you'll end with bigger problems in the end. I've seen code where people didn't use `-Werror` and suddenly weird stuff started to crop up. I went back, checked every warning the team was ignoring, and surely enough, the warnings were for stuff that was "grammatically" correct, but there was something stupid behind them. Changing the code to not produce the warning not only made the warning go away, but made the code easier to read and maintain (anecdote time, I know, but again, aren't we going trough our personal experiences on the subject?) It's not impossible, but it's hard to fix all warnings. And you don't keep changing compilers all the time: either you upgrade your compiler (and, since you were taking care of the warnings, most of possible problems will be already fixed) or, if you do cross compiling, you'll use the same compiler again.
If your team ignores warnings unless you supply `-Werror`, then you have a social, not a technical problem. &gt; It's not impossible, but it's hard to fix all warnings. And you don't keep changing compilers all the time: either you upgrade your compiler (and, since you were taking care of the warnings, most of possible problems will be already fixed) or, if you do cross compiling, you'll use the same compiler again. It is possible (and comparably easy) to do so on one compiler. It is very hard to do so for more than one or two platforms at once and mostly impossible without using non-standard C extensions. For example, the following code gives a warning on gcc with glibc: write(STDERR_FILENO, buf, data); The warning is “warning: result of function write unused.” This warning also appears with other compilers and is fine. I'm really sure that I don't care if writing to standard error succeeds though. The standard way to silence this warning is to cast to `void`: (void)write(STDERR_FILENO, buf, data); All major compilers except for gcc stop warning here. gcc doesn't because it was decided 20 years (or so) ago that this warning should not be silenceable except by compiling with `-Wno-unused-result`, which turns off this warnings for *all* functions, which is not what we want. If we wanted that, why do we compile with `-Werror` in the first place? To silence this warning in gcc, you need to assign the result to a variable. However, doing so causes a new warning that the value of a variable is unused. This warning, again, cannot be silenced effectively except by marking it with `__attribute__((unused))` which is unportable. But then, how do we get rid of the warning that the variable is unused on other compilers? There is the convention of casting to `void` again. Thus the almost complete code to ignore this warning is: #ifndef __GNUC__ /* we need test for the gcc version in which __attribute__ was introduced, too, but screw it */ #define __attribute__(x) #endif int unused_error_code __attribute__((unused)); unused_error_code = write(STDERR_FILENO, buf, len); #ifndef __GNUC__ /* if gcc encounters this, it might complain about a statement without effect */ (void)unused_error_code; #endif Another suggestion is to use an empty if-statement to silence the warning: int unused_error_code; unused_error_code = write(STDERR_FILENO, buf, len); if (nused_error_code) { /* we don't care about this error code */ } But this causes other compilers to warn that there is an empty if-statement. Do you know what I enjoy more than fiddling with simple code so it compiles without warnings on a dozen different platforms? Actually writing programs and being productive.
There's often no reason to allow custom allocators. malloc() should be just fine. A fairly robust solution would be providing three functions: struct widget *new_widget(void); void destroy_widget( struct widget *); void init_widget( struct widget *); This way, you can create and destroy them using the builtin functions, or just initialize one without allocating it ( and hence you allocate it yourself)
&gt; malloc() is not, generally, an expensive call. Depends on the implementation and other factors. Generally though, `mallloc` has to keep tab on which regions have which lengths and keep data structures to know where free memory regions can be found. Independently of that, you can expect a constant amount of bookkeeping data per allocation to be stored which can amount to up 100% of the data you allocate in small structures such as linked-list cells, causing 50% of memory to be wasted on bookkeeping. A specialized allocation scheme saves a lot of memory and time in such a situation.
Yes, phone typing sucks
I've updated the sentence reader to fgets so it keeps the spaces when its read, but the print statement still doesn't work http://pastebin.com/KW5SWzQU] I also changed sen[90] to sen[j] but I'm not sure how exactly to get this to work, so the value of j is set at 90 for the moment EDIT: http://pastebin.com/GkxZuP4r Updated link I changed the print statement to a for loop to try and print the characters separately but it still doesn't seem to want to work
You don't want to use tinycc for learning C, it deviates from the standard in many places.
Point taken. Is there a recommended "C only" compiler? My intent was to give the OP an environment where there a C++ compiler won't accidentally get involved, to catch things like the original question. Assuming that the OP is wanting to learn "C only", of course. 
&gt; If your team ignores warnings unless you supply -Werror, then you have a social, not a technical problem. Right, it's related to the [broken window theory](https://en.wikipedia.org/wiki/Broken_windows_theory) and `-Werror` is the easiest way to stop it. We use gcc for almost everything, but we are generating things for x86 and ppc in the same build ([buildroot](http://www.buildroot.org/) and (I think) [Sorcery CodeBench](https://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/) (Edit: Correction, it's [Crosstool-ng](http://crosstool-ng.org/)) for generating the code for all platforms we need) and it's gcc all the way, although our checkers also check CLang compliance (non-compliance isn't treated as an error, but actually a technical debt that should be fixed as soon as possible). And we enforce `-Werror` in all stages. This way no one leaves stupid warnings behind.
Read up on mergesort.
Furthermore, -Werror is an absolute pain while writing code. I know I'm not using that variable yet, but I will by the time I'm done! I'm OK with a warning about it, but an error is overkill. So I often disable `-Werror` while working on code, or at least poke exceptions with `-Wno-error=unused-variable`. IMO, having a culture where warnings are unacceptable is important. Once you've established that, `-Werror` doesn't really matter either way. Because you're going to fix or silence the warning regardless. If someone checks in a change into my codebase that issues a warning, they'd better have a good reason why that warning is A) not an actual problem and B) not going to become a problem and C) not possible to be silenced. Because warnings breed like rabbits, in my experience. They hide each other, you get used to them, and there comes a point when you might as well not even have warnings to begin with. Cases like you showed where you *might* make a case for a warning (though ignoring a write failure to stderr isn't necessarily the best example) are a vanishingly rare exception.
Done!
I agree this is robust to varying user needs. Since I want to avoid putting memory allocation responsibility in widget implementations, I could start with just "init" and "destroy", adding "new" only if/when it becomes worth the trouble. I'm not sure how to decide whether "destroy" should deallocate what "new" allocates...
To be honest, I think printf is easier to understand than cin/cout. printf just does what it tells you to. scanf can be very useful for reading formatted text. For user inputted integers, I would read from stdin and then use strtol/atoi. That should cover 99% of cases. Even in C++, I would never use cin.
Well... if DEBUG then CFLAGS="-Wall" else CFLAGS="-Wall -Werror" end Problem solved? I don't see the issue. Debugging is fine without Werror, just make sure to test the production build as well and fix all those issues too.
Typically you are going to have different optimization flags in a debug build (e.g. -Og instead of -O3). Did you know that gcc produces different warnings on different optimization levels? That's because some warnings are only available from information generated during optimization.
&gt; If your team ignores warnings unless you supply -Werror, then you have a social, not a technical problem. This doesn't argue against a technical solution. You're also over-complicating the code necessary to quiet gcc's result-unused warning. It can be done entirely without extensions and with no need to detect gcc vs. other compilers since gcc in fact doesn't warn about `(void)unused_error_code` (unless you're perhaps talking about some ancient version of gcc).
&gt; IMO, having a culture where warnings are unacceptable is important. Once you've established that, `-Werror` doesn't really matter either way. Because you're going to fix or silence the warning regardless Even with a culture where developers take warnings seriously they'll only silence the warnings they notice. If you don't have -Werror turned on in your CI builds then even conscientious developers may not catch them. &gt; Because warnings breed like rabbits, in my experience. Only if you're not using -Werror, and this is exactly the reason to use it.
-Og is a gcc optimization level that is a bit like -O2 without all optimizations that change control flow. It generates much more sane code than -O0 but the code is still reasonably similar to what you wrote, as opposed to the code generated with -O2 or -O3.
As far as I know gcc then complains about a “set but not used” variable as the `(void)` cast only cancels an “unused variable” warning but not a “set but not used” warning but I have to test that. Still, what if I have to compile this for my Linux 2.4 router with an ancient gcc? I cannot update the box, there is no support for newer Linux kernels and a newer toolchain is too complex to set up.
so it looks like it does this loop twice..... but still says the word "cat" is 1 word at the end. While i put in more words (4+) it gives junk values to the final loop, and i have no idea why
I have encountered problems like this, and found it difficult to debug when I have something incrementing inside a for() loop. In your case you have the i++ in the for() statement. Then inside that you have an I++ inside a while inside the for. The while loop may push the value in I past the limits you defined in the for() statement. Sorry about the formatting - iPad 
[removed]
Do you know any good resource to learn about linked lists? I google'd it and understood the concept, but I don't understand how it works.
wait wait, you're the actual author of the beej guides? *SWOON* they are sooo good, i use them all the time and recommend them often!
http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_linklist.aspx
If you don't want to deal with linked lists yet, you have another option. You could open the file for reading, open a second (temporary) file for writing, then loop through the records, reading each one. If the record doesn't match, just write it to the temp file as is. If it does match, then update it before writing it. At EOF, close input and output, then rename() the temp file to the input filename. This is somewhat crude, but easier to implement. The linked list method is more interesting though, and also would allow you to make multiple changes to users before updating the file and exiting the program. I read "The C Programming Language" cover to cover to learn C (a long time ago). That is an excellent book and I'm pretty sure it covers linked lists.
Even better, use `M_PI` from `math.h` which exists just for this purpose. For 4π², OP could use `(4*M_PI*M_PI)` and trust the compilers constant folding to do its job. I wouldn't use `pow()` though as the compiler cannot fold a `pow()` call that easily.
Thanks! I actually start out with that and work inwards.
&gt;Also I do not understand why pointers and malloc has been used here The author is either a noob or a fossil. Self-taught coders often use the first method they thought of which seems to work, despite simpler alternatives being available. Alternatively this code might have been written 15+ years ago. 
You are programming C on Android? Wow, that's something I've never seen before. How convenient is it to program on Android?
[**DroidEdit (free code editor)**](https://play.google.com/store/apps/details?id=com.aor.droidedit) - Search for "Droidedit" on the [**Play Store**](https://play.google.com/store/search?q=Droidedit) --- ^*bleep ^bloop* ^I ^am ^not ^a ^bot. ^Apparently ^this ^subreddit ^doesn't ^have ^the ^app ^robot ^that ^/r/Android ^has. 
Are you actually editing code on the android device itself? If not then just use any editor?
most text editors try and format text according to normal English rules, capitals, punctuation, etc
I mean any code editor. There are dozens with syntax highlighting and other useful code features, this isn't specific to Android
Thank you for breaking it down for me! But I'm still confused on what NULL terminators do.
I use a GNU chroot on my phone and use vim to code, makes it easy to compile and test the code too unless it's graphical (though there are some ways to achieve that too)
I was going to say this, but tell him to do tetris. I still have a version of Tetris I wrote a while back while learning SDL. If OP wants I can share the github, but the code has some not so nice points (like loading all the images from their own file instead of a spritesheet) because it was my first go at SDL.
I don't think this is a great list. Obviously its nice for inspiration, but I don't think a lot of thought was put into making any sort of knowledge build up happen. Some of them don't even make sense.
"Question here: if last = left, then ++last = left + 1 in swap(v, ++last, i); then it means the function swaps, for example, v[1] with v[1]? Typo? Should it be last++ and not ++last?: At every step this algorithm makes sure that the span left to last is &lt; v[left] (the partition element) . The increment is necessary to keep track of the last known split, however I think you are right that the swap is not necessary when the elements are the same. It might be the case that checking whether you are swapping the same element is not really less expensive than just swapping them.
You could call it create() and destroy(), and destroy would definitely deallocate what create did. Likewise, you could have init() and finalize() that are separate of the user wants to do allocation differently.
Could you please suggest some good C tutorials for sdl? Thanks 
I don't understand the bruteSequential function and why it has been used/why it is necessary. Can this not be done without pointers?
So could one say that this is poorly written?
I did not know that hello world used pointers, how come malloc() isn't used in that case? The part that I don't understand in particular is the bruteSequential function. Thanks for clarifying the recursion though, I'm looking for ways to implement it in my code, heard recursion was a good practice.
Depending on the desired scale of the project, these suggestions might be useful. I have been programming in C fr two months, and two mini-projects I have learned a lot from are: * A sudoku solver. Enter a sudoku, and the solution comes out the other end! * Minesweepeer. A simple game. Can be made directly for the terminal, or with advanced GUI! On the list of future projects I have: * Snake with advanced GUI. * A basic calculator with GUI. * A financial calculator, that spits out a file, instead of paper (You know the good ol' Casio Financial Calcs, right? :D ) * A physics simulator of sorts. Maybe a simulation of a star system, or some basic 2d-gravity sandbox. * A small logic circuit simulator (As an alternative to Logisim, which is no longer in development, and is full of bugs...). * A 2D portal-like game. Could be a tough task, depending on how you attack the problems of this one! 
&gt; I did not know that hello world used pointers What's the signature of `printf()`? int printf(const char * restrict format, ...); The function takes a pointer to `const char` as its first argument. `"Hello, World"` is a character string literal, which represents an array of 13 char (i.e. type `char [13]`) with static storage duration. Following the normal rules of pointer decay, it decays to `char *` (i.e. a pointer to the first character of the array) which is then implicitly converted to `const char *`. (Even though its type does not properly reflect it, the char array that a string literal refers to may not be modified. C++ fixes this oversight and gives string literals type `const char [n]`.) &gt; how come malloc() isn't used in that case? Pointers and dynamic allocation are two separate things. You don't need dynamic allocation to work with pointers. The second argument to `scanf()` in the program above is another example of a pointer that doesn't have anything to do with dynamic allocation. &gt; The part that I don't understand in particular is the bruteSequential function It steps through every possible password length from 1 to maxlen, and asks `bruteImpl()` to generate all passwords of each length. 
[Lazy Foo' SDL tutorial](http://lazyfoo.net/SDL_tutorials/) I'd also like to add the suggestions of a commandline shell, and anything else you can think of that requires external libraries (I've found that finding and reading documentation to figure out how to use a library is an important skill of its own, SDL is probably one of the easier ones, at least with the Lazy Foo' tutorial) Edit: forgot that Lazy Foo's tutorial uses C++, but I think it's close enough, same library (no C++ layer over it)
It uses malloc unnecessarily, which introduces extra complication that was not required.
A common one is sudoku-solving.
You're missing a } somewhere.
but where ?
I don't know. You didn't post the whole file. What line number does the compiler error point at?
As FUZxxl said, the '\0', or null terminator, is used as a signal to various things in C. String functions, like strlen or strcmp, use it to figure out where your strings end. If it is not present, these sorts of functions will not know when to stop reading your string and will continue indefinitely until it reads a null from garbage memory or wherever it traverses to (that's if your program doesn't crash by then). Because of this, there are newer functions that are memory-safe, such as strnlen or strncmp, in which the 'n' is the size of the string you pass in. These functions will then know when to stop reading your strings whether they're NULL terminated or not, but they still better be! Hope this helps.
Note: for strnlen, n is more of a limit check. You're telling the computer "hey, if you hit n=25 characters while figuring the length of this string, just return 25 as len and don't read any further!"
Please dont post pictures of your source code, a text is way better. Your idea/plan for generating random operators is good, but... operators[2] is '*', it's a character (char) with ASCII value 42. In C, char can be used to represent characters in a string. Behind the scene they are nothing more than numbers ( integers ). So your code/program does exactly what it is supposed to do : 5 + 42 + 2 = 49. Intuitively it seemed like you expected this character to be interpreted (evaluated) as a statement (*). It doesn't work that way in C. You have to explicitly execute the multiplication. Let's say you have a temporary "results" that is equal to 5. To execute the multiplication you have to do something like : results *= 2 Now since it is an assignment, you have to think about it a little more to provide a solution that is clean and works for every number and operator :)
That's not the modulus operator, it means the absolute (positive) value. See abs or fabs depending on the type of yn - y0
If `health` is the first structure member in both cases, you can safely assume that they occupy the beginning of the structures. Thus, you can safely cast a pointer to a cat or dog structure to an `int*` to get the value of the `health` field *if* that field is located in the beginning of the structure in both cases.
Why cant u struct animals and have a string named specie
If you know if the entry is a cat or a dog, you can use an `if` statement to distinguish these two. Your problem description is a bit vague and I don't quite understand what you need, could you elaborate.
I don't understand how to sort it into the linked list. How do I sort the array of cats while also taking in account for the dog?
Just extract the `health` field from both of them and compare that.
Consider using a union for animals, rather than a struct. One member of the union would be a type flag indicating whether it was a dog or cat (should probably be an enum rather than the bare ints you have now, but whatever), the other member would be a pointer to the dog or cat struct instance. At that point you iterate the linked list, inspect the type, cast the pointer to the appropriate type, and sort based on the health.
That seems easy enough, but how do I compare all 4? There are three different health values for the cats.
Unfortunately we haven't been taught unions
Look up sorting algorithms. For your problem, you could also just code all 24 possible cases. Just try.
Ah. This reminds me of the kind of exercise where they make you drive nails with a rock, and then later they reveal the existence of hammers and say, "isn't this so much better!". I usually hated such exercises, but I do understand they can't teach everything at once. Okay, *not* using unions, just to be cavemen and drive the rocks with nails and ignore pneumatic nailguns... Have your animals struct have a type identifier, like I mentioned, that indicates whether the current node in the linked list is supposed to be a dog or a cat. Have *two* pointers: one that points to a dog struct, and one that points to a cat struct. Based off of the type field, only use (dereference the pointer to) the appropriate one for that node, ignoring the other pointer for that node (and the space it wastes). Does this make sense?
"This is most often used (as in the example posted) to convert digits in character form ('4') to integer values in the range 0 to 9 ('4' - '0' == 4)." Is this the reason?I think I get it then :)
In mathematics, the value |x| is known as *the modulus of x*, and the remainder operation is known as *modulo*, with the associated operator being *the modulo operator*. Somehow, some computer science references have managed to mix the terms up. 
Complex numbers Perfect numbers Superperfect numbers Imaginary numbers Transcendental numbers Surreal numbers ... I'm 99% sure mathematicians are trolling us.
I haven't read the entire pastebin yet, I will if this doesn't answer your question or doesn't make sense in context, but I'd say consider using a union for this. One field would indicate if the current entry was a hero or a boss and the other would be a pointer to the appropriate struct for that data type.
This submission is not about C. Therefore, it's off topic in this subreddit and was removed just now. Please show how your submission relates to C next time you post.
I'm an engineer, not a mathematician - I've only heard it in the context of complex numbers personally, but you're probably right! I don't know better.
That probably comes from the divisor in the modulo operation being called modulus. 
How far have you gotten? It looks like you haven't filled in any of the TODO lines, even the ones that pretty much say exactly what to do. You'll have better luck here asking specific questions, nobody wants to do your project for you.
Is this 'friend' your professor? Because it sure sounds like homework. What's your actual question? In what way have you tried to solve the problem yourself? If you're not sure where to start at all, talk to your classmates or TA or professor and ask for help. If you've tried a few things and need some guidance, post details of what you've tried and where you're stuck. Ask a specific question. 
So you can't use google to search for "how to use malloc"? Because I'm pretty sure there are thousands to millions of examples online with the answer you seek.
http://pastebin.com/zQcy6QqB
I hate to be "that guy" but this is your homework and not mine so I'm not going to do it for you. I will have ever suggested that you look into how strings and words are stored in c. Put some printf() or breakpoints in the process_file function and see what's actually being pointed at. In addition look at your while loop. Does it ever exit? If not why not?
Making a linked list with different types is very very awkward (you will need `void*` and convert back to the right type (which you have no way of identifying)). I suggest you use a higher level aggregate with a `union` struct higherlevel { int type_of_animal; /* 1 = dog; 2 = cat */ union animal { struct dog dog; struct cat cat; }; }; 
There is also *norm*, meaning absolute value.
Use the `break` statement. When `break` is encountered, the loop immediately aborts.
 for { // calculations if (fabs(x-xy) &lt; LIMIT &amp;&amp; fabs(y-yy)...) break; } Like this? 
 oldX = x; x = expression; xo = x; oldX should store the old value of x. 
Well, it's equivalent of moving the xo = x; statements before the expression that assigns x. xo = x; x = expression; Now the values of xo and x will always be different. If that doesn't work, then start all over again. o~o
Yeah i know, tbh im a amateur doing it for a uni assignment, so im not expected to get it 100% efficient so i think this will do, if you can think of a more efficient way of doing it then please help me out :P Thanks again
You've also placed the second if statment inside the first, which isn't what you want. Add a loop and correct the braces around the if statements and it should work. edit: I should say the conditions of your if statements don't do what you think they do at the moment, but you're going to move some of that logic to your loop condition anyways.
&gt;gets() takes one character from standard input. gets is "get string". Your brain is telling you it's getc apparently. Give it more coffee. You're right about needing a loop, but it needs to go around the counting statements not this part.
You want to loop over 'str' and check isalpha and isdigit for each char: while (str[i]) { // if str[i] is alpha =&gt; countA++ // if str[i] is digit =&gt; countD++ i++; } and then print the results using printf. The while-loop will end when it reaches the null-terminator in the string.
The `isalpha` function/macro returns either `1` or `0` (meaning: is alpha, and is not alpha, respectively). You meant `== 1` instead of `!= '\n'`, although it's more usual to omit the comparison entirely. `gets(str)` should be replaced with `fgets(str, 100, stdin)`.
A couple of options 1. you can pass a pointer to node-&gt;test1 instead. 2. If the members have different types, an enum and a switch statement will do it.
A macro might be your best bet here: #define function(x, node) do { (node)-&gt;x = malloc(sizeof *(node)-&gt;x); } while (0) 
Excellent! :) Someday I hope to have enough free time to write more of them.
if you are trying to manipulate the node test1 and test2 char* fields you could just do the following: func(char* arg1,char* arg2) and then call the function with func(node-&gt;arg1,node-&gt;arg2) within a separate function. Hope this helps CraftyNecromancer 
code: void f(unsigned x) { while (x) { putchar(" *"[x &gt; x + x]); x += x; } putchar('\n'); } int main() { unsigned x = 1; do { f(x); x ^= x + x; } while (x - 1); } output: * ** * * **** * * ** ** * * * * ******** * * ** ** * * * * **** **** * * * * ** ** ** ** * * * * * * * * **************** * * ** ** * * * * **** **** * * * * ** ** ** ** * * * * * * * * ******** ******** * * * * ** ** ** ** * * * * * * * * **** **** **** **** * * * * * * * * ** ** ** ** ** ** ** ** * * * * * * * * * * * * * * * * ******************************** [meme](http://i.imgur.com/fu9EXBn.jpg)
What complicated code? He draws a [Sierpinski triangle](https://en.wikipedia.org/wiki/Sierpinski_triangle) by observing the remainder of the [binomial coefficients](https://en.wikipedia.org/wiki/Binomial_coefficient) modulo 2. OP could efficiently computes these remainders with the [theorem of Lucas](https://en.wikipedia.org/wiki/Lucas%27_theorem) but he chooses to use the recursive formula for binomial coefficients instead. Really basic stuff.
Throw in the terse/clever indexing into the char array `" *"` with 0 or 1, based on the truth of `x &gt; x + x`. Nice. 
A few other things: int score; You have score declared as an integer (whole) value, but you're comparing it against decimal (fractional) values. Unless you're restricting input to 1 decimal somehow, you're missing cases between the boundaries (like 0.805). Try using an `else if` condition instead of this set of `if`s. sscanf(line, "%d", &amp;score); Try printing out score after this step. I don't think it will be what you expect. You have an unconditional break statement in your loop, so why bother having a loop?
Also, score is an integer so it will never be between .9 and 1
OP want `break`, as he specified above.
It would be worth understanding the difference between stdin and program arguments. The question isn't clear about how you are receiving input.
Jar
This is the first task in the code //TODO: Use malloc to create an array of the initial size. Assign to the arrayPointer variable Do you know how to use `malloc`? This is a very basic task, you should be able to do it. What part of this line is giving you trouble?
No, as `!` is logical not, not bitwise not.
That's undefined behavior. In describing the cast operator, &amp;sect;6.5.2: &gt; Syntax &gt; &gt; cast-expression: &gt; unary-expression &gt; ( type-name ) cast-expression &gt; &gt; Constraints &gt; &gt; Unless the type name specifies a void type, the type name shall specify qualified or unqualified scalar type and the operand shall have scalar type. A union type is not a scalar type. (&amp;sect;6.2.5/21: "Arithmetic types and pointer types are collectively called scalar types.") But it doesn't matter — even if the cast was kosher your whole plan involves invoking undefined behavior. You're only allowed to read a member of union that was the last member written to. If you write to `u.i` and then read from `u.f`, you invoke undefined behavior. (&amp;sect;6.7.2.1/16: "The value of at most one of the members can be stored in a union object at any time.") Unions are not meant to be used for typecasting.
How is the `~` operator not well-defined for a `signed int`? It flips every bit, just as it does for an `unsigned int`. This would include a flipping of the sign bit. EDIT: Said another way, I don't believe an implementation could define `~` to do anything but flip every bit of the integer quantity, regardless of `signed` or `unsigned`. If the quantity is 16 bits, all 16 bits are guaranteed to be flipped. If the quantity is 64 bits, all 64 bits will be flipped. Etc. (Ditto for `char`, for that matter.)
So what would `printf("%d\n", ~0);` do? It depends on the representation of int: * 2's complement --&gt; `-1` * 1's complement --&gt; `0` or possibly undefined behaviour * sign-magnitude --&gt; `-2147483647` depending on size Further: in all systems there may be *padding bits* anyway (e.g. a parity bit). The definition of `~` (and the other bitwise operators) doesn't make it clear whether they also operate on the padding bits. For example, perhaps using `~` on a parity-checked integer would end up with an integer failing the parity check and generating a trap. 
Well, it could be that `~a` produces a trap representation and therefore undefined behaviour. For example, the standard permits the "negative zero" in 1's complement to be treated as a trap representation. Unfortunately we will be unable to test this since such systems are hard to get access to... 
The understanding of mallow and how to use it
So a couple of things here. First, your post is basically unreadable. As mentioned in the submission guidelines, you need to put 4 spaces in front of every line of code to have it show up cleanly. Alternately, with this amount of code, you can post a link to a sharing website. Consider something like http://www.tutorialspoint.com/compile_c_online.php since it will allow others to easily edit and compile the code. Secondly, you haven't asked a question. I see a few instances of `//Not working`, but that doesn't mean anything. Are you having issues compiling or running the program? Is the output not what you expect? What is the intended behaviour and what do you actually see? Third, this is clearly a school assignment. Some of us are willing to help you with this, but nobody is going to do it for you. Also, you probably want to remove your name from your post.
http://linux.die.net/man/3/malloc should have everything you need. Have you not covered this in class? 
Slight nitpick here, if you are using a C99 or newer compiler, type punning is allowed (as u/danielcamiel pointed out below). There is no undefined behavior invoked by the read, but the value could be indeterminate. The GNU C extensions do allow cast to union as a construction of a compound literal. As long as the compiler supports GNU extensions, this behavior is fine. That said, I doubt every embedded compiler on the planet supports the GNU extensions.
I wrote a Makefile that did this. Big hint.
The C standard clearly says about `~` in ISO 9899:2011 §6.5.3.3. ¶4: &gt; The result of the `~` operator is the bitwise complement of its (promoted) operand (that is, each bit in the result is set if and only if the corresponding bit in the converted operand is not set). The integer promotions are performed on the operand, and the result has the promoted type. If the promoted type is an unsigned type, the expression `~E` is equivalent to the maximum value representable in that type minus `E`. No mention of undefined behaviour, therefore I conclude that there isn't any. Of course, the *arithmetic* value of `~E` isn't the same on different `int` representations, but I don't depend on that.
&gt; No mention of undefined behaviour, therefore I conclude that there isn't any. Well it's the opposite really: if something is not defined then it's undefined. Other parts of the C11 standard go into more detail about negative zero being a trap representation. What do you think would happen when `~` generates a trap representation?
No, `~a` could not produce a trap representation. A trap representation is a representation of a type that does not represent a value of that type (cf. ISO 9899:2011 §6.2.6.1 ¶5 and §3.19.4). Since `~a` returns a *value,* not a *representation,* it cannot return a trap representation. You are right though, there is one tiny corner case in which `~` can yield undefined behaviour, cf. §6.2.7 ¶4: &gt; If the implementation does not support negative zeros, the behavior of the `&amp;`, `|`, `^`, `~`, `&lt;&lt;`, and `&gt;&gt;` operators with operands that would produce such a value is undefined. Good luck finding such a platform.
So what does `~0` yield on a system where all-bits-1 is a trap representation for `int` ? 
&gt; I see a few instances of //Not working I'd like to remind OP that “It's not working” is not an error description. A good error description comprises three parts: * What did you try to do? * What did you expect to happen? * What happened instead? “It's not working” contains none of these.
On these systems, all-bits-1 cannot be a trap representation (as it's a value) unless all-bits-1 is a negative zero in which case behaviour can be undefined as stated elsewhere.
Not OP, but I've certainly encountered a handful of situations where I could have used such a forward declaration, usually when the enum is declared in a header with a bunch of other stuff I didn't need. Including the whole header means increasing compilation times, especially if it results in widespread file dependencies. Admittedly, the fix is often to simply extract the enum declaration to another file, but it's still annoying. Also, the reason you can only do certain things with an incomplete type is because in many situations, the compiler needs to know the size of the type (e.g. when used as a struct member). Granted, the C standard leaves `sizeof(EnumType)` to the implementation, but if it were possible to specify the underlying type like in C++11, I don't see why forward declaring an enumeration type would be problematic.
I suppose the standard solution is to use the intended underlying type directly (perhaps `typedef`'d) and not mention the `enum` at all in headers. But a forward declared, incomplete enum type would be nice for showing intent in the code directly, even though the compiler wouldn't save you from e.g. passing in a bad enum value to a function.
there is some existing code in my project and i'm modifying it. some struct{ uint8_t a; uin8_t b} struct variable **a** is actually used for filling an enum which was defined later in the file something like. typedef enum{abc, xvz} my_enum_t; I know i could reorder the things, but just curious if i could forward declare the enum and see if it works and it didn't. 
But see, that's just impossible. The implementation does not know what underlying type the enumeration will have until you've listed all its members. It's free to pick an integer type based on the number of constants. If you only have a handful, then maybe it picks `char` to save some space. But that information is required at the point where the struct is defined. The size of each field must be known. But if you haven't yet listed all the members of the enumeration, you haven't given the implementation a chance to pick a type yet. It's just like I said before: you can't do much with an incomplete type. You're essentially asking the compiler to instantiate something that can't be instantiated. It's like trying to do this: struct foobar; struct foobar f; How is the compiler supposed to know the layout of `f`? It can't. It's an impossibility. The only thing you're allowed to do is struct foobar; struct foobar *fptr; Making a pointer doesn't require knowing the layout of the struct. Unless your struct was going to contain a pointer to an enum, what you're asking for is just physically impossible. 
makes sense. Thanks. 
thats helpful. Looking up.
&gt; One last note is, as your desire for error reporting increases, it becomes necessary to read signed values rather than unsigned values because the functions in the standard library for reading unsigned values (e.g. strtoul, *scanf("%u", ...)) perform in a way that is typically unexpected when reading negative decimal values. So its better to just parse signed and check afterwards. Can do that. In your awesome long example, I don't understand one thing: You say `n &lt; min`. If `n` and `min` both are `long` and `min` is the lowest long, how can `n` be less than `min`? BTW, thanks for the help! All much cleared up now.
I don't know any offhand, but clearly they exist because the text relating negative zero behaviour was added to C11 .
There's no technical reason. It's just that it was never added to the ISO standard, presumably because there was little demand for the feature. I can't think of anything useful you could do with this bearing in mind that it would have to be an incomplete type as we don't know the size of an instance of the enum until we've seen the enumerator definitions. GNU C supports this as an extension. 
Beautiful!
Sure!
Here is how my implementation works: 1. The Sirpinsky triangle is related to the [Pascal triangle](https://en.wikipedia.org/wiki/Pascal_triangle) in that it's the Pascal triangle modulo 2. 2. We can efficiently compute the remainder of binomial coefficients modulo *m* with the aforementioned theorem of Lucas. 3. By the theorem of Lucas, a binomial coefficient *n* choose *k* is odd if and only if the binomial coefficient for each digit in binary representation is 1 as otherwise the product is 0. 4. For booleans, there are four cases for the binomial coefficient and the result is 1 for all cases except 0 choose 1 where the result is 0 (as for all cases of *n* choose *k* where *n* &lt; *k*). 5. Thus we can compute the binomial coefficient of two booleans *n* and k* as `(n || !m)`. 6. We can use bitwise arithmetic to compute the binomial coefficients for all binary digits at once: `(n | ~m)`. 7. We can check if the result is all-bits 1 by inverting it and comparing with 0: `0 == ~(n | ~m)`. 8. By [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws), `~(n | ~m)` is equal to `(~n &amp; m)` and we can use `!` instead of `0 ==` to get `!(~n &amp; m)` to check if the binomial coefficient of `n` and `m` is odd.
This is the correct way to go about it and how **a lot** of API handle callbacks. Typically when "registering" a callback with a particular API/framework, you are given the chance to provide a `void *`, which is usually named `context`. It is up to the application utilising the API to ensure that it points to something meaningful. As a crude example: struct mycontext { int x; int y; }; int mycallback(apihandle_t handle, void *context) { // obtain a pointer to our original context and do some things struct mycontext *c = context; printf("%d\n", c-&gt;x); c-&gt;x++; c-&gt;y *= 3; return c-&gt;y; } int main() { struct mycontext c = { 3, 4 }; apihandle_t handle = api_create("peanut", 4, 0.33333f); api_setcallback(handle, mycallback, &amp;c); api_dosomethingcool(handle); // API calls your callback, providing context to the function api_delete(handle); } 
I want to replace some of the random letters in there into letters of my own choice that make sense for example if the table is like A G V E S Y B S W i want to replace that with the word BOAT so ; A G **B** **O** **A** **T** B S W 
You might find that fgets(), strtok(), and sscanf() would be a little easier since you have a variety of field separators in your file.
Use this `scanf` invocation: scanf("%3c %d/%d %lf %3c - %3c %d - %d %lf\n", ...); where `...` is pointers to all the struct fields in the appropriate order. That *should* work, although I haven't tested it.
Not sure what difference it makes, care to elaborate? I thought I had to juse fscanf since it's a file.
In addition to the other answers, your arrays are not long enough for your data. You cannot fit "fre" into weekday[3] because you're forgetting about the nul terminator.
Great it almost works! Result I'm getting: data[1].weekday = Fre data[1].date = 18 data[1].month = 07 data[1].time_of_day = 18.30 data[1].home_team = FCNFCV@ data[1].out_team = FCV@ data[1].home_goals = 3 data[1].out_goals = 2 data[1].viewers = 3.349 Problems at the team names, what can I do to fix that? Thanks alot!
It seems to work the the current code from /u/FUZxxl. Should I be concerned then?
This is because of the lacking `\0` terminators as /u/jedwardsol mentioned. The data itself is fine, there is just garbage being printed after that. Make all arrays one longer and change all `%3c` to `%3s` to fix this.
That is reading 3 chars into a 3 char array, which is fine. However, this doesn't make a string. The responsibility is now on you to never use anything that wants a string on these arrays (strcmp, printf(%s)) - which is also fine, if you don't want them to be strings you don't have to. Howver, i suspect you want them to be, so make the arrays 4 long, and put [3]='\0'
Is there any particular reason you're doing this in C? It's pretty much the worst possible choice for handling piles of text.
my bad with the array thing, i was going to try something with it but realised it wouldnt work and forgot to remove it Havent learnt about pointers yet, but apparently we're not required to use them for our class assignment sadly
That's alright, to do it without pointers you could make the character grid a global variable so other functions you make can use it too.
16 % 10 yields 6, 16 / 10 yields 1. You need to use `%` and `/` in a loop to extract digits from the number.
It's not true that NULL is not meaningful. It is by definition a semantic.
Does the server really need to know which threads are running at the moment? When a client connects, you could simply create a thread on the stack and detach it immediately, e.g: pthread_t thread; pthread_create( &amp;thread, NULL, thread_function, NULL ); pthread_detach( thread ); When the thread returns, the pthreads library will clean up everything for you. If you want to give data to the main thread anyway, create a data structure (e.g a variable-length array of integers representing completed threads, perhaps) and a mutex to prevent multiple threads from accessing it at the same time. Creating a separate thread for every connection isn't necessarily the best way of handling server networking, by the way - they have some overhead, and mostly do nothing waiting for the data to be transmitted over the network. You might want to check out things like epoll (if you're on Linux), with which you can wait for many sockets asynchronously. It's pretty easy to make mistakes in network programming, as well - e.g. assuming that what you get when you call recv() is the same length as the data that was sent on the other side. If you post your source, I can look it over for you.
Yes it was a mistake I wrote the post quickly, I am aware that it starts at 0, but Thanks for headsup :-) 
He's being pedantic because you said NULL is not meaningful, but meant that it isn't a meaningful memory address. 
NULL checks are only good if there is some sort of pipeline that will produce NULL pointers on failed operations. An assert on the pointer returned by malloc is good practice.
&gt; Is there a sort of "agreement" between devs and users stating that this is the user responsibility to not pass NULL pointer ? That's always the case, regardless of whether the library checks for it or not. Pick your favorite standard library function that takes a pointer (e.g. `strcpy()`) and try passing it NULL. You will probably get a crash of some kind, because it's sure as hell not going to bother to check that you didn't pass NULL. That's your job, not its job. "Garbage in, garbage out" as they say. (This all assumes that the function in question has semantics where NULL is not an allowed value. For example, `free(NULL)` is documented as a no-op, not undefined behavior.)
You're welcome. :-) &gt; You say n &lt; min. If n and min both are long and min is the lowest long, how can n be less than min? You're right that it can't be, although that particular scenario is tested by `(errno == ERANGE &amp;&amp; n &lt; 0)`. The test `n &lt; min` is for when min is assigned a value greater than LONG_MIN. My reason for adding those two test, `n&lt;min` and `n&gt;max`, is to make it easy to limit the acceptable range (e.g. min=0, max=999) without having to modify the rest of the source code. 
There are 'contracts' to using an API, for example most str* functions require a NUL char to represent the end of the string.
Well, the size of a struct isn't known either, e.g.: struct S; so that isn't a valid objection. Re-read my comment as I addressed that issue. 
It can be hard to design interfaces that can be used comfortably. Something I find helpful is writing code that uses the library, to get an idea of how it should be designed. If I had a program that read its configuration from the following file, ; last modified 1 April 2001 by John Doe [owner] name=John Doe organization=Acme Widgets Inc. [database] ; use IP address in case network name resolution is not working server=192.0.2.62 port=143 file="payroll.dat" And I wanted to access the server and port so I could connect to them, maybe something like this would be easy to work with: char *node, *service; if ((node = iniget("database:server", &lt;handle?&gt;)) == NULL) node = "127.0.0.1"; if ((service = iniget("database:port", &lt;handle?&gt;)) == NULL) service = "143"; fd = tcp_connect(node, service); But if I had another use case, such as translating an INI file to another file format, an interface like this would be excessive and parse_ini_str will do the job nicely. Even if I were to think about the iniget function described above, I'd need to look to something like your parse_ini_str function for its implementation, so you're definitely on the right track with that function as it could be considered a necessary primitive for reading INI files. The thing to think about now is how would you want to use the library at a higher level, e.g. beyond reading and processing one line at a time from a file? It's my feeling that parse_ini_file probably does't offer much benefit over fgets+parse_ini_str to the caller, whereas something like iniget would help out a lot, at least for the purpose I've illustrated above. It's worth having a think about other purposes you might like to use this library for, as well, and adding some wrapper functions that are comfortable to use for those. 
I always put "conditional compile" code at the top of all of my functions to validate parameters aren't NULL, so I can catch the problem during development. At some point after everything seems to be stable, I'll disable it, then I'll re-enable it for sanity checks every so often to make sure I haven't made any further mistakes. I leave it as a permanent part of my code base. When I malloc() space for a dynamic structure, I zero the structure with memset() before filling each structure member. If a structure member is a pointer, then zero-ing can be a source of NULL pointers caused by accidental coding mistakes, thus parameter NULL checking can find these problems. I always validate pointers coming back from malloc() or any function that allocates memory internally, and never disable that code. 
a safe strcpy() checks pointers against NULL
It could be done crudely like this: char buf[8192] = ""; char *s; int i; s = buf + sprintf(buf, "bash"); for (i = 1; i &lt; argc; i++) s += sprintf(s, " %s", argv[i]); system(buf); There's at least a couple ways to modify this so it will work without a buffer limit. The first option would be to compute the length of the destination string, either with strlen or snprintf, then allocate a buffer of that size and use this same method to copy the data to it. The second is to write a function that concatenates and resizes a growing array using realloc(). 
should not the year will be the first entry of each row in the csv file
Define 'valid' NULL pointer, if you mean my previous comment on NULL == 0 what is (void *)0 then?
&gt; My reason for adding those two test, n&lt;min and n&gt;max, is to make it easy to limit the acceptable range (e.g. min=0, max=999) without having to modify the rest of the source code. that is cool though. I ended up with a readNum method which shows whether there was an error and uses atoi inside. Thanks again.
The state machine logic is definitely uglier than I intended it to be when I started. That's probably also because I didn't plan the entire machine upfront, it grew somewhat organically. An example would definitely be appreciated though, thanks.
Remember to include this thread as a source of help in the assignment appendix, when handing it in to Aalborg University.
This subreddit is not for advertisements. Please look for hires elsewhere.
I like the iniget(&lt;handle&gt;, "path") format, but what the path should be can be discussed. /database/port or database:port? If you want to expand this you can make some form of querry that you can do on /database/ that will return server,port and file. It could also be useful with something like ini_get_int(handle, "/database/port"); Maybe setters as well as getters?
oh wow i didnt see that coming haha thanks so much that should really simplify things!
&gt; I always put "conditional compile" code at the top of all of my functions to validate parameters aren't NULL, so I can catch the problem during development. At some point after everything seems to be stable, I'll disable it, then I'll re-enable it for sanity checks every so often to make sure I haven't made any further mistakes. I leave it as a permanent part of my code base. Why not use assert()?
... because assert() takes wastes code space in a microcontroller, and cycles are thrown away to do it everytime a function is called with a good value 
Maybe you should a bit more about the actual content instead of how you are going to code the website... Show us an article. Show us a table of content. 
Take a look at GNU Utils. There's a Windows port.
I want the row of numbers stored in each seperate spot in the array
I was referring when returning from a function that returns a pointer, instead of return NULL just return 0.
This is also how you do this in any language when you're using a C library like SDL, for instance. It's a fairly common pattern, actually, and anyone using callbacks should get used to it.
Try compiling without CodeBlocks first. Tell us how it goes.
Is ld.exe giving you the error? Edit: are you sure it's saying permission denied or could it be access denied? Access denied almost always occurs when you try to compile while you are running the executable.
Then you declaration should be char credit_array[16][N]; that means you have 16 strings each with length N. go read about 2d arrays and nested loops. you also might want to read about C-style strings.
It would be other way around, first number then size. calloc(i, sizeof(struct data)) This is maybe better option as all memory will be zeroed, meaning name = "" and phone = 0. Besides, using int to store phone is not good choice. 
Or try using a different compiler, I thing eclipse has an extension?
sorry here is my code so far, thanks for the help. http://pastie.org/10590185
And where is the `printf` that prints random symbols?
There is a lot wrong with your code. Please read a tutorial on `scanf` before you try again. Your `printf` is wrong, too (why is there a stray `&amp;records[i]`)?
C has neither operator overloading nor structured. If you are programming in C++, please try /r/cpp_questions as this subreddit is about C only.
You could return an `unsigned long` (or any data type big enough to hold your data), and then reinterpret that as the type you need later. Note: use `memcpy` to avoid violating the strict aliasing rule. The C standard doesn't clearly define what happens when an object's address is cast to a pointer-to-union but it's generally considered that the strict aliasing rule does actually apply in that case. Strict aliasing is only bypassed when you have an actual union object and you access the members by name. 
This is exactly the same as returning NULL, per the standard. By definition the litteral 0 in the context of a pointer is the NULL pointer of that type, regardless of what the actual bit pattern is (ie: it works in all the cases -- it is only a matter of style)
&gt; sine of an array What does that even mean?
The subreddit is for C programming. There are few C++ programming subreddits linked in the sidebar.
Thank you for all your answers. My mistake occurred during the compilation. I had to add '-lm' at the end of the compilation command. I modified my code to make it smaller. I don't have to create the additional function to convert degrees to radians. #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;complex.h&gt; #define angle 91 /* angles */ #define pi 3.14159 int main(){ double thetai[angle]; for (a=0; a&lt;angle; a++){ thetai[a] = sin(a*pi/180);} } 
Just a tip for future reference, you need to add four spaces before your code or surround it with backticks (usually the key above Tab) to make it formatted as code. Also, you don't need `stdio.h`, `stdlib.h` or `complex.h`, since you aren't using complex numbers and you're not doing I/O (Input/Output i.e. printing stuff, writing to/reading from files, etc). If you're using them later on go ahead and keep them, but that small sample you gave doesn't. And one last tip, I wrote the degree-to-radian function as a way to make it more obvious what's going on, since it's so simple the compiler will probably inline it anyway (that is, take the code in the function and just insert it directly instead of calling it as a function), so any absolutely minuscule performance gain is taken care of anyway. I see in another comment you said you're very new to C (and presumably programming), so you may not realize yet how important it is to make your code as *readable* as possible. Code is more readable when you have to think less about what it's supposed to be doing while reading through a file. Putting things in aptly named functions is one way to make your code more readable. You also should worry less about *premature optimization*, which is optimizing code before it presents any real performance issue. You should only optimize if you see an actual performance loss somewhere and know where it is.
C declarators are odd. You can declare multiple variables on a line, initialize them independently, and they can even be of different "types". In your code, `random` and `f` are both declared to be integers, and `random` is initialized. But in `int random = 0, *f` for example `random` is an initalized integer and `f` is an uninitalized pointer-to-integer. You should avoid declaring multiple things on a line I feel, cause it can be confusing. 
Use the code formatting - basically indent your example 4 spaces and it should make it a code block. What is `DIGIT_T`? `dVector`?
I've been kind of embarrassed to come back to this thread. Right after you posted this I went to confirm that it was "Permission denied" instead of access denied, and I remember ld.exe giving me the error, but when I went to build and run the program again, it magically worked. Next time I guess I'll just check if the executable is running.
The thing I usually don't like about the middle one is that on first glance it looks like both f and random will be initialized to zero.
Steve, Thank you for your comments. 
I forget, can you do this? int random, f = random = 0; That is use a variable in the same statement it is initialized, but after it's definition, my gut says no (since I would have abused the hell out of it by now otherwise).
Correct me if I'm wrong but would that be?: int f = random = 0; Or would that imply random was already declared? Edit: punctuation
`random` must already be declared.
Merge sort is good for linked lists. You don't have the random access to the data that swap-based sorts rely on.
 **C Programming Absolute Beginner's Guide (3rd Edition)** |||| --:|:--|:-- Current|$19.36|Amazon (New) High|$23.13|Amazon (New) Low|$15.12|Amazon (New) |Average|$19.36|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/MY6zVIQ.png) **The C Programming Language** |||| --:|:--|:-- Current|$54.19|Amazon (New) High|$62.58|Amazon (New) Low|$40.99|Amazon (New) |Average|$53.49|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/DUIlKSH.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
As /u/dragon_wrangler said, this subreddit is for C programming only. I removed this post for you.
&gt; You should avoid declaring multiple things on a line I feel, cause it can be confusing. It's not confusing once you get used to it. I recommend to disregard this advise.
Yes, you can. A variable is known to the compiler once it sees its name as a part of its declaration. Notice that this is not going to work with global variables as the initializer of global variables needs to be constant.
What's the question?
The `␣` characters in the submission guide are visual representations of white space, you were not meant to type `␣`, you were meant to hit the space bar once for each `␣`.
are you asking for help? if so, try compiling it. try running it. and its pretty hard to have a memory leak when you aren't manually managing any memory.
You can't have a space like that in a format specifier. `% d` needs to be `%d`, and similarly for `\n`. I'm assuming that's just a transcription error that isn't part of the actual question. I feel like you're asking us to explain some kind of exam or homework question for you. You should tell us what your answers are first, or ask specific questions about specific things that you don't understand. We aren't here to do homework. 
This is homework. Please do your own homework. You aren't going to learn anything if you don't do your own homework. There is no policy against homework on this subreddit (and I don't plan to introduce any), but it's better if you did stuff like this on your own.
Your array declaration is incorrect. It should be array[ROWS][COLS], array[7][5]. You can also simply put array[][5] In the first printf, if you want to see the characters and not their values, use %c instead of %d 
s/advise/advice/
Thanks for the input, I've corrected it.
It isn't confusing if you know how to read it. The first part is always the data type, and afterward is a comma-separated list of variables, any of which may or may not be initialized.
That's like, your opinion, man.
Everyone already said it is a multiple declaration (equivalent to int random = 0; int f;) However, while I don't think it is present in the standard itself (there is only rand and srand here), many C libraries already define a function named random, so it would be a good idea to avoid using such a name.
The only case I feel it is ok, is when it is a simple type, and there are no initilizer, ie: int x,y,z; I have seen errors in production code using int x,y,z = 0; so I'd say your advice is strong.
For the lazy neophytes: https://www.securecoding.cert.org/confluence/display/c/DCL04-C.+Do+not+declare+more+than+one+variable+per+declaration
I was given this paper in my freshman compuing class about human parsing of C declarators. It hasn't steered me wrong yet. [Right left walk method](http://delivery.acm.org/10.1145/1050000/1041656/p52-canning.pdf?ip=149.32.192.35&amp;id=1041656&amp;acc=ACTIVE%20SERVICE&amp;key=711B103C38D1067D%2E711B103C38D1067D%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;CFID=564886168&amp;CFTOKEN=99375448&amp;__acm__=1448901056_9f3a03831a9ef3d5a083827516a6a0f8)
 unsigned char output_1; UART1_Read_Text(output_1,13, 10); // reads text until 'OK' is found primer_valor = atoi(output_1); atoi needs a string, not a single character. And UART1_Read_Text cannot alter the value of output_1 when called like this. What is the prototype of UART1_Read_Text? Do you have any documentation for it?
Yes I do, here it is: Reads characters received via UART until the delimiter sequence is detected. The read sequence is stored in the parameter output; delimiter sequence is stored in the parameter delimiter. This is a blocking call: the delimiter sequence is expected, otherwise the procedure exits (if the delimiter is not found). This is a generic routine which uses the active UART module previously activated by the UART_Set_Active routine. Parameters : Output: received text Delimiter: sequence of characters that identifies the end of a received string Attempts: defines number of received characters in which Delimiter sequence is expected. If Attempts is set to 255, this routine will continuously try to detect the Delimiter sequence. And how should I call it to alter it? Thank you very much for your time!
Do you not pass output_1 with a pointer ? En castellano. Tu función no puede escribir en output_1 si no pasas la variable como un puntero, o devuelves el valor y lo asignas a output_1
Some documentation is at &lt;https://www.scribd.com/doc/278837802/755/UART1-Read-Text&gt; The prototype is void UART1_Read_Text(char *Output,char *Delimiter, char Attempts); So you need char output_1[10]; UART1_Read_Text(output_1,13, 9); // reads text until '\r' is found output_1[9]='\0'; primer_valor = atoi(output_1); The 1st parameter is a buffer in to which the input is read. The 2nd parameter is the character that will end the input. You specified 13, which is carriage return, not "OK" The 3rd parameter is, I hope, the maximum number of characters it will read into the buffer. You should nul terminate it, the docs don't say whether it does or not, so better safe than sorry,
How can I pass it with a pointer? Cómo puedo pasar la variable como puntero? 
The easiest way for you would be to make a 3 dimensional array. letter[x][i][j], where x is the letter index eg. 0 is a, 1 is b, 2 is c... If you look at an ASCII table, you will see that all letters are one after another and capital 'A' starts with the index 65. So if you do "user char -65" you get the array index. Last thing, you must check if the index is not out of range, because that can cause memory access violation, also negative index is also an index, usually invalid, don't forget about that.
Anything, from 2 enter 7 enter, to 55 enter 99 enter
Good that function pointers are extremely rare in practice. Of course, when you have a particularly declaration you should maybe make a `typedef` or add a helpful comment, but making a blanket ban on more than one variables in a declaration is ridiculous. That's like saying “paragraphs increase readability, thus a paragraph must be introduced every three sentences” and completely misses the point of how code gets legible. Personally, I group variables in declarations according to their function, highlighting variables I see as performance sensitive with `register` to give a hint to the reader that this variable is important. Declaring each variable in its own declaration is just too noisy and clutters up my code. I'm not paid by LOC and I prefer to read code that I don't have to scroll through.
&gt; highlighting variables I see as performance sensitive with `register` to give a hint to the reader that this variable is important. I'm done talking about variable declarations (either you think `int* b[10], a` or `int x,y,z=10` is confusing or you don't), but this point is bad advice in general. There are semantics associated with `register` variables. In particular, you cannot take its address.
Willing to bet he copied and pasted from some place that screws up formatting.
So it's basically "You can ask homework questions, but don't be surprised when people are unhelpful or give you tiny hints at most."? Because some people are really just stuck on something and need a bit of help, and I generally do help them out by hinting towards the answer or asking questions.
No, that's not the case. There is the kind of homework where you are supposed to solve a problem, you can get stuck with that and we help you as good as we can. There is also the kind of homework where you are supposed to apply something you previously learned in a direct way without getting creative. This kind of homework is designed to give you a chance to revisit what you learnt and to make sure that you understood the concepts. Asking someone else to do it is counterproductive as you remove the purpose why it was given: So you can check if you understood the topic. OPs homework is the second kind of homework.
http://www.catb.org/esr/faqs/smart-questions.html
While technically true, his function wants to read a string, so taking the address of a random char and passing it in is _not_ what he wants to do.
Writing the program in the "Assignment" paragraph. Sorry if its sort of vague. I just copy pasted what my professor gave me, and he's not the best with English.
I have nothing. The only thing I think I could do is just write the "#include &lt;stdio.h&gt;" and "int main ()" statements and declare the variables.
Can you give me more info about what you plan to teach? Are you just teaching c or will you be teaching RISC/x86 ASM as well?
Well, the first part if fairly simple. If you know for loops you can just create a for loop to iterate however many times the user inputs and sum up the product of those numbers. For the second part it is a bit more complicated. I am assuming that your professor went over insertion sort. I would recommend looking in your textbook or googling it to find the algorithm. Google is your best friend when it comes to programming. Beyond that, just make sure you know how factorials work, what insertion sort is, and how to write functions. Once you understand that stuff and start actually writing a program you may encounter more specific problems that we can help you with. (I have enough assignments of my own :p )
So kinda understand what your professor is asking Basically you need to take a number and print out the factorial of said number Things to keep in mind : Is recursion required? If not how would you do it as a a human being (ie in your own head) Once you figure that out, write down some pseudo code and then start to plan out what functions or libraries are needed Feel free to message me if you need more help Good Luck CraftyNecromancer
C is probably not a good choice of language to do this in.
Yeah for sure, so for now anyways it will be sort of C-centric, I want to basically build a baseline for a total beginner if they wanted to start programming low level software and tools, so as I teach the high level C stuff I'll go through and show how you can view diassasembly and how to read it and then in the future I'd want to do a general assembly concepts series and eventually hone in on a specific assembly language to teach, I would assume it would be x86 ASM but I'm still undecided, I would want to do the one that reaches the most people. As far as the present situation is concerned I am in the last stages of proof reading the intro to C tutorials (I've posted a photo of topics it covers on the Patreon page). I was anticipating having the web hosting resolved by now and the first 8 of 20 lessons was supposed to already be up, but it's a weird situation for now until I can find more permanent hosting (for the first year I am hosting it on one of my professors servers), so I'm sort of sitting on my hands for the moment but within the week or next I should have the intro to C tutorials up, so if you would be more interested in it once you can actually see what is done I would completely understand that, and hopefully by then I can just have everything to a nice clean state and I can upload everything on there. As far as what's next I will probably teach some Win32 to introduce some more high level C and show how the operating system handles a lot of stuff like loading windows, cursors, handles, etc. I am open to suggestions on that front as well. Thanks for your question!
great. post what you have... I'd say the next step would be to take the input from the user. Check that input if you're feeling fancy to ensure it's a int and not something like 3.3, or a string like, "I cut way more than one class". From there you can do the factorial any number of ways. Unless your professor stated to do it a certain way...then I suggest you implement that method. personally I'd do a loop. Take the number, multiply it by itself minus one (remember order of operations and do the minus one first), test if you've gotten down to 1, lather rinse repeat if you haven't.
I agree with that. I would do it in a object oriented language with a library for what ever protocol your going to speak to it with
It was my first book without prior programming experience. What's great about today is that you have the web to cross-reference usages of examples in K&amp;R. Some might say try Python first, and they mean well, but once you learn C, you can write Python or any other language. Many times I will use Python to rapidly prototype and tweak something and then write it in C.
Ah, I guess I just must not do it since I subscribe to the 1TBS.
If you like challenging yourself and learning on your own, go K&amp;R. If you like more thorough explanations and examples, go with CPAMA2. Basically K&amp;R is very short (and old) and assumes you have a bit of basic programming knowledge. Because of its brevity, the complexity/"difficulty" ramps up quickly. On the other hand, CPAMA is a college text book and introduces things one chapter at a time, with plenty of details and exercises to help familiarize you with new concepts. Plus it's modern and explains stuff about the C standard(s). Personally I tried K&amp;R at first and got stuck in chapter 1, so I worked through CPAMA over the last year or so and now I'm blowing through K&amp;R with relative ease. But everyone's different, so maybe K&amp;R might be fine for you.
I think the second approach is better. I don't have time at the moment to give a full explanation. You're not crazy thinking that sprintf() takes a size_t but returns an int which could overflow easily if using a buffer with size &gt; INT_MAX. I'd just say roll with it. Most of the interfaces were written to a 32bit spec which would have sizeof(int) == sizeof(long) == sizeof (ssize_t) on most linuxes. Ultimately for the sprintf family, the return past a certain point is useless. If you want to know what would happen, either test the absurd case (recommended via an mmapped buffer) or read the implementation (which sucks to look at). Generally if I have this kind of disparity, I'll just guard against it if possible. EDIT: yes, sizeof(size_t) should be equal to sizeof(unsigned long)
Thanks! BTW, I am not 100% sure about this, but I think sizeof(size_t) is sizeof(unsigned long long) on the Raspberry PI.
Paranoia is the hallmark of any excellent programmer. 1. There's no real answer to if you're being too paranoid, but assuming this is an educational exercise for you, it's likely beneficial to really dig into the problem. However, there comes a point where it's going to be hard to add bug fixes when you don't actually know the kinds of bugs that people are hitting. If I were you, I would try to break the real version of asprintf() and see how it responds. I would personally prefer an implementation of a C library function to behave just like the actual C function, even if the behavior is strange. Subtle differences will make for much more frustrating bugs. 2. I would say the better implementation for actual use is the one closer to the real asprintf(). Wraparound is a tricky animal to deal with - at a glance it looks like you've handled it, but have you tested it? 3. Don't see any other than FUZxxl's suggestion to look at len_i == 0. 4. It definitely opens up the possibility to bugs, but the issue here is C's inability to handle errors. The negative numbers are needed to report errors. 5. I'm guessing the conventions of the coders involved allowed everyone to properly know how to handle issues like this. Programming and technology was in such flux during Linux's early days, it's no wonder there is insanity like this. 6. That's probably a safe assumption to make - I doubt you'd have to spend much time worrying about size_t being smaller than 32 bits.
I'm talking about the second snippet. If `len_i == 0`, your assertion is triggered because `len_i` is neither smaller, nor larger than 0.
I intended that, since `snprintf()` returning 0 would be really strange. My reasoning is that it would essentially result in an empty string. The assertion helps the caller (during testing) find out when this happens since empty strings would need special attention. In such cases the caller can decided to not call `asprintf()` at all. Do you think it is better to turn it into an explicit check in the conditions before the assertions?
Thanks for your reply! &gt; I would say the better implementation for actual use is the one closer to the real asprintf(). Wraparound is a tricky animal to deal with - at a glance it looks like you've handled it, but have you tested it? I haven't tested it yet and I haven't thought about ways to break this implementation. However I explicitly didn't want to be compatible with anything if it meant not doing what I think is right.
There are a lot of texts that explain pointers, but one you might consider is Peter van der Linden's book _Expert C Programming: Deep C Secrets_. None of these example expressions look to me to be "advanced," except in the sense that they may "advance" a pointer through successive memory locations. It is impossible to describe _exactly_ what pointer math is going on here without knowing the types of p and P, but let me give you a few hints for understanding these expressions in general. I'm assuming of course that p and P are pointers to some type and that these expressions would compile. If p and P are actually enumerations or structures or some other types then this code is nonsense. Also remember that according to C's rules, p and P are distinct identifiers (this isn't necessarily true of all programming languages, although it is true of most modern ones). The first expression will dereference p -- that is, it "follows" the pointer and the value of the expression becomes the value of whatever the "thing" ("object" is the term used by K&amp;R) at location p. The most basic kind of "object" in textbooks is usually just an integral type, char or int, maybe modified by unsigned or long or short, etc. If p is a pointer to an integral type, and assuming it has been assigned some reasonable value, that is, a valid memory address where an integer can live, the result of the expression is the integer value. The pointer p is "post-incremented" which means that it is incremented to the next address, according to its type. So if it is pointing to an integer, after the expression is evaluated it will be updated to point to the next integer. If your integer is four bytes long, which is not true of all systems, the value of the pointer will be the original pointer + 4. If p is a pointer to a character, the value of the pointer will be the original pointer + 1. Note carefully what post-increment means; it is incremented _after_ the expression is evaluated. So the value of the expression is the pointed-to-thing before the pointer is incremented. This post-incrementing will not be relevant until the next time p is used. C does not guarantee the updated pointer if valid; it may now be pointing somewhere beyond memory your program can legally read, or it may be pointing to memory that your program can read but which is not set to hold sensible values, or it may have wrapped around, etc. Your program must manage this; the language runtime will not do it for you. If you don't do it correctly your program may crash, or it may just wind up dealing with unexpected values. This is why it is so vital to carefully set up termination conditions when working your way through arrays or lists or other structures in memory. The second expression is like the first except that it performs a pre-increment -- that is, the pointer is incremented to the next address according to the type, and it follows that updated pointer to generate a value. The third is where they start to get interesting. Assuming that p is a pointer type defined with just one level of indirection, that is, just a "\*" and not a pointer-to-pointer or "\*\*" or other type, it is dereferenced and then the value is pre-incremented. The exact meaning of that, again, depends heavily on the type of p. It is true that you don't need to have parentheses in these expressions, as danielcamiel points out, and the order of operations means that some of the expressions actually mean the same thing. As a matter of readability, I generally prefer to use parentheses to express the desired order of operations even in cases where they are not strictly needed. And when pointer and array expressions become more complex than these, they are important for readability. Pointer and array expressions can be hard enough to interpret without forcing the reader to think about C's somewhat strange operator precedence rules. And of course in a real program I would try to use variable names that carried more information about what they actually do than the generic "p."
Definitely not an error. But I think that most of the time it would be an edge case that could be better handled in the caller (eg, as part of printing a status string to the user). One counter-argument to that would be needing a dynamically allocated empty string.
Hope that is more readable.
Start by breaking the problem up into chunks. First you need to collect data from the user. Google "user input c". Then you need to calculate the "check digit" based on the data entered. Then you need to compare the check digit to the inputted last digit of the bar code. Each of these tasks is very simple to accomplish on their own. Use google liberally. I will give you a freebie and say that declaring a variable like so: "int barcode[12];" will create an array of 12 integer variables, 'barcode[0]' through 'barcode[11]' that is probably the easiest way of storing the data entered by the user.
To this I would add the term tokenization. You didn't mention this in your description. I would assume by now you should have gone over the concept. If not l, this is the time to learn it. 
Slightly better.
&gt; EDIT: I have given up on this class and really just need help writing the code to pass. Please let nobody post any working code. Give hints but leave it there. This question is shameful. Is nobody else bothered by this?
C has a reputation for being harder to write things in than other languages (like python). Personally, I'm learning C at the moment, and will use it for anything performance intensive. But if it's something like this, and you just need it to be done (and not treat it as a method of learning a language), I would write it in python. Much quicker to write code in than C.
Okay, so your program's input is a sequence of 12 integers. Let's visualize this. Positions 1 1 1 1 2 3 4 5 6 7 8 9 0 1 2 ----------------------- [0 7 9 4 0 0 8 0 4 5 0 1] 1 // check digit [0 9 0 8 4 0 ] // odds [ 7 4 0 0 5 ] // evens Now let's look at the description of the algorithm, and break it into pseudo-code. /* Sum up the numbers in odd positions */ odds_sum = input[1] + // 0 input[3] + // 9 input[5] + // 0 input[7] + // 8 input[9] + // 4 input[11] // 0 /* Sum up the numbers in even positions */ evens_sum = input[2] + // 7 input[4] + // 4 input[6] + // 0 input[8] + // 0 input[10] // 5 final_sum = (odds_sum * 3) + evens_sum At this point, we need to figure out the last digit of the number stored in "final_sum". We do this by using the modulus, or remainder, operator, which returns the remainder when we do integer division on two numbers. If we take any number "mod 10", we get the number which would be its last digit in a decimal representation. 22 divided by 3 is 7, with a remainder of 1. Therefore: 22 / 3 == 7 22 % 3 == 1 125 divided by 10 is 12, with a remainder of 5. Therefore: 125 / 10 == 12 125 % 10 == 5 So, we go back to our (pseudo)code. last_digit = final_sum % 10 if(last_digit == 0) { check_digit = 0 } else { check_digit = (10 - last_digit) } if(input[12] == check_digit) { input_valid = true } else { input_valid = false } This is deliberately not valid C code. Just kind of a thought on one possible way to write it. As for building the program itself, here's what you need to know. Because we know how much memory is needed, we tell C to reserve, or *allocate*, an array big enough to hold 12 integers. The syntax for that is: int input[12]; Next, we need to figure out how to put numbers in it: we'd like to "store" an integer into each "slot" of the array. Note: array positions start at 0, so the "first" position in an array is 0, the next is 1, and so on. input[0] = 5; input[1] = 2; Here's how you *refer to* the integer stored in a given "slot". int plusFive = input[2] + 3; And finally, how to read input from the user: read up on the [scanf function](http://www.cplusplus.com/reference/cstdio/scanf/): int firstNumber; int secondNumber; scanf("%i %i", firstNumber, secondNumber); /* your program will pause while the user enters some input */ /* "%i %i" is called a format string- it's basically saying "this is what I expect the user to input." It's the opposite of printf. * In our case, we expect them to enter two integers, separated by a space. */ printf("Your first number: %i", firstNumber); printf("Your second number: %i", secondNumber); With these pieces, and the pseudocode above, you should be able to get your program working. Good luck!
The first line I look for when looking at file reading code is this: while(!feof(file)){ This is a pattern I see all the time. It's so intuitive: "do something until I'm at the end of the file" ... but it's also wrong. `feof` doesn't work that way -- it's job is to tell you if the last operation failed because you were at the end of the file. When people write loops like you have, it often ends up causing the loop to execute one more time than expected. Consider what happens with an empty file to see what I mean. The right pattern is to put your `fscanf` inside the condition: while ( fscanf(file, "%lf;%lf", &amp;var1, &amp;var2) != EOF ) { // Use var1 and var2 } if ( !feof(file) ) printf("Error occurred while reading from the file\n"); I also slipped in how `feof` should be used: `fscanf` might fail for other reasons besides being at the end of the file, and you can use `feof` to differentiate between a normal termination due to EOF and some other reason. Of course, putting a huge `fscanf` in the condition of the while loop is ... a little odd to say the least. I would recommend breaking that out into a separate function: int read_a_line(FILE* file) { return fscanf(file,"%lf;%lf;%lf;%lf;%lf;%lf;%lf;%lf;%lf;%lf;%lf;%lf;%lf;%s",&amp;(iterator-&gt;Lax),&amp;(iterator-&gt;deltaLax),&amp;(iterator-&gt;z),&amp;(iterator-&gt;B12[0]),&amp;(iterator-&gt;B12[1]),&amp;(iterator-&gt;B12[2]),&amp;(iterator-&gt;B12[3]),&amp;(iterator-&gt;B12[4]),&amp;(iterator-&gt;B2[0]),&amp;(iterator-&gt;B2[1]),&amp;(iterator-&gt;B2[2]),&amp;(iterator-&gt;B2[3]),&amp;(iterator-&gt;B2[4]),iterator-&gt;type); } ... while ( read_a_line(file) != EOF ) ... Now the `fscanf` can be broken up into separate calls. Maybe one to get the first three, then use a loop to read the next 5, another loop to read the five after that, and a final call to get the final field. Something like if ( fscanf(file, "%lf;%lf;%lf;",&amp;(iterator-&gt;Lax),&amp;(iterator-&gt;deltaLax),&amp;(iterator-&gt;z)) == EOF ) return EOF; for ( int i = 0; i &lt; 5; i++ ) if ( fscanf(file, "%lf;", &amp;(iterator-&gt;B12[i])) == EOF ) return EOF; // etc... One more comment. It looks like `iterator` is a global variable. That's poor style, first off. And second, it looks to be the tail of a linked list, so you should probably call it that instead.
Call it whatever it needs to be when you're using it. That could be the same everywhere, if that's what's right.
&gt; It all comes down to the call. The cast from int to size_t, in the first example, will protect you from the corner case where INT_MAX is returned from vsnprintf. Just a note in case both values were signed or unsigned: This would only work fine on amd64, so that is not always the case. On the RPI `int` and `long` are both 4 bytes. &gt; But do you plan on copying 32767 characters with asprintf? Definitely not, I would look for a more efficient way. But I had been wondering about these quirks I'm seeing everywhere. Also, even if this isn't a practically valid use-case, it's a theoretically valid one, and caring about that will make my programs still run properly in the future when machines are able to `asprintf` 32767 characters :) &gt; Looking at the second function definition there's at least one test which can be removed safely. The maximum value for any given signed type can safely be converted to the corresponding unsigned type, have 1 added to it, and the value will be correctly represented. That makes sense, because even though `int` and `long` could be the same size on some machines, the `int` here is signed and the `size_t` is unsigned. &gt; Yeah ... I wouldn't worry too much about that stuff unless you're writing lower-level code. For the most part you can just convert values with those types to unsigned long, unsigned long long, etc. without hassle. I am actually using `stat(2)` for that project and these issues started bothering me when filesizes &gt;4GB started showing up as negative values in `off_t st_size` on the RPI.
My compiler (clang) gives a warning for your loops in the `swap` function: c.c:216:33: warning: expression result unused [-Wunused-value] for(index2=0;index2&lt;6;index2+2) The expression `index2+2` doesn't actually change the value of `index2`. I think you meant `index2 += 2`. There are multiple instances of this problem. Perhaps that fixes your issue? Another place where my compiler warns is in the line where you try to print `odd`: c.c:73:40: warning: variable 'odd' is uninitialized when used here [-Wuninitialized] printf("odd avg is %f",odd); You should give a value to odd before this line. Notice that the variable `odd` in `averageodd` and `odd` in `main` are different, assigning to one doesn't influence the value of the other. Another problem is that `main` should return an `int`, not `void`: int main() { ... } Lastly, `printf` doesn't introduce linebreaks. You need to explicitly add a `\n` to the end of each line so `printf` actually breaks the line: printf("odd avg is %f\n",odd); This should be done in many other places, too.
I do have it defined.
Fixing the loop made it work perfectly. Thank you!! :)
You can't (read: really really shouldn't), and goto won't let you either. Why would you want to do this? The normal behaviour would be to have `b()` return some error code to `a()`, indicating that it should terminate early. Then have `a()` check for that error code and return to `main`
You can use [setjmp](http://man7.org/linux/man-pages/man3/setjmp.3.html) and [longjmp](http://man7.org/linux/man-pages/man3/longjmp.3.html) to do what you want.
Can I ask why you're not a fan of `goto`, by any chance? 
You can by manipulating the stack since you know what's on the stack already.
First, the smaller errors: You're using `feof` incorrectly. Instead of `feof`, check `fread`'s return value: while (i &lt; arraySize &amp;&amp; fread(...) == 1) { To print `account.name`, you must use the specifier `%s` because it's a string. According to the C standard, `main` must return an `int`. Some compilers accept `void`, but it's non-standard. --- Now the real error is the way you use `fread`: fread(&amp;accounts, sizeof(BankAccount), 1, fp); The first argument should be `&amp;accounts[i]` (or `accounts`, but then each `BankAccount` overwrites the previous ones). However, the loop is unnecessary because you can just ask `fread` to read all accounts in one call: fread(accounts, sizeof(BankAccount), arraySize, fp); Note that the first argument is `accounts`, not `&amp;accounts`. You may also want to check the return value just in case `fread` reads fewer than `arraySize` accounts.
Are you implying that you're a fan of goto?
Every time you enter a function you push registers to the stack and when you exit you pop registers off the stack. Couldn't b() call exit? It's either that or doing this in a() if ( b() == something ) return;
I'm a big fan of goto. Cleaning up (closing files, freeing pointers, etc.) after an error in a function is much easier to read and with much less code when using gotos. See Linux for a good example of clean and easy-to-read code that uses gotos *everywhere*
Thank you!!! :)
For another good response to this debate, see Knuth's [Structured Programming with go to statements](http://fuz.su/~fuz/structured-programming-with-the-go-to-statement.pdf).
If your goal is to get to `main` just so you can exit the program, consider calling `exit` from whatever function makes this decision. That may or may not apply, depending on your application, though.
As an advocate of 'goto' who feels any naysayer is just blindly regurgitating what some ignorant professor regurgitated to them, I have to say do not use goto to exit a called function. This corrupts the stack. Use it freely otherwise
C does not even allow you to `goto` out of a function. It's a compile-time error.
If people would just distinguish between forwards gotos and backwards gotos, we'd see alot less of these debates every time someone breathes the word goto. Don't use backwards gotos. 
Forward gotos are just as much of a problem. Take the "goto fan"'s example: // ...allocate stuff... if ( error ) goto cleanup; char *ptr = malloc(50); // ... cleanup: free(ptr); // oops 
Seems pretty straightforward: http://paulbourke.net/dataformats/ppm/
transform.h is certainly a user defined header file, and i doubt you can find the source code for this unless another student posted it.
Of course, you have to do the cleanup correctly. Every sharp tool can be used to cut yourself and `goto` is very sharp.
In C, the input is a stream. When you type in `y` `(enter)`, that's two characters on the stream. When you write `fgets(ans, 2, stdin)`, that extracts only the `y` from the stream (because the buffer is not big enough to fit two characters and null terminator). Then when you write `fgets(getyoname,100,stdin)` it extracts the `(enter)` and stops, because fgets stops when it gets an Enter. It will only wait for input if it has extracted all of the characters from the stream and not encountered Enter yet (and not filled its output buffer). To fix this you should make sure that your first `fgets` does not leave any junk on the stream. To do this robustly, here is one example: if ( ! fgets(ans, sizeof ans, stdin) ) exit(0); // Read failure - we must not go on to use the buffer in this case if ( ! strchr(ans, '\n') ) { // This indicates that the '\n' must still be on the stream, since it's not in our buffer int ch; while ( (ch = getchar()) != EOF &amp;&amp; ch != '\n' ) {} } You could wrap up the flushing code into a function if you're going to use it often. 
Try to write it yourself, it's not that difficult.
Those functions ought to exist anyway since otherwise you're mixing the cleanup code, which presumably is repeated in every place a resource is used, with the rest of the code instead of putting it in functions I don't see what you mean about interfering with recovery efforts. RESOURCE *x __attribute__((__cleanup__(free_resource))) = create_resource(); int err = use_resource(x); if (!err) { return; } some_sort_of_recovery_effort(); use_resource_some_other_way(x); The benefit of avoiding code like `goto fail` by using `__cleanup__` attributes or destructors is that these alternatives are more strongly structured while using `goto fail` is only as structured as the programmer manages to make it.
&gt; The rationale for using gotos [for centralized function exit] is: - unconditional statements are easier to understand and follow - nesting is reduced - errors by not updating individual exit points when making modifications are prevented All of those issues are also addressed by the `__cleanup__` attribute.
Just use `scanf` and ignore all the complexity wrt to comments and stuff.
Read the manpage of `scanf`, it's not that difficult. Something like scanf("%2c %d %d %d\n", ...); where `...` are pointers to the variables you parse your header into should do the trick.
No problem. I'm hoping that you're not just blindly copying this code- I know the pressure's on to pass your class, but the point *is* to learn, after all. After you have a working solution, take a little time to make sure you know *why* it works. That'll set you up for success on the next assignment- you'll have a kind of mental "frame of reference" for approaching problems like this.
Having learned (x86) assembly before C, I learned the hard way about JMPing out of a CALL, so I never bothered trying in C...
the most dangerous function is void userWritingOnKeyboard() .... imho
Yeah this is pretty true. It seems like such an easy function to use. However a disproportionate amount of my time debugging Heisenbugs and obscure bugs in embedded devices has turned out to be a `memcpy` or `memset` gone wrong - usually one that worked originally, but broke after the original code has gone through some changes, source control merges, etc. 
Example 3 also uses the wrong size (in addition to being redundant)
Which is not portable and not part of C.
That's not "as much" of a problem. Yours is a simple error. Backward goto can be exempt of error and still be freaking ugly and fuck readability. Yes, you also have to write correct code. Nothing will prevent that requirement. Compilers can now hold your hand to pick up these errors if need be.
It seems `sizeof` is to blame in a lot of these cases, specifically there seems to be a misunderstanding about what `sizeof` is actually going to give you. The same problem happens with `malloc()` too (I see `malloc`/`sizeof` issues **a lot** on StackOverflow). `memset()` has very little use in C++, as there are much better ways to achieve the same result, e.g. with functions from [`&lt;algorithm&gt;`](http://en.cppreference.com/w/cpp/algorithm).
Can you give some examples of malloc()/sizeof() problems?
Classical sizeof problem, trying to get an array size: fun (int array[]) { sizeof(array) / sizeof (array[0]); ... } Which does not work because C decays array parameters to pointers. Which is an awful thing to do. Classical malloc problem, doing sizeof on pointer to structure instead of structure: List* x = (List*) malloc (sizeof(List*))
what do you mean by decays? arrays are always pointers
Not always. Arrays decay to pointers in many situations, but there are cases where that doesn't happen. For example: char test[] = "Hello, world!"; size_t s = sizeof test; Here, `s == 14`, not the size of a pointer. Similarly, taking the address of an array type and incrementing said pointer will increase it by the size of the array, not the size of an element.
interestingly `memset` is meant for character strings which means something like `memset(int*, 1, N_elements*sizeof(int));` will fill your array with 16843009. It's completely the wrong tool for the job.
I've taken to always using sizeof(type) rather than sizeof(var) to avoid things like this.
Well a common way is something like: for(xy = 0; xy &lt; width*height; xy++) { x = xy%height; y = xy/height; } But you sure you need x and y? 'a' could be a 1D array you use 'xy' directly with.
Yes you do. A pointer to an array of two characters.
Stop making separate posts. Just make one big post for your homework and update it as you get further.
It’s commonly used for zeroing out structures you’re passing to/from another API; for example, when you’re doing `sigaction`, you can’t be sure what all’s in the `struct sigaction` or how it’s laid out, so you zero it first and then fill it in. If the structure is ever extended and that’s done so properly (i.e., zero = prior default) then it lets code operate in a forward-compatible way. It’s pretty much not useful except for zeroing, though, and even then IMHO it’s a tad iffy if there’s anything other than scalars or arrays thereof involved.
This is really cool. This is the kind of stuff I'd like to see on this subreddit instead of all the "Help me on this project that looks like homework but definitely isn't". How long did it take you to write? Why did you choose to do so? This is awesome.
Sorry, why are you not allowed to use nested loops? Sounds like a pretty strange requirement.
You should focus on getting your code to work before rolling the inner loop into the outer loop. As it stands, the code is not going to do what you think it will.
Ah, I see. Seems like you can use nested loop as long as you put the inner loop in a different function. It seems like your instructor gave you a function `readHeader()` to read the header of a PPM file. Why don't you use that?
It's all 1D in memory. Often there is no x/y access so you do "y*width + x" to get the 1D entry of a pixel. Anyway, hope some of this helped.
Yes, as I [said](https://www.reddit.com/r/C_Programming/comments/3v4z7g/return_to_main/cxkr8z6) it depends on the ability to use GNU extensions. The Linux kernel is full of stuff that's not C and instead relies on extensions.
I'm okay with extensions if they are required (e.g. inline assembly), or isolated and can be taken out easily (e.g. Linux' usage of `__builtin_assume()`. `__cleanup__` is neither of these two.
 printf("%s\n", messege); You want printf("%s\n", ptr);
You also want `munmap(ptr, strlen(messege)`, not `munmap(message, strlen(messege))`.
You run it through cppcheck and valgrind? Always a good idea. But looks good. :-)
Don't use [] for parameter.. I think there is a way to make it at least a warning
Thank you very much! I have been working on this on and off since this summer, as a side project. University takes alot of my free time! I had this course about the fundamentals of computers, we went from gates to assembly programming and processors. It was really interesting so I thought it would be cool to emulate this! I had also been introduced to C and thought that I needed some practice with it.
I had a similar class in university. It was hard, but it was very interesting. Did you learn assembly in that class? Ninja: I saw that you did. What processor was it for?
The code uses `scanf`, (resp. `sscanf`). Please read it and take notes.
&gt; __cleanup__ is isolated to each variable that uses it, and it's as easy to remove as it is to write the manual cleanup code in the first place. So if you think writing the manual cleanup code is easy then __cleanup__ meets your criteria. The capability to remove something by rewriting the code is not what I understand as “can be taken out easily.” It's not isolated either as it has a drastic effect on code structure.
Never heard of either actually, had to Google! Seems like a good idea to use them to check my program.
Mine did something similar. It was for a fake processor called LC3. I was kinda annoyed because ARM is so accessible now with stuff like Raspberry Pis and would be actually useful besides understanding how an assembly language works.
Well then the Linux kernel is definitely okay with extensions that you apparently aren't.
That's okay. I don't agree with the Linux project on many aspects of the way they develop software.
Yeah, `memset`’s mostly for portability to any ol’ C compiler on any ol’ system, however antiquated or unusual. I’ve seen it for both POSIX and Win32, and sometimes for library APIs, and it’s the documented Way To Do things purely because it’s guaranteed to work everywhere without. Unfortunately it’s just terrible for anything other than bytes and zeroes (especially since you’re not guaranteed anything about number format per C standard), and there’s not really a better solution offered for other kinds of fill which is unfortunate. And lessee... for arrays, you’ve got the GCC option of doing `[0 ... MAX] = 0` at initialization or by anonymous array, and for smallish arrays you can rig a preprocessor macro to pump out zeroes. (A convert-to-binary and convert-from-binary macro pair will get you very far; unfortunately, being able to handle [0,N) requires O(*n*) macros to implement those two things. Everything else you might want to do with the binary form can be O(lg *n*), though.) My only complaint about your way of initializing structures is that compilers will sometimes warn about it. (Which is not so much a complaint directed at you or your code, as it is about the compilers and language.) I generally prefer the pthreads approach, where you offer functions to de-/initialize, a macro to initialize, and then I also like to add a macro that generates an anonymous struct for C99+ code. Basic ctors and dtors are something I really wish they’d add to C, especially since everybody has to support both somehow (even if by `__attribute__`) anyway.
Nice, clean code. A detail: sizeof(char) is 1, by definition (sizeof is the size of something in chars).
I never said it was a function...
Gameboy or Gameboy advance?
You've defined variables and used them in function calls in other places. 
Ill start with gameboy first and graduate to something harder after I'm done.
True, but I think that: obj *o = malloc(N*sizeof(obj)); Is a good idiom to use consistently. 
Link to your project?
TIL that buzzfeed merged with stack overflow and produced this article. Coming up next: The top 10 worst things about C++! Number 7 really made me think! &lt;/snark&gt; 
You should lose the global variable.
I just googled original gameboy processor and this was the first result. It looks like it has some information that might be useful but I couldn't find what exact processor the gameboy is using in my 30 seconds of searching. http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf edit:specifically go to Section 3, 3.2 registers and 3.3 commands edit2: this looks pretty good too if you read or skip through until it talks about the fetch and execute cycle. Looks like the processor is a custom you have to look into if the instructions are pipelined though. https://realboyemulator.wordpress.com/2013/01/01/the-nintendo-game-boy-1/
Try running the program in a debugger, for example gdb. It will show you exactly what line causes the segfault. Search around the internet for "gdb tutorial" if you never used it before. 
The main thin I don't get is that its 8bits per instruction, but you look at this chart http://www.ticalc.org/archives/files/ss/814/81455.gif and the highest thing is FF. So my question is, how do I know when one instruction stops and one begins, are the data and the opcode two separate bytes?
This is good advice, but my usual goto for segmentation faults is Valgrind. Segfaults are memory errors, which is Valgrind's domain
I made a (very simple) debugger for the RealBoy emulator. If there is anything I can help with...
Oh I see, fixed it. Thank you!
It's been on my private repo the past decade or so -- but I just tossed it on GitHub for you: https://github.com/JeremyJStarcher/js-mote
You need to transform your data between lines 33 and 34. After line 33 you have the header information in `dimensions` and your pixel data in `in_img` Since you need to change the size of the image (rotation by 90^o swaps width and height) I would make make a new dim_t variable and a new `out_img` array and transform the input to the output, then write the output image. I'd do the greyscale transform first - you don't need to worry about the dimensions changing. 
Well I'm not about to read through those documents but If you look at the pdf I linked you some of the OP CODES are two bytes for example the ones the begin with CB. What you are looking for is referred to as alignment for example every instruction might be halfword (16bit) aligned so every instruction must begin at a memory address divisible by 2. Where each one stops and starts might depend on the instructions used because some may take up more memory. Part of your control logic and OPCODE decoding will need to know how many bytes the instruction occupies to increment the PC appropriately. For example many of the ARM Cortex M processors have 16 and 32 bit instructions, some are even duplicates, it is common for a 16bit variant of a duplicate to have some 'restrictions' on it's use such as a smaller range of possible immediate values or can only access certain registers, etc. A 16bit instruction might also be able to execute faster, it all depends on the instruction set architecture and how the hardware implements all these instructions. http://imrannazar.com/GameBoy-Emulation-in-JavaScript this site says an instruction (including operands) can be anywhere from 1-3 bytes.
 You need to loop over the width and height For each pixel, call get_pixel and you'll get a pixel_t structure containing the r,g, and b values. Average them Set r = g =b = average Call set_pixel to write the changed pixel back to the image.
No, don't mess with make_row at all. That writes a row of the image to the file. Remember you have several different transforms to pick from. make_row isn't the place to make that decision because some of the transforms can;t be done a row at a time (rotation, for example) In between lines 33 and 34 you need to make a new image that is the transformed version of your input image and write it out using make_row.
It depends on your operating system and also your locale and where you're reading your data from (from a file vs from a keyboard, for instance). Most Unix systems will use UTF-8 or ISO-8859. Modern Windows systems typically use UTF-16, with the caveat that text files, even on Windows systems, usually use an 8-bit encoding (like UTF-8 or ISO-8859). UCS-2 still occurs sometimes, as well. Ideally whatever software you're writing shouldn't care what encoding its input is in.
According to the C standard: &gt; [...] the fgetc function obtains that character as an unsigned char converted to an int [...] fgetc is *not* locale aware and will read *bytes*, so if your file is encoded UTF8 you will get UTF8. getchar is just a shorthand for fgetc(stdin).
Ah if you're writing a tool to convert, then you should read in byte-by-byte (using `getchar`). Anything that you read in with `getchar` will *not* be decoded, just the raw bytes.
The part where what `getchar()` returns depends on locale. It doesn't.
Thank you! 
Yes, "n" is an 8 bit value and "nn" is 16 bit. For your question "how to know when the to stop and go to the next instruction", the answer is simple. If the the opcode is not prefixed with "0xCB", if the instruction do not take argument (in this chart "n" or "nn") the length is 1 byte, if take argument the length is 1 byte (the opcode) + immediate value. Example: "LD C, n" is 2 byte
&gt; usually use an 8-bit encoding (like UTF-8 or ISO-8859) UTF-8, despite the misleading name, is not an 8-bit encoding. It varies from 8 to 32 bits per char. This is one of the more common misconceptions among programmers imho 
&gt; fgetc is not locale aware and will read bytes, so if your file is encoded UTF8 you will get UTF8 No, if your file is encoded in UTF-8, then you will still get a byte at a time. A UTF-8 char can be anywhere from 1 to 4 bytes (8 to 32 bits).
Not really true... you'll get one byte back. Since Θ is two bytes long in both UTF-8 and UTF-16, you'll only get half of that back, which will be interpreted as a completely different character by whatever tries to operate on it.
Yes. I don't know the gameboy assembly, but i think that the encoding for this instruction is something like this "LDH (0xA), A" -&gt; "0xE 0xA", so when you write the code for the disassembler, read the opcode and the parser do somtehing like this "switch (code) {case 0xE0: imm_value = code++; printf("LDH (0x%x), A\n", imm_value);" then increment the pointer to the code and you have the next instruction that have to be parsed. Sorry if my english is not good.
Not really a place where, but learn the preprocessor - you can make things pretty bad abusing it. And look into the c obfuscation contest results - these can give you some ideas too
Try http://codegolf.stackexchange.com for code that is not deliberately, but circumstantially obscure. For example, I wrote this program to [score a game of Go](http://codegolf.stackexchange.com/a/6731/134): #define I b[d*g+e a;b[65536];c;d;e;f;g;main(){for(;d=getchar()+1;f++)b[f]=d-80?d-89?d-46&amp;&amp; f--:5:6,g+=g*g&lt;f;while(!c--)for(d=g;d--;)for(e=g;e--;)I]&lt;3?a=3&amp;(I]|!!d*I -g]|!!e*I-1]|(d&lt;g-1)*I+g]|(e&lt;g-1)*I+1]),c&amp;=I]==a,I]=a:0;while(f--)c+=b[f ]%2-b[f]/2%2;printf(c?"%c+%i":"Jigo",c&gt;0?66:87,abs(c));} 
You could increase the chances of people helping you by copy/pasting the assignment text or posting a screenshot. Just sayin'...
Working through the entries in http://ioccc.org/ would help
There should be a homework help sub that is ONLY for this type of thing. I come to this and other programming subs for good solid conversation between people who love the language. It's all, "How do I solve problem 6 in my book?"
The ABI is only common for basic function calls, POD structs, floats, basic pointers, that sort of thing—stuff that’s actually common across the languages. C may or may not have anyting to do with vtables, member pointers (e.g., how is a pointer-to-virtual-function handled and distinguished from a pointer-to-nonvirtual-function?), non-POD structs/classes, exceptions, andsoforth—in fact it’s pretty common for anything beyond the bare-bones C ABI to be somewhat compiler-specific. This shows up especially with stuff like `__attribute__((__cleanup__))`, where you need special flags just to get it to work across C++ exceptions, and even then it’s only C++ exceptions in the same breed of sub-/E-ABI as the C++ compiler attached to your C backend. So IMHO more formalization/standardization around ABI would be needed if we wanted to push properly C++y features like exeptions into C on the compiler side. And wrt features, C++ has a *lot* of really weird corners, to say nothing of the fact that the language itself is very difficult to parse properly, and those things are quite visible even from the basic features. It has a lot of useful ideas, but a lot of old stuff has just metastacized over years.
Questions about homework are fine in /r/C_Programming. Only questions that more or less directly ask “do my homework” aren't. I don't see why an extra subreddit is required for that purpose. /r/C_Programming is already the second subreddit about C that takes all question posts from /r/cprog, I don't see how fragmenting the C community further is a good idea. I also fear that /r/C_homework is going to become a graveyard and just an excuse to not answer homework questions here.
that is awesome, I have looked for a legitimate use of goto for a while. Thanks!
Incorrect definition of the thread function void word_freq(struct to_read *data) You have to make void *word_freq(void *data) 
It's the best book in C. As for "prior programming experience" - if you are not a simple user (at least sysadmin), you will understand it.
Hmm seems at lot less active over there, but good to know. I don't mean to sound against learning. I love people who want to learn. Just see a lot of people who are looking to cheat. (Not saying about OP)
Another good use for goto is in nested loops where you want to break out of the outer one from an inner one.
&gt; I have looked for a legitimate use of goto for a while. This is a matter of opinion. Mine is that this is not a legitimate use of goto. It's spaghetti code whichever way you look at it.
My suggestion for you is to work on wave files (`.wav`) only. They are very simple to parse and directly contain the PCM samples you need, no preprocessing is needed. You don't need a library to read wave files.
Go over Dennis Ritchie's c programming book on file operations, also appendix. You should be right on track.
Didn't expect such a quick response, thanks :)
What, specifically, are you struggling with?
yep, thats the example everyone gives when introducing goto. Haven't needed it yet... Probably because I did a lot of java before.
I'm trying to go through a text file like this and get height/width: ###### ###### Basically go char by char until I hit a newline, and then line by line until I hit EOF.
Start at the basics again dude. Function is of type int but trying to return a char. Assigning char values to integer variables in your main function*. It's a mess
I figured it out; I wasn't able to get fscanf working and was struggling with the concept of a file ptr and going throughout the text file.
Why do you even call printf after a return statement? That line can never be reached because the function returns right before it.
rtfm
libsndfile did seem like the better option for me, but I'm still unclear on how I can access the data of the waveform. The file operations I see are just reading straight-up bytes from what I'm reading, and if that's the case, I would be better off writing my own parser. Surely there is a better way.
No they are not byte operations. The point of short/int/float/double functions is to read the same data but with different "precisions" ([bit depth](https://en.wikipedia.org/wiki/Audio_bit_depth)). The library will seamlessly convert between them.
Transcoding input is very easy, just run a decode in a pipeline with your program. It's much easier than programming against some API.
&gt; Assigning char values to integer variables in your main class. It's a mess I don't see a class in OP's code. C doesn't have classes.