Please provide the exact error you are seeing. This compiles fine using the minGW toolchain on windows, so it is likely an error in your visual studio setup.
I actually went with this : [sieve-of-eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/). Only difference is that I used allocated memory from heap. 
This code has lots of uses `__typeof__`, a GNU extension that's supported by a number of compilers, but not Visual Studio. It also improperly uses some reserved identifiers, but that's probably not the issue. 
This is not cross platform. I did forget to mention affinity, but I'm so used to working on cross platform stuff that I generally omit things like this from my head. Either way, you are right.
Thank you. Can you please specify which exactly identifiers are used misused? 
Identifiers containing `__`, especially as a prefix, are reserved for the implementation. So its uses of `__LL_H_`, `__MALLOC_FREELIST_H_`, and `__mptr` may cause errors. 
Fair point. I’d never considered cross-platform. My whole works is about Linux optimisation. 
Not an array. God can send big mallocs or reallocs straight to hell. 
`snprintf()` is the tool for this jorb.
Take a look at snprintf. If that doesn't get you going, follow up with more questions and I'll try to answer.
Try `sprintf`, `snprintf` or `asprintf`. The former two if you already have a buffer, the last one if you want it to allocate a buffer for you.
A hash table is a key-value store implemented as an array indexed by a hash of the key. As for the rest, I have no idea what you're on about. Get some sleep maybe?
You either have to know exactly how many entries you are gonna use, store lots of entries just to be sure or reallocate the array to accommodate more entries. Satanic practices indeed.
Prior to the Standard, many implementations added their own reserved words to the language. For example, many compilers added qualifiers `near` and `far`, so one could say e.g. int near *p1; /* Two-byte pointer that can only identify things in main data segment */ int far *p2; /* Pointer that can identify things anywhere in memory */ /* Function that is callable from a Pascal program, and might be written in Pascal, or written in C but marked with a pascal qualifier */ extern int pascal FOO(int bar) { return bar+1}; Unfortunately, programmers writing what were intended to be portable programs would sometimes use these names as ordinary identifiers. Someone writing code for the 8088-based machine that uses those qualifiers wouldn't use the names: int near = (distance &lt; 10); int far = (distance &gt; 100); but many people who never heard of the 8088 would have no reason to avoid them. To minimize such problems, the Standard established the practice that compilers would be free to add just about any reserved word meeting any of several criteria (e.g. starting with __, or _ and a capital letter) and programmers should be prepared for the possibility that implementations which might have any reason to use any such identifier might do so.
Sometimes there's no need for the path buffer, with `openat(dirfd, ...)`
I'm going to reorder your username to 'oh 5x no'. 
The hash table only contains pointers to the actual records, so the cost of allocating a larger hash table than needed, and of rehashing if necessary, is negligible. It baffles me how anyone who is comfortable with C would find this difficult.
How much have you programmed in C? What kind of code did you write?
If the job sounds good you should apply no matter what. Tailor your resume based on what's in the posting. [This](https://talent.works/blog/2018/11/27/the-science-of-the-job-search-part-vii-you-only-need-50-of-job-requirements/) was trending a few days ago, relevant here I think.
Every byte counts buddy. Every bite counts. Some of us are still using 1980s hardware.
Post the definitions. We can't guess as to what's wrong with it.
&gt; To be more precise, my struct Processor contains ... To be even more precise, show the struct definitions themselves.
100% agree. Remember that you only need to be better that the other candidates, so if it's an entry level job even linking your github page with some small personal projects may be good enough.
Because we can all do telepathy...
 void free_Matrix(TMatrix * matrix) { printf("Killing %d %d", matrix-&gt;rows, matrix-&gt;columns); for (int i = 0; i &lt; matrix-&gt;rows; i++) { free(matrix-&gt;intArray[i]); } free(matrix-&gt;intArray); free(matrix); } void free_Matrix_Wrapper(TMatrixWrapper * array[]) { for (int i = 0; i &lt; (*array)-&gt;matrixCnt; i++) { free_Matrix((*array)-&gt;matrixArr[i]); } free((*array)-&gt;operationsArr); } The issue lies somewhere here. I don't know how to get pointer from Wrapper array of Matrix to the function above.
It has always worked just fine for me. 
1: &gt; I only need one TMatrixWrapper Then only have one. At the moment you appear to have an array of pointers to them. Having a single wrapper, instead of an array of pointers, would remove 2 levels of indirection and make your code correspondingly simpler. 2: Your naming is very confusing. You have variables/members called `array`, `matrix`, and `matrixArr`. (and `matrix` isn't a matrix, it is an array of pointers to matrices.) 3: What are you intending to use LIMIT for. Specifically what is int position = ((*array)-&gt;matrixCnt % LIMIT); if(!position) meant to be doing?
every time I reach 0/20/40 elements, increase it to 20/40/60 (realloc matrix array for 20 new matrixes)
No, you just never noticed the problem. Consider: #include &lt;stdio.h&gt; int main() { FILE* f = fopen("file.txt", "r"); while ( !feof(f) ) printf("%d ", fgetc(f)); } I created a file with the contents "abcd" and ran this program. This was the output: 97 98 99 100 10 -1 You can see the 97, 98, 99, and 100, which are the ASCII values for my text. The 10 is because my editor added a newline to the end of the file. That's exactly what we wanted. But what about the -1? The problem is that the logic behind `feof` is backwards from what we want. It doesn't tell us, "will the next read fail because we're at the end of the file?" Instead, it tells us, "did the last read fail because we were at the end of the file?" A subtle difference. In this case, the read of `'\n'` succeeded, and so `feof` allows us to go through the loop again. We're at the end of the file, but `feof` doesn't know that yet. So we go through one last time, read and print something (the `EOF` return value, which isn't a character in the file), and now `feof` knows we're at the end and stops the loop. An even more convincing example is what happens when the file is completely empty. We would think that this loop should do absolutely nothing, but that's not true. It still does one iteration. But, like you said, this loop often works fine. That's because either: 1. You have extra error-checking logic in there. Maybe you're explicitly checking for the `EOF` return from `fgetc`? 2. Sometimes the extra iteration isn't noticed. For example, `fgets` ends up with the last thing it read, which might be completely innocuous for the rest of the loop, possibly by just doing the last thing precisely a second time, which has no ill effects. If it's because of 1, you're just making your life harder. If it's 2, there's a latent bug that might only manifest itself with the right data. Either way, don't use `feof` like that and save yourself some headaches. That's not what it's meant to do.
I have found the issue but I can't identify the problem. free(matrix); is responsible for it in this function: void free_Matrix(TMatrix * matrix) { print_matrix(matrix); for (int i = 0; i &lt; matrix-&gt;rows; i++) { free(matrix-&gt;intArray[i]); } free(matrix-&gt;intArray); free(matrix); } it may be caused by (*array)-&gt;matrixArr = (TMatrix*) realloc((*array)-&gt;matrixArr, sizeof (TMatrix) * ((*array)-&gt;matrixCnt + LIMIT)); any ideas? I'm trying to deallocate every single matrix (TMatrix) from the matrix array in the matrix wrapper.
Independent of the real answer given by the generous others (`snprintf`), you should be aware of your miscategorization of `strcpy` as a "syscall." The term "system call" / "syscall" is reserved for a call which crosses into kernel space (like, say, `read()` or `socket()`) -- not one which merely calls into a library linked into your program (such as strcpy`), coming from the C standard library, which the linker will "link" in with your own code to build your resulting executable. A system call is relatively much more 'expensive' than a regular function call. Here's a [reasonable Quora answer](https://www.quora.com/What-is-difference-between-a-library-call-and-system-call) on the subject.
Thought it might be worth mentioning but the author (Thomas Pornin) is the author of [BearSSL](https://bearssl.org/) a new SSL/TLS library which has amazing documentation and interesting design. It's definitely worth checking out as an example of a well done cryptographic library.
Can you implement a linked list off the top of your head? Do you understand indirection (double pointers)? Can tell if a function pointer can safely point to a specific function? Can you use qsort if you need to? If the answer is yes, then I think a reasonable person would say you are proficient.
Many programs are required to uphold the following requirements: 1. When given valid data, produce correct output. 2. Refrain from doing anything evil when given invalid data, even if that data is maliciously constructed. In many cases, even very loose guarantees about how an implementation will process certain cases where the Standard imposes no requirements may greatly reduce the amount of source code required to meet that second requirement, and the amount of machine code a compiler would have to generate for it. If a program would be allowed to process invalid data in *almost* arbitrary fashion, provided only that some loose constraints are met, behavioral guarantees sufficient to meet those constraints would render many "worst-case" scenarios irrelevant. 
&gt; every time I reach 0/20/40 elements Ensure that `(*array)-&gt;matrixArr` is NULL when `(*array)-&gt;matrixCnt` is 0. Otherwise, post the Valgrind errors and the complete program somewhere if possible. 
[Project based tutorials in C](https://github.com/rby90/Project-Based-Tutorials-in-C) [A tutorial on pointers and arrays in C](http://pw1.netcom.com/~tjensen/ptr/) [Lets Build A Simple Database](https://github.com/cstack/db_tutorial) Also Learn to build the various data structures in C that you get for free with Python like Queue, Stack, single, double and toroidal linked lists, dictionary/hash, b-tree, closures, etc.
If you like mathy problems, you could take a lookat Project Euler.
If you're corrupting memory then any call to malloc, realloc, or free could trigger the crash, even if that call itself is okay. What exactly is valgrind saying?
Eh, deja vu: [EEG DATA COMPRESSION [URGENT]] (https://www.reddit.com/r/C_Programming/comments/a0fyjr/eeg_data_compression_urgent/)
Do you have some sample data? What are the characteristics of an ECG signal? 11.79% sounds great, so what more do you expect? 
C isn't really a language so much as a collection of related dialects. While some jobs might only require use of a single dialect, I would say that true proficiency in C nowadays requires recognizing the existence of dialects where various constructs are reliably processed "in a documented fashion characteristic of the environment" even when the Standard imposes no requirements, as well as dialects that assume programmers will refrain from exploiting any such characteristic behaviors and may behave totally nonsensically if that assumption is violated. 
Yeah, well, some of us actually know *how* to use it.
This is amazing and encouraging (even though I applied to 2 jobs in my field in total and got both of them).
Thanks for the link! Found it very encouraging. I guess I'll be applying and changing up my resume/cover letter.
If you can deal with a bit of loss (mainly from quantization), look into doing [principal component analysis](https://medium.com/@andrewtan_36013/principal-components-of-electrocardiograms-14874b3a96b1). 
Have you tried basic, general purpose algorithms like lemper-ziv (gzip, zip) or Burrows–Wheeler (bzip2)? I'd imagine that an ECG might well behave similar to audio, so what about FLAC or ALAC ?
You might also want to try doing a [Burrows Wheeler Transform](https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform) before compression.
How difficult is mergesort to implement within a linked list, as thats actually the next ome that I have to do? :)
ECG Waveforms probably look very similar to music waveforms from a data perspective. You might find that a lossless music compression works well. Maybe take a look at [FLAC](https://en.wikipedia.org/wiki/FLAC) and [libflac](https://xiph.org/flac/api/) 
it follows this pattern: https://d2m3czf6fvb8bh.cloudfront.net/site_content/files/images/categories/heart/ecg_normal_waveform.gif
To add on to what the other commentors said, the namespaces reserved for implementation defined identifiers are identifiers beginning with two underscores or a single underscore followed by a capital letter (IIRC). So tl:;dr don't begin any identifiers with two underscores or a single underscore followed by a capital letter.
Ha, I bet you could not even turn on my PDP-7 even if I told you how to.
The multiplication signs are actually deferencing the pointers and not multiplicating. Its called operator precedence. Im almost sure the compiler is seeing it as BMI = 703 (\*Weight) / (Height(\*Height));
That is not what I mean. What does the actual data look like?
that helps a bunch. Thank you I was wondering if I was accidentally dereferencing them. 
May I ask why they are pointers in the first place? I'm trying to think of a good reason but it escapes me atm...
Its a very defined final project. They are defined that way because I take an input file and read it and then take age, height etc to find a few things like BMI, mah Heart rate etc and then print that to an output file. 
That doesn’t make sense, but whatever
There is no way to obtain this with strtok() but you cand just concatenate back the parts of the string you want together.
There are a couple of problems with your code. First, your main data structure is as follows: struct record { char *stringData; }; In memory, this data structure contains one element, which is a pointer to an array of characters (effectively just memory address). Now, when you try to write the data, what you write from, is the struct, and the size of the struct fwrite(&amp;theRecord, sizeof(struct record), 1, file); This means that what ends up in the file is not the string (array of characters), but is instead the pointer to that string. If you looked inside of your output file with a hex editor, you would see that your file is 8 bytes long, which is a single address (on a 64bit machine). &amp;#x200B; To fix this, you need to write the actual characters from the string. fwrite(theRecord.stringData, strlen(theRecord.stringData), 1, file); Note that to find the length of the string you use the `strlen()` function. Now you have a problem when you read back your data. When you write the string to a file, you don't know how long it is, you have the same problem when you read back. &amp;#x200B; One solution is that you could change your read back code to read into an array of a known size. &amp;#x200B; #define MAX_STRING 1024 char myString[MAX_STRING]; fread(myString, MAX_STRING , 1, file); readRecord.stringData = myString; This means that your `fread()` will be limited to reading at most 1024B. Another way to do it would be to write the length of the string to the file first. int stringDataLen = strlen(theRecrod.stringData); fwrite(&amp;stringDataLen, sizeof(int), 1, file); fwrite(theRecord.stringData, strlen(theRecord.stringData), 1, file); Now when you read back the string, you can first read how long it is, then dynamically allocate memory for it. int readStringLen = 0; fread(&amp;readStringLen, sizeof(int), 1, file); char* myString = calloc(1,readStringLen); fread(myString, readStringLen , 1, file); readRecord.stringData = myString; Hope this helps. 
It's not really a lossless algorithm overall if it includes quantization, is it? I really think your best bet (unless there's an ECG-specific algorithm or you have a large budget to develop one) is to run through the common lossless compression algorithms, like [DEFLATE](https://en.wikipedia.org/wiki/DEFLATE), and see what gives you a good compression ratio.
**DEFLATE** In computing, Deflate is a lossless data compression algorithm and associated file format that uses a combination of the LZ77 algorithm and Huffman coding. It was originally defined by Phil Katz for version 2 of his PKZIP archiving tool. The file format was later specified in RFC 1951.The original algorithm as designed by Katz was patented as U.S. Patent 5,051,745 and assigned to PKWARE, Inc. As stated in the RFC document, an algorithm producing Deflate files is widely thought to be implementable in a manner not covered by patents. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
There’s a lot wrong here. First off, you’re reading and writing a `struct record` directly. `struct record` includes a pointer, which has zero useful meaning outside the current process address space. Writing it to a file will dump (probably 4 or 8 bytes of) glorified garbage data. If you want to write the string, then you’ll have to use the pointer to and length of `"Here is some data!\n"`; it’d look something like static const char WRITE_DATA[] = "Here is some data!\n"; if(fwrite(WRITE_DATA, 1, sizeof(WRITE_DATA) - 1, file) &lt; sizeof(WRITE_DATA) - 1) { /* The write can fail too. E.g., insufficient disk space or broken network connection. */ fputs("error: unable to write to the file\n", stderr); /* You should be using `stderr` for error messages, unless you’re specifically assigned to do otherwise. */ return 1; } Note `sizeof(WRITE_DATA)-1` because `WRITE_DATA` includes an extra NUL terminator character. You could use `strlen` instead, but it’s icky to use it more than once since it’s O(*n*), especially since the compiler can see the size of the data right there. (OTOH, this means the compiler can optimize away that sort of `strlen` call if it wants to.) Note also that `sizeof` is an operator unto itself, and doesn’t need you to `#include` anything, contrary to the comment after `&lt;stdlib.h&gt;`, which AFAICT you don’t need at all. The type `size_t` requires `&lt;stddef.h&gt;` if you’re not using compiler extensions like `__SIZE_TYPE__` or `__typeof__(sizeof(0))` to get at it otherwise, but `sizeof` is always there whether or not you want it to be. (`offsetof` is another `&lt;stddef.h&gt;` feature that’s often implemented as a kind of pseudo-operator, but you’re not using that.) Moving on, you didn’t actually check for a successful read; you just assumed it went well, because I guess the OS didn’t take down your process suddenly? `fwrite` and `fread` both return the number of records they wrote, and it’s generally best/easiest diagnosed if you use an element size (i.e., first argument) of 1 and the total size to write/read as the second argument. If you’re debugging or capturing the return value, that’ll give you a byte count, which is usually helpful in diagnosing bugs and errors. But again, you’re reading a `struct record`, so you’re making `fread` come up with a basically-garbage pointer value. *If you’re lucky,* the garbage pointer value will match up to the address of the array that constituted the string constant you assigned to the record before writing, and you’ll be looking at the same data you wrote. (Even affording you the most compiler cooperation—say the string constant is assigned to a fixed address, allocated statically and permanently, and the compiler goes along silently with you reading and writing the pointer value—you’ve got a lovely security hole there, because it’s quite possible for some other process to have clobbered the file in between your write and read.) Were you to actually read/write binary data into/from a `struct record` that contained the right fields (e.g., a `char[256]` buffer), you’d be crashing off and on with your final `printf` of the data. Strings are NUL-terminated, meaning there’s a zero byte at the end so software knows when to stop iterating through characters. (Which is why `strlen` is an O(*n*) operation in general.) When you `printf` from binary data, either: a. there’s no zero byte there at all and `printf` will careen off into unmapped memory (→SIGSEGV or SIGBUS, hopefully) after maybe writing a bunch of garbage; b. there’s a zero byte there after what you got from `fread`, in which case the behavior is undefined—maybe it’ll crash, maybe not; or c. there’s a zero byte there inside what you got from `fread`, in which case anything after the zero byte is left out of the `printf` output. On a stylistic note, there is no reason for `file` to be global, and probably no reason for `disk` to exist at all. It’s not a good idea to aim basic `char *`s into string literals; always use `const char *` unless you’re very sure nothing will take full advantage of the non-`const`-ness. (Writing to the memory occupied by a string literal’s data is undefined behavior. Again, may crash; may cause really weird behavior; may not do anything at all.) If you’re going to use globals (in general, don’t), declare anything that isn’t needed in other C code (referenced via `extern` or prototype) as `static`.
Wow, that helps a TON. I was totally lost when I hexdump'd the binary file to the console and it wound up with different values every time despite being the same string. The man pages are a little confusing (or maybe I don't know how to read them correctly) as they claim the input for fwrite as such: fwrite(const void \*ptr, size\_t, size, size\_t nmemb, FILE \*stream). I thought the void pointer meant it had to be a memory address. Thanks!
[removed]
Dont you need the two indexes to access elements inside a 2D array?
Honestly I'm pretty lost at this point. I'm going to head to bed and try again in the morning. I appreciate your answer; i think I need to refresh myself on pointers.
Int grade[students] doesn't work and compiling should give an error. When defining an array statically, students needs to be known during compile time. You need to allocate the arrays using calloc(). 
Force yourself to stay up until you will fix it. Enough suffering will always teach you the lesson.
Are there any errors during compilation? I assume that there have to be some, since you are trying to statically initialize the array "int grade[students]" and others. When you are creating an array like that, using a constant, that constant have to be known during compilation time. Since you set students = 0 and then change it later. That doesn't work. If you want to create arrays dynamically like you want to, you need calloc() or something similar for your variables. 
It should work since the array is allocated in the stack. At least that is my understanding...
What do you mean by "concatenate back the parts of the string"?
I second this unless your health is being being severely impacted
Well mate, what I would do in your position is grab a copy of *The C Programming Language (Second Edition)* by Kernighan and Ritchie I mean there's a bunch floating around on the net if ya can't get a physical book. That's if you want to actually learn C though, to the point where you understand primitive functions like getc and can actually implement their more complex variants—such as scanf—in terms of them, along with understanding data storage, allocation, and usage. There's no shortcuts in programming, start with the fundamental concepts, then work your way up, or it's just one long tiresome stream of confusion and endless questions. All the best to you.
You could use sscanf() or strtok()
As far as the standard library goes, I'd first read the token into an array of characters, represented as a string, then use sscanf to handle the task easily, as shown int n, m; char *s = "mult:3,6"; if (sscanf(s, "mult:%d,%d", &amp;n, &amp;m) == 2) printf("%d\n", n * m); else if (sscanf(s, "add:%d,%d", &amp;n, &amp;m) == 2) printf("%d\n", n + m); else fprintf(stderr, "unrecognised operation\n");
Keep in mind that strtok is destructive, meaning if you intend to use the array of strings after tokenizing it, only one value will remain in the array. I'd suggest making a copy of the array of strings and then operate on the copy
Write your own handmade lexer. This one is simple, just make a function that keeps reading until it finds the delimiting character (can be taken as a parameter) and returns a newly allocated char pointer with a substring.
Your code is C++, not C, so please ask in /r/cpp_questions.
Wrong language -- this is C++
"char nLong[64]" is local to the function convertToLong() and is stored on the stack. It only has life (on the stack) for as long as convertToLong() is executing. Once convertToLong() returns to main() the memory (on the stack) can get reused by another function call. Such as calling printf()
The short answer is that "return nLong" returns a pointer, to a variable (an array in this case) that has "automatic" storage; meaning it will not exist after the function ends. The more technical reason is that nLong is created on the stack, and the stack changes and gets overwritten when functions are called and returned. It's like a "scratch" area. &amp;#x200B; You should either put nLong in the main function, and pass it into convertToLong(), so that it's still valid when returning to main, or use malloc() to allocate storage that is not "automatic" duration, and isn't on the stack. &amp;#x200B; You should also ensure that scanf(), and the loop you wrote to put the digits in nLong, don't exceed the space allocated by your static arrays, but those are independent issues.
I'm actually still new enough that I struggle with scanf, and memory management. I saw one solution saying I could use something like scanf("%64s",string) , but I don't know how well this works. I wanted to make scanf work with a pointer, originally. I originally used char * input; , but had confusing issues when doing this, and had a lot of trouble figuring out how to handle them. Pointers and de referencing still sometimes confuses me more than it should, unfortunately.
Thank you for the very informative answer!
I attempted to make a fix based on your reply (Thank you again for the time spent on it) and this is what I came up with, could you please tell me if this is the proper way to handle this? char * convertToLong(char input[],char nLong[]); int main(void){ char input[64]; char nLong[64]; printf("Input your credit card number\n"); scanf("%s", input); printf("%s\n",convertToLong(input,nLong)); } char * convertToLong(char input[],char nLong[]){ int i = 0; int j = 0; for(i=0;i&lt;strlen(input);i++){ if(isdigit(input[i])){ nLong[j] = input[i]; j++; } } return nLong; }
Can I ask why this particular code needs to be in C? There are other languages that shield you from the memory management part of these kinds of problems, and if you are just looking to learn how to do things like scan and transform input, process text, etc. you may get more bang-for-your-buck from them as a total beginner. On the other hand, since C \*doesn't\* shield you from this, you will need to learn a bit more about how memory, stacks, heaps, and basic datatypes (int, float, char, etc) work, so that handling these details eventually comes second nature. Don't get me wrong, learning and mastering C will make you a much better programmer in the long run, but given this particular example as a total beginner, I'm just wondering what your ultimate goal is.
&gt;and this is what I came up with, could you please tell me if this is the proper way to handle this? It's \*a\* way to handle it. Did the compiler warning go away? It's more typical these days to make the function signature something like: char *convertToLong(const char *input, char *nLong); ie. since the use of arrays in main() is sort of incidental; inside the function it's just pointers-to-char. After the loop (and before the return), you should put a terminating '\\0' on nLong, to make it a valid string, ie: nlong[j] = '\0'; This still doesn't handle inputs that overrun the size of the array, but first things first, and at least get this running okay so you can play with it. It seems to me like it should be working (or close to it, with the proper includes).
I'm learning in C because I have an upcoming education in C. You can take the above as a TLDR, or read further, depending on how much you care. In my country, we have a system called "WeThinkCode", which has partnered itself with every large programming company in the country. WeThinkCode is paid by all of these companies to properly train students, and only produce incredibly competent programmers, which is why it's funded entirely by companies, rather than requiring students to pay money to enter. They take in the top 1% based on their online aptitude test (It's mostly just a series of logical thinking tests), and then test these 1% by enrolling them into a "bootcamp". You need to show up to the bootcamp, and do programming assignments given to you regularly, and are expected to spent 10 hours a day on campus. After these 3 weeks, they choose a select few of the attendees that they think can become good programmers, and have good work ethic into their 2-year course. After the 2 year course, you are given guaranteed employment at one of the aforementioned, programming companies that are sponsoring WeThinkCode. It's considered very impressive to come out of WeThinkCode here, and has a lot of benefits. 
I changed it in the way you mentioned, thank you. The error did go away, and the code is running properly. You're right that there's nothing to handle input that exceeds the [64], and I'll try to fix that now. I just am not entirely sure how to best dynamically size my arrays right now. I know I can do char * input, but apparently that doesn't initialize input, and I'm not sure how to initialize it.
&gt;I'm learning in C because I have an upcoming education in C. Okay, that's great then. Learning C definitely pays off in making better programmers overall (IMO). But in the learning phase it means learning not just the language details, but also understanding concepts of how computer systems (memory and such) work on a basic level. So yeah, I'd say a next step is to ensure the scanf() doesn't write more characters to the input array then you have allocated storage for (remembering that there needs to be a final '\\0' character. Even more fun, \*deliberately\* input more characters than you have allocated space for, and see how it affects the program when running it (try various sizes of input, inputs without any digits, etc.)
I am actually trying to handle a lot of those things now, I added the \0 you mentioned, which I greatly appreciated, as it was something I didn't think about at all. I am curious, does \0 read as 1, or 2 in the array? If I had an array that could hold 64 chars, would the \0 take up the last slot, or the last two? I am also curious if you have any ways you suggest I handle making sure input stays below 64. Thank you so much for all the help you've given me, you've been a pleasure to talk to, and given me a huge amount of help in a small span of time.
&gt;I know I can do char \* input, but apparently that doesn't initialize input, and I'm not sure how to initialize it. I mentioned it in another reply, but you can learn `getline()`. It's a relatively new addition to the C standard, but it can read in an arbitrarily large amount of input, and return a pointer to that buffer. Behind the scenes it uses `malloc()` to allocate memory (and `realloc()` to enlarge that memory allocation if it needs to), so unlike a fixed size array variable, it's dynamically allocated memory that needs to be `free()`\-ed eventually. This starts to get into the slightly-more-advanced C category, but it must be learned eventually. Even when you are able to handle inputs of arbitrary size, you still have to prevent your nLong buffer from being accessed out of bound, but that shouldn't be too difficult since their should be a natural bound on the number of digits you need to read. [http://man7.org/linux/man-pages/man3/getline.3.html](http://man7.org/linux/man-pages/man3/getline.3.html) &amp;#x200B;
They just make up words to add padding to their advertisement, no one knows what proficient means unless they have a dictionary, so just apply anyway, they use it to discourage wimps from applying. You aren't a wimp are ya? :-P
&gt;I am curious, does \\0 read as 1, or 2 in the array? The '\\0' character, is just literally a byte with the value zero (ie. all zero bits). You could also assign 0 to the array, instead of '\\0', and it would be the same thing, but it's more conventional (and proper) to use the '\\0' constant to indicate you are working with a char, and not an int. So, to answer your question as asked, it reads as 0 in the array. &amp;#x200B; &gt;If I had an array that could hold 64 chars, would the \\0 take up the last slot, or the last two? Ah. Note that `'\0'`, although it takes 4 characters to type in the source code, represents just one char in the program. The single quotes are just there to indicate it's a `char` constant, rather than a string constant (with double quotes), and the slash before the zero indicates it's the literal zero byte, rather than the zero digit (which actually has a value of 48, '1' has value 49, etc.). The slash itself is just an indicator for the constant, but isn't actually stored in memory before the zero, for example. All C strings end with a zero byte, meaning '\\0', not '0'. &amp;#x200B; A string constant "0" (note the double quotes) actually represents \*2\* chars, in this case. The ASCII '0' char (ie. the digit 0), and a string ending '\\0' char, that all string constants have (ie. the compiler adds it, even though you don't see it directly in the source code). So that's why there is a separate way to represent single character constants using single quotes. &amp;#x200B; To answer your question, the '\\0' should take up a slot just after the last character in the string. That may \*not\* be the last "slot" in the array. For an array of size 64, if the input is only 10 digits, the '\\0' would be in the eleventh slot. What comes after that last '\\0' can be arbitrary, and typically is just whatever left over bytes are in memory. The C string functions know to look for a single '\\0' to indicate the ending of a string. It is typical to see people writing zero bytes to memory chunks used for string inputs, just to clear all the bytes to zero beforehand, ensuring that any byte in memory that is not modified by a string handling function will act as a kind of string termination byte. Ie. clearing memory manually to zero can be common. C even does it for "static" variables. However, forgetting to add a '\\0' char when working with C strings, or forgetting to leave one extra space in a buffer to hold the '\\0' in case the buffer fills up, is a common source of bugs for C, which you may have heard mentioned as "buffer overflows".
This was incredibly informative to read, and I can't express enough how grateful I am to have all of this to read. These little bits of information are fairly difficult to find when you need them, or at least that's what I find. I had no idea that 0 had an ASCII value that wasn't 0, or that '\0' would define a literal 0. This kind of information is great to have, and will have a positive effect on me to know, so I appreciate the extra lengths you went to to point them out! I actually changed up my code quite a bit between commenting with you, and do find myself experimenting with stupidity, admittedly. You probably noticed by how my application printed "Input your credit card number" that it handles .. credit card numbers. Because I'm working in C, I was forced to learn a lot of things from just this. I've been forced to think in a very specific way because of C, and I actually love it. Right now, I'm taking in a string from the user, for the sake of making sure they can't mess things up, and because some people input credit card numbers like this 555-6666-999, you get the idea, and then I convert this into a new string with only numbers. I had to think about this, because a credit card number is never more than 16 digits, but the initial string will be longer because of either user inputted spaces, or -'s, so I decided to have the user input string be 32, and the char containing only numbers be 17, so that it can hold all 16 of the credit cards digits, and the '\0' at the end. This is so.. Odd, but I love it, as it feels a bit like a puzzle to me right now. I obviously need to handle bad inputs, and tell the user that their input was bad, and why it was bad, but that can come later.
You are taking your first steps into a much wider world. It can be thrilling, it will certainly be challenging, and will likely be very frustrating at times. &amp;#x200B; Are there any C projects (or open source projects in general) that are most interesting to you? You will learn the most (IMO) by reading, reading, reading C code from something you find interesting. When I started out, it was reading the source code for NetHack (a game), for example. Then things like the obfuscated C code contest entries, Linux and the C library, etc. This is advanced stuff (and I had already had years with other languages), but if you look for some existing code that does something you have an interest in, it's a way to dive in that can help steer your early coding development. &amp;#x200B; With regard to this existing project, the way you describe your thinking on how to approach the problem sounds good to me; you are considering the individual pieces and how that will work as a whole. You are prepared to change things as you learn and re-consider (this will happen a \*lot\* even as you become advanced). You seem on the right track for a beginner. Just keep at it, hopefully consistently, and you'll be amazed at how much you can progress.
What I'm doing right now, is following Harvards, online, cs50 course. It was made free, and completely online a few years ago, and it's helping my by giving me progressively more, and more difficult tasks. Right now, I struggle to even read code at times, when it gets too messy, or advanced, so I'm trying to just program every single day, as much as I can. I'm still super early into my programming days, but maybe looking for books on the fundamentals of C would be helpful to me. For now, I'm happy with following this cs50 course at least, as it attempts to challenge me constantly. They tell you what you have to do, and that's it. I have to, on my own, figure out things, which is what is forcing me to think on my own, and grow. 
Using the token method dis string "0 : 65535" Will get separated into 3 different strings: "0", ":", "65535" and create a new string( in C its just a char array) and then use strcat() to concatenate the 3 new strings into one.
Not your question, but shouldn't the function return the number as a long ?
Try `strchr()` with pointer arithmetic or scan the string in loop, copying interesting characters to the other string. `strtok()` is another tool to do this, but uses static variable and reallocs, so you need to be careful. 
Bad naming conventions on my end. The function actually takes a string, and since it takes a credit card number, which could be input as 5555-5555-5555 or 555 555 555, I parse it into a new string with only numbers so that I can strtoll it later. I definitely need to rename the function.
&gt;shouldn't the function return the number as a long ? Though the functions talk about longs, the input (credit card numbers) suggests the value is a string of digits, rather than a number to be calculated with. So more likely the function and var naming (and use of the term 'long') is what should be changed, perhaps to 'digits'.
You are multiplying pointers. Try dereferencing them first. 
Ohh I see. That solved my problem. Thank you so much man.
The handling of strings in C is very weak and a touch esoteric. Improved string handling is a defining characteristic of most high level languages. It is important to remember that a C string is an array of characters terminated by a null. This is why many of the string.h functions feel like generic memory or array functions. For your particular example the following should work, char arg[] = "sum:1,2"; int len = strlen(arg); int i = 0; char* command = arg; while(i &lt; len) { if(arg[i] == ':') { arg[i] = '\0'; i++; break; } i++; } char* num1 = &amp;(arg[i]); while(i &lt; len) { if(arg[i] == ',') { arg[i] = '\0'; i++; break; } i++; } char* num2 = &amp;(arg[i]); We convert the tokens into nulls, which breaks the string into three little strings, and our extracted arguments are pointers into the start of each chunk. I think doing it manually is a nice way of showing how strings work. However this is basically how strtok() works, so you can use it very simply. char arg[] = "sum:1,2"; char* command = strtok(arg, ":"); char* num1 = strtok(NULL, ","); char* num2 = strtok(NULL, "");
Also format your damn code.
Why do you pass an array of pointers but only use the first pointer?
You mean with the TMatrixWrapper? I don't know, I thought keeping it on stack is not effective for some reason, I can rework it to be single instance
could you let us for a see？ 
it is a calculator program that used to calculator ，yes？where are wrong？ 
[Advent of Code](https://adventofcode.com)
No, it's a perfectly legitimate variable-length array. C11 made them optional, but most implementations support them since they were mandatory in C99.
There are several mistakes here: 1. In C, multidimensional arrays are written with the outermost dimension first, so `char name[50][students]` should be `char name[students][50]`. 2. `name` is a two-dimensional array, but you're passing it to `report()` as a *one*-dimensional array. 3. The loop in `report()` ends too early. 4. `report()` prints a newline character at the beginning of each line instead of at the end. 5. If you're alternating output and input as you do here, and especially if your output does not end in a newline, you should flush `stdout` before taking input. 6. You did not enable compiler warnings, which would have pointed out at least some of these issues. 7. You did not post the complete source code. 8. You did not indent your code properly.
&gt; The single quotes are just there to indicate it's a `char` constant It is a character literal, but its type is `int`.
`QuadTree()` expects a pointer to a pointer (or array of pointers) to `int` as its first argument, but `InitialArray[i][j]` is a single `int`.
It uses Raylib for rendering. [Player.h] (http://ronsoros.github.io/?8f66f474ba5a0939ebb0b8e3cab7a889cac4109a) [Player.c] (http://ronsoros.github.io/?7ef688ba8b51e44a7756070a3198522fb74ff29a) [Engine.h] (http://ronsoros.github.io/?63ffcb5d02324460479c65e613590dd38ce9d3c9) [Engine.c] (http://ronsoros.github.io/?c503ef59d9d2d8e68f3a4a5eea8957c1b453b6e5) [main.c] (http://ronsoros.github.io/?d728d9000d9ca6245478a06cc08c8e0a530d4aa5)
You are being a bit vague, but it sounds like you're having trouble managing game state between "walking around" and "other stuff", such as interactions. Maybe what you need is a state machine. Or, maybe, you're looking for a message pump / event loop: [WP Event Loop](https://en.wikipedia.org/wiki/Event_loop) I hope that's some food for thought, let me know if you have any more detailed questions.
Are you trying to do too much at once? I would split it into smaller parts, one function to multiply the whole BigNum by small integer and another to add a small integer to it. Then this function would be just the typical 10 \* bignum + chr - '0' in a loop.
No C++ memes. C memes are fine though.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Did you try it? Did it work? BTW, you should use `'a'` and `'z'` instead of numbers (and pray nobody tries to run your program on an EBCDIC machine), and the return value from `main()` should be between 0 and 255.
i tried it but i keep getting the error message for both cases(lower and uper) the error should.only be for uppercaseletters i also tried 'a' and 'z' but I still get the same result
So, maybe you should have mentioned that in your post. You'll figure it out if you add `printf("%d\n", a[i]);` at the top of the loop, before the `if`, or single-step through the loop with a debugger.
You should be able to make a simple "sieve of eratosthenes" prime check to start with. And then you can for(unsigned int i = a; i &gt; 2; i=i-2) { if(sieve_of_e(i)) { //check if number is prime if(sieve_of_e(a-i)) { //check if remainder is also prime printf("%u %u\n", i, a-i); } } } this works for 2 primes, if you need a third one, you would need to nest another loop in the inner if-statement and do another check, but this should send you on the right track.
I think you might be in the wrong sub. This is C programming not C++ programming. 
Might as well limit your exit code range to 0-125 since POSIX defines special meaning to &gt;= 126 in a shell context. 
Honestly, one of the best ways to do this in games is to have event queues. Push an event to a specific queue, and have an event loop iterate through all of the items in the queue and notify the subscribers when appropriate. Subscribers being function calls or a pointer to a strict of some sort depending on the task. This way also makes it easy to publish events concurrently if you have a physics engine as well. 
We just deal with C here, not C++. Try /r/cpp_questions 
Dont forget move to front!
C++ is off topic in this subreddit. Please post C++ questions to /r/CPP_questions instead.
From the linux man page for `fgets`: &gt; fgets() reads in at most one less than size characters from stream and stores them into the buffer pointed to by s. Reading stops after an EOF or a newline. If a newline is read, it is stored into the buffer. A terminating null byte ('\0') is stored after the last character in the buffer. Does that give you any clues?
AFAIR fgets returns a string including '\n' (newline from ENTER key supplied by user to confirm entry), which has a value outside of lower-case letters. Add a second condition to loop, for example `a[i] &amp;&amp; a[i] != '\n'`. If you are running this on Windows, check if that function does not return '\r' first, because line break in that system is composed of two characters and I'm not sure how fgets treats it. 
after i used break after the if clause it worked :) i guess the new line was the problem
Yup, `a` will have a newline at the end of it. I would have fixed it by checking for newline in the `for` btw, e.g. for (i = 0; a[i] &amp;&amp; a[i] != '\n'; i++) { 
If OP is writing for a POSIX compatible system, strtok_r eliminates the thread safety issue. Still need to operate on a copy of the original string if they need a nondestructive operation, though.
Rather than hosting your code in Google drive can I suggest you use version control of some sort: https://guides.github.com/activities/hello-world/ A good UI once you've got an understanding of the concept is gitKracken.
Oh sorry, thanks for the redirect though!
Hey, I'm sorry to ask this of you, and if it's a bother, feel free to ignore it, but I was wondering if you could review my finished code, now that I've spent my free time today finishing it. int main(void){ char input[32]; char handledCard[32]; char * endPtr; long long cLong; //Handles user input of their credit card. printf("Input your credit card number\n"); scanf("%31s", input); if(strlen(handleInput(input,handledCard))&lt;=16){ cLong = strtoll(handledCard,&amp;endPtr,10); } else{ printf("Input was more than 16 characters, input needs to be 16 or lower.\n"); } //Calculates if this credit card is valid. if(calculateValid(cLong)==1){ printf("Card was valid\n"); } else if(calculateValid(cLong)==0){ printf("Card was invalid\n"); } } char * handleInput(char * input , char * handledCard){ int i = 0; int j = 0; for(i=0;i&lt;strlen(input);i++){ if(isdigit(input[i])){ handledCard[j] = input[i]; j++; } handledCard[j] = '\0'; } return handledCard; } int calculateValid(long long input){ int temp = 0; int temp2 = 0; long long input2 = input; while(input){ temp += ((input/10) % 10) *2; input /= 100; } while(input2){ temp2 += input2 % 10; input2 /= 100; } if((temp+temp2) %2 == 0){ return 1; } else{ return 0; } } Any insight into what I could optimize, or do differently would be super appreciated. As to what this does.. It checks if a credit card is valid. This is done by multiplying every 2nd digit on the card (Starting at the end) and adding the results together, then adding that result to the sum of the numbers not multiplied. 
good idea - in the meantime, I solved it by first converting the decimal string to binary string and then just copying it. But your solution might be faster.
I'm assuming you're a beginner so you're no good with pointers yet (they make this very simple) Since you come from python (I don't know any) there's probably a nice way to split a string depending on the character. Think about how you could split the string. (hint: place a '\0' instead of the characters you don't want, and store the starting position of any legitimate string in an array) Here's two function prototypes that might help: int split(char string[], int startingpos[], char delimiters[]); int copystr(char string[], int startpos); you'd first split the string up, and then loop (remember to store the result of split()) over the startingpos array, copying the string to a different buffer and using standard library functions (atoi() for example) to convert the string to a number, or strcmp if it's the operation. Hope this helps. 
In addition to the other responses: idiomatic naming convention varies by platform. On Unix/POSIX, "snake_case" is preferred. On Win32, you're relatively likely to see PascalCase or camelCase. C code can be cross-platform on both, so consider establishing a pattern for your team or yourself, to be consistent. * name.command means an element in a struct, so you can't use the dot for variable names by itself. * hyphens are disallowed, as they mean subtraction. * Starting with a digit is disallowed, as that means a decimal-denominated constant (or octal-denominated if it starts with 0, or hex if 0x). 
&gt; and how the behavior in "aggressively optimized" dialects can differ from that. I don't know the answer to that, in the case of the example given. Would such dialects shove each argument into an unsigned short, multiply in place, let it overflow, and return the result? If I was hiring, I wouldn't care particularly about what implementations might do, I would mostly care about the precautions someone takes against the unexpected. 
Are you sure your logic is right? &amp;#x200B; If the input is bigger than 'a' and less than 'z', you print the error message. Is that what you want?
If by “empty” you mean EOF, then AFAIK no it’s not possible without trying to read something, or using `feof` after having failed to read something. If by “empty” you mean “without any unread characters having been typed yet,” you can’t do that with stdio streams but you can sort of do it with a raw TTY FD; you’d put it into some raw-ish mode (at least disable line buffering), make sure the FD is opened with `O_NONBLOCK`, and then you can use `select` or `poll` to probe it, or just `read` over and over again until it returns &gt;0. The specific platform may also have a `kbhit` or similar test function, but that tends to be a different thing than stdin.
If I'm interpreting you correctly, you're asking if there's non-blocking I/O in the standard library. In other words, is there a way to either check if, and how much, input is available before attempting to read it, or to return a short read without blocking when there isn't enough input available. The answer is, unfortunately, no. You have to reach out to a platform-specific API (i.e. POSIX, Win32) to get this functionality. It's not part of standard C. 
In other words, usage is printed instead of waiting for input from keyboard ? *isatty(0)* would be that on unix, easy to use even, but elsewhere... Could one cook up something with *fseek(stdin)* ?
I know all that
I just want to mention that many programs I've used do not expect input from stdin unless explicitly mentioned with a parameter (usually `-`). One notable example is `mpv`, a media player, that if you invoke with `mpv -` will start reading from stdin. I think this is the proper way to go, and you should show usage only on wrong parameters.
[is this what you wanted?](https://imgur.com/a/5GDqjqw)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/xNpXz2k.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20eb34vw8) 
Use c++ (fastest way) then you resort to pure c for other functions, parts of your code
&gt; C11 allows the use of arbitrary Unicode characters from a number of ranges specified in Annex D. That is for *universal character names,* You are only allowed to use these using the `\uXXXX` and `\uXXXXXXXX` syntaxes. It is not possible to use them directly in a portable program. The dollar sign is legal as per §6.4.3 ¶2 but not in the list given in §D.1, so it cannot be used in identifiers portably, even when given as a universal character name.
No! I want the actual data you have and an explanation how it is to be interpreted. Not a picture of it. Not a general explanation of ECG or EEG data. How am I supposed to fiddle with compression algorithms if I have no data sample to work on?
I am sorry, I can't provide with the actual data since it was given by the university
Can you at least answer the following questions? * What is the sample rate? * What is the resolution? * How many samples does your data series have? Just to allow me to estimate what amount of compression is possible. Also, does the compression have to be lossless?
&gt; The handling of strings in C is very weak and a touch esoteric. Improved string handling is a defining characteristic of most high level languages. There are also libraries for it in C, which can often ease the work while retaining everything we like about C. 
What if the user wants to paste the contents of a file? Easier to invoke: "program" rather than "program &lt; /dev/tty" right? Lol
`1 &lt;&lt; BIG_NUM_MAX_BITS_PER_BLOCK` should be `1ULL &lt;&lt; BIG_NUM_MAX_BITS_PER_BLOCK;`. Otherwise you are trying to do a 32-bit shift (if you're on a machine with 32-bit ints that is), which is undefined if the other operand exceeds 31.
Consider the following pair of functions: #include &lt;stdint.h&gt; uint32_t ct; unsigned mul_mod_65536(uint16_t x, uint16_t y) { return (x*y) &amp; 0xFFFFu; } uint16_t test(uint16_t n) { uint16_t tot = 0; n |= 32768; for (int i=32768; i&lt;=n; i++) { tot += mul_mod_65536(i,65535); ct++; } return tot; } Depending upon the compilation flags, gcc can treat `mul_mod_65536` one of three ways: * It can unconditionally return the bottom 16 bits of the product of `x` and `y`, without regard for whether that product exceeds `INT_MAX`. * It can deliberately squawk if signed integer computations yield a value beyond `INT_MAX`. * It can use the fact that `mul_mod_65536` is only required to handle cases where the arithmetic value of `x*y` is below INT_MAX to make inferences about the values of objects in the calling code. With optimizations enabled, for example, gcc is "clever" enough to recognize that there is no case where the Standard would require that `test` do anything other than increment `ct` exactly once and return 32768, so it will generate code that does that unconditionally. True proficiency in C requires understanding the Spirit of C (described in the published Rationale documents) and the dialects that uphold that in ways suitable for a wide range of purposes, and how it differs from the dialect processed by "aggressively optimizing" compilers. 
Sorry I didn't reply for a bit, was busy with birthday. I don't mind if it is C or C++, whatever works the best as I am not certain how visual studio works in terms with setting up the compiler (or if I need to change compilation settings somehow). I apologize if that sounds very noobish. (I am a noob :P)
 char * handleInput(char * input, char * handledCard); As a matter of style, attach the asterisk to the variable name, ie: char *handleInput(char *input, char *handledCard); This is much more idiomatic, and makes reading the code easier. Relatedly: temp += ((input/10) % 10) *2; Here, put a space after the asterisk for consistency. A space to the left of the asterisk and not to the right is scanned by C programmers (at first), to be a pointer dereference. So either put spaces on both sides, or neither, when multiplying. &amp;#x200B; } else{ Put the else on the same line as the if closing bracket, ie.: } else { &amp;#x200B; handledCard[j] = '\0'; This should go outside the for loop. It only needs to be executed once after all the inputs chars have been scanned. Yours works, but misrepresents intent (and doesn't catch the case where strlen(input) == 0). &amp;#x200B; Is the check algorithm meant to be a modified version of the Luhn Formula? [https://en.wikipedia.org/wiki/Luhn\_algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) The code you have isn't quite the Luhn algorithm, nor what you wrote as text. But it may be what you intended, which is fine. AFAICT it's very well written code for a C beginner, and your calculateValid() is fairly clever in how it handles the algorithm. &amp;#x200B; Your error message for entering fewer than 13 digits should mention the upper limit (16), not just "and higher". User experience can be greatly improved by little details like this, imo. &amp;#x200B; Honestly, it's fairly good straightforward and efficient code. Think about what might happen if the input is longer than 31 characters on a line, and you had to read in two lines of input. Or if the user inputs a space among the numbers they are inputting. This is one reason why scanf() is one of the trickier C functions. But what you've written appears to be safe from buffer overflow.
**Luhn algorithm** The Luhn algorithm or Luhn formula, also known as the "modulus 10" or "mod 10" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the United States, Canadian Social Insurance Numbers, Israel ID Numbers and Greek Social Security Numbers (ΑΜΚΑ). It was created by IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048, filed on January 6, 1954, and granted on August 23, 1960. The algorithm is in the public domain and is in wide use today. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The Luhn algorithm or Luhn formula, also known as the "modulus 10" or "mod 10" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the United States, Canadian Social Insurance Numbers, Israel ID Numbers and Greek Social Security Numbers (ΑΜΚΑ). It was created by IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048, filed on January 6, 1954, and granted on August 23, 1960.
&gt; I mean, C is hard to work with. Says who? You mean the people who have never worked with it? &gt; You low level everything. Unless you abstract everything but if you want to "low level" everything, at least you can but so can C++. The rest of your post is just blah blah about things you have serious misconceptions about and likely learned from reddit headlines in the C++ sub by people who don't realize C++ has the same components of C.
This is incorrect; in an expression `703 * weight` the language grammar determines that it is the binary-`*` (which means multiplication), without considering the types of identifiers. The error message indicates that multiplication of pointers is not allowed. 
There is a lot less complexity in C. With a C program you can immediately tell what's going on. With C++ you are at a loss without an IDE that helps you sift through all the inheritance/overwriting functions that might be going on. You can write reusable Code in C just fine. I can write code an run it on a STM32, an ATmega328, an esp8266 and my Linux box without any modifications provided the necessary functions are present. (Yes you can do that too with C++ but you'll have to restrain yourself more than you'd do with C++.) C++ is a complex beast. You surely can find elegance in it, but to do so you first have to master the language. C in contrast is a simple language that's easy to grasp and to master.
C was essentially invented to be an extremely low-level programming language. It was basically presented to me as a replacement for assembly. C is essentially a "you want something done right, do it yourself" language. It gives you access to the bits and bytes and everything else you need to do anything you want, and does very little for you. So yes, C is harder to work with, and does less for you, but it lets you do pretty much *anything*. Read Neal Stephenson's essay [In the beginning was the command line](https://en.wikipedia.org/wiki/In_the_Beginning..._Was_the_Command_Line) for an insight into the philosophy behind C. Ideally, there would be no reason to use C instead of C++, since C++ can do everything that C an do, and more, and you don't need to use the parts you don't want. Both Apple and Microsoft write device drivers in C++ nowadays. In practice, you might still use C because then there's no requirement to pull in the C++ run time, which lets you keep your memory footprint smaller. Or you might be running in an embedded environment where the C++ runtime is not available. Or you might just use C because it's simpler, and if you're not using *any* C++ features, then why bother with the extra overhead of C++?
C is harder to work with. String handling alone makes that abundantly clear. Handling memory management is significantly trickier in C than C++. &amp;#x200B; And I say this as someone who uses both languages quite frequently.
If I'm looking to optimize my time I'd use python, java, or c#. All C++ ever had going for it was that it had C in the name. "You never pay for features you don't use" goes out the window if you try to modify/re-use some one else's code. C++ code that combines language features rapidly turns into an ugly mess. Operator overloading further obfuscates what you are looking at. C++ is a mess of a language. Even the languages creator has moved on to other projects. C code is relatively easy to link into other languages if you need native performance (most interpreters are implemented in C). C++ code is not, unless you follow all the restrictions for extern "c". I've always found it easier to write my personal programs in python and if absolutely necessary write performance critical routines in C (or use someone else's library that already does this, like numpy or scipy). 
I would choose C++ over C simply for string handling.
C is complex? C++ has template, metaprogramming(templating is touring complete!), (almost)complete C compability(so it complexity), consteprx, rule of three that then became rule of five, "thanks" to reference you have not a quick way to identify if you modify your caller variable unless you know the function signature..
easy to learn hard to master?
Bjarne Stroustrup famously said: &gt; I never saw a project for which C was better than C++ for any reason but the lack of a good C++ compiler. Of course, being the creator of C++ makes him slightly biased. But there's some truth to the statement: since the common subset of C and C++ encompasses the majority of the C language, almost anything you write in C can be compiled by a C++ compiler. The result is you can't say that C is faster than C++ ... because you can write the same C-like code in your C++ program and get the exact same performance. Bjarne provides an exception -- when you don't have a suitable C++ compiler. Given that its orders of magnitude more difficult to make a standards-compliant C++ compiler, it's not surprising that there are platforms where C++ just isn't an options ... but almost every platform has an acceptable C compiler. But I disagree that this is the only reason. A few others that come to mind: 1. Legacy code. If you're extending code that already exists, it makes little sense to convert it to C++. Just keep writing it in the language that it's already in. 2. Prior experience. If your team is more experienced in C than C++, it will often make sense to stick with C. Getting up to speed on C++ often isn't worth the long-term investment in training. 3. Language bindings. C is the lingua franca between different languages, so if you're interacting between multiple languages it makes sense to just write in C. It's possible to do this in C++ (exporting the symbols as C), but I'd prefer to just use native C instead. 4. Sometimes you can't use the full C++ experience. Exceptions, RTTI, heap allocations, and more. So you start restricting out whole portions of the the language out of necessity, and your code ends up looking almost like pure C. At that point you might as well use C so that you don't have to monitor for use of disallowed language features. 5. Fringe differences. Yeah ... so what I said about writing C in C++ and it producing the same result? That was an oversimplification. There are some subtle differences where one will produce different machine code than the other -- the effects of the code will be the same, but it might perform ever so slightly different or the size of the executable will be different. It's rare, but sometimes this could matter.
Anything you can do in C++, you can do with Go, C#, or Java (and be more productive as a programmer). The only really amazing use case for C++ is videogames and maybe hardcore data processing where the speed is the primary concern. For low-level stuff, C has great interoperability with other languages and is a lot simpler. A lot of software projects also use it as the primary standard so you're kind of forced to use it there too (Linux, GNOME, Apache, etc.).
The main reason for using C is that it’s a WSIWIG language. I can look at a piece of C code and predict (with pretty good accuracy) what the assembly generated will be. With C++, all that abstraction comes at a cost. The compiler and libraries do nasty things under the hood like memory allocation and computation that makes this harder. Having the language WISIWIG is hugely powerful in systems programming where you’re operating directly on the metal, so there just are t the resources for all the abstraction and/or performance is critical. There are a couple of libraries out there that make programming in C a bit mor like C++ when you want it, here’s one of my favourites: https://github.com/mgrosvenor/libchaste 
TBH, I never use those features. My main use for C++ nowadays is Apple and Microsoft device drivers, and both operating systems have their own proprietary ways to deal with strings. Plus, in device driver land, you only have a subset of the runtime available to you. I couldn't even say if C++ string handling is available.
&gt;I mean, C is hard to work with. No, it's not. It's a lot easier really &gt;You low level everything You don't. If you want to write low level code, write low level code, if you don't, you can even go nearly python-level in C if you want. It's a huge misconception (Java propaganda) &gt;For example, string in C++ is much more convenient in C++ char mystr[] = "Hello world!" //later puts(mystr); It really depends on what you're trying to do. Dynamic strings are annoying, but they really only add a few lines here and there, and you can abstract that away easily (https://github.com/lib-x/xstr). It's a misconception that they're really hard. &gt;but is it worth the hassle of rewriting code that you already wrote / others already wrote? There's not much that you have to rewrite, that's a misconception (more Java propaganda) &gt;What about classes? They help a lot in OOP. 1. OOP is bad 2. You can do OOP in C if you really want, but don't. &gt;I understand that some C people write drivers, and back compatibility for some programs/devices. But if not, then WHY? Because it's a good language. It's easy, it doesn't have the random useless complexities of C++, and it's fast.
&gt; yet in C you type a lot of lines just to do the same task. Can you give me an example? Most examples of string manipulation being tedious in C come from people not using the string manipulation functions in the libc effectively. &gt; Some people may say "it's faster". I do belive that (to some extent), but is it worth the hassle of rewriting code that you already wrote / others already wrote? What about classes? They help a lot in OOP. It may be faster, but the main point is that C has a good base performance and encourages you to write efficient code because slow code is much more tedious to write than in other languages. In C, you naturally pick a down-to-earth programming style resulting in fast code because complictated high-abstraction code is annoying to write. Other languages are quite slow naturally and instead rely on fragile optimisations to reach adequate performance. There is little point in having a highly abstract programming language if you need to have intricate knowledge of the compiler's optimiser to be able to write code that can be optimised well. Many languages like Java don't even allow you to write fast code because they don't provide methods to manipulate the layout of data in memory, something that is absolutely vital for good performance. &gt; I do belive that (to some extent), but is it worth the hassle of rewriting code that you already wrote / others already wrote? It isn't. If a project is not written in C, for the sake of all that is holy do not introduce another programming language into it. &gt; What about classes? They help a lot in OOP. I rarely feel the need for classes and if I do, I just implement vtables myself for the task at hand. Easy peasy and more transparent with respect to performance. &gt; But if not, then WHY? It's easier to program in a simple programming language because you don't have to think about all the complicated features of the language interacting with your code. Programming in C is very straightforward compared to other languages like C++ or Java. Though I do admit, it's less straightforward than programming in Go. So if you want a simple language with good base performance, you might also want to consider Go.
Then ypu aren't choosing C over C++, you are having tonuse C strictly for the environment. And that's okay. :)
I think C is so simple that “mastering” it is not difficult for the most part. It doesn’t take long to learn all the syntax after all since there aren’t that many concepts. I think with more experience then you get a mastery not of the language itself, but of how to design elegant programs.
&gt; C was essentially invented to be an extremely low-level programming language. That's laughably false. C was invented as a high-level programming language to write UNIX programs in. Specifically, it was meant as an easier alternative to writing programs in PDP-11 assembly. C is high-level because it frees you from such tedious obligations as hard-coding constants, laying out a stack frame, breaking down calculations into individual instructions, or memorising the offsets of elements in a compound datum (struct). C could do revolutionary things like calculating with 32 bit numbers on 16 bit architectures without the programmer going insane. That's a level of abstraction that made C truly high-level.
Embedded systems. There are many microcontrollers out there that don't have room for a C++ library. When your code has to fit into 4KB of data space and your total system memory is 512 bytes, that doesn't leave a lot of room for non-essentials.
&gt; "You never pay for features you don't use" goes out the window if you try to modify/re-use some one else's code. I call this effect “[ambient complexity](https://www.reddit.com/r/C_Programming/comments/7gd437/question_what_are_your_reasons_for_using_c/dqi6rii/).” This is the complexity features of a language introduce just by being there, even if you don't want to use them.
The “implicit declaration” error is because you define `split_list` (as a publically available function, no less) after you reference it from within `merge_sort`. You need to prototype the function before you reference it, whether that’s in the form of an `extern` declaration inside `merge_sort`, or a declaration out at the global scope (the latter being preferable). And when you define the function, you take fewer and different arguments than when you call the function in `merge_sort`; the call passes two `Node **`s (`A` and `B` are very bad names for normal variables, BTW), and the definition accepts one `Node *`. &gt; Also as a sidenote, do any of you know any simple mergesort algorithms? Mergesort *is* the algorithm, and if you’re comfortable with linked lists it’s one of the easier sorts to implement, as long as you make sure that non-power-of-two-sized input lists don’t break your code. (E.g., what happens if you run `split_list` on a list of 3 elements?) And the `*front = tmp` lines would, if you were actually taking the right arguments, write out the results of the split. However, this is kinda a silly way to do it. You have the front of the list from the list head, so really you only need the halfway point, which you can return as a normal `Node *`, or else use temporary `LinkedList`s in `merge_sort` that are filled in by `split_list`. So the prototype should look something like either static Node *split_list(Node *head); or static void split_list(const LinkedList *list, LinkedList *first, LinkedList *second); or even just static LinkedList split_list(LinkedList *list) since `LinkedList` is presumably only one or two pointers.
One thing that C++ enables you to do better than C is all of the "clean up" code. Need to release a mutex when the code goes out of scope? Need to close a file when it goes out of scope? Need to release the dynamic memory when it goes out of scope? Need to respond to an RPC when the function goes out of scope? All are nearly built-in in C++. Yes, of course you can do this in C -- nobody is debating if C is Turing Complete or not. The question is, "How much overhead does C++ handle for you?" &amp;#x200B; And yes, I likely should switch languages. And if I weren't an old dog, the new trick of Rust or Go might be better picks for me.
This might be difficult to implement on primitive implementations that implement `va_start` as a macro without special support in the compiler.
C is also simple and doesn't get in your way, which is very convenient when you know exactly what you want to do; no other language comes close. C++ is a monster of a language in comparison, I don't think it's possible for two languages to be more different in philosophy. Which of course is very confusing, since the syntax looks more or less the same. While it's theoretically possible to write even faster code in modern C++; it's a major pain in the ass to figure out which knobs to turn which way and the abstractions tend to get in your way at every turn.
C is used for embedded programming. If your software runs a toaster without an operating system, disk drives, monitor, and has limited memory C might be the best tool for the job. C is sometimes used for libraries because you can write really efficient code once and use your library with any programming language. Windows API is written in C for that reason. The C programming language is small which makes it easier to write a compiler for a new target platform. Other than those things and creating a couple programs to practice organizing your code the C way, I probably would choose another programming language.
&gt;For example, string in C++ is much more convenient Yes, it's so convenient that for \*decades\* every C++ framework or library reinvented their own specific version of C++ strings, and the joy of converting between them all in a single app is just so much fun. Great example.
Considering the error message yeah, it makes sense. Amazed that now it turns out operator precedence has exceptions. Ritchie was really right. 
I typically follow a bunch of strict design patterns to make resource management a ritualistic task. This way, errors can be spotted quickly because they deviate from the ritual. Of course, I am also the kind of person who says that design patterns are bug reports against your language and I do think that other languages have better answers for this. I particularly like the way Go solves this with the `defer` statement.
The problem with depending on a good compiler is that this makes the abstractions provided by the language rather leaky. There is nothing gained by having to follow weird unwritten rules so the optimiser can generate fast machine code out of your program. A good language yields a good base performance even with a mediocre compiler and admits excellent performance with a good compiler.
Seems like someone just started coding... C is 10x easier than C++.
Hmm... what do you suppose the authors of the C Standard meant when they wrote the following: "Although it strove to give programmers the opportunity to write truly portable programs, the C89 Committee did not want to force programmers into writing portably, to preclude the use of C as a “high-level assembler”: the ability to write machine specific code is one of the strengths of C."
On such systems, also consider using Forth. This has the advantage of providing you with an interactive environment to develop and debug your code in situ.
Reusable code in C++ is easy, and you can do basically everything you can in C, albeit with some exceptions (VLAs, casting away void*). But the major reason not to use C++ is exceptions. Everything is structured around a major mistake in the language, that it's often easier to build C++-lite abstractions in C than to avoid using exceptions in C++.
True but primitive implementations are typically stuck in C89 anyway and not implementing new language features. It looks like C2x is going to stop supporting non-2's-complement so I don't think it is seen as a design consideration that newer language standards should be implementable on all systems. The esoteric systems can keep using the old standard (or more commonly, provide a compiler with thousands of bugs that does something with vague resemblance to the old standard). 
It would really help if the two languages would properly diverge. The "C is just simple C++" really confuses people. And they're not the same 
i'd actually say the management of memory is a lot easier in C because it's really hard to know what all those fancy containers and pointers do. C++ is only easier if you don't want to manage because you have an abundance.
&gt;One thing that C++ enables you to do better than C is all of the "clean up" code. Need to release a mutex when the code goes out of scope? Need to close a file when it goes out of scope? Need to release the dynamic memory when it goes out of scope? Need to respond to an RPC when the function goes out of scope? All are nearly built-in in C++ I agree with this &gt;Yes, of course you can do this in C -- nobody is debating if C is Turing Complete or not. The question is, "How much overhead does C++ handle for you?" I agree with this but disagree with the implication &gt;And yes, I likely should switch languages. And if I weren't an old dog, the new trick of Rust or Go might be better picks for me. Rust feels... Weird to me. Go, Zig, Myrddin, and Odin seem alright. I've used Go quite a bit, and I generally like it, but there are some issues that drive me crazy. I still use it a lot. Zig seems *ok*, I played with it a little and I liked Go better. Myrddin doesn't seem to offer a lot of new things aside from the horrifying syntax. It seems ok as a language. Odin is too new to do much in except for playing around. It acts like it's trying to be 'Go done right', and seems to be doing alright so far. I'd like a language using implicit reference counting for GC (and am writing one) for cases that I want it.
Can I reverse the question? C is beautiful but why c++ ? The standard template library was the killer app for me
Operator precedence isn't even in the language formally; a precedence table is just a way of summarizing the language grammar. But I wouldn't describe this as a "precedence exception" ... even in the case of using a precedence table, you still have to determine whether it is the unary or binary operator before you can check the precedence. And that is determined by whether or not there is an expression before the `*`. 
I think C is incredibly easy to work with. Such a simple language. Outside of groking pointers you can pick it up real quick. It can be tedious because there are no built in ADTs like Strings, and Lists, and Sets, and Maps, etc.. So you find yourself writing your own abstractions but you start building your own ADTs and libraries yourself that are somewhat reusable. C++ is just enormous and overwhelming and complicated, and gross.
Forth looks interesting, though I haven't done more than glance at it. Is anyone using it for real world applications? What is the tool support like?
That's what people used C as, but that's not what it was meant to be when it was designed. C was developed as the successor of B for writing programs on UNIX. If you look at research UNIX source code (i.e. the UNIX written by the people who invented it), you see surprisingly little weird shit and a lot of straightforward simple business logic. That's what C was designed for. The UNIX kernel was ported to C only later on and due to the way the PDP-11 works, very little of it needed to be written in assembly. Performance was never a primary goal of the UNIX team, though they did pay attention to making all there operation have a good base performance, so writing all the tedious business logic in a high level language was a good idea. C was always platform specific. The key to portable code in C was to write platform-agnostic code, where you assume as little as possible about the size of data types so the differences between platforms would not matter. For example, instead of demanding a 16 bit `int`, you would mask all your integers to 16 bits in code where you needed that. The C committee wanted to support this style of programming through type definitions like `size_t` while also keeping the ability to write platform-specific code if the task at hand demanded it. The term “high-level assembler” is a retrospective view. Remember, C was developed in 1972. That's 17 years before the standard was released. A lot of things changed in the way people saw C and programming in general inbetween. Old C code from the old days is barely recognisable today.
Its all too deep for my brain and the Yacc grammar does not help. [https://www.lysator.liu.se/c/ANSI-C-grammar-y.html](https://www.lysator.liu.se/c/ANSI-C-grammar-y.html)
&gt; Is anyone using it for real world applications? It's popular in embedded development, though more of a niche nowadays. &gt; What is the tool support like? You basically pick a Forth for your embedded system (or write your own) and that's all the tooling you need or have. You then develop your Forth code interactively on the embedded system, saving it in a text file on your computer for reference. To upload Forth code onto the embedded system, you basically just paste the source code into the Forth console. Forth is really different from modern programming languages and takes a while to get used to as many aspects of it are a bit archaic. It is a lot fun and you never want to miss being able to interactively type commands into a console to debug and develop and embedded system without having to whip up complicated and expensive in-circuit emulators or JTAG-based debuggers. Forth is also very much "what you see is what you get." There is no magic going on, but you can program on whatever level of abstraction you like.
As an example, check out `pcc` which AFAIK does varargs with special macros.
A few things: C isn't faster than C++. Intrinsically, both are just as fast, since they are both bound to the similar optimizations (with the exception of the restrict keyword and compiler extensions). Idiomatic C++, however, can be very slow (iostream adaptors and exceptions, especially). In fact, for many benchmarks, C++ is faster than C: https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/knucleotide.html There is one major, however, why you should be careful using C++: exceptions suck, and they're baked into everything in the language. They lead to major binary bloat, they are "zero-cost", which means catching an exception leads loading the next instructions from a cold region of memory. But there's more: every statement you wish to undo in the try statement needs to be unwound via stack unwinding, which is even slower still. C++ is fast, until you deal with exceptions. And then everything goes to shit. Another reason is some very questionable design choices in the language. Inheritance and virtual interfaces leads to quite possibly the worst API in the C++ STL: the IOStreams. They're unnecessarily complicated, add a lot of unnecessary overhead, and extremely difficult to implement from scratch (I've done so numerous times, it should be way easier). Likewise, making an allocator a non-erased type in containers means you cannot use the best part of C++ (manual memory allocation) without forcing all code to be generic, leading to glacial compile times. C and C++ are great languages, but both have major detriments. Neither is an easy language, and anyone who tells you otherwise likely does not understand what they're talking about.
If one looks at the 1974 C Reference Manual, the behavior of something like `p-&gt;q` was defined in terms of the offset of `q`, and was agnostic to whether `p` identified an an actual structure of the appropriate type at the appropriate location, or the location of a region of memory which might be usefully treated as a structure of `p`'s type even though it didn't actually hold one. The 1974 C Reference Manual also demonstrated how one could implement variadic functions like printf even though the compiler made no effort to accommodate such things. Such functions would need to be adjusted to fit different target platforms, but it sure looks to me like the ability to use C to do things that would typically require assembly language seems to have been part of Ritchie's intention in 1974, if not earlier. 
Nothing prevents your IDE from displaying them as glyphs though :)
No, none of this code is C++. Please figure out how to compile it as C, or I'm out.
* 250Hz * What do you mean by resolution? * 81251 Yes it has to be lossless. Thanks for your help :D
&gt; C is harder to work with. String handling alone makes that abundantly clear. Handling memory management is significantly trickier in C than C++. Understanding how templates works and the pages of errors they produce when you do something wrong is easy instead?
The only good thing about C's string design is that functions which expect to receive a string as *input* can all handle it the same way without having be passed the base pointer and length separately. If, however, C had included a build-in type that behaved essentially as a struct containing a data pointer and length, and had provided a way of initializing a constant structure of such a type, that would have been more convenient, efficient, and safer than zero-terminated strings in the vast majority of usage scenarios.
I am Lead C++ Developer and would pick C++ over C anytime, yet not for any of the reasons you stated because they are not really reasons to pick one over another. Strings in C++ are very limited and not much better than libc does it. The only advantage of C++ strings is you don't have to care about allocation — but that is double-edged sword, see below. For proper use of strings in applications, you still need libraries like ICU or gettext and those work pretty much the same in C as in C++. You don't need to type more lines in C than in C++. The structure is different because of exceptions but you still need to write error handling somewhere. This is a common misconception of novice C++ programmers because they don't realize that most of the time you spend on a project is handling errors, especially those least probable. C++ allows you to hide this by ignoring the problem but that does not make good apps. This is also true for allocations. While C++ handles allocations nicely, it also hides it from the programmer so novice programmers often get the idea that they don't have to care. Yet C++ is still pretty low-level, there is no garbage collector (actually, you can have GC in C++ but you can have it in C as well) and when it leaks or crashes because of `std::string_view` on a string that was destroyed, it's pain in the ass to find out why. This makes C programs much easier to debug and fix, everything is just pointers that someone has to explicitely take care of so you always have to think about who owns what. You don't rewrite what others have written, there are libraries for C++ as well as for C. Just as I have written above, even strings in C++ are very basic and you still need to use third-party libraries for proper apps and these libraries are for C and C++ alike. There are also libraries that allows you to use classes in C, such as GLib. It is actually quite common to write OOP in C nowadays, even Linux kernel is mostly OOP. C++ provides some sugar for that but it is not anything why someone should choose it over C. Moreover, C++ is not full-featured OOP, it lacks many OOP traits like dynamic classes, metaclasses or reflection. If you want real OOP, go for Python instead, C++ can't compete in that regard. And now for why I would choose C++ anytime: templates and lambdas. Some compilers have extensions that allow lambdas in C but templates can't be replaced in any straightforward way. However, templates are very high-level and it takes years to master them so it's not really anything most programmers should base their choice of programming language on. As a matter of fact, I think C++ is much worse language to start with than C, C++ is very forgiving but when it hits you, it hits very hard.
I regard the recursive and non-recursive merge sort as separate algorithms, and have something of a soft spot for the latter since it's able to alphabetize a list of 6,000 names stored in flash memory on a microcontroller with under 4K of RAM. When doing a merge sort, there should be no need to split a list after the initial pass. Instead, write sub-lists to alternating output files if a stable sort is required, or else start writing them to one output file until, at the end of a sub-list, one has written at least half of the total records.
I like to use [non-canonical mode](https://www.gnu.org/software/libc/manual/html_node/Noncanon-Example.html) to do this. Since you completely control input, you can ignore all input except the characters that you want.
&gt;a struct containing a data pointer and length What type should the length have been in 1973? &amp;#x200B;
It's not easy, but it's at least a compile time problem that clang can help fix. As opposed to a runtime dangling pointer that causes a severe ssl bug. 
An `int`, typically. On most platforms, a struct containing a pointer and an `int` will cost the same as one containing a pointer and any smaller type, and while code may sometimes need to access sequences of bytes whose length exceeds INT_MAX, such usage cases are better handled by using specialized code to handle them (which can pass pointers and length separately using some other data type, or use a custom structure) than by degrading the performance of general-purpose string handling code. Just about the only problematic case I can see would be the 68000, where `int` may sometimes be 16 bit and sometimes 32. Interop between systems with 16-bit and 32-bit `int` could be facilitated by allowing 16-bit systems to either store the length as a 32-bit `long` or precede it by two bytes of zero-filled padding.
There are a few options that I can think of: 1. use a game framework that comes with a event loop such as [libsdl](https://www.libsdl.org/) or [allegro](https://liballeg.org/) 2. use a event loop library such as [libuv](https://libuv.org/) or [libevent](https://libevent.org/) 3. roll your own as is outlined in [this article](https://www.gamedev.net/forums/topic/646358-event-handlers-in-c/) or [this article](http://gameprogrammingpatterns.com/event-queue.html) Some other options: 1. You might be able to use the [GLib event loop](https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html) 2. It might also be possible to do events using interrupts ([pong using interrupts](http://www.cs.kent.edu/~ruttan/sysprog/lectures/curses.pdf)) 3. pthreads.
[https://www.coursera.org/learn/algorithms-part1/lecture/ARWDq/mergesort](https://www.coursera.org/learn/algorithms-part1/lecture/ARWDq/mergesort)
Completely the opposite. The entire point of those fancy containers and pointers is so that you don't have to even think about memory management at all.
&gt;An int, typically. So, an extra 3-bytes per string for 16-bit ints and pointers. A bit of a high price in 1973, for a system with max 56KiB RAM. &amp;#x200B; &gt;16-bit systems to either store the length as a 32-bit long or precede it by two bytes of zero-filled padding. More wasted space and endianness issues (since you mentioned interop). &amp;#x200B; Yes, in the modern age, languages should prefer (length, data) or (pointer, length, capacity) representations. They have demonstrated their value in a world where RAM is much less scarce. Which is why the utter bungling of C++ strings a decade after C was released was so unfortunate.
&gt; What do you mean by resolution? How many significant digits does each sample have? E.g. are these 16-bit signed integers, or doubles, or something inbetween.
My point was not that you couldn't do this sort of stuff in C, but rather that it wasn't the main point of what C was designed for.
The structure would basically a shorthand for handling the length and pointer together, for code that needed to pass such things around. If one wanted, one could improve code-space efficiency by having functions accept a pointer to one of two types of structure: struct direct_readable_string { int length; char dat[ whatever length is needed ]; }; struct indirect_readable_string { int length; char *dat; }; Use positive length values for one, and negative values for the other, and have functions that write to strings expect that the passed pointer will be an `indirect_readable_string` within a structure that indicates how much space is available, and how resizing should be handled, thus making it practical for something like `sprintf` to either validate the length of a passed-in buffer or dynamically create one of proper size. On the other hand, the amount of code to create and pass such a structure for a string literal need not be any worse than the cost of code to pass a zero-terminated string. Pushing the address of a zero-terminated string N bytes in length would require six bytes of code, plus N bytes for the text, and one for the trailing zero, so seven bytes of overhead. Depending upon whether a string's length is even or odd, and more or less than 256 bytes, overhead to pass both address and length would be 5-7 bytes: call getShortOddString ; Four bytes db 5,"Hello" ; N+1 bytes call getLongEvenOrShortOddString ; Four bytes dw 6 ; Two bytes db "Hello" ; N bytes call getLongOddString ; Four bytes dw 501 ; Two bytes db "501-character string literal " ... ; N bytes db 0 ; Or any value For strings that aren't literals, code will typically have to store the length separately from the string content via some means, so string literals are really the only situation where zero-prefixed strings help, and I don't think they really help much even there. 
Yeah, basically, if you're working on device drivers or embedded systems, a lot of architectural choices are made for you.
Sometimes, that's detrimental. Especially with, say, games that have a ton of stuff going on. There comes a point where merely throwing GHz at the problem doesn't cut it.
Nothing forces you to use the smart pointers and containers. In those rate cases when you need to, manual memory management is still an option.
I don't practically, but C is a better programming language to learn programming than C++, I realized. There seem to be several different ways to write C++ code and hard to learn the most modern C++. Too many syntactic sugars and it is hard to keep track of which ones are sugars and which ones are original. C is really simple. The core C doesn't have much to learn at all. 
Personally I think it comes down to what you are doing and what you prefer. Also compilers got quite good optimizing code if you know its pitfalls and/or know how to analyze them. But I think it's quite funny you name std::string as an advantage over C. I't s more or less a vector&lt;char&gt; and its STL functions break as soon you leave the ASCII realm, what is ridiculous that there is no standard utf8/16 handling for C++ considering what sometimes proposed to go into the standard lib. C is nice for it's relative simplicity compared to C++ but if you bolt down what features to use so not everyone writes in a different dialect (what I incredible annoying especially during C++98 to 11 switch) it can give you some syntactic sugar that _can_ make it easier to reason about larger quantity of code. If you look at recent cppcon talks and papers people finally seem to realize OOP is not a silver bullet and finally start to look at the machine they are supposed to program against again.
When engineers need to make hardware do things, their go-to is going to be C, because its minimal and it fits right onto the hardware instructions and they can keep everything tight and fast. Then some time passes and the code gets bloated and stupid and some of the senior devs break off into a special taskforce to clean up the codebase, and they do this by rewriting in C++.
C++ strings have the small string allocation optimization, which can be a significant advantage over C-style strings.
&gt;Understanding how templates works and the pages of errors they produce when you do something wrong is easy instead? Knowledge of templates is not required to make effective use of `std::shared_ptr` and its related types, which are great sane defaults for owning memory. C++ features like `std::string` are easy choices for most cases -- every C programmer creates a string container early on in their project, but how many of those implement small string optimization to squeeze 16-22 "free" bytes of out their metadata struct? This is one of those situations where the standard library is giving typical C++ projects a significant boost to performance and safety for almost no cost.
I use C in preference to C++. I prefer the DIY style of things. I have never found the lack of OOP in C to be a hindrance. If I wanted it I could implement it, but I don't. I just find in C I can get things done faster than in C++. Also reading C code feels easier than C++ due to the lack of fancy language features like templating, operator overloading, objects, funtion overloading, etc. 
Never seen a bootloader written in Go, C# or Java. Never seen direct IO port manipulation written in Go and the Java code I've seen that does it drops back into C.
&gt; it's really hard to know what all those fancy containers and pointers do. I can't relate to this -- while I'd certainly struggle to explain it to someone used to a GC'd language, that's because *pointers are hard*. But to someone's who's already proficient in C, who's used to manually managing object lifetime and ownership, the purpose and applicability of C++ 11 smart pointers is intuitive and requires little transition time. The part that might need some adjustment is references, because they're a special case of pointer, and their usefulness it not immediately obvious. However my view is that once learned, their use can only *reduce* the mental overhead on the programmer.
I initially had the same apprehension, but it's not that bad. If you "new" an object, you are responsible for "delete"ing that object. New is equivalent to malloc, and delete is equivalent to free. There's C pointers, as usual, but there's a couple new pointer types that make things a bit more convenient. In C, there isn't an easy way to do reference counting without explicitly decrementing the reference count as each variable falls out of scope (to my knowledge). C++ has additional pointer types that interact with reference counting in different ways (called smart pointers): unique_ptr, shared_ptr, weak_ptr. These handle reference counting automatically. Another advantage of C++ memory management is the RAII (resource acquisition is initialization) paradigm. In C, you'd need two statements to initialize an object with a pointer type (malloc, then some init function). In C++, you do this in one step, which makes it difficult, if not impossible, to end up with an object that's in an invalid state. I dislike C++ for a variety of reasons, chief among them being how complicated it is, but I think it generally does a good job at memory management.
I don't understand why C++ would get in the way -- it only becomes a problem on large object construction, which is easily avoided while still maintaining sane memory management. Or is there some other zero-copy structure you're worried about?
You might as well say why eat an avocado rather than an apple. They are both fruit, they both start with A, yet they are clearly different and suitable for different things. When I want a program to do lots of string manipulation, I use Perl. When I want a program to run on a web browser, I use Javascript. When I want a program to do low level code, I use C. If I ever wanted a program to do strict OOP I might use C++, or Java, or Eiffel, or Smalltalk. However I'm generally not much of a fan.
OOP is not bad. You are ignorant for even saying that
It's great for game development and some other places, but it's *really* over-applied. Considering I've spent years with it before coming to this conclusion, I disagree that I'm 'ignorant for even saying that'.
if it can not be done in FORTRAN then it isn't worth doing !
Multiple inheritance, templates, exceptions... all the virtual calls, and near-constant cache misses, wasting tons of CPU time. It all adds up to pain, when blindly used. Enough old game engine still in use have plenty of technical debt from the eras these inefficient techniques were the big thing. Bethesda's nasty, hot garbage of an engine is the very best example of how bad it can be. C++ is okay, but OOP is a problem for creating massive, optimally-performing game worlds with a ton of concurrent things being processed all the time.
I rarely write C code. I usually write C++ because it has IO streams (which are superior to printf and scanf) and classes. C++ is superior to C for most things. Also the string in C++ are better. I like C, but C++ is better for large projects (and most projects) in general. 
It is meant to be the Luhn algorithm, but I'm making it as instructed by cs50 (The way I described it is what I asked for.) I looked up Luhn's algorithm now, and you are 100% correct in that this is not the same, but I was just following instructions. Thank you very much for spending the time to evaluate my code, I'll make sure to put into practice all of those tips you've given me. I do also appreciate the kind words, and I'm happy to hear you think it's somewhat efficient. I actually spent quite a bit of time trying to make calculateValid efficient, and had a lot of fun doing so. I'll make sure to put all of your advice into practice to make it not go to waste. 
&gt; you don't have to even think about memory management at all In what context? Maybe in a situation where you have more than 1kB of RAM, that's okay. In a lot of situations where C is applicable, though, one simply does not have the luxury of not counting every single byte.
yes, you might know that but try to enforce that on a project. It sounds a lot easier than it is to take language features away from a team. And at some point somebody will use vectors in a way that doesn't allow move causing a huge overhead. Just like in C somebody will at some point do something horrible with a pointer. I think there are good reasons to use both language and i actually prefer C++ in most cases, but i think the simplicity of C makes it just a bit easier to spot the problems abstraction tries to hide. 
Thats exactly my experience. I've seen projects where i found the part of the code that limits my performance or causes problems in general and after wards i had to sift through a dozens templates and classes it inherited from. In those C++ project you really need a great IDE that let's you find all those places fast. I've sworn to myself if i ever start a big C++ project the first thing i'll heavily restrict is templates, inheritance and that new auto keyword. Not that i don't like those things i actually miss them sometimes in C but they can lead you down a very dark path. 
i remember back when i learned C it really took me a while to understand pointers but after a while you really get used to them. And i think at the beginning of C++ you had to use them a lot more too not sure when all the containers and smart pointers got added. Maybe they've always been there and i just ignored them for a while. And for most projects on my powerful PCs i use smart pointers and vectors everywhere i can. I try to make sure that my objects can be moved, i try to allocate vectors with resize. But at some point i might do something small that i didn't think about that prevents a move or a push_back that forces a reallocation. I love C++ and i feel i have a good grasp of all those concepts, but it's hard to stay on top of it all i am not looking forward to C++20 when i get a new bunch of stuff to learn that brings more abstraction and hide possible traps and costs (concepts seem to be another thing that dose this, but we'll see). Now let's look at work where i'd go crazy trying to check what all my coworkers do because they will make that problem worse. Many people just use those things without thinking too much and even though C++ is "you don't pay for what you don't use" it's also a "we don't tell you how much", "you didn't know it's expensive? pay anyway!" and "we hide the expensive things from you!". It is a pain to make sure nobody touches those things. But yes it is possible to be just as good in C++ you just need programmers that have a lot more knowledge about a lot more.
I wish I could figure out what you are trying to do here .. but I can't. Looks like a function that returns what? Nothing. You iterate over the digits from least to largest and multiply by a power of ten for that decimal? digit. This is a mess. Perhaps try using datatypes like uint64_t and not those "long long" things. Also ... why? There are libs that do this much more easily.
C isn't easy-to-master. There's entire books filled with obscure cases of weird bugs in compiler implementations on specific hardware leading to weeks of debugging, security advisory warnings for seemingly idiomatic code that turns out to have behavior wildly different than expected. C is simple to superficially understand, and a reasonably smart person can get a reasonable level of proficiency in the language in a short period of time. But, being proficient in C and mastering C is like the difference between a someone plugging a street address into a GPS navigation system and taxi driver that knows every side street and the fastest way to get to upper 3rd street in Brooklyn from downtown Manhattan when major streets are closed for construction.
One could, it seems. Seeking to end of file - 1 and back should fail "on terminals". Not sensible, of course.
Why would you need events for this? Just write a function that handles the interaction between the player and an NPC. Call that function in your game loop when the right conditions are met.
Welp, I'm stealing that.
F77 or GTFO
The biggest thing is that C++ is staggeringly complicated, and it will screw you when least expected. Also, due to some nice things that the compiler can do, there's actually no guarantee that C is faster than C++. C will generally produce smaller binaries though. Also, if you know how C++ does OO, for the times when it's actually useful it's not hard to emulate. The real thing you miss though is not OO, it's RAII.
C is amazing.
You're asking a group of people who have already decided that C++ is bad and C is good. You're not going to get good responses. &gt; I rarely feel the need for classes and if I do, I just implement vtables myself for the task at hand. Easy peasy and more transparent with respect to performance. From the top response. This is EXACTLY the type of garbage I expected to read as a response to this post.
No offense whatsoever intended, but your post is rife with strong opinions that have little or no factual basis, which leads me to believe they have been formed from a place of inexperience. That's totally okay. We all have to start somewhere. If you don't want to use C, I'd be the last person to try to convert you. I see lots of people in this thread thoughtfully suggesting how you might use a combination of language features and libraries to make C do your bidding, but in the end, maybe it's just not for you. Totally okay. We're lucky to live in a time when there are lots and lots of great ways to get our computers to do stuff. What I've always found interesting about all the languages that have come along with the stated or implied intention of supplanting C (C++, D, Java, Go, Rust) is that no matter what level of success they achieve, _C is still here_.
&gt; not using the string manipulation functions in the libc effectively. There are no string manipulation functions in libc, only byte chunks ended with zeros manipulation functions. You need a library for strings. There are no lists and other useful most basic data structures as well. &gt;It's easier to program in a simple programming language because you don't have to think about all the complicated features of the language interacting with your code. And then your memory leaks again due to lack of RAII/GC. I've seen so much C-coder pretending that they tamed the memory management, yet I've never seen any sufficiently big and complex C codebase which has no problems with resource management (safe some simple embedded C with no dynamic allocation). In any sufficiently complex codebase where one resource could be owned by several owners at the time problems are unavoidable in C, and that's even without threads.
Did ya read the one where Torvalds shots on the guy who suggests rewriting Linux in C++? Lol
why you make it so complicated
I prefer C because of its simplicity. It's just an interface to memory, with operators and few tools like loops and conditionals. Dead simple. In my opinion, C++ is bloated. For example, why do we need more than one way to do a type cast? In C it is simple, because it is a simple operation - we just tell the compiler how it should interpret a bunch of bytes. Classes are nice, but not required for OOP. When I want to use struct methods, I'll switch to Go, which for me is a "simplified C for new generation". I do miss namespaces in C, though. 
&gt;Are the sizes of blocks of memory stored somewhere? When you call malloc() does it remember the size you gave it somewhere for later use? Yes.
Malloc maintains its own map of allocated memory. It knows nothing about the type of data contained in memory block being allocated or freed. Functions like `malloc()` and `free()` return and receive a void pointer. 
Food for thought: free accepts any type of pointer, and there is no function overloading in C, therefore free must be declared as `void free(void*)`, and all pointers you pass to it are implicitly cast to `void*` anyway.
I completely agree on the templates and lambdas part. On a side note, the only thing I wish for C is to standardize compile-time function evaluation and AST-level code manipulation. This way everything will be possible in terms of metaprogramming and we will only be burdened with design choices (hopefully).
This is one of the reasons that poor memory management in C can lead to disaster. If you write over mallocs memory keeping then your whole program is likely toast. Always run your program with valgrind to to be sure! 
16 bits that I will normalized/quantized between \[-1,1\[
&gt; There are no string manipulation functions in libc, only byte chunks ended with zero and byte chunks + their lengths manipulation functions. You need a library for strings. There are no lists and other useful most basic data structures as well. Those byte chunks are strings. I'm not sure what point you try to make.
&gt; every C programmer creates a string container early on in their project Citation needed. 
Bad programmers can write Fortran in every language.
&gt;how does it know how much memory it needs to de-allocate? it depends on the implementation. some store the metadata (or reference/index to it) before the pointer. so when you allocate say 16 bytes, system has to allocate sizeof metadata + 16. that is what I believe. never tested it though.
Why would the type of pointer, which is a fixed size, tell you how many elements to free?
Windows :( But why would you ever write over the memory keeping, which is out of bounds anyways.
For an array of size N, simply pick a random integer in \[0, N) an use it as your index. You will need to do this N times. 
It allocates at least 16, so the actual amount may be more, but this is unreliable and accessing out of bounds is always erroneous eventually.
 int a[2] = {1,2}; for(int i = 0; i &lt; 5; i++){ printf("%d", a[rand()%2]); } if you give more context as to what you're trying to do and why, I'd be able to provide you with a more useful answer. To get a random index, use `rand()%array_size`.
if what i think you mean is that you want to store in an array random values between [1, 2] ... srand((unsigned int)time(NULL)); for (int i = 0; i &lt; 40; i++) { /* return random number between [M, N] M + rand() / (RAND_MAX / (N - M + 1) + 1) */ s1[i] = 1 + rand() / (RAND_MAX / (2 - 1 + 1) + 1); ...
I made an assumption. I thought was "this is a pointer, it points to an int that I know is 4 bytes big, so when I say free the memory this pointer is pointing to you should know that the block is 4 bytes big", but I know now this is wrong because as /u/Kwantuum pointed out the arguments are implicitly parsed to void type.
And if you think about it, an int* doesn't necessarily point to *one* int, it usually point to many contiguous ints (an array) at which point the size of the stored type is only helpful if you you also have the number of elements in the array, but pointers don't have that information, so the OS has to keep track of how much memory was allocated either way.
How would I track the right conditions and which event to load for which NPC? I mean, I got a skeleton of a function already implemented. But without classes, in pure C, what would you do? &amp;#x200B; I'm doing this to build a master's portfolio without a bachelor's in Comp Sci. The only library I'm using is for rendering and I want to learn how to build this stuff myself to get into the program.
OOP is a concept that's really over-applied and even by some considered legacy. New programming languages aren't OOP often even. Sure, string handling is suboptimal in C, but it's not great in C++ either as soon as you diverge from the sacred path of Unicode. But most of the time I don't need it. Most of my problems can be better handled using other design paradigms than OOP.
&gt;here are no string manipulation functions in libc... You need a library for strings. The clue is very much in the first three letters of "libc".
How do you concatenate strings in C? Well, you make an area of memory big enough for both of the strings and then copy the bytes from one string to the appropriate location in the new memory area... &amp;#x200B; How do you break strings into tokens? Easy, you overwrite the memory location of the token item with a nul character, and then keep track of where you need to start the next point in memory for the next string lookup. &amp;#x200B; How do you duplicate a string? Easy -- you call strdup which returns a new pointer to memory that you will need to free later. &amp;#x200B; How do you copy a string? Oh, is this a string you trust? Because, if it doesn't have a terminating nul character you had better use strncpy, instead of strcpy. Oh, and make sure you are giving a pointer to a big enough memory area. &amp;#x200B; That's why it's appropriate to consider C and not really manipulating strings, but rather just a simple malloc wrapper with a single convention. &amp;#x200B;
Similar things to valgrind can be achieved in windows (visual studio) [https://docs.microsoft.com/en-us/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2017](https://docs.microsoft.com/en-us/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2017) Some malloc implementations keep the bookkeeping data right next to the allocated memory. If you write over the edge of your array, you can overwrite the bookkeeping data. 
Including the memory management stuff I am beginning to better understand the workings of pointers and arrays. Browsing the [standard library documentation](https://www.gnu.org/software/libc/manual/) I can see many places a pointer is passed a "number of elements" value is also passed, and when operating on arrays it is almost always done via side effects because returning an array would be difficult as the caller can not know how many elements there are, with the exception of strings that have a terminator. &amp;#x200B; Thanks for your help.
&gt; Those byte chunks are strings. First of all there are strings in the narrow sense (aka encoded valid strings of some natural languages, probably UTF8 strings) and in the wide formal sense (sequences of some alphabet symbols, asciiz in case of C). There are two problems with ASCIIZ: 1) it's pretty useless since it can encode only a tiny subset of natural languages and 2) it is inefficient due to linear complexity in case of dynamic strings. Consider you use some other encoding but ASCIIZ. 0 is a valid byte in your encoding? Your strings are broken. And nobody prohibits you from doing `srtncpy(s1, s2, bad_len);`. So you have to wrap C arrays in a struct with len and write your own facilities. Or use a library.
But visual studio sucks. If you write out of the bounds of an array, it's already a more general issue than losing bookkeeping info. It's bad code.
All byte-oriented character encodings are designed such that NUL bytes do not appear. C strings do not specify a character encoding and C strings are not ASCIZ. That's just one possible implementation. In fact, all of POSIX has been constructed around text files not containing NUL bytes in any encoding. This design choice is fine.
&gt; All byte-oriented character encodings are designed such that NUL bytes do not appear. UTF8 could contain zero bytes.
UTF-8 contains zero bytes in the same sense that ASCII contains zero bytes and that is that it does not. The NUL byte does not occur in UTF-8 encoded text. It does not encode a character. 
&gt; UTF-8 contains zero bytes in the same sense that ASCII contains zero bytes and that is that it does not. The NUL byte does not occur in UTF-8 encoded text. It does not encode a character. It is a valid unicode point, which could occur within a string.
It does not occur in meaningful ways and it can always be removed from text files without harm. Indeed, POSIX specifies that text files must not contain NUL characters. No meaningful text processing functionality is lost by refusing NUL characters.
&gt; But visual studio sucks. Each to their own. IMHO, Visual Studio is hands down one of the best IDEs I've ever worked with. If you're developing on windows and not using VS, you're making your life unnecessarily hard for your self. &gt;It's bad code. Good programmers write bad code all the time. It's a fact of life. The more important issue is finding and fixing these errors. The reason I bring this up is that you these sorts of errors can be very subtle. A variable 'here' breaks, but the reason for it breaking is an out of bounds array access 'there'. 
Deciding to work on Windows is making life unnecessarily hard on yourself. Not which IDE to use.
LOL. Sometimes Windows chooses you...
That *is* how it works in Pascal (ignoring vendor extensions), so I can understand the confusion. In Pascal, the size is part of the type, so it's always known at compile time exactly how much memory is being freed. However, this only works because Pascal doesn't support arbitrarily-sized allocations, which is [incredibly limiting](http://www.lysator.liu.se/c/bwk-on-pascal.html). 
&gt;in meaningful ways and it can always be removed from text files without harm I'm amused that you would like remove valid utf8 symbols from textfiles for the sake of your posix religion, but we are talking about C and strings, not about posix and removing characters you consider unnecessary.
Since the dawn of computing, NUL bytes were removed from text. NUL bytes originated in unpunched spots in punched tapes, resulting in nothing happening. NUL bytes do not belong in text files and do not have a meaning if present. If your file contains NUL bytes, it is not a text file! There is no rational expectation that text files containing NUL bytes can be processed in any reasonable way.
&gt; This is one writeup which explains the difficulties originally faced (nowadays fixed but illustrative of subtle differences complicating the implementation): https://web.archive.org/web/20170225035151/https://www.cse.wustl.edu/~schmidt/win32-cv-1.html So in other words, the hooks weren't so insane as that jumping through them is impossible.
TBF window is getting much much better. Also I find VS's build system to be less of a hassle than MAKE / CMake
Note that rand() is generally really insecure; don't rely on it for anything which requires randomness for anything cryptographic or where people being able to predict the outcome is problematic. Also, note that rand() will produce the same sequence of results every time the program is executed, unless you seed it with `srand(seed)`. You can do `srand(time());` at the start of the program to make it produce a different sequence every time the program is executed, but again, that is not appropriate for anything where it's important that people can't predict your random numbers. For better random numbers, this would work (though it's slower and Linux-only): int betterrand() { FILE *f = fopen("/dev/urandom"); int num; if (fread(&amp;num, sizeof(num), 1, f) &lt; 0) { perror("/dev/urandom"); abort(); } fclose(f); return num; } Alternatively, you could use OpenSSL's good random functions: https://wiki.openssl.org/index.php/Random_Numbers If you need something simpler and cross platform, that's better than `rand()`, but not necessarily cryptographically secure, there are simple implementations of the Mersenne Twister algorithm like this one: https://github.com/ESultanik/mtwister
Thanks man I appreciate it. I am fully realizing this and spent a big portion of yesterday just going through videos and practicing haha.
Thanks for going into detail, I'm going to look into these problems and try again today
1. Don't use `strcpy()` to change a single character. C-string is an array of char types, so `string[index] = '0'` will change a character at `index` to `0`. 2. Iterate over a c-string until you reach a nulbyte, which is a terminator: `string[index] == '\0'` 3. Either peek back or store last read character in a temporary variable and compare it with current.
&gt; What did I do wrong? What happens if `i` and `j` are equal?
So do you mean field1\[j+1\] = zero (zero \[\] = '0')? That wouldn't work, would it?
Why does clang-format exist if it makes things worse?
OK, take a look at this: ``` #include &lt;stdio.h&gt; static void zero_dup(char *string) { for ( int i = 0; string[i] != '\0'; i++ ) if ( i &gt; 0 &amp;&amp; string[i -1] == string[i] ) string[i] = '0'; } int main(void) { char string[] = "aabbccddee"; zero_dup(string); printf("%s\n", string); return 0; } /* vim: set ft=c sw=4 sts=4 et: */ ```
Does it matter? I gave you very specific instructions and you decided to ignore them and go your own way. Last chance: if you want my help, which I'm giving you *for free*, you will follow my instructions.
[removed]
Windows 10 with the built-in Linux system activated is by far the best Windows experience I had since Windows 3.0. Not bad at all really.
&gt; I mean, C is hard to work with. Depends on your perspective. If you want to do X in a quick and dirty way, C might not be the first choice. But if you want to do something **right**, C is a great choice. I'd improve your argument with Brian Kernighan's perspective on software tools. Don't use a punch to nail something in when you can use a hammer. &gt; You low level everything. "low/high"-level lost their meanings a long time ago. &gt; For example, string in C++ is much more convenient in C++, yet in C you type a lot of lines just to do the same task. Correct, the standard library (ANSI at least) can be weak at times. I think Plan 9 fixes that, and you should check that out, it's one of the best C resources out there. (see https://old.reddit.com/r/C_Programming/comments/4g4cte/the_plan_9_c_compilers/) One nice aspect of C is that the compiler makes it easy to have your code available on multiple platforms, and that the language is a sitting duck. &gt; Some people may say "it's faster". I do belive that (to some extent), but is it worth the hassle of rewriting code that you already wrote / others already wrote? What about classes? They help a lot in OOP. "Faster" is a bad argument. See Rob Pike's thoughts about programming: http://users.ece.utexas.edu/~adnan/pike.html &gt; I understand that some C people write drivers, and back compatibility for some programs/devices. But if not, then WHY? I like the syntax.
How well does the linux subsystem integrate with VS?
C was designed to let the programmer do such things on the occasions when they were needed, so as to avoid the need for the compiler to handle them. While *most* of the code in a typical C application will be doing straightforward things that could be done in almost any language, the same would be true of most assembly-language applications as well. I think C was quite deliberately designed to be capable of doing things that would otherwise need to be done in assembly language, for those relatively rare times when such abilities were needed *but essential*.
On a side note, we made a local modification to cron to be able to handle '?' as a specifier -- saying, "I don't care which time, but just one time". To do this, I hashed the crontab file and used that as the seed to pick whatever time was needed in the range. Very useful on a distributed system where everyone either picked 0,1 or the totally random value of '42'. 
How do you normally implement your vtables? Any good sources for learning more on that kind of thing? I've never tried that and it sounds fun.
Nothing happens?
A vtable is just a structure of function pointers. For example, suppose you want to build an interface for storing data. The corresponding vtable could look just like this: struct iofunc { ssize_t (*read)(void *handle, void *buf, size_t nbytes); ssize_t (*write)(void *handle, void *buf, size_t nbytes); int (*close)(void *handle); } You use these like this: struct iofunc *iofuncs; iofuncs-&gt;read(handle, buf, lan); iofuncs-&gt;close(handle); Very simple. In languages with class-based inheritance, each object typically has a pointer to a vtable for its virtual methods as a hidden first argument. This implements dynamic dispatch in a very straightforward manner while only consuming an extra pointer per object.
&gt; there is no function overloading in C True, but there could still be several type-specific `free()`s thanks to type-generic macros introduced in C11. IE: #define free(X) _Generic((X), double*: freed, int*: freei, char*: frees: default: free)(X) However, something like this would be quite impractical for determining the size of memory regions since the types must be resolved at compile time or else it will fall back to the default. Also because `malloc()` allows you to allocate arbitrary amounts of memory, not just the size of actual data types. Type-generic macros do have some real applications though, for example, a cube root macro: #define cbrt(X) _Generic((X), long double: cbrtl, default: cbrt, float: cbrtf)(X)
That should be evangelized!
Sorry, I meant if `i` is equal to `j + 1`, which is bound to happen if `temp` is greater than 1.
linking an SO answer, which particularly answers this , hope it helps https://stackoverflow.com/questions/1518711/how-does-free-know-how-much-to-free
I set temp equals to i though
Just like in ASCII, 0 is a control character: https://unicode-table.com/en/0000/ Control characters are never displayed in text, unless for debug reasons. What are you on about? It's literally like saying 0 is valid character in ASCII. 
Not in the code you've shown us.
Pointers are all the same... Just syntactic sugar to aid you in pointer arithmetic. Everything is just bytes dude. ints, chars, Jesus, they are all bytes and you give them the meaning you want to so I can not understand how does having a char \* instead of a void \* will tell you how much memory to deallocate. Malloc keeps data on memory blocks that were assigned. 
Ohh get it. Sorry. I was quite in a hurry when I pasted the code
There's work to make C++ exceptions not suck, if that helps. And there's an awesome replacement for the string-formatting part of iostream.
Here's an interesting trick that demonstrates the type does not speak anything of the size of the allocation; You may have a struct declared like this: ``` struct header { uint16_t type; uint32_t size; char data[0]; } ``` Then you have an allocation for some buffer AT LEAST the size of the struct... ``` void *buffer = malloc(some_size); ``` And then you cast to your header struct: ``` header *hdr = (header*)buffer; ``` Question: How big is the header::data array? You would think by looking at the declaration that you have an array of size 0, and the rest of the buffer is lord knows what, but in truth, the front of the buffer is your type and size, and then everything from byte 6 onward are elements of your data array; you can index ```hdr.data``` anywhere between 0 and ```some_size - sizeof(type) - sizeof(size) - 1```, because the compiler only sees a memory address (not technically true, but I can never keep straight the nuance how C treats arrays), and C allows for pointer arithmetic. This way, you don't have to convert the buffer to char *, offset past some number of bytes, cast that... I might not have gotten the code exactly right, but I was doing a lot more networking code back in the day and this was an idiom that came up frequently.
&gt; If you look at recent cppcon talks and papers people finally seem to realize OOP is not a silver bullet and finally start to look at the machine they are supposed to program against again. C++ has always been a multi-paradigm programming language. You can do object-oriented, functional, imperative, or whatever. (Meaning, support is baked into the syntax of the language, you don't have to emulate it like you do in C.) The problem is that the whole programming industry went through an "OOP or bust" phase, where that was the focus of everything Language design, university instruction, research, etc. So of course that's what they focused on with C++. I don't think that's changed much: the industry is still pushing OOP as "the way" to program, but C++ is ahead of the curve on pulling back on that and showing the problems with that approach.
&gt; What are you on about? It's literally like saying 0 is valid character in ASCII. Zero is a valid symbol in ASCII, but not in ASCIIZ.
Not '0' but 0, '\0'. 
Yes, zero byte is a valid ascii character.
Read up on control characters: https://en.wikipedia.org/wiki/ASCII https://en.wikipedia.org/wiki/Null_character
**ASCII** ASCII ( (listen) ASS-kee), abbreviated from American Standard Code for Information Interchange, is a character encoding standard for electronic communication. ASCII codes represent text in computers, telecommunications equipment, and other devices. Most modern character-encoding schemes are based on ASCII, although they support many additional characters. ASCII is the traditional name for the encoding system; the Internet Assigned Numbers Authority (IANA) prefers the updated name US-ASCII, which clarifies that this system was developed in the US and based on the typographical symbols predominantly in use there.ASCII is one of the IEEE milestones. *** **Null character** The null character (also null terminator or null byte), abbreviated NUL or NULL, is a control character with the value zero. It is present in many character sets, including ISO/IEC 646 (or ASCII), the C0 control code, the Universal Coded Character Set (or Unicode), and EBCDIC. It is available in nearly all mainstream programming languages.The original meaning of this character was like NOP—when sent to a printer or a terminal, it does nothing (some terminals, however, incorrectly display it as space). When electromechanical teleprinters were used as computer output devices, one or more null characters were sent at the end of each printed line to allow time for the mechanism to return to the first printing position on the next line. On punched tape, the character is represented with no holes at all, so a new unpunched tape is initially filled with null characters, and often text could be "inserted" at a reserved space of null characters by punching the new characters into the tape over the nulls. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
So? [\64, \14, \0, \37] is a totally valid ascii string, though C string facilities would consider it a [\64, \14, \0] string. Read your own article and then https://en.wikipedia.org/wiki/Null-terminated_string
That makes sense thanks.
Definitely. fmtlib is also great, but IOStreams also have a lot of weird design choices internally. And I can't wait for the day that the iostreams and streambuf especially get re-worked.
It does. The pointer you call free with has the same address as when it was allocated with malloc.
&gt; What about classes? They help a lot in OOP. I'm sure they do. But what does OOP help with? It helps coding OOP style. Now, how does that help? OOP was supposed to reduce LoC, but evidence for that is extremely tenuous. OOP was supposed to increase code re-use, but that was in the 1980s, and today we ubiquitously re-use C libraries from virtually every language through the ubiquitous C ABI. Code re-use has been the norm due to open source and, recently, public code-sharing sites like Github, not as an effect of OOP. But enough discrediting OOP. The answers: * C has a stable ABI, unlike C++. * Benchmarks show that C uses less memory than C++, and is generally slightly faster, but not always faster. * For a given piece of code, C is many, many fewer Assembly-language instructions than C++. * C is simpler syntactically and semantically than C++. * C doesn't change with the whims of fashion like C++. In C, the tools and the best practices get improved, but the language stays mostly the same. 
&gt; If a project is not written in C, for the sake of all that is holy do not introduce another programming language into it. It can make sense to factor out a library, and C is often a very good choice for a library. In general, always use a project's existing language(s), existing code-style, existing frameworks, existing guidelines and practices. That includes not adding C++ to C code, even though C++ was designed to encourage that sort of thing. And don't cast the result of allocations in C... 
If someone wanted GC in C, it's very straightforward to use the Boehm GC. It's even packaged for you: % apt-cache show libgc-dev Version: 1:7.6.4-0.4 Depends: libgc1c2 (= 1:7.6.4-0.4), libc-dev Description: conservative garbage collector for C (development) Boehm-Demers-Weiser's GC is a garbage collecting storage allocator that is intended to be used as a plug-in replacement for C's malloc or C++'s new(). . It allows you to allocate memory basically as you normally would without explicitly deallocating memory that is no longer useful. The collector automatically recycles memory when it determines that it can no longer be used. . This version of the collector is thread safe, has C++ support and uses the defaults for everything else. However, it does not work as a drop-in malloc(3) replacement. . This package is required to compile and link programs that use libgc1c2. Homepage: http://www.hboehm.info/gc/ 
If fervent language advocates couldn't promote their pet language by trying to denigrate C, what ever would they do? 
&gt; I hashed the crontab file and used that as the seed And how many of your servers have the exact same crontab (enforced by Ansible) with the exact same hash running the same commands at the exact same time?
&gt; I've sworn to myself if i ever start a big C++ project the first thing i'll heavily restrict is templates, inheritance and that new auto keyword. Most experienced teams [have C++ guidelines that prohibit C++ features](https://google.github.io/styleguide/cppguide.html). Arguable, prohibiting features is the single most important key to a successful C++ project. Ponder that for a bit. 
haven't done it in a while i rarely work with inputs and strings. did it get better? back in the day i remember having to switch back and forth between c-strings and string to get everything done it was as ugly as it gets. 
&gt; and you can do basically everything you can in C, albeit with some exceptions (VLAs, casting away void*). Note that VLAs are in many ways deprecated in C. &gt; But the major reason not to use C++ is exceptions. Exceptions have huge cost, [and Google doesn't use them](https://google.github.io/styleguide/cppguide.html). Explicit error handling is worth a few lines of code, right there. &gt; If you accidentally get the pointer one-above or one-below the array, the compiler is free to optimize away the check, since it's undefined behavior and therefore never happens, and all your code safety just flew out the window. Modern compilers do a much better job communicating this than did GCC in its first 15 years. That's before even starting with static analyzers, runtime checkers of the Address Sanitizer family, and modern fuzzers like AFL. The reason one can assert that newer languages are "easier to master" without being laughed out of the room is primarily because the majority of recent languages are defined by a single implementation, and usually one that's only portable to 32-bit and 64-bit two's complement byte-addressable ASCII machines -- a considerably narrower remit than C. 
It's a toy, or rather a proof of concept. D is a great example why nobody use it, it's too slow and not very memory effective. If you want to build a fast (precise) low latency GC, you want your compiler and GC to work together to be able to distinct pointers and values. 
Yeah, just an example of VLAs as something C++ never adopted (for good). I also agree on explicit error handling. Just, a lot of facilities in the C++ STL use exceptions liberally. Like, a request `at` throws `std::out-of-range`, requiring you to do the logic of unsafe check or handle exceptions. It takes a concious, and major effort to not use them in modern C++, and it's totally possible. And the lack of general assumptions about the underlying hardware is what makes C portable, it (and various optimizations with undefined behavior) also make C very hard to master. It's a two-pronged sword, I'm not saying it's universally bad. I am saying anyone claiming to be a master is likely full of shit. Also, nice username ;)
I really like pascal, would probably use it about as much as C if there was good, modern ide support that wasn't based around gui or just a ton of extraneous code. But freepascal allows var abc : array of integer; xyz : array of integer; w : integer; begin w := 3; SetLength(abc,w); abc[0] := 1; abc[1] := 2; abc[2] := 3; xyz := Copy(abc,0,w-1); WriteLn(abc[0],' &amp; ',abc[1],' &amp; ',abc[2],' : ',Length(abc)); WriteLn(xyz[0],' &amp; ',xyz[1],' &amp; ',xyz[2],' : ',Length(xyz)) end.
Well, bitwise operators are relatively straightforward. Aside from a couple implementation gotchas, they work about how you'd expect. [Here's the top answer](https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/) from googling "C bitwise operators," but I suspect any such overview would provide you with the information you need. As for multithreading, I'm afraid we'll need a bit more. What are you goals? Which OS would you like to work with? How low level do you want to go?
Indeed, macros not being part of the AST is a weakness of C. But C++ doesn't eliminate macros and doesn't have the OOP features of a Smalltalk or even a Java. 
&gt; I'd like a language using implicit reference counting for GC (and am writing one) for cases that I want it though. Swift? 
Forth is relatively popular for microcontrollers, or was. And you might know it as the implementation language for [OpenBoot](https://en.wikipedia.org/wiki/Open_Firmware). But it has nothing like the toolchains or libraries of C. And while [a Forth stack-machine microcontroller can be attractively minimalistic](http://www.excamera.com/sphinx/fpga-j1.html), it's exceedingly unlikely one could justify using something like that outside of an FPGA. Consider that at the moment, a 32-bit microcontroller costs the same as any of the traditional 8-bit micros, and you can run [a C-based RTOS on an 8-bit micro in less than 512 bytes of (S)RAM](http://www.integerfox.com/xmk/). I can scarcely find a justification to run even a 16-bit architecture, should I want to, much less a Forth chip. Despite being a fan of C, I'm always looking for opportunities where [high-level architectures](https://en.wikipedia.org/wiki/High-level_language_computer_architecture) or stack machines might have a sustainable advantage, but they're hard to find in the last 30 years. Especially if you skip Java. 
**Open Firmware** Open Firmware, or OpenBoot in Sun Microsystems parlance, is a standard defining the interfaces of a computer firmware system, formerly endorsed by the Institute of Electrical and Electronics Engineers (IEEE). It originated at Sun, and has been used by Sun, Apple, IBM, ARM and most other non-x86 PCI chipset vendors. Open Firmware allows the system to load platform-independent drivers directly from the PCI card, improving compatibility. Open Firmware may be accessed through its Forth language shell interface. *** **High-level language computer architecture** A high-level language computer architecture (HLLCA) is a computer architecture designed to be targeted by a specific high-level language, rather than the architecture being dictated by hardware considerations. It is accordingly also termed language-directed computer design, coined in McKeeman (1967) and primarily used in the 1960s and 1970s. HLLCAs were popular in the 1960s and 1970s, but largely disappeared in the 1980s. This followed the dramatic failure of the Intel 432 (1981) and the emergence of optimizing compilers and reduced instruction set computing (RISC) architecture and RISC-like CISC architectures, and the later development of just-in-time compilation for HLLs. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; You basically pick a Forth for your embedded system (or write your own) and that's all the tooling you need or have. You then develop your Forth code interactively on the embedded system, saving it in a text file on your computer for reference. To upload Forth code onto the embedded system, you basically just paste the source code into the Forth console. &gt; &gt; Forth is really different from modern programming languages and takes a while to get used to as many aspects of it are a bit archaic. It is a lot fun and you never want to miss being able to interactively type commands into a console And that's Forth, yes. Now, I *do* wish that all of the mindshare and ROM implementations of BASIC had been Forth, like the [Canon Cat](https://en.wikipedia.org/wiki/Canon_Cat) and [Jupiter Ace](https://en.wikipedia.org/wiki/Jupiter_Ace#ACE's_Forth), but that's a subject for another time. 
That's an [echo of Djykstra's famous 1968 missive](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html), I think. 
I'm working on my thesis and my advisor gave me little information besides "look into bitwise operations and multithreading programming in C." I could ask for more information, but it's a crapshoot if he gets back to me as it's break. For safety, I would like to cover as much and as in depth as possible in a month. It has been a hot minute since I've done anything beyond the basics in C. The topic is (roughly) estimation of kmer frequency. I know the most recent publication didn't use multithreading in their implementation, and chose samples based upon kmers hashed into 64 bits, discarding based upon repeated samples and the rightmost digits. So, that's as close as I can guess as to /why/ I need to learn about these two topics. Any direction would be appreciated.
&gt; and they do this by rewriting in C++. That was the fad at one time, yes. [Like Netscape 4 in the late 1990s, according to jwz.](https://gigamonkeys.wordpress.com/2009/09/28/a-tale-of-two-rewrites/) And C++ as a language always dedicated much effort to making it easy to move a compilation unit from C to C++, and so forth. It's a shame that Netscape 3 C code was never made public. We don't have a pure C or primarily C major browser at the moment. Google and Microsoft have C++ as house languages but not C, and Mozilla started with the C++ Netscape 4 code. 
Maybe a site like this http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html This would be for Linux, or if you install cygwin for Windows or Linux for Windows. Sounds like you're working on parallel search algorithms, so maybe just start with a basic: create 10 thread to find a number in 1,000,000 random numbers. Then maybe after you get that program working, maybe make a similar one that sorts those numbers. As soon as you deal with writing in threads, you'll need to learn about locks and mutexes. 
HHHa
Wonderful thank you! I'll get right on it :)
Multithreaded algorithms have some general principles that overlap, but implementation is largely environment specific. For instance, Windows has its own multithreading API while POSIX compliant operating systems use `pthreads`. There are also cross platform libraries like [OpenMP](https://en.wikipedia.org/wiki/OpenMP) that aim to provide a unified API regardless of OS. This sounds academic, which means you're either already working with Linux, or you don't have OS constraints which would lead me to recommend Linux (or a similar Unix-like environment). There's a lot to consider for k-mer frequency, and it's hard for me to advise without knowing what you intend to do. I imagine that given a sequence `S` of arbitrary length `L` you're attempting to determine the frequency for any k-mer contained therein. My first thought is to iterate `k` from `1` to `L` and step through `S`, extracting k-mers one at a time, and either appending them to a hash table or incrementing their value if it already exists. You can multithread this by having different threads created for each `k` value, and/or having multiple threads read k-mers from `S`. You can help efficiency by having `S` be a read-only value your algorithm accesses, which should mitigate the need for mutexes or similar locking mechanisms. This won't be possible for the hash table as you'll need to write to it, but for a significantly large `L` you won't be able to store all this in memory anyway. If you can, it may make more sense to have a SQL server that you feed your data to. I recommend Postgre, since it will manage accesses for you, and you won't need to worry about horizontal scaling so MySQL won't be necessary. Now, all of that is subject to change if I've misunderstood your goals. Were I you, I would start by choosing a platform and compatible library, then google tutorials for that library. For instance, "pthreads c tutorial" led me [here](https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html) and [here](http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html) which I think are good starter resources for understanding threads and locking mechanisms. Please keep me up to date on this; I'm very interested, and would love to see how your project progresses.
thanks, all of those tips are useful - I'm not used to C, so I'm happy for every advice also, yes, there are libs, but as I stated, I'm doing this for learning purposes
Um ... did you actually read that style guide? It doesn't even prohibit that many things. The vast majority are clarifications on when certain constructs are allowed and when they aren't, but you'll find similar guidance with *any* language, *including C*. Or have you never seen a C style guide that discusses things like when `goto` is allowed? Here's what it does prohibit: * Exceptions. This is understandable, as everyone admits that there's some fundamental problems that prevent them from being appropriate for everybody. In Google's case, the reason is because of extensive legacy code that isn't exception safe. * C-style casts. Well, there's some irony for you. * Built-in integer types except for `int`. Some more irony, IMO. * `NULL`. Hmmm ... I'm seeing a pattern here ... * Most of Boost. Not a language feature, so this isn't applicable to the discussion at hand. * Compiler-specific extensions. Again, not applicable to this discussion. I might have missed a couple, it's a big document.
Ideally we'd be sampling individual kmers from a whole string, which is beastly long so iteration isn't an option. And as gene bases aren't independant and identically distributed, we can't take every nth kmer or the first m kmers and get an accurate result. I'm going to have to either find or come up with a markov model for sampling. Further, depending on the source of the gene, there are different probabilities for each base i to base j. I have some ideas for a solution, hopefully ones that work. It's a monster, but at least it's fun. I'll make sure to keep you posted. And yeah, I should be working in linux :P Thanks a bundle!
All of them. It's not a crontab run on a per-machine basis, but rather a distributed job runner that uses the crontab format. Trust me, our group knows a bit about distributed services. 
Such divergence could be good if it made people responsible for C willing to incorporate more C++ features, like the ability to specify that a pointer to a particular structure type should be regarded as compatible with a pointer to some other type, or specify that an attempt to use member-access syntax with a particular identifier should be treated a certain way. That would allow programmers to define types which client code could use in the same way as C++ classes, but without requiring classes to contain any "compiler-private" information.
&gt; Um ... did you actually read that style guide? I've read it twice. In the case of the exceptions, my feeling is that it tries to avoid controversy by saying, *oh, if we were starting from scratch, we might use exceptions. (Not really.)* The codebase prevents use of exceptions, but saying so mostly serves to avoid needless debate -- exceptions have never been worth it, in retrospect. &gt; C-style casts. Well, there's some irony for you. Why would they use C casts on C++? I never contended they were trying to program C in C++, just that sane C++ users *inevitably* have tight guidelines that include not using some language features. C users don't normally avoid using language features (exceptions: trigraphs (ha!), VLAs, Annex K), and that's the difference that's relevant. C users should avoid C++-style casts, meaning casting the return from `malloc()` *et al*. Some programmers who are programming C with a C++ compiler do use this cast to avoid compiler errors. This is only really seen on Microsoft platforms, where the toolchains can punish one who chooses not the C++. &gt; Built-in integer types except for int. Some more irony, IMO. Subset and portability concerns, plus they choose to go with POSIX. I often do the same; after all a `long` varies in size between 64-bit POSIX and 64-bit Win32. Whole quote: &gt; Of the built-in C++ integer types, the only one used is `int`. If a program needs a variable of a different size, use a precise-width integer type from `&lt;stdint.h&gt;`, such as `int16_t`. &gt; it's a big document. Listing things you shouldn't actually do in C++ requires a lot of text... ;) 
On C++ this is only used for runtime polymorphism via `virtual` methods, non-virtual are linked at compile-time.
Firstly at line 19 and 20, instead of writing the code in two individual parts you could write them in a inside the same conditional line, using and operations, as: if ((\*compare)((\*pp)-&gt;data, p-&gt;data) &gt; 0) Another thing to point out is that if it was an experiment then its ok, but it is not generally a good idea to use the linked list to implement insertion sort. It is not just worth the effort. And the traversing needed in the linked list can put a strain in the memory and thus decrees the overall performance. Another thing is that the current data does not need to start from the head every time. It is because all the data up to this point are already sorted. Therefore the loop needs to start from the position of the next data. You could learn many more optimization techniques and the proper time to use pointers by undertaking courses in specialized programming training courses that are offered by different academies such as “[*Holberton School*](https://www.holbertonschool.com/)” and participating in programming contests. 
&gt; C++ because it has IO streams (which are superior to printf and scanf) You know `cin` and `cout` are lower performance because of buffering, right? I know they can be unbuffered, but I believe there's a performance penalty overall. C++ can use C's `printf` to avoid that, of course. I wish I still had the exact code from an ETL project where converting from C++ to C improved performance dramatically, partly because of the buffering. 
I've used it a bit, I'll have to go check it out again
&gt; And then your memory leaks again due to the lack of RAII/GC `__attribute__((cleanup))` on GCC and Clang
This is for c++ 
Maybe you post the source code and the files, so we can help you better. Without it, we must guess. 
I have a C++11 codebase that runs on an ATTiny85
Yes but that wouldn't work for structs so the point is moot
I’ll have that up in like 30 minutes 
In my line of work I use C over C++ due to interfacing with Linux. The C++ standard library is pretty thin when it comes to system-level interfaces so you end up writing what's basically C anyway. The other main reason I avoid C++ is that I can write very, very clean C. Yet C++ code I wrote a month ago, or "good" C++ libraries are difficult for me to grok. There is just so much complexity in the language and so many rules to memorize. It takes time and effort away from working on the problem domain.
&gt;Are the sizes of blocks of memory stored somewhere? Not necessarily; e.g. the allocator might just store a sorted set of pointers to blocks with a boolean tag as to whether the block is free or allocated. The length of each block would be deduced based on the start of the next block. 
It might point to a block of many ints though, so you couldn't use that logic anyway.
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;fstream&gt; using namespace std; void setDealershipInfo(char [80], char [80], char [80], char [80]); void getBuyerDataFromSalesRep(char [80], char [80], char [80], char [80]); void getNumberOfQueries(int &amp;); void getCarPreferences(int &amp;, int &amp;, double &amp;, double &amp;, int &amp;, int &amp;, char [80]); void getCarDataFromInventoryFile(ifstream &amp;, char [80], int &amp;, char [80], char [80], int &amp;, double &amp;); void processCarInformation(ofstream &amp;, int&amp;, int&amp;, int&amp;, int&amp;, double&amp;, double&amp;, double&amp;, int&amp;, int&amp;, int&amp;, char [80], char [80], char [80], int&amp;, char [80], char [80], int&amp;, double&amp;); int main() { ifstream inventoryCarFile; ofstream customerReportFile; char dealershipName [80], dealershipAddress [80], dealershipCSZ [80], dealershipSlogan [80], buyerName [80], buyerAddress [80], buyerCSZ [80], carClassification [80], rptFileName[80], makeAndModel [80], VIN [80], preferredClassification [80]; int yearLow, yearHigh, mileLow, mileHigh, numQueries, carYear, carMiles, count, numMatches, search; double priceLow, priceHigh,carPrice; setDealershipInfo(dealershipName, dealershipAddress, dealershipCSZ, dealershipSlogan); getBuyerDataFromSalesRep(buyerName, buyerAddress, buyerCSZ, rptFileName); getNumberOfQueries(numQueries); customerReportFile.open(rptFileName); count = 0; while (count &lt; numQueries) { getCarPreferences(yearLow, yearHigh, priceLow, priceHigh, mileLow, mileHigh, preferredClassification); //getCarDataFromInventoryFile(inventoryCarFile, makeAndModel, carYear, // VIN, carClassification, carMiles, // carPrice); search = 0; while (search &lt; 10) { getCarDataFromInventoryFile(inventoryCarFile, makeAndModel, carYear, VIN, carClassification, carMiles, carPrice); processCarInformation(customerReportFile, numMatches, yearHigh, carYear, yearLow, priceHigh, carPrice, priceLow, mileHigh, carMiles, mileLow, preferredClassification, carClassification, makeAndModel, carYear, VIN, carClassification, carMiles, carPrice); search++; } count++; } return 0; } void setDealershipInfo(char dealership [80], char address [80], char CSZ [80], char slogan [80]) { strcpy (dealership,"JPL Customs"); strcpy (address, "195 Washington Street "); strcpy (CSZ, "Watertown, NY, 13601"); strcpy (slogan,"We'll get ya the best deal"); } void getBuyerDataFromSalesRep(char name [80], char addy [80], char CSZ [80], char rpt [80]) { cout &lt;&lt; "Buyer Name: "; cin.getline(name, 80); cout &lt;&lt; "Buyer Address: "; cin.getline(addy, 80); cout &lt;&lt; "Buyer City, State Zip: "; cin.getline(CSZ, 80); cout &lt;&lt; "Enter report file name: "; cin.getline(rpt,80); } void getNumberOfQueries(int &amp;num1) { cout &lt;&lt; "Enter the amount of queries you want to process: "; cin &gt;&gt; num1; } void getCarPreferences(int &amp;yearLow, int &amp;yearHigh, double &amp;priceLow, double &amp;priceHigh, int &amp;mileLow, int &amp;mileHigh, char classification [80]) { cout &lt;&lt; "Enter year range (low): "; cin &gt;&gt; yearLow; cout &lt;&lt; "Enter year range (High): "; cin &gt;&gt; yearHigh; cout &lt;&lt; "Enter price range (low): "; cin &gt;&gt; priceLow; cout &lt;&lt; "Enter price range (High): "; cin &gt;&gt; priceHigh; cout &lt;&lt; "Enter mileage range (low): "; cin &gt;&gt; mileLow; cout &lt;&lt; "Enter mileage range (High): "; cin &gt;&gt; mileHigh; cout &lt;&lt; "Gas, Diesel, Hybrid, or Electric? "; cin &gt;&gt; classification; } void getCarDataFromInventoryFile(ifstream &amp;carFile, char makeAndModel [80], int &amp;year, char VIN [80], char type [80], int &amp;miles, double &amp;price) { carFile &gt;&gt; makeAndModel; carFile &gt;&gt; year; carFile &gt;&gt; VIN; carFile &gt;&gt; type; carFile &gt;&gt; miles; carFile &gt;&gt; price; } void processCarInformation(ofstream &amp;customerReportFile, int &amp;match, int &amp;yearUpper, int &amp;year, int &amp;yearLower, double &amp;priceUpper, double &amp;price, double &amp;priceLower, int &amp;mileUpper, int &amp;mile, int &amp;mileLower, char customerClass [80], char classification [80], char makeAndModel [80], int &amp;carYear, char VIN [80], char carClassification [80], int &amp;carMiles, double &amp;carPrice) { match = 0; if (yearUpper &gt;= year &amp;&amp; yearLower &lt;= year) { if (priceUpper &gt;= price &amp;&amp; priceLower &lt;= price) { if (mileUpper &gt;= mile &amp;&amp; mileLower &lt;= mile) { if (customerClass == classification) { customerReportFile &lt;&lt; "please work"; customerReportFile &lt;&lt; makeAndModel &lt;&lt; carYear &lt;&lt; VIN &lt;&lt; carClassification &lt;&lt; carMiles &lt;&lt; carPrice; match++; } } } } } 
 Here’s the c++ code #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;fstream&gt; using namespace std; void setDealershipInfo(char [80], char [80], char [80], char [80]); void getBuyerDataFromSalesRep(char [80], char [80], char [80], char [80]); void getNumberOfQueries(int &amp;); void getCarPreferences(int &amp;, int &amp;, double &amp;, double &amp;, int &amp;, int &amp;, char [80]); void getCarDataFromInventoryFile(ifstream &amp;, char [80], int &amp;, char [80], char [80], int &amp;, double &amp;); void processCarInformation(ofstream &amp;, int&amp;, int&amp;, int&amp;, int&amp;, double&amp;, double&amp;, double&amp;, int&amp;, int&amp;, int&amp;, char [80], char [80], char [80], int&amp;, char [80], char [80], int&amp;, double&amp;); int main() { ifstream inventoryCarFile; ofstream customerReportFile; char dealershipName [80], dealershipAddress [80], dealershipCSZ [80], dealershipSlogan [80], buyerName [80], buyerAddress [80], buyerCSZ [80], carClassification [80], rptFileName[80], makeAndModel [80], VIN [80], preferredClassification [80]; int yearLow, yearHigh, mileLow, mileHigh, numQueries, carYear, carMiles, count, numMatches, search; double priceLow, priceHigh,carPrice; setDealershipInfo(dealershipName, dealershipAddress, dealershipCSZ, dealershipSlogan); getBuyerDataFromSalesRep(buyerName, buyerAddress, buyerCSZ, rptFileName); getNumberOfQueries(numQueries); customerReportFile.open(rptFileName); count = 0; while (count &lt; numQueries) { getCarPreferences(yearLow, yearHigh, priceLow, priceHigh, mileLow, mileHigh, preferredClassification); //getCarDataFromInventoryFile(inventoryCarFile, makeAndModel, carYear, // VIN, carClassification, carMiles, // carPrice); search = 0; while (search &lt; 10) { getCarDataFromInventoryFile(inventoryCarFile, makeAndModel, carYear, VIN, carClassification, carMiles, carPrice); processCarInformation(customerReportFile, numMatches, yearHigh, carYear, yearLow, priceHigh, carPrice, priceLow, mileHigh, carMiles, mileLow, preferredClassification, carClassification, makeAndModel, carYear, VIN, carClassification, carMiles, carPrice); search++; } count++; } return 0; } void setDealershipInfo(char dealership [80], char address [80], char CSZ [80], char slogan [80]) { strcpy (dealership,"JPL Customs"); strcpy (address, "195 Washington Street "); strcpy (CSZ, "Watertown, NY, 13601"); strcpy (slogan,"We'll get ya the best deal"); } void getBuyerDataFromSalesRep(char name [80], char addy [80], char CSZ [80], char rpt [80]) { cout &lt;&lt; "Buyer Name: "; cin.getline(name, 80); cout &lt;&lt; "Buyer Address: "; cin.getline(addy, 80); cout &lt;&lt; "Buyer City, State Zip: "; cin.getline(CSZ, 80); cout &lt;&lt; "Enter report file name: "; cin.getline(rpt,80); } void getNumberOfQueries(int &amp;num1) { cout &lt;&lt; "Enter the amount of queries you want to process: "; cin &gt;&gt; num1; } void getCarPreferences(int &amp;yearLow, int &amp;yearHigh, double &amp;priceLow, double &amp;priceHigh, int &amp;mileLow, int &amp;mileHigh, char classification [80]) { cout &lt;&lt; "Enter year range (low): "; cin &gt;&gt; yearLow; cout &lt;&lt; "Enter year range (High): "; cin &gt;&gt; yearHigh; cout &lt;&lt; "Enter price range (low): "; cin &gt;&gt; priceLow; cout &lt;&lt; "Enter price range (High): "; cin &gt;&gt; priceHigh; cout &lt;&lt; "Enter mileage range (low): "; cin &gt;&gt; mileLow; cout &lt;&lt; "Enter mileage range (High): "; cin &gt;&gt; mileHigh; cout &lt;&lt; "Gas, Diesel, Hybrid, or Electric? "; cin &gt;&gt; classification; } void getCarDataFromInventoryFile(ifstream &amp;carFile, char makeAndModel [80], int &amp;year, char VIN [80], char type [80], int &amp;miles, double &amp;price) { carFile &gt;&gt; makeAndModel; carFile &gt;&gt; year; carFile &gt;&gt; VIN; carFile &gt;&gt; type; carFile &gt;&gt; miles; carFile &gt;&gt; price; } void processCarInformation(ofstream &amp;customerReportFile, int &amp;match, int &amp;yearUpper, int &amp;year, int &amp;yearLower, double &amp;priceUpper, double &amp;price, double &amp;priceLower, int &amp;mileUpper, int &amp;mile, int &amp;mileLower, char customerClass [80], char classification [80], char makeAndModel [80], int &amp;carYear, char VIN [80], char carClassification [80], int &amp;carMiles, double &amp;carPrice) { match = 0; if (yearUpper &gt;= year &amp;&amp; yearLower &lt;= year) { if (priceUpper &gt;= price &amp;&amp; priceLower &lt;= price) { if (mileUpper &gt;= mile &amp;&amp; mileLower &lt;= mile) { if (customerClass == classification) { customerReportFile &lt;&lt; "please work"; customerReportFile &lt;&lt; makeAndModel &lt;&lt; carYear &lt;&lt; VIN &lt;&lt; carClassification &lt;&lt; carMiles &lt;&lt; carPrice; match++; } } } } } 
not really, it's just another useless feature added to the language by wankers who don't even program with it..
It's almost like the comment that you replied to made note that it would be very impractical. It's also almost like the comment that you replied to was just pointing out an interesting alternative to function overloading that's available in modern versions C. Also, as long as your code is aware of whatever structs you plan to use, type-generic identifiers work fine with structs in C.
My favourite site about C and bitwise operations. You can learn a thing or two but the whole content is amazing and really interesting!! https://graphics.stanford.edu/~seander/bithacks.html
I've worked with OpenMP a lot in the past. It's really really common among researchers. OP If you are looking into creating a parallel program this is the most effective and productive alternative, and there are tons of tutorials and educational videos about ths matter.
Most libraries are available in C, or with a C API/ABI, aren't they? &gt; c++ is much more complex but no one forces you to use all those functions You're forced to do so if you're working with anyone else's code. And since the majority of professional programming is reading more code than one writes, then yes, *all the time*. 
This is C++, not C. When you repost in cpp_questions, format the code properly and include any compiler error messages or other pertinent information.
Honestly? I know C. It’s simple. It’s fast. Its available everywhere. There’s libraries for everything. No weird linkage or name mangling issues. And honestly for me it’s more fun. I like writing C. If I don’t want to deal with C I will just use Python. I’m not against learning other languages... I enjoy that, but I just like C.
Thanks!
All languages were literally created by people that didn't program in them.
Ah, now I get what you're saying. This system has thousands of people writing their own specifications to run tasks.
That is a very good point, although I think the person you replied to was referring to the standards committee
why can’t you put the formatted code here?
God save us.
I'm laughing audibly.
I use this struct of function pointers approach a lot in API building interfaces. Works really well. Makes testing easy too, as you can swap out real functions for test functions. E.g. in your example if you want to test what something does with data it has read, you can replace the read function pointer with one that returns simply the thing you want the test to read.
There's a lot going on here, but first and foremost, shame on your professor for giving you a "build-a-counter" assignment in which you are building a stack data structure.... On line 11, you malloc space for a new node (regardless of whether you use that space or not). On line 26, you calloc space for a new node as well... This is going to cause you memory issues (and confusion). My gut reaction is that you're getting lost (and overwhelmed with debugging) because you're trying to do too much with your add_node function. If you don't clean it up and organize things now, you're going to get in even more trouble later when you need to clean up your memory problems. If I had to do this assignment, I'd create a pointer that we'll refer to as the "head". This is where new nodes will be added an accessed from. "head" will always point to the node that you added most recently. (You are currently using "node" for this on line 42. Your choice of naming gets really confusing.) Next, I'd make the `struct node *add_node(struct node *first, const char *word)` function responsible for adding a node and THATS IT. Do not perform traversals, do not check for items, do not do anything but add a new node and update the pointers. Next I'd write a new function (like `traverse_list`) that takes a string as an argument, along with the reference to the head. This function traverses the list looking for a match. if it finds a match, return that node, otherwise return a null pointer. In the main function, I'd write a loop that takes a user input and calls the `traverse_list` function. If it returns a node, it increment the counter on that node. If it doesn't return a node, it calls the `add_node` function.
they didn't create C they just butchered it
Backwards compatibility with ANSI was kind of maintained. If you feel Reddit-Tumblr urges to always use the later features go code in Python and be happy with a "committee" than can't stand by their own past desitions because of crowd sourced hipsterism.
compiler maintainers will always have more common sense than document maintainers. it's about stability &amp; consistency, not standardisation I'll omit int from my return types n have no issues gettin workin code—winders, loonix, bull shit dee, eunuchs, mac oh ess sux—while yall strugglin with this generic bizz bazz that you didn't need to write in the 1st place lol
What sort of sin did I commit? Im not reading this wall of text and your learning is YOUR responsibility, not your professor's. The mindset you have as you can clearly see will just take you to reddit lol. 
Interesting, though I was talking more about like....operating systems and firmware and such. 
For those interested in the history of programming C is pretty important. If learning languages for that reason is something you're in to. 
I genuinely am very personally responsible in my learning and can tell you honestly I never talk crap about my teachers. I was only illustrating my point here bc we have an assignment due tonight that is much more complex than what we have learned in class. The only thing we have touched in class on files is opening them and that was yesterday. I think in this case explaining that i'm coming to reddit bc a professor has given us an assignment prematurely is fair. This point aside, is there anything helpful you could send my way?
&gt; (He is so disorganized that he may be getting let go so lets not waste time on 'my studying' or 'time management right now please) Your attitude sucks. &gt; Programming_Quiz 3 Treat this like a take home exam. You may not work together. By posting on reddit and asking help for this assignment specifically, you are cheating... very, very blatantly. Shame.... shame.... shame... If you want meaningful and constructive help, start coding the damn thing yourself, or at least show that you've made some effort into thinking through the general steps, then ask specific questions about the things you don't understand or can't wrap your head around. This is not a place for experienced coders to do your homework for you, and the situation you are in is no one's fault but your own.
Some combination of fgets, sscanf, and fprintf. The format string specifiers will do most of the work, combined with the number of values read by sscanf (hint - you are garaunteed to be able to read at least two values per line. [http://www.cplusplus.com/reference/cstdio/printf/](http://www.cplusplus.com/reference/cstdio/printf/) I will not respond to any questions. You should however question the value of the degree you are getting if you are majoring in engineering or comp-sci. Either you aren't willing to put the work in to get something out of it, or your department is so inept that you are paying them for a piece of paper and nothing of actual value. Good luck.
Yeah do your own homework
just pray to ken u might not receive the help u want, but u will receive the help u need just pray to ken.
Why are you allocating a new string to copy the result into in the first place? If you want a modified copy of a string returned from a series of operations then copy it once and perform all the operations on the copy. In terms of your example, strdup() the string from main() and pass it to your removeNewline/remove Spaces/removeParen calls - which would *not* allocate new memory on their own. I've never seen anything like what you're showing, and for good reason: it's bad design.
You are supposed to do your own research. Learning does not end at the class room. Read documentation, google for answers, analyse code of Open Source projects, write your own programs etc. You have to learn how to find information on your own, because out there, in a world of jobs and tasks, there is no professor to explain you what to do.
This is the mentality Im talking about. You need to do research on your own and be a step ahead of everyone. Anyone that wants to study computer science should be able to do this before entering college. Its like if someone wanted to study medicine but had never taken the time to read on biology on his free time before making the decision. &amp;#x200B; Anyways, besides praying to Ken Thompson you should: Create your data structure. Aka structs. Write a function that parses just one line of the file and organizes information inside your structure and then just put that function inside a loop until the end of the file is reached. You do not know how many students or grades there are so you will need to use LinkedLists together with mallocs for simplicity sake. Here is a snippet: //DONT FORGET TO TERMINATE CHAR POINTERS AKA STRINGS WITH 0x00 or NUL (not NULL!) struct Grade{ struct Grade *next; char *subject; int score; } struct Student{ char *fname; char *lname; struct Grade *grades; struct Student *next; } So you will also need to write functions to append to the list, read from the list and create new lists. This is all Ken Thompson can tell you because I only read the first paragraph.
There is no need for malloc here. You can work on your input pointer...or if you really want you can add another argument for output string and pass a larger char buffer. 
I was a total derp and built out the program (because I'm a loser with free time and insomnia) It's so flipping simple that no structs or (or helper functions, really...) are even needed.... The entire thing is about 60-70 lines max. The whole thing about "at least two functions that include FILE pointers in their parameter lists" and reading the names and grades separately is really overcomplicating things. This whole project just comes down to: Read line. Format Strings. Write line. Repeat. Don't fuck up formatting.
Yep. If you want to do it in a "corporate" way you would go with what I suggested or perhaps something even better but since everything is written the same way and separated with spaces you can just do it the quick and dirty way and get it done in 30 minutes.
If you really wanted to, you could make each function do the bookkeeping, passing char \*\*s, initially stdupped, to them. If the function did not need to change the string at all, or it could reuse the area, it would not change \*s. Otherwise, it would make a copy, free the incoming \*s and pass back the new area in \*s. Not recommending this or that way, just an idea if the needs are very special.
Oh absolutely -- structs and the corporate way was my first thought.... ...then rapid-prototyping mode kicked in :D
In C I always try to follow a rule where the user of an API has to allocate and provide the memory buffer and its size as parameters. This gracefully handles both static and dynamic buffers. Of course he is also responsible to free them later. If the required size can't be known at call site, I provide an additional 'get_size' function. I find this strategy to be very clean and flexible, even though the buffer and size parameter passing has been a source of bugs for years. Slices or views are really a valuable tool in a language.
valgrind works perfectly fine on my mac -- I just installed it with brew ie. `brew install valgrind`
u realize that malloc is a really heavy operation?
I agree with you, and I think you expressed roughly the same thing I did, with an added analogy
I generally only tend to use it in that exact case - changing what the "%s" format specifier's going to feed into _printf_ based on a condition. It's a simple use-case and it doesn't require extra variables (provided you're not going to use that same ternary result anywhere else).
I find the ternary operator problematic only when it appears in a really long line. For small (character-wise) expressions it is actually very helpful regarding code flow. It almost is a form of declarative flow control. The syntax seems weird at first but it is actually very simple.
personally i do not like it, because it leaves less space for comments and it is not as common or well known than a simple if else. I just like to stick to the defaults if there's no advantage in using something different. I usually quote Titus Winters at this point "Don't be smart" and "Don't be stupid". But in a simple case like this i'd say it is alright. It's simple enough there's no need for a explanation of what you are doing so the only people confused by it are the people who don't know about the operator. Which might happen.
%s missing from the format ? I don't understand how something could be declared bad by the church. Say, return count ? True : False; ..., nfds ? &amp;fdset : NULL, ... ((level &lt; 10) ? Warn : Note)("battery %d%%", level); In my eyes, two perfectly fine uses and one not so, but still practical.
It's not objectively bad practice. Some people like it, some people don't. Some leave it out of their language to force their opinion on others (Go). Personally I tend to most often use it with empty true branch, i.e. `foo ?: ""` to print empty string instead of (null). That's a language extension though. The way you used it is fine as well. The most problematic part of it is the precedence rules. It's easy tusedo think it has higher precedence than it does when reading code. So you should put parentheses around it if it's ever used as part of an expression. Lately I've seen and used it with realloc. I'd say that's actually quite readable: sz = sz * 2 ?: 4; xnew = realloc(x, sz * sizeof(*x));
Yes, I didn't notice, thank you!
I think your example is perfectly fine. We use tenary operators a lot in variable assignments like `double const foo = condition ? x : x*x;` instead of `if(condition) foo=x;` `else foo = x*x;` because it allows me to have more `const` variables, giving the compiler more room for optimization. We do mainly numerics, and it does make a small difference in a tight loop if applied consistently
it's bad like michael jackson so it's good if you like mj ;-)
useful, thank you I appreciate it
Teaching in steps, that's not bad practice :) Erm... there's still something wrong in the format, contain**s**.
&gt;I agree with Titus and that's what I usually do. In this case I believed it was a good idea because since it's the first course that introduce people to programming ( most of them didn't know anything) and it's good to show them something different, it's up to them after that.
It was badly translated from italian to english and I was a little bit upset during the process :D Anyway we are students as well and not teachers, so our opinions doesn't really matter
scanf format %\[\^0-9\]s would keep eating until a digit is seen. Would not handle Harry Old 1st .999, but ...
It's probably frowned upon because it's hard to debug in this case. Something like this is probably better: bool identical = cmp_arrays(v1, v2, N); char* verdict = identical ? "" : "do not "; printf("The two arrays %scontain the same elements\n", verdict); 
Read the whole line and then iterate until the first numeric character. The address at that index is the start of your integer character sequence. If the character at the previous index is a white space, you can set it to '0' and effectively get your full name string in the original buffer. For the conversion of the integer sequence to a true integer you will need an extra call to atoi.
It works just fine for what I needed it. Thank you!
Not bad practice at all. However, I wouldn't introduce the operator with an example like yours, it can be a little daunting to a beginner, using an intermediate variable would probably be clearer to neophytes: char* contains = cmp_arrays(v1, v2 ,N) ? "" : "do not "; printf("The two arrays %scontain the same elements\n", contains); and it's easier to explain, you can present your version after explaining how the ternary works.
&gt; I'm working on my thesis and my advisor gave me little information besides "look into bitwise operations and multithreading programming in C." You have a shitty advisor... but that's par for the course, I guess. &gt; The topic is (roughly) estimation of kmer frequency How big is *k*?
Not many languages suit the plural trick well. In finnish the extra part changes depending on the noun, so here we just put up with "1 dogs found".
It bothers probably many here to continually see unbounded string scanfs. Just remember it later, use a limit to prevent buffer overflow.
The ternary operator in of itself isn't a problem. It's just an "if-expression" (instead of an if-statement), which pretty well every language supports, and for good reason, though sometimes in better syntax. You wrote: cmp_arrays(v1, v2, N) ? "" : "do not " Which, in other languages, would be written as: if cmp_arrays(v1, v2, N) then "" else "do not " Which is a totally sensible bit of logic, if you ask me. Some people may get intimidated by seeing a ? in syntax instead of a friendlier English word, but, well, anyway the overall point is that logic itself is fine, separate from the syntax. In your specific case, though, I'll warn you that playing tricks with the ternary operator like that (and, it's more common friend, printf("%d item%s", n, n == 1 ? "" : "s")) have one big downside, which is that the code will have to be rewritten entirely if the code is ever internationalized/localized (e.g., with [gettext](https://en.wikipedia.org/wiki/Gettext)).
**Gettext** In computing, gettext is an internationalization and localization (i18n) system commonly used for writing multilingual programs on Unix-like computer operating systems. The most commonly used implementation of gettext is GNU gettext, released by the GNU Project in 1995. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It's not bad practice. However, I've stopped modifying strings like that and instead use two different strings if one contains something that the other doesn't. So it would be something like this: puts( cmp_arrays(v1, v2, N) ? "The two arrays contain the same elements" : "The two arrays do not contain the same elements" ); This makes your program more friendly to translation (eg. with gettext) and less English-centric.
fwiw, i write code like that all the time.
Bad as in badass?
I actually wrote this as a function before and just posted out of curiosity, so in an upcoming test I can have a shorter method.
&gt; True, but there could still be several type-specific `free()`s thanks to type-generic macros introduced in C11. I'm pretty sure `free` predates type-generic macros ;)
well, put it this way conditional_operator = ("you know I'm bad") ? "I'm bad" : "I'm really, really bad"; 
There is an entry in the C++ core guidelines about this. Its not meant for C specifically but in this case applies as well. In this example the main purpose is to print the result of the comparison, and not to perform different actions depending on the result being equal or distinct. Another way you could express your code is having both complete messages pregenerated: const char* msg_same = "Arrays are identical\n"; const char* msg_dist = "Arrays are different\n"; printf( equal? msg_same : message_dist ); The main concern is whether your code is readable and in your example, the intention is clear and does not require deeper analysis.
"Bad practice". Sounds like these nuts who are afraid of `goto`s. Stop scaring students from using features just because they're dangerous. Teach them how to use them properly. ...which is exactly what your doing so good for you. 
You gave `foo()` a function pointer, but not an argument.
Function `foo()` can't see `sptr`, because it is in a different scope (`main()`).
Which ever is easier for you to read. I think the mistake is when people use it because it's easier to write. 
Make it void foo(void (*fp)(struct str_ptr *), struct str_ptr *sptr) { ... } Sometimes it's better **not** to give a descriptive variable name in a declaration.
I would create a 10-element array with zeroes and just increment its values by index.
IMO it's usually alright, but you might want to hold it off, depending on the skill level of the students.
A function pointer is nothing but a pointer to a function. It can be used to pass he name of the function to another function and in more other tasks. &amp;#x200B; I have modified your code .. please check it below. e.g.: The changed code is.. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct str_ptr { char *name; }; void foo(void (*fp)(struct str_ptr *), struct str_ptr *sptr) { (*fp)(sptr); } void print_name(struct str_ptr *sptr) { printf("%s\n", sptr-&gt;name); } int main(void) { struct str_ptr *sptr = malloc(sizeof(*sptr)); sptr-&gt;name = "Nice Remark"; foo(print_name, sptr); exit(EXIT_SUCCESS); } &amp;#x200B; please check the below tutorial for function pointers. [https://www.cs.nccu.edu.tw/\~chenk/Courses/PL/Papers/FunctionPointer-Tutorial.pdf](https://www.cs.nccu.edu.tw/~chenk/Courses/PL/Papers/FunctionPointer-Tutorial.pdf)
General Suggestions: * If you call malloc in a function, make sure that you free it in the same function. * If you cannot free it in the same function, store the pointer variable in a global array or pass it to the calling function. Make sure that you will have that address where malloc'd address is present. If your case, the memory location allocated by removeSpaces is sent to removeParen. But in removeParen you are not calling free. There lies the problem.
Whenever I use a ternary operator and one of the values is a null or zero (or something indicating the absence of a value) then I always wonder if there is a better option to use, structurally speaking, since it appears i'm only concerned with one of values and ignoring the other. I don't think the ternary operator is bad practice, but if I was being picky, i'd say your particular use of it is bit messy. Again, I admit i'm being picky, so take this with a grain of salt. I would have probably not used it in your case, and opted for a simpler if/else and two printf statements (one for each outcome).
I have tutored for more than 4 years at my university as part of my research assistant position and I can't really agree with you here. What you see as a different and interesting feature of the language is not really essential in learning the core of the language or programming on general. It only adds noise to an already tough concept for beginners and is not really having any benefit in return. I think that we as experiences developers and computer scientists often underestimate the complexity of the topic for beginners, as tutors we owe them to make it as appoachable and easy as possible.
Just because you can install it doesn’t mean it works properly. I think ever since Sierra the Valgrind dev team has been trying to play catch up. For some, installing the most recent dev build will work via ‘brew install —HEAD valgrind’. However, even that won’t run properly on Mojave, afaik. 
Indeed! Devirtualisation is a very important optimisation when your whole code has been written under the assumption that virtual function calls are free.
Below is the code that works. Please check it and reach me if you still find any doubts. &amp;#x200B; #include &lt;stdio.h&gt; int main(){ int arr[18]= {11, 11, 11, 5, 6, 2, 3, 2, 7, 2, 2, 9, 2}; int count = 0, count_max = 0; int num , max_num; int i; max_num = num = arr[0]; for ( i = 1; i &lt; 18; i ++){ if(num == arr[i]) count ++; else if (count_max &lt; count){ count_max = count; max_num = num; count = 0; } num = arr[i]; } printf("max_num: %d\n", max_num); printf("count_max:%d\n", count_max+1); return 0; } &amp;#x200B;
You should probably check pointer arguments for `NULL` pointers. For instance, `jsmn_fill_token()` doesn't check `jsmntok_t *token` which will cause problems if its ever passed `NULL`. This of course leads to the next problem of what to do if these functions are passed `NULL` pointers, which in my mind is that you should be returning error codes. I recommend making an `enum` and don't be afraid to `typedef` it for an error type. It may require some refactoring as a number of your functions already return something, but you can have those values returned via reference after you add a pointer argument. More of a style thing, but I found `jsmn_parse_string()` to be a little hard to navigate. In general, if you have to go 3+ blocks deep due to control flow you should consider refactoring your function to rely on more support functions. That's all just at a cursory glance. My explicit examples aren't exhaustive, but I've tried to point out specific design choices to look out for. Overall this is a cool project, and you're definitely heading in the right direction. Great work!
That does not handle more than one digit with the same frequency. Try this: ``` #include &lt;stdio.h&gt; int main(void) { int freq[10] = {0}; int last, digit, max; char ch; printf("Type digits below, end with ENTER key\n"); while ( (ch = getchar()) != '\n' &amp;&amp; ch != '\0' &amp;&amp; ch != EOF ) { if ( ch &lt; '0' || ch &gt; '9' ) { fprintf(stderr, "Invalid digit: %c\n", ch); return 1; } else { digit = ch - 48; } if ( freq[digit] == 0 ) { freq[digit] = 1; } else if ( last == digit ) { if ( ++(freq[digit]) &gt; freq[max] ) max = digit; continue; } last = digit; } printf("Digit(s) "); for ( int i = 0; i &lt; 10; i++ ) if ( freq[i] == freq[max] ) printf("%d ", i); printf("appeared %d time%s in a continuous sequence\n", freq[max], freq[max] == 1 ? "" : "s"); return 0; } /* vim: set ft=c sw=4 sts=4 et: */ ```
I thought it was a well known lib, and I've copied his copyright in the 2 files thinking it's the way to go about it. It's not really a dependency if it's included in my code, but I see how I should have mentioned it in the readme.
It is well known, which is why I'm extra dumb. You don't technically have to say anything about it since you are including the copyright, but it's polite to give credit where credit is due. Moreover, it's worth mentioning which version you're using to help document future compatibility. Since you're github works as a portfolio you may also want to segregate your code from the JSMN source, lest a future reader make the same mistake I did.
link to version was in the source files, and now I've added it to the readme as well
re EDIT3, thanks! I had my doubts about it and rebased it a few times before posting, but it's definitely both motivating and nice to hear I'm on the right track :)
In function jsmn_parse_string, why a for loop and not a while? Any pros or cons to either?
&gt; You should probably check pointer arguments for NULL pointers. For &gt; instance, `jsmn_fill_token()` doesn't check `jsmntok_t *token` which &gt; will cause problems if its ever passed NULL. I know we've established this isn't OP's code, but I utterly and completely disagree with this advice. Instead, document that this function doesn't accept a NULL pointer for `token` — or, more likely, accept the default situation that pointer arguments cannot be NULL unless explicitly documented otherwise. Therefore passing a NULL pointer is a violation of the contract, which is entirely the responsibility of the caller. Callees cannot, in general, validate their pointer arguments, so they shouldn't try. It's especially dubious to check for NULL in `jsmn_fill_token()` since, in modern, hosted implementation, the hardware is already doing that check for you for free. If you passed a NULL pointer, the program would crash, which is exactly what you want to happen. When a bug is detected in a program at run time, that program should immediately abort before it causes more damage. Summary: *Do* check for *run time errors*, like `malloc()` or `fopen()` returning NULL. Do *not* check for *programmer errors*, like passing NULL to a function that doesn't accept NULL. If you're really worried about programmer mistakes, use an `assert()`, which is designed for this purpose. &gt; This of course leads to the next problem of what to do if these &gt; functions are passed NULL pointers, which in my mind is that you &gt; should be returning error codes. Again, completely backwards advice. Since `jsmn_fill_token()` doesn't accept NULL, it has no error conditions, so there's no need to return an error code. By forbidding NULL pointers in its contract, this function is much simpler, easier to read / maintain, and faster. 
&gt;I mean, C is hard to work with. &amp;#x200B; I used to think so, until I worked on million-line C++ projects with "Context" objects passed around everywhere. C is a \_lot\_ easier than C++. This guy summarizes the problems with C++ quite well: [http://blog.greaterthanzero.com/post/58482859780/c-and-the-culture-of-complexity](http://blog.greaterthanzero.com/post/58482859780/c-and-the-culture-of-complexity) &amp;#x200B; &gt;What about classes? They help a lot in OOP. &amp;#x200B; New languages (Go, Rust, etc) have removed classes and to some extent the entire OO-paradigm. C is a small language where you can keep most of it in your head and just solve problems with it. Why are there no C conferences, C courses and lengthy C discussions? Because they spend all of their time developing. &amp;#x200B;
Man, I hope the rest of my day goes better than this thread has. Great advice, as always. 
&gt; jsmn_parse_string that's not my code but I'd guess that with `for` you don't have to scroll until the end of block to see what gets incremented at the end
&gt;simpler, easier to read / maintain, and faster and later you get to look exactly what happened from the coredump.
First of all thank you for taking the time to write this :) Now , I don't think this code works because when I run it , if I input for example just the number 1 , it goes invalid digit.But if you input only 5 it goes to the printf("appeared...").And if , I write 10 , I get digit(s) 2 3 4 5 6 7 8 9 appeared 0 times in a continuous sequence.. I can't understand the way it is made , can you elaborate please on this implementation of yours? Finally , the line that says : digit = ch - 48 , what does it do? I have seen it before . 48 isn't the ASCII code for '0'? So you are writing essentially, digit = ch - '0'. I've seen this last one before , what does it do and why do you need to do it?
Thank you for writing this :) This does indeed work , but it cannot handle the case of having more than one digit with the same frequency , as kumashiro said. &amp;#x200B;
ASCIIZ is not a separate character encoding from ASCII. It's just a convention to terminate strings. 
So , initially the array would be \[0,0,0,0,0,0,0,0,0,0\] and then it would be \[0,1,2,3,4,5,6,7,8,9\]? How does this adress to the problem of the appearance frequency?
It's not a valid text string because text may not contain NUL characters.
In deciding whether to use any language construct, the simplest rule in most cases is to consider how one would write the code with or without the operator and decide which seems more natural, and whether either approach would result in unnecessary duplication or "merging" of functionality. For example, consider the statement: snprintf(message, MESSAGE_BUFFER_SIZE, "You have %d kni%s and %d fork%s.", knife_count, (knife_count==1) ? "fe" : "ves", fork_count, (fork_count==1) ? "" : "s" ); This approach may be the most efficient way to handle all four possible combinations of knife/knives and fork/forks, but there's some dubious merging of content which might be better written as: snprintf(message, MESSAGE_BUFFER_SIZE, "You have %d %s and %d %s.", knife_count, (knife_count==1) ? "knife" : "knives", fork_count, (fork_count==1) ? "fork" : "forks" ); Trying to eliminate the `?:` operator while using a single `sprintf` and without having to have four different versions of the whole message would be possible, but it would take more vertical space and I'm not sure I'd say it's really clearer: char const *knifeWord = "knife"; if (knife_count!=1) knifeWord = "knives"; char const *forkWord = "fork"; if (knife_count!=1) forkWord = "forks"; snprintf(message, MESSAGE_BUFFER_SIZE, "You have %d %s and %d %s.", knife_count, knife_word, fork_count, fork_word ); A better approach when practical might be to avoid the need to pass many conditionally-formed arguments to a single function call (`sprintf` in the above case) by arranging things so the operation can be done in pieces, e.g. using a well-designed string-concatenation function along with a function that accepts a number and strings for zero, one, or multiple items [easing translation to languages that don't use the plural forms of nouns with zero], thus: char *msg_end = message + MESSAGE_BUFFER_SIZE; char *outptr = message; outptr = safestrcat(outptr, msg_end, "You have "); outptr = counted_cat(outptr, msg_end, knife_count, "knives", "knife", "knives"); outptr = counted_cat(outptr, msg_end, fork_count, "forks", "fork", "forks"); outptr = safestrcat(outptr, msg_end, "."); if (outptr &gt;= msg_end-1) // Filled buffer precisely but couldn't write trailing zero fatal_error("Insufficient space in buffer"); int message_length = outptr - message; where safestrcat and counted_cat refrain from writing `*msg_end` or any bytes beyond it, and return a pointer to the zero byte which was written at the end of the string if there was room for it, or the second argument otherwise. That approach is a little more verbose than the form using `snprintf` and conditional operators, but is probably nicer to work with. It would, however, including good well-designed string concatenation function since none of the ones in the Standard library are suitable for incremental string building. 
Sure, in a C-tard world maybe. ASCII standard (as well as unicode) allows a zero byte in a middle of a string, so I could store a zero byte in a middle of a string for my own purpose (parsing simplicity of binary data for example), and it will be a totally valid unicode/ascii string breaking C programs, though not OCaml or C++ programs. https://community.filemaker.com/thread/136832
Yea, my last fix broke it, sorry :D It was supposed to demonstrate an idea, not a fully working program. I fixed it (hopefully, but it won't work with a single digit - you can try to fix it). Let me explain how it works. ``` int freq[10] = {0}; ``` First we are creating a frequency register. It's an array of 10 integers. Each element will hold the amount of the same sequential digit, freq[0] for zeroes, freq[1] for ones etc. All elements have value 0 right now, which is explicitly set by `{0}`. ``` while ( (ch = getchar()) != '\n' &amp;&amp; ch != '\0' &amp;&amp; ch != EOF ) { ``` Now, we are reading characters from stdin, one at a time. We stop at ENTER key (`\n`), empty data in case of error (`\0') or end of file if user presses Ctrl-D on Unix (`EOF`). ``` if ( ch &lt; '0' || ch &gt; '9' ) { fprintf(stderr, "Invalid digit: %c\n", ch); return 1; } ``` We need to check if user entered correct character. If we got something else than a digit, we throw an error and exit with status 1. ``` digit = ch - 48; ``` This converts a character into a number, so a character `'4'` becomes an integer `4`. We do this by substracting an ASCII value of `0` from the ASCII character value we got from the user. ``` if ( freq[digit] == 0 ) freq[digit] = 1; ``` If previous digit was not the same as current one, its count will be 0 in our frequency register, so all we need to do is bump it up to 1. ``` else if ( last == digit &amp;&amp; ++(freq[digit]) &gt; freq[max] ) max = digit; ``` This does three things - checks if current digit is the same as the previous one, increments the count for it in frequency register, then checks if the new count is higher than the amount of a digit we remembered in `max`. At the start, `max` is 0 and `freq[max]` is also 0, so here, if we read a digit - let's say - 7, `freq[7]` will be higher than `freq[0]` (`1 &gt; 0`) and we change `max` to `7` for future comparisons. ``` else freq[last] = 0; ``` If current digit is not the same as last one, we reset the count of the previous digit, so it won't accumulate with digits repeated further in the input. ``` last = digit; ``` We also store the last digit we've read, so we can detect repetitions in `else if` above. ``` for ( int i = 0; i &lt; 10; i++ ) if ( freq[i] == freq[max] ) printf("%d ", i); ``` Lastly, we print all digits from the register, that have the same count as `freq[max]`, which is a cheeky way to reuse variables. `max` is the digit with highest repetition count. 
Yeah , I get it now . Thanks you for this in depth explanation of the code :)
No, no. Initially it will be `[0,0,0,0,0,0,0,0,0,0]`. For input `1112671888` it will be `[0,3,0,0,0,0,0,0,3,0]`.
&gt; like the ability to specify that a pointer to a particular structure type should be regarded as compatible with a pointer to some other type You're asking for strong typing. Sounds great in theory, but a lot of the complexity and weaknesses of C++ come in the end from strong typing, as opposed to C's "weak(er) typing". There are ways to do it in C codebases, but I think everything with compile-time checks relies on typedefs. 
Whats the fun of coding in C if you are not gonna reinvent the wheel and write your own JSON parser?
What I am asking for is not "strong typing" of storage, but rather the ability to have a function accept pointers of any structure type that claims to be compatible with some particular type, without requiring that it accept a `void*`, and require that compilers not be obtusely blind to the possibility that when a pointer of type `struct BLOB6*`: struct BLOB6 { size_t size; FLAGS flags; THING dat[6]); is passed to a function like: struct BLOB { size_t size; FLAGS flags; THING dat[6]); FLAGS get_blob_flags(struct BLOB*p) { return p-&gt;flags); the latter function might use type `struct BLOB` to access the storage associated with a `BLOB6`. 
Bitwise operators are simple enough to understand, but it helps a lot to know what idioms are commonly used. Bitwise OR for flags, say on opening a file handle, and Bitwise AND to take the bottom *n* bytes of a result, and Bitwise XOR to symmetrically obfuscate a sequence of bytes. Multithreading is rather different, in that it's not in the base language, it's relatively advanced, and it's not at all hard to get wrong. You'll want to use "pthreads", which is POSIX threads. [Even on Windows, you'll want to use pthreads.](https://locklessinc.com/articles/pthreads_on_windows/) Threading has been common on Windows for a bit longer than Unix, largely because process creation has high overhead on NT and, I believe, the IPC (Inter-Process Communication) facilities are a lot weaker. So understand that from a Windows point of view, threading may be the assumed way to do concurrency, while there might be equal or better ways to do it on Linux with multiple processes. 
K&amp;R ch.1 exercises gave me enough text processing for the month :) and jsmn really is a neat little lib, seems like the author decided to [give it some love again](https://github.com/zserge/jsmn/compare/modernize)
C is very efficient for operations, but it can take quite a bit of work to extract that efficiency sometimes, depending on the task. Concurrency normally doesn't come for free, notably. You'll have your pick of libraries to use, and also anything you develop can be turned into a library for use by other code. The biggest problem can be one of searching and deciding, so remember to use your resources to help you do that. Concurrency has been everyone's problem for at least a decade now. Efficient computation usually demands concurrency of *some* sort, today. Threading is popular, but it's not the the only way. Windows-centric programmers tend to focus on threading to the exclusion of other options, because their ecosystem channels them that way. 
Not enough text processing until you write your own parser generator.
well, at the moment your interfaces are dependent upon the jsmn library and its types. hard to work with especially if you decide later on to switch to another library other than jsmn. imo a header should serve as an interface by which the caller and implementir can communicate. the caller needn't know what jsmn.h is or its types, and the implementor should be free to change the implementation to use another library without having to change the .h file—at least not in a way that disturbs the caller's code. 
My code has a problem, however. It will not cope well with repeated sequences of the same character. Do you want to try solve it yourself? My solution is a bit more complicated than the original code, so shout out if you get stuck. I will post new code here.
Thanks! So my interface should really be a mix of `jstab.h` and `hnb-api.h`, and I have to hide the specifics of how I get from the API url to the finished table. At the same time, maybe I will want to pull data from some other sources so have to figure that out as well. I'll tinker with it some more these days...
re edit: this program actually solves a problem for me so it was fun coding experience, I used to do it with `sed` in a shell script :) I had some C++ at university but it was long time ago. C is more interesting IMO.
It depends upon the implementation of `malloc()` where the tracking information is kept, and it's usually near the point of allocation. And sometimes, it's all too easy to overwrite---from a bug I just fixed at work: size_t numrecs = 0; size_t maxrecs = 0; int *data = NULL; if (numrecs == maxrecs) { size_t newmax = (maxrecs + 1024) * sizeof(int); /* BUG */ int *newdata = realloc(data,newmax); if (newdata == NULL) { fprintf(stderr,"out of memory\n"); return someerror; } maxrecs = newmax; data = newdata; } The bug here is that `maxrecs` is tracking the number of *records* I can store, but in the marked line, I set the new maximum number of records to the number of *bytes* it will consume. This will easily cause memory to be overwritten, and possibly scramble other allocations as well. The code should read: size_t newmax = maxrecs + 1024; int *newdata = realloc(data,newmax * sizeof(int)); NOTE: I use a constant to increment the allocated size of memory when it's common to double the increment each time `realloc()` is called, and the code I pull this example from does that, but I did not want to complicate the example more than necessary. 
Well, calling a `virtual` method does indeed do something different than a non-virtual one when it comes to inheritance, so I don't think this assumption is made, really.
 scanf("%s", data[i]-&gt;name); This is treating `data` as an array of pointers. It isn't; it is a pointer to array of structures. `data` is a pointer to a single pointer, so deference it with `*` and deference the result with `[]` scanf("%s", (*data)[i].name);
You need to think carefully about what type `data` is when passed to `addItem`. It's a pointer to a pointer to the first element of an array of `Travel` structures. However, when you do: scanf("%s",&amp;data[i]-&gt;name); scanf("%d",&amp;data[i]-&gt;age); This treats `data` as a pointer to the first element of an array of pointers to `Travel` structures. The `Travel**` is still the same, but what each level of pointer actually refers to is different. Also, the first `scanf` has an extra `&amp;` that isn't right. What you really need is: scanf("%s", (*data)[i].name); scanf("%d", &amp;(*data)[i]-&gt;age); The same goes for `displayArr`, but in that case I'd just pass a `Travel*` to keep things simple. Also, don't make `size` a global variable, pass it alongside `data`.
Thanks, you are a life saver! 
sounds like you're on the path and your software's really good so far, I think you'll have no trouble completing k&amp;r2 and getting this project to a point of satisfaction keep up the great work :D
Yeah , I stumbled across that a few moments ago.. I will try to solve it and if not I will tell you.
BTW, while C may have been designed as a loosely-typed language, the way the Standard is written makes it one of the most strongly-typed languages around, save for a couple of loopholes. The "character-type" loophole needlessly impedes many optimizations that would otherwise be useful, the "effective type" loophole ambiguous and unworkable, and few programs that work with the rules as written would need either of those loopholes if the primary rule (N1570 6.5p7) were changed slightly to effectively make the footnote normative. For aliasing to occur, there must be some context in which two lvalues are used to access an object in conflicting fashion, and there must be no consistent parent-child relationship between them within that context. 
another thing, look at the call to realloc, you got the new size wrong work on small pieces at a time, consider getting valgrind and learning to use it to catch any memory errors that might pop up. get into the swing of testing the return values of malloc and realloc memory management's a big thing in C, and getting it right from the start will serve you well into the future, so take your time with it :)
Is Codecademy so bad that they did not even teach you the differences between C and C++? r/learncpp
You will want to use a double pointer `char **` (similar to the return type for the function) for your result variable. Also, to get the length of a string, use the function `strlen(string)` provided by string.h. Basically, you're going to allocate an array of pointers using malloc. So to start, allocate the initial array using `char **result = malloc(sizeof(char*) * strlen(string));` This is allocating an array of char pointers (strings) with the length of the sting. Now you have the right idea with the `for` loop, but instead of just setting each index in result to the character, you need to allocate some space for a string instead. Within the for loop, `result[i] = malloc(sizeof(char) * 2);` will allocate a string with room for 1 character and a null terminator. Hopefully this helps you figure out the problem!
thanks! this helped a lot :D
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. in /r/cpp_questions.
Please be civil. /u/a4qbfb gave polite and useful advice to you. There is no reason to insult him like this for his effort.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Your title pretty much says “Stack-based Language.” Is that not what you meant C is?
Do not spam.
Do not spam.
Do not spam.
Do not spam.
Unfortunately, knowledge of templates is necessary to debug templates error and not spend hours wondering why your code doesn't work and the compiler produces 1000 lines of cryptic errors. 
Theres some discord or team speak to talk? I'm starting on C and i need help.
I'm pretty sure that what you're doing results in undefined behavior. You're using two post-increment operators that are not separated by sequence points. So, the results are unpredictable and defined by your compiler.
actually, I saw your post, and my first impression was to get the very same results as you, so Idecided to try it myself. My test result= 63 and 33. [https://imgur.com/a/TKkFdVL](https://imgur.com/a/TKkFdVL) &amp;#x200B;
How? If you think b is 33, clearly you think a is 34+35=69. How do you get at thinking that a is 63?
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/XYfX8eg.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20eb8w5m1) 
Please do not post pictures of code. See [here](http://idownvotedbecau.se/imagesofcode) for reasons why.
Pretty sure this UB. See sequence points. Also that code is C++, and this is C subreddit. Head over to /r/cpp or other C++ subreddits mentioned in sidebar.
So what does that mean.I'm not that well equipped with the knowledge of c++ because my semester just started it and I have to submit a 20 questions output with its working and this question is the last one.So if you could kindly explain to me what sequence points are and what undefined behavior would mean I would appreciate that Thanks in advance :)
a=15: b=(15+1) /\*now a=16\*/ + (16+1)=16+17 = 33
None of the content of `data` is going to be used before the first call to `realloc`, so you could either initialize it to a null pointer, or using `malloc(0)` [which on some implementations might yield a null pointer]. Your `addItem` function increases `size` by `n` (rather than setting it equal to `n`). That would be reasonable if the function appended information to the end of `*data`, but the code as written replaces whatever records are there. The behavior of `scanf()` with interactive console I/O is rather broken. Writing a function that reads a line with `fgets()` and strips out any trailing newline character would probably be better; that's such a common operation, it boggles the mind that there's no standard-library function that does that other than the unspeakably horrible `gets()`, but spinning your own probably shouldn't be difficult.
https://en.cppreference.com/w/cpp/language/eval_order check sequence point rules and undefined behaviours. 
(And the X++ command means in practice "after the rest", whereas the "++X" means before the fact.)
that is why I decided to run it! 
According to the ISO standard, it's expecting a variable to be modified only once before the next sequence point (a semicolon ';'). When you do two modifications of a variable, it results in undefined behavior, which is entirely up to the compiler to handle. In the case of your compiler, both increments are happening after the sum in both statements.
I get 63 and 33 (along with a warning) &gt; cat foo.cc &amp;&amp; clang++ -O3 -std=c++14 -O3 foo.cc &amp;&amp; ./a.out #include &lt;iostream&gt; using namespace std; int main() { int a = 15, b; b = (a++) + (a++); a = (b++) + (b++); cout&lt;&lt;a &lt;&lt;endl &lt;&lt;b; return 0; } foo.cc:5:11: warning: multiple unsequenced modifications to 'a' [-Wunsequenced] b = (a++) + (a++); ^ ~~ foo.cc:6:11: warning: multiple unsequenced modifications to 'b' [-Wunsequenced] a = (b++) + (b++); ^ ~~ 2 warnings generated. 63 33
Someone correct me if I screw up the terminology here, but I think that your confusion might stem from the fact that you've put `a++` inside parentheses, thinking that the parentheses should prioritize the increment before the remainder of the expression is evaluated. However, the post-increment operation occurs at the end of a sequence--which parentheses do not affect. From Wikipedia, "a sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed." The C and C++ language have several sequence delimiters, including the semicolon, `&amp;&amp;`, `||`, etc. So, your increments aren't happening until the remainder of your expression is evaluated. Additionally, the C and C++ languages do not allow two modifications to the same variable within the same sequence. So, by having two post-increments within the same sequence, you've invoked undefined behavior, which means the compiler can do whatever it wants, including [starting a game of Rogue](http://wiki.c2.com/?UndefinedBehavior).
This has nothing to do with code and everything with thinking how the heck you can mutate the input to find matches. Think and don't forget to pray. 
Yeah, thanks. This is just a quick prototype. In original program, records are appended to data so I intuitively wrote similar code here.
Semicolons are not the only sequence points. Function calls, binary boolean operators, the ternary operator, and the various meanings of the comma are too.
I really wasn’t asking for the answer just general guidance because I have no idea steps to take next! I have no clue what functions would be useful. Wish me luck!
Another thing: You’re allocating `strlen(_str)` (—don’t use `_` as a prefix unless you’re writing system headers—) but if you don’t remove anything, the string will require `strlen(_str)+1` bytes, because of the terminating NUL. If you do convert it to where the functions operate on their (hopefully mutable) input string, note that any pointer to a string literal should be treated as `const char *`, and preferably declared that way. If you want to be able to modify the contents, do char s[] = "Some String"; which creates a buffer on the stack—suitable only for small-sized strings, to avoid crashing. (Or make it `static` so it matches the string literal behavior, and so there’s no risk of crashing for larger strings.)
It's just a matter of style. However, i would disagree with you that your version makes the program more friendly to translation. I would argue that it remains the same. Gettext allows the translators to rearrange the positions of the format strings making translation fairly straight forward in such cases.
In French, “do not contain” would be something like “ne contient pas” where “contient” means contain. You can see how that would fail with the other approach.
Do you want me to rewrite all that has been written about compilers, parses and lexers in this universe? Read the definition of compiler to see if what you did is one of them. Also google. God save us.
So stack based programming languages are definitely a thing, and they work much like that example. For example Postscript and its derivative PDF are stack based languages. However I wouldn't classify this as a compiler. A compiler transforms from one representation to another, for example C code into a binary, or assembly. As the proposed program executes the code it reads it would more properly be called an interpreter. There is nothing wrong with an interpreter, most high level languages such as Postscript, PDF, Python, PHP, Perl and others which start with different letters are implemented with an interpreter.
This way consumes more flash on embedded processors though. Across a large program it can really add up. 
For a first compiler, a virtual stack machine is more of what you'd *target* rather than what you'd accept as source input. Stack machines are generally easier to target than register machines. One of the earliest such architectures was the [p-Machine](https://en.wikipedia.org/wiki/P-code_machine), and this is what originally inspired the Java virtual machine, which is also largely a stack machine. For example, your input program might look like: def foo(x): return 4 + bar(x * 5) And your compiler would produce a stack machine program: push 5 mult push "bar" call 1 push 4 add ret Suggestion: If you don't want to fuss around with syntax, make the surface syntax of your input language a lisp. It's super easy to parse. 
**P-code machine** In computer programming, a p-code machine, or portable code machine is a virtual machine designed to execute p-code (the assembly language of a hypothetical CPU). This term is applied both generically to all such machines (such as the Java Virtual Machine and MATLAB precompiled code), and to specific implementations, the most famous being the p-Machine of the Pascal-P system, particularly the UCSD Pascal implementation (among whose developers the "p" in "p-code" was construed to mean "pseudo" more often than "portable", "pseudo-code" thus meaning instructions for a pseudo-machine) . Although the concept was first implemented circa 1966 (as O-code for BCPL and P – a code for the Euler Language), the term p-code first appeared in the early 1970s. Two early compilers generating p-code were the Pascal-P compiler in 1973, by Nori, Ammann, Jensen, Hageli, and Jacobi, and the Pascal-S compiler in 1975, by Niklaus Wirth. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
You can make the case that people will make the same kinds of mistakes, but you need to provide data. There have been enough cases of real world exploitable memory corruption originating from the unbounded functions that I've started keeping track of them: [https://twitter.com/hashtag/annexk?f=tweets](https://twitter.com/hashtag/annexk?f=tweets) . You can make the case that people will use them wrong - the size of the wrong buffer - but in practice, that's *a lot easier* to detect in static analysis than to do a full buffer size analysis, or otherwise keep track of the valid sizes. &amp;#x200B; Yes, it's awkward, and runtime constraint violation is a mess. IMHO, the default handler should just be \_\_fastfail() (or your Linux equivalent of choice). 
it's an interpreter. it reads and parses the program *then evaluates it* a compiler reads and parses too, but it translates one language to another. input could be C, then it outputs say x86 machine code. it doesn't evaluate /execute the program.
Don't bother making a compiler until you consider yourself a very good programmer. However, that's not to say you can't get closer to that goal by staying on this topic, just start with something more basic, that is, an interpreter. Skip all the compiler theory, and bash your head at making a very simple scripting language. Start with the simplest of stuff. Can you interpret 3 + 4? what about 3 + (4 \* 5)?
If you're interested in how software transforms and executes software, there is no better guide than [SICP](https://mitpress.mit.edu/sites/default/files/sicp/index.html). It was used for many years as a freshman Intro to CS text at MIT.
It's an interpreter, not a compiler. And what you describe is like the old programming language FORTH. The simplicity you complain abiut, is one of its strengths. Also: I wholeheartedly reccomond the book known under the acronym SICP. It's in Scheme, a simple dialect of Lisp, but it's a mind opener. 
By your definition any type of Encoder is a compiler. For example I'm working a project that is encoding a set of binary instructions into an 64base string. This isn't the same as translating human readable langauge into machine instructions, which is what a compiler does.
This uses a wide-character string constant to store the Unicode-Codepoint, but afaik `wchar_t` is not defined to be made of Unicode codepoints. On Windows it's even UTF-16 (and not even really that).
You have already learned to snatch the error code from the trap frame.
If you add instructions to do things like take the top two numbers of the stack and add them together pushing the result to the stack, reading and writing from the stack to an array (memory), conditional and unconditional jumps, and reading a character from stdin and writing a character to stdout you would be able to turn higher level language instructions into your stack machine instructions.
Try reading this: https://stackoverflow.com/questions/4592762/difference-between-const-const-volatile#4597164
In my opinion, the linked answer does not stress enough the fact that `volatile` variables will never be cached and always will be freshly read from main memory.
This is not strictly true since the CPU might cache or reorder them, even though the compiler won't.
I'm not sure what you're trying to say. The compiler translates `L'\U0001f914'` to the correct wide character constant, if at all possible. And `wchar_t` can't be UTF-16 since UTF-16 is a multibyte encoding.
Thanks for the answers guys. Guess I'm working on an interpreter this weekend.
https://icpcarchive.ecs.baylor.edu/
I assume the number is stored as an unsigned integer. You will need a `char` buffer large enough to store one character for each bit in the number, plus a terminating '\0'. You must then repeatedly check the lowest bit of the integer, append a 1 or a 0 to the buffer depending on whether it is set or not, and shift right. Alternatively, you can repeatedly compare the integer to a mask that you shift left for every iteration. Once you're done, you will need to reverse the string, which can easily be done in place. If this is something you're going to use repeatedly throughout a larger program or even in multiple programs, it is best to have the caller provide the buffer in which the string will be stored. If it's just a one-off, you can use a static variable defined within the function and return a pointer to it.
You may find it much easier to convert to a hexedecimal string, then convert that to binary (scanf, printf). Or you may find it easier to design an algorithm around bitshifting and masking. The first requires more typing, and the second requires more thinking.
**Any** decimal number ? In excess of 4 billion or even 2^(64) ?
The number 23 **IS** the number 10111 in the eyes of your computer. You can simply carry it around(return it, pass it e.t.c.) in an int or int64 variable and interpret it differently(print it as decimal, print it as binary e.t.c.) according to the context.
re Update, Too bad, good luck today :)
&gt; there's implementations where CHAR_BIT == 9, https://news.ycombinator.com/item?id=3112704 trust me That link does not give any examples of an implementation where `CHAR_BIT == 9` =/
This is actually an interview question I commonly ask. Volatile only affects register caching on most modern architectures, it does not affect caching in things like L1, L2, etc. These caches are typically managed via MMU/page tables which are outside of the compilers control via ASM. 
r/ihadastroke
What timing, arrived here from a google search, wondering this exact thing. I completed a course this semester where we were tasked to build a MIPS in Hardware descriptive language, and we'd use ternary operators as MUX's (an if/else statement). This is the 5th programming course I've taken and the first where I've learnt about them and used them. I guess no one who teaches, likes them either. I'll certainly continue to use them if I feel the need for a simple if else assignment in the future.
Volatile forces a memory access whenever the variable is read. Const just means the program won't modify that storage location. It's useful for things like reading a timer.
No one seems to have mentioned yacc [yacc](https://en.wikipedia.org/wiki/Yacc). Maybe it's not used anymore :)
Did I come off as pretentious? I didnt mean to :( i thought I should explain what I have done already in case anyone mentions The C Programming Language by K&amp;R
Can you provide a source for more reading? The whole “constant volatile” thing seems to be a paradox to me. 
From the compiler's point of view, L1, L2 cache does not exist. There is just memory from which it can read to get the most up-to-date value. I personally find it a fitting mental model for when volatile can might be useful. This is already a convoluted topic. I agree with you that the way I phrased it, might send the wrong message. I stand corrected. 
To be honest, I didn't like my wording either, as register could mean the HWIO/MMIO register as opposed to what I meant of a compiler utilized CPU register storing a memory read value. I generally prefer to think of it as volatile will force the compiler to generate a unique read or write via a memory operation for each access. My favorite variant to see if people "get" C is to ask of you can have a register volatile and what register does. Oddly, yes, this is doable, and provides an interesting side effect because you can't dereference a Register variable, and thus can't pass it by reference. 
There are a variety of resources depending upon what makes it click for you, but stack overflow, quota, and something like [this] (https://wiki.sei.cmu.edu/confluence/plugins/servlet/mobile?contentId=87152463#content/view/87152463) might be helpful. The important thing is just to parse them one at a time. Volatile and cons just "stack" on each other and don't change the behavior of the other, so you can treat them separately. Const just says the object can't be assigned a value, and volatile just says go to "memory" for each read and write, but since Const forbids writes, only reads will be done. Things only get complicated for me when you start to have pointers and the pointer can have properties as well as the type the pointer is referring, i.e. A Const pointer to a Const value. 
Write a C compiler that uses less than 100 kb of memory.
The simple explanation is that, volatile means *your code* could change it somewhere else, so it shouldn't be optimized by the compiler. Const volatile means that *something else* can change it and it shouldn't be optimized (such as a hardware register), but if *your code* tries access it, you'll get a compiler error because you shouldn't be writing to it.
Hrm the key there is my code can’t change it but fully permit another source to change it. Seems interesting. Where in memory would I find this? In the “text” part of the memory map where all other constants are?
Unless you are writing for an embedded system with a fairly simply architecture, keyword `register` is merely a request that will be ignored by the compiler on modern architectures.
I'm not sure whether this works as you described. Can you cite some source proving it certainly translates the Unicode-Codepoint into a wide character literal? Also yes, Windows does use UTF-16, and yes, it is broken.
Usually you'll see `const volatile` used on pointers for [memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O), like: ```c uint32_t const volatile *MY_READ_ONLY_MMIO_REGISTER = /* whatever the address is */; ``` In this example, `MY_READ_ONLY_MMIO_REGISTER` might point to a CPU status register, a hardware controller, or who knows what else. In any case, though, reads from it are volatile: it may change between subsequent reads. You will much less frequently see `const volatile` values which are not pointers, because there are very few cases where a value like ```c int const volatile ONE = 1; ``` will be overwritten.
**Memory-mapped I/O** Memory-mapped I/O (MMIO) and port-mapped I/O (PMIO) (which is also called isolated I/O) are two complementary methods of performing input/output (I/O) between the central processing unit (CPU) and peripheral devices in a computer. An alternative approach is using dedicated I/O processors, commonly known as channels on mainframe computers, which execute their own instructions. Memory-mapped I/O uses the same address space to address both memory and I/O devices. The memory and registers of the I/O devices are mapped to (associated with) address values. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Alright, I did some refactoring. Now `main` sees only the `hnb-api.h` which is changed to write into a plain string instead of custom structure, and `jstab.h` which exposes only the resulting table structure. The process for converting the string to table is now hidden from the user. Thanks again! If I want to add more APIs, I could easily rename `hnb-api.h` to `apis.h` and add some more API-specific functions to go from query to a json string. `jstab.h` currently only accepts a json substring in the `[key:value, key:value, ...]` format, and more functions could be added for other cases like `{key1:[value, value, ...], key2:[value, value, ...]}`, etc.
That's a novel way of using it. That's going into the library, definitely!
&gt; Can you cite some source proving it certainly translates the Unicode-Codepoint into a wide character literal? C11 §6.4.5. A string literal is a multibyte character sequence. If preceded by the `u8` prefix, it is stored as a UTF-8 sequence. If preceded by the `L`, `u` or `U` prefix, it is converted into a wide character string as if by `mbstowcs()`, `mbrtoc16()` or `mbrtoc32()`, respectively. Otherwise, it is stored as-is. 
Not at all. I just meant that you are ready to take on real projects rather than just practice.
Error messages should contain the program name, they might get interleaved with other stuff into some logfile that's not viewed in real time. &amp;#x200B; This made me scratch my head once: `sock_connect_with_timeout: connect: No route to host` Who said it. Who was he trying to connect to. Why am I told the exact function name. Better would have been `sylpheed: connect` `gmail com``: No route to host`
https://web.stanford.edu/class/cs140/projects/pintos/pintos_1.html Instructional OS ... Will learn synchronization, system calls, virtual memory and file systems. The reading material with each project is sufficient to learn the material. Comes with unit tests to test your code.
&gt; easier to convert to a hexedecimal string, then convert that to binary Umm. Why?
I've used const volatile frequently in the embedded world - usually when I have configuration data in flash memory. It can't be written to directly, but it can change through special flash programming calls, and you want to make sure the compiler isn't optimizing out reads of parameters that might have changed.
Thank you!
The only time I can think of that a `register volatile` combination could be relevant would be if an automatic object which is modified between a `setjmp` and a `longjmp` is then read after the `longjmp`. E.g. #include &lt;setjmp.h&gt; jmp_buf buf; int test(void) { register volatile int x = 1; if (setjmp(buf)) return x; x++; longjmp(buf,1); } In the absence of the `volatile` qualifier on `x`, a compiler that cached `x` in a register would be entitled to save its value on the stack across the call to `setjmp` [on some platforms, `setjmp` could be processed by the compiler as an ordinary call to an xternal function about which it has no special knowledge]. If for some reason one wanted to impose a constraint that an object's address not be taken, `register volatile` would be the proper combination of qualifiers. Not that I'm sure when such constraints could serve a useful purpose to anything other than a one-shot compiler. The qualifier could be much more useful if programs were allowed to use the address of a `register`-qualified object in limited ways, and if use in combination with `volatile` were to imply that compilers must handle constructs with `setjmp` but were not otherwise required to employ volatile semantics.
The Standard requires that `register` it be processed as a constraint that forbids `&amp;`. If it instead limited the use of a pointer yielded by `&amp;` it give a compiler useful information it would otherwise have no way of knowing, e.g. given: void test(void) { register int foo; proc1(&amp;foo); for (int i=0; i&lt;1000; i++) proc2(foo++); proc3(&amp;foo); } it could allow a compiler to substitute: void test(void) { register int foo; proc1(&amp;foo); for (int i=0; i&lt;1000; i++) proc2(foo+i); foo+=1000; proc3(&amp;foo); } in cases where that would be useful, but would allow a compiler to process the code as written in cases where the substitution would be counterproductive. 
Apart from this, I would also recommend the [6.828 labs from MIT](https://pdos.csail.mit.edu/6.828/2018/labguide.html). Similar to Pintos, it is an instructional OS. The only difference I found is the last lab. It is about a implementing a simple form of a network driver.
I don't understand your point. Admittedly, I have not kept up with the more recent standards, so there may be changes of which I am not aware. However, the following excerpts come from the 2005 working draft of the ISO C standard [\(PDF\)](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf). --- p. 46 &gt; 3) Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. p. 78 &gt; The operand of the unary &amp; operator shall be either a function designator, the result of a [] or unary * operator, or an lvalue that designates an object that is not a bit-field and is not declared with the register storage-class specifier. p. 98 &gt; A declaration of an identifier for an object with storage-class specifier register suggests that access to the object be as fast as possible. The extent to which such suggestions are effective is implementation-defined.^101 &gt; ^101 &gt; The implementation may treat any register declaration simply as an auto declaration. However, whether or not addressable storage is actually used, the address of any part of an object declared with storage-class specifier register cannot be computed, either explicitly (by use of the unary &amp; operator as discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as discussed in 6.3.2.1). Thus, the only operator that can be applied to an array declared with storage-class specifier register is sizeof. p. 109 &gt; An object that is accessed through a restrict-qualified pointer has a special association with that pointer. This association, defined in 6.7.3.1 below, requires that all accesses to that object use, directly or indirectly, the value of that particular pointer.115) The intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior). P. 118 &gt; 2) The only storage-class specifier that shall occur in a parameter declaration is register. p. 135 &gt; 3) The declaration part of a for statement shall only declare identifiers for objects having storage class auto or register. p. 492 &gt; An lvalue having array type is converted to a pointer to the initial element of the array, and the array object has register storage class (6.3.2.1). p. 507 &gt; ### J.3.8 Hints &gt;1 — The extent to which suggestions made by using the register storage-class specifier are effective (6.7.1). --- Although the `register` keyword does prevent taking the address of a variable, it is still only a hint to the compiler for storage allocation, which the compiler is free to ignore (other than adding the constraint of preventing taking the variable's memory address). In my experience, all of the modern compilers I have worked with on modern architectures are much better at optimizing than the average developer, and I discourage the use of the `register` keyword. However, I have worked with some special architectures (*i.e.* embedded systems) where the compiler didn't do a good job of optimizing, and the `register` keyword did make a difference.
I don't know of such a function, but you could do it pretty easily with bit shifting and andling the least significant bit with 1. Push it onto a stack and repeat. When you're done, the stack (let you design it) will hold the chars representing the number. You the join it, to produce the result. (I say stack, because that's how I did it when I had the same exercise.... except in my day it was asm, so a stack was handy) Looks like a fun project to enjoy doing :) I think the key is remembering that internally, these numbers are binary, just as you describe except that endianness can become an issue. Hope I was helpful. 
const means you can't change it. volatile means it might change itself, so you can't cache it. a register that says what line of the lcd you're on would be const volatile, by example.
The reference from p. 78 specifies that the operand of `&amp;` not have a register qualifier. In cases where an object's address isn't taken, a compiler will know that it may safely perform any optimizations that could be facilitated by the presence of the `register` keyword. The main situations where the keyword could tell the compiler something useful *that it doesn't already know* would be those where an object's address is exposed to the outside world, but the outside world won't use it outside the contexts where it is received. In the absence of a `register` qualifier, a compiler processing the first `test` above without knowledge of what `proc1` and `proc2` might do would be required to to update the value of `foo` in memory before each call to `proc2`, to allow for the possibility that `proc1` might store the address someplace that `proc2` could see it. If the `register` qualifier could allow the compiler to assume that the only place `foo` might be accessed outside the control of `test()` would be within the invocations of `proc1` and `proc3`, then a compiler could either keep `foo` in a register or else reload it each loop but not bother updating the storage. 
This. It's constant for your code but hardware can change value of that memory location. For example memory mapped IO which can be changed from hardware so you should read the memory every time instead of relying on the value in CPU register.
good stuff! I dunno if it's applicable, but the macro where there's a list of strings in hnb-api.h, and the macro paired with it which records the size of the list, caught my eye one thing that's common where you have a list of strings as a initialiser list, is to assign the value NULL to the final element, #define LIST { "abc", "def", NULL } this allows the program to compute the length of the initialiser, so the length doesn't have to be recorded alongside it, extern char *list[]; int len; for (len = 0; list[len] != NULL; len++) ; length can also be computed as a constant expression so it can be used for sizing arrays and such, but there's a few cases which *can* make that trickier, for example when the array is defined externally as in the above example. but for an internal definition, it can work wonders, char *list[] = LIST; int len; len = (sizeof list / sizeof *list) - 1; /* subtract 1 to omit NULL element */ you can even leave out the NULL element from the initialiser list with this approach. hope that's relevant and helpful to ya, hehe
those headers are looking much tighter :D
Each character in a hex string converts to four binary digits (a1 = 1010 0001. You wind up converting to binary one hex digit at a time, rather than converting decimal to binary. There is a printf specifier to print an int as hex. Once you have a hex string you can build a binary string with a switch case and strcat inside a for loop. It's in not the best way to do it, but it's easier for beginners to wrap their head around if their class was light on bit twiddling.
Is there a function called [srtchr](https://en.cppreference.com/w/cpp/string/byte/strchr)?
It's in &lt;string.h&gt;, no?
strchr is. srtchr isn't.
You misspelled `strchr` as `srtchr`.
Egg ----&gt; my face Thanks!
Egg ----&gt; my face Thanks!
This is meme worthy, OP.
Yep..
 } else { node-&gt;next = Add(node-&gt;next, val); return node; } Why are you doing that? 
You are reusing and overwriting the same buffer in each `fgets`, and then directly insert this single buffer into your list, therefore you inevitably end up with each element containing the last chunk of data that you added to the list ("jenny" in your case). Additionally, as you are declaring the buffer as a local variable in `RunCmd`, it is allocated as part of `RunCmd`s stack frame and goes out of scope when `RunCmd` returns. Subsequently your accesses to the address of the buffer (`0xee37b4d0` in your example output) exhibit undefined behavior according to the C standard, and you are lucky that the memory that was used for the buffer in `RunCmd` has not been reused when you iterate through your list after calling `RunCmd`.
These are the sort of interview questions which are red flags for me... they don't really demonstrate anything useful, other than if the interviewee knows C esoterica, which doesn't demonstrate anything terribly useful. 
I might have read a different semantic from your post, and so I felt the need to clarify. Regardless, glad to see we're in agreement.
The control char NUL has hex 00, and the char '0' has hex 30. So when you say "Control characters are ascii-alphabet symbols...", they in fact are not as 0000 0000 =/= 0011 0000.
&gt; node = malloc(sizeof(struct Result\*)); I may be wrong. But I think this is might be one issue with your code. You might be mallocing the wrong amount of bytes. I think you should malloc `sizeof(struct Result)` and not `sizeof(struct Result*)`
* What happens when you call `trianglular` with `n &lt;= 0`? Formulated differently: what is the definition for T_0? * What happens when you call `lucas` with `n &lt;= 1`? Formulated differently: what is the definition for L_(-1)?
I think instead of iterating to find the last node, OP is using recursion. It is slightly unreadable and would definitely affect performance for a larger list. (Maybe stack overflow if the compiler doesn't optimize). But that isn't causing the error.
would you be more descriptive ?
Trianglular n&lt;=0, calculate fonctuion not working Lucas n&lt;=1, not working at all
I don't see Linux going through a C++ rewrite anytime soon ;)
That was not what I meant... What does your implementation do if I call `triangular(-1)`?
Came here thinking "oh, great, another stupid question in C_programming". Left having learned something new.
Your code will simply not compile properly, since the function declaration for calculate is borked. int calculate(int n; int n) doesnt work, you should only have 
Just read it dude, its a book. And if using non-standard libraries is suspicious then the whole universe is. 
That's just shift and mask done badly. You might as well use a lookup table and shift 4 or 8 bits at a time.
No experience with that book, but K&amp;R is undoubtedly the best place to start. See the "RESOURCES" section of the sidebar. You aren't going to get any better suggestions than those. I'm finding "Modern C" (Jens Gustedt) fantastic as a second book. Bonus, it's free!
Oh, I know, I know! It goes into an infinite recursion loop!
&gt; ~~exhibit~~ invoke undefined behavior FTFY
I just assumed a C textbook would want to focus on portability.
Thanks, I didn't notice that section and it's exactly what I was looking for. 
Not really. And conio.h is mostly input and output so its not like they used a gigantic black box that you can't understand. Just use the equivalent I/O functions for your system, which probably is Windows anyways haha.
It demonstrates deep knowledge of the type system. I'm not even sure it qualifies as esoteric. If they asked you to explain duff's device, I guess you'd have a problem with that too?
\&gt;It's not the best way to do it, but it's easier for beginners to wrap their head around if their class was light on bit twiddling.
My problem with the ternary operator i that people that since it doesn't look like control logic (if/else) people assume it doesn't branch. That said, there are times that you really just don't wanna deal with yet another level of control logic, in which cae, yeah I'll use a ternary operator. a good example in in my logger, where it's deciding whether to print Error or Test, I'll use a ternary operator there in the function call instead of duplicating the log template yet another two times.
Except volatile isn't a type. It's a qualifier. Actually, having someone *explain* how Duff's device behaves would be a useful interview question. But, I rarely interview for specific languages... I want to see problem solving skills. Once I've determined someone is proficient in a specific language, which is easy enough to determine just using short snippets of code that do common operations and replacing the function name with "foo" and asking "What is 'foo' designed to do?" Or doing the opposite, supply a function declaration and asking for an implementation. 
`conio.h` is a DOS or Windows console accessor. On the subject of affordability of books: laypersons assume that older computer books are usually worthless, so if you can find them, they're cheap. And most C today is C99, with a fair amount of C89/90 for portability. I still haven't stumbled on a Petzold 5th edition (1998, probably still in print though) and I just know there are unused copies around. At the same time, my large local new-bookstore has something like a dozen C books, and a bit more than that for C++. 
Nah, but you see it sometimes in well supported opensource software, for example snort
My actual lead is to do this in my header file : struct s_parse { char *printout; size_t content_size; void (*setter) (void*, char **, int); int type; size_t line_offset; }; struct s_parse_shape s_parse[2] = { {"Sphere : ", sizeof(t_sphere), &amp;sphere_set, SPHERE, 5}, {"Cone : ", sizeof(t_cone), &amp;cone_set, CONE, 6} }; &amp;#x200B;
A nudge in the right direction would be to think about how you invoke qsort.
And I disagree.
I originally mentioned two ways you might go about creating your own function. One route didn't involve bit shifting and masking (option A, which I know is a dumb way to go about it). The other route specifically mentioned bit shifting and masking. The reason I gave two different ideas of how to do it is because it read like a homework/final problem. Even if OP came up with a terribly inefficient way to do it based on option A, they still solved the problem. 
Visual Studio also supports C and C++.
I get that VS can compile C and C++, but does it auto-generate logic for controls? Like if I added a button to a dialog, would VS plop logic into my Main, where I could just add my desired function to occur on button press?
There are visual c++ libraries (MFC and WinForms) built on/above win32 that handle that. I don't know what you are extending, but your constraints probably wouldn't let you use them. 
I dont use qsort
Auto generated code is cancer. Window editors suck in Java, I cant imagine how hard they are gonna suck on C.
Personally, over the years I have come to believe that one variable declaration statement per line is best. It simplifies refactoring and documentation. 
One variable per line and grouped into semantical groups. Each semantical group is separated by an space. int xposition; int yposition; int speed; &amp;#x200B;
Thanks - I don’t know for sure, but it wouldn’t surprise me as the dev explicitly suggested C and Win32.
What you learned something new?
C is much easier than C++. And I work with both daily. In C for example I don’t have to decipher cryptic error messages, things like call to implicitly deletes constructor. So much of C++’s behavior is implicit, with C I know what’s happening and I can reason with any bug or crash and fix it. In C++ I don’t have that luxury unless I limit myself to a subset of it, at which point why use it? That said I love Qt.
it doesn't matter 
my parents don't let me use scissors
I'm gonna second this one. My personal coding standard mostly follows the Barr Group's coding standard for embedded C, and one declaration per line is one of the rules. One of the immediate benefits is that when I hover over a variable name, Eclipse shows me only that one declaration (with its comment) and not a whole list. My other big rule for variable declarations is that any variable that holds a value in units that aren't given in the name always has the units in a comment at the declaration.
use C to tear down the windows api and bend the operating system to your will windows is the grime, C is the lemon. remember that simple guideline &amp; it's smoov sailing :D 
did ya smash all the exercises?
Blink an LED.
most of them
well pick that sledgehammer back up and get a workin I wanna see nothing but dust when you're done, ya hear me? ;-)
Have you just focused on the language itself or have you played with any interesting libraries or developed anything of practical use?
Only the language, i don't know what to do next
Do a project. Something not too small but not impossibly large. Maybe write a shell?
This guy embedd’s..
I don't know what Pelles C does, but the Windows API includes a simple dialog manager. The Windows dialog manager will do basic dialog UI, including focus handling. It's possible to "roll your own" dialogs, in which case you have to implement all that focus stuff yourself. If Pelles is generating standard Windows dialogs and your UI isn't weird, you shouldn't have to do too much work to get your dialog to work right. You might just have problems with control styles. &amp;#x200B; I know Visual Studio includes support for these standard Windows dialogs. The VS dialog editor creates the dialog template in the app's resource file. &amp;#x200B; There are modal and modeless dialogs in Windows. DialogBox() API creates a modal dialog, and handles the UI for you. CreateDialog() API creates a modeless dialog, and you need to use IsDialogMessage() in your event loop to implement the standard UI. &amp;#x200B; If Pelles is not using a standard Windows dialog manager, but uses Windows built-in controls in a regular window, then you will have to implement some focus logic yourself in the event loop.
Yeah I'm not using those macros anywhere (yet) but the idea was to use them to check the data or just let the user know what to expect. Anyways, cool technique, thanks! A list variant of '\0' terminated strings :)
The Advent of Code is going on. Good for practicing C. 
i want to use it in real world applications...
The fact that you have a `cone_set` and a `sphere_set` indicates that you need some kind of polymorphism. This construct does not map well to C. Are your two `setter`s that much different;;; Based on your code, I guess you could define a `parse_radial_shape` function that would get all the required parameters(type, offsets e.t.c.) and perform the generic task without having to call a shape specific `setter`. If the setters are **that** different then you could pass them as function pointers to the function. I hope this gives you a new perspective.
You ask advice about what next, people suggest stuff and you want real world applications. Lol wut? You need a problem that requires solving first.
But turbo-c on my 5160 uses more than that.
File a pull request with details. 
i'm not a native english speaker so i cant express my self very well in this language, what i meant that what is the real world applications that i can use C with it , i don't need another home work i already done that
Learn Rust ;D
Do you have anything low level or embedded that you're interested in, or something that you'd like to automate?
Submit patches to Linux kernel
unfortunately not, it seems that these days the only use of C is Linux Kernel and embedded Systems
Learn python...
I like this, when it fits the situation static Atom wm_state, wm_protocols, wm_delete_window;
Thanks! I was able to fix it by allocating the size of the val to the node val and using strcpy. node-&gt;val = malloc(sizeof(val)); strcpy(node-&gt;val, val);
Find an interesting project and do it. Or contribute to some real-world open source projects.
I’d rather take a tour through my own butthole dood
Try this one [http://www.apuebook.com/](http://www.apuebook.com/apue3e.html)
0: Write lots of programs 1: Learn from your mistakes 3: Goto 0
Study Verilog and FPGAs 
Your scanning specifications are for strings when you want them to be numbers. You should turn on all warning options on your compiler. 
Move to an Object Oriented language like C++ or Java
&gt;The two passes are preceded by a preprocessor, that handles the #define and #include statements, and related features (e.g., #ifdef, etc.). It is a nearly machine independent program, and will not be further discussed here. I would love to see how they handle preprocessing. It is a core part of the language after all. Macro expansion is a beast of its own.
Want to learn programing from a more mathematical perspective, with type checking, lambda calculus, polymorphic functions (therefore writing less code) and other goodies? Go functional - &gt; Haskell. But beware that it may be a hell of a ride because it is a completely different paradigm. 
I arrange variables logically, grouping together those, that are somewhat connected to each other, if using a struct is not feasible. In case of variables that are not logically connected, I declare them in a single line as much as fits in ~78 column boundary. For example: ``` int pos_x, pos_y, pos_z; int idx, next; int err; ``` 
Well, you're right that it's *type* qualifier, which is part of the type system. 
Your data types in the structure are all character arrays but for then you treat **number** as a number. sum = sum + cars[i].number; is not adding the "value" captured in the character array, it is adding the memory address of the **number** array itself to sum, that is why it appears to be random. Look up various conversion functions like **atoi**.
This article makes several major errors. 1. Overflowing a signed integers is undefined behavior. The example *might* turn into an infinite loop with that value wrapping around two's complement. It might print numbers above 127. It might not print anything at all. The program is meaningless because wrapping around as described in the article is not what's specified by the standard. The last example on the page will not reliably reveal `INT_MAX`. 2. Adding dummy loops is a terrible way to slow down a program. Under even the lowest optimization settings your compiler will eliminate those loops. The only reliable way to slow down your program is to reach out to the host system and ask it to pause your program for a time (`sleep()`, etc.). 3. `char` is not always signed. The standard leaves it up to the implementation. On some systems, like ARM64, the ABI says that `char` is unsigned, so if you wanted it signed you need to say `signed char`. 4. `char` is not necessarily 8 bits. It's only guaranteed to be *at least* 8 bits. This is issue is only a technicality since there no longer exists hardware where this isn't the case. 5. Signed integers aren't necessarily represented using two's complement. Again, this is only a technicality since there no longer exists hardware that doesn't use two's complement. 
This almost sounds like you're we're heading towards [Greenspun's 10th Rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule) &gt;Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp. 
**Greenspun's tenth rule** Greenspun's tenth rule of programming is an aphorism in computer programming and especially programming language circles that states: Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
OK, where shall we start? * Omits any declaration for `printf` or any inclusion of `&lt;stdio.h&gt;`. * Assumes `char` is signed and is 8-bit (though thankfully it does say this is "usually" the case). * Assumes signed integers are represented in 2's complement, but calls the lower bits the "magnitude", which could confuse readers into thinking of a sign-magnitude representation for them. * Exploits signed-integer overflow, which yields undefined behaviour. * Uses a "slow-down loop", which will be trivially elided by any optimising compiler. * Omits the semicolon after this slow-down loop. * Claims that the range of a 16-bit signed integer is [-65536, 65535].
The sticky is there to explain to you how to do that.
It's available, for example in [http://www.nordier.com/v7x86/download.html](http://www.nordier.com/v7x86/download.html), cpp.c begins with /* UNIX V7 source code: see /COPYRIGHT or www.tuhs.org for details. */ # # include "stdio.h" /* C command /* written by John F. Reiser /* July/August 1978 */ Grinning madly
https://www.lysator.liu.se/c/pikestyle.html In particular: &gt; Ah, variable names. Length is not a virtue in a name; clarity of expression is. 
[Project based tutorials in C](https://github.com/rby90/Project-Based-Tutorials-in-C) [A tutorial on pointers and arrays in C](http://pw1.netcom.com/~tjensen/ptr/) [Lets Build A Simple Database](https://github.com/cstack/db_tutorial) Also Learn to build the various data structures in C that you get for free with Python like Queue, Stack, single, double and toroidal linked lists, dictionary/hash, b-tree, closures, etc.
I see what you did there, haha
Earn money programming in C
Your program (which, btw, does not compile if I just copy-paste it) prints only numbers which contain `c` as the last digit, because that's the only digit you're looking at in the for-loop. Here's a hint: if you divide a number by 10 you will get all of its decimal digits but the last.
This is not quite correct, `malloc(sizeof(val))` will always return the amount of bytes required to store a single pointer, which does not relate to the length of the string you wish to copy. You should be using `malloc(strlen(val))` in this example. Another option is to use `strdup` (needs `#include &lt;string.h&gt;`), which does the malloc for you. Note that you should only use `strcpy`, `strdup`, etc. when you're certain that your strings are well-formed, i.e. they have a trailing `\0` byte. Additionally, `strcpy` has no internal checks that the destination buffer is big enough -- how could it, seeing as pointers don't carry any further metadata in C -- and thus many people recommend to use `strncpy` instead. Note that `strncpy` is not fool-proof either, as it does not ensure that the destination buffer holds a well-formed string in all cases.
I wrote a simple hash table like this for a class project a while ago. You may be able to learn something from reading it. The source is on github at https://github.com/pbackus/hash/.
Yeah it misses } after return 0;. However, I'm not sure where to add i=i/10. If after last printf I add 'else i=i/10;' it returns nothing, that new i doesn't just lose its last digit and calculate for new last digit, it just stops working.
 b = i; do { } while (b /= 10); &amp;#x200B;
Well, that depends on you, you can make video games, create a new program to solve an issue, or a new way to use your computer. There are many ideas out there.
If your compiler isn't complaining about this, turn on warnings (compile with `-Wall -Wextra` for gcc and clang) and pay attention to them.
What concept? Hash tables in general, collision resolution via chaining, linked lists, etc.?
so the problem is the compiler? or the code? The code works without the while, so what's the problem?
Your obfuscation-tricks.txt made me chuckle... The force is strong in this one.
Very much with the code. Your compiler will let you know about one major issue if you ask it to.
so where the code is wrong? i just need to get a second value from a txt file &amp;#x200B; the file has numbers 1 2 3 4 , i need to print the second number "2", if my code is wrong, where it is?
this is my solution : static inline void init_parse(int type, t_parse *config) { config-&gt;line_offset = 5; if (type == SPHERE) { config-&gt;content_size = sizeof(t_sphere); config-&gt;setter = &amp;sphere_set; } else if (type == PLANE) { config-&gt;content_size = sizeof(t_plane); config-&gt;setter = &amp;plane_set; } else if (type == CONE) { config-&gt;content_size = sizeof(t_cone); config-&gt;setter = &amp;cone_set; config-&gt;line_offset = 6; } else if (type == CYLINDER) { config-&gt;content_size = sizeof(t_cylinder); config-&gt;setter = &amp;cylinder_set; config-&gt;line_offset = 6; } else exit(0); } int parse_shape(char **greed, t_data *d, int i, int type) { t_list *node; t_obj obj; t_parse config; void *shape; i++; init_parse(type, &amp;config); if (!(shape = malloc(config.content_size))) malloc_error(d); config.setter(shape, greed, i); obj_set(&amp;obj, type, shape); if (!(node = ft_lstnew(&amp;obj, sizeof(t_obj)))) malloc_error(d); ft_lstadd(&amp;d-&gt;lst_obj, node); i += config.line_offset; return (i); } &amp;#x200B;
Turn the warnings on in your compiler, like raevnos suggested, and it will tell you where things are probably wrong.
Use warnings. Better to learn how to use your tools to help you debug a problem than just get spoon-fed an answer.
i did it and there are no errors, so what's the problem with the code?
clang, valgrind and scan-build catch the error, but gcc 6.4.0 does not bother to warn about it, even with -Wextra.
i don't want to learn, i just need it to work
what error?
Then why are you bothering to do this at all? This is clearly some kind of homework problem where the goal is for you to learn.
Your compiler should warn you about this. In any case, you can debug the program and see the problem pretty easily: $ cat tmp.c #include &lt;stdio.h&gt; int main() { FILE *file; file = fopen("a.txt", "r"); int a; int b; while (b&lt;2) // i need the second number, that's why i put 2 { fscanf (file, "%d" ,&amp;a); b=b+1; } fclose (file); printf( "%d",a); return 0; } $ gcc -ggdb tmp.c $ gdb ./a.out Reading symbols from ./a.out...done. (gdb) break main Breakpoint 1 at 0x772: file tmp.c, line 3. (gdb) r Starting program: /home/erin/tmp/a.out Breakpoint 1, main () at tmp.c:3 3 { (gdb) n 5 file = fopen("a.txt", "r"); (gdb) 8 while (b&lt;2) // i need the second number, that's why i put 2 (gdb) print b $1 = 21845 Do you see what I did? Do you understand the problem now?
it's not a homework, but a personal work, i never had a teacher, and is very difficult to learn without code examples, somebody could already give me the answer, but no, there is no fun in that
Respect people's time. Most of the people here answer questions because they want to help others to learn. They don't want to solve other people's problems for free. If you don't come in with the intention to learn then no one will help you.
If you've tried to compile with the flags suggested by [raevnos](https://www.reddit.com/user/raevnos) you would've known that b is uninitialised, change "int b;" to "int b = 0;". But I strongly suggest reading some book, because you won't get far in C by blindly trying things without understanding how they really work.
no i don't understand these warnings
What is the value of your `b` variable at the top of the while loop?
TCC supposedly uses 100kb of memory. Magic. [https://bellard.org/tcc/](https://bellard.org/tcc/)
Interestingly enough gcc (I've checked 5.4, 6.2, 7.4 and 8.2 on gcc.godbolt.org) does complain about it with `-Wall` and any optimization level higher than `-O0`.
great, now i understand it, finally someone answered, thanks a lot my friend
it's working now!
yes now i know, i should put b=0. thanks for your time 
This is not a support site for C. We are not obliged to give you any help. Either accept our methods or find something else, for example you can pay someone to do your job. "I never had a teacher" is not an excuse justifying your claims. 
Solve real life problems with C programs... Thats the whole point of programming, solving real life problems, not doing exercises.
Ugh, my bad, I left out -O.
What is wrong with this one? Why it doesn't just take i and check for digit? When I enter n and c it does not work at all. int main() { int n,c,i,b; do{ printf("n="); scanf("%d",&amp;n); printf("c="); scanf("%d",&amp;c); }while(n&lt;1 || c&lt;1 || c&gt;=10); for(i=1;i&lt;=n;i++){ while(i&gt;0){ b=i%10; i=i/10; if (b==c){ printf("%d",i);} } } return 0; } 
 just expressing it how I learned it. Can you show me an easier way for the same results?
Macro expansion though is extremely simple, since it's essentially just copy and paste.
Thank you I will have a look at it
You can't go changing i that way, it's your outer loop variable. Make a copy in b and check with % until b whittles down to nothing.
Linked lists but I'm not sure. Can I send you the problem in PM ?
Check this link(https://gcc.gnu.org/onlinedocs/cppinternals/Macro-Expansion.html) to get a glimpse of how complicated it can get. For one, take MSVC which has gotten it wrong for years. Recently they are trying to make it compliant(https://blogs.msdn.microsoft.com/vcblog/2018/07/06/msvc-preprocessor-progress-towards-conformance/).
Sorry if I'm asking dumb questions, I'm beginner at C but we've been given this task in our first course and I can't find anything similar online. for(i=1;i&lt;=n;i++){ b=i; while(b&gt;0){ d=b%10; if (d==c) printf("%d ",b); b=b/10; }} Now it prints out numbers, but like this: 5 15 25 35 45 5 5 5 5 5 55 5 5 5 5 5. Not really sure why it loses last digit.
Thanks, will do
b has been fouled in the process, don't print that. 
I fixed it, it needs to print i. The problem now is that it prints 55 twice 
That's no problem at all, just break the loop on match. There is another problem, it doesn't handle 0. That's why I suggested do () while.
Its numbers&gt;0 so program is working now. Thank you a lot, I really appreciate your help.
At your service :)
That's not really complicated, when compared to a lot of other things compilers do. Complicated to use correctly, sure, there's a reason Boost Preprocessor has tens of thousands of pre-expanded macros. Compared to everything else a compiler does, the preprocessor adds complexity but it's not really that fundamentally complex. Fundamentally, it finds a pattern from a string, and replaces that with another token. There's no sanitization, there's no tolerance for whitespace, etc. And MSVC has historically always been non-compliant, so it really doesn't surprise me.
pay someone to just add "=0" to an asnwer? that was the answer to my question, now it's solved, thanks to another member
` `
Nothing is returned from a void function.
Nothing is returned but using the pointers it loads the values into those arrays right?
Nothing is returned but using the pointers it loads those values into the array its referencing right?
1/ptrData-&gt;induc\*ptrData-&gt;capac is for 1/LC ? Needs to be 1 / (...) if so.
Without knowing the inputs, its hard to know. If there is even a single `nan` produced by any one of those expressions, thats all you will get. To help debug it, i would put each single expression in a variable and print it, that way you would know exactly where a `nan` was produced. Without looking to hard i would suspect a `0.0/0.0`. 
Add `printf()`s to your code, or use a debugger to set a breakpoint at the start of the function and single-step through it. Even better, write unit tests. And try to find better variable names than `ptrData`: the `ptr` part is redundant, and `Data` is meaningless. I would also recommend using simply `t` for `currentTime` and `Q` for `holderCharge`. Anyone reading your code should be familiar with those abbreviations, so there is no need to waste electrons and neurons spelling them out. Finally, put spaces around every assignment, arithmetic, comparison, or boolean operator.
Correct.
I think they're saying that its not working for all values.
Try maling all your literals floats maybe" -1 to -1.0, 2 to 2.0, etc
ok I obviously cant even format the code...
It's not the first time you are disrespectful towards people helping you. It is also not the first time you are coming here with a trivial problem. If - as you say - that's for your job, not homework, we are not here to do work for you. Start learning C instead of coming back every week or so, demanding help.
So in this day and age you can not write 5 lines of code and try to compile it to test it yourself? You instead have to post here and wait 4 minutes for my irrelevant comment to be posted?
You can write `swap(*i, *j)` if and only if `i` and `j` are declared or defined as `int **` (pointer to pointer to `int`) so that `*i` and `*j` have type `int *` as expected by `swap()`. If `i` and `j` are plain `int`s and your compiler does not give you a warning or error, you need a better compiler — but start by turning on warnings; your program isn't done until it works *and* compiles without warnings, and sometimes not even then.
What computer stuff seems cool to you? 
I ask A you answer B, because B i the way to understand A but i don't need B, i just need A, see? So why not just answer A? I remember you, last time i asked a simple thing, it was solved with 5 lines of code, and you gave me a super complicated shell script with more than 30 lines, and including other concepts that i would never use. I read all the C tutorial from tutorialspoint, and it don't explain how to debug code. I'm sure that you asked trivial questions at university and someone explained to you, showing the code
I assume the structures were given to you. If so, it looks like they want you to use what is called [separate chaining](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining). This means that if there is a collision, you create a new `struct pair` and connect it to the existing entry using the `next` pointer. It will look a little like this: uint32_t hkey = hash(/* new key */); if (table-&gt;data[hkey].value != NULL) { if (table-&gt;data[hkey].key /* equals new key */) { /* same key, either update the value or do nothing */ } else { struct pair *ndata = calloc(sizeof *ndata); ndata-&gt;hkey = hkey; ndata.key = /* new key */; ndata.value = /* new value */; /* this is almost but not quite insert-at-head */ ndata.next = table-&gt;data[hkey].next; table-&gt;data[hkey].next = ndata; } } Note that my code contains deliberate errors / simplifications which you will have to find and fix.
&gt; Assumes char is signed and is 8-bit (though thankfully it does say this is "usually" the case). The most widely used general-purpose processor in the world has unsigned `char`.
&gt; I don't need another home work i already done that If you only just finished K&amp;R, you've barely started to learn C. The Advent of Code is excellent practice. But if you absolutely must move on to “real world applications”, take a look at [https://up-for-grabs.net/#/tags/c](Up For Grabs).
...and most of the GNU userland, plus {Free,Net,Open}BSD, Xorg, Wayland, Gnome, and thousands of other F/OSS applications.
Fallthrough is a killer in C. 
The next thing you do is to start solving your problems with C as your tool, or start working on a project you've been thinking about for a long time, or take someone else's code and improve it, or write code to test your own assumptions. 
We would say the second is slightly "more idiomatic" in C. In this particular case, the second one is just as clear as the first because the variables are named very well. Also the second one has the advantage of being shorter, which means more code on the screen at once, which can be a big help in being able to understand the code. However, this is just one example. Current practice is to declare variables as close as possible to the location where they're used. This is, I believe, slightly wrong in C89, so when compiling `-std=c89` you can't also compile `-Wpedantic` or you get ` error: ISO C90 forbids mixed declarations and code [-Werror=declaration-after-statement]`. Your example is arguably one where comments have been misused, as the variable names already tell us their purpose, and your comments haven't told us Why. 
Test test test. I agree 100%. These guys are going to get to their first job, ask a question like this and be looking for a new job shortly. OP will learn so much more using printf(), gdb, and experimenting. 
&gt; I ask A &gt; you answer B, because B i the way to understand A &gt; but i don't need B, i just need A, see? So why not just answer A? You asked A, we told you what to do to achieve A. You responded with "I had no teacher, this is not a homework, just do this for me". It's not rocket science. We are showing you how you can help yourself, so next time instead of going to Reddit, you can solve the problem. &gt; I remember you, last time i asked a simple thing, it was solved with 5 lines of code, and you &gt; gave me a super complicated shell script with more than 30 lines, and including other concepts &gt; that i would never use. No, I gave you a working program, that did exactly what you wanted. Then you said it does not compile, without telling us what compilation error you got, so I've pasted entire shell session listing that showed the program does compile and work. You - for some reason - assumed it's a shell script, called me a troll and posted your solution, that had flaws. &gt; I read all the C tutorial from tutorialspoint, and it don't explain how to debug code. I'm sure &gt; that you asked trivial questions at university and someone explained to you, showing the code No, when I had a problem, all I got was a hint what I should look for or what to do to debug it. The rest was up to me - finding information (books, manuals), experimenting, debugging and fixing. Next time I had a problem, I knew what to do and didn't have to ask for help. In programming, you have to know how to analyze problems and find solutions by yourself. Trust me, I'm not trolling you.
There are many opinions on this. My advice is to find an existing well-documented style (although I would not advise picking the GNU or LLVM ones, which are awful) and stick to it. Personally, I prefer the FreeBSD's [`style(9)`](https://www.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9), which is a modernized [KNF](https://en.wikipedia.org/wiki/Kernel_Normal_Form). I'm not sure if the man page answers your question, but most BSD code uses Version A.
You can trivially spoof MAC addresses.
yes but you had a teacher right in front of you, i don't have one, the only way is asking on forums
Ah, OK. Then that's not even an option.
hmmn. That sounds like a good option, I didn't consider this. Is this how bigger programs like photoshop/word do it?
Can we see the actual code (and not as an image, please) and the warnings?
It's how Windows has historically done it. Basically. I have also done this, not to tie an install with a key to a specific piece of hardware, but to definitively identify a client machine. Granted, they could *still* modify network packets. But, there's a fair amount of reverse engineering to do that.
You're making it pretty difficult to help by not providing the actual code. However if your intention is to have a double pointer and not a triple pointer that could be the issue. Here's a pointer (unintended pun); variable[] is the same as *variable.
OK, so first, this sub is for C, not C++. Your code also happens to be C, not C++, but I'd like to make sure that you're compiling it as C and not C++, because while many C programs can be compiled as C++ without modifications, there are subtle differences. Second, we need more information than “it just doesn't work”. How are you trying to run it, and what happens when you do?
Its an array of pointer to pointers as far as my understanding goes.
We are your teachers then. But you are not interested in learning. You are interested in getting solution on a silver plate. People here gave you an excellent advise - turn on compiler warnings, let it tell you what is wrong and fix it. If you don't understand what compiler says, ask (but please, paste the warning and error messages instead of just telling us "it does not compile"; we can't see your screen). Try things people tell you to try and very soon you won't be needing anyone's help. Learn to use your tools, especially a debugger. If `gdb` is too intimidating (it can be), take a look at Nemiver, Kdbg or see what your IDE can do (if you are using one... if not, I recommend Kdevelop or Eclipse with C/C++ mod if you have lots, lots of RAM). Anyway, `-Wall -Wextra -pedantic -pedantic-errors` are a must have compiler flags when developing programs in C. They can point out trivial errors as well as problems that are difficult to notice. Valgrind will tell you where are potential problems with memory management, but its output can be hard to read (there are some good tutorials on the Internet).
I see. That helps a lot, gives me a starting point to learn from. let us say I go the identity machine via some unique serial number. Without having some sort of server, I would still need to have a trusted person go over to the computer, run some install files that spit out an executable that will only run on that machine, right? or if I do end up using a server, I can have an installer that will require a login, if it passes then the installer can spit out a machine unique executable. 
Yes, you can "sign" the executable using some unique hardware information.
You need a license manager. There are both commercial and free solutions. Here's the [top Google hit](https://github.com/open-license-manager/open-license-manager).
ok thanks for the tips 
I understand. This helps a bunch, thanks!
Awesome! I had no clue what to even google for haha. I will look into this more, thanks!
Breaking that long expression into smaller ones would still work. He could even call `isnan` on each of them.
it's like, "I spent all those years learning to program computers just so I could use these skills to pacify some dude's paranoia complex" sad scene, man
You'll probably want to learn how to google before trying to learn how to program...
word. haha. though to be fair, it is a useful enough tool that if it was me using it, I would honestly save it on the cloud in case I wanted to use it again.... so I kinda understand. 
I didn't post code as I thought it might have been normal behavior and the explanation was simple. https://pastebin.com/zt9kQ84Y
I didn't post code as I thought it might have been normal behavior and the explanation was simple. https://pastebin.com/zt9kQ84Y https://imgur.com/a/mnqlIjJ
Just a single separate thread for generating the image is more than enough. To have a separate thread for each raindrop would be needlessly complex. If you insist on doing that, you’re pretty much on your own. I’m not saying it can’t be done, but that kind of data structure isn’t suitable for multithreading, and the robust infrastructure needed to support that type of mechanism would likely be slower than if it was done all on a single thread. 
Good stuff. Thanks for posting this.
As someone who has spent a lot of time both writing and reverse-engineering software, I can confidently say that--assuming your end users have access to the binary and/or can control the execution environment in which your program will run (that is, the app is not cloud-based or otherwise running on a computer solely under your control)--there is no 100% foolproof way to guarantee that your program can't be copied and run by an unauthorized user. The best you can do is to raise the difficulty bar for doing so. The downsides of adding copy protection to your application include pissing off legitimate users and adding cost/complexity to your application. For example, if you license against an exhaustive fingerprint of a user's computer, you run the risk of angering your users when their licenses are invalidated because they changed their fingerprints by upgrading RAM or swapping out the video card. Like any feature, you need to understand your customers and put some thought into the design of your licensing scheme. You also need to test the hell out of it. A great way to anger your users and/or lose sales is to have copy protection that introduces bugs into the program or simply doesn't work. If your license generation algorithm is buggy and you suddenly find that you can't generate valid licenses for a subset of your users, you might lose sales. Of course, all of that points to not rolling your own copy protection. Instead, to prevent casual copying (handing a copy to a friend/coworker or uploading to a warez site because it's trivial to do so), I'd recommend looking into 3rd party license managers as u/a4qbfb suggested. One of the industry standards is [FlexLM](https://www.flexera.com/products/software-monetization/flexnet-licensing.html). It's used by large commercial packages such as Solidworks and Matlab and it gives you lots of licensing options, including network licenses and hardware dongles; however, I'm not sure what the costs associated with it are--probably not cheap. You'll need to contact them for a quote. If you don't need the extensive license management features that FlexLM provides, you can probably find something more lightweight and less expensive. If you're trying to prevent a more determined attacker, you can start playing around with custom schemes that include encryption and anti-debugging tricks, but remember that this only makes it harder, not impossible to reverse-engineer--and it can be a huge time investment (or waste, depending upon your perspective). You can also look into watermarking your executables so that you can (theoretically) trace any piracy back to its origin. All of this adds significant development time and complexity to your application, which will increase your costs, slow your time to market, and make your QA more difficult. If I were in your shoes, I'd go back to the person in your company who came up with this requirement to clarify their goals and ensure that they understand the tradeoffs and costs associated with their ask. If they just want to prevent casual copying, then some sort of license management scheme could be a perfectly reasonable feature to add--assuming the costs associated with it are acceptable to your management. If they think they're going to prevent very determined users from stealing your software, then they need to understand the impossibility of that requirement and the conversation needs to pivot to how much your company is willing to invest to raise the bar to make it more difficult to reverse-engineer your software. Personally, I believe that--if piracy is a valid concern for your product--it's worth making a small investment in some lightweight copy-protection/license management. Then, make a larger investment in continued innovation so that the pirates need to continually play catch-up to get your latest/greatest features. Legitimate customers will happily pay for your software to avoid the hassle.
Unfortunately I am not employed by them, they are outsourcing this to me. I see what you are saying. Honestly I would much rather make the software as portable and simple as possible, but then this request came up. I will mention the draw backs to them and see what they would like. I don't have the luxury of extending the timeline either, so they may be forced to agree to a simple to implement/test (low bar) solution.
Dude. Spare them the lecture. If you spent a little less time typing reading and a little more time, you'd see it wasn't their idea in the first place.
&gt; Good stuff. Thanks for posting this. I do think this could be improved though. The disk and ethernet info it gathers isn't as good as getting serials from other devices, like the motherboard, for instance. Seriously, the best you can do is a token effort. VMs make *everything* moot. It's like the Master lock on your high school locker, all it does is keep honest people honest.
First, fix all your warnings.
That's fair. Even as a contractor/consultant, it's still your prerogative--and, I'd argue, your responsibility--to have the economic tradeoff conversation with them. First, ensure that they understand that it's impossible to have foolproof copy protection as long as you're distributing an executable. If they're okay with that, then they'll need you to quantify the impact of adding some sort of reasonable level of copy protection/licensing scheme. In your estimate, be sure to consider the development time, any licensing fees for 3rd party software, and plenty of testing time. Also ensure that they understand that they're going to need someone to manage the license generation/distribution moving forward.
std.io is already imported in main.c, so that can be ignored right? i don't know how to fix the game.c:2:16 warning.
Sure. I generally presume that someone is not running a business app. on a dedicated machine under a VM though. Which I presumed to be OP's case. But, your point is well taken.
No. No warnings can be ignored. Headers are not libraries. They are information about how to use libraries. They have to be included in every translation unit (i.e. C file) in which they are needed. That means `game.c` needs to include `&lt;stdio.h&gt;`, and preferably also `"game.h"`. The other warning is telling you *exactly* where the bug is and how to fix it.
What? I didn't think it was OP's idea. It was clear that the requirement came from someone else. I was not trying to lecture, but rather arm OP to have an informed conversation about the economics of the feature with the person who came up with the requirement.
The organization I work for has thousands of VMs. Most of our server applications run in VMs, and we provide virtual desktops for remote access, so most client applications can also run in VMs. And that's in normal operation, whereas here, we're talking about what an attacker might do. Some vendors use hardware tokens to track licenses, but guess what... we virtualise those as well. We have a few servers with tons of USB ports and special software that allow us to tie a physical USB port on that server to a virtual USB port on a VM somewhere else.
What operating system are you programming for? Is this a DOS application? A Win16 application? Or even a Win32 application?
It is a dos application, and I am programming in it through dosbox 
It is a dos application, and I am programming in it through dosbox 
even when rendering with opengl, and using multiple threads (likely for physics), you can only have a single thread actually hitting opengl... one solution is to have a set of render lists for each thread, however arbitrating access to the lists is... well more trouble than its worth...
If it's a DOS console application, it can't control the font. You'll have to play with your DOSBox settings. If it's a graphical application, you'll have to check the documentation for your GUI library. Borland never provided a GUI library for DOS, only for Windows (Borland OWL).
Then you should be able to load a different font using int 0x10, AH = 0x11. It's a bit involved to produce an appropriate font file though. You can't just load a ttf file, you have to make a bitmap font in the right format to be able to load it.
Also, sorry if this came off as a lecture. I didn't mean it to.
K.N. King's book might be the best introductory programming text I've read, period. Thorough, yet accessible to the novice. 
You can use several hardware specific IDs like serial numbers packaged together into a message. Then encrypt that message to send to a server using AES or similar that has rolling keys that is coded within the application. That way they can't just change the authentication message using wireshark or reverse engineer it. Having 2 way encryption should help with authentication. It's not fool proof but it's hardened enough to annoy the typical sw pirate.
there's a chapter on them with sample C code in both "The C Programming Language" &amp; "The Practice of Programming"
Web development, PHP, Apache, mysql or mariaDB, bootstrap. Then Apache modules in C. 
even as a "python person" you should be able to distinguish between C and C++ I suggest heading over to /r/cpp_questions/ on a side note: if you were stuck with C, SDL is just awsome. 
I would really like to avoid needing a server, as that would mean the application requires network access and the business has to worry about the server being up. here's what I am thinking, considering everyone's comments: Upon running, the program will check whether the machine serial number is correct, if yes then the program will work. If not, then the program will request a password, password will be hashed to prevent reverse engineering and finding it, if the password is correct then the new machine serial number is used. I can assume that the 1 person (or team) that knows the password is trusted, and it will be on them to distribute the program to different machines. would this be a good idea? the issues I see are that I would have to dynamically modify the serial number the program recognizes, which can be a vulnerability for those messing with the binary, right?
haha its fine. I didn't feel lectured lol. this is uncharted territory for me and your help/advice is very welcome and valued.
Cool. Good luck!
Hashing the password instead of storing it in plaintext inside your binary is a good idea. However, the downside of using a fixed password is that once it's leaked by one bad actor, then you no longer have protection. Instead, you might look into something like public key signing algorithms. A user could send you the serial number of their computer. If they're a legitimate customer, you could then sign the serial number and send back the signature. They would enter this into the program, which would verify the signature and run if it's valid. The advantage of this is that the signing key is kept private at your corporation. The application only contains the public "verification" key that cannot be used to sign. You could use something like [libsodium](https://github.com/jedisct1/libsodium) for the cryptography part. You can also safely store this signature in plaintext somewhere on the computer so that you can verify it every time the program launches. The signature is only good for the serial number of the computer it's running on (if the serial number is spoof-able, then you have other problems). Again, this scheme really only protects against casual copiers. If I was trying to crack your program, I'd simply disassemble it, find the places where it checks the serial number, and remove those checks altogether.
Hmmn. Alright I get a general idea, I'll have to mull some more over the implementation, but thanks, your advice helps. &amp;#x200B; So is there a way to protect against disassembly without needing a server? I can see code obfuscation can help, maybe also rooting the license check deep within the program (not just 1 check for example, but like a thread that checks and is refreshed by other processes ) &amp;#x200B; What's stopping me from disassembling photoshop and messing with the part that checks for product keys ?
There is absolutely nothing stopping you from disassembling photoshop and messing with the part that checks for license keys. It's been done. You can probably find cracking programs to patch out those checks online. Now Adobe has obfuscated their code and sprinkled licensing checks all throughout their programs--so it's harder to find them all and remove them. On top of this, they frequently release updates. Every time the binary changes with an update, the crack has to be redone since it is binary-specific (I'm speaking generally here, there have been some clever exceptions). So, it can be hard to find a crack for any specific version of Photoshop because you have to wait for someone to crack the exact version you're looking for and release the crack. Legitimate users don't have the patience for that, so they just pay for the app. That goes back to my previous comment about investing in continuous innovation. For someone skilled in the art of assembly, having your binary executable is almost as good as having the source code. You can make it more difficult to locate and disable all of your licensing checks by sprinkling them everywhere and mixing up their functionality so they don't all look the same. You can also use binary tools that encrypt or otherwise obfuscate the binary, but encrypted machine code has to be decrypted somewhere to run and obfuscated machine code simply takes longer to understand. You can employ lots of these techniques to make it a pain in the ass to crack your program, but never 100% uncrackable. And, the more anti-piracy tricks you throw in there, the more complicated your program becomes and the more likely you are to introduce a bug that impacts legitimate users.
If you want a simple game made by Christmas I’d argue that using C/C++ and a IDE would take you too long unless you’re knowledgable about game logic. Your best bet IMO is either Godot or Gamemaker; drag and drop visual interface, both have python-like scripting languages, plenty of documentation, and they’re free!
Don't listen to the people criticizing you for "lecturing". Your answer was fantastic, well thought out, and comprehensive. Saved me from writing up the exact same thing ;)
Some good advice already in this thread. Solve some problems that interest you, Read other people’s code for programs that interest you. Small programs and utilities like hex editors or any of the UNIX commands (grep) would make good initial choices. Make modifications to these programs and/or write your own version. Once you have some confidence using C move onto C++. Learn cmake so your programs can build on multiple platforms and a testing framework (google test or others). Then contribute to a project that interests you. 
It’s only bad if your learn nothing from it or it contains tons of errors. Lots of books contain code that is in some way non-portable. They can be tied to specific versions of packages or compiler versions. If the code in a book is directly useful that’s a bonus. It’s usually only there to demonstrate a concept. 
He’d be thinking MFC then as suggested above. Fair learning curve with MFC unless you can find existing code that does something close to what you want. If your project allows for C# then I would look into that before going down the MFC route. 
wrods are difficult to get right 
It’s a multi-dimensioned question. I work on projects that are ported to many operating systems each with different compilers and different levels of language support. K&amp;R C &amp; C++ 98 are pretty much good everywhere, C++ 11 support varies sometimes. C++ 17 is not yet everywhere on my target platforms. So on a portability level I may choose one or the other. If C++ lets me express the problem more concisely then I may go for that if what I need is on all platforms. If it’s simple to express in either I might go for C for maximum portability.. Depends on the problem being solved. 
There's lots of spelling errors in the book but the exercises themselves seem legit. 
Seems like a good pickup then 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
&gt; check whether the machine serial number is correct There is no machine serial number on modern x86 compatibles.
&gt; So is there a way to protect against disassembly without needing a server? Not really. If an attacker is smart enough to disassemble your program, the attacker is also smart enough to pass most hurdles you throw at him. There are automated tools to reverse many common obfuscation techniques these days so that doesn't really help. &gt; What's stopping me from disassembling photoshop and messing with the part that checks for product keys ? Nothing.
What kind of program are we talking about? What does it do? And how is it being used by the client? The most effective way to deal with unlicensed usage is to somehow make instances of the software check each other's work. For example, the popular disassembler IDA-Pro inserts licensing details into all project files it creates and refuses to open projects with wrong license data. So if your team uses IDA-Pro, you either have to buy licenses for the whole team or run entirely off hacked copies, making misuse easy to detect. For another example, there used to be an instant messenger which proved that it was legitimate by uploading a piece of its machine code to the server upon request. Other vendors could not build third party clients for the instant messenger because that would involve having to ship a copy of the original binary to upload bits and pieces of code if needed.
Nothing stops you from it, Adobe CS 5 did quite some hops as they also checked their own binaries on startup against tampering in a rather involved way, but I know that they made some quite bad mistake (that I cannot share) which allowed at least CS 5 to be easily cracked even without real changing the software. DRM is just "annoy user and cracker and hope that only the latter is stopped from using the program". Current games' DRM often create a small virtual machine, run code within it and additionally go online. Usually these are cracked within a year, at the latest. The best DRM that I know is of IDA -- they create a watermarked copy of the program for every customer and employ license keys. Every two years or so a version gets leaked but it's usually an older one and you know who would've distributed it.
"concern the company has is that someone will walk to a competitor with this program" This is the main concern ? I would think this would be handled best by a lawyer.
Only one thread can update the screen in ncurses. You don't need threads because you are "drawing" on a buffer, that is then "put on screen" with update. Randomize, calculate, draw at coordinates, update screen. 
i think that is what i'm going to do, i already use linux so it would be cool to see how all these tools work, thank you
What is the difference between: signed int typedef my_int; and int typedef signed my_int;
I have yet to find a good C tutorial on Youtube. If you really want to learn C : 1 Modern C by Jens Gustedt 2 The C Programming Language by Kernighan and Ritchie are your best options in my opinion. 
C Programming: A Modern Approach is up there with those as well.
Hi! I tried to generate the wav file, but the player cannot play it. Can someone explain how to generate it? Maybe I am doing smth wrong.
I would recommend this one: https://youtu.be/KJgsSFOSQv0 It’s very basic but it offers the basic knowledge you need to start learning and after that it’s up to you to expand your knowledge :) 
Awesome, thanks for the explanation. It sounds like Pelles does exactly what VS does, based on your description. The manual focus shift was a one-off - and could certainly be due to preceding errors on my part.
I'm having a hard time with programming books. I was looking for a more exercise based video series for C but couldn't find any. Thanks for the reply though! &amp;#x200B;
&gt;Could anyone post a recommendation for a video based C crash course? Preferably on Youtube. This is the only option I have right now. Will wait for more replies, thanks though!
Pick a specific C standard (e.g. `-std=c99`) and don't rely on the compiler's default. This not only helps you avoid non-standard extensions to the language, it will hide non-standard functions (POSIX, etc.) that otherwise become visible from standard C headers. The build will work a slightly differently between Windows and anywhere else, mostly at the linker step. On Windows, statically link GLEW and GLFW. (Even better, replace GLEW with an embeddable loader, specifically suited for the specific OpenGL standard and extensions you're using, generated by a loader generator like [glLoadGen](https://bitbucket.org/alfonse/glloadgen/wiki/Home), [glad](https://github.com/Dav1dde/glad), or [gl3w](https://github.com/skaslev/gl3w)).) If your code is clean and portable, relying fully on GLFW and an extension loader for interacting with the host, then you should be just fine. 
If you really want to learn how to code, you really need to read books. They should be your best friend. Maybe the reason you are having hard time with them is becose you did not find the one that suits you, the one that goes slowly enough and explaining every single step along the way. I also hate book which are written in such a way that you need to read one sentence five times and you still don't know what the writer meant to say. Book 1 that I recommended should be the one that works in those situations.
If you really want to learn how to code, you really need to read books. They should be your best friend. Maybe the reason you are having hard time with them is becose you did not find the one that suits you, the one that goes slowly enough and explaining every single step along the way. I also hate book which are written in such a way that you need to read one sentence five times and you still don't know what the writer meant to say. Book 1 that I recommended should be the one that works in those situations.
what other platforms are you targetting (mobile devices, etc?) I think if you can get a successful build on linux and windows, you will have good coverage as far as desktop usage goes. the things that are likely to vary between CPUs are byte order and sizes of the basic types, so try to make as few assumptions about those as possible for the basic character set it should be fairly safe to assume 8-bit chars and ASCII
I’m also skeptical about using non-interactive video as a means of learning programming languages in general. I only learn by really engaging with the material; by reading closely, questioning a lecturer, or just rolling up my sleeves and coding, compiling, linking, and running. But for the sake of discussion, what’s your previous programming background? How’s your grasp of discrete math and data structures and algorithms?
richard buckland from unsw is funny instructor has some good videos, they make toast in the lecture theatre in 1 episode lmao in terms of learning material, the stanford programming paradigms class where C is covered for a large portion is pretty good as others have said, for learning C, best bet's gonna be a book like k&amp;r2. and of course a text editor &amp; compiler to write and test your software hehe
I have tried K&amp;B, but I'm looking for a faster and more fluent way to learn C. After I do the course, I'll go back and read the books.
I have good understanding of data structures and algorithms. I know other programming languages. I just couldn't find a way to study the C programming language with videos. I was also thinking about going in a Code Academy kind of course, but couldn't find that either.
I would strongly prefer version A, but the comments are pointless (to me) because the information is already explained by the function names. Also I would group things that are of the same type (this might matter more in structs, which you might not have been shown yet). I would do something like this: `int title_size, title_color_hex;` `int indent_x,indent_y;` `unsigned char text_justification_enum;` &amp;#x200B; where the unsigned char type shouldn't be in between the int types. &amp;#x200B; 
Which languages?
Carl Herold’s C course is quite good but just don’t read up about him and his personal life if you still want to feel comfortable while watching it.
What is it that you want to learn? You're not going to "crash course" your way to learning a whole programming language, plus programming and debugging skill. If you want to climb a mountain, you must climb it. You won't wake up, one day, at the top.
Just wanted to mention that targeting C99 will probably get you into some troubles when moving to Windows and MSVC as C99 support is not that good. Of course there's MinGW and Clang which offer a far superior experience.
My bad, I searched C++ and this reddit came up! Thanks for the redirect!
Since VS2015 it's not *too* bad. You'll generally be fine if you don't use VLAs, the `restrict` keyword, or array qualifiers in parameters (e.g. `int foo(int a[static 10]);`).
No one has posted Jacob Sorber? Swear I heard about him from here. https://www.youtube.com/user/jms36086
Even though it is definitely not a crash course, I highly recommend Casey Muratori's Handmade Hero (https://www.youtube.com/user/handmadeheroarchive). He works with C++ but programs almost exclusively in a C compatible way. He is highly opinionated on some things but he absolutely knows what he is doing. There are countless hidden gems concerning low level programming.
Even though it is definitely not a crash course, I highly recommend Casey Muratori's Handmade Hero (https://www.youtube.com/user/handmadeheroarchive). He works with C++ but programs almost exclusively in a C compatible way. He is highly opinionated on some things but he absolutely knows what he is doing. There are countless hidden gems concerning low level programming.
K&amp;R is about as concise as it gets without being hard to understand. I'm not sure what you are looking for.
This a software/compiler thing; not a hardware thing(?) https://stackoverflow.com/a/792107
In regards to restrict, MSVC provides __restrict, which is basically the exact same thing (The only difference has to do with assigning a restrict pointer to a non-restrict pointer - it’s not common)
Try and read my post again.
Will check him out, thanks!
Will check out, thanks!
I want to study the basics of the language. I'm not looking to go into a job interview using only a crash course of the language, of course I'm going to practice it a lot after getting the basics set.
https://www.youtube.com/watch?v=Jlbs8ly6OKA&amp;list=PL76809ED684A081F3 Is this the one you're referring to?
Python, Java and a bit of ASM (and some minor scripting languages).
Referring to the Stanford programming paradigms: Does he only cover C or other languages aswell?
That’s it.
This sounds like a "do my homework" question. We will not do your homework... ... but we can help you think about the problem so YOU can do your homework. You will need to read a bunch of man pages to learn the specifics... No one is going to hold your hand through standard library function usage. Think about the problem like this: * Open the file. You might want to use `fopen`. * Allocate memory for your matrix. If you know how many records you'll have, you can define the size appropriately. Otherwise, you could make it larger than you need, although my CS Prof might judge me for recommending that. You might want to use `malloc`. * Start a loop that continuously reads a line from the file and stores it in a buffer array, so you can work with it. You might want to use `fgets` * Parse your buffer to pull out the values you need. You might want to use `strtok`. Store these values in the buffer. * Close the file because good little programmers put their toys away after they play with them. * Return the matrix. In the future, before you make a post like this, show that you made some effort to try to solve the problem yourself. You will never learn if you do not try.
You can dynamically construct a specifier string for the scanf family of functions. You could also use strtok/strcpy inside of a loop. 
Hello, thanks for taking the time to answer. This is my approach to my homework, I have to read a file and turn it into a binary tree. I have done the reading the file part, and as you saw I have my matrix initialized with its size. I'll be looking into the buffer thing, but I'm not sure if reading line to line is the solution since I need to take the space into account to separate the words. Then I close the file and out the matrix through a tree-making program I have yet to do.
Using `strtok` with a space as the delimiter is really, really easy. It's job is literally to take a string, and chop it up based on a known separator (like a space)
What prior programming experience do you have?
I'm fine with binary tree, it's basically a structure with a value, a pointer "true" and a pointer "false" that point to another of these. So i build a tree by comparing the characteristics with the value being the thing's name.
Do you speak Hindi?
Its hard to find actually good videos on programming on the internet, its even harder to find them on C since its not very mainstream. I would suggest you to read some books and write a lot of programs in it if you want to learn.
Its called lexing.
learn to format your code reee
d is uninitialised
 int main(int argc, char** argv) { int a[3] = {1,2,3}; int c,d,i=0; c = sizeof(a) / sizeof(a[0]); for(i = 0;i &lt; c; i++){ d = d + a[i]; } printf("%d",d); return 0; } this prints 6 mdude idk
I didn't copy paste from IDE.
wait no it isn't, int c,d,i=0;
That doesn't initialise `d`.
It is. In that line of code, only i is initialized to 0.
Only `i` is initialized, `c` and `d` aren't initialized.
i just added d = 0 to the line.
And it did the job
I just added d = 0, so it is c ,d = 0, i = 0;
yep im dumb
think there's a bit of python, lisp, asm, and sepples in there too
😂
I wasn't expecting to learn a programming language in an hour, please refer to other replies I've made.
Unfortunately not. 
One of the last videos seems to introduce the While loop. Are you sure that's the right pacing needed in a C course?
Python, Java and a bit of ASM (and some scripting languages).
There are a number of situations where the authors seem to have been more interested in defining behavior that fits a simple model, than in making the behavior practical. Perhaps the most infamous one is `0x1e-4 where the Standard requires that compilers be Just Plain Dumb because the authors didn't want to mandate that compilers recognize that the `e` is a hex digit rather than an exponent indicator, even though every pre-standard compiler I've used would in fact do that without difficulty. If the scanner records which tokens are and are not separated by whitespace, and `##` were not required to issue a diagnostic when the left and right operands are separate tokens, there would have been no need outside of contrived corner cases for the C89 preprocessor to worry about recognizing any tokens other than sequences of `[0-9A-Za-z_]`. C99 added the additional requirement to handle sequences `[0-9][0-9A-Za-z_.]` but that's still pretty easy since the first character of a token would indicate whether the token should end at the next `.`. What really irks me with all of this is that the authors of the Standard decided to try to make all corner-case behaviors uniform rather, thus mandating that compilers irreparably break code which may have been relying upon some of them, instead of adding features that would let programmers do anything that would have been facilitated by any of the weird corner cases, and many more useful things besides, in ways that can be more clearly and straightforwardly processed. 
Borland had a graphical interface called BGI which worked with a variety of display cards, but wasn't terribly fast. It supported a single bitmap font which could be scaled by integer amounts, and stroked fonts which were based on drawing lines rather than polygons, and generally didn't look very good.
Always compile with warnings enabled. The warnings would have flagged the use of uninitialised variables.
CS50 maybe
Yeah it’s a great intro. I failed my C class, and this break I am going to take my time to go through the book and do the example problems as well.
It’s a great book for reference. The Linux Kernel website lists it first in its list of C books. https://www.kernel.org/doc/html/v4.16/process/howto.html Link for reference. 
Not really.
Care to explain??
It’s basically the bible!
Hard to read, even for seasoned C programmers, but they'll never admit it because it's a holy book. It's one to own for historical interest, I have it, I like it, I've read it, I get it. It's not that great. For learning and reference, the man pages are far more useful.
The first edition of that book was published in **1978**. Fourty years later and with a few minor tweaks, it has more than merely 'weathered a few storms' or simply 'stood the test of time'...it is still regarded by many as the *de facto* standard. If you work through the book from cover-to-cover (there are some parts you may safely skip) you'll end up in a good place with C.
I used MacOs primarily and a Windows computer. I use GitLab to sync it across both computers (and the Fork gui client on both) and it works great. I was careful to not rely on anything platform specific, and even the standard library I really don't use hardly at all (really just calloc, free, fread, fwrite, and the socket io functions, connect, send, etc, etc, etc). If you rely on platform specific functionality you're gonna have to rewrite those parts.
Dealing with Windows filepaths isn't actually that hard. You'll generally want to either offer both a UTF-8 and UTF-16 interface, or you'll want to convert UTF-8 to UTF-16. Also, UNC paths are a thing (the one that start with "//?/" and you'll want a function to add and remove that prefix from any file path strings) but otherwise it's pretty easy.
Uh, nope. C99 is fully supported (except VLAs) in VS 2017 (I'm using the community edition) and C11 will likely be supported in VS 2019.
&gt; and sizes of the basic types Yeah, generally don't ever use those. Use stdint.h
I declare module wide constants in an enum named `ModuleNameConstants` and for variables I use a descriptive name in PascalCase. I do NOT declare them all at the top of the function like c89 requires, fuck that.
In structs I order them to reduce padding as much as possible, so everything is organized by size. Pointers are at the top, then 64 bit variables, 32, 16, and 8. then any typedef enums, assuming there isn't over 128 which I don't think there ever has been in my code.
Write programs... Did you learn to program to solve any specific problem? if so, do that.
Yes, and no. It's the bible, most C programmers have read it, have a copy for reference, everyone is familiar with it. It is also 40 years old, uses old syntax, poor style in things like function names and doesn't cover things like the C99 features or OOP style. Many people use the book is a starting point, I probably wouldn't recommend it as a method to learn but that depends very much on your experience and goals. It certainly shouldn't be your only source of knowledge.
Do you know other languages? Derek Banas is pretty good for getting up and running: https://youtu.be/nXvy5900m3M
he means indent the code 4 spaces to make it format like code on reddit. Otherwise it looks like arse and is insanely rude to make us read unformatted code and ask for help at the same time.
no, not really. it's a very famous book. but it's very old now and things have moved on.
&gt; It is also 40 years old, uses old syntax The first edition, yes. The second addition is C89 compliant.
If you already know how to program and just need to pick up C it is great. But I would not recommend it if you don't already know how to program.
I almost failed mine but managed to squeeze out a C++ thanks
yes but make sure to use correct flags with gcc or whatever compiler you use.
Your posts basically say "I want to learn it in a faster way, I dont understand books". Think harder and you will understand them. You also mention you are looking for a more "exercise-based" learning. I dont know how it gets more exercise based than coding programs that solve real life problems as I suggested above. You really need to find Jesus man. 
Your vision probably.
Solving it properly *is* a hard problem, which is why nobody's done it yet for either C or C++ on Windows. Instead everyone either ignores the problem (and can't access some files), or they hobble along, routing around their C standard library, making platform-specific calls for basic file operations since the standard functions are incomplete and insufficient on Windows. On unix-like systems, filenames are just null-terminated bytestrings, and so they're compatible with `char` arrays as passed to `fopen(3)` and such. The tricky part is that a unix filename cannot necessarily be represented in Unicode. For C this doesn't matter since its strings aren't strictly Unicode, as it is in other languages. On Windows filenames are not byte strings, nor UCS-2, nor UTF-16. They're zero-terminated arrays of 16-bit integers. They're not UCS-2 nor UTF-16 since they can contain unpaired surrogate halves. If you want to represent an arbitrary Windows filename as a byte string (i.e. for `fopen(3)` or `argv`), you need to encode it somehow. Since it's not compatible with Unicode, plain old UTF-8 won't work. I've never seen this solved by any C or C++ standard library on Windows. The problem is just ignored. [WTF-8](https://simonsapin.github.io/wtf-8/) is a scheme for encoding Windows filenames as byte strings, so they can be handled internally the same way as they would be on unix. That's the sort of thing I'd expect from a proper C standard library on Windows. Python [does](https://www.python.org/dev/peps/pep-0383/) it's [own thing](https://www.python.org/dev/peps/pep-0529/). Mercurial [has another strategy](https://www.mercurial-scm.org/wiki/EncodingStrategy). 
I think this is what you are looking for: [https://www.youtube.com/watch?v=UILNmv2kFMc&amp;list=PLCNJWVn9MJuPtPyljb-hewNfwEGES2oIW](https://www.youtube.com/watch?v=UILNmv2kFMc&amp;list=PLCNJWVn9MJuPtPyljb-hewNfwEGES2oIW)
Hard to read? How? I’m a mediocre programmer who had only done a Discord bot in python before and a few websites and I managed to go through the book easily. Most of the chapters are basic programming principles, variables and types, conditions, loops, functions, structs, not much else. Then it gets tough with the chapter on pointers and how to use them with data structures, but that’s maybe the only hard thing with memory allocation. The book is easier than actual C programming done in embed or in most programs which many experienced programmers have spent decades working on. I think it’s a great first approach to the language before diving in more complicated implementations and principles, and figuring out how to use the different APIs and libraries one frequently use C with. I’d say though a good thing to consider is to make sure to learn how to use GDB and Valgrind to make development easier. People would complain less about memory issues if they used Valgrind and fixed the most obvious leaks.
I can't judge the book as I have acquired it just recently. So far I like it, even with the fact that it covers the very first standardized version of the language, and I do really appreciate comprehensive exercises included in each chapter. But I'm not the one to make critical statements here (yet) so in the end my answer appears to be absolutely irrelevant.
get KN King - excellent book
One of the best textbooks I've used in any field.
Your inner loop is just an infinite loop once a capital letter is encountered.
Crap. I see it now. Any ideas for how to fix it?
I don't know the whole problem statement, but why do you think you need an inner while loop? What about just an 'if'? The outer loop is the one which traverses through each character, what other task needs to be repeated?
Well, I have several variables that will eventually be counting. I tried an if statement, but for some reason it would only let me enter one character and finish execution. The problem: Write a program with a loop that reads characters until a '#' character is entered. After all the characters have been read print the number of: 1) uppercase alphabetic characters read 2) lowercase alphabetic characters read 3) digit characters read 4) space characters that have been read - whitespace is ' ', , newline 5) total alphabetic characters read. I don't understand the comment on whitespace, but I figured I would address that after I could get at least one variable correctly counting.
&gt; I tried an if statement, but for some reason it would only let me enter one character and finish execution. You'd have to show your code, but I took what you have above, changed the inner while to an "if" and got it basically working. You don't initialize your 'i' variable, so the count won't be correct. Maybe try again with the 'if' statement, and post your code as a reply if it isn't working. Since you have a "bare" inner while loop (ie. no brackets), by guess is that you made a dead 'if' statement because of an extra parenthesis. Always use brackets, even for single statement ifs or while loops (until you gain experience).
Modern C is excellent and free. Programming C: A Modern Approach is equally good. A tutorial on arrays and pointers in C by Ted Jensen will get you over that hump.
Dangit. Thank you, that fixed it. I left out most of my unrelated variables and the initialization to keep it short. Brackets? Not parentheses? I will have to re-review the differences between (), {}, \[\]. 
I should have said braces (ie. {}). In other words always do this: if (something) { action; } rather than: if (something) action; The latter can be incredibly error prone, especially when making changes.
Thank you very much. Major help. I finished the problem and got it all working now. And that's a major pro tip. You're right that I missed the braces. 
Great! Glad I could be of help.
c++ btw &amp;#x200B;
I have the week off of work, so I'm going to be doing a ton of programming. Can I reach out if I hit other snags or should I just post again? 
Probably post; I'll have visitors this week and may be too busy to answer quickly.
Sounds good. I greatly appreciate the feedback! 
neh, that shit's fer babies
old? low level? geez man, would you say that bout your grandma? yeah maybe pick up let us c or learn c the hard way if that's yo attitude but if you wanna be like C is a classic, versatile language. flexible, simple, and highly refined. now we've got some enthusiasm. so ritchie, kernighan, pike, look up the stuff those cats gone and published. i mean they designed dis stuff doiiiii go learn from them like if you wanna know how to use a coconut, you don't go ask the guy who sold it to ya. go to the palm tree that grew it, or just ask the nut itself :D
C subreddit btw.
This is a C subreddit, not C++. But you’d have some pointless `class box` that has the one `value` field in it, presumably initialized in the ctor to something suitably random. You’d have some (probably template) `class queue` or use something from `::std` for the queue part of things. E.g., you can implement a queue on top of `std::vector`. This assignment doesn’t really require queueish behavior of course, since it’s fill-the-list then display-the-list (are you supposed to *actually* empty it along the way?), so really you could get away with using `vector` with no wrapping whatsoever.
It's a very good book. That said, I like the "C a reference manual" from Harbison &amp; Steele even better. Guy L. Steele is incredible technical writer and a "language lawyer". Steele has been involved with ANSI C standard, Common Lisp standard, Java standard and has been writing or coauthoring several classics, including: Common Lisp the Language, The High Performance Fortran Handbook and The Java Language Specification.
&gt;scanf("%s".psword); There should be a comma, not a period
omg i feel dumb now lmao thanks for the help without mockery kind stranger 
unfortunately I can't talk about the program in a more specific manner due to NDAs and stuff :( I guess I can litter licenses checks throughout the program and make it extremely annoying to remove them. It would kill me haha, I can't even imagine how I'll feel when I sit down and spend x amount of hours putting license checks in the final product. I see what you are saying though. I will have to discuss it with the client more and see how far they would like to push the license issue. 
lmaoooo
Hey look, people here are trying to help you out; no need for the snark. I would also add another voice to the choir here; There are no good C or C++ videos on the internet. You need to either find a book that suits you, or buckle down and try harder. I might also ask; *why* do you wish to learn C?
1989 was last year, after all.
d is uninitialised which means undefined behavior. Which compiler did you use which set it to 0? Does it always give to correct answer?
Writing my own parser after completing a lexer and I think I've had just enough thank you very much!
&gt; I guess I can litter licenses checks throughout the program and make it extremely annoying to remove them. Note that this only helps if you are sneaky about it. The following won't work: * call a validation function every once in a while (an attacker can just patch the validation function) * inline the same snippet for validation in a few spots (tools like IDA Pro allow you to search for code snippets, so these can be removed automatically, too) I don't know how professional DRM tools do it, but getting license checks right is quite involved. Though, once you realise that this is just a huge smokescreen, you might just want to implement a simple license check in the beginning to satisfy the client and call it a day.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
No blog spam please.
Just because it's a very powerful programming language, and learning it will improve my knowledge around other programming languages.
Thank you, I'll check it out!
Not intented to spam..but if it offended you i am really sorry
&gt;if you want to learn c something like this is probably better - https://learncodethehardway.org/c/ That's a pretty bad resource for learning C, for [various reasons](http://hentenaar.com/dont-learn-c-the-wrong-way). There may be books and websites that are easier for a neophyte than K&amp;R, but Zed Shaw's work is not one worth looking at.
Try functions and arrays. You can find many excellent tutorials to them online. And please, use markdown and its code block to format source here. It will be easier for us to read it. 
I put in some text above saying I don't know why it's not formatted nicely, when my prior code was nicely formatted. It's all tabbed, and usually that formats it nicely.
There's a link at the bottom of the editor frame, that says "switch to markdown". When you click it, you'll be able to use Markdown markup and format code nicely (google markdown for a list of formatting sequences). 
You need to put four blanks in front of every line of code for reddit to format the code correctly.
Thank you!
I did that, but apparently I needed to switch to "Markdown" to get the formatting going nicely. Had no idea that option existed.
That's because you use the reddit redesign which is quirky in all sorts of ways. Switch back to the old design to have the true reddit experience.
No! If you are beginner do not read it. In my experience most people recommending it have not read it. It's a reference book written more than decade ago....it does not teach programming! It assumes that you already have some experience in programming. On the other hand, i strongly recommend 'A book on C'...it's great book does not assume you know something about programming. And it really teaches you how to program. And it also covers later standard of C than K&amp;R