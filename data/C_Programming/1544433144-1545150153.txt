I'm on mobile, so I'll be brief. 1. You're declaring `int` vars, then assigning `char` vars and performing logical comparisons. This practice will get you into trouble with some very hard to find bugs. Either declare variables consistently or use explicit casts. 2. Stop using deeply nested loops. Instead, use [Finite State Machines] (https://en.m.wikipedia.org/wiki/Finite-state_machine). Doing so will make your code much more flexible and robust.
**Finite-state machine** A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Is there any alternative you would recommend instead?
This is a correct answer. Learn another language, python for example. Then learn data structures and some algorithms with python, then come back to k&amp;r. If you use k&amp;r as the first book to get into programming, you are most likely to think you are not good enough for CS. It would be hard for you. K&amp;r is a good book, but for someone who already knows programming. And if you read the book, you'll notice that it mentions things like fortran, or talks about how things are implemented in other languages, so it assumes that you already know programming and you are reading the book to learn C.
1) Prefer not declaring your loop variables before the loop. Rather declare it like: `for(int i = 0; i &lt; 10; ++i)` 2) add an else if clause if you are testing for multiple possibilities: `if (a == 1) ...` `else if (a == 2) ...` 3) you could try to replace the nested for loops with a for loop that depends on length for(int i = 0; i &lt; length; ++i) { for(char a = 'A'; a &lt; 'z'; ++a) { ... } }
If you need to indent your code more than three levels you should think about refactoring the code and moving parts into separate functions.
Yes
If I weren't so new to programming, I'd have tried to do what I actually wanted to get done, which would help that.. I was really hoping I could somehow make a function that iterates through as many for loops as it is specified to, rather than me hardcoding it all in, which feels messy. I should have kept my main() function clean here, and actually put most of this into a function, definitely agree with you on that, thank you.
It was a good book 35 years ago Imagine learning the English language today by reading Shakespeare 
C89 is 30 year old syntax. The 2nd ed. still calls functions without a declaration in scope, and uses implicit int (both removed in C99)
&gt; declaring `int` vars, then assigning `char` vars Where? Do you mean “assigning character literals to `int` variables”? Character literals are `int`s. &gt; Stop using deeply nested loops. Instead, use Finite State Machines. Recursion would be more appropriate in this case.
&gt; I was really hoping I could somehow make a function that iterates through as many for loops as it is specified to What you want is recursion. BTW, you are aware that there are non-alphabetical characters between the upper-case and lower-case alphabets in ASCII? It would be better to create an array of the characters you want to allow and iterate over that array (i.e. `char alpha[52] = "ABC..XYZabc...xyz"` and `for (i = 0; i &lt; 52; ++i)` instead of relying on details of the execution character set.
It wasn't out 35 years ago.
Zed Shaw is a pretentious ass and his book is garbage.
I am, but the code has a case for that. When the value being handled = 'Z', it's changed to 'a', and once it reaches 'z', the for loop is finished. I definitely see iterating over an array being a cleaner way to handle it, that would also allow me to add more characters in future, so I should have done that, thank you. I'll look into recursion in a bit and try to wrap my head around it. Everything is a little overwhelming when you're this new to programming. Even just nested for loops broke my brain for quite some time, and I had a lot of trial and error to even get this code working.
It's a good book but doesn't cover C99, C11 or C18, is very Unix centric and expects you to already have some experience with programming. So if you're new to programming it might not be the best book for you to get.
look up counting algorithms ... shouldn't need a new level of nesting for each digit it 's like, n raised to the power of m computations. so try first to write a process that loops that many times where n and m are its parameters . then think about what needs to change at each iteration to count from the first value to the last. all the best,
have you ever programmed in any other language? your code repeats the same idea too many times. somehow you need to make the repetition part of the program itself, rather than writing out the same thing again and again. unless you are very concerned with speed (which might be the case for decryption) or the amount of repetition is large, the simplest way here might be to use a recursive function, although that's not very common in C. unfortunately you have chose quite a hard problem to start with. generating permutations is quite tricky. maybe the best idea is to google "generate permutations in c" and read what comes up. there are likely explanations that help. i'm just assuming it's permutations from a quick scan of teh code, so sorry if i've misunderstood.
&gt; 1) Prefer not declaring your loop variables before the loop. Rather declare it like:.... I've had many-a-compiler not allow defining variables in the first part of a for-loop. 
Speed is a slight concern, since it is a task that can become very slow, eventually, but I do want to implement recursion, I just don't know how. I've not really programmed in any other language before, I've been learning C for about a month now, and this is sadly, the extent of what I can do. Even just handling a nested for loop needed quite a bit of trial and error to learn in my current state. I understand that this problem I'm taking on is probably a bit difficult for a beginner, but I think that's why it's doing me good to attempt. I could be wrong, but this forced me to at least use nested for loops for the first time, so now I actually can use them in the future with confidence, and I feel like it helped me learn in that regard. I'll look up the message you mentioned and see what others have written to do the same thing, and hopefully that will help me learn as well. I need to look up recursion and rewrite this at a later date I think.
does it have to be in c? if i were you i'd be starting with python.
First edition published 1978. The second ed is basically the same but with function prototypes, and some mistakes fixed.
You are missing character 'a' because of the ++ at the end of for-loop.
The column 80 rule is good, follow it. Especially the line if(i == 'z') { length++; printf("All possible permutations of length(4) have been tested\n");} is pretty infurating.
Try also beej's introduction to C. Google will find. Not authoritative or such, but written in a funny way.
You're right, and it's also a redundant if statement that doesn't need to exist. I've fixed this already, but I agree, it looks awful and should not have been done that way, thank you for pointing that out.
You're right, thank you. I guess I should technically make the value become the ASCII value of 'a' -1, what ever that may be. 
That is the bible. It is very-very well written, a pedagogical example on how to introduce a language, its syntax and semantics. But: you first need to know some constructs well: loops, conditionals and functions.
So the description of it being the bible of C fits very well. Old, teaches superseded knowledge, however morals and style can be learned from it. &amp;#x200B;
Thx for this answer I sometimes read the book to help me for class but i find the examples a bit confusing sometimes. Also tried an exercise and I was like "how am i supposed to do this"
I'm in the middle of reading it too. I struggle with it too. But I read this somewhere: If it is easy, you are not actually learning. Right?
You could take a different view to the problem: start by buf\[6\]; strncpy(buf, "A", 6); and then keep "incrementing the string". If you reach 'z' in a character position, make it 'A' again and lengthen it to "AA". Stop when you reach "zzzzz".
Try your compiler's option for using a newer c standard, eg --std=gnu11 for gcc
It's a holy book because of what everyone but you thinks of it. So what does that tell us about you? In addition, both authors have written other books which are also "holy". Which tells us a lot about them.
As an electronic engineer in 1985, who only knew assembly and was dragged kicking and screaming to learn C, it was the book I learned from and it still sits proudly on my shelf. If you can't learn C from this book, you should find another hobby.
You said you knew assembly, right? So you already could program in a much harder way, and you came to C. Like someone who knows C and learns python. Of course it would be easier for him/her. It is not right to compare people who are completely new to programming, algorithms and data structures, to yourself and blame them if they find k&amp;r hard. It is a great book, but for someone who already knows a little about programming, like you.
I just have to say that your attitude and approach are really commendable, and they'll take you far if you can continue to keep yourself humble and chase the knowledge.
You just made it more tempting for me to search up about him by mentioning that...
Your #2 is great advice. I completely disagree about #1. In general, don't use `char` or `short` variables. Array of `char` and `short` are fine and necessary, as are pointers to these types, but there's never a reason to use this type for a variable. First of all, it doesn't save you anything. These variables will be stored in registers, so it doesn't save any memory to make them smaller. When spilled the savings are negligible, and the spills will probably be aligned to a larger type anyway. Second, integers smaller than `int` are cast to at least as large as `int` for all integer operations. So again, you're not saving anything by using smaller values. In fact, in some cases it will make your code slower forcing the compiler to convert back and forth (to truncate). Third, given that integer operations are always done at least with `int` precision, it's less error prone to stick to at least `int` even when dealing with individual characters like this. You won't have to remember this rule. For example, here's a similar, common mistake we see all the time around here: char c = getchar(); if (c != EOF) { // ... } 
gcc. And it seems to always work...
- The man pages. There's a man page for almost everything. especially sections 2 and 3. for instance https://linux.die.net/man/3/printf - Advanced Programming in the Unix Environment - maybe outdated but very good.
Hi. As the author of [a finite state machine language](https://github.com/StoneCypher/fsl) and [machine](https://github.com/StoneCypher/jssm), I'm here to say that your finite state machine advice is terrible This problem does not usefully model in a finite state machine. There are no meaningful nodes to move between (unless you have one node for every radix^5 combination) and no edges to constrain. This will not "make your code more flexible and robust." Those are just things people say to sound like they know what they're talking about.
&gt; Your #2 is great advice. It's actually awful advice. Hi, I'm the author of [a finite state machine language](https://github.com/StoneCypher/fsl) and [machine](https://github.com/StoneCypher/jssm), and I love FSMs. They have absolutely no place here. Spend five minutes trying to figure out what the finite state machine for this would look like, what the nodes would be, and what the edges would be. Then, without using a sound bite like "it makes your code more robust," which is horseshit, try using a specific technical claim with a justification to explain why this is an improvement. 
https://imgur.com/inaWzjv
I read the OP in the early morning hours, so I didn't read it too closely. Rather, I saw deeply nested loops. I'm guessing you know something about state machines, so to say my advice is terrible, you're either a dick or on the spectrum, as you, of all people, should understand the value of state machines. Also, I'm still on mobile, and unless I'm not getting the full picture, your first repo looks pointless, and although your second one has some nice directed graphs, those are easy to create with GraphViz, so I'm still not impressed.
Glad it worked out for you. I bought it, I was all excited, I read it, wasn't impressed. Sorry. And then, throughout my C programming life, i never needed it, it never had any answers i needed, the man pages however, almost always delivered. 
We don't know that he's new to programming but I was not a programmer when I learned C. I designed medical computer hardware and used assembly for low level uses, drivers and operating system booting. 
I feel like you are missing the point of such book. The man pages aren't tutorial based and are focused on the standard libraries and its functions. How is one supposed to learn pointer arithmetic or the rules of function declarations? I don't know of a man page for this, and even if there was one, how do I find it? The book is intended for teaching a language and tour its main features. Obviously you only need it once, if you aren't already introduced to the language. It's for beginners, a first approach, and it is in ways dated, but still quite relevant since the language hasn't changed much, and the syntax is only flawed in details easy to adjust. If you have no constructive criticism to present to the book specifically, and you are just dismissive of its legacy, nobody is going to take you seriously.
&gt; you're either a dick or on the spectrum Not appropriate . &gt; you, of all people, should understand the value of state machines. I do. And this is a place where they will cause much more harm than good. . &gt; unless I'm not getting the full picture You're not
Thank you very much. I appreciate the kind words, and hope that does hold to be true! 
Is it about as bad as his attempt to write a Python tutorial? Is he gonna say that modern C isn't Turing complete because you can't write old C in it?
Consider updating your compiler. This has been in the standard since C99. If you are using gcc &lt; 5.0, simply pass \`-std=c99\` to the compiler. If you are using current versions of most compilers, they should default to c11. Properly scoping your variables is just good practice.
That is SO. Here, you can simply put three ticks \`\`\` to format a code block...
I didn't say it was a shit book. I said "Not really." I stand by it. It's not really that great.
I can see you've found the answer, but with the right compiler and the right compiler settings this could have been made pretty obvious to you. For example, here's what I get when I try to build it: $ gcc -g -Wall -pedantic -std=c99 login.c -o login login.c: In function ‘login’: login.c:22:19: error: request for member ‘psword’ in something not a structure or union scanf("%s".psword); ^ login.c:31:23: error: request for member ‘psword’ in something not a structure or union scanf("%s".psword); ^ login.c:42:22: warning: unknown conversion type character ‘-’ in format [-Wformat=] fscanf(Ptr,"%-10s %s",cuser,cpword); ^ login.c:42:20: warning: too many arguments for format [-Wformat-extra-args] fscanf(Ptr,"%-10s %s",cuser,cpword); ^~~~~~~~~~ $
That only works in the redesign.
C is not an OOP language.
Another thing, you should have a think about where you're calling `fclose`...
IMHO, the book *should* be treated as the Bible by compiler writers, at least with regard to any program whose behavior is defined by the book, but compiler writers don't see it that way. This book describes the language the C89 Standard was written to define, but that is which is unfortunately different from the language that is actually defined by the text of the Standard. Until C99 came out, situations where the book would describe a behavior but the Standard would not were recognized by programmers and compiler writers alike as defects in the Standard, but since those defects didn't actually hurt anything there was no perceived need to correct them in later versions. Someone who tries to program a modern compiler using just the book may get tripped up by constructs which worked in 1990s compilers but are broken in modern ones. A couple examples: 1. The Standard introduces the concept of a `pp-number` token, and defines the behavior of `##` as concatenating exactly one token from either side to produce a new token, while K&amp;R2 has no concept of a pp-number and describes the behavior of `##` on page 90 as rescanning the text to either side. Although K&amp;R2 would suggest that an expression like `(0x1E-q)` should be equivalent to `(0x1E -q)`, the Standard requires that if a hex constant's last digit is `E` or `e`, any `+` or `-` operator following it be preceded by a whitespace character, and the cases where the `##` token-pasting operator can and cannot be used to form floating-point constants get even more bizarre. One could contrive a Strictly Conforming program that relies upon the weird way of parsing mandated by the Standard, but the normal effect of the Standard's rules is to break programs that could be parsed usefully under the rules in K&amp;R2. I'm not sure if there are any non-contrived programs that would work if parsed under the Standard rules that would not work under the K&amp;R2 rules. 2. K&amp;R2 describes how objects are stored in memory, and many constructs' behaviors are implied by that layout. The Standard uses the same layout, but only defines behavior when objects are used in particular ways. The charter and rationale for the Standard both say that the Standard is intended to uphold the Spirit of C, which includes the principle "Don't prevent the programmer from doing to be done", and the Standard never requires that implementations process objects in a fashion inconsistent with their memory layout. I think the authors thus intended that compilers that claim to be suitable for a particular purpose would behave as described by K&amp;R2 whenever doing so would help serve that purpose, but some compiler writers view any code that would rely upon such treatment in cases not mandated by the Standard as "broken". IMHO, the divergence between modern compiler behavior and K&amp;R2 has if anything increased the need for programmers to familiarize themselves with the book so they can pressure compiler writers to focus more on supporting the useful language that became popular in the 1970s to 1990s, as distinct from the inferior subset that compiler writers want to process today. 
This function is big try breaking it up into several functions with good names to make the code more legible - it's easier to understand shorter functions that spell out what they're logically doing, and it helps you compartmentalize "I'm focusing on just this tiny part of the code." There's something about, ```i```, ```j```, ```k```, ```l```, and ```m```, and their relation to ```attempt``` that I would try to put your individual variables into an array. I see lots of loops and repetitive code that all seem to do what is essentially the same thing, you can probably condense this down to something very concise, easier to read, and understand. Reducing repetitive code to functions is a good first step. Single letter variable names are *often* terrible. Imagine you have a gigantic ```for``` loop and it has counter called ```i```; now imagine trying to search for all instances of that variable name using your editor - how often do you think "i" is going to come up? The place where they do come in handy is when you're writing out equations (in it's own function), and as a general equation, the idea of giving your variable a robust and telling name might not make sense - but then document what all the variables are in code comments! My boss called them "Yoda statements" but consider the difference between ```if(x == 0)``` and ```if(0 == x)```. The former runs the risk of a typing error, ```if(x = 0)``` is always false, and not all compilers will even warn you might have made a mistake here, because it's perfectly legal syntax. Then, at 3am and on your 4th pot of coffee since you first woke, you'll be staring into your editor and unable to see the bug right in front of you. By inverting the check where possible, you can't assign to a literal, so it blows up in your face with a nice error. It's not the greatest tip, but sometimes it's the little things... Try to be consistent about your formatting. Do open brackets go at the end of their opening block statement or on their own line? Better yet, use a code formatting tool and configure your build environment to run it first every time you compile. Just pick a formatting style and go with it - no one is really going to care which so long as you're decided and consistent. Is there a reason you're mixing types? Ints and chars? If you have dreams of unicode, keep dreaming; unicode encoding is not so trivial as using an int for your character type - use a unicode library. Do you intend to have each condition evaluated in sequence everywhere? Or do you expect only one to execute per iteration and it's just coincidental that the rest will evaluate to false? If you're performing unnecessary checks, then use ```else if```. And I wonder if there is a case for you to use a ```switch``` statement when you check ```length``` at your top level loop. Always handle each case explicitly - that is to say, if you have 5 length cases, there should be 5 case statements; don't write cases 1-4 and then case 5 is the ```default```, because then more than just ```5 == length``` can match that criteria. Also, regarding ```switch```, always have a default case. If anything, if you don't have a catch-all case for everything else, then use it for sanity checking and error handling. Try to have a return statement as the last statement in the function. There are some who strive to have only one return statement in their functions no matter what, but that isn't strictly necessary. The problem here is your top ```while``` loop has an exit condition. It just so happens by coincidence that it never evaluates false because you exit before then, inside the loop. But what if you had a bug where it did evaluate to false? Then you exit the loop and you reach the end of the function without a return statement. There may be some funky language rules about your code here, but I don't know off hand what the compiler presumes is going to happen in that code path. So if you never actually intended for that loop to exit, why does it have an exit condition at all? You can have "forever loops", and it's a perfectly valid thing to do. The canonical examples would be ```while(true) {}```, ```do {} while(true);```, and ```for(;;) {}```. You have two outputs - standard out, and standard error. ```printf``` writes to standard out by default, and you're basically using it right - it's for typical end-user program output - this is what the program is meant to print out, this is it's output. The other is for all other side channel communication, things that the end-user isn't going to consume because that's not why he's running the program. This would be errors, traces, warnings, debugging, profiling, statistics, crass messages from the developer, and program state. By default, both go to the console, and on Windows and Unix, you can redirect these two outputs to whatever you want, typically the console and /dev/null, respectively (for a program of this caliber, since you can just run it again; or somewhere in /var/log if there's any risk a subsequent run might not produce identical output). I recommend you get into the practice of dividing up your output between the two. And remember, just because it's called standard error, that doesn't mean that only error messages in the strictest sense go there; the name is slightly unfortunate. Use asserts. Assert statements are a great way of declaring your invariants - "This statement MUST be true or the whole program is in an undefined state." For example, if you have a loop that runs until your counter is equal to 7, then you can assert that - and if your counter isn't equal to 7, then what happened? What can you trust if something THAT trivial didn't hold? You've got bigger problems and the right thing to do is report the assertion and terminate the program (that's what assert statements do for you).
Looks like I’m going to get it, I already know some basic C things like writing your own functions, enums, basic variable/string manipulation etc... Thanks for the feedback (:
&gt; Do you mean “assigning character literals to int variables”? Not exactly. I meant *character constants*. I have updated my original comment accordingly. &gt; Character literals are ints. This is not technically true. *Character constants* are different from *string literals*. *Character constants*, which are the reason type `char` exists, can always be safely cast to `unsigned int`. Most of the time, single byte *character constants* are implemented as `unsigned int`s, but, to my knowledge, this behavior is not guaranteed by any version of the ANSI/ISO C standards.
&gt; Not appropriate I have a brother who is on the spectrum. He acts like a real asshole sometimes. Although I have to remind myself that he has a disability, I also remind him that his disability is not an excuse for being an asshole. &gt; I do. And this is a place where they will cause much more harm than good. Just try to write out the appropriate state machine for this job. Let me know when you have something. After getting 4 hours of sleep and re-reading the OP's post on my desktop, I agree that this problem does not lend itself to a FSM. However, I also stand by recommending learning about FSMs to OP. Whenever I see lots of deeply nested loops in a beginner's code, 95% of the time, the code could be greatly simplified with a FSM. The concept is fairly easy to learn, and it's a natural progression from learning basic syntax. &gt; It's a reference parser for a programming language, so, I'm betting you're not getting the full picture. I've gone back and looked at your first repo. You really need more documentation. Just based on a quick look, all I see is an abstraction of the GraphViz rendering engine. I don't understand why that's useful.
OOP is a paradigm that can work perfectly fine in C, it's just not built into the language. Not something you see every day, but entirely possible. That said, it probably doesn't belong in that book.
&gt; but there's never a reason to use these types for variables. You make some really good points in your post. However, I'm taking a wild guess here, but I bet that you've never done embedded systems programming. Nowadays, memory and computing power are so incredibly cheap compared to when I started programming in C. Keeping in line with your points, the C99 standard guarantees that a `char` can always be safely cast to an `int`. However, if you're ever running in a memory constrained environment where the `char`data type is smaller than the `int` data type and your data can fit in arrays of `char`s, you'll be really grateful for it.
What I said applies just as much to embedded programming as well. These processors still have registers, and using local variables with types smaller than `int` doesn't use less memory, usually not even for spills. I had already said arrays are a different matter.
# How to radix count [Text also available here](https://stonecypher.github.io/explanations/RadixCounting/) I feel like you need an example of building this being done well, but that to do so in a different language will give you an opportunity to redo it well yourself. Therefore, I'm writing Javascript in a C group. `lol` I want to give you a heads up: your teacher is probably trying to trip you up with numbers they don't realize are 15 years old. 52 radix at five digits is 380 million entries and change. These days, amusingly, that's reasonable in a web browser. That was probably a deal-breaker when the book was written. They probably want you to not actually keep the list, and just seek out to the right position (or use math to figure it out with no seeking.) Depends on what your homework actually is. Anyway. [Here's an implementation in Javascript](https://stonecypher.github.io/explanations/RadixCounting/counting.html). Let's go over how it was done together, so that you can do the same thing in C. ---- The key understanding here is that treating the various lengths as different, rather than handling it once flexibly and re-using that, is a mistake. That massively inflates the work with the same thing repeatedly. ---- Think about this algorithmically instead. What are you actually doing? You're just covering a space of counters. That's pretty much just a number, and you're pretty much just counting. So let's use the US counting algorithm. So to treat this like a number, not a string, we observe that 1234 is a number: it's four digits on the implied radix "0123456789". 0x1234 is four digits on the implied radix "0123456789abcdef". So fuck it. Your passwords are a number too, on the radix ... whatever your password character set is. ***Now*** you can just count them upwards. Counting by hand is annoying, but easy when you remember how. Presuming the US english method of writing integers without separators, presuming four digit decimal, but using full zero fill, you start with `0000`, then you go to the leastmost, and you increment it by one. If the leastmost is now over 9, you reset it to zero, and increment the second leastmost. You continue inwards until you hit a not-ten, meaning you've finished this increment, or you run out of digits after the fourth counter, meaning you've run the whole range. Now rewrite that without the decimal and four digit assumptions. Starting with `least-counter`, `increment`. If `counter-overflow`, `next-counter`. If `out-of-counters`, `range-complete`. Else `increment-complete`. Which isn't so bad. ---- So next we think about this architecturally. How do we want to do this, ish? For one counting range, it's * To do `one range`: * With counter: * Record current state in log * Increment to next counter * If next-counter-too-high * Done * Else * Continue counting Thus for your five, it's just * Concatenate `[ one range(N) || N &lt;- [1..5] ]` (lol erlang too I guess) ---- Fine. That encloses most of the gross into `increment to next counter`. How do we actually do that? Counting is hard. Well, we think functionally. (Note that this does the digits in the reverse of the order you'd expect from reading English, since index 0 as least is natural, but index 0 is usually written at the left.) /******** * Get the next counter from the previous * next_counter( [3,2,1], 4 ) -&gt; [0,3,1] */ function next_counter(counter, digit_cap) { const counterLength = counter.length, // we use this a lot so cache it iCounter = new Array(counterLength); // the new counter let bumpNext = true, // always bump the first digit whichDigit; // cursor in digits of number // go over all the digits once, least-significant to most-sig for (whichDigit = 0; whichDigit &lt; counterLength; ++whichDigit) { // if the previous step said bump, or always at first, then increment this digit by one iCounter[whichDigit] = counter[whichDigit] + (bumpNext? 1 : 0); // if this digit has gone over if (iCounter[whichDigit] &gt;= digit_cap) { iCounter[whichDigit] = 0; // reset it bumpNext = true; // mark to bump next } else { // otherwise bumpNext = false; // mark not to bump next } } // if bumpNext is on at the end, the last digit overflowed; return false because no counter remains return bumpNext? false : iCounter; } ---- (continued, too long)
How do we use that? Well that's pretty straightforward. * Make a list. * Make the first counter, and put it in the list. * Keep getting new counters, and putting them in the list, until there aren't any left. * Transform those to your letters. * There's your result. ---- Let's do the transform first. It seems like your radix is all capital letters then all lower case, so, put the relevant letters in a string, and take that character as a string. function ch_transform(digit) { return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"[digit]; } Simple enough. ---- Then, let's turn `next_counter` into `all_counters`, like discussed above. function all_counters(length, digit_cap, transformer) { const output = []; // make a list let counter = new Array(length).fill(0); // make the first counter output.push(counter); // put it in the list while (counter = next_counter(counter, digit_cap)) { // keep getting new counters output.push(counter); // and putting them in the list } // until there aren't any left const transform_one_row = row =&gt; row.map(transformer).join(''); // if a string transform is offered, use it then join on '' return transformer? output.map(transform_one_row) : output; // transform those to your letters } ---- Presented in a little bit of HTML so that it's usable, you get this. [Alternately, you can just see it on github pages here](https://stonecypher.github.io/explanations/RadixCounting/counting.html). Probably the smart choice. &lt;!doctype html&gt; &lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt; /******** * Get the next counter from the previous * next_counter( [3,2,1], 4 ) -&gt; [0,3,1] */ function next_counter(counter, digit_cap) { const counterLength = counter.length, // we use this a lot so cache it iCounter = new Array(counterLength); // the new counter let bumpNext = true, // always bump the first digit whichDigit; // cursor in digits of number // go over all the digits once, least-significant to most-sig for (whichDigit = 0; whichDigit &lt; counterLength; ++whichDigit) { // if the previous step said bump, or always at first, then increment this digit by one iCounter[whichDigit] = counter[whichDigit] + (bumpNext? 1 : 0); // if this digit has gone over if (iCounter[whichDigit] &gt;= digit_cap) { iCounter[whichDigit] = 0; // reset it bumpNext = true; // mark to bump next } else { // otherwise bumpNext = false; // mark not to bump next } } // if bumpNext is on at the end, the last digit overflowed; return false because no counter remains return bumpNext? false : iCounter; } function all_counters(length, digit_cap, transformer) { const output = []; // make a list let counter = new Array(length).fill(0); // make the first counter output.push(counter); // put it in the list while (counter = next_counter(counter, digit_cap)) { // keep getting new counters output.push(counter); // and putting them in the list } // until there aren't any left const transform_one_row = row =&gt; row.map(transformer).join(''); // if a string transform is offered, use it then join on '' return transformer? output.map(transform_one_row) : output; // transform those to your letters } // It seems like your radix is all capital letters then all lower case, so, // put the relevant letters in a string, and take that character as a string. function ch_transform(digit, chs) { return chs[digit]; } function byId(id) { return document.getElementById(id); } function update() { const tgt = byId('tgt'); tgt.innerHTML = ''; const chset = (byId('chset').value) || "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", len = Number(byId('digits').value); const ctrs = all_counters(len, chset.length, digit =&gt; ch_transform(digit, chset)); ctrs.map(ctr =&gt; { let li = document.createElement('li'); li.innerHTML = ctr; tgt.appendChild(li); }); } window.onload = () =&gt; update(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Digits&lt;/th&gt; &lt;td&gt;&lt;input type="number" id="digits" min="1" step="1" value="2" onchange="update();" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Characters&lt;/th&gt; &lt;td&gt;&lt;input type="text" id="chset" value="ABC" onkeyup="update();" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;ul id="tgt"&gt;&lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;
So, we're in violent agreement?
Good advice, bad advice, a bar fight, essays, do we accept how-about-this-ways as well ? main() { #define N 5 char buf[N + 1]; char *p, *word = buf; memset(buf, 0, sizeof (buf)); for (;;) { /* longest suffix of z must wrap over to A. * the slot to increment is just before that suffix. */ for (p = &amp;buf[N - 1]; p &gt;= buf &amp;&amp; *p == 'z'; --p) *p = 'A'; if (p &lt; buf) break; if (*p == 0) { word = p; /* length grew by 1 */ *p = 'A'; } else if (*p == 'Z') { *p = 'a'; } else { (*p)++; } puts(word); } } &amp;#x200B;
You're right I try to think that way too but sometimes I am just like "How im I supposed to do this" and get stuck
Heh, I always referred to Stroustrup's "The C++ Programming Language" as the New Testament.
This is C++, not C. But this seems to be a math question, not a programming one. By "slow down" do you mean converge? If so, that's correct. The sum of 1/n does not converge.
Ah yes thank you. Didn't know there was a name for it :P.
&amp; - get the address of * - get a typed view on a memory location &amp;* - cancel each other out array[index] = *(array+index) array[i1][i2] = *(array+(i1*dim2)+i1) ...
&gt; I've gone back and looked at your first repo. You really need more documentation There's an entire book. I think you should stop criticizing on quick glances.
&gt; Character constants, which are the reason type char exists, can always be safely cast to unsigned int Characters are often signed on embedded, actually. This is incorrect.
Hi, I'm on mobile right now so the best thing I can recommend is: online research. With a little effort you can find a copy of "The C Programming Language" in an older version. The version does not really matter since the concept of pointers is the same. The explanations there are on point and understandable (maybe after the third read but still). Another good thing might be trying image search. Arrays and pointers can be visualized pretty nicely. I also think there have been many questions towards pointers in this or another C related sub. Believe me: pointers are not that hard. It just takes some time to understand them entirely. And understanding is important here. Maybe I'll check in here later when im on PC. Good luck to you
No. `br` and `bj` only receive the value that is contained in `j` at that point of time (`0` in this case), but any further writes to `j` won't modify `br` and `bj`.
Understandable. Pointers are difficult, especially if it is the first time you have encountered them. Couple that with the fact that they are heavily tied to concepts like heap and stack and you can really get bogged down... But, my suggestion - take a deep breath, and just get started on that project. Take it one step at a time - when you encounter something that you don't understand, take that as an opportunity to expand your knowledge. Since you are building from the ground up, you control the pace and things will seem much more manageable. When you are building an application, you are not simply trying to ingest a bunch of disparate concepts but attempting to apply them one by one...
This doesn’t answer your question, but because you said you know some Lua I would suggest looking at the Lua docs for how to embed Lua programs (call Lua from C) or create Lua libraries in C (call c from Lua). (Do this after you learn some C though) Lua is great for interfacing with C, so you can take what you already know and understand how it works and build on it!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead. Also, you are not meant to type literal `␣` characters. Instead, for each `␣` you should hit space once.
`br` and `bj` don't automatically change when `j` changes. A common misconception with beginners is they think `=` is like = in mathematics, defining a property of equality that will hold for the duration of the program, or something like that. Instead, `=` means *assignment* -- it changes a variable so that it holds the same value as another in that instant. Any following statement in the program can change that.
No. You initialize all the variables to zero, but then only increment `j`. The expression `br = bj = j = 0` also isn’t valid C code, and should not compile. 
I can recommend you another book to check out, and/or you can tell us what you think you don't know, so we can help more directly. It's fine to say you don't know even what you don't know, but that means we can't do much beyond pointing out another material for you to study from. http://publications.gbdirect.co.uk/c_book/
This is by value - even if this were by reference, you would not get the results you expect as you only set the value one time. If you want to get those results, you will want something like: ``` int j = 0; int *bj = &amp;j; int *br = &amp;j; for (j = 0; j&lt; 4; j++) { printf("%d %d", *br, *bj); } ``` And get rid of the `return 0` - this is a C89 standard and no longer necessary. 
it's gross but valid.
My bad. It does work if you’ve defined the variables beforehand.
Asserts are great for debugging. Be careful checking for runtime conditions with an assert.
A bigger issue is that the publication of C99 fundamentally changed what the notion of "standard C" meant. For about ten years prior to the publication of C99, there was a published ANSI C Standard, but few people actually cared what it said. Since the stated purpose of the Committee was to formally describe Dennis Ritchie's language, the book written by Dennis Ritchie himself was regarded as more authoritative than a Standard written by a committee, especially in cases where the book would describe the behavior of some construct but the Standard did not. Unfortunately, while compilers hadn't needed to use the C89 Standard while writing "ANSI C" compilers (they could regard K&amp;R2 as a better reference), they couldn't claim to write C99-compatible compilers without using that Standard as a reference. Unfortunately, compiler writers lost sight of the fact that what had become popular in the 1980s was the language described in K&amp;R2, and not the C89 Standard, and that C99 should be treated as adding extensions to K&amp;R2, rather than as inviting compilers to limit programmers to constructs described by C99 itself. 
there is a really good bunch of lectures on C and programming in general on YouTube. i think it's Stanford C or Stanford programming. I'd look it up for you but I'm on mobile at work. try to find them and watch the first eight or so videos. Understanding memory and binary helped me a lot in learning pointers. Then i think there is a whole two hours of lecture devoted to pointers and what's going on there. very very good video series.
We need a language called Rimshot
Hey! I'm glad to hear you've been doing alright in the class. Sounds like you're doing much better than me in my first C class. I did terrible, barely passed but once it clicked I loved it and now I have a full time job writing C! I'd say definitely look around online. Don't just read one example, read multiple examples. They'll all say pretty much the same thing but slightly different so you won't be stuck with a single-minded explanation. Look at sites like tutorialspoint.com and geeksforgeeks.com, I find those to be good basic explanations. Lastly, if you are still stuck and want some help then you can PM me and I'd be happy to try to help you out!
Asserts are typically macros, and their release definitions are empty, so they compile to nothing. But that's unfortunate, because again, you're asserting that your program is not in a logically impossible state. What does it mean for your program if it is in an impossible state? How can you possibly recover, or continue on? Unless you're writing aviation or space probe software, where your error handling is far more robust, what else can you do but terminate execution immediately? The default decision should be that is the right thing to do. Capture output into a log, and let the rest of the environment recover accordingly.
&gt; There's an entire book. &gt; &gt; I think you should stop criticizing on quick glances. You've obviously put some real work into this project. If you'd put just a little bit of background in your [README.md](https://github.com/StoneCypher/fsl/blob/master/README.md), if only two sentences with a link to your manual and perhaps the [example image](https://raw.githubusercontent.com/StoneCypher/fsl/master/assets/no%20problem%20flowchart.jpg) taken from your [tutorial document](https://github.com/StoneCypher/fsl/blob/master/draft%20tutorial.md), you'll get a lot more mileage out of that project. Busy people are not going to take the time to dig through your repo for documentation. Outside of my regular job, I review far too many repos and code samples just as a hobby each week to go into any detail without a compelling reason. If I see a barebones README.md, I skip over that repo. If I understand your concept \(*i.e.* building a FSM engine on top of the GraphViz language by taking advantage of the relationship between directed graphs and FSM to enable quick automated rendering via [vis.js](http://visjs.org/)\), I genuinely like the concept.
&gt; You've obviously put some real work into this project. It's just getting started. . &gt; If you'd put just a little bit of background in your README.md It'll get replaced when it's time. Right now I'm building out the website, the book, and the video tutorials instead. . &gt; Busy people are not going to take the time Thanks, I've gotten more than enough libraries popular. I wasn't looking for your advice. . &gt; If I understand your concept Nope. The grapher is largely just a convenience to help people understand their work more easily. The (half-finished) language is to FSMs what check constraints are to SQL: a much stricter expression than people are usually used to. There's an embedded language (the documentation doesn't discuss it yet.) It's what Edwin Brady would call "pac-man complete." The goal is to allow portable expression of extremely strict state machines.
lol
The `=` operator in C is an assignment operator, it's not a propositional operator like it's in mathematics. 
if it's any consolation, what you're describing is pretty normal. arrays and pointers are what cause lots of people problems. you won't be the only one struggling and your prof will be expecting it. i don't have a fix, but maybe it's enough to know that what you're experiencing doesn't indicate you're bound to fail. people do struggle at this point, but they finally understand. well, most of them :)
Pointers take a while to get your head around, for sure. It'll click with practice. I don't know if this is good or bad advice, but you might have an easier time if you focus on pointers, and then work your way back to the slight abstraction of arrays. Work with a chunk of raw memory with malloc, and see how pointer math works with types (ie, 4 or 8 byte ints vs 1 byte chars).
I guess i'll be the one guy here who suggests TALKING TO YOUR TEACHER. Sorry for the caps, but that is quite literally what they are paid for. They are supposed to teach you, and if their lesson is not getting through to you, schedule some time to go talk with him/her outside of class and get further explanation. If your teacher is not making time for you outside of class, perhaps go speak to the dean about it.
Pointers: //some notational stuff to get you started, not exactly a rigorous syntax, will not run int array[ ] &lt;=&gt; int* array int array[10] &lt;=&gt; int* array= malloc(10*sizeof(int)) //how to get a value array[0] &lt;=&gt; *array array[1]&lt;=&gt; *(array+1) ... array[9]&lt;=&gt; *(array+9) //it's the same for any data type, but let's add a little detail; you need to "transform"(called casting) it; THIS WILL RUN char* string= malloc(4*sizeof(char)); //&lt;=&gt;char string[4] string[0]='a'; //character, not string string[1]='b'; string[2]='c'; string[4]='\0'; //terminating character, why we needed an extra byte printf("%s",string); char* string2 = malloc(5*sizeof(char)); //&lt;=&gt;char string[6] string2="radar"; //this is a string printf("\n these are new line characters \n"); printf("%s",string2); //getting an address; THIS WILL RUN int value=5; int* address=&amp;value; printf("This is a value %d and its RAM address: %d ",value,address); //more advanced stuff to think on; THIS WILL NOT RUN int matrix[ ][ ] &lt;=&gt; int** matrix int matrix[ ][ ] &lt;=&gt; int** matr=(int**)malloc(rows*sizeof(int*)) int 3Dmatrix[][][]&lt;=&gt; int*** matr=(int***)malloc(rows*sizeof(int**)) Let me know if it helped. 
As you are learning you are building a mental model of how it all works. This helps you understand and approach designing programs. Your model will change as your learn. Pointers in particular are complex. Partly because you can do a lot with them, they are the key piece to advanced C functionality. Partly because everyone seems to have slightly different mental models of how it works. My personal model is that C deals with blobs of memory located somewhere on the system. Array syntax is one way of accessing memory at a location. Pointers are another way. Structs are a third. They are interchangeable because they are all just different ways to access data at a location in memory.
I mean starting programming is hard. You chose a great language to start with as it will make you later understand most of the languages philosophy out there.
&gt; Characters are often signed on embedded, actually. By example, ARM ADS, ARM SDT, and in most configurations, CodeWarrior ARM and CodeWarrior Thumb. &gt; This is incorrect. Are we talking C or C++ (there are some minor differences)? It's been a long time since I've reviewed this part of the standard, but my recollection is that in C, whether a `char` is implemented as a signed or unsigned `int` is not defined by the standard. Rather, the C standard only states that a `char`must be able to hold all single byte characters. In the vast majority of processors I've encountered, the C `char` data type was implemented as `int`, but I have worked on a more than 1 system where it was an `unsigned short int`. Regardless, I do agree that all single width `char` values can be safely promoted to an `int`, and with only a few exceptions, an `unsigned int`. Where people get into trouble is like one poster said, by storing the output of `fgetc()` and similar file handling functions to a `char`, and then they miss `EOF` which is often represented as `-1`. Still, that's no excuse to use improper variable types (like using `int` for *constant characters*) or to do things like initializing a variable or pointer at instantiation to zero because you're afraid that you might access an uninitialized var/pointer later. Writing bulletproof portable code in C is not nearly as hard as the C++, Java, Rust, Python, JS, etc people say. The best C programmers understand the tradeoffs between performance and memory, and they also know the standard, as well as the limits of the compiler and hardware they are working with. They also know when to push the limits of the hardware/compiler. Have I ever shipped code that I knew had platform dependent constraints? Absolutely! However, I was aware of those constraints and I made sure that they were documented. The best C programmers rely more on code itself for clarity and documentation than /* COMMENTS */. If I see a bunch of *character constants* being assigned to `int` values, I'm immediately questioning if the developer understood what s/he was doing.
I would suggest getting the book "Understanding and Using C Pointers." It is an all around good read that improved my low level knowledge and helped me with pointers. Also, Stack Overflow *can* be a good place to ask questions. In fact, your question may already be answered by a simple search.
&gt; Thanks, I've gotten more than enough libraries popular. I wasn't looking for your advice. Then, what are you looking for? Besides, you won't get thorough advice from me unless you want to get a contract in place for $250/hr. With *free advice*, you get what you pay for.
The language Dennis Ritchie invented and described in the book *The C Programming Language, Second Edition* [which I call K&amp;R2C] treats arrays and pointers in a way that's easier to understand and less ambiguous than the one defined by the Standard. The Standard doesn't require implementations to treat pointers differently from Ritchie's language, but allows compilers to blindly assume that code will follow certain additional rules with tricky corner cases that nobody can really understand since there was never a consensus about how they should be handled, and to behave in arbitrary fashion if those rules are disobeyed. In K&amp;R2C, every object whose size is N behave as though its value is stored using (N times CHAR_BIT) bits located in N consecutive characters. Each character has an address which may be thought of similar to a building address, which identifies a house number and a street, and pointers hold house numbers. Consecutive bytes have consecutive numbers, and if one has the address of any house on a street, one may find any other address by adding or subtracting some amount from the byte number. Further, address calculations are allowed to compute a byte number just past the highest-numbered byte on the street, even though only bytes that actually exist may be accessed. An array is a range of addresses on a street which can be used to store a sequence of values consecutively. If the system uses four bytes to store each `int`, the declaration `int foo[5];` will cause the compiler to reserve a range of 20 bytes on some street somewhere and associate the starting address of that range with the name `foo`. If the range happened to start at 100 Data Drive, then a statement like `foo[3]++;` would read the bytes from 112-115 Data Drive, interpret the bits thereof as an `int`, add one to that value, and write the bit pattern associated with the new value into 112-115 Data Drive. The model of memory used by K&amp;R2C is simple, elegant, and useful, and describes how most compilers will behave with optimizations disabled. Before you try to understand the vague and ambiguous model defined by the Standard, I'd suggest starting with the much more useful model used by K&amp;R2C and recognize that: 1. The authors of the Standard have described the Spirit of C as including the principle "Don't prevent the programmer from doing what needs to e done", writ 2. Implementations that abide by the Spirit of C and claim to be suitable for various purposes will behave in a way consistent with K&amp;R2C when necessary to serve those purposes, whether or not the Standard requires them to do so. 3. The maintainers of gcc and clang see no reason to uphold the Spirit of C except to the extent required by the Standard. 
You seem to be under the misimpression that you are a respected programmer that other people want help from. You're actually some stranger on Reddit who started yelling, has no work apparently public to justify their presumed expertise, and keeps getting their claims wrong. . &gt; Then, what are you looking for? To warn people that your FSM advice for this problem was terrible, as you eventually half-admitted inbetween insults.
&gt; In the vast majority of processors I've encountered It's not about the processor, it's about the compiler. Two entirely different compilers can validly have different signedness for `char` on the same processor, and often do. . &gt; Still, that's no excuse to use improper variable types (like using int for constant characters) Stop your yelling. It's not as wrong as you imagine. It's correct and normal in many cases, particularly around wide characters. Your schtick seems to be built on never actually admitting any of your own mistakes, while trying to point the finger at other people on unimportant technicalities. . &gt; Have I ever shipped code From the sound of it? Not much.
`8*sizeof(a-i-1)` is constant and is equal to the number of bits in an integer (32, probably).
Pointers are very simple. Think of your RAM as numbered slots, each number is the address of the slot. These slots can hold integers, characters, and so on. When you do `int i = 0;` the compiler behind the scenes figures out where in memory to put it, and it keeps track of the address without getting you involved. This is called automatic allocation, because the compiler knows how to do it and does it on its own for you. For example you want an array of 10 elements, you can just do `int array[10];`. Just like how the compiler knows how to allocate one int, it also knows how to allocate ten. There's though, something called dynamic allocation, for example you do not know how much memory you are going to read, for example you don't know how big the file will be, or how long the user input will be, and so on. For that you want to dynamically (while the program is running) figure it our and allocate the necessary memory for it. The compiler can't figure it out for you. This is achieved using malloc, `int *a = malloc(sizeof(int));`. This might seem like a lot to take at once, so let's go over it: 1. pointers using the * operator, yes can be confusing because it is also used for multiplication. The compiler tells the difference by whether their is a variable or a numeric constant to the left to it, as well as other precedence rules. So, to declare a pointer to an integer, you write `int* p;`, you can also write `int *p;` and you can also write `int * p;` Pick which ever one you like but be consistent. 2. A pointer is merely an address (or the number) of a slot in your RAM, having a pointer doesn't mean you have any memory allocated. You need to tell it how much memory you need. For that you use malloc. C gives you an operator called sizeof, that gives you the sizeof whatever type you want, including your own typedefed structs. 3. malloc returns a pointer, the same pointer type you want. malloc might return NULL if it failed to allocate memory (your RAM is out of memory), so be sure to test for that. To dynamically allocate an array, just multiply sizeof with the number of elements you want. This could be a variable determined at runtime. `int * array_of_dynamic_size = malloc(sizeof(int)*dynamic_size);` I hope this helps. Feels free to ask questions. * Variable Length Arrays are omitted from this post. They are an optional feature in C11.
Which of C and C++ are you programming in?
Which error do you get? “I got an error” is not a useful error description.
I feel that the teacher screwed up here and left out some critical information until the last moment and then dumped it on the students. 
&gt; Any best approach to this? https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html
Please don't insult other users.
&gt; It's not about the processor, it's about the compiler. Two entirely different compilers can validly have different signedness for char on the same processor, and often do. You were saying something about pointless technicalities? Pot, meet kettle. Also, we're talking about C, in case you can't keep up. &gt; Stop your yelling. Who's yelling? &gt; It's not as wrong as you imagine. It's correct and normal in many cases, particularly around wide characters. No, if you want portable code, you use `wchar_t` for wide characters. Jesus Christ....a person writes a few lines of JavaScript or Python and they think they are an expert in software engineering. &gt; Your schtick seems to be built on never actually admitting any of your own mistakes, while trying to point the finger at other people on unimportant technicalities. Your MO seems to be complaining about other people's posts even though you know about 1/10th what you really think you know. &gt; From the sound of it? Not much. Judging by your repos of which you are so proud but have terrible documentation and are full of dust-bunnies, you're one to talk.
Nobody's yelling. I give lots of people help on Reddit and other places. You're just here to argue. Also, to be blunt, your code repos suck ass.
Dude was being a prick. I simply responded in kind. I'm happy to edit the comments, delete them, or get booted. I'm subscribed to too many subs as it is, and I waste too much time giving free advice anyway.
...which means the program causes undefined behaviour by shifting `1` by the width of the type 
Sure thing, friend
Am I correct in expecting that you won't show any of your code, while trying to speak negatively about code you keep misunderstanding? I'm curious to see what drives all this pride 😁 
It sounds like msys2 and mingw-64 would work well for you. http://www.math.ucla.edu/~wotaoyin/windows_coding.html 
Oh god. I use Visual Studio and all you need to do is "Create a new C++ file" and before creating it change the .cpp extension to .c, as far as header files, I just use the default header prefix that Visual Studio gives me and it works fine.
CS50 from edX should be helpful. The class is designed exactly for students like who have no knowledge about the programming and computer science. You probably need a few very very good lectures to watch instead of a book to go through as you have already done so. Search edx and sign up. Find cs50 introduction to computer science. Just watch first 5 lectures. Each takes 90 minutes (long...) so speed up with 1.25x and make sure to focus that 112 mins. The lecture is very energetic and high quality. 
The reason your book has pointers and arrays so close is that they are fundamentally the same. At their most basic level, pointers are just numbers. Without the leading `*`, the compiler will treat them as such. When programming, think of pointers as a portal. You "traverse" (dereference) them to reach another point in memory. Arrays are a special case of pointer, which are easily explained when you consider the numerical nature of pointers. Supposing that you have two contiguous items in memory, `item0` and `item1` item0 item1 \-----------/ \-----------/ w w |----------- 2w -----------| Both of these items have a _width_ (commonly referred to in modern programming as _size_). This width is represented by `w`. Now, imagine a pointer, `ptr` to `item0`. The address of `item0` is `b`. item0 item1 \-----------/ \-----------/ ^ | | (b + (w * 0)) | ptr[0] In an array, `item0` is the 0^th element in the array, effectively it's address can be represented by applying `b + (w * i)` with the index _i_ as 0. Should you want to access `item1` you would repeat the equation with `i = 1` - `b + (w * 1)`. Graphically, this looks like the following - item0 item1 \-----------/ \-----------/ ^ (b + (w * 1) | +-------------+ | ptr[1] If you haven't yet noticed the pattern, `array[index]` is equivalent to `*(array + (index * sizeof(*array)))`.
I still struggle with pointers sometimes and I've programmed in C for years. I wrote this for you, don't be intimidated by the length, I've made it as easy to read as I can. I've written this about `char*` pointers, but it is true for every type of pointer. Pointers point to an area of memory. People hear that phrase and don't understand what it means. Think of it like this: char* s = "hello"; Somewhere in the memory of your computer, there is an 'h' at some byte (chars are 1 byte), and an 'e' at the next byte, and an 'l' at the next byte, and so on. After 'o', the next byte contains '\0', the null character (ascii value = 0), which is there to tell you and your program that the string ends here. To repeat: Pointers point to an area of memory. `s` points to where your new char `'h'` exists. So when you do: printf("%s", s); then `printf` will print all the characters at each byte up until it reaches `'\0'`, then it ends. Part 2: Because `s` points to an area of memory containing the start of your string, we can do some cool things with it. For example: s++; What does this do? It advances to the pointer to the next byte. Now `s` points to the area in memory that stores `e`. So if you try to do `printf("%s", s);`, it will print `ello`. Simple program to demonstrate: https://onlinegdb.com/ryxmjF2kV. Click "Run" at the top. If you look at that link and study it, you can see what's going on. You'll notice never do I index `s` like `s[0]` or `s[1]`. We're just changing the address that it points to. This is one of the many powers of pointers. So what's the difference between `char* pointer = "hello";` and `char array[5] = "hello"`? To keep it basic: * Pointers are immutable. That means you can't go in and change their value. `array[3] = 'b'` is perfectly legal, but `pointer[3] = 'b'` is not. * Pointers don't need to know how long the string is going to be. `array[5]` can only hold up to 5 characters max (not including the `'\0'`) and that's it. Pointers can hold any length at all, because they're not technically "holding" anything, they're just pointing to an area of memory. * Pointers have arithmetic properties which I have shown above. * Pointers can be easily changed to point to something else, whereas it's trickier getting a char array to hold different contents without screwing it up. Example: char* string1 = "hello"; char* string2 = "world"; char* s; s = string1; // points to the 'h' in "hello" s = string2; // points to the 'w' in "world" I hope this helps. 
To help you with pointers and arrays, i super duper recommend this: write small programs that use those things and then put pri tf statements in there to print out pointer values, addresses, array content etc and do variations of them. Use sizeof, ++ and stuff on pointers and data types to start grasping pointer arithmetic. Let things crash, debug to figure out why. Really printf and a debugger can help you a lot here.
For Visual Studio, you just need to create ".c" file (not ".cpp") and it work well. But I think the best way to learn is using gcc &amp; text editor (like VS Code, SublimeText,..) &amp; terminal in Linux (a lot of senior told me that when I started to learn, and I can't thank them enough). I believe Linux is a "must know" for a CS guy, so you should really learn to use it. For easy start, you can run Lubuntu on VirtualBox on Windows. Lubuntu is lightweight and fast, so it doesn't consume much resource.
It works fine even if you haven't declared them ahead of time. Modern C doesnt need declarations ahead of time, at least, as long as you're using a standard written in the last 20 years.
&gt; I'd tell you what was wrong with that but I'm sure you'd say "it's a pointless technicality to point out that the thing I said isn't correct" again Sure you would. &gt; Am I correct in expecting that you won't show any of your code, while trying to speak negatively about code you keep misunderstanding? Just look through my posts here on Reddit. Knock yourself out. &gt; I'm curious to see what drives all this pride The feeling is mutual. 
I'm not sure telling newbies allocating about malloc without any stack frame / heap background knowledge and then implying they both are the same is going to help them. Also you managed to access an invalid memory address (string\[4\]='\\0' will not work in the example you wrote).
You should rewind the FILE pointer after counting the lines (or close the file and reopen it). As it is, after you count the lines the file pointer is pointing to the end of the file, so fscanf can't actually read anything. If you check the return value of fscanf it should be equal to EOF.
That did it! Thanks!
Best way to compile is through terminal, and a text editor. Saves alot of debugging headaches.
You're missing the point: release builds with asserts are removed, so if you're testing values that are not logic errors in your programming (or are very rare logic errors in said program), you're likely going to miss some serious bugs in your program besides crashing. Asserts are only when you, the programmer, messed up code. Anything else should be a non-aborting error mechanism, unless the API has preconditions for the function call and they didn't fulfil them.
&gt; &gt; Am I correct in expecting that you won't show any of your code, while trying to speak negatively about code you keep misunderstanding? &gt; Just look through my posts here on Reddit. Knock yourself out. It's not actually worth that much to me. If you want to talk poorly about other peoples' work without showing your own, more power to you . &gt; &gt; I'm curious to see what drives all this pride &gt; &gt; The feeling is mutual. I'm not lecturing strangers on all the help I give I'm not telling people what they have to do to earn my help after they said they don't want it I'm not telling people what I think of their code without being asked I'm not saying "this is pretty good" then switching to "this is terrible" after nobody was impressed Whatever makes you feel better, though Have a day
Contrary to what the top post says -- I wouldn't say that the K &amp; R book is a good place to start, and I really really disagree that the version doesn't matter. If you get the book, please be sure to get at least the [second edition](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628), as many of the programs in the first edition won't even compile on a modern system. [C Programming: the Absolute Beginners Guide](https://www.amazon.com/Programming-Absolute-Beginners-Guide-3rd/dp/0789751984), and [Zed Shaw's Learn C the Hard Way](https://www.amazon.com/Learn-Hard-Way-Practical-Computational/dp/0321884922) are much more modern approachable books, written after decades of addressing common pitfalls. Lastly OP, don't worry too much. I got through two years of programming in C++ in college with similar worries. Pointers and how they relate to arrays is a tough concept to get at first. The key is repeated exercise and experimentation. Check out [Rosetta Code](http://rosettacode.org/wiki/Category:C) and [Exercism](https://exercism.io/) for some arbitrary problems to do. Also [Advent of Code](https://adventofcode.com/) is on right now!
Pointer[3] = ‘b’; is perfectly valid 
Stick with it, starting in C will make you a better programmer. All other languages after will come a bit easier.
I found that this blog post helped me understand pointers: https://karwin.blogspot.com/2012/11/c-pointers-explained-really.html
Ok
There are 2 types of arrays, dynamically allocated with calloc or malloc (there are other options too like aligned\_alloc, but we'll skip those allocators) and statically allocated arrays. to denote a statically allocated array, you just use bracket notation \`intX\_t Array\[\];\` the brackets can be empty, or they can contain the number of values either way doesn't matter. to denote a dynamically allocated array we use pointer notation like this: \`intX\_t \*Array;\` A pointer is simply a variable that contains the address of another variable, like this: \`intX\_t \*Pointer2Array = \&amp;Array;\` What that line means, is that there's a variable called Pointer2Array, which is a pointer to an array (aka the address f the first element of Array) and the \`&amp;\` means get the address of Array, and store it in Pointer2Array. Let's make a little diagram to explain this concept a little more: Array\[2\] = {0xFF, 0x00}; which means that Array is laid out like this: Array\[0\] = 0xFF; Array\[1\] = 0x00; Now, there's one more piece to arrays that we haven't needed t care about before, but with pointers we do. We need to know where in memory the array is located, normally the compiler and runtime handle this detail for us when it comes to local variables and whatnot, and we don't need to concern ourselves with that. With pointers and arrays, we kinda have to know where everything is so we know it doesn't point to junk. so \`Array\[0\]\` is located at address 0x7F262374 and since Array is a byte array, \`Array\[1\]\` is located at 0x7F262375. So, when that line way above, \`intX\_t \*Pointer2Array = \&amp;Array;\`, is getting the address of the Array variable, that's what's being stored. Pointer2Array now contains the value 0x7F262374. In order to use the value stored in Pointer2Array as an address to another location in memory, instead of as it's own actual value, you'd need to dereference the pointer by using the \`\*\` operator again, OR by using array notation \`\[\]\`. I feel like I didn't do a good job explaining it, does this make sense to you? Has it raised any other questions for you?
What do you mean by "convert decimal to binary"? Do you have a string you're trying to convert into a number, or are you messing around with floating point types? are you trying to print a value stored in memory to a human readable number like a string? What exactly are you trying to do?
I'm studying CS also. The thing is, I barely understand what my teacher is saying (or maybe I don't give much attention). I've learned all the thing by watching some tutorial from Udemy/Linda. Try those courses. If you cannot afford the courses then you can download them from torrent(illegal though). 
It compiles, but will produce a seg fault.
Both clang and gcc reject it by default.
Typo. As for the rest, most people who've I've explained it to found it a lot more intuitive this way.
Thank you very much for the time spent on that long reply. I woke up to it, but of course read every single word of it. A lot of it did fly over my head, because of how new I am, but I'll just have to make sure to look into things like standard error and how to use it on my own time. You giving me good practices like this is more than I could ever ask for, and it's what I was asking for. I can't thank you enough for all the trouble you went to typing it all out, either. Even if they're small tips, I've internalized what you've said, and those tips will begin to manifest themselves in my code from here on out. I have been trying to be consistent with my code's formatting, as I'm actually using an editor, rather than an IDE, but I think I make mistakes every now and then, unfortunately. I do have hard set rules in my brain now about things I do, mostly to make the code more legible. 
No, he is not a prick. You are a prick for first posting incredibly misguided advice (no, a finite state machine won't help OP at all here) and then being a really bad sport when someone points this out.
Thank you!
I understand, thanks! 
I cannot understate the importance of your advice.
I have encountered the same problem with the pointers! It didn't took a while but lot of time to understand pointers. A simple tip if you are trying to learn pointers study them visually. Even you can study array visually. Don't go through books. If I would have kept reading books for learning programming I would have still sticked to pointers! This doesn't mean you shouldn't read books! First of all you should understand the concept and you should be able to visualise what would happen in memory. If you understood this then you can move on to read books. It will become easier for you to grasp the concepts easily. I am a visual learner and I am glad that I did it in that way.
I haven't done this sort of thing at all, so you're the expert here. but have you tried using the simple, lowly, system function?
The title here says "Recommend by the industry level experts". The article says "Recommended by the programming community". Either way, it's so unspecific as to be meaningless. As far as I can tell, this is just Amazon Affiliate spam.
Because why should the authors make any money, right?
Pointers are somewhat tricky man...I would recommend you to watch online tutorials on pointers . 
Don't make all the pipes at once. Make a loop that takes in *input* fd, initially 0. If it's the last command, *output* fd is 1, else you need a pipe. Fork the command, close *input* and *output*, and for next round, set *input* = pip\[0\]. Be careful not to close 0 or 1 in the parent. In the child, just close everything from 3 to 100, if you don't want to keep tabs on every fd :)
The version I found online is pre ANSI C. I think it is ok to have outdated versions online and look at them. Nevertheless I bougt the latest version because I think it is a gerat book. In my opinion if you find something usefull for free and like it, go buy it so authors get payed for their efforts and continue their work.
Actually there is nothing complicated about pointers if you are just working on engineering projects. They became a real peoblem if you deep into the computer science i think reading tutorials point text about pointers and pointer aritmetic will be enough to understand the basic concept and after you should make exercices for use them in your projects effectively
&gt; `rewind(array);` Well there's a bug. If you want to have access to the array in `displayfiledata()`, you have to either split your line counting into a separate function and allocate the array inside of `displayfiledata()`, something like this: int lines = countlines(); numFileStruct *array = malloc(sizeof(numFileStruct) * lines); readfileintoarray(array); or return the `array` pointer to the array from `readfileintostructs()` (meaning its return value will no longer be void but `numFileStruct *`)
This article is a poor list with Amazon referral links. &gt; * Learn C the Hard Way Nope. [Don't Learn C the Wrong Way](http://hentenaar.com/dont-learn-c-the-wrong-way).
I absolutely do not mean to write this in a negative tone, but I've read this advice so many times. I know to swap the file type to .c (should have mentioned, sorry) but VS still suggests C++ headers like iostream to me. Same with GCC and VS Code, I can get GCC through Cygwin and get the version through the Cygwin console, but I do not get how to configure VS Code to pick out the GCC compiler from Cygwin's directory. This can't be that complicated, right? I feel increasingly dumb after so many separate failed attempts.
That would be kind of cheating because that function actually calls a shell to parse and execute the commands it's given and open and connect the pipes.
I was referring to C compilers for the various MCUs I've worked with.
Why did you use a macro to define N here? Really confused about that part.
Default header prefix? Given where/when?
No particular reason, other than for testing with N range 0 ... 5.
&gt; or return the array pointer to the array from readfileintostructs() (meaning its return value will no longer be void but numFileStruct *) I tried &gt; return array; at the end of readfiletostructs() and having displayfiledata() accept an array of type struct but I get "array must have struct or union type" when I try to print it in displayfiledata(). Also I don't know how often to loop in displayfiledata() which you address in your first point but I have to have the array allocated inside readfiletostructs() https://pastebin.com/5ua9L1w9 
No it won’t. There’s nothing wrong with using array notation with pointers. 
try compiling with all warnings (-Wall -Wextra) - you're still rewinding array, array is not a file descriptor, what you want to rewind is numFile - readfileintostructs() is still of type void, even though it returns a value, this won't even compile. It returns `array`, which is a `numFileStruct *` and as such should be declared as `numFileStruct *readfileintostructs()` - You're not storing the returned pointer anywhere, and you're not passing it to `displayfiledat()` I will say it again because this is key: compile with all warnings enabled, it will tell you what's wrong and where.
Get Dependency Walker and check if the Dependency on libgcc is direct or through another lib.
I've been using flags like this: &gt; -static-libstdc++ -static-libgcc -Wl,-Bstatic -lstdc++ -lpthread -Wl,-Bdynamic The -Wl passes flags directly to the linker, and -Bstatic/-Bdynamic turn on/off the linking state... I think it's implicitly dynamic which makes sense in my world. As always, start a new command prompt and set the path to nothing (path=.) make sure notepad won't open and test... then you'll know for sure if your DLL / Library is mangled. You can even build DLL's manually, and link directly to the library objects giving you a more static binary...
Why would you use gcc on windows? Clang has binary compatibility with MSVC, and clang-cl has a compatible CLI interface...
If you're really stuck on Windows, here are three options. I've put them in order of best to worse (in my opinion). # Windows Subsystem for Linux (WSL) This is only available on Windows 10, but you'll get a very solid Linux environment without having to change operating systems. Pick an easy distribution like Ubuntu, open a terminal, install the `build-essentials` package (`pt-get install build-essentials`), pick out a text editor that has a terminal interface (recommendation: Vim or Emacs), and get to work just like you were on Linux (without Xorg). You can simply invoke the compiler by the name `cc` while you focus on learning the language. The binaries you produce are actual Linux binaries that you could run unmodified on a real Linux system. cc -Wall -Wextra -O3 example.c ./a.out # Cygwin Available on any version of Windows. It's a little slower and clunkier than WSL. The binaries you produce are weird Windows executables that are linked to the Cygwin environment, and are essentially tied to that environment. You can install GCC trivially through its package manager, so it's no headache. Again, you can just invoke the compiler as `cc` while you learn. cc -Wall -Wextra -O3 example.c ./a.exe # Visual Studio, just the build tools Forget Visual Studio the IDE. There's a reasonable set of command line tools alongside that monstrosity. Don't try to put them on your PATH yourself. Instead, find the batch file `vcvars64.bat` in the Visual Studio installation. Open up a console window and execute this batch file by name in that console. This will properly set up your environment in that console for using the command line tools. I'll run gvim (native Windows GUI version of Vim) *after* setting up the environment. This imports that environment into Vim, which lets me invoke the compiler and `nmake` and such from the editor. With the environment set up, you can invoke the compiler as `cl`. Unfortunately it's irritatingly noisy by default, so make a habit of invoking it as `cl -nologo` to shut it up. cl -nologo -W4 -D_CRT_SECURE_NO_WARNINGS -Ox example.c example.exe 
.h is the one that Visual Studio automatically creates for you.
Isn't that a postfix? Why call it anything besides a file extension? :/ And by "creates" I can only assume you mean "adds as a dependency," otherwise I have no idea what you're talking about, and even then I get more than just headers ending with .h.
No it does not add a dependency. How hard can it to be to use an IDE? Sure, the C functionalities are a little bit hidden and its crappy that you need to change the extension but holy Jesus. Create a new "C++ Terminal Project" or "C++ Console Project" something along those lines. Then on your right hand you should have a File explorer and a folder with some files that were automatically created like pch.h or some crap like that. Delete those and right click it that folder and select "Add a new element". Then just navigate to the C++ section and if you want to create a header file just click on create, if you want to create a .c file just select "C++ file" and before creating it replace the ".cpp" extension with ".c". You will have to disable precompiled headers but I will let you google that, I really dont know what is going on with your IDE or if you are using Visual Studio 2024 instead of 2017.
I can also add iostream to my header files. Just dont do it... I have access to all the standard headers of the C library like stdlib.h or stdio.h
You can go fuck yourself too.
Understood, I have this now I believe, compiling without warnings but when I try to print using the pointer I get the error "expression must have a struct or union type. I tried dereferencing the pointer but it did nothing. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct { int firstNum; int secondNum; } numFileStruct; numFileStruct *readfileintostructs(); void displayfiledata(numFileStruct *numFileStructPtr); int main(void) { displayfiledata(NULL); } void displayfiledata(numFileStruct *numFileStructPtr) { numFileStructPtr = readfileintostructs(); // gives error described above printf("%d", numFileStructPtr.firstNum[0]); } numFileStruct *readfileintostructs() { char FILENAME[] = "numfile.txt"; char temp[1000]; FILE *numFile = fopen(FILENAME, "r"); // check if file can be opened if (!numFile) { fprintf(stderr, "Can't open %s for reading\n", FILENAME); // warning here i am aware exit(1); } int lines = 0; // get total number of lines in file while (fgets(temp, 1000, numFile)) { lines++; } printf("%d\n", lines); // create array of structs numFileStruct *array = malloc(sizeof(numFileStruct) * lines); rewind(numFile); // read array into array of structs for (int i = 0; i &lt; lines; i++) { fscanf(numFile, "%d %d", &amp;array[i].firstNum, &amp;array[i].secondNum); } return array; } 
I understand that you are angry. Perhaps it's best if you stepped back from this discussion for a while and then came back when you are calmer.
Oh, I totally didn't notice the affiliate links. Post removed.
Do not spam affiliate links.
Nahhh. I won't be calmer later. I'm always like this. The world would be a much better place if people would care less about *being civil* and stand up to the Dolores Umbridges of the world. Honestly, if I were in your shoes, I'd just ban me. Life's too short to put up with nonsense.
&gt; Create a new "C++ Terminal Project" or "C++ Console Project" something along those lines. With the latest update of VS 2017 it's just New Project -&gt; Visual C++ -&gt; Windows Desktop -&gt; Windows Desktop Wizard. After you do that, you get another dialog, choose console application from the list, check empty project and uncheck everything else. That is all you need to do, nothing else, and of course use the extension .c instead of .cpp
You're trying to access an array (`numFileStructPtr`) with the dot operator, the dot is only valid on unions and structs, not arrays, you have to do it the other way around: `numFileStructPtr[0].firstNum` because numFileStructPtr is an array of numFileStruct, so numFileStructPtr[0] is the first numFileStruct of the array.
Header files are normally written by hand. I guess it is possible to automatically generate a header files which contains prototypes and declarations for variables and functions with external linkage in a given code base, but I don't see the point. First, it doesn't really save you much work; second, headers usually contain more than just prototypes and variable declarations; third, you need the header to compile the code in the first place.
&gt; You will have to disable precompiled headers Why? In my admittedly limited experience, they work just fine.
I can't make sense of your code. If you're trying to print `a` as a binary number, all you need is this: for (unsigned int b = 1U &lt;&lt; (sizeof b * 8 - 1); b &gt; 0; b &gt;&gt;= 1) putchar((unsigned int)a &amp; b ? '1' : '0'); Or if you want to get cute, for (unsigned int b = 1U &lt;&lt; (sizeof b * 8 - 1); b &gt; 0; b &gt;&gt;= 1) putchar('0' + !!((unsigned int)a &amp; b)); 
"You need the header to compile the code in the first place" well the header file that will be included by the client code is not part of my library compilation if I am not completely off? I am building the library and want to provide a header file that can be included by someon elses codebase in order to compile and later link with my library.
It could be outdated, but check out [cproto](https://invisible-island.net/cproto/cproto.html) 
&gt; How are they deployed to avoid duplication? If you don’t need the stuff in the public header but multiple source files need it, just make your own header in the same directory as the source code and `#include "it.h"` like that. If you do need the stuff in the public header, you can generally just stow it there. Most people do headers by hand because the decisionmaking about what goes where can get a little twisty—e.g., you generally just want function prototypes, but shared inlines should go in headers too. Also, some `struct`s only get declared (not defined) publically if they’re only used as a pointed-to type, stuff like that. For really simple cases, you could *start* (not maintain) a header by doing some trickses—empty-define marker macros and use someting like `gawk` to find those and pull out headerables, or go with `flex` and `bison` to make a fuller C parser that pulls things out more cleverly.
&gt; heavily tied to concepts like heap and stack C has no concept of heap or stack.
Hatewrecked is correct, in this particular case, because `pointer` points to a string constant, and modifying it invokes undefined behavior. But it's a very bad explanation because they're basically saying that the *only* thing pointers are used for is string constants.
&gt; stack frame / heap background knowledge C has no concept of stack or heap. A stack frame is simply one of several ways to implement subroutine activation records. C can be implemented with or without a stack; other languages, such as Simula or Lisp, *can't* be implemented with a stack even if it looks like they can at first glance.
Please [do not recommend LCHW](http://hentenaar.com/dont-learn-c-the-wrong-way).
&gt; The language Dennis Ritchie invented and described in the book The C Programming Language, Second Edition [which I call K&amp;R2C] treats arrays and pointers in a way that's easier to understand and less ambiguous than the one defined by the Standard. TCPL 2 describes C89, so no.
In addition to function prototypes and variable declarations, your header will include things like macros and types which both your library and the application will use. Declare your functions and variables, define your types and macros, and include your header in every single source file that goes into your library. Otherwise, you will end up duplicating much of the contents of the header in your source code, and run the risk that your code and your header diverge if you modify one and forget to update the other.
While it is possible to write code the way you describe, the usual approach is to compile your library using the same header files you later install.
&gt; For really simple cases, you could start (not maintain) a header by doing some trickses—empty-define marker macros and use someting like `gawk` to find those and pull out headerables, or go with `flex` and `bison` to make a fuller C parser that pulls things out more cleverly. Just do it by hand ffs. You'll spend more time writing and maintaining your script and fixing the corner cases that they can't handle than it would take you to do the work yourself. There are cases where it makes sense to generate headers automatically, but those are usually cases where the interface is described in a metalanguage or IDL such as XDR, COBRA OMG (used by the W3C to describe the DOM), or BSD VOP definitions.
My Visual Studio always cries about the precompiled default header it creates not existing after you delete it. 
C89 describes the language the C Standards Committee was *supposed* to describe. There are a number of situations where K&amp;R2 would say that a piece of code would work a certain way, but the Standard would regard it as violating a constraint. For example, in K&amp;R2C, `int i=0x1e-2;` would set `i` to 28. In C89, it's a constraint violation. In K&amp;RC2, if address arithmetic on part of a larger object would yield the address of a different part, the resulting pointer can be used to access that other part. C89 fails to define means of accomplishing that even in cases where the offsets are known (which rather limits the usefulness of the `offsetof` intrinsic). The K&amp;R2 model of memory is simple. The Standard C model is anything but. 
Why did you delete it?
Because I dont need it?
It's highly unlikely a guy asking for help about pointers is going to try and implement his own compiler; I think learning the difference about stack and heap (which are two things most compilers support) is useful to understand how memory works. 
&gt; It's highly unlikely a guy asking for help about pointers is going to try and implement his own compiler I never suggested that, but there's no reason to talk about the stack or the heap when teaching C, and it can lead people to form mental models which will make it harder for them to learning other languages later on.
You basically said “I don't use it because VS complains when I remove it”. That makes no sense. Leave it alone and it will do what it's meant to do, i.e. speed up compilation.
There is if you're going to make any reliable application on any modern operating system. What are the "mental models" that can cause people to have a hard time afterwards?
Please go back and remove the extra backslashes from your source. They aren't needed when you already have code formatting.
If header is not already defined, define it.
&gt; There is if you're going to make any reliable application on any modern operating system. Why? You don't need to know whether your C implementation uses a stack to write a working program.
Reddit puts them sometimes for some reason. 
What can I do with a definition of a header file?
Maybe not a simple program, but you will likely run into issues later on if you decide to make something more serious (stack overflows) and want to make use of random access memory / localized address space to improve your program performance.
1) format your code for reddit by indenting it 4 spaces. 2) it's to include the enclosed stuff, only if it hasn't already been defined. To avoid defining things twice if some other .h file tries to also include it. &amp;#x200B; The practice is nonstandardly but defactoly being replaced with `#pragma once` &amp;#x200B; see [https://en.wikipedia.org/wiki/Pragma\_once](https://en.wikipedia.org/wiki/Pragma_once) &amp;#x200B;
[The Wikipedia article on include guards](https://en.wikipedia.org/wiki/Include_guard) has a nice example as to why they are required in general.
Can't check your code right now, but first oddity I found is `&amp;array[1]`. Shouldn't it be just `array + 1` and a pointer in second argument to function? You want to pass an array starting at second element, do you not? 
They are in the source along with "\&amp;#x200B;" on blank lines. I'd guess whatever editor OP used added them into the copy buffer.
&gt; ​The thing I'm having the most trouble with is &amp;array[1]. Does the array then start at 4 instead of 1 or what happens? If someone could explain a few loops that would be great. `array[1]` accesses the second element in the array (remember, arrays start at 0). The address-of (`&amp;`) operator yields the memory address of whatever is on it's right hand side. So `&amp;array[1]` gives you the address of the second element of `array`. In your code `&amp;array[1]` is being passed as the second argument (`int array[nrOfElements]`) to your function. What happens here is that the second element in your array becomes the starting position for the array in the new invocation. This effectively just passes the array to the function again, but starting at the second position. The first element is skipped, basically. I don't know if you learned about pointers yet, so I'll skip on those. Once you grok pointers and how arrays decay to pointers in parameters, this will all make sense.
https://en.wikipedia.org/wiki/Include_guard
FYI `&amp;array[1]` and `array + 1` are identical.
Ah, didn't even cross my mind it could be something else I'm using.
This might help you https://stackoverflow.com/questions/1653958/why-are-ifndef-and-define-used-in-c-header-files
Its called a header guard. Google it.
Yes, I know. I said it's an oddity, not invalid code.
Im not gonna use their crappy auto-generated precompiled headers so I delete them, once I delete them the header precompiler cries so I disable it since Im not gonna use it. You should have more important things to do than telling a stranger how he should setup his IDE.
I'm getting the same result on every run. What do you mean by "sometimes a get the right output but most of the time I don't"? This code (the same as yours, but a bit cleaner): ``` #include &lt;stdio.h&gt; static int arrayFunc(int nrOfElements, int *array, int val) { if ( nrOfElements == 0 ) return val; else if ( array[0] % 2 == 0 ) return arrayFunc(nrOfElements - 1, array + 1, val + array[0]); else return array[0] - arrayFunc(nrOfElements - 1, array + 1, val); } int main(void) { int arr[] = {1, 4, 2, 7, 9, 3}; fprintf(stdout, "%d\n", arrayFunc(6, arr, 2)); return 0; } /* vim: set ft=c sw=4 sts=4 et: */ ``` prints `8` every time, which is correct (a sum of even numbers in the array).
I'm supposed to do it by hand, with pen and paper. 
For hosted implementations, the Runtime library has a definite concept of the heap. C also specifies that execution contexts are kept in some kind of storage medium that can accommodate objects with last-in-first-out lifetimes--a concept which looks like a stack, walks like a stack, and quacks like a stack, even though there would be other (generally less efficient) ways of achieving the required behavior. 
Oh, I get it. It's simple: you are running the function recursively, passing the array (`array`) from its second argument and a value (`val`), that is just there to hold the result for updates. So, on first execution the function will get `{1,4,2,7,9,3}`, on second - `{4,2,7,9,3}`, on third - `{2,7,9,3}` and so on until `nrOfElements` it gets is 0, which means we've checked all the elements (because of `nrOfElements - 1` on each execution). Now, look at the `if - else if - else` block. First `if` is easy, last `else` is just recursion with no change to the value. The meat is in `else if`. If you don't know that yet, google - or better - experiment with `%` operator and see what it does. The rest will be a piece of cake. Since you already know what is the result for `{1, 4, 2, 7, 9, 3}` and `(6, arr, 2)`, calculate it for `{2, 6, 0, 8, 5}` and `(6, arr, 3)`. On paper :)
You're describing the language Dennis Ritchie invented. The language actually described by the C Standard added some additional rules without bothering to include corner cases sufficient to uphold the Spirit of C principle "Don't prevent the programmer from doing what needs to be done". In Ritchie's language, given `int foo[4][5];`, `foo[0]` would yield a pointer to the start of a group of 20 integers that may be accessed consecutively. In Standard C, however, the pointer could only access the first 5 elements. In Standard C, one could compute `foo[0]+5`, and it would be guaranteed to compare equal to `foo[1]`, but `(foo[0]+5)[x]` would only be valid for values of `x` from -5 to -1, while `foo[1][y]` would only be valid for values of `y` from 0 to 4. I don't think Standard C actually specifies any means by which one could create an `int*` that would be guaranteed usable for accessing all 20 elements of `foo`.
The comments about header guards are correct, but not quite enough for good understanding. For the rest of this example let's assume the build system is configured so it can find the following files. foo.h: //Comment void bar(void); struct S { int s_int; }; foo.c: #include "foo.h" void bar(void){ return; } main.c: #include "foo.h" void main(void) { bar(); } First, realize that `#include` is a preprocessor directive that means, "Find that file, copy it's contents into this current location". After the preprocessor runs on `foo.c`, there is a file that looks like this (it's just in compiler memory though, so there's not acually a file name). //Comment void bar(void); struct S { int s_int; }; void bar(void){ return; } After the preprocessor runs on `main.c` we are left with this "file" in compiler memory //Comment void bar(void); struct S { int s_int; }; void main(void) { bar(); } Second, this collection of code is passed to the compiler stage. Each of these new files on their own is fine, but a `struct` can't be redefined. So the failing output of this will be an error something like: In file included from main.c: foo.h error: redefinition of 'struct S' struct S { ^ foo.h note: originally defined here struct S { ^ &amp;#x200B; Now let's take a look at what happens when the `foo.h` file adds include guards like this foo\_include\_guard.h: //Comment #ifndef FOO_H #define FOO_H void bar(void); struct S { int s_int; }; #endif Assuming the preprocessor hits foo.h first, the inclusion in `foo.h` now looks at the `#ifndef` sees no definition, so it includes the file like so and adds `FOO_H` to the list of definitions //Comment void bar(void); struct S { int s_int; }; void bar(void){ return; } When the preprocessor reaches the include in `main.c` it checks the `#ifndef` finds it defines and so excludes the text between the include guards. Leaving a file that looks like this (note the `//Comment` from `foo.h` is included because it was outside the include guards): //Comment void main(void) { bar(); } This will end up compiling fine without any problems. &amp;#x200B; If you have a project that's working and you want to try this out, just add the `struct S` to an include file that's in more than one file and remove the include guards.
Include guards have nothing to do with including the same header in more than one source file. They are to protect against #include "foo.h" #include "foo.h" //potential for redefinition errors void main(void) { bar(); }
This helped me immensely - [Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/~tjensen/ptr/pointers.htm)
I assume it can’t be used to analyze kernel drivers, as it has to run the code, right?
I've worked with a lot of crappy old embedded builds that pulled everything into a single compilation unit before doing optimization. Your example is more right as generally separate files are separate compilation units. &amp;#x200B; Edited my example to reflect modern compilers.
I may have a lead for the first issue. I haven't looked at it deeply, but for the first issue, it looked like you are closing the connection after only extracting one Time (which i presume is the same as extracting one timezone). After timeextract, you close the connection. This "lead" is presuming that your client sends separate packets for the different timezones. I may very well be presuming wrong, or maybe you've thought of this or this does not apply, but on the ott chance this helps I decided to comment.
That does make sense to be honest. I have an idea on how to fix it but not sure if it'd work, put the closeconnection bit in the if statement which is responsible for the "CLOSE" string. Makes sense in my head, user wants to CLOSE, client outputs BYE, connection is closed.
It's a static analyzer, so it shouldn't have to execute/compile the code. So it should be used to statically analyze kernel c, but it won't be able to determine coverage and testing metrics. I've used polyspace in the past, but I can't remember if it's like of a compiler meant that it replaced the preprocessor definitions or not.
Yes. As a static analyzer, IKOS does not execute any code, and it doesn't need to know about the libraries that you are using. &amp;#x200B; It should be able to analyze kernel drivers. A minor problem is that the default analysis is interprocedural, and starts from the `main()` function, that is probably not present in a kernel driver. You could either write a small `main()` function that triggers your code, or use the intraprocedural analysis (but you will get a lot of false positives).
Please show me where the word “heap” appears in the standard.
&gt; crappy auto-generated precompiled headers You realize that they're exactly the same as the original headers, just preprocessed to significantly reduce compile time? &gt; Ken Thompson is my father lol
&gt; make use of random access memory ...as opposed to...? Just stop trying to teach the stack to beginners, it's an additional concept to wrap their head around that they have *absolutely no need for*. Those neurons are better spent learning about lifetime and scope. They don't need to know about the stack until they start learning recursion, and probably not even then.
The Standard describes the ability to allocate storage from somewhere and later free it. It does not say where that storage would come from, and would not forbid an implementation from processing `malloc` by sounding a bell, pausing program execution, and waiting for an operator to insert a memory module of the appropriate size into the machine, nor processing `free` by activating a solenoid that would elect the no-longer-needed memory module, but the behavior of `malloc()` and `free()` will look like a heap, walk like a heap, and quack like a heap, regardless of its actual physical implementation, so from a practical perspective it will be indistinguishable from a heap. 
If only preprocessed compilers were just that... Open your eyes buddy.
The C compiler is very stupid when it comes to "importing" stuff. Unlike other languages, C does not have any such functionality. But you do have "include" which literally just pastes the file contents there. If you paste twice, you get multiple definition errors. Remember: other headers can also contain headers so this gets messy fast. This is why we let preprocessor handle it by defining a macro for our header and not including it if already defined. 
How does it compare to [Cppcheck](https://en.wikipedia.org/wiki/Cppcheck)?
Now, this is interesting. And it's an open-source release sponsored by the U.S. taxpayers as well. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/opensource] [IKOS 2.1: an open source static analyzer for C and C++](https://www.reddit.com/r/opensource/comments/a5c740/ikos_21_an_open_source_static_analyzer_for_c_and_c/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
You watch too much Infowars.
Thats why Im woke af.
I still maintain that it is completely unnecessary and counterproductive to teach beginning programmers about the concepts of heap and stack. Teach them about scope and lifetime instead.
[Paper](https://ti.arc.nasa.gov/publications/16610/download/) &gt; The DO-333 extension to DO-178C lists Abstract Interpretation [4] as a possibility to obtain certification credits. Unfortunately, there are few available commercial static analyzers based on Abstract Interpretation. Moreover, they often lack precision and scalability for C/C++ code, or, they are restricted to strict subsets of C. &gt; IKOS provides abstract interpretation concepts for developing specialized analyzers, which helps drive down the number of false positives without compromising scalability. Designing a specialized analyzer using standard methods is long and difficult. IKOS facilitates this process by factoring out most of the expertise required to write the analyzer. &gt; Guillaume Brat, Jorge Navas, Nija Shi and Arnaud Venet. IKOS: a Framework for Static Analysis based on Abstract Interpretation. In Proceedings of the International Conference on Software Engineering and Formal Methods (SEFM 2014), Grenoble, France.
C is not for the lazy.
The reason it goes from arrays to pointers is that in C, an array is equivalent to a pointer to the first element of that array. In other words, `foo == &amp;foo[0]`. Don't panic. This is one of those class situations where everything is easy until suddenly it isn't. But once you get this one thing, it will be easy again. * Read `&amp;foo` as "the address of foo". Address means memory address, which is pointer. * Read `*foo` as "contents of pointer foo". Foo has to be a pointer to *dereference* it like that. Declarations are just a tiny bit different. Read right to left: * `const char *bar` means, right to left, "bar is a pointer to a const char". * `float *baz` means "Declare baz as a pointer to a float". 
Those are Header Guards, to keep the compiler from including the same header twice and causing all kinds of issues. `#pragma once` is more modern and faster, so make sure to put that before the header guards
Just write everything in header and make them `inline`. (/s)
This! When the choice is to spend two minutes websearching for an answer, or four minutes writing a quick program to test your understanding, write the four-minute program. Once someone starts doing this, they've just moved up a level compared to where they were previously. 
you could always plan first, (flow charts scribbled on paper often helps you understand the problem before coding) then you minimise the number of times you need to change your function signatures....
Unless someone is interested in performing the kinds of tasks (primarily low-level and embedded ones) for which C is uniquely suitable, why learn C at all? One need not worry about the precise details of how stacks and heaps are implemented to recognize that: 1. Storage for automatic objects has to come from somewhere, that somewhere is generally referred to as "the stack". On many systems, the total amount of stack storage available for automatic objects in a particular execution context will be only a small fraction of the total memory. 2. Storage returned from `malloc()` and similar functions has to come from somewhere, and that somewhere is generally referred to as "the heap". There's no need to get into the nitty gritty details of stack frames, free lists, etc. to benefit from knowing what people are referring to when they talk about "the stack" or "the heap".
Can static analysers, tools like valgrind and pedantic compiler switches be considered as advantages for C (against other newer options) in deciding the programming language of a **new** project?
Apocrypha. 
&gt; In my experience most people recommending it have not read it. We all read it. We may have read it decades ago, and already been programming well before reading it, but I'd say most people recommending it have read it. That said, there's room for improvement. I haven't read "A Book on C", but I liked ["The C Book"](http://webhome.phy.duke.edu/~rgb/General/c_book/c_book/index.html) when I needed a refresher. 
&gt; Imagine learning the English language today by reading Shakespeare You'd learn a lot. It just wouldn't be a well-rounded education, by itself. 
In the language Dennis Ritchie invented and christened C, any consecutive region of storage of at least N bytes, which is aligned suitably for use with type T, can be treated as an array of N/sizeof(T) objects of type T, without having to actually be one, so there's no need for any concept of a "dynamically allocated" array. Because the Standard doesn't allow a `T*` to be indexed unless it actually identifies an array of type `T`, use of a `malloc()` region as an array would seem to require a means by which a dynamically-allocated array could come into existence within such a region, but I don't see anything in the Standard that defines such a concept. Further, I don't like your use of the phrase `statically allocated` to describe a concept which could apply to objects of static, automatic, allocated, or thread duration. I prefer to call such things "named objects", given the Standard's lack of suitable coinage. 
&gt; `char *x = s + len - 1;`, I don't understand why it's not *s &gt; so would *s not be the memory address? No. `*s` means "the contents of s (which is a pointer)", also known as "dereference s". `s` by itself is the address. It might be confusing because it's being declared in the same line it's used; this once confused me as well. This is the same syntax: char *x; x = s + len -1; Change your copy and see how it works exactly the same. Probably the same assembly code as well. In `char *x` there, the `*` is just part of the declaration, not a dereference on the spot. 
Its called refactoring dude. 
Good advice. Leverage your toolchains. I lean on mine quite heavily, though a little bit less every year. 
K&amp;R 2nd edition is a pretty good book, but when I needed a refresher I was happy with ["The C Book"](http://publications.gbdirect.co.uk/c_book/) (now free online). The best advice is that when you're confused about something, see if you can figure out how to test it in a short program. Keep copies of your exercises and little programs. Put comments on them so you know what you were trying to figure out or test at the time. When you remember doing something before, look at your own code first. 
Now you're arguing my point. Since you're not saying anything about what makes the stack a stack and what makes the heap a heap, there is no need to use those words. Just refer to them as two separate pools of memory and mention that one of them is usually much smaller than the other. Or would you like to start discussing how uninitialized and pre-initialized static variables and constants usually live in separate areas of memory, so that there are at least three, possibly as many as five separate pools?
In many organizations, almost all of the production servers are virtualized today. Years ago, VMware wouldn't let you set arbitrary MAC addresses in a VM. But they gave that up years ago, probably because competing hypervisors didn't have that restriction. 
Cppcheck is **unsound**. It uses heuristics to find bugs in your code, but it can miss bugs. The advantage is that it produces a small rate of false positives (i.e, warnings that are not actually bugs). By the way, clang-tidy is also a very good unsound static analyzer. &amp;#x200B; IKOS is sound, so it will actually try to prove that your code is safe, and will warn about anything that could not be proven safe. Thus, it produces more warnings than cppcheck, but gives you way more confidence in your code (see [abstract interpretation](https://en.wikipedia.org/wiki/Abstract_interpretation)).
&gt; For example, the popular disassembler IDA-Pro inserts licensing details into all project files it creates and refuses to open projects with wrong license data. So if your team uses IDA-Pro, you either have to buy licenses for the whole team or run entirely off hacked copies, making misuse easy to detect. That seems to guard mostly against buying one copy and running it multiple times, not against having a dozen cracked copies each with false licensing info, no? If so, reminds me of old Photoshop. Adobe seemed to be cunning in how it wasn't hard to run one pirated copy, but it was much harder to run a business with several copies sharing the same license info. 
It sounds like you have an idea what you're doing now. In the future, and for other readers, anyone with this sort of request should press their customer about exactly what they expect. As is evident from this thread, the subject is book-sized, with nothing foolproof, and not even any easy recommendations (except perhaps "Don't do that"). We engineers always want to avoid failing to meet client expectations, and just as bad, spending a lot more time and effort than the client intended. Avoid that by knowing the general considerations around copy-protection, and then asking them specifically what they expect. If they anticipate that you'll spend a dozen hours researching and weighing considerations, then that by itself is worth the conversation. But if you were to spend that time, only to find out that the client thought this would take only one hour and five lines of code and zero ongoing dollars, you might have a problem... 
Which for OP will be 100% of his use cases. 
If you use a decent IDE or editor, you just have to do it once and the IDE/editor changes the other one for you.
Use the [Feynman algorithm](http://wiki.c2.com/?FeynmanAlgorithm). **You think hard about what the function is going to do, then you put the prototype in your header file.** Less facetiously, there are systems where the documentation is written first, even APIs where the documentation is written before the code. Or you can write the function locally first, and copy the prototype into your header only after you have it working in one compilation unit. Quite often you'll by passing-by-reference pointers to structs in your functions, and you'll need to edit the structs in your header instead of the function prototypes. I use an editor that has high performance starting and opening files, and can have multiple files open at the same time if I want. 
&gt; `*s` means "the contents of `s` (which is a pointer)" Does this mean the contents of where `s` is pointing, or is the contents of `s` just a memory address since it's a pointer?
guess and guessLimit are used uninitialiesed
"Contents" means not the memory address, but what's at the memory address. Remember, outside of variable declarations: * `*` means the contents of. * `&amp;` means the address of. Ampersand means address, and addresses are pointers. Also sort-of when declaring strings: char *mystring = "This is a pleasant and jovial string." It's most common to use `&amp;` syntax -- "address of" -- when passing a non-pointer type into a function. We like to pass pointers around because it's higher performance and more flexible, as C is otherwise a "pass by value" language. 
&gt; (i = 0; i &lt;= 2; i++) You're only counting the first three strings? 
Such a dumb mistake, thank you so much!
&gt; but VS still suggests C++ headers like iostream to me. (They're added as dependencies.) Well, given that we know that the ones that don't end in `.h` are C++, we can just avoid those, right? I'm accustomed to a full stock of man-pages to remind me which header I forgot, but I guess the normal mode on Windows is quite different. 
Impressive, thank you very much for sharing. Do you consider it equivalent to Ada Spark? 
&gt; It's most common to use &amp; syntax -- "address of" -- when passing a non-pointer type into a function. Would that be something like this. foo(int * x) { printf("%i", *x); } int main() { int y = 10; foo(&amp;y); }
Many thanks!
Your tax dollars at work, and not sarcastically for once.
Yes, like that! But most often we're passing pointers to structs, or generally things bigger than a `size_t` pointer. On an "LP64" machine like 64-bit Unix, `int` is smaller than a pointer so one wouldn't be saving anything by passing a pointer to an `int`. 
Is there a roadmap for future features and documentation?
French, eh? Any connection to CompCert and Coq, I wonder? 
Your wording in your pointer section is way off. Pointers aren’t immutable as you claim. Pointers to a string literal may or may not be able to change the pointed to memory, but that has nothing to do with pointers, it has to do with read only memory.
I'm absolutely no authority on the subject, and I'm biased, but I'd say proper use of external tools puts C on roughly equal safety footing with new languages that have safety and correctness as an explicit goal. Then whether C is a good fit otherwise is determined by the usual factors. What's the platform? Is it a native C platform, using a C ABI? I wouldn't choose C first on an [HLA](https://en.wikipedia.org/wiki/High-level_language_computer_architecture#Examples) stack machine, and C is not normally a perfect fit on an EBCDIC machine. But C is native to Unix and NT, so it's often a good fit there, especially for system daemons, libraries, and anything that should run with minimum memory allocation or fast start-up time. 
A high-level language computer architecture (HLLCA) is a computer architecture designed to be targeted by a specific high-level language, rather than the architecture being dictated by hardware considerations. It is accordingly also termed language-directed computer design, coined in McKeeman (1967) and primarily used in the 1960s and 1970s. HLLCAs were popular in the 1960s and 1970s, but largely disappeared in the 1980s. This followed the dramatic failure of the Intel 432 (1981) and the emergence of optimizing compilers and reduced instruction set computing (RISC) architecture and RISC-like CISC architectures, and the later development of just-in-time compilation for HLLs. A detailed survey and critique can be found in Ditzel &amp; Patterson (1980).
Ask OP. His username suggests he's one of the [authors](https://ti.arc.nasa.gov/tech/rse/research/ikos/).
/u/MaximeArthaud, any connection with CompCert and Coq? 
Thanks, very helpful.
Also the if and while conditions combined may give some trouble. For guessLimit = 2, and secretNum != guess, the while loop will be executed. 1. If user guesses correctly(guess = secretNum = 7), guessLimit becomes 3 and the loop breaks, but "You lose" is printed. 2. If the user guesses incorrectly, guessLimit is 3, but loop will still continue. 1. When user guesses correctly, say in guessLimit = 8, the loop breaks. and "You Win" will be printed. &amp;#x200B;
&gt; VS still suggests C++ headers Just ignore it? &gt; Same with GCC and VS Code, I can get GCC through Cygwin and get the version through the Cygwin console, but I do not get how to configure VS Code to pick out the GCC compiler from Cygwin's directory. I tried GCC for windows, but trust me, it's terrible when compare to the real one on Linux. Try Lubuntun on a virtual machine, it's easy to start, and the Linux terminal is so great to work with. Seriously, you should try Linux.
I think i pointed out that it was based on my personal experience, hope it did not upset you. What i think is that, people who have not coded in C, especially beginners try to find material for studying just like this guy did when he asked this question. Then they come up to this book and recommend it without even reading it(even without writing any C code). Second case is that they haven't just read better book on C. Don't get me wrong here...I absolutely love Dennis and everything about Bell Labs. I'm 22 and in my free time i enjoy watching old videos from Bell Lavs. My point is that 'Book on C' is much better book for learning C. I could not go half of K&amp;R even i had some background. Again, it's just me. 
Yes, most of the contributors of IKOS (including myself) are French (and American, obviously). The theory of abstract interpretation is really a niche started by French people (Cousot), so a lot of researchers in that field are French. CompCert and Coq are based on theorem proving, which is a different research field, so no, there is no connection. One of the author of IKOS was previously working on Polyspace. We also know a few people working on Frama-C (French CEA) and Astrée (French ENS). This is a small field.
Sorry, there is no roadmap. Is there any feature that you would like to have?
I'm mostly trying to get an idea of the current state and future of the project. Are there more checks that *could* be added? If so, *will* they be added? If the project is being shelved, why? etc
None of those are exclusive to C (Valgrind is a good example), and some languages even incorporate static analysis into the compiler (Rust's "borrow checker" is an example). 
You're right. I worded it incorrectly. The aim was to simplify but I ended up misrepresenting it. I still maintain that my reply is the most helpful because I'm speaking to OP, likely a freshman who 3 months ago learned Hello World, at a level which he can understand. Verbosity is what gets people lost.
You would be amazed how often stuff like this happens to programmers who have been working for decades. All .. the ... time.
Not really. I'd like to think that I learned my lesson early on about getting a second pair of eyes on the problem, but I need the occasional reminder as well. 
The project is definitely not being shelved. In terms of checks, the list is pretty complete for our use cases, but if a user asks for a specific check we will consider it. I personally have several ideas to improve the analysis (for instance: adding function attributes, model more standard library functions, etc.). Most of these will be implemented in the future. We also have a big feature that could improve the analysis time. It will be subject of a publication, but I can't say more right now. We are also trying to gather feedbacks to see where we should focus our work. Also, keep in mind that IKOS is used internally at NASA by other teams, so it will be maintained for a while.
I'm really glad to hear that it will continue to be used, and that it's fairly feature-complete for practical use cases. Many NASA projects end too soon, which was my concern. I will incorporate this into a small project to evaluate it. There doesn't seem to be much available between the expensive commercial tools and the "best effort" free tools, so I'm glad that this exists. Thank you!
Oh look, more great tooling based on LLVM! &gt; To analyze this program with IKOS, simply run: `$ ikos loop.c` I take it ikos will forward all my command line flags (`-I`, `-D`, `-W*`) to Clang? I'd love to try to run this on the Linux kernel. Hopefully you'll present at the next LLVM developer's meeting?
If it's good enough for NASA, it's good enough for me. 
The `toBinary()` function is recursive, which means that it calls itself. When given a number, it returns a different number which, when printed in decimal, looks exactly like the original number printed in binary. For instance, for 5 it will return 101 (one hundred and one) which happens to look exactly like the binary representation of 5. It's fairly easy to understand how it works: First, imagine calling it with 1 as argument. The `if` on line 19 is true, so it just returns 1. Next, imagine calling it with 3 as an argument. The `if` is false, so it *calls itself* with 3 / 2, which is 1, as argument. We already know that the result of `toBinary(1)` is `, so the first or outer instance will calculate `1 * 10 + 3 % 2` which is `10 + 1` (remember, `%` is the remainder operator), which is 11, which corresponds to the binary representation of 3. The general idea is to divide the problem into smaller, more manageable parts which we handle individually by dividing them into smaller parts which we... etc. until the parts are small enough that we can figure out the answer without further subdivision. In this case, we simplify the problem by splitting the number in two parts: the lowest bit (the remainder of dividing the original by two) and the rest (the quotient of that division). We run the entire algorithm on the quotient, then multiply the result by ten (to shift it left one position) and add the lowest bit back.
&gt;I take it ikos will forward all my command line flags (`-I`, `-D`, `-W*`) to Clang? Unfortunately, no. If you want to use `-I`, `-D` &amp; co, you have to compile your code to llvm bitcode and feed the `.bc` to ikos: `clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -g -O0 -Xclang -disable-O0-optnone -Ixx -Dyy -Wzzz test.c -o test.bc` `ikos test.bc` To analyze a whole project, we have a tool called `ikos-scan`. it is similar to `scan-build`. &gt;Hopefully you'll present at the next LLVM developer's meeting? That would be great! But I need to convince NASA to let me go..
&gt; Unfortunately, no. If you want to use -I , -D &amp; co, you have to compile your code to llvm bitcode and feed the .bc to ikos That's a non-starter for a lot of large projects with complex or custom build systems. Being able to swap out the "compiler" used makes things way easier to use on larger projects. I recommend looking at how `ccache` or `bear` utilities work from a consumer standpoint.
Maybe it's better to look for the entry point of a binary or allow the use to specify what that entry point is, rather than explicitly a function named `main`? `_start` or I think there's a `-e` flag linkers use, or `ENTRY` that is used by linker scripts.
Please see [https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#analyze-a-whole-project](https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#analyze-a-whole-project) We also have large projects to analyze at NASA ;)
You can specify a custom entry point in IKOS using `--entry-point` ;) See [https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#entry-points](https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#entry-points)
How about feeding ikos a compile_commands.json file? That's build system agnostic.
Yes, we could do that. Feel free to open an issue. Actually, If you fill an issue with a minimal set of flags (`-I`, `-D`, etc.) that we should forward to `clang`, I will happily implement this.
If you can guarantee that they will (almost) always be used to the fullest extent possible, then I'd say yes. But I'd be skeptical of such claims. To me, C's UB and subsequent mitigations is kinda like a city providing free-to-use wreckers so you can tow your car, rather than fixing potholes. UB provides a benefit (optimization opportunities), as does the city's repair stance (reduced expenditures). Is it worth it? Not IMO.
[Done](https://github.com/NASA-SW-VnV/ikos/issues/17). Unfortunately, while I thought that `-I` and `-D` flags were the only flags (they're certainly the most important), it turns out that `-m` flags can also affect certain defines supplied by the preprocessor. I'm going to be conservative and suggest that all arguments be forwarded to clang.
given is a type, not an object given entries[NumEntriee] for (int i = 0; i &lt; NumEntries; i++) { fprintf(data, "Name: %s\n", entries[i].Name);'
dude you are a fucking life saver. We just learned about structures and pointers and I was just dying. Thank you so much. 
Could this framework be used for computing worst case loop bounds for worst case execution time analysis? I believe the open source [SWEET](http://www.mrtc.mdh.se/projects/wcet/sweet/) and closed-source [aiT](https://www.absint.com/ait/index.htm) both use forms of abstract interpretation for their flow analysis to obtain worst-case execution paths, which can then be used to annotate the assembly language code and fed into a machine model to obtain worst case execution time.
Today's work goal, dockerize and test internally. Thank you, this is very relevant to my work.
Does it check for MISRA rules? 
You can deduce it by understanding how most operating systems are implemented. Processes have a virtual address space that the kernel maps to physical pages Shared memory is implemented from the kernel sharing the same physical pages with the processes, Linux has /dev/shm and a few syscalls. Shared memory by itself can be used for message passing, etc but how it's usually used with locks, etc is a horrible way to implement parallelism due to how it interacts with hardware.
That was mean... I like it. 
This isn't a c programming question. Try /r/kernel. Your question is also hard to parse. Linux/Windows are operating systems. Computers implies architecture. Are you asking how Linux/Windows synchronizes shared memory at a process/page level? Are you asking how SMP systems synchronize access to the memory bus?
**1)** The client trusts h_length in the hostent structure after calling `gethostbyname()`. This sort of thing has been responsible for many buffer overflows over the years because resolver libraries have based h_length on data returned from a potentially malicious name server. **2)** There are three instances of the following erroneous construct, two in the client and one in the server: n = read(..., buffer, ...); buffer[n] = '\0'; if(n &lt;= 0) break; If `read()` returns -1, you underwrite the buffer by one byte. Check the return value of `read()` *first*. **3)** You use the magic constant 10 twice in the client and once in the server instead of simply using '\n'. This is bad style. **4)** The following client code is erroneous and leads to a definite buffer overflow: zone = malloc(strlen((argv[i]+2)) * sizeof(char)); e.g., for a three-character time zone, `strlen((argv[i]+2)) == 1`. You then allocate only one byte to hold the time zone and trailing three characters. Change to this: // 3: \r\n\0 zone = malloc(strlen(argv[i]) + 3); You should always check `malloc()` for a NULL return, which you don't do in the client or the server. (Incidentally, `sizeof(char)` is guaranteed to be 1 even on weird systems, so there's mostly no point in writing it, which you do once in the client and once in the server.) **5)** Following on from the above in the client, `strcat(zone, "\r\n\0")` is no different from `strcat(zone, "\r\n")` The only conceivable reason for writing "\r\n\0" is to emphasize that there are three trailing characters. **6)** There are two instances of the erroneous `write(sockFD, ..., sizeof(...))` in the client. It should be `strlen(...)`, not `sizeof(...)`. In both instances, `sizeof(...)` yields the size of a character pointer, not the size of the buffer. On typical 32-bit systems, you won't write enough; on typical 64-bit systems, you'll write too much if you're lucky, which will magically work, but the underlying overread is technically undefined behavior. **7)** The second do-while loop in the client (the one conditioned on `n &gt; 0`) should be removed. It's useless. **8)** The server will handle only one request line from the client because that's all it's been programmed to do. **The first and second issues you mention are consequences of this single design flaw.** **9)** In the server, 'checker' is not initialized to 0 as it should be. It's initialized only if an error occurs, which means you're reading an indeterminate value in the non-error case. **The third issue you mention is a consequence of this.** **10)** In the server, the use of `ctime()` is erroneous in all instances. `ctime()` returns local time, not GMT time, and is equivalent to `asctime(localtime(...))`, whereas what you want is `asctime(gmtime(...))`. **11)** In the server, the 'equals' buffer size is calculated based on 'timezone' set to "-GMT\r\n". When the client causes 'timezone' to be set to "-AEST\r\n", there would be a one-byte buffer overflow were it not for the fact that the buffer size is calculated with the time string's '\n' still intact, giving an extra byte of room in the buffer. Keep this in mind, though. **12)** The if/else-if/else chain in the server is highly repetitive. Only 'timezone' and 'currentTime' are zone-specific, allowing the other code to be factored out (or removed altogether in the case of `time()`). **13)** The server's "BYE\r\n" string gets overwritten because 'checker' will still be 0 (once you've fixed the initialization issue mentioned above). **This means the client won't receive the "BYE\r\n" even if you address the larger design flaw responsible for the first and second issues you mention.**
Thank you so so much for the great explanation. To me it's not clear if it actually loops as cycle and when or how it stops. Maybe a full example with a number like 8/10 would clear things out. 
Both tools are sound and both can be used to prove absence of runtime errors. But IKOS is (I assume) a tool that works on the pure source code only, while SPARK usually requires annotations (pre and postconditions) to work. In exchange one can prove more advanced properties using SPARK (not only absence of runtime errors). Also the underlying technologies are very different. 
What I meant in my question, is, firstly, what model does the linux kernel use, and two, how 2 processes have consensus about read/write operations. (aka collision avoidance)
&gt;Here, sound means that it is mathematically correct and cannot miss a bug, thanks to the theory of Abstract Interpretation. Do you mean that the program *actually* can't miss a bug, or just that it can't miss a bug assuming there are no bugs in it's own code? Has this program's code been proved correct with a formal verification tool?
have two windows open, one for working and one for reading documentation well written headers are documentation—they describe an interface :)
Has the program's proof been proven correct with a formal verification verification tool?
A single devel is behind this ?
 char inputLength[512]; That's an evil name for a buffer.
Define what you mean by 'model'. Processes don't have a 'consensus' with shared memory, hence the name shared memory otherwise it would be called replicated memory or something. If you mean reading, writing etc its done with locks. 
These sort of checks are much easier to make on a higher level language that offers safety as one of its core objectives.
By default there aren't any. You wind up with the same locking issues you have with threading. Unless you use semaphores or some other kind of locking the read/writes to that physical page of memory will be interleaved (race conditions). Shared memory is implemented through virtual memory. Virtual memory, the paging unit, internal kernel data structures, and the page fault handler are behind Linux's implementation. If you want to understand how it works you are going to have to learn at minimum about virtual address spaces, how they are implemented, and how they interact with paging/swapping. I've not seen a simple article/video about this. 
C and C++ are still the language of choice for safety- and mission-critical applications. Despite being more difficult to analyze than many other languages, a sufficient level of analysis has been achieved by some (usually expensive) tools. Even with this trade-off, C/++ are usually still the better choice for some applications after considering all of the project requirements.
For the hardware caching layers, I'm pretty sure that's hardware dependent. Cache invalidation across multiple cpus is one of the giant problems with shared memory. 
It doesn't loop. It takes a round pizza, cuts small bits from it, stacking them. When there's just one bit left, it unstacks and stretches each bit to form a square pizza.
Hahaha thank you for your explanation it was actually useful. I just didn't get the square thingy but the rest was very clear.
Automatic variables are allocated on the stack; \`malloc\` allocates memory on the heap. [https://www.gribblelab.org/CBootCamp/7\_Memory\_Stack\_vs\_Heap.html](https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html)
Not to be taken seriously, of course.
Really, there are only two concepts relating to memory that a beginners should be aware of in C - and these are stack and heap (data and code are . These two separate concepts have very deep implications for the operation of your program, particularly when it comes to the heap. It is very important to know when you are allocating on the heap as that memory is manually managed. If you are not properly managing that memory, you wind up with memory leaks and degraded performance. Understanding these two concepts related to memory is key to understanding C and this is why most text books will have a chapter near the beginning on them. Without this understanding, new users will flail when approaching strings and arrays later on or try to return more complicated types from functions.
What jumps out at me are those two closing braces at the same indent level (i.e. in the same column). Very often that indicates a problem somewhere in the code, and it's no different here. Where are the corresponding open braces? What consequence does that have for the control flow? Also, I see a printf where you have 3 format specifiers but 4 arguments. Your compiler should have warned you about that. If not, increase its warning level (using -Wall). Then work on eliminating all warnings.
what do you mean?
One of the things that make me avoid Rust at all costs its exactly this kind of 'cult' sort of behavior by people that like it. Its exactly the same thing that i thought it was creepy about Haskelers before. Also the language used its pretty akin to religion, where one language is the "one true way" providing *SAFETY, BE SAFE, SAFE, SAFE* amem, and all other languages are UNSAFE, DIRTY, BLASPHEMY, specially C++. By the way, i think Rust syntax is even uglier than C++, theres no way people will rewrite large, high performant c++ codebase in Rust just because Rust is SAFE, SAFE, SAFE, without any other improvement, and the lifetime annotation among other things make Rust code not only more painful to write, but also feel even less productive than c++. Just a small rant here, but i think a lot of people from the Rust community need to review their behaviour towards Rust in online communities, because it can even hurt the tech in the long term. This is a post about C and something about C++, why every time do we have to hear a preach about how guilty we are for using for dealing with the *filth* that is C and C++ and how we should all convert and start to pray in the church of Rust, amem brother. *(note: this is not just about you, but to every comment now and then, here on in HN that looks exactly the same and follows the same pattern, it was kind of cute when Rust was new, but with time it starts to feel creppy and annoying)*
why does guesslimit = 3 when guess = secretNum? 
Any experience with multithreaded programs?
Most C implementations work like that, yes. But the language itself has no concept of stack or heap, and neither word is mentioned even once in the standard. It is entirely possible to implement C without a stack; as for the heap, that's a meaningless word for “memory which is available through `malloc()`”.
&gt; Really, there are only two concepts relating to memory that a beginners should be aware of in C Yep: lifetime and scope. That's it.
&gt; I still "see" the recursive function in line 23 just like a division by 2. Which obviously is not. Think of it as: “when I get to this point, I make a note of what I was doing, then evaluate `toBinary()` with half the original number as argument; once that is done, I insert that into my arithmetic expression and continue.” &gt; I also don't get why in your example you basically never enter the base case of the function that should terminate it. Because we had already examined that case, so I just reused the previous result instead of going through it again. I have an idea. Take that code and type it in, if you haven't already. Then replace the last line of `toBinary()` with the following: int intermediateResult = toBinary(decimalNo / 2); return intermediateResult * 10 + decimalNo % 2; This does *exactly* the same thing, just in a slightly more readable manner. Now, make multiple additional copies of this function which you rename to `toBinary1()`, `toBinary2()`, `toBinary3()` etc. Then, in `toBinary()`, you replace the `toBinary()` call with a call to `toBinary1()`; in `toBinary1()`, you replace it with `toBinary2()`; and so on; but in the last copy you make, let's say `toBinary9()`, you replace it with `0` instead, so it reads `0 * 10 + decimalNo % 2`. Now, instead of a recursive function, you have a function that calls a different function that calls a different function, which I think will be much easier to understand as a first step on the way to recursion. I would also suggest watching these two [Computerphile](https://www.youtube.com/user/Computerphile) videos: * [What on Earth is Recursion?](https://youtu.be/Mv9NEXX1VHc) * [Programming Loops vs Recursion](https://youtu.be/HXNhEYqFo0o) 
 int guess; int guessLimit; while (secretNum != guess || guessLimit != 3){ The 1s'^st time it compares `guessLimit` with 3, `guessLimit` has an undefined value - it hasn't been set to anything yet
Valgrind is not perfect and it's slow. Ugh.
Lol this is the only of two comments on this whole page that even mention Rust specifically, and the other one wasn't even in this comment thread. So salty. &gt; theres no way people will rewrite large, high performant c++ codebase in Rust just because Rust is SAFE, SAFE, SAFE Mozilla would like a word..
This is almost certainly not what you meant to do: if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') { loweralphabet[c - 'a']++; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') { upperalphabet[c - 'A']++; } } Correctly indented, it becomes if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') { loweralphabet[c - 'a']++; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') { upperalphabet[c - 'A']++; } } 
Print the entire array out at each step and you'll get a better sense of what it is doing
Sure I will try
Oh Mozilla the one that inherited the whole Netscape codebase, so [they are doing it again?!] how smart.. (https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i) The fun part of all of it, its because Firefox will probably continue to fade away, while Rust will be the only real thing rest for Mozilla. Look, i get it, Rust has value, its a good proposition and i like what its trying to do, but what i dont like. its the culture of its community going around where technology is seen much like a religion where once you are converted, all things will magically sort out. I get that a lot of languages go through this hype phase where people seel it like some sort of magic unicorn that will solve all of your problems. But why only with Rust'ers theres this culture of contantly bashing other languages while trying to make people that use those languages feel bad for doing so, sorting out for this constant psycological sort of bullying? "Did you hear about the wonders of Rust? Why are you still dealing with all this filthy, convert all your code to ther wonderful Rust and stop suffering" About being salty, i normally avoid doing this sort of comment, but its like 4 years now where you see this same pattern going on again and again, where this magical thinking doenst seem to end. (I get it i used to think/feel about tech the same way when i was more green, i can understand and be patient by looking into my younger self and the wrong way of seeing at things.. but this has been going for so long now..)
ok so setting it to 0 for example would fix that problem?
Yes. The while condition is incorrect too, as mentioned in the other comment.
Firstly, thank you so much for this, I followed all of the points regarding the client and it managed to fix it instantly, without any compilation errors or anything, so my client at the moment seems to be fine and without problems. In terms of the server, i'm not exactly sure on what I could do to fix the design flaw that you mentioned. The thing you labelled as 8 seems to be the kind of thing that u/arxlight is talking about (if i'm not mistaken), and I commented there on how I tried a possible fix but it didn't seem to work :/ 9) is now fine after initializing the checker as 0 at the start :) 10) Would asctime(gmtime(...)) work on all timezones, so like asctime(pstime(...)) or would I just get the GMT time in all cases and add/subtract the required number of hours for that specific timezone, like i'm doing now? 11) I think that's fine for now? 12) How could I change the chan of if/else-if that I've got currently? I've got the modified version of my code here if you're still able to help [client](https://pastebin.com/GtHrwQdc) [server](https://pastebin.com/Se8S8VX7)
Firstly, thank you so much for this, I followed all of the points regarding the client and it managed to fix it instantly, without any compilation errors or anything, so my client at the moment seems to be fine and without problems. In terms of the server, i'm not exactly sure on what I could do to fix the design flaw that you mentioned. The thing you labelled as 8 seems to be the kind of thing that u/arxlight is talking about (if i'm not mistaken), and I commented there on how I tried a possible fix but it didn't seem to work :/ 9) is now fine after initializing the checker as 0 at the start :) 10) Would asctime(gmtime(...)) work on all timezones, so like asctime(pstime(...)) or would I just get the GMT time in all cases and add/subtract the required number of hours for that specific timezone, like i'm doing now? 11) I think that's fine for now? 12) How could I change the chain of if/else-if that I've got currently? I've got the modified version of my code here if you're still able to help [client](https://pastebin.com/GtHrwQdc) [server](https://pastebin.com/Se8S8VX7)
No GPL License no use.
The fundamental source of controversy around "strict aliasing" is the failure of the Standard to make the footnote to N1570 6.5p7 normative. If the rules had said what things a compiler must recognize as *aliasing*, but had not forbid operations *that don't actually involve aliasing as written*, that would eliminate the need for the "character type exemption" as well as "effective type" rules in most programs that would be compatible with the rules as written. The authors of the Standard expected that compilers would uphold the Spirit of C, including such principles as "Don't prevent the programmer from doing what needs to be done" [their words] without having to be explicitly ordered to do so. They almost certainly thought that compiler writers would recognize that implementations claiming to be suitable for low-level programming would support more constructs than mandated by 6,5p7. I find the author's "gcc to the rescue" attitude curious, since the authors assume the Standard's authors intended that the rules be interpreted in a way that would frequently undermine the Spirit of C. Given the union definition: union { uint16_t hh[8]; uint32_t ww[4]; } u; If both arguments are equal, the following would involve aliasing between `*hp` and `*wp` uint16_t test1(int i, int j) { uint16_t *hp = u.hh+(i*2); uint32_t *wp = u.ww+j; if (*hp) *wp=1; return *hp; } since `*wp` would be used to access storage between the time `hp` was created and the time `hp` would be used to access that storage, without `wp` having been derived from `hp` within the context where `hp` is next used. None of the following, however, involves aliasing as written: uint16_t test2(int i, int j) { if (u.hh[i*2]) u.ww[j] = 1; return u.hh[i*2]; } uint16_t test3(int i, int j) { if (*(u.hh+(i*2))) *(u.ww+i) = 1; return *(u.hh+(i*2)); } uint16_t test4(int i, int j) { uint16_t *hp1 = u.hh+(i*2); if (*hp1) { uint32_t *wp = u.ww+j; *wp=1; } uint16_t *hp2 = u.hh+(i*2); return *hp2; } uint16_t test5(int i, int j) { uint16_t *hp = u.hh+(i*2); if (*hp) { uint32_t *wp = (uint32_t*)hp + (j-i); *wp = 1; } return *hp; } In the first three of those case, a `uint16_t*` is derived from `u`, used, and abandoned. Then a `uint32_t*` is derived from `u`, used, and abandoned. Finally, another `uint16_t*` is derived from `u`, used, and abandoned. At the time each pointer is used, it holds the most freshly derived reference to that storage which will ever be used, or that existed before entering the present context. The last case is a little trickier. Although `wp` is created after `hp`, it is created from `hp`, and the creation of `wp` and all use thereof occurs within the context where `hp` will be used next. At the time `*wp` is used, it's the freshest live reference to the storage, and while there's a time when `*hp` isn't the freshest live reference, it regains that title by the time of the last access. Of those last cases, none of which involve aliasing, only `test2` is handled correctly by gcc. While the Standard defines the behavior of `test2` in terms of `test3`, neither both gcc and clang process `test3` in broken fashion, along with `test4` and `test5`. While gcc and clang by happenstance happen to work in cases where they can determine that two pointers will always access the same storage, they are unable to recognize that deriving a pointer from something creates an attachment to that object *at that point in time*. The first `uint16_t*` created in each example above is attached to the state of `u.hh[i*2]` before any operations that were attached to `u.w[j]`, but the second `uint16_t*` is attached to the state of `u.hh[i*2]` after those operations. 
No it's not. The plot is very thin. There is no surprise ending. &amp;#x200B;
Still im not getting.....Can u tell me which type its i mean name of this algorithm..... I can serch more details about this algorithm 
Consider an alternate method -- what if we had a separate array of boolean values to recognize duplicates? We could write code like this: for (i = 0; i &lt; size; i++) { if ( !dup[arr[i]] ) dup[arr[i]] = true; else printf(" %d ", arr[i]); } In other words, each value we find sets a flag to say that we've already seen it. If that flag was already set, we know we found a duplicate. The version with `abs` is effectively doing the same thing, but re-using the same array instead of a separate one. A negative value in the array serves as the same flag. The assumption here, of course, is that all the values are within the range of the array (you don't have 128 or -42 or whatever in the array).
How arr[abs(arr[0 ])] is 2??
Is there a way to pass multiple .bc files into ikos? &amp;#x200B; For example if a project with many C files was compiled into bitcode, could ikos analyze all the files, starting with the single entry point?
How arr[abs(arr[0 ])] is 2??
`arr[0]` is 1. `abs(1)` is 1. `arr[1]` is 2.
Indeed, which is why IKOS is all the more interesting.
O my god..got it...array inside array
Yes, this could be done using IKOS and abstract interpretation.
arr[0] is 1 abs(1) is 1 arr[1] is 2
The array only contains non-zero positive numbers. None of the numbers are larger than the size of the array. The algorithm makes the number at index `i` negative if `i` is in the array. So if `arr[1]` is 2, and there is a `1` somewhere else in the array, then `arr[1]` will be changed to -2 If you find a `1` in the array and look at `arr[1]` then if it is negative this isn't the 1^st `1` that has been found. All the `abs` are needed because if you're looking at `arr[j]` and the value is `-1` this means that you have found `j` in the array already. You need to ignore the fact that the value is negative. The `-` is just a marker that is telling you about `j`. You want to look at `arr[1]`, not `arr[-1]`. 
No, it doesn't. IKOS is not a code style checker. It understands the semantic of your program and computes an over-approximation of all the reachable states, and checks for possible error states.
Lifetime, scope, and the association of the "stack" with objects that have automatic lifetime, and the "heap" with objects that have allocated lifetime. 
Most people see value in having short words to refer to concepts, rather than having to use verbose phrases "memory which is available through malloc(), calloc(), realloc(), or any other library functions that call them" all the time. Perhaps that's a matter of taste, though. 
That's... a mixed bag. **Valgrind**: executes raw assembly, so is usable on any language compiled to a native binary. This includes Ada, C++, Go, Jai, Nim, Rust, Zig among others. As such, it does not give any advantage to C. **Pedantic switches**: are concerned with the respect of the standard. C compilers accepting non-standard C by default is a specific defect of C compilers (and C++), so there is no advantage to C here. **Static Analyzers**: static analyzers are more nuanced. The best static analyzers (validating MISRA-C or FRAMA-C) definitely give an edge to C over many languages (C++, Go, Jai, Nim and Zig for example), however they mostly lag behind what Ada/SPARK or Rust can offer natively in terms of safety. They may provide embedded-specific proofs not otherwise available to Rust, such as a maximum memory or stack footprint. --- In short: C tooling is not about giving C an advantage, it's about mitigating its short-comings. However, given that: 1. A **lot** of safety/mission-critical applications are written in C. 2. C is the only languages available on a number of platforms. 3. C is not going away anytime soon. 4. C has a lot of experienced veterans used to the rigor of developing safety/mission-critical applications. C remains a good choice for writing such applications, and the tooling available is very helpful in saving lives and funds.
Good question. First, when I say it can't miss a bug, I am referring to our list of [checks](https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#checks). They are still a few bugs that we can't catch: data races, dead locks, etc. And of course we won't catch logic bugs since we can't guess what the programmer actually wants. And no, the code of the analyzer hasn't been proved. The code is a huge pile of C++, it would be hard to prove it. We have to rely on our tests for now.
Many of these questions should allow multiple options. To name a couple, Dogs or Cats? What about both? What about people who work from home and the office? 
Yes. You can compile manually all your code into a single `.bc` file using `clang -c -emit-llvm` and `llvm-link` to link all the files together. Or you can use `ikos-scan` that will do this for you, see [here](https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#analyze-a-whole-project).
Unfortunately, we don't handle multithreaded programs since the theory of abstract interpretation does not apply easily to concurrent programs. This is a research topic, there are a few papers about it, and it's pretty heavy stuff. See [https://tel.archives-ouvertes.fr/tel-00903447/document](https://tel.archives-ouvertes.fr/tel-00903447/document) (no less than 95 pages!)
I would be happy to change it but it doesn't depend on me..
The project started in 2011 with 4 persons working on it. Since last year, I am the only developer working on it. I also get interns from time to time.
Awesome! I feel like I should've realized that lol. Sadly our build system is made up of a bunch of makefiles and relies heavily on the -I and -D flags, so ikos-scan doesn't seem to work for me. I would love to throw my vote in for the -I/-D parameter request though.
And I sort of agree that it's fine to use “heap” for that, because nobody remembers its original meaning, but I object to using “stack” because it evokes a very specific image or idea. If you want to get formal, what C and other Algol-derived languages use is a tree of activation records; in most cases (but not all, cf. Simula) this tree has no branches, so it is actually a list. It is usually implemented with something that resembles a stack but actually isn't, since it mixes FIFO access with random access; even more so with modern compilers which will reuse the same memory location for different variables within the same activation if they can prove that those variables do not overlap in time (which is not the same as saying that they have non-overlapping lifetimes as C defines it). If you want to see a real stack, learn Forth or Postscript.
No. Lifetime and scope. That's it.
Will the results show references to the .c files the same way? 
Yes, since the llvm bitcode contains debug information referring to the .c files.
Your first scanf() doesn't have the ampersand operator. Should be scanf( "%d", &amp;requested );
Because in the first call you're passing `requested` by value. If you change the first call to `scanf` to the following, it should work: scanf("%d", &amp;requested); Moreover, try to get in the habit of compiling with all warnings `-Wall` as when I pasted your code my compiler immediately pointed out the error: w2.c:13:13: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’ [-Wformat=] scanf("%d", requested); Hope that helps!
If this stuff really interests you, I'd invite you to look into erlang, elixir and BEAM. They have some interesting ideas about parallelism, but it's pretty much the exact opposite of C (with data mutating anyway) Shared memory is also useful for non ipc related things, such as process forking because it enables better utilization of resources. For example, shared libraries. 2 or more procs can easily share the same code, because code isn't written to. 
So... What are we supposed to write?
Exactly! I'm actually starting to prefer header files for this reason. Keeps the code cleaner. There are utilities for automatically building header files, but I don't use them. 
&gt;Also the underlying technologies are very different. Sure, one is Ada the other C++ ;-) But Ada/Spark is well accepted by certification authorities for producing high integrity software, and I would like to know how close we get to this using C++ and Ikos. Up to now the primary contributions in terms of safety/integrity - besides some unsound static checkers - were coding standards; or did I miss something?
If there are people interested I can send further details. I'm just seeing if there's any interest
It's better to give information and assume interest, since many won't actively ask but will passively read.
 #include &lt;stdio.h&gt; int main(void) { printf("Hello World\n"); return 0; } I can haz money now?
Sure you're probably right, I'll edit the post 
Nailed it 
Sorry, I forgot the ampersand while I typed here. The issue isn't with scanf, it's on the last line. I get a error "= left operand must be l-value"
Sorry, I forgot the ampersand while I typed here. The issue isn't with scanf, it's on the last line. I get a error "= left operand must be l-value"
Not an array in an array. You are taking an array *element* and using that to find the *element*located at `arr[abs(arr[1])]`
I would do it but I don't trust you.
that's fair, I've done nothing to earn your trust 
In a nutshell, how does this compare to tools such as [SMACK](http://smackers.github.io/) or [KLEE](https://klee.github.io/)?
Do you need someone to solve a homework exercise for you and provide the code or is this a "real" project? Is it payed by Paypal or how will you pay for it?
I've edited the post for ya
You could say it's a little of both. It's a term project where we are measuring somethings as they grown and we want to place them in different categories.
Measuring... Does that mean converting analog input into digital and then organizing them? 
`&amp;newRequestPtr[0].amountRequested` yields a pointer because of the `&amp;` preceding it, but `requested` is an int. If `newRequestPtr` is a double pointer or a pointer to an array, you should replace the `&amp;` with a `*`, assuming `amountRequested` isn't a pointer, ofc.
Error on line 3: edit: I need an id3 algorithm programmed in C++ ^^^ This is a sub for the C language. For C++ you want /r/cpp or /r/Cplusplus. Though, in this case I doubt /r/cpp will be receptive to your request.
You sound really defensive and emotional. &gt; for dealing with the *filth* that is C and C++ This is counterproductive. The Rust community is aiming to solve or address problems that have been persistent sources of serious problems in C/C++. No one looks down on C/C++ or its developers -- instead, the Rust community is trying to solve problems and bring those solutions back to the rest of the development community. Your post *itself* shows a great deal of contempt and irrational anger. "Safe" languages mean something -- they define and attain a specific formal definition of correctness. How you can be against correctness, I'll never understand. &gt; By the way, i think Rust syntax is even uglier than C++ This is largely a matter of taste and familiarity. Everyone is familiar with some set of languages, and unfamiliar with others. 
&gt;theres no way people will rewrite large, high performant c++ codebase in ...whatever language. Of course not, it would be a pure waste of time and money to do this in most cases, especially for C++ or C code bases. But there will always be new projects, and some of them will use Rust if it's a good fit. Why not? It's a good programming language. There is probably no programming language in the world *without* preaching or cults surrounding it. Advice: simplify your life by just ignoring these things.
No we will be reading a file in and we will be adding to that file and looking for results. I think ID3 uses a decision tree so that's why I want to use that algorithm 
Oh I see. Sounds interesting. I dont do C++ tho. You may want to post this on a C++ subreddit to see if someone is willing to do it for you.
Reasoning? Work product of the U.S. government is public domain by law. Some non-U.S. jurisdictions find the idea of public domain problematic, and benefit from an explicit license statement, which IKOS has. But it's still PD, which the license statement confirms by saying that the code is a product of the U.S. government. 
One bug is if (pos &gt;= (ARRAY_SIZE(frequency_offsets) - 1)) is assuming that you have 2048 frequencies. I just registered and got 1021 frequencies in my list.
I mean I agree with you that clang is better suited to windows than gcc. But OP wanted to know about an issue they were having with gcc on windows... so I don’t see how this is relevant. They weren’t asking for tooling suggestions.
I have not read through all of your code yet, but noticing your ARRAY\_SIZE macro, I don't think it does what you think it does. Note that the following code: #include &lt;stdio.h&gt; #define ARRAY_SIZE(x) sizeof(x) / sizeof(x[0]) int main(int argc, char* argv[]) { int my_arr[6] = {1, 2, 3, 4, 5, 6}; int *ptr_to_my_arr = my_arr; printf("My size: %ld\n", ARRAY_SIZE(ptr_to_my_arr)); return 0; } Outputs: My size: 2 Also note that you don't use this macro in part 1 :D 
Is there a solution for this macro, then? I only use it so I don't have to specify the array size in my loops.
Um... I never mentioned Rust. What are you talking about?
Okay, now that I added a print right after the assignment, it worked. I even added a print in the main function to check if the array is being correctly assigned, and it looks like it is. But now the problem is that it's returning exactly the first item from my input. It looks like `frequency` is resetting itself after every loop, but I can't find what's causing it.
The standard method is to pass the array size along with the array to your function, i.e. void do_things_with_array(int arr_len, int* arr) { // Do things with array that you know the size of here } You could also create a struct which stores the length of the array alongside the array, but in general that's overkill. Just pass the size. You'll notice that this pattern is SUPER common in the C standard library as well as pretty much every other C library,
There's the bug on line 31 described by /u/rocketpower4 The best solution is to pass the number of items to check if (array_contains(frequency, idx)) Also : Using very generic names (`pos` and `idx`) for 2 variables in the same function makes things confusing to read.
Cool thanks bud. I didn't know this was an only C sub I thought it covered both
Thank you so so much again you are life saver mate &lt;3 Great explanation really. 
I think adding some oop syntax sugar would be nice. I think it should be easy to add something similar to this: void doSomething(MyStruct val, int arg) { ... } MyStruct val; val.doSomething(arg) or maybe not. I don't know lol.
I strongly agree in general—C and C++ have so much machinery around the interplay between headers and implementation, and there’s a ton of fine-grained control that one can exercise along those lines. But figuring out how to do it and what limitations are imposed by design choices would be rull edumacational, &amp; ’d give one insight into how compilers and lexers work, how language implementation and extension works, all the weird, dark little corners of languages. Not a bad (“)little(”) project.
You just deal with it, or use another language. Granted, I do agree because I dislike redundancy... especially in programming. Someone mentioned it's convenient as a 'doc' of the file. However, I believe producing a doc should really be handled by 'tools'. In fact.. maybe there is a tool out there that will automatically generate header file and keep them in sync for you? A quick google search found this: [https://www.hwaci.com/sw/mkhdr/](https://www.hwaci.com/sw/mkhdr/) Perhaps you can combine it with CMake or something..
See my other comment. Im not talking about Rust the technology, which i recognize has value and merit per se. Im talking about (a part of) Rust the community. My problem here is only with this zealot kind of approach, thats being happening for what.. 4 or 5 years already? and its always the same kind of pitch, over and over.
You said you can't say more, but do you have a timeline for the 'big feature'? Do you think it would help with RAM usage? Seems like some portions of our codebase cause Ikos to sprawl tremendously. 24GB of ram+swap and it wasn't enough.
Thanks for your answer. Kernel drivers have more “entry points” than just module_init, and they can be “interleaved”.. (so an init function, and then ioctls or file operations called by userspace). How can IKOS handle this “non linear” execution?
Isn't C++ just an attempt at OOP for C?
&gt; Advice: simplify your life by just ignoring these things. Sure, thats what i've being doing &gt; But there will always be new projects, and some of them will use Rust if it's a good fit. Why not? It's a good programming language. Im sure of it, and i dont mind people trying to sell it as a good fit.. we are here for this reason. To see and know about new things. But why it always has to be this way, by diminishing and bashing languages like C and C++? Cant it stand on its own merits? Im certain it does, i've already have seen it.. I just dont think it has to be always like this .. and i say this as somebody that never sayed anything about it.. but hey, maybe is time for part of the community to grow up and try to use less passive-aggressive, it makes me bitter about Rust, and i know its a great technology, and im sure im not the only one. But anyway, lets move on.. im pretty sure things will be the same and i will see this kind of comments for years to come.. But i just think they (the community) must change their strategy and try to get new followers on green fields. It doent need to keep calling us stupid for keeping using "unsafe" languages and comparing with C++ code from the 80's.
It started out as a bunch of preprocessor macros that introduced object orientation to C, yeah. That's not the case now, today they're distinctly different languages. [here's](https://github.com/danakj/openbox/blob/master/openbox/window.c) a peek at some real world code written in object oriented c.
The point is: theres a lot of C code outhere, they wont rewrite themselves in Rust or Ocaml, they are maybe massive codebases, and there is a lot of research and a massive amount of hours to create a static checker for a language with the complexity of C, from the standpoint of a static analizer.. and the old adage of "rewrite everything in Rust" wont work here, and i think is even disrespectful in regard to the hard work of the author. I dont want to make this sound personal, aimed at you, but you are like the 10000th person with this pitch that has being going on all over the years, and its so common nowadays, that you can even expect to see a comment like this in a totally unrelated thread. I didnt want to go to the sidelines here, and get out of the topic.. but sorry if i've had seen to much of this for years here and in HN, and it doesnt seen to end.. (i know you dont desearve this, im sorry, but this is more about a sort of culture that's been going on and i think that by now, it kind of reached its peak)
Your post is about programming in general, not programming in C. Posts about programming in general are not on topic, not even if they try to seek an audience of C programmers.
I made a slight error in my initial comment. I have corrected part of it. &gt; why does guesslimit = 3 when guess = secretNum? And would: &lt;code&gt; work better? Try to go through simple cases. I cannot tell you whether it will work better. Part of learning to program is understanding what might work better. When I started programming, I used to make tables for loops. (So, I have explained using one below.) &amp;#x200B; Let's start with a scenario where you have initialized guessLimit and guess to 0. (from comments below) &amp;#x200B; |Iteration in code|guessLimit|guess|guessLimit != 3|guess != 7|while loop |if(guessLimit == 3)|output| |:-|:-|:-|:-|:-|:-|:-|:-| |Before while|0|0|true|true|started|N.A.|N.A.| |After first loop iteration|1|8|true|true|yes|N.A.|N.A.| |After second loop iteration|2|8|true|true|yes|N.A.|N.A.| |After third loop iteration|3|8|false|true|**yes (false||true is true)**|N.A.|N.A.| |After 4th iteration|4|8|true|true|yes|N.A.|N.A.| |After 5th iteration|5|8|true|true|yes|N.A.|N.A.| &amp;#x200B; And so on forever till [integer overflows](https://en.wikipedia.org/wiki/Integer_overflow) and you return to 3. Now consider the scenario after third loop iteration and, you had correctly guessed. &amp;#x200B; |Iteration in code|guessLimit|guess|guessLimit != 3|guess != 7|while loop |if(guessLimit == 3)|output| |:-|:-|:-|:-|:-|:-|:-|:-| |After third loop iteration|3|7|false|false|break|N.A.|N.A.| |Reach if condition|3|7|N.A.|N.A.|N.A.|true|"You lose"| &amp;#x200B; Hopefully, Reddit's editor formats it correctly. &amp;#x200B;
IKOS does not handle multithreaded programs, so that could be a problem. If your driver is not multithreaded, then you can just "simulate" userspace calls with a simple loop, I guess: int main() { while (1) { switch (__ikos_nondet_int()) { case 1: entry_a(); break; case 2: entry_b(); break; // etc. } } } You would have to write a "stub" like this, and craft fake parameters to your functions. This is kind of similar to a fuzzer entry point.
No, I don't have a timeline since this will be an external contribution. Also, it won't help with the RAM usage. IKOS does a good job at being scalable **compared** to other similar tools using abstract interpretation, but it has its limits. In that case, I recommend to try to break down your software into smaller components and analyze them independently. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
From what I know, SMACK and KLEE are (mostly) based on model checking, where IKOS is based on abstract interpretation. In theory, they should provide better results since they can be path sensitive, but they will have trouble scaling up to millions of lines of code. In practice, I haven't tried them.
Note that C != C++ when referring to programming languages. 
Thanks!
"I only know the basics but I do not want to do something basic". And C is not the same as C++.
And you're reflecting and reproducing exactly that kind of angry zealot approach. Are you trying to criticize that kind of angry approach, or reproduce it? &gt; My problem here is only with this zealot kind of approach, thats being happening for what.. 4 or 5 years already? and its always the same kind of pitch, over and over. You're combining two things, here, and apparently attacking them both. First, you're criticizing some "zealous" Rust advocates. I suspect you're exaggerating the degree of zealotry. In my experience, the Rust community has been quite welcoming of new *and old* ideas, and rather than having *contempt* for languages such as C/C++, sees them as the state of the art that Rust is trying to build upon and improve. Second, are you attacking Rust's development priorities and timeline? You say "its always the same kind of pitch, over and over". Yes, that means that the Rust community has a clear direction and is working toward it on a time scale that spans many years, possibly decades. That does not invalidate the work. Rather, I think it shows that the Rust language designers are taking very seriously the challenges in building a new language, and using it to address serious, real-world design challenges. If the design priorities of the Rust team changed frequently, would you be attacking them for flip-flopping? Third, the Rust community has a Code of Conduct, and it takes it quite seriously. It is applied to everything that they do -- how they manage RFCs (and the RFC process is open to the public), how they manage pull requests, even how they manage /r/rust. If you feel that you see behavior that is disrespectful or excessively "zealous", then speak up about it, to the mods in that particular community. They take their responsibility for a respectful, professional community quite seriously. 
Regarding the problem in the title: You cannot declare an array with a variable, it might change and dynamic arrays don't work like that in c - you need to manually allocate them
The default is to not define your types in headers, but only to declare them there... Unless you have a damn good reason to share the inside of your struct, don't.
There are other types of type besides structs.
By reading your class notes?
* Easy introduction: [What a C programmer should know about memory](https://web.archive.org/web/20170503011745/http://marek.vavrusa.com/c/memory/2015/02/20/memory/) * More advanced take on that subject: [What Every Programmer Should Know About Memory](https://www.akkadia.org/drepper/cpumemory.pdf) [PDF] * From the Linux kernel's perspective: [Understanding The Linux Virtual Memory Manager](https://www.kernel.org/doc/gorman/pdf/understand.pdf) In short: The virtual memory is mapped to the same physical memory, so it's the hardware that manages consensus between processes/threads (full of its own caveats). You can even use this trick within a process to map the [same physical memory to different virtual addresses](https://nullprogram.com/blog/2016/04/10/). 
Ayyyyy lmao
ヽ༼ ຈل͜ຈ༽ ﾉ Raise ur dongers! ^^Dongers ^^Raised: ^^40947 ^^Check ^^Out ^^/r/AyyLmao2DongerBot ^^For ^^More ^^Info
Yes, there is, but they aren't defined, they're declared.
See *§6.7.2.2 Enumeration specifiers* and *§6.7.8 Type definitions*: enumeration constants and typedefs are defined.
Wtf are you
Also you don't have to rewrite everything in Rust, it links well with C and C++ so you can write critical code that would appreciate the checking in Rust and the rest you leave it as is.
I love the page so much. Sent me through a weird phase where I needed to make a pulse generator at work. To get the pulses to predictably output, I removed all branches using those tricks
As we were talking about this, here pops a thread on HN, and it goes exactly as predicted according to its title.. (https://news.ycombinator.com/item?id=18668669)[Why should I have written ZeroMQ in C, not C++ (2012)] Mind you, theres a lot of comments about merits.. all right.. but it theres almost nothing to do with Rust, its about C and C++, but almost all of the comments are about Rust, and when you read them, the only right conclusion you can take. I here was i here opening a topic about a static analyzer for C, and was almost certain to found a thread that would imply that we are wasting our time and that we shoud rewrite or migrate to Rust.. I hope that now you try to get it what im really talking about here. Its not about wether Rust has or not merits.. its because YOU CANT TALK ABOUT ANYTHING ELSE without having to be dragged into this mud. Theres this implicity harasment of C and C++, that is becoming normal.. and you feel like you have to think this way here.. its all subtle, but its always there.
Additionally to what you've pointed out, the variable c is being initialized by calling tolower(). So the upper case check is even harder to get into. char c = tolower(strings[i][j]);
A very impressive project, it is probably the most practical open source abstract interpretation tool. But I still think that he has too many false positives and does not apply to non-research departments. Can you give me some advice on how to use IKOS in industry?
You actually can declare a variable-length array inC99. 
&gt; C and other Algol-derived languages use is a tree of activation records; in most cases (but not all, cf. Simula) this tree has no branches, so it is actually a list. It is usually implemented with something that resembles a stack but actually isn't, since it mixes FIFO access with random access; even more so with modern compilers which will reuse the same memory location for different variables within the same activation if they can prove that those variables do not overlap in time (which is not the same as saying that they have non-overlapping lifetimes as C defines it). Or, we could just call it "stack" instead of all these words, a single word which most C programmers consistently associate and have associated with a particular meaning for nigh on 40+ years now regardless of whether the word has been used as formally defined. But, I guess we could all go ahead and just learn Forth so that we could properly use the word stack.
You could try to use other numerical abstract domains, see [https://github.com/NASA-SW-VnV/ikos/tree/master/analyzer#numerical-abstract-domains](https://github.com/NASA-SW-VnV/ikos/tree/master/analyzer#numerical-abstract-domains) Of course, the tool works best for safety critical codes, with strict rules such as limited memory allocations and so on. We are trying to reduce the number of false positives. Sometimes it's just engineering, and sometimes it's research related, and would deserve a publication. Feel free to open new issues with small codes triggering false positives.
You can put the guessLimit in a for loop. Then make a conditional statement inside saying if the guess == 7 then print out the “you win” message and break; the loop. 
Why on earth would the intention be to rewrite all C code?!
A good example of it are the way Linux kernel makes use of OOP, or how GNOME is implemented.
`ARRAY_SIZE(arr);` is a bug
Good catch! And I only just noticed that the `printf()` call has three conversion specifiers but four arguments.
&gt; Or, we could just call it "stack" instead of all these words, a single word which most C programmers consistently associate and have associated with a particular meaning for nigh on 40+ years now regardless of whether the word has been used as formally defined. ...and then teach students that “stack” means one thing in their C class and another in their algorithms class, and try to explain the difference, and hope they get it right? When they don't even need to know anything about it to learn C?
I submitted some issues about precision or bugs before with the same ID. I think IKOS is a very "industrial" project. It can really love this project and hope it be better. But, I have some doubts about whether abstract interpretation (without other technology) is applicable to safety-critical software. In fact, false positives usually come from buses, interrupts, registers, etc., rather than abstract domains. I hava no good idea how to use abstract interpretation unless ask user to add many annotations(just like astree).
That's a C++ library, and this sub is for C. Try /r/cpp_questions.
Is using your OS's implementation of mmap an option? 
I'm not aware of this solution. My os is linux mint, do you know where I can find some information about this ? 
It's a technique called memory mapped IO. http://man7.org/linux/man-pages/man2/mmap.2.html It's an OS level abstraction - you interact with the file's data as if it were memory. The kernel will page the file contents in and out of memory as required as you change/access data in the memory region. Depending on your algorithm it can be many times faster than fseek/fread. 
I never understood the reasoning behind pointer type declaration and pointer dereferencing using the same symbol (*), but one way to keep it simple is to attach the * to the type when declaring a variable (char* x); this way, whenever I see an * together with a variable, I know it's dereferencing it. I have no idea why people prefer doing (char *x), aside from when declaring several pointers in the same line. Seems pretty counter-intuitive to me.
The full code is [on GitHub](https://github.com/PurpleAlien/Raytracer/). There is also [part 2](https://www.purplealienplanet.com/node/23). Disclaimer: it's my blog.
Oh, hey! Thank you so much, I've been studying the blog posts they're incredibly well written! Do you ever think about going back and extending it?
I do, but I have so little free time I don't know when. I'm trying to write part 2 of [this one](https://www.purplealienplanet.com/node/69) before the year is up, but even that keeps sliding because of other obligations...
This is a fantastic article. It really helped me grasp strict aliasing rules and learn about the various subtleties. I was confused by the discussion of MISRA rules though. It seems like there's no way to type pun.
Ah, I see! I wish you the best of luck, unfortunate that there's only so few hours in a day! 
Ok, in the first example why does it not break? I tried programming it so it would break if just one of them was true. does not || mean "or"? &amp;#x200B; &amp;#x200B;
See, it does not break because the condition stays true. Try it for yourself. Think of what condition would ensure that the condition is false. Have you worked with Boolean Logic before? Do you know how logical OR works? If you don't, can you please search on the internet and find the "truth table of logical OR"? It will help you understand what is going on. 
MISRA is effectively a subset of C which is designed to be portable, and is intended to be immune against compilers doing weird things. Code which performs type punning via any means, whether unions, `memcpy`, pointer casts, or other mechanisms will generally be inherently non-portable. If the nature of the task to be done is inherently non-portable, that may be justified, but programmers should document when they rely upon such constructs to ensure that systems don't evolve in a way that breaks them. Incidentally, while most places that use MISRA require that many compiler optimizations be disabled (definitely a wise move for some compilers that prioritize "performance" over correctness), `memcpy` has an additional problem when used for type punning. Requiring that `memcpy` always make allowances for type punning would sometimes needlessly impede efficiency, but the Standard fails to offer any meaningful and useful guidance as to when it should or should not be expected to do so. Use of `memcpy` for type punning thus falls in the category of operations that will generally work, but may occasionally fail if a compiler happens to find certain "optimization" opportunities, which is not something that anyone should tolerate in a safety-critical system (nor anywhere else, really, but especially in safety-critical systems). 
It's interesting comparing this analyser to rust. In (the safe subset of) rust, you have to write your code a certain way to satisfy the region analysis (borrow checker), which is getting smarter (non lexical lifetimes) but still makes you jump through some hoops, and rely on the compiler applying optimizations to get code as fast as hand written unsafe code. The times when you know your code is valid but the compiler rejects it are analogous to the false positives here I guess. It's also interesting to think about whether I would still prefer rust if I could have a C compiler that disallowed memory errors. I think I would, because I can write more precise APIs using rust's rich type system, but I would certainly have less fear when using C with complete static guarantee. One thing that is good in rust is that often when you have a false positive, you can rewrite your code into an equivalent form that passes the borrow checker, since deciding whether something is a false positive is a possibility for an error of judgement. I wonder how writing C with this tool pans out - if you have the same experience.
You will probably get a better response on /r/cpp the c++ subreddit.
This is C++ not C.
This is a subreddit about C, for C++ questions you should head over to /r/cpp_questions. For future questions: "it doesn't work" is not a description of a problem, please be descriptive when describing your issues, e.g. "When I enter a statement, I get more than one prompt before the processing is complete".
Seems like someone is not aware of ASCII codes. Someone screenshot that switch statement lol.
i'm a student in intro to c++, this is my first switch statement
any tips for switch statements?
&gt; it's not working for some reason, can anybody help me out? First, you will get faster, better, help by asking more specific, more answerable, questions. Here are some relevant resources: * [How to create a Minimal, Complete, and Verifiable example](https://stackoverflow.com/help/mcve) * [How To Ask Questions The Smart Way](http://www.catb.org/esr/faqs/smart-questions.html) These might seem a bit condescending, but, well, in a way that's the point. 
Yes. Learn about ASCII codes and think how you can implement them so that you do not have to write such horrible and lengthy switch statements.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
The most obvious problem is that you issue the user prompt before reading every single character. A less obvious problem is that your program doesn't handle end-of-file. ... but to get more help you will need to be more specific about what you expected and what you got.
Don't be a dick.
ok guys I understand that this is my first post and that my coding and the manner in which i posed my question was not up to par. This is my question now, is there anything i can use other than cin.get(char) so that I will be able to enter either Q OR a statement to be processed
where should i put the prompt? im using my professors template of reading a letter entered and saying if its lower case or not then he gave us this crazy (atleast to me) question. 
ok i will do so in the future
&gt;Just a small rant here ...i love how this is included in your SEVEN paragraph tirade.
If you're looking for exercises I recommend checking whichever textbook you chose to use. See the sidebar; K&amp;R is gospel in this sub, but [The C Book](http://publications.gbdirect.co.uk/c_book/) is free and totally serviceable. Beyond that, check out [HackerRank](https://www.hackerrank.com/) for general problem solving, or just do a google search for "programming exercises." Personally, I stick to [Project Euler](https://projecteuler.net/) because my background is mathematics, but a lot of people find its content to be impractical. There are also a number of challenges out there like what was once known as [The Montasano Cryptography Challenges](https://cryptopals.com/), or [The Eudyptula Challenge](http://eudyptula-challenge.org/) if you can persuade them to let you. In general, don't look at anything as being too difficult for your skill level; try everything, and if you can't make what feels like significant progress in an afternoon move onto something else. Hope that helps.
Yeah. I've probably forget to set the verbosity level to --verbosity=1 before commenting here. My bad.
I use an editor with tabbed windows. Or you can open two instance of editor and put one on another monitor. 
Not to forget reddit's /r/dailyprogrammer where each problem is labeled with a category out of "Easy", "Intermediate", and "Hard". The problems given in dailyprogrammer are not always the easiest to deal with in C, but there's bound to be some that will help you practice your C programming.
Your \`output()\` function does not define \`ptr\`. BTW, it is customary to name \`FILE\` pointers \`f\`.
Ty i will look all this pages
Ty i like the idea of challenges
&gt; it is customary to name `FILE` pointers `f` I'm not familiar with this custom. I usually try to name them something meaningful.
"ptr" isn't really meaningful.
So, your problem is that you have no way to connect the data you read to the data your wrote. Why, for example, does "output\[50\]" have anything useful in it?
There is no custom in this regard.
No that's just to obtain the name of the output file and create a file with that name. What I want to do is transfer the contents of the input file to the output file
Suggestion: one function for prompting the filename and opening it, used twice, another function to do the actual copying, once. FILE *prompter(char *Input_or_Output, char *r_or_w) { ... return (fp); } void copier(FILE *fin, FILE *fout) { int c; ... } &amp;#x200B;
I'd certainly agree with that. I was questioning using `f` as the name for all `FILE` pointers not advocating meaningless names.
Most of the time, you only have one, so there is never any doubt about which one a particular `fread()` or `fprintf()` or whatever call refers to. In cases like this, the name is mere decoration; make it unobtrusive.
&gt; Most of the time, you only have one You must not work on very complicated systems. Even in this example there are two files. Not naming the files something reasonable leads to confusion. At the very least naming them something like `in` and `out` would make it obvious which file was which.
Okay -- and when would this program do that? It has two files -- it opens and closes each one without doing anything. 
C and Rust are not unrelated languages, and they are not unrelated topics. It is entirely appropriate to discuss, compare, and contrast different languages. It is healthy and normal. There is no such thing as a "C developer" or a "Rust developer". People use different languages, and use many languages. People choose tools as appropriate for a specific task. Ideas cross over from one language to another. Are you asking for some kind of "silo" of languages, where every language community is disconnected from every other language community? That sounds horrifying, and stagnating. &gt; Theres this implicity harasment of C and C++, that is becoming normal.. If you think that *discussion* of languages equates to *harassment*, then you're beyond the point of rational discussion. If you think that C/C++ developers are being *harassed*... I just can't wrap my head around that. It is literally the dominant language of systems programming. It is not some pitiful underdog. It is the language that I spend nearly all of my waking hours working in. You really seem to have *invented* this point to argue about.
24.0 miles ≈ 38.6 kilometres ^(1 mile ≈ 1.61km) 15.0 gallons ≈ 56.8 litres ^(1 gallon ≈ 3.79 l) ^(I'm a bot. Downvote to remove.) _____ ^| ^[Info](https://www.reddit.com/user/Bot_Metric/comments/8lt7af/i_am_a_bot/) ^| ^[PM](https://www.reddit.com/message/compose?to=Ttime5) ^| ^[Stats](http://botmetric.pythonanywhere.com) ^| ^[Opt-out](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=Don't%20reply%20to%20me&amp;message=If%20you%20send%20this%20message,%20I%20will%20no%20longer%20reply%20to%20your%20comments%20and%20posts.) ^| ^[v.4.4.6](https://www.reddit.com/user/Bot_Metric/comments/8o9vgz/updates/) ^|
This is a C subreddit, try posting this on r/cpp_questions
1. This sub is for C, not C++. Try posting on /r/cpp_questions instead. 2. Please format your code. Add an extra four spaces to the start of each line, or use the formatting tools in the new "fancy pants editor." 3. There's a difference between `#include &lt;Odometer.h&gt;` and `#include "Odomoeter.h"`
thanks :)
Imperial units are wierd... 
What people are referring to is that in the context of the function, there is no confusing the one file that's being worked on. So, no real issue calling the FILE \*f. &amp;#x200B; Second, you probably want your code to be closer to: FILE *open_input() { char input[50],c; FILE *f; printf("Enter Name Of Input File:\n"); fgets(input,sizeof input,stdin); strtok(input,"\n"); f=fopen(input,"r"); return f; } FILE *open_output() { char input[50],c; FILE *f; printf("Enter Name Of Output File:\n"); fgets(input,sizeof input,stdin); strtok(input,"\n"); f=fopen(input,"w+"); return f; } int copy_file_then_close(FILE *input, FILE *output) { ... DO copying here... } int main(int argc, char *argv[]) { copy_file_then_close(open_input(), open_output()); } &amp;#x200B;
Windows is just... different to do C on. Visual Studio's compiler only does C89 i think. In Linux, you can install all the tools you need in just one command in the terminal, no crazy configuring really needed there. Linux is just easier to get programming done on. If you really need to stick with Windows, try Code::Blocks
!remindme
good luck. cmake has the worst documentation cuz for the company maintaining it, it is a side-business from the visualization stuff they do https://www.amazon.com/Mastering-CMake-Ken-Martin/dp/1930934319 also: https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 i mean it, by they way: if you think autotools suck, with cmake you will be in a world of pain, especially if you want to pass advanced options.
I would recommend searching the subreddit for "unit testing". There have been a lot of similar posts and people have replied with several options. &amp;#x200B; Personally, I would recommend Unity from [http://www.throwtheswitch.org/](http://www.throwtheswitch.org/).
Yeah, I have a similar opinion. Autotools is horrible and CMake is horrible factorial. Nothing but pain trying to get them working. I randomly encountered the [Bazel build system](https://www.bazel.build/) when checking out Google's Swiss hash. It may be worth taking a look at.
There are other [formal](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#Formal_methods_tools) static analyzers for [C/C++](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2C_C.2B.2B), but there is plenty of room for more tools. Ada (and the Spark extension) use dynamic checks where they can't use static checks. Static checks are non-intrusive, while dynamic checks are intrusive at run-time, so there is some trade-off.
https://imgur.com/bUbQLj5
You shouldn't have to rewrite your "code base" just to adopt CMake. Often times you can just add CMake support by throwing in a `CMakeLists.txt`. The biggest thing for understanding CMake is the understand what its primary abstraction is: targets. A target is basically a static library, a shared library, or an executable. If you have a shared library, you'll want to "declare" that with [`add_library()`](https://devdocs.io/cmake~3.12/command/add_library). You probably have some include paths to specify when building that so you'll want to specify those with [`target_include_directories()`](https://devdocs.io/cmake~3.12/command/target_include_directories). You probably link to some other libraries so you can specify those with [`target_link_libraries()`](https://devdocs.io/cmake~3.12/command/target_link_libraries). You probably have some special compiler flags you use when building that library, you can specify those with [`target_compile_options()`](https://devdocs.io/cmake~3.12/command/target_compile_options). Although you can specify compiler defines with `target_compile_options()`, there's a more idiomatic way of doing it with [`target_compile_definitions()`](https://devdocs.io/cmake~3.12/command/target_compile_definitions). Once you fully specify your target it should be buildable now. All of those commands basically append to or set properties on the target. These properties can be public or private which changes how those properties are inherited when other targets link to it. CMake 3 overhauled their documentation so it isn't terrible: - https://cmake.org/cmake/help/v3.12/index.html - https://cmake.org/cmake/help/v3.12/manual/cmake-buildsystem.7.html
Write your own. You really don't need 75% of the garbage anyway.
&gt; CMake 3 overhauled their documentation so it isn't terrible: can cmake give me a list of all the targets it can build? or even worse: what variables does this CMakeLists.txt use?
Interesting, thanks. Will have a look at it. &amp;#x200B;
Hm, haven't had to yet so not sure. There is a graphviz output of targets for dependency visualization between targets so the info is there but I'm not aware of any direct CLI option to bring that out. For environment variables probably not unless the author has done their due diligence in specifying build configuration customization points as "cached" variables: https://cmake.org/cmake/help/v3.12/command/set.html#set-cache-entry.
Sorry I am rebuilding my code base by adding CMake build scripts.
Yesterday I discovered that clion and kdevelop both support cmake. Not sure if that helps.
Why?
What part is represented by 75%. Wouldn't the act of writing custom unit testing frameworks be full of errors or something.
I'm just going to write a short list because it's a large list It can build for Xcode, Cline, Code::Blocks, Visual Studio, Ninja and more... I'm not sure about the environment variables because not to long ago I just stated learning C then to add on that I am also learning C++, Rust and CMake. &amp;#x200B; &amp;#x200B;
It's certainly not going to cause the program to not compile, it's just sloppy. If I were reviewing code that used `f` in this way I'd mention it as something that ought to be cleaned up for readability and maintenance issues. It isn't my code, but if you are going to rewrite OP's code here are a few notes: * Instead of two functions to open files, consider one function that takes `FILE*`, prompt and mode as arguments and returns success. * Pay attention to the success responses from the file_open function. * You changed OP's mode for the write file. Perhaps you had a good reason for that, but if not, OP will get an unexpected result.
Hence the "something like". There are numerous errors in the code, actually.
I've used Unity which works well. I don't care for the setup though, such as having to compile the `unity.c` file along with your source files, while also including the `unity.h` header. Makes it cumbersome for testing smaller programs. [https://github.com/mortie/snow](Snow) looks really nice. I'll probably try this for my next C project.
I care
http://www.jera.com/techinfo/jtns/jtn002.html
Although the speaker is not a great presenter, [This talk](https://youtu.be/bsXLMQ6WgIk) is pretty good to describe how to use CMake Warning - you should know basic CMake first 
GTest is the standard for c++ and ports c easily. I'd suggest that.
Vv
sorry? &amp;#x200B;
I didn't understood your problem, that was missclik, sorry.
Search "scanf char" in the subreddit. You will see why that is happening. Quick read: [http://c-faq.com/stdio/scanfprobs.html](http://c-faq.com/stdio/scanfprobs.html) &amp;#x200B;
God save us. What is the exact input you are using and what are the exact results. "Sometimes" does not cut it. And should this work with lowercase and uppercase too? 
When I give input that is not g or d then it sort of gets stuck
Should only work with lower case 
So I should be using fgets instead and then just take the first char of the fgets?
Okay. Now answer the two other questions. Write down the input you tried it with and the result. Then state whether it was expected or not. Include one test case where the program misbehaves and can always be reproduced. 
&gt; So I should be using fgets instead and then just take the first char of the fgets? Think about this from the user's perspective: they enter some input, then hit Enter to submit it. Why shouldn't your code mirror this sequence of events? If your code only reads a single character, then it _has_ to be incorrect if the user does anything except enter a single character. And since (by default) a line can't be submitted without the user pressing Enter, the user is always going to be doing _more_ than just entering a single character.
You shouldn't have to rewrite your codebase to change build system
Youll want to take indent-code50 before CS50 my brother. And no Im not doing your homework. 
Did you try cs50 through edX? You want to take it through edX because it is structured well that way. They have their own IDE for C. I think CS50 is the best way.
CS50 through edX. I dont know what it means by crash course because you dont learn anything something like programming in a few days. If you need something to do numerical computation, then it may not be difficult to learn only you need very quickly. You only need to know how to loop things and how to write function with input and output.
Definitely bad if you are a tutor. You are writing a solution to students who want to check the code logic not that syntactic sugar.
Why C and not Java? Why C and not Python?
Yes, thats the way, scanf save the last \\n from the user, and in the while loop thats make troubles
I've had good luck with [munit](https://nemequ.github.io/munit/), personally. It's easy to integrate, easy to use. I've only every used it on Linux but it runs on Windows, too.
Instead of using scanf() can't you just use getch() ?
All software is buggy when it's initially written... Writing your own makes you independent from API/ABI changes, and allows you to customize it to your specific needs, not to mention it's entirely yours, you can do it absolutely however you want. I know, it's an unpopular opinion here, but I've done that for all the basics, my main library FoundationIO has implemented all of the standard library features I need except allocation, deallocation, and I use fread/fwrite. and I did it absolutely how I want. With that, I don't need to worry about which platform implements which decimal to string algorithm for example, or wether various standard libraries are reentrant or which ones support multithreading and which ones don't. it's an option you should consider is all I'm saying. it's not as hard as you'd think.
https://gmplib.org
Do you need to simply store and retrieve a 160-bit integer? If so, you can just declare an array of 20 bytes and write a routine to serialize/deserialize to/from the array. Or do you actually need to do 160-bit math? If so, you're most likely going to want a 3rd-party library such as the [GMP library](https://gmplib.org) that u/jedwardsol linked.
Thanks
an array of 10 bytes, `unsigned char value[10];`, will do nicely
Thanks. I was skeptical because the link is not https.
You did not mention the language you’d like to test in, so I’ll assume it is C or C++. First of all, I would really recommend reading the book “Test Driven Development for Embedded C”, as it describes the fundamentals very well. It also describes why it is very useful to be able to run the unit tests on both the host- and target machine. If you are targeting a PC, Google Test and Google Mock are a great combination. If you are targeting an embedded device, I would really recommend [Cpputest](https://cpputest.github.io). It can test both C and C++, supports mocking, supports testing for memory leaks and uses very little resources as in RAM and ROM. This allows to run the unit tests on resource limited systems. 
why do I get a certificate error on that site?
Maybe you don't have to, Windows server [includes an ssh server](https://blogs.windows.com/buildingapps/2018/12/11/windows-server-2019-includes-openssh/) now! /s https://github.com/substack/libssh/blob/master/examples/samplesshd.c
It expired today.
Thanks! That's pretty much what I was looking for. I'm writing this just out of curiosity, so I'm not really going to use it for much. 
Yeah, they seem to be having certificate problems at the moment.
With typedef, the meaning of the identifier before the; changes. `struct Foo {} bar;` creates a variable `bar` of type `struct Foo`. `typedef struct Foo {} bar;` creates a type alias `bar` for the type `struct foo`.
gmplib.org is definitely a legitimate page. As someone else said they're having certificate problems now. Regardless, it's wise to always verify the signature of any code you download, especially from a page that has certificate issues. On a sidenote, I feel like we should not downvote people for being skeptical of certificate warnings. This trains them to have the wrong reaction to these warnings. There really is an issue here on the gmp and distrusting it is the correct reaction.
Yeah. But what happens with the \n from the enter? 
Better use an array of 5 32-bit integers so doing math is easier.
Well this is the first time I've ever heard that.
I don't really see how you can make it simpler, but there's two little things that bug me : 1. You declared your function as returning an `int`, but you don't return anything. Either make it `void` or return an exit code instead of using `exit()` directly in your function. 2. Your error message insn't very informative. If your program must be called with exactly three arguments, just say "This program needs exactly three arguments". Also when you put several lines of code you should put them between two "```" to make a code block.
getch() will return once the user presses a single key - not after they press enter after pressing their selection. You could make it print the answer they chose and then wait for an enter - and you would just eat the enter. A far cry from insurmountable to my mind.
Just because curiosity why you want that
1. If I make it void, it doesn't work with the int argc as I see. 2. That's a good point, I fixed it. 
Probably for SHA-160. 
I think you need this to be something like: ``` int verified_arg_count(int argc, int expected) { if (argc == expected) return expected; fprintf(stderr, "Expected %d args", expected); exit(1); return 0; } ```
Maybe he/she ment "why a function for this". Checking arguments in main is most straight forward way.
Upps you are right i miss that point
Many microcomputer C implementations have an easy means of getting a single character rather than waiting for a line. The authors of the Standard have refused to standardize any such features on an as-available basis, but the appropriate function is often name `getch()` [as distinct from `getchar()` and may be, but isn't always, found in `&lt;conio.h&gt;`.
When I say `void` I mean the return type, so instead of `int checkforerror(int argc)` it should be `void checkforerror(int argc)` because you're not returning anything. I'd be surprised if your compiler doesn't at least throw a warning.
i found some ty both of u
Hey guys how can I make the following code simpler: `int x = 10;` Thanks.
I doubt he ment that, 'cause the actual task said that the main function can only be 5 lines...
You can’t just define `uint128` (how?) and expect `&lt;stdint.h&gt;` to magick it into existence; only 8, 16, 32, and 64 are remotely guaranteed, and technically only then in the `_least` and `_fast` forms. (The plain old `uint8_t` etc. aren’t guaranteed to exist on all arches, although you’d be hard pressed to find an architecture without those types.) `&lt;stdint.h&gt;` could theoretically define `u`-`int128_t` and its variants, but I’ve never seen that in the wild, since the preprocessor won’t support ≥64 bits and that’s what `&lt;stdint.h&gt;` uses for `u`-/`intmax_t`. *When supported*, you can do typedef unsigned int ext_uint128_t __attribute__((__mode__(__TI__))); typedef __signed__ int ext_int128_t __attribute__((__mode__(__TI__))); on GNUish compilers back to like GCC 4.6 when targeting most 64-bit architectures; that mode isn’t generally supported on 32-bit targets, since `DI` (64-bit) is already double the word size. Newer GCC and Clang support the MSVC extension `__int128`, which on GNU compilers you can semi-reliably detect by testing for `__SIZEOF_INT128__` being defined. Those `typedef`s’d look like /* For GNU: */ #if !defined(__SIZEOF_INT128__) || (__SIZEOF_INT128__+0) &lt; 16 # error "`__int128` doesn't appear to be supported by this compiler" #endif /* For MSVC, AFAIK you have to pick through the various `_M_`- target * architecture macros to see if `__int128` is supported. */ typedef unsigned __int128 ext_uint128_t; typedef signed __int128 ext_int128_t; GCC and Clang also support an older pair of built-in types that’s more GNU-specific, again dependent upon target architecture: typedef __uint128_t ext_uint128_t; typedef __int128_t ext_int128_t; None of the above allow you to use 128-bit integer literals, or to use 128-bit values in the preprocessor, unfortunately. So, assuming you pick one of those 128-bit types, you can do typedef struct { ext_uint128_t low; uint_least32_t high; } ext_uint160_t; typedef struct { ext_uint128_t low; ext_int128_t high; } ext_int160_t; to make a composite 160-bit type. For 32-bit targets, you’ll probably need to do something more along the lines of typedef struct { uint_least64_t low, mid; uint_least32_t high; } ext_uint160_t; typedef struct { uint_least64_t low, mid; int_least32_t high; } ext_int160_t; As for doing actual operations on them, the compiler won’t be much help on its own because under the hood the double-width integer operations tend to be done in a very architecture-specific way; on x86, for example, they may make use of CF, which is difficult to mix with other code. Extended-width add, subtract, shift, and multiply are pretty easy to hand-code; e.g., an add of the 32-bit type without going into inline assembly: out.low = in1.low + in2.low; out.mid = in1.mid + in2.mid + (out.low &lt; in1.low); out.high = in1.high + in2.high + (out.mid &lt; in2.low); /* For the signed version, pull out into the unsigned variant, do the add, * and stuff back into signed output so signed overflows don’t break things. */ You can use inline assembly to ensure the compiler uses CF tricks for those `&lt;` comparisons that check for carry-out on the prior operation, but doing that at all optimally may require some horrid trickery. x86-64 is simple-ish assembly, though (GNU): union { ext_uint160_t value; struct { uint_least64_t low, mid; uint_least32_t high; } parts; } tmp1 = {in1}, tmp2 = {in2}; __asm__( "addq %q2, %q0\n" "adcq %q3, %q1\n" "adcl %k4, %k2\n" : "+&amp;r,&amp;r,&amp;r,&amp;r,&amp;rm,&amp;rm,&amp;rm,&amp;rm"(tmp1.parts.low), "+&amp;r,&amp;r,&amp;rm,&amp;rm,&amp;r,&amp;r,&amp;rm,&amp;rm"(tmp1.parts.mid), "+r,rm,r,rm,r,rm,r,rm"(tmp1.parts.high) : "nrm,nrm,nrm,nrm,nr,nr,nr,nr"(tmp2.low), "nrm,nrm,nr,nr,nrm,nrm,nr,nr"(tmp2.mid), "nrm,nr,nrm,nr,nrm,nr,nrm,nr"(tmp2.high) : "cc"); out = tmp1.value; A 32-bit version of this has to be significantly more miserable because there aren’t enough regs (need 5 for each value), although you can do some cheating with the FPU (which can do 64-bit math perfectly well) or SSE. For fully arbitrary-width integers, you’d do an initial `add`, then loop tightly with `adc` for anything beyond the first 32 or 64 bits; alternatively, you can do an `xor` to zero out the output and clear CF, then `adc` everything in the loop. Extended-width division will have to be done mostly-manually or via the x87 FPU, although instructions like BSR can help speed up the search for 1 bits to match up. You can also cheat a bit for wider-by-narrower division (e.g., 64-by-32), and iff the result fits the output regs, DIV and IDIV on x86 will do a narrowing division for you. Extended-width multiplication will either have to use half of the processor’s native word for each multiplication, then combine them (i.e., evaluate *xy* as (*x*₁ + 2³²*x*₂)(*y*₁ + 2³²*y*₂)), or else use an architecture-specific widening multiply like the implicit-operand forms of MUL on x86. ADCX/ADOX is a useful extension to use here if you have it, because it lets you do two extended-width adds in (instruction-level) parallel. And because all this is so unpleasant and tedious to deal with properly, it’s probably easier just to go with GMP or something along those lines.
In that case the simplification is probably the return type void, like others have pointed.
Perhaps we could have a link to the full code? - Would make a bit easier to get some insight into what you Professor intended you to do.
If he asked a detailed question, I'd give a detailed answer. 
Please indent your code and get real bro. Write a lexer at least and then come back asking for help.
So a sum of all the integers in your array ? The way you asked your question is kind of confusing ...
The reason the standard size of integers varies is because of the number of bits used in the different CPU architectures out there (think 4, 8, 16...-bit microcontrollers) and basically has to be a power of 2 (2^N). That's defined in the stdint.h library. 
But if I make it void, it doesn't work with the int argc...
Is this a troll?
Well I had to make my own strcmp fuction. I wanted to make it "fail proof" so if somehow it not gets 3 args, it exits with failure. 
They're right and you're wrong. Bits are counted starting from the least significant, i.e. rightmost.
You are going to need some more logic here... Also, what is `n` in your for loop? You haven't defined it, so you should be getting errors for at least that.
Please post your entire, unmodified code, properly indented.
Bits are numbered right to left. But the question means that once you have the starting position, they procede left to right. Ie. 3 bits starting at 5 means 5,4 and 3 876543210 000111000 and not 5,6 and 7 876543210 011100000 
I'm happy to be wrong, as long as I learn from it. However, consider the text of the "answer" book: &gt;To set `n` bits of `x` to the rightmost `n` bits of `y` xxx...xnnnx...xxx x yyy..........ynnn y &gt;we need to clear the `n` bits in `x`, clear all bits in `y` except the rightmost `n` bits and then shift them to position `p`, and OR the quantities together. xxx...x000x...xxx x 000...0nnn0...000 y ----------------- xxx...xnnnx...xxx x That doesn't seem to be what's happening, though. 
K&amp;R is probably good to read and feel pleasant to read indeed, but no very good to learn C from because it is old. You want to learn C from CS50 by Harvard through edX and/or Duke's C specialization (4 courses, and 3rd and 4th feels actual learning) through Coursera. Both are very high quality. EdX has another C course offered by another University but CS50 is by far better if you think of how much resources have been dedicated to the course over the last few years.
Thanks, I've seen K.N. King's book being recommended as well. I've been posting some of my solutions from Ch.1 on codereview.stackexchange.com and getting valuable feedback there. Many commented that it's outdated but I figure it'll teach me more than just C, and I can get up-to-date using King's book later :)
What's happening where? In the one-liner? That's exactly what's happening. If you don't see it, break it up into separate steps.
There we have it, thanks :)
I see it now. I was counting bits from the other side :D :facepalm:
How come? void check_for_two_args(int argc) { if (argc != 3) { fprintf(stderr, "2 arguments, please.\n"); exit(EXIT_FAILURE); } } &amp;#x200B;
Wait, I understand I've been counting from the wrong side, but shouldn't the `n` go in the same direction ie 3 bits starting at 2 to be: `876543210` `000011100` and not `012345678` `001110000` as I initially thought 
In looking at that problem, I believe you may be overthinking it a bit. From what I can gather, you want to have your integers in an array. You need to define that array size as well. So start like this: #include&lt;stdio.h&gt; #define SIZE 5 Then initialize your array. int nbrs[SIZE] = {23, 45, 67, 89, 10} Then run your loop. See what happens.
I think we need to see the full program to understand what's going on.
Just before the exercise in the text book is the text &gt; As an illustration of some of the bit operators, consider the function getbits(x,p,n) that &gt; returns the (right adjusted) n-bit field of x that begins at position p. We assume that bit position &gt; 0 is at the right end and that n and p are sensible positive values. For example, &gt; getbits(x,4,3) returns the three bits in positions 4, 3 and 2, right-adjusted So setbits(0,5,3,0xFFFF) returns 876543210 00000111000 Start at bit 5. Next bits are 4 and 3.
`getch()` does not exist in the standard C library.
&gt; is it a good idea to learn UML? UML is never a good idea.
The Duke's course (4th) does teach you OS level (system call) while CS50 teaches you things faster with 4 lectures and more resources to watch as a supplement. They have assignments you can work on and the forums are very helpful. Because those courses obviously consulted K&amp;R in creating the course, you really don't need to spend so much time on K&amp;R. Again it is pleasant to read. The writing style is very confronting considering it is a book to teach programming, but I don't recommend to spend time (waste?) to solve the exercise as those courses I recommend ask you to do their exercise in more appropriate (modern) contexts. . 
The Duke's course (4th) does teach you OS level (system call) while CS50 teaches you things faster with 4 lectures and more resources to watch as a supplement. They have assignments you can work on and the forums are very helpful. Because those courses obviously consulted K&amp;R in creating the course, you really don't need to spend so much time on K&amp;R. Again it is pleasant to read. The writing style is very confronting considering it is a book to teach programming, but I don't recommend to spend time (waste?) to solve the exercise as those courses I recommend ask you to do their exercise in more appropriate (modern) contexts. . 
It's old but it's still useful. Remember a thread here the other day where some people said it's a good book for people who already can program? My university uses it as the text for _third_ semester programming
The oneliner becomes slightly less hairy, if you count p from lsbit, and p + n towards msbit.
Geez, I see now that my head will continue to spin until I get used to it all. So when we're finding the first bit we count right-to-left, but then when we're taking `n` starting from there we're counting left-to-right.
In that exercise yes. I don't know that there is a industry wide acceptance of what "n bits starting at p" means because in the real world it is unusual to need to do this.
Perhaps the teacher meant to look at using the functionality in `assert.h` or some variation supplied by the implementation? That could replace the body of that function with a single line. Otherwise, my preferred approach would probably be to define a `fatal_error` function which combines the actions of outputting a specified message and performing `exit(EXIT_FAILURE)`. This approach can be helpful if it's necessary to change the mechanism for outputting messages (e.g. feed them to a log as well as the console), and can help make code more compact if one is using a formatting convention that allows `if` statements with simple controlled statements to avoid the need for whitespace-only lines (e.g. using a convention of: if (foo) simpleStatement(); if (bar) { partOfComplexStatement(); partOfComplexStatement(); } or if (foo) simpleStatement(); if (moo) { simple(); sequence(); } if (bar) { partOfComplexStatement(); partOfComplexStatement(); } I personally prefer the second group of styles, since I think it best handles the case of an `if` controlling a simple statement, and putting the opening brace on its own line makes it easy to find given a closing brace, and vice versa; other people like other conventions, however. 
Small codewise or memory wise?
re edit; TIL that shifting for &gt;= type width is undefined, so that's why in my solution I put `(~0u &gt;&gt; (p + n - 1) &gt;&gt; 1)` instead of `(~0u &gt;&gt; (p + n))`
TIF it, once again :)
Unrelated but i read "I have a question about nipples "
It does, if you haven't played tricks with stdout (freopen etc). Just remember to close it too, on both processes, so that reader can see EOF.
Does it close it automatically when I exit the program with exit(EXIT\_SUCCESS)? Because after the fork and configuration of the pipe, I'm using execlp() to use the child process as a recursion, which means I can't close it afterwards because the variable pipefd doesn't exist in the child anymore, if I understood it correctly.
It willl close all right when the child exits. Just good manners to not pass extra open files beoynd exec. The usual problem is when the close is forgotten in parent. "Why is read hanging?"
I have two pipes per child(one for parent-&gt;child and one for child-&gt;parent). After the fork I immediatly close the read end on parent-&gt;child in the parent, the write end in child-&gt;parent in the parent, the other two ends in the child, write to the child, then close writing in the parent and after reading from the child, I close the reading in the parent before exiting the parent. And in the child I immediatly close the read and write after using dup2 for stdin and stdout, followed by the execlp. So I hope that covers everything and I didn't forget anything.
What are the similarities and differences to tcc? And does it try to accomplish a different goal?
Sounds right. Any leaked descriptors should be visible to some system utility, lsof, procstat -af, ... etc.
You mean: printf("Something Something\\n"); &amp;#x200B; fflush(stdout); &amp;#x200B; exit(EXIT\_SUCCESS); &amp;#x200B; right=?
No, `exit()` calls `fflush(NULL)`, but you should flush and close everything other than `stdin`, `stdout`, `stderr` before calling `exec*()`.
Just that. There's a newish stdio addition, dprintf (to a descriptor, not FILE \*) which could be useful, but it maybe missing from older systems. It might be a good idea to check the first pipe descriptor you get, \[0\] end, that it is above STDERR\_FILENO. If it isn't, something is very wrong, potentially someone trying to fool the program to do bad things.
sonny, if you don't tilt your head down and embrace the `pipe` game, you'll never `fork` a child process of your own...
One more pitfall to remember: If stdio had buffered something before fork, exit in child and parent could \_both\_ write that out.
Binary, 10100000 Quaternary, 2200 Octal, 240 Decimal, 160 Hex, A0 Base 32, 50 SHA-1 is a crypto function that takes an input and produces a 160 bit (20 bite) hash value that will be rendered as a 40 digit hex number. (Can be found in CryptoJS https://code.google.com/archive/p/crypto-js/ Alternatively, in your shell, you may try npm install sha1 Or ender build sha1 
Need an Update OP: How did you do on the assignment?
Former, from desc. &gt;Like 8cc, no memory management is the memory management policy in 9cc. We allocate memory using malloc() but never call free(). I know that people find the policy odd, but this is actually a reasonable design choice for short-lived programs such as compilers. This policy greatly simplifies code and also eliminates use-after-free bugs entirely. 
&gt; if you think autotools suck, with cmake you will be in a world of pain CMake gets used for the portability, though. I don't believe autotools is very portable at all. 
He may want to use my lexer lol. It uses no mallocs at all. Its all memory blocks that are statically allocated and can be reused as many times as you want during lexing. Memory works like a stack and is dirt simple. With 10kb of memory I am able to lex about 2kb of C code at a time or around 500 tokens.
A lot of things don't exist in standard C.
I agree with your methodology, with the possible exception of "Read “Modern C” by Jens Gustedt and use the most interesting ideas in the project". I hear it's good, but I haven't read it yet. It wouldn't hurt to have read it before work, but be careful applying it, perhaps. Try to practice making clean commits. Change just one kind of thing in each commit, or change just one subsystem. This is how development is done at scale, so we can (hopefully) apply patchsets/commits mostly-independently from each other for testing and isolation. Branching and merging can be used, too, but you'll really want to practice having clean diffs. Therefore I would suggest doing any "modern" refactoring last. I guess I would reformat first, and then crank up tight compiler options and static analyzers and work on all those. As far as I know, the classic volume on refactoring is *Working Effectively with Legacy Code* by Feathers. *Code Complete* by McConnell has general good advice and is quite readable, with the only caveat that you'll have heard much of the advice already if you spend time reading programming forums these days. 
tcc is a complete package. this seems still experimental.
those elses aren't necessary. The function has already returned.
It's not a memory leak, it's a feature!
Your code is formatted like an asshole.
Spoiler lol. Fix your formatting. This is disgusting.
Is there a point to this, or just a fun hobby? (And fun hobby is a quite worthy thing to do -- I'm not disparaging that at all if it's your goal). It's just that I don't know what the advantage to a small compiler is. 
'Tis the season, check out https://adventofcode.com/.
Infinite number of registers to finite number of registers. Someone's missed the concept of infinity...
Why do you say that? The mapping is not one-to-one.
Because then it's not infinite...even if you map at a billion to one, there's still an infinite things to map
It is definitely for edificational purposes. His previous compiler, `8cc` was along similar lines. The express purpose this time around appears to be readability so that beginners can benefit from the same.
Let f(x) = 0 where x𝜀ℤ. We have just mapped an infinite number of integers to a single integer.
I had the same book in the second semester over a decade ago. Still the best book for beginners/intermediates to learn/refresh their C skills quickly! :-)
&gt; but I don't recommend to spend time (waste?) to solve the exercise as those courses What a load of utter bullshit. The exercises are where all the actual learning takes place. OP, please do ALL the exercises - they will make you an overall better programmer.
I definitely think you are doing the right thing. Also, it is great to see you doing the exercises. For such a small book, most (if not all) the learning actually happens in the exercises, so I would doubly encourage you to definitely do **all** the exercises from K&amp;R (2nd Edition). It will indeed teach you a lot more than just C!
I was going to do the same, but if you've already done the work ... care to share the Dockerfile?
I would expect NumBytesRead to be a pointer to an integer so that the function can modify it in which case you do not have to modify your macro. Seems to easy tho so I probably misunderstood something.
You could try using an `inline` function to wrap `ReadFile()` instead. It's not as portable as a macro, but as I understand it you'll end up with the functionality you want. 
Could be off the mark, but there used to be a function readsocket, direct replacement for read.
&gt;I'm using execlp() to use the child process as a recursion Recursion, as in execing the same program a new ? longjmp back to main could be an option.
 &gt; I'm trying to write code that can be understood extremely easily I'm wondering how such a goal is measured. Further, I'm curious: does the almost complete lack of comments and documentation help, or hinder that goal?
The first number on each line is simply the index (or the address) of the first byte of the line. It starts at 0 and each line has 6 bytes so the indexes will be 0, 6, 12 (which is C in hex), etc.
It's just the address byte for the byte to the direct left of it. It's basically helps you locate specific bytes in the output. The first line starts at 0 and there are 6 bytes on it. The second line starts at 6. 0xC is equivalent to 12.
Oh my gosh, how can I not realize it? Understood now, thanks!
&gt; What is the front-most part of the binary? Why is there even a 6 or a c there? I think that's hex, presumably indicative of where you are in the file in bytes. Since the each line seems to show no more than 6 8-bit values it would make since that each line increases by 6. Then again there is that `.+&lt;M_f` and `......` on lines 1 and 2 respectively, so maybe I'm wrong. How are you extracting this information? Can you show us code? &gt; I tried to turn the binary to hex form, and even though it worked, the compiler seem to completely ignore that front part. Why is that? Ignore how? Like it doesn't show it as hex or it doesn't show it at all when you make this change? Are you using a compiler to extract this binary somehow? Again can you show code?
Thanks, that's the plan! My resoning is that it'll teach me not only C but also how to solve problems with it, and some computer science, too. It's amazing what you can do with just finishing Chapter 1.
I am currently afk, so I type this on my phone. It is not the complete code, but the essential part of the code that concludes my assumption is this fread(mac, sizeof(char), 6, file) for(i=0; i&lt;5; i++) { printf("%02x ", mac[i] } printf("%02x\n", mac[5]);
Currently writing a wrapper tool for dynamic analysis tools, should be finished by the weekend with it. I'll update today sometime with it. https://github.com/JeffJerseyCow/jeff
Depends on what you consider portable. It's portable on POSIX-platforms, which is kinda much. Except Windows. Windows is usually the only system people preferring autotools switch to CMake.
lol, so all solutions out there __are__ wrong :D
I think he will need another macro because with the first macro he lost the posibility to call the variable by code. `#define NumBytesRead (&amp;num_bytes)`
 #define Socket_Read(SocketAddress, OutputBuffer, NumBytes2Read) (ReadFile(SocketAddress, OutputBuffer, NumBytes2Read, NumBytesRead, NULL), NumBytesRead) 
https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#c Here are a Lot of books
limits.h (on FreeBSD) gives \_\_WORD\_BIT but it doesn't sound like it's to be used n &lt; __WORD_BIT ? ((x &amp; ((~0 &lt;&lt; (p + n)) | ~(~0 &lt;&lt; p))) | ((y &amp; ~(~0 &lt;&lt; n)) &lt;&lt; p)) : y; &amp;#x200B;
Judging by the readme, this is using an approach for modern day computers, with huge amounts of RAM, eliminating all traditional optimizations, including input streams, and hanging on to malloc'ed RAM forever. I like it. Caveat: I haven't looked at the code, yet.
You don't need to know the word width if you do `&lt;&lt; n-1 &lt;&lt; 1` instead of `&lt;&lt; n`. Well, as long as the user knows that he can't give an `n` bigger than word width which is a reasonable thing to ask. The user can check for `n &gt; __WORD_BIT`. However, the program should work for `n == __WORD_BIT` since that's in the problem domain, and those solutions don't work for that because they all perform `&lt;&lt; n` somewhere :D BTW, I'm doing Exercise 2-8 now, and author of the "C Answer Book" uses a function to find the word width. I don't see the need to do it - because it's really unnecessary, here's my take: /* **Exercise 2-8.** Write a function `rightrot(x,n)` that returns the value of * the integer `x` rotated to the right by `n` bit positions. */ #include &lt;stdio.h&gt; /* Right-aligned index, ie bits are counted as 76543210. * Example: p=4, n=3 gets us bits 432. */ unsigned rightrot(unsigned x, unsigned n) { for (unsigned i = 0u; i &lt; n; ++i) { if (x &amp; 1u) { x &gt;&gt;= 1u; x |= ~(~0u &gt;&gt; 1u); } else { x &gt;&gt;= 1u; } } return x; } int main(void) { unsigned x = 0xFFFFFF11; printf("0x%08X\n", rightrot(x, 16)); } &amp;#x200B;
Thinking about it, I imagine using \`WORD\_BIT\` instead of the hacky \`&lt;&lt; n-1 &lt;&lt; 1\` saves us some operations :)
So I started skimming through the code. While I know that reading someone else's style is always a matter of taste, there are still some things that really bug me. First, the code organization -- I'm really not a fan of "one header to rule them all". For example, parse.c should include parse.h, and maybe something like util.h. Second, once you do that, having a test per module becomes much easier. Third, it also shows where you screwed up your statics -- there's a non-static function in the middle of the sea of static calls in parse.c. Now, fifth, I *really" get the heebie-jeebies from the horrible memory management. For some reason, in your description, I had assumed you were allocating one big block in the beginning, and then that was it. Those mallocs sprinkled everywhere are just cringe-worthy. In some cases they might not even get used. The issue here is when this starts to have problems, you aren't going to be easily able to track down why. Couldn't you at least do a little more stack-based allocation, you know, where that might make sense?
`n[1]` doesn't exist. `n` stores the address, so use `printf("%s\t", n);`
I'm not sure about p[1]=name; p\[1\] is a pointer to void, while name is the 2Darray reference. You said it works with numbers, maybe that's because you don't use a 2Darray for number, you use a normal array. Try using name\[0\]: that is the reference of the first string. &amp;#x200B; I'm not really sure what "name" itself is as a reference, but in any case writing that line leads to confusion. 
`n[1]` The array subscript is also a dereference operator. The above statement will return a char. Internally, it'll be promoted to an int, dereferenced to 0x69 in memory, and probably crash your program. Just replace it for `n + 1'. That way you keep the pointer arithmetic without the dereferencing. Btw, casting p[1] is unnecessary.
Compile with warnings enabled. gcc -Wall -Wpedantic -Wextra new.c -o new new.c: In function ‘main’: new.c:8:14: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=] printf("%s\t", n[1]); //it works with name[1] ~^ ~~~~ %d This should give a hint that `n` isn't of a type we expect it to be. As a test, lets change `char * n = (char *)p[1];` to `char * n = name;` Now we get the following warning: new.c:7:15: warning: initialization of ‘char *’ from incompatible pointer type ‘char (*)[7]’ [-Wincompatible-pointer-types] char *n = name; ^~~~ Which is the real cause of the problem. `name` (or `p[1]`) is of type `char (*)[7]`, but you're trying to assign it to a pointer of type `char *`. Change this line to `char (*n)[7] = p[1];` and the program will work.
n+1 with printf gives output as "ill" while n+2 gives "ll". However I want to access "John" by dereferencing n pointer. Can I? 
Along the lines of your experimenting, try printing the value of the pointer to see where you've assigned it. (Hint -- it should print the zeroth value of the array)
`n[1]` doesn't exist. Try `n` :) Let's analyze it line by line. `name` is a `char**` i.e. a pointer to pointer. So in this case it stores the address of the pointer to a first char of the first string. So when you do p[1]=name; Copies the address of the first char into p[1]. The address will be written into some random memory location reserved for array of pointers `*p[3]`. char *n = (char *)p[1]; `char *n` reserves some memory cell to store **one** address. Assignment copies the address stored in `p[1]` into that cell. `n[1]` attempts to fetch the address stored in a cell **coming after** the cell for `n`, which will contain garbage. There's only one address stored, and that one is accessed with `n`. I think that `n[1]` is equivalent to `*(&amp;n+1)`, both which would get whatever garbage is stored at memory cell following `n` and interpret it as an address, jump to that address and attempt to read a '\0' terminated string from there. 
&gt;char (\*n)\[7\] = p\[1\]; I think I would have to typecast p\[1\], as it is a void pointer. and thank you for explaining at such length. &amp;#x200B;
&gt;Update: I tried to use puts(n\[1\]) it gives an error. &gt; &gt;but with puts(n), it prints "Will" which is at index 0; I have already tried it. Still couldn't understand.
n+7 will give you "John". The whole blob is stored as `"Will000John000Karl000"`. `n` gives you the address of where `'W'` is stored at and `printf` starts reading from there until it reaches the `0`. `n+7` gives you the address of where `'W'` is stored at but offset for 7 which happens to be the address of where `'J'` is stored at so `printf` starts reading from there until it reaches the 0.
Use `printf("0x%08X", n[1]);`. Addresses are not strings but integers.
Or just %p 
Thanks a lot. I just got that.
TIL, is there a way to make it show leading 0s?
I would rather not use an implementation of this in Javascript for a multitude of reasons.
Thanks everyone for going at such depths. I understood the problem.
Thank you. :)
Except in a few cases, an array expression decays into a pointer to the first element of the array. The array expression `name` decays into a pointer to the first element of `name`. This first element is an array of seven characters, so this means the array expression `name` decays into a pointer to an array of seven characters -- i.e., a pointer of type `char (*)[7]`. `name[1]` is equivalent to `*(name + 1)`. When you add 1 to a pointer of type `char (*)[7]`, pointer arithmetic dictates that this yields a pointer to the next array of seven characters, which in this case is a pointer to the "John" array. Dereferencing a pointer to an array of seven characters yields an expression of type "array of seven characters, so `*(name + 1)` yields an expression of type "array of seven characters." This array expression associated with the "John" array itself decays into a pointer to the first element of the array, this time a pointer of type `char *` pointing to the 'J' in "John". This is what you wanted, and everything works as intended. On the other hand, the statements `p[1]=name; char * n = (char *)p[1];` in effect result in a pointer of type `char (*)[7]` being assigned to `n`, which is a pointer of type `char *`. The pointer of type `char (*)[7]` pointed to the "Will" array, so `n` points to the 'W' of the same array. Hence `printf("%s\t", n);` will work but will print the wrong name, whereas `printf("%s\t", n[1]);` won't work any more than `char *p = "Hello"; printf("%s\t", p[1]);` would work.
This works: #include &lt;stdio.h&gt; int main(int argc, char *argv) { char name[3][7] = {"Will", "John", "Karl"}; void *p[3]; p[0] = name; p[1] = name + 1; p[2] = name + 2; for(int i = 0; i &lt; 3; i++) { printf("%s\n", (char *)p[i]); } char *n = p[0]; printf("%s\n", n); } 
Fill and spill?
`ReadFile` is not equivalent to `fread`. `ReadFile` is equivalent to the `read` system call on UNIX. Note that macros are *substituted,* not *called,* so it doesn't make sense to talk about what a macro returnes. My recommendation is to not use a macro for this. Instead, write a wrapper function. If you fear performance, you can make it `static inline` and stick it in a header file.
He explicitly states that he does not want to use a lexer. Note that most lexers do not need to allocate memory or at least have an option not to.
My pleasure :) Please see edit, I got confused. The compiler stores that as an array of \`char\` so \`name\` is not \`char\*\*\` but a plain \`char\*\`.
&gt;Compile with warnings enabled (always!). \+1 .... always listen to your compiler, it will save you endless hours of heart ache....
It doesn't seem to be sanctioned by ultimate church like CHAR\_BIT.
&gt; I think that `n[1]` is equivalent to `*(&amp;n+1)` `n[1]` is `*(n+1)`.
`name` is really not a `char*`, it's a true array, although it's true that it behaves the same way as a pointer when used as a pointer (as in the code), or when passed as a function argument. For example, `sizeof(name)` ought to be 21, not 8 or 4.
%p will typically format it into hex, which has 0x preceding it. From the gcc manual: &amp;#x200B; "You can supply the ‘-’ flag with the ‘%p’ conversion to specify left-justification, but no other flags, precision, or type modifiers are defined." &amp;#x200B;
Thanks, fixed it. Damn I'm hasty.
This looks like an excellent class project. I could see handing off individual instructions, various loader parts, etc, and have a large combined effort. The nice thing is that also teaches all the meta-programming parts -- how to write interfaces, how to test, how to name, how to comment, how to do source control. Very cool. 
This is epic.
Of course it get stuck. This has nothing to do with pointers and all with printing something that is probably not NUL terminated. All pointers are the same thing, types are just syntactic sugar so that the compiler does the pointer arithmetic for you. If you have a char pointer and you go to the next index the offset will be one. If you have an int pointer and you go the next index the offset will be sizeof(int) which is usually 4. 
Pay attention next time in class.
Sorry but he did not teach anything related to that project I have same ideas like getting numbers in char and converting them to array and make addition and subtraction in loops but I didn't learn how to convert strings to chars 
I assumed you would guess C because this is the C programming sub reddit after all. But its understandable that the language most be specified. 
 Not really sure what your asking here to be honest...
I have a feeling that you're in the same class as the person who asked about 160-bit math very recently. That thread is still on the front page and has good answers.
C program have to do addition and subtraction of 40digit integers like 4x10^39 - 3x10^39 sorry I'm not native speaker
No, we won't do your homework for.... wait.... wait.. this isn't the regular post... this is awesome. I love this write-up with all my heart. Thank you.
Thanks but i don't think so
Then learn how to... And also read on how to make a better question. Title is confusing and the body of your post does not help. Why don't you edit it and post some examples of the numbers that you wan't to deal with.
Strings are stored as an array of chars in C; the first element that array being the first char of that string. No need to convert, just access a particular char of a string by reading the correct element. For example, char string[] = “Random Text” char Char_1 = string[2] then printing Char_1’s value would give you character ‘n’
Oh thanks if we write something like char string[] = “1234567” How can get 7 as a integer?
I have to do this for all 40 digits and subtract from another 40digit number
By subtracting ‘0’ from that particular character. That is: char myChar = string[6] int thing = myChar - ‘0’ Remember, all chars are especially integers (they all have an ASCII value behind it) So char ‘7’ in ASCII is 55, and ‘0’ is 48 55 - 48 give you 7 
Let's think about how to think about the problem: Think about what you want your input and output functions to do. First generally, then specifically. Generally: `input` is responsible for prompting user for a filename, and reading the input. Generally: `output` is responsible for prompting user for a filename, and writing to output. What's missing here? Well, the big glaring question is *what* does input do with the file contents and *where* does `output` get it's contents from? Design questions/considerations: It seems like you need a place to store the contents between functions. For this, you need some type of buffer that will persist beyond the scope of the input function. If you declare this buffer in the input function, it'll go out of scope as soon as input returns. So if you want something to persist past the local scope of a function, you have two options: 1. Declare a buffer on the stack in your main function, and pass a pointer to it, so input can write to it, or.. 2. Declare a buffer on the heap, write to it, then pass it to your output file. (And remember to free it somewhere) I'm not going to tell you which one to do. It's up to you to figure out the implications &amp; pros/cons of each. Next design question -- how much data are you reading/writing? Is it a known size? Is the size unknown? If it's a known size, a fixed buffer will work. If it's an unknown size, a fixed buffer will still work, but you'll need to reuse it again and again and again... This implies (or rather, necessitates) that you run your input/output functions in a loop. Ie, read some stuff, store some stuff, write some stuff, repeat until all stuff is read/written. With that in mind, how many times do you want to open and close the files? Optimally -- you want to open each file once, and close each file once. What does that mean for how you structure your functions? Next design question: error handling. Now that you're thinking about how your program optimally runs, it's time to think about what happens when shit goes wrong. Where are places in your solution where errors can occur? What happens if you can't read from the file? What happens if you can't write to the file? What happens when you get unexpected user input? What happens when system calls fail? So... if you've gotten this far, it's time to write your functions. Think about them in this form: Generally: `function` is responsible for X. (Ie this is what happens inside it. Specifically: `function` takes xyz as parameters. `function` does xyz within it's scope (and potentially modifies stuff in the global scope?). `function` returns abc when it finishes running. Hope that helps. Good luck thinking through the problem.
How many significant figures are we talking? If it's few enough then the problem should be trivial if you know basic math.
It's just for 40 digits numbers not 39 or 41 and first number must entered as bigger than second one 
I get that it's a 40 digit number, but is it also 40 significant figures? 3*10^40 only has 1 significant figure so you could easily store it along with its exponent.
Given an `a` that is a power of 2, this returns `x` aligned to the next multiple of `a`. It is roughly equal to #define ALIGN(x, a) (((x) + (a) - 1) % (a))
Your program causes undefined behaviour by giving a `char` as argument for `%s` . If you didn't see a compiler warning for this then adjust your settings as you are missing out on important information
Thanks I think that I now understand. This is taking me way too long tough.
Will I did some research and it seems that Unity is the best framework I can select at this time.
While I respect the notion of making the code highly understandable in lieu of extensive documentation describing less-understandable code, my experience has been very mixed. There seems to be a certain brand of developer who has heard from Uncle Bob that "clean code needs no comments", and so they decide that since their code has no comments, it must be mighty clean. 
 &gt; heard from Uncle Bob Robert Martin said that?
nah, better use a null terminated ascii string formatted as a decimal integer so presentation and shooting it to a disk/down a network is easier. ;-)
Some think that he did. 
Look up Effective Modern CMake to learn about targets and compiling your program For a little more, this talk is pretty good too https://youtu.be/bsXLMQ6WgIk
Isn't his position clear? His [essays](https://blog.cleancoder.com/uncle-bob/2017/02/23/NecessaryComments.html) seem pretty overt.
Are there any stats as to what fraction of programs are strictly conforming, and what fraction rely upon features beyond those mandated by the Standard and either enabled via switches like `-fno-strict-aliasing` or by selecting a compiler like `icc` which can assume that unrelated objects of different types won't alias without ignoring visible relations that don't involve aliasing as written?
What's wrong with mallocs without frees in a one shot program? If it's gonna take hours and use a lot of memory, then sure, manage it properly. But for most files, it shouldn't take that much. 
&gt; UML is never a good idea *unless you work for a company that has built some application for a client whose outsourced technical compliance team requires you to submit intricate design documents detailing every little bit of data flow, across every logical and physical device, as well as across any systems-of-record that your application interactions with... and no one on your development team knows what the heck they're talking about so you have to learn to do all the UML yourself, despite the fact that you didn't build the damn thing and you're never going to get back those 2 years, 10 months and 20 days you spent at that job..... ... you know, hypothetically speaking, that would be an okay reason to learn UML.
How would you add/subtract them on paper by hand? Apply the same algorithm and make a program to do it for you.
The main reason is that it makes debugging harder as you create things that dangle. But, let's stop for a moment -- I'll agree, if everything you make you keep reachable until the end of the program, freeing everything before the exit isn't a huge deal. The bigger issue is that having all these heap allocations and drops speaks to a possible design flaw -- shouldn't there be a way to do this, especially in a recursive decent parser, without all of the seemingly haphazard dynamic allocations? 
You're right. An Arena allocator is perfect for things like thing
So you've got a couple of options. The most obvious way to approach this problem is to load the lines of the file into an array in memory, then pick a random element of that array. The array would need to be resized whenever it was "full", of course; you could use `realloc` for that. But if your only goal is to pick a random line from a file, you can actually be a bit smarter than this. Imagine your program could only remember _one_ line from the file. With this constraint it's still possible to randomly (and uniformly) sample the lines in the file. The trick is to read each line of the file one at a time, and probabilistically _replace_ the line your code has previously remembered. If the probability of replacing the remembered line is 1/n, where n is the line number (first line being 1, of course), then the line remembered _last_ will be randomly and uniformly sampled from the file.
Use `fegts()` to read the file line by line, instead of `fgetc()` which reads it character by character. If you already know the exact number of lines your file has, you can just do `rand() % number_of_lines` and stop once you've reach that line number. Otherwise you will have to count the lines first, which is as simple as going through all of the lines a first time, storing the result and then resetting the stream with `rewind()`.
Other have answered how to pick a random line. I'll point out one other way to pick a random word: First, first find size of the file using ftell. Next, pick a random spot, and fseek to that point. Then seek backwards to find a word break, and repeat for forward to find the other word break. This won't find all words equally, but rather have a better change of finding longer words than smaller words. (eg: "A very long word is supercalifragilisticexpialidocious." This algorithm is much more likely to find 'supercalifragilisticexpialidocious' than 'A')
He's saying infinite in lieu of "unlimited". And there's no way for a compiler to use infinite resources on a finite input -- which all programs would be. 
&gt; and probabilistically replace the line your code has previously saved This is called [reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling), in case anyone wanted to learn more about it.
These lines are just... weird. *(volatile uint32_t *) AUX_ENABLES = MINI_UART_ENABLE; Convention is to put the cast in the `#define`, such that `AUX_ENABLES` and other equivalent hardware registers can be treated like normal variables. Change your defines to this: #define AUX_ENABLES (*(volatile uint32_t *) (PR_BASE + 0x215004)) making your code to set the H/W reg look like this: AUX_ENABLES = MINI_UART_ENABLE;
I agree. These do look ugly, I was just unsure whether it's just me.
The heuristic that immediately tipped me off to something being wrong was the repetition. There's almost always something wrong if there's a ton of repetition.
 mini_uart_puts("It works!\r\n"); while ((*mini_uart.data_status &amp; MINI_UART_TX_EMPTY) == 0); Expand \\n to \\r\\n in putc instead ? Stealthy semicolon to another line ? :) I don't know raspberry, but some devices are "sluggish to act" after memory writes, is it okay to just \*p = value ? wr(addr, value) style macros could potentially save a lot of grief later. But you know better.
Have you tried reading the specifications of these protocols? I'm pretty sure they say how the packet length is encoded. It might also be part of the surrounding IP header, I'm not exactly sure.
Not sure what you’re doing but TCP is really a stream of characters rather than packets (it’s sent as packets but received as characters). Generally when you call the recv you get the number of characters received (in a high level language). On the sending side for TCP, you send characters and the stack decides when to send them. On UDP, when you send a packet, that’s what gets sent and the same applies — on the far end your call to get the packet also returns the length. If you’re using HDL to encode, Wikipedia has all the packet length in the header details.
TCP and UDP use packets. The word you are looking for is "datagrams". TCP is not a stream of characters. It is a stream of data in bytes.
Well technically they’re octets and not bytes. Byte length can differ between machines ;)
Every packet comes with a length field. Length can be different and the maximum size of a single packet you can send or receive depends on your interface configuration. Packets can also be fragmented into smaller chunks by routers on the way. 
I suspect that you believe that you’re trying to tell me something I don’t know. From where I sit, although there is only a pedantic difference in a character and a byte and the point of my comment is the same. The TCP beginner (not me) is often surprised that he has less programmatic control over TCP packet generation then he expects. This was my point. Source: I’m the CTO of an IoT company since before IoT was a thing and I’ve coded a substantial systems in C and Verilog that both generate and consume IP packets.
The size of a network byte is the same for all platforms. 
That’s because the protocol specifications explicitly define: octet An eight bit byte.
I sense much bitterness in you, young Padawan.
&gt; I suspect that you believe that you’re trying to tell me something I don’t know.
&gt; I suspect that you believe that you’re trying to tell me something I don’t know. [...] &gt; Source: I’m the CTO of an IoT company since before IoT was a thing and I’ve coded a substantial systems in C [...] As a CTO of an IoT company you should know that a character can be multibyte. As a C programmer you should know that `char` type is signed. 
As mentioned, you should check the standard (RFC) for each protocol. Each protocol will list each field in the packet, the length, etc. If you are looking at the hex of a packet then understanding the full packet is probably what you want. A list of RFCs is here: https://www.rfc-editor.org/rfc-index.html. However a better list is on Wikipedia as it lists by topic: https://en.m.wikipedia.org/wiki/List_of_RFCs Each protocol will have a different length of packet and may vary from packet to packet. You have to read the length field of the protocol. You can get the overall length by reading the length field of in the IP (either v4 or v6) header but if you want just the length of the, for example, the UDP portion you need to look at the length field (third octet) of the UDP header. See RFC 768 (https://tools.ietf.org/html/rfc768). ICMP will vary depending on the type of ICMP message, and its length is indicated in the IP header as it is part of the IP protocol. If you find the RFCs difficult to decode take a look at a graphical packet analyzer that highlights the different fields in the packet.
I was confused about why you would be so mean to someone trying to help someone out on Reddit. Then I looked at your history and I realized it’s just part of who you are. I mentor college kids in EE/CE/CS during their senior year to help them understand how what they’ve learned applies in the real world (because many universities are bad at this). I woke up this morning and thought I’d help someone out on Reddit when I saw the question with no answers. My wish for today is that you could reevaluate whether your actions help out the community (the Redditors we hope to serve here). 
I'm not mean. English is not my native language, so my posts may sound mean, but it is not my intention to offend anyone. There's a difference between packet and datagram. There's a difference between character and byte. I'm only adding precision to your answers, not saying you are wrong.
s is a string, so strlen must be used. That 4 is the size of a pointer (including strings) on your system. You don't need to check if the file exists, "a" will create it.
/r/cpp :) This is a C subreddit.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Thank you. I didn't know "a" would create a file if it doesn't exist, so that's also helpful to know.
An IPv4 header contains a 16-bit field for the total length of the IP datagram and a 4-bit field for the number of 32-bit words in the IP header (a normal IP header is 20 octets, but the interpretation of the 4-bit field allows an IP header to be up to 60 octets -- the octets beyond the first 20 are used for IP options). The length of a TCP segment, UDP datagram, or ICMP message is then the total length of the IP datagram minus the length of the IP header. Note that the above description assumes a non-fragmented IPv4 datagram. If the IPv4 datagram is fragmented, each fragment will have its own header length and its own total length, both lengths describing only that fragment. When the fragments are reassembled into the original IPv4 datagram, the reassembly module can calculate a new total length. The header length becomes that of the offset-0 fragment.
Great share - thanks - I’m also interested in this so thanks!
Can I quickly ask: what’s PIC? 
&gt; As a C programmer you should know that `char` type is signed. No, whether the *char* type is signed or not is up to the implementation: §6.2.5.15 The three types **char**, **signed char**, and **unsigned char** are collectively called the *character types*. The implementation shall define **char** to have the same range, representation, and behavior as either **signed char** or **unsigned char**. 
[https://en.wikipedia.org/wiki/PIC\_microcontrollers](https://en.wikipedia.org/wiki/PIC_microcontrollers)
**PIC microcontrollers** PIC (usually pronounced as "pick") is a family of microcontrollers made by Microchip Technology, derived from the PIC1650 originally developed by General Instrument's Microelectronics Division. The name PIC initially referred to Peripheral Interface Controller, then it was corrected as Programmable Intelligent Computer. The first parts of the family were available in 1976; by 2013 the company had shipped more than twelve billion individual parts, used in a wide variety of embedded systems. Early models of PIC had read-only memory (ROM) or field-programmable EPROM for program storage, some with provision for erasing memory. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Not a book nor a video, but maybe worth a peek. [https://github.com/AD7ZJ/PICAprs/tree/master/Software/src](https://github.com/AD7ZJ/PICAprs/tree/master/Software/src) 
I found it helpful. I'm trying to learn networking in C using sockets. Do you have any advice for learning http/https using sockets? (windows has schannel for https)
I found the Beej guides good when I used them years ago: https://beej.us/guide/bgnet/
👏🏻 👏🏻 CODE REVIEW
Did you try stepping thru it in a debugger? you can see what i, j, k and x are at every step.
You can format code on Reddit by adding four spaces before each line: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i,j , k, x=0; for ( i = 4; i&lt; 5; ++i) for (j = 2; j &lt; i;++j) { k = (i + j - 1); if (k % 2 == 0 ) x += k; else if (k % 5 == 0) x += k - 2; printf ( "\nx = %d\n",x) ; } } Like another poster suggested, you can step through this code with a debugger. If you do not know how, or would not like to, you can add print statements on various lines to see how the values of i, j, k and x change as the program runs.
Did you verify the contents of Array after fscanf? Something tells me &amp;Array[i] isn't doing what you want it to do. A copy will be updated, and not the actually Array. Try printing Array after fscanf and confirm its contents. Note, this is just a suggestion. I haven't debugged the code and confirmed it.
You're not resetting X to anything after it first becomes value 3, so on the next loop around j == 3 which means k = 4 + 3 - 1, or k == 6. Thus k % 2 == 0 again and X (which is currently 3 from the first loop) has 6 added to it. 3 + 6 = 9.
Where is the segfault happening? Have you used a debugger? When I run this code it's fine for me - apart from if the original numbers.txt file isn't open. I suggest adding a check to see if it's open before use: fp1 = fopen("numbers.txt", "r"); if(NULL == fp1){ fprintf(stderr, "File not open"); return EXIT_FAILURE; }
It would be easier for other people to read your code if it was properly formatted. Add 4 spaces to the beginning of each line and reddit will format it as code. Then make indentations for all blocks of code (things inside if statements, for loops, etc). Like this: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i,j , k, x=0; for ( i = 4; i&lt; 5; ++i) for (j = 2; j &lt; i;++j) { k = (i + j - 1); if (k % 2 == 0 ) x += k; else if (k % 5 == 0) x += k - 2; printf ( "\nx = %d\n",x) ; } } The first thing you'll want to do is make sure all code blocks include braces. There's a pair missing around the first ``for`` loop, and it's good practice to have them around all ``if`` and ``else`` statements, even if they're just one line.
Thanks for the suggestion, tried it and with the help of deftware's explanation it helped me understand :)
Thank you for clearing that up, I understand now :)
Hi,I've added 4 space before each line and it just stayed the same when i saved the post
Segmentation fault often leads when wrong file path is given. Hence make a check below the fopen wheather the pointer return NULL or not.
Youre welcome
Suggestion for code readability, indent by more than 1 space. I recommend at least 4.
Turns out you didnt
Go do your own homework.
`&amp;Array[I]` is correct here. It's equivalent to `Array + i`, but IMO more readable in situations like this.
You're probably not compiling with a version of the C standard that supports VLA's, which your code relies on. You probably want to change rowsums and columnsums to be dynamically allocated.
This code is aweful, I don't even wanna try to understand it 
A sanely-written Internet stack on almost any machine is going to store each octet in a separately-addressable storage unit. Although the specifications for functions like fread() and fwrite() would allow for them to operate on bytes which are not octets, when used with a TCP sockets it would be extremely weird for a system which uses anything other than 8-bit signed characters not to convert each received octet into a `char` value from 0 to 255.
What a load of stupidity you expressed before reading the rest of the sentence. Because those courses obviously consulted K&amp;R as it is a very good book to learn C, they give exercises that follow the spirit of K&amp;R on top of the modern programming practice developed over 30 years since its publication. I have written exactly that in the same sentence. Those courses give you the environment for learners to get started with programming, give you instruction to compile and complie with flags later. If you try to follow K&amp;R, you cannot even complie because the modern compiler does't complie K&amp;R code without specific flags. 
Open Google and type in `man strstr`. Alternatively `C string contains`
If your goal is to update your x variable with a new value at each cycle, you might just want to put "x = k;" and "x = k - 2;" instead.
Faster answer than reddit, and friendlier :) $ cc -g prog.c $ ./a.out Memory fault (core dumped) $ gdb a.out a.out.core (gdb) where #3 0x08048639 in main (argc=1, argv=0xbfbfe9d0) at prog.c:17 (gdb) list 17 sscanf(argv[1], "%d", &amp;i); (gdb) q
An easy one -- multi-dimensional arrays for math calculations.
`***` and beyond is rarely useful. There's a term for programmers that use them: [Three Star Programmer](http://wiki.c2.com/?ThreeStarProgrammer).
&gt; Just want to here some practical examples of when pointers to pointers should be used. Whenever they are needed. The most common case is a function that wants to return a pointer, but also some other datum. In such cases, you can pass a pointer to a pointer-typed object to the function which the function writes the object to. `strtol` uses this pattern for example. Triple pointers are rare. You are considered a [*three star programmer*](http://wiki.c2.com/?ThreeStarProgrammer) if you make frequent use of them. I don't remember a case where I used triple pointers, but these situations do appear every once in a while.
As u/LowB0b points out, the answer could be as simple as reading the whole file to memory, and running strstr over it mutliple times. &amp;#x200B; However, your tutor/TA is probably trying to tell you that you know the delimiters of the words to begin with. In that case, you're scanning character at a time, and creating a data structure for a list that you are then running a linear search over.
Also, you can look at some "real" code that uses these: &amp;#x200B; [https://files.ettus.com/manual/usrp\_8h.html](https://files.ettus.com/manual/usrp_8h.html) &amp;#x200B; This is an interface to a software-defined radio driver, and you can see the "handles" are actually pointers to structs. You then hand in pointers to handles to make and use those handles.
Fab thanks! I’ll do some googling! :) cheers!
Funny, 5 days ago, in a doodle concerning a post in here: char *ls[] = { "ls", NULL }; char *wc[] = { "wc", "-w", NULL }; char *tr[] = { "tr", "0-9", "a-z", NULL }; char **pipeline[] = { ls, wc, tr, NULL }; for (char ***cmd = pipeline; *cmd; ++cmd) ...
Dont be a three star programmer please. Pointer to pointers are very useful when you want to change the actual value of the pointer. If you just pass a pointer and not a pointer to pointer you would be changing the COPY of the pointer and not the pointer itself.
I don't think I've ever used `***` in real code. I can dream up some reasonable use cases, though. Like a ragged 2-D array of strings. Or a ragged array output parameter. Or an array of pointers as an output parameter. These are going to be rare. `**` is much more common, though. This could be a ragged array, an array of pointers, or a pointer to a pointer, and at least one of those will be used in non-trivial programs.
One other example -- int main(char **argv, int argc) Then, if you have a function that processes the args, you may need to pass in &amp;argv ...
Kind of the same idea as linked lists but trees are another example of long chains if pointers.
I dont know OP. You seem to be the trash for posting a "Do my homework post". Try harder. Do you even know what a function is or how to google their documentation to see what they do? 
Set total to zero Set grade counter to one While grade counter is less than or equal to ten Input the next grade Add the grade into the total Set the class average to the total divided by ten Print the class average. int total=0; for(int i=1; i&lt;=10; i++){ int grade; cin &gt;&gt; grade; total=total+grade; } int avg=total/10; cout &lt;&lt; avg; 
Cool. The first thing you should learn in college is that your instructors won't generally spoon-feed you information. I presume you have heard of these things made out of dead trees called "books". You'll be able to borrow them at your university library. They contain information that might help to decode those weird symbols. These days, there's also this thing called the "world wide web". Here's a link you can click that demonstrates how to use a popular search engine: [http://lmgtfy.com/?q=introduction+to+programming+in+C](http://lmgtfy.com/?q=introduction+to+programming+in+C) Seriously, especially in your discipline, you have to learn to learn on your own, because even if what they teach you is up-to-date (which given that you have to write an 60's-era flowchart, is evidence to the contrary), it will be out of date within months of graduating.
Use “cout &lt;&lt;“ instead of print 
Looks about right. How to proceed from here depends on what kind of “command line” you want to make.
Just something very simple, like getting the screen resolution with the command "screenres" etc..
If a UART is being used to talk to a printer or display terminal which processes code 0x0A as a line feed that does not home the cursor, having the output routine expand that to a 0x0D/0x0A sequence can be helpful. If it's going to be used for transmitting binary data, however, it's more useful to have it pass through data precisely as-is. The Unix convention seems to be to leave the expansion to lower levels of stream I/O, but on the embedded systems I've done which need both kinds of I/O my preference is to do such expansion in text-output formatting functions (I don't really like printf), or else manually include returns in text literals if there are only a few text strings.
Yes that is how you would do it. I would get rid of the do while and just make an infinite while loop and instead of wasting time with a `program_exit` I would just break out of the loop and therefore terminate the program. If you want to get serious you should use a Lexer so that your shell application can take arguments and act accordingly. 
alright. thanks. I'll use that.
You've got the right idea. You should `fflush(stdout)` before prompting for input. Otherwise the prompt might be buffered and the user won't see it. Some standard libraries do this for you, but not all of them do. What you've got is just a barebones command line. You (typically) won't have any history or editing support, unlike, say, your shell. The big library to help with this is libreadline, along with its various clones. Another option is to process raw input yourself. On unix this requires changing options on the psuedoterminal (pty), changing it from "cooked" to "raw." On Windows the equivalent is to interact directly with the console object.
Okay then. What I usually do is having an array of command names and function pointers for each command. The CLI loop finds the command in the array and calls the appropriate function. See [this file](https://github.com/fuzxxl/dobutsu/blob/master/dobutsu.c) for one example.
Thanks again, I'll look into the libreadline library. Also could explain a little further what `fflush(stdout)` does? 
LMAO as someone in a love/hate relationship with pointers, I love everything about this.
&gt; I did but I have no Idea how it's supposed to help me with the assignment. He is probably looking for you to try and place each entry in the file into a linked list and then check if the linked list contains the things that are required to be there.
something like a shell would have a complex grammar, where characters are read from stdin and accumulate as tokens, when one token's read it is processed according to the state of the reader, then the next one's read. '\n' for example would be an individual token, in the initial state it would evaluate the current commandline that's been processed so far, then prompt for another. however if a partial command has been read it would serve as whitespace separating two other tokens. so it depends upon how complicated you wish to make the syntax of your program. for processing whole lines of less than 254 characters, this is a straightforward way to do it. but for something more complex, this won't work so well and should look at other methods
Output file streams like `stdout` can be in one of three modes: fully buffered, line buffered, unbuffered. When fully buffered, the program doesn't send output to the operating system until enough has accumulated (the buffer is full). When line-buffered, the output buffer is flushed when you write a newline. When unbuffered, output is sent to the operating system immediately. Calling `fflush()` sends any buffered output to the operating system immediately. When standard output is attached to a terminal, it's typically fully buffered by default. When it's attached to a terminal, it's typically line buffered. Your prompt doesn't contain a newline, so nothing is (typically) actually output when that `printf()` returns. That prompt will be sitting in the buffer. Since this situation is pretty common, many standard library implementations will flush standard output before reading from standard input. However, this isn't required, and on some systems the user will not see a prompt since it will be stuck in the buffer.
You don't need to check for a null pointer. You're already implicitly doing so by only indexing argv up to argc-1 and not beyond. The uppercase version of an empty string is an empty string so your output is correct, IMO 
Thanks for the explanation!
Although the Microchip PIC 16C54 was a clear direct descendant of one of the 1970s GI parts, I think that's the only historical link between any modern PICs and the GI days. Every Microchip part since then seems to have clearer roots in the 16C54 than in GI parts. For example, to save address space, the GI parts with a 5-bit address space use the same address to write port pin latches and read port pin input states; those parts have no address to read the port latches. The data sheet I saw for a GI part with a 7-bit address space did add a separate address for reading port latches, but the Microchip PIC parts with 7-bit address space never included one. 
I just wanted to make sure if this was a good way to make a very very basic command line. Yea, for the more complex stuff this may not be such a good example.
First of all, you don't have to call `strlen()` for each iteration of the loop. Actually you don't need to know the length of the string at all. A string is terminated by a `0`, so instead of ``` for (i = 0; i &lt; strlen(str); i++) ``` you can do while (*str) { } which is the same as writing `while(str[0])` There are also already functions for [`islower()`](https://www.programiz.com/c-programming/library-function/ctype.h/islower) and [`toupper()`](https://www.programiz.com/c-programming/library-function/ctype.h/toupper). If you look at the `tolower()` function description you will find &gt; If c is a lowercase letter, toupper() returns its uppercase equivalent, if an uppercase representation exists in the current locale. Otherwise, it returns c. so you can just write char *toUpper(char *str) { char* start = str; // because you wanted to return the start of the string while (*str != 0) { *str = toupper(*str); ++str; // advance the string position } return start; } 
How do you even know that will work? This looks to be C, not C++.
&gt; lvl2 pointers Your "lvl2" pointers are not pointers. They are the integers themselves. &gt; with a large part of its memory cost being just the many pointers within pointers to hold the entire thing up How many dimensions are we talking here? That won't be an issue for most reasonable things you may want to do. &gt; Would there be a more efficient way of storing and retrieving these values? Yeah, not just in terms of memory usage, also speed. Something like this (untested): int* A = (int*)malloc(3 * 5 * sizeof(int)); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 5; j++) { A[i * 5 + j] = /* do whatever you want here */; } } You should probably use defines or variables for the 3 and the 5, though.
Assuming pointer size of 8 bytes, and machine word size of 4 bytes, as you've indicated, yes, the total allocation would be 84 bytes. &gt; Would there be a more efficient way of storing and retrieving these values? Does it need to be allocated on the heap (from malloc)? Assuming not, then yes e.g.: int A[3][5]; Which will allocate 3*5*sizeof(int) = 60 bytes total. If it does need to be from heap, then what you've done is one approach. To see others: https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/
&gt; When standard output is attached to a terminal, it's typically fully buffered by default. It is usually line-buffered.
Do you not have access to documentation?
Oops, yeah, that's what I meant. Thanks.
You can implement multidimensional arrays without using pointers to pointers: int *A = malloc(n * m * sizeof(int)); A[x * n + y] = 0; Now `A` is a 1D array, but we use it as a 2D array. It would be easier if you didn't need dynamic memory allocation, as doing `int A[n][m];` would have the same effect: a 1D array which can be indexed by two variables.
thanks! I was using an online compiler and turns out my text file was in the wrong folder haha
thank you! It turns out my file path was wrong haha
It is probably a school assignment to help students learn to read and understand code.
&gt; for ( i = 4; i&lt; 5; ++i) What the point of this instruction ? At this point let's do brainfuck &amp;#x200B;
It was the only \*\*\* I could find, is my only excuse.
You have a point.
Also, check fgets return.
you got 2 print out because the printf is in call 2 time because he is inside the second for that run 2 times
No. `strip_newline` is a reserved identifier and needlessly reinvents a more elegant wheel: `input[strcspn(input, "\n")] = '\0';` A potentially more serious problem is that you don't test `fgets()` for a NULL return. When prompted, the user can cause an immediate EOF condition, which results in `fgets()` returning NULL and no characters of `input[]` being changed. More than a little contrived: If your code were used as part of a restricted shell, perhaps in an embedded environment, and if you were unlucky enough to have `input[]`'s initially indeterminate characters consisting of no newlines or NULs, and if you have the presence of a NUL at some indefinite location in readable stack memory (such as a zero byte of a hidden `argc` -- note that a compiler will typically rearrange `program_exit` and `input[]` or use a register for `program_exit`, so the 0 bytes of `program_exit` are no savior), `printf("command: %s not found\n", input);` will leak information from the stack. This information may assist in defeating exploit mitigations (e.g., stack canaries, ASLR-relevant pointers) or it may be functionally sensitive (e.g., another buffer on the stack containing an admin password for entering admin mode).
I don't know if you're aware of this, but it's possible to implement choosing all lines with equal probability such that: - You only need a single pass through the file (which means it would word with `stdin`) - You only need enough buffer to store one line I don't want to give any spoilers, but it's been floating around as an interview question so you should be able to google it if it eludes you. Though, it's hard for me to imagine anyone actually coming up with it under interview conditions. As far as your code - You could refactor you file opening/closing into main and pass your various function a `FILE *` instead of filename. - You might want to handle the case of a bad file name more descriptively - e.g. "unable to open file: %s". - You might consider looking into using a standard argument parser (e.g. getopt_long) so that you conform to all the UNIX conventions. - You have calls to exit scattered all over the place. For debugging purposes it's nice to have them only in one, or maybe two places (e.g. after testing the validity of the args and then one at the end). I.e. your various function could return an error code to main. 
&gt; You might want to handle the case of a bad file name more descriptively - e.g. "unable to open file: %s". Here is how `cat` does it. % cat foo cat: foo: No such file or directory Replace `die_with_error` with `err` and that is almost trivial. 
An assorted set of issues: * replace `die_with_error` with `err(3)`. * Line 91: Why do you cast to int? * Line 110: Don't allocate space for just one bookmark; the overhead is huge. Allocate for 100 at least. * Line 110: Also check if the malloc failed. * Line 120: I like to grow my buffers by 1.5. * Line 144+: Please don't mix variable declaration and initialisation of different variables on the same line. * Line 219: Don't use a switch-statement if you don't make use of the "fall-through feature". * It would be nice if your tool would work on multiple files.
&gt; If you try to follow K&amp;R, you cannot even complie because the modern compiler does't complie K&amp;R code without specific flags. What? It may have been a while back, but I don't recall having to use any specific flags to compile K&amp;R code. Are you talking about the 2nd edition?
IMHO the opening and freopening is unnecessary complicated, I'd just use stdin if "-" was given, and never fclose, but use rewind as many times as necessary. But maybe I didn't catch something that requires freopen.
You are using uninitialized `i` at line 366: `if (cmdlen &lt;= sizeof commands[i].command)` 
Nope. The operand of `sizeof` is not evaluated.
I was playing with this too to store a table, see \[here\]([https://github.com/div0man/hnb-app/blob/master/src/jstab.c#L32](https://github.com/div0man/hnb-app/blob/master/src/jstab.c#L32)). You can allocate storage for all those pointers in a single block to avoid multiple calls to \`malloc\` but that comes with a caveat that you can't easily grow/shrink your array as the entire block must be freed.
I was playing with this too, to store a table, see [here](https://github.com/div0man/hnb-app/blob/master/src/jstab.c#L32). You can allocate storage for all those pointers in a single block to avoid multiple calls to `malloc` but that comes with a caveat that you can't easily grow/shrink your array as the entire block must be freed.
If you have a program that can render one frame given one input, then a trivial way to do it twice as fast would be to copy half of the inputs to a second machine. Then have each do half of the total work, then combine the frames at the end. This is a simple version of parallel processing, and is less related to C than to the OS that allows you to copy and distribute the work. 
I would agree with all of those but a couple -- the switch statement in particular. Using a switch to handle a bunch of cases is efficient and very readable. I do my best to avoid anything but trivial fall-throughs. Handling multiple files is hard because there's no natural definition of what that means. 
Lack of a filename should make it stdin. That then allows it to run on no file, which should produce no output, which is valid. 
look into povray. Fairly easy ( at least it was twenty years ago ) to render blocks of render lines across machines and then re-combine later. see http://hof.povray.org/images/pebbles.jpg
Hm.. Could you please explain what this check actually does?
i'm a learning project so i dont gonna use any external tools other than library of c.
"don't gonna" ? Okay .. you had better start with basic physics and some low level tcp communications reading such as Stevens "TCP/IP Illustrated Volume 1" and you will need English for this. 
outch "you will need English for this." english is not my native laguage and i just woke up but this hurt XD. Thx for the ressource, i will look into it.
sizeof is evaluated at compile time except for variable length arrays. This check throws out overly long commands and allows me to potentially not NUL-terminate the command strings in the array.
I'm not a computer scientist and don't know the interview question, but it's fairly easy to figure out (under non-interview conditions). Spoiler: [This is the identity you'll need to use to prove it works.](https://www.wolframalpha.com/input/?i=1%2Fm+*+product+x%3Dm%2B1+to+n+(1-1%2Fx)). 
Stevens is essential texts as well as UNP == UNIX Network Programming Also English .. sure ... I figured you were not a native but don't worry about it because computers love C as a language and opcodes below that and micro-code below that and then signal traffic below that and then ... turtles all the way down.
Your use of `tmpnam(3)` as an entropy source is pretty clever. I wondered how effective it might be, so I did a survey of some standard library implementations. ## glibc and musl Both get a high resolution timestamp and generate the filename directly from the timestamp (no hashing, etc.). glibc does a very poor job of also mixing `getpid(2)` into the timestamp before using it, and it's probably making it worse. This is a higher resolution clock than you can normally get in standard C, so this *is* a sneaky way to get a little more entropy from the standard library! ## dietlibc Calls `rand()`, so you're not getting anything at all out of it. This is actually (yet another) bug in dietlibc, since the standard library is not allowed to mutate the random state in this function. ## libiberty Generated from `getpid(2)` alone, with a counter to handle multiple calls. Not very useful. ## BSD libc / Bionic (Android) Actually gathers real entropy from the operating system (e.g. `arc4random(2)`), which means you're getting a lot of mileage out of this one. However, there's a very minor bug in that it immediately terminates the program if the entropy system call fails. IMHO, instead this function should either use a fallback or return an error (return NULL). --- I would have liked to look at this since it's one of the major implementations in use, but I couldn't find any information about how theirs works. When `tmpname(3)` generates from a high resolution clock, using `time(3)` doesn't really get you much, but it also doesn't hurt. However, if you *are* going to use it, you should do [a better job hashing/mixing it with your `tmpnam(3)` hash](http://www.pcg-random.org/posts/developing-a-seed_seq-alternative.html). You don't have much entropy here, so make the most of it. Other portable sources of entropy: * Try to open and read from `/dev/urandom`. If it fails to open or read, trying was harmless and you just don't get anything from it. * Cast the address of a function in your program (e.g. `main()`) to an integer and mix it into your entropy pool. Depending on how it was compiled, there might be some ASLR entropy in the address. Do the same with a libc function since those would be different ASLR bits. * Allocate a big chunk of memory with `malloc(3)` and get its address. Usually this memory is allocated at a random location. The reason for using a big allocation rather than small is some implementation (i.e. glibc) make small allocations using `brk(2)`, which won't get you any new entropy outside of ASLR. * Mix a stack address (local variable address) into your entropy pool. This will gather some entropy from any random stack gap. 
Note that `err(3)` is a BSD extension, and OP is explicitly avoiding functions not found in the standard library.
Sorry, missed that. 👍
How long of a project are you looking for? If you're going to develop the renderer from scratch, this could take quite a while. If you're really interested in parallel computation as your learning focus, I'd try something more like pulling a renderer from somewhere else open source (maybe blender would be a good place to start) and focusing on writing the scheduler. Depending on what your cluster HW arch is (basic heterogeneous machines on a LAN, maybe a Beowulf type, or maybe just one machine with a single socket cpu and a gpu or two), your starting point for parallelization will be different. Also what's the main OS target? If we're talking a heterogeneous LAN structure, I'd recommend brushing up with OpenMPI to start. If it's one machine with shared memory across cores/sockets, you might be better served by spawning threads yourself. Of course, if GPUs are involved, you'll want to take a look at either CUDA or OpenCL.
The render is already half done, the machine is gonna be iMacs. Cluster HW ? 
HW = hardware. You mentioned a cluster in your original post, and I took that to mean "more than one machine working together." You're planning to do this on a single iMac? In that case, you'll probably be most interested in POSIX threads (I *think* OS X is POSIX compliant due to its BSD heritage, but I'm not 100% on that) and/or IPC (Inter-process Communication). Shared memory between processes and threads makes the parallelization implementation simpler than the other alternatives, but of course limits your effective scalability in comparison.
&gt; I tried using an array of pointers but it gives back segmentation fault If you paste your code then we can tell you why it's segfaulting. Help us to help you.
typedef struct phones { char brand\[10\] ; int price; int amount; } PHONES; int main(int argc, char \*argv\[\]) { FILE \*fin; int ch; int i; phones \*phonep\[20\]; fin = fopen(argv\[1\],"r"); &amp;#x200B; for(i=0; i&lt;20; ++i){ fscanf(fin, "%s %d %d", &amp;phonep\[i\]-&gt;brand,phonep\[i\]-&gt;price,&amp;phonep\[i\]-&gt;amount); } &amp;#x200B;
you never allocate memory for your struct elements.
How do I do that? 
You either create an array of structs phones phonep[20]; // notice the missing * or allocate memory for the elements with malloc and assing that to the pointer.
\`PHONES \*phonesp = malloc(100 sizeof (PHONES))\` Like this?
Correction, he states that he doesn't want it to be a black-box autogenerated one, such as ones from lex and yacc.
Something like that. As a rule of thumb, every time you write a malloc() somewhere, you should also write a corresponding free(). And malloc() returns a void*, which you should check for NULL (the call can fail), and cast to the right type.
I've edited the code above but it still gives out segmentation fault &amp;#x200B;
Can you post the whole code and input data on something like pastebin / github ?
&amp;#x200B; [https://pastebin.com/ZnYTFFy1](https://pastebin.com/ZnYTFFy1)
What do you have so far? What have you done to think through the assignment? What's your general thinking for the steps you'll need to do to accomplish the overall goal? Put in the smallest bit of legwork, and we'll help.
 *strstr(input, "stop") = '\0'; (Error handling was left as an exercise for the reader.)
One way you could go about doing it is looping though while adding the chars to a new c-string until you see the char ‘s’. If the word connected to this ‘s’ turns out to be ‘stop’ then you stop the loop.
After correcting the typos in the code ( why would you post code that doesn't compile?) and giving it a suitable input file, it works. Check your input file, I think you go over the 10 characters for brand ( don't forget about the '\0')
Well I obviously should get some sleep apparently it was working after 5 comments ago I just wasn't inserting the file Thanks a lot and I'm sorry for wasting your time &amp;#x200B;
Just one more thing how do I check if it reaches the end of file? So it doesnt create empty structs &amp;#x200B;
Was this answer helpful? 
To answer your question technically correct (the best kind of correct), with feof(). To answer what you probably wanted to ask, you need to check the return value for fscanf. It returns how many read elements could be correctly matched and might set the eof flag.
Thanks dude!
I plan to use multiple imacs on the same network
Make sure you understand what that code is doing and why.
For that interview question you mentioned, couldn't you just &gt;! generate a random number in the range of lines in the file then loop through the file and print the line when the index reaches the number? !&lt; Maybe I'm missing something though. 
Please do not delete your posts after receiving answers.
No, in this way you have to perform 2 "passes" on the file: one for knowing the total number of lines, another one to go to the random generated index and print the line. This will not work for streams.
ITS CALLED MALLOC.
It might, it does. We are not here to do your homework. 
Since it seems you already have gotten some help with your code, can I just point out there are about a thousand other tools out there that would be far better suited for this task? Both `awk` and `perl` immediately come to mind...
It wasn't about you doing my homework, I do that by myself. My query was about me struggling with that sequence after having already finished a console application, just seeking some help from people that have more knowledge and experience than I do.
Yeah, my bad about the lvl2 pointers, was originally posting the example with `int***`, but changed halfways for simplifity. As for your example of a better memory usage allocation, I quite like the idea. I can't allocate the whole thing upfront because I only know the number of elements on each level as I go deeper, but I guess I can just go realloc'ing as needed. Thanks!
You did not post what you had tried and where you were having issues with the code that attempted to do it so I don't think you really struggled.
Thanks for the confirmation! You mentioned the 8 bytes on the stack for A (which I really forgot to take into consideration). If I were to, instead, do an `int* A[3]`, and allocate each of the array elements with the space for 5 ints, would that have a memory footprint of 60 bytes on the heap (4B/int * 15), plus 24 bytes on the stack (8B/elem * 3)? Alas, yes, I need it in the heap, as I only know the total size during runtime. Thanks for the website, though!
Yes, as I answered in other comments, I need it in the heap because I don't know the full size of it during compile time. I'll try implementing my data this way, thanks for the tip!
You never adjust the value of the loan with the payment. 
Thanks for the code example! I'll try implementing something along these lines. Yes, growing/shrinking might be a problem, I wonder how much multiple calls to realloc would affect performance (considering it not being able to allocate contiguous memory blocks). It's still worth trying, as doing pointers of pointers of pointers would be too expensive for me, memory-wise.
That is not how loans work not interest applied to amortization payments. However you may be using flat interest rate ( in University? ) only. You should check if the interest is applied monthly or not as you solution is entirely wrong if you are doing any payment schedule.
Points to a twitter account advertising a video game humble bundle?
Deceptive spammer tried to be deceptive. Here's a direct link to the Humble Book Bundle without having to jump through hoops, injecting this user's referral code: https://www.humblebundle.com/books/hacking-for-the-holidays-books
r/C*_programming
Do not spam.
I'm also storing pointers, but wanted to save on number of syscalls. If you want to save memory, others here have suggested a good way - put it all in a blob, and you only need one pointer - to the beginning of blob, and then you access parts of it using pointer arithmetic.
Yes, that looks right. And in fact, that is example #2 on the site I listed. One other thing: C can dynamically allocate from the stack, as long as the allocation is static for the lifetime of the function. In fact, that example #2 does this (uses 'r' for the size of the array). You do need to be somewhat careful if the sizes can get large, since you can overflow the stack. I'm not sure it's a really great idea to do it with something like you're showing, but just thought I'd mention it.
As a side note: In non-educational software, never use fixed-precision floating point numbers for money or money-related numbers. Use an arbitrary-precision number library instead.
Thanks, I've fixed that now! But no the value of the loan isn't being refreshed for each run through the loop. So for each calculation of the salary, they're all being subtracted cumulatively from one loan. Any ideas? &amp;#x200B; `while ((loan &gt; 0.0) &amp;&amp; (month &lt;= 359))` `{` `month++;` `loan = loan + (loan * (rate / 12));` `for (salary = 25000; salary &lt;= 41000; salary = salary + 2000) {` `loan = loan;` `thresholdsalary = salary - 25000;` `monthlysalary = salary / 12;` `payment = ((salary - 25000) * 0.09) / 12; /* 25000 is the threshold salary */` `loan = loan - payment;` `printf("\nWhen salary is: %f\n", salary);` `printf("Monthly payments = %f\n", payment);` `printf("In month %d the sum remaining is %f \n", month, loan);` `}`
Yes, the result seems to be stored in sumleft. 
i changed sumleft to loan. This stopped it increasing but now I'm having the problem above
I'd think of the "key" identity as (1/(n-1))(1-(1/n)) = 1/n. I don't see a need for an iterated product. 
Thank you so much! I appreciate your comment.
Thanks!!
Thank you. I agree.
Thank you for a valuable advice!
You could also program in Rust if you wanted that.
Rust is aids.
I am not familiar with Rust, but if it's a project that motivates you then go for it. With that said, you are really appealing to the wrong crowd. People that want stuff in their programming language usually don't stick with C.
C++'s `std::unique_ptr` kinda implements a rust-like ownership model. The main difference is that the compiler doesn't prevent use-after-move (though clang-tidy does have a check for this problem), but overall it's a very similar concept. And in my experience, it's wonderful. Responsibility for a resource is well-known and self-documenting. The compiler keeps you from doing something stupid. As with all fancy features like this, there's absolutely nothing preventing you from writing similar code in C right now. I already do, actually. But you have to be diligent and careful yourself, instead of relying on the compiler to catch your mistakes. And so, what you're really talking about is implementing some sort of compiler-checked enforcement of the idiom. I can get behind that. It has to be opt-in (use an attribute or pragma to declare unique ownership), and you'll need to think carefully about how you move ownership (is it implicit like Rust, or explicit like C++?), and how you handle memory cleanup (is it automatic, or do enforce manual cleanup?), and more. This won't be an easy project, but I'd be interested in seeing the results.
I haven't worked through your solution in any depth, but this part waves red flags: &gt; ... &lt;&lt; (bit_start_pos - number_bits) It is possible for `bit_start_pos` to be less than `number_bits`, and shifting by a negative value yields undefined behaviour.
I thought about that, but the different results were with the following arguments: unsigned int x = 9713; unsigned int y = 3500; unsigned z = Set\_Bits(x, 11, 4, y);
While Microsoft's C standard library isn't 'open source', (most of) its source code is available. It's basically libiberty but a bit more complex.
I guess my point was that there's no point in fixing your code until it's clear that it _can't_ inokve UB, since the solution will need to be completely changed to avoid UB anyway.
&gt; It's possible to implement choosing all lines with equal probability [in one pass] That's pretty amazing! I see some hints in the comments below and will think about them. So in essence I can remove my via_bookmarks and via_expmarks and leave only via_fseek and the new via_fancypants methods? The former is faster, and best used for streams that a) can seek b) can hold the file size in the long type and c) can tolerate nonuniform probability of picking lines. &gt; You could refactor you file opening/closing into main and pass your various function a FILE * instead of filename. The methods do use different modes -- via_fseek is "rb", and the others are "r". So I couldn't just open it in a uniform way then pass the FILE* in. &gt; You might want to handle the case of a bad file name more descriptively - e.g. "unable to open file: %s". Because the filename is being passed to perror, it is prepended to a descriptive message. An example error message would be: `fakefile: No such file or directory`. &gt; You might consider looking into using a standard argument parser Is that available from the standard library, or does it require pulling in POSIX? My goal for this project was to be as portable as possible. &gt; You have calls to exit scattered all over the place. For debugging purposes ... your various function could return an error code to main Good idea.
Quick and dirty with stolen code from stack overflow to make things print, but I'm not sure it's working as you think https://onlinegdb.com/ryoQahHeE 00000000111111110000000011111111 10100101101001011010010110100101 swap from 12 to 11... 00000000111111110000000011111111 01001010111110110000000011111111 
&gt; Here is how cat does it. My program actually does it similarly. Because the filename is being passed to perror, it is prepended to a descriptive message. An example error message would be: `fakefile: No such file or directory` &gt; Replace die_with_error with err That appears to come from err.h -- I don't think it's available in the C standard library, is it?
&gt; I wondered how effective it might be, so I did a survey of some standard library implementations. Thanks for doing the research, that was very interesting! &gt; you should do a better job hashing/mixing [time()] with your tmpnam(3) hash That's an in-depth article. Can you summarize a good replacement for simply adding the two values together as I am currently doing? &gt; Other portable sources of entropy: [address of main/array/stack] Is it undefined behavior to cast a pointer to integer? I know that some historical architectures used weird values as pointers. &gt; Typically rand(3) is complete garbage and shouldn't be used Very good to know! I'll use xorshift.
That's a good idea. I see that cat, grep etc treat no filename as stdin, so I can blend in. Seems they also treat "-" that way. Perhaps I should support both?
Well via_fseek requires a stream opened with "rb" and the other via_* functions require "r" but then again via_fseek is going to fail on stdin anyway. I should probably have main pass a FILE* rather than a filename to these functions, as suggested by someone else in this thread.
I'll work on that, thanks for the help. Just as a last question, would you mind to explain what would be a expected result if you try to swap 11 bits from X with 13 bits from Y?
Replying to myself... looks like the article suggests the following function to mix values together for a seed: ``` uint32_t mix(uint32_t x, uint32_t y) { uint32_t result = 0xca01f9dd*x - 0x4973f715*y; result ^= result &gt;&gt; 16; return result; }; ``` 
&gt; Line 91: Why do you cast to int? Wow, I super screwed up that's why. :) I think I was thinking "let's make this integral rather than floating point" but it obviously limits the values even further. &gt; Line 110: Don't allocate space for just one bookmark; the overhead is huge. Allocate for 100 at least. Good point, starting at size one guarantees we'll have to resize, so I'll start bigger and skip those first resizes. &gt; Line 110: Also check if the malloc failed. Good catch. Is there a warning or linter I can enable to catch that kind of stuff? In general it's on me to be careful, but just checking... &gt; Line 120: I like to grow my buffers by 1.5. Any rationale for this? &gt; Line 144+: Please don't mix variable declaration and initialisation of different variables on the same line. Would you say it would have been OK if I had been initializing them all, rather than some and not others? &gt; It would be nice if your tool would work on multiple files. Like I could say `randln filea fileb filec` and it would then choose a) which of the files to print from and b) which line in that file? What if fileb has only one line but the other two are big files? Does that single line have a greater likelihood of being picked than lines in the other files? &gt; randln.c:(.text+0x15): warning: the use of tmpnam' is dangerous, better usemkstemp' I use it for generating srand entropy rather than to create a temporary file, so that particular warning shouldn't apply to me. Annoying that people who build the project will see the warning though and get worried about the quality of the code. Maybe there's a way to disable this warning? &gt; to enable reproducibility make the user able to supply a seed That's a very good idea. I would have liked that myself earlier when debugging.
Replying to myself yet again. The C99 standard says in section 6.3.2.3: &gt; Any pointer type may be converted to an integer type. Except as previously specified, the result is implementation-defined. If the result cannot be represented in the integer type, the behavior is undefined. The result need not be in the range of values of any integer type. Worried that &amp;main might not be able to be represented as integer type on some platform and then we hit UB.
So the question as you've stated it is a little ambiguous. First, you haven't defined a _numbering_ for the bits. I'm going to assume that bit 0 is the least-significant bit, since that makes the mathematics slightly easier. Second, it's not clear whether that range P to P + N should be _inclusive_ of P + N or _exclusive_. I'll assume that it's exclusive. You've got: 111111 54321098 76543210 ------------------------- x = ... 00110101 11110001 ^^^^ y = ... 00001101 10101100 ^^^^ ------------------------- z = ... 01100101 11110001 I've marked the sequences of bits to be replaced in `x` as well as the corresponding sequence of `y` with which to replace them. `z` shows the resulting value. With these interpretations, I make `z` out to be 26097.
&gt; Can you summarize a good replacement for simply adding the two values &gt; together as I am currently doing? Use an integer hash function. An integer hash function is a 1:1 mapping between integers of some particular size. uint32_t hash32(uint32_t); uint32_t combine2(uint32_t a, uint32_t b) { return hash32(hash32(a) ^ b); } This will prevent changes in one from canceling out changes in the other, and you'll get nice avalanche effects. If you really want to go all the way, use two different hash functions. I'm a big fan of SplitMix-style integer hash functions, and I've [spent some real effort discovering highly effective constants](https://nullprogram.com/blog/2018/07/31/). There are a whole bunch of them here in the README here (and, IMHO, these are the best value — in terms of quality per cycle — 32-bit integer hash functions ever published): https://github.com/skeeto/hash-prospector If you need a 64-bit integer hash instead, there are [a couple here](https://gist.github.com/degski/6e2069d6035ae04d5d6f64981c995ec2) as well as Splittable64/SplitMix64: uint64_t splittable64(uint64_t x) { x ^= x &gt;&gt; 30; x *= UINT64_C(0xbf58476d1ce4e5b9); x ^= x &gt;&gt; 27; x *= UINT64_C(0x94d049bb133111eb); x ^= x &gt;&gt; 31; return x; } &gt; Is it undefined behavior to cast a pointer to integer? It's implementation defined: you can't rely on any particular meaning of the value of the integer (e.g. you can't technically use this to align a pointer). If you use `intptr_t` or `uintptr_t` you can safely go back and forth between integer and pointer so long as you use the same integer value. Fortunately for this use — as an entropy source — the limitations don't matter at all. 
Yup, this works well, too.
&gt; &gt; Is it undefined behavior to cast a pointer to integer? &gt; It's implementation defined: you can't rely on any particular meaning of the value of the integer As you point out in your interesting article about hashing pointers, the C99 standard §6.3.2.3¶6 also mentions, "If the result cannot be represented in the integer type, the behavior is undefined." That's the part that scares me. Also I'm writing in C89 so I don't believe I have access to uintptr_t. What if I loop over the `sizeof(int (*)(int, char**))` bytes in &amp;main and hash them as a string with djb2 like I'm doing with tmpnam? Does UB lurk in this approach? Would I lose entropy by calling my `mix` function (or your `combine2`) repeatedly to combine the hashed address of main(), the hashed value of tmpnam, and time(NULL) into a final value?
&gt; Would I lose entropy by [...] If your PRNG state is smaller than the total entropy you're gathering, definitely yes. But it doesn't matter in that case since you have more than you need. On the other hand, you don't want to "spill" any if you're gathering less entropy than your PRNG state. Every seed bit should depend on every bit of entropy. Using my `combine2()` repeatedly with different inputs risks spilling since it's a compression function. You'd be compressing your entropy (2 \* 32 bits in, 32 bits out) before mixing in new entropy, and it would act like a funnel, limiting the total number of possible states you can reach. If you have more than two inputs, build a mixer like the one shown in that fancy diagram in the article I had originally linked. &gt; Does UB lurk in this approach? If you want to get *really* technical about it, [function pointers aren't necessarily compatible with object pointers](http://c-faq.com/ptrs/generic.html) (imagine a Harvard architecture). Though, unlike invalid pointer-to-integer casts, I can't find any language in the standard that says trying to cast a function pointer to an object pointer is invalid undefined behavior. So I think that approach is reasonable if you're worried about the integer cast. POSIX *does* require that function pointer and object pointers are interchangeable (e.g. for `dlsym(3)`), and the C standard lists this explicitly as a common extension (A.6.5.7): &gt; A pointer to an object or to void may be cast to a pointer to a &gt; function, allowing data to be invoked as a function. A pointer to a &gt; function may be cast to a pointer to an object or to void, allowing a &gt; function to be inspected or modified (for example, by a debugger). 
Start with `char *string = "hello";` instead of `char string = "hello";` then realize that no value is pushed onto the stack. You declared a string literal which is stored on read only memory and therefore can't be modified. Realloc will fail because of that. Why don't you just try to compile it to find out what happens instead of just guessing. Its 2018 and you can even find online compilers. [https://www.onlinegdb.com/online\_c\_compiler](https://www.onlinegdb.com/online_c_compiler)
Too many files for my brain.
I think the prototype for realloc is : void *realloc(void *ptr, size_t size); However even if you do char *str = "hello"; void *foo = realloc(str0, sizeof(str0) + 1); You are going to get a massive SIGSEGV 
Go go gadget arbitrary Google! http://www.cs.columbia.edu/~sedwards/classes/2013/4840/reports/RCS.pdf
Hmm, that's true that you can't convert a function pointer to an object pointer because of weird machines like the Unisys 2200 or chips with a Harvard architecture. However a pointer-to-a-function-pointer is a data pointer, isn't it? We could walk the bytes of the value in the function pointer: ``` #include &lt;stdio.h&gt; int main(void) { int (*p)(void) = &amp;main; char *bytes = (char*)&amp;p; size_t i; for (i = 0; i &lt; sizeof(p); i++) printf("%x\t", bytes[i]); printf("\n"); } ``` Does this make sense or have I tangled myself into next-level knots?
Conceptually you are close. The main disconnect is that memory is not reallocated to the heap when a stack frame is left. It remains part of the stack (just unused) From a practical point of view the stack is just a large array allocated when your program loads. 
You only allocate the size for the pointer in the new section. The literal lives somewhere else and isn't copied over, just the address of which is assigned to \`string\`. When you realloc, you're changing the address to newly allocd memory, which isn't freed afterwards. 
rb and r are \_pain\_ :) Another 'std method' would have been if (strcmp(filename, "-") == 0) filename = "stdin"; /* just for nice error messages */ else if (freopen(filename, "r", stdin) == NULL) syserr(filename); &amp;#x200B;
Its stored as a string literal on read only memory. You can't call realloc on it because the pointer you pass has to be previously allocated. Therefore behavior is undefined. Sizeof will return the size of a pointer which is 8 bytes in 64 bit architecture and 4 bytes in 32 bit. You need to use strlen. It won't work anyways. &amp;#x200B;
\** Rubik's 
&gt; Good catch. Is there a warning or linter I can enable to catch that kind of stuff? Clang/LLVM comes with a static analyser called *scan-build* that catches this. &gt; Like I could say `randln filea fileb filec` and it would then choose a) … Don't overthink it. Just print a random line from each file. If the user wanted a different functionality they could do `cat filea fileb filec | randln`. Think of `head`. I just prints the first ten lines of each file it's given; not the first ten lines of just the first file + if that has to few lines some of the second and so on. &gt; That's a very good idea. I would have liked that myself earlier when debugging. It is also a requirement for derandomised unit tests and reproducible science.
Line 2 (y &amp; ~(ALL_32_BITS_ACTIVATED &lt;&lt; number_bits)) &lt;&lt; (bit_start_pos - number_bits) This sets `n` rightmost bits in `y` to 1, and then shifts them to start at `p`, where `p` is a 1-based index. Other solutions use 0-based index so there's a mismatch there. For 0-based index, you need: (y &amp; ~(ALL_32_BITS_ACTIVATED &lt;&lt; number_bits)) &lt;&lt; (bit_start_pos - number_bits + 1) Obviously the user needs to make sure that he's not trying to get more bits than possible, otherwise you'll be trying to shift with negative numbers, which is undefined. Also, when solving this myself I discovered that shifting with MAX_BITS is also [undefined](https://stackoverflow.com/questions/53783259/right-shift-inconsistent-behavior-when-shifting-for-type-width-related-to-kr-e), and all the solutions out there didn't catch that (except [mine](https://github.com/div0man/knr_2nd_edition_exercises/tree/master/Chapter%202/Exercise%202-06), hah :D). In your case `p=31` `n=32` would fail as it would attempt to shift for 32. To avoid that, a hacky way to do it is to take the 1 out: (y &amp; ~(ALL_32_BITS_ACTIVATED &lt;&lt; (number_bits-1) &lt;&lt; 1)) &lt;&lt; (bit_start_pos - number_bits + 1) so now we'd shift for 31 which is OK, and then for 1 more, which is OK, 2 operations having the effect of shifting ALL the bits. Line 3 &amp; 4 (x &amp; ~(ALL_32_BITS_ACTIVATED &gt;&gt; (MAX_BITS - bit_start_pos))) | (x &amp; ~(ALL_32_BITS_ACTIVATED &lt;&lt; (bit_start_pos - number_bits))) I see the intention is that the line 3 clears all bits left of `p`, and line 4 clears all bits right of `p+n-1` so when you OR them, you get `x` with the target bits cleared. However, there's the issue with 1-based index. Corrected: (x &amp; ~(ALL_32_BITS_ACTIVATED &gt;&gt; (MAX_BITS - bit_start_pos - 1))) | (x &amp; ~(ALL_32_BITS_ACTIVATED &lt;&lt; (bit_start_pos - number_bits + 1))) 
Looks like a cool project! Just a few things that I noticed at a glance (Most pretty nitpicky, take all with grain of salt since I can see this was just a school project and not production code) : * Some code is commented with too much granularity and some code is not commented at all. A good rule of thumb is that comments should describe why you are doing something not what you are doing (since that is in the code!). Of course there are exceptions to this where complicated things require comments. * Some functions seem like they could be broken up more. I saw some functions that had too high of an indent level to be easily digestible and some that were just on the verge of being too long. This also will help with reducing the need to comment. If a function only does one thing, and it is named acceptably, then it is self-commenting in a way. * Strcmp is one of the only string functions that you don't *need* to use the "n" version of since you are reading and you stop when you get to a null in either string. By using strncmp in your code (especially with string literals) you are introducing the possibility for bugs via an incorrect size param. If you really want to use the n version though I believe you should be able to do something like this: `strncmp(str_to_cmp, "Hello", sizeof("Hello"))` which is slightly less prone to errors although verbose. p.s. it is dumb that prof made you implement standard utility functions in a 400 level class... I feel your pain.
This sort of thing is my area of research! However, I don't know any library for this purpose. Every program seems to have its own implementation.
 \`loan = loan;\` ???
Oh, yeah, you're completely right. I was thinking about it all wrong. That should be perfectly valid, except that you should use `unsigned char` to avoid reading negative-valued bytes.
So tell us more about this "Linux dantooine"... Also you are uploading object files into the project, probably not what you wanted.. I once got a bit of the 32v kernel running in userspace, although it was borderline useless, but it was cool watching it print messages to the console...
&gt; a new stack frame is created by the {} No. &gt; string is newly initialised and gets pushed on to the stack with the value "hello" (and '\0') No. &gt; string is removed from the stack and reallocated on the heap with one more byte reserved No. &gt; stack pointers are reset to what they were before and string is freed from the heap No. Sorry to pick on you, but I've been arguing that beginners shouldn't be told about the stack because it only leads to misconceptions and misunderstandings, and this is a perfect example. Forget that you ever heard about “the stack”. There is no such concept in the C language as defined by the standard, even if most C implementations use something that resembles a stack but actually isn't. In programming language theory terms, what C has is a set of activation records. Since C does not have coroutines, closures, or anything similar, and activation records are strictly last-in-first-out, it can use a linked list or a stack to organize them, but you don't know that, and you don't *need* to know that either. But back to your question. What happens, according to the standard, is that: #. Your dog dies, your house burns down, and you receive a letter from the IRS notifying you that you are going to be audited. OK, if we pretend that your program doesn't invoke undefined behavior by passing a value to `realloc()` that is not the result of a `malloc()`, `calloc()` or `realloc()` call, what actually happens is: #. Absolutely nothing. OK, if we pretend that the “as-is” rule does not exist and that the compiler has to produce code that does exactly what you say, even if you wouldn't be able to tell the difference if it chose a more efficient way of achieving the same result, and look at what a compiler might do with all but the simplest optimizations turned off, what actually happens is: #. An “array of static storage duration and length just sufficient to contain the sequence” is created somewhere in memory and initialized to `{ 'h', 'e', 'l','l', 'o', 0 }`. #. The address of that sequence may or may not be stored temporarily in memory or in a register. It is usually known at compile time, or at link time at the latest, so probably not. #. During each loop iteration, `realloc()` is called with that address as its first argument and the size of a pointer plus one (typically either 3, 5, or 9) as its second. #. Depending on how `realloc()` is implemented, the program may either do nothing at all, or it may crash, or it may do something in between, including possibly overwriting other data or even code. 
&gt; You are going to get a massive SIGSEGV Well, no, because that code won't compile since you haven't declared or defined `str0`.
Umm. Yes, that is how loans work and interest is applied, or close enough. It's mathematically incorrect, which is why effective APR != nominal APR, but it's how banks do it, because that's how they've always done it, because they've been around much longer than computers, and calculating twelfth roots by hand is really, really hard. Plus, it makes no difference as long as your payment each period exceeds the interest that has accrued during that period.
Your program tries to simulate multiple scenarios simultaneously, so you need to track them separately, using an array with one element per salary “bucket” in your simulation (nine in total). A much easier solution would be to simulate each scenario separately, one after the other, and reset `loan` to its initial value before each simulation.
Tangent from this, had you instead while (1) { char string\[\] = "hello";
I'm sorry, I only thought about the question being ambiguous after turning the PC off. And I did commit a mistake when posting the algorithm, its from P to P - N, being inclusive. Thanks for your time and efforts.
Thanks for the thoroughly explanation. Now I can understand.
“Linux dantooine” is just a server name, nothing special 
It's from a galaxy far far away. I don't think you'd understand.