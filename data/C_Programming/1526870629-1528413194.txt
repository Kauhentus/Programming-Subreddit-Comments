ty for tip, already edited
Linked lists are a great data structure, but they have their limitations. Speed of access is one of them. If you want to access the 10th item in the list you have to start at the beginning item and count up to 10 along the list. This is slow. You can't fix the speed of accessing random elements in the list, but that new data structure will allow you to make some other improvements to performance. Start thinking about how you might use the 'end' member to help you improve the speed of some of the functions you need to rewrite.
I realise I dont need an array for the series, I made it to check the values that are smaller than the one you type in
Like using \*end in additem to add it directly to the end of the list instead of using the while loop?
Cool. Inline functions, done the ~~hard way~~ insane way.
Thanks for not dismissing the /u/tufflax's question out of hand... I think a lot of others are a bit defensive because the question mentioned garbage collection :-/. To expand a bit on your answer: If you call a function to say, "Please give me a heap-allocated thing," it's almost always your responsibility to either free it or call some more complicated deallocation function. Exceptions tend to be things like "Please create a big thing in your big pool of things," like "I fired my gun, give me a pointer to the new projectile" -- in that case the projectile will be deallocated by someone else for sure, because the caller knows nothing about it's lifecycle. "Ownership" is a great logical system to work in that maps pretty well to memory management, but I don't know off-hand whether C programmers talk about it as much as C++ or Rust programmers do, because it isn't as much "a part of the language." Clearly, though, "pure" functions can't "own" anything, which has two implications: - Anything heap allocated they return must be deallocated by someone else, and - Anything heap allocated they do *not* return must be freed before they return.
The thing thats confusing me is that each node of the list will have a head and end node.
Yeah, this new structure introduces a new way of representing the list. There are 2 different concepts here - the list as a whole, and an individual item in the list. Previously the list as a whole was represented as a pointer to the first item in the list. Therefore, the list as a whole was represented as the same _type_ as the items (Node *) in the list. But now you have a different structure to represent the list as a whole, and you can store extra data in this structure such as a pointer to the last item in the list. You can add more data in to this new structure if you want (there are further optimisations you can make by storing some extra data, but that is an exercise for later). The items in the list still have exactly the same format as before - they contain just a pointer to the 'next' item in the list. Look at the change you made to the typedef again. You can see how the old typedef made 'List' to be the same as 'Node *'. But after your change 'List' is now a completely new structure that didn't exist before. Node is still there, unchanged.
&gt; Use malloc() when you need memory. Use free() when you are absolutely done with it. This really assumes you own (and grok) all parts of the codebase. This tends to be truer more often for C programmers because they're relatively more leery of external dependencies, but the general case is "I am going to interact with code I do not know, and I need to reason about what it is going to do." Take a function like `strerror`. Does it `malloc` returned strings like `"Unknown error XXX"`? It doesn't -- you are not supposed to free them. This behaviour ("Do/don't free that pointer yourself") is an important part of a C function's API, and should somehow be made clear. [Documentation](http://man7.org/linux/man-pages/man3/strerror.3.html) can serve that purpose, as can programming conventions. Maybe after a while you build an intuition for how/when a `free` *should* happen in a reasonable API or codebase, but it is absolutely not trivial for new C programmers, and your condescending attitude here is really embarrassing.
Roughly speaking, "How to manage memory" is a question that is equivalent to "How to program a computer." When you think about the problem generally, it applies equally in C as in Java or any other language. In Java, you are asking what data belongs in which classes, what object lifetimes and lifecycles are expected, what data gets persisted to disk, and how, and who cleans it up off the disk. And the data that you send over the network, do you need to retain it? In C, you are looking at the same sorts of problems, with a somewhat lower level perspective. "What goes where?" and "Who cleans up after it?" are pretty much universal questions that fundamental to the design of any sort of computer program. The fact that you need to malloc and free some pointers really isn't a dramatic paradigm shift if you zoom out of the problem far enough to think about it generally.
LIST \*head \*end |Item/next\-\&gt;|Item/next\-\&gt;|Item/next\-\&gt;| |:-|:-|:-| |film title and rating|film title and rating|film title and rating| Is this a correct representation?
Yes. It might just be the formatting looks weird but of course you need to maintain 'end' so it always points to the end of the list.
You are very close, missing just one more statement I think. Pay close attention to 'end'. 
new code. seems to work correctly. // list.c -- functions supporting list operations #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "chapter17pe2list.h" static void CopyToNode(Item item, Node *pnode); void InitializeList(List *plist) { (*plist).head = NULL; (*plist).end = NULL; } bool ListIsEmpty(const List *plist) { if ((*plist).head == NULL) return true; else return false; } bool ListIsFull(const List *plist) { Node *pt; bool full; pt = (Node *) malloc(sizeof(Node)); if (pt == NULL) full = true; else full = false; free(pt); return full; } unsigned int ListItemCount(const List *plist) { unsigned int count = 0; Node *pnode = plist-&gt;head; while (pnode != NULL) { ++count; pnode = pnode-&gt;next; } return count; } bool AddItem(Item item, List *plist) { Node *pnew; pnew = (Node *) malloc(sizeof(Node)); if (pnew == NULL) return false; CopyToNode(item, pnew); pnew-&gt;next = NULL; if ((*plist).head == NULL) { plist-&gt;head = pnew; plist-&gt;end = pnew; } else plist-&gt;end-&gt;next = pnew; return true; } void Traverse(const List *plist, void (* pfun)(Item item)) { Node *pnode = (*plist).head; while (pnode != NULL) { (*pfun)(pnode-&gt;item); pnode = pnode-&gt;next; } } void EmptyTheList(List *plist) { Node *psave; while ((*plist).head != NULL) { psave = (*plist).head-&gt;next; free((*plist).head); (*plist).head = psave; } } static void CopyToNode(Item item, Node *pnode) { pnode-&gt;item = item; }
 if (plist-&gt;head == NULL) { plist-&gt;head = pnew; plist-&gt;end = pnew; } else { plist-&gt;end-&gt;next = pnew; plist-&gt;end = pnew; } is that what I needed?
Yep, that's it, should be good now.
thanks for your help. Do you work as a programmer?
Maybe the problem is the format string used to print numbers. There are some differences between Windows and Linux... Now I see it, the `for` loop doesn't initialize `i`. You can't assume an untouched variable is zero initialized, and probably wasn't on the other platform. If the function got called more than once there may or may not be junk data on the stack as well... It would be easier to do like this: #include &lt;stdio.h&gt; long fib(long upper_bound) { long a, b, tmp; a = 0L; b = 1L; tmp = a + b; while(b &lt; upper_bound) { printf("%ld", b); if(tmp &lt; upper_bound) printf(", "); else printf("\n"); a = b; b = tmp; tmp = a + b; } return a; } /* the original program ran an interactive session with a variety of math functions */ #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { long n; argc--; argv++; // skip program name while (argc) { n = atol(argv[0]); fib(n); argc--; argv++; } return 0; }
That's true up to a point, but unfortunately I don't think it reduces the need for documentation. For starters, you certainly shouldn't infer anything from the mere fact that you are being returned a pointer, because this could be returning a string constant, or a reference to a statically-allocated variable within the function, or a global variable. For example, consider standard library functions like getenv, strerror, asctime and ctime. Even if you know for certain that the object is heap-allocated, and leaving aside the exceptions you mentioned, that doesn't necessarily mean that it is OK for the caller to deallocate it using free(): there could be sub-objects or other resources which need to be deallocated, or it could itself need to be unlinked from some other data structure. So, yes, these are good hints for working out what might be going on in someone else's poorly documented API, but I'd urge caution in jumping to conclusions, and in your own code it is better to document any changes of ownership. 
&gt; essentially consists entirely of calls to subroutines. so use function pointers, really, really no reason to use goto... unless you want difficult to follow spaghetti code...
They probably did that to seek the last node of list quickly, perhaps to append items to the end instead of prepend itens to beginning. The header file has no append routines so that feature went unused.
First of all I work with embedded systems, usually with fairly serious resource constraints. At the moment I do a lot of low power microprocessor development which is a style of programming which is quite different from a lot of the markets out there. I say this just to say that my answer will come from that perspective. In my opinion books and formal education are fine, but there is no substitute for actual experience. I think 95% of what I do on a daily basis I learnt on the job. I say my degree got me my first job and that's it. Personally I am more interested in the thought process of a candidate not the education. Many people with impressive looking CVs are actually clueless, and many 16 year olds are far better than me or anyone else I know. So I am not impressed or unimpressed with a degree, but I will pay attention if someone turns up saying they are self taught with a small portfolio to show off and asks good questions. However, this is a point of disagreement between me and some of the people I work with, unfortunately one of those people is my boss, and he does the hiring.
I'd recommend picking up a copy of game engine architecture. It's written by a couple of developers at Naughty Dog and explains AAA game engine concepts in depth, including memory management techniques. It's C++ focused but all the concepts apply to C equally well. It's the best book on game engine programming I've seen, since it comes from experienced professionals not a random person writing a book about how to make space invaders.
I think what madsci was getting at is this is not the appropriate subreddit for this post. 
Remember the old `GOTO 380 + 20 * (OPT=1) + 50*(OPT=2) + 120*(OPT=3) + `....
thanks.
goto is peak performance, you might not like it but it's true
I’ve seen code with a single goto take more than 50% longer to run than the structured equivalent. Some compilers really don’t care to optimize such code and some processors were far more sensitive to that lack of optimization.
I initialized the i in 0 now and still its not working on linux
IDK how complex the systems you're trying to buld are, but I personally just create a Type_Init and Type_Deinit function in each module, then when I'm actually using the modules I'll call either of those when I need to create or delete a type. it's not as complex as you're making it seem.
If you're just learning C you should know that depending on what you're doing its quite possibly you'll never need to mess with heap allocated memory at all. Actually, a video game would be a perfect example of something that *doesn't* require memory management, as a video game is nothing more than a state machine with millions of states but all states are the same size. It would be silly to incur the cost of dealing with the heap in something like a video game when you can just make sure that there's enough memory to hold the player inventory, the map, all of the items, etc. If you change characters you do it by moving the pointer pointing to the current character to another character. And things like textures and sounds that have variable sizes you just make sure enough memory is statically allocated to hold the most that would be required.
Thank u!
That adds a level of indirection and extra overhead and the potential of stack overflows and basically defeats the purpose of writing threaded code with gotos to computed labels (Unless you goto a function pointer like in OP's code in a coroutine-like fashion). For a practical example, consider the ocaml bytecode interpreter. Normally the opcode field of a bytecode instruction is just an index that's used with a big switch. But when using gcc-style compared gotos, it adds a pass that replaces the opcode with the address of the label that implements that particular instruction. Dispatching the next instruction is just a goto, without the overhead of a switch. The resulting assembly is way cleaner, and more efficient than without.
Nope, I'm replacing the standard library, I'm not calling any of the printf family of functions in any of my code.
So you don't call into the libc at all? How are you doing system calls then? Are you sure that all people who want to use your library can make sure the same thing for all the code in their programs and all libraries they use in their programs?
What happens if we do like int a = 0; int b = (a++, a++, a++, a++, a++, a); b would be 5. The most important thing in comma operator is that comma is a sequence point. I think all C programmers should know about sequence point. You can get all about sequence points in C standard document. *welcome to correct if I made a mistake*
All great points, thanks for being more concrete than I could.
Some code I worked on (long, long ago) used computed gotos to avoid the overhead of function calls. In this case, the functions were called an ungodly number of times and without computed gotos, there would simply have been no product - it'd be way too slow. 
the TLDR is in assignment; only the last element is assigned
okay call me fussy - but I'm not too sure that this helps with readability... 
LD_PRELOAD to the rescue. You can intercept libc calls and do amazing things. I used it to improve IO throughout over NFS.
Right; the C language does just fine at disabling buffering. The article has nothing (directly) to do with the language.
Interesting! I think it would be a good addition indeed.
&gt; Hmm. I'm not sure I agree. That's fair. As-stated, my philosophy that all things are memory allocation is probably a pretty extreme opinion. That said, I think it's still a useful metaphor/philosophy to think about. &gt; Say you have a database with information on disk. Databases don't generally say to other parts of the program "oh just go look at this address on the disk" Well, the filesystem implementation certainly deals with all of that stuff, deciding on addresses very much like malloc, so it's not like you've gotten away from the problem -- just built a layer of abstraction on it. Then the database itself needs to keep track of which files have the data in them, and using a config file to decide where to keep your data files is conceptually the same question as, "where does malloc get to put the data structures that are needed to make malloc function?" Once the database is up and running, it hands out row ID's in response to SELECT queries, and then you've got exactly that an application "doesn't know if it's safe to move or delete that data" because if you delete a row when something else has that row's ID cached, everything might go to hell. You still need to think at least a little bit about ownership of row ID's and their lifetime in the way that you would worry about pointer addresses. I still think that thinking in general terms about data/object ownership and lifetime is important to think about regardless of the specific technical context. And that kind of thought process helps inform the way you think about the code you write to handle malloc and free. 
I think it's really difficult to give blanket statements about memory management. It really depends on the program you're trying to create and what constraints it has. In some cases it makes sense to just gather all the memory at the beginning and then free it right before calling return. In other cases, you may need an unknown number of large complicated data structures that have to be allocated on the fly and (if memory is at a premium) need to be freed when no longer in use to save overall memory. In other cases, you might need some parts to stay allocated and just get re-initialized since allocating and freeing can have performance impacts, especially when doing it in a loop. So, with each "thing" that needs memory, you have to ask yourself when is it needed, how long does it have to stay allocated, and what are the constraints affecting it. The design of your program will make a difference. It might be pretty easy in some cases. You have a module that handles widgets, it can create one and it can destroy it on command. You have a module that does something with widgets, it presumably knows when it needs one and when it doesn't need one any more. Your widget module might allocate memory per-widget, it might allocate enough for some large maximum number of widgets, or it might allocate enough for a certain number of them and allocate a larger chunk when needed. The widget-using module probably shouldn't care how it's done. Other times things will be much more complex and you'll have to come up with some sort of scheme to handle it that is specific to the program.
look how admirable someone has put together a tool that could be used by someone creating a script kiddie toolkit....
These sorts of tools are essential for security hardening though. 
&gt; Mariusz Ceier pointed out that there is an ancient bug report in glibc suggesting essentially the same environment variable mechanism that I suggested and that was adopted in NetBSD. The suggestion was firmly and summarily rejected. (“Hell, no … this is a terrible idea.”) Of *course* it was Ulrich who said that.
Talking about a suggested improvement to a very popular standard C library implementation is not appropriate?
Yes, it's very rarely used. Sometimes I'll do something like this: for (ptr=start, i=0; i &lt; len; ++ptr, ++i) { … } but other than that, I avoid the comma operator.
Lines of text do not have fixed lengths. Generally, you would recreate the whole file from scratch to delete some records in it. It's the easiest way of doing things.
ssh/telnet bruters are all over the internet as well as the malware used to control them. It’s all on GitHub. OP is not really hurting anyone. 
&gt; `movl $0, %eax` &gt; After some light googling it looks like this is the assembly funcition to push main’s return value onto the stack, but I can’t seem to get the inline assembly to actually work. So for now I’ll say that is isn’t very feasible to use this at all, and other compilers don’t even support it. EAX is the 32-bit form of the accumulator register, which isn’t on the stack. Return values that fit are stored in it; otherwise RAX if it’s available; otherwise EDX:EAX or RDX:RAX. Larger than that, the compiler would have to prepare a buffer above the argument area on the stack and pass in a secret pointer to it. Arguments are passed *in* on the stack, if there are more than fit in the ABI-designated registers. Your technique is fun to play with—in that moment, you were euphoric—but jumping between functions is totally unusable in anything other than toy code. The compiler can do whatever it wants with the stack outside of your scrutiny. It might stash some data there even if no locals are defined, it might alter the stack or frame pointers, etc. Since you jumped into the function, it’ll be fine(-ish) setting up its own stack frame, but it’ll be doing it without the calling (er, jumping-into) function having prepared for its stack/regs to be taken over, and this could lead to chaos. Globals might not get stored properly, cleanup from inlined calls might not work, any ABI-specified stuff that *must* be there at call time could be broken. (E.g., for linux-i386 ABI, if this were in one of your functions: register unsigned x __asm__("ebx"); __asm__("cpuid" : "=r"(x) : "a"(0) : "ecx", "edx"); then EBX might well not have been restored before you jump away, causing a call to `printf` to wander off into a SIGSEGV. Anyway, if you turn on optimization the compiler should reduce your calls-only `main` to the following (decompiled): int main(void) { puts("In main"); puts("In printer"); main(); return 0; } which drops it to a single call site—still CALL because the separate `return` statement has to clear EAX before returning. With a slight change to enable TCO— int printer(void) { puts("In printer"); return main(); } int main(void) { puts("In main"); return printer(); } —the compiler will optimize it down to int main(void) { for(;;) { puts("In main"); puts("In printer"); } __builtin_unreachable(); } which is just a single jump. You might be able to get something similar with `_Noreturn` or `__attribute__((__noreturn__))` funcs, or by throwing `for(;;) __builtin_unreachable();` after a call. Or you go the other way and simulate function calls with `goto`s: #define ENTERABLE(depth) \ register unsigned enter__sp = 0; \ const void *enter__stack[(depth)] #define enter(label)do {\ __label__ __next; \ assert(enter__sp &lt; sizeof(enter__stack) / sizeof(enter__stack[0])); \ enter__stack[enter__sp++] = &amp;&amp;__next; \ goto label; \ __next: (void)0; \ }while(0) #define leave__BODY \ assert(enter__sp); \ goto *enter__stack[--enter__sp]; #define leave__ERHALT for(;;) __builtin_unreachable(); #define leave \ for(;; (__extension__({leave__ERHALT}))) {leave__BODY} #define entry(label) \ for(; 0; (__extension__({\ leave__BODY leave__ERHALT\ }))) \ label: ENTERABLE(4); int param; param = 0; enter(thing); param = 1; enter(thing); return; entry(thing) { printf("%d\n", param); leave; }
Thank you for the informed reply. I was only intending this to be toy code, as I though it was interesting. I was compiling with \-O0 turned on. Enlightening answer, you've given me some things to look at further!
Hmm. I wonder if there's any continuation libraries for C? Or if one of the C++ ones could be converted without too much pain? That's the way to go for jumping between functions. Or write everything in continuation-passing-style with a compiler that can do tail call optimization, but that's a royal pain to do manually. Better left to tools that do it for you, like the chicken scheme to C compiler.
Yup. This kind of stuff is utterly dependent on the calling convention (and the compiler's whims). By the time you're this deep into it, it's probably time to think about writing the function in assembly.
This is for online password brute forcing, not offline. A GPU wouldn't help.
yes...that's why I mentioned it's a single threaded application. I will again change the code to support multithreading (as soon as I know how multithreading works in C). It's also next on my to-do list for this project. So if anyone wants to contribute, please.
I've done a fair bit of multithreading in C, might have a shot at this! Looks like a great project.
Yes, there are co-routine libraries in C, but most of them depend on setjmp+longjmp being implemented in a certain way (because the standard does not say anything about what happens when jou jump _down_ the stack), and to be 'safe', they often allocate a lot of extra space on the stack to be able to treat the stack as multiple stacks (one per coroutine).
It definitely has impact. For instance in lines like: ``` int* foo, bar, baz; ``` only `foo` actually becomes a pointer to an int, `bar` and `baz` are simple ints. This is why: - some people prefer to write the pointer-star always next to the variable-name, rather than next to the type-name. - usage of comma's (either as separator or as operator) should be limited to a minimum. The main use comma's have is to function as separator between arguments in a function. Other than that, only @capilot's suggested usage (compound loop initialization) makes sense; other things quickly become unreadable. 
Please don't post these.
http://roar11.com/2016/01/a-platform-independent-thread-pool-using-c14/ It's C++, not C but I guess you could learn the concepts and mechanisms from this tutorial. Then you coule replace the C++ only tools by C equivalents. By the way, https://github.com/mbrossard/threadpool is not a tutorial but it's only two files and the code is quite self-explanatory. Good luck !
I wonder what's the purpose of something like this. I mean, the main hurdle and also the first protection is the "disconnection after 5 attempted logins", so the *practical* use of this thing looks nonexistan since every worth target would disconnect, I'm not promoting hacking people and stuff, but... I'f at least you would bruteforce your way into a file in your own pc, at least you could give as many tries as you like, but for online sites, the very existence of the project puzzles me. ¿Is this academic, for-fun or something? I'm lost.
I love C for its simplicity and dislike C\+\+ STL for opposite \- I'm trying to change and learning in practice some modern CPP at the moment. What i would find perfect would be type safe C and some minor upgrades of things that are annoying \(enum elements treated as global defines, etc.\). C18 where are you? :\)
As @hdgdtegdb already mentioned, this type of tools can be used for security hardening. And this is mostly a fun project. Being a security consultant, there are many internal servers where Fail2ban is disabled. So i won't say SSH brute force and Dictionary attack is completely useless. Thank you for your comment. 
Can someone explain ELI5 why GOTO is never used? And what the hell is happening in that link
So you were defeated within seconds of starting by a typo?
Generally when working on game engines in C, I'll set things up with an ECS. Typically an interface with a central factory that will create entities and components. Each subsystem will register a call back that handles allocations and deletions of the component types they manage. This call back returns a handle that everything else uses. Internal to the systems, it's up to them how they manage memory. Typically if it's a system like graphics where most entities will have this component, I'll generally use a massive dynamic array to store everything in. For something more sparse, a hashtable, or for something really rare, a linked list or a static array. To make sure resources are manageable on a component level, there are callbacks for them that get called when entities are added or removed from the scene. This is where it's resources are managed (if they have any at all). Generally components are just data though.
Story of my life
Popen
I'm not sure parsing "top" output to get into is the best/easiest way to get info you need, but look into using popen() with the -b and -n 1 options.
What would you recommend? Im still very new to C and am open to any suggestions!
No POSIX function exists, but POSIX [specifies](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ps.html) `ps` for this purpose.
**tl;dr**: you need to provide more information, and express better what you already know, what you've considered, etc. to make it clear that you've invested some time/thought into the problem. I think you will need to provide more information. Some inferences could be made, but it would be more reliable of you provide more context. In addition, you might want to consider your answers to these questions: (1) "What information is in the Graph ADT?", (2) "Why does the Graph ADT have that information and not more?" If the answer to the first question is "I don't know yet", then perhaps you need to design the Graph ADT first. Also, you might have better results from /r/C_Homework, although I understand that sub is less active. 
Hi there. Before even answering your question there are a couple things I want to clarify. &gt; adjacency array of linked lists The linked lists that you mentioned are fundamentally part of the contruct you were referring to, which which is an **adjacency list**. Neither just the array or just the linked list would let you get the information you need to about the connections in your graph. Thinking about them separately can lead to undue confusion. &gt; BFS is a recursive algorithm That isnt exactly true either. BFS is just an algorithm that describes how you would traverse a graph. It can be implemented both non recursively or recursively. Both methods have their advantages and drawbacks. It seems like you were taught the recursive version which is **totally fine**. Just keep in mind that algorithms are not (usually) inherently tied to their implementation, and usually can be implemented several different ways. So onto your question &gt; im confused on how to get the source vertex when the only variable in my helper function is the Graph ADT The source vertex would be whatever node BFS was called on prior to your current recursive call. Let's think a little bit about how BFS is going to run. You're going to initially call it on a node in your graph, and the BFS will get called on each of the initial nodes neighbors, then each of the neighbor's neighbor's so on and so forth. **The key insight that you need to make is that as you make each recursive call on a neighboring node, you also know what the corresponding source node is** Unless you're homework put restrictions on how you should implement the getSource function, you can save and subsequently return the source node however you like.
People like you are the reason I disable password login and only use keys. Still, solid project, great work, keep us updated as you add more features.
Hahaha :P you really shouldn't use only password login...use combination of both...
You usually have a list of arrays that keeps track of the nodes you went through. When you reach the end of a tree you go back up by popping a nice from that list. For breadth first search, you pop a node from a first item in the list while pop a node from the last item in the list. When you keep track of modes, you append a node. So if you take a node from the last item, you will be going back to the node that is very close to the node you have just reached. If you take the first node in the list, you are going back to the node you have visited a while ago. That's the intuition. 
You still get key attacks, don’t you? Really pisses me off. Fail2ban could be made leaner, now. Amyone putting it on a diet? I’d be interested. C, bais, were gointo have to,do, it bais! 
Hm... Adapting `STDBUF` from NetBSD could turn out to be a good idea. On the other hand, this feature could be a huge security issue: if you execute a setuid root program with `STDBUF=4G` you cause a privileged program to waste 4 GB of RAM, potentially enabling some nasty denial of service attacks. Another issue is that quite a few programs make implicit assumptions about the way buffering is configured and few people have really tested their programs with non-standard buffering configurations. Since this feature would act before `main` is called, there isn't really any escape hatch you can use to get around the new behaviour, making this even less attractive. Perhaps this behaviour could be gated behind a standard library function (e.g. a new flag `_IOABF` (A for auto) for `setvbuf` and making `setvbuf` affect all open files if called with `NULL` as its first argument) or similar.
Oh yeah, and both GNU and FreeBSD have `stdbuf(1)` to deal with this issue.
Shouldn't the first example result in stack corruption? It's writing size of pointer to a char...
[sshguard](https://www.sshguard.net/) is written in C and functions similarly to fail2ban. I'm confused why people assume I take no further precautions when I mention disabling password authentication.
This looks pretty neat. Granted, if I wanted more than C \(in this style\) I would probably use Rust.
Keep in mind that existence of tools like this isn't why people get hacked. People get hacked because they choose to ignore security vulnerabilities, or they're unaware. The tools that exploit unknown vulnerabilities (i.e. zero day attacks) are a serious problem. Security research, like this, is essential in protecting against these kinds of attacks.
You can adding specific features all you want, but what would get me excited would be allowing the programmer to extend the language himself, Lisp-style.
Did you make sure your program is compiled as 64-bit?
Can you show us the allocation code?
Are you nesting for loops? C only supports 127 nested for loops I believe (it may support more but that's an implementation detail).
I... What? In one function? 
I get the feeling he created an array of the nodes he wanted to add on the stack
I think you might have missed the term 'nested' based on your comment? https://msdn.microsoft.com/en-us/library/dcda4f64.aspx I do not think it is a big deal, I have never come across it outside Ackermanns Function, and it can/should be avoided by refactoring. It's any blocks, not just for loops. Can also happen with fewer for loops and nested if else blocks.
Did you check for memory leaks in your program?
To expand on this a bit: a 32 bit program can only address (i.e. use) up to 4GB of memory (at maximum. Other factors can decrease this). A 64 bit program can address up to 16.8 million terrabytes of memory. So you may need to ensure your program is being compiled in 64 bit mode in order to make use of that extra memory.
This sub is for C only. C is not object-oriented, unlike C++, C# and Objective C.
As well as needing a 64 bit program, padding will make that char 4 bytes the pointers will be 8 bytes
That's most definitely not the reason. No modern C compiler has this limit, it's a concession to very simplistic compilers.
Please show us your code. There are a few things that could have gone wrong, the most likely thing is that you used an `int` instead of a `size_t` for your array index. This matches your problem description exactly.
Please don't blog spam.
C doesn't have classes.
I think not, for he says his 128M structs occupied 2Gb, so 16 bytes per struct, so most likely 4 x 32-bit fields (int, padded char, pointer, pointer). That would mean his pointers were 32-bit.
It depends on compilers and compiler settings, but the default stack size is generally much lower than his 2 Gb, rather in the vicinity of a couple of Mb. So it *probably* would have crashed much sooner if it was the case.
To expand a tiny bit on this expansion: A 32-bit program can address 4GB of memory; a normal 32-bit program on a normal 32-bit operating system can only use 2GB of that address space for its own purposes, which is consistent with what is being described here.
Ouch
Jesus christ who has 127 nested for loops that would be insane
I made no such assumption, :) To be clear, I’m just voicing my annoyance that people still keep knocking on my door.
&gt; if I wanted more than C (in this style) I would probably use Rust. No, you'd use D.
Oof
Good points... if promotion rules didn't exist and if this was 30 years ago and prior. The best reason against it is that it would break backwards compatibility big time, most likely resulting in not a single relevant project developed in C in the world would use it.
No I wouldn't because of D's runtime, GC and lack of portability.
Oh with your formatting it's obvious, on mobile it looked like OP was taking the address of a char and filling it with a pointer.
My stack
I thought so too (and it's true of gcc and clang) but the Visual Studio compiler gives this error for "just" 200 nested for loops fatal error C1061: compiler limit: blocks nested too deeply Here's my test code and the compilation failure: [https://godbolt.org/g/aEgSg3](https://godbolt.org/g/aEgSg3).
I did say *modern* compiler.
1) This is C++ code, but you've posted in a C Programming subreddit. Try /r/cpp_questions. 2) You're printing `sizeof(int_msg)` values. Try printing out that size, I don't think it's what you think it is.
Hey, I think you're looking for r/cpp_questions. This subreddit is about the C programming language. 
The size of probably returns “8”. Try doing sizeof(int_msg)/sizeof(int)
i
I realize it’s 32 bits now. I’ll switch to 64 to see if the problem resolve.
As others have pointed out, your problem is here: for(int i=0;i&lt;sizeof(int_msg);i++){ `sizeof` returns the size in bytes, not the number of elements in the array. If you have a C++17 compiler, you can use [`std::size`](http://en.cppreference.com/w/cpp/iterator/size) instead, which will give you what you want. There's also [`std::extent`](http://en.cppreference.com/w/cpp/types/extent) if you only have C++11, but it's less easy to use, so I sometimes just write an equivalent to `std::size` myself (it's easy, see the first link). You can also use `sizeof(int_msg)/sizeof(*int_msg)` or a variant like others have suggested, which is the more C-like way of doing this. Also, you can use a ranged-based for loop: for ( int value : int_msg ) ss &lt;&lt; value; And, for the especially ambitious, you can use [`std::copy`](http://en.cppreference.com/w/cpp/algorithm/copy) with `std::ostream_iterator` instead of writing a loop.
Many scripting languages with a syntax based on C \(like Java, PHP and similar\) lack the comma operator, which is why some people coming from these languages find it confusing and think it decreases readability. But this not really a reason to avoid it.
Thanks all for the comments. I'll be sure to post in the correct subreddit next time!
You just made a buffer overflow. Also, it's undefined behavior anyway, so that is what you expirence. In real life, it overwrites some memory after the array, potentially corrupting variables and so on. You were just lucky that it didn't crash. By the way, the array `char array[4]` can store 4 characters, but a string also has the terminator character `'\0'`, which is implicitly written by `scanf` (I assume, didn't check). So if you input 4 characters (e. g. `Hey!`), an additional 5^th character `'\0'` is being written.
This is the case. I solve it now. It only used 2gb not 4gb, so I didn't think it had anything to do with 32/64.
The problem was cos I compile it for 32bit, fixed it by compiling it into 64 bit, this is the code. void init_inode(struct inode *node, int deep, char lbl){ node-&gt;deep = deep; node-&gt;label = lbl; if(deep &lt; maxdeep){ node-&gt;sub_nodes = (struct inode *)calloc(lbnum+1, sizeof(struct inode)); for(int i=0; i&lt;lbnum; i++) init_inode(&amp;(node-&gt;sub_nodes[i]), deep+1, labels[i]); init_inode(&amp;(node-&gt;sub_nodes[lbnum]), deep+1, '*'); } /* debug code here nodecount++; if(nodecount&gt;128410000) if(nodecount%100==0){ printf("%d\n", nodecount/100); system("pause"); } */ }
It flashed out. I use eclipse and click the .exe directly. Fixed the problem now.
:)
&gt;It only used 2gb well.... &gt;can only use 2GB of that address space for its own purposes 
I would think the following: char c; int i; unsigned u; long l; float f; foo(c); // foo(int) foo(i); // foo(int) foo(u); // foo(long) foo(l); // foo(long) foo(f); // error---wrong paramter type Seems reasonable to me, and C11 now allows a form of overloading based on type. Or do you not use that? 
&gt; Seems reasonable to me I don't think that's reasonable at all. Especially since on platforms where `int` is as large as `long` (i.e. amd64 linux), the choice is a bit arbitrary. &gt; C11 now allows a form of overloading based on type. Or do you not use that? I don't use it at all. `_Generic` is something added only to allow for an implementation of `&lt;tgmath.h&gt;` without proprietary extensions. Nobody asked for it and nobody seems to use it either. I haven't seen `&lt;tgmath.h&gt;` being in wide use either.
Make a Struct array { Char* data; Int size; Int capacity; }; And assert that your string size is less than your array capacity using assert ();
Since you haven't given us much to work with, here are some things to look into: `#include &lt;pthreads.h&gt;` to get threading functions. You need to compile with the flag `-lpthread`. `pthread_create` to create a thread `pthread_join` to sync threads up. You can create multiple threads in a row using a loop. 
 #include &lt;stdio.h&gt; #include &lt;sys/time.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;pthread.h&gt; int main(int argc, char** argv); void* funcao(void* list); static int tamanho; static int numThread; int main(int argc, char** argv){ (void) argc; (void) argv; /* this is the size of the list of numbers we want. */ printf("Escreva o tamanho da lista: "); scanf("%d", &amp;tamanho); printf("Escreva quantas threads quer: "); scanf("%d", &amp;numThread); // float listaY[tamanho]; // float listaX[tamanho]; float* listaX = malloc(sizeof(float) * tamanho); float* listaY = malloc(sizeof(float) * tamanho); srand(time(NULL)); struct timeval tv1, tv2; gettimeofday(&amp;tv1,NULL); pthread_t threadID= malloc(sizeof(float) * numThread); pthread_t threadID2= malloc(sizeof(float) * numThread); for (int i=0;i&lt;(tamanho/numThread)/2; i++){ pthread_create(&amp;threadID+i,NULL,&amp;funcao,listaX); } for (int p=0;p&lt;(tamanho/numThread)/2; p++){ pthread_join(threadID+p,NULL); } for (int l=0;l&lt;(tamanho/numThread)/2; l++){ pthread_create(&amp;threadID2+l,NULL,&amp;funcao,listaY); } for (int u=0;u&lt;(tamanho/numThread)/2; u++){ pthread_join(threadID2+u,NULL); } int e = 0; for (int i = 0; i &lt; tamanho; i++) { float a = listaX[i]; float b = listaY[i]; float c = (a * a + b * b); double d = sqrt(c); /* Runs much faster without printing */ printf("x: %f, y: %f total :%f\n", listaX[i], listaY[i], d); e += (d &lt; 1.0) ? 1.0 : 0.0; } float f = 4 * ((float)e / (float)tamanho); printf("e: %d\n", e); printf("f: %f\n", f); gettimeofday(&amp;tv2,NULL); printf("Tempo Total = %f segundos\n", (double)(tv2.tv_usec - tv1.tv_usec) / 1000000 + (double)(tv2.tv_sec - tv1.tv_sec)); free(listaX); free(listaY); return 0; } void* funcao(void* tmp) { float* list = tmp; for (int i = 0; i &lt; tamanho; i++) { list[i] = -1 + 2 * ((float) rand()) / RAND_MAX; } return NULL; } 
sorry for not posting the code earlier, but I responded to another person with it, if you are able to help.
The same that happens to all sufficiently strong typed languages, or most likely the same that happens in C\+\+? Implicit conversions and warnings or errors depending on your platform? Why?
 pthread_t threadID= malloc(sizeof(float) * numThread); You used `sizeof(float)` for a `pthread_t`, probably a copy&amp;paste error. Also, you try to store a pointer onto a non-pointer. pthread_create(&amp;threadID+i,NULL,&amp;funcao,listaX); I don't think you need the `&amp;` operator on a function (they're somewhat special), I'd omit it. Also you don't need the `&amp;` operator for the first argument either since (when you converted `threadID` into a pointer), `threadID + i` already returns the correct pointer. for (int i=0;i&lt;(tamanho/numThread)/2; i++){ Why do you go until `(tamanho/numThread)/2` and not simply until `numThread`? pthread_join(threadID+p,NULL); Unlike `pthread_create`, `pthread_join` expects an actual `pthread_t` and not `pthread_t*`, so after converting `threadID` into a pointer, you need to dereference `threadID+p` to get the `pthread_t` object. You also need to check whenever `pthread_create` was successful (and also check `malloc`).
I did edited, but the post don’t change? I myself can’t see the change from mobile either?
Use `size_t`, not `int` for your indices. `int` is a 32 bit type and not sufficient for large arrays. `size_t` is a 64 bit type on 64 bit platforms and can hold all indices you like.
Make all references to a chunk of memory exist only within a certain model if you can. The fewer references to something, the better. If you need to pass a pointer to a block of memory out of the module, document that where the pointer is being returned to and do what you need to do with it, then free it as soon as possible. The fewer living references, the better.
It's not the easiest with threaded programs, but I'd imagine a debugger would help if you're getting segfaults. GDB (if you're using GCC) should give you a stack trace, so you'll be able to see what memory access or function call is causing the problem. You might need to set your compiler flags to include debugging symbols, though.
The computers have different architectures, I'm pretty sure you can't link an x64 binary on an x86 system.
You can't do it in the sense that malloc() will create threads for you. If you want to create a thread using pthreads, pthread_create will do it for you. Check out the manuals. Nevertheless, you can use malloc to allocate memory for some thread-related information, like thread ids (pthread_t) if you need it to be located in heap.
Stack Overflow is truly the short bus of the IT world.
The computers are both amd64. That's a lot of why I was so confused. I didn't initially understand that I had put a 32\-bit compiler one one of them. But I also had no idea that the whole toolchain was 32\-bit, or that that included things like nm and objdump.
I thought int was the size of whatever the environment you're running in? What about size\_t. If I'm on a 32 bit syste, what'll happen then?
Try using [\_\_asm](https://msdn.microsoft.com/en-us/library/45yd4tzz.aspx). Maybe that will help.
I think this is the way to go. May also have to use volatile to stop the compiler removing or optimising it away? Iirc
In inline assembly,what you write is what you get. I don't know why you would need volatile. Check this link. https://msdn.microsoft.com/en-us/library/5hd5ywk0.aspx 
If you're okay with a MSVC-specific option: https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/rotl-rotl64-rotr-rotr64 (You might need to use a `#pragma intrinsic` with it too.)
Pretty amazing. Nice work. How did you begin to write this? How long did it take? Did you know exactly how to do this or did you have a general idea of the high level of what was required?
Thanks. It took a few days, it's a simple CPU. I already knew what was involved though, I'm not new to emulation. I've done an 8086, 6502 and a PIC emulator before. The 8086 was the hardest, but it was also my first one. For this one, I just printed out the Intel 8080 documentation and found a good opcode table for reference and got to work.
Well done! Next one will be 386? ;-)
lol... I've been meaning to extend the 80186 emulator I wrote some years ago into a 386 emulator, but it's a little (okay, *very*) intimidating so I haven't really done anything serious there yet!
it looks good now.
The x64 compiler doesn't support inline assembly. OP could write assembly in a separate asm file, or use _rotl64 from the msvc runtime
I agree. I was answering OP's title question. How to generate a specific op code. Use __asm. Adding an asm file to the build is of course a good way too. 
You should thoroughly document it and throw it on github with a decent license (MIT, GPL, BSD, etc). It will look great under a personal project section on your resume and be a fantastic talking point during interviews.
It's public domain, why would it need a restrictive license?
Yes. It's RAM. I suggest you learn about the stack and the heap. You will answer your own question. 
Thanks for the info on `_rotl64`, I forgot about that. However, it turns out that even though it's using the opcode now, there is zero change in performance, at least on this CPU (ancient i7 3632QM laptop). Perhaps it's still worth using, in case that opcode is better optimized on other CPUs?
Both stdin/stdout, and the stack/heap are managed by the OS and you don't really need to worry about where it comes from. A buffer is just a contiguous stream of bytes located somewhere in memory. scanf just reads from the stdin buffer. If I didn't answer your question you might need to rephrase it.
Impressive stuff! Thanks for your work.
Ah whoops, I just noticed at the top: &gt; Use this code for whatever you want. I don't care. It's officially public domain. Credit would be appreciated. Public domain does not work everywhere though from what I understand, meaning some countries don't accept something being in the public domain. It might be worthwhile to instead put it under something like the Unlicense [license](http://unlicense.org/) which SQLite uses and includes a no warranty clause. Though I still think it would be awesome if /u/i_have_birbs threw it documented on somewhere like github so patches can be put in and jazz. Plus, more visibility.
The real answer is that it depends on the compiler. Most define an int as four bytes, regardless of a 32-bit or 64-bit system. size_t usually refers to the largest size of a contiguous object in memory, which can differ by platform.
Hmmm, breaking news. Signal handlers can execute asynchronously. Also, polls are now showing Carter with a slight advantage over Ford.
Maybe your CPU translates both the single instruction and the long version into the same microcode?
I need a ps3 EMU because I'm too cheap / busy working to game 
I personally recommend you to implement a lexer if you really want to check all of typos, and exceptions.
As someone who doesn't understand emulators well, what specifically makes this emulator cycle accurate?
An `int` is at least 16 bits, typically 32 bits. Even on 64 bit systems. A `size_t` is a type large enough to store the size of any object. On 64 bit systems, it's generally a 64 bit type. As a rule of thumb, always use `size_t` for loop indices.
Have you enabled optimizations?
No blog spam please.
This is exactly what I'm looking for, thanks:\)
His `int i` ranges 0 to 27, that's all. It's just a count of the children of a single node, not a count of the total number of children.
 size_t version_write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) { size_t numbytes = size * nmemb; struct jenkins_version *jv = (struct jenkins_version *)userdata; char *loc = strstr(ptr, "/download/war/"); if (loc != NULL &amp;&amp; strlen(jv-&gt;value) == 0) { loc += strlen("/download/war/"); char *end = strstr(loc, "/jenkins"); memcpy(jv-&gt;value, loc, end - loc); } return numbytes; } I don't think you should use standard string functions on the data passed by Curl. It is apparently not guaranteed to be a properly terminated C string: &gt; The data passed to this function will not be zero terminated! https://curl.haxx.se/libcurl/c/CURLOPT_WRITEFUNCTION.html --- You should check that `end - loc` is not greater than what the destination (`jv-&gt;value`) can hold. ---- Also, you should properly terminate the string in `jv-&gt;value` by adding a `'\0'` after its content (and remember to count this extra zero when you check the previous point).
 version_t parse_version(const char *version_str) { version_t res; char *v_str = strndup(version_str, strlen(version_str)); Just use `strdup()`, it is strictly equivalent and shorter; you do not gain anything by using `strndup()` this way. ------- Remember to `free(v_str)` when you don't need it any more (in this case, after you have filled your `nums` array). 
Hah! True. I sort of read from the docs that functions which take a length parameter are usually safer. 
Please show us your whole makefile, otherwise it's hard to see what the problem is. #if MYVERSION==VERSION2 This only works if `VERSION2` is a macro that resolves to some constant. Generally, the C preprocessor can only compare numbers, so you need to make both `MYVERSION` and `VERSION2` resolve to some number for this to work. There are rules for what happens when you try to compare an unresolved macro or identifier, but I am not sure what they are.
How is this cycle-accurate? I don't see anything that simulates actual machine cycles. It seems to be just accurate to the instructions it executes but doesn't seem to guarantee that each instruction takes the right number of cycles and does the right thing in each cycle.
Here! https://rpcs3.net/ It's pretty accurate already, I can even play Demon's Souls. :D
Unlikely. `rol` is not a microcoded instruction on modern x86 CPUs.
Yup, that's the problem here. Optimizations are definitely not enabled. It's setting up a frame pointer and spilling. If you enable optimizations, MSVC has no problem generating `ror` instructions: https://www.reddit.com/r/C_Programming/comments/8dli8l/recommendations_on_a_largeperiod_prng/dxokn69/?context=2
That advice is a common false friend. It drove people to follow it blindly. In many cases, it is useless. Like this one, when the *n* comes from the exact same source which the regular function would have used anyway, and not from a more limiting source. It can also cause bugs. I've seen many times people reading this advice and replacing regular functions by 'n' functions, and they replace `strcmp()` with `strncmp()`, without noticing the complete change of behaviour... Whereas the previous version tested for strict equality of strings, now every string that *begins* with `s2` matches. You wanted to test if the string was "cat", now it matches "catering" as well...
This is really cool stuff. Thanks for sharing! One question though. What do you mean by cycle accurate? 
&gt; I did read that part but somehow didn't really register as a problem because the tooling worked. As long as the data contains the substrings you are looking for, there will be no problem; but the string comes from an external source that you do not control, so you cannot guarantee it. So it is better to handle this case gracefully rather than randomly crash when the string is not expected. &gt; I was thinking of adding a '\0' and be done with it. Only if you can find a proper place to put this character. For example `ptr` is only guaranteed to have `numbytes` allocated, you cannot safely add a `'\0'` *after* its payload data. If you cannot somehow insert the `'\0'` inside the limits of the payload data, you have no other solution (IMO) than to implement your own `strnstr()`. substring="/download/war/"; lss=strlen(substring); found=false; for(i=0; i&lt;numbytes-lss; i++) { found=true; for(j=0; j&lt;lss; j++) { if(ptr[i+j] != substring[j]) { found=false; break; } } if(found) break; } if(found) { loc=ptr+i; } else { /* the substring is missing, deal with error */ loc=NULL; } It just typed this in the comment area, do not trust it blindly, it probably has bugs. But you get the principle.
As long as it has a front panel simulation...
Yeah, no, the 'n' functions don't do anything magic that would add a systematic layer of security. They just do *different* stuff than regular functions. You have to read the standard or the manual page that describes each of them. Sometimes this different behaviour is more suitable to the current problem, sometimes less. Things than `strncpy()` can indeed prevent buffer overflows: on one hand you have a fixed size destination buffer, and on the other hand you have a source string of unknown length. If you use `strcpy()` with out making sure than the source string can fit in the destination buffer, you will overflow the buffer and either crash or corrupt memory. The `n` function can here prevent that, *providing that you use the size of the destination buffer as the limit*, and not the length of the source (you'd be back to the regular function behaviour).
Not in the examples given, but you can also write things like if ((err = f()) == -1) { } as if (err = f(), err == -1) { } which is just about taste. It's possibly a bit more readible but adds redundancy. But if you want to check for multiple things after the assignment, possibly even in a loop, this is elegant: while (err = f(), err != -1 &amp;&amp; err != 0 &amp;&amp; SOME_OTHER_COND) { }
That is an excellent explanation. Thanks man for taking the time to write it down. It makes sense now. The difference I mean. 
There are a bunch of memory safe C variants. I worked with one variant named [Frama C](http://frama-c.com/) in my previous job. In my experience, the people who want memory safety enforced by the compiler don't seem to choose C in the first place, reducing the desire for a safe C.
Exactly, public domain does not work in Germany, for example. The reason is that in Germany you are unable to waive your copyright on something you created. 
Thanks for sharing.I found Great content.' Can You help in my Problem please ping me
I believe SimH already supports it. 
Thanks! I misused the term though, it's cycle counting rather.
Memory safety takes time and bloats code. That's what Java is for. 
From a brief perusal, Frama C appears to be a code analyzer, not a compiler. 
Frama C is a static analysis tool, yes. You use it to prove the correctness and (memory) safety of C code by annotating your code with function contracts. That's a dialect of C for me.
Are there any resources you used to learn how to write emulators? I would like to learn more about this.
Just to complete this answer: any undefined identifiers in an `#if` or `#elif` are simply replaced with `0`. From section 6.10.1 paragraph 4 of [the C11 standard](http://port70.net/~nsz/c/c11/n1570.html#6.10.1p4): &gt; After all replacements due to macro expansion and the defined unary operator have been performed, all remaining identifiers (including those lexically identical to keywords) are replaced with the pp-number 0, [...] So this code #if MYVERSION==VERSION2 #error yes #else #error no #endif will give the error `yes` if neither `MYVERSION` or `VERSION2` are defined. This means OP's second problem is something other than nothing being defined. 
Some people enjoy the permissive nature of C.
Mein Heapen
Thanks for the suggestion, was looking for a good emulator!
Not necessarily. As Rust has shown, a lot of type safety can be enforced by compilers. For many tasks, Haskell is very close to the performance of C. And hey, GCs and JIT can do incredible things, like profiling and optimizing on the fly.
Can anyone explain what this is? 
Thank you for this clarification.
The Rust Evangelism Strikeforce would like a word with you.
Please don't post this.
It's pronounced Rust.
Okay, no problem. If I could ask why? since you didn't say much. The courses are free. There's only a fee if you want to pay for a certificate. Just curious so I don't post something else that's against the rules again.
We have a general ban on self-promotion and commercial tutorials. Many of these tutorials are of very low quality and people like to spam out subreddit with them, often submitting one link for every episode of their video tutorials. No beginner is helped by such tutorials and the quality of our subreddit suffers because people are really turned off by shitty content like that. Though I must admit that this tutorial is neither low quality nor self-promotion nor an ad infested shitfest, so I'm going to reverse the decision to remove your post.
Thanks, I appreciate the reply.
I've heard the exact opposite regarding Haskell. I guess it depends on the task.
It is a software model of the Intel 8080 CPU from 1974. It's able to interpret the same raw binary instructions that the real CPU does, and perform equivalent functions by using C variables acting as the CPU's internal registers. You would generally use a byte array with this to simulate the CPU's memory, both RAM and ROM. Basically, you can run unmodified 8080 software on any modern PC with this, and the original software has no idea it's not running on the original hardware. You can use this as the heart of a program that emulates any full system that was based on the 8080, like the Space Invaders arcade machine or an Altair 8800/IMSAI, etc. That's the basic idea behind this.
I tried that but nothing changed.
Although rust suffers from complex syntax. 🤔
Not familiar but maybe you can reset the IDE's application font? https://forum.pellesc.de/index.php?topic=6084.msg22978#msg22978
Did you try this? [Link to the Pelles C forum](https://forum.pellesc.de/index.php?topic=2995.0)
Go is pretty memory safe too
yeah
Cool edgy reply. 
C is superior to C++ in every conceivable way, and anyone who disagrees is an idiot.
This is a good course while EdX Harvard's introduction to computer science is as good as this. The Duke offered course feels very verbose; it takes 4 entire set of courses to go through merely 5 days of lectures in Harvard's course. Harvard's courses starts with Scratch for 0th lecture and next 5 lectures focus on the C programming. 
One of the best suggestions here.
Why should IDE producers have to shoulder the burden of bundling (and probably maintaining) compilers they themselves don't develop? On Windows, you're shit out of luck and will have to install a compiler--but Unix systems often come with compilers as a matter of course.
Usually when debugging it is useful to use macros, for example: #define TRACE_LINE() traceLine(__LINE__) So you don't have to type `__LINE__` and `__func__` yourself. This can be expanded to include all the context information and an additional message, for example: #define LOG(msg) \ fprintf(stderr, "%s:%d:%s(): " msg, __FILE__, __LINE__, __func__) If you have never worked with macros before, be careful because they are very dangerous, look up "c macro higiene". You are using a global variable `traceCode` to disable debugging at runtime, but I guess you actually want to disable it at compile time? Check out this stackoverflow question for some ideas: [C debug macro](https://stackoverflow.com/questions/1644868/c-define-macro-for-debug-printing) And finally, this may be off-topic but there are a few things wrong with your code: "Your looking in " -&gt; "You're looking in" And most importantly: srand( (unsigned)time(NULL) ); uint32_t secretNumber = rand() % 1000 + 1; You only need to call srand once during the setup, otherwise the random number will be the same while the time is the same, which is 1 second, so if you call `generateRandomNumber` many times, the number will not change.
&gt;Help me. Thanks! No. You're welcome!
Is this your homework?
Thanks. I well look into the macros as carefully as humanly possible and I will fix that random number generator bug. And on anther note is there something wrong with this? I already made a note to self to fix quit program flag resonantly discovered by my sister typing the string 'yes' instead of typing 1 or 0. //Variables used in the game. uint32_t secretNumber = 0; uint32_t playerGuess = 0; uint32_t playerAnswer = 0; //Flag used for on off switch in the games loop. bool isQuit = false; letsGreetMyPlayer( ); do {//Start of the game... goAskPlayerQuestion( ); //A message prints as a hint to do something. secretNumber = generateRandomNumber( );//The computer will stor a random value. while ( playerGuess != secretNumber ) { fscanf( stdin,"%u",&amp;playerGuess ); if ( playerGuess &gt; secretNumber ){ numberIsToBig( &amp;playerGuess ); } else if ( playerGuess &lt; secretNumber ){ numberIsToSmall( &amp;playerGuess ); } else{ youGuessedMyNumber( &amp;playerGuess ); } } likeToPlayAgain( );//A message asking the user to type in true or false, //or simplify this: A basic 'yes' or 'no' question. fscanf( stdin, "%u", &amp;playerAnswer ); if ( playerAnswer == false ) isQuit = true; } while ( isQuit != true );//End of the game... letsThankThePlayer( ); 
Do people get access to the graders even if they don't want a certificate?
Ok....
&gt;Yes pro :\)
One of the my exercice. 
Good to know if I ever need to.. sort or store ints :)
This is wrong on so many levels
Your variable *name* isn't correctly null-terminated, so will be undefined behaviour to use %s in printf. Also, when variable *i* is equal to 4 you'll be dereferencing beyond the end of *name*.
Well, you can get all the lectures [here](https://www.youtube.com/playlist?list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu). There's also [cs50.tv](https://cs50.tv) that contains all previous years.
Thank you!
Note that there is no language called “C/C++.” If you are programming in C, please ask here. If you are programming in C++ (as indicated by your `Circle.cpp` file name) please ask in /r/cpp_questions. As it seems like you aren't programming in C, I have removed your question as it is off topic.
&gt;Exercise about C\+\+ Oh. Sorry! Thanks for reminding.
How is this related to programming in C? I have removed your post as it appears to be off topic.
No problem. Just make sure to post in the right subreddit!
Thanks! It's a exercise in SPOJ. I will refer to your way of doing it. 
For what micro-benchmarks are worth : - [C vs Haskell](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/ghc-gcc.html) - [C vs Rust](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/gcc-rust.html)
Looks like it's working to me - what results are you seeing, and how are they different from what you expect? https://ideone.com/2YUnZP
whoops, it was working all along. I feel dumb. My bad. For some reason, i was not looking at the output properly. thanks anyway. :D
why would you not have a isgreater function pointer parameter for the sort functions, then you could just have void pointers to the array and sort anything you wanted... similarly with the other functionality 
Honestly, I generally find type safety to be pointless (there are very few cases where the difference between an 8 bit, 16 bit, etc integer matter) But what I WOULD like to see, is type safe variadic functions.
You have not allocated enough room for your `xx` string. This means that `xx` is 1) Not nul-terminated, and 2) overwriting other memory in your program.
The `char xx[]="";` array is one byte long, so you quickly start overwriting random memory in your `pop()` loop.
Code to match parent's comment: int main() { char str[]="Hello World"; char xx[strlen(str)]; int len= strlen(str); int i; printf("String is %s .\n",str); for (i = 0; i &lt;len; i++) push(str[i]); for (i = 0; i &lt;len; i++) xx[i]=pop(); xx[i+1]=0; printf("Reversed String: %s \n",xx ); return 0; }
Life without generics is a pitiful one. 
The main problem here is they you have a horrible buffer overflow in your code, look at this: char xx[]=""; This means: "Create an array in memory with which is 1 byte long" (The 1 byte allocated here is the NULL terminating byte \0). Then, (in the second loop) you start overwriting xx with 11 bytes! Overflowing memory by 10 bytes! So before the second loop: xx = "\0" after the loop, xx looks like this: xx = "dlroW olleH" The reason you see "dlroW olleHd" printed is becouse right after the xx variable, you program has allocated memory for the str variable, this is the memory that you are overvwriting. If you run your code in a debugger and look at the memory layout before the loops, they look like this: (gdb) x/13cb xx 0x7fffffffe00b: 0 '\000' 72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' ' 87 'W' 0x7fffffffe013: 111 'o' 114 'r' 108 'l' 100 'd' 0 '\000' Here's the memory without gdb data: "\0Hello World\0" Here we say: examine memory at the address of 'xx', then print 13 bytes from this address. So as you can see, first you wee the null byte \0 (that's the 1 byte allocated for xx), then you see str (Hello World\0) directly after the xx variable. So after your second loop, the memory will look like this: (gdb) x/13cb xx 0x7fffffffe00b: 100 'd' 108 'l' 114 'r' 111 'o' 87 'W' 32 ' ' 111 'o' 108 'l' 0x7fffffffe013: 108 'l' 101 'e' 72 'H' 100 'd' 0 '\000' Here's the memory without the gdb data: dlroW olleHd\0 In this example, you were lucky to overwrite already used memory (str) and you were lucky that the end of str contained a null character which will stop printf from reading (potentially) protected code. You can fix this code by allocating enough memory for xx to hold the length of str (note that you need 12 bytes to include the string + the null char) char xx[12]; Note that you also need to make sure that the end of xx contains a \0 or printf will read outside of xx's allocated memory. In this simple example it doesn't matter since arrays are initialized to 0 (which is essentially \0) but if you where to reuse xx for something else you could again cause memory violations (printf will read outside of xx if no \0 is added to xx)
Just a note, instead of xx[i+1], you can use xx[len].
No, he calls printf later and thus needs the null terminating byte. So you need len+1. Also, This is not standard (added in C99) and also, you are not guaranteed to get zero terminated memory when using this method (if I remember correctly) so you need to clear the memory before use or make sure you manually add the null terminating byte before calling any string operations on this array.
Ah, I understood now. Thanks a ton for your time. 
Easy and simple. Thanks. It's working now.
easier if you show your code
No, xx is null terminated (in fact, that's the only thing that's allocated for an empty string). But that 1 byte is (as you say) not enough to hold the data in str
Let me clarify. After copying the stack into `xx`, it is (probably) no longer null terminated.
Cannot check at the moment, but it was possible by one of the classic zoom key combos, like ctrl+plus or ctrl+scroll-up. Try those ;)
 Graph G = malloc(sizeof(Graph)); I assume from this that `Graph` is a typedef for a pointer type. That's confusing, keep the `*`; but more importantly, the malloc is not allocating enough memory.
Should I then do `Graph G = (Graph *)malloc(sizeof(GraphObj))` Thanks for helping my btw
The cast you added is wrong. Graph is a pointer type already. malloc is returning a pointer to a GraphObj - which is Graph, not Graph*
I don't know how to do that in C. But I will look it up. Thanks for the suggestion.
I am sorry, but can you elaborate a little more.
I've never even heard about virtualC. I assume you're on windows? Could you try downloading CodeBlocks and run your code with that instead? Because your error message isn't about your code, it's your environment that's messed up
Yeah, I figured that the ThreadID\+i was wrong, it was just an attempt to increment a thread, but I'm going to try that way now, Thanks!
I downloaded and installed it but fuck that looks complex.. I really dont have time to learn how it all works to be honest. This is all due monday morning. 
here's a naive implementation of a linked list, alas it only allocates node at a time not in bulk... https://github.com/chriscamacho/clist notice its really a linked list of void pointers.... so its not limited to int's when its time to do a simple bubble sort, void clistSort(clist_t *list,int(cmpFunction)(cnode_t *node1, cnode_t *node2)); notice the compare function pointer int(cmpFunction)(cnode_t *node1, cnode_t *node2) which the end user provides for int's for example it would just return one subtracted form another, but having a compare function means you can sort any data type, you just need to be able to make a value judgement between two custom data types...
Thanks it worked. Ctrl scroll. 
Was ctrl scroll. Thanks. 
Thanks. 
Thanks. 
sorry
Try printing out the first string you read, `c`, that should give you a clue. If you're still confused, read up, in detail, about how the `%s` format descriptor works in `scanf`.
Works for me, let's me scan in.
Try to do tour first scanf like this: scanf("%s\n", c)
Just a friendly reminder to avoid scanf (), bacause it is unsafe and fucks up sometimes.
See this [example from IBM](https://www.ibm.com/support/knowledgecenter/en/ssw_i5_54/rzab6/poll.htm). Maybe it will help you. 
Better to do char str[] = "Hello World"; char xx[sizeof(str)]; since the reliance on `len` makes `xx` technically a VLA, which is a C99 feature that IIRC became semi-optional in C11.
it doesn't matter since he's learning he'll pick up best practices later, dont worry about it
One way: Poll will skip over any negative value fd. The manual page on my system suggests using the negation of the fd (and how this won't work with fd 0, of course, but that's usually a moot point, and solvable). Poll will ignore it, you can keep track of the old fd, and you know which array entries can be used. I hope I don't sound like I'm RTFMing you, but the manual page is really worth looking at.
I would recommend using epoll(). That's a better alternative to select() and poll().
Others have already answered the question so I'll just mention that you should probably change from raw character comparison to string comparison (look up strcmp) if you want your program to only accept specific inputs. In your current program, "fahr to cels" and "fart on my balls" would have the exact same behavior. Your program also has a buffer overflow bug caused by reading your input string with scanf, try using fgets instead and look into buffer overflows as they crop up a lot in C and are very important to understand.
Youre gonna have to post the snippet of code for the people to really understand whats going on, im thinking either your didnt store the strings correctly, the pointers arent configured correctly, or the way youre reading from the linked list is wrong
?? Code blocks is straight forward my dude, and it also has the most support you'll find for a C IDE
Oh nice. Is epoll event driven? I don't really understand the difference from poll
`scanf()` is the standard library function to use. C might not have a good readLine function as standard but you're **supposed** tl use `scanf()`!
This is trickier than you would think... #include &lt;stdio.h&gt; #include &lt;string.h&gt; void printReverse(char *str, unsigned int len) { char buff[len + 1]; // c99 automatic stack allocation, last variable buff[len] = '\0'; while(len--) buff[len] = *(str++); printf("reversed='%s'\n", buff); return; } int main(int argc, char *argv[]) { int c = 1; char *hello = "Hello, World!"; char **v = { &amp;hello, NULL }; if(argc-1 &gt;= 1) { c = argc-1; v = &amp;argv[1]; } while(c--) printReverse(v[c], strlen(v[c])); return 0; }
but to be a pedantic whiner, for formatted input.
https://stackoverflow.com/questions/29947302/meaning-of-options-in-mingw-w64-installer Also you could consider [installing via MSYS2](https://stackoverflow.com/questions/30069830/how-to-install-mingw-w64-and-msys2) as the package management is nice. 
Don't put space at the end of a scanf string. It means input will block.
Please edit your post and add the code. Make sure to put four spaces in front of every line of code so reddit formats the code correctly.
In epoll you add and remove fds using separate syscalls. They'll also be auto-removed if the they are closed. This lets you avoid creating the array for each call and also avoids the kernel having to parse that array for every poll. 
Yes you are right :) i dont want him to Never use it anymore. Just Wanted to say it for the future.
It's less about verbosity, if I only use this value there, for me doing the assignment inline tells me "this is just used within this block and not outside. Making the assignment outside is -- to me -- a heads-up that it's gonna be used after the immediately following if-else blocks. Additionally this variant can only be used in for `if`, not for loops, since you want to do the assignment on every run and not just at the beginning.
&gt; use a bi-dimensional array to do so, but Im not sure exactly how to go about this Have you tried [the first result in Google](https://www.tutorialspoint.com/cprogramming/c_multi_dimensional_arrays.htm)? You declare a 2D array like so: type name[size1][size2]; What part is confusing to you?
I literally spent the last 2 hours googling it and didn't come across that result. Wow Im a noob. Thankyou, I understand whats stated on there. Any tips for future efficient google searching?
You just need to get used to the terminology. If someone can link to a site or a book with the most used terms in programming since im on my phone it would be nice.
No worries. All I did was search "C array multi dimension". I hope this helps!
Do you know how I would implement the grid system as is? In the sense that, how would I actually make the grid? 
Like rendering it? For a text based interface you could just iterate the array
How so? Would that cover both the axis and the dots? 
Just print the row number before the row?
The way I'd do it would be something like this: char grid[5][5]; int x,y; /* Fill the array with dots */ for(x=0;x&lt;4;x++) { for(y=0;y&lt;4;y++) { grid[x][y] = '.'; } } I'm sure you can figure it out from there.
&gt;The manual page on my system suggests using the negation of the fd (and how this won't work with fd 0, of course, but that's usually a moot point, and solvable) Why wouldn't it suggest the *bitwise* negation of the fd? Are there even any non-theoretical systems out there that this wouldn't work on? Preserving the magnitude doesn't matter.
tl;dr you can also go directly to the [source website](https://sourceforge.net/projects/mingw-w64/files/) and look at "Downloads/Week" and go with the crowd with absolute no understand what you're choosing (lol). https://i.imgur.com/sdieORu.png &lt;-- choose posix https://i.imgur.com/swpAx7B.png &lt;-- choose seh 
This is why I hate contrived programming exorcises... the constraints are all artificial and it's hard to figure out what's the best approach--I guess you could just always default to just sticking with a standard, but in my experience that's not how any business operates (we're c99, except we use XXX compiler which uses YYY feature which isn't standard anywhere else).
I was thinking the same thing. I think overall negation is just conceptionally easier, and when that man page was written I'm not sure two's complement was quite as ubiquitous. But you could also equivelantly do `-fd - 1` (and then `-(fd + 1)`) to achieve the same thing without requiring two's complement integers, so I do think it's just a matter of a negation being simpler to understand.
Easiest approach is to install the nuwen version (based on MinGW-w64) https://nuwen.net/mingw.html. 
I am not completely sure, but I don't think defining strings as a macro is that easy. Strings in C are just arrays of characters. I believe macros can better be seen as a value which is substituted at compile time (or at least not at runtime). Likely you would want to do something like: `#define STRING "string"` And then later on somewhere: `char str[SIZE] = STRING;` Again, I am not sure about this, since I have never used strings as macros.
Poll, select, and epoll are all event driven io mechanisms. Epoll is the modern choice on Linux, but select is easier to grasp. They all perform similarly for small sets of sockets, but select has a HUGE performance problem after 1024 fds.
Macros are not worth it. Modern compilers inline small functions so a function is just as fast as a macro but much easier to maintain. Also note that “it does not work” is not an error description and doesn't allow any of us to find out what went wrong. Be more specific!
First thing I note is that you wrote `return` in capitals (`RETURN`). Second thing: I don't know if presentation is messed in the post or not, but if you want a macro to spread over several lines, you have to end each line (but the last) by a backslash (` \`) just before the newline.
Bitwise negation doesn't work for one's complement, because the complement of `0` is actually `-0`, both of which are treated as zero. So bitwise negation causes the same problem with one's complement that arithmetic negation causes with two's complement.
So you're trying to take the nth byte of some_number and OR it with some value which I'm assuming is an 8-bit value, unless you're wanting to keep the high bits of value. #define WRITE_TO_A_BYTE (some_number, value, byte)\ value | ( (some_number &gt;&gt; (8*byte)) &amp; 0xFF) Just be sure to only pass a value that is between 0x00 and 0xFF and a byte between 0 and 3 for 32 bit systems.
The only way to get good at anything is by doing it (practice). So just code stuff. Doesn’t matter what it is. Write code.
That's a useful way to help — though not guarantee — your program be extremely portable. I use `-ansi -pednatic` on projects where I care about this or where it's fairly trivial to do. 
&gt; `-pedantic` is slightly stricter than `-Wpedantic.` Wrong. [They are identical](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html). IIRC GCC wanted all warning switches to start with `-W` so `-Wpedantic` was introduced in newer releases as an alias for `-pedantic` 
It would make more sense to compile with 2 different compilers (GCC, Clang) and maybe something like Facebooks "infer" command or Clang's Checker. Some libraries from my GitHub I've compiled with many compilers, and they all return 0 warnings, but the static analyzers give me useful hints.
Ahh, that's what I was missing. For some reason I was being dumb and thinking that compilers ought to just check the sign bit but I didn't think of -0.
Take a look at the FreeBSD repository. It's at svn.freebsd.org. Fetch everything and start with something simple, like "cat" command or "wc" command for example. It will give you all you need to study - something that works and something that is high quality. It's also real example of system programming. Each FreeBSD command that you can execute will be available to you in the source form. Overall I've found FreeBSD made the biggest dent on my knowledge, and made me understand C much better.
I agree. in addition, macro is notoriously prone to bugs as discussed in "Elements of Prigrqmming Styles". Just don't use it unless there is no other option.
Ah, gotcha. That's poor wording in the manual and man page since, by specifically naming -Wpedantic under the heading for both, it suggests its behavior is different from the other.
No no no NO NO NO. you don't convert functions to undebuggble macros to make your code faster. Profile your shit, figure out what's wrong, fix it as a function. Macros should ONLY be used for compile time operations.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
`-ansi` is actually `-std=c90` and gcc seems to prefer that, even though both ANSI and ISO have withdrawn C90. -ansi In C mode, this is equivalent to -std=c90. In C++ mode, it is equivalent to -std=c++98. -std= (--snip--) c90 c89 iso9899:1990 Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as -ansi for C code. That's on my 7.3.0 on Gentoo.
Hello, while I fully agree with you, unfortunately my comp.sci professor does not agree. I would add that the function version works perfectly. The assignment is to convert 4 of my 9 functions to macro's. Here is the error being thrown my this macro after some modification. #define ECRIRE_SUR_UN_OCTET(quelconque, valeur, byte, result) (valeur = valeur&lt;&lt;((byte)*(8));\ quelconque = quelconque &amp; ~( HUIT_BIT &lt;&lt; ( ( byte ) * ( 8 ) ) ) ) ;\ (result = valeur | quelconque)) Here is the calling of the macro result = ECRIRE_SUR_UN_OCTET(quelconque, valeur, byte, result); Error message : [http://i64.tinypic.com/nltvtj.png](http://i64.tinypic.com/nltvtj.png)
&gt; result = ECRIRE_SUR_UN_OCTET(quelconque, valeur, byte, result); which develops as: result = (valeur = valeur&lt;&lt;((byte)*(8)); quelconque = quelconque &amp; ~( HUIT_BIT &lt;&lt; ( ( byte ) * ( 8 ) ) ) ) ; (result = valeur | quelconque)); See the problem**s**? Just don't write steps in your macro, write the full expression: #define WRITE_TO_A_BYTE(some_value, value, byte) (valeur&lt;&lt;((byte)*(8)) | quelconque &amp; ~( HUIT_BIT &lt;&lt; ( ( byte ) * ( 8 ) ) ) ) (something like that, anyway).
The better approach is usually to define a static inline function in the header file. To debug your macro though, run the processor and look at the code after the macro has been expanded. It will probably be easy to figure out what's wrong when you look at that. 
Keep answering yes.
What's his justification for doing this? Is he completely ignorant of the last, oh, 20 years worth of compiler and language developments?
What's his justification for making you do this? Is he completely ignorant of the last, oh, 20 years worth of compiler and language developments? 
Compile with Facebook? Now I've seen it all
Rap your professor sharply on the nose with a rolled-up newspaper, because he’s teaching you bad things and completely missing an opportunity to teach you about the wonderful world of compiler optimizations. It’s an engineering discipline whose disciples have ended up with a huge amount of power over people’s money and lives, and he should damn well behave responsibly in his role as educator. If he protests, continue striking him about the head until he relents. Rub his nose in his thorough wrongness. Also, I strongly recommend that a. you evaluate each macro argument exactly once, so that subexpressions like `a++` or `a=4` don’t wreak havoc and aren’t accidentally skipped; b. you surround any use of a macro argument in parentheses so operator precedence doesn’t bite you in the ass (only in very specific, rare situations should you not wrap up your arguments); and c. either make the macro expand to a single expression (use operator `,` if need be), or turn it into a standalone statement so that it behaves normally amongst other statements. For (a.), things like `a = a OP expr` can become `a OP= expr`, so (valeur) &lt;&lt;= (byte) * 8 (quelconque) &amp;= ~(HUIT_BIT &lt;&lt; ((byte) * 8)) // (You don’t need to put parens around 8; it’s a single token and // it can’t possibly break things alone.) For (a) and (c) together, you can do (result) = ((valeur) &lt;&lt;= (byte) * 8) | \ ((quelconque) &amp;= ~(HUIT_BIT &lt;&lt; ((byte) * 8))) which is apalling but it makes it so that `byte` is the only thing evaluated multiple times. If you don’t need to use it as part of a larger expression (e.g., with `,`), for (c) you can also do do { \ unsigned byte__; \ unsigned long /* ? */ valeur__, quelconque__; \ byte__ = (byte); assert(byte__ &lt; sizeof(int) * CHAR_BIT); \ valeur__ = ((valeur) &lt;&lt;= (byte__ * 8)); \ quelconque__ = ((quelconque) &amp;= ~(HUIT_BIT &lt;&lt; (byte__ * 8))); \ (result) = valeur__ | quelconque__; \ } while(0) which is probably what I’d go with if I were forced into your shoes. It’s imperfect—when possible you should opt to keep things function-like—but it’s about as good as you can do without getting compiler- or standard-specific. Some things to note about this: - It ensures that each argument is evaluated exactly once. This keeps the programmer from being especially surprised/dismayed by its behavior. - It ensures that it makes sense in contexts like if(ptr) ECRIRE_SUR_UN_OCTET(a, b, *ptr, c); which it wouldn’t if it had a bunch of unguarded `;`s in it—then the `if` would only guard the first statement, which would suck badly. - Since it’s a standalone statement with its own scope, you can define variables inside that make it safer and easier not to trigger unwanted side-effects or undefined behavior. (Again, though, this is a terrible hole to swim in: You have to make sure nothing else will try to pass the variable names you’re using in as parameters from outside, or things will get mixed up. There is no standard-specified way to come up with a unique name, although `__COUNTER__` or `__LINE__` can help somewhat.) - Since you can declare your own variables, they act like parameter declarations that shore up types before pumping expressions into `&amp;`, `|`, `&lt;&lt;`, and `~`. Bitwise operators are intended primarily for use with `unsigned` operands, and they can induce undefined behavior if an operand is negative. Since you’re left-shifting, this also makes sure that the shift operation won’t get truncated by a short operand. - There’s an assertion in there to make it safer; if the shift count is ≥ the number of bits in the operand type, you can get weird/bogus results. You could also force outputs to zero instead of asserting, depending on how you want it to behave. Note how pointlessly complicated all this is, unlike writing a normal function? Macros in C almost require their own dialect of the language, and you’ll see a lot of usage of operators like `?:` and `,` in macros to try to force them to behave properly and evaluate in well-defined (usually function-call-like) ways under whatever abuse the programmer lobs at them. They’re difficult to maintain, difficult to debug, and difficult to reason about. They can also introduce really weird behaviors; for example #define count (*(const char *)0x5000UL) .... void foo(unsigned count) { ... } will cause a syntax error because `count` expands before the compiler gets to it. That doesn’t happen for things outside the preprocessor, and in production code it tends to lead to people having to prefix every last identifier in their headers, either to ensure their own macros don’t bork somebody else’s code or to ensure other somebody else’s macros don’t bork their own code. Whereas, if you’re allowed to use a function, you can ensure the thing is reasonably self-contained and behaves just like any other code. If you can declare it `static` (i.e., it doesn’t need to be shared between compilation units), it’s actually *easier* for the compiler to make good optimization decisions about it than it’d be as a macro. If you can’t declare it static, then you can declare it `inline`, which like every compiler has supported as a C extension since C++ was a thing, and which became official in C99. In most compilers, you can even do things like __inline__ void do_this(...) __attribute__((__always_inline__)); and it’s exactly what you’d get if it were a macro, except sane and again, the compiler can deal with it much more easily. And even if you can’t declare it `inline` or `static`, most remotely recent versions of compilers support link-time optimization, so even if the compiler can’t inline it, the linker almost certainly can.
[removed]
Yeah, or add --noconfirm param if there's a lot of them
&gt;It also has QtCreator IDE as the only IDE I've found so far in which open source integrated debugging actually works. I have installed MSYS2. how to add QtCreator IDE with a debugger?
I compile with `-std=c11 -pedantic` and anyone who doesn't like it can upgrade their compiler 
1. Can you please give me exact commands for pacman? 2. After installation, do I need to configure IDE, debuger and compiler or they work right after installation?
Here is confirmation: https://stackoverflow.com/a/50548090/1601703
1. No, but you can use `pacman -Ss` to search and `pacman -S` to install. It is similar to the other pacman commands you used so far. 2. I think it works without configuration but can't remember.
When I run `pacman -Ss qt` I am getting a huge list. Which one should I install? *Never used pacman, has very little experience with Linux and never used C (trying to start learning)*
I linked the package names earlier. 
Which one should I choose? https://i.imgur.com/Sg1GUAC.png 
Are you sure a should be a char? Does your compiler give any errors or warnings with that line?
`malloc()` returns a pointer. Do it like this: char *a = NULL; a = malloc(15*sizeof(char)); /* check not NULL then use `a` as if it were an array of length 15... */ free(a); a = NULL;
If you aren't going to do QT development it doesn't matter. I think I did the nonstatic, you can always change it later or do both
http://lmgtfy.com/?q=facebook+infer
No. You can install FreeBSD in a VM aka. Vagrant. Then just install Subversion inside: pkg install subversion and you could fetch the source code inside of the VM. Or just fetch the code without running it and read it. But that's not the same :-) For Linux -- each system command has the source code. You'd need to fetch the packages for each command separately. Each distro has that done separately. I'd guess that maybe Gentoo is the closest there is, so that could be worth exploring.
How basic is basic? Go program Conway's Game of Life on a 80x24 grid and print generations out to the terminal after each readline, quit when a line starts with 'q' or 'Q'. Have your program accept command line arguments and have options to read in a starting pattern (from keyboard, ending with '.') or from named file. Make the q/Q quit work if the player gets board, ignore parts of pattern outside grid.
Add on top of the list: * this is a subreddit about the C language, not C++ or C# (insert links to the proper subs). ---- To make worse the absolute shit discoverability Reddit has, when you search for C++, the search returns: 1. /r/C_Programming 2. /r/Warhammer40k 3. /r/learnprogramming 
I think we need an additional subreddit for homework questions - and a rule that no homework questions should be asked here. 
The people who need that advice are the ones least likely to read such a post.
I'm subscribed to all 3 of those...
If you look in the side banner, /r/C_Homework is listed.
In the grim darkness of the far future there is only Javascript.
Then I guess more active moderation, and outright deletion would make sense. Homework questions are really toxic for a subreddit like this, since they dilute interesting content, and so reduce the kind of engagement that makes the place worthwhile. 
You should have mentioned that `epoll()` isn't portable.
True sometimes I dont even check this subreddit anymore, because he are alot of time question like, whats wrong with my linked list, my stack etc. 
A sticky answering "I'm a newbie and I want to Learn C", subsets of which include "I want to learn C tomorrow" and "I want to learn C so I can get a job tomorrow".
This is a good starting point. Once upon a time using multiple compilers with no common heritage (and not trying to emulate the poorly to undefined GCC “extensions”) targeting processors with different behaviors (word size, endian, packing, alignment, etc...) pulled out many errors that couldn’t be found on a VAX. Ten years from now most new code probably won’t run right on anything but an LP64 little endian system.
Here's a sneak peek of /r/C_Homework using the [top posts](https://np.reddit.com/r/C_Homework/top/?sort=top&amp;t=all) of all time! \#1: [Welcome to /r/C_Homework](https://np.reddit.com/r/C_Homework/comments/3vl83o/welcome_to_rc_homework/) \#2: [Help with basic C programming HW](https://np.reddit.com/r/C_Homework/comments/72rr2h/help_with_basic_c_programming_hw/) \#3: [Made a discord for C/C++ help! Three channels to post code and get help from advanced/experienced coders. You can chat with other coders too.](https://np.reddit.com/r/C_Homework/comments/6l6anm/made_a_discord_for_cc_help_three_channels_to_post/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
[Comparison with Google with site:reddit.com](https://www.google.com/search?q=C%2B%2B+site%3Areddit.com)
But, when they don't, the first response to their post can be a link to the sticky
Am I part of the problem?
I have installed: mingw-w64-i686-qt mingw-w64-i686-qt-creator mingw-w64-x86_64-qt mingw-w64-x86_64-qt-creator QtCreator is building well but if I try to debug: https://i.imgur.com/LdMBLLd.png I think the debugger is not set: https://i.imgur.com/J73lP98.png How to set debugger?
do you know how to solve problems in any other languages? because like any other language, you get better at C by solving problems in it. if there's a particular class of problems that you don't think c is suitable for, try using it for one of those. personal advice: C's features are good for simulations involving arrays of actors whose behavior only depends on the current world state -- it's a fun language to do ex economics problems in. (golang competes well with it in that niche though) casting to ``char*`` is useful for homemade persistence features and since you actually control the memory layout in C you can guarantee dumping your data to disk doesn't do anything stupid. so it's good for little programs that need to save or clone their state. (again, like simulations)
i can't tell if you're talking about the big O representations or the underlying functions for those big O representations, so i'll answer for both. you probably can't do this using math on the big O representations exclusively because big O (or big theta, whatever you have) neglects constant factors and small terms. the point where kn^2+C intersects gn^3+D can be *anywhere* depending on what C and D are . however, doing it on the underlying functions should be fine and I think you're correct. keep in mind that many algorithms' number of steps is not actually determined exclusively by the size of the dataset. splay trees have O(log n) amortized access time, but with the right access pattern they approach O(1). the time complexity of t = log n is very misleading. practically this approach has more problems. since performance is often predetermined by characteristics of your dataset (ex: quicksort is going to be slow compared to recursive radix sort in a dataset with a lot of duplicates) the only way to actually determine this is to benchmark. your time/memory usage function probably doesn't account for this. it's also determined by characteristics of your storage medium: b-trees are a popular data structure on hardware where following a pointer is expensive (like hard disks), but red-black trees are popular on hardware where that's relatively cheap. you *could* account for this in your time/memory usage function but most theorists won't because that would make their papers very hardware dependent. *the only way to do what you want is to actually benchmark on real data*
The break-even point will vary from one implementation to the other. It might even vary from one machine to the other, with the same implementation, due to differences in memory size and organization (including cache), optimization features such as speculative fetching or execution, and instruction sets. BTW, constant factors are usually omitted, so your example would be *O(√n)*, not *O(3√n)*
In my experience, people don't read it, so you'll be doing this solely for the purpose of telling them to read the sticky or whatever section of the sub \(wiki/faq/etc\) instead of answering the questions. Add to that the fact that resources get old, with no one wanting to update them, and that makes people ignore them even more. So, by all means, do it, but don't expect it to help.
I guess I'd much prefer if C_Programming was much more quiet, but with more relevant and interesting stuff being posted here. The problem with homework questions, even downvoted ones, is they train you to ignore new posts from this subreddit - since they are almost never interesting. So I find myself ignoring stuff that I might interact with - and I bet I'm not alone. I'm also really not sure it's good for the people who ask questions. Seems to me that most of the homeworkish questions are about stuff that's really easy to look up - and that developing techniques for looking up things, knowing how to navigate and use documentation, is actually a core skill of programming that gets atrophied if your first reflex is always to ask. I think they also make for a less friendly atmosphere, since people tend to find them irritating, so you get a sort of toxic spiral of irritation where regulars develop the practice of being rude to newcomers, and that develops into the culture of the sub. Obviously, everybody starts somewhere, and everybody asks questions that are, no doubt, documented in a manual somewhere - but I think the problem with homework questions is they are generally posed by people who aren't actually interested in the answer, but rather just in completing their homework. Which I understand, but I would rather not subscribe to.
Good C questions are fine, they sharpen the understanding of the language and the standard. Questions about `scanf(3)` that start with the words "plz hlp me wid my h0mework" are not (to me at least).
Do the head case first, delete and return if it's the head node. Then iterate through the list keeping a pointer to the previous node until you either find the node you're looking for or reach the end. If you reach the end return. Else, change the previous node's next pointer to your node's next pointer. Then free your pointer.
Stickied due to general interest.
Okay, thank you very much for your input!
I did downvote those submissions for a while, but I stopped caring about curation when I figured out that "my side" was on the losing side. What might help is the same thing that might help in your case: a strong editorial policy. It would take the arbitrariness out of moderation and also make clear which content is appreciated and which isn't. I'd point to the Hacker News moderation standards as a kind of healthy community standard.
Just ignore those posts? If they're properly flaired you can even filter them out.
Every other C subreddit is basically a dead barren wasteland. If you try to push posts away from here this one will be too. That would be bad. Don't want to see homework posts, don't read them. This isn't exactly a high volume sub; it's easy to do. 
This is the subreddit for programming in C, general programming questions are off topic. Please post this sort of question to /r/learnprogramming instead.
This would be my concern. If you fragment the sub, it's unlikely that we'll get as much participation. In the long run, getting some basic use posts is useful because those commenters have a chance to participate and begin joining the conversation. More quality content is the answer to a lot of people's gripes, but this might be a reflection of there just not being a ton of good, new C content out there. That said, if I see a post that looks like it's copied from homework, I downvote and move on. It's tough to tell the difference between a homework question and a non-trivial beginner implementation question sometimes, though. And that's a bummer because often the latter generates the best discussion about how C is organized and philosophical choices that were made in the language. I love that stuff. We just all have to be a good citizen and participate with our votes.
*scanf* returns as soon as it finds a character it can't parse, and it doesn't remove data from the input if it hasn't parsed it – this means the letter you wrote will still be left in the buffer for the next iteration. To solve this, you can do something like reading an entire line with *fgets* and then parse that buffer with *sscanf* instead: int size = 0; do { printf("Size: "); char buf[32] = { 0 }; fgets( buf, sizeof(buf), stdin ); sscanf( buf, "%d", &amp;size ); } while (size &lt; 1 || size &gt; 100); 
Yeah I had my extensions as .cpp. Im new to Visual Studio so I couldn't understand why I was getting an error. Thanks!
You can answer most of these questions by googling, e.g. "how to set debugger in QT Creator".
The common way to do this is to use header files. You would make a file functions.h which has int add(int a, int b); then in functions.c you would have #include "functions.h" int add(int a, int b) { return a + b; } and then in main.c you would #include "functions.h"
You can't include another source file, only headers. You have to compile each .c file separately and then link them together. This is where makefiles come in. http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/ Basically, in simple terms a makefile is a script that compiles your program. I'll let the link explain makefiles (its rather good at the basics). It allows you to do quite a bit with your program. .C files -&gt; obj files -&gt; .exe
Then in the build script you reference the .o file, functions.o
As I understand I should install gdb, right? Which packages should I install to be able to debug both 32 and 64 bit code? Here is an output of `pacman -Ss gdb` command: $ pacman -Ss gdb mingw32/mingw-w64-i686-gdb 8.1-1 (mingw-w64-i686-toolchain) GNU Debugger (mingw-w64) mingw32/mingw-w64-i686-gdbm 1.14.1-1 GNU database library (mingw-w64) mingw64/mingw-w64-x86_64-gdb 8.1-1 (mingw-w64-x86_64-toolchain) GNU Debugger (mingw-w64) mingw64/mingw-w64-x86_64-gdbm 1.14.1-1 GNU database library (mingw-w64) msys/cgdb 0.7.0-1 Curses-based interface to the GNU Debugger msys/gdb 7.11.1-1 (base-devel) GNU Debugger (MSYS2 version) msys/gdbm 1.11-3 (Database) GNU database library msys/libgdbm 1.11-3 (libraries) GNU database library msys/libgdbm-devel 1.11-3 (development) libgdbm headers and libraries 
What's wrong with your code? What happens? What's it doing or not doing that it shouldn't be doing or should be doing?
And you expected us to figure that out, *then* fix it?
Mr. Troll im expecting HELP. On how to go about solving my problem. 
"i'm" 
Thank you for this amazing write up! Truly helped me understand whats what.
Re-read the docs on `qsort`. Specifically, take a hard look at the third argument.
Use your brain
Some of those actually work? Strange. Are you still on a 32 bit system?
I'm not trying to eliminate homework posts, especially. I'm trying to eliminate the need to tell quite so many people not to post imgur screenshots of their code, that they need to post a complete example, that they should turn on warnings in their compiler, etc. 
Yes they work. This is a HM assignment, all three compare classes were supposed to be filled in by me the rest of the code was created by the professor. The compare methods essentially need to sort the arrays based on Id numbers from low to high, prices from high to low and colors should be sorted alphabetically. I have the Id and prices sorted but I can't figure out how to sort the colors alphabetically within the given method. (Also im on a 64 bit system).
Bizarre. But that's undefined behavior for you.
I am new to C programming, and I plan on using the second solution that you have suggested. I have a 765 elements in my key value pair array. would you consider this to be a too big of an array to affect lookup time?? I am coding this for an atmel 32bit microcontroller. Thanks in advance.
Thats not the common way, you might wanna check [http://buffered.io/posts/the\-magic\-of\-unity\-builds/](http://buffered.io/posts/the-magic-of-unity-builds/)
Someone has to tell them. We can make a wiki page, but in my experience, no beginner ever reads these. Same problem on Stack Overflow, even though they put their tour pretty much in the face of newbies.
I look forward to seeing the results of you implementing these techniques with the code you presented here also note you should allocate individual nodes from a larger pool of memory you got from alloc only free-ing it when no nodes use it - done right this should be faster and also help prevent system memory fragmentation...
If you expect help, you have to first explain what you need help with. Also, please indent your code properly, then add four spaces at the beginning of each line before pasting it into your post. And never use floating point for currency.
There are legitimate use cases. For instance, look at [OpenSSH's `umac128.c`](https://github.com/openssh/openssh-portable/blob/master/umac128.c).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [openssh/openssh-portable/.../**umac128.c** (master → fbb4b5f)](https://github.com/openssh/openssh-portable/blob/fbb4b5fd4f8e0bb89732670a01954e18b69e15ba/umac128.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dzpap88.)
Or just exit if `scanf()` returns anything other than 1.
I can see there being a few exceptions, and I'm probably also just biased towards reading text by my own personal preferences, which likely do not match everyone in this sub. I'm certainly not expecting that all videos disappear forever, but it would definitely be nice if the majority of these were removed. As for your issue above about avoiding bias in moderating, I do understand that is important. I think it's possible to remove the obviously shitty tutorials but still "let the votes decide" for most things as a way of not sliding down that slippery slope. Perhaps an appeals process that requires review by a _different_ mod?
With simple programs they shouldn't differ that much. Your example `pwd` functionally isn't very much different: - GNU: http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/pwd.c - FreeBSD: https://svnweb.freebsd.org/base/head/bin/pwd/pwd.c?revision=326025&amp;view=markup The reason why it's longer... you'd start digging here, which FreeBSD makes easy. And while on GNU/Linux system `pwd` is GNU `coreutils` package, which is one repo, the functions it's calling from the standard C library (`getcwd`) are in different repo. So you'd need to find all these repo links, fetch them, check that what you're executing is the version whose source you're reading etc. While in FreeBSD, if you install the system with the source code package, the `getcwd` is here: https://svnweb.freebsd.org/base/head/lib/libc/gen/getcwd.c?view=markup 
Which platform?
`-Wstrict-prototypes` is your friend
Both win and linux if you know, or one only.
I use a terminal, vim, makefiles and the compiler of choice (usually gcc). The good thing of getting used to this set of tools is that you can get a good productivity and it is way easier to have it already available even when you do remote login (via ssh) to a cluster.
I can speak only from Linux side of stuff. 1.Choose a Text Editor/IDE I preffer Atom and Sublime 2. Compile the code You can compile code from terminal in any Unix OS with command: "cc /path/to/file/file.c" The command will make a file" a.out", which is the result of your compilation. You run it by typing "~/a.out" 
You could see the same article in C++ Primer Plus.
* Learn CMake or another tool that can configure builds and (importantly) exports a compilation database. * Use Vim with YouCompleteMe. * Run clang-tidy on the source code. * Write test cases to be run with Valgrind.
4000001f is coming from the x86 emulation layer of 64-bit Windows. Perhaps your debugger doesn't understand it. Try building a 64-bit program instead.
I'm usually "too nice" to downvote these questions. Downvote can mean different things to different people. Now I know just to downvote these questions until I see this subreddit improve.
Yes, please do that. Downvotes on reddit don't work like downvotes on Stack Overflow.
&gt; Perhaps an appeals process that requires review by a different mod? I don't think I want to pile that work onto the other moderators. Also, someone would have to implement such a review process.
I'm starting to believe that another survey should be conducted. The upvotes on this post alone indicate quite the contrary.
That's a good idea. Let me see what I can do.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/cprogramming] [Difference between “int main()” and “int main(void)” in C\/C++?](https://www.reddit.com/r/cprogramming/comments/8mrszt/difference_between_int_main_and_int_mainvoid_in_cc/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Your answer is very good. It was something I wanted to hear. If you know any more tools, you are welcome to write. Terminal, vim, makefiles and gcc is ok. But debugging with gdb and address sanitizer is something I should look more.
Thanks for replay, but this is not something I was looking for. I use sublime text too, didn't really used it heavily for C, but it is very different thing for text editor to be C dev environment. I meant some heavy development, with IDE, debugger, checking some errors as you write and so on.
I heard about valgrind before, but never used it and don't know what it is. I will check it. Your answer is something I was looking for to hear.
Code::Blocks. you can download it with the compiler, very easy setup.
Nice website. I didn't watch whole video, they were like hour long. But he codes in C\+\+. Is it same setup for C from first video I saw ?
I used Code::Blocks but GUI seems so old and sometimes it would not render nice after I alt tabed. 
A great example which article does not belong here. I mean seriously If you can do C and C\+\+ for at least 25&amp;#37; you would know this. So in my opinion garbage poste sorry
It can be. For Linux, you are likely going to have everything you need already installed. 
Thanks. I usually like checking the stuff I compile with Valgrind just to make sure it's ok. Here's a cool introductory \[video\]\([https://www.youtube.com/watch?v=Sddn1UjzSAo](https://www.youtube.com/watch?v=Sddn1UjzSAo)\) from Jacob Sorber which you might find interesting.
Yeah, I think that's a great idea. and users could comment their n00b questions and we can answer them there so they're less overlooked.
Honestly, I'd prefer to hear more about new things in C, than just the same old homework questions. Take that with a. grain of salt tho, cuz I talk about my projects very chance I get (without being a spammer or anything, I just have a big fucking mouth)
&gt; I think they also make for a less friendly atmosphere, since people tend to find them irritating, so you get a sort of toxic spiral of irritation where regulars develop the practice of being rude to newcomers, and that develops into the culture of the sub. Can confirm, I've struggled with this a bit, a couple months ago I lashed out at a newcomer to the point that he deleted his post and apologized for posting a basic question, I apologized to him, and even /u/FUZxxl called me out on my behavior (which was completed justified of him); I took a break from the sub for a while after that... 
which is called linking, and the .o file is generally in an `.a` file (static archive)
Considering also that C functions can have parameters with default values, I don't really see why people would need function overloads.
I'm not sure if there are any specific exeptions for the main function, but declaring the following function ``` return_type foo() ``` Means different things in C and C++ In C++, you're saying that you're declaring a function named foo, that returns data of type return_type, and that takes **no parameters** In C, you're saying that you're declaring a function named foo, that returns data of type return_type, and that takes **an unspecified number of parameters** To specify that a function explicitly takes no parameters in C, you would want to add the void parameter ``` return_type foo(void) ```
What do you mean? Certainly not like C++, and if you're talking about vararg's, that's still wrong.
How do I include a .c file, and why is it bad practice?
For one, `__func__` is in the standard, `__FUNCTION__` is not. Also, Strings (even constant strings declared with `[]`) are pointers no matter what, so have your declaration use pointer syntax.
I like using freebsd or osx and using emacs as a text editor. Emacs has a c mode and its very nice. 
Sorry but this is not true at all. In C `return_type foo(void)` and `return_type foo()` is literally the same on the right the left you just make it clear that this is void. Its just more readable See more about this [https://www.gnu.org/software/libc/manual/html\_node/Variadic\-Prototypes.html#Variadic\-Prototypes](https://www.gnu.org/software/libc/manual/html_node/Variadic-Prototypes.html#Variadic-Prototypes)
You write #include&lt;filename.c&gt; And it's bad because you could include the same function definition or declare the same variable several times and it wouldn't show up until you performed the link step to build the executable. 
Thank you for help. I set up everything and I think everything works as intended. I also made tutorial so other people could set it up too: https://www.reddit.com/r/C_Programming/comments/8muc22/mingww64_qtcreator_and_gdb_installation_with/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/cpp] [MinGW-w64, QTCreator and gdb installation with MSYS2. Compiler, debugger and IDE installation for programming in C and C++, 32 and 64-bit code.](https://www.reddit.com/r/cpp/comments/8mudbc/mingww64_qtcreator_and_gdb_installation_with/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Answers to questions: 1. Undefined behaviour, no diagnostic required. 2. Constraint violation. No defined output in either case. 
The C Standard specifies which variations must be supported, and each implementation's documentation describes any extras that it supports .
I'll be completely honest, I am a relatively new C programmer and I program on Linux and abandoned the prospect of compiling stuff on Windows long ago because it looked like there were too many downsides and workarounds and the like, so I have no idea what is going on here, but it looks beautiful.
Thank you :)
The problem was that I needed good IDE with a debugger and a compiler that I can use to program in C 64 bit code on Windows. QT has one of the best free IDE but official version only supports compiling 32 bit code. I searched for other options and OldWolf2 suggested to use MSYS2 which uses 64 bit tools with QT IDE. I was trying to install everything for several days and with help of other people finally did. I thought that my work may be useful for others too and made this tutorial.
Step 1: You install Visual Studio. Step 2: There is no step 2.
sure...will notify you once I made the changes
That doesn't work out very well if you're interested in writing C.
The C support is actually pretty descent these days.
Have a look at cgdb. It’s gdb with a wrapper for displaying code automatically as you debug. Very handy addition to gdb.
Better than it was sure, but still a long ways from C99, much less decent C11 support. To be fair, some of the issues come from their libc, not the compiler, and thus impact mingw compilers too. printf and friends in particular are a steaming mess of non conformance.
VS has crap GUI support unless you want to target dotnet. 
For tools follow r/cpp I recommend getting familiar with clang tools and your development platform (vim emacs eclipse, what you want to use). I strongly advice to start with the bare minimum (compiler editor and debuger) and then adding stuff in little steps over time.
Fwiw if you're using mingw anyway, you can cross-compile your windows build from linux. It will produce an exe that runs on windows. No idea how hard it would be to integrate Qt into this process but it could be useful. I use it e.g. for automated testing.
Oh, cool. I made this asteroids clone and I want to be able to distribute binaries, but first I would need to be able to build it for windows as well as on linux, so this is very helpful. Thanks!
Okay, so what would happen if you would call the C version of the function with parameters? Are they just ignored, or is there some way to use them. I do know there is a way to have variable arguments, I am just interested in the behaviour.
Just curious, what do you mean by &gt; Write test cases to be run with Valgrind. I have only used valgrind for checking memory leaks and related issues, but was not aware valgrind has further use. Could you elaborate?
I have no experience with a lot of IDE's (which is what you're looking for). Maybe you would want to use Virtual Studio, but that's only available on windows. Another option is CLion, I have not used that particular IDE but used the Java version (intelliJ) which was pretty good. Personally, I learned C in Geany, which is a very light weight IDE, but that might be nice. I always compiled using the command line (gcc compiler).
The `vimrc_example.vim` is a good starting point. It should be located somewhere in your installation path.
It would compile. I'm not positive that there's a way to use the parameters without using a Calistoga, but it would compile
Also, since you're a beginner you can also try other IDEs or text editors, I personally like using VS Code
Thank You but i want something that is readily available everywhere. Is learning VIm worth it ?
Sorry but i can't find it :\(
Well that's more or less what I meant as well. I was imagining writing a library, so you initially can't use Valgrind to test it because it isn't an executable. So you must write a test program that uses the library functions to check the Valgrind analysis.
My two cents -- I learned vim when starting working full-time, having used it in a non-productive way (always in insert mode) for a while before that. Now that navigating and editing text using Vim is second nature, using a normal editor seems really lame. The most important resources that opened my eyes on how to use Vim correctly was http://www.viemu.com/a-why-vi-vim.html . Another good article was http://moolenaar.net/habits.html was also pretty good. Other than that, I simply picked up the occasions where I wondered if there was a more effective way of doing what I'm currently doing, googled, and made a habit of the more effective workflows. And to answer your original question, my vimrc was based on this: https://web.archive.org/web/20120922052549/http://www.derekwyatt.org/vim/the-vimrc-file/the-absolute-bare-minimum (original link no longer exists). After that, I extended it whenever needed. Nowadays I use an IDE, Pycharm from Jetbrains, which is basically a reskinned IntelliJ IDEA (CLion would be the C version of the same IDE). At least for Python, Java and web dev, an IDE brings multiple cool features that were missing on bare Vim. I kinda regret on not making the leap to using an IDE earlier, although I also appreciated the simplicity of the bare Vim UI. Luckily, there's a nice Vim plugin for Pycharm (and basically every other IDE), so I didn't have to give up on my 1337 text editing skillz :) . If you're just learning to code, I don't know if mixing learning Vim into it is a good idea, since it has a pretty steep learning curve. But in my case, I still think it was a worthwhile investment.
I would start with an empty vimrc.. You can have a look at mine if you want https://raw.githubusercontent.com/he4d/dotfiles/master/common/.vimrc This is all i use for c programming
Install Visual Studio, and use it as the compiler for Qt. Use Qt Creator for the IDE. 
That works too. You also have to install the Windows SDK in that case in order to have a debugger in Qt Creator (though the debugger in VS is far superior).
Ah okay, thanks for the clarification
Yes. It worth every second you invest on it.
If you have a function declared as taking an unspecified number of parameters and call it using a different number (or types) of arguments than what it's defined as taking, it's undefined behavior. 
If you are student get CLion. You will be a lot more productive and have better profiling/debugging tools. I use Vim when I have to and that is not very often, mainly when I need to make a quick edit on a remote machine or need to produce a bash script quickly. 
Vim is an editor, so you add in the settings that you think will work with your programming style. Personally I just use: set ai syntax off set ts = 4 highlight OverLength ctermbg=red ctermfg=white guibg=#592929 match OverLength /\%81v.\+/ Turn syntax highlighting off, (or leave it on and add a theme you like). Preferences for auto indent and tab/space settings. And then highlight any code over 80 characters on a single line.
Quick answer \- not. For embedded I know only MISRA C:2012, because CERT C is more about general security stuff. May be try to use open\-source tools modern tools like clang \(\-Wall \-Wextra\), clang tidy, clang analyzer and also cppchecker.
If you're concerned about correctness I'd try ubsan \(\-fsanitize=undefined\), dynamic checking with asan or valgrind, and and tests with great code coverage to run with them. Static and syntax checks aren't going to find much.
Yep, and fuzzy checking for console tools as well ;\)
I've worked at a company that followed such a standard (not MISRA, but similar) and frankly, the result is less readable and maintainable, not more. The most obvious drawback is that the requirement for single exit points leads to deep nesting and the use of hard-to-track state variables. I have a feeling that they were written for the benefit of primitive static analysis tools rather than human readers. Modern static analyzers (including clang and gcc with warnings turned up to 11) deal with forward `goto`s, multiple block and function exit points, complex conditions etc. effortlessly.
The C standard itself has a similar price tag, yet you seem to be fine programming in C. 
Thanks for your answer. This is an exercise to show how setjmp can be used in error handling. I'm really struggling to understand it, since it is strongly nested/interleaved.
I guess I'd read the reference: setjmp() Macro *crv-setjmp* -------------- Synopsis~ $#include &lt;setjmp.h&gt;$ $int setjmp(jmp_buf state);$ Return~ 0: if normally executed !=0: value passed to$longjmp()$ Description~ When called normally,$setjmp()$stores information about the execution state of the program in$state$and returns zero. If$longjmp()$is later used to perform a nonlocal exit to this state,$setjmp()$returns a nonzero value. Calls to$setjmp()$are safe in only the following contexts: - As the test expression of a selection or iteration statement (such as$if,$ $switch$, or$while$). - As one operand of a equality or comparison operator that appears as the test expression of a selection or iteration statement. The other operand must be an integer constant expression. - As the operand of a unary ! operator, that appears as the test expression of a selection or iteration statement. - By itself as an expression statement. Return points are valid only during the dynamic extent of the function that called$setjmp()$to establish them. If returned via$longjmp()$to a return point that was established in a function that has already returned, unpredictable and disastrous things are likely to happen. longjmp() Function *crv-longjmp* ------------------ Synopsis~ $#include &lt;setjmp.h&gt;$ $void longjmp(jmp_buf state, int value);$ Return~ none Description~ This function restores current execution to the state saved in$state$, and continues execution from the call to$setjmp()$that established that return point. Returning from$setjmp()$by means of$longjmp()$returns the value argument that was passed to$longjmp()$, rather than 0. (But if value is given as 0, setjmp returns 1). 
PS: If you don't yet have an easy way to look up doccumentation, get one. I have it set up so I can look up the reference for whatever word my cursor is on - it's really useful when you're reading gobbledegook. 
&gt; The ternary operator (?) means it either returns a random nuber &lt; RAND_MAX-RAND_MAX/100, or it evaluates to 0x00100010. Not exactly. This generates a random number, if that number falls within the top 1% of possible random numbers then it sets `x=0x00100010`, otherwise it leaves x as is. It looks like it's meant to simulate a 1% chance that various values could be changed arbitrarily in order to trigger the `setjmp()` and `longjmp()` exception mechanism. Just throwing my two cents in: this is a bad way to teach someone how this mechanism could be used. In my opinion exercises should lean in favor of determinism, to show students how things work in predetermined scenarios. This has some examples where an exception may never be thrown simply because of chance.
I wonder if formal methods would result in an improved system safety. I can imagine manual audits \(like in the case of your company\) would become infeasible with increasing code size and system complexity and they are still prone to human error. Anyway, just to use the opportunity: Do you have any tips on what I could do while I'm still at University? I'm considering Embedded as one possible field I would like to enter after getting my CS degree. How important is Electrical Engineering knowledge?
I worked for a small company that designed Automotive ECU's, and wrote and maintained our own Simulink Library for programing said ecu's. All of our C code was MISRA compliant. We frequently worked on ASIL D projects.
A similar thought crossed my mind. 
The delim project works well, my only suggestion would be to comment the lib files for both .h and .c
&gt; (I don't know if `nproc` is available on macOS.) I think one can use: sysctl -n machdep.cpu.core_count
I think the 'hidden' options is worth using; `$ vim +":help 'hidden'"`: *'hidden'* *'hid'* *'nohidden'* *'nohid'* 'hidden' 'hid' boolean (default off) global {not in Vi} When off a buffer is unloaded when it is |abandon|ed. When on a buffer becomes hidden when it is |abandon|ed. If the buffer is still displayed in another window, it does not become hidden, of course. The commands that move through the buffer list sometimes make a buffer hidden although the 'hidden' option is off: When the buffer is modified, 'autowrite' is off or writing is not possible, and the '!' flag was used. See also |windows.txt|. To only make one buffer hidden use the 'bufhidden' option. This option is set for one command with ":hide {command}" |:hide|. WARNING: It's easy to forget that you have changes in hidden buffers. Think twice when using ":q!" or ":qa!". 
it seems unusual to me that you don't have any optimization flags set in the Makefile. Any reason?
This is true, and I think it's a bit of a shame, but I'm not going to change my pick of language because of this.
Learning vim is absolutely worth it. That said, I still is VSCode (with the vim plugin) on most platforms, because it's easier to install/configure. Then on my cloud hosted servers, I use tmux and vim.
Sure
Since this might be very useful to new subscribers of this subreddit and it's been a few years since this was posted here.
cout? That suggests you're using C++, not C...
Yeah, I accidentally included the extra star, thanks for that. Unless I'm missing something, don't you have to run the program by referring to its path anyways? Even if you link it in /bin, it'll still get passed its own path as argv[0].
I do not know for certain, however I would guess the following happens if you have your executable (named my_program) in a `/bin` directory: You run the program with: `my_program` Because `my_program` is literally the first argument specified, this is what argv[0] will be. Again, this is purely speculation. Maybe bash has some underlying behaviour where it runs the program with the path specified. I don't know. Only way to know for sure is to try :)
Some research into the exec syscall says it's possible to run a proccess and specify anything you want as the first arg. TIL.
Dennis Ritchie was not really involved all that much in the standardisation process. The latest version of C being related to Ritchie's death is wrong, too. The C committee is still at it, the next standard might be released later this year, but don't count on it. A language standard (or rather, any sort of specification at all) is very important for the future development of a programming language because it gives people who want to build their own implementations of the programming language a clear description of how their implement it. Without a specification, building your own implementation of a language is a lot of guesswork and many incompatibilities crop up with no easy way to tell who is right. That's not productive for a professional programming language. 
A modern version would be handy... No kidding. To refresh myself, I started with 1.1 and although its statements about guaranteed sizes of built\-in types is useful information, it's too old to know about [stdint.h](http://en.cppreference.com/w/c/types/integer).
1. My guess is for portability reasons. The growing ecosystem and the need to make things work across platforms likely drove the standardization efforts, especially when it comes to the C standard library. Python, on the other hand, is portable by design since the interpreter abstracts the underlying layer. 2. You assume DMR was some kind of "boss" of C. He was not. After the language was standardized, it took on a life of its own. Further improvements to the standard are now made by committee. 3. There are some things in C that have not followed modern developments, and which could be standardized. Things like native parallelism, atomics (present in C11) and support for machine models other than the C machine model, like GPUs. In that sense C as it's standardized is not a cutting edge language. But is it holding back Linux development? I'd say not, because C is flexible enough to cover those features with library support (sometimes with a bit of help from inline assembly).
Fun fact: `argv[0]` may even be `NULL`. `argc` can be 0.
&gt; As far as I know, developers of safety-critical embedded systems often don't write (MISRA) C code directly but use i've met zero people who actually do this, despite that i was in that industry for almost ten years
Underrated.
Very good point! No reason at all, totally just forgot to include those in there. Adding now! I mostly use Xcode for development, so that has its' own build flags.
Nobody expects that, though.
Python *is* standardized, just not by the ISO.
Could you give an example of when this happens,
When you call one of the exec functions and don't use the program name as the first element of the arguments being passed to the program you're executing.
http://c-faq.com/style/revtest.html is my favorite
Does it work?
seems to.
In C, unless you have to do it for a class or something, I'd go for bsearch() over writing my own binary search code.
There is clc-wiki.net
You make a similar mistake to the article. Your code isn't a valid declaration. If this is part of a function definition (i.e. followed by `{`) then the C version actually means that the function takes no parameters; however the compiler is not required to warn if you call it and pass parameters. Such a call would be silent undefined behaviour. 
Thanks for taking the time to go through everything!
&gt; Even though it never got updated for C99 There does seem to be several references to C99 in there.
I hope that big C boys comment about it! I am just beginning to learn programming \(C\) and it is rather alarming! 
I would say your solution is ”A way to implement binary search”. Looks good. Although I only ran this in my head so I can’t say for sure if there are edge cases somewhere. Does it find the items at the end and start of the list?
Don't be alarmed, just keep using an old standard and you'll be fine
sizeof( *iptr ) is generally the preferred approach although meaning the same as yours, but sizeof is also a compile time construct so you will never get any runtime errors from it. (I say never but sometime will prove me wrong)
&gt; I say never but sometime will prove me wrong No, you are right. Just remember that it is evaluated by the compiler, not the preprocessor, so you can't do things like `#if sizeof(int) == 4`.
Waiting for other build methods support and open-source licences. :)
You can get open source license already :) for any IDE.
clc as in opencl?
OK then, waiting for Meson/Makefile support. :D
I agree, Yoda conditions were a thing back then but nowadays every mainstream compiler will give a warning
If he needs 4 bytes int I think using stdint.h and int32_t might be useful
I came here to say this.
&gt; (I say never but sometime will prove me wrong) C99 §6.5.3.4 ¶2: &gt; The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand. The result is an integer. If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant. 
The code you have provided should have caused a compiler warning. Did you not see it? Look at the types of your arguments, and look at the types required for the function from the [man page](http://man7.org/linux/man-pages/man3/fread.3.html). `fread` requires a buffer to read into, so you need to provide a pointer, not an (uninitialized) `int`. Try with `&amp;temp`
For some contrast I was never able to learn C effectively until I started learning C. With an IDE (like code blocks), you start up and are given several choices for what kind of project you want to make. Then you get a bunch of bootstrap code that you have no idea how it works. And then you hit "compile and run" and then see some magical command line box appear on the screen. With vim and more specifically the command line, you start with nothing and only add in the text you need. Then you specifically tell gcc to look at the file you created from scratch. And then once you have the a.out file you are able to run it from the command line. Since you're able to see each step of the process it made a lot more sense for me than a IDE that masks the whole process. At least that's from my experience. I've met a lot of interns in person who are generally confused by their school telling them to use an IDE and never really understand what's going on. They catch on really fast and generally seem to enjoy what they are doing a lot more once I get them started with vim / gcc.
Whatever works! An IDE did the trick for me, because I was able to abstract certain concepts until I was ready to learn them — e.g not biting off too much at a time and getting overwhelmed. Also intellisense helped me understand the relationships between various concepts. Then once I got comfortable I’d just bite off another concept. I learned on my own though; it might be different if a professor was force-feeding a workflow on me. 
As well as what /u/dragon_wrangler has said, how has an unsigned int been written to the file? If you're expecting fread to convert from a textual representation in to an unsigned int then you're going to be disappointed.
150 specified UB?
It seems like you are trying to read out of the file but you keep saying "in to" which makes no sense
Sorry into was a poor choice of words, I should have said read 4 bytes from the start of the file.
Thanks for clarifying! 
I think the guy you are responding to was trolling. In any case you should use the latest standard . The newer standards clarify things that were unclear in the older, and introduce new features without breaking old code. The older standards have been withdrawn by ISO. It's not a Python situation where incompatible changes have forked the language.
Still, C11 is barely available everywhere but Desktop/Laptop OS. What redeems it useless! Anyway, it seems that we dont really have a choice. The text talks about new programming languages as Swift...I really, really doubt that Microsoft, Linus and GNU team will change their low-level PL soon. And so wont most big corporations! 
&gt;Still, C11 is barely available everywhere but Desktop/Laptop OS. * Those are very popular platforms. * I use C11 in embedded for my day job. There's an [official gcc port to ARM](https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads) now. 
First, threads aren't free. There is a lot of overhead, not just to create and start the thread, but also to keep track of them all. And you are measuring all of that, instead of just the time it takes for them to complete their tasks. Second, switching between threads is *really* expensive. It's one of the most expensive operations you can do on a computer. So not only does it not make sense to use threads (due to the aforementioned overhead), but it makes even less sense to use 12, because unless your CPU actually has 12 cores, they'll spend most of their time fighting over the CPU. A good rule of thumb for CPU-bound tasks is to start one more thread than the number of cores in your system. For memory- or I/O-bound tasks, you may want to increase that to something like twice the number of cores. Note that this task is neither CPU-bound nor memory-bound; it's insignificant. Depending on your compiler (and compiler settings), `count_to()` might even be reduced to `sum = MAX_SUM`. Third, `sum` is not declared as `volatile`, so technically, your program is invalid. The only reason why you get the correct result is *probably* that your compiler optimizes the loop away as I described above. Making `sum` volatile will make your program correct (or at least, slightly more so than it is now), but slow as molasses, because the compiler won't be able to optimize the loop away, or use a register instead of the actual variable for the duration of the loop, and the CPU cores will spend most of their time arguing over whose cache is correct. And that's just off the top of my head. I'm sure others will point out more mistakes in your code, plus a few in my reply.
Fair and Fair (lmaoooooo)
&gt; if i use a mask with '&amp;', the others will change Not if you use it properly. Show us what you've tried.
To set bits, you bitwise-or with the mask: `x |= 0x7;` To toggle bits, you bitwise-xor with the mask: `x ^= 0x7;` To clear bits, you bitwise-and with the inverse of the mask: `x &amp;= ~0x7;` To test bits, you bitwise-and with the mask: `if ( x &amp; 0x7 )`
thanks a lot
Thanks! Do you know why 1048592/0x00100010 is the alternate value? Seems weird to me. 
x = (( x &gt;&gt; 3 ) &lt;&lt; 3);
You are redefining struct in your main function. Remove the word struct from there for starters.
On windows that would be using visual studio I guess. You can compile and run c programs by simply pressing a button. But be aware: you are always using the ms c++ compiler there, so you might accidentally use c++ features that won't work using other c compilers. Although you can probably use some settings to only allow standard c
If you just want to write simple single file c programs and are comfy with a terminal probably using cygwin which i think comes with gcc. Otherwise you can probably install it.
I'm confused how am I redefining 'results' in main. Aren't I just statically creating a new instance of the structure?
Two hints; Turn on compiler warnings. Why are are you casting `arrTest` to `void *` when `elem` are of type `void **`.
If you go with Visual Studio^1 but don't want to deal with its projects and solutions quite yet, you can run _Developer Command Prompt for VS 2017_ from your start menu and type `cl program.c` to compile a simple program. ^1 Which I would recommend, it's a fine IDE and also has a Clang frontend if you want better C (rather than C++) support.
 gcc -Werror -pedantic test.c -o test I am getting no warnings or errors. If I can arrTest to void ** the result does not differ. newResults-&gt;elem = (void **) arrTest; 
In this line: printf("%d\n", newResults.elem[x]); the expression `newResults.elem[x]` is of type `void *`. In other words, you are iterating along a sequence of _pointers_. On your system, `sizeof(void *)` is probably 8, while `sizeof(int)` is only 4. This cannot possibly do what you want to do. Why do you have `void` pointers in this code at all? Why not just declare your structure as follows? struct results { int *elem; int elemCnt; }; 
element is a void** (pointer to a pointer) but the array name is effectively an int* (pointer to the first element of the array) . Either change element to be a void* or pass the address of the ptr to the first element of the array and change your code to match this extra level of abstraction.
Visual studio is a pretty big program, so I don't see how its the "path of least resistance" to start a c program. The quickest way to compile and run a C program is by terminal, using for example gcc for compiling, and ./name.exe for running. But that can be hard if you haven't used a terminal before. So I'd go with a lightweight IDE. I personally use Codeblocks, but there are many more.
&gt; I am getting no warnings or errors. You should expect a warning on the `printf` line, given the type of the argument (`void *`) does not match the specifier (`%d`). With GCC you need `-Wformat` (or better yet, `-Wall`). `-Werror` does not, itself, turn on any warnings. It just makes whatever warnings that _are_ produced errors instead.
Yes, it's one of the parameters in the Solution to what standard you are compiling. The default is c++, but it can be set to C.
Any answer other than Visual Studio is misguided IMO. Yes it's a pretty sizeable install, but it's handsdown the best C/C++ IDE in existence, and one I routinely return to when I need to do the "hard stuff" in my company's code base.
what about looking at the `/proc/self/exe` symbolic link, which you can resolve using [`readlink`](https://linux.die.net/man/2/readlink) and extract the directory with [`dirname`](https://linux.die.net/man/3/dirname) 
Install WSL, run gcc.
Try adding `-Wall` and `-Wextra`. Quite a few issues are only diagnose when optimizations are turned on, so don't forget to pass `-O2`.
Depends. DevCpp is completely outdated, but embeds MingW in an slim and easy to use way. Big IDEs will embrace and nurse you, with a knife in your throat in case you want to go away. Some Windows colleagues of mine had different problems around paths and libraries that could be solved simply by putting the file in the same folder on my GNU/Linux gcc setup, but they couldn't make Netbeans, VS or Eclipse understand that. So there is a trade-off. The simplest is Cygwin or some kind of WSL with gcc, but then you have to learn to use CLI, so it may not be the easiest right now.
Download MinGW 5Minimal GNU for Windows) or Clang. Clang has nicer error reporting, IMHO. There was a tutorial here on how install the very latest Clang on a 64 bit machine just in the past week. You need a text editor, preferable with syntax highlighting, and a simple way to drop into the command line in the directory your source file is in. And then, run the compiler from the command line, without use of make, or a Makefile. You need just a few command line options. See for example [Walkthrough: Compile a C program on the command line](https://docs.microsoft.com/en-us/cpp/build/walkthrough-compile-a-c-program-on-the-command-line) which shows the steps you can use using Microsoft's compiler, Visual C. GCC and Clang use minus signs single or double) instead of the slash ('/') for Microsof Visual C. Here's [the command line options for Clang](https://clang.llvm.org/docs/ClangCommandLineReference.html); first of all, you'll nee `-o` to give your executable a different name than the standard "a.out". Use of make and a Makefile can come later, when you start to use more than one or a few source files in your project. It'll help to have a basic understanding of the command line for the compiler for when you get problems in Makefiles.
Can't be sure, but my guess is that `LED_LedId` is a typedef'd enum, not unlike `failure_t`, where values therein represent different LEDs on a board (either virtual or physical). `0x00100010` is likely the value for a special LED on the board, or just the LED used to signal an exception for this particular project.
On POSIX, use UTF-8. On Windows use UTF-16, and prepend `//?/`, because that'll increase the max path length to 2^15-1 instead of 2^8-1
I've noticed some intermediate programmers have a hard time distinguishing a specific implementation (or even just cargo cult) from the language itself. They "know" that `x &gt;&gt; 1` is faster than `x / 2`. They "know" that `++x` is more efficient than `x++`. They "know" that `int` is 32 bits in size (or that a 32-bit integer type even exists). Often times, this spills over into not understanding undefined behaviour properly. They "know" that adding 1 onto INT_MAX wraps around to INT_MIN. They "know" that dereferencing a null pointer causes a program to crash. They "know" that casting a `float *` to an `unsigned char *` allows you to manipulate the bit representation of the underlying float. Misunderstanding `const`, `volatile` and `restrict` is also very common. `const` and `volatile` were not defined well (IMHO) and are very easy to get wrong. It doesn't help that C's `const` has almost no similarities at all to C++'s `const`.
Yes you are. That's not the issue. Here is your format string `"%d\n"`. Here is the variable you are printing, `void** elem`. Do you see the mismatch? 
I think the most common are things that are due to always coding on the same computer (or similar architecture). Expectating types to have a given length (int is 32 bits, long is 64 bits) for example. That size can vary depending on the actual architecture, all you get is a minimum. Structure padding is another: when coding it's easy to fall into the fallacy that all fields of a struct are next to each other while in reality there can be quite some gap because of padding. Another common misconception is thinking that C is actually close to what the CPU does. It's not by a long shot. It's closer than, say perl, but modern CPUs don't behave like the computer C describe. A simple yet useless example is that in C numbers are represented in binary (as shown with the results of binary operations such as shifting numbers) regardless of the actual architecture of the CPU. Ternary computers have existed, and had you compiled a C program on those computers shifting would have worked the same because C abstracts the machine away. Knowing that and understanding the differences that arise from that abstraction is important. There are very many corner cases and undefined or implementation defined behaviours in C. It's easy (and good) to say to avoid them, but there the difference between the beginner and the expert is that the later does know what to avoid (since he's very likely been bitten before). Look at https://hackernoon.com/so-you-think-you-know-c-8d4e2cd6f6a6 if you want to laugh a bit, but it's far from being the only cases. Also, I think the most important thing is that experts know that C is hard. Manual memory management is hard. Knowing that tricky language in and out is hard. Working at a low level is hard. It's doable of course, otherwise we woudn't be here, but it's definitely not easy. It takes focus, commitment and sheer will (just seen John Wick again) not to stray off the path that keeps you safe.
That clever code is more important than clever design. 
C is not a high level assembler.
&gt; Another common misconception is thinking that C is actually close to what the CPU does. It's not by a long shot. It's closer than, say perl, but modern CPUs don't behave like the computer C describe. A simple yet useless example is that in C numbers are represented in binary (as shown with the results of binary operations such as shifting numbers) regardless of the actual architecture of the CPU. Ternary computers have existed, and had you compiled a C program on those computers shifting would have worked the same because C abstracts the machine away. Knowing that and understanding the differences that arise from that abstraction is important. &gt; &gt; AFAIK C does not support ternary computers. The numeric representation is explicitly binary. There is some variance allowed in how signed numbers are represented - I believe ones complement and twos complement are both allowed, although I've never seen a real ones complement system. 
I find that beginner programmers think the compiler is their customer. Pro tip: You, revisiting the code in 6 months or 6 years, are the primary customer. Write code that is clear and easy to understand. Don't use stupid "tricks" that are clever if they make the code harder to understand. Add lots of useful comments.
The number of senior engineers who don’t understand volatile is shocking to me. It is commonly used where a fence should be used. At least I’ve got everyone properly using fences now and I think I’ve buried the misuse of volatile. The C vs C++ const is annoying. It’s one specific thing I think C++ is vastly superior, but I’m on the C++ side of preferring to limit the use of macros.
Believing that implementation defined behavior is regular for the language (like 2’s complement)
If you ask me, great programmers understand that it's all about transforming data and understanding what is in memory.
- most return values can be safely ignored - `malloc` rarely fails, `realloc` never fails - pthread is the best way to do multithreading - `while(!feof)` - Typo error can not happen to me 
What's a fence? 
the global standard for C is ANSI C89. later versions of C are mostly for hipsters who dont write important code from a systems or security perspective with a few exceptions i am sure someone will immediately point out in a feeble attempt to try to refute my claim because a lot of intermediate level programmers think they are advanced programmers but they are not. 
https://en.wikipedia.org/wiki/Memory_barrier You can use the C11 atomic types to work with them.
https://en.wikipedia.org/wiki/Memory_barrier Basically, when you're working with multiple processors across multiple caches, you can use a fence instruction to "flush" any pending reads/writes that are sitting around. This will prevent different processors from getting an out of date value. Volatile is often used, incorrectly, to do this because people say "volatile means it always goes out to memory!". That's true, it does, that value is reloaded each time. However, that value might be temporally different between caches -- the value simply hasn't had a chance to make its way through the pipeline. A fence (or memory barrier, whatever, all the same thing) forces the flush of either reads or writes so you can be assured your value is correct. It's really useful if you have variables that you don't need to be atomic because no two writes are ever going to occur, so you save the performance hit of an atomic by using fences. There's lots of use cases for this e.g. let's say you have a variable that's going to be updated across many threads. You don't actually care *what* the value is, only that it's been updated. What you would do is just write to that variable wherever you damned well please. Then, on the rare case where you check it (every few milliseconds), you insert a fence before your read to make sure you have the correct version. It's hand wavey because I can't go into too much detail, but that is an example of a live system.
&gt; The number of senior engineers who don’t understand volatile is shocking to me. Wasn't the consensus that in proper c, there was no well defined meaning to volatile? 
Eh, sort of? If you're interfacing with hardware, you need it. But that's literally the only case, it's otherwise meaningless. https://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c
[About 2's complement](https://www.reddit.com/r/C_Programming/comments/8f9y6z/not_only_is_the_c_standards_committee_happy_to)...
One of the most amusing things is students who think they “know C” after a one term course at uni, and start wondering what language to learn next. I have been coding in C for about 30 years and yesterday I just learned something new (a quirk regarding the meaning of `int` when defining bit fields). 
Oh wow. That’s interesting 
No C++ const is not superior. You cannot simply say something is const and it will be a true const. This is only possible with read-only memory. C works on bare metal and memory is mapped to regions and these regions need to be accessible in exactly the same way when you cast const away. C guarantees it for you. It won't surprise you when you switch const on and off passing parameters. Then there is this funny construct: const volatile. You can use for memory mapped hardware ports that are read only. Here, you can clearly see why const does not refer to a constant, but just forbids assignment.
Is this like, a good idea? It seems v. confusing. Would have thought it would make more sense to define something like SPECIAL_LED.
You're not wrong, but const implies constant. If the language wanted, they could've introduced some other keyword that meant "forbids assignment". Const is literally short for constant. So yeah, I stand by what I said, but it's a purely philosophical debate -- practically I really don't give a crap :)
I can confirm this. You can know C for 30 years using it intensively, but you always find something new.
I understand your point, but I work too much with bare metal. const suggest "constant variable" (yeah, I know, LOL). And a variable declaration is just allocation of memory, even the underlying memory is constant (ROM). The C linker is responsible to map it to read-only memory having this info or some further hints. If it does not, it's effectively not a constant. Some parts of code still can have a pointer to write to this address. And change the value for someone holding a read-only reference. So you rather need to ask yourself: Do constants really need memory or are constants expressions? That said, if you want a constant, use #define or enum values, whatever is adequate for your specific problem.
Can you elaborate on this? What is the meaning of int when defining a bitfield? 
On the other hand, it's great for single-thread memory-mapped I/O sorts of applications, like interfacing with a coprocessor or I suppose a bus? You don't want the compiler thinking the value of a status register is the same as it was the last time you accessed it, or that just because you issued the same byte over a bus last time as this time that you don't need to write it again.
If the compiler isn't my customer, why is it always complaining at me?
It supports them just fine, it just requires that the behavior of the operations match the spec, which is written to match common hardware instructions on binary computers. &lt;&lt; must multiply the value by 2, mod an appropriate power of 2. &gt;&gt; must divide by 2, and extend the carry bit. You can implement this as one's complement or two's complement, but it must behave like a two's complement binary computer.
&gt; ______ You sure that's enough leading underscores?
I have been compiling in C11 mode using Clang but can’t tell how fully complaint it is
MIN_INT/(-1) causes an exception?
"You could run C code on a ternary computer" does not mean that C code which relies on binary number representation is not correct. C 100% requires that the runtime implement binary numbers. The C standard doesn't require much, but that's one of them. This is like saying C code that relies on non-quantum computers is incorrect because someone could theoretically try to run it. It's just not true. C requires a binary representation of both integers 'ints' and pointers.
The type of a character constant `'a'` is `int`, not `char`.
Still technically correct; there are plenty of esoteric applications that use two's complement, but they're not esoteric for that reason.
I've gotten into arguments with people who insist that VM overcommits never exist, and that checking the return value of malloc is sufficient for any memory related problems. No, you imbecile. The kernel will give you as much memory as you ask for, but it won't crash until you step on the pages.......
You could let users use tilde's and locate files relative to their home directory. Below is some code to expand tilde's in path. The code standard C, but the existence of a `HOME` environment variable pretty much ties you to UNIX. #define PATH_COMPONENT_SEPARATOR '/' static bool GetTildeExpandedPath(const char *path, char expandedPath[static FILENAME_MAX]) { bool result = false; if (path[0] == '~' &amp;&amp; path[1] == PATH_COMPONENT_SEPARATOR) { const char *home = getenv("HOME"); if (home != NULL) { if ((strlen(home) + strlen(path) - 1) &lt; FILENAME_MAX) { strcpy(expandedPath, home); strcat(expandedPath, path + 1); result = true; } else { LOG_ERROR("File path length must be less than %d.", FILENAME_MAX); } } } else { strcpy(expandedPath, path); result = true; } return result; } 
It requires binary _semantics_. That's what I'm saying. It must behave that way. The spec can't really say that a program is incorrect if it has exactly the same behavior. They don't really care if you have to emulate a binary environment or use suboptimal instructions. It's designed to match an idealized version of the semantics of most modern computers, but if bitwise xor translates to ternary instructions that have the same behavior, and so on and so forth, then the behavior of the resultant program is correct.
Lol gcc 4.5, we're at 7.3 already. Update your toolchain!
8.1 is the most recent gcc version.
I've pretty much gotten over caring about the return value of malloc. I just wrap it in a function that abort()s if it gets a bad value. It's just not worth the time spent working around it since it's so unlikely unless you're doing weird custom allocators for some special use case. If you run out of memory, the OS will kill your process. The only way to deal with it is to make your process robust to being able to be killed anytime, anywhere, and be able to recover smoothly.
&gt; Structure padding is another: when coding it's easy to fall into the fallacy that all fields of a struct are next to each other while in reality there can be quite some gap because of padding. This burned me for a long time at one point because I understood a processor would make sure every word was aligned, but I didn't realize that every long had to be aligned on an even word address. I couldn't understand for the life of me why the massive union (in legacy code) was working fine when I addressed it one way, but when I addressed it another, it came out all garbled.
I'm not sure I understand this. IME, "clever code" is terrible (most of the time). I don't want it to be clever. I want it to be readable and maintainable. If it is clever, it needs a lot of comments to make it clear. However, IME, comments almost inevitably go stale, so if your code is more comments than instructions, then you are doing something wrong. IMO, clever needs to be reserved for only where absolutely necessary, both at the design and code level.
Most of the posts can be summarized as “not understanding unspecified, undefined and implementation defined behavior, followed by a small subset of different aspects of the language that fall into those categories.” Most languages have these but C rose to prominence in a narrow window where we went from data center machines at hundreds of dollars per CPU hour to a wide variety of OS and CPU combinations and C had the standardization that Pascal lacked and the simplicity that the likes of PL/1 and Ada lacked (along with “long int” that was a unique piece in writing useful code on small systems) which allowed it to play across all those new systems. Most of those have died along with too many great ideas and it’s P64 Windows or LP64 POSIX on little endian hardware now. Most C code bases like those written in those other languages will become non-portable over time as a result. Beyond the language there are basic software skills (functional decomposition, refactoring, API design and compliance, input verification, error handling, naming, any means of tracking to know when to free resources, etc...) which just aren’t there in much of the C community because it slowly chokes but rarely kills programs (as in “program management,” not “software program.”) Screw these up on a big C++ program and wave as you pass the empty buildings where your company used to be. I don’t see “strict aliasing” as I scan through the posts but that may make most C incorrect if read strictly. I don’t have the link handy but there are presentations on optimization related problems as well as commentary on the design and coding of OpenSSL and other such libraries which will help you see where things can go really wrong. I’ll just add “use unions for passing opaque data instead of casting ints to pointers or pointers to ints” the lack of which has caused no end to problems on 64-bit machines. Finally, I don’t expect an eidetic memory of the extreme esoterica or even to be able to divine such esoterica without help from a larger community, but if you can’t answer “what is ISO 9899?” in a C developer interview as 99% of those I’ve worked with can’t you really need to choose a different career path.
Yes and no. This value likely does have its own symbol within the `LED_LedId` enum. However, using that symbol means that, in the 1% of cases where it sets the value, `LIGHTSABER` is expecting an `x` of type `LED_LedId`. Without explicit casts, this could cause problems for instance in `void wait(unsigned int time)` where the macro operates on an `unsigned int` or in `void set_led(LED_LedId, bool)` where it operates on a `bool`. Even if a cast isn't necessary, using a typed symbol is somewhat disingenuous, when the macro is being used on `x` values of various types. By using an integer constant expression one can safely assume `LIGHTSABER` is used on variables that can be represented as ICEs, whereas using `SPECIAL_LED` (for lack of a better name) implies that the macro should only be used on `LED_LedId` variables. Beyond that, `LIGHTSABER` is the only place where I can see this value being used in OP's code snippet. If `0x00100010` were used to serve multiple purposes throughout, then I would agree that it would be worthwhile to `#define SPECIAL_LED 0x00100010`, but since the value is only used once, it's not overly necessary. That being said, it's still definitely worth a single line comment to explain the significance of `0x00100010` as a value. So, while I'd say this can be an elegant way to sidestep some practical challenges, and can even be used to help self-document, there's still at least *something* that I think could be done to make this clearer. Hope that helps.
As long as you check the value. The reason to check for malloc is not to handle it gracefully but to prevent dereference later. You may argue that it will crash anyway when you dereference the nullptr later, but if you do something like `possiblyNull[LARGE_NUMBER] you may overwrite data
On x86, yes. This exception is translated into a `SIGFPE` on Unix-like systems. In general, `INT_MIN/-1` is undefined behaviour.
Thanks, I forgot it was INT_MIN instead of MIN_INT. I pretty much use unsigned.
What you're saying is COMPLETELY useless though. Yes, you could emulate the C runtime on a computer that is entirely foreign to it, but as a programmer that should not concern you at all - it's useless to theorize about. 
How often do you think it _actually_ returns NULL, on modern systems? Even on embedded systems, the failure case is usually a page fault when you attempt to access the memory, not when you allocate it. Yes, you can turn off VM overcommits, and then it _might_ return NULL at malloc. You could also use calloc, which should, theoretically, zero the pages and allocate them, but even that isn't 100%. I've never once seen malloc return NULL. That doesn't mean you shouldn't check for it, but it does mean you should consider that it's not the only failure case. In memory constrained systems, it's better to just not use malloc() at all if you can avoid it. 
I don't think recalling, off the top of your head, what "ISO 9899" is makes you a good developer. If you said "What's a few major differences between C99 and C89", that's much more useful. It's like saying someone's a bad network developer because they can't tell you offhand which RFC defines the TCP protocol. It's trivial knowledge, easy to look up, and tells you absolutely nothing useful about someone's skill. 
I generally prefer one of two options, depending on your situation. The main question is if you need everything to have a consistent interface at the call site. Every function will have the same interface and work the same way. In that case, I like to use `void* (*function_t)(void*)` \(the return type can vary, though\). Alternatively, the call site might support a set of various interfaces. Maybe you have a `switch` on some enum to tell you which interface to use or something like that. In this case, I just use a simple `void*` instead of an actual function pointer, and then cast this back to the function pointer type it actually is. I don't like using the empty parentheses version for this second case, for many reasons.
No, it's very useful. It says, in essence, what you said: as a programmer, I don't have to worry about it.
because as the age long saying goes, the compiler is always right
How would you write code differently if you're assuming it might some day run on a system with 6 states per 'bit' instead of two? You wouldn't. You can't, because C doesn't support 6 states per bit. It explicitly supports two. You should write your code as if it will only ever run on systems for which it was designed.
I'm amazed how you manage to mention “modern computers” and “ternary computers” in the same argument as if one is an instance of the other.
You may need to verify the references, but [Wikipedia](https://en.wikipedia.org/wiki/C99#Implementations) has a table of which compiler implementations are C99 compliant. From the list, if I know correctly, Pelles C is both C11 and C99 compliant. 
&gt; I've never once seen malloc return NULL. `malloc()` returned `NULL` about two dozen times on my FreeBSD box today. This definitely happens.
And is that not useful?
I'm very curious what situations lead to that. 
You probably couldn't find any part of C99 not supported by GCC, except for those parts that belong to libc. The same probably goes for C11. The case is different when you consider libc. glibc essentially supports all of C99 except for a couple cases where it intentionally diverges from all C standards. For example, in glibc [the end-of-file bit isn't sticky](https://wiki.musl-libc.org/functional-differences-from-glibc.html) which makes it non-conforming. There are a number of C libraries that support the non-optional parts of C11, but there's probably no implementation that supports every optional part. For example, most still don't support threads, and I'm not aware of a single implementation of Annex K.
It is explicitly not useful. 
It's not literally the only case. `volatile` is essential when interacting with signal handlers (ISO/IEC 9899:1999 7.14.1.1-5): &gt; If the signal occurs other than as the result of calling the abort or &gt; raise function, the behavior is undefined if the signal handler refers &gt; to any object with static storage duration other than by assigning a &gt; value to an object declared as `volatile sig_atomic_t` […] It's also essential when interacting with long jumps (7.13.2.1-3): &gt; All accessible objects have values, and all other components of the &gt; abstract machine have state, as of the time the `longjmp` function was &gt; called, except that the values of objects of automatic storage &gt; duration that are local to the function containing the invocation of &gt; the corresponding `setjmp` macro **that do not have volatile-qualified &gt; type** and have been changed between the `setjmp` invocation and &gt; `longjmp` call are indeterminate. I've also used it to prevent the compiler from optimizing away unit tests and benchmarks. It's a way to "sink" values without needing to print them out somewhere. 
&gt; They "know" that casting a `float *` to an `unsigned char *` allows you to manipulate the bit representation of the underlying float. Since `unsigned char *` is permitted to alias with anything and there is no `char` trap representation, this is a perfectly valid way to *read* a float's bytes. The only problem with assignments through the `unsigned char *` is that it could create a trap representation, but this [concept is a bit dubious](http://www.cl.cam.ac.uk/~pes20/cerberus/n2091.html).
Running out of memory.
I guess FreeBSD doesn't do VM overcommits, or you have it turned off? I know the default behavior in linux is to overcommit.
That's an interesting philosophy, but I guess you're welcome to it.
Okay, so in what way should you write code differently, as an "advanced" programmer with knowledge of nonexistent ternary systems? 
I certainly did not want to give that impression. It's just that the differences are more subtle with modern architectures that what I'd like to hint in a reddit comment.
I didn't say it did. I said it's explicitly useful to know that you don't need to worry about architectures like that when programming in C, because it's specifically designed to have binary semantics. The information that you never need to consider that possibility is useful information. Do you have a problem with that interpretation? Was this something you wanted to fight about some more?
There is also a page about [gcc's C11 status](https://gcc.gnu.org/wiki/C11Status), which is also "substantially complete".
And that's why ternary computers are such a good example. I re-read the ISO/IEC 9899:2011 to be sure not to say anything stupid. At *no* point does the standard force a binary architecture. Ternary is perfectly fine by the standard's measure. It's optimized for a binary computer though, for example all constants representing the minimum amount of functions to support etc are linked to powers of 2. It is also said that numbers shall be represented within the language in binary which, as I said in the section you quoted, is both perfectly normal and says nothing about the implementation of this representation. If the compiler wants to organize the code never to use the third state of the architecture it can, as inefficient as it may be. This is all very important, not because you might someday find a ternary computer, but because it highlights that C is a language, in other word an interface to CPU features, but it should never ever be confused with its implementation. C abstracts the machine away, and working with numbers assuming they are binary in C is fine because they are defined to be binary in C, which says absolutely nothing about the architecture the code will run on. This feature is important because it gives us guarantees to reason about our programs free from knowing the implementation details of the CPU. As I'm sure you know modern CPUs don't execute instructions sequentially for example. When facing unrelated instructions they do them in parallel, use data pipelines, and when faced with a branch they compute each side then discard the unused one. You generally don't have to know all this to write C, your code is guaranteed to run similarly both on such a CPU and on a simpler one, and that's good. Of course you do sometimes have to consider those effects because all abstractions are leaky to an extent, but that doesn't make the abstraction less useful in the general case.
&gt; For example, in glibc the end-of-file bit isn't sticky[1] which technically makes it non-conforming. This will change in next version of GLibc (2.28). It was kept (for a looong time) for compatibility with older systems from when the standard allowed both behaviours. In C89 the end-of-file indicator and the error indicator were handled the same way. In C99, they added that the end-of-file indicator should be tested for the following reads. Note that the C99 standard specifies the behaviour for `fgetc()` ~~and derivatives~~(^(er... no in fact they did truly not fix *getc* and *getchar* specification...) ) more clearly than C89... but for `fgets()` it does not!
[C99, § 6.3.2.3 ¶ 8](http://port70.net/~nsz/c/c99/n1256.html#6.3.2.3p8): &gt; A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the pointed-to type, the behavior is undefined. So, it doesn't matter what type you use, as long as you cast the pointers back to their original types before calling the functions.
Sorry if I was unclear about this, but my question has less to do with feasibility and more to do with style and best practices.
Yes, apparently when you use `int` as part of a bitfield definition, then it's implementation-defined as to whether this is `signed` or `unsigned` (unlikes normal definitions eleswhere, where `int` on its own is always implicitly `signed`). So if you have: typed struct foo { int x : 1; }; it's implementation-defined as to whether `x` takes on values -1 and 0, or 0 and 1. TL;DR: always used explicitly `signed` or `unsigned` `int`s when defining bitfields. 
when is it sufficient enough to put on a resume
Good to know, thanks! 
Dang, you got me. I originally had it as a different type and then went back and changed it at the last second.
Well if you have any faith in the 10,000-hour rule then that might be 5 years x 50 weeks / year x 40 hours / week to become somewhat “expert”.
FreeBSD can do overcommits, but it's turned off by default. You can use the `vm.overcommit` system control to select the desired behaviour. I tend to disable overcommitment on my Linux boxes, too. I just don't see the point in taking away the ability to see when you run out of memory. Fail early, fail hard. That's how running out of resources should be dealt with.
I think you’re overthinking what volatile actually means. https://www.gnu.org/software/autoconf/manual/autoconf-2.61/html_node/Volatile-Objects.html It really comes down to specific implementation details, but it universally means don’t optimize the accesses out. It doesn’t do much else — the side effect of that meaning is why you use it in signal handlers and the like.
There's not much you can do at that point anyway. The kernel can make sure you don't overwrite the overcommited memory, but it won't keep you from dereferencing a null pointer returned by malloc and potentially overwriting memory. That's why you null check malloc, to make sure you don't overwrite anything, not to recover from it.
Not to sound contradictory, but what would you say is the best way to multithread in C? How does pthreads fall short of your standards? Sorry for not being more knowledgeable here, but I've only ever worked with pthreads for multithreading in C. I've heard good things about the windows multithreading API, but it's less than portable, and I work exclusively in Unix\-like environments.
You seem to have differing definitions of "clever"
C89? Pfft. *Real* C programmers know that the only true standard is K&amp;R first edition
You won’t here an experienced C developer say “what was that book with an &amp; in the title?” even though after nearly three and four decades neither K&amp;R is as relevant as the modern language standard. If someone spend their entire career writing TCP stacks and didn’t even recognize the identifier RFC793 I’d expect problems. Knowing the names doesn’t make one good, but not even recognizing them says they’ve not spent any real time suffering them. People who can’t read standards and interfaces tend to be really bad at writing and conforming to them as well. At the end of the day when you’ve worked on C code bases so bad it takes 5-10 calendar years to port them to a newer version of the same compiler family on the same OS and CPU you develop an understanding of how bad tens of thousands of C developers can be.
thats bullshit
https://en.wikipedia.org/wiki/Tee_(command)
TIL the `restrict` keyword exists. Do you have a good resource for explaining what it does? What I'm finding isn't super clear on what exactly it does, and most examples I'm finding just say to use it for functions with multiple, non-overlapping pointers.
This is why I said I don't understand. To be clear, don't do anything a "clever" way, when there is a tried and true, simple and clear way of doing it. I think this applies both at the design level as it does at the code level.
I don't have a good resource for it, but yes, it's used to clue the compiler in that two pointers are not aliasing each other. For example: void foo(int *x, int *y, size_t n) { for (size_t i = 0; i &lt; n; i++) { x[i] = *y * i; } } In this function, a memory load operation may need to be emitted for `*y` for every iteration. The reason is that, since `x` and `y` have the same types, they may be aliases to each other. I.e., it's possible that y could be a pointer to somewhere inside the array pointer to by x. If that's true, then the `*y` could have been changed by a previous iteration of the loop. If the compiler knows that `x` and `y` are pointer to different regions of memory, it might be able to emit more efficient code. You can signal this with `restrict`: void foo(int * restrict x, int * restrict y, size_t n) { for (size_t i = 0; i &lt; n; i++) { x[i] = *y * i; } } This tells the compiler that `x` is not an alias for any other pointer of type `int *` that is currently in scope (and similarly for `y`). Thus, the compiler is allowed to do a single memory load operation for `*y` before the loop begins, and then never again. (If `x` and `y` do overlap, the behaviour is undefined) The `restrict` keyword's introduction does have some significant consequence: before that, Fortran code was almost always faster than C code when doing scientific/numeric computation. The example function I gave you is quite simple, but if you imagine more complicated functions involving vectors and matrices, maybe you can imagine that the compiler has a lot more leeway with reordering code and hoisting code when it can assume there aren't any aliases in play.
Thanks for the clarification!
The problem isn't compilers per say, but standard libraries. Apple's standard library does not support a lot of stuff from the C11 standard, threads is the obvious choice, but there's other problems too, like char(16|32)_t support.
nah, Clang's support for C11 is pretty good (except for FENV, but that's apparently a PITA to support, and there's talk about how to design it, it's just actually getting the work done that's the problem.)
in C there is no "one true way^TM", do whatever you need with whatever idea you have to solve the problem.
Wow, you really dolearn something new every day! I had no idea that this was the case in C; it is not the case in C++.
Please don't use types with bitfields. All bitfields can be specified with just `signed` or `unsigned` and an explicit size. How bitfields are packed into machine words is implementation defined and `unsigned char name` will result in a different memory layout than `unsigned name:8` depending on alignment. The former will add padding to enforce alignment along byte boundaries. The latter does not. I ran into this at work adapting some legacy C code that exchanged hand coded structures over the wire. This was with an old, but not ancient version of gcc.
Ehhh, comments are for "why," which is something that code can't explain on its own.
You have a stray semicolon after the top of your for-loop: for (i=0;i&lt;5;i++); { Remove it: for (i=0;i&lt;5;i++) {
It would just be: Informe valor 1 do Vetor A: should be? No idea why i gets the value 5? Also does not do a loop, calculates the difference between two numbers and the program stops there, while I have to enter 10 numbers. Edit: Because of the copy paste, the spaces have disappeared, apologies. 
Thanks!
Open Watcom has Annexe K iirc. Visual Studio has it as well but I believe in typical MS fashion it's not fully conforming.
MSVC will assume C if the file extension is .c. You can also set /TC in the project options.
I expect someone to know about the K&amp;R book but don't expect them to know ISO #s or it's ISBN off the top of their head. There are for more important things for a C programmer to know to be good.
It's not because you'll "overwrite something" if you dereference a NULL pointer. It's that dereferencing a NULL pointer is undefined behavior.
Pipes on their own don't support this. You need a program that acts like a T piece. This is done by the standard `tee` command.
Isn’t that just implicit int though ?
Thanks for the response. I think I definitely overthought this, because your response seems totally sensible, while my original post seems less so. Be that as it may, I'm still struggling a bit with the second scenario you describe. Would you mind writing up a short snippet of how you would organize a call site to support multiple interfaces?
My compiler asked to see my manager the other day :(
``` char *buf = malloc(1000000); memset(buf + 500000, 'a', 500000); ``` buf is NULL. Oops... You are right though. It's just that on most implementations, that undefined behaviour would be overwriting the memory. (or failing to do so because the memory is protected, causing a seg fault) My point is that, in contrast to dereferencing a null pointer, trying to access overcommited memory returned by malloc is not undefined behaviour. You shouldn't check for it, nor is there a portable way to do so.
"Clever" code doesn't have to be hacky. Though I believe "elegant" would be a more appropriate term.
&gt; pthread is the best way to do multithreading Could you elaborate on this? Super curious! I have a personal project that uses pthread on *nix and the native thread API on Windows. I thought it was pretty easy setting it up, and I’m at least not aware of any significant performance hit. Project in question: https://github.com/VKoskiv/c-ray
Which OS are we talking about? If Linux: There are lots of options, albeit if you insist on using a single pipe you have to invent a protocol for addressing clients…essentially making a "tee" as suggested in other answers here. I suggest you review all IPC chapters in The Linux Programming Interface (https://nostarch.com/tlpi#content). You should choose the simplest option that fits your use case, IMO that would be just using multiple pipes. Non-exhaustive list of options. * Use **multiple pipes** * Use **shared memory IPC** for your child processes (shm) * You could use **UNIX domain sockets** instead (and perhaps abstract socket addresses). Whenever a client process connects() to your IPC socket, accept() in the main process will return a different file descriptor, and you could send a message multiple times to the socket so that each client process could read once. Instead of sharing one socket, you could also create one socket per child and just submit each message to each of them since you also control fork(). * You could use a **regular network socket** for IPC (TCP or UDP) and just *broadcast* to all connected clients. You could even use multicast. * **POSIX message queues** * You could use **messaging busses like ZeroMQ. 
Omg! Tee stands for ‘T’. Only took me 25 years to learn that. TIL!
That's the big thing, it's up to the implementation. One can disect every detail of the interaction between the Linux memory manager and the glibc malloc, but that doesn't guarantee that those pieces will work that way tommorow, nor even be the ones present.
Spent a few hours trying to chain a tee command between pipes but it won't write to output file using execvp
Do you have any idea why this doesn't work on execvp? It should.. Right? 
I didn't know that about Open Watcom. [It looks like you're right.](http://www.open-std.org/JTC1/sc22/WG14/www/docs/n1967.htm). And, yeah, Visual Studio has a lot of the functions, but only in name. They all have the wrong prototypes and the wrong behavior, nor do they don't provide the right macro definitions. For example, here's `memcpy_s()` in Annex K: errno_t memcpy_s(void *restrict s1, rsize_t s1max, const void *restrict s2, rsize_t n); And the behavior: &gt; Neither `s1` nor `s2` shall be a null pointer. Neither `s1max` nor `n` &gt; shall be greater than `RSIZE_MAX`. `n` shall not be greater than &gt; `s1max`. Copying shall not take place between objects that overlap. &gt; &gt; If there is a runtime-constraint violation, the `memcpy_s` function &gt; stores zeros in the first `s1max` characters of the object pointed to &gt; by `s1` if `s1` is not a null pointer and `s1max` is not greater than &gt; `RSIZE_MAX`. Here's [Visual Studio 2017's version](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-s-wmemcpy-s): errno_t memcpy_s(void *dest, size_t, const void *, size_t); There's no size restriction (e.g. no `RSIZE_MAX`). There's no check for overlap. It allows null pointers when the sizes are zero. When a runtime constraint is violated it calls a platform-specific error handler (e.g. crash by default), though it *does* also zero the destination. 
I don't understand the question. Could you elaborate?
Please show us your code.
My problem with that is that comments are on the scale of code, so very often that advice gets used for trying to explain the "why" of very low-level details which actually can be read from the code. You see, code *is* documentation, but it's bottom-up, explaining what it is by telling you atoms. Natural words are top-down, telling you the larger structure and what necessitates it. Lines of code are the details, and specifications are the face they make up. The problem with the philosophy of "self-documenting" code is that while it's possible for code to be well-enough written and organized to stand its own, it ends up being incredibly costly, with large endeavors either failing to finish or failing to be maintainable. The problem comes in that by way of symmetry, natural words can fail this same way. They work *spectacularly* in large granularity, being able to clear up the picture of a project with even fairly bare descriptions and specifications; but as you meld them closer and closer to the code, even well-written words of intent fall to the same trap of duplicity as the well known `/* Add 1 to i */`, incurring the large issue of cost of writing every detail of code in two languages. In a concrete example, I can tell you about chunks of wood sealed with wax, then explain that's to keep it water resistant. The problem comes in that this hints that I certainly might be a shipwright, but it doesn't tell you that I'm actually building a hot-tub. There's plenty of room for comments in a source file to fill that medium area between code and specification, you just don't start by putting words in the body of functions -- documenting the "why" lets you rewrite bad or obsolete code, but you don't rewrite code line-by-line in the function bodies. You throw out groups of functions at a time, so start the layer above that. Start with a descriptions at the module layer; in `lex.c`/`lex.h` you put in a big-ass comment up top saying the role of the lexer, filling in what language it's tokenizing, and give a brief on how you decided to implement it. Move onto documenting the individual functions the same way, with a big-ass comment at the top saying what part they play and how they are used. Don't move into the functions, forget finer-grain comments that don't explain oddities (non-idiomatic code) and open up another file and describe how the lexer interacts with the other modules.
&gt; big ass-comment *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
Used "tee - a temp" between pipe commands.. Works on bash.. But not in my program
Can you show us your code? Otherwise, I can't tell what the problem is.
I didn’t know QuickTime Player is still available on Windows.
The compiler is hired labor and you're not paying it enough to put up with your shit.
Not home write now... Was just testing to insert pipes between commands.. And output works fine, but not a single byte is written to temp file
Again: I have no idea what exactly you did and your description is very vague. Without seeing your code, there is little chance I can help you.
Thanks - really interesting post! Honestly, posts like this are extremely helpful - I'm learning programming outside of university/industry, so while I have a lot of access to technical/theoretical information, insight from direct experience is really hard to come by. 
"array of function pointers" is too vague. there are 3 basic paradigms: 1. static interface \-\&gt; create a struct with the proper types. 2. dynamic \-\&gt; branch on \`condition\` where each path type\-casts the function pointer to the proper type. 3. callbacks \-\&gt; pass a pointer to a "context" struct as the only arg \(all functions have the same type\) Called function type\-casts the context struct to its specific proper type. The call returns generic pass/fail. Special return values may be stored into the context struct.
Subscribe my Youtube Channel
Assuming VM Overcommits are turned on, there's no reason this code will necessarily crash. You don't know that malloc will return NULL. That's why checking the return value is not sufficient.
C and C++ are different languages. This is not relevant here.
I misspoke slightly, it's been a while since I've done this. You shouldn't cast a function pointer to `void*`. Here's two ways of implementing what I suggested. There's no function pointer equivalent to `void*`, but you can freely cast between function pointers. So I'll use `void(*)()` as an equivalent. That gives code like this: void foo(int i) { printf("%d\n", i); } void bar(double d) { printf("%f\n", d); } typedef enum { INT, DOUBLE } func_type; typedef void (*void_func_ptr)(); void baz(func_type type, void_func_ptr f, void* arg) { switch ( type ) { case INT: ((void(*)(int))f)(*(int*)arg); break; case DOUBLE: ((void(*)(double))f)(*(double*)arg); break; } } int main() { int i = 42; double d = 3.141; baz(INT, (void_func_ptr)foo, &amp;i); baz(DOUBLE, (void_func_ptr)bar, &amp;d); } Alternatively, you could use a `union`, but the concept is similar. I've even made this into a tagged struct: typedef struct { func_type type; union { void (*f_i)(int); void (*f_d)(double); }; } func; void baz(func f, void* arg) { switch ( f.type ) { case INT: f.f_i(*(int*)arg); break; case DOUBLE: f.f_d(*(double*)arg); break; } } int main() { int i = 42; double d = 3.141; func f1 = { INT, {.f_i = foo} }; func f2 = { DOUBLE, {.f_d = bar} }; baz(f1, &amp;i); baz(f2, &amp;d); }
It is sufficient for making sure your program doesn't do anything dangerous. Overcommits aren't dangerous, writing to the result of malloc without a null check is.
I agree that it's too wordy. Few will read it. The reference to the SO example format is terrific. A mention of using your runtime debugger might be a good addition.
I like this idea a lot! I agree with everyone that it seems a little bit wordy. I revised the original post a little bit. Hope this is helpful: **Title: What to do when your program doesn’t work** Please read this post if you are about to ask for help with getting your program working. You are here because: * Your code doesn’t compile * Your code doesn't do what you want it to do. **Before posting**, *try searching the web for instructions on how to enable compiler warnings for your compiler*. Turn these on and try compiling to see if the warnings help you find the issue. If that doesn't help, read on. The easiest way to get help is to create a [minimal, complete, verifiable example](https://stackoverflow.com/help/mcve) of the problem. The result should be a very small program that illustrates what your problem is. You can build this example from scratch, or copy your code and strip it down by removing code that is not involved in the issue \(unless your program is already *very* small, then just use the whole thing!\). Try to fix the simple example that you've just prepared. If you're still running into trouble, keep it on hand, because you will need to include it with your post so we can help you. **Your post should include:** * A sentence or two about what the problem is. What do you want your code to do? What is it doing? * What have you tried already? Have you tried enabling compiler warnings \(yes\), have you tried using a debugger to step through your code? * Your example code snippet of the problem. You can include it with your post as a **properly formatted code block**, or you can link to a service like pastebin or a github gist where you've uploaded the code snippet. 
Thank you so much. &gt; Why do you want to make this sure? The code is included in my mini project. so that I wanted to make it sure. &gt; What exactly would you like to know in greater detail? For example, which books or articles I should read to figure out what's going on behind compiler. and what I should know to make sure that it works properly. stuffs like that.
Rather than bolding "Before posting", I'd bold the "try searching the web for instructions on how to enable compiler warnings for your compiler" part since it is the main thing in this paragraph. Also, maybe bold "create a minimal, complete, verifiable example of the problem" since that is a core point in this paragraph. Also maybe put "(indent the code with 4 additional spaces)" after "properly formatted code block", since they basically never look at the formatting help anyway. Otherwise it is fine and better than the proposed one.
You and me both, buddy. Glad I could help.
what with all those `dzf_vec_add(&amp;str, "Hello World x")`; Cant that be made in a loop?
But code doesn't much explain why at all. It can't say why it was chosen over another, perhaps more straight-forward method. It can't say why you do things in order A when order B technically also works. *That* is the why that comments answer. It's supposed to be in with the code to answer questions that can't be answered by the code itself. Self-documenting, sure. But never self-explaining. And I certainly agree with you on the broad descriptive aspect of comments. (Though I'd also say large loops or conditionals should have at least some kind of summary) But the problem with another file is, well, it's another file. A file that could very easily get lost 20 years down the line, while the code itself remains in-tact. Just as your development journal for your hot-tub might get lost, but the hot tub is still there.
So why da heck there are people advicing to use c11?
&gt; But code doesn't much explain why at all. It can't say why it was chosen over another, perhaps more straight-forward method. It can't say why you do things in order A when order B technically also works. *That* is the why that comments answer. I agree with this; the issue I think is that a coarser granularity is a much more valuable aspect when the code gets written, primarily because early revisions tend to see whole groups of functions tossed around and thrown away. When rounds of bug-fixes pass through and the code paths become stable and carefully managed, smaller changes need to be more well reasoned and understood, and fine-grain comments are fantastic. I think it's just too much to ask before that, though, and starting from a higher scope helps fix that. &gt; (Though I'd also say large loops or conditionals should have at least some kind of summary) But the problem with another file is, well, it's another file. A file that could very easily get lost 20 years down the line, while the code itself remains in-tact. This reminds me to note that I'm that sort of coder who writes a function every 10 to 20 lines and starts a module every 15 or so functions, so the scale I gave is probably worth re-interpreting. In terms of losing external documentation I don't have much worry, since I keep it in the source tree; though I'll agree that losing documentation *definitely* is a problem when it's separated out.
Thank you! Out of curiosity, is there a reason you perform those casts in that first code snippet? Casting the arguments makes sense, but casting the function pointer seems superfluous to me since the pointer and functions all share a return type, and the empty parentheses should allow you to pass whatever arguments you want so long as they're typed properly.
&gt; so long as they're typed properly. There's the first reason right there. Without the cast you don't get any type checking. The second reason is that an empty parameter list is considered to be an obsolete feature in C. Supposedly it'll be deprecated and removed eventually. I doubt it will be removed from the language any time soon (since they haven't done that in the last 46 years). Honestly, I should have added the extra `void` to that typedef to make it explicit. And third, and most importantly ... C does something more interesting than you might to a function with an empty parameter list. Try running the following: #include &lt;stdio.h&gt; void bar(float f) { printf("%f\n", f); } typedef void (*void_func_ptr)(); void baz(void_func_ptr f, float arg) { f(arg); } int main() { float f = 3.141f; baz((void_func_ptr)bar, f); } This looks like it should work, right? Well, it doesn't. Now change everything `float` to `double` and it works. What's going on here? When there's an empty parameter list, that doesn't exactly mean "anything could be passed here." At the call site, [arguments are promoted](http://en.cppreference.com/w/c/language/conversion#Default_argument_promotions) before being passed in: `short` is promoted to `int` and `float` is promoted to `double`, for example. So even though `arg` is a `float`, in reality a `double` is being provided as an argument. But `bar` is actually expecting a `float` ... so bad things happen. (The same thing happens with variadic functions: the `f` argument to `printf` in that example is being promoted to `double` before the call, and that's what `%f` is expecting.) We don't get an error here because of the casting, but if we had tried to create a prototype for `bar` with an empty parameter list we would have gotten an error. There is no error if its argument is a `double`. Instead, we're invoking undefined behavior since `void_func_ptr` is not a valid prototype for a function with a `float` argument -- we can cast to this, but we have to cast back to what it *really* is before calling the function.
Why do you have no intention to learn modern C++?
https://www.reddit.com/r/cpp/comments/8mp7in/bjarne_stroustrup_remember_the_vasa/
Do you think Bjarne feels modern C++ is a lesser language to C++98 or C99? I can see absolutely no reason to write C++98 in 2018. 
Nice article! The author succinctly summarises many good arguments, much better than I was able to.
Well, I'd say with so many functions that comments take on a new life as a sort of bread trail, as it becomes something of a jungle of calls at that point, which is difficult to navigate.
cool post, thanks.
I'm not the author so I couldn't tell you.
Seems fair
No, he stated the opposite: it's a greater language, a much greater language, and that's the issue.
Surprisingly, it's not that hard to keep straight, since instead of being woven together you tend to get a structure of layers. It's not to say that they can't get messed up, but it's revealing to say that I never have to use forward declarations because of it. For example, I mentioned `lex.c`/`lex.h` earlier since I'm actually in the process of writing a hobby assembler. The current body of the module is 12 functions in 183 lines, but it all nicely splits out into I/O, pattern-matching, and public interface. I/O handles incoming characters, the buffer they get saved to, and knowing their position (row and column) in the file. Matching knows how to read classes of characters and fit them together into whole lexemes. The public interface initializes all this, then runs an iterating function that fills the buffer with a matched pattern and return its type. Sure, the worst case scenario of 12 functions without forward declarations is 66 paths of interaction, but reasoning about the module as a whole only takes knowing 3 logical groups of them. If the interface calls an I/O function, it's manipulating the buffer; if it calls a matching function, it's reading a pattern. The matching functions call I/O, looking to fill their patterns further. If our lexeme contains junk, blame the matching; if the position information is wrong, blame the I/O; if the lexeme's type doesn't match its contents, blame the interface. In tune with our original subject, something we may agree on: this level of division is certainly a great place for comments, for visually separating out the file into these groups and explaining the sections and interactions. It's a microchosm of the module level, albeit one often taken with different rules of heirarchy.
They can be with snprintf, malloc.
\&gt;I expect someone to know about the K&amp;R book but don't expect them to know ISO #s or it's ISBN off the top of their head. The 1978 K&amp;R \(the standard before the standard,\) ISO, RFC, IS, CCITT, etc... standards are often better known by an identifier other than their title. If your career goal is to write one million linked list implementations in C you probably don't need the standard. If you are going to do something wildly advanced like a copy a sequence of characters with some overlap and you can't read the standard to learn the difference between memcpy and memmove and you don't use any of the many tools that can show you you chose the wrong one you are in the majority of C developers and ruin the world for the rest of us. \&gt;There are for more important things for a C programmer to know to be good. A\) I NEVER said it proved a developer was good in any of my posts and it should have been an easy "exercise for the reader" to figure out you'll need more to know if someone actually is good B\) I COMPLETE AGREED with your first reply with my own text "Knowing the names doesn’t make one good..." C\) The fact that you are still presenting this as a new idea that we somehow disagree about is IRREFUTABLE PROOF that having text in front of you doesn't mean you can comprehend it which is why you need to know more than the fact that the person has the text in front of them It's a heuristic prescreening technique, not the entire interview. I don't end interviews on it but reviewing static analysis and bug reports on the code from the developers hired says it's a good predictor in large scale systems development where everyone will be forced to confront constructs with which they are not entirely familiar. Strong teams not only refer to the standard fairly frequently but provide properly cited references to train each other and everyone eventually learns the identify of the standard by writing those citations and develops skills in how to use it. Weak teams have hundreds of thousands of warnings in each build log and assert "C is easy!" and they "know everything about C!" If the weak were one team or one division or even one company I could say it's not the C culture, but it's not.
What's with the float* and unsigned char* stuff? Is it covered in k&amp;r by any chance?
Interesting...
IMO this is caused by MSVC. They put a fence around volatile variables. It confused the industry because so many people now think volatile implies a fence.
That's not what he's saying really. His point us more about the outstanding proposals and the lack of analysis of how these proposed features would interact.
Please educate me: what does "all data is POD" mean?
POD stands for Plain Old Data. It is the C++ name for types that are C-like. See [more](http://en.cppreference.com/w/cpp/concept/PODType) 
Ah, right. Not the advanced CS concept I was expecting, but it makes a lot of sense :-) Thank you!
Thanks guys. Cygwin's been the simplest option so far.
`*(buf+i)=(char)( (rand()+1) % 255);` will allow zero bytes into buf `strlen(key)` will stop when it hits a zero byte
I'm still confused. Can you clarify?
You'll need yo be a bit more specific with what you're problem is. I don't understand what you need. 
There’s no sidebar on mobile which, I suspect, may be why some of the homework posts get posted here.
My rate is €100 per hour, to be paid in advance. 100% surcharge for URGENT work.
Had no idea that was the going rate for doing someone's homework.
I'm a professional. I don't exactly work for free, though I do give advice for free.
Is there any reason you can't just pass in length like you did for the generation of the char array? If you know the expected length anyway, you don't really need to worry about measuring the length in place? Unless I'm missing something, seems like you're adding an unnecessary step.
`strlen` stops counting when it reaches a '\0', regardless of the size of the buffer. I think /u/aqrit is saying that your original code could put '\0' into the buffer. His suggestion is to not use `strlen` for your loop condition since it won't always be the buffer size. 
Test is never assigned a value.
&gt; "C is easy!" and they "know everything about C!" I inherently distrust anybody who says this about _anything_, let alone something as complicated as C. &gt; I don't end interviews on it but reviewing static analysis and bug reports on the code from the developers hired says it's a good predictor in large scale systems development where everyone will be forced to confront constructs with which they are not entirely familiar. While I think that this probably holds true to some degree, I think correlation does not equate causation in this case. It seems equally likely to me that such a question would be very important simply for weeding out the type of people who won't admit they don't know something. Essentially, I feel there is a large difference between remembering the exact number of any given ISO/RFC/etc. and being the type of person who plainly ignores the importance of them and who is unable to process them in a meaningful way that leads to remembering their contents. &gt; Strong teams not only refer to the standard fairly frequently but provide properly cited references to train each other and everyone eventually learns the identify of the standard by writing those citations and develops skills in how to use it. This is completely different than "cite the RFC number for TCP off the top of your head", which is what your original posts came across as, hence the replies given. I can easily not remember the number, then look it up before starting my work to ensure I have the reference material and correct number required for writing the best code and documentation I can. If anything "provide properly cited references to train each other" would imply that they _can't_ recite random reference numbers, and that it is OK to not be able to because that is not the most important part of comprehending them.
Char ch []= "AB $C" is the given string . The output should look like CA $B . It is related with string manipulation ig
but what is the changing pattern here? bring the char after $ to the front and shift the others? is ' $C' always at the end?
Side note: It looks like you are doing cryptography. By eliminating 0 from keys you could be compromising security (unless you know exactly what you are doing). Also, if someone else where to take over or collaborate on your code, you would have to make sure they are educated on the limitations of your function. These types of ”fixes”, where you don’t directly address the problem at hand could leas to serious consequences in the future. Do what has already been suggested, fix your buf length size comparison.
It could be a pre increment vs post increment problem. Try \+\+i instead of i\+\+
SEEMS CHEAP..... SHOUTING MAKES IT MORE EXPENSIVE...
I'm not sure what you are trying to see here. I tried to run this code and it didn't even crash. Note that as a use after free is undefined behaviour everything can happen, *including nothing*. Modern operating systems / compilers / libc implementations use all kinds of mitigations to make memory errors harder to exploit, so it can be hard to actually see bad things happen in trivial examples. But you can use [valgrind](https://en.wikipedia.org/wiki/Valgrind) to confirm that this is indeed an error.
I have never used EFL, I don't even know what that is. If you want to have a stable and functional toolkit, consider using Motif.
You shouldn't use strlen for buffers that contain things that aren't strings. You should pass in 'keylen', which is the amount of space you allocated for 'key' and 'key2'. Now you don't have to worry about NULL bytes anywhere. str*() functions can only be used with NULL terminated strings.
Stop posting these. Last warning.
I have added you as a moderator so you can add a sticky and/or update the submission guidelines. Let's see if it helps!
Motif is ok but I don't know if it's still being maintained. Even though it is now under LGPL it was a little too late. The API is stable though.
It is not just stable, it is an industry standard with a formal specification and the whole shebang. There isn't really anything to maintain with Motif apart from the occasional bug fix and I think that is done regularly (last release was in December 2017).
PThread is fine for **low level** multi-threading but beginner and intermediate should really avoid it as multi-threading is **Hard**, as with any tool one should probably evaluate the alternative, such as the high level API OpenMP, or Apple's Grand Central Dispatch.
Oh, I didn't find it too difficult to use. If you're more knowledgeable on the subject, I'd love feedback on code quality! Here's what I use pthread for: https://github.com/VKoskiv/c-ray There's #ifdefs to support Windows' proprietary thread API as well!
Looks like you need help with how to ask questions. Provide what you have so far, post code, post the input, post the output and try to describe your thinking and where the problem occurs.
[removed]
I've never used it but apparently they fixed the spank error messages :D [https://git.enlightenment.org/core/efl.git/commit/?id=9a4eedb078bde1ea15d80ba2f285f7d2dc672c10](https://git.enlightenment.org/core/efl.git/commit/?id=9a4eedb078bde1ea15d80ba2f285f7d2dc672c10) Apart from that, judging by the changelogs it looks they are focused on bug fixing so the rant that you posted might still be relevant
pow() is a function that works with doubles. It seems that pow(2, bits_of_long_long_int - 1) cannot be represented exactly as a double, so you have a rounding error.
This is the most horrific code I have witnessed
i am a novice,tell me something more about the horrific part , i will try to do some improve.thx~
I genuinely thought I was on r/WordAvalanches/ for a minute when I opened this thread
Here you go, this will do what you ask for :) #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char ch[] = "AB $C", c, *p; p = ch; c = *(p+1); *(p+1) = *p; *p = c; *p = *(p + strlen(ch) - 1); *(p+strlen(ch) -1) = c; return 0; } 
Why go with such long variable names when it looks like 'biggest', 'bytes', 'bits' would do fine and make it much more readable. So would using int64_t over long long int.
sorry,i just grab a book and page by page for about 50 pages , and English is not my mother language , i will try to cultivate my good habits.thx~
To get used to pointer: Try to implement data structures or build small projects. I recommend the book, Data Structures and Algorithms Made Easy. Data Structures and Algorithmic Puzzles by Karumanchi N. 
Please format code properly so it is readable
emm....i re\-edited again,i posted on phone app,it do not allow me to edit with code format,i\`ll keep it in mind from now on.thx\~
[Mastering Algorithms with C](http://shop.oreilly.com/product/9781565924536.do) It’s a little older (1999) but still very much relevant - kinda like C ;)
This is the exact book you want to master.
I recently completed a Data Structures and Algorithm's course at University and our text book was [Data Structure's, Algorithms, &amp; Software Principles in C](https://www.amazon.ca/Data-Structures-Algorithms-Software-Principles/dp/0201591189). It was a very thick and hearty book. 
Pointers aren't all that deep. It's just a memory address. Data structures can be deep though. 
Data Structures Using C..it’s old but you can probably find it used cheap somewhere 
Thank you very much! adding (long long int) before pow() saved the problem! My the bug be away with you!
Firstly in your 'match\_digest' function the 'return 0;' should be outside the for\(;;\) I will look at other things buy please tell me if that solved your problem. 
I would look at your match_digest function and think about what it means to have a return statement in a for loop. I also can't guarantee that's your issue, but that's the thing that jumps out to me first.
It appears that you have been shadow banned. Please talk to reddit's admins to rectify this issue.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/shittyprogramming] [It's a long long way to the top...](https://www.reddit.com/r/shittyprogramming/comments/8oic94/its_a_long_long_way_to_the_top/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
My slightly abbreviated version of the sticky. Cut elements have been ~~crossed~~ out, additions made in (parentheses). Most of my changes are simply wording and cutting back on the volume of text. Most people mindlessly searching for help online won't bother reading a sticky, but they definitely will not read something longer than about 200 words. *** **Title: What to do when your program doesn’t work** ~~Please~~ Read this post if you are about to ask for help (debugging your program) ~~getting your program working~~. ~~Maybe your code doesn’t compile, or perhaps it compiles but it doesn’t do what you want.If your code compiles but doesn’t work as you expect,~~ The most likely quick fix for beginners is to turn on all the compiler warnings for your code, find out what they mean \(e.g. read the manual, search the web\) and fix the problems they identified. If that doesn’t work \(either because you did it and you still have a problem or because there are too many warning messages for this to be feasible\) ~~then you need a smaller example~~; read on. ~~The single most helpful thing you co do, for yourself and for us, is to~~ Take your code \(for example copy it\) and create a [minimal, complete, verifiable example](https://stackoverflow.com/help/mcve) with it. ~~The result should be a very small program which illustrates your problem. People looking for the problem \- including yourself! \- will have less code to look through to find the problem.~~ When creating the minimal, complete, verifiable example, if the code now works, slowly build on it until you get the result you want, testing frequently as you go ~~\(using a version control system, such as git, can make it simpler to rewind your changes\).~~ As soon as the example stops working, take a look at what you just changed.You can get to a [minimal, complete, verifiable example](https://stackoverflow.com/help/mcve) in two ways: 1. Take your existing code and remove the parts that don’t need to be there to demonstrate the problem. This is the easiest approach with small programs \(for example homework problems\). 2. Build an example from scratch. This is the easiest approach for problems you encounter when maintaining a large system. Once you have your example, post it here either as correctly formatted code \(e.g. a “code block” in the Fancy Pants editor\) or as a link to a post on a pastebin site \(e.g. [pastebin itself](https://pastebin.com/)\). *** If it seems like I was a little aggressive cutting text, I was. Not that the text is useless or bad, but nobody posting low effort posts that we see here will take the time to read it. Something a little more digestible will be better IMO. *** **Meta:** * We could perhaps deal specifically with the most common types of problem/solution \(though what are they?\) * `scanf` leaves people in a world of hurt for some reason. * `malloc` and friends can also give people serious headache. * A small snippet on turning on `-Wall` and `-W4` for gcc/clang and MSVC respectively would be useful. * Basic `printf` and friends usage could also help out noobs.
`s[i] = alphanum[rand() % (sizeof(alphanum) -1)]; //` This isn't wrong but had to look at it more than once... Do a `int len = strlen(alphabet);` before the loop and `int pick = rand() % len; s[i] = alphabet[n];` inside. The way it is works because the C standard says a char is of "size 1" and the static array has a null byte at the end, but it looks nicer to do modulo length. `if(hash1[i] == hash2[i]) //` I think you want that to be `for(...) { if(A != B) return false; } return true; /* survived elimination rounds, the gauntlet */` I think this might be the bug you asked about in title. `printf ("%x", rand_hash[i]);` This should be `"%02x%"` otherwise hex values under 0x10 would print as only one hex digit and the print out will be missing a digit each time it happens. Happy hash collision hunting. :)
&gt;This is completely different than "cite the RFC number for TCP off the top of your head", which is what your original posts came across as, hence the replies given. I can easily not remember the number, then look it up before starting my work to ensure I have the reference material and correct number required for writing the best code and documentation I can. The TCP thing was from you, not me. As with the last go round you still can't keep track of what YOU are saying. &gt;If anything "provide properly cited references to train each other" would imply that they can't recite random reference numbers, and that it is OK to not be able to because that is not the most important part of comprehending them. No, it proves they graduated elementary school and know to cite quotations, not just by document identifier but with additional bibliographic information including where in the document to find the quote. It's useful both in longer exchanges between team members (at least one went all the way to the C standards committee which had to go off and figure out what the language should do because the standard had a hole) and when team members or whole teams move onto an existing project where they will have context when they search the archives. The real super-geniuses get messages with a full citation including the standards body on the cover sheet (ISO/IEC,) working group number (9899,) issue year and revision along with document title, section numbers and titles and page numbers with the quoted text properly indented and reply with the citation and expository text elided leaving only the indented text from the actual standard then add "This isn't how C works. &lt;Name&gt;" These are the ones who "can't recite random reference numbers" nor even understand them in context. Teams without these people are far better than teams with them.
I'm surprised nobody has recommended [CLRS](https://en.wikipedia.org/wiki/Introduction_to_Algorithms) yet. It's language agnostic, very in depth, well written, and I see it recommended constantly. One thing that may drive some students away is that it is *dense*. It's worth noting that a solid understanding of pointers is necessary prior to tackling data structures and algorithms. I think a good way to get comfortable with pointers is to recreate containers (vectors, linked lists, dequeues, etc...) similar to the C++ STL. Hope this helps.
We used 'Data Structures in C' by Dr. Reema Thareja.
I was thinking about that random alphabet part. Since you have to do that frequently searching for a hash collision your teacher's use of `size-1` instead of `strlen()` is good if a bit trickier looking... There isn't a *pretty* way I can think of to statically get the length of that string without runtime compute or hard coded constant (which looks bad too if you typo/change the alphabet). Maybe a complicated macro that might crash the compiler... It WOULD be nicer to do modulo length but your teacher is right for the speed aspect.
Don't worry too much about people criticising your code. Don't let it stop you. People too easily forget where they came from.
You're allocating memory for 5 pointers on the "Tree" structures, but not for the structures themselves. You get null when you're inspecting this pointers due to calloc zeroing the memory it has provided you with, thus leaving you with 0 valued pointers. To fix that you have to allocate the memory for structures themselves for each of 5 pointers to point to. Another fix that you may consider is using a pointer to the structure instead of pointer to the pointer to the structure. This way, Tree *children = xcalloc(5, sizeof(Tree)); will provide you with five zeroed "Tree" structures. However, you still have to keep track of the number of trees you have allocated not to accidentally access memory out of allocated borders.
Calloc does do automatic zeroing of course, but sometimes in a lazy manner, but I doubt that would be the issue. Perhaps there's something in how you access or add nodes? You are setting the parent node's child to include the returned newTree, right? Any reason you're not doing that in the makeTreeNode function?
Your answer has made me realise the debugger wasn't saying my pointer was null, but that the thing it *pointed to* was null.. which is actually fine. Then I thought it must be an indexing issue I had accessing the children, which is exactly what it was. Bit of a silly mistake. Thanks for your help!
I know it's not super relevent to C, but as a C programmer who was planning on adopting it at some point, it's relevent.
This makes me sad. I guess if you are going to have acceleration in your code you need to keep up to date on * CUDA (for your high end deployment) * Renderscript (for Android released by Google) * OpenCL (for Android released by Samsung) and if you decide to forgive Apple and want your thing to work on the Mac * Metal Performance Shaders 
Apple made OpenCL, and they just deprecated it as well.
&gt; The TCP thing was from you, not me. As with the last go round you still can't keep track of what YOU are saying. If you're going to be arrogant and snide, at least take the time to _remember_ to go back up to your own post, from which I can directly quote: &gt; If someone spend their entire career writing TCP stacks and didn’t even recognize the identifier RFC793 I’d expect problems. Regardless, the point is _obviously_ not about which specific RFC or ISO number is at play, it was some arbitrary example of _a potential number_. &gt; No, it proves they graduated elementary school and know to cite quotations, not just by document identifier but with additional bibliographic information including where in the document to find the quote. This still has nothing to do with remembering which numbers go with which standard. &gt; when team members or whole teams move onto an existing project where they will have context when they search the archives. Again, nothing to do with remembering specific numbers. It's about having the humility to say "I am unsure of the answer, and therefore must do research", and then having the technical expertise to process the retrieved information in a useful, time-efficient manner that leads to a tangible result in code. Nobody is contesting that knowing why standards exist and which are important is an important skill as a professional. It just seems silly to place emphasis on an identifier when the truly important part of any technical document will be abstractions and architecture knowledge contained within (especially when paired with historical context). None of what you've posted thus far actually substantiates the originally posted interview question (for which I can think of several valid explanations that could be substantiated by data). I was hoping that you'd perhaps expand on what you meant, but instead you've decided it's more important to feel superior than to communicate well.
Deprecating OpenGL, too, and only supporting Metal. As a developer I already essentially operate as if macOS doesn't exist, but I'm still experiencing schadenfreude seeing Apple shoot themselves in the foot, making themselves *even less* relevant in the desktop/laptop space.
Good. Every major gAPI supports computing natively, which automatically makes OpenCL redundant, which is why Kronos has already talked about merging it with Vulkan. And if you rely on these 2, it'll still be there, just frozen.
Does [SPIR-V](https://github.com/KhronosGroup/SPIRV-Cross) look like a suitable solution?
That won't work. Though we can compile opencl kernels to spir-v, we still need opencl loader and device runtime to execute it.
SIPR-V is basically a stable version of LLVM's IR.
How does that work? If I was to use OpenMP to compile a program that had the proper pragmas and whatnot, would the binary be compiled for a specific GPU? Would I have to release to versions of a library to support the integrated and dedicated GPUs in my mac?
Sorry, don't know about that.
shame on Apple. we should do something.
Compiling your code with `gcc -Wall -o calc calc.c`, the compiler complains about the calculation: $ gcc -Wall -o calc calc.c calc.c: In function ‘main’: calc.c:24:37: warning: left-hand operand of comma expression has no effect [-Wunused-value] (a1 + a2 + lab + quiz + exam, &amp;finalMark); ^ calc.c:24:9: warning: statement with no effect [-Wunused-value] (a1 + a2 + lab + quiz + exam, &amp;finalMark); ^ $ Assignment in C has the following syntax: result = a + b + c + d; So, the value you print is the uninitialized value of `finalMark`. Note that local variables will not get initialized to zero in C.
https://web.facebook.com/permalink.php?story_fbid=2146412825593223&amp;id=100006735798590&amp;_rdc=1&amp;_rdr Supposedly Apple were never too keen on OpenGL.
Thank you very much!You are so kind~ that's not a big issue, i can make progress through criticism anyway. May the bug be away from you~
Thank you very much!You are so kind~ that's not a big issue, i can make progress through criticism anyway~ May the bug be away from you~
OpenCL *can* replace CUDA nowadays (at least sometimes), and it's also available on just about any android phone, samsung or not. 
I know it's a repost, I just wanted to share the new link.
Reposts are fine!
I am 100% convinced that Apple is playing a game of how much stupid shit they can get away with and still have people buy their products. It has to be a joke to them.
It would be cool if you had some comments explaining haw your code works.
`finalMark = a1 + a2 + lab + quiz + exam;` The normal way to do assignment in C (both initializers and active code) is with `=`. Sometimes you can use variants like `x += 2;` or `y--;` but `=` is the normal way. That analogy with `scanf()` isn't the typical way code works... And if ever do it that way it's part of a function call not a regular statement. Returning values via a function's reference parameters is one way for C to return multiple values and `scanf()` can return a bunch of values. e.g. int myint; double mydouble; char mybuffer_size128[128]; int sf = scanf("%d %lf %127s", &amp;myint, &amp;mydouble, &amp;mybuffer_size128); // sf == 3 if all three items scanned But those `&amp;`-'s are only involved because a function was being used and only sensible for returning multiple returns.
I'll admit C likes to return error codes and/or auxiliary information (like `scanf()`'s scan success count) because a functions return value isn't required to be assigned to anything. Actually even more popular in C is setting a global variable but that... *ick!* If the error code was done by `result = doSomething(&amp;error);` you would have to add that `&amp;error` reference every darn time... The function might double-check whether you passed `NULL` but you want both code and information transfer by code to be graceful.
Here's the previous discussion for this code: https://www.reddit.com/r/C_Programming/comments/7rzo0a/im_sharing_with_you_a_small_base_64_encoder_and/ 
You're absolutely right, once I'll have some spare time I'll commit more commrnts
Hungarian notation being used? And why so cryptic argument names anyway? Why not names like src_string, dest_string, dest_string max_length? Why embed the type in argument names again? 
&gt; we should do something. Like provide OpenCL/GL as a third party library.
It's amazing how many people *HATE* the fact that there's still support for these things through a third party. It interferes with their circlejerk of hate.
How many APIs have Microsoft introduced and later deprecated? Software changes and evolves, and old methods give away to new ones. There's *nothing* stopping a third party from offering these libraries as an open source package or commercial product.
&gt; I'm still experiencing schadenfreude seeing Apple shoot themselves in the foot It's a little premature to be saying whether or not this is a mistake. &gt;making themselves even less relevant in the desktop/laptop space. Citation?
OpenCL is pretty shit anyways. I absolutely hate writing it. Personally, I'm happy to see it go. 
For the future, try to write the comments before you write the code. That's really helpful for writing good code.
[ Dear Apple, shame on you for deprecating OpenCL ](https://www.reddit.com/r/apple/comments/8oovsa/dear_apple_shame_on_you_for_deprecating_opencl/) and [A complete list of Free/Open\-Source OpenCL implementations](https://www.reddit.com/r/opensource/comments/8oot87/a_complete_list_of_freeopensource_opencl/)
Here are my comments [from a year ago](https://www.reddit.com/r/programming/comments/5ecva4/eskil_steenberg_how_i_program_c/db1b25b/): Slide 25: Pointers and arrays are similar, but are still very different things, and teaching that they are the same is a big mistake that leads to confusion in the future. They tend to look similar but mostly because arrays decay into pointers. Slide 26: Arithmetic on void pointers isn't permitted. Use a char pointer. Slide 27: That's undefined behavior. Slide 37: More undefined behavior. Easy to fix in C99, which the author says is broken. Slide 48: Cool, but undefined behavior. Also, it's no longer fast on current hardware.
The "standard" algorithm is [Boyer-Moore](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm). Implement that in C and start optimizing if you need to. "over 9000!!" isn't a large string to search.
**Boyer–Moore string search algorithm** In computer science, the Boyer–Moore string search algorithm is an efficient string searching algorithm that is the standard benchmark for practical string search literature. It was developed by Robert S. Boyer and J Strother Moore in 1977. The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It doesn't look like Hungarian to me, I haven't specified any types in the variable names. About cryptic names you're right, I'll make them more clear with the next commits.
Over 9000 was just for the joke, I know that ils not large, un fact I work in string composed by 10^9 values...
Thank you a lot, it's very helpful ! :\)
I'm not seeing Hungarian notation, either. Maybe the "b64" prefix looks like a type, instead of its namespace meaning as "base 64"? 
That joke is literally more than ten years old at this point.
I'm somewhat surprised people are suggesting MSVC for a language as simple as C. MSVC is huuuuge. I would suggest getting a Linux Distro from the Windows Store and enable the WSL. Then you can just use bash in the command prompt to get a compiler, text editor, and debugger all in one shot. 
Yep I guess that was the reason.
'extren'? 'controll'? 'acitectectiure'? 'sequencial'? 'ellement'?
pro tips
https://giphy.com/gifs/uncomfortable-flLNWf7E60yfS
I'm really not sure why the author considers C99 "Broken"... I find it to be a great upgrade from C89 with plenty of QoL improvements.
I'm kinda of a noob, how do you program platform independent gpu accelerated code without OpenCL? Are you forced to awkwardly use OpenGL shaders?
[Context](https://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm.git/commit/?h=device-properties)
I wish this wasn't an image. I find Linus' argument interesting -- pragmatism vs technical correctness. Since his complaint seems to be the one-sided nature of the commit message, would he have responded better if the message included GCC's behavior, but that avoiding this type punning is more "future proof" or something? I wonder what Linus would do if GCC for some reason (say, to better implement some feature or correct some bug) decided to change their position on type punning with unions? They would have the authority to do so, given the standard's wording. 
You could, but that's not the point. OpenCL is destined to such end because it shines in scenarios where cross-platform is relevant and/or you don't have a Nvidia GPU, which in reality, it's rare. Parallel computing's greatest application by far is scientific computing, which is dominated by CUDA (which offers, among other things, better performance) in devices up until laptops, and the rest is pretty irrelevant, since I doubt you'll be doing relevant parallel computing work on cellphones. 
Please do not post pictures of text. These emails are archived in public email archives, link to one of these instead. I have removed your post so you can post this again but with a link to the actual email instead of a picture of text.
Oof. There is so much wrong with this I don't even know where to begin.
Once again, it's not super relevant to C, but I like this sub more than the other programming subs. I'm currently running my script that generates StringIO's tables, and checking it over to make sure all of the bugs have been fixed, if everything works out I'll commit the StringIOTables.h file to FoundationIO today.
OpenMP is an option, apparently Clang supports (most or all? it's not super clear) Tho I think OpenCL was at least part of OpenMP's backend...
&gt; Once again, it's not super relevant to C, but I like this sub more than the other programming subs. I'm sorry, but I really don't see how this is about programming in C, so I removed your post. Perhaps a different programming subreddit might be appropriate. 
Did you forget than AMD exists?
Yeah sorry, just thought it would be better to club two messages into one to make for continuity.
Didn't you see the part in my answer that says "there's also Vulkan now"? Don't you know that Vulkan does computing? Or just how shitty AMD's OpenGL implementation is? Or how much they're pushing for Vulkan for these exact reasons, among others? And that any resource wasted on OpenCL could be spent on Vulkan compute? Regardless, I just don't like to pretend they have any real relevance in this area.
If you want to do that, you can just paste the message into a self-post. Just don't post pictures of text please as they can't be read by blind people and prohibit searching for the text with a search engine.
Yeah understood! Thanks for the pointer.
I love those rants :D What language standard is Linux targeting? Since C99 it is explicitly allowed to use unions for type punning.
I wonder about performance...? There's a bunch of implementation across different open source projects ([here's mine from facil.io](https://github.com/boazsegev/facil.io/blob/48d73674be54e33b5e3cbd14179b073d8b0841d8/lib/facil/core/types/fiobj/fio_base64.c) and [it's header](https://github.com/boazsegev/facil.io/blob/48d73674be54e33b5e3cbd14179b073d8b0841d8/lib/facil/core/types/fiobj/fio_base64.h))... I would love to know how these implementations compete.
[Diff of the changes](https://kernel.googlesource.com/pub/scm/linux/kernel/git/rafael/linux-pm/+/dp-4.18-rc1%5E%21/). Looks utterly pointless to me. 
Linux is written in C89 using GCC extensions, last I looked.
I urge you to post that on /r/linusrants
I hate these kinds of changes that don't accomplish anything essential.
Here's the patch in question: https://kernel.googlesource.com/pub/scm/linux/kernel/git/rafael/linux-pm/+/63dcc7090137a893322432e156d66be3ce104615 Over the years I've come to disagree with Linus (and others) about strict aliasing and signed integer overflow. These are important tools that allow compilers to generate efficient code. The vast majority of the time pointers to different types *don't* alias and you want the compiler to exploit this. The main objection comes when the compiler can prove that two pointers alias, but it still pretends that they don't. They want the compiler to operate on that information. However, this would lead to really complicated rules. Under what specific circumstances can we assume the compiler sees aliasing? Good luck memorizing all those special rules. Since they can't get what they want, they just invert it with `-fno-strict-aliasing` and all pointers alias until proven otherwise. They want to go behind the compiler's back for the sake of performance (by violating strict aliasing), but they also want to remove the tools that allow the compiler to emit good code. The right solution is to encourage compiler vendors to improve their compilers so that they generate fast code when the programmer does the right thing. Why are they type-punning? Because it's faster than, say, a memcpy() into the right type and back. Solution: Make the compiler smart enough to consistently copy elide the memcpy(). You get your fast code without nasty tricks. Compilers *have* slowly been picking up these sorts of tricks over the years. 
&gt;a standards paper is just so much toilet paper when it conflicts with reality. another one for the archives
That's not really a "right solution" that could be applied to an important project that needs to work correctly _now_, though, is it? The right solution for Linux is certainly not to write to a (often rather divorced from reality) abstract standard in the hopes that, theoretically, maybe, compilers will always do the best thing, some day. Particularly in a project where what the real, actual, compiler does is very important. `memcpy` being the only pedantically standard-blessed way to do such things, even for primitive types, is a farce anyway. People aren't going to want to - and therefore won't - do that, regardless of how fast it is. Passing the size(s?) of the types dynamically to a function isn't the right solution here in any universe, real or imagined.
use SIMD on longs strings [see here](https://github.com/lemire/fastbase64). More fun: my [SSSE3](https://github.com/aqrit/base64/blob/4cfed1c52f3b00ba9d87466e173bfbb36141c546/lib/arch/ssse3/dec_loop.c#L131) decoder my [SSE2](https://github.com/aqrit/base64/blob/15e59e66f57f3bee00a15e6148f89c5e626f2fb0/lib/arch/sse2/dec_loop.c#L20) decoder \- (mapping to 6\-bit only) never got around to get decent packing... but it was meant for Atom so pshufb would still be available (just slow).
&gt;it's also available on just about any android phone Nope. There are lots of android phones that have chipsets that could support OpenCL, but if its from Google (like the Pixel, Pixel 2, Pixe 2 XL, etc) they don't support it. They force you into Renderscript. [There are tons of posts like this, where people with OpenCL capable Snapdragons discover they don't actually have OpenCL](https://developer.qualcomm.com/forum/qdn-forums/software/snapdragon-neural-processing-engine-sdk/34526) [Here's one with a weak explanation](https://streamhpc.com/blog/2013-08-01/google-blocked-opencl-on-android-4-3/)
I really enjoyed David R. Hanson's 'C Interfaces and Implementations' book, which tought me quite a few tricks I did not know before.
&gt;(I present the problem as a research of string into char\[\] but it could be something else because I want to compare bits) ... are you searching for bytes on byte boundaries, or bits starting at any position?
I search a bits sequence in a bigger sequence of bits, the pattern could start at any position.
How large are the bit sequences? Are they a fixed size? Are they always \&lt;= 32 bits ?
Linus is being an ass, as usual. F/OSS would be better off without him.
The pattern is just 22bits and it's fixed. The other sequence is not fixed at all and it's very huge (no minimum and no maximum size)
He followed up mentioning that he accepted it: https://lkml.org/lkml/2018/6/5/774
Type punning is an issue I want resolved, and quickly, for both C and C\+\+. Nobody can agree on the proper way to do it and what's allowed by the standard. The best you can do is what Linus did: GCC makes guarantees about punning through a union, so that's what we're going to assume is allowed. But not everybody can assume they'll be compiled with GCC. Sorry, Linus, but we also need the standard to catch up on this one.
Could you go into what's wrong though? I am newbie to okay-ish C programmer so I don't want to learn bad habits or ideas. From what I gathered, much of his tips assume x86 arch, so there are UB tips there. But again I am not that good C dev, so any clarifications would be great.
Don't they require driver support on Apple's end?
If you already know the length of both strings, you can use the standard library function `memmem`. The C standard makes no asymptotic complexity guarantees about any of the functions, and while a poor implementation of this function could be O(N^(2)), optimal algorithms are close to linear. The Turbo Boyer\-Moore algorithm is the classic approach. If you're implementing this yourself, consider the [Tuned Boyer\-Moore algorithm](http://www-igm.univ-mlv.fr/~lecroq/string/tunedbm.html) and the [Two\-Way algorithm](http://monge.univ-mlv.fr/~mac/Articles-PDF/CP-1991-jacm.pdf). Otherwise, there is an efficient [implementation of the Two\-Way algorithm in GNU gnulib with some special\-casing](http://git.savannah.gnu.org/cgit/gnulib.git/tree/lib/strstr.c) important for some obvious cases; [similarly also for the memmem case where we know the length of the strings](http://git.savannah.gnu.org/cgit/gnulib.git/tree/lib/memmem.c).
Even part\-way through a byte?
How so? He's making a valid argument here.
 abcdefgh'ijklmnop'qrstuv??'???????? ?abcdefg'hijklmno'pqrstuv?'???????? ??abcdef'ghijklmn'opqrstuv'???????? ???abcde'fghijklm'nopqrstu'v??????? ????abcd'efghijkl'mnopqrst'uv?????? ?????abc'defghijk'lmnopqrs'tuv????? ??????ab'cdefghij'klmnopqr'stuv???? ???????a'bcdefghi'jklmnopq'rstuv??? so for avx2: for(...){ broadcast 1 dword from src to ymm vpand mask\_off\_the\_question\_marks vpcmpeqd if(vptest) goto found; mov src pointer ahead 1 byte } would be my first attempt :\-(
This is my first time seeing the code. A couple things seem a little weird to me. 1. Why is `b64wrd` a `uint8_t *` instead of a `char *`? I would think the whole point of base 64 conversion is to be able to deal with it easily as an ordinary string? 1. When decoding, why do you accept illegal characters? And why do illegal characters have the value 64 in your array?
Uhmm, I see. That's totally an OEM decision though, more than anything (I have 2.0 full profile on my XZ2) Also, I think it can still be [hacked around](https://maxlv.net/how-to-enable-opencl-on-nexus-5/)
1. b64wrd has to be zero\-extended at some point, so this is just function signature nit.
Linus is an arse approximately 0.1% of the time. When he is an arse, he presents great reasoning majority of the time.
The sorts of advice here that can be wrong are specific details -- how much space gets used in padding and whatnot. More widely scoped advice ends up being the best pieces to take away, like the value of crashes and tools, the trade between flexibility and immediate results, or the idea of tackling mountains. Look less towards the specific 'how'-s presented and instead towards the reasons behind them. If you find a good reason, look for a good way to use it, using Eskil's example as a starting point.
I don't understand the point of this. The standard gives explicit license for type-punning through unions, you need to read the standard in an extremely hostile way to believe otherwise.
 Alternate title: " standard Linus on C".
Like avoid apple entirely.
&gt; Passing the size(s?) of the types dynamically to a function isn't &gt; the right solution here in any universe, real or imagined. Clang &amp; GCC seem to know the stdlib well enough and optimize it away. https://blog.regehr.org/archives/959 (scroll to the last example) Still ugly though.
GNU89, specifically. Which is more like a half-step between C89 and C99.
First, I don't think he's a native English speaker. But second, some people I know online who at first I thought were idiots because they couldn't spell anything correctly despite being native English speakers are very talented people. And I don't mean "in their own special way," they just can't spell very well. I used to just close the page if I saw so many spelling mistakes, but I've learned to give them a chance since then.
&gt; But not everybody can assume they'll be compiled with GCC. Sorry, Linus, but we also need the standard to catch up on this one. That's pure theory. Linus did write in this post: &gt; The C standard is \_clearly\_ bogus shit (see above on strict aliasing rules), and when it is bogus garbage, it needs to be explicitly ignored, and it needs per-compiler workarounds for braindamage. 
Yep
Amazing! 
Come from java and PHP background. I juste finished to learn basic core concept ans syntax of C and was searching starting point for learning system programming. Thank's ! For sur I will follow this guide.
Aka read it the Stackoverflow way. 
Sure. I was speaking a bit sloppily, I meant an interface that looks like passing the size dynamically (and maybe is, maybe isn't, depending on compiler cleverness and whether you screw it up or not) is clearly not the right one for coercing types when the compiler inherently knows their sizes (among other things).
This would take hours, though in general I agree with /u/xrxeax that much of the high-level broad advice is okay, but a lot, if not most, of the details are misguided at best. It strikes me as quite amateurish to be honest. To take a random example, he spends quite some time early on talking about how C++ encourages thinking you're clever when you're really being dumb, then presents slide 25, in which a clear and straightforward for loop is translated into a weird pointer thing for 1980's "optimization" reasons. Using pointers as "iterators" is not itself a bad idea, it often makes things much clearer and indeed sometimes faster, but this is just taking clear code and mangling it into a form that's less likely to be vectorized if anything, making it weird for reasons that would not be clear to anyone reading it. No compiler is so stupid that this is a win. A perfect example of thinking you're clever when you're really being dumb.
Yeah, you are right. But there is absolutely no reason to "namespace prefix" variable names with b64 or such. They are not visible in code when using the API, and when reading the API you are already in the context. There are no uniqueness requirements for the argument names anyway, except within the function.
shit
Perhaps, but he's doing so by publicly berating and insulting one of his own co-workers / contributors as well as dozens of hard-working professionals who made these decisions with for very good reasons which he just can't be bothered to educate himself about. 
Thanks, I added this to [Project Based Tutorials in C](https://github.com/rby90/Project-Based-Tutorials-in-C).
I started my own PI OS in arm a while ago. I got the graphics and memory management, but stopped after spending weeks trying to write the USB drivers. You’ll need them for: SD card access, mouse, keyboard, wifi. Looks like this tutorial doesn’t have that part yet neither.
Great content! Anyone interested in learing more about OSDev should definitely check out the [OSDev wiki](https://wiki.osdev.org/Main_Page)
I thought it would have made clearer the distinction between plain and encoded/decoded word within function parameters. I'll change them in the next commits. Thanks for the suggestion.
&gt; Project Based Tutorials in C you might enjoy this then: https://www.ops-class.org/ A complete lecture (latest being 2017) on developing an operating system. :)
Great content! Awesome stuff!
That's right. But what I am trying to do is to investigate the source code of popular operating systems and then mimic and simplify their functionality. I started with Linux, but its driver model is really complex. Now I am working on investigating Google's Fuchsia OS. If you need a good and more or less easy to understand sample of usb driver you can take a look here: https://github.com/fuchsia-mirror/zircon/tree/master/system/dev/usb Though I am not there yet.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [fuchsia-mirror/zircon/.../**usb** (master → c06f465)](https://github.com/fuchsia-mirror/zircon/tree/c06f4654a89f48bbb3430e7b1f2c7e9948ab5cf7/system/dev/usb) ---- 
High level picture: Imagine a surreptitious escape route (like the [Underground Railroad](https://en.wikipedia.org/wiki/Underground_Railroad) in US History). For privacy and security reasons, you only know the starting node (the HEAD NODE). Once you get to the HEAD NODE, you're then told about the next point (NODE) on the route. At the next NODE, you're told the next NODE, and so on until you get to the end of the route (TAIL). That's basically a linked list. It can be (and typically is) implemented using dynamic memory, but I've done it in arrays (in AppleSoft Basic, so no `malloc`). Now imagine, again for security, the route changes frequently. The next time someone goes to the HEAD of the route, or any NODE on the route, they may be directed to a different NODE. This is a *dynamic* linked list. The path traveled changes, and the traveler generally doesn't care. But, things have to be communicated. Now, if each NODE only knows about its next NODE, then that is a singly linked list. To remove a NODE from the route, you have to start with the HEAD until you get to the NODE whose NEXT NODE will be removed, then set the current NODE's NEXT to the new NODE. You then have to go to the skipped NODE to let them know that they are not in the list. If you're merely rearranging NODEs (sorting), you still have to remove a NODE, then insert it. Since one-way routes can be cumbersome, imagine you decide that each NODE knows its PREVIOUS and NEXT NODE. Now to remove a NODE, you follow the route to the NODE to be removed. Tell its PREV that its NEXT is the current NEXT, and tell the NEXT that is PREV is this PREV, then tell the current NODE that it's done for now. To remove a NODE C from a single linked list: A--&gt;B--&gt;C--&gt;D 1) Visit NODE B, because its NEXT is C A--&gt;B--&gt;C--&gt;D ^ 2) remember B 3) Visit NODE C 4) Get C's NEXT (i.e. D) 5) Set NODE B's NEXT to D A--&gt;B C--&gt;D \___^___/ 6) FREE C (if using an array, mark C as available to reuse, if using `malloc`, then call `free`). Make you clear anything in C (e.g. if you allocated a string, then free the string before freeing the NODE) To remove a NODE C from a doubly linked list: A&lt;-&gt;B&lt;-&gt;C&lt;-&gt;D 1) Visit NODE C A&lt;-&gt;B&lt;-&gt;C&lt;-&gt;D ^ 2) Set B's NEXT to C's NEXT, and D's PREV to C's PREV A&lt;-&gt;B&lt;--C--&gt;D \___^___/ 3) FREE C (if using an array, mark C as available to reuse, if using `malloc`, then call `free`). Make you clear anything in C (e.g. if you allocated a string, then free the string before freeing the NODE) 
**Underground Railroad** The Underground Railroad was a network of secret routes and safe houses established in the United States during the early to mid-19th century, and used by African-American slaves to escape into free states and Canada with the aid of abolitionists and allies who were sympathetic to their cause. The term is also applied to the abolitionists, both black and white, free and enslaved, who aided the fugitives. Various other routes led to Mexico or overseas. An earlier escape route running south toward Florida, then a Spanish possession (except 1763–83), existed from the late 17th century until Florida became a United States territory in 1821 (and ending the safe haven for escaped slaves was the main reason it changed nationality). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Awesome ! Thank's :)
But gnu89 supports union aliasing 
No he isn't. Standard C allows union aliasing so he is wrong to abuse the standard for not allowing it. 
Nice list.A lot of cool stuff! 
This subreddit exists to discuss the C programming language. Please redirect this to r/java.
Fuck off you dirty spammer.
Honestly, I have tried this before, and you really shouldn't. Not unless you have a lot of spare time.
This kind of practices will improve your programming skills extrem
Never said it wouldn't, but it is a lot of effort.
You really need to make `get_single_element_mol_mass` use a table instead of a massive if/else tree...
Why does your code include every single standard library header? Note that you can greatly improve your code by turning that large cascade of comparisons into an array and a call to `bsearch`.
Any particular issues? Or the problem is with the overall complexity of the material? If you can point out the places that are confusing or unclear I'll try to fix everything.
Oh, sorry for the confusion. I am not referring to your guide, but rather to the process of writing your own OS. It as a whole is a very time consuming process. This may encourage people who know not what they are getting into to try it is all. Which is fine, unless they get in over their heads so to speak.
For why unions are useful, [StackOverflow users](https://stackoverflow.com/questions/252552/why-do-we-need-c-unions) have a good answer. TLDR: It is just to optimize the amount of memory used. The view layer that you mention was unnecessary, is necessary because you have a PyObject\_VAR\_HEAD at the top. Instead of typedef struct { PyObject_VAR_HEAD union { PyObject *objects[1]; PyTupleObject *tuples[1]; PyASCIIObject *ascii[1]; struct { char pad[offsetof(PyTupleObject , ob_item)]; PyObject *key; PyObject *value; } *elements[1]; } *view; } mp_item_view; You could directly do: typedef union { PyObject *objects[1]; PyTupleObject *tuples[1]; PyASCIIObject *ascii[1]; struct { char pad[offsetof(PyTupleObject , ob_item)]; PyObject *key; PyObject *value; } *elements[1];} mp_item_view; But you need the VAR\_HEAD member to be present. So, the view becomes a member pointer to union in the struct. If you remove VAR\_HEAD like I have, you can get what you want partially. Also, your code is incomplete and I am unable to understand a lot of other variables being used. Can you please define every type clearly? (For eg, PyASCIIObject, Py\_ssize\_t , as\_unicode, offsetof() are not defined) Lastly, pointers aren't nasty. They make life pretty easy if you understand how to use them correctly. 
Yup. You answered your own question. Next. 
&gt; is the address of the address of the next node? It's the address of the location at which the address of the next node is stored. You're storing the address of the next node in memory somewhere, right? This tells you where it wound up.
In related news, Casey Muratori uploaded a talk about how operating systems used to work. It's a great video that talks about how much better modern operating systems could be. https://youtu.be/kZRE7HIO3vk
[This is all I could think of when I saw the title.](https://i.imgur.com/iWxJUEQ.jpg)
Thank you for this!
Kind of tongue in cheek, but useful nevertheless. &amp;(adress) doesn't do anything and is usually wrong. But your code doesn't have any of that. Keep in mind: pointers are just like every other variable. They just happen to store memory locations instead of integers or chars.
USB is really hard. I'm not sure if x64/x86 systems have a serial buffer built in, but in embedded systems you can just access that directly and it will handle interrupt flags and puts it in a buffer for you automatically.
Look carefully at the logic of your if-else statements... if (c == '\t') { ... } else if (c == ' ') { ... } else if (c != ' ') { /* reset it */ ... } else if (c == '\n') { ... } else { ... } You should get in the habit of either stepping through your code or putting in some printf statements in each of the if-else cases to see what is actually getting run. 
In theory [KMP](https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm] is better for small alphabets like this because there are more repeated letters in the matching string. Though I'm not sure how much this plays out in practice 
Yeah, no. To fully support USB on x64, you need to parse the ACPI tables, be able to do PCI and then write four separate drivers for the host controllers, to handle OHCI, UHCI, EHCI and XHCI. You can, however, get keyboard and mouse working before that because USB ones are emulated as PS/2 devices as well
Yea. no thanks. thanks for the info though, I wasn't fully aware of how modern systems work.
`head-&gt;next` is a variable. `&amp;(head-&gt;next)` is the address of that variable. 
Hey!! and here is the full repo: https://github.com/p1v0t/sort :))
i think we should include a step that involves getting hated by the big os-gurus tannenbaum and torvalds.
Why is your whole program full of backticks?
Look into OS161, very stripped down and used in many uni courses 
Here's the code with formatting fixed and those backticks removed (how did they get there in the first place?): https://ideone.com/tXu0cE Then the commentary: 1. You insert different stuff in the `init` function than in the expected output. 2. In `insertFirst` you create a temporary array, then insert to the new value in the first position (`*(temp+0) = x;`), then copy the old array to the rest of the temp array, and finally copy the temp array over the old array. So of course your new value then appears in the first place of the array. To do what you want, you need to first copy half of the old array on over the temp array, **then** insert the number, and then copy the other half over it. 3. `insertFirst` is a terrible name for a function that inserts in the middle of an array. 4. You allocate too little memory for `temp` in `insertFirst`. It needs to hold `*num + 1` items but you only allocate `*num`. 5. Speaking of that`insertFirst` probably leaks memory since you don't `free(temp)`. BTW, allocating memory for `temp` with malloc is not totally necessary: - you could just create a regular array on the stack (`float temp[*num + 1]`), and then you don't have to `free` it. In general, you want to avoid malloc if possible. 6. Your `deleteInvalid` works exactly like you say it should, even in your screenshot (though I got a runtime error if I didn't fix the bug in point 4.) Disclaimer: I'm not a C programmer.
An idea is to count for each one of the sets you test (random, partially random, already sorted etc.) the number of swaps (interchanges) and the number of iterations and display them.
This video and the guy talking are a really nice starting point. Even though a PI does have USB, knowing how to work it even without USB hardware is a wealth of information :) [https://www.youtube.com/watch?v=GFY\_A3jcI28](https://www.youtube.com/watch?v=GFY_A3jcI28)
What kind of metric are you looking for? You can measure how long it takes in number of cycles, or how many times a particular function was called. It may be worth using a dedicated profiling tool if your platform supports it (such as `prof`)
Why would you assume that because you didn’t enjoy it others won’t? People should do whatever they want and everyone who is interested should try this.
I’m not so sure how it added the back ticks when I copy-pasted from my IDE. Weird. But thank you for doing the format fix and all! Also thanks for the help! And yeah, insertFirst is a terrible name. Wahahahaha. My prof just named it that for some reason. I’ll edit my code now with your comments in mind. Will check if it works! Thank you! 
And yeah just realized my deleteInvalid works. I should probably get some sleep. Hahaha! Thanks again!! 
In your example, you're taking a type of `pointer to: pointer to: node_t`, and storing it in an identifier named `pp`. It isn't _exactly_ correct to say it is the "address of the address of the next node", rather, it is the "address of a pointer to the next node". For some context, this is useful if you have a function that you wish to update the pointer, and have that reflected back in the caller's scope: node_t* head = get_head(); // find the Nth node int rv = find_nth(&amp;head, 0xff); // now `head` refers to something else.. Something else worth mentioning is the use of `address-of` and parens: In this case, `&amp;(head-&gt;next)` is identical to `&amp;head-&gt;next`; The `-&gt;` (i.e. structure dereference) operator has a higher precedence than the `&amp;` (i.e. address-of) operator. Some times it adds clarity to use parens, but this is subjective and arguable either way. 
@kodifies So instead of implementing generic linked list first, I started with the generic sorting algorithms. Please take a look at it. https://github.com/x899/algorithms/tree/master/sorting_algorithms/generic_sort_algo
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [x899/algorithms/.../**generic_sort_algo** (master → 92c42e3)](https://github.com/x899/algorithms/tree/92c42e3b35be52655bb164dafbb86b57d04fb2ad/sorting_algorithms/generic_sort_algo) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e09gomo.)
Why do you use malloc in insertion_sort when you use a variable length array in swap. Better to use VLA for both.
.
I’ve been doing it for years. I’ve rewritten my OS completely 8 times. Always learnt stuff though, and I still love the challenge. Unfortunately, now I’m at Uni, I don’t have as much time as I did in school.
 char temp[elem_size]; this is not actually an array. It is meant to store a element value. But yeah...you do have a point. However, i am not sure which is a better approach. Storing temp variable in heap(malloc) or in stack (vla)?? and Why?
Newbie here. I thought VLA was super-dangerous when you don't know the upper bound of the size because you might be allocating something very big on the stack?
I am skeptical to VLA at all... Do you have anything interesting to say to its defense?
I don't really think you can make assumptions about where the memory allocation algorithm can place things. Its possible that after the free call that it will "defragment" or move blocks around to reduce memory fragmentation. I wouldn't necessarily be _surprised_ if bufR1 ends up pointing to bufR2 because its reused but you can't assume this. Strictly speaking, using the pointer after calling free is undefined. If you're trying to figure out what happens to do some form of exploitation than you'll need to understand the implementation pretty well.
My real point to be consistent whichever you choose. Practically, both have pluses and minuses, but I only have experiences with OOM. Stack overflow in my mind = infinite recursion. Otherwise I never see it.
See my response below.
See my response below.
 I just want to demostrate how long does it takes in terms of time :)) Maybe not the best idea, but i'd to see the result and add them to README.md file. But the problem i couldn't figure it out how to structure the code, and apply the test cases.
Consistency is the main point here. I think I will go with VLA instead of malloc, only because of memory leak. Thoughts?
I would say it is the caller's responsibility to keep the size from overflowing the stack. If you feel you must, you can check the size and use `alloca` or something dynamically.
Yeah much better, a lot more flexible no?
As others said it returns a pointer to the variable `head-&gt;next`. If you like some visualization: (requires unicode capable font) ╔════╦══════╗ ║head║0xBCDA╟┐ (Pointer addresses) ╚════╩══════╝│ ( are arbitrary ) ┌────────────┘ │ ╔═══════════╗ ╔═══════════╗ │ ║ n1 ║ ║ n2 ║ │ ╠════╦══════╣ ╠════╦══════╣ └→╢val ║100 ║┌───→╢val ║200 ║ ┌→╢next║0xABCD╟┘ ║next║0x0000╟→⦿ │ ╚════╩══════╝ ╚════╩══════╝ └──────────┐ ╔══╦══════╗│ ║pp║0xBCDE╟┘ ╚══╩══════╝ 
Here is some visualization: (Requires unicode capable font) ╔════╦══════╗ ║head║0xBCDA╟┐ (Pointer addresses) ╚════╩══════╝│ ( are arbitrary ) ┌────────────┘ │ ╔═══════════╗ ╔═══════════╗ │ ║ n1 ║ ║ n2 ║ │ ╠════╦══════╣ ╠════╦══════╣ └→╢val ║100 ║┌───→╢val ║200 ║ ┌→╢next║0xABCD╟┘ ║next║0x0000╟→⦿ │ ╚════╩══════╝ ╚════╩══════╝ └──────────┐ ╔══╦══════╗│ ║pp║0xBCDE╟┘ ╚══╩══════╝ 
So I would suggest using `clock` from `time.h`. What you do, is call clock to get the time before doing your processing, then once finished call it again immediately afterwards. This will give you the CPU time, not the "wall time". You can also find out the wall time but for this kind of thing you may only want to measure pure CPU impact, not time spent doing IO.
Are you looking for help? I might be interested in helping a bit, if you want :)
Very nice!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
This subreddit exists to discuss the C programming language. Please redirect your C\+\+ related questions to r/cpp_questions. That aside, you should take the lines: cout&lt;&lt;"Do you want to keep on going?(y/n):"; cin&gt;&gt;choice; out of your cases and put them after the switch but before the beginning of the if block. Try to never repeat lines of code like this, and use control flow to your advantage. To answer your real question, you probably want to put the `continue` keyword in your if statement for yes. Bear in mind that your logic is still not correct even with this addition; if I were to input a value that is neither `'y'` nor `'n'` (say `'q'`) twice, your loop would keep on going as if I had answered yes. To fix this you need a loop that will run continuously until a proper input is given, if the user answers yes, then run the switch parts, if they answer no, terminate the program, otherwise ask them for proper input. Hope that helps, and please keep in mind that C and C++ are different languages.
oic i m new to reddit thus my sincere apologize
I suspect that **compare_float()** may not work for values that differ by less than 1. You'll probably have to do a couple comparisons and return -1, 0, 1 instead.
wow i sure have a lot to learn anyway thx alot for the help,tho i need time to figure out how to write the loop
I'd rewrite the compare functions with something like this: typedef int (\*fptr) (const void \*, const void \*); int cmp(int \*a, int \*b) { return (\*a \&lt; \*b) \- (\*a \&gt; \*b); } The advantage is that the typedef allows you to avoid the cast. As for the return, if you need to sort an array of 64 bit integers you might have some overflow problem because the difference might not fit into an int which is the return type of cmp. int cmp(int64\_t \*a, int64\_t \*b) { return (\*b \- \*a); } 
I'd rewrite the compare functions with something like this: typedef int (\*fptr) (const void \*, const void \*); int cmp(int \*a, int \*b) { return (\*a \&lt; \*b) \- (\*a \&gt; \*b); } The advantage is that the typedef allows you to avoid the cast. As for the return, if you need to sort an array of 64 bit integers you might have some overflow problem because the difference might not fit into an int which is the return type of cmp. int cmp(int64\_t \*a, int64\_t \*b) { return (\*b \- \*a); } 
 typedef struct { int avail; int len; float data[0]; } grades_t; #define PAD 16 void pushGrade(grade_t *grade, float value) { int a, l; if(!grade) exit(1); a = grade-&gt;avail; l = grade-&gt;len; if(l == a) { grade = realloc(sizeof(grade_t) + (a+PAD)*sizeof(float)); grade-&gt;avail = (a+PAD); } grade-&gt;data[l] = value; grade-&gt;len = (l+1); return; } grades_t* init(int n) { grades_t *g = NULL; g = malloc(sizeof(grades_t) + (n+PAD)*sizeof(float)); if(g == NULL) exit(1); //return NULL; g-&gt;avail = (n+pad); g-&gt;len = 0; pushGrade(g, 3.0); pushGrade(g, 1.0); pushGrade(g, 0.0); pushGrade(g, -1.0); pushGrade(g, 0.0); pushGrade(g, 4.0); pushGrade(g, 2.0); return g; } void printGrades(grades_t *grades) { int i, len; char *head = "Grades: ", *tail = " | ", *sep; if(grades == NULL) exit(1); len = grades-&gt;len; sep = head; for(i = 0; i &lt; len; i++) { printf("%s%f", sep, grades-&gt;data[i]); sep = tail; } printf("\n\n"); return; } Let me look at rest before these Reddit menus ruin my session again...
&gt; I don't really think you can make assumptions about where the memory allocation algorithm can place things That is why I was wondering about the code posting on the mitre page. Their example seemed overly complicated unless they were assuming that the allocation would take place in their free'd memory.
&gt; Right now I'm passing a number to each of these and they all return the same number. Can you elaborate what this sentence is supposed to mean? You can't pass a number to a type, that makes no sense.
I'm passing a number object to a getter, like getLong() which returns the value of the object as a long.
If you’re talking about `printf`, then you’d use whatever `int` or `unsigned int` specifier (`%c` `%d` `%u` `%X` `%x` `%o`) to format `int`, `short`, and `char`—the `...` arguments that format operands get passed in will extend things smaller than `int`/`unsigned int` to a full `int`/`unsigned`, so no special tricks are needed to display those things. Theoretically, you can use modifier `h` for `short` and `hh` for `char`, but AFAIK there’s no reason to. `long` and `long long` need the `l` or `ll`/`L` format modifier, so for example `%d` would become `%ld` for `long`, or `%lld` or `%Ld` for `long long`. Other than that, it’s not possible to tell what you’re asking or how to answer it.
Are you sure you are programming in C? What do you try to achieve with such code?
I am writing a python C wrapper. I am trying to call the functions in C that return the int, long, short, and char of the number object passed in by building wrappers that return PyObjects that are then called in a python file. Right now I'm passing 42 to each of the Python functions, which go through the wrappers, which call the C function that gets the value of the number object as an int or long etc. They all spit back out 42 so I was just trying to confirm if that's what's supposed to be happening. It looks like that is the case, the bit size is what is different.
Were you expecting the numbers to somehow change?
I think I get what you're asking... If you pass one of those three options to a function accepting a long, and print out the result, what is the difference? On the architecture I'm currently working upon, a long is 8 bytes, int is 4, short is 2, and char (per definition) is 1. Say we pass in a short, the value is copied and pasted into the argument of the function. The size discrepancy is taken care of with an implicit cast from the short type to a long by padding the extra 6 bits and it will print as a long. Note that I'm not endorsing this behavior. 
You just contradict yourself by saying that &amp;address doesn't do anything and then go on to explain how it stores memory locations (addresses). Also their code doesn't have any of what?
Thank you, this is what I was looking for.
Honestly, VLA is a ticking time bomb and should almost never be used. If the VLA length is ever under control of untrusted input, then the application is likely to be vulnerable to [stack clash](http://nullprogram.com/blog/2017/06/21/). The only safe way to use VLA is to essentially *not* use it. That is, you pick some safe upper bound and only use a VLA if it's within that bound. However, if that upper bound is truly safe, *then you might as well use that array length statically in the first place*. That's your worst case, and you had better be able to handle it. If you want the performance benefits of VLA without the security / safety issues then use [small size optimization](http://nullprogram.com/blog/2016/10/07/) instead. Pick a fixed array size that covers most cases. Then use a pointer. If the automatically allocated array is big enough, point it it. If it's not big enough, then point to a `malloc()` allocated buffer. 
Concurrency != Parallelism That being said, I've found both MPI and OpenMP quite useful. They should be available for Windows as well.
hm ok. thanks for the answers and more questions. :) google away
This scares me. I recently watched the 8 bit computer guy’s video on the clock and I was transfixed. But I only have one life...
 if(++i != struct-&gt;amt_of_arrays &amp;&amp; struct-&gt;arrays[i] == NULL) { i++ } should be if(struct-&gt;arrays[i] == NULL) { continue; } i is then incremented by the for loop statement.
AFAIK MinGW has a pthread library for Windows available.
https://www.youtube.com/watch?v=o9nW0uBqvEo MIT Comp Sci lecture