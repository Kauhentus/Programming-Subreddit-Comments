Oh my god, this website is awesome! Thanks for sharing and the research! :)
Honestly, I think you probably have more experience with this concept than me in the first place. It's an interesting problem, I wish I could think of an answer right now. Might be worth making a post with this question, I would be interested in an answer. EDIT: I still have no idea but am going to type my chain of thought and post it: This would be fucking horrendous code I am sure. I guess you could go bit by bit with hardcoded strings for value of each bit that is out of bounds of an unsigned int (no need for the rest). Find the highest bit and set your result string to the hardcoded string corresponding to that bit. Then for each set bit you would "add" the two strings to gether using a method much like you are taught to add in primary school. By adding each unit and carrying over. So starting at the end of each string add the integer value of each character together if the value is greater than 9 store the unit and add 1 to the next character of the result string before moving on the the next character of the bit string. Wow that was a ramble... but I guess by doing that you would be able achieve printing a string, with some caveats. a) you would have a huge nasty header file. b) you would have to predefine the maximum lenght of the int array. c) this would be insanely innefficient. Which defeats the point of being efficient in the first place. I am sure there is a much much better way but thats what I cam up with stoned and waiting for dinner after work.
What was the solution? Someone in the future might be looking to answer this very question, come across this posting, and still have no idea ... 
Yes, I call it in the "main" loop of the game, when I need a "new next shape". &gt; it would be better to simply use a loop inside the function so that you don't have to depend on the value of variables that aren't in your scope for no reason (i). Sorry, can you provide an example? Because I can't see your point.
I was gonna write down a solution asap, no need for downvote me so hard. By the way, I was just miswriting my printf. I knew I only could have 12 numbers after the point as I'm reading from file, so I printed my results using %.12f, getting the right number. Operations would have been right anyways, which is what mattered to me.
Google random number in C. The [first response has the answer you are looking for](https://stackoverflow.com/questions/822323/how-to-generate-a-random-number-in-c). Why not google a question like this before asking online? 
Why is this kinda post allowed here?
Because OP asked and I see no rule against it.
I used this approach before (without the "tweak" part though), but sometimes I got the same shape for 4-5 times sequentially (maybe it's `rand()` fault). That's why I chose to follow those specs. I'll try your tweaked version though. Thank you for the suggestion.
Well guess that's true this just seems against the spirit of this sub kinda disappointed that there isn't a rule against stuff like this.
Thanks for your help. The problem is solved. Turned out to be a hardware issue where the mosi and msio pins where not receiving power. Took me forever to figure out but now it works!
I used this approach before, but sometimes I got the same shape for 4-5 times sequentially (maybe it's `rand()` fault).
Depends on your requirements. True randomness isn't possible unless you use specialised hardware that uses quantum effects. Otherwise, you can predict the output of an algorithm given you know the initial vales of the variables. Anyway, let's get on with randomness. In C, you can have PRNGs, Pseudo-Random Number Generators. DO NOT write your own function. The beginner approach is: srand(time(NULL)); rand_nb = rand() % 100; /* generate a number between 0 and 99 */ But there's a problem: if you've heard of information entropy, you should know that the above example uses the modulo operator to simulate an upper bound. It's crap. Don't do it. Entropy is severely affected. It works for your project needs, but for situations like statistical analysis DO NOT USE THIS METHOD. If you're on a UNIX system, bless POSIX: int my_rand(void) { int val; int fd; fd = my_openfd(RAND_PATH, OPEN_READ); if (read(fd, &amp;val, sizeof(int)) == FAILURE) { close(fd); return (0); } close(fd); return (val); } *code extracted from [my libc implementation](https://github.com/Garuda1/unixlib), unixlib/source/my_rand.c* Basically the above code reads `sizeof(int)` bytes from a stream of random values from the pseudo-file `/dev/urandom`. I'm not sure if this is Linux-only, someone confirm this. But you get the idea: POSIX turns most things into files, and you can read from them just like any other files. This `/dev/urandom` file happens to contain an "infinity" of seemingly unpredictable values. **EDIT:** I told you not to write your own function before giving you the code of one I wrote myself. No, I'm not an hypocritical guy. My function does not "generate" the random numbers, it reads them. Your OS will gather information from your devices, like let's say your mouse, as well as other system aspects, and will work out some magic to produce data. The entropy here comes from external devices and the user itself, not an algorithm. It's still a PRNG not an RNG, but we're pretty close to what I'd call secure for personal projects. If you're onto security/statistical analysis, look into dedicated libraries and hardware.
You don't need a book if you're still learning. Just some examples. What I love about C++ is the STL, for Standard Template Library. I'm not experienced enough in C++ to recommend anything, but it's some serious business. It's got all kinds of data structures you can think of. Also, data structures aren't there to make your code look fancy. They're supposed to be used along dedicated algorithms. You're gonna learn about the sorting ones soon, it's truly an amazing subject! How something as mundane as sorting stuff is in fact an incredibly complex process.
We don't have many rules and there was no precedent for people not liking this sort of content so I didn't see any good reason for not approving it. Due to the strong feedback, I probably won't accept this the next time but we'll see.
Im a student too and we use the book Sedgewick's Algorithms as a reference at university. We got told that among informatics it is a defacto standard work and wide spreat reference and gets used in a lot of universities around the world. I got an older secondhand copy from amazon, where C gets used as the programming language in the book. In the current edition I believe its Java. So just wanna let you know there is one with C out there if you are interested in it.
hey thanks for the update
You realize that what you're asking for is illegal, right? Did you even try to find a [used copy](https://www.amazon.com/gp/offer-listing/0393969452/ref=sr_1_2_olp?ie=UTF8&amp;qid=1499897898&amp;sr=8-2&amp;keywords=C+Programming%3A+A+Modern+Approach) before whining about the price?
Well for one, this library is for C programs. Oh wait. It says Python at the bottom. Just keep using the standard library. Like you said it is very good
I'm not sure how useful an analyzer would be that doesn't know about basic language grammar ... surely it should start from something similar to a real compiler front-end.
Intel has added instructions for hardware generated random numbers see [here](https://en.wikipedia.org/wiki/RdRand). If you are compiling for a recent CPU you may want to use that. You don't have to go down to asm to use them, gcc provides intrinsic functions. Example: #include &lt;stdio.h&gt; #include &lt;immintrin.h&gt; #include &lt;stdint.h&gt; int main(void){ uint32_t x; _rdrand32_step(&amp;x); printf("%u\n",(unsigned)x); return 0; } You must compile with `-mrdrnd`. 
I like this: Mastering Algorithms with C. Kile loundon (contains several errors but is nice to read)
good method!
With the first case, most compilers give a warning for that. Setting your compiler to treat warnings as errors means this would never become a bug (also. Don't ignore warnings...they usually mean something). Your code snippets are severely lacking and make it hard to discuss this. Neither would even compile and depending on the type of 'v' the example you gave could work perfectly fine. If 'v' were volatile, an interrupt could happen that sets 'v' to a valid address before the "v-&gt;m = 10;" line. Still, I'm not sure what you're trying to say here. Are you saying cppcheck sucks? Then don't use it, or make it better, or make your own tool.
Start with [SSL_shutdown()](https://www.openssl.org/docs/man1.1.0/ssl/SSL_shutdown.html)
To add to your answer: This kind of optimization is not possible if the compiler doesn't know if the pointer is aliased or not. C99 added the restrict keyword to explicitly tell the compiler that a pointer is not aliased and in turn enable such optimization.
Thanks for the idea! I saw this thread and immediately realized a CLI helper is exactly what I needed to make some of the example code for [`facil.io](http://facil.io) more readable. However, after reading the comments here and the API interface, I decided to [roll my own](https://github.com/boazsegev/facil.io/blob/aa53fb89e9361d34e7e8cfcc098ac0b9e82ce346/lib/facil/services/fio_cli_helper.h)... It was mostly the API that seemed a bit over the top. Too many features for my taste. Also, the fact that your library uses a `union` for data type means your library excluded some features I required. For example, I wanted to parse an argument (port number) where I require the user to enter a valid number, while I collect the information as a string. I admit my implementation builds on other features that [`facil.io](http://facil.io) offers, but I think the simplicity of the API is something worth exploring.
This is undefined behaviour. You are not allowed to bit shift a 1 into or past the sign bit of an integer.
I am not sure what you are looking for. I don't think there is anything in musl that gcc, clang, or VC cannot compile.
Terribly sorry for my bad wording. I updated the OP. I know musl-gcc and musl-clang exist. 
&gt; Knuth's Art of Computer Programming volumes are also excellent, of course, if rather advanced in places. Agreed. Knuth is rather hard to start with, probably best to start with books like Sedgewick, Skiena or CLRS and go on with Knuth *if* someone wants to deepen their understanding after that.
&gt; You don't need a book if you're still learning. Just some examples. &gt; &gt; What I love about C++ is the STL, for Standard Template Library. I'm not experienced enough in C++ to recommend anything, but it's some serious business. That's not enough if one wants to get into Computer *Science*. You'll have to understand algorithm design and proofs in order to become better at developing new algorithms. &gt; It's got all kinds of data structures you can think of. It apparently doesn't have Graphs (e.g. in the form of adjacency lists) and standard Graph algorithms. These are very applicable in many areas. Not that I think adding them would be a good idea. The C++ standard library is already pretty big for a systems programming language.
The examples are very, very silly. &gt; Cppcheck primarily detects the types of bugs that the compilers normally do not detect. The goal is to detect only real errors in the code (i.e. have zero false positives). Both of these examples lead to warnings and are therefore explicitly stuff cppcheck DOESN'T want to warn about... Warnings that have been moved into the compilers are often even disables/removed.
I suspect you didn't read the first/last paragraphs of my post (or intentionally twisted them). I think cppcheck is a good tool, that's why I'm exactly proposing ways to improve it. The examples are intendedly lacking. In general, cppcheck can still extract meaning out of them. For instance, cppcheck diagnoses a null pointer dereference in the snippet below, even though 'T' is unavailable (or could be volatile as you say). void f() { T* p = 0; *p = 10; } The snippet above is of the same nature of the ones I used in the original post. A compiler can't provide warnings in such cases because it can't even parse the code, since parts of it are missing. 
This is not something a compiler can detect because it won't even be parsed. But cppcheck can still diagnose issues in parts of the code. See my other reply to this comment, where a null pointer dereference is diagnosed by cppcheck in an example similar to the ones I used.
But why? Why would you want to do that?
&gt; True randomness isn't possible unless you use specialised hardware that uses quantum effects. Otherwise, you can predict the output of an algorithm given you know the initial vales of the variables. That is both true and false. It is possible to generate pseudo-random data which is good enough for all practical purposes. Note that randomness and predictability are two different matters; a PRNG can be deterministic (non-random) but still unpredictable to an external observer. Also, different applications have different requirements. Scientific applications often require deterministic sequences and don't care about predictability but do care about distribution, while cryptographic applications care about both and games may or may not care about either.
I'd say Knuth is for people who already know the subject well but are looking for deeper understanding. Beginner or intermediate readers will be better off with Sedgewick. BTW, Knuth was Sedgewick's PhD adviser.
You can't. Either it's a trick question or you misunderstood or misremember it.
The obvious answer is actually to use scientific notation.. and there would still be the challenge of converting your int array into this form. 
A compiler will know every detail about T on compilation time, because it requires T to be defined. Your argument that the compiler isn't able to detect this problem is only true in a vacuum and not in the real world. You don't try to compile small snippet without the necessary header/other information. If you omit important header information the same would be true for cppcheck and all other static analyzers as well, simple because I could have a macro defined that is redefining these types into something completely else. I could go ahead and redefine NULL or even the literal 0.
"Text" is your code. It is not stored in RAM. "Data" might be in flash, RAM, or both. BSS is in RAM, along with whatever goes on your stack.
Are you trying to roll your own crypto? Don't roll your own crypto.
Ok ! So in the worst case RAM = bss + data = 19528 bytes which is ~60% of use in my case. It make more sense. 
[The maintainers view that as a mistake](http://openwall.com/lists/musl/2013/03/29/13). 
Stop trying to advertise your (scripting) language, we don't want it.
Meh, mine is better.
Relax, I'm not advocating using any language. I'm simply asking why this library would reinvent what's already really great for at least one of the languages it supports. I can't speak for the other three because I don't have as much experience with them in regards to argument parsing.
God no. Openssl sha256 hash.
Perhaps I haven't made my point clear. I'm specifically targeting the case where the source-code is incomplete. Static/dynamic analysis tools face this "real world" problem: a header may be missing in a cross-platform environment; or because you wanna analyse embedded device drivers; or maybe it's desirable to analysis a patch in isolation, since it doesn't scale to trigger all your analysis' tools for every commit in project with millions LoC; or an exoteric feature of a build system isn't supported by the tool. There are static analysis that require that the source-code must be in compilable form so they can do their job. Other static analysis don't impose this requirement, but still work on a best-effort basis. One example of the latter case is cppcheck. Inferring the missing parts of a program can improve the functionality of both sorts of static analysis tools, in scenarios such as the one I described. 
Are you using TLS to exchange the plaintext password?
Flash usage is text + data, RAM usage is data + bss as the data segment is copied from flash to RAM on program start. Note that there might be a rodata segment for read-only data that is counted into data but won't be loaded into RAM.
Yes. 1. Establish secure tls connection 2. Pass plain text pass from client 3. Hash text and compare 4. If hash fails, force disconnect 
Generate a map file to see exactly where your data is being stored. 
Textbooks can give a good overview - Algorithm Design by Kleinberg is what we used in school. I find watching videos or going to websites like www.geeks4geeks.org for different data structure examples, and www.beehyve.io b/c it's a community of students taking Data structures -- so there's lots of student recommended resources.
Ok thanks for your inputs ! :) 
Yhea I have take a look to that. There is plenty of .symbole. Not quite easy at first look but I will take care of it. Thanks 
Just scroll through the file until you see a column of 32 bit hex numbers. Those are addresses and the data stored there should be listed next to it. Find out the physical address range of the processors flash and RAM to help understand where your data lives.
60 pages is bigger than many papers I've read. Anyways, someone should develop a distributed RNG service. That would be cool.
Wait what? Only the richest can afford quantum event based randomness? A noise diode is pretty cheap.
No, I said only the richest can afford dedicated hardware using quantum effects. I was referring to dedicated PCIe adapters and stuff
I see. Even then, I'd say it's a stretch that only the richest could because you can buy USB dongles for fairly cheap.
&gt; Turns out, almost nothing is random. In classical physics, nothing at all is, we've got to switch to relativistic physics and study quantum effects to start seeing some true randomness. That's quite a bold statement. Ignoring the pseudo-physics, one of the fastest, simplest ways to implement a good general purpose PRNG is through [xorshift](https://en.wikipedia.org/wiki/Xorshift) and friends.
**Xorshift** Xorshift random number generators are a class of pseudorandom number generators that were discovered by George Marsaglia. Specifically, they are a subset of linear-feedback shift registers (LFSRs) which allow a particularly efficient implementation without using excessively sparse polynomials. They generate the next number in their sequence by repeatedly taking the exclusive or of a number with a bit-shifted version of itself. This makes them extremely fast on modern computer architectures. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
&gt; The problem with today's so called RNG's is that they're not random. What gave them away? [Was it the "pseudo" prefix?](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) ;-)
If you have an hour and really interested in high performance, statistically "good" PRNG, check out this [talk on PCG](https://youtu.be/45Oet5qjlms?t=1s) (Permuted Congruential Generator) 
For anything that's long running or generates lots of random numbers, I like [SFMT](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/), seeded with lots of bits from `/dev/urandom` and/or `_rdrand32_step()`. Or if C++ is an option, use one of its PRNGs and an appropiate distribution from `&lt;random&gt;`, but that's off topic for this sub.
https://www.random.org/integers/
It should be usable from the terminal. This is close, but not quite what I had in mind.
Turns out it also has a [JSON-RPC](https://api.random.org/json-rpc/1/) interface. Should be easy to whip up a script that pulls numbers from it.
What do you mean by "usable from the terminal" ? 
Something I can use from the terminal, or the command prompt if you're a window$ user. like [this](https://fossbytes.com/wp-content/uploads/2016/02/terminal-weather-report-3.jpg).
After 5 min browsing the website, I didn't find a single example of terminal command. I gave up.
That's the great thing about programming. If you can't find a tool to do what you want, you **make** it.
I'll post this here as a separate entry even though it was raised by another user ( protoUbermensch ) : Anyways, someone should develop a distributed RNG service. That would be cool. Please see https://www.random.org/ As for the topic of random numbers generators I think we need a working definition on what a random number is. Personally I don't know what people call a random number unless you want to get a pre-school class of four year olds to all flip coins and then call out heads or tails. Most people flip coins in a predictable manner. They don't just toss the coin flipping over their heads and they don't toss it with a spin kick. Most people eventually figure out that the mechanism involves the thumb and a forefinger and a "kick" of the thumb. Then people practive this to get a neat coin flip upwards straight and downwards into the palm of the hand to catch it and therein you have a predictable and steady seed process that leads to consistency. Not truely random. Papers and research has been done over and over on that topic to a point where it is generally accepted that a coin toss is damn close to random and unpredictable, sort of, but it isn't. ( see https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2789164/ ) So what is random? Here is my approach from the days when I taught classes on the topic. Not that I am any expert nor even a reasonable mathematician. More an engineer and physicist I guess. Regardless I must toss out the idea that what I really want is a perfectly unpredictable coin toss wherein every single toss of the coin results in either a head ( value equals one ) or a tail ( value equals zero ) and that every coin toss event is a singular event with no effect on the next coin toss and no dependency on the previous coin toss. What this means is that we expect to get either a value of one or a value of zero from the coin toss event. The coin has no memory and therefore every event is a single event and not part of a sequence. However we need a whole collection of these perfect events to gather up a reasonable collection of bit values ( zero or one ) in a row to form some output data string of zeros or ones. This is commonly refered to as a Markov process. Not at all an easy thing to create but I can tell you that we expect a perfect zero or a perfect one from every single coin toss event and thus there is an "expectation value" in this sequence of the average 0.5 exactly. So that then leads us to the question of how to make these perfect coin tosses? I can tell you that engineers in second or even third year may get the task to design a coin flipping machine that is perfectly "random" and thus creates a perfect expectation value of 0.5 but many people have tried. most machines have a calibrated spring system or gear arrangement and thus static and unchanged between flips. Some people have smartly tossed in cockroaches and beetles into the machines to really mess up the process. Sadly it is not easy to make such a machine. However it is fun to watch people try. So then we get to radioactive decay of a source like radium for example. We can attach a transducer which produces a voltage level based on the emissivity of the radium source. We can use a shot noise detector that responds to photon packet counts from a noisey source like cosmic background radiation. There are plenty of hardware devices on the market that produce bit sequence data from such sources : https://en.wikipedia.org/wiki/Comparison_of_hardware_random_number_generators Regardless how you slice it up the /dev/random and the /dev/urandom devices in Linux/UNIX is not a source of true random bit sequences but they are provided rater to be seed values to some other tool such as a hardware device. They are legacy devices and they serve a purpose but a more modern approach is the kernel interface getrandom() and even then we are dependant on an entropy pool. The only true way to get a valid markov chain event sequence is to resort to hardware devices that detect quantum noise in some reasonable physical way. Please see : http://www.fourmilab.ch/hotbits/ http://www.protego.se/sg100_en.htm#StatisticalTests As an example an Oracle system with a PCI based hardware crypto source generator may report : $ cryptoadm list User-level providers: Provider: /usr/lib/security/$ISA/pkcs11_kernel.so Provider: /usr/lib/security/$ISA/pkcs11_softtoken.so Kernel software providers: des aes256 arcfour2048 blowfish448 sha1 sha2 md5 rsa swrand Kernel hardware providers: redactedforsecurityreasons_some_hardware_device $ cryptoadm list -p provider=aes256 aes256: all mechanisms are enabled. $ cryptoadm list fips-140 Kernel hardware providers: =========================: redactedforsecurityreasons_some_hardware_device however a coin toss generally works. Just do sixteen of them and write down the bits and then use that value as a integer between zero and 65536 ( 2^16 ). EDIT : please see a brilliant discussion at http://insanecoding.blogspot.ca/2014/05/a-good-idea-with-bad-usage-devurandom.html 
If you're on a microcontroller, you can use uninitialized SRAM to form your entropy. When those flip flops get power, minute manufacturing and environmental differences will make them flip one way or another. Or just hook up a wire to a floating ADC pin and take a few samples. 
Write a script that you can invoke from the CLI and retrieves data from random.org and packages the results however you like.
 #!/bin/bash COUNT=1 MIN_VAL=1 MAX_VAL=100 while getopts c:n:x: opt; do case $opt in c) COUNT=$OPTARG ;; n) MIN_VAL=$OPTARG ;; x) MAX_VAL=$OPTARG ;; \?) echo "Invalid option: -$OPTARG" ;; esac done curl "https://www.random.org/integers/?num=${COUNT}&amp;min=${MIN_VAL}&amp;max=${MAX_VAL}&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new"
You rocks! Thank you so much stranger!
You'd need to measure the quality of your sources, and figure out how much quantity you need. Measuring variances in cpu frequencies, network packet pings, dns lookups etc. If you get a good variance of +-8 bits per source, and you want 64 bit values, you'd need 8 sources. You can mix or shuffle the results if you want, or append, but a good non invertible mix would help if one of your sources wasn't as good as expected. So say you measure pings 10,000 times in nanoseconds. Finding the degree of good (unpredictable) variability gives lets say +-128 nano seconds. We can then use the last 7bits of a ping to dump into our random pool. Of course you'd have to have limits on how often you ask for the data too. Pinging 10 times a second may give far less variance then pinging once an hour. So you variance test would need to include time too.
I don't know how random numbers are generated in modern hardware and systems, but is it like, taking the base numbers from the temperature of the CPU and GPU, mouse pointer position, microphone, free memory, battery level, and the timestamp of the request for the RNG? Mix these numbers in a smart way, and you have a random number.
&gt;semi-paper (it only was around 60 pages) I did the math. I would imagine a full paper would be around 120 pages. I don't see how this relates to C. All programming languages are deterministic. Without an outside source for the seed, the next number can always be predicted.
I would point out, this isn't intended for cryptography.
More or less you have the idea. Take data from a pile of places and hope they are random enough to create an entropy pool source. The a "smart way" is something like Makoto Matsumoto's Mersenne Twister : https://en.wikipedia.org/wiki/Mersenne_Twister The code is trivial to implement and what you get is "pseudo" random. Get the source here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html however the author is clear that "Mersenne Twister is not cryptographically secure."
I'm not really sure what you're asking. This line int i,fact =1,n; ...is declaring three variables: i, fact, and n. fact also has an initializer. It's equivalent to int i; int fact = 1; int n; 
Thank you, I just cloned [the git repo](https://github.com/MersenneTwister-Lab/TinyMT.git). For the "smart way" of mixing the numbers, I had in mind something like the SHA-256 algorithm, mix them in the binary level. I'll take a look at the source code later, though.
omg ok , i read it bad, like ... i equals 1 and fact equals n so i was making a big movie out of nothing happens to me all the time thanks rhomboid
minor hint, stay in the SHA512 algorithm simply because it is a pure 64-bit process and nearly all the computations, rotations, shifts and XOR's can happen inside 64-bit registers. 
**; )**.
In my experience, the number of applications in which one needs "true", unpredictable randomness is small - e.g. cryptography is about all I've been exposed to. I have, by far, been more interested in deterministic randomness that exhibits certain properties like overall distribution or pair-wise anti-correlation, but is overall predictable. And it is often the case that the property of being *deterministic* is actually a key requirement. Here's one example: simulation (of physics, economics, whatever). You often want a model that tracks a real-world "random" process or variable with an appropriate distribution so that the simulation correctly models the the real-world process. And you want all those nice properties about distribution and anti-correlation. However, it is often desirable to rerun a particular execution of such a model to reproduce the same simulation. E.g. so that a 3rd-party could confirm your results. The RNG has got to be predictable &amp; repeatable. A different kind of example: randomized quicksort. This is a basic algorithm that has many wide-reaching applications. Some of those applications may want to leverage the performance randomized quicksort gives them, but their domain requires determinism, so they require that the RNG being used by quicksort be deterministic based on some kind of seed. My current employ is in the space of static analysis of software. Generally the exploration space is huge, so you can only explore so much. One option is to randomly subdivide the analysis space in order to limit what you look at. However, a requirement from the user is that if they rerun the analysis on (almost) the same code, they expect to get approximately the same results. They accept the trade-off that there are false negatives in exchange for the analysis being predictable in order to facilitate tracking of issues for developers to look into (did a code change fix an issue found in the previous analysis, or does the analysis still find the same problem at that point in the code?) Again, it is an explicit requirement that the RNG be predictable.
I work in the embedded world, so entropy sources are sometimes limited - you can't use the number of clock ticks since startup as a seed, for example, because the system will typically boot in exactly the same way every time. The MCUs I use all have internal temperature sensors connected to an ADC channel. They're basically just diodes with known thermal characteristics, so they add nothing to the cost of the chip. I take the low bit of the ADC reading, well below the noise floor, and run it through a von Neumann deskewing algorithm. The disadvantage of this method is that the time it takes is non-deterministic, and I've seen ADCs fail. A von Neumann extractor will spin forever trying to get randomness from a constant value, so it needs a timeout and some fallback entropy source. My implementation uses the [fallback value 4](https://xkcd.com/221/). Most often I'm doing things not terribly critical, like shuffling patterns in an LED hula hoop. (Generating a random permutation based on a seed value without enough memory to hold the entire permutation turns out to be an interesting exercise in small domain cryptography, BTW. I'd totally read a paper on that. It turned out to be too much trouble for my application.) If I'm doing anything secure, it's probably just generating session keys and waiting some milliseconds for the von Neumann extractor is fine.
[Image](https://imgs.xkcd.com/comics/random_number.png) [Mobile](https://m.xkcd.com/221/) **Title:** Random Number **Title-text:** RFC 1149\.5 specifies 4 as the standard IEEE\-vetted random number\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/221#Explanation) **Stats:** This comic has been referenced 742 times, representing 0.4553% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dk792wt)
If you have a new enough CPU, you can use RDRAND. https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide Edit: if you go with /dev/urandom, you can always add something like https://www.vanheusden.com/aed/ to the mix.
I would think that in simulation most people would use (good enough ) pseudo random generator, so finding could be reproduced with the same seed ( or avoid using the same seed again for confirming the experiment )
&gt; Turns out, almost nothing is random. In classical physics, nothing at all is, we've got to switch to relativistic physics and study quantum effects to start seeing some true randomness. [The Dome: A Simple Violation of Determinism in Newtonian Mechanics](http://www.pitt.edu/~jdnorton/Goodies/Dome/)
The compiler has to know the declaration to generate correct code (e.g. MOVSX vs MOVZX, or SAR/SAL vs SHR/SHL). The compiler only reads the source code to find out, so you can always do the same.
I like the cute SETE/MOVZX/LEA trick for if equal return 3 else return 0.
Not really. Once you know the specific steps your algorithm makes, it isn't hard to get the values you want out of it. The key is to get even a **tiny** bit of randomness (usually obtained from the hardware) so that can be 'stretched'. That tiny bit of randomness is required for a good PRNG. Also, many common LFSRs are broken. 
A programmer's editor like Vim is a much more powerful tool than an IDE, but it has a steeper learning curve. If you don't want to put in the effort of learning it now, keep it in mind for when you need more from your editor in the future.
OP is talking about true randomness, not pseudorandomness
[_getch()](https://docs.microsoft.com/en-gb/cpp/c-runtime-library/reference/getch-getwch)
ah alright that works great, thank you
Pretty much this, also learning to use an editor can be useful when working on different systems, you might not have the same tools everywhere. 
&gt; I'd say Knuth is for people who already know the subject well but are looking for deeper understanding. Beginner or intermediate readers will be better off with Sedgewick. That's what I said. &gt; BTW, Knuth was Sedgewick's PhD adviser. [He was even asked about it](https://www.youtube.com/watch?v=M2quf7rMONU)
Get a decent IDE, you still can use CLI, but IDE can do so much more... You can begin with QtCreator, I personally switched from it to CLion (commercial license only) and couldn't be happier. And yes I still use CLI to compile and run my programs, but IDE gives me everything else.
There is no randomness involved here, and the claimed "nondeterminism" is an artifact of the choice of a singular coordinate system. If one chose cartesian coordinate system instead there would be no "nondeterminism" involved, as the direction of travel would be uniquely defined by the acceleration vector at t=T. The solution in cylindrical coordinates is only describing the radial component of the position, and therefore it is correct, but you cannot make any inferences about the direction the ball travels without looking at the polar angle component as well. This is why philosophers shouldn't do physics.
I see, according to my MCU (KL17Z256VLH4), SRAM address start at 0x1FFF_E000 and end up to 0x2000_5FFF (which correspond to 32KB btw). I see a lot symbol of FREERTOS, my variable and placed at the end of the RAM .heap and .stack. That is so cool !
When it comes to C, I still think an IDE with proper debugger integration beats vim. Working with CLI debuggers is not the most comfortable of tasks.
CLI+Vim+plugins is the most powerful development environment you can get. Sure, you have to learn Vim and choose and learn the tools and plugins you need for your workflow to be optimal, but this initial effort will pay in the future. You will be able to do everything you can do with an IDE (and more), but you'll do it your way and without bloated menus and unnecessary tools lurking around.
habarnai ;-)
Neither will help you improve as a programmer. Only writing code helps you learn and improve. If you think emacs and vim are hard to learn then you shouldn't be a programmer. vim is easy. One of the easiest in the world. emacs isn't difficult except there are a lot of things that can be added and modified. With vim, you are either in insert mode or you're not. Beyond that, there are only five, one letter commands to know to edit. How difficult can it be to start with?
&gt; That's what I said. Bah. I thought I was replying to /u/r_notfound. I didn't even notice your comment. Probably need either new glasses or more coffee or both.
Maybe it was rand() and you need a more robust source of randomness. Maybe it was your implementation. Or maybe it was a regular statistal occurrence.
That's just one of the many reasons why Emacs is better than Vi(m). 
You probably want a bugnum-library like the [GMP](https://gmplib.org/) library.
I used to think that was the big downside of CLI development too, but after getting comfortable with `gdb`'s visual mode, I feel debugging can be just as productive on the command line, even without integration in the editor.
Yeah I was just reading about this. Looks like it may be what I need. Now just to learn how to use it...
Any links to a start point for gdb visual mode? I'm currently using cgdb and I'm not too satisfied. I've also the dbgx/lldb.nvim plugin, and I didn't manage to make it work for me. I haven't given up though, but an alternative would be nice.
Or you can build such library on your own :D
I'm not opposed to the idea if it can be done relatively easy. If I have an array of unsigned chars of length 32, representing a 256 bit number when printed in sequence, how would I perform a multiplication operation on it?
Fair enough. Same question though: If I have an array of unsigned ints, where an int is 32 bits, giving me an array length of 8 to represent a 256 bit number, how would I perform a multiplication operation on it?
&gt;Or you can build such library on your own :D Why reinvent the wheel when the library is likely vetted by many, many highly experienced programmers?
I know. Claiming that the entirety of classical physics is deterministic is a stretch by any means. Depending on your definition of "random" one simply needs to look at a simple non-linear system such as a double pendulum for a (in practice) random system. Additionally, the theory of statistical mechanics was designed to deal with systems where in principle they are causal, but in practice can never be treated as such. Any perfectly degenerate system can produce randomness via the instantaneous breaking of state symmetry once a trajectory in the state space is chosen. See below for "the dome" as an example.
With things like Emacs (and vim to a lesser extent), they give you the opportunity to look through source code and add to it, which aids in developing a programming mindset. Neither will outright make you a better programmer, although they do extend your perspective a bit
Start `gdb` and press ctrl-x ctrl-a
But how can you learn without doing things done already?? Why every programmer does Hello World program? even if it was done by thousands of programmers before? And so on...
Same way you do it when multiplying numbers with pencil and paper, having to carry over to the next place.
Actually there are more than two modes on Vim. There is a huge amount of functionalities you need to master properly in order to appreciate all the tools. Not many people can be considered expert in Vim imo. When you are a beginner, you are focused on learning the language, you don't want to learn another sintax only for editing, it is just an effort a lot of people want to avoid. Sure you can learn only the basics, but then what's the point in using Vim, you can use any editor. It is not easy Vim, it is not easy at all.
&gt; With vim, you are either in insert mode or you're not. You might as well use notepad if that's all you're using vim for. 
Whoa.
Should work. There is actually an industry standard for curses, if you restrict yourself to the standard, your program should be fairly portable.
You probably want to use uint64_t (or uint32_t). There's two common ways to represent numbers: two's complement and sign-magnitude. I would strongly recommend sign magnitude. So you have a struct with a uint64_t\*, a size_t to determine the number of uint64_t's, and a signed char to determine the sign. Then addition and subtraction are pretty. Multiplication can be done as raevos said using the grade school algorithm, which is not too hard to implement, but a highly optimized library like gmp will use faster algorithms like karatsuba, toom-cook, or schonhage-strassen depending on how large the numbers get. Division is really hard to do more than a bit at a time even if you're using the most basic algorithm. The most common efficient algorithm for division is Newton's method. If you want to do a/b=c, you compute how many bits c has as len(a)-len(b) and then use Newton's method to find 1/b to that many bits of precision. You will represent this as an integer so it will actually be more like (1/b)\*2\*\*len(c). Then you use your multiplication algorithm to do ((1/b)\*2\*\*len(c))\*a) and bitshift to get down to len(c) bits. Note that you might find it convenient to do parts of the code in assembly because it's easier to get carry/borrow/overflow/ the high word of multiplication. I used 128 bit integers (a gnu extension) to emulate this feature when I made a similar library and it definitely would have been better to use assembly. You can see my library [here](https://github.com/hacatu/comparch/tree/master/a2), but it's quite disorganized because I had no idea how to structure a project.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [hacatu/comparch/.../**a2** (master → bc6cbd1)](https://github.com/hacatu/comparch/tree/bc6cbd12a946b66a50f692b81e9e114f6158b589/a2) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk7s6zw.)^.
*raises coffee mug in salute* I'd say that's a fair characterization (Knuth being for further understanding). I generally rely on the other books as tutorial/overview of how to attack a problem, but I'll reach for Knuth if I actually have to implement the thing in a performance critical context.
Thank you. :) 
This is an amazing response. Thank you!
May be, you should try some cryptography library, they often work with large keys.
I try to follow TDD practices as much as possible (I use CppUTest). I have a basic skeleton that has folders, dummy files, gitignore, and the CMakeLists.txt files I need to build. Right now I'm lazy and just do a copy+paste and find+replace to change the project names. I should write a script to create it automatically. Then I start with all the low level building blocks. Mashing through that code usually gets me thinking about how to do the higher level stuff.
I use the peda plugin for gdb. Maybe try that...
IMHO: neovim + deoplete + deoplete-clang + ctags + tagbar + Nerdtree + Makefiles + cgdb http://imgur.com/a/GHmce 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/mV2JhOx.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[state_of_imgur](https://np.reddit.com/r/u_imguralbumbot/comments/6i1huv/imgur_has_gone_to_shit) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dk7zdi9) 
He said vim is hard. My point is to show him it's not.
No it doesn't. There are two. Insert mode and normal mode. You don't need anything else to edit in vim, though learning the commands is helpful, of course. Even then, you can do a lot with just i,j,k,l. vim is easy. Do you want to delete a line? dd Do you want to delete a word? dw That's far more difficult in notepad where you need to use a mouse, select the line without missing anything, right click and select delete. You want to move down a word? w You want to move back a word? b How complicated is that? You already know how to use vim.
Can your IDE actually do something Emacs or Vim can't?
By giving false statements?
You want to delete everything in ( )? di( You want to move a half page down? Ctrl-d You want to open a new split? :sp &lt;name&gt; You want to change a word in the whole file? :%s/word/new/g You want to use registers? Plugins? Splits? Tabs? What you wrote are the basics but to be really fast in vim you have to spend a lot of time doing stuff and searching for new features. Only this will make you faster.
Then you don't know vim or you are really, really stupid. My son was editing with vim when he was 12. How old are you?
Using the basics is not. Being fast is.
IDEs are usable without weeks of learning. Otherwise the feature set might be very similar.
You've got a point there. But imo investing these weeks is really useful.
Being faster than notepad is easy. You can move around and delete/copy things far faster than notepad and it's one of the first commands you learn. Assuming one can learn things which, by some comments here, is not something to be assumed.
All things are learned when one takes the time to learn them. Most of those things you can't even do in notepad. If you could, then you have to learn them. Just like vim. The basics immediately make you faster than notepad.
Based on the name calling, ranting and not understanding that subjectivity &lt;&gt; fact, I'd be highly impressed if you weren't the 12 year old son you were speaking of. You stated that vim had only two modes, which is incorrect. Whether you think vim is hard or easy to learn is subjective and isn't at all what I'm arguing (literacy is a wonderful thing).
Well you're right, and I didn't say what I meant. What I meant is vim has two modes that one needs for most, basic editing which is what I was talking about which is that vim is not hard. If that is still way over your head then we're done here cause rather than being constructive and showing how easy vim is, you instead want to make this thread about me. Typical redditor.
I'm going through my own issues on here. These...people...are the perfect example of showing their lack of intelligence. Rather than discuss the technicals, they get into rants about using the wrong word or a typo and it devolves from there. This place is the most useless excuse for a forum I've ever seen.
Judging by your comment history, it seems you have quite the history of just calling other people names and belittling them. Extremely opinionated, to the point that if someone doesn't agree with you - you just turn it into a tantrum party and begin acting like a child. Whether you meant to say something different is irrelevant. The information you gave was wrong, and when it was pointed out you became defensive about your stance - this is unjustifiable to your actions of turning into a some tool - **that** is what I'd expect from a typical redditor. Have a wonderful day.
You, /u/icantthinkofone used an alternate account to respond to your own reply? Haha What's the likelihood that, based on comment history, both /u/signup1234567 (an alt account) and /u/icantthinkofone both own a web dev company for 14 years, both brag about making "millions", and both post in /r/StLouis. This is straight hilarious.
Sometimes you have time to learn and create things, sometimes you just have to get a job done. That's the industry we're in. 
Building an arbitrary precision arithmetic library is surprisingly non-trivial. C does not expose instructions like add with carry, subtract with borrow, the carry flag, or the full 128 bit result of a 64 bit unsigned multiply, etc. These features are not portable across architectures, so no languages expose those features. Virtually all arbitrary precision arithmetic libraries are, at their core, assembly libraries with high level interfaces, and possibly a high level fallback which is a few orders of magnitude slower than the "real" implementations. The point is: writing an arbitrary precision arithmetic library isn't even a useful learning exercise for the vast majority of programmers. It's a great learning experience from people who work in a field where they expect to regularly have to break apart their C code and rewrite some of the functionality in assembly, but such people are few and far between.
Why stop at writing your own library? Why not write your own compiler?
Or your own lisp
Nah. I have two accounts cause one other sub here won't accept the other one anymore and I crossed them when replying to a different thread. Same opinion applies, though.
&gt;With vim, you are either in insert mode or you're not. Beyond that, there are only five, one letter commands to know to edit. How difficult can it be to start with? With C, you are either compiling or coding. Beyond that, there are only 32 keywords to know how to write code. How difficult can it be to start with?
What’s your business and company name, I will follow all of your accounts for eternity, you will slip, you will say some identifying information, point is you’re a fake! 
Only a redditor would make a brain dead comparison like that.
Why do you think I care what you think? It's obvious from this thread that you don't think at all but, why am I responding to you at all now (I ask myself)? You can't even stay on topic! 
I’m literally following your posts to ask this question and will until you either admit your bullshit or name a company 
You aren't the only crazed, degenerate to say that over the years so join the padded cell.
gcc ftw \o/
Don’t worry, you will slip, you’d be surprised in the amount of information you actually need to find out about a person, but doubt me if you want - even better, don’t take it seriously, but once you do slip, and if you happen to be telling the truth about your nonexistent company, I will make sure I reach out to all of your clients and ensure they know the jackass they are dealing with. It’s one thing to share an opinion, and another to belittle someone, you think your high and mighty, though if you actually were you would have no problem telling me the company name. But you sit here and say, “just like silly redditors” when you have a thread just to say “Wow” about the Tesla, you are just a really shitty human being, and as much as you think the internet is anonymous, there are ways to collect data very easily.
Sick. Degenerate.
That’s fine by me :) so is being a compulsive liar and thinking your above everyone else! 
It really depends---are you &lt;a href="http://blog.osteele.com/2004/11/ides"&gt;language maven or a tool maven&lt;/a&gt;? If you are more interested in computer languages (or work on multiple, different systems), then a text editor is better as it can edit any computer language [1] (and might be available on the systems you use). Otherwise, if tooling is more your style, or you work in one (maybe two) languages (or a single system), then an IDE will be more helpful. For the record, I use a text editor. I've used the same editor for assembly, C, Lua, Forth, Pascal, Ada, Perl, my own home written language and a few others I'm probably forgetting. Also, I've used the same editor under MS-DOS, Windows, QNX, IRIX, SunOS, Solaris, HP-UX, AIX, Linux and OS-X. [1] IDEs suck for multiple language work. The last time I tried an IDE, it crashed hard on some C code I wrote. I suspect it was because the IDE was a C++ IDE ("but it works for C!" Yeah, right) but I had a structure with a field named "class". Valid in C, not so much in C++. 
He won't be reinventing the wheel if he got a better implementation instead of GNU's
Results of this seem very odd. 18% using Visual Studio, but only 7% using MSVC? Looking at the question it was 'what compilers do you regularly use' which I suppose means that people put multiple, but 18% vs 7% still seems like quite a large disparity. Why are people even using Visual Studio for C?
Thank you for your complete answer
Custom compiler ? seriously ?
Visual C++ compiler, you can compile C code with it too, so most people that have experience with Visual Studio and dont want another dev environment use VS instead
It probably means a custom target for GCC or something (embedded stuff?), or just a small modification to the source code of an existing compiler.
Please format your code with 4 spaces in front of every line so it's readable. Or put it up on pastebin, gist, etc. since it's moderately long.
Look for a 'bigint' library, as working with numbers larger than the processor is designed for is referred to as bigint arithmetic.
`y=(x+x);` is not a formula for how to calculate `y` whenever you need to know it's value, it sets the value of `y` immediately. Since `x` has no value this doesn't do what you intend it to. Set the value of `y` after you get a value into `x`.
ok Meefims , now it works, but if my program is just the one of the top, i have to place that INSIDE the bucle ? so it's gonna repeat all the times ? :/
Yes.
My two guesses are a combination of also using visual c++ already and Windows making things more painful than necessary.... you know to then help with my pain with one of their fine products 
Visual Studio includes Clang as an optional install
For embedded I imagine people saying custom if they use Kiel or IAR, both of which are very popular. Not sure if people consider ARM's version of GCC or Tensilica's version of GCC as custom.
Really great book, and a great reference to have. Coming from a math based background, the work that goes into the proof behind each topic is really helpful.
Have a look at [libkeybinder](https://github.com/kupferlauncher/keybinder). It comes with most distros.
Im no expert but applying atoi and storing the result should take care of converting your char array and storing its elements as ints. Then a few if statements to store the letters as digits, ie if (char_tab[5] == A), int_tab[5] = 10; Sorry if this doesn't help. Ive just been learning C for a few months but thats how I might approach your problem (if I've understood properly)
Can you give an example of what you are trying to do, the explanation is rather muddled. 
*Edit: experienced C coders please correct me if I'm wrong here* A char can be stored as int using values from an [ASCII table.](http://www.asciitable.com/) If you do this: int testletter = 97; printf( "%c %c\n", testletter, testletter +1 ); You get this as output: a b I'm not really sure how you want to use this, though, so I don't know how useful this explanation is to you.
What's the advantage of using GCC over Clang? I've always found the latter made smaller binaries. Does GCC just tend to optimise for speed rather than size?
Do not implicitly check pointer values. list *input(char *file) { char buf[100]; if (file != NULL) return (read_file(file)); else { printf(O_RED "PHRASE :\n" O_NOR); scanf("%s", buf); return format_phrase(phrase); } } Your scanf is storing characters into a temporary buffer. Once you exit the function, its data is lost from the stack. When exiting, you're calling `format_phrase`, passing `phrase` as an argument, which will lead to `format_phrase` **or the next executed functions** attempting to use random stack values. Basically, you're accessing memory you shouldn't access. Try malloc'ing the buffer instead of declaring it like this, and don't forget to free it.
&gt;but how can one store chars as ints? *Assuming x86_64 or i686* `char`s are signed 8 bit integers. `int`s are 32 bit signed integers. Just cast the char's to int's. The casting can be done implicitly but it's good practice to detail your work. The compiler will optimize it anyway. void to_intarr(const char *s, int *arr, const size_t nb) { size_t i; for (i=0; i&lt;nb; ++i) arr[i] = (int)char[i]; } Here's a function I wrote that prints unsigned 8 bit integers as hexadecimal in the format `0x--` static char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }; size_t tty_putn_hex2_short(uint8_t n) { size_t count; count = 0; if (n &lt; 0x10) { count += tty_putc('0'); count += tty_putc(hex[n]); } else { count += tty_putc(hex[n/0x10]); count += tty_putc(hex[n%0x10]); } return (count); } Now try and adapt it to fit your purposes. Do some work!
 int len = strlen(str), result = 0; for(i = 0; i &lt; len; i++) { // each digit is 4 bits of the final value result &lt;&lt;= 4; // could also *16, as each digit ranges 0-15 // add value of next 'digit' if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') // numeric digit result += (int)(str[i] - '0'); else if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'F') // alphabetic digit result += (int)(str[i] - 'A') + 10; } You can add code to make it handle lower-case alphabetic digits, and do error checking stuffs. Alternatively you could use sscanf, which does the same thing. int result; sscanf(str, "%X", &amp;result); https://ideone.com/tXdv2G
Looks fine from over here. Are you getting prompted for a string and then it segfaults? Or does it just segfault before you even get to enter anything in? I can't imagine why it would segfault at all, unless you're not including stdlib.h and your compiler is ignoring the lack of definition and pretending it knows what the function is without linking it to any actual code in the clib. This has happened to me before with sin() and not including math.h. It would compile with just a warning, when it should've been erroring out, and it would run until the sin() call, which would crash it.
This is bad practice. Do not `malloc` in a called function. How do you plan on `free`ing `phrase`? Also, just a note, do not define variables in the middle of a function. It makes everything harder to understand and looks super messy.
Garuda1Talisman is right, but I think there might be an easier way to fix this: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; char *input(char*); char phrase[100]; // file scope! int main() { printf("%s\n", input('\0')); } char *input(char *file) { if (file == NULL) // If the string is null then the phrase is scanned from terminal { printf("PHRASE :\n"); scanf("%99s", phrase); // prevents overflow return phrase; // Return the list of words from the input phrase, parsed into a list } else return file; }
Mind posting your vimrc?
Things you should **NEVER DO**: 1. `if (ptr)`: You can substitute `NULL` by `((void*)0)`, but NEVER implicitly check pointer values. Your `if (file)` can and will get you banned from any professional development environment. 2. Declaring variables in the middle of a function It may seem fine with you. I still don't understand why it's been allowed in C99. You're making your code unreadable, because you read a function first looking at the values it operates on, then looking at the assertion it makes (ex: is this parameter valid? If yes, carry on, otherwise exit with an error) then by looking at the actual algorithm. Imagine the chaos it would be without respecting that simple rule? As an example, let's take your code (my cleaned up version): list *input(const char *file) { char buf[100]; /* Variable declarations: the values the function operates on */ if (file != NULL) /* Assertions. Making sure our code will work. */ return (read_file(file)); printf(O_RED "PHRASE :\n" O_NOR); /* Actual code */ scanf("%s", buf); return format_phrase(phrase); } Let's now forget about the aforementioned rules and basic coding practices: list* input(char *file) { if (file != NULL) return read_file(file); else { printf(O_RED"PHRASE :\n"O_NOR); char phrase[100]; scanf("%s", phrase); return format_phrase(phrase); } }
GCC tends to have some useful non-standard language features that aren't in the standard yet, usually for POSIX systems. A lot of the big ones have been added to the standard over the years, but there are still things like nested functions that haven't made their way in. Aside from the extensions to C, it can also compile programs in languages other than C or even C++ (like MSVC), and it's included with every GNU/Linux distro, so it's easier to work with if you're used to that environment. I believe Apple also ships its own custom version of the GCC with macOS, so it's useful on there too.
There is nothing at all wrong with either of those things you say to never do.
What's your format_phrase() function? scanf() reads a single word, so calling it phrase is kind of odd. And if you are getting a segfault in it, that word is over 99 characters... The only good advice I've seen here is to use %s with a length limit. Raw %s in scanf() is as bad as gets() - no way to use it safely.
Your code will compile, but if you think this is good practice don't ever work with me. Code needs to be organised.
If you mean that you have a string holding a number in base 16, use strtol() to convert it to a an int or whatever.
Doing things like defining a variable at point of initialization is being organized, yes. As well as being less prone to errors like accidentally using it before it holds a meaningful value. Not just good practice, best practice. Wanting to explicitly compare a pointer to NULL suggests a lack of familiarity with the language and its idioms. So, yes, I hope for the sake of my sanity you're never a coworker. 
This 100%. 
&gt;As well as being less prone to errors like accidentally using it before it holds a meaningful value So you suggest making the code less organized to avoid being stupid? &gt;Wanting to explicitly compare a pointer to NULL suggests a lack of familiarity with the language and its idioms. That's pure elitism - Code should be understandable by everyone. If you want to make things more abstract because it looks too "beginner-ish" for you, then you're just a dick.
Thanks this looks like just what I wanted.
&gt;So you suggest making the code less organized to avoid being stupid? I'm pretty sure /u/raevnos is suggesting it makes code *more* organized and he would be correct, which is why big projects such as FreeBSD (often lauded as an exemplar C codebase) and Linux make extensive use of the style. It is particulary useful in cases where you're inside a conditional block and need a variable to do something that's not relevant to the rest of the function, like this: if (some condition) { int error; // never used outside of this block /* do something with error */ } &gt;That's pure elitism - Code should be understandable by everyone. If you want to make things more abstract because it looks too "beginner-ish" for you, then you're just a dick. I personally prefer explicit checks myself but the parent is not completely wrong about this; saying you should **never** do something that is *that* idiomatic is incredibly silly. 
But it only supports C89
tbh c89 is well enough for most things and most beginners
yeah no problem: https://github.com/elsuizo/Dots_files/blob/master/Vim/nvim/init.vim is based in this cool config: https://youtu.be/xZTkrB_tEoY Whit: Alt + t ---&gt; open the terminal split window F8 --&gt; tagbar leader(in my case is ,) + F ---&gt; NerdTree Enjoy!!! 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [elsuizo/Dots_files/.../**init.vim** (master → da483fd)](https://github.com/elsuizo/Dots_files/blob/da483fda2ba9075b222e7167c0530435433cfaeb/Vim/nvim/init.vim) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dk9dwc4.)^.
Why are all the unit testing frameworks C++? I feel like a bunch of C++ programmers got confused and took this survey by mistake or something.
Wouldn't that fit better under 'other'? 
I think it looks very usable. I'd like to see a README describing its usage, maybe a sample project. One thing of note is that `hashmap_free` makes no attempt to free the values stored. That's a legitimate decision, but it should be clearly documented. Still, pretty cool. 
&gt; I basically want to hard depend on musl libc and thus preventing portability. I'm a bit confused. You intentionally want your code to only work with musl? I am asking in case English isn't your primary language. 
C99-ish since 2015 if I remember right.
The difference between Emacs and vi/Vim users is notable. Why is that?
Emacs can use `gdb`.
Thank you for the feedback and suggestions. I have gone ahead and added them, along with an example program.
You could add an optional callback to `hashmap_free` so the user can release entries if he wants.
In C, you don't have to do anything special to store characters as ints, since they are already stored as ints regardless of being type char. Type char is no different than type long, unsigned, or long long, in that they all have the base type of int. The only difference is in how much memory each of them uses for storage. To put a finer point on it, to the computer, there is no such thing as decimal, hexadecimal, octal, et al. They are all ints stored the same way in memory (in binary). They are only abstractions that help you, the programmer. You can print the same int from the same memory location as any of these forms by way of printf(). The only difference with char is that it won't print the int as char if the int isn't within the range of chars (ASCII, Extended ASCII...whatever your system is set to use). Here is a simple example that may help you with this confusion: &gt;#include &lt;stdio.h&gt; &gt; &gt;int main(void) &gt;{ &gt; int i; &gt; &gt; i = 15; &gt; &gt; printf("int i = %zd\n", sizeof(i)); &gt; &gt; i = 0xF; &gt; &gt; printf("int i = %zd\n", sizeof(i)); &gt; &gt; i = 15; &gt; &gt; printf("15 as int: %d\n", i); &gt; &gt; printf("15 as hex: %x\n", i); &gt; &gt; printf("15 as char: %c\n", i); &gt; &gt; return 0; &gt;} This produces the output: int i = 4. int i = 4. 15 as int: 15. 15 as hex: f. 15 as char: As you can see, they both take up 4 bytes and are stored exactly the same way in memory. The ability to print the int in various forms using the printf() conversion specifiers is a service provided by the language but has nothing to do with how ints are stored in memory. Edit: Reddit formatting is like sliding down a razor blade into a pool of alcohol. Edit 2: If you look at an ASCII chart you will notice that for each character there is a column for the decimal, hexadecimal, and octal, representations. Those are representations of the int that is stored in memory for that character. There is no special flag in memory that designates this number as a char rather than an int. That distinction is made by the C language in how you represent it in code. The compiler handles this distinction based on how you represent it in code. Hint: You can store 0 - 15 in 4 bits.
I'm ok having only one daemon managing key-bindings.
What?
That seems like a viable option. I've tried implementing it [here](https://github.com/Encrylize/hashmap/commit/55d2f953ed82411acdcc45aff601913a3439b6f3), although I haven't tested it yet.
Yes. The goal is to prevent portability.
ncurses is rare, `scrollok( my_win, TRUE )` ? &gt; The `scrollok()` function enables scrolling. That means any text displayed after the last line, or a newline or line feed on the last line, pops text up by one row in the window. The top row of text is lost, and a new blank row appears on the bottom to allow for the next text. &gt; The `scrollok()` setting is inherited by subwindows. If you set `scrollok()` `TRUE` for a window, then all its subwindows will also have the ability to scroll. Otherwise, new windows and new subwindows start out with `scrollok()` disabled. &gt; Text can be manually scrolled by using the `scroll()` or `scrl()` functions. &gt; Pads cannot be scrolled. Trying to apply `scrollok()` to a pad returns `ERR`.
That's pretty much what I tried without success. :-(
To the parent window?
ok, ncurses is rare!
Ah. I just saw your edit. I applied `scrollok()` to the content `WINDOW` which may be the reason why it only displays the last instead of the first few lines. But I want to be able to scroll up and down and `wscrl()` seems to delete the text. Which might be because of: &gt; The top row of text is lost, and a new blank row appears on the bottom to allow for the next text. How can I make it stop lose the lines of text which were scrolled off the visible area?
i think its imposible you have to program your own scroll anyway look http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/NCURSES-Programming-HOWTO.html (or my copy repo https://github.com/nasciiboy/NCURSES-Programming-HOWTO/) and https://nasciiboy.github.io/prog/cobaya.zip （´＿｀）
To quote /u/FUZxxl &gt; But why? Why would you want to do that?
I like it - The code is clean and the interface is fairly nice and simple. The only things I'd add are all related to the freeing others have commented on, and I think the big thing to recognize (That you may have already realized) is that freeing a hashmap generally stinks, because iterating over a hashmap stinks. Thus, if you're willing to expand the scope of this project a little bit, you might consider including a simple memory-pool-based allocator. Such a thing can be fairly simple to create (Though there are a few things you have to keep in mind, like alignment requirements), and then users of the hashmap could use your alllocator to allocate their key's and value's - with the idea being that when they're done with the hashmap, they just free the allocator, which then frees all of the associated memory-pools (And thus, frees all the keys and values at once without having to iterate over the hashmap or the keys/values). As a bonus, you could use the allocator internally to allocate your `Pair`s, and since all the `Pair`s are the same size it would be very efficient. If you did this, you could avoid ever needing to iterate over the hashmap in your `free` function because you could free all your `Pair`s by just freeing the allocator. You could even get fancy if you wanted and loop over the entries in the allocator instead of the hashmap to free the key-value pairs if the user requests to do that. Also, you may or may not know this, but you don't need to test a pointer for NULL in a condition - when a pointer used in a condition it is implicitly compared to NULL, with a non-NULL pointer being 'true'. So `if (ptr != NULL)` can be just `if (ptr)`. Lots of people do the explicit comparison anyway, so it's up to you, but personally I prefer not to have the explicit comparison.
Formatting it by putting 4 spaces in front of each line helps readability for code: #include &lt;stdio.h&gt; int main(void) { int i; i = 15; printf("int i = %zd\n", sizeof(i)); i = 0xF; printf("int i = %zd\n", sizeof(i)); i = 15; printf("15 as int: %d\n", i); printf("15 as hex: %x\n", i); printf("15 as char: %c\n", i); return 0; }
It's common practice to use c++ test suites for C code. They work just fine together.
Visual Studio if you're on Windows.
No,that thing requires me to build a project n stuff.I am not touching it with a ten foot pole.
Maybe experiment with the colour scheme more in codeblocks ... you can use literally anything
Netbeans was the first IDE I used for Java, though I am sure you can program in C too. It definitely has a dark mode that I enjoyed using
Have you tried to use a different colour scheme with Code::Blocks ? Here http://wiki.codeblocks.org/index.php/Syntax_highlighting_custom_colour_themes pick your choice from Black to Solarized and others ... 
CLion has a very nice dark theme (if you're a student you can have the full version for free)
Try https://www.amazon.com/gp/product/B00NYBRH30?ref=dbs_P_W_p2e_popup_T1. It's really good. 
Emacs
You can have as many header files as you want. The C programming language doesn't know about the concept of header files. The only thing it knows (resp. the preprocessor knows) is that you can include files using the `#include` directive. Everything else is just convention. So if you want to have a single header file for everything that is fine. If you want one header file for each source file, that is fine, too. If you want to have headers for each group of functions with no correspondence between headers and source files, that's fine, too. Just do what you think suits your project most.
In my experience most emacs users prefer functional programming languages
Apple has replaced gcc with clang and symlinked it (by now)
Visual Studio by now also makes it able to compile remotely via gcc etc. – but I guess that just a couple of C++ wuzzies answered because they don't know the difference anyway ("C++ is a superset of C" or even "C++ is the successor to C")
as a Vim user for years and still didn't find a proper replacement – some things vim cannot provide, by design. Thinks like code minimaps for example and anything that requires stuff that's not possible to properly do with text. I mean, these features I do kinda want but they won't get me away from vim as long as there's nothing that can replace all the other features I need
mingwstudio: the unheard of. I swear by it.
This is an aspect of C (and by extension C++) programming that newbies frequently have a problem with. I think the best way to overcome the confusion concerning header/source files and includes is to get a basic understanding of the concept of a [translation unit](https://en.wikipedia.org/wiki/Translation_unit_\(programming\)). Typically each *source file* (*.c* or *.cpp*, *.cxx*, etc. in C++) in a project represents a single translation unit. It's the job of the C preprocessor to turn a source file into a single *translation unit* by expanding macros, performing *include* resolution, processing `#ifdef` blocks, etc. The translation unit is then converted into object code (e.g. *.o* files) by the *compiler* and then that object code is linked together by the *linker* into *executable* code (e.g. a standalone executable program, a library, etc.). It's much more useful (and correct) to think in terms of translation units rather than "source files". For example in a [unity build](https://en.wikipedia.org/wiki/Single_Compilation_Unit) scenario all of your "source files" become a single translation unit. Each translation unit needs all of the **declarations** for the types, functions, etc. it makes use of. So we put the declarations of things that need to be shared by multiple translation units into header files that may be `#included` safely across several translation units. However, things like functions may only be **defined** (i.e. implemented) in at most one translation unit, otherwise you will get duplicate definitions at the linking stage, which is an error (an exception to this is if the function is marked as `inline` or `static` which changes the linking behavior of the function). That is, there would be two identical *symbols* with conflicting definitions. So if you wanted a single header and 20 source files that would be fine. The main gist is that any declrations that need to be shared between translation units should be put into a header file that can be safely included. How these declarations are partitioned across files is completely up to you. I wish I knew of a decent resource that spelled all this out in a way that was beginner friendly. I think a lot of newbie problems regarding source files/headers/compiling/linking/etc. just boil down to not understanding the different phases of the tool chain in general and some fundamental concepts of how the compiler and linker transform source into executable code.
please explain me last two lines"Last return statement" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* A binary tree node has data, pointer to left child and a pointer to right child */ struct node { int data; struct node* left; struct node* right; }; /*Function protoypes*/ int getWidth(struct node* root, int level); int height(struct node* node); struct node* newNode(int data); /* Function to get the maximum width of a binary tree*/ int getMaxWidth(struct node* root) { int maxWidth = 0; int width; int h = height(root); int i; /* Get width of each level and compare the width with maximum width so far */ for(i=1; i&lt;=h; i++) { width = getWidth(root, i); if(width &gt; maxWidth) maxWidth = width; } return maxWidth; } /* Get width of a given level */ int getWidth(struct node* root, int level) { if(root == NULL) return 0; if(level == 1) return 1; else if (level &gt; 1) return getWidth(root-&gt;left, level-1) + getWidth(root-&gt;right, level-1); }
&gt; double averagearray(int,int); This is a prototype declaring averagearray as a function that takes two ints and returns a double. &gt; avg = averagearray( array[7], size); You call your function with two ints, however that array access is out of range because array only has 7 elements and you're trying to use an eighth. You're also calling it twice for some reason, and before you actually fill the array with numbers supplied from the user... &gt; scanf("%d",array[7]); Again, out of range of array, plus scanf() needs a pointer to an int for a %d format specifier, not an int. And that will only read one number when fixed, when it looks like you should be reading enough to fill the array... &gt; double averagearray(int array[7],int size){ Here you define the averagearray function as taking a pointer to an int (The length of the array here is ignored; see http://c-faq.com/aryptr/aryptrparam.html) and an int as arguments, and returning a double. See the issue? Go back to the prototype if you don't. 
thanks for the input, ill work on the solutions.
Source code of what?
i seem to have got it to work, but when i test the variables of size 7 array, values {78,90,56,99,88, 68,92} it just stops at 88 and calculates the avg which it prints as 3041235.56 or something which is clearly wrong... #include &lt;stdio.h&gt; double averagearray(int values[], int size); int main(){ int values[] = {0}; double avg; int i; int size; printf("Enter the size of the array\n"); scanf("%d",&amp;size); printf("Please enter values to fill the array"); for (i = 0; i &lt; size; ++i){ scanf("%d", &amp;values[i]); } avg = averagearray(values, size); printf("Average = %.2lf\n", avg); system("pause"); return 0; } double averagearray(int values[], int size) { int i = 0; double avg, sum = 0.00; for (i = 0; i &lt; size; ++i) { sum += values[i]; } avg = (sum / size); return avg; }
&gt; int values[] = {0}; values is an array with a single element. Trying to store more than one number in it means you go out of range which means anything can happen since it's undefined behavior. Otherwise, looks much better!
how can i set everything in values to be 0 so no random numbers that take up memory would be used.
I direct your attention to this line: int values[] = {0}; 
Try stepping through it with GDB
&gt; Coming form Java &amp; Python and trying to learn C...My question: do I really need to have a .h file for each .c file in my library? For instance I need token.h that can be included by TokenList, or can TokenList just include token.c? What would be the bast practice and why? One way to think about headers is as something like a Java Interface. The preprocessor is basically just copying and pasting the contents of the header into the source file you gave the `#include` in, which means it is up to you to choose how to use the headers, and behaving like a primitive Java Interface relies on the honor system. Generally, you don't need a header for each source file. But the way I would do it, based on your example, is to create a `token.h` that has a declaration for a token `struct` and names any `token_*` functions I desire to be "public". Then I would `#include "token.h"` in `token.c` and I would define a token `struct` in `token.c` as well as implement the "public" functions. Now, I am free to add `static` functions (something akin to "protected") to `token.c` and only `token.c` knows what exactly goes into a token `struct`. I can compile `token.c` into an object file and other programs can link against it, they need only `#include "token.h"` to see what "public" interfaces have been defined. So `TokenList` would `#include "token.h` and link against `token.o` but would not know about the inner workings of what makes up a token. You've effectively encapsulated the token into a nice separate module. This is not the only way to use headers/translation units, but it is the way I would recommend as a general rule of thumb.
Flash usage might be a bit less than text+data. For example the IAR suite compresses the .data initializer block with LZMA or something, and decompresses it during app startup.
LZMA would be surprising considering how much memory the algorithm demands. Surely, if you have enough flash and RAM to run LZMA, compressing the data segment is not really a necessity. 
i am setting all elements to 0 that shouldnt be an issue, especially since i have this here to have the user add the elements manually printf("Please enter values to fill the array"); for (i = 0; i &lt; size; ++i){ scanf("%d", &amp;values[i]);
I just ran this code without changing anything and inputting the same values as you. It spat out 81.57, like it should.
what did you use to run it?
&gt; i am setting all elements to 0 that shouldnt be an issue How many elements is that?
https://gyazo.com/0217cbcce82adb72c3c861b27f579be8
**[Fixed your link? Click here to recheck and delete this comment!](https://np.reddit.com/message/compose/?to=Gyazo_Bot&amp;subject=delete&amp;message=delete%20dkb583r)** ***** Hi, I'm a bot that links Gyazo images directly to save bandwidth. Direct link: https://i.gyazo.com/0217cbcce82adb72c3c861b27f579be8.png Imgur mirror: http://i.imgur.com/N4UcoUM.png ^^[Sourcev2](https://github.com/Ptomerty/GyazoBot) ^^| ^^[Why?](https://github.com/Ptomerty/GyazoBot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/u/derpherp128) ^^| ^^[leavemealone](https://np.reddit.com/message/compose/?to=Gyazo_Bot&amp;subject=ignoreme&amp;message=ignoreme)
Compiled and ran using Dev-C++ https://gyazo.com/232e944aa264d3ae3b6ada272d6ab4d5 I notice your first input is a line below mine. Are you pressing enter before you input any values?
how many elements is linked with what is the size of the array the user chooses. or did i do this wrong? int values[] = {0}; double avg; int i; int size; printf("Enter the size of the array\n"); scanf("%d",&amp;size);
The number of elements is determined solely by the array declaration. I.e. this line: int values[] = {0};
i fixed the problem and my program runs as expected now. i set the base size of 100, but when the user inputs the size of the array, and adds the number of values for the size it works now. int values[100] = {0}; 
no i am not pressing enter before, which would be weird for it to do that since there is no \n for space edit: nvm my updated program has a \n where you would input values, thus why its below
That's a solution. But, suppose the user wants to enter 101 values?
thats my issue, how can i set the size to be what the user inputs it to be?
I suggest you reread the section on arrays from whatever source you're learning from. If you're learning C99 or later, there should be a section on variable length arrays (VLAs).
What compiler error do you get? We can't help you fix it if don't tell us what the issue is.
I used gcc and it works fine. 
If you're asking the user for the size, you need to use dynamic allocation, you can't use an array (of automatic storage duration.) And you will need to initialize each value to zero after allocating the array. All these problems go away if you use `std::vector`. 
bsd mostly, if i'm not mistaken.
I am compiling directly in the raspberry pi terminal. the command I issue is: ___ " sudo gcc button2.c -o bunton -l 'sdl2-config --cflags, sdl2-config --libs, wiringPi' " the response is: ___ " /usr/bin/ld: cannot find -lsdl2-config --cflags, sdl2-config --libs,wiringPi collect2: error: ld returned 1 exit status " 
No, you can group all the structs and functions into one header and one implementation file, if you want, one header for each item (structs, variables, functions, etc), an implementation file per function, and anywhere in between. It’s up to you to decide how header and implementation files work in your project. Now, as a rule of thumb, you should have one implementation file per header, but that isn’t required. For example, you can write ‘header libraries’, where the implementation is in the header itself. If you have a reason to split things up in a weird way, you can also do that. As a rule of thumb, you should not include headers in other ones, so this seems like a time to group those two structs together, unless you’ll want to reuse Token without TokenList, as this way, anything using Token will not have TokenList imposed on it without need. If the latter is the case, separating them is what you want. If reusability is not a concern here, merging them would be the traditionally more correct way of doing it. I know this subreddit is about C, but given your background in Java, you might be more comfortable in C++, at least at first. If you decide to go with that, then luckily for you, C and C++ are interoperable, meaning you don’t have to scrap what you have. (Also, do not include implementation files; that is Bad and Wrong.)
`sdl2-config` is a command line tool you have to use to get the appropriate flags. Try the following: sudo gcc button2.c -o bunton -lwiringPi -lSDL2_mixer $(sdl2-config --cflags) $(sdl2-config --libs)
[This gave back a similar response.](https://imgur.com/d5F7P0Q) Good thinking though the error is either the way I am issuing the compile command wrong or I installed SDL2 wrong. I even tried installing via [this method](https://youtu.be/Yo7hO7GZ-ug). But I did not use the IDE. Do you think an IDE would fix it?
I've never written C in an IDE, so no idea about that. Looking at that error message, are you sure you've installed SDL2_mixer? It's not included in the main SDL2 package, so it requires a separate download.
First of all thank you for your time. I installed sdl2_mixer via: ___ sudo apt-get install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev libsdl2-mixer-dev As part of a guide from [this page.](http://computingvoyage.com/2114/installing-sdl2-on-raspbian-jessie/)
Case matters. Try -lSDL2_mixer instead of -l sdl2_mixer. Also, you generally don't want to be compiling stuff as root.
Same error :/ I will have to try a fresh install of SDL
I commend your ability to lead this guy through his problem. I wouldn't have gotten past "lol" but then, I am not a patient person.
This is a fundamental concept you'll learn in C programming. You only get the memory you ask for, and if you use memory that wasn't yours, it crashes. Higher level programming languages often hide this aspect of programming from you, and do the memory allocations and deallocations "behind the scenes", this is where garbage collectors come into play. C is known as an "unmanaged" language, in contrast to a language with a garbage collector "managing" memory for you. Edit: it won't always crash immediately, if the memory happens to be in a lucky (or really, unlucky) location. This is a common source of difficult to debug problems.
Just an alternative solution in case you want it. You might try using BlurrrSDK for Raspberry Pi. Blurrr is a download-and-go SDK containing everything you need in the .zip download. It comes with a bunch of pre-built libraries (including SDL) and CMake based cross-platform build system generator for your project (it creates Makefiles for Pi). Note: Blurrr provides pigpio instead of wiringPi and ALmixer instead of SDL_mixer. Here is a Simon game demo using SDL+pigpio+ALmixer. https://www.youtube.com/watch?v=vg-unbjdBHQ This is a simple sample project demonstrating SDL+piopio in Blurrr. https://bitbucket.org/blurrr/simplegpioc (I can help you add the audio bits to the example if you need help.) Blurrr SDK is currently in open beta and free to download at: https://blurrrsdk.com 
Couldn't you declare the array after the size variable is assigned then initialise the array with "size" size? Eg: int values[size] // size having been set already by the scanf 
I have heard and use mingw on a daily basis,never knew they had a ide.Gonna try, thanks 
Yes, you can and that avoids the problem of using a fixed limit on the size of the array. However, what happens if the user enter a ludicrously large value for size? E.g. 2147483648.
It seems to me that you're over thinking this problem a little. Assuming that there isn't another part to this question that you've left out, it doesn't mention anything about assigning the array size based on user input. So long as your average function takes the proper parameters and returns the correct answer in the correct format, consider hardcoding the rest maybe? It seems that you're having problems on something extra that you've added that isn't in the question. 
so I'm writing C for maybe 22 years and yet think WTF. that's very cool input.
If I'm not mistaken, here's what you're looking for #openbsd-daily @ Freenode here's the blog post: https://blog.tintagel.pl/2017/06/09/openbsd-daily.html
ha... this is it.. thanks.
Probably unusual/unlikely, but maybe try putting `-lSDL2_mixer` at the end. It is possible that SDL is installed somewhere else and the `$(sdl2-config --libs)` includes the SDL-libraries folder, but the compiler sees `-lSDL2_mixer` first and not `-L/what/ever/the/path/is`. Also, do you have the binary package installed? (`libsdl2-mixer-2.0-0`, but should be automatic when installing the development libraries)
Compiled as soon as I put `-DWINVER=0x501` before `test.c` (and fix compilation issues). You may want to do `#define WINVER 0x501` at the beginning of the file.
this is so cool i almost want to make some fake accounts just so i can upvote more
I feel like C is the deconstructivism of programming.
No, they usually mean you're missing a library. But *sometimes* they can mean that you're missing a header that redefines a name (e.g. `#define getaddrinfo win_getaddrinfo`), causing the linker to look for the wrong one.
Actually, to my research, these functions exists since 0x501 (Windows XP i think). Without that, I also get that the function hasn't been declared before (so the header only declares them using the specified `WINVER`). Also, this is some Windows header file, so probably they change the name anyway to something like `getaddrinfoW` using a macro. Without the `WINVER`, the compiler, as said, generate a warning and tries to find `getaddrinfo` in the library, where the real name is actually something like `getaddrinfoW`. I hope you understand what I meant.
Ah well, I stand corrected. I was thinking of the "implicit declaration" warning. With those, it usually tells you what header you're missing too.
Client side security alone isn't security.
Yup!
Fun article, and this technique can be used for a lot of things. A few notes: - Declarataions in the head of a `for` loop require C99/equivalent or better. - As the author noted, subject to weirdness if the programmer uses `break`. `continue` should work nicely as an escape construct for once-through constructs, however. Unfortunately, standard C doesn’t give you a way to do a proper cleanup (e.g., for lock/unlock or try/finally-type constructs)—in the presence of `break`, `goto`, `longjmp`, or C++ `throw`/similar, any epilogue code will be bypassed. GNU C grudgingly gives you `__attribute__((__cleanup__))`, which could be worked into this scheme. It also gives you `({})`, which makes it possible to introduce statements, labels, and even function definitions into the head of a `for`. IIRC some Clangs and OpenCL C 2.0 also/instead give you blocks that basically act like lambdas. - Nitpicking, but the first loop for (; (*to = *from) != '\0'; ++from, ++to); can be dropped to while(*to++ = *from++); —no need to use a full `for`—though I’d write it as while(!!(*(to++) = *(from++))) (void)0; or something along those lines. (Superfluous inner `()`s for clarity w.r.t. precedence of `*•` vs. `•++`, superfluous `!!` to notify the reader and compiler that I’m fully aware that `=` is not `==`, superfluous `(void)0` so the reader doesn’t miss the `;` terminating the loop and the compiler doesn’t think it’s a mistake.)
&gt; He won't be reinventing the wheel if he got a better implementation instead of GNU's Are you *really* suggesting that the guy who is too ill informed to know how to solve his coding problem and turns to Reddit for a solution is somehow going to write a *better* library than the one contributed to by **HUNDREDS** of professional coders that have refined the GNU library over the last ***TWENTY+ YEARS***?? Delusional. 
&gt;But how can you learn without doing things done already?? You can learn from the experiences of others *without* recreating their steps. When I learned to drive, I also learned to fix my car. I didn't have to invent the model-T and create the auto industry to do it. &gt; Why every programmer does Hello World program? even if it was done by thousands of programmers before? And so on... Are you *seriously* comparing the first steps a beginner makes to the creation of a robust and well tested mathematics library? If the answer to your own questions isn't self evident, then programming probably isn't for you.
Don't do any of those things if you want to keep your job.
C is probably not the best language for this. In something like python, ruby, PHP etc, this would be trivial. However, it can be done. Have a look at [onion](https://github.com/davidmoreno/onion) or [haywire](https://github.com/haywire/haywire). 
The first thing that comes to mind is something along the lines of `int values[min(size, SOME_LIMIT)] = {0};` but this seems inefficiant. What is considered the "correct" way of handling arrays sized by user input? 
Get a library that supports HTTP connections. Then, hash the content of your files (`a.html`, `b.html`, `c.html`), and save the digests as constants in a header. Now your program should use the library to establish a connection with a server, and fetch the file to hash its content using the same hash function. The rest is done with a `switch` statement: switch (hash(fetched_file)) { case HASH_A: system("shutdown now"); break; case HASH_B: system("restart"); break; case HASH_CA: system("shutdown 1"); break; default: fprintf(stderr, "Remote file doesn't match, possible data corruption?\n"); break; } I suggest a simple hash function, like MD5 or SHA-1. Security isn't required here so you shouldn't care about collisions. Note that MD5 is 128 bits, so you won't be able to store the hash as an integer and your `switch` statement will have to be replaced by cascading `if (!strcmp(hash(file), HASH_X))` statements. 
There's no way to know exactly what to pick for SOME_LIMIT. It depends on how much stack space you have. If you go this route you just have to stick to something "reasonable." Allocating an arbitrary amount of stack space based on user input is dangerous. It introduces an exploit similar to how buffer overflow attacks work. At the very least it introduces an easy way for users/testers to crash your code with unpredictable results. The alternative is allocating `values` on the heap using `malloc` or `calloc` which, in theory, return `NULL` if they fail. Allocating a huge chunk of memory on the heap is also bad, but not as bad as blowing out the stack. So, you'd still want to use a "reasonable" limit, but you should be able to handle much more than when using the stack. For a homework assignment like this, allocating values on the stack, even without limit testing, is a reasonable thing to do, but it's good to be aware of the limitations of your code.
There's no way to know exactly what to pick for SOME_LIMIT. It depends on how much stack space you have. If you go this route you just have to stick to something "reasonable." Allocating an arbitrary amount of stack space based on user input is dangerous. It introduces an exploit similar to how buffer overflow attacks work. At the very least it introduces an easy way for users/testers to crash your code with unpredictable results. The alternative is allocating `values` on the heap using `malloc` or `calloc` which, in theory, return `NULL` if they fail. Allocating a huge chunk of memory on the heap is also bad, but not as bad as blowing out the stack. So, you'd still want to use a "reasonable" limit, but you should be able to handle much more than when using the stack. For a homework assignment like this, allocating values on the stack, even without limit testing, is a reasonable thing to do, but it's good to be aware of the limitations of your code.
MinGWStudio is an independently made IDE by one guy a while back. He has since disappeared and someone else now maintains packaging it with the latest versions of GCC/MinGW. Yes, everybody knows MinGW, but when it comes to IDEs they have only ever heard of DevC++ or CodeBlocks. I discovered MinGWStudio back ~6-7 years ago by accident and tried it, have used it since.
Yea if the linker can't find it then the mixer library isn't installed I guess? Do you see the library in /usr/lib? Try running: ls -l /usr/lib/lib*mixer* 
Hard to say for sure without seeing actual code, but maybe they're trying to have a variable length array at the end of a structure [like so](https://gcc.gnu.org/onlinedocs/gcc-7.1.0/gcc/Zero-Length.html) and aren't using C99 or better, where this is actually supported, for some reason.
It's part of sqlite (I think, they gave away everything so everyone can use it). http://www.sqlite.org/slt/vpatch?from=1d627f5850e271cf&amp;to=f85e9769888f9e76 And, yes, that looks like the pattern they are using. Sometimes old code hangs around a long time. Thanks!
If you do `malloc(sizeof(struct ThingyList))` then it will contain one item. However you can make the block as large as you want, e.g. `malloc(sizeof(ThingyList) + sizeof(ThingyItem) * 49)`. In this case there are 50 items in the array, one in the header and then 49 in the block that comes after. The standard specifically allows and blesses this. In C99 you can make the size zero to avoid the chance of an off-by-one error, but the principle is the same. And SQLite targets C90 so they can't use that. 
 struct VdbeFunc { FuncDef *pFunc; /* The definition of the function */ int nAux; /* Number of entries allocated for apAux[] */ struct AuxData { void *pAux; /* Aux data for the i-th argument */ void (*xDelete)(void *); /* Destructor for the aux data */ } apAux[1]; /* One slot for each function argument */ }; /* Later */ int nAux = (pVdbeFunc ? pVdbeFunc-&gt;nAux : 0); int nMalloc = sizeof(VdbeFunc) + sizeof(struct AuxData)*iArg; pVdbeFunc = sqlite3DbRealloc(pCtx-&gt;s.db, pVdbeFunc, nMalloc); Looks like it allocates more memory than `sizeof struct VdbeFunc` `iArg` additional entries for `struct AuxData`.
You only jump over a condition. I wouldn't call it a bypass, just because you run gdb in root. Unix authentication program (like su) run in 'client side'. So, you can 'bypass' it only if you already have... root permissions.
:)
Deck is an array of struct cards, 52 cards in length
So each struct holds the suit and the rank right. Would that be more useful than having a struct full of arrays. Each array being a suit and filled with the ranks. 
Depends entirely on what you're doing. Usually an array of structs is easier to work with. Sometimes using an array for what would be each field in a struct can be better, though - for example, in high performance number crunching code so it's more easily vectorized with SIMD instructions. That doesn't really apply if you're implementing a deck of cards, though. Stick with an array of structures for that. 
I have implemented a virtual machine in C for an industrial control language set (IEC-61131) - See https://iec61131.wordpress.com/ and https://bitbucket.org/rob_au/61131. Other projects that you could look at include: * libz80 - An emulator of the Z80 processor (C library) - https://github.com/ggambetta/libz80 * uJ - Java VM for microcontrollers (written in C) - http://dmitry.gr/index.php?r=05.Projects&amp;proj=12.%20uJ%20-%20a%20micro%20JVM * EmbedVM - Small embeddable virtual machine for microcontrollers with a (very simple) C-like language front-end - http://www.clifford.at/embedvm/
Lost me at vectorized 
Alright man so I'm supposed to have a deck of cards. Each struct is a card. But I can't initialize that. How would you go about labeling the structs (or cards) as the correct rank and suit. Or should I just initialize all 52 cards. That doesn't seem like the answer 
"professional coders", lol. "TWENTY+ YEARS", twenty years of historical cruft.
Nested for loops maybe. It seems that's always the answer 
&gt; Each struct is a card. But I can't initialize that. Sure you can. Something like: enum card_suite { Clubs, Spades, Hearts, Diamonds }; struct card { int rank; enum card_suite suite; }; struct card deck[52] = {{1, Clubs}, {2, Clubs}, and so on}; Or use some loops to initialize all the elements of the array. Whatever you like.
One more question. What's the point of enum. It seems like it's just making variables. 
Enums are a way to create constants, or variables that can only hold one of a given set of values. http://en.cppreference.com/w/c/language/enum
Take a look at Knuth's MIX or MMIX.
calm down unidan
C and C++ are pretty different nowadays depending on your standard. "Game engine" is a pretty generic descriptor, because you can build game engines in a lot of different ways depending on your needs for the genre and how all-encompassing your engine needs to be, so I'm going to ask you a few questions about specifics in regards to your experience which might help to flesh out where you can start your search. * How are you with Data Structures? Algorithms? Which are you familiar with? How extensively have you used them? [CLRS](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1500340400&amp;sr=8-1&amp;keywords=clrs) is a decent starting point with pretty broad coverage and good descriptions. * What about Design Patterns? Which ones? How much? They're not so much applicable in C, but C++ and other OOP languages are lousy with them. My university was way too into [this book](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=pd_sim_14_12?_encoding=UTF8&amp;pd_rd_i=0201633612&amp;pd_rd_r=YDX0XGBBKTHR0YWGQBFK&amp;pd_rd_w=V250X&amp;pd_rd_wg=fo9TF&amp;psc=1&amp;refRID=YDX0XGBBKTHR0YWGQBFK), but it wasn't bad; bonus all the examples are in C++. * How portable is your code, generally? What's your programming environment like? Windows? Mac? Linux? *BSD? Games are usually Windows oriented, but there's a lot that C/++ can do aside from that, and IMHO the best way to learn systems programming is with C and a Unix-like OS. * What is it exactly that you want to accomplish with your code? A broader engine? A more portable engine? Something not game related? In my experience learning for the sake of learning is great and all, but I lack drive without a concrete goal I'm working toward. Hope this helps.
C and C++ are NOT the same thing and acting like they fall under the same category is going to rustle a lot of jimmies on this subreddit.
+1 for the rustling of the jimmies.
Start learning about data-oriented design: https://en.m.wikipedia.org/wiki/Data-oriented_design http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf http://gamesfromwithin.com/data-oriented-design https://lwn.net/Articles/250967/ This will help you write even better code utilizing the full power of your CPU / GPU etc. Learn about vectorization and parallel computing: SIMD, OpenCL, SPIR-V, CUDA Learn about writing lock-free and branchless algorithms: http://www.1024cores.net Learn about functional programming, abstract algebra, concepts etc. 
Non-Mobile link: https://en.wikipedia.org/wiki/Data-oriented_design *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^92469
&gt; unidan lol
I understand that nowadays C++ and C are very different. The reason I brought up both is that I want to get better at both. That's why I'm asking for resources that will help me become a better software developer and become more aware of the differences.
I'll try to answer your questions/clarify things as best I can. It's a small yet robust 2D game engine. Nothing fancy will be implemented, just the basics and necessities to get you started. I feel that unless a particular functionality is common among a variety of 2D games, then it should be implemented by the user. Written in C because I personally get so caught up with data structures that I loose focus on what I need to be writing (basically put interface &gt; inplementation). I know how classes work in depth. I know the basic searching and sorting algorithms and their complexities. I may have forgotten how some of them are written since I haven't written any of them in a while. Singletons and factories are all I can think of off the top of my head. I'll take a look at the book. I always try to make my code as platform and compiler independent as possible. I'm using GLFW, OpenGL, and STB libraries for my engine right now. I'm also using Arch and I'm quite comfortable with it. I use Vim and I use scripts to run gcc to compile my code. My goals are basically what I described above, but mostly this engine is going to take a long while to develop because I want to constantly try new ways to implement features and functionalities into my code to make it as flexible yet optimized as possible. Right now I'm trying out an entity-component system in C and trying to implement data-oriented methodologies into the code, but it gets complicated when you need data from different components and they don't have a 1 : 1 mapping.
Thank you for the help.
It's a very common idiom. C has no way to declare a struct containing a variable-sized array.
So, you are already doing DoD. To solve the 1:1 mapping issue: Create different lists optimized for the different systems / use cases. Copy the variables from one system to another system only for the entities that have that specific component (using an index list to map between their IDs). You can do this every frame or spread out over multiple frames (syncing multiplayer, eventual consistency), depending on the use case. The goal is to get the data tightly packed and ordered in the way it is going to be processed. Let me know if you have any more questions. Are you not using GNU Make?
I never really bothered learning how to use make. I learned how to use command line gcc and g++. I don't know the other benefits to switch to GNU make.
I'm not sure if I follow what your saying correctly? My plan to compensate is to have a C vector storing data for different components and another vector for storing their handles. Taking rendering as an example, I have a transform component (position, length and width) and a render component. When creating the render component, the user assigns the component a position component handle to get the data. In my render loop I iterate through all of the render components and do a binary search on the position component vector (using the handle stored in the render components), to find the position. Then I render the texture/box. This is my approach for all systems that need data from other systems.
What I meant, as an example in pseudocode: The render system should have its own list (in this example non-interleaved): drawable[batch_id] { texture_id[]; shader_id[]; transform[]; } The physics system should have its own list (in this example non-interleaved): rigidbody[batch_id] { force[]; velocity[]; transform[]; } Then another system copies the data between the physics system and the render system according to a list (in this example non-interleaved): rigidbody_to_drawable[batch_id] { rigidbody_handle[]; drawable_handle[]; } This way the render and the physics system can stay decoupled. Every frame you run the systems, for example as follows (showing a single frame): before: rigidbody_to_drawable_copy(rigidbody_to_drawable[0], rigidbody[], drawable[]); rigidbody_to_drawable_copy(rigidbody_to_drawable[1], rigidbody[], drawable[]); on core 1: physics_apply_forces(rigidbody[0]); physics_integrate(rigidbody[0]); render_schedule(drawable[0], rendercommands[0]); on core 2: physics_apply_forces(rigidbody[1]); physics_integrate(rigidbody[1]); render_schedule(drawable[1], rendercommands[1]); after: render_sort(rendercommands[]); render(rendercommands[]); The systems are just a collection of functions accepting batches of data as their arguments. An incomplete example as follows: https://pastebin.com/gXkBtHCE You may want to create a scheduler that automatically distributes the work over multiple threads.
Something else for you to consider learning then. Knowing how to use GNU Make is very useful.
The mother of all C based VM's is Lua. Check it out! 
Typically you just use extra parentheses to indicate that `=` instead of `==` is intentional. To make it even clearer, I would use this: char byte; while (byte = *to++ = *from++, byte != 0) ; I really don't like adding piles of parentheses just because the reader might not know how C works.
Now that's something I can help you with. I made a really simple operating system that fires a VM with its own instruction set and stuff. It's 100% C with a few lines of i386 assembly for the bootloader. The best part: it totals to only around 1700 lines of code! [Here it is on Github](https://github.com/DxBorks/DxBorks) Ask away!
Thanks for the clarification, and howdy fellow Arch user ;) My setup is fairly similar to yours: Arch, vim (inside tmux) for editing, gcc for compiling. That being said you would really benefit from learning how to use make; [this](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/) is what I learned from, it's short but still very in-depth. It will prevent you from reinventing the wheel with scripts. From there I strongly recommend you learn [cmake](https://cmake.org/cmake-tutorial/) down the line, because you're going to want an easy way to compile your engine on different platforms; [GNU autotools](https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html) can fill a similar void in your production process, but it's fairly limited to GNU/Unix-like systems and cmake will make it easier to port your project to Windows when you're ready to launch. The last thing I'm going to say in regards to your environment is that while vim is wonderful, it does have limitations. I'm an avid vim user; whenever I can get away with using it I do, because I'm more comfortable with it, but when I need an IDE I use emacs. It's okay if you don't want to use it, at the end of the day use whatever tools allow you to complete your project, but I have found that more often than not when my project gets large enough, or I'm in need of a full suite of features/plugins, that emacs provides a cleaner interface for a fully personalized IDE with less effort on my part than vim ever could. I'll get off my soapbox now. Back to the main event, I recommend you start with data structures and algorithms, especially since it looks like most of your engine will be in C (making design patterns more rare). Your project is very specialized so you're only going to need a handful of the structures and patterns you would learn from the books I posted above, but your project is also performance oriented so choosing the right approach is imperative. To that end it's probably good to have a thoroughly fleshed-out interface in mind before you begin implementation; I've coded myself into a corner a few too many times, especially in C where you don't have as many modular benefits of object oriented design. I wish I could help you with some of the ECS or DoD stuff but it's pretty far from my specialty, but it looks like u/deorder has a solid grasp on it.
Gentoo, vim, clang/gcc user here! Arch (using openrc instead of systemd) is nice as well. Arch has the most comprehensive documentation of all Linux distributions I've ever seen and I use it all the time.
Client side security - because nothing could *ever* happen on the ride over. I just passed some code over to another programmer the other day. During my explanation of it, he asked me why the parameters needed to be bound in SQL. I have a bad feeling about this...
Just extra parens don’t kill the compiler warning, though. The force to Bool will kill it.
Extra parentheses are enough to kill compiler warnings.
C99 does.
Been reading the code, really impressive. I'm going to concentrate on the VM part and not the OS sections of your code. Do you have Discord?
I'm at my best friend's birthday I'll be available in about 24 hours, I'm Garuda1 on discord
Not on all compilers—everybody behaves differently on this stuff, and they’re allowed to per standards. IIRC ICC (at least versions I used) happily discards parentheses during parsing and forgets about them during warning-generation, and I vaguely recall some older GCC doing it too. The `!!` won’t come out until optimization (generation if `-O0`), which would be after any checks for `=`-vs.-`==`. The `!!` is also a sigil for the reader, though. Someone coming across `if(x = y())` will either breeze past and misinterpret it first time ’round or harbo(u)r the nagging suspicion that it’s a mistake.
Awesome, enjoy the party
And on reddit. You speak to my heart friend.
C99 lets you elide the size of one array in the declaration [under certain conditions](https://en.wikipedia.org/wiki/Flexible_array_member). It's nowhere near as general as, *e.g.*, this declaration in C++ where both members' sizes are determined at run time. struct foo { std::vector&lt;float&gt; member1; std::vector&lt;bool&gt; member2; }; C++ does a lot of extra work under the covers to make this work, of course.
**Flexible array member** Flexible array member is a feature introduced in the C99 standard of the C programming language (in particular, in section §6.7.2.1, item 16, page 103). It is a member of a struct, which is an array without a given dimension, and it must be the last member of such a struct, as in the following example: The sizeof operator on such a struct is required to give the offset of the flexible array member. When allocating such structures on the heap, it is generally required to reserve some space for the flexible array member, as in the following example: When using structures with a flexible array member, some convention regarding the actual size of that member should be defined. In the example above, the convention is that the member array has length double-precision numbers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I might have a solution for you. Use fmod to calculate the floating point modulus. So essentially just use decimal = fmod( my_float, 1.0 ) my_answer = my_int + decimal Sorry about formatting guys, I'm on mobile. But in any event, someone correct me if this won't do what he wants. Pretty sure it will though. 
You could do something using [modff()](https://linux.die.net/man/3/modf). Also, your current implementation doesn't work properly when floatTest and intTest have different signs.
What problem are you actually trying to solve? First, not all decimal values are directly representable as floats ( 0.1, for example ) Second, why is "intToFloat" returning void and using a pointer? What's it supposed to do? You might be trying to solve the wrong problem. 
&gt; lol. "TWENTY+ YEARS", twenty years of historical cruft. Yeah. Windows 3.1 was ***TOTALLY*** better than Windows 10. The Linux 1.0 kernel and circa 1995 GNU tools were **FAR** superior to those out today. #/S What a moron. Well maintained software gets **BETTER**, not worse.
Sweet, much safer than what I did. I will change my implementation to use this.
I want to set the value on the left side of the decimal in a floating point number. So I want to take 10.6 and change only the 10 part and leave the ".6". The int would only modify the left side while preserving the ".6". The float will have other values in them before I change them. My implantation is not good and I hoping you all would help me do this a better way.
My jimmies are rustling already.
There's no need to be rude here, GNU tools are shit, they themselves admitted it, the only thing being added over the years is standards and more cruft. aaand please, stop this silliness, this conversation is going nowhere, you can still use your lovely GNU tools, no one is stopping you, what I did was just give my opinion.
float foo = fabsf(floatTest); floatTest = intTest + (foo - floor(foo)); This works for negative values as well. 
I use sublime for C with a robust Makefile and gnu make from the mingw packages. It's good to have Makefiles anyway and its a good thing to learn if you don't already use them regularly. Clicking on add a new build system in Sublime defaults to a simple 'make' command, all the compiling and linking and stuff can go in there where you can edit it easily. You can tell it to do pretty much anything which will run when you hit 'build' in sublime. If you have Makefiles it also becomes a lot easier to build and run all your code from the command line using commands like 'make all', 'make build_run' or whatever you like. You can pass arguments into your exes in the makefile and you can also pass arguments into the make commands for better control. I only fairly recently began really understanding make (there's a lot here I haven't mentioned) as now I use it in my job but it's already my go to for building code as it really allows you to codify what a successful build needs.
You will have to check the build script. Go to Build phases, the last phase should be the run script. Modify the install path from /usr/local/ to /Applications You may have to create the folders manually using Finder. Also, the script maybe old, Apple blocked access to certain paths and directories. [Edit: /usr/local is still kosher] I'm posting from mobile at the moment. If I were on my mac I would be able to post screenshots. Build phases in the project settings, select the project icon on the left, and then select the target you are building.
That's most likely it, recompiling now! I had thought it might be the output path because it was right there in the error message that it couldn't create a folder but it didn't occur to me to change it -_-
You have to keep at it. Missing files and directories in shell scripts can be nasty. On the plus side, if you didn't know Bash you will be familiar with it once you get the script fixed. Edit: Any questions related to Bash should be directed to r/bash as this is not a C related question Good luck
Will do, thanks a bunch!
Thanks for the advice.
Thanks for the pseudo-code. It makes it easier to understand what you intend but I'm still slightly confused as to what you mean and how this is beneficial? I've never seen an approach like this so I'm having a hard time understanding.
Do you have to use floating point? It seems like fixed point arithmetic might work better for you.
Enums mostly improve readability. This declaration: enum card_suite { Clubs, Spades, Hearts, Diamonds }; is very close to this code: #define Clubs 0 #define Spades 1 #define Hearts 2 #define Diamonds 3 The keywords are not variables, but are converted to the constant values by the preprocessor before it compiles. It makes the code much more readable by a human, so that you don't have to remember the arbitrary values you gave to each card type. Enum is even more readable in a way because it obscures the fact that number values were even assigned to the keywords.
Late, but I can confirm that NetBeans can have C functionality.
The standard only blesses it if the array bound was omitted in the struct definition. Specifying `[1]` means it's undefined behaviour to access past the first element , regardless of how much memory was allocated. &gt;In C99 you can make the size zero You can omit the bound (making the array have incomplete type), you cannot make it `0`. 
In that C++ code, both members have fixed size. They appear to contain other elements only in that the other elements are stored in an entirely separate memory block that can be resized, and a pointer to that block is stored in the vector in the struct. You could do something similar in C.
&gt; Specifying [1] means it's undefined behaviour to access past the first element It is valid in C90 according to the [ANSI rationale &amp;sect;3.5.4.2](https://www.lysator.liu.se/c/rat/c5.html#3-5-4-2) which specifically calls out this idiom as well defined. &gt; But this paradigm works just as well, as written, if N is 1. 
Floats are not stored as a left side + right side. They are stored as a mantissa \* 2^ exponent. For example: 0.5 is stored as 1\*2^(-1), while 2 is stored as 1\*2^(1) Note how their mantissa is the same, and only the magnitude changes by changing the exponent. This means that there is no super quick and easy way of just switching out the greater than 0 part. Also, if the integer part you switch in is too large, it can make the remainder go away. That is, using 32-bit floats: 10000000 + 0.2 = 10000000 If you for some reason do this a lot, your original solution of using fp-int conversions is probably faster than modulo, because module uses divisions which is slow while conversions are fast. I would remove the pointers and just use a simple value-based calculation, just to make it easier on the optimizer, though: float intToFloat( int whole, float fractional) { return (float)( whole + ( fractional - (int)fractional) ); } In most cases the compiler should be able to inline both functions and make them go away, but I bet there are situations where the indirection might confuse it and force it to actually do the call. It's not like using pointers buys you anything here.
esx kernel was leaked few years ago and it was in C
 float dec( float f ) { return f - ((int)f); }
u/dmc_2930 was asking *why you wanted to do that* not *what you think you need to do* in order to solve the problem, we all understand what you wanted to do, your opening title is clear enough. &gt; You might be trying to solve [the wrong problem][catb]. [catb]: http://www.catb.org/esr/faqs/smart-questions.html#goal That is, if you can divulge more information.
Why not just use the stack instead? I guess you could have a butt load of temp. memory requirement which cannot go on the stack. I don't recall encountering such scenarios regularly. IMO use the slow memory (heap) for memory that'll last a while and it's usually freed by some other thread. Hence RAII seems useless.
&gt; Why not just use the stack instead? I guess you could have a butt load of temp. memory requirement which cannot go on the stack. I don't recall encountering such scenarios regularly. Dynamic data containers might be an area where one could use this. But yes, I generally avoid heap allocation whenever I can. Taking the struct example from above, I'd rather supply the init function with a struct * parameter that simply gets filled with data, rather than doing object initialization in a Java-like manner. I just think it's nice to know that the boundaries of C can be pushed somewhat before one should really use another language like C++.
Thanks!!
&gt; Dynamic data containers You mean like form a linked list in a scope and inside the same scope use it and while exiting that scope if you forget to release the linked list RAII will do it for you. That could be it. But this encourages "fat" functions. imo it's better to write small functions passing things to each other.
what about ...? #define RAII(on,off) for( int L = ((on), 1) ; L ; L = ((off), 0) ) int main() { RAII(puts("begin"), puts("end")) { puts("middle"); } } use a unique name instead of L if worried about variable shadowing.
Try to do it for 10 variables that need to be used in the same block and you'll answer your own question.
I was just making sure I was clear. The &gt;What problem are you actually trying to solve? First, not all decimal values are directly representable as floats ( 0.1, for example ) Made me think that I might have had not been clear. 
www.xyproblem.info Asking about your solution to your problem instead of your problem.
I am ok with the inaccuracy converting to float will bring. And both values will always remain positive. The function I gave was more of an example of what behavior I wanted, I agree its not the best way. What I was really using was a macro in my project. :P Also I did not really know about that last part about optimizer, thank you for the help.
I feel that might be more involved than I need. 
&gt; What problem are you actually trying to solve? You misunderstood the meaning of the question, he was asking why you needed to solve the problem this way, what exactly the problem is, more precisely, *what* led you to believe *that* problem is the problem? But he still offers the *First* and *Second* on the path you are taking, then finally he clearly stated: &gt; You might be trying to solve the wrong problem. If you read the link in my previous comment, you should understand sometimes when you see a problem and think of a solution, they might not be the real problem and solution. And often, there is more direct way to solve a problem, but you could be just caught in thinking too much and not being able to see though. This is why when asking a solution to your problem, you should also bring up the backstory. Nonetheless, your question is still a very good question.
I took a look at the link. In my case I have a working X and Y I just want a more pretty y. :) Its for a non-realistic simple physics simulator. The coordinates are represented as floats and are set up as 1 pixel = 1 world unit. I wanted to teleport the object around to arbitrary spots. My teleport locations where an array of integers so I felt the most strait forward way to do it would be to just to set the floats to the integers. Also to note my coordinates are always positive. Anyway loosing the sub unit amount would cause it to be off slightly when teleported. So I ended up implementing something I have above which works but I felt like their was probably a better way.
Ok I see now, I have made a follow up answering that here. https://www.reddit.com/r/C_Programming/comments/6o2gth/convert_an_int_to_a_float_while_preserving_the/dkfcbii/ Thank you for the reply! 
If you know the magnitude limits of your world, it might be better to use a fixed point notation. For example, you could use a 64 bit value, with 32 bits being the integer portion and 32 bits being the "decimal" portion. This makes your math WAY more predictable.
I was thinking about that but I was wondering if that would add more overhead and complexity than I wanted or needed. I wanted to keep it simple. The program was more about art and feel than a deterministic physics engine. My world limits are 2D with 8k world units starting from 0 if that helps. 
If you're just using 0-8192, all you need is 12 bits. You could easily use a fixed point math library. For ease of use, you could use a 16 bit "whole" part and a 16 bit "fractional" part. Or, just use a 32 bit whole and 32 bit fractional. This is how tons of video games work. If you don't need floats, don't use them - they add all kinds of irregularities....even comparing them gets tricky. With fixed point, that all goes away. Google "fixed point" to find tons of example implementations and why it's often the right choice. 
Does this contain the updates from POSIX.1 2008?
Thank you for your help :)
When your program exits, all of its memory is destroyed. While yes, it's best practice to free() what you malloc(), in a case like this, it doesn't actually result in a memory leak if you don't.
&gt; There's no need to be rude here, GNU tools are shit, they themselves admitted it, The only one full of shit here is you, baby. Go back to playing with your node.js/PHP hybrid IDE kid.
If you ghad actually read that you would realise that X is the solution and Y is never the solution. The point is that you are asking questions about Y because you can't do Y but Y is possibly the wrong way around this and you actually want to do X. People are asking what the problem to be solved is rather than your solution...so they can help you with an X solution rather than a Y one do you understand this?
Wait... why do you represent your pixels as floats? Why not just use integers?
In this case I think your X solution is to not use floats.
I think you overthought this a little bit... why is he using floats in the first place to represent a value between 0 and 8192. Like it is a good answer, but not sure he even needs that level of complexity. 
It sounds like he wanted some fractional possibilities - physics engines often use more accuracy than one rendered pixel.
Right.... But he then says he does t care toiuch about the accuracy... And I imagine he is only drawing to pixel resolution.
Real question, why not if its doing what I need it to? What I have works for what I need it to, I was just trying to see if there was a pretty way of doing this. 
I do get it, I have provided my X to help out. The first statement I was messing around indicated by the smiley face. Sorry to confuse. 
&gt; When your program exits, all of its memory is destroyed. While that is true for the most common PC operating systems, I'm pretty sure you would be able to find exotic platforms (probably embedded systems) where that isn't the case. And historically, operating systems didn't do that for you. DOS and Win 95/98 would be an example. EDIT: Memory leaks might also become an issue in applications that run for a long time. Server applications would be an example.
The point is if you know X the problem is solved... so all the while you still think you need help with Y you have not understood the X Y problem. 
Because it doesn't hence this question. 
I am arbitrarily using pixels as my units. I'm using floats to represent an objects location which can be between pixels. 
I do not know what you mean by "hence this question."
I'm an embedded systems developer. In embedded systems, I avoid heap allocation unless it is 100% necessary. I'd still rather clean up a program without using non-supported compiler extensions. 
I am no Games Developer so I don't know what i am talking about.. but why would you want an object to be between pixels when you will always only be able to draw it aligned to pixels? 
Well if everything was fine and dandy with you're implementation then you wouldn't be asking anything.
I agree with your logic I just feel in my case it does not apply. I am trying to find a better way to express Y specifically in C. I am ok with the functionally of my Y and i'm not trying to fix that. I have been happy with the answers other have given. :) I am happy with this topic.
**solved**
**solved**
Ok. (Y)
I just don't like the way it looks, but its kind of superfluous in the big picture. I was just wondering if the cool people on this subreddit knew of a better looking way of doing this. Ralusp post is what I wanted. :)
Hehe, I'm not much of a games developer also. I am learning C and making something recreational. Why I want objects to be off gird is for smoothness of motion. So I can add .5 to an objects position and it will move on screen 1 pixel every 2 frames. If I used integers and wanted to move less than a pixel per frame I would have to implement a delay mechanism which is more involved than I need. I could get fancy with fix fixed point arithmetics and delta time but its way over the scope and goals for this small project. 
Ha, Yes I just discussed this with a colleague and came to the conclusion that this is exactly why you were using a float. 
&gt; embedded systems Wrong argument. It takes lots of resources to recreate new process after it exits. This is the only reason we've things like [fastcgi](https://en.wikipedia.org/wiki/FastCGI) instead of just cgi. Thus isn't not practical to exit and recreate your process just to avoid memory leak.
**FastCGI** FastCGI is a binary protocol for interfacing interactive programs with a web server. FastCGI is a variation on the earlier Common Gateway Interface (CGI); FastCGI's main aim is to reduce the overhead associated with interfacing the web server and CGI programs, allowing a server to handle more web page requests at once. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
That's hard to say without seeing the rest of your code.
So you don't think it's in that function 
It [doesn't](https://ideone.com/WJn6nY). Which means that something is wrong in the code you didn't include.
Hold up bro 
It could be that this function crashes, but to understand what is really wrong, I need to so the code around it, e.g. the definition of `struct card` and what you pass to `deck_fill()`.
That's ingenious! I have never thought of that
If you have an interest in designing a stack-based (virtual) machine, you might enjoy this book: https://users.ece.cmu.edu/~koopman/stack_computers/ (author's site) It's now online but I picked it up, used, a few years ago, and really enjoyed reading about the alternative architectures of stack-based machines. It doesn't touch on a C (virtual) implementation, but I don't think that matters. Maybe it gives you some neat ideas. Among other interesting bits, because of the era of the book (late 1980s) it includes the RTX (1988) by Intersil which is a radiation-hardened CPU for space probes, including the Philae lander that was in the news again in 2015. Build it to last! ;-) Good luck! Stack love.
Win 95 does that for you. Implementations of C for DOS do that for you, too.
nah bro u try holding a book up to your face some time. in other words, hit the books
Lol I'd just like to say. Obviously. That was the first place I looked. 
Use the debugger, Luke! 
Vim! Just type :make ;-)
Oh really? Ok.. I just heard that from someone. I'm actually too young to have programmed in the 90s. Perhaps I might try some DOS programming someday... just to see what it was like to program on a system that had almost no protection mechanisms.
I've never ever ever ever used an IDE in my life, and never tried any of PHP or node.js. *sigh*
We use this technique in places in Asterisk. You can also do something similar with clang's blocks. We've also used (abused) it to manage lock scopes, which is kind of handy when you're locking something for the duration of a function call and want it to be unlocked when the function exits. For those who are curious: https://github.com/asterisk/asterisk/blob/master/include/asterisk/utils.h#L1001
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [asterisk/asterisk/.../**utils.h#L1001** (master → f43fc91)](https://github.com/asterisk/asterisk/blob/f43fc9191132d93918a2e4c173c876dd1cbfe4d2/include/asterisk/utils.h#L1001) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkfv7u5.)^.
Is k ever &lt; 0?
That's a function, not a program.
Both are fine.
They're exactly equivalent. It doesn't matter which one you use, but pick one and use it consistently. 
If your variable is called `ptr`, then it probably doesn't matter. I prefer to use `x != 0`, `x != '\0'` and `x != NULL` and leave `!x` for `bool` only.
€1€€7 }{@#0|2
You can use the cleanup attribute on stack variables as well, for example closing file descriptors.
Wouldn't the second check fail on architechtures where NULL isn't 0? Even though they are quite exotic and for the most part quite old, such architechtures do exist. Just wondering.
No, it won't fail as ! specifically considers null pointers to be false.
I'm too tired to actually read the spec right now, but I was under the impression that null pointers always compare equal to 0, but isn't necessarily represented by all bits 0. For example, `ptr = 0;` could (theoretically) be turned into machine code where "ptr" was assigned some magic value not equal to 0x00, and that the way of actually setting bits to 0 – `memset(ptr, 0, sizeof(type));` – won't necessarily result in a null pointer.
I'm fond of `if (!*ptr); // Didn't dump, we're good...` but that's me. Kidding, both of yours work fine. Though arguably `if (NULL == ptr)` would be better since you don't risk accidentally overwriting ptr if you forget an equals. (did have an employer at one point who insisted that the code standards be "seg fault if anything is not correct". it was an interesting approach.)
I tend to prefer the more explicit version, like the first. I also tend to put the constant on the left to help avoid accidental assignment, and because the constant is the more interesting part of the comparison. 
1. How are you calling this? Are you passing in the deck correctly? Is the deck big enough? 2. Where is it crashing? You could put lots of `printf` statements (brutal but effective) or run in a debugger (slight learning curve, but much better). 4. How is the struct defined? Is `suite` a `char*`, or `char[10]` (or other fixed size)? 3. Why are you using `memcpy` instead of `strncpy` (or similar)? 5. Can you give a link to a complete code that fails?
Literal-0-null is kept entirely separate from the actual representation of `NULL`, though IIRC POSIX requires the two be equivalent.
I'm sure it was just an example...
Testing against NULL also conveys the *intent* of what you're doing, which is good for readability.
I always thought myself a hobbyist, but I strive to write according to my thought process, so my code expresses my intent rather than a specific style. I would probably use `ptr == NULL` when testing for a valid option and `!ptr` to test against an error. Just my 2¢.
`default` case missing???
I always experienced suid programs to be un-bypassable through a debugger or a single-stepping software if you're not already logged in as the owner of the file because the tracing runs as you instead of the suid account, is it no longer the case ?
It would change from undefined behaviour to not-UB in the multithreaded case, and make no difference in the single-threaded case
What exactly are you confused about? It is beneficial because: - It fully utilizes the CPU cache for data. - It fully utilizes the CPU cache for instructions, especially if functions are kept small and there is no branching inside tight / hot loops. - It can potentially utilize all cores at 100%, but it will melt phones if not constrained. - The same code layout can be used even when using SIMD, OpenCL, SPIR-V etc. - Lock / wait-free, especially if multi-buffering is being used. - Easy to adapt between interleaved / non-interleaved structures. - Decoupling of all subsystems. - Multicore / thread friendly. 
If the program isn't in a state you recognize, segfaulting is a great option.
 if (!ptr) do stuff;
That is the correct answer.
The ` == NULL` is just noise to me, and (contrary to some other opinions in the comments) I think `!ptr` often/usually expresses intent _more_ clearly when that intent is to check if a thing is "falsey" or "invalid" or "unset" (which is NULL for a pointer). If you happen to mix code with C++ or work with both it's also nice because this uniform syntax applies to many similar types like smart pointers or optionals. That said, in a purely C context, implicitly treating zero as false is pervasive in C (think status codes), and `== 0` and `== NULL` usually read like amateurish verbosity to me, to be honest. I don't think I'm objectively right about that, or anything, just how it reads to me.
Yesh, but the function stops doing the same thing it did before.
No it doesn't ...
If we were being particularly anal I would say (NULL == ptr).
I prefer: if (ptr == NULL) or: if (ptr == ((void*)0))
&gt; I also tend to put the constant on the left to help avoid accidental assignment Instead of using [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions) you could just enable warnings.
**Yoda conditions** In programming jargon, Yoda conditions (also called Yoda notation) is a programming style where the two parts of an expression are reversed from the typical order in a conditional statement. A Yoda condition places the constant portion of the expression on the left side of the conditional statement. The name for this programming style is derived from the Star Wars character named Yoda, who spoke English in a non-standard syntax. Yoda conditions are part of the WordPress and Symfony coding standards. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
For me, it depends on how I'd read it. The latter version I use more often, that is if the not indicates "non-existent": ``` if (!next) { break; } ``` reads as "if there's no next element, break". OTOH, if `NULL` has a different meaning here (eg. as a standard return value – for what ever reason) and does *not* mean that the "returned element does not exist", I'd use the latter version (can't find an example from the top of my head, but been there). Basic rule for me is: Try to make your code rather readible for English-speakers.
Yes it does: the intent is clearly to ensure that all pieces are given out once on each cycle. If you use thread local variables, this only holds per thread but not globally.
It's a lot simpler to check if (ptr == NULL). A void pointer is nothing but a pointer variable declared using the reserved word in C ‘void’. 
If the goal is to iterate through the entire 2d array, the for loop should probably look more like this: ` for (i=0; i&lt;row*col; i+=col) {` 
This kind of backwards conditional has been obsolete for at least 20 years, since any decent modern compiler will emit a warning if you use `=` instead of `==`. 
Better safe than sorry. Also I made this mistake when I first started in c, no compiler warning and that was only 5yr ago.
1234 5678 9016 This is the desired output
Unfortunately gcc (and some other compilers) default to not emitting warnings. This is bad news for beginners, as the kind of mistakes they make when they are learning can often be picked up by the compiler. About half the beginner questions on C on StackOverflow could be solved simply by turning on compiler warnings (and the other half could be solved by learning how to use a debugger). 
Your code already *nearly* does this. You just need to tweak your `printf` calls. You should also turn the warnings on on your compiler, there's a couple of things that should be fixed. Also for future postings, indent code by 4 spaces for reddit to format it as such, like: indented code block here.
Thank you for your advice on my future posts. 
Yes, you are correct. `NULL` itself is essentially defined to be `(void *)0` (IIRC, it is not required to be `void *` type, so in that case it can be a literal `0`). This doesn't mean the `NULL` value internal to the compiler has to be only 0 bits, but `0` in the context of a pointer always has to compare equal to whatever `NULL` is.
his approach was for all errors, not just critical ones. We also weren't supposed to verify function arguments passed in or return codes passed back. We were supposed to assume that our functions were called correctly and that functions we called worked. I get the idea, but it's a "Time and place" type thing, not a "general marching orders" thing.
OpenSSL is a piece of crap. However, if you use Common Crypto, your software won't work on other operating systems, so pick your poison.
Personally I prefer the second - it's just as easy to read and it's less stuff to look-at. But it doesn't really matter, I've worked on code-bases that do both and it has never been much of a problem. If you're *adding* to an existing codebase though, I would definitely go with whatever style they're already using, just for consistency.
&gt; We've also used (abused) it to manage lock scopes, I do that as well. I actually wrote a [macro](https://github.com/mkilgore/protura/blob/master/include/protura/stddef.h#L100) that expands to give a 'block' syntax for the scope of when it is valid. I had an earlier version in there that you can see that does it without using `cleanup` (With some major caveats - just ignore it really), but the `cleanup` version is extremely handy. I pretty much always wrap the basic macro I linked above into more specific versions for different types of resources. For example, [this](https://github.com/mkilgore/protura/blob/18efc3af76576c729789f52fb64b6d7fde2e44c4/src/fs/procfs/node_cache.c#L64) and [this](https://github.com/mkilgore/protura/blob/18efc3af76576c729789f52fb64b6d7fde2e44c4/src/fs/procfs/node_cache.c#L72) is using the `using_mutex` version, which just locks a provided mutex and then unlocks it when you exist the scope. Somewhat more interesting is the [`using_block`](https://github.com/mkilgore/protura/blob/18efc3af76576c729789f52fb64b6d7fde2e44c4/src/fs/ext2/ialloc.c#L45) macro, which does the necessary stuff to get ahold of a specific block you want from some block-device, assigns it to a variable you provide, and then releases it once you exit the scope.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mkilgore/protura/.../**stddef.h#L100** (master → 56ea8b5)](https://github.com/mkilgore/protura/blob/56ea8b5fb64657f2662cfd85074afdbe51dba3a6/include/protura/stddef.h#L100) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkh00a4.)^.
&gt; OpenSSL is a piece of crap. Is this common knowledge? If no, can you explain your position?
And thats exactly why you should write it in the way I suggested. You never know what will happen. Write C well not half arsed, hoping for the compiler to tidy up your mistakes.
OpenSSL is a de facto standard and a great piece of security related software. What is it that makes it a piece of crap? 
*deprecate
Yes, it's common knowledge to anyone who hasn't been living under a rock since 2014. I mean, many of us knew it was crap long before that, but that's when the industry woke up and took notice.
Ambiguous license, awful API, difficult to use correctly and safely, a long history of unsafe defaults, plus a never-ending stream of [vulnerabilities](https://en.wikipedia.org/wiki/OpenSSL#Notable_vulnerabilities).
Look for a blog named "OpenSSL valhalla rampage"
Have you ever looked at the source code?
**Explain the following program** The program loops through a 2 dimensional array and prints out the results. The `show` function accepts 3 parameters: 1. A 2D array 2. Number of rows to print (starting from first array element) 3. Number of columns per row to print (starting from first array element) Personally I would do something like this: #include &lt;stdio.h&gt; void show(int q[][4], int row, int col); int main() { int a[3][4] = { {1,2,3,4}, {5,6,7,8}, {9,0,1,6} }; show(a, 3, 4); } void show(int q[][4], int row, int col) { int i, j, *p; for(i=0; i&lt;row; i++) { p = q[i]; for(j=0; j&lt;col; j++) { printf("%d", p[j]); } printf(" "); } printf("\n"); } Assuming the output format you want is `1234 5678 9016`. Note I have also removed the use of pointers such as `*(p+j)`. ~~Pointers and arrays are the same thing in C~~ and since you're dealing with arrays here I think it's easier on the eyes to use square brackets. For example `int q[][4]` is clear at a glance that the function accepts a 2D array. If pointer arithmetic is what you're going for you can do something like this: #include &lt;stdio.h&gt; #define ROW_SIZE 3 #define COL_SIZE 4 void show(int (*q)[4], int row, int col); int main() { int a[ROW_SIZE][COL_SIZE] = { {1,2,3,4}, {5,6,7,8}, {9,0,1,6} }; show(a, 3, 4); } void show(int (*q)[4], int row, int col) { for(int i=0; i&lt;row; i++) { for(int j=0; j&lt;col; j++) { printf("%d", *(*q+(i*COL_SIZE)+j)); } printf(" "); } printf("\n"); } The second example is harder to read imho. I avoid using pointers with arrays unless required.
TIL Yoda conditions. Thanks. &gt; you could just enable warnings I usually do, but this becomes a hard error rather than a warning (which can be overlooked). An interesting side effect is that I've made the error *far* fewer times, because I'm more careful writing the comparison. 
&gt; Pointers and arrays are the same thing in C No. The name of an array devolves to a pointer to its first element, but it is not assignable, so not 100% equivalent.
What alternatives are available for cross platform development?
Ooops. I've put a strike through that claim. Thanks.
I use both at times. Personally I prefer `if(!ptr) { ... }`
Please look through the subreddits history before posting threads like this. This question gets asked at least twice a month.
Apologies /u/theboxingfox I've only recently discovered this sub. Noted :)
I never had problems with Vim, not even when working on non-trivial code bases like Transmission: https://github.com/transmission/transmission/pull/229
I'd love to become productive in Vim. Do you have any recommendations on useful plugins when working with C? I have all the usual plugins such as NerdTree, YouCompleteMe (pita to set up at first!) etc.
GnuTLS, NSS, PolarSSL, and [many others](https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations) including several OpenSSL forks (counter-productive, IMHO).
**Comparison of TLS implementations** The Transport Layer Security (TLS) protocol provides the ability to secure communications across networks. This comparison of TLS implementations compares several of the most notable libraries. There are several TLS implementations which are free software and open source. All comparison categories use the stable version of each implementation listed in the overview section. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Here's my .vimrc: https://github.com/stefantalpalaru/dotfiles/blob/master/homedir/.vimrc I switched from YCM to neocomplete and from syntastic to ALE. These shortcuts are very useful for working with tabs: map &lt;C-Up&gt; :tabnew&lt;CR&gt; map &lt;C-Down&gt; :q&lt;CR&gt; map &lt;C-Left&gt; gT map &lt;C-Right&gt; gt (plus stuff like ":tabmove -2" to move a tab 2 positions to the left) Tab-completion works wonders when opening files, specially when coupled with command history (":e " followed by up arrow). When I need anything more complicated I just use Midnight Commander. I have a habit of saving Vim sessions for every project I work with (":mksession! vim.session" with 'vim.session' being ignored by Git by adding it to ~/.gitignore) and loading that session is as simple as ":source vim.session". There's a limit to how much I use Vim as an IDE. For example, I like running "make" from another terminal emulator tab instead of doing it from inside Vim. Same for gdb.
Lots of useful advice there. Thank you!
[Dug this up for you.](https://www.reddit.com/r/C_Programming/comments/6e3v9f/which_ide_do_you_use/di7k4aq/)
If I recall correctly, OpenSSL doesn't have a stable ABI and there were compatibility issues between releases. The recommendation became to ship it with your app if you need it. 
While not the same syntax, [here's](https://brynet.biz.tm/pub/susv4-headers.txt) a raw distillation of the POSIX header rules. It has some flags for things introduced in Issue 6/7.
`if (!ptr)` looks more like C-ism than `if (ptr == NULL)` but it is really not worth arguing about. Both styles are used in the linux kernel and the style guide doesn't say anything.
"critical" can mean a lot of things -- keeping a program running in an unknown state is, I'm guessing 9 times out of 10, worse than crashing, as not only can you lose data, you can also corrupt it (or worse, leak information or even allow complete control to an attacker). If your program is not correct, presumably that means that it's not in a state that you, the programmer, thought was possible, so you should segfault. I'm also an advocate for leaving asserts on in production for most cases now as well. Verifying function arguments in general is also a fool's game... if you don't want NULL passed into your function, the caller should check for that (unless NULL has a special meaning). It's rare that silently ending the function or returning an error code is the right solution here, as the caller would have to deal with detecting that and dealing with it after the function call when they could have just checked beforehand and not called the function with a bad pointer.
Why would you ever use the definition of a null pointer constant to compare against?
I don't, I'm just saying it's valid. But terribly verbose
I really like vim. Coupling it with tmux makes it even better. 
How does vim make your productivity plummet?
Because I don't use it often enough for my projects. There was a time in the past I used it exclusively for web development, but the company I worked for gave us copies of PHPStorm and I got used to using that. I probably need to jump back in the deep end and start developing muscle memory again.
Believe it or not that's some good advice! Thanks.
What version of Ubuntu are you running? What compiler do you use and what version of it do you have installed? My guess is that the man pages for standard libraries are dependent on you distribution, and I imagine many distributions use the man pages from the default compiler. For Ubuntu this should be `gcc`. My hope is that a system/compiler update will fix this for you, but if not you can always download your preferred man page and install it at `/usr/local/share/man/man0/`. Are you able to find it with `man 3 strtoll`? Are you able to use the function within a program as expected? **EDIT:** changed `/usr/local/share/man/man3/` to `/usr/local/share/man/man0/`; `man3` is for specific functions, `man0` should hold libraries afaik.
It worth a small discussion. Not an argument. Essentially a NULL is a symbolic constant defined in the POSIX header stdio.h and we expect that the implementation has the "NULL" symbol defined as some sort of a zero value constant. However it is best to refer to the actual C language specification here : WG14/N1256 Committee Draft — Septermber 7, 2007 ISO/IEC 9899:TC3 6.3.2.2 void The (nonexistent) value of a void expression (an expression that has type void) shall not be used in any way, and implicit or explicit conversions (except to void) shall not be applied to such an expression. If an expression of any other type is evaluated as a void expression, its value or designator is discarded. (A void expression is evaluated for its side effects.) 6.3.2.3 Pointers A pointer to void may be converted to or from a pointer to any incomplete or object type. A pointer to any incomplete or object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer. For any qualifier q, a pointer to a non-q-qualified type may be converted to a pointer to the q-qualified version of the type; the values stored in the original and converted pointers shall compare equal. An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. 55) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. Conversion of a null pointer to another pointer type yields a null pointer of that type. Any two null pointers shall compare equal. etc etc ... The point I am trying to make here ( no pun intended ) is that ((void*)0) isn't really the same thing as using the "NULL" symbol. Also using if(!ptr) is not the same as being perfectly clear in a given implementation that is POSIX spec compliant and cross platform portable such as if( foo == NULL ). Have a read of the page at http://www.schweikhardt.net/isomac.c.html where the real objective of good code is to be entirely clear in its intention and entirely clear in compliance with specifications and standards. Mostly don't try to be fancy. The man that wrote that page is a multiple time winner of the "The International Obfuscated C Code Contest" and just about anyone can make tasty looking slick code with stacks of defines and gymnastics. However a truely excellent programmer will write code that is really obvious and clear. Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live. https://blog.codinghorror.com/coding-for-violent-psychopaths/ 
`abort`ing might be an option, but "segfault" actually means something specific happened (memory access outside the allowed space of the program) and it shouldn't be used for anything else.
At risk of being verbose, all manner of crazy things can be done. That doesn't mean you should do them : 1 #define _XOPEN_SOURCE 600 2 #include &lt;stdlib.h&gt; 3 #include &lt;stdio.h&gt; 4 #include &lt;stdint.h&gt; 5 6 int main( int argc, char *argv[] ) { 7 8 uint64_t bignum = 0; 9 unsigned char uchar = '\0'; 10 uint64_t *ptr = NULL; 11 12 fprintf ( stdout, "let's have a NULL here somewhere ..\n" ); 13 14 if ( bignum == NULL ) { 15 fprintf ( stdout, "well this is strange. bignum == NULL\n" ); 16 } 17 18 if ( uchar == NULL ) { 19 fprintf ( stdout, "more bizarre. uchar == NULL\n" ); 20 } 21 22 if ( (void*)uchar == NULL ) { 23 fprintf ( stdout, "lucky you. (void*)uchar == NULL\n" ); 24 } 25 26 if ( (void*)bignum == NULL ) { 27 fprintf ( stdout, "golly gee. (void*)bignum == NULL\n" ); 28 } 29 30 if ( uchar == ptr ) { 31 fprintf ( stdout, "wow. uchar == ptr\n" ); 32 } 33 34 exit ( EXIT_SUCCESS ); 35 } 36 compile and run : $ ./null let's have a NULL here somewhere .. well this is strange. bignum == NULL more bizarre. uchar == NULL lucky you. (void*)uchar == NULL golly gee. (void*)bignum == NULL wow. uchar == ptr Really, stick with if ( ptr == NULL ) and be clear in your code. Also the compiler, ( gcc for example ) may bark warnings at you : null.c: In function 'main': null.c:22:10: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast] if ( (void*)uchar == NULL ) { ^ null.c:30:16: warning: comparison between pointer and integer if ( uchar == ptr ) { ^ Just because you can compare lots of stuff to NULL doesn't mean we should. 
It is a lot more clear when pushed through cb ( C program beautifier ) to output Kernighan and Ritchie style : #include &lt;stdio.h&gt; void show(int (q)[4], int row, int col); void main() { int a[3][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 6 } }; show(a, 3, 4); } void show(int (q)[4], int row, int col) { int i, j; int *p; for (i = 0; i &lt; row; i++) { p = q + i; for (j = 0; j &lt; col; j++) { printf("%d ", *(p + j)); printf("\n"); } printf("\n"); } } 
There should be a manpage `strtoll`. The manpage `stdlib.h` isn't present on my system, possibly it comes from elsewhere. Don't rely on it, only rely on pages for functions.
A struct is complicated to use, compare struct options opts; /* set all options to zero, including options we don't know about */ memset(opts, 0, sizeof opts); /* set the options we want */ opts.mode = RDONLY; opts.cloexec = 1; open(file, opts); with open(file, O_RDONLY|O_CLOEXEC); Which one would you rather use?
&gt; It's rare that silently ending the function or returning an error code is the right solution here, as the caller would have to deal with detecting that and dealing with it after the function call when they could have just checked beforehand and not called the function with a bad pointer. I likely am already checking the the function return code; if an extra check is even needed it's not going to cost enough that I care. And even if my local function is in an unknown state and can't deal with the error that doesn't mean that the functions calling me are as fragile. I may be checking TCP sequence numbers and they no longer line up, but I shouldn't be assuming that I need to seg fault everything just because I'm having a problem. I should be returning and letting those that called me decide if they want to crash or just dump that sequence. It's not my place at the end of the chain to decide what the overall system is going to do.
You misunderstood the text you quoted. `NULL` must be defined to a null pointer constant (see 7.19), which is defined in the text you quoted as "An integer constant expression with the value `0`, or such an expression cast to type `void *`". It really is the same to use `NULL` as to use either `0` or `(void *)0` (depending on which of those two the implementation chose). 
Very nicely written and clear. 👍🏻 I would have also enjoyed reading more about how to access the parsed data. However, I also think you would do well to consider the following few concerns and perhaps revisit your article. 1. According to [this extensive JSON benchmark GitHub repo](https://github.com/miloyip/nativejson-benchmark), `jsmn` might be considered slow relative to the features it offers. For example, RapidJSON is about 1,500K times faster and offers a similar (read: sparse) feature set (no memory copy, no real Hash map). 2. Numbers and well as other "primitives" (`true`, `false`, etc') aren't completely parsed during the parsing process... they remain string objects (or "primitives") and require post processing to completely parse. This is both is reference to the features provided and to the fact that the reported performance is higher than the actual performance cost. I'm totally biased because I was looking for a library and ended up rolling my own (there's [a PR requesting to add it to the benchmarks](https://github.com/miloyip/nativejson-benchmark/pull/92))... ...but I think that if `libc` is available than other options might be better. And where `libc` might not be available, it might be best to choose a different option and implement a subset of `libc` for any required features. --- Originally I posted the comment in the blog, but then I thought the you might want to concentrate the discussion here... perhaps you would like to flame me and this might be more convenient ;-)
*sigh. It is not the same but you go ahead anyways. Just hope you don't have to release code that gets passed through strict lint checks and be stable across platforms that are embedded or otherwise. http://c-for-dummies.com/blog/?p=177 https://stackoverflow.com/questions/9894013/is-null-always-zero-in-c
Read the answers on the stackoverflow thread you quoted. Particularly the one by "John Bode": &gt;The null pointer constant is always 0. The NULL macro may be defined by the implementation as a naked 0, or a cast expression like (void *) 0, or some other zero-valued integer expression You are confusing `0` in the source code, with all-bits-zero representation in memory. Your "c-for-dummies" link is terrible, full of mistakes, and the source example causes undefined behaviour several times.
Want me to rustle them harder?
`stdlib.h` is part of the POSIX programmer's manual (0p) here.
Really? `memset`? that's so 1989 😉 How about: open(file, (opts){.read = 1, .cloexec = 1}); Or even better: #define open(f, ...) open((f), (opts){__VA_ARGS__}) and use: open(file, .read = 1, .cloexec = 1); P.S. (*EDIT*) There's also a difference between external API and internal implementation. No reason the `open` example can't be implemented using something such as: union { int i; struct { unsigned read : 1; unsigned write : 1; unsigned cloexec : 1; // ... } flags; } opts = {.i = opts_}; /...
Lookup from what section your manpage is, section 0 is for libraries, 3 for functions. On Linux you usually have a suffix 'p' indicating if it is of the POSIX programmer's manual. You can list the different available man pages using `-f &lt;manpage&gt;`. Ubuntu has all the manpages split, you need to install sth. like "linux-manpages". Shot in the dark: `strtoll` was missing because the man page was of an old POSIX standard.
This is not really open to discussion. You have a belief and you hold onto it. I am okay with that. 
Well, mine's based on the C Standard, and you even provided quotes that prove my position. Your beliefs are out on a limb. You do appear to be correct that you're not open to discussion (or reading) though.
Yeah, that's not the documentation for your system.
Still worse than just oring together a bunch of flags. And note that designated initializers are a C99 features, so using them (or requiring their use) is out of question for an OS interface.
Yep, one shouldn't rely on it when programming for that system, but it's a nice overview and usually a good additional resource.
Note that there is also a technical reason: You can't pass structs to system calls by value. You can only pass structs by pointer, requiring a costly memory read to get the contents of the structure. That's why system calls generally avoid using structures when reasonably possible (cf. `stat` vs. `access`, the latter existing in case you just want to check if the file is present).
In addition to some of the other answers; many details about a bit-field are implementation defined. Whereas if you can guarantee the word size of an integer then you only have to worry about endiness and only when doing bit-shifts.
The first line of your code is ill-formed. (There must be at least one initializer)
You don't have to worry about endianness with bit-shifts. They're defined in terms of the value order of the bits, not any detail of representation.
Problem is that when you add a new field/flag, you have to recompile everything that uses it. I like the varargs macro trick otherwise. It's like having labeled arguments.
On Linux, man pages for libc are a completely different project than gcc.
My mind is slipping! :-O
I agree for some cases, but I think it's mostly a question of "when" and "where". For a compiled library I would avoid structs, since ABI is a priority... but I might provide a header which includes (when allowed by the language) inline static wrapper functions / macros that provide an easy to read API. For the application source code I would suggest that readability and and easy API are far more important than an ABI no-one will access. XORing flags is great, but sometimes you get really complex functions that require both a steady ABI and a complex option matrix (consider `pthread_attr_t` as a good example).
&gt; I like the varargs macro trick otherwise. It's like having labeled arguments. Thanks :-) I mostly use the trick for labeled arguments, but it's also good for lists, when you want to avoid an `argv` function... the following is a poor example (good examples use more code for cases where this is actually helpful) int foo(char **strings) { /* iterates until NULL is encountered */ } #define foo(...) foo((char [][]){__VA_ARGS__, NULL}) foo("many", "strings", "can", "be", "used"); &gt; Problem is that when you add a new field/flag, you have to recompile everything that uses it. That's true and an very important note. I think [my answer to Fuzxxi](https://www.reddit.com/r/C_Programming/comments/6ojcrf/is_there_any_advantage_of_using_an_int_with_its/dki1bwp/) covers it.
@FUZxxi, that's both a good point and perhaps a misconception? I'm not sure, but considering that the `struct` by pointer is most likely in the CPU's L1 cache (was either just created, set or referenced), can't the performance hurdle can be easily circumvented by duplicating the `struct` to the kernel stack before switching memory maps to the system map?
This was almost the exact explanation provided by the Apple documentation when the deprecation notice came out. An OS requires a stable ABI. The expectation is that all application compiled for OS X Lion will still run on after an OS X Lion update (and hopefully an OS X Sierra upgrade as well). However, the constant changes in OpenSSL's ABI meant that application compiled under OS X 10.10.1 would break on OS X 10.10.2. For years, Apple would pour updates from the open source project to an ABI stable flavor, until it just made more sense to dump OpenSSL altogether and provide a solution dedicated to macOS.
And doesn't work on some compilers (looking at you MSVC).
The second link does not work by the way.
Yeah, this is one of the case that I meant with the bitmask as well (although certainlyI could have been clearer). Correct me if I'm wrong, but by all the answers, it seems that it depends more on the use case (by which I mean it is not a universally established "best practice"). 
DECK = 52 
I like Oracle Developer Studio... 
I used to use jsmn but found it a little too low level. In the end I migrated over to [cJSON](https://github.com/DaveGamble/cJSON) and just parse json all at once into a giant memory structure. Maybe cJSON isn't the fastest (I have never benchmarked it or needed it in high speed parsing apps) but I find the API really well written.
Thanks, that's a good point. I wasn't verbose but I had assumed that OP was using the default setup for Ubuntu which would be `gcc` as a compiler; by default `gcc` comes with `glibc` which appears to pull a package labeled `glibc-doc` as a dependency. I assumed these were man pages since it makes sense for the library to come with them, but it seems I was mistaken.
It seems they removed it. Try the following: https://web.archive.org/web/20150212013524/http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf
Those are great benefits, but I guess I'm overthinking the approach you brought up and left behind on other places. rigidbody[batch_id] { force[]; velocity[]; transform[]; } rigidbody_to_drawable_copy(rigidbody_to_drawable[0], rigidbody[], drawable[]); What does these line mean? What is rigidbody[]? I assumed it would be exactly like what you would have in your example. Unless I am missing something obvious (I haven't read through Pitfalls of OOP yet) I think there might be either an inconstancy or just a different pseudo-code syntax I'm not used to. Whenever I read things about new ways of thinking, I always take the time to consider how to apply what I've read. When I look at what you have written, I mentally consider how to apply (what I think) you suggest. I think about how this methodology will handle instances where there is a rigidbody/collider but no drawable (invisible wall) or vice versa. I realize that I'm not experienced enough to fully understand or comprehend your suggestions. As Noel said in his article, "It requires turning our mental model of the program ninety degrees and changing how we think about it. It takes some practice before it becomes second-nature." Even though I've been using C for a while now, I am predominantly an OO programmer (and a bit slow to learn no things; not mentally challenged or anything)so I hope you understand that I need some more clarification if I ask for it. I appreciate the help. Here is a more real-world pseudo-code example of what physics in my engine will look like. Maybe it will help both of us if you understand where I come from. https://pastebin.com/3BsHC7ft
The rigidbody_to_drawable_copy job copies the transform of a rigidbody to the transform of a drawable. Keeping the transforms in sync. If you need a rigidbody without a drawable just do not add it to the rigidbody_to_drawable list. If you create an entity having a single rigidbody and a single drawable component (of which the transforms are kept in sync) the following happens: - An entry gets added to the end of the rigidbody list. For ex.: {.transform = MATRIX4_ID, .force = VECTOR4_ID, .velocity = VECTOR4_ID}, at index 362 - An entry gets added to the end of the drawable list. For ex.: {.transform = MATRIX4_ID, .shader_id = NO_SHADER_ID, .texture_id = NO_TEXTURE_ID}, at index 143 - An entry gets added to the rigidbody_to_drawable list. For ex.: {.rigidbody_id = 362, .drawable_id = 143}, this way the rigidbody_to_drawable_copy job knows it should copy the transform from rigidbody 362 to the transform of drawable 143 The copy jobs will mostly access the data sequentially because all component data was created together. To minimize the amount of random access you can create a defragment job that reorders the data over time / multiple frames. The following data order: Component a b c Entity 1 * * Entity 2 * * (copy from a to c) Entity 3 * * Entity 4 * * (copy from a to c) After one defragment step becomes: Component a b c Entity 1 * * Entity 2 * * (copy from a to c) Entity 4 * * (copy from a to c) Entity 3 * * You cannot fully minimize the fragmentation of course. You have to find out the most optimal order yourself and which components to sort first. Note that colliders and rigidbodies are separate. Different components and different jobs (resolving broadphase, midphase, narrowphase etc.). The interaction between the two are handled by different jobs as well (applying reactive forces from collisions to rigidbodies etc.).
I'm working with JSON on small devices so a simplistic, low-level solution sounds ideal to me. I'll have to check it out when I have time. 
Eclipse mainly right now, and occasionally the pre-Eclipse MetroWerks Codewarrior. Notepad++ is great for obscure stuff where you want to easily create your own syntax highlighting. If you're looking for people to take sides in the ancient holy war, I'm on team vi. :wq!
I started writing a 6502 emulator in C once. Wasn't that bad, with the right docs. 
&gt; still run on after an OS X Lion update (and hopefully an OS X Sierra upgrade as well). As long as said app didn't use ObjC garbage collection! :) A little off-topic, but I don't envy Foundation engineers. They've got: - a codebase started in the 80s - fragile-base-class problem on the i386 runtime = no adding stored properties (hopefully you've got a non-public word-sized ivar you can repurpose to point to some *other* object containing any stuff you want to add) - to support retain-release, ARC, &amp; garbage collection - to ship *one* version of frameworks, unlike Java or .NET where several different library versions and runtimes may need to be installed as apps require them
Consider this approach: - Use ints 0-51 to represent cards. Given a card `i`, its suit is `i / 13`, its rank is `i % 13 + 1`. - The deck is just an array of 52 ints. - Initialize the deck by assigning 0-51 to the elements of the array. - Shuffle the deck/array using [Fisher–Yates](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle). 
**Fisher–Yates shuffle** The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite sequence—in plain terms, the algorithm shuffles the sequence. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I was bored earlier and came up with pretty much what you described: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define DECK_SIZE 52 #define PER_SUIT 13 const char *suits[] = {"SPADES", "DIAMONDS", "CLUBS", "HEARTS"}; const char *types[] = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king"}; /* globals bad, but fine for simple program */ int deck[DECK_SIZE]; void print_deck() { int i = 0, suit_idx = 0, type_idx = 0; for(; i &lt; DECK_SIZE; i++) { suit_idx = deck[i] / PER_SUIT; type_idx = deck[i] % PER_SUIT; printf("%s:%s, ", suits[suit_idx], types[type_idx]); } printf("\n"); } int is_original_order() { int i = 0; for(; i &lt; DECK_SIZE; i++) { if(deck[i] != i) return 0; } return 1; } void shuffle() { int i1 = 0, tmp = 0; int i = 0; srand(time(NULL)); do { i1 = rand() % DECK_SIZE; if(i1 == i) continue; tmp = deck[i]; deck[i] = deck[i1]; deck[i1] = tmp; i++; } while(i &lt; DECK_SIZE); } int main() { int i = 0, reshuffles = 0; /* initialize the deck to a simple order (original order) */ for(i = 0; i &lt; DECK_SIZE; i++) deck[i] = i; shuffle(); print_deck(); printf("\n"); while(!is_original_order()) { shuffle(); reshuffles++; } print_deck(); printf("reshuffles: %d\n", reshuffles); return 0; }
being the root user is the real trick here!
I was curious and wanted to get a comparison to implementing it in a higher level/interpreted language. I really should go to bed. Python: from random import shuffle DECK_SIZE = 52 PER_SUIT = 13 SUITS = ("SPADES", "DIAMONDS", "CLUBS", "HEARTS") TYPES = ("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king") def print_deck(deck): print(", ".join(["%s:%s" % (SUITS[deck[i] / PER_SUIT], TYPES[deck[i] % PER_SUIT]) for i in range(DECK_SIZE)])) if __name__ == '__main__': reshuffles = 0 deck = [i for i in range(DECK_SIZE)] original = deck[:] shuffle(deck) print_deck(deck) # This could take forever because Python's slow random implementation or random source while deck != original: shuffle(deck) reshuffles += 1 print_deck(deck) print("reshuffles: %d" % (deck))
Just curious, what's the purpose? How are you going to use it?
It was a project for school 
I used this principle in my [Conway's GOL implementation](https://github.com/Garuda1/gol) Basically, instead of declaring a 32x32 matrix of booleans, we create an array of 32 32-bits integers (`uint32_t world[32];`). The array index is the Y coordinate, and the Xth bit of the selected value is the X coordinate. This way, we theoretically should use 8 times less memory (not true, it depends on the alignment and stuff... but eh) Now, to check if a value in the matrix is 1 (alive) or 0 (dead) I use: `gol/source/cell.c`: int cell_state(uint32_t *world, int x, int y) { if (out_of_bounds(x) || out_of_bounds(y)) /* Checking if the argument is within the matrix's bounds */ return (CHAR_DEAD); if (world[y] &amp; BIT(x)) /* &lt;-- Important stuff */ return (CHAR_ALIVE); return (CHAR_DEAD); } This algorithm uses `BIT(x)`, which is defined as `(1&lt;&lt;x)`, basically, the `x`th bit of an integer can be read using `(my_int) &amp; (1&lt;&lt;x)`, if this expression evaluates to a null value, the bit is 0, otherwise it's 1. You can also set individual bits: /* Clears a bit at a given coordinate */ void cell_clr(uint32_t *world, int x, int y) { world[y] &amp;= ~BIT(x); } /* Sets a bit at a given coordinate */ void cell_set(uint32_t *world, int x, int y) { world[y] |= BIT(x); }
I prefer `if (ptr == NULL)`, since it's more clearer to me that the comparison is about a pointer. Then again, I haven't programmed C for that long, so it may be poor judgment since I'm 'inexperienced' in this regard. In any case, code is read more than it's written, so I prefer a little bit more verbosity.
Doesn't ':x' do the same thing that ':wq!' does? Also, I know that you use Eclipse for MCU development. Any good add-ons for the IDE if you're developing C for TI Stellaris Launchpads? 
Linux for example doesn't pass anything to the kernel through the stack. All arguments are passed in registers. Reading data from the user process while in kernel address space is always slightly time consuming (as in, still fast but much slower than just fetching the data from registers) as a special helper function needs to be called that checks if the address is valid and then reads the datum you want.
If you're working with an embedded system that has extremely limited memory, you'd want to cram all your variables down into the smallest space possible.
From the sound of it, it's getting into the if statement alright. Sounds like scanf isn't doing what you think it should. I would try printing out the next variable after the scanf command to see what it put in the next variable. 
doesnt really understand what you mean, sorry beginner here
Check that another scanf call before this isnt messing up this call. Also If you are trying to just read in 1 char, scanf is bit of overkill. Look into getchar().
so i need to replace it to next = getchar(); right? but the same problem still exist 
&gt;Doesn't ':x' do the same thing that ':wq!' does? In versions that have it, I suppose. It certainly wasn't there when I started using vi. &gt;Any good add-ons for the IDE if you're developing C for TI Stellaris Launchpads? I haven't used any of TI's development tools. Freescale and NXP have put out a couple of MCU IDEs based on Eclipse with a bunch of their own tools.
Well you are expecting scanf to stop the program and ask for input right? It's not doing that correct? If so than scanf isn't doing what you think it should be doing. You need to find out what it is actually doing. One way to find out is to print the value stored in the "next" variable that you pass into scandal. That way you can figure out what scanf is acualy doing. I would print it out as a character and a number in case next is holding a newline character. 
i key in printf("%c", next);to see if anything was stored in the "next" variables, the output just skip a line in the program, because the user doesn't even have a chance to enter Y or N
Are you pressing enter after you put in y on n? If so the first scanf will get the character you want and the next scanf will get \n Try scanf("%c\n", &amp;next); Or after your scanf put fflush( stdout );
i can run the program normally now by putting a space infront of %c, the %c will get the first char in its way and i get the enter key, is there any way to overcome it other than adding space infront of %c
Try doing a %d instead of a %c I bet it's a return character 
ya i change the variable to int and input to 1/2 the program run without any problem because %d scan a digit but if i use %c it scan the next char which happens to be an enter(\n)
Thanks for the reply. I was just wondering, since things seemed to have been shifting. After all, some kernel functions do take `struct` pointers, such as `nanosleep` (`struct timespec *`) and the `mktime` / `gmtime` family (all taking or returning a `struct tm *`)... ...so I assumed there's an easy solution to the performance concerns.
`nanosleep` takes a pointer to a structure because time is not representable as a scalar due to the high range needed (no 64 bit types were available when the interface was designed) and requiring you to unpack the `struct timespec` was seen as bad interface design. Plus, `nanosleep` actually overwrites one of the buffers, so a pointer to that buffer is needed. `gmtime` is not a system call, so the concern does not apply. Same thing for all the other functions dealing with `struct tm`.
MSVC doesn't support designated initializers?! Wow, I guess that the fact that I keep avoiding Microsoft related projects made me live a much happier world 😂 P.S. for ABI stability and complex function arguments: struct foo_args_s { /* options */ } /* ABI is stable since pointer is used */ int foo(struct foo_args_s * args); /* add helper inline function and macro when allowed */ #if __STDC_VERSION__ &gt;= 199901L inline foo2(struct foo_args_s args) { return foo(&amp;args); } #define foo2(...) foo2((struct foo_args_s){__VA_ARGS__}) #endif I do think bit fields and enums are very comfortable, but sometimes these tricks help make the API so much clearer.
Cool! I'm happy to learn :-)
So what is happening is that every key you type including the enter key is being put into stdin. stdin is what scanf reads for input. When you ask scanf for a %c it is grabbing the next thing in stdin. That happens to be a \n because someplace in the past you had to press enter to get some other input. Maybe try scanf("%c\n", &amp;&lt;variable&gt;); for you scanf calls. This might eat the enter key up as well. 
that wasn't the assignment. The assignment was to use structs, and there was a certain shuffle he wanted us to use. 
Yeah but i needed a out-shuffle. Look that up and you will see why that algorithm wouldnt work for me. 
That's limiting the creativity of students.
Nah we were learning about structs and that shuffle is really good practice in programming. 
Try leaving a space before the %c in the scanf, like that scanf(" %c",&amp;next);
gcc is a compiler, it converts C code into an executable file (skipping over a lot of details here) Do you know what compiler you are currently using? Are you using an IDE or do you use a command-line program to compile your code?
GCC is the GNU Compiler Collection, a compiler system which supports several programming languages (including C). Compiler is a software which 'translates' your C code into something that your CPU understands and executes (object code, machine code). So, in order to execute your program, you need to compile it using GCC. Arguments passed to the compiler (in this case main.c and foo.c), are the files that the compiler needs in order to 'build' your program. You can add some other arguments (for example, the -o flag, for naming the executable which the compiler produces, in this case 'my_app') to tell the compiler exactly how you want your program to be 'built'. GCC is the default GNU/Linux OS compiler collection, so if you are using Windows, you're going to have to install some other C compiler (minGW). 
What operating system do you use?
Then go get yourself Visual Studio. This should be enough for learning C and is the least difficult to set up.
I just took a quick loop. When I open a C project there, I see "gcc version 4.6.3" so it looks like you already have gcc. If you click the "Add new file" button on that page (near the top-left corner), you can rename the new files to be "foo.h" and "foo.c" If you then run the project, it should [just work](https://repl.it/Jcue/2) Of course, I would recommend getting a local development environment set up soon since it gives you a lot more control over what's happening in your project, and a better awareness of all the steps. 
So do I need three files, two .c and one .h? Because what the professor has assigned is asking for just one of each called (myname).c and BigArithmatic.h. You can't rename main.c in repl.it, but If I were to make the project (which is nothing complex) on that website, copy paste main.c into my own file called (myname).c and do the same for BigArithmatic.h but keep the name the same, would that cause any issues?
That sounds like it would be okay, the two .c files was based on the question you linked. What would be in BigArithmatic.h in this project?
The project is about different ways to multiply very large numbers and the time economy of the different ways. I'm pretty sure that the different functions and their definitions would be in the header file, right?
I also realised that using `uint64_t` to store the order of the operation is hillariously stupid. The results of such operations cannot even be digitally represented in our universe, even when using every single Plank volume in the observable universe as a bit. And it wouldn't even be enough to store its number of digits. And the number of digits in its number of digits. And so on for a number of times far exceeding the number of particles in the observable universe. This is blowing my mind on so many different levels. But what does even more is that there are numbers far, far greater than this. Which can be computed by the `TREE` function. `TREE(1)` is `1`, `TREE(2)` is `3`, and `TREE(3)` is so gargantuously large that I don't know how to describe it.
I understand now. Thanks for the example!
I see, Good luck.
You're in the right neighborhood, but you may have made the comparison of inc, plus, etc to the Ackermann function a little too strong. The Ackermann function is 1. *total*, meaning it is defined for all natural numbers 2. it is *computable*, thus we can come up with a Turing machine (or equivalent model of computation) that always halts given input *n* with *Ackermann(n)* on its tape 3. is **not** *primitive recursive*, but it is [*μ-recursive*](https://en.wikipedia.org/wiki/%CE%9C-recursive_function) The number theoretic function (succ or inc, plus, times, etc) *are* primitive recursive, and all primitive recursive functions are total and computable. Thus there is a lot of overlap but there is an important difference between your functions and Ackermann (important to theorists, at least). At any rate, very impressive "rediscovery" of primitive recursion, considering you evidently had no one prompting you in that direction. These are fairly esoteric topics.
**Μ-recursive function** In mathematical logic and computer science, the μ-recursive functions are a class of partial functions from natural numbers to natural numbers that are "computable" in an intuitive sense. In fact, in computability theory it is shown that the μ-recursive functions are precisely the functions that can be computed by Turing machines. The μ-recursive functions are closely related to primitive recursive functions, and their inductive definition (below) builds upon that of the primitive recursive functions. However, not every μ-recursive function is a primitive recursive function—the most famous example is the Ackermann function. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
The code you posted shouldn't crash and doesn't crash on my machine. Could you post the actual code you tested? While reducing your example is very useful, make sure to not delete the code that actually causes the error!
I feel like you may have a bug earlier in the program. Put a fflush( stdout ) on the line before your scanf and it will remove any data from the input buffer meaning that the next character you get will be the one you want. If that works you might have another scanf that needs fixing. Fix it my putting \n in the scanf pattern so than scanf consumes the enter key as well.
for whatever it's worth, it compiles and runs fine here, aside from missing a prototype for "func". I'm running it on ubuntu.
Yeah, the if is probably crashing because you are passing a string the is not zero terminated to strlen, in the example given this is not the case because you are passing a constant to the function. 
The code is part of a homework assignment. I don't want to be accused of cheating, or of asking others to do my work for me, so I just posted what I thought was the most essential and confusing part of the code, but if you insist, I'll see if I can post the whole problem. Edit: I edited my code a bit. Is it more understandable what the error may be? Must be more specific still?
If you don't want to post the whole code, that's fine. Try to find a different reduced example, but make sure that it crashes on your computer! Remove parts of the code until it no longer crashes (or crashes for a different reason). Then undo the last change (so you get the smallest version that still crashes) and post that.
OK I'll give it a go.
Have you tried to run it? It's guaranteed to dereference a null pointer. When you 1st call addNode, head is null. So you call constructList, which dereferences head.
The code you have posted crashes? Is this on a 64bit system by any chance? Edit: What compiler are you using? I just tried 4 different ones and none of them will compile this because of a lack of a prototype for func() causing errors.
Yes, sorry I had fixed already. I'll update it
Can you double-triple-check that there is no typo in you original code? Like if(str = NULL || buff == NULL) instead of if(str == NULL || buff == NULL) or strlen(buff) instead of strlen(str) or if(strlen(str == 40)) instead of if(strlen(str) == 40) There has to be something of that kind somewhere, IMO.
General advice - look for repeated code you can refactor in a common fns. Mallocing a node, mallocing its name, and strcopying its name, is one such example of repeated code. How about adding fn, allocNode, that malloc's up a new node, initializes it's name, and returns it (you can init prev and next to NULL and let the caller set them up - or take prev/next as arguments - see which you like better). Note - constructList already, almost, fits the bill. Note how allocNode compliments the existing fn, freeNode, which frees all the storage associated with a node (though why you jammed it all on one line is another q...). Notice that addNode potentially calls strcmp twice to compare the exact same strings. In principle, this is an expensive operation and shouldn't be done unnecessarily. Also, addNode has five different return statements. Generally it's better to have one, at the end. Besides making the code easier to follow, when you're debugging there's just one spot to set a break point. E.g. if you wanted to examine the list after each addition. Why the field name totalCost instead of just cost? To me, totalCost implies the summing of costs from multiple nodes. After making some of these changes, take another long, hard look at addNode. It strikes me as big, complicated, and repetitive. I think you should be able to shrink it down considerably and simplify the logic in the process. Post again if you want further comments.
Calling the function causes undefined behaviour because it was implicitly declared to have return type `int` but the definition has a different return type. Add a function prototype etc. and see if things improve.
What I'm about to write is probably a little too soon and int might not be relevant for you today. I'm not sure how far along you are in your studies, so maybe you can ignore this or keep it as something to think about for later. --- I took a very quick look and my first thought was: "this can't be re-used"... It's true that your code might do it's job today, it's probably good enough for homework and a very good exercise for a student... ...but in the real world it wouldn't last for long. It seems to me that the linked list got married with the data, which is a mistake in my book. The linked list should be independent of the data it carries, this way you can re-use the list when you have more data types in your application. Also, combining the data and the list makes some of the functions messy and harder to read - for example, `addNode` is really `addData` and it's a long messy function with a lot of logic that can be separated into different functions. consider: struct list_s { struct list_s * next; struct list_s * prev; }; #define INIT_LIST(name) {&amp;(name).next, &amp;(name).next } Where the data has: struct Data { struct list_s node; /* ... data goes here ...*/ }; There are other options, but now you can create functions that manage a list and separately create functions that allocate, deallocate and manage data. Also, because the `struct list_s node` is the first declaration in the `struct`, the pointers `struct list_s *` and `struct Data *` are interchangeable, which acts similar to inheritance in object oriented languages.
This has nothing to do with whether this works or not, but what does this do? token = strtok(NULL, delim); I understand that strtok returns a pointer to the first occurrence of delim, but why pass it NULL? Edit: Just read that if passed NULL strtok will pick up where it last left off, nevermind.
Life Advice: just ask the person teaching ya. In any class you can usually hand an assignment in early and ask professor specific questions, like you did here. This is highly adventurous when looking for jobs or research positions because you've set up a relationship with this professor and you showed them you had a set of ethics to take extra steps. You also get to learn more programming in the process.
After adding a prototype I get: /usr/bin/g++ -Wall -Wextra -std=c++11 a.cpp -o a a.cpp:14:10: warning: ISO C++11 does not allow conversion from string literal to 'char *' [-Wwritable-strings] func("0123456789abcdef0123456789abcdef01234567"); ^ a.cpp:19:12: error: cannot initialize a variable of type 'stuff *' with an rvalue of type 'void *' stuff *buff = malloc(40 * sizeof(stuff));
This is C, not C++...
Whoops. 
Hey, thanks! You're definetly right in that jsmn doesn't actually parse the data as in convert them to appropriate datatypes but just saperates the tokens. But I didn't require that features and it seemed really small so I went for it. Does RapidJSON work with C? It says on its github page that it's made for C++. Edit: Forgot to mention, facil.io looks really cool!
&gt; head-&gt;name = malloc(strlen(name) + 1); &gt;strcpy(head-&gt;name, name); head-&gt;name = strdup(name)
didn't he do all that in ConstructNode?
What is the context of this post? It seems like jumping in halfway through some argument.
`strdup` is not in C89 - it's POSIX and not 100% portable even today.
I'm on my phone at the moment so I can't compile and check the code, but it looks good. It shouldn't crash. My advice is to run the code in a debugger and step through it line by line. The stacktrace given by the debugger could help you narrow down the problem. On an unrelated note; you have a nasty potential memory leak bug in your code if you pass NULL to func().
@curious_s is rigth, that's probably the reason. A string looks like that in memory: ------------------------------ | S | t | r | i | n | g | \0 | ------------------------------ if you are working with char* you can't delegate the ending character to the compiler. Maybe it put the \0 or not. Usually they do, but... So, if you don't have the \0 when you work with the string, like the strlen, the function works until it finds the \0. It wont find it so ... crash. Hope this helps. Edit: In C11 standard draft n1570 6.7.9 initialization: 10 If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static or thread storage duration is not initialized explicitly, then: if it has arithmetic type, it is initialized to (positive or unsigned) zero; . So if your compiler suports c11, your code will work. otherwise, nopes. 
This attitude of yours is not going to get you very far. Name calling and derogatory terms arn't signs of being the sharpest tool in the shed. It appears you also place way too much responsibility on your professor - he might actually be irght, and you might not be. The comparison to tennis is way off, in such sports you train repetitions that needs to be spot on to build muscle memory and to enhance your own physical structure - programming as a cognitive skill is an entirely different practice.
Strdup is sys v
I've tried your extended example, it still doesn't crash on my computer. Try adding more of your actual code!
These rules didn't change from ANSI C to C11. I don't think this excerpt is relevant. Note that string literals have always been automatically null terminated, i.e. if you write `"foo"` the compiler puts the bytes `'f'`, `'o'`, `'o'`, and `'\0'` into the program.
Somethings to keep in mind: 1 - The line struct BigInt A[300] is creating a array of the type struct BigInt, and BigInt, the way it is, represents nothing but array of a struct that doesn't has any members. The numbers you are initializing go to the memory limbo. 2 - In relation to [1], the struct should have some member field. If you want to use it to store numbers as an array of integers, you should put this int array as a field of the BigInt struct. 3 - I do not recommend staticly defined array of a bigger size than the size you really need to use. Use resourses like malloc if you don't know how much memory you gonna need. 4 - In C, arrays start at the 0 index.
Why doesn't your `struct BigInt` have any members?
For now it's OK, but once you learn to dynamically allocating your stuff you gonna a lot of things more efficiently and cleaner. Check this out: [link](https://pastebin.com/Z7X0Yjk0) EDIT: let me know if you don't understand something
My pleasure. If you have any more questions feel free to contact me (you may PM me as well).
This was very helpful, and I already feel like my code has improved. Still trying to figure out how to improve the logic in my addNode function, but I'll keep at it. Thanks again.
Yes, but I could've further abstracted that function to make it usable for other nodes, rather than just the first.
Hmm, this is definitely something that has got me thinking... I'm about sophomore-level, btw. The concepts of code re-usability and separating data and the structure that holds it are ones that I've heard about, but haven't given much thought to. I'll try to start applying this idea in my work. Thanks for your reply, I feel it was very insightful!
Something, something, static variables :)
Heh, thanks for the life advice... I do occasionally go to his office hours, but never really for my own code. Usually, just to talk about some concepts more deeply. I try to exhaust all/most of my resources before going to ask my professor for homework help. Maybe that's the wrong mentality!
Well, either way, the point stands - it's not in C89 and it's not portable. 
Structures, enumerations and function prototypes before main. That's nice. &gt; if ( (! ( strcmp( original_deck[1].suite, deck[1].suite))) &amp;&amp; ( original_deck[3].rank == deck[3].rank)) NO! Not in the main loop.
Then where and why? 
You could start by trying to fix some bugs: https://github.com/curl/curl/issues
Since you are using original_deck and deck as variables local to main, make a function that will take a pointer to both and do the comparison from the function. Return false if the function fails. 
Always a good idea!
*wipes tear* beautiful.
&gt;is not primitive recursive, but it is μ-recursive And after looking stuff up I wanted to try and implement my own Ackermann function. I expected it to run out of memory from excessive recursion for `n=5` or `n=6`, turns out the program runs out of stack space at `n=4`. That's just ridiculously impractical. Where my function is better is that I can initialise `res` like this: switch(order) { case 2: res = 0; break; case 3: res = 1; break; default: res = a; break; } Since for `order&gt;3` or `order=1`, `res` should be initialised to a. In the end my algorithm looks like: order_n(order, a, b) { if (order = 0) return a+1 else if (order = 2) res := 0 else if (order = 3) res := 1 else res := a for (i := 0; i &lt; b ; i := i+1) a := order_n(order-1, res, a) return res } Which in C translates to: uint64_t order_n(const uint8_t order, const uint64_t a, const uint64_t b) { uint64_t res; size_t i; if (order == 0) return (a+1); /* Here we initialise res */ switch(order) { case 2: res = 0; break; case 3: res = 1; break; default: res = a; break; } for(i=0; i&lt;b; ++i) res = order_n(n-1, res, a); return (res); } This function does require a lot of recursion, but a lot less than Ackermann's phi function. So I'm pretty happy with it. Not that I'm going to use it, though, since I'm not sure there is any computer on Earth capable of running this function with `order&gt;=6`.
Yes, I'll start with that once I am done with the basic guide. can you recommend me some other open source projects related to network programming? EDIT: Thankyou!
You're welcome, and thank you too 👍🏻 &gt; Does RapidJSON work with C? It says on its github page that it's made for C++. RapidJSON is a header library, full of class declarations and C++ specific code. It requires C++ and I don't think you could use it in a C source file (though you could mix C++ and C in most projects). &gt; ... just saperates the tokens ... If that's all you need, than probably any library will do. The faster seems to be `ujson4c`. However, if you need full data parsing, consider that some seemingly fast libraries, such as `ujson4c`, might not completely parse the JSON (just tokenize it)... I'll explain: [Low conformance scores](https://rawgit.com/miloyip/nativejson-benchmark/master/sample/conformance.html) are fine, since it mostly tests the parser's strictness. For example, it tests if Hex numbers are rejected (facil.io supports them, along with comments, NaN and other extensions). However, String parsing should be considered a high priority. Some libraries get ~ 89% String conformance, which probably means that it doesn't parse the `\uXXXX` escape sequences correctly (probably ignoring the UTF surrogate pairs. Some libraries, such as `ujson4c` and `jsmn` have an even lower String parsing score, probably indicating an issue with more escape sequences (which can include `\r`, `\n`, etc') or maybe even all of them. I don't know what you're doing with the JSON, so some features might not be as important to you. For example, `double` conformance checks for rounding errors as well (notice the differences between C++ double handling and C double handling where rounding is concerned in the `printf` library call). Some libraries just keep the string value to avoid getting caught with rounding errors. If you're looking for full JSON parsing, you might consider json-c , Vinenthz/libjson, , udp/json-parser. I didn't check all the libraries out there, but these three seemed most likely to provide correct results. Out of the three, testing on my machine, only [udp/json-parser](https://github.com/udp/json-parser) outperformed `facil.io`, and I think it's because it doesn't seem to use a Hash table (it seems to use name-value arrays, but I might be mistaken). Did I mention I'm biased 😉 Anyway, good luck!
Sorry for the late reply. This code was compiled in VS 2015.
Yup, just a typo. 24 hours in front of my computer, and it's just one single missing `=`. I wouldn't have noticed this without your help. Wow... I'm speechless at my own obliviousness. Of course, now I've got a whole bunch of segfaults in different places, but at least this specific part of the code works now. 
It turns out it was a missing `=`... (╯°□°）╯︵ ┻━┻
It was a typo...
It turns out it was just a stupid typo that I couldn't spot, but thanks for your help anyway.
That's one of the compilers I tried. You need to post the exact code giving you the problem, not something different that doesn't even compile.
... It was just a typo...haha... I'm sorry
Why. Simply for readability. Cuz it's sure not easier 
I'm all about math-heavy. I'm out and about right now, but once I get home tonight I'll give it a spool through and edit this comment accordingly. Really cool sounding project! 
I would comment your code more, if someone else wants to mod this, it'll take a bit more time than might be necessary were you to have explained some of the functionality within the logic. I also noticed what appeared to be a lack of error checking. I imagine this to be an artifact of you having tested it thoroughly, but in terms of what I would have done differently, I think it's nice to add error checking because if/when this code is run on different machines unexpected behavior might be encountered, and having those stopgaps in place will help whomever debug the code. I like the idea. Seems like it could turn into a nice sim function codebase if there is a fair amount of contributed work. 
Yes you can put a variable in your case: switch (var) { case var2: // do something break; } And for multiple conditions in a loop, you can use the logical AND operator (&amp;&amp;). So: while (something == something &amp;&amp; this == that) { // do sometime } 
Nice!
**Question 1:** No you cannot use a variable for a case statement. The various cases must be a constant expression. int a = 0; int b = 0; // Some stuff happens to a and b here... switch (a) { case b: // This is the thing I want to do break; default: // This is other thing I want to do } is not valid C. What you would want to do is something like this: int a = 0; int b = 0; // Some stuff happens to a and b here... if (a == b) { // This is the thing I want to do } else { // This is other thing I want to do } **Question 2:** Yes. The following evaluates every time the while loop executes int a = 0; int b = 0; while (a != 1 &amp;&amp; a != 2 &amp;&amp; b != 3) { // Some stuff happens to a and b here... } Edit: C *constant_expression*
Excellent. Looking forward to it! It's basically a nonlinear differential equation solver with a couple extras.
i tried that on case and didn't work thanks 
thanks a lot 
Finished reading "tmux productive mouse-free development" and it changed my life.
Yeah there isn't any error checking right now. I'm passing enough data around to check a few things but haven't implemented anything yet. Right now my process is to implement everything in Matlab before c so I have something to test against. I don't really have enough c experience to develop and debug new c code. Still relying on Matlab/Matlab debugger to get things working before moving to c.
That's not for buffer overflow protection, it's to keep rsp aligned on a 16-byte boundary. If x is 16, or a multiple of, then there will be no slack space.
I would assume it is intended. That seems deliberate. An interesting part of that disassembly is it could attempt to stack allocate 18446744073709551600 bytes on the stack. Seems legit.
something I noticed that will likely throw an error is the if( (something == NULL) || (otherThing == NULL) ) statement. If the thing is null, the program won't be able to make the comparison because it has nothing (literally, NULL means nothing) to compare from. 
Without looking at the code... In C NULL is defined as ((void*)0) or pointer to memory location zero for a "generic" type. It is perfectly valid, and in fact good practice to compare pointers to NULL to make sure they are pointing to something before using them. Now, you'll get a *runtime* error if something is pointing to NULL, and you try to access the value pointed at by something(a.k.a. dereference). '*something'
Is that true when "something" and "otherThing" are pointers? Generally that check would be done to see if a pointer is set or not. Can you tell me the file/line number where you see the problem?
On network programming I only read of netcat. Don't ask me anything about it, I have no clue, but maybe you find it interesting. https://en.wikipedia.org/wiki/Netcat
Yep, runtime error is to what I was referring. I figured he'd want to know about that as the comparison is in a conditional statement that frees memory if true. I might be wrong, because he isn't referring to the dereferenced value, only the pointer itself. I ran into some errors on a program that I wrote comparing to NULL, but they weren't pointers, so perhaps that's the disconnect in my logic. Sry if I was wrong. 
No worries. Thanks for looking at it anyway! I can't think of a (normal) situation when you would compare anything other than a pointer to NULL.
You're welcome! I was error checking to see if a variable, that was initialized to NULL, had been assigned a value. I could have, and eventually did, use the conditional if(var) to see if it was, but it initially threw an error during runtime. Good luck!
`dealAHand` finds an unused card, marks it used, and prints it out. It does _not_ convey that information back to the caller. You need a data structure to hold the dealt cards that you pass in to `dealAPlayer` and `dealAHand` and through which, the choice of card(s) is passed back. The arguments `suits` and `faces` are kinda named like they would be such a data structure, but what they really represent are constants holding strings used to display cards. It's kind of weird that you pass these constants in. I would have expected them to be global variables, but maybe your instructor has forbidden you from using global variables? Alternately, maybe you're conflating these constants with the data structures that you need to hold the cards. In any event, there's clearly confusion with the basic design of the program (hard to tell how much of it is yours vs how much was provided to you) that you're going to need to sort out. It's not just a matter of finding the bug. Also, I don't think this code means what you think in means: int deck[4][13] = { AVAILABLE }; The only reason this "works" is because `AVAILABLE` happens to be zero. You should look up the details on how array initialization works. "Just because it works doesn't mean it's not broken." 
You sure you want to have a struct with 300000 integers? There is no limit on how large structures can be, but that just looks like you are not sure what you are doing. How about a dynamic structure like this: struct BigInt { int *val, size; } where `val` is dynamically allocated and `size` says how many entries `val` has. The only difficult thing left is to figure out the algorithms to add, subtract, multiply, and divide numbers represented like this.
Would that let me store numbers that are too large for regular variable types, like 50!, into A.size? Regardless, that's how my professor said to do it and nobody can get in contact with him.
As I read u/FUZxxl's intention ... the `int size` field is the number of consecutive digits (stored as `int`s) you will find at the pointer `int *val`. In your 10! example, `.size == 7`, `.val[0] == 3`, `.val[1] == 6`, etc. up to `.val[6] == 0` (the last digit of 10!). The number of bytes allocated that `val` points to might be any amount greater than or equal to 7. You may or may not know in advance how many digits you are storing. The allocation (and freeing) are up to you. As it is, in C. :-)
&gt; That's not for buffer overflow protection, it's to keep rsp aligned on a 16-byte boundary. Hmm, I did not think of that, good point. &gt; If x is 16, or a multiple of, then there will be no slack space. Yes that is correct. In the disassembly, the `rax` register is loaded with `x + 15`. Then `rax` is `AND`ed and the **result of the `AND` makes `rax` aligned by 16**. After investigating with different inputs, it seems like the compiler has set itself up with **at most** 15 bytes of slack space based on the value of `x`, which I need to correct in my OP (it says there will always be 15 bytes leeway). However, what's interesting is that no matter the input, it is always enough to protect against a buffer overflow. There is always enough stack space allocated for the VLA because of the `lea` and `and` instructions mentioned in the OP. Could this all be just a coincidence? 
&gt; Yup, just a typo. 24 hours in front of my computer, and it's just one single missing =. I wouldn't have noticed this without your help. Wow... I'm speechless at my own obliviousness. Bah, it happens. The ridiculously small typo looks stupid, oneself feels stupid too, but that's because it is small and stupid that it is hard to spot. With experience, they still happen from time to time, but you can spot them more easily because: * you know the different kinds of typos that can happen, because you underwent them already (and remember how long and painful it was to find them the first time(s)); * you know the language better, so you can tell faster that it shouldn't be the fault of the language so you can start looking for typos and other stupid mistakes. Thats's how I thought it was probably a typo not present in the code you showed and proposed a few possible ones :-)
Well, I guess as an educational exercise it is fine to use a very large fixed array size. However, in practice you should use some scheme involving dynamic memory allocation. &gt; Would that let me store numbers that are too large for regular variable types, like 50!, into A.size? No. It seems you misunderstood the way this structure works. `val` contains the number you want to store in base 2³² (or 2³¹ resp.) and `size` contains the number of places stored in `val`. If you want to deal with numbers that have 50! places, then I don't think there is any way to store them completely.
The way that I've been doing it is by making val an array, letting me store huge numbers, each part of the array holding one number. With this create numbers that have up to however large you can make an array number, of digits. I can make and store a random number that has 300000 digits with the above code, just not a specific one like 50!.
Did you post a complaint online somewhere? 
In `csim2/constructors.c`: struct StrictlyProperBlock * block_new(struct StrictlyProperBlock const stackb) { struct StrictlyProperBlock * heapb = malloc(sizeof(struct StrictlyProperBlock)); if (heapb) memcpy(heapb, &amp;stackb, sizeof(struct StrictlyProperBlock)); return heapb; } You could just say `*heapb=stackb;` to copy the structure content. (There's another occurrence of the same kind of `memcpy()` later in the file too.) (And I personally don't like taking the address of a parameter, it is just a value (here, a set of values) that has to be copied on the stack to then take its address, it is not the original structure that was passed as argument in the caller. So if `&amp;stackb` was destination instead of source in `memcpy()`, the result wouldn't appear outside of the function, once the function is over. I am not sure you are aware of this, so I prefer to mention it.) --------------------------- #define freeif(ptr) if (ptr) free(ptr) freeif(storage); freeif(input_storage); freeif(output_storage); freeif(bheap); #undef freeif You don't have to test that a pointer is non-`NULL` before `free`ing it. `free(p)` doesn't do anything if `p` is `NULL`, that's all and that's fine. 
Yes, it's a coincidence. gcc definitely does not do anything on purpose to help you when you invoke undefined behavior. 
I get your first and third point. I'll update the code. Thank you! I think what you're saying in the second point is why pass stackb by value when all you need is the address? The idea was to be able to make a one line call like: block_new(integrator(1)); Where integrator returns a struct StrictlyProperBlock. Would it work as a one liner like this: block_new(&amp;integrator(1)); Awesome if that would work but feels like cheating as there isn't anything to have an address to? Edit: formatting
I started with tiling window managers (in particular dwm), but as soon as I switched to tmux my life was so much better. I still love dwm, but since almost everything I do is in-terminal it just isn't as applicable, and now my development environment is available on anything with an ssh client. Glad I could help!
Modern CPUs implement instructions on scalar data (that is, operations that work on single pieces of data at a time, like just a normal a + b = c), and instructions that work on vector data (that is, doing the same operation to multiple different pieces of data at the same time, such as doing a0 + b0 = c0, a1 + b1 = c1, a2 + b2 = c2, a3 + b3 = c3 in a single instruction.) Vector extensions to x86 are named (in order they were added): MMX, SSE1-4, AVX1-2, AVX512. If your code is amenable to being vectorized, you can get major speedup for doing so, but this often requires very careful planning about how you layout your program and data.
Would love to see a fully worked example in C.
Getting a patch into the main code base is not super hard (I had a very small contribution to Cistron RADIUSD back in teh dial up days. Fixing a bug and proper regression testing is usually more welcome than a new feature. Typically a feature means that you're part of the 'inner circle' and understand the direction of the project. A bug fix is a bug fix.. unless it replaces a major portion of the existing code base they'll happily take it if you present it well and its documented properly.
I use MightEMacs. Really like the non-modal editing, has built-in C support, a C-like scripting language, and is fairly easy to learn for an Emacs variant.
LibreSSL. Developed by guys at OpenBSD so secure and rock solid.
Why can't you store 50!?
 newStudent = malloc(sizeof(struct student)); This line allocates enough memory to store a _single_ `student` structure. scanf_s("%i %i %i %i", &amp;newStudent[i].exam1, &amp;newStudent[i].exam2, &amp;newStudent[i].exam3, &amp;newStudent[i].exam4); This line is written as though `newStudent` points to an _array_ of `student` structures. One of the above two lines needs to be changed in order to resolve the discrepancy. It's hard to tell which one without seeing the rest of your code.
instead of making a function return a struct (which is a bad idea), you could pass a pointer to struct as an argument, that way you could declare the struct from the calling function and pass the memory address of it to get initialized.
maybe _realitycheck_ is thinking of readability, then you could have something like: are_decks_the_same( &amp;orginal_deck, &amp;deck ); A comment would do because what the code here does is not immediately obvious. In one months time you will look back and wonder what you were trying to achieve. 
You probably want %d instead of %i
Yeah I don't have many examples set up yet :(. Did you see the (single) test function? Also mexdemo is written in c but not set up to be called from c.
You are completely right. Thanks FUZxxl
Nice library! Thanks for sharing. Nice to have when for instance trying combinations of things, and storing combination and result in an efficient manner.
Second one returns dangling reference
Just to make it a little more clear, the variable result doesn't exist anymore when the function returns, thus the pointer points to nothing, I.e. dangling
&gt; I think what you're saying in the second point is why pass stackb by value when all you need is the address? Nay, that's not what I meant. :-) What I meant is that, often, when I see people trying to take the address of a parameter inside a function, it is a mistake. They would like to modify the original argument, but in C everything is passed by value, by copy, so there is no relation to the original argument once you're inside the function. One way to see that it is awkward to take the address of a parameter, is that the parameters can or could be passed by register, and a register has no address. In your case, it works OK and it is legal ; it has however the drawback that, if the structure content was passed through registers, that content has then to be copied on the stack, so that that address can then be used in the `memcopy()`. But if, instead of `memcpy(heapb, &amp;stackb, ...)`, you had wanted to use `memcpy(&amp;stackb, heapb, ...) hoping the original argument for `stackb` to be updated, you would have been surprised. `&amp;stack` points to a temporary object (which contains a copy of the values of the argument) on the stack that won't exist any more when the function exits, it doesn't point to the original object. That's why I am suspicious when I see `&amp;parameter` in a function (and I don't use it), it is not natural and often the result of a misunderstanding (or the cause of one, if someone gets to modify the function afterwards).
&gt; The idea was to be able to make a one line call like: &gt; &gt; block_new(integrator(1)); &gt; &gt; Where integrator returns a struct StrictlyProperBlock. Would it work as a one liner like this: &gt; &gt; block_new(&amp;integrator(1)); &gt; &gt; Awesome if that would work but feels like cheating as there isn't anything to have an address to? You're right, you cannot take the address of a return value. One would usually just have `integrator` return a `struct xxx *`. That's lighter to return from a function, lighter to pass to another function, compared to having to return or pass the whole set of fields a structure contains, which can be very heavy if the structure has many. And you wouldn't need `block_new()` any more, the heap allocation would take place in `integrator()`. I don't know if that would break the architecture of your program?
Thanks mate. I don't have any Freescale or NXP boards so it's pointless. Probably will have to role out my own for the TI board. There is always Code Composer Studio that TI provides but I wanted to see if I could use an open source IDE. *Edit*: I did come across this [getting_started_with_the_ti_stellaris_launchpad_on_linux!](https://www.jann.cc/2012/12/11/getting_started_with_the_ti_stellaris_launchpad_on_linux.html) 
You should malloc() the result in the second try, instead of allocating in the stack. Or copy back the result to s in the end.
Copy won't work. New string would end up longer than original.
Ah, that's probably why the first one is failing as well, since "Hi" becomes "Hi!" and it'll seg fault on writing the extra '!'. I used malloc with result and now it works. And I think I understand. Thanks.
Ok, working code: #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char* remove_bang(char *s){ char *p, *t; p = calloc(strlen(s) + 2, 1); for(t = p; *s!= '\0'; s++){ if (*s == '!') { continue; } *t = *s; t++; } *t = '!'; return p; } Explanation: In worst case, resulting string is one character longer than input. `strlen` doesn't count terminating zero, hence +2. I use calloc to delegate zeroing new array to stdlib. strlen is trivial to replace with a loop, but why? Then, straightforward copy of string excluding all bangs. And plopping of final exclamation mark in the last free place, without worrying that resulting string won't be null-terminated.
OK. Zeroth: use [multibyte strings and related functions](http://en.cppreference.com/w/c/string/multibyte). UTF-8 is default lately and compatible with ASCII from single-byte strings. First, you use strtok, but not include string.h Second, in concat, you can pull entire second condition, both realloc and strcat are smart enough to return original pointer if \*string == NULL. Can't say anything about performance. Third, you define VAR\_\*\_TAGs, but [use bare values](https://github.com/Isty001/dotenv-c/blob/0c7b40dd21c78cd182ee06b0f98d7509b827925b/src/dotenv.c#L44-L45). Also, why VAR\_\*\_TAG instead of \*\_TAG? Put OPEN\_TAG, CLOSE\_TAG, COMMENT\_TAG instead. Fourth, in above lines, I don't understand why you are searching for token in NULL. This isn't thread-safe. I don't quite understand whole logic in this entire parse_value function. But that's on me. You may want to put more comments in dotenv.h . What's path (it's current directory), what overwrite does. 
Some critique: * having *env_load* first attempt to open the argument as a directory (and then as a file if that fails), is a bad idea. If the programmer wants foo/.env, let him explicitly type that. * Your *char path[]* will overflow the stack with a sufficiently long argument. You should reject strings longer than PATH_MAX beforehand. * Your *char path[]* does not allocate space for the null terminator. * You open the files with "r". Don't do that; always use "rb". It'll prevent the OS from messing with your line endings on certain platforms (e.g. Windows). * Never use *strtok* in libraries (or at all, really). It saves a pointer to the string it's working on; if the calling code uses it as well, their state will be lost. * Why VAR_OPEN_TAG, COMMENT_CHAR and so on? You think that is ever going to change...? Just use '#' and such directly. * In the *parse_value* function, you're trying to handle a tiny part of what bash is capable of, i.e stuff like `FOO=${BAR}`. What if the .env file contains `FOO=$((1+2))`? *FOO* should now be 3, but to support all this stuff you'd pretty much need to completely reimplement bash. Not very realistic! To do it properly, you'd need to do something like calling *popen( "$((1+2))" )* and storing the return string. However, doing this is kinda pointless as you could have simply executed "source foo.env" instead, and the entire file would have been processed for you.
&gt; Zeroth: use multibyte strings and related functions. Why? There's nothing in his code that needs to be multibyte-string aware as far as I can see.
Ok I see what you're saying now. Because what I'm passing in is a copy the address of that copy isn't the same as the address of the original. Incorporating your first comment means I don't need to call memcpy anymore so the &amp;stackb goes away.
Well, yes. It should work fine with multibyte environmental variables. But I have a small degree of doubt, hence the comment.
I work with some guys who do a lot of embedded work where the malloc function isn't always available. So the reason I made my constructors return a struct (rather than a pointer) is to avoid malloc calls for as long as possible. Right now malloc is only used in "constructors.c" and "solvers.c" in functions that are technically unnecessary but convenient. This way everything can be done on the stack if that's what you want to do. I don't know if that's actually better or not but that's my reasoning...
 xxd -p binary_file | ascii_hex_analyzer
running 64 bit ubuntu MATE 16.10 On my system it looks like those directories are in /usr/share/man. man0 doesn't exist. directories man 1 through 8 are there.
so when I type `man 0 stdlib.h` It returns the man pages for stdlib.h(3avr). Oh... I wonder if that is for arduino. I've used this laptop in the past for programming an arduino. Could installing the arduino IDE affect my man pages by possibly over-writing files? I wonder if the man page for stdlib was even there before installing the IDE.
Man pages installed by the system belong in `/usr/share/man/`. Man pages installed by users should go in `/usr/local/share/man/`. The `man` command should pull pages from the `/usr/local/`directories first and should be able to parse through any `/usr/local/share/man/man*/` directory even if there is not an equivalent in `/usr/share/man/`. **EDIT:** Have you checked for updates? Have you tried to force an update with `sudo apt update &amp;&amp; sudo apt upgrade`? If neither of those fix this, you could try to find which package controls your system's man pages and force a reinstall on that package. Lastly, you can still store your own man page for `stdlib.h` in the `/usr/local/share/man/` directory.
Alright, so there isn't a man0 directory. So that just means it's structured a little differently on my system and getting those files from some place else?
The standard man page for `stdlib.h` was almost certainly there, and probably still is somewhere. It would be *very* strange for a package to overwrite the man pages for another package. Arduino is built on top of AVR-GCC so what most likely happened is that the IDE created a `man0` directory somewhere that the `man` utility would search prior to finding the standard man page. Having found a properly named file that matches your search it returns that without searching further. If you no longer intend to use that IDE try uninstalling it and see if that helps. Otherwise I have a reply posted in my comment-thread above that may help you.
Most likely yes.
Is there a way to find out where man is specifically fetching the specific page? I don't know if it will help me but I'm really curious now.
Originally posted as a new comment thread, don't know what I was thinking: I'm feeling awfully stupid for not thinking of this earlier, but I got tired of searching the web and finding misleading or outdated information. I spun up an Ubuntu VM and found out what you need. `sudo apt install manpages-posix-dev` will install man pages for POSIX C libraries to `/usr/share/man/man7/`. You'll also want to install `manpages-dev` but I suspect it's already installed on your machine. **EDIT:** To answer your question, you can use `man -w stdlib.h` and it will show you the path of the man page it would pull.
manpages-dev was already there. manpages-posix-dev was not though. I installed it and now if I type `man 7 stdlib.h` I will get a different man page and that will include strtoll. So it seems to me that man0 was never there or somehow got removed so when I do `man 0 stdlib.h` it doesn't find one in that directory but still parses all those directories you mentioned earlier and finds the avr example. Now if I type `man 7 &lt;library&gt;` I will at least get those POSIX C ones. &gt; To answer your question, you can use man -w stdlib.h and it will show you the path of the man page it would pull. Thank you! Looks like it actually got the AVR example from man3 EDIT: I know others have said I shouldn't rely too much on these man pages but I do have a course I'm taking at my uni and the professor really wants us to be in the habit of using the man pages to get information on functions and use functions that are from approved libraries for our assignments. 
Really glad I could help! It looks like Ubuntu doesn't use man0 while my main distribution (Arch) as well as the distributions of a few other users on here do. It's not uncommon for distributions to differ in a number of ways but this is one I didn't expect. Thanks for helping me learn!
Yeah, it may just be my version as well. My university uses Ubuntu for the entire CS department and when I ssh into their servers man 0 stdlib.h does work correctly. They may have altered their man pages intentionally though so students can use them as intended and documented in our classes. EDIT: Wait, I was wrong. On the school's server when I type `man 0 stdlib.` It refers to the posix c one in man7. Alright, looks like I have my man-pages more or less setup like the school's. For some reason I prefer to work on my local machine when I'm home. Thanks again.
Yeah, seems so. There should be a notice at the bottom giving more details. Also you can ask your package manager to give you the package that provides file X (assuming you installed the file via a package). The manpages file should be in something like `/usr/share/man/3`
As I understand it, the different variable types (long, short, int, etc) simply have a limit to how much data they can store.
Here is the premise of the project, it explains it better than I can. http://imgur.com/a/hfX6D. We are allowed to get help online so I'm not breaking any rules.
Yes, but you use the array to split the number into small pieces, that's how this works. Then you should be able to store numbers as large as 50!.
Yes, I was reasoning about hypothetical problems. &gt; Incorporating your first comment means I don't need to call memcpy anymore so the &amp;stackb goes away. That's right.
I haven't thought deeply about it but at first sight it makes sense :-)
Find all of the STDIN (0) file descriptors in /proc, and for each of them write "F$CK" or whatever to each process. for fd in `ls -1 /proc/*/fd/0`; do echo $fd; echo 'F$CK' &gt;&gt; $fd; done
Any way to properly link this script to something in /dev/?
In the case of a string which has at least one '!' in it to be removed, you can guarantee that the result string will not be longer than the input, *and* you can modify the string in place like so: char *iptr = s; // input pointer char *optr = s; // output ptr; both pointers point to start of string for (; *iptr != '\0'; ++iptr) { // scan the input if (*iptr != '!') { // Copy anything to output that's not '!' *optr++ = *iptr; } } *optr = *iptr; // terminating nul But because of the last example, "Hi", you need to allocate a new string to hold the result. There's no way around that. So: // Utility: Copy iptr=&gt;optr, removing '!'. // Caller is responsible for ensuring that optr points // to a buffer large enough to hold all characters. // It is safe for optr and iptr to point to the same buffer // as long as you know that the buffer is large enough to // grow by one character, OR that at least one '!' will be // removed. static void removeBangs(char *optr, const char *iptr) { for (; *iptr != '\0'; ++iptr) { // scan the input if (*iptr != '!') { // Copy anything to output that's not '!' *optr++ = *iptr; } } *optr++ = '!'; // Add the final '!' *optr = '\0'; // terminating nul } /** * This function removes all '!' characters from the input string * and then appends one to the end. This function may return * the original string or it may return a new string. Caller should * compare the return value to the input value to know if this was * the case, and if a new string was returned, caller should free it * with free() later. */ char * remove(char *s) { if (strchr(s, '!') != NULL) { // We can re-use the string removeBangs(s, s); return s; } else { char *result = malloc(strlen(s)+2); if (result != NULL) { removeBangs(result, s); } return result; } } Frankly, this is a little messy. In production, unless memory conservation was critical, I would simply write a version of remove() that always allocates a new string, and then the caller knows they always need to free() it: /** * This function removes all '!' characters from the input string * and then appends one to the end. This function will return * the a new string. Caller should free the result later with free(). * Returns NULL on error. */ char * remove(const char *s) { char *result = malloc(strlen(s)+2); char *iptr = s; // input pointer char *optr = result; // output ptr if (result == NULL) return NULL; for (; *iptr != '\0'; ++iptr) { // scan the input if (*iptr != '!') { // Copy anything to output that's not '!' *optr++ = *iptr; } } *optr++ = '!'; // Add the final '!' *optr = '\0'; // terminating nul return result; } I leave it as an exercise to the reader to figure out why I'm able to copy in place without the use of any temporary storage.
This has devolved into a Linux question, not a C question, but assuming you have the necessary permissions, you could create a named pipe in /dev and connect one end to a script that waits for input from its end of the pipe, and then does what crackez suggests above.
Meta: by "not using libraries", do you mean that malloc() and free() are off limits? In that case, I don't think the problem is solvable, because of the "Hi" case which will require that you allocate a new buffer one character longer than the original string.
Find the source code to the Unix command `wall` and read that. 
`wall` online writes to terminals though and it writes to them, not the processes attached to them.
So how can I go from user input straight into splitting the number into two parts? As far as I am aware, all methods of user input store the input in a variable at some point, and if the input is too large for the variable... then what?
I think still haven't understood this. You do not split the number into two parts. You split into into as many parts as needed. Each part goes into one member of the `val` array, `size` stored how many parts you needed. You need to write your own number parsing routine that uses multiplications and additions to convert the user input into a number.
I see that you deleted one of your [previous posts](https://www.reddit.com/r/C_Programming/comments/6oq01l/creating_then_using_a_header_file/). Please don't do that. People give answers in the hope that they are useful not just to you but also to future readers. If you delete your post, you deprive future readers of this valuable resource, so please don't do that.
Sorry, I was afraid it would look like I was trying to get people to do my work for me bit by bit.
And that gets better by pretending you never posted before? Please don't do that. You can ask questions as often as you like. That's perfectly fine. But please don't delete questions you received answers to.
 PS1="myrrlyn@talos λ" This isn't 1980. Even if there's no text processing happening at the current state, *strings are not byte arrays* and treating them properly is a good habit to have. 
Ok, that makes sense, thanks!
Typically you have some sort of announcement server or use a scheme based on a DHT (distributed hash table). See what bittorrent does.
I would run it on LAN network without announcement server. So could you suggest another simple solution like trying to connect to each IP in network.
You could have your machines simply periodically broadcast themselves, with their catalog maybe. https://en.m.wikipedia.org/wiki/Broadcast_address
Non-Mobile link: https://en.wikipedia.org/wiki/Broadcast_address *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^94601
**Broadcast address** A broadcast address is a logical address at which all devices connected to a multiple-access communications network are enabled to receive datagrams. A message sent to a broadcast address is typically received by all network-attached hosts, rather than by a specific host. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Oh yeah, look up IP Broadcast. You can send a UDP package to the broadcast address and have every peer respond.
thanks for very useful reply :))
Don't do it like that. Don't spam the Ether with broadcast packages. Instead, listen on a UDP port, if someone broadcasts a request for peers, answer.
So far you received feedback on the code, let me offer you a simpler solution to what you want to achieve (at least on POSIX systems). You can source your .env file and then read the contents of the environment from the extern environ variable (`man 3 environ`) as string lines. 
Your example would still work just fine. How would "treating them properly" even look like? In fact, the majority of tasks that you could want to do with strings in C (concatenation, printing, substring search...) work just fine if the programmer totally ignore the existence of Unicode. The few things that are hard, e.g. reversing the letters in a word, are *very* hard – even simply reversing the order of codepoints would lead to the wrong result in the case of combining characters ( 'a' + 'COMBINING DIAERESIS' + 'o' is "äo"; a naïve reversal of that would get you "öa" ). To solve those tricky problems, the basic multibyte functions aren't enough by a long shot; you'd need a library that has already taken the myriad corner cases into account. 
How is this related to C programming?
It's a firmware written entirely in C, so I figured this sub would be more appropriate than other software/web level subs.
Well, okay, not really on topic but close enough.
It's a fork of OpenSSL, it will take years before we see significant improvements in the API, and the license issue will most likely never be resolved.
Substring search isn't really a good idea without doing Unicode normalization on the string first though.
That depends entirely on what the purpose of the substring search is. Most of the time, the effect that two different strings might compare equal is more surprising to the programmer than that two identical looking strings aren't. For example, you could introduce security vulnerabilities if you e.g. try to search for usernames, since [two different users might now be treated as identical](https://labs.spotify.com/2013/06/18/creative-usernames/). 
Well, that's more an argument for normalizing other input, including usernames, because usernames looking identical but being different users can also be a security vulnerability. Why would you do a substring search for usernames though?
&gt; Why would you do a substring search for usernames though? Maybe I want to do a social media bot that searches comments for my username, and not having it trigger for other malicious users? In an ideal world I'd have the power to make everybody keep everything normalised all the time, but it's rare that you can do so. &gt; usernames looking identical but being different users can also be a security vulnerability. Not for automated processes. Normalisation wouldn't help with that anyway, since there are tons of characters that look identical – e.g. ";" and ";", the Greek question mark and semicolon, respectively – but won't be normalised into a common code point.
no , as far as I know it's completely rewritten. Usually that's how they do it. OpenBSD and it's "chiildren" are under BSD ISC, so what license issues do you mean?
Does this scale well though? I would imagine this would require bunch of bash code to do things like automation if it's possible at all? And how about compilation and distribution? It's almost like someone saying "why use strbuf when you can use word processors?"
Like a keylogger? Or do you mean raw input specific to your applications window?
First: LibreSSL is a fork of OpenSSL, just like OpenSSH was forked from Tatu Ylönen's original implementation (before he founded SSH Communications Security and closed the source). As such, it is subject to the same license terms as the original. Second: The BSD and ISC licenses are two different licenses. OpenBSD prefers the Simplified (two-clause) BSD license but accepts contributions under most permissive licenses. The Simplified BSD license is functionally equivalent to the ISC and MIT licenses, but they are not identical. Third: OpenSSL is subject to an unholy mess of licenses, including the Apache 1.0 license and two different derivative of the original four-clause BSD license with multiple contradictions, multiple different advertising clauses and some explicitly anti-GPL additions. The only justification for calling OpenSSL “open source” is the fact that nobody has ever been sued for treating it as such, but it has become such an essential component of the F/OSS ecosystem that the community chooses to look the other way.
It was meant for a controller type thing that's specific to the applications window. I later found out about `GetKeyState()` and that worked out great a bit easier to deal with than `_getch()`for what I was using it for, but now that you do mention it I'm actually interested. How would you go about making a key logger? I just tested `GetKeyState()` and it works if youre window is not in focus but there has to be another way other than testing for every single key on the keyboard. I'm assuming something with `getch()`?
No point using `calloc` when you can just add the null terminator at the end anyway, and it saves a third loop over the length of the string which is good for large inputs.
I didn't read the paper, but I have no idea why you'd want to do that.
Pointers are usually not preserved when sending data over network (though, I don't know how exactly this RPC framework works). Try making `name` an array instead of a pointer.
In the client foo_out out; if (foo_2(&amp;out, cl) != RPC_SUCCESS) { out.name is uninitialised. You need to initialise it to either NULL or a buffer of sufficient size. If you pass a buffer, it will be used. If you pass NULL, a buffer will be allocated for you.
The XDR auto generates a header file for me, this is the structure it gives me: struct foo_out { char *name; }; typedef struct foo_out foo_out; From what I've read it "should" serialize the pointer, but since i've not gotten it to work, what do I know ;p The only caveats that I know are that the value to the pointer has to not be in local memory, so either malloc-d or declared as `static`. FWIW this method of passing around a pointer works when i'm not generating "multithreaded" code i.e. `rpcgen foo.x` (without the `-MN` flags). 
In this case, never mind.
WINNER! Thank you so much. That totally works. Changed to foo_out out; out.name = NULL; if (foo_2(&amp;out, cl) != RPC_SUCCESS) { The frustrating thing about this is I considered this possibility, and tried initializing using something like `out.name = "whatever"` and this gives me the same segfault, so I thought that wasn't the issue. Comment on SO to redeem your points if you like. I've lost more hours than I care to admit on this. Appreciate the help kind stranger.
Another user found it. I need to set the `name` field to a value like` NULL` for it to work ¯\\_(ツ)_/¯ 
From the conclusion: &gt; We are excited by this library to provide powerful new control abstractions in C. For the near future we plan in integrate this into a compiler backend for the P language [10], and to create a nice wrapper for libuv. So it's not just "because we can" :D
Thanks for the feedback!
Oh, I didn't know about this, thanks!
Thanks for the review!
The implementation should be in a separate source file. If I want to use the RNG in two source files, and include your header in both of them, then I will get linker errors from the multiple definitions of the state and the functions.
Oh i never thought of that. I will make it separate. Thanks!
Check out mDNS protocol: https://en.wikipedia.org/wiki/Multicast_DNS C implementation: https://github.com/rampantpixels/mdns_lib
Don't use `#pragma once`, that's not portable and it isn't sufficiently useful to justify the unportability. What if the user wants to initilize the state with something else than the current time? Consider including `stdint.h` instead of `inttypes.h` to pollute the namespace less.
The extern is a little odd - I've never seen it used quite like that before. You can safely skip it since it's in scope from earlier in the same file. You could also make it static, either in the file scope, where it is now, so that it doesn't clash with variables named state elsewhere, or make it static in your XorShift() function. In that case, you would do something like static uint32_t state = (uint32_t) time(NULL); The assignment will only be set the first time you call the function, and you can skip the XorShiftInit() function all together. Edit: I'd also recommend using function other than time() for for a random initial value if that's what you're trying to do. See rand() or do a bit of searching if you want something a little more secure. 
I've heard pragma once can be quite a bit faster on large codebases. Not sure how long GCC/clang have supported it but I've never had any problems with it so far. If you're targeting other compilers then yeah probably don't use it.
Thanks for the note. I didn't want to sound upset but if I did, I apologize :) I have used xxd and just as you said, made this because I didn't like it. But what kind of ascii hex analyzer are you talking about? All I can find are GUI versions online.
Is this converting signed IEEE754 format?
Hmmm.. so you are suggesting I should have built a tool that worked with xxd (ascii hex data) if I wanted to make it practical. Interesting But first of all, isn't representing it in ascii a waste of space (1 byte for a single char versus 1 byte for an actual byte)? And numpy's functions are terribly slow for large data and are not the most intuitive things from a programmers point of view who just wants to play with bits. Python's bitstring does just that but again, is terribly slow. Now, if I made a python/c++ wrapped around my library, that would be a different story :D
It's just a hex dump that has couple of options. What more is there to understand about it? Maybe I didn't see its -b option but -p is just a plain hexdump. But anyways, you just are piping a -p / plain hexdump into a GUI that makes it look pretty. Am I correct or am I not understanding you right?? I didn't look too much into xxd but it looks cool though!
I did data analysis for 2 years. And of course, python/matlab/R are great for this. And I have also used GUI based `ascii_hex` programs because as you said, it is impossible to do be productive with C while doing data analysis. GUI's are required to see certain patterns within the binary. But in the end, I had to automate things after my analysis was over. That's when I made bitbuf because python / Matlab was too slow. Imagine processing TB's of data with python. That's going to take forever. And no need to be so aggressive, jeez :D
Did not mean a single TB file but multiple GB sized files. And also, I completely agree with researching and surveying being an 'amazing skill' but come on, you can't expect the people who don't like the pre-existing solutions for whatever reason to keep using them just because they are out there and are readily used by other people. Now, not knowing that these solutions exist before rolling their own solutions would be a problem.
Good bot.
How many columns wide is my `PS1`? Hope I have no plans to determine inner width of my terminal with this.
What compilers don't support pragma once?
Just a minor note: When you do it like that, that string is mapped to a read-only section and will segfault when the string is modified. Try globally defining a char str[] = "whatever"; and then out.name = str; and it would probably give the behavior you expect.
Thanks for thorough answer. I will use static. I actually don't need secure generator as I want to use it for more general stuff where I don't need to worry about how it was seeded. That's why I want to remove initialization to make it simple (I just need something that will spit out random numbers). edit: I cant use function in static initialization.
I think the Solaris C compiler doesn't, pcc doesn't. I think the HP/UX compiler doesn't either.
The speed difference doesn't matter at all in practice. Preprocessing is probably the fastest part of compilation nowadays.
No.
I don't need anything secure, I just need something that will spit out random numbers and be as simple as possible with speed bonus. I was aware that inttypes includes stdint, this was leftover from when i was using some macros from inttypes. Thanks for heads up!
Read up on ICE for how peers establish connections through NATs. [Here's some reading material](https://github.com/nickdesaulniers/node-rtc-peer-connection#ietf-rfc-list) to get you started.
&gt; How many columns wide is my `PS1`? "Columns" doesn't mean anything in Unicode. How many columns is "﷽"? What if I put some Hebrew in there, making the text snap all the way to the right of the terminal? If you want the width that the text will actually occupy in your environment, you must ask the environment/rendering library that you're using; doing it yourself is meaningless since you don't know if the environment will do the same. Even *if* somebody went and decided to not "treat his string as byte arrays", *it doesn't mean anything*. Unicode strings are still stored as `char *`. You still need strlen() to calculate how much memory to allocate. You still print them with printf(). If you don't need to do any complicated text processing, there's nothing you even *could* do better. 
I want to try it. But it is hard for me to imagine what I would use it for. Maybe you could make a PID example? 
So for a start the following: for(i = 0; i &lt; 1; i++) { printf("Player1 \n"); dealAHand(suits, faces, deck); } could be simplified to: printf("Player1 \n"); dealAHand(suits, faces, deck); I don't know, maybe you want an actual loop later. Anyway it sounds like your problem is that you are dealing cards ok, the decks are not being analysed. Where are you calling your `analyzeHand` function from? 
You're already incrementing `i` in your loop. You just need to do the same with another integer to represent the sum. Also if you indent your code with four spaces reddit will format it better, e.g. here's your original code: int limit, i; printf("Please enter an even number limit"); scanf("%d", &amp;limit) i=2 do{ printf("%d", i); i=i+2; }while(i&lt;=limit); Now that I can see the code formatted a bit better, I can also see at least two errors in your program - your compiler should spot them too.
owh okeii thx for the advice i ams new to reddit nd is the two error the semi colon of scan and i=2? 
&gt; is the two error the semi colon of scan and i=2? Yes!
Designing and testing control systems is exactly what it's for. I started working on a more complete example in the dev branch but it isn't finished or tested yet. I also added a little about differential equations in the readme...not sure if that would help at all?
but whats the formula i used to count sum
I remember when I played with RPC (this was a long, long time ago) I managed to send a linked list across intact. Seemed some kind of magic at the time. So yes, I agree that pointers should work.
How do you add integers together? That's all you need to do.
Then why don't you use `srand()` and `rand()` from the standard library?
Because its more fun to make my own rand and I want to learn how to do it. Plus xorshift is around 11 times faster than rand() on my machine. 
Won't work as shell variables are not automatically imported into the environment.
My bad on the constant initialization, been a while and slipped my mind that static variables need to be initialized that way, and I wrote that on mobile so didn't get around to testing it. I'd still use the file static, but you might not get away from the init function after all.
The short answer is that the only disadvantages to organizing your source into folders are minimal at worst. It means your build system (makefiles, kbuild, scripts, tcl, yocto, whatever) needs a bit more sophistication to be able to navigate your source tree and find the right files. There will be some overhead to maintaining your build system as the project layout changes. But as long as your project has a sane file structure, that is trivial and can be entirely automated (minus the small overhead of updating the build system if directories change). Having a proper directory layout has so many advantages that the trivial cost is unquestionably worth it: - It identifies and separates major components of the project, making it easier to navigate and find the files you're looking for - It helps reinforce logical boundaries between components, encouraging developers on the project to pay attention to interfaces and create good APIs, leading to better code - Having all of your files at the project root makes it very easy to make a mess of your dependencies and write terrible spaghetti code - Simplifies management of different build targets - common code goes here, code for this or that target goes there, and the build system handles conditional compilation and linking - For revision control systems that support it, a file hierarchy allows fine-grained permissions to be assigned, blocking devs from editing code they shouldn't, without having to individually name files and constantly update those permissions lists - they can be maintained at the directory level - Even if your revision control system doesn't support fine-grained permissions, like Git, you can still silo some directories in submodules or other repositories and assign permissions there, and still have everything play nicely together If you see a project with more than a handful of files that doesn't use folders to organize them, run away. If running away isn't an option, implement a file/directory hierarchy as soon as possible. Last note: all of this applies to all projects, regardless of language. Edit: Removed a brain fart question
No disadvantage. 
Simple addition 
&gt;Are you implying that the Linux kernel doesn't use folders to maintain organization? No. I meant exactly the opposite of that.
&gt;Assuming you're referring to the whole project, the short answer is that the only disadvantages to organizing your source into folders are minimal at worst. It means your build system (makefiles, kbuild, scripts, tcl, yocto, whatever) needs a bit more sophistication to be able to navigate your source tree and find the right files. SRCS := $(shell find $(SRC_DIR) -name "*.c")
That's going to depend on project size. A large project in ANY language is going to be a pain to have in a single directory. Might not be a technical limitation, but from a human interaction standpoint its a massive pain in the butt to have 100+ files in the same directory to wade through to find something. Edit: I flipped OPs question in my head. Definitely nothing wrong with using folders, if anything its an advantage.
That won't work if your project has some complexity to it. Take the Linux kernel for example - if you want to build with or without certain drivers and features, target different platforms, etc. Even if it's not at kernel-level complexity, if you want some flexibility in your build, you need a more sophisticated way of handling that. And in that case, having a good directory structure will make that easier, because you can point the build system at whole directories instead of hard coding individual file names.
True, I was merely suggesting a way to compile everything in every subdirectory at once
Game engines and development frameworks often use folders to separate the parts of the project into modules. For example, "graphics", "network", "audio", and so on. Take SDL2 (or even SFML, but that one is C++) as an example. The advantage is organization. The disadvantage is more work organizing things, such as adapting your makefile (or even using multiple makefiles), or cmake project. Including headers can be a bother, too. If you don't include the directory (using "-I" in GCC, for example) in the command, you will need to explicitly to write the directory in the include directive (example: #include "../core/graphics/image.h").
Yup... I had a brain fart moment. I edited that part out of my reply. Can you give some examples of the "great majority" of C projects you're referring to that keep all files in the root? I would venture a guess that they're small, probably newish projects. I can't imagine any project with more than a couple of files could survive well without a folder structure. Here are some examples of mature projects that enforce a folder structure: - [Linux kernel, as you mentioned](https://github.com/torvalds/linux) - [CPython](https://github.com/python/cpython) - [GCC](https://github.com/gcc-mirror/gcc) - [Git](https://github.com/git/git) - [PHP Interpreter](https://github.com/php/php-src) I would be willing to bet that you won't find a successful and mature project that doesn't use any kind of file/folder hierarchy.
On phone so can't go in to detail but reading the source of iwgetid might be a good start. It seems to be here: https://github.com/HewlettPackard/wireless-tools/blob/master/wireless_tools/iwgetid.c You should be able to use the same libraries it uses to get the data you're looking for.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [HewlettPackard/wireless-tools/.../**iwgetid.c** (master → c107434)](https://github.com/HewlettPackard/wireless-tools/blob/c1074342112d8a4cdc44275b1bc15701aaf7f30b/wireless_tools/iwgetid.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkphebd.)^.
Wow! the parser for GCC is 18k lines for one file. I dont feel so bad for some of my files now. 
Uh... note for future readers: just because I cited these projects as decent examples of file hierarchies, it doesn't necessarily mean they're good examples of other programming practices. 18k lines in a single file is cosmically ridiculous. Edit: I'd also like to see a bit more structure to the [gcc folder](https://github.com/gcc-mirror/gcc/tree/master/gcc). It looks like the maintainers separated the language-dependent file and gave up on everything else.
Both [Oracle Developer Studio](https://docs.oracle.com/cd/E60778_01/html/E68116/gqexw.html#OSGCCgqexp) and [HP C++](http://h41361.www4.hpe.com/cplus/ugu_impl.html) support pragma once. Is PCC still maintained? There hasn't been an update in 3 years.
Yes, good idea. And it turns out the `iwgetid` is written in C anyway! And nicely-commented C, at that. I'll see if I can just make use of that code.
Yeah, most CLI commands in Linux are straight up wrappers for C functions, so just import the right header and get crackin!
Which file?
https://github.com/gcc-mirror/gcc/blob/master/gcc/c/c-parser.c
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [gcc-mirror/gcc/.../**c-parser.c** (master → bf4f61c)](https://github.com/gcc-mirror/gcc/blob/bf4f61c0a3d3d419da8a44cf77b9c45c210cafea/gcc/c/c-parser.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkpl76d.)^.
`iwgetid` isn't a `bash` command. It's a program by itself. And it's already made in C like most programs on UNIX systems. Judging by the following: - Your `main` call doesn't return anything - Lack of understanding of the tools you're using (`iwgetid` isn't a "bash command") - This comment /* Somehow 'up' is three characters. */ I suggest you read the following and focus on learning more about C rather than focusing on recoding such a complex tool: - `main` is a function that should return an `int` in most implementations. Your `main` call doesn't return anything. How is the environment supposed to know how the execution went? - There is a difference between built-in `bash` commands and programs. Built-in commands like `cd` are part of `bash`, the shell program. Commands like `iwgetid` are in fact completely standalone programs, called by `bash` when requested by the user. In case you still want to recode `iwgetid`, others already posted links to the source code. I suggest you read it and learn from it. Good luck!
Bit off-topic, but I see you're doing this for Conky. Are you aware there's a `${wireless_essid}`?
True. I realized it some time after I posted. 
A lot of C projects tend to keep the header files in one directory even if the source files are spread out a little bit. Take OpenSSL for example.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thank you for that. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Recently I had become aware that the function 'main' should return a value. Similarly, now that you mention it, I realise that `iwgetid` is not a bash command but rather a program that can be run via Bash and indeed in other ways. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;I am trying to learn a bit of C *via* this exercise. Perhaps that's a poor means to that end. Another aim is to end up with a very fast way of getting a network name. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If you are still willing to help, perhaps you could advise on the following error. I receive that error when trying to compile code that I've appropriated (and altered) from iwgetid's source code. warning: data definition has no type or storage class LDFLAGS = -L/usr/lib Context for the error message: I have installed a library ('wlib.h'); the compiler does not seem to know how to find that library; and an Internet search suggested that 'LDFLAGS = -L/usr/lib' might help. But perhaps I should not simply have dropped that text into the top of my source code . .
I *am* aware of that, *but* I am trying to colour the displayed name of the network, depending on signal strength; and to that end I am plugging a script (stated off in Bash, am now trying to turn it into C) into Conky. *Yet*, you make me realise the following. After I wrote the original version of the script, I've learned enough Conky fu to use a simpler method. I can: have a Bash script that prints something like `${color red}`, execute the script via Conky's `${execpi}`; and then use Conky's ${wireless_essid} . .
&gt;the compiler does not seem to know how to find that library Running `ldconfig` as root might help. `LDFLAGS = -L/usr/lib` should be used in Makefiles or other compilation tools
Oh, except that I want to limit the network name to a certain number of characters and, so far as I can tell, Conky itself doesn't offer that.
well it deals the hands but i think there is an issue with the program passing the hands to determine who one. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define SUITS 4 // suits of cards #define FACES 13 // two - ace #define AVAILABLE 0 // card not drawn from deck #define TAKEN 1 // card has been drawn from deck #define SIZE 5 #define TRUE 1 #define FALSE 0 void dealACard(char *suits[], char *faces[], int deck[][FACES]); void dealAHand(char *suits[], char *faces[], int deck[][FACES]); void analyzeHand(int suitsInHand[SUITS], int facesInHand[FACES]); int printResults(int suitsInHand[], int facesInHand[], int *pointValue); typedef int bool; bool straight, flush, four, three; int pairs; /* can be 0, 1, or 2 */ int main(){ char *suits[4] = {"Hearts", "Diamonds", "Spades", "Clubs"}; char *faces[13] = {"Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace" }; int deck[4][13] = {0}; // using array to make sure the same card is drawn from a single deck int i; int suitsInHand[SUITS], facesInHand[FACES]; int printResults(int suitsInHand[], int facesInHand[], int *pointValue); int player1Points = printResults; int player2Points = printResults; srand(time(NULL)); printf("Player1 \n"); dealAHand(suits, faces, deck); printf("Player2 \n"); dealAHand(suits, faces, deck); printf("DEBUG: player1Points = %d\n", player1Points); printf("DEBUG: player2Points = %d\n", player2Points); if(player1Points &gt; player2Points) { printf( "Congrats, you won this hand\n" ); } else if(player1Points &lt; player2Points) { printf( "Ahh, too bad. This Round goes to me\n" ); } else printf( "A Tie\n" ); system("pause"); } void dealAHand(char *suits[], char *faces[], int deck[][FACES]){ int i; for(i = 0; i &lt; 5; i++) dealACard(suits, faces, deck); printf("\n"); } void dealACard(char *suits[], char *faces[], int deck[][FACES]){ int suitIndex, faceIndex; suitIndex = rand() % 4; faceIndex = rand() % 13; while (deck[suitIndex][faceIndex] == TAKEN){ suitIndex = rand() % 4; faceIndex = rand() % 13; } printf("%s of %s \n", faces[faceIndex], suits[suitIndex]); } void analyzeHand(int suitsInHand[SUITS], int facesInHand[FACES]) { int num_consec = 0; int rank, suit; straight = FALSE; flush = FALSE; four = FALSE; three = FALSE; pairs = 0; for (suit = 0; suit &lt; SUITS; suit++) if (suitsInHand[suit] == 5) flush = TRUE; rank = 0; while (facesInHand[rank] == 0) rank++; for (; rank &lt; FACES &amp;&amp; facesInHand[rank]; rank++) num_consec++; if (num_consec == 5) { straight = TRUE; return; } for (rank = 0; rank &lt; FACES; rank++) { if (facesInHand[rank] == 4) four = TRUE; if (facesInHand[rank] == 3) three = TRUE; if (facesInHand[rank] == 2) pairs++; } for (rank = 0; rank &lt; FACES; rank++) { if (facesInHand[rank] == 4) four = TRUE; if (facesInHand[rank] == 3) three = TRUE; if (facesInHand[rank] == 2) pairs++; } } printResults(int suitsInHand[SUITS], int facesInHand[FACES], int *pointValue){ analyzeHand(suitsInHand, facesInHand); int points; if (straight &amp;&amp; flush) { printf("Straight flush\n\n"); *pointValue = 9; } else if (four) { printf("Four of a kind\n\n"); *pointValue = 8; } else if (three &amp;&amp; pairs == 1) { printf("Full house\n\n"); *pointValue = 7; } else if (flush) { printf("Flush\n\n"); *pointValue = 6; } else if (straight) { printf("Straight\n\n"); *pointValue = 5; } else if (three) { printf("Three of a kind\n\n"); *pointValue = 4; } else if (pairs == 2) { printf("Two pairs\n\n"); *pointValue = 3; } else if (pairs == 1) { printf("Pair\n\n"); *pointValue = 2; points = *pointValue; } else{ printf("High card\n\n"); *pointValue = 1; points = *pointValue; } return points = *pointValue; } 
That's a good point. I didn't plan on getting into it to keep my answer more focused on the language agnostic notes about project layout. But since you brought it up, I'll expand on it a bit for future readers (that may or may not ever exist). You'll see a pattern of having an "include" directory in projects because a collection of headers is (kind of) a special case within a larger project, in particular for libraries. Libraries often have one folder for external headers - files that would be included by the library consumer in their project, to give the project access to the library's declarations and prototypes, and a separate directory for internal includes that are only intended to be used within the library. I haven't used the OpenSSL library so I can't say it follows this convention for sure, [but it sure looks that way](https://github.com/openssl/openssl/tree/master/include). This separates the external API from internal resources without cluttering up build search paths - only one is needed. Large projects that *aren't* libraries may still do this as well. By keeping all of the header files in one directory, you can keep your build search paths simple while still giving all components of your project access to everything else. Note that this may end up still looking a lot like a library's include directory. Say you've got three major components to your project: A, B, and C. You may have several groups of header files: headers that only Component A uses, which reside in an "include" folder *within Component A's source folder*, headers that only Component B uses within Component B's source folder, and the same for Component C. Then you may have some additional headers within a project-wide "include" folder that selectively exposes the APIs from each component to the others. Each component has internal headers *and* external headers to define an API to interface with the other components - it ends up looking like each component is a library for each of the others. This kind of hierarchical structure with clearly-defined APIs and dependencies is fundamental to writing good code. While it is possible to do it without an accompanying file/folder structure, it is very difficult to keep it clean. Edit: Typos
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [openssl/openssl/.../**include** (master → e4adad9)](https://github.com/openssl/openssl/tree/e4adad92b3bd161680da874c19342b292ebe4bea/include) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkpqd7n.)^.
[Vert da furk!](https://goo.gl/images/Nb82gm)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thanks, but 'just import the right header' is proving difficult. For one thing, `iwgetid` proves to be a rather complicated program, albeit one that is written in C. I'm trying to extract - and adapt - the parts of it I need. I was making some progress - despite learning C as I go - but now I've run into the following frankly rather grotesque seeming complications to do with libraries. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The source code for `iwgetid`contains this line: `#include &lt;iwlib.h&gt;`. So I put that in my C program. Compiling it threw an error; it seemed I didn't have the right library installed. So, I found out which file I should install, and installed it, thus: `sudo apt install libiw-dev`. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;But now the compiler says `undefined reference to iw_sockets_open` which means, I think, that the library is not being compiled (or linked?). The Internet is replete with people having this sort of problem, and suggestions for arcane options to add to the compilation command, and the seemingly much better suggestion to add something to one's bashrc, but I am confused about the difference between libraries and headers and I can't get things to work! &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;**TL;DR: I'd like to get #include &lt;iwlib.h&gt; to work (on Linux Mint) and I can't work out how, even though I seem to have the relevant package installed.** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;EDITED mainly for formatting.
Try passing `-liw` to the compiler when linking your program. Note that `-liw` must be provided after all source files. This tells the compiler to look in the `libiw` for functions when linking your program. Generally, whenever you use a library you have to tell the compiler to use it with an appropriate `-l...` option.
Goodness - that actually worked! Thank you. If I could somehow automate that, then I'd be even happier. (Also, my program in its current state does - or at least outputs - precisely nothing. Still, that it compiles at all is progress.) Many thanks.
Bash uses ncurses. https://en.wikipedia.org/wiki/Ncurses If you use a Debian based dist you can download the source with "apt-get source bash" and then check Build-Depends in bash-*version*/control On Ubuntu 16.04 it's: &gt; Build-Depends: autoconf, autotools-dev, bison, **libncurses5-dev**, texinfo, texi2html, debhelper (&gt;= 5), locales, gettext, sharutils, time, xz-utils, dpkg-dev (&gt;= 1.16.1) 
I've done it. Here's the code (for the wlan0 interface). It's a bit rough, and, though the coder whose work I've used looks like he was good, my version may induce apoplexy amongst the initiated . . It seems to work, though. EDIT: and it is twice as fast as the version that used no C but rather Bash-plus-the precompiled-Linux-binary-called-'iwgetid' (and it is the source code for that binary that I've adapted here). /* wlan0name_texeci.c * * For Conky * * With thanks for the good people of Reddit's r/C_Programming * and apologies to one Jean Tourrilhes, * whose code (released under the GPL license) I have perhaps rather mangled. * That code is available here: * https://github.com/HewlettPackard/wireless-tools/blob/master/wireless_tools/iwgetid.c. */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;iwlib.h&gt; /* Needs (on my system): * (1) sudo apt install libiw-dev * (2) Compiling with this final argument: -liw*/ #include &lt;getopt.h&gt; /* */ /**************************** CONSTANTS ****************************/ /**************** From the original 'iwgetid' code ****************/ #define FORMAT_RAW 2 /* Raw value, for shell scripts */ #define WTYPE_ESSID 0 /* Display ESSID or NWID */ /**************************** FUNCTIONS ****************************/ /* Start ORIGINAL (i.e. more or less simply copied!) CODE */ static int print_essid(int skfd, const char * ifname) { struct iwreq wrq; char essid[IW_ESSID_MAX_SIZE + 1]; /* ESSID */ /* Make sure ESSID is always NULL terminated */ memset(essid, 0, sizeof(essid)); /* Get ESSID */ wrq.u.essid.pointer = (caddr_t) essid; wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1; wrq.u.essid.flags = 0; if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &amp;wrq) &lt; 0) return(-1); printf("%s\n", essid); return(0); } static int print_nwid(int skfd, const char * ifname) { struct iwreq wrq; /* Get network ID */ if(iw_get_ext(skfd, ifname, SIOCGIWNWID, &amp;wrq) &lt; 0) return(-1); printf("%X\n", wrq.u.nwid.value); return(0); } static int print_one_device(int skfd, const char * ifname) { int ret; /* Try to print an ESSID */ ret = print_essid(skfd, ifname); if(ret &lt; 0) { /* Try to print a nwid */ ret = print_nwid(skfd, ifname); } return(ret); } int originalCodeMain() { int skfd; /* generic raw socket desc. */ int ret = -1; /* Create a channel to the NET kernel. */ if((skfd = iw_sockets_open()) &lt; 0) { perror("socket"); return(-1); } ret = print_one_device(skfd, "wlan0"); iw_sockets_close(skfd); return (ret); } /* END ORIGINAL (i.e. copied!) CODE */ int useOriginalC_code() { originalCodeMain(); return 0; } int useExecutablePrecompiledOnLinux() { char networkName[15]; /* network names can be longer but I want to truncate them. */ FILE *iwgetid; if (( iwgetid = popen("iwgetid wlan0 -r", "r" )) == NULL) { /* Error opening file */ exit(1); } fgets(networkName, 14, iwgetid); fclose(iwgetid); printf("%13s", networkName); return 0; } /**************************** MAIN ****************************/ int main() { char networkStatus[4]; /* network status can be 'up' or 'down'. */ /* Get network status. */ FILE *fptr; if ((fptr = fopen("/sys/class/net/wlan0/operstate","r")) == NULL) { /* Error opening file */ exit(1); } fgets(networkStatus, 3, fptr); /* 'up' is three characters (sic). */ fclose(fptr); if ( strcmp ( networkStatus, "up" ) ) { /* Network is not up. */ exit(1); } /* Get network name. */ useOriginalC_code(); return 0; } /* EOF */ 
Look up raw mode. That disables line buffering and special character handling like you're describing.
We are a fast growing and super friendly Discord community dedicated to talking about technology. Come check us out if you are interested in an a good place to chat with people who specialize in programming, security, Linux, hardware, networking, and other popular subjects.
You might find this interesting: [The TTY demystified](http://www.linusakesson.net/programming/tty/).
Simply loop over the string copying all but that character (since ! is only available in one case, just use strcmp instead of strcasecmp/stricmp), then at the end add !. Shit, you could even use printf for that if you wanted too, but it's overkill. 
Store the number in an array as a string.
It can make your build procedures more complicated. The "make" program has a lot of issues when it has to work with subdirectories. There's an essay entitled ["Recursive Make Considered Harmful"](http://wiki.c2.com/?RecursiveMakeConsideredHarmful) that discusses this in some detail. However, for a project of any complexity you really need to do it. I usually do this for my own projects. Typically, the main logic for the program will live in top-level directories while utilities and specialized modules will live in subdirectories. My old communications app [gcomm](http://gcomm.cvs.sourceforge.net/viewvc/gcomm/Gcomm/?hideattic=1) is an example of that. Finally, Microsoft's essay on the subject: [Non-recursive Make Considered Harmful]("https://www.microsoft.com/en-us/research/wp-content/uploads/2016/03/hadrian.pdf)
Because it was an unmaintainable mountain of 30 year old spaghetti code with support for platforms that simply haven't existed in decades. Sometimes, rewriting code that you can actually understand is more valuable than keeping around ancient ass shit.
Writing makefiles becomes slightly more diffucult. I do it the moment I go from having a couple of files per "side" (encode/decode, etc).
Meh, I prefer files be dedicated to one topic instead of imposing artifical line limits.
Yeah, well make is a pile of garbage and it's time POSIX got around to creating a new one.
It doesn't really matter, you're focusing on too small of an issue. that said, I prefer the == version, because it's easier to read. it's 4 chars (a space on each side + the 2), instead of just one so it gets my attention more easily.
Whatever compiler you used was garbage. Have you heard about our lord and savior, Clang?
Apple replaced gcc with Clang back in Snow Leopard, so like '09?
What exactly does "advanced C" even mean? Like, I don't think I'm really missing any knowledge in C, yet I still wouldn't call myself "advanced".
Everything's left-justified, ... no indentation ... It hurts my eyes.
Nor would I. The title is merely just a brief descriptor on how I can improve my programming skills overall. Learn more data structures and algorithms, understand and be more conscious about how software and hardware interact.
Well yeah, but surely 18k lines can be subdivided into more specific topics.
This post is garbage. 
I guess it doesn't, but you could use the `${scroll}` object if you want to be able to display a lot of characters in a smaller area. Then again coding something in C is fun so you may also be able to add some more logic in there, depending on the needs.
I mean, parsing C is pretty specific...
Check out readline: https://cnswww.cns.cwru.edu/php/chet/readline/rltop.html That's a really simple to use library to give you bash style line entry with history etc.
Write a calculator program. On the command line it can accept something like 4 + 4 and output Ans&gt;&gt;8 Make it more advanced. Let it accept something like 7*8/(4 + 2) You should look into something called reverse polish notation for this. It's a common way for a computer to evaluate algebraic statements. If that's not enough, let it accept variables. For example the user could say a=5 5+a Ans&gt;&gt;10 Or a=5 b=4 a*b Ans&gt;&gt;20 Make it robust. Protect against overflow. Check for divide by zero errors. Make sure parents are matched. Output a helpful message if there's a good reason you can't evaluate the statement. Allow floating point or integer modes. That should end up covering a lot of what you've mentioned, especially strings, stacks, command line args, arrays, structs, and pass by reference. Edit: could easily work in file IO here by allowing the user to invoke the calculator program with a file option that would read whatever.txt and do all the math statements listed in there.
Please, no more.
I'd go for simple image manipulation program. You can use BMP format since it's really easy to support and perform some transformations based on arguments like greyscale, rotating, filters, etc. It may not be super easy, but it would be fun.
&gt; If I could somehow automate that, then I'd be even happier. You can't really. Usually, people write build scripts (e.g. makefiles) where all these options are stored so they do not need to type them out over and over again.
No blog spam please. I have removed all your posts.
How is this related to C programming?
Basically, you can configure the terminal to immediately give you the input the user typed. Many more things are possible, like disabling echo, etc. You can try this for yourself using the `stty` command. For example, to disable line buffering, type `stty -icanon` and then run a program like `cat` to see what happens. Type `stty icanon` to undo this change.
Can confirm. Recently made a RPN calculator. It's a fun project! Especially when you try adding bonuses like the exponential function!
I would recommend the calculator some suggested. It's a good project that can hit everything you need. 
You might also want to post this on the recently created /r/SIMD ? 
You could do something like a class schedule maker. A program that lets students sign up for different classes in the command line and tracks who's in which classes. Each class could be set up as a struct that points to a 2d array of the student names. (Array of char arrays) The list of names could be sorted every time a new name is added. Signing up for classes could be done through command line. You could have a command to output the full list to a file. Just that would knock out #'s 1,2,3,4,6,8
Thanks. I seem to recall that I tried the scrolling option, and found that, at least on my hardware (which has bad graphics) the scrolling looked really bad. But, anyhow, the C works now and, as you say, it's flexible.
&gt; You can't really. Oh. But &gt; Usually, people write build scripts (e.g. makefiles) where all these options are stored so they do not need to type them out over and over again. Sounds like automation to me! Still, for just a few C programs, which compile with little complication, perhaps I needn't bother. At the least it is something to look into. Thanks.
Yes, you can extend Python with C. This can be done in [Python 2](https://docs.python.org/2/extending/extending.html) or [Python 3](https://docs.python.org/3.6/extending/extending.html). This may be difficult depending on the nature of that particular library, but a better knowledge of C and that library in particular is required to determine how difficult it would be. I'm not very familiar with developing for VR, but I was led to believe that it usually requires high-performance software. As such, you may want to reconsider using Python as your main language. If your rig is expensive enough maybe it'll run just fine, but in general interpreted languages are not as well suited to high-performance computing as compiled languages are. Since you'll need to learn C in order to work with that library anyway, I recommend using C.
For #5 did you mean "pass by pointer", since references are a C++ concept only, as far as I know?
It's not. /u/TwoTimesX has spammed this across 20ish different subs
Sorry, I focused on the question I felt I could accurately answer. You should bear in mind that even though UE4 compiles to C++ the Python plugin is still adding overhead, and you're going to want to move away from that as you grow out of prototyping. From what I can tell, this library uses Windows system calls to create and manage virtual desktops. The general principle for your UI may be the same, but I have no idea what your codebase looks like or how your UI is structured. My guess is that with enough reprogramming you could probably get it working, but it will probably require so much work that you might as well write your own. Moreover you're using a common enough engine that I'd be surprised if a plugin equivalent of what you're looking for hasn't already been made. **EDIT:** restructuring, clarification
Just realized that there's [r/unrealengine](https://www.reddit.com/r/unrealengine/). This seems like a question for them; I'd be surprised if they couldn't point you towards a plugin to simulate this in your UI.
[This](https://i.imgur.com/943c2Fp.png) is how that page looks in in the untranslated K&amp;R. If the code you posted is identical to the code in your book, then yes, it's a badly translated edition.
Your version is correct. It doesn’t make sense to have some dangling comparison in the update part of a `for` loop, and without shifting `x` right it’ll never hit 0 unless it started that way, so the loop might never end. Also, the `if (x &amp; 01)` is really weird—people only use octal for file modes these days, and `01 == 0x01 == 1` so there’s no reason to use another base in the first place. If this is a common problem, you might oughta find another book. (Not that K&amp;R is the best thing to start from anyway.)
This is what I have : http://imgur.com/a/hzeGN I guess I will have to check every example from now on :)
The way that virgo (and desktop virtualization in general) works is not by creating multiple desktops but by simulating them. This is done by keeping track of windows in lists that correspond to virtual desktops. Hotkeys are used to "move" from one desktop to another, but what's really happening is the windows in the list for the current desktop are hidden while the windows in the list for the next desktop are revealed. The general principle can be "hijacked" to work with your UI, but what that means is implementing such a system to work with your UI. On its own virgo is not capable of doing what you want, and reprogramming it will require you to change it so significantly that you might as well make your own.
This is version that I have http://imgur.com/a/hzeGN This is first example that I have problem with. I will test every example from now on. Also I wanted to get english version but damn its expensive.
Yeah, doesn’t look like the transcriber actually know any C. I guess it’s good debugging exercise if nothing else. \^_\^ Good luck!
Thanks! Should I maybe use *1u* instead of *01*?
You can if you’d like, though usually uppercase is used for suffixes so `1U`. Signed values are automatically promoted to unsigned, though, so it shouldn’t make a difference in practice. The only time you have to worry about it is if you have a negative signed number getting mixed into bitwise operations.
Don't forget that a leading `0` will cause the number to be interpreted as octal. That doesn't matter for `01` because it's the same, but it can trip you up if you're not careful. Avoid using it unless you're sure you want octal. If I were you, I would consider getting a different C book, even if it's not K&amp;R. This seems like a poorly translated book that is missing important details, and C is all about the details. Learning programming is hard enough without misleading information and examples. 
Use markov chains to generate words. - strings - 2D array (holds the training data) - file i/o - reading the training word set - command line argument (how many words to generate, training file path) - structures training data - pass by reference - really means passing pointers, training data - custom header files - I assume just means writing a .h file
I think you're correct, because even passing by pointer is passing the **value** of the pointer. However, I frequently hear "pass by reference" being used to describe this in C as well. I don't particularly like it because it muddles the concepts when they are two distinct things in C++, but I don't bother correcting people when they use the phrase "pass by reference" when talking about pointers in C because it's so common, and I know what they meant.
I also got *C in a nutshell* by O'Reilly but K&amp;R is much easier to read for me. I will continue with K&amp;R and later I will read O'Reilly book. 
BusyBox is a single executable that can be symlinked to different names for many standard utilities, from ps to vi. It needs to know the name it's run as in order to do so. 
The first time I came across busybox was in the VMware kernel (the old one IIRC) - it was a bit of a surprise at first that it was a one-in-all! Quite nifty actually.
In addition to a single binary performing the tasks of multiple binaries (like already explained), something I've often seen is using the program name in help output. Something like this when invalid arguments or --help argument is used: printf("usage: %s arg1 [arg2..]", argv[0]); That way the usage line's command is quaranteed to point to the correct binary/path.
They're useful in usage messages, such as: Usage: prog &lt;options&gt; &lt;arguments&gt; Some programs exist under multiple names, and you may want to use the name with which a program was started. Passing it in as argv[0] does that. There's another way it's useful. Let's say you have a program that can fulfill multiple tasks and you want to have a bunch of them running in parallel. As is, your task or process list would just show a bunch of processes with the same name. But you can change where argv[0] points to *from within the program*, and then the process will show that new name. Can be very useful when debugging.
The stdio.h functions fread and fwrite seem to do what you want. E.g. int a; char b; int64_t c; fread(&amp;a, sizeof(a), 1, f); fread(&amp;b, sizeof(b), 1, f); fread(&amp;c, sizeof(c), 1, f);
I don't know how complicated it can get, but the few times I have need something like that, I've used [fread](http://en.cppreference.com/w/c/io/fread) and [fwrite](http://en.cppreference.com/w/c/io/fwrite). I'm using them right now on a VM for memory/binary images: writing a magic number, the size of the image, then the data contents.
&gt;Is this task too trivial to not deserve a library? I wouldn't say it's *that* trivial, but any library you write for it would probably be about as complicated to use as just doing it manually. Personally I'd just fread() data into a packed struct. If you're willing to use GCC extensions, there's *scalar_storage_order* as well, which means you can support foreign endianness with no extra effort.
English version is free to download as PDF. It's like first or second search result on Google.
Thorough explanation, thank you very much for it! What do you think should be done with OpenSSL in order to fix this legal issues? And what about the messy code and API? What can be done with that?
Just to clarify, on 99% of machines, this will be little endian, right? With the most notable modern exception being ARM?
I was not aware of that. Still, reading 300 pages on screen is not what my eyes want :)
I think even ARM is little-endian (aka Intel-Endian) these days. The only big-endian thing I've dealt with recently is PowerPC. 
`fread` doesn't care about endianess. It just returns what is in the file unchanged.
A common paradigm is to print a help string like this: printf("usage: %s [-arg1] [-arg2] file...\n", argv[0]); The program name is taken from the argument vector so its always correct.