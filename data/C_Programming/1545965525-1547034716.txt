Are you sure about the jobs in embedded not increasing in demand? I thought the embedded systems field was actually growing a ton due to the rise in popularity of IoT devices
or a uint64_ and then crop it of the system is a 32-bit arch.
He probably could be in high demand if he wanted to be, but it sounds like he's looking for something very specific which makes the pickings a lot slimmer.
I gave it a really quick glance and saw "yy". Are you using Yacc and Flex as the Lexer/Parser? I know Im lazy.
Structures and Callback functions. Sometimes structures with function pointers to different callbacks. There are a variety of GUI systems still "in the wild" that use C as their primary language. GTK+ and win32 are probably the best known still widely used. My experience maintaining legacy systems in the early 00's is that you could replace "object" with "module" and it worked out to be about the same. People would group the functions that implemented a widget/form/whatever into a single .c file, with a "constructor" to instantiate a widget (usually a struct with state information). Almost every GUI system I've used OO or not relies on callbacks and function pointers.
If you have a add_library() call, CMake creates a library If you want to logically separate code but only create one executable, you can use target_add_sources() to add sources to a single executable If you’re compiling someone else’s code, look to see how they call add_library(). If they specify add_library(libname SHARED/STATIC/etc ...) then there’s a library created (shared or static, seems like you don’t want either). Instead put OBJECT - this means there is no library, only object files compiled, so linking everything should be done at once Hope this helps
Seriously, proper "constructive critique" in programming is something like a "pull request". Unless you asked for it, anything less is most likely from people who don't want to/can't pull their own weight. "Constructive critique" doesn't have any personal creed associated with it. &amp;#x200B; If you don't have his company email address, then he is not making a "constructive critique", but indirect request with a ambiguous promise. He is either leading you on, trying to make you do X which he himself is tasked to, jealous, wants to put you down for some reason, waste your time or something else. I don't know. If you don't have his company email address, then don't bother. He might steal your work and put his name on it without you ever knowing. &amp;#x200B; If you do however, have his company email address, then it is obviously very different and keep what is between the two of you private.. I do doubt he gave it to you though, which is why I'm making a rant. &amp;#x200B; It is never a good idea to buy into a public apeal to authority here on reddit... You only have their word here on reddit that they are so and so. Wouldn't someone who has a real insterest in you at least be aware enough to send you a private message? A private message where they can raise their marginal and \_local\_ concerns over discrepancies they hope can be worked out with you? Think about it. People pretend all the time here on reddit to social engineer other people. Some pretend to be someone they hate to lower their reputation, catfish other people, e.t.c. Your time is not a free resource. He can buy your time if he really needs something specific. &amp;#x200B; That aside, use your time networking or doing what \_you\_ want to do until someone \_pays\_ you to do otherwise. It is not only programmers you can make friends with, you can also make friends with electricians/mechanics and make industrial stuff or robots. (Many electricians tend see programmers as snop who don't want to get down and dirty and only aim to take their fancy PLC's jobs, so be aware of this when you talk to them, it can take time.) It can be fun if you find the right people.
Keep the dream alive man. Sometimes its better to forge on alone until someone else who appreciates your talent gets involved. Even if you become a truck driver you're obviously a gifted coder. The world needs people who are passionate about these things to devote their spare time to them, whether other people appreciate it or not. Good luck.
Hmm well I am not explicitly calling `add_library()`. I am calling `add_executable()`, and cmake appears to be automatically creating an object file along the way.
I don't think any build system has a way to specifically run something like ```gcc source.c -o a.out```, because the purpose of a build system is to speed up compilation I'm not sure why you cannot create relocatable object files (.o files), that's normally what you want to do. If you want to / are able, you can post the code so I can take a look at it, because I don't think the .o files are the issue if you're getting errors at compile-time
CS50 on edX is what I've heard most people recommend before anything else.
Tell your university she's drunk and needs to go home.
I didn’t really understand. What do you mean by “All at the same time” And the reason for the temporary arrays is because I want each thread to return an array. Should I be copying all of the returned arrays into one big one and then merging? Or merge 2 by 2? 
That’s just a separation between the functions. 
 \*\*and produce proprietary object files and a.out-style executables\*\* &amp;#x200B; Can it not produce free executables?
How about the requirement that types with identical representations be regarded as incompatible or the horrible and nonsensical notion of "Effective Type" which has become an excuse for compilers to throw the Spirit of C "Do not prevent programmers from doing what needs to be done" out the window. There is no "mechanism"-based reason why it should not be possible to write a function that can silently accept (and coerce) a pointer to any 16-bit two's-complement non-padded little-endian signed integer type, but have it squawk when passed a pointer to anything else, but that and `const` can be dealt with through the use of typecasts without losing anything other than conciseness and the possibility of the compiler being able to usefully diagnose some programming mistakes. The "Effective Type" notion, however, stems from a botched rationalization for the answer to DR#028. The "dilemma" introduced in DR#028 should have been resolved by observing that there is no *general* permission given to access a structure or union object with an arbitrary lvalue of member type, but that quality compilers will recognize that the derivation of an lvalue from a struct or union object and subsequent use thereof is an access to the original (and thus does not alias it, but would be allowed to alias any objects the original could), and will further recognize that an object does not alias anything else during the execution of any function or loop where it is neither accessed nor addressed. Instead, the authors said that because writing one union member and reading another is Implementation-Defined Behavior, the act of doing so via pointers invokes Undefined Behavior--a horribly nonsensical rationale given that: 1. Some cases of writing one member and reading another have Standard-defined behavior, 2. The fact that writing one member and reading another invokes Implementation-Defined Behavior would suggest that using pointers to do likewise should also be Implementation-Defined Behavior. 3. If the "definedness" of the example in DR#028 were dependent upon the behavior of writing one struct member and reading another, that would suggest that compilers would be required to allow for the possibility of aliasing given a function like: void test(int *p1, float *p2, int mode) { *p1 = 1; *p2 = 1.0f; if (mode) *p1 = 1; } even though such allowance would significantly impede optimization [without such allowance, a compiler could omit the conditional test along with either the first or second write to `p1`]. If one instead the authors of DR#028 had recognized that there's no *general* permission to access unions via pointers of member types except in cases that don't involve aliasing between the parent and the resulting pointer, that would have eliminated the need for the Effective Type nonsense and the resulting requirement that compilers include the complexity necessary to handle #3 above. 
I have just edited my code. it does work, although I feel here is a better way then copying each array into a total array and then merging parts of that total array. anyone have any ideas. is there possibly a function in c that can concatenate integer arrays?
sorry, it does work now I edited the code. although I wanted to know if there was a better way of doing this.
A good standard for a language should make it possible to produce a bunch of files which, if given to any conforming implementation, will produce one of three results: 1. The implementation will eventually process the code in a fashion consistent with the intended semantics. 2. The implementation will eventually indicate via some documented means a refusal to process the code or continue processing it. 3. The implementation will spend forever long without doing either. Not all C programs are going to be meaningful for all implementations, and it wouldn't be practical for the Standard to specify everything that would be needed to run 100% of all embedded projects, but it should be both useful and practical for the Standard to specify everything necessary to handle a majority of embedded projects with the above semantics, without requiring the use of non-standard concepts like linker scripts. Since the present Standard fails to achieve the above semantics with even 0.0001% of freestanding programs, having it define the behavior of 50% would in a very real sense make it infinitely more useful. 
agree, the book is great
Rewrite in C++? That's blasphemy 
You might want to look at an immediate mode UI example to see an alternative way of doing things, though the most popular imgui library is written in C++.
Storage class specifiers generally affect the scope of an identifier, with the exceptions of `_Thread_local`, which seems a bit of an oddball, and `register`, which feels to me like it should be a qualifier that would waive the guarantee that an object behave as though it has a constant address outside the immediate contexts where its address is taken, so that something like: void fetch_integer(int register *dest); register int foo; ... fetch_integer(&amp;foo); foo++; other_function(23); foo++; other_function(foo); would be legal, but a compiler could at its leisure process it as: register int foo; ... int __temp = foo; fetch_integer(&amp;temp); foo = __temp; other_function(23); other_function(foo+2); Having argument qualifier to indicate that a function would only write to the pointer (thus eliminating the need to initialize `__temp` would allow even better optimizations, but the key point in any case would be that a compiler would not need to allow for the possibility that `other_function` might access `foo`, and would thus be able to consolidate operations like the two increments without having to update the value in memory on every function call.
YOU ARE A CODING GOD, YOU ARE A GENIUS HOW I DIDN'T THINK ABOUT THIS, OMG! I LOVE YOU, MAN!!! THANK YOU!!! I GOT THE HAPPIEST HOLIDAYS IN EVER! HAPPY HOLYDAYS!!! THANK YOU!!!
This is real neat. Does it do standard compiler optimizations like range based register allocation?
Probably not due to the k&amp;r format required
In the gender scanf() the second argument should be `&amp;gender`, not just `gender`; with the code left as it is the input value isn't assigned to your variable. Because of this working improperly, the `if` statement after it doesn't execute, since the aforementioned variable has no value assigned (and that probably causes an error).
I bet you have some mean BBQ!
It would have to be a very dumb compiler with negative optimisations. even down to the asssembly level its hard to avoid short circuiting A&amp;&amp;B equiv: TEST A Zero? JMP endif TEST B Zero? JMP endif ...if block... ENDIF: A||B equiv: TEST A Nonzero? JMP if TEST B Zero? JMP endif IF: ...if block... ENDIF:
I'm not going to bother sifting through the standard to find the actual "proof," but this is such a core semantic in the language, unless you're using a very, very esoteric compiler, you should always have short circuiting.
The register allocator assigns variables to registers at the basic block level, and then attempts to maintain the same register assignments across basic blocks. It uses some basic DEF/USE data to aid in spilling decisions. This is a bit ad-hoc but it probably approximates something between graph coloring and linear scan. As an aside, the allocator is also responsible for synchronizing register contents with memory when the memory is potentially aliased. Very little alias analysis is done: global variables are all assumed to be aliased, and all local variables whose addresses aren't taken and not declared explicitly *auto* are assumed to not be aliased. Any accesses to/from memory that aren't spills are assumed to access potentially-aliased variables. In both of these areas, there are definitely improvements to be made.
Does this dialect of C support functions with variable arguments? Good luck finding a job. I'm in a similar situation as you -- don't want to do Java/C#/etc. but unfortunately there's very few systems programming jobs available in my town. I hope you do find something; I'm sure there's something available remotely. I seriously hope you don't go the CDL route!
Yes, it will always evaluate like that. see chapter 6.5.13 and 6.5.14 in ISO/IEC 9899:1999 (C99) [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf) 
Perhaps that's just poor wording on my part. The format of the .o and a.out files is idiosyncratic, but it's not, like, intellectual property.
Yes, it does. C has pretty much always had variadic functions, though there was a sort of gentleman's agreement not to discuss them. ANSI made such things legitimate, introducing the '...' syntax and standardizing the va_*() macros.
Sadly, if `operator&amp;&amp;(...)` is overloaded, it might not short-circuit. https://ideone.com/dBberr
I totally agree with you! I am asking because I want to hear what people are using and why do they recommend that stuff to others. Maybe someone will recommend some software that is really good or just fits my needs. I dont ask because I want to be trendy cuz everyone is doing it or what will they think about me if I don use what they are using. So thanks to this answers that this wonderful community gave me, it gave me some really nice information.
That is correct but the if should fail on the equals 'm' check meaning it should print "m'lady". One reason it might not be printing anything might be due to the fact the printf calls in the gender conditions do not have a new line on them and the output buffer isn't getting flushed before the application exits so you may be losing that output.
Yes, it is required in the language spec that &amp;&amp; and || short circuit. You can safely do things like: int* some_ptr = ...; // maybe NULL ... if (some_ptr &amp;&amp; (*some_ptr &gt; 100)) { ... 
Now that's pretty neat! 
Maybe "standard object files" is more clear.
You can post the code.
Try to compile that trash and you will see : "/tmp/barf_code.c", line 39: Warning: Likely uninitialized read (variable gender): main Sort of a hint. Did you glance at the man page to scanf(3C) ? ... function reads bytes, interprets them according to a format, and stores the results in its arguments. Each expects, as arguments, a control string format described below, and a set of pointer arguments indicating where the converted input should be stored. The result is undefined if there are insufficient arguments for the format. If the for- mat is exhausted while arguments remain, the excess argu- ments are evaluated but are otherwise ignored. Please note that the scanf function won't consume the 0x0a carriage return. See Why does everyone say not to use scanf? What should I use instead? http://c-faq.com/stdio/scanfprobs.html 
You'll have to give more than that, code snippets would be great. What is each array item's type? Are you allocating statically, on the stack, or dynamically? Failing around 300k sounds like possible stack overflow.
look, just tell me the changes I have to make in the program
I am allocating statically, well the code it's actually pretty big that why i didnt post. Can I allocate memory with malloc?
IO errors are persistent with stderr, that is, if an IO error happens, all further IO fails until it is cleared. Thus, you can generally treat an IO error like an end of file and break out of your reading loop. Afterwards, check if you finished reading due to IO error with `ferror()` and you can distinguish both cases easily. If you want to check this immediately, nothing stops you from going like this: c = getc(f); if (ferror(f)) { /* IO error */ } else if (feof(f)) { /* end of file */ } but that looks rather tedious.
I suppose I shouldn't try to speak for the entire industry, but in my experience over the past 15 years, web development is slowly becoming less about developing your own custom solutions and more about installing plugins, pre-made templates, and third party solutions. Most of the popular web frameworks are more about clicking buttons to setup the website than they are about writing code. Web development is basically becoming plug and play, which is good for some people, but bad for developers who want to be creative, and who prefer optimized custom code over generic third party solutions.
As others have mentioned, yes `&amp;&amp;` and `||` are guaranteed by spec to short circuit, but as an interesting aside, the reason that there isn't a logical xor (`^^`) is that it *can't* short circuit. 
logical xor: one or the other but not both. should be able to ? `A^^B == (A&amp;&amp;!B)||(B&amp;&amp;!A)` no?
How would you only check one of the results?
yes, do that. it will also work as a "static". the stack, where the variable is now, has a limited size.
xor need 2 operands, self-xor is always 00/false
Are you on unix? Depending on your shell, you can *unlimit* or *ulimit* system imposed limits on stack, data...
You still need to know both operands. A || B If A is true, then A || B is also true no matter what B is. Therefore B doesn't need to be evaluated. A &amp;&amp; B If A is false, then A &amp;&amp; B is false no matter what B is. Therefore B doesn't need to be evaluated. A ^^ B If A is true, then we need to know what B is to know the result of the whole expression. This is also the case if A is false. Therefore, xor cannot short-circuit.
Yes i understand all that. I misread the OP in saying there couldn't be a logical xor at all
I use Ubuntu,any info on thag?
I laughed way harder than I should at this.
To me it's generally bad, professional developers should be experts in their field, they should build efficient websites, softwares and systems. This popular trend of trying to make it easier for the developer to build anything is bad because it's pushed too far. They have to stop acting like they're special snowflakes and should have respect for the users/clients. I want to build things to bring ease and satisfaction to the users with the most comfortable setup and tools, but if I need to get dirty and think hard, I'll do it, it's part of your job. Anyway... it's kinda unrelated but too tempting to rant...
As an important side note: The same is _not_ true in C++; whereas the original operators on built-in types do short-circuit, custom implementations do not have to, IIRC. 
Assuming bash, [https://ss64.com/bash/ulimit.html](https://ss64.com/bash/ulimit.html)
sauce https://github.com/mcandre/tonixxx/tree/issue-115/examples/fewer
When you write ```gcc file.c```, gcc does a few things: * calls the preprocessor (gcc -E) * calls the compiler (gcc -S) * calls the assembler (gcc -c) * calls the linker (ld) Whether or not a .o file is created in your build directory has nothing to do with the actual process of creating a c program, as calling ```gcc file.c``` does create one, but only temporarily 
Its actually more than 100 lines.. so I don't know if I cant post this. 
&gt; (contrary to popular belief, it is of no value in optimization) It's of *little* value to optimization, but it's not of *no* value. flatfinger pointed out that `const` on global data allows it to be stored more efficiently. Here's another one: void foo(const int *); void bar(int); void baz(int arg) { const int c = arg; for (int i = 0; i &lt; 10000; i++) { foo(&amp;c); bar(c); // this load of "c" can be optimized out } } The `const` qualifier on `x` allows the compiler to discard an unnecessary load. 
K&amp;R also disallows internal pointers to structs. struct { int x; int y; int z; } foo; int *p = &amp;foo.y; // error It looks like your compiler permits this, though. ANSI C also added constants that were not available in K&amp;R C, such as `RAND_MAX`. Though since you don't include your own libc it's not relevant. 
[It's dangerous to go alone, take this](https://pastebin.com/).
I'm not sure I agree here. Do you have a citation? &gt; The result of the unary &amp; operator is a pointer to the object referred to by the lvalue. If the type of the lvalue is "...", the type of the result is "pointer to...". That's all it says in the reference. And since foo.x is an lvalue ...
Ok, you win. But that's a stretch :-)
I see, thanks.
Hmm, you're right. It's likely that years ago I misread the following passage from Appendix A of first edition K&amp;R: &gt; In all implementations, there are no arrays of fields, and the &gt; address-of operator `&amp;` may not be applied to them, so that there are &gt; no pointers to fields. By "field" it's talking about *bitfields*, not *members*. Doh! Sorry! While I was looking for that, I came across another limitation of K&amp;R C vs. ANSI C that I hadn't yet seen mentioned: initialization of automatic arrays and structures. Chapter 6.2: &gt; Finally, automatic structures, like automatic arrays, cannot be &gt; initialized; only external or static structures can. 
Slightly off-topic: When someone overloads operators `&amp;&amp;`, `||` or `,` in C++, then they are not short-circuiting anymore. You shouldn't overload the operators, but you can.
I'm glad you asked. For this particular workload, ditching threads would do. For arrays with millions or billions of elements, replacing the naive bubble sort for a merge, quick, or heap sort would be good.
&gt; but it would not conform to the language standard And a fuck-ton of existing software would break.
For issue 2, you are only allocating 1 memory location for the "limit", and giving a pointer to it for all the threads. It's not that a thread is "executed more than once", it's that the limit variable for all of them is exactly the same variable that they all share, and it's being modified in your main loop. I think you'll find that when all the threads are created, the limit for each of them is 9. A typical way of dealing with this is to make an array of variables, one for each thread, and point each thread to it's corresponding variable index. &amp;#x200B; For issue 1, it sounds like you really only want two threads (for now), 1 that plots data, and one that collects data. To "order" the data, you'll have to put it in an ordered data structure that they both can access. A queue is the typical data structure for such workloads: the collector adds data to the end, and the plotter would take data from the front. Look up "producer consumer" threading and you'll find info. There is still an issue of having to (likely) copy the data from the network interface into a userspace buffer, that you then use for plotting (that's presumably what the "sniffer" is doing). A key point is that you aren't trying to order the threads with regard to each other and how they are scheduled, but you need to keep the data itself ordered; this is a different and hopefully simpler requirement.
hmm you look like funnier one's.
could you fork a child process, read from the network interface and write it out reformatted to a pipe? then in the parent process, read from the pipe and plot the output? it could be written as two separate programs and invoked as 'sniff /dev/netdevice | plotnetdata` to avoid multithreading/multiprocessing entirely
Both your issues sound like race conditions (might want to google it for more info), although I agree with /u/primitive_screwhead that for a packet sniffer I'd probably use only 2 threads and a FIFO buffer (i.e. queue) for communication between the threads which will enforce the order. Good luck!
There is a logical xor. It's `!=`
well, as someone who uses C a bunch, I'd probably do something like this, struct text_cursor { int x, y; /* coordinates from top left corner */ int size; /* font size in (pixels)? */ Color fg; /* text colour */ Color bg; /* background colour */ Color border; /* border colour */ int border_size; /* thickness of border in pixels */ }; int update_text_cursor(struct text_cursor *tc); void draw_text_cursor(struct text_cursor *tc); sample usage: struct text_cursor tc_default = { 0, 0, 16, 0x000000, 0xffffff, 0, 0 }; struct text_cursor *tc; tc = malloc(sizeof *tc); if (tc != NULL) { *tc = tc_default; tc-&gt;fg = fgcol; tc-&gt;bg = bgcol; update_text_cursor(tc); draw_text_cursor(tc); free(tc); } 
Why malloc in that case?
just giving myself things to write lol
Thank you. After some digging it looks like this is a producer–consumer problem. Looks like I'll have to start over with a new setup.
Thanks. I think I'm just going to need a different approach. Continuously generating threads won't be my solution.
&gt;Looks like I'll have to start over with a new setup. This is one of the biggest steps to becoming a mature and experienced developer, imo: not clinging to an improper existing design and recognizing that sometimes an approach needs to be discarded for something altogether more appropriate. So well done. &amp;#x200B; Another key lesson is learning that throwing out an existing design and starting from scratch is one of the biggest reasons that development projects fall behind and fail. Yes, this completely conflicts with the above lesson. :) Truly understanding when to realistically choose if and when to start over, and by how much, is when you master the art of making a successful project (imo). &amp;#x200B; Anyway, in this case, I think you are making the right choice, and will learn a lot from it.
As others said, you're passing in the same pointer to the same int to all the threads, so the value they see depends on when they run. &amp;#x200B; You're also only joining on the last thread you create, but that might not be the last thread that is ran. &amp;#x200B; In addition to the array solutions, you could also use malloc to allocate a new int for each thread. In your mental model, and your documentation, you'll transfer ownership from the main thread to the new thread, and so that thread is responsible for freeing it. &amp;#x200B; Someone suggested that you want a queue for what you really want to do. Personally I would use a library that provides me one instead of creating one myself. (Unless this is for education and not production, AND writing async queues is what you want to learn.) &amp;#x200B; Example library: [https://developer.gnome.org/glib/stable/glib-Asynchronous-Queues.html](https://developer.gnome.org/glib/stable/glib-Asynchronous-Queues.html) &amp;#x200B; Thread pools can also be useful. You still push work, but now a pool of threads are pulling the work off the queue instead of just one. Example of that from the same library as before: [https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#g-thread-pool-push](https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#g-thread-pool-push)
It's no one's job to fix your code but your own. /u/lank3y did you a big favor by pointing out the issues with how you're reading the line. Don't get snippy.
I never though about that before. I was actually using \^ sometimes.
Hey, don't delete your questions; at least not for a few weeks. It means all these good responses aren't gonna be seen by others, and that's a waste of our time. We answer to help the community as a whole, and when you delete your post after getting some responses, that converts our free efforts into consulting.
I’m not sure if the assignment has changed or not but here was my working version. Hopefully I commented enough for it to be understandable https://github.com/tbejos/C-Testing/blob/master/Recover/Recover.c
When I did this problem (3 years ago?) we didn’t have to worry if they file ended in the middle of the block because for the context of this problem the drive was zeroed beforehand so there wouldn’t be any noise. “Because this memory card was brand-new when I started snapping photos, odds are it’d been "zeroed" (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It’s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable.”
Yes, as other say spec doesn't permit behavior to the contrary for compiler writers. I'll give you a hundred bucks and my dog Zeus if you get a teammate to fork your "patched" gcc compiler that changes this behavior, use it to build production code, and introduce bugs that would net a big fat bug bounty payout. 
In C++ it's actually not even possible for overloaded `operator &amp;&amp;` or `operator ||` to short-circuit.
Oh sorry about that. I just thought it would help clean up the sub.
So much of my code, this is a terrifying idea! 
Yes, the alternative would be brain dead waste of cycles. 
Yeah, I figured it was something like that, so no worries. But I mention it to you now to make the point that you don't need to "clean up" the sub; let downvotes do that if necessary. It costs participants time to research and answer these questions, and the way you "purchase" this free advice is by sharing it with all the other readers. Advice like this could literally cost you hundreds of dollars an hour otherwise, so it's no small thing. Anyway, just something to keep in mind for the future. Cheers and good luck.
ELI5 overloading please? I’m not familiar with that term. Thanks!
&gt; You shouldn't ... but you can. That pretty much sums up why I love C/C++.
Forgive me if I'm stating the obvious but you can manually bypass the optimization by evaluating A and B separately first, then evaluating them ANDed/ORed together. i.e. int A(int x, int y) { return x + y; } int B(int x, int y) { return x * y; } ... // force evaluations of A and B int a = A(value1, value2), b = B(value1, value2); if(a &amp;&amp; b) foobar(); 
Thank you very much! They didn't give a staff solution to compare with, so I love you for this.
Hm? It's an exercise? 
Operator overloading in C++ means that you can add a new definition for an operator within a class. For example you could have a `Point` class, representing a point in a Cartesian field, and define `+` to be the summation of those two points. By overloading the `&lt;&lt;` operator in addition to `+` for that class you could have a code snippet like the following: Point A(1, 1); Point B(2,2); std::cout &lt;&lt; A + B; //prints (3, 3)
Good question I'd also appreciate any answers around this! 
Personally I use curses https://en.m.wikipedia.org/wiki/Curses_(programming_library)
Desktop link: https://en.wikipedia.org/wiki/Curses_(programming_library) *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^227919
**Curses (programming library)** curses is a terminal control library for Unix-like systems, enabling the construction of text user interface (TUI) applications. The name is a pun on the term “cursor optimization”. It is a library of functions that manage an application's display on character-cell terminals (e.g., VT100). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
For just a command line, you can also use the gnu readline interface. [https://tiswww.case.edu/php/chet/readline/rltop.html](https://tiswww.case.edu/php/chet/readline/rltop.html) &amp;#x200B; This gives you all the history, editing, with very easy integration.
I have used term box before and found it to be easier than curses. IIRC termbox is a wrapper for curses so it’s the same functionality but easier set up etc. 
curses needs obviously some augmentation to get good window management out of the box. There are libraries which help with building that. * cwidget (used by aptitude) (probably C++) (you could write a C interface). * ncmpcpp has a simple but unicode-capable, object-oriented (C++) windowing library for ncurses (https://github.com/arybczak/ncmpcpp/tree/master/src/curses) which you can compile and use separately (you could write a C interface).
I hope your future H1-B gets denied.
curses based systems like ncurses are the standard for console interfaces. Personally I avoid them. A command line program with options is typically easier to use and nicely scriptable. For less technical users a web interface or graphical GUI is normally better.
Thank you for including the obligatory opening apology required for every reddit post but you forgot the "I apologize if this isn't the right sub" part.
This is exactly the correct subreddit, but for some this may appear as a request for one specific library, instead of opening a discussion of what tools exist in the area. I thought it was necessary, better to be specific about the topic of the post ¯\_(ツ)_/¯ .
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
Haha
On Linux, you can use non-canonical mode, VT100 escape sequences and box drawing characters. You can see a good example of this (except box drawing characters) in the [kilo editor](https://viewsourcecode.org/snaptoken/kilo/)
PSP is a platform that asserts a bus error, learned that the hard way. 
You totally missed the joke. If you come here often enough, you'll see what appears to be a constant theme of starting every question off with an apology. 
We've switched from readline to linenoise, specifically [linenoise-mob](https://github.com/rain-1/linenoise-mob) because it small and does everything we need.
The Readme wasn't very clear, does it help generating terminal-based user interface the way ncurses would do with a significant amount of code and effort but quicker than that? 
&gt; compiler development lacks test oracles Did anyone else misread that as I did?
No, just CLI (command line interface) similar to what GNU readline gives you. If you want a user interface, ncurses is the way to go.
Got it, thanks my dude! 
ncurses is nice 
dialog, for shell scripting and such, seems to have a C interface as well. Don't know anything about it.
Why do you shuffle the data so much ? You receive nice arrays from the child threads, put them in a `int *subarrays[NUM_OF_THREADS]` and pluck from there, in order to your final array.
Please don’t use escape sequences directly, they’re not portable between terminals. Curses implementations can use termcap or terminfo databases to work on many different terminals.
Ok. But what if I were to keep the threads. And replace the sorting each thread would use. What in your opinion is the most optimal way to merge the sorted arrays each thread returns into one array 
I don’t understand. How would I hold NUM_OF_THREADS arrays where each is of size SIZE into an array of size NUM_OF_THREADS?
The issue is that big allocations should be in the heap, not the stack. Allocate that dynamically. 
Hold just pointers, not the arrays themselves. In a loop, go thru the pointers and select the one holding the smallest int. Pick it and increment that pointer.
https://en.wikipedia.org/wiki/Merge_algorithm#Parallel_merge https://en.wikipedia.org/wiki/Merge_sort#Parallel_merge_sort
If you're working on an embedded platform, you might not have a choice. Not that a lot of people are implementing CLIs on small embedded devices, but I'm having to write my own lightweight curses-style library. There aren't nearly as many terminal types to support in common use as there used to be. I'm actually using the kilo text editor (with some modifications) in my application. What's been a bigger hassle than terminal emulation is telnet negotiation.
kids ... not much you can do with them.
I only know of termbox and ncurses
You've basically written a wrapper around malloc with some extra checks and optimisations. Writing custom allocators is very common in C because the memory savings and speed boosts are real, at least when you start doing loads of allocations. If you want proper checks at run time there are already some tools like (`ASAN`)[https://github.com/google/sanitizers/wiki/AddressSanitizer] which similar checks and report errors back to you correctly. But you can't always use ASAN, so your proposal is a decent idea. Another note is that having more memory allocated than is actually used is not too much of a problem since OSes are pretty clever and use demand paging so that they don't actually use any resources for your large allocations until you start writing memory into them, so I wouldn't worry about that. TL;DR yes this sort of idea is totally fine, but you might be reinventing the wheel or doing premature optimization a little bit.
`read` is a function in the libc which reads from files. By providing your own implementation of `read`, you basically override the libc's version of `read`, leading to weird behaviour. Don't do that.
You could make your 'read()' static, at which point it would on affect other things in your .c file. It's still not a good idea. Just call it something else like: &amp;#x200B; readNothing(); &amp;#x200B; But...what are you trying to do? Why read 10 bytes and throw them away? 
Umm... I'm a beginner with C, so it's VERY possible that I'm wrong. But isn't malloc just that? It "chops up" the memory chunk it gets (through mmap() maybe? Not sure)?
&gt;If we have 1000 strings, we have to do 1000 * 2 malloc's, in the case of new_string(). That's also 1000 * 2 frees Um, no? What stops you from doing 1 malloc with appropriate size?
Why would that give me a sorted array? 
Sorry. I did not really understand. Could you maybe show me what you meant in some code? 
OP asked about options other than curses. While I agree that you probably wouldn't want to use VT100 escape sequences in a production program, it is ok to use them to in a personal project or while learning to program. 
This looks similar to the "Arena" approach in game programming.
I don't get it. He's asking abou "CLIX interfaces, and the bulk of the responses are about "curses", which is*not* a 'CLI" interaces, but insteax a fake GUI interface on a terminal.
I didn't know about ASan. I wanted to know if I was on to something and it seems like I am so I'll actually try to write an implementation. Thanks for the informative response.
Kind of, but it's behavior isn't very specific. It's just - allocate memory of this size and give back a pointer. I'd like for there to be less work, get a pointer, and have an absolute guarantee this pointer points to a thing of 'n' size of 't' type. And when I get rid of it, I just reset a variable ( used[i] = false ), rather than doing a free - that way that memory is immediately available for a thing of the same type. I could also look into working with mmap directly, but that's scary.
Oh, I see. So basically a workload optimized, fast malloc, if I understand it correctly.
If I call your routine and there's no memory, what happens? Do you hand back nullptr? If I free your memeory, and then later free it again, what happens? If I free your memory, and then access it it through my pointer, what happens? If I have a circular buffer, and then drop the reference to the head, does it leak or not? What safety did you actually add here?
I could translate that pseudocode into C, but I doubt it would help you better understand it. Basically, it recursively finds medians of the sorted ranges, and put them in their final places. [Here's the idea](https://i.imgur.com/p9OTZmd.png). It's fairly complex and you need a good grasp of recursion to understand why it works and why it's parallelizable. If know nothing about this stuff, I'd recommend you to learn in the following order: recursion -&gt; binary search (first the iterative, then the recursive version) -&gt; merge sort algorithm -&gt; parallel version of the merge and merge sort algorithms.
These are good questions. I thought I had answers, but I don't. But, your questions have caused me to rethink how the block would be designed and what data it would give away. I'll have to consider the way pointers to items in the block are distributed and how they ought to be disposed of. I think it can be done. Well, I think I can account for questions 1, 2, and 3. Not sure about 4 though. That's tougher.
*Command line interfaces* are usually done by providing a set of flags through argv. The number is recorded in argc and individual arguments can be tested with strcmp. There's libraries such as getopt to make the processing easier, but often it is straightforward enough to write your own code. stdin, stdout, and stderr are often used for receiving input, writing output, and reporting errors, diagnostics, and status updates, respectively. *Text user interfaces*—where the input and output are processed and displayed interactively in a terminal, similar to *graphical user interfaces*, can be done on Posix-like systems using termios, but there's a learning curve there. I use *termbox* for most programs myself, it's easy to use, simple, and covers a wide ground, although *ncurses* is more popular and provides more features and opportunities for customisation. On Windows there's *conio*, but you might be able to find ports of the previous 2 I mentioned if you look around the Web.
Take a look at [tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html) and [jemalloc](https://github.com/jemalloc/jemalloc), they're somewhat similar to what you're describing. 
What is the best way to avoid this kind of mistakes? I can think of a couples: 1. prefix every method name with a unique string like \_\_tanin47\_read() 2. Add log at the beginning of every function. Is there a way to do this automatically?
This is a simplified version that reproduces the problem I encountered. My actual code read from fgets and return something. Seg fault only happens like 50% of the time during GC\_init(). And the backtrace didn't show read() because the seg fault occurred when GC\_get\_nprocs() tried to use the return value. It was a cryptic problem.
Choose unique names for your external functions. Do not use names beginning with two underscores or an underscore and a capital letter, these are reserved. Using a common prefix for all functions in your library is generally a good idea. But more generally, the kind of issue you have is rare. With more experience you are going to know the names of all important standard library functions and overwriting them accidentally is going to be a rare ocassion.
Nice correction (I can't fix the title of this post), the two are used interchangeably so often that I didn't think about the difference. 
Custom allocators are very common in performance critical applications like videogames. Malloc is a general purpose allocator, and while it's very good, it makes trade-offs. You know your data better than anyone else so you can make a very specific allocator(s) to definitely speed things up. On a side note, Quake uses a similar allocator to what you're describing if you want to check that out: https://github.com/id-Software/Quake in zone.h/c
They updated the post. They meant TUI, not CLI.
A web interface or GUI may not make sense in some environments. One could provide both a TUI and a scriptable CLI. A good example of this would be SMIT for AIX. 
It sounds like you may need to reinstall ZFS. libspl is only redefining getmntent because it is not aware of the existing version on your platform. Hope that helps.
libzfs relies on and uses libspl. I've installed it from the system package manager, I don't see what reinstalling it would do. It's all working correctly. It's just when I attempt to import the headers I get conflicts.
If you really want to get things working with a quick hack, you can always include your header for getmntent, then define `_SYS_MNTTAB_H` (see https://github.com/zfsonlinux/zfs/blob/master/lib/libspl/include/sys/mnttab.h), then include the ZFS header.
Look up kilo 
I agree, Kilo is good, especially because the code is _very_ well documented: https://viewsourcecode.org/snaptoken/kilo/ In general, if you want to learn how to make an X, check out the build-your-own-X index, which has links to tutorials for lots of different projects in lots of different languages: https://github.com/danistefanovic/build-your-own-x
Speaking of similar things, there is some hardware out there (SPARC I believe) which embedded the size of data a pointer is pointing to within the pointer itself. This allowed each and every instruction level memory read/write to be checked, in hardware (so negligible to no overhead), if you are going beyond the memory. So, bounds checking via the 64 bit pointer contents itself. 
I don’t know if there’s a straightforward guide for this sort of thing, but Brian Kernighan assigned a [project](http://www.cs.princeton.edu/courses/archive/spr08/cos333/ed_to_grep.html) to his students to recreate `grep` by modifying the source code from `ed`. Maybe that could provide some inspiration.
I'd start by writing a text buffer module which records the data entered in the buffer along with the cursor position, along with a set of procedures for inserting and deleting a character before/after the cursor, moving the cursor back or forward, as well as other more complex processes you'd like to perform through the text editing interface (paste, highlight, kill line, for example), along with procedures to read/write the buffer to/from a file a gap buffer is a good choice for the implementation of such a module in C but there are other ways you can do it too the next thing is a library for the interface and that choice depends entirely on the kind of interface you want, but it will usually involve using an external library unless you're happy with something like ed :-p aside from those 2 things, a good grasp of basic C programming, as taught in books like k&amp;r2, should be all you need (aside from an active imagination and a bunch of ideas :D) to write an awesome text editor all the best,
You need a [piece table](https://www.averylaird.com/programming/the%20text%20editor/2017/09/30/the-piece-table/)
Thanks. At least now it builds! I still would like to know if there's a better solution. This must happen to other people as well.
Plugging a personal project: [https://github.com/adsr/mle](https://github.com/adsr/mle) It is comparable to nano or emacs but legacy free and easier to follow. For a vim-like editor, look at [https://github.com/martanne/vis](https://github.com/martanne/vis).
Thanks, I'm looking for something very simple, I do not have much experience, but kilo looks very good to learn
I agree. Maybe post an issue on GitHub.
&gt;I agree, Kilo is good, especially because the code is very well documented Kilo is one of the few C projects I've come across that (mostly) matches my own volume and style of documentation. Drives me nuts when I find an interesting looking project that has all of three lines of comments.
Kilo's great. If you have any questions on it, let me know - I've torn it apart and rewritten major chunks of it and I don't think there's any part I haven't touched. I'm using it in two commercial products where a text editor was an occasionally handy thing to have. You can get it to run in a few KB of RAM, which is a big deal on a system with 128 KB total.
Tried codeacademy?
Doesn't k&amp;r include a little getchar()/putchar() program in chapter 1? Reads input and prints it to screen until you give it an end of file?
ya man, "1.5.1 file copying"
Boom. Word processor. Just don't make any mistakes.
Ok. Thanks!
Thinking about MVC for a program where you only need a single model, view and controller is a waste of time.
many different terminals? Are you living in the past?
Wouldn't it be a cmake issue?
well, check out kilo. Its great!
Often standard libraries use tricks that make them not see your read(). Otherwise you would have had even more trouble, not just from GC\_init().
There is a great tutorial about this [https://viewsourcecode.org/snaptoken/kilo/](https://viewsourcecode.org/snaptoken/kilo/)
[Editor Buffers](https://ecc-comp.blogspot.com/2015/05/a-brief-glance-at-how-5-text-editors.html) is a great discussion of the various ways people implement text editor buffers, and a core decision for how you approach writing your editor. I very much recommend reading this as a starting point because data structures deeply impact the rest of your editor, and how you do things like undo or navigation.
How so? It's a simple way to organize your source files into one that stores and operates on the data, on that shows the data, and one that handles user input. Just from a "where do I start?"-point of view, it's a very reasonable suggestion. 
If you want to make a GUI editor then you need to learn a gfx library - like Qt, GTK. If it's a text editor then it's useful to know about ncurses/text-gfx-library. If you just want to explore algorithms.. then you just need printf
Completely agree on the embedded case! That's a very different environment for sure.
The Linux console is `linux`, my NetBSD console is `wsvt25`, my OpenBSD console is `vt220`, my Illumios console is `sun`, and tmux is `screen` by default. I haven't looked into it closely but I wouldn't be surprised if all of those are a superset of VT100 but one gets out of VT100 territory fairly quickly. 
Yeah, I see. And supposedly there are other libraries on top of curses (or terminfo/termcap directly) that may be a better fit.
Derek Banas on YouTube has a text editor tutorial in QT creator. I think it was C++ but I can’t recall it too well right now even though I followed it a while back.
Interesting you brought up that a char should fit in INT_MAX. It seems like on platforms where sizeof(char) == sizeof(int) this would make an implementation of fgetc impossible (even though this hypothetical platform probably wouldn't come with a libc/stdio).
My belief is this has more to do with how ZFS is trying to handle your platform. libspl should not be redefining getmntent when it is already defined.
Since reading ["Pointers are more abstract than you might expect in C"](https://stefansf.de/post/pointers-are-more-abstract-than-you-might-expect/) which was linked here a few weeks ago, I've been having a hard time accepting the conclusion - specifically that comparing two pointers for equality is defined only for pointers that derive from the same origin (or point to the same aggregate object). If you accept the conclusion then aside from the peculiar example shown on the page, you're also saying that two distinct non-NULL pointers to malloc() can't be compared for equality without hitting undefined behaviour (assuming malloc is returning pointers to distinct objects in the first place). I opine at face value this is absurd. I also was unconvinced how the author came to the conclusion and felt he conflated the requirements of relational operators (&lt; &gt; &lt;= &gt;=) on pointers with equality, in particular that relational operators require that pointers are derived from the same origin (or aggregate). Anyway, I'm glad this is being specifically addressed in ["Clarifying Pointer Provenance"](https://cdn.rawgit.com/C-memory-object-model-study-group/c-mom-sg/master/notes/cmom-0001-2018-05-04-sewell-clarifying-provenance-v4.html#q2.-can-equality-testing-on-pointers-be-affected-by-pointer-provenance-information). I am however sad to see that the answer is a "yes", in that pointer provenance can affect equality. Reading C11 6.5.9p6 (excerpt available on above link) it is quite clear that pointers should compare equal irregardless if they're derived from distinct origins. Sigh, C can be incredibly frustrating.
I think I can implement something like that in the block. Another user was pointing out some flaws in the idea, which caused me to take a look as some old code I wrote once. I never found a use for this struct before, but I think it would be perfect for the block type. Here's an example: #include &lt;stdlib.h&gt; struct person { char* name; int id; double height; double weight; }; struct ref { const void* ptr; const size_t tsize; }; int main(void){ struct person p1; p1.name = NULL; p1.id = 0; p1.height = 5.11; p1.weight = 162.03; struct ref person_ref = {&amp;p1, sizeof(struct person)}; free(person_ref.ptr); } When you try to compile this code, you'll get a warning: warning: passing argument 1 of ‘free’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] That's because the members or struct ref are const. So what I'm thinking is this - the user asks the block to allocate some memory. If it can, it returns a ref, whose members are const. The ref would be returned on the stack, so no additional mallocs or frees need to be called. The compiler guards against freeing the ref because it is on the stack and has const members. In order to open that memory in the block again, the user must return the ref to the block. So, associated with the block there would be the following functions: struct ref block_allocate(struct block* b, size_t bytes); bool block_free(struct block* b, struct ref disown); In the block_free(...) function, it would check to see if that ref actually belongs to the block. If not, false. If it does, that memory gets opened up and I could use memcpy to write over the ref, circumnavigating compiler warnings. Then the ref would be mutated and would go out of scope so the user could not continue tying to use it is used in block_free(...)
A few concepts I would suggest should be supported by a memory-management library are relocatable blocks and sub-heaps with memory reservations. A relocatable block is an area of memory to which the memory manager will at most times hold the only pointers. User code will hold either a pointer or abstract reference to memory regions, and can ask the OS for a direct pointer when needed; user code will then be required to indicate when it no longer needs the direct pointer. If memory becomes fragmented, the memory manager will be free to relocate objects at times when it holds the only references; for code-validation purposes, the memory manager may be invited to change the address of memory blocks more frequently (the Mac OS had an option called "Discipline" which would do this). A handle-based memory manager may also provide options to make blocks purgeable and/or have them backed by files on disk (or flash, or other media). Another concept is that of sub-heap reservations. Given a heap, user code may ask for a "sub-heap" object which will be guaranteed to be capable of honoring a specified number of allocations with a certain total size. If the user application ends up not needing all of the reserved storage, the unused portion can be made available again in the parent heap. This approach can minimize the amount of error checking required for many applications by guaranteeing that certain allocations will succeed. Finally, I would suggest that allocation requests provide a means of indicating whether the caller is prepared for the allocation to fail, and a means of calling a configurable function if that occurs. If an application won't be able to proceed usefully without getting all the memory it requests, or if an allocation failure would indicate that something isn't working according to plan (e.g. because code reserved a certain amount of storage for a sub-heap but is requesting more than that) an abnormal program termination may be an appropriate response, but letting the programmer have some control over the process (e.g. to produce diagnostics, output recovery files, etc.) may be helpful. Pairing every allocation request with: foo = allocateStorage(...); if (!foo) fatal_error(...); isn't harder to read and less useful than allowing code to specify how errors should be handled. 
Different kinds of semantic guarantees are appropriate for different kinds of applications and target platforms. Rather than try to come up with a single set of semantics which would supply everything programmers should need without imposing any unnecessary costs, they merely sought to define a baseline set of semantics whose cost on the platforms where they were most expensive would not significantly exceed the value in the application fields where they were least useful. They expected that compiler writers would recognize that upholding the Spirit of C principle "Don't prevent [or needlessly impede] the programmer from doing what needs to be done" would imply that implementations should offer additional guarantees appropriate to their intended platforms and purposes. Such a notion may have been obvious to pretty much everyone in 1989, but some of today's compiler writers have latched onto the bizarre notion that the Standard was intended to fully specify a language that was useful for all purposes on all platforms. If the Standard is to do more good than harm, it needs to officially recognize that different kinds of implementations can and should offer stronger guarantees than others. It need not concern itself with the question of *which* implementations should offer what guarantees, but merely offer a means by which programs can demand the semantics they need and refuse to run on those that don't. For example, given a function like: #ifdef __STDC_WILLFULLY_BLIND_TYPE_PUNNING _Static_assert(!__STDC_WILLFULLY_BLIND_TYPE_PUNNING, "Sorry--not compatible with gcc/clang -fstrict-aliasing semantics"); #endif void reduce_mod_65536(uint32_t *p) { uitnt16_t *pp = (uint16_t*)p; pp[!__STDC_IS_BIG_ENDIAN] = 0; } a compiler would be allowed to reject it entirely, or would be allowed to process it in a way that recognizes the possibility that it will write to a `uint32_t` object, but would not be allowed to use the Standard as an excuse to pretend that the function won't ever be called upon to access a `uint32_t` object [even though it's being passed a `uint32_t*`]. A compiler that can process the code usefully should generally be regarded as being of higher quality than one that can't, but if a compiler is intended for purposes that would not require such abilities, conformance should require nothing more than that it reject demands for features that it cannot supply. 
https://github.com/rampantpixels/rpmalloc is pretty good too.
The "Clarifying Pointer Provenance" paper seems to over-complicate some things, and also presupposes that no kinds of programs are going to need semantics that might be expensive to support, and that achieving optimal performance will never require withholding certain semantics that some kinds of programs will need. As a baseline, the Standard could be much clearer and more useful if it recognized that certain kinds of things are and are not allowed to alias, while requiring that certain constructs be recognized as being able to operating upon certain objects, rather than "aliasing" them. If one recognized N1570 6.5p7 as applying only in cases that actually involve aliasing, the rule could be written much more tightly while supporting most existing code that works under present interpretations of the Standard as well as a lot of code that doesn't. I'd suggest that the Standard could be simplified if it added the noun "lref" as referring to an abstract run-time entity that identifies an object and is encapsulated by a non-void pointer. Unlike an `lvalue` which is a syntactic concept and could identify different objects at different times in a program's execution and could have side-effects when evaluated [e.g. `someArray[i++] an lref would be a run-time concept. Resolving an lvalue would yield an lref. Taking the address of an lvalue would encapsulate that lref into a pointer. Now all that's necessary to enable most useful aliasing optimizations is to say that a use of an lref is a use of the object from which is is derived, and that operations involving an lref are generally unsequenced with regard to anything that occurs between its formation and its last use. Additionally, if an lref is brought into a function or loop, the first operation on the lref would be unsequenced with regard to anything that precedes it in that context, and the last operation unsequenced with regard to anything that follows it in that context. Operations upon lrefs that identify elements of the same array, or an array and elements thereof, however, would be sequenced, and various other operations such as `volatile` accesses could force sequencing as well. Most programs, including those that don't work under gcc/clang rules, will abide by these access patterns, and these rules would clarify the legality of many optimizations that the Standard either unambiguously forbids or does not clearly allow. For example, given: struct foo {int x, y;}; int test(struct foo *p, struct foo *q) { if (p-&gt;x) q-&gt;y = 1; return p-&gt;x; } If a union object happens to contain two overlapping `struct foo` instances, both `p-&gt;x` and `q-&gt;y` would be lvalues of type `int`, and each is in turn part of a `struct foo`, so 6.5p7 would not seem to forbid them from aliasing. On the other hand, the requirement that a compiler recognize aliasing between elements of the same array would not require a compiler to recognize aliasing between `p-&gt;x` and `q-&gt;y` since they could not alias if `p` and `q` identified elements of a common `struct foo[]`. Consider also: void test(int *p, float *q, int mode) { *p = 1; *q = 1.0f; if (mode) *p=1; } Under the Effective Type rules, a compiler would be required to recognize the possibility that `p` and `q` could identify the same storage, and that if they do the effective type of `*p`/`*q` would depend upon `mode`. Extreme compiler complexity would be required to allow for all such scenarios without substantially and needlessly restricting optimization in many cases. On the other hand, since `p` and `q` cannot be elements of the same array object, and since they are being brought into the function from outside, the operation on `*q` would be unsequenced with regard to the operations on `*p`. No need for "provenance ids" or anything like that. If code casts a `uintptr_t` to a pointer, such a pointer should be viewed as potentially derived from any object whose address has been exposed numerically, but a compiler need not do anything special with it outside the context where it is created.
I'd suggest that a good optimization model for other forms of aliasing would be to focus on common-sub-expression elimination, while invalidating any cached sub-expressions whose constituent parts could possibly be disturbed, and regarding a cast from one pointer type to another, or any `volatile`-qualified access, as a potential disturbance of any sub-expressions involving global or "addressed" objects of that type unless the compiler can see that nothing is written via the resulting pointer. This will facilitate most of the useful optimizations that would be blocked by `-fno-strict-aliasing`, while supporting a dialect of C that's far more suitable for low-level programming than the dialect clang and gcc support without that option. 
/r/minimalism would be proud of ya! :)
Use calloc if you can.
Yeah, I agree. Also, why would it have just one Model/View/Controller? Like with a vim like modal editor, you would have different input controller for different modes. 
Honestly, most of them aren't very useful. Here are the ones I know about/use sometimes: * Optimization: -O1 enables a few optimizations, but isn't very useful overall. -O2 is the most commonly used optimization flag. -O3/-Ofast enable even more optimizations, but can actually harm the runtime of your code by making it take up more space (so it doesn't fit into cache anymore). -Og enables optimizations that can co-exist with debugging, but in my experience you can debug just fine with -O2. -Os optimizes for small binaries. * Warnings/errors: -Wall enables some warnings, -Wextra enables more warnings, and -pedantic will try to enforce standards compliance. -Werror turns warnings into errors. You can turn individual warnings on/off with -Wthis-warning or -Wno-this-warning. * Debugging: -g adds debug symbols. There's also -ggdb which may or may not do something useful, and -g3 which iirc lets you debug macros. * -march=native -mtune=native: enables optimizations which work specifically on your cpu and might not on others. You can also enable sse or avx extensions with -msse or -mavx (just enables the use of those extensions in generated code) * -m32: makes a 32-bit object rather than a 64-bit one (assuming your processor is 64-bit) * -fPIC: makes position independent code. You need this if you want to make a shared library, otherwise it's not very useful. Consider -fPIE (position independent executable) if you're making security-critical code, though. * Miscellaneous stuff: -Idir: adds that directory to the include search path (so then if you #include "bla.h", it might include dir/bla.h). -Wl,-whatever: passes the -whatever flag to the linker. -Lwhatever: adds whatever to the library search dir (so if you do gcc -Lwhatever -lbla, you might link to whatever/libbla.so). * -std=(c89, c99, c11, c17, gnu-one of those numbers): enforces compliance to a given version of c. If the version starts with 'gnu' instead of c (for instance, gnu11), then that means that version of c plus the [gcc extensions](https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html) * -Dfoo=bar: same as saying `#define foo bar` in your source file * -ffast-math: makes floats faster
Your post is being downvoted because the title contains zero useful information and you seem to have put no effort into answering the question yourself. In conversions from base *n*, you tend to find `% n` and `/ n` used to extract and remove (respectively) the least-significant digit of the number. When *n* is a power of two and you’re dealing with integers, `&amp; (n-1)` and `&gt;&gt; lg(n)` (respectively) can be used instead.
&gt; -O3/-Ofast enable even more optimizations, but can actually harm the runtime of your code by making it take up more space (so it doesn't fit into cache anymore). Those options are not interchangeable and I have yet to see the software that runs slower when compiled with -O3 rather than with -O2. The fitting-in-the-cache bit is an urban myth. &gt; -march=native -mtune=native The former implies the latter. &gt; -ffast-math: makes floats faster By breaking the standard. It's not something I would share with someone who can't read the manual. OP should stick to "-O3 -march=native -pipe" until his needs overtake his laziness. As an alternative, there's always https://wiki.gentoo.org/wiki/GCC_optimization
Also you probably already know this but -c just compiles it into a .o, and -o sets the name of your executeable if you don't want it to be a.out
Mmh I see next time I will write a better title! When you say lg you mean log? Anyways I did put thought into this problem it's just that it's not perfectly clear to me how the divions by 10 work. I underdstand they are to position properly the reminder but I don't really understand how. 
&gt; I have yet to see the software that runs slower when compiled with -O3 rather than with -O2. The fitting-in-the-cache bit is an urban myth Even with large programs like browsers or AAA video games? Yes, 5kb maths microbenchmarks will fit into cache _anyway_, so it doesn't matter, but the firefox binary is many times my cache size. &gt; &gt; -ffast-math: makes floats faster &gt; By breaking the standard. It's not something I would share with someone who can't read the manual. The GCC manual is boring trivia. Floating points are not. To /u/5tarrealm5: I recommend you read all the posts in [this series](https://randomascii.wordpress.com/category/floating-point/page/3/) (starting from the bottom), and know that you can't rely on that behaviour with -ffast-math. Also see https://en.wikipedia.org/wiki/IEEE_754
Why would you have to read the entire manual just for the command line parameters? Here's the [page for options specific to C](https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options). While it's not brief, it's only about 7 printed pages.
The vast, vast majority of them are specialized. If you're part of a large project, the project administrators might use some of the specialized options when they build the Makefile. For me, I only use a very small number of options: * -o *filename* — choose the output file (when linking) instead of letting the system choose a default. * -c — compile only (when not linking) * -g — generate debugable output (during development phase) * -O — generate optimized output (for release) * -Wall — warn on all issues * -Werror — treat warnings like errors * -I*directory* — look for header files in this location And seriously, those are **all** the flags I ever use for 95% of my code. For the other 5%, I might also use some of these: * -D*name*[=*value*] — define a macro. I typically use -Dlinux or -Dmacos if my code needs to compile differently for different operating systems. * -S — Generate assembly code instead of object files. Useful for seeing what the compiler is doing, and gaining insights into how the code could be optimized.
what are the numbers you want to convert, from which number to which number, how many decimals do you need?
&gt; Even with large programs like browsers or AAA video games? Yes. I've benchmarked software like LAME or ffmpeg and it runs faster with -O3.
If you're interesting in warnings, read the `-W*` part of the manual. Any "tutorial" will be just be one guy who actually read the manual writing it in his own words, either in a more lengthy version or leaving out details that might matter to your application. Don't waste time and don't be lazy - read the manual, but just the parts that are relevant for your use case.
You can find some custom memory alloc in the pbuf struct of lwip, those are for data packets, so the proposed interface is fast. [http://www.nongnu.org/lwip/2\_0\_x/group\_\_pbuf.html](http://www.nongnu.org/lwip/2_0_x/group__pbuf.html)
-fsanitize=address is by far the most useful debugging flag.
Those aren’t “large” programs in the sense of having huge amounts of executable code. Or at least the critical path you’re hitting on any particular execution is probably not that big — there may be 50 different encoders/decoders compiled in, but you’re only using one of them at a time (or maybe two if transcoding). I’m not sure if I’ve seen gcc’s -O3 by itself cause problems, but excessive use of compiler macros to force inlining definitely can. Aggressive inlining looks great until your working set of instructions stops fitting in the instruction cache of your CPU.
You could write a guide. It's a good way to learn.
The number is 2.625 in this case. I don't really get your questions I'm sorry. It's just a converter from decimal to binary that also converts fractions. 
Do not enable `-Ofast` or `-ffast-math` unless you know exactly what you are doing. These are dangerous options that break correct programs. The extra performance is almost never worth it.
If it's from a video, do the effort and type the code in yourself. Or do you expect others to do this for you?
Sheesh no need to be so aggressive. I did type it down and tried it many times mate it's just that there are lots of comments in my native language and I didn't want to post that screenshot or just right it down as a text only post since it wouldn't have mattered! What I'm asking is to explain to me the part of the algorithm that involves the divisions by 10. I got that the division moves the remainder in the correct position but I would like a better explanation of this concept that's about it.
so first thing is to get the integer part so: float a = 2.625; int int\_part = (int) a; a -= int\_part; //so here in a we have 0.625 printf("%x", int\_part); so now for 3 decimals multiply a for 1000 and do the same trick or 10, 10, 10 and print each part &amp;#x200B;
&gt;read the manual, but just the parts that are relevant for your use case. This. One skill that I think is not often discussed with regard to command-line tools is how to find what you're looking for and ignore the rest. Man pages can be, at 8k+ pages, somewhat intimidating. But after reading enough of them, you invert the approach - instead of thinking you need to read the whole damn thing, just search for keywords pertaining to whatever you're looking to do.
&gt; I’m not sure if I’ve seen gcc’s -O3 by itself cause problems I haven't, and I'm using Gentoo ~amd64 - I compile everything with -O3 (except those few packages that revert to -O2 in their ebuilds because of known problems).
By lg, I mean binary (base 2) logarithm, which you can grab from any other-based logarithm via lg *x* = log *x*/log 2. lg is used often in asymptotic analysis, where things tend to be recast into most-reduced forms. The divisions by ten work because in decimal representation, each digit is muliplied by 10^(*i*) for decreasing *i*. E.g., 123 is **1**×10² + **2**×10¹ + **3**×10⁰. Modding that sum by 10 isolates the 3×10⁰ term; dividing it by 10 shifts the digits so you’re left with 1×10¹ + 2×10⁰ + 3×10^(−1), and generally the integer-ness of the division and representation will chop off the 3×10^(−1) term leaving you only with powers of 10 that are ≥0. Successive divisions shift things successively towards 10⁰. This can be generalized to any normalized, polynomially structured number; e.g., some raw time difference in seconds can be converted to days+hours+minutes+seconds form by successively divving/modding it by 60 (seconds per minute and minutes per hour) and 24 (hours per day). You can also start from the most-significant end, although you’re probably not saving any time/effort in doing so. E.g., 123 could be split up by first doing (/100)%10 to get the 1 (%10 optional if you know the input is &lt;1000), then (/10)%10 to get the 2, then %10 (after optional /1) to get the 3. At first glance, this seems like the way to go for display purposes since we tend to use a big-endian ordering in text, but modern CPUs may do worse with top-down, especially if you have to find the most-significant nonzero digit before starting output. Tricks at your/compiler’s disposal for speeding divs/mods up, which should be kept in mind when planning out how to code things: - CPUs usually hand back the remainder alongside the quotient from integer division instructions, so `a/b` and `a%b` (singular integer `a` and `b`) can be done with a single instruction. The optimizer is generally quite good at finding cases like that, although you can also use `div` from `&lt;stdlib.h&gt;` to make it explicit. (May or may not save any machine code or cycles in the end, of course.) - Good optimizers know how to convert division by a constant to multiply+shift, and modulus takes a further multiply+subtract beyond what the quotient needs, for a total of 2 multiplies. Multiplication tends to run in 5–8 cycles, whereas division-by-arbitrary will require a few tens of cycles. (Shifts, adds, and subtracts tend to run in ≤1 cycle.) - As mentioned, integer division and modulus by power of two can be done with shifts and masking, just like you’d do div/mod by power of ten on paper. Non-integer operations may handle power-of-two operands differently than integer ones, but they still tend to be faster than arbitrary operands. (E.g., IEEE-754 floats will usually be able to quickly add to/subtract from the exponent field when multiplying/dividing by power of two, unless the add/subtract would trigger ±∞ or sub-normal cases.) - When trickses are in use, signed numbers may require an extra few instructions to adjust results, because trickses tend to obtain a quotient rounded towards −∞ (not 0) and/or grab the modulus, not the remainder (which may or may not be different). Unsigned numbers won’t incur these extra costs, so if you know a number can’t be negative, use an unsigned type to communicate this to the compiler. Alternatively, you can explicitly tell the compiler that negatives are not possible if you’re sticking with signed, using `__assume`, `__builtin_unreachable`, or plain old `if`+`for(;;) abort();`.
And it'll probably the thousandth bad guide to the topic. It's a good way to learn something but you probably don't get it really right. I'm glad I didn't start publishing stuff I wrote in order to learn immediately. I'm know rather comfortable doing so and yet stand correct quite often.
gcc's flags are a superset of the POSIX-defined c99 and these are the basic flags needed to make use of the c compiler, they are described here: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/c99.html The compilers add quite some other flags such as `-W`, `-f` and `-m`, the first by numbers mostly pertaining warnings (but not always), the latters configuring compilation behavior. An excerpt for GCC: * -Wall, -Wextra, -Wwrite-strings, -Wstrict-prototypes, ..., -Wl,-xxx (passes linker flags) * -fPIC (position independent code) * -m32, -mfloat-abi=hard, ... Mostly you don't look at the flags and then decide which are needed but the other way around: You want to do X and look for flag Y. Except when you are looking for optimization possibilities or similar. I once looked through all warnings GCC offered, selecting those that I considered important (especially for me and my code) and learnt quite a bit about code that *might* be problematic. However it's also good to learn when to ignore the compiler (it's not: I don't understand the message)
I'm not sure if it still is slower, but I've also seen zlib deflate slower with -O3 The reason is that aggressive unrolling actually hurts performance where the programmer already knows what the optimum unrolling should be and codes it that way. In the zlib deflate case, the optimum code length is 3, so Mark Adler coded it with loops optimized to decode 3 at the source level. Gcc with aggressive optimizations would unroll that and create loops that are larger than this.
Using GCC by Richard Stallman et al all the command line parameters explained. There's a specific section for C programming only. [https://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc.pdf](https://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc.pdf)
I just think most bad guides are written by people who just want filler for their blogs. That's why you read through twenty different guides and they use the same examples. A person that has to become an expert at something from reading the documentation because there were no easy answers to be found should write better guides.
Most advice against using -ffast-math is based on a poor understanding of floating-point. Only a negligible amount of code is broken by such transformations and most code sees pure upside from it. FMA changes the numerics by making them more accurate, for example.
You've not provided: * your code; * the specific output you were expecting; * the specific output you actually got. See https://idownvotedbecau.se/itsnotworking/, https://idownvotedbecau.se/nocode/ and https://idownvotedbecau.se/unclearquestion.
We can actually know if you dont provide us your code source. A public repo as Github/Gitlab would be a good choice!
FMA is only used when coming with -ffast-math?
Really impressive stuff, well done.
man gcc Then Google anything you don’t understand. (I guess that’s a DIY tutorial...) ;)
I wish people wouldn’t just recommend the optimization flags without mentioning how the generated assembly can modify critical memory management functions. I imagine if you were to start using memset, you’d need to do research first on how the compiler translates it, but still, the current top post of the subreddit at the moment has no issues talking about -O as a simple beginner friendly flag.
That document is the reason why this question exists. There's so much information in it that it's hard to get an idea of what matters.
On line 161 after the fork() which is executed by the child you have: kill(getppid(),SIGTERM); It appears the child is going to terminate the parent process. This seems unnecessary. Again looking at the parent you have these lines: if(taskNum == 0){ printf("Orders done\n");fflush(NULL); kill(child, SIGKILL); return; This seems intentional, however you still need to reap the child after killing the process. So you will want to add to the block (right after the kill()) _something_ like: int status; waitpid(pid, &amp;status, 0); if (WIFEXITED(status)) { printf("child exited with status %d\n", WEXITSTATUS(status)); } else if (WIFSIGNALED(status)) { printf("child exited due to receipt of signal\n"); } return; I recommend carefully reading the manpage of `waitpid`: https://linux.die.net/man/2/waitpid . However this only takes care of the case where you killed the process. You will also need to add similar waitpid() statements _before_ the parent returns from simulate().
-E is a useful flag - if you've got a C file using a lot of macros, that flag makes gcc use only the preprocessor on the file. The output file will have all the macro substitutions done in-place so you'll be able to see exactly how the code looks. This is especially useful if you're using a boilerplate library - you use the macros to set up the general contents of the C-file (say, two macro-defined structures and three functions), you run the preprocessor on it, you edit the resulting file (which is nicely unrolled now) and you start filling the function logic code in.
I don't know why the following hasn't been considered. Compile your wipemem() [which can simply call memset] in a shared library and static/dynamic link to your program. It seems both simple and portable*, but I'm sure it is probably not viable. \* Ok I'm not absolutely sure it is portable, since static/dynamic linking of a C application might not be available to all compilers/platforms.
The optimisation does not affect behaviour the program can observe. This is about unobservable behaviour which is nevertheless important for security reasons. Beginners need not to worry about such things and disabling optimisations is not a good solution for the underlying cause (poorly written code).
&gt;int status; waitpid(pid, &amp;status, 0); if (WIFEXITED(status)) { printf("child exited with status %d\\n", WEXITSTATUS(status)); } else if (WIFSIGNALED(status)) { printf("child exited due to receipt of signal\\n"); } return; i tried to call waitpid at the end of the parent ( if(child&gt;0) statement) but it **crashes** the application. also used this for knowing the status after the kill(child, SIGKILL); pid_t return_pid = waitpid(child, &amp;allapot, WNOHANG); if (return_pid == -1) { printf("error\n"); } else if (return_pid == 0) { printf("child is runningt\n"); } else if (return_pid == child) { printf("child is done\n"); } else { printf("crap"); } return; &amp;#x200B;
I can see this, and I don't suggest to disable optimization, I just think it's nice to know those can have an effect on safety, even if beginners won't touch on any critical code anyway.
You said “the current top post of the subreddit’s frontpage has no issues talking about -O as a simple beginner friendly flag.” clearly indicating that you do not think of `-O` as a beginner-friendly flag, i.e. that you think beginners should not turn on optimisations. Or have I misunderstood your intent?
I meant it more as the flag being talked about without its side effects, but this is maybe me being too curious and worried about those behaviors. I guess I need to read more on it, I just always feel like I'm not being told about certain things and I always want to dig deeper to not produce such problems myself.
First of all addressing the code, I would not use WNOHANG. There is a race condition you need to consider. The parent could send the SIGKILL to the child, but before the signal is received by the child, the parent can continue to call waitpid(). With the WNOHANG option the waitpid could return with 0 and then return. Later the child will receive the SIGKILL, terminate. This child will not be reaped, and become a zombie process. Regarding your code crashing the application, can you paste your updated code (on pastebin)?
Turning on optimisations does not have observable side-effects! That's the whole point. If you depend on the compiler maintaining the value of an object as it goes out of scope, then your code is broken. It's not the optimiser's fault, it's yours.
[here you go.](https://pastebin.com/BD1AM7c6) Thanks for your help, I appreciate it!
So I take it that using memset to clear memory holding sensitive data is broken code? I guess then this is indeed more a warning that comes with the usage of memset than the optimization flag.
First of all. Do not use WNOHANG - particularly your application does not need it. WNOHANG is more appropriate for applications with an event-loop that may or may not create child processes. A good example is a *nix shell, where you might background a process, and everytime you run a command or simply press "enter". a waitpid() is called with WNOHANG to see if there's any child processes that need to be reapead. In your case, you're _always_ forking a child process, and you want to always want to make your parent wait on your child. So simply put WNOHANG is not appropriate. What error do you see when you do waitpid() on line 144 (without WNOHANG).
&gt;I have no problem using waitpid(child, &amp;allapot); on line 144. But I am not sure how to test if child process ends before parent process.
&gt; So I take it that using memset to clear memory holding sensitive data &gt; is broken code? If your program was perfect and had no bugs, you would never be able to tell the `memset()` was optimized away. Clearing sensitive memory is a defense-in-depth technique to make a program's bugs less harmful. It's not necessary for a program's correctness. 
The talk mentions this when it discusses linking. It's very toolchain dependent and requires the program to be built a very specific way. This technique would likely fail when link-time optimization (LTO) is used.
Yes! That's because in general, the C standard does not specify whether changing an object actually changes anything in RAM. It merely says that the code must behave as if RAM was changed. This means for example that the compiler can throw away writes to memory when it knows that you never inspect that memory again. This applies to all writes, not just `memset`. Such an optimisation is by design never observable from within a correctly written C program. There are some ways out of this, the easiest one being `volatile` variables. Watch the video for more strategies.
I got the impression that the fear is that \_in the future\_, a smart linker phase can still delete apparently dead code.
&gt; For static linking, this technique would likely fail when link-time optimization (LTO) is used. So I did consider this when I posted earlier under the impression that LTO wouldn't optimise beyond the translation units it's compiling and linking. I even wrote a test library/program and supplied -O3 to clang and it didn't optimise away the memwipe() function I wrote. I later realised you need to pass -flto to clang for it to do LTO, doh! I haven't tested dynamic linking yet, but I have a hunch that it should be foolproof because LTO cannot be influenced by shared libraries.
You should carefully close all unused ends from all pipes on each process, and then exit the child when it's reading end closes. No need to send signals, it'll work automatically by itself.
If you place the waitpid() on the parent _before_ returning from simulate(), then it must wait on the child to finish. If the child isn't finishing, then you might have a problem with the child code. Of course a quick way to test is to replace the child code to just sleep for 5 seconds or so. If the parent **does not use** waitpid(), then the program should exit immediately, while the child process will continue running in the background. If the parent **uses** waitpid(), then it will wait on the child process until it completes.
thanks for everything :)
printf("Happy New Year to you, too!!")
To format your code every line needs to be preceded with at least 4 spaces. Anyway here is an equivalent formatted code: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int i, j, count[26] = {0}, x, linecount = 0; FILE *fp; char fname[20], veta[512]; scanf("%s", fname); fp = fopen(fname, "r"); printf(" "); for (i = 26; i &lt;= 26; i++) { for (j = 1; j &lt;= i; j++) { printf(" %c ", 'A' + j - 1); } } printf("\n"); while (!feof(fp)) { fgets(veta, 512, fp); linecount++; printf("%d ", linecount); for (j = 0; j &lt; 26; j++) { if (veta[j] &gt;= 'a' &amp;&amp; veta[j] &lt;= 'z') { x = veta[j] - 'a'; count[x]++; } printf(" %d ", count[j]); } printf("\n"); } return 0; } You can simplify the first loop: for (i = 26; i &lt;= 26; i++) { for (j = 1; j &lt;= i; j++) { printf(" %c ", 'A' + j - 1); } } to for (i = 0; i &lt; 26; i++) { printf(" %c ", 'A' + i); } Anyway onto the actual problem you're having: for (j = 0; j &lt; 26; j++) { if (veta[j] &gt;= 'a' &amp;&amp; veta[j] &lt;= 'z') { x = veta[j] - 'a'; count[x]++; } You're iterating over the first 26 characters of the string `vera`. What you want to actually do is iterate over the number of characters in the string returned by fgets(). You will want to use the `strlen()` function to determine the string length, see [manpage on how to use strlen](https://linux.die.net/man/3/strlen). 
You don't have to declare functions inside the main. Once you declare it outside, you can just use them inside the main.
Your professor is referring to function prototyping. This explains the topic pretty well: https://computer.howstuffworks.com/c13.htm In most cases, the compiler will warn you about using a function before its definition if you don't provide a prototype, but it won't give you an error. That said, it's generally considered good form to provide them. Doing so will ensure the compiler checks the return types and parameter count of your functions so you don't call them incorrectly. Better to let the compiler catch mistakes than to have unexpected behavior at runtime. 
C/C++ don’t *require* a separate declaration. A function definition will also function as a declaration. However, this forces you to define the functions fully before they are used. If you have functions that call each other you’ll need to declare at least some of them ahead of time. It’s highly recommended to declare them. In a larger program that is being split into several modules, by far the most common approach is to put your function declarations in a .h file and then just the definitions in a .c file.
;
I used different method, but thanks for replying and solving the problem.
`-ffast-math` will break code that relies on the specific behavior of the standard, but the vast majority of code isn't written so carefully. If you're not concerned with perfect output reproducability, then it's probably worth using. &gt; The extra performance is almost never worth it. Here's one of my own projects as real world example: [sort-circle](https://github.com/skeeto/sort-circle). It animates various sorting algorithms by writing a video stream to standard output. It does quite a bit of floating point math in order to render the output video, and I don't care about each build's output being a pixel perfect match with one another. $ gcc -O3 sort.c -lm $ time ./a.out &gt;/dev/null real 0m22.472s user 0m22.364s sys 0m0.012s $ gcc -O3 -ffast-math sort.c -lm $ time ./a.out &gt;/dev/null real 0m18.210s user 0m18.188s sys 0m0.008s I'll happily take a 20% speedup from `-ffast-math` in this case. 
The standard requires rounding error to be introduced between multiplication and addition. FMA eliminates that rounding error, so it can't be used.
I made a [formated gist](https://gist.github.com/g-berthiaume/74f0485fbba5cc3249eee458c1d0d386) of my favourites answers in this thread. Thanks for the question and the great answers.
*cries in Visual Studio*
And im here in 1st semester college struggling with begginer stuff in Structure Programming. I just cant get the logic, I dont know what is with me. If you give me the code I'll probably know what it is about, but when I need to write, I just cant get it. I dont know what to do :( &amp;#x200B;
&gt; `-Idir`: adds that directory to the include search path (so then if you #include "bla.h", it might include dir/bla.h) I thought this effected `#include &lt;blah.h&gt;` but not `#include "bla.h"`
It affects both
What exactly gives you trouble?
Documentation for this sort of thing is very slim. My advice would be to: - read Linux Device Drivers and have a play with an older kernel. This is about getting familiar with the basic concepts. A lot of it will transfer to any kernel version. - start with a driver that is similar to one you want to write and maintained by a reputable company (eg Intel). Read it through with Linux Device Drivers in one hand and the kernel docs directory in the other (and google close by) - get to know that driver deeply. How it works, why it works. You’re looking to understand the driver &lt;—&gt; kernel side most deeply. This is the part you’ll need to use. - start working on your own driver. Copying the key concepts from the one you’ve read and understand. Take it very slowly. This is a very different style of development and you can easily tie yourself up in a mess with bad memory management or bad locking. The kernel is a dangerous and unforgiving place when you make mistakes. - have fun. Once you’ve figured it out, driver development is pretty straight forwards and fun :-) 
Break the problem down into the smallest, easiest steps possible. In this instance, I wouldn't really know what to do either and would have to look at other programs that use graphics.h.
I dont know how to explain it XD If you give me the program as I said in the first comment I'd understand what it does probably, but if you take that away and tell me to write it by myself, I wouldnt know how. On my first mid-term I had a task to make program (really easy) that does this: Find the smallest number with (insert what digit you want to search for in the number) and (insert how many times that digit repeats in the number you've given). In concept it sounds really easy, you make one counter (with For) and give condition if that number is bigger than the last one you put it in 'minimum' integer. Yes it sounds easy as f*ck but I didnt know how to execute it. Now on my final exam I'll have one matrix, recursion and FILE, and I know nothing. I mean I know the basics, the dead basics, literally the rock bottom info about it. Like my brain denies this thing I dont know man. I want to learn it but idk...
That kind of thing comes with practice. Do you work on your own stuff in your spare time? Making little games and scripts is the best way to learn how to structure code. It isn't as hard as it seems. 
Thanks for the guidance! Have an upvote.
Make me a logitech driver that doesn't make a device randomly disappear right before each update.🧐
I'm starting with learning more and more after New Year. My Final is on 4th February, I hope I learn at least to pass it, then I can learn some things on my own. They give us a lot of tasks that are heavy math and need deeper and more apstract thinking.
...and solve the halting problem while you're at it. Shouldn't be too hard after that.
What tricks do they use? I'd like to learn more. Thank you.
Thank you!
Nice one, haha. Just starting out though.
Well that one may need a cup of coffee. With whiskey.
 double example(char *s, char **endp); /* this is a declaration */ double example(char *s. char **endp) { /* this is a definition */ } a function should be declared or defined before it's used, so the arguments and return value can be converted to the correct types. 
This is incomprehensible. Maybe you could try writing articles in your native language, it could help others who speak it.
Wait I maybe wrote the wrong term. Its structural programming probably. We do arrays,matrix,recursion,FILE,functions.
Ya that's what I meant too. A good way to practice is to use those concepts to make stuff you find fun, to get a feel for it. That way the assignments are easier. That's the biggest advice I can give. 
this is an interesting resource [https://kernelnewbies.org/Linux\_4.0-DriversArch](https://kernelnewbies.org/Linux_4.0-DriversArch) but years ago I did some hacking on an existing driver, and I have to say its not easy and often poorly documented and its also a fast moving target, what you learn may well get out of date quite quickly... If I were developing my own device.... I'd be tempted to do as much processing on the device so I could use simpler and lower bandwidth interfaces like USB...
&gt; void main
English is a little rough, but not that bad and I could undestand it with slight difficulty. From as far as I read to it seemed to do a decent job explaining the operators and what they do.
It's not that bad, just rough english.
I remember finding that a while ago but didn't follow through because it was linux specific
It is convention, I believe. If you ever write your own implementation of the C standard library, go nuts.
I would second reading older kernel versions. I personally have the `1.0`, a random `2.4` and `2.6`, and the latest, and I look at all three fairly frequently when doing kernel programming. The `1.0` code is *pretty* crusty (Not being reentrant probably the biggest difference that has to be accounted for), but the drivers in paticular are still very useful for seeing some simpler code for interfacing with various devices - and there's *tons* of them even in `1.0`. There's also the advantage that the older devices were overall simpler, making them much easier to understand as a starting point. Generally, most modern devices aren't tons different from older devices, but they tend to have lots more features making the code harder to follow. Also, [lwn.net](https://lwn.net/Kernel/Index/) is a *fantastic* resource. You should buy a subscription (Because it's a fantastic website), but you can read all articles except for the current week's article for free, and there'e execelent. There'a also fantastic for learning about the current stuff since pretty much all big changes get articles almost as soon as they're merged in.
God yes
Right now, I'm just looking for a low level C project so I can understand how devices really work. I'm not planning on commercializing anything. But yeah, thanks for the link!
You might want to consider crossposting to /r/crypto .
See any libc source. read could be known as \_read for internal use by the C library.
Doesn't -S strip all debug info from the output?
This sounds a bit like [memory pools](https://en.wikipedia.org/wiki/Memory_pool).
**Memory pool** Memory pools, also called fixed-size blocks allocation, is the use of pools for memory management that allows dynamic memory allocation comparable to malloc or C++'s operator new. As those implementations suffer from fragmentation because of variable block sizes, it is not recommendable to use them in a real time system due to performance. A more efficient solution is preallocating a number of memory blocks with the same size called the memory pool. The application can allocate, access, and free blocks represented by handles at run time. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
How small is small? [https://github.com/AntonioBohne/KiwiLexer](https://github.com/AntonioBohne/KiwiLexer) Here is my contribution to human atrocities. A lexer&amp;parser. Still not finished.
A more modern project: [BearSSL](https://bearssl.org/). Incredibly well documented SSL/TLS library with very consistent and clean codebase.
I've done kernel module development and this site is an invaluable resource: https://elixir.bootlin.com/linux/latest/source This site will not teach you how to do driver development, but its handy for when youre looking for how things interact in kernel-land and what the structures look like.
seconded this, bootlin(the people who made elixir) is a real life-saver when searching for kernel symbol, I also recommend their [linux training slides](https://bootlin.com/docs/)(they are available for free). [This book](https://www.amazon.com/Linux-Device-Drivers-Development-customized-ebook/dp/B073V4LKWN)has a lot of editing problems but should be more up-to-date compared to ldd and would really help you at least know about the different subsystem and tools(like regmap for i2c and spi code reuse) to help you. Also like others said, read a lot of other people code(just look at the kernel source tree) and just be persistent, good luck!
[removed]
conio? what about Linux?
With a casual look at the source, I'm not spotting any glaring issues. I did see some trouble spots, though. The function `libVES_veskey_new` has biases when generating keys. Some characters are significantly more likely than others: https://i.imgur.com/o2oTDLz.png Perhaps this was intentional in order to make these keys easier to remember (prioritize letters of special characters), but I don't see this fact documented. The return value of `RAND_bytes` is never checked. OpenSSL isn't clear about when and how likely it is to fail, and I suspect it's very unusual. However, if it *did* fail, the results would be catastrophic since the program wouldn't notice. There are a lot of useless `memset(buf, 0, len))` calls to clear sensitive data. Each of these will be trivially optimized out. Use `OPENSSL_cleanse` instead. Interesting timing since [the subreddit just discussed this issue yesteday](https://redd.it/ab2v3i). I see two ciphers in here: two variants of AES256-GCM, and AES256-CFB. GCM has built-in authentication, so that automatically takes care of a MAC. However, the "AES256GCM1K" scheme on top, invented for VES, is dubious. It's adding a *redundant* integrity check that significantly bloats the size of the data. This has no benefit. I don't see any authentication when AES256-CFB is used. Maybe this is handled at a higher level? I'm not seeing it. I don't see any reason to choose CFB when GCM is already in use. It's a strange choice. Don't check generated files into the repository. This includes `configure`, `depcomp`, and `missing`. If you want to make a source distribution that includes the `configure` script, have Autoconf [generate the tarball](https://www.gnu.org/software/automake/manual/html_node/Preparing-Distributions.html). Don't use a repository ("VES-win32") to distribute binaries. Use GitHub "releases" infrastructure to upload builds/installers for a particular tag/release. 
The C standard actually reserves these groups of identifiers. Two underscores for implementation details of the libc, an underscore and a capital letter for new keywords. POSIX [reserves](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_02_02) quite a bit more actually.
Try to do some embedded programming. Helped me a bunch when learning C.
Not true actually. The standard specifies that it's implementation defined with what precision intermediate values are kept. Otherwise, the x87 FPU could not be used for floating point operations in a sensible way since it keeps intermediate values with 80 bits precision.
Keep in mind that Linus assigns version numbers almost arbitrarily, so a switch from 2 to 4 isn't that big of a deal, and the book probably isn't as dated as it seems.
I don't have any resources for you, but I would also suggest to find a relatively simple open source driver and work on building a copy of it yourself. It being open source would allow you to look at its code for when you got stuck, and once you get that first one built, you should have enough of the concepts down to work on a more complicated driver. 
That true, but implementations explicitly declare their intermediate precision via `FLT_EVAL_METHOD`. Old x86-32 compilers set this to 2 which gives them the freedom to use FMA. When `FLT_EVAL_METHOD == 0`, which is standard on new architectures, including x86-64, the intermediate value must be rounded with the lower precision, which blocks the use of FMA. IMHO, `FLT_EVAL_METHOD == 2` is a dirty hack to make the weird behavior of old compilers legitimate. It's a bad idea. In no world is it reasonable for this function return 0, as it does for `FLT_EVAL_METHOD == 2`: int float_compare(void) { float x = 1.3f; return x == 1.3f; } 
I don't quite see how you don't accept `FLT_EVAL_METHOD == 2` but then happily apply `-Ofast` which gives even less guarantees.
When using any level of optimization for tasks that require or benefit from non-portable constructs, it's often essential to also use flags like `-fno-strict-aliasing` and `-fwrapv` or `-fno-strict-overflow`.
`-Ofast` does useful things, relaxing the standard when I don't need something so strict (e.g. I will never get a NaN, so they don't need to be considered). It allows the compiler to use advanced features like SIMD and FMA that are often otherwise off limits, even with `FLT_EVAL_METHOD == 2`. Ultimately I can choose whether or not to use it. On the other hand, `FLT_EVAL_METHOD == 2` is usually hardcoded by the implementation, and it doesn't do anything useful for me. Instead it *slow down* a program. It undermines the type system and makes it harder to reason about floating point operations (per my example above). If I really need more precision, I'll just be explicit and use `double` or `long double` operands, which still works fine under `FLT_EVAL_METHOD == 0`. 
i is a variable used to keep track of how many times the loop has run. It doesn’t have to be called “i”, it’s just an accepted convention. 
oh god I just realized ho simple it was.... I was trying too hard :P thx a lot
`i` is an integer, declared in the `for` loop. It only exists within the loop. A for loop has three parts, the initial state, a condition that must be true for the loop to continue, and what to do at the end of each loop. In this instance the initial part declares that `i` is an integer with `int i`. It then assigns it the value of 0. The comparison checks if i is less than 255, and i is incremented by 1 each loop (`i += 1`, though I prefer the more compact `i++`.)
I would not advise using any non-zero `-O` level without flags like `-fno-strict-aliasing` or `-fwrapv` unless one is certain that all of the code one is using will adhere to gcc's interpretation of the Standard. According to the published Rationale document for the C standard, the authors recognize that one of C's strengths lies in the ability of non-portable programs to perform actions which are not described by the Standard, but the gcc optimizer isn't designed to work reliably when not required to do so by its authors' interpretation of the Standard. 
 for(int i = 0; i &lt; 255; i += 1){} Is basically shorthand for int i; for(i = 0; i &lt; 255; i += 1){} Meaning: i starts with the value 0; the loop stops when i equals 255; each time the loop executes, the value of i increases by 1. The *i* is just a variable that controls how many times the loop executes. It doesn't have to be an "i", but it is very common to use "i" (for "increment"), or "a" for this purpose. If you're confused by // fades out green bring blue full when i=255 just read it as // fades out green bring blue full when the loop has executed 255 times
You cannot assign to these symbols, as they may be macros. However, you can use `freopen` to make them refer to different files.
you can override STDOUT_FILENO with dup2() 
Do you mean to redirect reads/writes to another file? If so, then `freopen()` might help. It's part of the standard and closes the current `FILE` stream and connects to another file. Example: ```cpp stdout = freopen("output.txt", "w", stdout); printf("Hello!\n"); /* Prints "Hello!" to the file output.txt */ ``` 
&gt; you can override STDOUT_FILENO with dup2() This will _probably_ be safe, so long as nothing has been written via `stdout` beforehand. I don't think C makes any guarantees on behaviour when a stream's underlying file descriptor is reopened.
&gt; cpp stdout = freopen("output.txt", "w", stdout); I don't know what the `cpp` is meant to mean there, but regardless, you cannot portably assign to `stdout`. Even if you _could_ assign to `stdout`, you wouldn't want to do so in this way: if `freopen` fails it would become a null pointer. `freopen` has been designed to muck around with internals of a `FILE` object _without_ reallocating it.
Behaviour is well-defined if you flush all streams for this file-descriptor beforehand. Calling `fflush(NULL)` to flush all streams should do the trick.
Have you tried stdout = some_file; If you want to support unbuffered IO, too, use `dup2()` instead.
Ah thanks, I thought that would be the case, but I had a fair amount of trouble synthesising that from the specs. POSIX has [a section](https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_05_01) on the behaviour when two "handles" refer to the same file description... which is close, but not quite the same thing.
You can also design your code so that you always use `fprintf()` etc. with a FILE pointer passed as an argument to your functions (Or even a global variable), instead of using `printf()` etc or an explicit stdout.
&gt; I would not advise using any non-zero `-O` level I would.
@vincentdankgogh answer is very good. I see pool concepts and data oriented ones in your proposal. For instance, the Java interpreter (JRE) uses a pool of strings by design. I assume most high level/scripted languages do so. Data oriented design is all-out cache friendliness performance optimization but this leads to similar concepts, like allocating contiguously all instances of the most used data types. I'd recommend you to read about data oriented design, and not taking it as the holy grial.
Not sure why you're seeing `cpp` but it's supposed to tell the code highlighter that the syntax is C/C++. 
Thank you for the lwn.net link. Amazing articles so far from what I've glimpsed!
Dirty, unportable, nasty, but happened to work (FreeBSD 10) stdout-&gt;\_file = new\_fd;
reddit's Markdown dialect, [snudown](https://github.com/reddit/snudown), doesn't support fenced code blocks (```) or syntax highlight hinting. Your only option is to prefix lines of code blocks with four spaces.
I'm not familiar with CloudABI, so maybe this is a dumb question. But why can't you redirect those on program startup instead? \`myapp &gt; /some/file 2&gt; /some/other/file &lt; /some/input/file\`
Thank you for a really helpful review! &gt; The function libVES\_veskey\_new has biases when generating keys. Some characters are significantly more likely than others: &gt; &gt;[https://i.imgur.com/o2oTDLz.png](https://i.imgur.com/o2oTDLz.png) &gt; &gt;Perhaps this was intentional in order to make these keys easier to remember (prioritize letters over special characters), but I don't see this fact documented. It should be since it trades off security for convenience. Yes, it is intentional, to make a generated VESkey more human readable. In most cases, generated VESkeys will be handled automatically by VESvault. But if the person has to manually type the VESkey into their app, fewer special characters makes it easier. I added a comment in [libVES/VaultKey.h](https://ves.host/docs/libVES-c#libVES/VaultKey.h) to avoid further confusions, and referenced your frequency graph (with your credits). &gt;The return value of RAND\_bytes is never checked. OpenSSL isn't clear about when and how likely it is to fail, and I suspect it's very unusual. However, if it *did* fail, the results would be catastrophic since the program wouldn't notice. Good point. Not sure when RAND\_bytes() may fail (maybe when lacking a true random source?), but i added the checks for the return value. Released as 0.901 beta. &gt; There are a lot of useless memset(buf, 0, len) calls to clear sensitive data. Each of these will be trivially optimized out. Use OPENSSL\_cleanse instead. Interesting timing since [the subreddit just discussed this issue yesteday](https://redd.it/ab2v3i). Really good to know, thanks for the heads up! Changed, released as 0.901 beta. &gt;I see two ciphers in here: two variants of AES256-GCM, and AES256-CFB. GCM has built-in authentication, so that automatically takes care of a MAC. However, the "AES256GCM1K" scheme on top, invented for VES, is dubious. It's adding a *redundant* integrity check that significantly bloats the size of the data. This has no benefit. &gt; &gt;I don't see any authentication when AES256-CFB is used. Maybe this is handled at a higher level? I'm not seeing it. I don't see any reason to choose CFB when GCM is already in use. It's a strange choice. There are two derivations of GCM - AES25GCMp and AES256GCM1K. GCMp is GCM over a padded plaintext - a padding length byte is inserted in the beginning, and the corresponding number of ignored bytes appended at the end. The purpose is to conceal the exact length of short entries (to minimize side channel leaks). GCMp is used internally in asymmetrically encrypted vault entries - for all entries encrypted with an ECDH key as a part of [VES ECIES](https://www.vesvault.com/assets/download/VES%20Vault%20Key%20Algo%20ECDH.pdf), and for long entries encrypted with RSA (when the length exceeds the maximum for the RSA key). [GCM1K](https://www.vesvault.com/assets/download/VES%20Cipher%20Algo%20AES256GCM1K.pdf) is a chunked seekable extension of GCM. The purpose is to be able to * resume encryption from a block boundary to the end of the stream, without storing the cipher context * start decryption from a random block boundary without processing any preceding content * validate the integrity of each block without decryption the complete ciphertext All these features are useful for large files and streamed web content. The only drawback is a small increase in the ciphertext length comparing to the plaintext, extra 16 bytes of GMAC hash for every 1024 byte block. CFB is a naturally seekable cipher (with 1 byte granularity instead of 1024 byte for GCM1K), without any integrity validation, thus any corruption to the ciphertext will corrupt the plaintext starting from the first corrupted offset, without raising any decryption errors. The advantage of CFB is that it produces ciphertext without any overhead, where the length exactly equals the length of the plaintext. CFB may be useful for applications where the size is critical but the integrity is not a concern or is validated by other means. Example use case is an encrypted block storage. In addition, there's a fake "NULL" cipher, which doesn't have any cipher key and doesn't support encryption or decryption, but may carry encrypted cipher metadata stored in the cipher entry, same as any real cipher does. Hope it all makes sense. Additionally, anybody can implement their own cipher algorithm in a VES enabled app and use it with libVES - see [libVES\_Cipher\_registerAlgo()](https://ves.host/docs/libVES-c#libVES_Cipher_registerAlgo). &gt;Don't check generated files into the repository. This includes configure, depcomp, and missing. If you want to make a source distribution that includes the configure script, have Autoconf [generate the tarball](https://www.gnu.org/software/automake/manual/html_node/Preparing-Distributions.html). &gt; &gt;Don't use a repository ("VES-win32") to distribute binaries. Use GitHub "releases" infrastructure to upload builds/installers for a particular tag/release. Makes sense. I'll revise the packaging shortly. Thanks again!
Already did, thanks
So you haven't told us: * what compiler and compiler options you're using; * how you're invoking the compiled program; * what the code is supposed to do; * what the code is actually doing instead; * what kinds of debugging you've already tried. Do you just want us to guess?
So a segmentation fault typically means that you are trying to dereference an invalid pointer. In your example it is probably because you are walking off the end of your linked list. Two easy ways to find the fault. 1. Use GDB. Run the program through gdb. When you segfault ask for a backtrace. This will show you the exact line of code at fault and the execution path to get there. 2. Put prints or guards on all your linked list walk functions. Specifically sval and sset, the problem is almost certainly triggered by calling one of them.
Sorry. What I am trying to achieve is make a linked list and then sort the numbers using quicksort algorithm. The linked list part works alright, what is not working is the quicksort part (I think it is around the quicksort function calling in main part). The bug is spotted at the run-time, so I guess gcc compiler cannot detect the error. I only tried simple debugging like reversing code lines and changing code to comment to spot the mistake, and yet I can't find the mistake
On line 102 you are doing nothing. Change it from `new-&gt;next;` to `new = new-&gt;next;`. I suggest you add the flag `-Wall` whenever you compile your code. It enables all of the warnings gcc will find. &amp;#x200B; Whenever I run it -- `./test 3 3 3` \-- it does not segfault.
Okay I used the tag, here is what it gave me: hw8.c: In function âquicksortâ: hw8.c:36:2: warning: implicit declaration of function âsplitâ [-Wimplicit-function-declaration] middle = split(first,left,right); ^ hw8: In function `_fini': /home/abuild/rpmbuild/BUILD/glibc-2.18/csu/../sysdeps/x86_64/crti.S:80: multiple definition of `_fini' /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../lib64/crti.o:/home/abuild/rpmbuild/BUILD/glibc-2.18/csu/../sysdeps/x86_64/crti.S:80: first defined here hw8: In function `data_start': (.data+0x0): multiple definition of `__data_start' /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../lib64/crt1.o:(.data+0x0): first defined here hw8: In function `data_start': (.data+0x8): multiple definition of `__dso_handle' /usr/lib64/gcc/x86_64-suse-linux/4.8/crtbegin.o:(.data+0x0): first defined here hw8:(.rodata+0x0): multiple definition of `_IO_stdin_used' /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../lib64/crt1.o:(.rodata.cst4+0x0): first defined here hw8: In function `_start': /home/abuild/rpmbuild/BUILD/glibc-2.18/csu/../sysdeps/x86_64/start.S:67: multiple definition of `_start' /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../lib64/crt1.o:/home/abuild/rpmbuild/BUILD/glibc-2.18/csu/../sysdeps/x86_64/start.S:67: first defined here hw8: In function `_init': /home/abuild/rpmbuild/BUILD/glibc-2.18/csu/../sysdeps/x86_64/crti.S:64: multiple definition of `_init' /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../lib64/crti.o:/home/abuild/rpmbuild/BUILD/glibc-2.18/csu/../sysdeps/x86_64/crti.S:64: first defined here /tmp/ccDiOBTY.o: In function `sval': hw8.c:(.text+0x0): multiple definition of `sval' hw8:(.text+0xf0): first defined here /tmp/ccDiOBTY.o: In function `sset': hw8.c:(.text+0x3c): multiple definition of `sset' hw8:(.text+0x12c): first defined here /tmp/ccDiOBTY.o: In function `quicksort': hw8.c:(.text+0x7e): multiple definition of `quicksort' hw8:(.text+0x16e): first defined here /tmp/ccDiOBTY.o: In function `split': hw8.c:(.text+0xf8): multiple definition of `split' hw8:(.text+0x1e8): first defined here /tmp/ccDiOBTY.o: In function `main': hw8.c:(.text+0x1f0): multiple definition of `main' hw8:(.text+0x2e0): first defined here /usr/lib64/gcc/x86_64-suse-linux/4.8/crtend.o:(.tm_clone_table+0x0): multiple definition of `__TMC_END__' hw8:(.data+0x10): first defined here /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../x86_64-suse-linux/bin/ld: error in hw8(.eh_frame); no .eh_frame_hdr table will be created. collect2: error: ld returned 1 exit status &amp;#x200B;
You look confused at what you are trying to achieve. The segfault isn’t a concern, you whole approach seems wrong. You hace to build a quicksort on top of link d lists. Quicksort is a n log n algo. It seems to me that you are basing your code on an array-based quicksort, and replaced indexing by calls to « sval » and others. This will get you nowhere. Array indexing is a constant time operation, while your « sval » operation is NOT constant time. Even if you succeeded, the result would NOT be qucksort, and you would fail the assignment (I suppose this is an assignment). You need to look at qucksort in a very abstract way, to implement it on top of linked lists: 1 - sorting an empty list is a no-op 2 - sorting a non empty list is: 2.1 - extracting the pivot (first element) 2.2 - re-arrange the rest of the list into two sublists, relative to their value with the pivot. 2.3 - sort the two lists 2.4 - concatenate the small list, then the pivot, then the bigger list There are no indexing operations in that, only pointer assignments in the isting nodes. One last thing that may help you: some arguments to your functions should not be « node * », but « node ** », so they can get pointers to NULL and uptade them to the right place. Good luck, have fun.
Declaration of implicit function (despite the function clearly existing) is usually because you are accessing it before you define it. &amp;#x200B; You should write a list of all of the function as function headers at the top of your file, or you should move the split() function above the quicksort() function. Its up to you.
I am afraid I can't teach you how to read. But I can tell you to look up fopen and fwrite.
It might be best if you show us what you've tried.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ FILE *f=fopen("draw.sketch","wb"); if(f== NULL) { printf("Error!"); exit(1); } putc(0x00,f); putc(0xA8,f); putc(0xFE,f); putc(0x3f,f); putc(0x7d,f); putc(0x03,f); fclose(f); } &amp;#x200B;
OK, does it do what you want?
That appears to work. What issue are you having? Or if no issues, what questions can we answer for you?
It works marvelously. Thanks a lot!
I want to implement the same thing using fwrite but not really sure how I can do that. Any help will be appreciated!
Off the cuff: char[] bin = { 0x00, 0xA8, ... }; size_t n = fwrite(bin, 1, sizeof(bin), f); if (n != sizeof(bin)) { /* do something about it - maybe try fwrite again from where it left off */ } Be sure to read the [fwrite manpage](https://linux.die.net/man/3/fwrite).
&gt;Assuming the values are laid out sequentially in memory somewhere (like an array): char a[] = { 0x00, 0xA8, 0xFE, 0x3F, 0x7D, 0x03 }; fwrite(a, sizeof(char), 6, f); &amp;#x200B;
What exactly is a “hex byte?”
We had your blogposts here, twice, and iirc twice removed because of the low quality. Most issues still stand (bad command of English, wrong, pictures of code, old compilers, ...). Heed our advice and don't try to teach others C before you understood the language yourself really. Ask if things are unclear, but do not write and *distribute* blog posts.
No, this a also a function declaration: int foo(); but it's no prototype, since -- by C grammar for historical reasons -- it includes an empty *identifier-list* which *does not say that the function takes no arguments* and it *does not constitute a prototype*. This is a prototype with a non-empty *parameter-list*: int foo(void); In the first case, it is allowed to call `foo` with arguments (but Undefined Behavior if the *implementation* of the function doesn't want arguments), in the latter case it's a compile-error.
Before a variable or a function can be used, it must be declared. A declaration gives the type of the object, eg.: int a; // declares a of type int int foo(void); // declares function foo returning int &amp; prototype, specifying it doesn't take any arguments int main(void) {} // declaration + implementation After that we can use `a`, `foo` and `main`. If you want to use the function `bar` within `main` you need to declare it before `main` as well. A similar approach is writing a header file, this contains code (usually mostly declarations) that can be included in a C file using the `#include "filename.h"` preprocessor directive. Note that this is no special magic but just copies the contents of the header file as-is into the C source code at that position. Thus: // foo.h int foo(void); together with // foo.c #include "foo.h" int main(void) { return foo(); } is equivalent to just writing: // foo.c int foo(void); int main(void) { return foo(); } Note that you usually write include-guards in header files to guard against multiple inclusion (read online for more info about that). Also it's good practice to declare functions that are only used within one C file as `static` (this makes them visible only internally).
 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;err.h&gt; int main(int argc, char *argv[]) { if (argc &lt; 2) err(EXIT_FAILURE, "%s: missing input", __func__); FILE *read_file; int *ptr; int i, c, z, line = 1; for (i = 1; i != argc; i++) { if ((read_file = fopen(argv[i], "r")) == NULL) err(EXIT_FAILURE, "%s: fopen() failure", __func__); if ((ptr = calloc(1, sizeof(int) * 256)) == NULL) err(EXIT_FAILURE, "%s: calloc() failure", __func__); (void) printf("\n\n-----\t%s-----\n\n", argv[i]); for (z = 65; z != 91; z++) (void) printf("\t%c", (char) z); (void) printf("\n"); while ((c = fgetc(read_file)) != EOF) { switch((char) c) { case '\n': (void) printf("%i", line++); for (z = 65; z != 91; z++) (void) printf("\t%i", ptr[z] + ptr[z + 32]); (void) printf("\n"); free(ptr); if ((ptr = calloc(1, sizeof(int) * 256)) == NULL) err(EXIT_FAILURE, "%s: calloc() failure", __func__); break; default: /* * c as a char values the current letter * ptr[c] values the number how often fgetc() reads the letter in the current line * ptr[65] to ptr[90] values A to Z * ptr[97] to ptr[122] values a to z */ ptr[c] += 1; break; } } fclose(read_file); free(ptr); } return EXIT_FAILURE; } Sorry if the english isn't that good, it's not my native language. &amp;#x200B; I hope that comment is enough to get the idea behind it. I use int c as (int) letter and (char) letter to fill my int \*ptr (array). There are shorter ways to get the same result, but I think calloc() is a way to make the code much more readable than flushing the value after each line. &amp;#x200B; usage: a.out file1 file2 file3 ... &amp;#x200B;
Why not just `stdout = new_file;`
This is sadly still being taught in Indian and Pakistani universities.
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int i, j, count[26], x, linecount = 0; /* * you have to fill count[26] with zeros * I'm not that fit in C but count[26] = {0} * won't do the job? * * if the memory wasn't empty before, your * results could get wrong values */ for (i = 0; i != 26;) count[i++] = 0; FILE *fp; char fname[20], veta[512]; scanf("%s", fname); // check for errors or the programm can do crazy things fp = fopen( fname ,"r"); printf(" "); for(i = 26; i &lt;= 26; i++) { for(j = 1; j &lt;= i; j++) { printf(" %c ",'A' + j-1); } } printf("\n"); while(!feof(fp)) { fgets(veta, 512, fp); linecount++; printf("%d ", linecount); for(j = 0; j &lt; 26; j++) { // capital letters? if (veta[j] &gt;= 'a' &amp;&amp; veta[j] &lt;= 'z') { x = veta[j] - 'a'; count[x]++; } printf(" %d ", count[j]); } printf("\n"); } // even if it isn't necessary, use fclose() if fopen() was called before fclose(fp); return 0; } Now after reading your programm, I'm not entirely sure what you wanted, but I commented some parts which could possibly deliver wrong numbers. You didn't flush the array after each line, so you counted every letter which isn't capital and sum it up until EOF
vi/vim. It's on every Unix/Linux/BSD which includes Apple and servers. Xcode is Mac only. VS is a Microsoft product geared towards .NET and Windows products.
Yours \_is\_ better.
[https://idownvotedbecau.se/imageofcode](https://idownvotedbecau.se/imageofcode) [https://idownvotedbecau.se/toomuchcode/](https://idownvotedbecau.se/toomuchcode/)
While I agree that vi/vim is a solid choice and it's the one I use (vim). VS code is different than Visual Studio, it's still developed by Microsoft but it's cross platform.
Please note that C++ is off topic in this subreddit. Please post C++ projects to /r/cpp or /r/cplusplus instead. (I check your source, it has the file extension `.cpp` and is written in C++). 
Please post your source code rather than pictures of it.
I thought so at first, but he actually let Visual Studio default name for source file in, and included iostream for no reason. Should we call it "C++ without classes"? LoL The fact the code is shoved up all together in one file is the cherry on top of the cake, but with cake-sized cherry, and a cherry-sized cake.
I've been a 15+ year vim user but lately been dabbling with vs code. I've tried xcode in the past but found the learning curve to be steeper. I'm not going to list pros/cons of both since I don't know both, but i think you should aim for simple easy to use editor/IDE and I think vs code fits that bill.
I’m not a Xcode fan, it seemed needlessly complicated. I’ve been using vs code on my Mac recently and it’s pretty good. I also use vim, which is great as it’s on all unix systems, so I’d recommend you learning at least enough to use it in a really basic way. You might find you love it. But for anything bigger than a single script I like an IDE or an editor as I like that hand holding! 
You would advise doing so *without being certain that none of the code you're using relies upon any non-portable constructs that gcc's optimizer won't support unless forced*? That would seem rather reckless. 
&gt; You would advise doing so without being certain that none of the code you're using relies upon any non-portable constructs that gcc's optimizer won't support unless forced? Of fucking course. &gt; That would seem rather reckless. Nigga, I've been running Gentoo ~amd64 compiled with "-O3 -march=native -pipe" for many years on many computers. You don't know what you are talking about.
The functions `malloc()`, `calloc()`, etc. are required to either acquire memory via any means they sees fit and then return a pointer to a portion that it at least as large as requested, or return a null pointer. The `free()` function isn't actually *required* to do anything but should generally, at minimum, make memory available for future malloc requests. If the execution platform has allocation functions of its own that can be invoked efficiently for small objects, and a release function that does not require the allocation size as an argument, `malloc()` may just chain directly to that. If the execution platform has allocation/release functions that can be used efficiently even with small blocks, but the release function needs to be told the size of the allocation, `malloc` and `free` could be implemented as something like: void *malloc(size_t n) { size_t *ret; n = -((-n) &amp; (-ALIGN_WIDTH)); ret = platform_alloc(n+PREFIX_SIZE); if (!ret) return ret; *ret = n+PREFIX_SIZE; return (unsigned char*)ret+PREFIX_SIZE; } void free(void *p) { size_t *block = (unsigned char*)p - PREFIX_SIZE; platform_free(block, *block); } In a freestanding implementation, if one knows that code will `malloc()` everything it needs on startup and never allocate anything after that, one could on many platforms use something like: union { unsigned char data[HEAP_SIZE]; long long l; double d; } HEAP; size_t heap_remaining = HEAP_SIZE; void *malloc(size_t n) { n = -((-n) &amp; (-ALIGN_WIDTH)); if (n &gt; heap_remaining) FATAL_ERROR(); heap_remaining -= n; return HEAP.data + heap_remaining; } void free(void *p) { } Obviously not a good implementation if memory will ever need to be reused, but it will have *zero* per-object overhead when allocating objects that are a multiple of ALIGN_WIDTH bytes. If there's never any need to reuse memory, there may be no need for anything fancier.
Not the OP, but that's referring to typing up the markup yourself, instead of having it generated by the WYSIWYG editor. Those editors get the job done, but in my experience, the result markup tends to be unnecessarily messy and prone to bloat. 
I get the sense I should post this to r/roastmycode instead? LOL
If you're explicitly being told to use fork(), you'll want to look at some form of IPC, such as pipes. Don't really want to give a detailed explanation for an exam project.
Unfortunately the Prof did not explain us very much but I know that I have to use the fork function because it's the only one she explained. 
Unfortunately the Prof did not explain us very much but I know that I have to use the fork function because it's the only one she explained. 
I don't know how much memory do you have in your mac but I just tell you that VSC occupies ~200 MB of weight while Xcode ~6 GB. If you only need to learn C I suggest you to use Visual Studio Code.
I’m not sure about the rest but I can answer question 1 (*(volatile Ifx_SR_S*)0xF00385Cu) Is a common idiom when working with device registers. 0xF00385Cu is the address of the memory mapped io register, because writing / reading this register causes side effects. An example is an LED on an arduino board - there’s a specific address that you can write to which turns on and off the LED. It looks like there are multiple things you can write to this register, hence the union. I’m not sure why, but there’s likely different scenarios where you need to use the differently sized values when writing. The word volatile simply means “disable all optimizations”. Normally when you write to an address, that write is cached so that your program runs faster. But since you need to actually do a memory write immediately, you need to do a “volatile memory access”, AKA “dereference a volatile pointer”. That’s why there’s a dereference of a casted pointer, this tells the compiler to not apply any optimizations so that the write really happens.
I advocate giving Xcode a try. The integrated edit/run/debug workflow is pretty nice. If all you're doing is writing generic C code for you class, create a new project of project under the "macOS" tab of type "Command Line Tool" and in the next screen be sure to pick "C" for your language. In the sidebar, find main.c and modify that to write a simple program. If you need more specific help, this is the wrong subreddit. Maybe try /r/Xcode.
use fork() and https://linux.die.net/man/5/ipc . For example, you could do it with semaphores and shared memory. Also use man pages and be patient in reading them.
&gt;Any help will be appreciated! Go, You Can Do It!!
Yes I'm doing it but I don't know how to "project" the program. It seems more difficult than I was expecting. I'll try this. Thanks. 
Can you tell exactly what the assignment states without paraphrasing? And also can you tell what you have learned in the course so far so that we can get some context? &gt; I have to do a muti-client / server chat in c using the fork function What you have mentioned is slightly broad.
Great idea for a sub. But mfw it exists but there's only 2 posts. Sad! Besides, I suspect non-C/C++ programmers wouldn't get it.
go baby steps, first try forking 1 server that printf("I am the server"); and let's say 5 client that each printf( "hello from client nr %d", client_nr);
Probably K&amp;R
See the sidebar -&gt;
K&amp;R
The only advantage that I can see to requiring that `main` be declared as returning `int`, and requiring that user code explicitly return the value 0 when it is successful, is that it can make some implementations slightly easier. Since C89 was written at a time when implementations were being squeezed into machines with 32K or less of RAM, it made sense to say that implementations that could cheaply accommodate `void main(...)` would be free to do so, but those where it would be expensive didn't need to. Once the Standard to waived the requirement that `main` return a value, however, that eliminated any benefit I can see to requiring that it be *declared* as though it returns a value. The notion that the authors of the Standard intended to suggest that any constructs for which they didn't mandate support should be viewed as "broken", rather than merely allowing compiler to decide for themselves whether it made sense to support them, has become absurdly popular, but it runs directly contrary to what the authors of the Standard themselves have said in the published rationale documents. 
On some implementations, it may be expensive to support the ability to initialize automatic objects as part of the declarations, rather than requiring that all objects used within a function be declared (allowing a compiler to generate prologue code that knows their total size) before any of them are used (requiring a compiler to generate code that can't execute until after the prologue). Any quality compiler that isn't running on a tiny machine, however, should be able to support more flexible declarations.
The `const` qualifier can also offer such benefits when used in combination with `restrict`. Given: int *pp; int test(int *restrict p) { if (*p) foo(&amp;p); if (*p) *pp += 1; return *p; } a compiler would need to load `*p` three times, but if the function declaration had been `int test(int const *restrict p)` it would only have to load `*p` once. 
This sounds like the same project from my Prof. Becke?
1. Modern C 1. C Programming: A Modern Approach 1. 21st Century C 1. Expert C Programming 1. C Primer Plus 1. The Linux Programming Interface 1. The C Standard Library 
Nope 😂
*Programming in C*, Stephen G. Kochan Then after you finish that, *Understanding and Using C Pointers*, Richard Reese
I studied from Deitel&amp;Deitel and it was written in a simple and detailed way. K&amp;R is not a good starting book imo.
It might help to start with a rough outline of what your program needs to do. Take the description you already have "Being a chat, the server should take the message from a client and then send it back to the others, so to all the clients except the one which sent the message" - and expand it. 
Minor nit: I've worked on embedded systems. All the hair on the back of my neck stood up when I saw `0xF00385Cu`. You really, *really* don't want to use a hard-coded constant like this in your code. It should be a symbolic name, preferably #defined in a header file. No matter how sure you are that this address will never change, you're wrong. Someday, someone is going to copy this code into the driver on a different embedded system.
The operators will always behave as though they short-circuit in any circumstance where the compiler recognizes that the second operand may have side-effects. They may not short-circuit in cases where a compiler does not recognize that possibility. For example, given something like: struct { int x,y; } foo; int test(void) { return foo.x || foo.y; } it may be faster on many platforms to read `foo.y` unconditionally than to avoid the read if `foo.x` is non-zero. On many platforms, it may be "physically" possible for the read to cause side-effects (e.g. if one sets a "read data" breakpoint on foo.y), but the Standard would regard code which reads a statically-allocated non-`volatile` object and effectively ignores the value as equivalent to code which doesn't.
Modern C and K&amp;R are great. 
This took me a long time to digest, but I get it now. Thank you.
I would personally recommend C Programming Absolute Beginner's Guide. It assumes you have no prior programming knowledge. I quite enjoyed it.
It *is* in a `#define`.
But it's already in a define and the meaning of it is documented not even 10 lines above. Really don't see how defining the address alone as `DMA_SOURCE_REQUEST_ADDRESS` right above might increase readability or maintainability. If someone wants to reuse the code with different hardware they should already expect to have to rewrite a non-trivial portion of it.
This one is actually not as bad as the other one. It does miss some operator classes, but otherwise it's well illustrated with examples.
How much knowledge about computer science do you already have?
I know that's a really obvious answer, but... "Introduction to Algorithms" by Thomas Cormen.
*The Art of Computer Programming* by Donald Knuth. It's quite a niche read, but interesting for sure. Wouldn't recommend it as a first book though.
I read *Data Structures in C* by Noel Kalicharan. It was a nice introduction.
Go find an introductiory course on Coursera or similar, they have nice presentations, tests, good lecture notes, and a recommended reading list.
If you're a beginner, this is an excellent read: https://www.amazon.in/Data-Structures-Through-C-Depth/dp/8176567418/
&gt; Looking for an introduction level book &gt;Wouldn't recommend it as a first book though. So you blurted out a useless post anyway?
[The Algorithm Design Manual by Steven Skiena](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202/)
I wouldn't recommend it as a first book to someone who has never been exposed to Computer Science, but it's great for learning algorithms and data structures. P.S. Why the downvotes?
It's getting a bit heated in here, should I leave?
This. Prefer not mixing the abstract data structures with their C implementation. Take even something trivial like a list, it can be implemented in a number of ways: as an array most obviously, or as a linked list. And even when taking the linked list implementation there are other details to consider: using a memory pool and indices (less memory overhead, better cache locality) vs using pointer, using an unrolled linked list (better cache locality) etc... Most books that treat data structures in C i've seen do a poor job either when it comes to the quality of the C code or taking into account various C subtleties, like the allocation overhead of `malloc`. Starting with analyzing data structures in terms of asymptotic behavior is a good start. After that you can worry about the implementation. 
Please, don't post these. Our users really don't like this kind of article.
I have removed this post as it is a repost of a [submission from yesterday](https://www.reddit.com/r/C_Programming/comments/ab94iz/operator_in_the_c_programming_language/).
A decent amount. Know some Java just haven't really touched on linkedlists, hash tables, etc.
Are you talking about a physical push-button or a GUI element? If it's about physical push-buttons you're gonna have to deal with the harsh reality of mechanical bounce. It can be dealt with it quite easily in software (add some delay and take multiple samples).
You could write increment and decrement functions which take the current value of your button and return that value +/- 0.1 respectively. cur_val += 0.1 or cur_val -= 0.1 var++ or ++var will always be 1
Physical. I have dealt with bounce in previous examples using a delay. I just wanted see if it was possible to easily increment by .1 as I am making a variable alarm point control to a measurement system (e.g. you use up/down push buttons to set the desired value of you alarm point). 
Brilliant thank you! Why didn't I even think of adding/subtracting 0.1!?
I'm sorry but that isn't a decent amount
True, though initialization of automatic structures follows from struct assignment, mostly. Initialization of arrays is outright weird, though. I wasn't even aware that was permitted in C89 -- I always assumed that was a C99 thing, but you're correct that it's C89. On the subject of initializers, K&amp;R doesn't allow the initialization of unions, either, static or otherwise, whereas ANSI does, somewhat awkwardly, with that "first member" rule.
Make sure that you change your variable to a float or double if you do it this way. Adding 0.1 to an int won't work properly. 
Yes thank you! It is already a floating value set to 1 decimal place. Many Thanks :)
Adding 0.1 to a double won't work "properly" either, since 0.1 can't be exactly represented. Ie. if you start with 0.0 and add 0.1 ten times, the result will not compare equal with 1.0. If you care about this, use an integer and treat it as a count of tenths. int counter=0; ... counter++; printf("result is %f", counter/10.0f);
You're right. I misunderstood the question. 
What platform are you programming for?
I'd prefer *Algorithms* by Sedwick to *CLRS*. More concrete introduction and less theoretical.
It makes it up with worse English, still talking about ancient compilers, pictures of code etc. It's not completely wrong anymore but still really bad quality (IMHO).
Man, I'm sorry. But I can't imagine a degree in mathematics would put you at a disadvantage. Some places are starting to get on board with remote employees. Mozilla and Wolfram both primarily do remote development work. Have you thought about [Upwork](https://www.upwork.com) and [Freelancer](https://www.freelancer.com/)?
If you weren't aware, the reason these articles use Turbo C is that it is (apparently) still the teaching standard in many Indian universities, at least as far as I can tell. There are a lot of tutorial videos on "how to install turbo c" that come from India, I had been curious as to why that was the case and came across a comment, on reddit (I think), from an Indian uni student complaining about the continued use of TC.
But the code listings are in comic sans :(
lol.. .I've reach to bookshelf and check it out.. =.==== yup... dunno.. lol.. 
what???? First of all, did you even test your example? Because it totally works.
it didn't how come it will work and the self created test function didn't even had a returned code to be in conditional
yeah just make sure your variable is a float or double, not an int
This is real code from a project of mine: switch (parsed.exit_flag) { case INIT_EXIT_USAGE : { printf(usagestr, argv[0]); return 1; } case INIT_EXIT_NUSAGE : { fputs("-h or --help for usage\n", stderr); return 1; } case INIT_EXIT_ERR : { perror("An unexpected error has occurred: "); return 1; } }
Just wondering, do you know of a good driver to look at (for kernel programming beginners)?
i just did my search again and i need a other way otherwise i found that return; is a possible way for that but didn't work either 
No mention of TAOCP?
The return value of any function ends up in a register. Any line that reads a returned value will just read the register for that return type and use whatever is there. Your if "works" because it simply reads the register after calling the function as it assumes that whatever is there is the value it needs to look at.
The others here have made some good points, with good code. But just to note, with your basic code example, you could simply return test(), which would be the exact same. 
I've never had to work with anything that low level so unfortunately I don't. However, I do think that something like a mouse or keyboard driver would be your best bet because those pieces of hardware are simple, so you shouldn't be exposed to much black magic like a GPU driver will probably have in it. 
Can you explain what exactly does not work? What do you expect to happen? What happens instead? Can you show us your whole code so we can see how you use the snippet in your question?
TAOCP?
Just yesterday found out about this one: http://algorithms.wtf In the introduction it also lists additional (free in ebook format) reading to get you up to speed. 
Where the hell was I a dick?
The Art Of Computer Programming. It is like a bible for all the most important data structures and algorithms. Written by one of the creators of C.
It makes it easier for a human to see what is happening. The following code: if ((*(volatile unsigned char *)0xFFF0 &amp; 0x01) == 0x01) // rest of code is the same as: #define ACIA_STATUS ((volatile unsigned char *)0xFF00) #define ACIA_STATUS_READ 0x01 if ((*ACIA_STATUS &amp; ACIA_STATUS_READ) == ACIA_STATUS_READ) // rest of code You might not know what ACIA stands for (Asynchronous Communications Interface Adpator---also known as a serial port) but you can see that it's checking if we can read data from the device. That's all /u/capilot was mentioning. 
Thank you all for help, i find it very helpfull
You need to include `linux/memory.h`, not `memory.h`. Same for all other files.
Nope, the code is returning 0 on truthy values and 1 on falsy values
Wasn't it written by Knuth? I thought Dennis Richie and Ken Thompson were the creators of C.
I do C for 10 months now and i use vscode. Vscode is cross platform and is widely use. It got a integrate terminal and dont take 1 min to load. Xcode is hard to use and not very customizable. Vim is nice to know as well.
LOL you're right, I'm a moron. I was just discussing TeX with a friend earlier in the day and guess I got my wires crossed
It's not an intro.
Dasgupta, Papadimitriou, and Vazirani is a decent introduction that has the advantage of being free: http://algorithmics.lsi.upc.edu/docs/Dasgupta-Papadimitriou-Vazirani.pdf 
That's how you let the front-end people know that this is not their house. 
I already lost my keys so I'm not afraid of losin em hehehe
 int main() { while (test()); return 0; } int test() { int x; (void) printf("%i\n", x = rand() % 100); return x ? 1 : 0; // can get unreadable really fast } As long as x == true != 0, it returns 1. If x == false == 0, it returns 0.
"Algorithm Development and Program Design Using C by Gary J. Bronson" This is the most thorough book I've ever seen on programming. This is hard to find unfortunately. I found this treasure at a thrift store. 
This sub is for C, not C#; try /r/csharp instead.
I'm programming an STM discovery board - using an ARM Cortex Chip at university.
I had hoped to do as you stated from zero all the way to 25 (E.g. 0.1, 0.2..... 24.6, 24.7). I will modifying the variable using the push buttons as stated to increase/decrease by this "tenth" or 0.1 but it does not need to be wholly exact as it will be referencing another floating value and simply need to provide a threshold for an alarm to be activated (by polling the referenced floating value). Using a floating value, would the same outcome not be achieved? It doesn't need to be exact but functional for demonstration. As stated previously by Daelon, would this not NEED to be a floating value due to the nature of an interger being a whole number.
That looks very interesting, thanks!
Why, because it does not start off with directly applicable examples, but builds up to them from the basics?
So you're not even through an Intro2programming first semester CS course. That's bot decent.
A sorted linked list feels a bit weird to me. A binary tree is a much better if you need to search, or insert/remove retaining order. Also works well to retrieve or walk through items in order.
I didn’t made the problem, just coded that answer, because the one given in the previous post was awful.
Write your own memset.
That's a non-solution. The root cause of the issue is due to an optimisation called dead-store elimination. If the compiler doesn't detect any loads after writes and deems there is no change to the observable behaviour of the execution then it can simply optimise away the writes (which is what any equivalent memset implementation will do.
On GCC+glibc systems in particular, you can combine [`mlock`](https://www.gnu.org/software/libc/manual/html_node/Locking-Pages.html) (to ensure you've got unswappable memory) and [`explicit_bzero`](https://www.gnu.org/software/libc/manual/html_node/Erasing-Sensitive-Data.html) to get most of the way there. That last link echoes the caveats from your links.
&gt; The wrapper he named memset_s is apparently actually defined in the new C11 standard. But I'm not sure that gcc is implementing C11 yet? ​Bad news. It is specified in the _optional_ Annex K of the C11 standard. So you cannot rely on it if you want portability. &gt; So what approach would be best? Turning off optimization, using a volatile type and a memset_s wrapper, or using memset_s from C11? The volatile approach seems popular. This is the approach used by [tarsnap (from the same author of the blogpost)](https://github.com/Tarsnap/spiped/blob/5c13832aeecdad8a655dadcf5413cc504ad99e49/libcperciva/util/insecure_memzero.h). It is also the fallback approach in [libsodium](https://github.com/jedisct1/libsodium/blob/master/src/libsodium/sodium/utils.c#L103). A good survey of methods can be found in this paper: [Dead Store Elimination (Still) Considered Harmful](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf).
Not a problem if your `memset()` replacement is out of the optimizer's scope when you call it. When compiling your `memset()`, the compiler doesn't know that the memory it sets is not used after the call, and when compiling the call (where it *does* know that the memory won't be used again), it doesn't know that your `memset()` does not have other side effects.
gcc is a C compiler. It's not the C compiler's job to implement Annex K; that's firmly the job of the standard library. And to be honest: Annex K is a steaming pile of shit for the largest part and is likely going to be thrown out soon.
C# is off topic in this subreddit. Please post C# content to /r/csharp instead.
Writing your own memset means having it read back what you wrote, so that it forces it to write.
Simply reading what you wrote doesn't help as it is still dead code that leads nowhere. Instead you can make the compiler to just [not elide the store](https://github.com/google/benchmark/blob/47a5f77d754892f20b8c717ead26de836e0bb552/include/benchmark/benchmark.h#L315). `asm volatile("" : : "r,m"(value) : "memory");` doesn't actually read the value, produces not actual instructions but keeps `value` around.
Um, no. TAOCP was written by Don Knuth, who for all his accomplishments (including the creation of TeX) is definitely not a creator of C; C was created by Dennis Ritchie.
Your second example is EXACTLY the same as the OP though. You're not defining the 0xFF00 (of 0xFFF0 since you don't seem to be using the same value in both examples) separately as ACIA_STATUS_REGISTER_ADDRESS which is what the person I'm replying to is suggesting.
The behaviour of this code *undefined.* What it exactly does cannot be said in general and the behaviour might change every time you compile. It could even happen that little dæmons fly out of your nose when you compile this code. Don't write this kind of code. 
Printf("%d%d", i,j); will give the output of 100 200. You need to specify variables in the order you want them to be printed in the printf function.
i think you must specify what you want to print, like: printf("%d %d", j, i);
&gt; Simply reading what you wrote doesn't help as it is still dead code that leads nowhere. That's interesting, because it worked just like I imagined: https://www.dropbox.com/s/jfa66jjcjo55mf8/h4x0rm3m537.png Here's the code (-O2): https://pastebin.com/9KqSWh4T 
Let us c It is an amazing start for begginers
You are printing unintialised memory and don't get what you think you are getting. (on my Linux I get totally different results). If you dump your code into https://gcc.godbolt.org/ and inspect the assembly you can see that the compiler elides the call to memset. It even removes your mynull if it is static. Because these things are hard to explain in writing, you might want to what this recent presentation on the topic: https://media.ccc.de/v/35c3-9788-memsad
Because most people who have read it reported that it was very difficult if you didn't have past experience with the subject. It's more of a reference book than a text. And some of its exercises aren't even really meant to be solvable. Unless your intent is to set someone up to fail, it's a bad suggestion here.
Will check it out for the use of double pointers (which still confuses me a bit), though as mentioned, qsort and linked lists go together like pb &amp; mayo, lol!
What do you think the problem is with memset being optimized away? ...h4x0rz can snag private/sensitive information off the stack, just like the functions in my example. Nevermind, you are just another MIT n00b.
Your code is all garbled. Are you sure this is correct?
It could be that i have changed so much that it is all messed up
No, I mean you did something wrong uploading the code to reddit; there are random backslashes all over it and `student.name` has been turned into a link.
Different compilers and configuration options are are suitable for different tasks. Rather than trying to define everything necessary to make the compiler suitable for any particular task, the Standard defines a set of baseline set of semantics and allows implementations to provide whatever additional semantics they need to accomplish whatever tasks they need, based upon the Spirit of C, which the authors of the Standard described, in part, as "Do not prevent the programmer from doing what needs to be done", never expecting that compilers might throw the Principle of Least Astonishment out the window. From a practical perspective, the most efficient way to do a non-optimizable `memcpy` for a non-trivial number of bytes is probably something like: void *(*volatile_memset)(void *s, int c, size_t n) = memset; that would require one extra volatile read per entire operation. The Standard wouldn't forbid an implementation from replacing `volatile_memset(secret_data, 0, 256);` with { void *(*__temp)(void *s, int c, size_t n) = volatile_memset; if (__temp == memset) memset(secret_data, 0, 256); else __temp(secret_data, 0, 256); } but from the point of view of the Standard it's no worse at protecting data than anything else one could do. Even if one had a perfect `volatile_memset` function, the Standard would allow the above to be replaced with { send_data_to_enemies(dest, 256); volatile_memset(dest, 0, 256); } provided that the call to `send_data_to_enemies` was not regarded as an "observable" side-effect (for a capricious implementation, it wouldn't be observable). 
I think new reddit strikes again, it really doesn't handle pasting code in well.
Seriously, how hard is it to embed a markdown editor? Quora does a decent job.
Put your code on github gist
Modern C had a section going over c coding styles. Depending on how you code now, it can be triggering, but is a good read. For example if you declare a pointer char *ptr, it can take some getting used to. 
Is this for personal use or something else? A link to an updated standards is (here)[https://ntrs.nasa.gov/search.jsp?R=20080039927]. And that original from NASA's actual site is (here)[https://ntrs.nasa.gov/search.jsp?R=19950022400].
Ah thank you!
I'm not hugely interested in style guides as most companies have their own to some extent and I don't think there's anything in the NASA style guide that's revolutionary or vastly different to other style guides. Something I did find interesting though, was the NASA Software Safety Guidebook ([https://standards.nasa.gov/standard/nasa/nasa-gb-871913](https://standards.nasa.gov/standard/nasa/nasa-gb-871913)). There's a lot of info in there, and I haven't read it all, but there's plenty of useful parts on how to develop mission critical systems, at least from a high level (e.g. requirements, reviews, etc...). If you're interested in space, there's also a book written by Jeff Eickhoff who works for Airbus called Onboard Computers, Onboard Software and Satellite Operations: An Introduction. Pretty high level again, lots of information on documentation, project structure, etc... None of these are specifically targeted at C, but are interesting reading regardless.
Yeah, that separation between normal variables and constants by naming convention is a great improvement I think. 
Thanks! I love this sort of info. I Googled that book and it appears pricey, looks like an interesting read though.
Arent constants usually done all caps? Or is that solely for defines?
MISRA. Used in cars. Most if not all companies that develop embedded systems for cars use that guide as a base and then add anything else the client wants.
Yeah I wouldn't have bought it on my own but got it through work as a reference guide. It is high level and I'm not sure quite what I've got from it yet, but haven't gone through all of it. Probably more as a reference book when starting new projects.
I can't see where you read the `total_amount` thing. You init it with 0, than add `time_spent`, so it just equals the `time_spent`, so it actually reads only once... And if I were you, I'd add `\n` (or `\n\r` since you seem to be on Windows). to the end of `fprintf()` statement, or the input will mix up for different days, like `Time spent: 1.000000Time spent: 1.000000`
it's for defines usually, I think
Yeah, constants are and in the newer standard #define should be avoided except for conditional debug. But what I was thinking is that the "normal" way to name now is clearer than underscores in naming since they are generally for more special uses than common variables. 
Let me try that double pointer thingy. Here is the memory layout for the example: +-----+ | | | .. | +-----------+ | 42 | | list 80 +--+ | .. | +-----------+ | | | | | | +-----------------+ | | | | .. | | +-----------+ | 80 | +--&gt; data 5 | | 81 | | next 90 +--+ | .. | +-----------+ | | | | | | +-----------------+ | | | | .. | | +-----------+ | 90 | +--&gt; data 7 | | 91 | | next 0 | (NULL) | .. | +-----------+ | | | | +-----+ This is a linked list, containing 2 nodes, with the data '5' and '7'. First node is at address 80, second node is at address 90. The head of the list is stored somewhere (for instance, on the stack, at the address 42). Let's say you have a function that does something to a list, that may change the list pointer (for instance, it searches for all occurrence of some data and removes it). If you pass it a ```node *```, you will have an issue, because, if you call it with 5, you would need to update the list to point to the new list (ie: change the pointer in address 42 to 90). So, if you write code like: find_and_delete( list, 7 ); then, it will work fine with 7, but will fail with 5 (because, after the call, the list will still point to the deleted node at address 80) You have two ways out of this. One is to carefully update you variables, say by having ```find_and_delete``` return the new head (now at address 90) list = find_and_delete( list, 5 ); This is error-prone, if you forget to re-assign the list, the code will work, as long as the deleted element is not the first (and, as C won't erase content of free'd memory, it probably won't immediately crash, you code will behave like delete didn't occur, and will fail much later). Passing a pointer to the list variable, is much better: find_and_delete( &amp;list, 5 ); Have a nice day!
When I was learning programming, I didn't study it at all. I learned by taking an empty program that somebody had already setup, then tried to make it do what I wanted. If I wasn't sure how to do something, I'd google "How to output string in C" or whatever. Fast forward a few years and now I'm a professional! :)
Practice. Learn one thing and write tiny programs that use the feature you just learned plus some features you previously learned.
 void change(int* old){ int* p; p=old; // why not &amp;old? *p=400; } You don't use `&amp;old` here because `old` is already an `int*`. Taking the address of old `&amp;old` would yield an `int **` (pointer to pointer to int).
&gt;why not &amp;old? Because in the function parameters old is already declared as a pointer to an int, so no references are needed. old is declared as a regular int in your first code meaning you do have to get a reference to it in order to create a pointer.
A Book On C is not a bad starting place. 
You program...
I've now added a link that should be easier to read 
oh ok thanks a lot :)
O good need/motivation is all that you need. I didn't learn a thing during a specific course of C at university but I learnt a lot in another subject when I had to develop a code to simulate the trajectory of a rocket/missile.
You are naming two different things with the same name, which is confusing: int old = 257; old is an int. void change(int* old) old is a pointer to an int. Those are very different beasts. p=old; // why not &amp;old? Because in that code, old is a pointer to an int. The ```int``` is ```*old``` (you could do ```p = &amp;(*old)``` if you really wanted to confused everyone). If you rewrite ```change()``` as: void change(int* old_ptr) { int* p; p=old_ptr; *p=400; } it would be easier. Both p and old_ptr are pointers, because you took the address when you called ```change(&amp;old);``` ```
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct { char name[51], number[14], gender[7], program[50], age[4], email[100]; int roll; } student; // this runs into problems if your input is longer than the variables holding it student inputStudent(){ student stu; printf("\nName: "); fgets(stu.name, sizeof(stu.name), stdin); printf("Number: "); fgets(stu.number, sizeof(stu.number), stdin); printf("Gender: "); fgets(stu.gender, sizeof(stu.gender), stdin); printf("Program: "); fgets(stu.program, sizeof(stu.program), stdin); printf("Age: "); fgets(stu.age, sizeof(stu.age), stdin); printf("Email: "); fgets(stu.email, sizeof(stu.email), stdin); return stu; } void printStudent(student stu){ printf("\nName: "); printf("%s\n", stu.name); printf("Number: "); printf("%s\n", stu.number); printf("Gender: "); printf("%s\n", stu.gender); printf("Program: "); printf("%s\n", stu.program); printf("Age: "); printf("%s\n", stu.age); printf("Email: "); printf("%s\n", stu.email); } // forces user to input integer, pretty useful int integerInput(){ int in; char *end; char buf[1024]; do { printf("please enter an integer: "); if (!fgets(buf, sizeof buf, stdin)) break; buf[strlen(buf) - 1] = 0; in = strtol(buf, &amp;end, 10); } while (end != buf + strlen(buf)); return in; } int menuChoice(){ int choice, valid = 0; do { printf("\nplease enter a valid menupoint: \n"); printf("press [1] to add students\n"); printf("press [2] to search students\n"); printf("press [3] to exit the program\n"); choice = integerInput(); } while(choice &gt; 3 || choice &lt; 1); return choice; } int main() { int stu_max = 1000, stu_total = 0; student stu_list[stu_max]; int choice, running = 1; while(running){ choice = menuChoice(); if(choice == 1){ printf("\nhow many Students do you want to add?\n"); int stu_num = integerInput(); for(int i = stu_total; i &lt; stu_total + stu_num; i++){ stu_list[i].roll = i + 1; printf("\nRoll: %i\n" , stu_list[i].roll); stu_list[i] = inputStudent(); } stu_total += stu_num; printf("\n_____________________________\n"); } else if(choice == 2){ int roll; do{ printf("\nenter a valid roll number (there are a total of %i students).\n", stu_total); roll = integerInput(); }while(roll &lt; 1 || roll &gt; stu_total); roll--; printf("\n_____________________________\n"); printf("\nRoll: %i\n", roll + 1); printStudent(stu_list[roll]); printf("\n_____________________________\n"); } else if(choice == 3){ running = 0; } } } searching and adding should work, my testing was not extensive
Thank you for that!
Learning \*any\* language has a simple route. 1. Set up a minimal environment {an editor and a compiler/interpreter}. Make sure it is as simple as possible. 2. Have a couple of cheet sheets. Like [this](https://learnxinyminutes.com/docs/c/) one. 3. Just do random stupid things. Check [this](http://rosettacode.org/wiki/Category:C) one out for ideas.
If the program needs to only sort once (such as to print a report of what's in the list in a sorted order after other operations completed), then qsort can be used if the program first creates an array of pointers to the linked list elements, and runs through the array setting each pointer to the address of each list element. The array is then passed to qsort. The compare function needs to know that it's dealing with pointers to the list structure so it can use the internal fields for sorting. I've used this before if I'm getting data from more than one source of indeterminate size (such as two or more sql queries) and combining it into one list and then outputting it. It's easy to just attach the next one to the bottom (or top or whatever) of the list and then do the sort at the end.
I will also recommend The Power of Ten by NASA JPL. https://ieeexplore.ieee.org/document/1642624/
Seriously, write code. Start by hand copying examples in any book. Use a good editor (I like emacs for its c-mode) and become expert in it. Learn a debugger and use it to step through your code. My favorite beginner books are C programming: A Modern Approach, Modern C, and Head First C.
Well my approach changed a lot during the 20 years i am learning now (i should really stop and find some real work). First i just red books and it didn't work well - i red about everything and forgot most of it right away. At least i got the basics, after that i just programmed worked a bit better and i kinda figure most of the things out that i needed but i got kinda stuck on a skill level - not learning new stuff only using old things. What works for me nowadays is reading about C (a table of contents of a book or nowadays mostly online references) to find a topic that i'm not familiar with and than i just read about it until i understand what i can use it for and how to use it. Second step is writing an example implementation, usually something that doesn't take more than 20 minutes. Just something small to make sure i understand all the details. Usually i'll make some errors here and i have to reread parts of the documentation. At first i made notes about the topic to make sure i can check it later, nowadays i write lots of comments (especially about the parts i got wrong in my first implementation) and upload the code to my git repository. After that i force myself to use the new concept even if it make a task more complicated or doesn't make sense at all. If i red about sorting i will use a sort algorithm the next week 3-4 times to solve a real problem. Usually i just make a commit with the code i wrote and delete it later. But this is the crucial step, if i don't do this i will forget about it and i won't use what i have learned. But after forcing myself to use something 3-4 times it seems to find it's way into my permanent toolbox. This is the most efficient way that i found for me to not just learn and read about new things but to actually get myself to remember everything in my day to day work. In addition to that i google my problems to find other solutions which sometimes teaches me some new ways to apply something. And even if it doesn't i like to think about why the solution works and how it compares to mine (is it more efficient? is it easier to understand? is there something in it that i did not know about? ...).
Let us c is an amazing book for start learning c, I use websites like codeforwin for prgorams and i try to write the code by myself (99% will be error when compiling😂😂) and then look to the code to see how the way people think Finally i suggest to try to do multiple things like put a semicolon after for loop or if condition and see what will happen 
I’ve read it before, and enjoyed it a lot. That being said I don’t think it’s useful at all. Try it for your inner nerd and if it’s not for you don’t worry.
This. I took an introductory programming course (in Java), an intermediate course (in C), an OO course (in C++), used Verilog for a digital logic course, and assembly for half of another course. Aside from reading datasheets (like the man pages from the Bash terminal) and answers from StackOverflow, your greatest resource is programming to inspect the behavior of a specific language under a specific compiler.
Read it and decide for yourself? It's not that long and I found some elements useful but others may not. Usefulness is quite subjective. 
Taking an introductory class to learn the more complicated concepts like data structures and algorithms in C is a good idea, as well as reading up some references/manuals. The way I learned was with an intro class to start with then I just started making projects that were more and more complicated so that I learned more and more piece by piece. I think that’s the best way, to get a brief intro then learn by doing 
It's not terrible. On the one hand, that's a 25 year old document. On the other hand, C is close to 50 years old. While there have been some changes in style (e.g., now it's recommended that header files include any headers necessary for whatever they define, whereas you used to avoid that because the extra time preprocessing an include file multiple times was significant), general C style hasn't changed much, and that's as far as that document really goes. "Use good names" and "arrange and format your code in the language's idiomatic style" pretty much applies to every language. The only stuff that I consider really out of date in that document is the enormous box comments on every function. These days we have Doxygen and other tools, and syntax highlighting plus expectations of consistent style obviates the need for those giant box comments. Duplicating the name of the function in the function's docblock is pointlessly redundant, whereas documenting *what the function actually does* is now probably the single most important thing, which in 1994 they somehow thought was not necessary.
B+ Trees instead of binary trees if performance is important. They were invented for disk storage by adapting binary trees to work with pages of memory. Now that memory has fallen so far behind CPUs in terms of speed they look attractive even for in-memory data.
No, don't waste your money. Employers look for engineers that can solve real life problems and translate them into code... Everyone can code, not everyone can do useful things with it.
Maybe i dont understand your code right but how will it locate the student information if the program exits after adding a new student?
Wrong sub, mate. Also, no.
I've been a hiring manager, and I've never seen anyone ever even look at or consider those. Most of the time if you don't have a 4 year degree in Electrical Engineering, Software Engineering, or Computer Science, you won't even make it past the HR screeners.
MISRA is used widely throughout industry where you’re required to deliver high integrity C/C++. CERT is a similar standard. You might want to take a look at [mitre](https://www.mitre.org) 
This does not seem to be a C programming question
Not the creator of this, but I thought is was interesting and worth sharing,
Yeah...don’t do that. Save your money, but learn as much as you can from the course. I’m sure that course is a good stepping stone. I’m a fan of EDX. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
[Link to Modern C for the lazy](http://icube-icps.unistra.fr/index.php/File:ModernC.pdf). 
Read. Read. Read. Rationale: When you learned to read or write English (or whatever your mother tongue is), you started by reading what those who knew how to write it wrote. You didn't start by writing and guessing if the letters were correct. You're better off learning how to write good code by reading good code than muddling through writing your own bad code. It also teaches good style. Personally, I learned by reading the UNIX source code. My school had access to the UNIX (BSD 4.1, then 2, yes, I'm dating myself) source code. I learned C by first buying K&amp;R, so I would know what I was reading, then I would read source code. I'd print out the source for some program I was interested in (or some part of the kernel), and study it on my lunch break at work. These days, with so much open source code out there, and so much on github, it's a great time to learn code. Just find some well-reviewed repo (or the kernel if that's your cup of tea) and read, read, read.
It is now possible to use different compilers by setting the CC and CXX variables. &gt;Or did you plan your code to be easy for others to write drivers? This depends on how people will use bake. If a lot of drivers are going to be developed, it may be more productive to have a textfile (or some format other than C code) to write the drivers. &amp;#x200B;
It is quite different, actually. I just wrote a blog that highlights some of the features and should give you a better idea of what it does: [https://medium.com/@cortoproject/a-closer-look-at-bake-a-tool-that-makes-building-c-c-code-effortless-b2e0409fad8f](https://medium.com/@cortoproject/a-closer-look-at-bake-a-tool-that-makes-building-c-c-code-effortless-b2e0409fad8f) &amp;#x200B;
TBH, The C programming language is a great beginners books and you can get it really cheap on eBay. There are also a lot of e-books easily available online. 
As a rule of thumb, all threads you create have to be collected with `pthread_join` when they are done.
Ah okay so only index 1 onwards since I store the programs own pthread_t value at index 0 I guess?
I guess so. Though, it's a bit weird to store your own thread ID in this array. Seems overly complicated.
Yeah just for some debug reasons. Thank you! :)
&gt;I don't think there's anything in the NASA style guide that's revolutionary or vastly different to other style guides. This may have just been a rumor, but I thought I had heard that NASA had fairly strict coding guidelines to try to limit code complexity, such as limiting the number of if/else cases (or maybe if cases within other if cases), loops within loops, etc..
I have no clue what you're trying to do. total_amount will always be 0 when you add time_spent to it as you never assign it to anything else, so you will always just add the amount you put in to 0 which makes the addition rather pointless. If you want to read the total_amount from the file, you need to actually do that. You are also never calling the input() and amount() functions. In addition, you should sanitize your inputs as your program would behave weird if one were to input anything but a number there. 
Awesome, thanks for that second link. Looks like I can rely on OPENSSL_cleanse since my project is using it anyway.
I teach C by giving our students increasingly difficult programming tasks. Then they solve these tasks with supervision. Each task is designed to have no exact solution so the students have to think about what their program is supposed to do for themselves and come up with a reasonable interpretation of the specification. I believe that this is a very effective way to make teach people to think about program design. Another focus lies on teaching students to read manuals and do research on their own. In the first two days I pose a number of exercises the student has to solve by carefully reading documentation and man pages. I want to teach students to learn what kind of documentation is available and to intuitively rely on documentation when faced with a difficult situation. It is necessary to break some student's habit of asking the teacher the instant they don't understand something; in real life, there is no teacher you can ask and your colleagues are often as clueless as yourself, so you have to learn how to find out things for yourself.
Thank you
This is great!
It is lol from a c++ data structures class. 
Why do people not get this?
Only God himself, I meant Ritchie, knows this.
p is set to NULL, which means the boolean value of p is false. Thus !p has the boolean value of true, and the following conditional statement is executed.
Thanks! &amp;#x200B; Setting a pointer p to NULL, I thought it simply meant "pointer p points to nothing". If ptr points to nothing, how can it have a boolean value of false?
In C anything that is non zero is true, and because NULL is like the "zero" address it's considered false (I'm also relatively new to C myself so someone might answer this better than me haha).
See this https://stackoverflow.com/questions/2599207/can-a-conforming-c-implementation-define-null-to-be-something-wacky
See this: https://stackoverflow.com/questions/2599207/can-a-conforming-c-implementation-define-null-to-be-something-wacky
In C, the `if` substatement is not taken when the expression provided to the `if` statement compares equal to 0, otherwise it is taken. That's it. Furthermore the results of the `!` and `==` operators are either 0 or 1. &amp;#x200B; The NULL pointer compares equal to 0. Which means `(!p)` does not compare equal to 0, and also `(p == NULL)` also does not compare equal to zero. Both expressions are not 0 when p is the NULL pointer value, so the `if` substatement it taken.
Hint about the log n power function: x^4 is x\*x\*x\*x. But what if it was (x*x)*(x*x)? You can keep dividing long chains of multiplication in two, which leads to a log n complexity.
Same thing as “how do I get in shape?” They are looking to learn the “trick.” Unfortunately the trick is to just put in the work and accept it. Truth is repetition. I’ve recently learned about the phrase “insecure coding” and it’s helped me “just fucking go with it man.” I now just get past the stupid perfect variable name/function name type of dilemmas I used to agonize over. I wouldn’t have learned that if I was watching someone code, reading others code examples, or practicing mid numbing “toy” problems. 
In C NULL isn't a keyword, it's just a define statement in standard library. Usually something like `#define NULL 0` or `#define NULL ((void*)0)` so NULL literally is 0 in C, which translates to the boolean value of false.
Your answer is correct.
You are actually write. Though NULL is not like the "zero" address, it literally is defined as the number 0, like I explained in my reply to the comment you replied to.
Note that setting a pointer to `NULL` is not the same thing as having the pointer uninitialised. Indeed, setting it to `NULL` does initialise the pointer. An uninitialised pointer points to an unpredictable address and doing anything with its value is undefined behaviour whereas you can do anything you want with `NULL` except dereferencing it.
This!
return !test();
This is not universally true. C allows the NULL pointer to have other values. However, it compares equal to zero, so NULL==0 is true. So, really, "null is *like* the zero address" is a more accurate way of putting it.
Pointers are values on their own; even the value inside a pointer might be kinda "meaningless" (`0`, address higher than you have available, address of memory that belongs to other process... - so, you can't de-reference the pointer and find the value it's pointing), the pointer itself exists pretty well, takes some RAM (as all the variables do), and some operations (comparison, addition...) are available on it. This is good thing to remember when you work with double pointers (pointers to pointers, aka `void **` (and of course `int **` and so on))
What are the possibilities for adding cross compilation in the future? The embedded world could stand to benefit from a number of these features. I could see the complications added to your project by having to support the large number of different cross compilers out there, but it seems to me that you're already halfway there when it comes to arm-none-gcc support - which is used by a likely majority of modern embedded targets. &amp;#x200B; Thanks for sharing your work! You've clearly worked very hard on this
NULL is guaranteed to compare to 0, but it's numerical value could actually be unequal to 0. Does that necessarily imply that it will also evaluate to false? 
NULL is defined as zero
`return !test();` then. Also, `return x;` is not strictly equivalent to if (x) { return 1; } else { return 0; } is it? 
vcruntime.h of VS2017: #ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif So for C it's defined as `((void *)0)`, for C++ it's defined as `0`.
[removed]
 I suggest you try it on godbolt.org and check what the compiler(s) do in each case.
Correct. The if statement is technically throwing away the value of x in truthy contexts. Generally when I do this though, I only want to know it's not false. But you are right.
So using one of Intel's AVX2 instructions you *can* use `VGATHERDPS`/etc. to perform a load on a sparse array. It'll be faster than manually loading/shuffling, but will be a lot slower than a simple `MOVAPS`. So, you should still prefer to find a way to do SoA. I don't know if any compilers are smart enough to use this when doing automatic vectorization. You would need to pass the necessary compiler flags, at least.
There are two important C concepts you need to know to understand this: 1. The memory address NULL corresponds to 0x0 (or address 0). 2. Truthiness in C is a bit weird. 0 is false, and anything that's not 0 is true. It doesn't matter if it's 1 or -123. So, using point 1, and assuming `p == NULL` we can translate the expression `(p == NULL)` to `(0 == 0)`, which is true. Using point 2, we can translate `(!p)` to `(!0)`, which evaluates to 1, which is also true. Hope this helps!
i'd say the biggest problem here is the memory, since the arrays aren't nice and packed you probably have to optimize memory access to get the best out of this - not sure how much can be done in this case. My guess is even though simd would be possible it probably won't get you great results because of this (in both cases). 
A null pointer is always considered “false,” regardless of how it is represented.
Cross compiling would be exciting! To cross-compile to ARM, it could be as simple as configuring the correct compiler: ``` bake export CC=&lt;path-to-toolchain&gt;/bin/arm-none-eabi-gcc --env ARM ``` Then, if you want to use the toolchain, you could simply build your projects with: ``` bake --env ARM ``` That assumes that the command line interface of the cross compiler is the same as gcc. If it is substantially different, you would have to write a different bake driver for it. To give you an idea, this is what the current C driver looks like: https://github.com/SanderMertens/bake/tree/master/drivers/lang/c
The "manual" version shouldn't work either, because you never actually allocate any of the nodes in the list. You have to allocate each node with malloc before moving to it.
you need to allocate memory for nodes of linked list 
First of all, you use \`struct node\` \*before\* the typedef finishes; I'm not sure that'll work, actually. &amp;#x200B; \`typedef\` and \`struct\` are separate statements, in fact. 'Classical' version would be like &amp;#x200B; \`\`\` struct \_node { struct \_node \*next; int val; }; &amp;#x200B; typedef struct \_node node; \`\`\` If you want to use \`typedef\` with \`struct\` at the same time, I think it should be \`\`\` typedef struct \_node { struct \_node \*next; int val; } node; \`\`\`
So like if I'm making a video game -ffast-math should be good?!
The key here is to always benchmark. In essence, you're missing the point of SIMD, and it's also why the compiler will likely refuse to vectorize your code. After all, it's still a technique highly reliant on data locality, just like every other load optimization. Try compiling it with `-O3` and check the assembly on gcc.godbolt.org However, it probably doesn't matter. It can be the case that your 10k elements are just of primitive data types. But if you're trying to learn, do it. You'll probably be doing it by hand using intrinsics. It'll almost certainly end up being slower than using standard -O2.
Thanks! (!0) evaluates to one because it is zero factorial?
Because the definition of `!` is: &gt; `!E` is equivalent to `(0==E)` and the definition of `==` where one operand is a pointer and the other operand is the integer `0`, is to test whether the pointer is null or not; and the result of `==` is always `0` or `1`. You can look these rules up in the C Standard.
`NULL` is a macro, not a memory address. Also, a null pointer does not correspond to any memory address. It represents a well-defined state for a pointer, which is different to any case of pointing to a valid object. `3 == true` is false so I doubt your claim that anything not 0 is `true`.
The (!0) actually expands to (0 == 0). More specifically (!E) expands to (E == 0). The == returns 0 if unequal and 1 otherwise.
A linked list is a dynamic structure, meaning it is created during the runtime of the program. Other languages handle the memory allocation for you, however in C you must do this yourself. typedef struct node { void *data; struct node *next; } node; typedef enum { OK, ERROR } status; typedef node *list; node * allocate_node (node **return_node, void *data) { node *new_node = (node *) malloc(sizeof(node)); if (new_node == NULL) { return ERROR; } new_node-&gt;data = data; new_node-&gt;next = NULL; *return_node = new_node; return OK; } status list_prepend (list *l, void *data) { node *insert; if (allocate_node(&amp;insert, data) == ERROR) { return ERROR; } insert-&gt;next = *l; *l = insert; return OK; } int main () { list l = NULL; int *data = (int *) malloc(sizeof(int)); *data = 1234; list_prepend(&amp;l, data); list_destroy(&amp;l); } Of course, since you have allocated memory, you must also deallocate/free the memory. void list_destroy (list *l) { if (*l != NULL) { list_destroy(&amp;((*l)-&gt;next)); free((*l)-&gt;data); free(*l); } } Welcome to C, my fellow masochist. &amp;#x200B; (WARNING: I have not checked if this code works)
Would be a good idea to also compare their effect on cache: `valgrind --tool=cachegrind`. AVX2 may give you x8 the throughput by working on packed integers in parallel, but accessing main memory costs you x100 more than L1. So one should optimize for memory access first.
It depends on what you're doing. You probably *don't* want to use it if it's a multiplayer game where different clients must agree on physics simulation results. Different builds will compute slightly different answers for the same inputs. Some single players game engines can record a play session by tracking only the PRNG seed and a precise series of all the player's inputs. With `-ffast-math`, different builds probably couldn't play back each other's recordings due to accumulating differences in results. If it's just for graphics, then go ahead and use it. The differences almost never matter. Even different OpenGL implementations won't necessarily render the exact same pixels — and, in fact, this is exploited via WebGL for fingerprinting a web visitor's specific hardware configuration. 
You can install gdb and valgrind with homebrew or macports. It is easier. Valgrind is not much needed these days, I believe. AddressSanitizer is good enough and much faster.
You could always dual-boot linux. I'm running Ubuntu next to macos and just switch between the two for whatever I need. 
No you cannot install them on Mojave. I was able to install gdb on Mojave, but it was not feasibly instructionable. There are too many variables that will alter the steps of the method to install. I don't think you can install valgrind at all as of today. I have to tell several dozens of students to set up the enviornment. The easies way is to have them use linux on VM, but it requires them to learn emacs/vim. But installing linter on emacs is not even easy.
I just listened to an embedded.fm podcast where james grenning advocated for cyber-dojo as a cloud c dev environment to limit set up for classes. I haven't used it but he definitely knows what he's talking about.
Nope! It is universally true in standardized C. In C source code, the `NULL` macro is always `0` (or `(void*)0`). Section 6.3.2.3 Pointers: &gt;3. An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. 55) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. Footnote 55 referenced above: &gt;55) The macro NULL is defined in &lt;stddef.h&gt; (and other headers) as a null pointer constant; see 7.17. Section 7.17: &gt;7.17 Common definitions &lt;stddef.h&gt; &gt;1. The following types and macros are defined in the standard header &lt;stddef.h&gt;. &gt;3 The macros are &gt;NULL &gt;which expands to an implementation-defined null pointer constant So `NULL` in code is always `0` (or `(void*)0`). Note that implementation-defined means it could technically be something like `(8-8)` but that's still an integer constant expression with the value 0. There are indeed architectures where the "null pointer" is not at 0x0 (or with a non-zero segment), but it is up to the compiler to interpret that as needed. Keep in mind this interpretation generally only applies to explicit assignments of `0` or `NULL` to the variable (`ptr = NULL;`). This is evident in the standard section on the `calloc` function. &gt;7.20.3.1 The calloc function &gt;2 The calloc function allocates space for an array of nmemb objects, each of whose size is size. The space is initialized to all bits zero. 255) Footnote 255 referenced above: &gt;255) Note that this need not be the same as the representation of floating-point zero or a null pointer constant. So setting bits of a memory location without a typical pointer assignment might not trigger that "use the actual null pointer value for this architecture" behavior.
You actually gave me a hint. I checked Coder.com which uses the vscode plugin and found that no gdb or valgrind were installed. But I just went there now and tried to install gdb and valgrind and I could install them, and use them. So, this is probably the best method. I also found that cs50 has their own IDE that works very well except that the IDE feels tiny bit sluggish. The only way my method has over them is that my suggested setup is local.
Yeah, you can, but I consider that's over what I can ask my students to do.
Students can use `nano`. It's waaay simple, but most of 18-20-years-olds just always type the notepad way actually, I think; so just `ssh`-ing into Linux server with `nano`, `gdb`, `gcc`, `valgrind` might do the trick. But if a student run VBox locally, can't he have his graphics inside it?...
Out of curiosity, did you manage to get gdb to actually work? After following the magic incantations to get gdb signed, i compiled a simple C program with debugging symbols and I get the following: $ gdb ./d GNU gdb (GDB) 8.2.1 [...] (gdb) break main Breakpoint 1 at 0x100000f66: file d.c, line 5. (gdb) run Starting program: /private/tmp/d [New Thread 0x2803 of process 85360] [New Thread 0x2603 of process 85360] During startup program terminated with signal SIGTRAP, Trace/breakpoint trap. 
gdb doesn't work on recent osx versions as unsigned binaries are crippled by the os. Other useful tools like clang's msan also don't work. OSX pratically no longer has first class support for C and can't be recommended anymore.
Nano, emacs, vim don't have a last resort to use mouse. I consider it as too complicated (subjectively). 
How did you install gdb? If with macports, what error messages did you get? I don't use Mojave, but on High Sierra, installing gdb takes &lt;1min. I was using valgrind all the time, but addressSantizer is mostly better these days.
you will, at some point, be forced to use a text editor in a terminal. I'd suggest picking one of these and getting comfortable with it, even if it isn't your main editor. 
Why does using linux on VM require them to learn emacs/vim? Can't you prepare a kubuntu (or whatever easy to use distro) of some sorts as VM? Alternatively, make a script that mounts a local folder to the server, that way they can edit the files using whatever editor they want, locally.
You need to use a set of correct options in compiling: gcc -g -Og myprogram.c -o myprogram It is something like that, but sure exact. Besides that, you probably needed to cosign the program and that's not trivial to figure out. I have Mojave and there is a way to make GDB run fine locally. It seems like it is not possible to install Valgrind at all as of now.
Yes, you can install them on High Sierra. But you can imagine I cannot make students downgrade from Mojave to High Sierra.
I want to avoid an excessive hacky way from my subjective judgement. Setting the dev env with Virtualbox, Valgrant with ubuntu is the standard acceptable setup. 
Thank you very much for your input. It seems like using [Coder.com](https://Coder.com) is the best solution. You can install gdb and valgrind on your container (they use docker?). I didn't know you can do that. You can essentially use vs code there. The collaboration functionality will be possible very useful. It's free to use unless you want to speed up some process for commercial production, but totally overkill if you just want to compile a few of C files for teaching purpose.
It's the bees knees. Protocols are the cool handshakes if the internet. You should read the history of the internet beginning with start of Arpanet - [Where Wizards Stay Up Late](https://www.amazon.com/Where-Wizards-Stay-Up-Late/dp/0684832674/ref=mp_s_a_1_1?ie=UTF8&amp;qid=1546742913&amp;sr=8-1&amp;pi=AC_SX236_SY340_FMwebp_QL65&amp;keywords=where+the+wizards+stay+up+late&amp;dpPl=1&amp;dpID=51ZUxfxpJ3L&amp;ref=plSrch)
Psst, Valgrind also runs on Docker for a leaner approach!
didn't they finally block user mode address space remapping? Valgrind needs 0x00000000 to catch null pointers, just as SheepShaver needs it to do it's 1:1 memory map of a PowerMac.
lldb works nicely, though!
Ok. I concede. Although macports installs gdb, it doesn't work out of box. I have only been using lldb. Its basic functionality is similar to gdb.
TBH, tools not working on the standard distributed operating system means that you should find new tools, not that you should be hacking around in a million ways to make your way work. asan, dtrace, `/usr/bin/leaks` will be fine to replace valgrind. lldb will replace gdb. clang will replace gcc. You REALLY should not be focusing on what's easiest to you as the instructor if it makes your student's lives much more difficult. 
Just be aware that RFCs cover everything from jokes and experiments, through historic memoranda, up to actual in-use standards. Mark Nottingham's [How to Read an RFC](https://www.mnot.net/blog/2018/07/31/read_rfc) is worthwhile reading.
Of course we should. Otherwise, you are taking their important time out of their life. It's not like what you offer is the most valuable thing for them. That's a very arrogant way to think. We should be guilty if we don't provide something valuable to them. Setting up the programming environment could take a days and reset up takes 2 hours every single time. That's not acceptable. They have other things to learn as well as other things to enjoy. 
Programmers implementing software whose functionality falls within the domain of various RFCs should certainly be trying to ensure that they adhere to (or at the very least, not contradict) those RFCs, or else have very good reasons for not doing so. On a far less serious note, you might be interested in [the April Fools RFCs](https://en.wikipedia.org/wiki/April_Fools'_Day_Request_for_Comments).
That link is great - bookmarked. Thanks!
You're not setting the `list` variable on main(). When you call print_linked_list(list), you're passing in an indeterminate value.
None of your business.
&gt; You need to use a set of correct options in compiling: gcc -g -Og myprogram.c -o myprogram That's what I did originally. Same issue still. I find lldb completely unusable for debugging curses program since there's no way to reset the terminal after a crash. Anyway thanks. 
A few things: *As written, you're passing a *copy* of your list pointer to the function, not the pointer itself. When you allocate memory inside that function, you're doing so to a different pointer variable that has scope limited to that function. The function ends, the variable(s) go out of scope, and now you cannot access that memory. The memory, however, remains allocated so you now have a memory leak. If you want to allocate memory inside a function, you either need to add another layer of indirection by pointing to the pointer that you want allocated (so your argument will become a type node **), or you need to return a pointer from the function to the memory you have allocated within. **Note** dereferencing an uninitialized pointer is undefined behavior, so if you attempt to assign the parameter to another variable (i.e. node * current = *head), this will not work. Keeping the current style, you would need to allocate first (**head = malloc(..etc)) and then assign that first node to 'current'. *The way your code is set up current-&gt;next is NULL, meaning it does not point to a valid piece of memory. You're trying to allocate memory to nothing. I am unsure whether this is undefined and a memory leak, or if malloc simply does not allocate memory. In essence, your loop is not traversing down a tree of memory locations. void enum_linked_list(node **head, int len) { int n = 1; node *current; *head = malloc(sizeof(node)); current = *head; for(n ; n &lt;= len; ++n){ current-&gt;val = n; current-&gt;next = malloc( sizeof(node)); current = current-&gt;next; } }
Thanks!
Then why don't you use clang+asan+lldb, the official toolchain on Mac? For basic commands (e.g. b, p, l, n and s), lldb is close to gdb.
Another approach is to run a C toolchain in a Docker container, see for example (the linked article uses a C++ example, but it should work just fine for C) https://blogs.msdn.microsoft.com/vcblog/2018/08/14/c-development-with-docker-containers-in-visual-studio-code/ . You should be able to edit C files, compile, debug and run your C code.
I think that's hacky. It also has to be as standard as possible.
Yeah, I think it works and works as a local development. Students just have to copy the same Docker image. I think Coder from Coder.com is nicer (online) after having spent some time looking at it. It is snappy enough. The collaboration functionality may be very useful.
What do you mean by data inside a file? 
For example a string in a .txt file. 
Why hacky? Those are the *standard* tools on Mac. Your proposal is way more hacky. Coder.com is worse because it is even less standard. Your students wouldn't know the most basic: set up the environment. Also, coder.com is in public alpha. You don't know how it will change in future. It is a bad idea to depend on it. If you prefer vscode that much (I don't), you can set up vscode as a light IDE. You can compile, debug and launch terminal inside vscode, using the standard tools on mac. I have just tried.
You already have the file pointer which points to a file and you can have a struct containing the offset and maybe other things about the piece of data you want. If I understand correctly what you are trying to achieve is something like this `https://github.com/josephg/librope`
You should ask in /r/cmake
You're probably going to have to clarify your question somewhat. Are you perhaps asking about [memory-mapped files](https://en.wikipedia.org/wiki/Memory-mapped_file)?
Always const.
Constants refer to fixed values that the program may not alter during its execution. [https://www.tutorialspoint.com/cprogramming/c\_constants.htm](https://www.tutorialspoint.com/cprogramming/c_constants.htm)
Thx. i\`ll read that. One more questions. Is "constants" just a real number in this context?
"point data" doesn't mean anything in English when used in this context.
I mean a pointer assigned to some memory in hard drive, not in ram, using the pointer changing this memory or reading.
Anybody correct me if I'm wrong here... but you can't treat a Hard Drive like RAM. You cannot have a "pointer" to an HD location. Copy the file (or the relevant portion) to RAM and then examine it there, in RAM...
If you're on a UNIX based system such as Linux then have a look at [mmap](http://man7.org/linux/man-pages/man2/mmap.2.html). If you're on Windows I don't know what you'd use but you should be able to search for it.
Although it'll technically be using RAM at some point you can treat a file like a memory location with `mmap`.
I think it's misleading to say that we can treat NULL as zero because it's written zero. The 0 pointer in code is a magical constant, but that's a convention and the standard could've required it to be written some other way. What matters here is the rules around conversion of a pointer to and from an integer type. It doesn't convert to zero because the standard says we should write it zero, it converts to zero because the standard defines it as converting to zero. The concerns about calloc, etc., stem from this distinction.
You’re a programmer. You can teach yourself in less than a week and this no longer becomes an issue. If you want to work on servers you’ll have to learn one of those three anyway
I hate it when teachers do this. They think that by avoiding spending a few hours teaching you how to properly set up an environment that you are somehow better off. His solution is garbage, and your right, far more hacky. The fact that he calls the official toolchain on Mac “hacky” makes me wonder if he’s even qualified to teach C. That’s preposterous. His students will learn how to write code that runs _only in his class_, and will somehow be better off for it? What a joke. If setting up a basic compiler on Mac is too difficult, you shouldn’t be teaching them C in the first place. 
Start a background thread to do work. Use the main (foreground) thread to wait for user input. Set up a pthrrad_cond to tell the background thread to kill itself.
allocate_node returns the wrong type.
I can think of three basic approaches to this: * Polling. Periodically your program checks whether some input is available, and takes action upon it. This is not a good solution if your program is mostly idle; it only makes sense if your program is relatively busy most of the time. It might make sense in a simple game loop, for instance. * Using threads. You could dedicate one thread to user interaction, and some other thread to all the other things your program needs to do. There are quite a lot of gotchas with threads though. * Using an event loop. A single loop waits for and dispatches events within your program. A timeout expiring might be one event, as might receiving keyboard input. 
If you have a file pointer, does that mean the file is now in memory? Or do you have a buffer in memory that pulls and pushes data in and out of the buffer as you move the pointer? Something else? 
Sounds like this person might be better of doing it the old-fashioned way. If you don't know the basics, adding libraries just makes it worse.
That seems like bat practice, considering threads work differently for Windows and UNIX.
&gt; That seems like bat practice, considering threads work differently for Windows and UNIX. If you want portability, use a portable library.
Show your code.
Yeah, you're probably right.
Can't you just use VSCode on Ubuntu?
Opening the file doesn't read it. The act of reading the file transfers it from disk to memory (RAM). The file pointer tells the read command where to go on the disk to get that data you want to read. Well, you can't guarantee it's in memory. Optimization stuff gets weird, operating systems do things like read ahead on the reasonable assumption that when you start to read a file you will want to read the next bit soon. So it gets loaded into a page cache, then when you read the OS transfers it from the page cache portion of memory to the application portion of memory which is faster than a disk read, most of the time. You can't guarantee that it has been cached, or is still in the cache, because the OS makes decisions on this based on the full system load. For some new expensive disk designs some people feel that the delay of disk access has gotten so low that it is faster than the overhead of the page cache. So they have introduced DAX to Linux as a direct access option, which may become standard as disks continue to speed up. Which is all to say, optimization is hard, benchmark your code.
Please provide a complete program, sample input, and a detailed description of what works and what doesn't. By the way, that `break` statement is almost certainly a mistake.
Are you on Windows or Unix? Windows has pretty much all the equivalent threading capabilities as pthreads, you can even use pthreads with Mingw installed.
i am sending you a private messege
Sure. I charge 220 EUR / hr.
Since you're going to have to port the software from one GUI toolkit to another anyway, why not switch to a multiplatform toolkit such as Qt?
Feedback will be very much appreciated :)
i need litle help here is full code #include&lt;stdio.h&gt; #include&lt;string.h&gt; struct student{ char name[20]; int roll; int marks; }; main() { FILE *fp; struct student st[3]; int i; char srch[20]; char line[300]; int num1; printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d",&amp;num1); while(num1&lt;3) { if(num1==1) { for(i=0; i&lt;3; i++) { fflush(stdin); printf("Enter %i name:\n", i+1); gets(st[i].name); printf("Enter roll number:\n"); scanf("%d", &amp;st[i]. roll); printf("Enter Total marks:\n"); scanf("%d", &amp;st[i].marks); } } fp=fopen("test.txt","w"); for(i=0; i&lt;3; i++) { fprintf(fp,"Nmae = %s\n",st[i].name); fprintf(fp,"Roll Number = %d\n", st[i].roll); fprintf(fp,"Marks = %d\n", st[i].marks); } fclose(fp); printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d",&amp;num1); if(num1==2) { fflush(stdin); fp= fopen("test.txt", "r"); printf("Enter Record To Search:\n"); gets(srch); while(!feof(fp)) { for(i=0; i&lt;3; i++) { if(strcmp(st[i].name, srch)==0) { printf("Name = %s\n", st[i].name); printf("Roll Number = %d\n", st[i].roll); printf("Marks = %d\n", st[i].marks); fclose(fp); } } break; } getchar(); } printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d",&amp;num1); if(num1==3) { exit(0); } } } &amp;#x200B;
The common idiom is to use `#define`.
Start by indenting your code properly so you see its actual structure. Then ask yourself if the way you're prompting the user for which operation to perform really works as intended. Also, what happens if the user selects 2 the first time? By the way, this program does not correspond to the code you posted originally. That code had a marginally better chance of working.
Unrelated, but I have to say: coder.com is slow af, wow.
Please do not teach other people how to use C like this. 
on 1st time opening its works fine it search perfectly when i close the program then open for searching it does not work 
Its a bit hard to understand exactly what you mean but generally no. There is abstraction via the file/read API - you should not have knowledge of where in memory files are stored. 
You can set up a timer filedescriptor for the wakeup time, and epoll for both timer fd and STDIN_FILENO.
That doesn't answer my question. Based on reading your own code, not running it, what do you think will happen if the user selects 2 the first time?
Good effort! Some initial thoughts: the main loop looks far too long code-wise. Generally a function should be able to fit the length of a code editor window without one having to do any scrolling. So it would be good to refactor it into several smaller ‘helper’ functions...
Thank you!
1. Where is \`st\` located? 2. How is \`st\` populated with values?
thanks for the feedback! refactoring the code has been on my mind for quite a while. I guess I'll add that in the todo list as well
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Note that a copy still happens with memory mapped files, it's just that the operating system does that for you.
then it searches data from the file and returns to the user
No. Here is your code, properly indented and with a few labels added: #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct student{ char name[20]; int roll; int marks; }; main() { FILE *fp; struct student st[3]; int i; char srch[20]; char line[300]; int num1; prompt1: printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d", &amp;num1); while(num1 &lt; 3) { if (num1 == 1) { enter_data: for (i = 0; i &lt; 3; i++) { fflush(stdin); printf("Enter %i name:\n", i + 1); gets(st[i].name); printf("Enter roll number:\n"); scanf("%d", &amp;st[i]. roll); printf("Enter Total marks:\n"); scanf("%d", &amp;st[i].marks); } } save_data: fp = fopen("test.txt", "w"); for(i = 0; i &lt; 3; i++) { fprintf(fp, "Nmae = %s\n", st[i].name); fprintf(fp, "Roll Number = %d\n", st[i].roll); fprintf(fp, "Marks = %d\n", st[i].marks); } fclose(fp); prompt2: printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d", &amp;num1); if (num1 == 2) { fflush(stdin); fp = fopen("test.txt", "r"); ask_search: printf("Enter Record To Search:\n"); gets(srch); while (!feof(fp)) { for (i = 0; i &lt; 3; i++) { if (strcmp(st[i].name, srch) == 0) { printf("Name = %s\n", st[i].name); printf("Roll Number = %d\n", st[i].roll); printf("Marks = %d\n", st[i].marks); fclose(fp); } } break; } getchar(); } prompt3: printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d", &amp;num1); if (num1 == 3) { exit(0); } } } Now read it carefully and tell me precisely what happens if the user types 2 at the first prompt.
the problem is still not solved when user type 2 first time when he enters data then type 2 then it shows right data when user close the program then open the programme then type to then he can't get the result why? the data is saved in the file then the program must show the result
I didn't say anything about solving the problem. I'm asking you to describe exactly what happens if the user types 2, not by running the code but by reading it.
okay, when user types 2 it first enters data that he need to search from a file.
No. Read the code line by line. The program starts, the user enters 2. The first `scanf()` sets `num1` equal to 2. What happens next?
&gt; Go (short for Golang) Argh
okay lets explain everything when user first type 2 the he enter in search section first computer fflush his memory by fflush(stdin) that to enter enter character then **opens the file with read mode** the he enter the record that he need then computer r**ead the file from to bottom line by line then the loop will execute to search the data the by executing** if statement it compares the search data and the data that is present in file if it finds the data he will get the data back if not then close the file and break the loop
It's pretty snappy to me considering being online. edX cs50 has their own IDE and it is nice but feels like using atom. I can feel .01 second delay. 
No. You're not actually reading the code, you're just telling me what you think the code does based on what you intended when you wrote it. Read the code line by line.
: D We had to, don't you think?
I tried ubuntu server and ubuntu desktop on VM. Ubuntu server works very good with ssh but I really want to use vscode workflow and emacs/vim/nano doesn't have a mouse last resort. They also have a lack of decent linter/autocomplete. Well, they probably do but writing config or lisp is completely beyond their knowledge. Ubuntu desktop is so sluggish and I looked up posts on stackoverflow to turn on graphic acceleration and so on but I wasn't able to do it with 3 tries which means that I should abandon this route. I consulted several dev setup by other online courses for full stack dev and python dev and they tell students to use virtualbox and vagrant and let them use their image. So I think their setup and instruction is upper limit of what I think I can require them to do. Keep in mind that using VM itself is already strange concept for students. 
I consulted many other programming courses from CS department. They always go with gcc/clang gdb valgrind. I am trying to figure this out on Mac because windows does have the trouble that latest MacOS has. I guess I should've mentioned. I am not seeking the dev env only on Mac. I am seeking the dev env I want on Mac because the same setup on windows is not a problem.
what is my task in this code is there any mistake or any debug that i have to figure out what actually i do in this code
Yes, there are tons of mistakes in your code. I am trying to help you find them yourself, rather than just give you the solution. So start by telling me exactly what happens if the user types 2. Which lines of code are executed and what effect do they have in terms of variables set and input from / output to both the console and the file?
 1st bug i fix when user type 2 it prints again then get get input from user 
That is correct, but something else happens *before* that.
I didn't get any mistake in the any clue
So, if I understand the situation correctly, you [collected a few thousands dollars using empty promises](https://www.kickstarter.com/projects/1313324524/hermes-eudoras-next-generation) — something that you have suspiciously failed to disclose here. Then you twiddled your thumbs for a couple months — as there's no evidence whatsoever that you've done anything beyond cursory research on the Eudora source code. Then, finally, as the first Kickstarter deadline looms, you're desperate to find some suckers to do all the work for you, behind closed doors, on this supposed "open source" project. There's a certain irony in trying to build "Qualcomm Eudora for Windows into the 21st century" on SourceForge, the premier open source platform of the *20th century*. It's such [a garbage platform](https://en.wikipedia.org/wiki/SourceForge#DevShare_adware) that nobody who has any clue about what they're doing starts a new project on SourceForge in in this decade. 
FWIW if you decide to go the container route, I made a small bash script built around Docker that lets users jump straight into a Linux dev environment. [https://gitlab.com/DarrienG/lsh](https://gitlab.com/DarrienG/lsh) Just a \`./lsh\` and you're in assuming you have Docker installed. I made it for my girlfriend, but feel free to use it if you find it helpful!
I always liked clang's error messages. From my experience msvc is probably the worst C compiler. There's many reasons, but the most important is that it doesn't not support neither C99, nor C11.
&gt; I keep getting terrible errors What errors do you get? Without a detailed error description, it is impossible to say what went wrong. &gt; maybe an interpreter but I don't really know the difference An interpreter is a program that takes your code and executes it directly. A compiler is a program that translates your code into machine code so the computer can execute it. Python is generally interpreted, C is generally compiled. If your class uses Visual Studio, it's best to use that, too since Microsoft's toolchain has a few percularities that make it hard to compile code written for it with other compilers. If you want something easy to use, install *WSL*, the Windows Subsystem for Linux and use the C compiler `cc` (which is a variant of gcc) shipped with it.
Installing and worrying about which compiler to use is advanced problems and setting up a non default compiler can be confusing on it's own. That's why i'd say the Microsoft compiler on Windows and GCC on Linux, because they are the easiest to get working. And since dealing with errors is one of the most important skills for a programmer i'd recommend you to try and fix those error instead of running away from it.
1. The program prints the prompt and calls `scanf()`, which waits for input. 2. The user types `2`. 3. `scanf()` reads that number and assigns it to `num1`. 4. What does your program do after this? Line by line?
then check the while condition whether num1 is lessthan 3 or not if yes then it enters if condition
Why is that?
The language is called Go, not Golang. The word “golang” is used when an identifier for Go is needed but Go has already been taked by some other thing.
doesn't not neither nor... Let me help you. "...it doesn't support either C99 or C11"... 
You already know that `num1 == 2` after the `scanf()` call. So what, specifically, happens? Does the program enter the `while` loop? If so, does the first `if` evaluate to true or false? Does the program execute the code under the `enter_data` label? Where does it go next? What are the values of the variables (especially `fp`, `srch`, and the `st` array) at each point?
Thanks! I did type it in a hurry :)
Overall it's a pretty cool little program. I would echo the comments from /u/dr_j_ that `main` is too long. Generally, a good technique is to have some type of `struct` representing the state of the screen, and then write a 'render' function that just takes the `struct` and draws the whole screen from it. That way, you can separate out all of the rendering logic from the file handling logic. I also would add that while starting separate programs to do the file handling is not bad, you don't call [`waitpid()`](http://man7.org/linux/man-pages/man2/wait.2.html) to wait for the process to end. Meaning, your file manager spawns a bunch of `cp` or `mv` processes, and then returns or exists before they actually complete. If they end-up taking a long time, you won't be able to tell and might make the mistake of starting more then one process trying to use the same file, or try to do the same operation multiple times (Which may end badly). If you simply call `waitpid()` on the pid returned from those processes, you can ensure your process doesn't continue until that operation is done.
You wrong, you filthy sand nigger.
yes program enter the while loop no first if will not evaluate because at first if the condition is false, because the first if condition is false so the code under the enter data will not execute, if goest to second if condition the fp is pointer to open the file srch value will input vale from user to search the data and st is the structure array 
A brief refresher: when you have code like this: something(); if (condition) { handle_condition(); } something_else(); the computer will execute `something()`, then check if `condition` is true. If it is, it will execute `handle_condition()`. If not, it won't. Either way, it will then execute `something_else()`. So, in your code, where does the `if` end? What does your program do after checking if `num1 == 1`, which we already know is not the case? Please refer to my version of the code, which is properly indented. Indentation does not matter to the compiler, but it matters a *lot* to the human reader, so you should make an effort to always indent your code correctly. Most development environments or editors will do it for you if you ask nicely.
okay Thank you so much for helping me whole day Thank you so much next time i will try my best to write code user friendly. 
You didn't answer my question: &gt; So, in your code, where does the `if` end? What does your program do after checking if `num1 == 1`, which we already know is not the case? If you can answer that question correctly, you will have found the first major bug in your program, and I will show you how to reorganize the code to fix it and to avoid similar bugs in the future.
I think it's because the official website is https://golang.org
No, the author told me it's an intentional jab.
[This](https://imgur.com/a/5n1k3xN) is what happens when I type the code in exactly as the teacher as demonstrated. &gt;If your class uses Visual Studio, it's best to use that I plan on it, assuming that I can get it running correctly on my PC and laptop (both W10). Visual Studio seems like a big piece of software and it is quite intimidating. I feel like I could sit here for the rest of the day and not get it working correctly, which is why I am going to install it on my laptop and then ask the teacher about it tomorrow. In the meantime I thought that notepad++ and a compiler to run code through command prompt would be a good idea to get started with the textbook.
Linux.
&gt;And since dealing with errors is one of the most important skills for a programmer i'd recommend you to try and fix those error instead of running away from it. I understand that. [This](https://imgur.com/a/5n1k3xN) is what happens why enter the code exactly as the teacher demonstrated. &gt;E1696 cannot open source file "stdafx.h" I see this and I assume that it means that I have to download more stuff with the Visual Studios installer and when I look through it I have no idea what any of it means. I went through it and downloaded a bunch of stuff that looks like it relates to C but beyond that I don't know.
First of all, it seems like you are programming in C++. Second, please don't ever post pictures of code or error messages. Always paste the code or the error messages as text into your post so others can edit and cite them! The error message is quite clear. Error E1696 tells you exactly what it says: the compiler can't find `stdafx.h`. Have you added this file to your project? `stdafx.h` is not a standard include file, so you have to supply it yourself. Error C4326 tells you that `void main()` is wrong. If your teaches tells you to write `void main()`, he has no business teaching C. The `main` function returns an integer, so it should be `int main()`. &gt; Visual Studio seems like a big piece of software and it is quite intimidating. I think so, too. For this reason, I exclusively develop code in a terminal using command line utilities. &gt; In the meantime I thought that notepad++ and a compiler to run code through command prompt would be a good idea to get started with the textbook. Indeed it is! You can invoke the MSVC C compiler with `cl` if it's in the search path. This might need some fiddling to get right.
There is no facility in ISO C to do what you are asking. POSIX is your best bet for cross platform compatibility. 
You can put the terminal into non-canonical mode. [https://www.gnu.org/software/libc/manual/html\_node/Noncanonical-Input.html#Noncanonical-Input](https://www.gnu.org/software/libc/manual/html_node/Noncanonical-Input.html#Noncanonical-Input)
Maybe so but Wikipedia references golang with a citation to https://tip.golang.org/doc/faq#go_or_golang so golang is an official moniker.
in my program the first if end at line 41 just before the file open and second if ends at line 84 if i am not wrong i got the mistake if the first if condition becomes false then it open the file in write mode after execution this it will check 2 if condition
Pick up a normal c book. Skim through it, and if you see something you don't understand, read it over and do the exercises.
and apparently you've just made a mistake when creating the project in VS https://stackoverflow.com/questions/26330178/error-c1083-cannot-open-include-file-stdafx-h 
Once again, please refer to my version. I have not made any modifications to the code other than indent it correctly and add labels so we can more easily refer to specific points in the code.
[Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/~tjensen/ptr/)
It's not the name of the language. The FAQ says so: &gt; The language is called Go. [...] The language's name is just plain Go, regardless.
in your version of the code you have written save data promote what does it means
I would just say 'it doesn't support c99 or c11' (or 'it supports neither c99 nor c11').
Yes. Not disagreeing with you. Just on where the usage of golang came from and it's official usage (i.e. #golang.)
That's what I got and wrote it there. VM with virtualbox and vagrant allow you to use vs code locally and compile, debug and valgrind on ubuntu server within a shared folder. It is decently easy setup but it feels like you dont gain that much from going through the process over using Coder as of 2019. You dont really get to learn about setting up VM if you just follow the instruction to setup. 
These are labels. They simply identify places in the code. You can use `goto` to jump directly to a given label, although it is generally not a good idea, except in very specific circumstances. In this case, I added them simply so we could refer to places in the code by their labels instead of trying to count lines. The label `save_data` is placed right before the code that saves data to the file, and the `promptX` labels are placed right before each instance where you [prompt](https://en.wiktionary.org/wiki/prompt#Verb) the user for input. And again, please use proper punctuation.
I will definitely try that, maybe some time today. So does it have the latest ubuntu (18.04* LTS) and c/cpp and maybe java jdk?
I guess I can edit your docker file adding gcc gdb and valgrind and java jdk.
It's important to note that C has always been a collection of dialects than a single language, and interpretations have changed over time. There are many situations that commonplace hardware can process in useful and predictable fashion at no extra cost, but that might be impractical to support on obscure platforms. The Standard uses the same term ("undefined behavior") to describe actions which most implementations should process consistently and usefully (but which may cause some to jump the rails) as for those that few if any implementations should be expected to process consistently. According to the published Rationale documents, this was intended to encourage variety among implementations, and costs and benefits of supporting various behaviors on various platforms to be resolved by the marketplace rather than a Committee. Given a piece of code like: unsigned mul(unsigned short x, unsigned short y) { return x*y; } it would be logical to say that a compiler should treat the multiply as `unsigned`, but the authors of the Standard noted (in the Rationale) that on commonplace implementations the effect of processing the arithmetic as `int` and then coercing the result to `unsigned` would have the same effect *even when the result is in the range `INT_MAX+1u` to `UINT_MAX`*. There was no need for a rule mandating such behavior, because implementations would behave that way even without a mandate. In most cases, it would be cheaper for implementations to behave that way than to do anything else, and the value of behaving that way consistently was regarded as more important than the possibility of aggressively seeking "cheaper" alternative behaviors that would be allowed by the Standard. Thus, if gcc is given the above function, it will usually process it in arithmetically-correct fashion without doing anything unusual, but if it's invoked from within a function like: unsigned volatile q; unsigned q; int test(unsigned char x) { int i; unsigned long j=0; for (i=32768; i&lt;=x+32768; i++) { j+=mul(i, 65535); q++; } return j; } and optimizations are enabled, gcc will effectively replace the code for the function with: int test(unsigned char x) { q++; return 2147450880; } on the basis that when `x` is zero, the above code is cheaper than using any kind of loop, and when `x` isn't zero the Standard would allow the implementation to do anything it likes, including behaving as though `x` was zero. The dialects of C that implementations process with optimizations disabled are simple but powerful. Enabling optimizations adds complexity and will allow some tasks to be done faster, but at the expense of turning the language into a Heisenbug minefield. Functions like `mul` above will *usually* work, but may arbitrarily fail in ways that are essentially impossible to diagnose if one doesn't know in advance what to look for. 
If you haven’t grasped pointers, might be a bit optimistic to think of yourself as “intermediate”. 
Is it easy to share a folder with this setup between local mac (to use vs code) and ubuntu via ssh?
now sir can you tell me why data is not searched when we open the program again 
Please use proper punctuation, and please refer to the version of your program that I posted rather than your own, *especially* if you have made modifications that I can't see. Let's divide your program in two parts: everything above `prompt2`, and everything below. We have already established that the first part contains a serious bug: it will write data to the file regardless of whether the user entered any. Now, assume that the second half your program is 100% correct (it is not, by a long shot): what happens when you open the file to read from it?
It opens the file in read mode and get input from user to search data
I'm curious if Rust can make some real inroads in 2019 as well. Once I got past the initial learning curve (which was substantial for me) I've really fallen in love with the language. It actually delivers on the promise of "C like performance" without a lot of the gotchas, and offers a whole lot of modern conveniences. The last time I remember being so enamored with a language was when I first learned C. 
If you're on a POSIX system, you can use `poll()` or `select()` to do this. These functions will wait on a set of file descriptors for input, or timeout. #include &lt;stdio.h&gt; #include &lt;poll.h&gt; int main(void) { struct pollfd fds[1] = {0, POLLIN}; do { puts("This is a message."); fflush(0); } while(poll(fds, 1, 3000) == 0); } In the default "cooked" pty mode the user will need to hit ENTER (or type enough input to fill the buffer). If you want *any* key to work, you'll have to switch the terminal to raw mode, and then switch back when you're done to be nice. 
Still no punctuation. Don't they have punctuation where you come from? Are the comma and period keys on your keyboard broken? Please use punctuation, because it can be *very* difficult to understand you when you don't. &gt; It opens the file in read mode and get input from user to search data Sure, but what's in the file at this point?
&gt;If your teaches tells you to write void main(), he has no business teaching C. The main function returns an integer, so it should be int main() Does it matter if I say that it is ANSI C? Either way, thanks for the information. I'll keep working on it.
The data which is save in file new.txt. 
From the post-funding update, it looks like the OP already burnt through all the funding. $2k for visial studio licenses for the "developers". $170 per month for someone's mobile data, and the best part: &amp;#x200B; \&gt; Finally, because our team is scattered all over the world, I need a device to communicate with them; I found only one suitable for the task (the Cosmo Communicator), which I purchased for the princely sum of $840. &amp;#x200B; Either this guys is an idiot and massively unqualified to hold on to funds for an "open-source" project, or this is a straight up scam.
But what's *in* the file? When was it created, or when was it last written, and what was written to it?
ANSI C does not specify `void main()` either. Even in ANSI C, only `int main()` is strictly correct.
It was written by user by typing 1, and then user close the program, then it opens to search data, by types 2 
&gt; how to identify what y is, I am not sure what you mean. Could you elaborate? Also, it is very hard to answer questions about your code without seeing it.
Those are zombie processes too, so essentially a resource leak.
I'd suggest the book *Mastering algorithms with C* by Kyle Loudon. First few chapter serves great introduction to pointers.
Hey dude,first i'd recommend to you to read C Programming Language by Ritchie and Kernighan.This book is the best tutorial for you
post your code. ```c int a; ```
I disagree. I think functions can be any length.
[https://www.youtube.com/watch?v=Ps8jOj7diA0&amp;list=PLjn3WmBeabPOUzxcCkzk4jYMGRZMZ6ylF](https://www.youtube.com/watch?v=Ps8jOj7diA0&amp;list=PLjn3WmBeabPOUzxcCkzk4jYMGRZMZ6ylF) &amp;#x200B; This video series made me a better C programmer. It helped me think of programming in terms of memory and manipulating values at addresses. I think its good up to like video #7 or something like that, since he goes into some basic assembly stuff.
No. We already established that when the user types 2, your program writes *something* to the file. And since it did not ask the user for data, that *something* is... garbage. The code between the `save_data` and `prompt2` labels needs to be *inside* the `if`. Now you know how to fix the first major problem. I will give you the second for free: when you run your program and type `2`, you expect to be asked for a string to search for. But instead, you immediately get a new prompt. This is because you repeated the code that displays the menu and asks the user to select an option. In fact, you repeated it twice. So my next suggestion is to not only remove the second and third prompts, but remove the loop entirely, so you only do *one* thing each time you run the program. If you like, we can re-add it later; but for now, it's just an unnecessary complication. The result (plus a correct prototype for `main()` and the missing `return` at the end) looks like this: #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct student { char name[20]; int roll; int marks; }; int main(void) { FILE *fp; struct student st[3]; int i; char srch[20]; char line[300]; int num1; prompt: printf("1 for name:\n"); printf("2 for search:\n"); scanf("%d", &amp;num1); if (num1 == 1) { enter_data: for (i = 0; i &lt; 3; i++) { fflush(stdin); printf("Enter %i name:\n", i + 1); gets(st[i].name); printf("Enter roll number:\n"); scanf("%d", &amp;st[i]. roll); printf("Enter Total marks:\n"); scanf("%d", &amp;st[i].marks); } save_data: fp = fopen("test.txt", "w"); for(i = 0; i &lt; 3; i++) { fprintf(fp, "Nmae = %s\n", st[i].name); fprintf(fp, "Roll Number = %d\n", st[i].roll); fprintf(fp, "Marks = %d\n", st[i].marks); } fclose(fp); } if (num1 == 2) { fflush(stdin); fp = fopen("test.txt", "r"); ask_search: printf("Enter Record To Search:\n"); gets(srch); read_loop: while (!feof(fp)) { for (i = 0; i &lt; 3; i++) { compare: if (strcmp(st[i].name, srch) == 0) { printf("Name = %s\n", st[i].name); printf("Roll Number = %d\n", st[i].roll); printf("Marks = %d\n", st[i].marks); fclose(fp); } } break; } getchar(); } return 0; } With this version, if you type `2`, you will be asked for a string to search for, but it still won't work. And unfortunately, this part of the code everything from `read_loop` and on down is so wrong that I suggest you rewrite it from scratch. But first, write down *in English* and *in detail* what that code should do, step by step. You are not yet experienced enough to go straight from thought to code.
What class is it? Embed system or numerical computation from math?
You can watch cs50 first 4 lectures are about C. I am sure that's all you need to know for the course.
An attempt to indexing a null-pointer by a non-zero displacement will invoke UB in both C++ and C. Although C++ mandates that adding a zero displacement to a null pointer will yield a null pointer with no other side-effects, C implementations have traditionally behaved in that fashion, and such behavior would be more often useful in C than in C++, the C Standard does not mandate it and compilers whose writers who are more interested in what's required by the Standard that what would make their compilers most useful cannot be relied upon to support it. 
I would suggest getting *Understanding and Using C Pointers* by Richard Reese.
Pointers are not required to have any meaningful "numerical value", except that copying the sequence of byte values held in their associated storage into the storage associated with another pointer of the same type will yield a copy of the original pointer.
I'd take a int main(int argc, char *argv[]) { bool running = true; init(argc, argv); while (running) { if (get_input()) do_command(); tui_render(); } return 0; } any day over the mess that `main` is now. What if i want to decouple rendering from input parsing and command execution, for example the fm could have some animations that run each frame. It's easy to change this code to do multiple render steps. And `get_input` isn't tied to keyboard here necessarily, could be coming from network packets or even mouse events. Decoupling is good as it allows flexibility in implementation, as it can be seen here. And big monolithic functions are a coupling nightmare.
Thank you for the help!
The way this works, it automatically mounts your home dir. Try and run \`./lsh\` or \`bash lsh\` and it'll put you into a Docker container running Ubuntu with a few utils. But all of the files in your home dir will still be there (and will be the same between your container and mac). I made it so my girlfriend could program in XCode or whatever, but then compile the program using standard gcc or the like. &amp;#x200B; It's also really easy to use. Just run the executable and your terminal becomes a linux shell. I'd totally use it if I still used macOS.
Yeah, add them into the Dockerfile, and then when the user goes to run lsh, it'll automatically have it. Optionally, you can also just have your students apt-get whatever they need when they want to use it. It's full Linux, so everything still works :D 
It comes with most of the latest stuff. Some will be slightly outdated, but they're the versions that most people use. e.g. will have gcc/++ 8, can install JDK 8-12, etc. 
Yea, I think that is a good idea.
Shorter functions often correlate to a reduction in cyclomatic complexity. https://hub.codebeat.co/docs/software-quality-metrics looks to be a useful guide. Cheers.
Operating Systems
I actually meant "intermediate programmer" to mean that I have experience with programming in general (logic, conditional statements, control flow etc.) but it's just the specifics of C I need to brush up on.
Very good point, I forgot about that. To be honest, he's probably be better off just using `system()` unless he wants to learn the dark secrets of forking and process management and such (And maybe even signals!). `system()` will wait for the process to complete without him having to do anything. Unfortunately, he opens `xdg-open` via `exec()` as well, and that one's a bit harder to fix since he probably doesn't want to wait for it to close, so the solution is going to be a bit more complicated as you can't use `system()` here.
Yeah sorry for incomplete information but it is included in that way. But it seems compiler does not look for the upgraded kernel.
Functions should be long enough to encapsulate the task. No more, no less.
I have no way to help you with this little information given. Where did you put the altered header file?
Yes, they do. Well written long functions also correlate to a reduction in cyclomatic complexity.
It is in the directory usr/src but even if i give this way the usr/src/linux/memory.h looks for the old linux/memory.h
You have to change the header file of the linux kernel tree you are working on, not the one in `/usr/src`, unless you actually work on a source tree in `/usr/src`. 
Mostly I agree. Except in the case where you have many single use tasks. If you make all of those into a function then the people reading your code will get whiplash as they need to jump to each function to figure out what the program does. This is where a long function is useful. 
That's a tautology. It says nothing.
Hello everyone! Thanks for pointing that out! We'll modify so that there's no "confusion".
lol reddit shilling.
I don't see a problem then, unless you want your code to be cross platform. In that case all you have to do is learn the equivalent threading code on Windows, but I can assure you that Windows threads don't do anything too special compared to pthreads.
Udemy has an awesome advanced pointers class. Worth the ten bucks 
In theory, it's undefined behavior, because you're accessing uninitialized memory. In practice, it usually results in segmentation fault. What I suggest is to always initialize the struct, before doing anything else, even if it means explicitly setting the pointers to null. If you're using C99 you can "zero initialize" the struct with ` struct foo bar = (struct foo) {0};` This will ensure the pointers are null (and everything else is set to zero or something equivalent).
A good place to start is reading up on the scope of variables in C. These rules dictate what variables can be accessed, when, and how long they last. https://www.tutorialspoint.com/cprogramming/c_scope_rules.htm What you’re doing is declaring a local struct. The lifetime of this is just the lifetime of that function. This is why you can’t access it in main. To fix this, there’s a few approaches. You can declare the struct at the file scope by placing it outside of any function. The more “correct” way, I think, would be to change your initializer function to take a pointer to a struct. Then you can create the struct in main, and pass it’s address to the initializer function. You’ll have to change to the `-&gt;` to access the fields of the struct. 
Why can’t you use NULL as a default value for a pointer in a struct? Just make sure to set the value to NULL when allocating or creating an instance of the struct similar to how you would set an initial value for any other non-pointer.
I was just thinking in the case if I forget. by default I meant what the compiler gives to the struct.
I would abuse the preprocessor here to separate data from code: /* in pidvars-init.inc */ .setPoint = 0, .kP = 0, .kI = 0, .kD = 0, .enable = 0, .alarmLow = 0, .alarmHigh = 0, .alarmEnable = 0, /* in main.c */ int main(void) { pidVars_t pidVars = { #include "pidvars-init.inc" }; /* ... similarly for other structures ... */ } You could even go further and have `pidvars-init.inc` be generated at compile time from a JSON file or some other common config format using a scripting lang.
The compiler does not set up default values. The value is whatever is in that memory cell at the moment the compiler decides to use that memory for the structure.
&gt;This will ensure the pointers are null (and everything else is set to zero or something equivalent). Do you mean all the members of the struct are initialized to zero/null be it pointers?
This is really not relevant to your question. But what does a statistical computing in c course look like? I thought python/r/Matlab was what everyone else usef?
You can do `struct foo bar = {0};`, no need for the compound literal
OP, definitely don't do this. There are plenty of cleaner and more idiomatic ways to accomplish the same thing.
To make this concrete, here are two examples of ways to do this: File-scoped variable: ``` pidVars_t pidVars; void structInitialize(void) { pidVars.setPoint = 0; pidVars.kP = 0; // etc return 0; } int main(void) { structInitialize(); // use structs } ``` Pass-by-reference: ``` int structInitialize(pidVars_t * pidVars, globalVars_t * globalVars) { if (!pidVars || !globalVars) { return -1; } pidVars-&gt;setPoint = 0; pidVars-&gt;kP = 0; // etc return 0; } int main(void) { pidVars_t pidVars; globalVars_t globalVars; if (structInitialize(&amp;pidVars, &amp;globalVars)) { return -1; } // use structs } ``` I'd recommend the second option. It forces data use and modification to be more explicit by eliminating going variables. Additionally, it's a step in the direction of encapsulation and re-use.
Wow, gross. Please don't ever do this in production code for something that can be solved _so_ much better and direct than that.
Today is my project submission, i made a project of student's related where i get same issue so, i think i made another simple code -this code- where i can learn which actually problem is, but my project code is bigger than that code 390 lines code.
after a while, the pieces get too small and functions only complicate things. Plus it hides details where it far too often takes more effort to figure out what exactly a function does. (which is why I hate and don't fully trust function overloading). So yeah, I agree with you there.
If you end up going the route of making these file level (global) variables you should consider: - Using `static` so they're not exported by the linker - unless you need to access them in other c files - in which case it makes the decision to make them globals even more questionable. - File level (and all static) variables are, by default, initialized to all zero's. So, if zeroing is all you want, declare them properly and you're good to go. - If, even though you're zeroing, you feel it's better to have an explicit initializer, you can simply do: static pidVars_t pidVars = {0}; 
It's like numerical analysis but teaches C at the same time. In this type of course, the instructor usually doesn't specify what language students should choose or use Matlab but learning Matlab is practically useless in 2019, and I can supplement the course with video materials from myself or from youtube, or other online courses. It allows me to cover probably 40-50% more topics which is to learn C up to a use of pointer with good memory allocation/understanding. The topics covered will be (hopefully) sorting algorithms, hashing, numerical optimization (newton types, simulate anneling, EM algorithm, ), numerical derivative/integration, some sampling (Gibbs sampling, MCMC). Because it's a course for senior of math major, I cannot expect them to know a programming at all but they have a good understanding in the college senior level of math. So I can skip string/char manipulation which could be unnecessarily confusing. I can have them write a code in main() until I want to introduce pointer and have them write functions so that they know what they are doing in passing function to another function which is seen in a lot of optimization part. It is also useful to understand R under the hood. Many numerical techniques will be compared with R which can be run in command line on Linux or R/RStudio locally. I want students to be able to write codes to read data from file (fread() or getline() or something), and use array to store the data in memory and do something with it and write on another file as soon as possible. So I probably tell them to just write it momentarily at first so that they can start coding elemenatary statistics computation like mean, standard deviation, trimmed mean, some statistical test from scratch, some newton type optimization to gain some writing code experience before getting into the difficult topics. I don't have to cover linear algebra and dynamic memory allocation as they are probably taught in numerical linear algebra course. 
Some malloc's are excessively kind and free(p) will free the corresponding block even if the pointer is \_not\_ pointing to the start of the block but point into the block. &amp;#x200B; ie. If you malloc() and then free(), malloc() may re-issued that block of memory, and even if your old pointer is pointing at some offset into the block.... it will helpfully free it for you. Resulting in amazing confusion. &amp;#x200B; Debug malloc's and valgrind are marvellous tools. Especially valgrind. &amp;#x200B; If you're coding in C/C++ you can't really live without it.
Oh wow, that's quite heavy even just for the stats part. Add in C for people not experienced with it and I'm assuming the average grade of the class is going to be pretty low. Just implementing fourier transforms in C is a damn nightmare. I don't think you can really teach file handling without also going over Cstrings but that might just be me
yeah don't bother checking for NULL before free(); but do set things to NULL after you free them. (written ten thousand times on the blackboard....)
Because that's what casting syntax is in C. A cast expression has the syntax \`(type) value\_expression\`. In your code, \`char\*\` is the type, and \`ip\` is the value expression. &amp;#x200B;
Fast fourier transformation is probably HW assignment. I thought it's a good mathematics application to code. But they probably know how the foureir transformation works from other courses (differential equation) though while they probably don't know how to compute it. The problem with the introduction to the programming course is that the application they use is so not mathematical that it just doesn't do good for mathematical oriented students. First they don't have to know how FILE * f = fpen("input.txt", "r")... works. But I want, float x[n]; while() x[i] = num; filled so that they can do something with this data array in x. You can kinda see students can do quite a bit of things as long as they know how to deal with the a data array within main() using stack frame. But then once you want to use functions and want to pass arrays to functions, you need to start teaching pointers, but you can delay that quite a bit. 
To expand on this, remember that the memory allocator is just more code, and free is just another function. So what happens when you pass it bad input is totally dependant on the specific implementation of free(). In some cases the heap implementation may do error checking and prevent anything bad from happening. In others it may attempt add the pointer that you pass it to a free list, look aside pool, etc. It may also overwrite some of the data at offsets from the pointer you pass for storage of meta data. Some times it may even end up in a suscall releasing the virtual address, and subsequently the underlying physical address back to the operating system.
Get K&amp;R and check malloc/free implementation described there. Most implementations do something similar wrt pointers and block metadata. There are allocation schemes that use the pointer literally, as a key into some data structure, and never dereference it. Those can handle free(whatever) gracefully, but it usually comes at a cost of speed or memory efficiency. See for example mmap/munmap and the page tables they work on.
I can only help you with what's in front of me, and what's in front of me needs a ton of work. For starters, it never reads any data from the file at all.
This is a cool little program, and something I'm interested in contributing to now!
A JSON file is much more easy to change, settings should be kept in a settings file.
What better way? If i want to compile for some other platform where initial settings differ, i only need to change 1 file. I could have a bunch of config files one for each platform.
Wow! I would love to get some extra help on this
If I add `waitpid()` then the program will stop responding till the copying or moving is done, am i right?
I'll start working on implementing renaming of files when I have free time.
You have to rethink your architecture. You should aim for something event based because that's one the cleanest way to build a concurrent system. Right now both your `getch` and `system`/`waitpid` would block, so you couldn't wait for a file to copy, take user input, and render the screen at the same time.
can you explain how an event based architecture would be like? 
Can you write another code please, i am at University, i have only 30 mint please 
You're massively overengineering this. 
No. I am more than willing to help you find and fix the problems in your code, but I will not do your homework for you. And even if I wanted to, it would take me more than 30 minutes.
Okay thanks
So this a compact way of `cat watch -n t file`?
Right now it is, but I will add new features. Hell, the project could evolve into something else entirely.
Yeah. Trying to program something that already exists is not bad. A lot of programs start out that way.
Some compilers barf without the "cast".
Yes.
It uses a global variable, so it will just keep pushing the same struct over and over again. Every entry in the queue will point to the same global variable which will contain the values of `val1` and `val2` that were provided to the most recent `push_circ_queue()` call, although that is moot since `pop_cirq_queue()` never actually passes any values back to its caller.
you are referring to my latest modification. I have modified the code since I posted the question. I have solved the local and global problems, but I am now stucked with [system crash due to that modification](https://www.diffchecker.com/8qCqBFor).
&gt;pop\_cirq\_queue() never actually passes any values back to its caller. Why ?
You create a global array of pointers to structs, then try to dereference those pointers without every assigning anything to them. Note that the initialization is pointless (both in the old and the new version) since variables with static storage duration are already initialized to 0.
First, there is no “item struct”. There is a local variable named `item` which is a pointer to a `struct item`. After the call to `ptr_ring_consume_any()`, it will point to whatever the next entry in the ring pointed to, which is *presumably* a `struct item` (or would be if `push_circ_queue()` worked). But you never pass the values it contains back to the caller. The assignments on lines 89-90 have no effect. By the way, there is a race condition in `pop_circ_queue()` between checking if the queue is empty and fetching the next element. You should drop the `ptr_ring_empty_any()` call and just check the return value from `ptr_ring_consume_any()`.
No they don't. 
&gt;You should drop the ptr\_ring\_empty\_any() call and just check the return value from ptr\_ring\_consume\_any() `ptr_ring_consume_any()` return type is of `void *` . Checking this return value does not substitute the purpose of `ptr_ring_empty_any()` And why race condition between checking if the queue is empty and fetching the next element ? I am a bit confused understanding this statement &amp;#x200B;
What do you think about my [latest version of the code](https://gist.github.com/promach/65e9331d55a43a2815239430a28e29c6#file-circ_ring-c-L59-L110) ?
`ptr_ring_consume_any()` returns the next entry in the ring or `NULL` if the ring is empty, so there is no need to check in advance. Just call `ptr_ring_consume_any()` and check the return value. Since your code does not use any form of locking, there is a chance that another thread may consume the last entry in the ring after you checked if the ring was empty but before you get around to fetching the entry yourself.
It just keeps getting worse. Your code now uses about three or four times as much memory as if you had just implemented a circular queue from scratch, which is very easy to do, and it uses that memory regardless of how much data is actually stored in the queue. And you still haven't fixed `pop_circ_queue()`.
&gt;there is a chance that another thread may consume the last entry in the ring after you checked if the ring was empty but before you get around to fetching the entry yourself. I am implementing single-producer,single-consumer buffer. &amp;#x200B;
&gt;code now uses about three or four times as much memory Why ?
OK, so no race condition, but there is still no point in checking the ring before trying to consume the next entry. Just check the return value.
Post the code, not an image
The `ptr_ring` itself is 36 bytes on x86-64, plus 8 bytes per slot in the ring. I don't see where `CIRC_BUFF_SIZE` is defined, so I don't know precisely how many that is. In addition, you have two `struct item` per slot, one in `item_push` and one in `item_pop`. Each of those is 8 bytes. So your total memory consumption is `36 + CIRC_BUFF_SIZE * 24`. If you had implemented a ring buffer from scratch, you would have needed a single array of `struct item`s plus a head index and a tail index, for a total of `8 + CIRC_BUFF_SIZE * 8`.
&gt;The ptr\_ring itself is 36 bytes on x86-64, plus 8 bytes per slot in the ring. Why 36 bytes ? &gt;So your total memory consumption is 36 + CIRC\_BUFF\_SIZE \* 24 Why 24 ?
I was kind of wrong, but what I had in mind was [this gcc bug](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53119).
I had already implemented that (and bulk renaming). I just pushed the latest code, you can have a look at the updated TODO
Everything is explained in my previous comment.
&gt;It just keeps getting worse. Are you implying that some of my code modification leads to excessive memory use ? Could you roughly point out which portion of the code modification ?
I already have. And I have better things to do than argue with someone who won't listen.
Don't [delete your old posts](https://old.reddit.com/r/C_Programming/comments/ad3wg3/trying_to_take_input_from_the_user_while_also/) once you get an answer. It robs other people of learning, and it's rude to those that answered.
Do you happen to watch system logfiles? One of my favorites is a "syslog voyeur". All syslogds on of all my boxes are configured to send everything they see to a multicast UDP, and each "armchair box" sits on there and runs a scrolling log in a small window, in a small font :) of everything that happens that I should be aware of. Really love it. *.* @239.255.0.3:3000
`free` is just a library function. It doesn't know anything about your pointer. So it will do what it does with pointers which are allocated. The implementation of malloc/free in K&amp;R for example, allocates a header and then the data. Header is behind the data pointed by data. So when you try to the header, you will access garbage and anything can happen. For example, the header may contain the length of data allocated. If it's garbage (let's say a huge number, you know what might happen). 
https://www.sqlite.org/index.html
I'd use a flat text file with fixed length records. Use fseek to skip to the proper record, and read in the string.
Well conforming compilers that is. As a small note, gcc 4.9 on centos 7 sometimes warns you, requiring you to write horseshit such as {{0}} instead of {0}
That's true but shorter functions are far easier to maintain and read.
gotcha.
gotcha.
Do you have a debugger? Link with debugger and drop a bunch of break points and run to fail. When you walk forward or backward far enough to see the system crash you know your in the area. I’ll admit I don’t know what rwlock_rdlock is exactly but the process of locating the last instruction executed prior to system crash still probably applies.
They are the reader-writer locks in the pthread.h library. [here there are some info](https://linux.die.net/man/3/pthread_rwlock_rdlock)
With multi threading the challenge is much greater. I’m not intimate with the pthread stuff and I yield to someone who is more helpful. Good luck.
It may be worth noting that these issues are generally only relevant on compilers/configurations suitable for low-level programming, and which--unlike the `-fstrict-aliasing` configuration of gcc and clang--aren't too primitive to reliably recognize that passing the address of an non-`uint64_t` object to a function like `munge64()` in listing 4 may result in that object being accessed by that function. Functions like `munge64` may be very useful on quality implementations that treat the footnote of N1570 6.5p7 ("Footnote 88: The intent of this list is to specify those circumstances in which an object may or may not be aliased.") as an indication that they should not needlessly impose restrictions on code which does not involve aliasing as written. When using the `-fstrict-aliasing` modes of clang and gcc, however, any performance issues due to alignment will pale in comparison with the possibility that a compiler might reorder a call to `munge64` across other operations on the objects whose address it is given, turning e.g. uint32_t myArray[66] = {1,2,3,4,5}; munge64(myArray, 256); return myArray[0]; into uint32_t myArray[66] = {1,2,3,4,5}; munge64(myArray, 256); return 1; Note: I'm politely pretending that the `munge` functions in this example had done something useful in their loops like `*data64++ ^= -1;`, rather than `*data64++ = -*data64;` [where even the *intended* meaning isn't particularly clear]. 
Grepping for EDEADLK in the thread library, join, mutex and suspend pop out.
C does not have dynamic typing. If you want to do something like this, you have to implement it yourself.
I mostly disagree. If you are trying to read and maintain a program that has many small functions, you need to keep jumping between functions to understand the bigger picture. If you have several blocks of code that are only used once and that need to be run in a sequential fashion. Comment them well. Encapsulate them well. But don't put them each in their own function. Every time I have to scroll though the code to find the next function to read, it breaks my focus. If you want to make functions because the indent is too far or architecturally it makes sense, then that is ok by me. That being said. If you are new at programming or bad at it. Then yes, please create functions that are small.
You can try taking input as a string and then converting to your desired data type 
uh, so, a noob will have to implement a serialization library?
If you don't know what the data type will be, yet, use a stub data type: use text or an int and come back to it later.
niiggers are inferior vile disgusting stinky cockroach type creatures
If that's what they want to do.
For "could be any data type", there is void*. However, as others pointed out, there is no dynamic typing so you will have to store somewhere what data type the pointer is pointing to. 
One should learn how to write parsers sooner or later. If nothing else he will learn why there is probably a better non-dynamic solution to his problem.
SQLite is this exact use case.
A commen thing is to store what type it is, with an enum.
Given a declaration like `structType foo = {0};` a compiler is required to ensure that all objects within `foo` or any structures nested therein get initialized to the whatever values of their respective types would be represented by `0`. For integer types, that's integer zero. For `float`, `double`, or `long double`, that would mean floating-point zeroes of those types. For pointers, that would mean a null pointer of proper type. These guarantees hold regardless of the representations of the values in question. Implementations where all of those values are represented by a sequence of zero bytes may simply initialize the structure to all-bytes-zero, but implementations with unusual floating-point or pointer storage formats would be required to set the byte patterns to whatever would yield the proper values.
That only happens if you tell the compiler to initialise your structure though.
No "in theory" about it. While the Standard often used the term "Undefined Behavior" in circumstances where they expected implementations to define behavior *when practical* [some people seem to confuse that with "Implementation-Defined Behavior", which implementations are required to define *whether it was practical or not*], it is almost never practical for implementations to guarantee anything useful about the effect of passing to `free` or `realloc` anything other than a null pointer, a pointer to a block of storage received from `malloc()`-family functions, or possibly a limited range of implementation-specific pointer values that `free` will ignore as it would a null pointer. On some implementations, the likelihood that passing an invalid pointer to `free` would yield a segmentation fault may be higher than the likelihood of any other particular consequence, but limiting the potential harm from an invalid `free` is apt to be more expensive than limiting the harm from almost any other programming error. While there are some actions where the Standard imposes no requirements but some implementations will reliably either process them in a useful fashion or force an Abnormal Program Termination, an erroneous `free` isn't one of them. That falls into a category of behaviors which no implementation can reasonably be expected to handle usefully.
If you know all the types you want to store in advance, then you can use what is called a Tagged Union. For that, you will need a struct of a tag enum and a union together. C11's anonymous unions make this nicer as in you can access union elements "directly" from struct. struct TaggedUnion { enum {TAG_INT, TAG_FLOAT, TAG_CHAR} tag; union { int i; float f; char c; }; }; Now you store the value along with it's tag into it. Then read it after checking which tag it has. struct TaggedUnion t = {TAG_FLOAT, 1.0f}; // somewhere else if (t.tag == TAG_FLOAT) { float foo = t.f; } 
If one doesn't include any initialization for an automatic-duration struct, the compiler won't initialize any of it. The act of initializing anything, however, will cause a compiler to initialize the the remainder to default values. Personally, I think the Standard should have provided a means of initializing part of a struct, e.g. so one could write an declaration-initialization like: struct ITEMS { int size, count; THING items[50]; } myThings = {200,0,__STDC_INDETERMINATE__}; without obligating the compiler to zero out the storage for `myThings.items`, but at present any structure that has some but not all members initialized will set others to a default value.
I recommend formatting your post so that your source code has 4 spaces at the beginning of each line. That way the code will be shown with monospaced fonts that are much easier to read. You need to: 1. Open the output file for writing (as you are doing) 2. Open the first file for reading 3. Loop until you can't read any more (feof) or you find an error (ferror) 3a. Read at most N bytes (fread) from file in (2) 3b. Write that exact amount of bytes (fwrite) to file in (1) 4. Repeat 2 &amp; 3 for the second file. You can either do this with fopen, fread, fwrite and fclose; or with open, read, write an close.
So I completed step 2 for reading the text file, but i get stuck when I'm trying to write the text read into textfile2. Do I just need to create a fwrite command that puts the ch read into the textfile? current code : int main(int argc, char \*argv\[\]) { FILE \* outfile; outfile = fopen("C:\\\\temp\\\\testfile2.txt", "w"); if(outfile == NULL ) { printf("Unable to open the file"); return 0; }else{ fprintf(outfile, "A piece of text\\n"); fclose(outfile); } FILE \*infile; int ch; infile = fopen("C:\\\\temp\\\\testfile1.txt", "r"); if (infile == NULL) { printf("Unable to open the file."); } else { while ((ch = fgetc(infile)) != EOF) { printf("%c", ch); }} fclose(infile); } (I hope the formatting worked)
What empty promises? We're almost ready for release! In fact, we're ahead of schedule. We'll have released a binary in two weeks. HERMES Mail 8 for Windows is done, for all intents and purposes.
&gt;Do I just need to create a fwrite command that puts the ch read into the textfile? Exactly. In your code you use `printf`. However, to save something into a file you need to either use `fprintf(outfile, format, args...)` or `fwrite(outfile, buffer, size)`. You want fwrite here since you do not really care about format. By the way, if you do it properly, the code formatting looks like this (there is a *code block* button in `...` menu): char buffer[128]; size_t in_bytes = 0, out_bytes = 0; do { in_bytes = fread(buffer, 1, sizeof(buffer), infile); out_bytes = fwrite(buffer, 1, in_bytes, outfile); } while( !feof(infile) );
That’s only “could be a pointer to any type”. 
Nope. The first expression is evaluated at runtime, then the applicable option gets called.
Why don't you try it and find out? A simple print statement in each would suffice.
thanks
It's a good start, overall it looks clean. I will point some things and nitpick a little, not in a negative manner. In your readfile function the else is wrongly indented and the parameter is misleading as it can be bigger than 20. You should use `char*` . The name of the function is misleading as it is doing two things: reading and printing the file content. You should refactor it which will help you implement a locking mechanism for the the problem that I will mention next. I would use a switch in your main. I'm not a big fan of that "###" literal. I would remove it for something more friendly or define it one time instead of copy/pasting it 4 times. When argc equals 3 you can have both threads writing to stdout which can interleave both outputs. You should have exclusive access to stdout until you finish. Not the same problem but similar: when you are printing the file you are in canonical mode with echo which will print whatever you type interleaved with the file content. You can see [both problems happening here.](https://i.imgur.com/BK2IzqA.png) 
Are you specifically wanting to do this in C? If not, I'd suggest just using cat. cat foo bar &gt; baz
I really like this method. It appears to be very clean, and allows separation of the initialization. For those not completely clear on pointers (such as myself before this example) see this link to explain more: [Cplusplus.com - Pointers](http://www.cplusplus.com/doc/tutorial/pointers/) What is happening is that in the calling function structureInitialize(&amp;pidVars, &amp;globalVars) is passing the address of pidVars, and globalVars to the function. Now in the function it is using the * operator to access the value itself of the structure. The arrow operator -&gt; I'm not completely clear on but my understanding is that we use this to access the members of the structure when passed via pointer. see [StackOverflow - Arrow Operator Usage in C](https://stackoverflow.com/questions/2575048/arrow-operator-usage-in-c)
Without going into tons of detail on these things (Though I can expand on things if you want), to get an event-based architecture here you basically need to reduce everything into a single blocking call (more or less). Right now, your program is kind of event-based - and the blocking call is `getch()`. So, effectively, an event happens every time a key is pressed. But `getch()` is pretty limited so going beyind keypresses with it is basically not possible. You can still use it, but you can't use it to wait for input. In the Unix world, the big event-based calls (ignoring some newer stuff) are [`select()`](http://man7.org/linux/man-pages/man2/select.2.html) and [`poll()`](http://man7.org/linux/man-pages/man2/poll.2.html), and their counterparts [`pselect`](https://linux.die.net/man/2/pselect) and [`ppoll`](https://linux.die.net/man/2/ppoll) (They're the same call, but they interact with signals differently). I would persinally recommend looking at `poll` (or `ppoll`, if you need) as I find the interface much nicer to use then `select`, which is a bit crusy. Also note, the "keyboard" is also called `standard-input, or `STDIO`, and it has a file descriptor of zero (You can also use the constant `STDIO_FILENO` instead of the number). Point being, you can call `select()` or `poll()` and have one entry for the zero file descriptor, and then `select()` or `poll()` will block until there is input. So it wil block identically to `getch()`, but with the big advantage that you can wait on more then one file descriptor, or wait on signals (If you use `ppoll()` or `pselect()`). I mentioned signals before, signals are basically a separate event system in `unix`. They act like interrupts, if you have heard of those. Basically, "signals" can be sent to your program from the OS, and when that happens the OS stops running your code and instead runs some separate code you designate. The little example program [here](http://www.yolinux.com/TUTORIALS/C++Signals.html) (The C one, not the C++ one) looks decent. The important point is that they install a signal handler for `SIGINT`, which the OS will send to your program if you try to kill it with `ctrl-c`. So you hit `ctrl-c`, the OS sends a `SIGINT`, and then your signal handler function is automatically called by the OS. It gets ugly, but tha's the gist. The improtant detail here for you is that there is a `SIGCHLD` signal which is sent to your program when a child exits, meaning you can wait for that signal and it will tell you when you have a child ready to be `wait`d on - so you don't have to block on `waitpid()`. So, the compilcated way to put all this together is to use `ppoll()` or `pselect()` to wait for either keyboard input or a `SIGCHLD` signal. If you get input, then you call `getch()` like normal (And it won't block, since the input is ready). If you get a `SIGCHLD`, then call `waitpid` in a loop with the `WNOHANG` flag to reap all the children that have exited. You have to call it in a loop because signals are dumb and you won't get more then one `SIGCHLD` signal when two children exist at the same time. The `WNOHANG` flag ensure that `waitpid` does not block if there are not zombie children ready to be `wait`d on at the moment (Which it would normally do if you just called `waitpid` normally). I *might* be able to find an example of this if you're interested, I believe I have one in some of my code on github. Now that said, you have possibly an easier route to take in that you don't actually need to call `mv` or `cp`. So you could instead just write all the file handing yourself, and then you don't need to spawn any extra programs making everything is a fair bit simpler.
This is the wrong way to learn C. Just because your compiler does one thing is not a reason to assume that's how the language works. 
&gt; The arrow operator -&gt; I'm not completely clear on `struct-&gt;field` is simply equivalent to `(*struct).field` - it's just a convenient syntactic sugar
It's neither. We're gearing up for release. I purchased the Cosmo with my own money and included it as an example of the kind of expenses we're burning through. The majority of the funding is allocated to legal expenses. Most of it hasn't been spent.
Release is in two weeks time or so.
This is the correct answer.
I refuse to use GitHub as long as it doesn't have support for Mercurial SCM, the only revision management system worth thinking about. Git (the software, not GitHub) is a piece of crap to install, a piece of crap to use, and a piece of crap to find usable documentation for. Whoever wrote it ought to be taken out back and shot. I put a little bit of thought into migrating to BitBucket. Unfortunately, I'd have to migrate the other two projects as well, because Soren Thygesen (my best C(++) coder, and the man almost single-handedly responsible for the fact that HERMES Mail for Windows is being released, and a fortnight ahead of schedule to boot) will be assisting on this project, and he's spent all his time on SourceForge. In short, objects at rest tend to stay at rest.
Getting it in is easy. C lets you put arbitrary things in arbitrary memory locations. Getting it out, not so much, arbitrary memory locations don't have type. You are clearly coming from python. One of the difficult things when you change language, particularly between families is that you need to change your approach and way of thinking. C doesn't have tuples. C doesn't allow you to mix types. You can achieve the same things, but the optimal approach will be different. The data is coming from a user. I suggest that you treat it as an array of strings, user data is typically a string. If you need to process things that look like integers as integers, determine if it looks like an integer and convert it when required.
Thank you so much for the elaborate answer! 'll look into ppoll and pselect. Also it would be great if you could link me to some example that uses loop to use waitpid on all the children. Thanks again 
We've been here before. This was for the Windows version, and in that case we DID have to port from one GUI toolkit to another (Stingray to MFC, because Qt didn't have all of Stingray's features). Funny thing is, I don't think we'll need to port anything in this instance. We'll have to migrate from one IDE to another (which stinks, but c'est la vie), and then the resource forks got clobbered so we'll have to make new ones, but the GUI toolkit I think has stayed pretty constant across OS X's versions (QUALCOMM used the native one).
 A software developed by a programmer should be correct, reliable and maintainable. It should satisfy the user’s requirements. Software development is a dynamic process because it needs to be modified or redesigned to incorporate the changes required by the users. To cope up with this dynamic behaviour of the software development cycle, different approaches of programming have been developed. These programming approaches are known as programming paradigms. A programming paradigm represents the structure of a program. know more: [Object oriented programming](https://www.techzone003.in/2019/01/object-oriented-programming.html) &amp;#x200B;
I have compiled pcre2 by myself a few days ago. I am working with an MSYS2 Env on Win 10. So you can use: My example ./configure --prefix=/c/dev/testplace/repo/_c/_third_/bin --enable-newline-is-anycrlf &amp;&amp; make &amp;&amp; make install On Linux System it should be more easier depend on distribution you can get and install the lib by systems package manager.
It does not compute both, no. But if you were in a situation where it did, you could work around it like so: double c = expensiveFunction(condition ? a : b); Or if you want to call a different function: double c = (condition ? functionA : functionB)(val);
It's less about learning the definitive standard and more doing a modicum of personal investigation.
Ok. If you want to believe that it's easier to read a thousand line function with many branches versus a small and concise function that has to call into a number of other small and concise self document and easier to read sub functions then who am I to stop you.
Still disagree. Learn the standard and it's caveats, know undefined and unspecified behavior.
Hmmmm... didn’t realize anonymous unions were a C11 thing. NT kernel has relied heavily upon them since inception... so, circa ‘89?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/kernel] [data race within ptr\_ring code implementation](https://www.reddit.com/r/kernel/comments/ads0j3/data_race_within_ptr_ring_code_implementation/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I just refactored some of my code and started using `system()` for `cp` and `mv`. So now when someone copies or moves some files, a shell is opened showing the progress and the user can continue to use the program in another instance
What higher-level problem are you actually trying to solve?
So you think everyone must have absolute knowledge before then can start? That's ridiculous.
The first thing that comes to mind is the synchronization between consumer and consumer for full/empty situations. You will probably need a lock or an atomic operation to make sure they don't access the same slot in the ring.
Not really a c programmer so bear with me. Could there be an issue with buffer either not being initialized? I know at least with go, this could cause a panic. I’m not sure what the behavior is for that type. Also is it safe to access the head and tail before checking if it’s empty? 
ptr\_ring data structure implements lock in the kernel already. See [https://github.com/torvalds/linux/blob/master/include/linux/ptr\_ring.h](https://github.com/torvalds/linux/blob/master/include/linux/ptr_ring.h) 
I likely should not be attempting to answer as I wake up, but the Tsan error is pointing to some pthread_join statement in the test util -- could the race condition be something in your thread starting code?
testutil.c is ok because I have tested it OK with [a working (but inefficient) circ\_queue.c](https://github.com/promach/riffa/blob/full_duplex/driver/linux/circ_queue.c) Check my original question again. Read it again.
I'm seeing your implementation, but not the code that's actually under test.
I need an explanation like that for `struct` and `typedef struct`.
See [testutil.c](https://github.com/promach/riffa/blob/full_duplex/c_c%2B%2B/linux/x64/test_apps/testutil.c) which you have asked for
I think the most useful skill to have as a C programmer might the ability to sketch bits of computer memory on grid paper.
Yes, I believe that. I have been a software engineer for 6 years now. I have maintained several different code bases. I prefer maintaing the longer functions.
https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions Questions?
Looking through it, nothing immediately jumps out at me.
&gt;Also is it safe to access the head and tail before checking if it’s empty? After I move the head and tail inside the empty check if , I still have system crash. So, I suppose this is not the direct reason for the ThreadSanitizer error.
I've been programming in C for 25 years and have never needed to do that.
Javascript developers barely have enough IQ points to understand the alphabet let alone the C programming language.
This all started a month ago when I accidentally minimized the window. Since then I haven't been able to get it back beside the floating report window, but that doesn't work that well since it blocks up the text and is quite annoying to work with. Every time I looked up this problem I only found people saying to use the floating window, but there must be a way to fix this issue without using that.
Let’s not get elitist here. Right tool for the right job. This generalisation doesn’t help anyone. 
I think I sort of figured out why. I have **two** instances of ptr\_ring data structs in which both uses pop\_circ\_queue() in a multithreaded manner. However, my code only has **one** instance of item\_pop\[\]. This leads to data race between threads chnl\_send() and chnl\_recv() within riffa\_driver.c
if this were done in a for loop, will it be vectorized?
PM me with details
No malware solicitation.
I don't use Dev C++, but based on my experience with other IDEs, have you tried to delete the user-specific settings or preferences file? It should be in the %USERPROFILE% directory or an app-specific sub-directory within it.
What's listed under the windows option in the menu bar? I've not used this IDE but In others there's usually something like "reset view" or "reset perspective" that should reset all your windows to the default configuration.
Name checks out.
I've never got on with IDE's for this (any other reasons) I've learnt far more by using a terminal and a simple text editor....
This was the core competency tested in my advanced programming class. All of the sudden everything just came together and made sense. The goal of the course was basically starting with the basics of C, getting through pointer arithmetic, I/O, socket programming etc, culminating in writing a. Web server from scratch, then finishing up with an under-the-hood dive into C++ and eventually learning to build out structures to behave the way we expect the Java object lifeline to behave. Best class I've ever taken.
Your comment was very funny 😂, did you really mean it or was it a joke 
Compiler writers used to try to maintain compatibility with the behavior of previous versions, even in cases where the Standard imposed no requirements, but the authors of gcc have expressly stated that they feel no obligation to do so. From their point of view, code which would be processed usefully on 100% of existing compilers for conventional platforms is "broken" if the Standard doesn't actually specify how it should work (notwithstanding the fact that in many such cases, the reason the Standard didn't bother to define certain corner cases that compilers had processed 100% consistently *was* that 100% of compilers were processing them consistently). Consider, for example, a function like: unsigned mulMod65536(unsigned short x, unsigned short y) { return (x*y) &amp; 0xFFFFu; } on a machine with 32-bit (non-padded) `unsigned int` and 16-bit `unsigned short`. Having that function processes the multiplication in all cases in a fashion consistent with unsigned arithmetic would be useful *but* the authors of the Standard noted in the published Rationale document that there was no need to mandate that implementations do so because commonplace implementations would do so anyway *even for intermediate results in the range `INT_MAX+1u` to `UINT_MAX`*, unless those intermediate results were used in ways that would make signed arithmetic more useful. Unfortunately, the authors of the Standard failed to consider that some compiler writers would interpret their failure to mandate behaviors that had been essentially universal as an invitation to deviate from them in the name of "optimization". While gcc will *almost* always process the above `mulMod65536` in a fashion consistent with using unsigned multiplication, it will sometimes be processed in ways that disrupt the surrounding code if `x*y` exceeds 0x7FFFFFFF unless overflow-related optimizations are disabled, and its authors regard that as a "good thing". Anyone seeking to use gcc without disabling overflow-related optimizations must consequently be aware of the kinds of nonsensical "optimizations" the Standard would allow, rather than merely relying upon observations of how code behaves. 
IMHO, it's best to regard the name `C` as describing two concepts: 1. A simple meta-language invented by Dennis Ritchie which maps source constructs to platform constructs which are then mapped by the machine into actual behaviors (so if a "language" is a mapping from source texts to behaviors, Ritchie's C is effectively a mapping from platforms to languages). In this meta-language, some actions will map to machine constructs that behave predictably and useful on some platforms, but may behave unpredictably on others. 2. A sparse mapping of source texts to behaviors, whose boundaries are given much more attention by compiler writers than they ever were by the people defining them, especially in cases where all or nearly all known platforms worked the same way, but where mandating a behavior could have caused difficulties on some obscure platforms. Most constructs which are not required to behave usefully on all platforms cannot be expected to work reliably on any. Those seeking to write the first, broadly-useful, form of C on a particular target platform will need to know how that target platform handles various things. Writing bug-free code for the second form of C, however, will be impossible unless one knows all of the allowances the authors of the Standard made for unusual implementations.
```c item item\_push\[CIRC\_BUFF\_SIZE\]; item item\_pop\[CIRC\_BUFF\_SIZE\]; ``` Don't you need instances of both of these per instance of circ_queue? Right now they're just global.
Recognize also that the meaning of "Undefined Behavior" intended by the authors of the Standard and described in the Rationale differs enormously from the meaning as treated by compilers like gcc and clang. As intended by the authors of the Standard, the difference between Implementation-Defined Behavior and Undefined Behavior is that classifying an action as Implementation-Defined Behavior requires that implementations document how it will behave, even on platforms where guaranteeing *anything* about the behavior would be expensive, and without regard for whether any possible behavioral guarantees would offer any benefit any programmers targeting that platform. Classifying the action as Undefined Behavior means that implementations are not *required* to specify anything about its behavior, but does not imply any judgment about whether some (or even most) implementations should be expected to specify a useful behavior anyhow. | The terms unspecified behavior, undefined behavior, and implementation-defined behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe. The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard. Informative Annex J of the Standard catalogs those behaviors which fall into one of these three categories. The only sensible interpretation of this paragraph is to recognize that many implementations usefully extend the semantics of the language by defining behaviors in circumstances where the Standard imposes no requirements, and that the authors of the Standard intended to encourage this. If the intention was that UB mean "behave uselessly unpredictably", that would hardly be difficult for the Standard to describe [indeed, it would only need three words to do so], nor would that encourage any kind of useful variety. Further, the authors made reference to "popular extensions", but for an implementation to document something that it's required to document would hardly seem like much of an extension. Likewise specifying that when given a choice of a few discrete possible actions, it makes the choice in a particular way. Specify that some particular action will cause a program to do something useful the authors of the Standard did not specify (nor, in many cases, even contemplate), however, seems like much more of an extension. Unfortunately, some compiler writers seem to believe that when the authors of the Standard use the term "Undefined Behavior", they intended it to mean "behave uselessly unpredictably", even though that contradicts the authors' stated intentions. While the Spirit of C (again quoting from the Rationale) includes the principle "Don’t prevent the programmer from doing what needs to be done.", some compiler writers believe that only applies to actions expressly described by the Standard. 
They were also a gcc extension that was on by default iirc. 
That model fits the language Dennis Rithie invented and documented in K&amp;R, as well as the language the Standard was written to describe. It does not match the language that is actually described by the Standard, as interpreted by the authors of "modern" compilers.
Welp time to reinstall the defaults /program/OS. P. S. On a more serious note, half of the time I lose a floating window it just somehow got behind the main window. P. P. S. You should just use something like Eclipse instead. 
Of course not. But "try it and see what happens" isn't a good answer. If you know the answer, point to the relevant section in the standard.
Try it and see
I suspect opinions on this vary considerably. My experience has been that the best way to learn most any programming language (once you've got a handle on the very basic syntax) is to simply start writing it and looking things up as-needed. %nbsp; Tutorialspoint and c-faq.com are websites that cover basics, and searching "how do I ____" will usually bring up a ton of answers for beginner and intermediate questions. Stackoverflow is your friend. The thing about C that is both good and bad for learning is that there is not much to the standard language. It does not provide a standard data structure library, so it's up to you to write your own or rely on 3rd-party implementations. Pointers and arrays are how you will move most of your information around in some fashion or another, so I might focus my attention there once you read through the syntax of stuff you're already familiar with.
Your blanket statement is asinine. I've been coding Javascript for 20+ years, as well as C. I prefer Javascript for many reasons, but I use C where it is the right tool for the job. I doubt you have enough IQ points to master Javascript, so you just sling bullshit instead. 
It's a good article and a good thing to learn. But if you are already a JavaScript developer, you might just learn C programming which doesn't take much effort and naturally figure out the JavaScript architecture under the hood. What is difficult to understand and I still don't get and the article doesn't mention is how struct is related to the object oriented programming. 
I would focus on the C memory model and what you as a developer need to know to manipulate it (pointers, arrays, stack, malloc/heap.) Next, is data structures. You need to build all of these yourself to manage the data you use in your program (stack, queue, linked list, hashmap, etc..) These you got for free using other languages like C# or C++. For me, the best tutorial on pointers is [Ted Jensen's Tutorial on Pointers and Arrays in C](http://pweb.netcom.com/\~tjensen/ptr/). Find a book or resource on algorithms and data structures in C and practice implementing them.
K&amp;r c
This was actually a great read! Thanks for sharing. 
It looks like you can pass -no-pie to gcc to instruct it not to build a pie executable. (I found this out here: [https://stackoverflow.com/questions/34519521/gcc-creates-a-shared-object-instead-of-an-executable-binary](https://stackoverflow.com/questions/34519521/gcc-creates-a-shared-object-instead-of-an-executable-binary))
Seems to be a [known issue](https://bugs.launchpad.net/ubuntu/+source/shared-mime-info/+bug/1639531)?
That worked! Why is that, why is a position independent executable treated as a library (even if its clearly executable)
...which classifies it as indeed a problem in Thunar and other GUIs , they incorrectly report a PIE executable as a shared library.
Use `poll()` to wait for data to arrive before calling `read()`.
Note that this is a known issue with the GUIs, not with GCC. They incorrectly (arguably) report a PIE executable as a shared library.
There's a button that says "Back to Normal", but all that does is make Dev C++ full screen and the report window doesn't reappear.
Could you give me any assistance on how to access the user-specific settings? Sorry, I don't know much about that.
I was considering trying out Eclipse before this, but now that Dev C++ is pretty much cursed on my computer I'll have to switch.
Use the `recvmmsg` call or use `poll` or `select`.
thanks
great, i'll try to use poll()
This is how I've been doing it. Reenforce what you learn and look for reasons to use each little trick you know in each project. So far so good.
What type of problems? What don't you understand? You're really not giving us much to work with here.
you can use threads for work with blocking functions
I have two ptr\_ring , and what happen if both rings uses a single item\_pop ?
I had to do some investigation to be sure, but the reason is that there is no "shared object" vs "executable" flag in ELF binaries. What they do have is a "type" field, which is generally set to either `ET_EXEC`, or `ET_DYN`. These stand for 'executable' (I guess) or 'dynamic' - and generally, you can equate these to 'executable' vs 'shared-object'. But that's really a lie, because both of them can be executables - some shared-objects can even be executed sucessfully (Try running `libc.so` if you get a chance, it runs and outputs some text). The real difference between the two is how the address fields in the ELF file is treated. When the ELF file is marked as `ET_EXEC`, then all the addresses are absolute addresses. But when you mark it as `ET_DYN`, then the addresses are relative to some base address. Which, this is exactly what happens when you compile as `-fpie` - the entire executable is made position-independent, which is done by making all the code relative to some base-address. The loader can then adjust this base-address to anywhere it wants, and all the code still works. But to make that work the executable has to be marked `ET_DYN` so that the OS/loader knows the addresses are relative, and this works fine but makes it appear as a shared object to programs that just check the type field.
I am having trouble casting [void \*\* queue in ptr\_ring struct](https://github.com/torvalds/linux/blob/master/include/linux/ptr_ring.h#L44) to use my item struct. typedef struct item { unsigned int val1; // event number unsigned int val2; // relevant value tied to the event number } item; &amp;#x200B;
Please see the [error](https://paste.ubuntu.com/p/cQj5WBsmbN/) I faced with [this code](https://paste.ubuntu.com/p/vmqwC7XFmj/)
But you should not do this just so some tool identifies it as an executable because PIE is a security feature.
Learning a programming language is like learning to drive a car. You can read all the books you want but the understanding comes when you finally get behind the wheel and shift into drive. Think about some simple program you could write that uses an array. Maybe fill in the values 1-5 and print them out. Pointers were really confusing to me until I decided to use a linked list in a program I was writing and to my surprise, it actually worked.
it is up to you. i consider the pre-processor a separate language and i try to avoid using it unless i really have to. i guess a better question to ask is: what do you gain by defining a macro that you use only once? what do you gain from it being a macro vs a variable? what things do you lose?
no -- they're identical.