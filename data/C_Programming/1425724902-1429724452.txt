Try [ncurses](http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/). You can use it to [write to screen with coordinates](http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/printw.html), use [colours](http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/color.html) or even make something [controllable with the mouse](http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/mouse.html). Edit: I think you'll need to use [PDCurses](http://pdcurses.sourceforge.net/) because ncurses doesn't seem to be available for Windows.
First of all, `testmerge` should be an array of 10 elements, not 5; it’s taking both `testtop` and `testbot`’s elements. (If it’s actually declared that way, you’re probably colliding with other variables on the stack and that’s your problem.) Second, so much extra code here; you can accomplish this with much less fluff: while(i&lt;N &amp;&amp; j&lt;N) testmerge[k++] = (testtop[i] &gt; testbot[j] \ ? testbot[j++] : testtop[i++]); while(i&lt;N) testmerge[k++] = testtop[i++]; while(j&lt;N) testmerge[k++] = testbot[j++];
Moving randomly is really a bad idea, unless it's for homework, and it's a requirement. You're basically going to walk in a small circle and not actually get anywhere. If it's really a maze, and he's supposed to wander around in it, better would be to only make him choose randomly when he hit an intersection. As to "whenever I press a key on the keyboard", you will need some library to allow that to happen. This will be compiler specific, so you need to look into your documentation. Alternately, you can do this, and just hit enter: int c; while( (c = getchar()) != 'Q' ) { wander(); } **stdin** is line buffered, so it won't actually be "when I press a key", but it's as good as you get with Standard C.
Why don't you run it and see?
What does "I cannot position" mean??? What happens? The data is printed in the wrong spot? The data is not printed at all? The data is printed at the bottom as if no positioning occurred? You need to provide a meaningful description of the problem. Keep in mind that your function is not positioning the cursor on the *screen* specifically. It is positioning the cursor in the *window buffer*. And it counts coordinates from the top left corner of the *window buffer*. If you scroll your window in any direction, the same coordinates will designate a different location on the screen. They might even end out outside the window. Could it be that when you printed your map it caused your window to scroll down and thus scroll your coordinates out of the window?
I don't see anything "cut in half" in your picture. The numbers seem to be *under* the labyrinth. What exactly is "cut in half" and where? What coordinates do you supply to your `gotoxy`? And how do you call your `printf`? What you posted in your OP does not seem to look real, since I don't see the string `"Speed of Character"` in your picture. Note also, the if you want to position your `printf`s, you should not begin your output with `\n` (as in your original example). The `\n` will cause your text to drop to the beginning of the next line, which will defeat the purpose of positioning.
http://gyazo.com/714ce959a8748d4bc9d7077bbbe83956 gotoxy(posx,5); clreoscr(); textcolor(15); posx = printf("Speed of Character: %d / %d",speed, m1); gotoxy(posx,7); clreoscr(); textcolor(15); posx = printf("Speed of enemie: %d / %d", speed_e, m2); this is what I get now :( this is very weird why my labyrinth keep disappearing :(
It can. Breakpoints and watchpoints in gdb more capable than even many gdb users are aware of. Another example of something you can do in gdb is to set up a breakpoint where you've told it the expected behavior, say, the series of branches to be taken in a search algorithm, and then tell it to break only when the actual branch is different from the expected branch, so you can examine the program state at exactly that point, instead of having to manually step through to that point.
What's `clreoscr()`? Why are you calling it after each `gotoxy`? Isn't that what makes your labyrinth disappear?
For specialized processors like that often the only tools available are from the vendor. On the other hand, TI's "Code Composer Studio" IDE is just a version of a popular open source IDE, so perhaps the vendor compilers and debuggers are similarly just versions of the usual open source tools; You might already be using gdb as your debugger (gdb is the debugger that typically powers Eclipse's debugger ui when debugging native executables). If so, then you might benefit just from learning more about the gdb's advanced features.
Create new build system with this (for GCC): { "cmd" : ["gcc $file_name -o ${file_base_name} &amp;&amp; ./${file_base_name}"], "selector" : "source.c", "shell": true, "working_dir" : "$file_path" } or clang (if you have): { "cmd" : ["clang $file_name -o ${file_base_name} &amp;&amp; ./${file_base_name}"], "selector" : "source.c", "shell": true, "working_dir" : "$file_path" } 
Make sure you have saved the file.
You're right, thought it was in the same sub.
How are you going to use this for encryption? How is it going to be decrypted? Edit: There is no problem in your code, however you seem to have a misunderstanding of how c-strings work. The character '\0' signifies the end of the string. So when you place that in the array, functions like printf will stop as soon as they see that. You can either change the way your algorithm works and shift everything after the match one place back. Or you could write another function to copy your string to a new one while skipping the extra '\0's.
oh I see, would it be possible for you to help me out on how I could write the new function to skip the extra \0's or is that frowned upon here since I am not exactly sure what the steps are.
yes it's the remainder, so if I put if x%5==0 it will be the same if i am using, but my issue is getting to print the table of just those 5 multiples of everything less than n (n being the number the user inputs)
OK here is where I am now for(x=1;x&lt;n;++x) { if(n%5==0) x=x*5; printf("multiples of 5: %i \n", x);
You are overcomplicating it a lot. Try this instead: int i, n = 123; for( i=5; i&lt;=n; i+=5 ) printf( "%d\n", i );
Great suggestions here but I want to add an important bit: make sure the C compiler is in your system path.
Where would be a good place to find a right explanation?
What happens when x hits 5 and n is less than 26?
Thanks!
It's actually not a "big" book about C, it's very tightly and efficiently organised. For some people, its restraint and small size makes it the best (and of course, it is (by definition) the most authoritative). For other people, who will appreciate more expansive explanations and more examples, it is not the best C book. Why would you think there should be one book that is the best for all readers?
&gt; it is (by definition) the most authoritative Well, that's true for the first edition, which was essentially the definition of&amp;nbsp;C at that time. But the second edition describes ANSI&amp;nbsp;C89, and for that there is no reason that K&amp;amp;R is necessarily the most authoritative source—in fact, there are [a few known errata](http://www.seebs.net/c/knr.html).
One option is to use pthreads.
A couple of notes before answering your question * In the ASCII chart, 'A' - 'Z' are consecutive and 'a' - 'z' are consecutive, but there are non-alphabetic characters between 'Z' and 'a', so handling both upper and lower case with the same code may not be possible/easy * it's not a good idea (IMHO) to use the integer values for characters. Your code is more readable if you use the character constants (e.g. 'A' instead of 65) * Because of 1 above, use the isalpha( ) function from ctype.h rather than your if statement to check for alpha characters. There are also functions to determine if the character is UPPER case or lower case I'm not sure I would try to use 'mod' here although there may be some clever way of doing so Simply add the key to s[ i ] and see if it's bigger than 'Z' or 'z'. If so, calculate the new char by adding the difference to 'A' or 'a' Something like this pseudo code char c = s[i] + key; if s[i] is a lowercase letter if c &gt; 'z' c = 'a' + c -'z' -1 else if s[ i ] is upper case letter . . . 
Since you mention epoll(), maybe eventfd()? Or signals.
&gt; **16.1 Standard C** &gt; 2 Why does the following code return 0 and not -1? (Answer: because sizeof is unsigned, thus the result of the subtraction is unsigned, thus the shift is logical.) &gt; &gt; return ((1 - sizeof(int)) &gt;&gt; 32); Poorly stated question and bogus answer. The question apparently implies that number of bits in `int` is 32. But it ignores the type of `sizeof(int)`. * On a 32-bit platform `sizeof(int)` is 4 and number of bits in it is 32 as well. This means that the result of `1 - sizeof(int)` is 32-bit wide. And this means that shifting it by 32 bits is illegal. Behavior is undefined. You are not allowed to shift 32-bit values by 32 or more bits in C. On x86 platform, for example, 32-bit instructions interpret shifts by `N` bits as shifts by `N % 32` bits (i.e. only the lowest 5 bits are taken into account). This means that a shift by 32 bits is a no-op. The only reason the code might return `0` in practice on such platform is that the expression is constant and evaluated at compile-time. The compiler simply quietly pretended that shifting by 32 bits is defined in this case. * On a 64-bit platform number of bits in `size_t` is 64 and the result of `1 - sizeof(int)` is 64-bit wide. The shift is legal. Assuming that `return` converts to `int`, the code will produce something implementation-defined, most likely `-1`, not the promised `0`. ------------------------- &gt; 6 This is from c-torture. This function returns 1. Strictly speaking, it doesn't. It does not even compile in standard C. This statement return pt3-&gt;value; attempts to convert a `char *` pointer to `int` without an explicit cast. This is illegal in C. But even if we allow this conversion to happen implicitly, as an extension, I still don't get the purpose of this entry. It is full of pointer reinterpretations, but it is pretty straightforward otherwise. What exactly was this entry supposed to demonstrate? ------------------------- &gt; 7 Another one with constructed literals. This one is legal according to the GCC documentation but somehow GCC chokes on (it works in CIL though). This code returns 2. &gt; return ((int []){1,2,3,4})[1]; Well, this is just an ordinary *compound literal*, which has been in the language since C99. Nothing to see here. BTW, why does this article list compound literals as "Standard C" (not as a "GCC ugliness"), yet calls them by a pre-standard GCC-specific name "constructed literals"? ------------------------- &gt; **16.2 GCC ugliness** &gt; 5 extern inline is a strange feature of GNU C Strictly speaking `extern inline` combination has special meaning in standard C since C99. And no, the code provided in this entry will not even compile, since it defines `foo` twice. ------------------------- &gt; **16.3 Microsoft VC ugliness** &gt; 1 Why does the following code return 0 and not -1? (Answer: because of a bug in Microsoft Visual C. It thinks that the shift is unsigned just because the second operator is unsigned. CIL reproduces this bug when in MSVC mode.) &gt; return -3 &gt;&gt; (8 * sizeof(int)); No bug in the compiler here. The code simply triggers the same undefined behavior as described above (16.1/2 entry). Shifting 32-bit values by 32 bits is undefined.
In a debugger context, yes (watch points). In general, no. You need to specifically signal if you want to wake up other threads for whatever reason. Typical ways of doing this are a cond/mutex pair (e.g. pthread_cond_t, pthread_mutex_x), or a semaphore (e.g. sem_t).
&gt; BTW, why does this article list compound literals as "Standard C" (not as a "GCC ugliness"), yet calls them by a pre-standard GCC-specific name "constructed literals"? This article seems to know as much about C99 as Microsoft's C compiler does
Yet it lists designated initializers in "Standard C" section.
I did the same thing as you mentioned but it says: 'gcc' is not recognized as an internal or external command, operable program or batch file.
subtract 'a' from your original lower-case char (to put it in the range 0-26), then add 5 (or whatever the cipher value is), then take %26 of the result, then add 'a' back again. If uppercase, do the same with 'A' instead of 'a'.
problem is that it needs to support shell or ssh. 
Eclipse is my favorite IDE and for c/c++ is just fine, but it can be quite complicated for a beginner, as the others said you could start by working via CLI to know the inner workings of the compiler you chose ( I personally use gcc via the MinGW toolchain), but if you are able to configure it it's perfectly fine for you to use it. Other fine alternatives are netbeans and code::blocks, even though I think they are complicated in their own way, but again, the choice is yours. 
 while(true) {/* check for changes */} Meanwhile in another thread you execute other code and break out of the initial while cycle 
i don't thats why im looking for a unified solution.
This is where the post was Xpost'd: /r/programminghelp * * * *I'm a bot.* - [FAQ](https://github.com/SolarLiner/Subreddit-Linker-Bot#subreddit-linker-bot) | [Source](https://github.com/SolarLiner/Subreddit-Linker-Bot) | [PayPal Donation](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=V2LJY4HCKW3FE) 
Author here. You're right, it's kind of the same mechanism on Linux. There's a lot of abstraction in the first section (Virtual memory), as it's meant as a primer for (the hypothetical) reader to connect it with something he's accustomed to. Page faulting (as you explained it) and demand paging is then further explained in the memory mapping section, with the references to more in-depth explanations. My reasoning is that it's more digestible this way, just as in the high school where we've learned the practical arithmetics first, where all the nitty gritty details were hidden behind these convenient constants and coefficients, and then the actual explanations of the constants came later on.
&gt; waiting for buildsystem everytime i make changes will take to long so the buildsystem step is a hinder in the deployment cycle. It might help rebuilding only the parts that changed instead of rebuilding everything. Saves a lot of time. &gt; the fact that its a cross platform software that will run on mutliple platforms in all different sizes and shapes. from small 32bit arm machines to big 64bit xeons i need to be flexible when i develop and test. Portability begins with one's mindset. Inform yourself about what APIs are available on the platforms you want to support and write code in a way that you avoid APIs that aren't available on all of them. When I write portable code, I start to write it on one machine and constantly take into account the availability of interfaces and the differences between platforms while writing it. When the code is roughly finished, I take the tarball and try to compile it on another platform, fiddling around on that platform until it works. Rinse and repeat for all of the platforms. Building time isn't the largest concern if you use a Makefile-oriented build system like cmake as they allow you to only rebuild the parts of the source that changed since the last build. &gt; maybe im just overthinking it, but beeing able to move from one machine to another seamlessly should't be that hard today. Not at all! Thinking about the problems you might face during the implementation is a very important step of the planning phase. Try not to get tangled in mazes of `#ifdef WIN32`.
Makes sense, I've rephrased it and added a reference. I'm hardly familiar with the NT, so the "long rambling" is quite reassuring. Thanks for your time, I appreciate it.
i tried to answer it here: http://www.reddit.com/r/C_Programming/comments/2yfc1e/looking_for_insight_when_it_comes_to_cross/cp9adbl
I'm not going to give you a complete solution, but start with declaring an array of chars, containing the letters of the alphabet. ASCII chars are really just ints, with A starting at 65 and a starting at 97(have a look at www.asciitable.com). So, depending on if the entered character is upper- or lowercase, subtract the appropriate number and use the result as the starting number to iterate and print the rest of the alphabet array with a simple for loop. Give this a go and post your code, I'll try to give you some feedback. 
ASCII to the rescue! All characters are represented by a numeric code. For example, 'h' is 104. These code are alphabetical. So, all you need to do is create a for loop between h and z, but print out the value as a character instead of a number!
One possible portable solution would be to simply create an explicit table of characters listed in the proper order const char *const ABC = "abcdefghijklmnopqrstuvwxyz"; I represented the table by a string literal, which makes it easier down the road - we can use standard functions to work with such "table". Then look for your starting character `s` in the table const char *start = strchr(ABC, s); assert(start != NULL); And then simply print the tail portion of the table printf("%s\n", start + 1); Add input and error checking, and you are done. ----------------- Alternatively, you can implement your program in terms of character codes simply by incrementing the starting character value until you reach `'z'`. This will work for ASCII platforms. However, the language does not require ASCII and does not guarantee that alphabetical characters form a contiguous group of character codes. Which is why I suggest the above table-based solution as formally more portable.
Well, this doesn't actually work, if your original description of the problem was correct. This will print all the letters up to the given one(in your example, z). Try with 'f' to see what I mean. And, assuming you declared letter as 'a' before the while loop, a will not be printed. Can you see why?
in the context of the rest of my program, it asks for a lowercase letter and a while loop runs until one is actually given. so that helps!
emacs.
You *always* have to put yourself into a different mindset. I've yet to find a single editor available on every platform (vi (note *NOT VIM* but *VI*) comes closest to being available everywhere, but you may have to install it), or a compiler (at work we use at least three different compilers, GCC, SunWorks, Clang---and from that you may be able to tell what platforms we run on), or a debugger (gdb, ldb, dbx---*that* was a painful lesson). Even though we use one version control system (SVN) there are issues since some of our clients (Solaris; a few legacy Linux systems that, for "business reasons" can't be upgraded) are old and don't support some new stuff (like external references to repos) so even *that* is problematic. I haven't had issues with Make, but I suspect we have GNUMake on all platforms to begin with. Yes, it may seem like I'm advocating bear skins and stone knives for cross-platform development, but unfortunately, it's bear skins and stone knives that are the lowest common denominator between Windows, Linux and Mac. Such is life and portable programming. Note---I am not a big fan of IDEs. I've tried them on and off over the past twenty-five years and I'm never impressed as I watch them crash and burn on me (the latest was Eclipse on a one file program of almost 2,000 lines) and in just about every case, they're language specific anyway (I have to wonder how a typical IDE would handle [this file](https://github.com/spc476/LPeg-Parsers/blob/master/json.lua) which contains Lua, C and a parsing DSL in one file). I tend to stick with text editors. And while using Notepad might be painful, it *is* usable over some even older text editors (edlin comes to mine, or ex).
no need for an array.
Alternatively to your while loop, char a; for(a='a'; a &lt;= 'z'; a++) printf("%c", a);
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { for (char c = 0; (c != '\n' &amp;&amp; printf("&gt; "), fflush(stdout), scanf("%c",&amp;c)) == 1;) { char l = c &amp; 0x20, /* preserve lowercase bit. */ n = c &amp; ~0x20; /* store character in 'n' with lower case bit removed. */ if (n &gt;= 'A' &amp;&amp; n &lt;= 'Z') { for (register char i = n; i &lt;= 'Z'; i++) putchar(i | l); /* print alphabet and include lower case bit if there was one. */ putchar('\n'); } } exit(0); }
Welp reddit just messed up my post haha thats what i asked http://pastebin.com/Dvm0JPfu
well the thing is the beginning of the triangle has to have 1, then the next line 3, and following that 5, and so on
Basically, you need to guess the formula between the line number and the number of stars. Something like stars = line x 2 - 1 when ascending. And (rows-(line-rows)) x 2 - 1 when descending. And also, if you are aiming for a cleaner code, you should separate the computation and the rendering...
First, find out how the number of asterisks and the line they are on are linked. Line two has three. Line three has five. Line four has seven. Line five has nine. See a pattern? The number of asterisks is equal to double the line number minus one. You should be able to figure it out from that!
plain old make (or gmake) will work too. Visual studio and other IDEs support makefiles and other external build components
You can just have a single print statement right before your loop. That way each row has a single star as the offset before printing the remaining stars. 
Way overcomplicated given the requirements, and would be better without the obfuscation.
Looks like you just need to modify your program to print `2*i-1` stars where you currently print `i` stars.
You're right. Starting at the given char and printing the rest would be easier. Assuming uppercase letters, the loop will need to run 25 - (inputChar - 65) times, increasing the char by one for each iteration. OP, this should work. You'll have to implement reading the letter from keyboard if that's needed. #include &lt;stdio.h&gt; int main(int argc, char *argv[]){ char inputChar = 'k'; // Should be read from keyboard int asciiIndex = 0; //Check if capital, small or none: if(65 &lt;= inputChar &amp;&amp; 90 &gt;= inputChar){ asciiIndex = 65; } else if (97 &lt;= inputChar &amp;&amp; 122 &gt;= inputChar){ asciiIndex = 97; } else { printf("Not a letter.\n"); return 1; } int iterations = 25 - (inputChar - asciiIndex); for(int i = 0; i &lt; iterations; i++) { inputChar++; printf("%c\n", inputChar); } return 0; }
:D
Please put four spaces in front of each line so the code appears in a mono-space font. Also, you might want to provide more information about the code.
Beat me to it :) I was contemplating whether to do it this way printf(&amp;(letter - 'a' + 1)["abcdefghijklmnopqrstuvwxyz"]); for extra credit. Another variant (without `&amp;`) would be printf("abcdefghijklmnopqrstuvwxyz" + letter - 'a' + 1); Of course, any of these defeat the primary purpose of my original variant: make it independent of the underlying character table. P.S. For extra WTF points one can "optimize" `+ letter - 'a' + 1` into `+ letter - '''`. ("Backtick" character #96 is meant here, I just can't figure out reddit formatting to type it in.)
If you don't care about preserving case, just turn everything into lower or upper case and then pass through the cypher. That would be really easy to do, just change each char using toupper or tolower. 
Maybe I'm not understanding what you mean by "one input", but you can't do what I think you are describing with `scanf`. You should do this (or some version of it) instead: scanf("%u", &amp;unsignedIntVar); floatVar = unsignedIntVar;
Scanf can not read one input into multiple variables, so you need to find a way around that. One way would be to read the number as a string and then parse the string to get both uint and float representations. As an example: #include &lt;stdio.h&gt; int main() { printf("Enter a number: "); char num[200]; scanf("%s", num); unsigned int asUInt; float asFloat; sscanf(num, "%u", &amp;asUInt); sscanf(num, "%f", &amp;asFloat); printf("UInt: %u\nFloat: %.6f\n", asUInt, asFloat); }
http://linux.die.net/man/3/system Though unless you actually want the formatted output from hexdump, you're probably better off just reading the data in with fread or similar...
I want The exact output of hexdump 
&gt; It is a fantastic book to read if you already know how to program but it is terrible as a true beginners book. Doesn't it actually say toward the beginning that it's meant for people who already know programming?
 scanf("%f", &amp;floatvar ); This reads the value in to a float. If you want to know how that is represented, you can cast cheat one of a few ways. This is not going to be consistent across platforms, fyi. char p[sizeof(float)]; memcpy( p, &amp;floatVar, sizeof(float); Now you can loop through and print out the values of p[0] through p[sizeof(float)-1]. 
http://en.wikipedia.org/wiki/Iterator_pattern The *rem* member of xcb_screen_iterator_t is a flag indicating if there are any remaining items in the collection. Your first variation always returns screen 0; i.e., where you run the loop with screen_nbr == 0. Your second variation has a type error. The XCB documentation is poor, and I have been resorting to consulting the source code directly. However, XCB autogenerates a lot of code from protocol specifications, so you may have to build the code to read it.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Iterator pattern**](https://en.wikipedia.org/wiki/Iterator%20pattern): [](#sfw) --- &gt; &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), the __iterator pattern__ is a [design pattern](https://en.wikipedia.org/wiki/Design_pattern_(computer_science\)) in which an [iterator](https://en.wikipedia.org/wiki/Iterator) is used to traverse a [container](https://en.wikipedia.org/wiki/Container_(data_structure\)) and access the container's elements. The iterator pattern decouples [algorithms](https://en.wikipedia.org/wiki/Algorithm) from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled. &gt;For example, the hypothetical algorithm *SearchForElement* can be implemented generally using a specified type of iterator rather than implementing it as a container-specific algorithm. This allows *SearchForElement* to be used on any container that supports the required type of iterator. &gt; &gt; --- ^Interesting: [^Behavioral ^pattern](https://en.wikipedia.org/wiki/Behavioral_pattern) ^| [^Iterator](https://en.wikipedia.org/wiki/Iterator) ^| [^Coroutine](https://en.wikipedia.org/wiki/Coroutine) ^| [^Visitor ^pattern](https://en.wikipedia.org/wiki/Visitor_pattern) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpbi22p) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpbi22p)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
No issue FUZxxl. Just keep guiding
True .. I am not getting any errors. iter = xcb_setup_roots_iterator (xcb_get_setup (c)); screen=iter.data; This 2 lines are compiled successfully without any errors
Yes I understand that. But I am still in some confusion. Is it possible to get the info of the last screen?
"Last" in what sense? Last in the iteration sequence defined by `xcb_setup_roots_iterator`-`xcb_screen_next` functions? This will get you the last screen in the iteration sequence iter = xcb_setup_roots_iterator (xcb_get_setup (c)); for (; iter.rem; xcb_screen_next (&amp;iter)) screen = iter.data; But what's the importance of that "last screen"? Why would you want to do that?
These two lines are perfectly OK. My remark about errors was specifically referring to your screen = xcb_setup_roots_iterator(xcb_get_setup(c)); line, which you quoted in your original post. 
This is not guaranteed to work - that's why I didn't post it above. It will probably work, but it is not 100% correct C.
What on earth is a union for then if you set in one and get from the other? That makes no sense at all. Please don't tell us a story about how you use it for OOP either, because no one wants to hear that.
Wow, so lots of problems to try to understand. I'll take what you said and try to patch it up. 
There's only one real problem: the first one. You have to reset `C` to point back to `S` on every iteration of the outer cycle, before starting the inner cycle. Additionally, I don't understand why you return `S` from your function. In the end `S` will point to the last element of the list. Did you really want to return a pointer to the last element of the list? The rest are just remarks/requests for clarification. Here's how I'd implement it struct node* sortnode(struct node* N) { assert(N != NULL); for (struct node *S = N; S-&gt;next != NULL; S = S-&gt;next) for (struct node *C = S-&gt;next; C != NULL; C = C-&gt;next) if (C-&gt;data &lt; S-&gt;data) { int tmp = S-&gt;data; S-&gt;data = C-&gt;data; C-&gt;data = tmp; } return N; } (Not thoroughly tested). But again, this implementation swaps node data (just like yours) instead of relinking the nodes. I don't know whether you need the former or the latter.
Well, if I understood your intent correctly, your selection sort swaps the smallest data to the beginning of the list. After that it continues to work with the shorter version of the list (beginning from the second element), then even shorter (form the third element) and so on. This will work. So, each time the inner cycle should start from a new element located further down the list. I.e. `C` should be reset to `S` (or to `S-&gt;next` as in my version), not to `N`. &gt; still only get a "(first value)-&gt;NULL" when I print I strongly suspect that what happens is that you use the return value of your `sortnode` as the beginning of the "new" sorted list. As I said above, your version of `sortnode` returns a pointer to the last element of the list for some reason. Don't do that. If makes more sense to return `N` from your function, not `S`. Your function does not change the structure of the list. Just as before calling your function, `N` remains pointing to the beginning of the list after calling your function as well.
This works great (had to initialize outside of loop cause we have to use c89 though) thanks for helping me understand. I got a test tomorrow and I'm worried I might not do too well if I couldnt even understand why it wasn't working on my own :\
Thanks so much for explaining this all so well, sometimes peoples help on here doesn't help me cause it's not dumbed down enough for me. I really appreciate it.
Be careful! Such code breaks on systems that use EBCDIC as in EBCDIC, the letters are not continuous. Not that OP's code would ever run on an IBM mainframe but it's important to keep this in mind.
Even better would be to not make any assumptions about the character set at all beyond what is written in the C standard (i.e. 0 to 9 are adjacent and all characters specified in the C standard are in it).
Thank you for the quick response, and I was under the impression that it would be a rather open-ended question. To be quite honest, since I have no particular use for them at the moment, I was looking up information so that I could grasp the grasp the concept of them. From my understanding, the point of them would be to manipulate integers on a binary level. But that understanding seems awfully...vague, for lack of a better word. I guess I was looking for working examples of bitwise operators in code, since I am more of a hands on learner and I understand theory better once I see the theory being employed.
This is fantastic! Thank you bundles, I appreciate it immensely! 
People like you make the technical subreddits so fantastic, and motivate me to get my ass off of /g/ I will have to mess around with that stuff later, seeing how useful it appears to be. [Tausend dank!](http://i.imgur.com/QqpuKs0.gifv)
A union has no way to keep track of what it has stored, so C isn't ever going to care if you assign it one thing and fetch it as something else. It literally has no way of knowing. It's like a fancy void pointer that saves you the trouble of having to cast.
Right, that is left to the programmer to determine. Using unions to convert from floats to integer values invokes undefined behavior. That's what I was trying to point out to the OP.
Two different people have told you now that C99 dictates that it is not undefined behavior.
String literals have static storage, so the code is fine - as long as you don't try to modify the string. From the [C99 standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf) (6.4.5 String literals): The multibyte character sequence is then used to initialize an array of static storage duration [...]
Neat, thanks
&gt; everywhere I use that string literal is pointing to the same address. This is the part that's platform dependent, I believe. The literal will be stored with static duration, possibly in read-only memory. But I don't think you're guaranteed that the same literal will have the same address, so any comparisons need to be done with `strcmp`. Now, this normally applies when the same literal is used in different translation units, and I'm not sure what happens if they all come from the same function. Maybe there's a guarantee there. Someone a bit more familiar with the standard can either correct me or back me up on that.
Good to know, thank you. Boy is my face red... I was trying to reduce the size of the code because we are out of room in the processor (we run code from flash memory on the DSP) and I noticed someone had used the same generic error message as a string literal all over the place so I replaced them all with a global const thinking I had saved a few dozen words of codespace... oh well.
In pre-C99 C language using unions for type-punning was immediately qualified as undefined behavior. In post-C99 C language using for type-punning does not immediately qualify as undefined behavior. It has a *potential* for undefined behavior, but only if type-punning leads to trap representation in the union field being read. There's a huge difference between the two. This difference is what I'm talking about.
Making such claims is no different that claiming that adding two `int` values using operator `+` in C leads to undefined behavior, because exact range of `int` is not defined and signed overflow triggers undefined behavior. Yes, everybody understands that the potential for the undefined behavior in operator `+` is there. And one can even claim that from academic point of view arithmetic `+` *produces undefined behavior in general case*. But at the same time everybody uses arithmetic `+`. Everybody just makes sure overflow does not happen on their specific platform for their specific `int` range. The entire C language is designed around the idea that users are supposed to know what they are doing. Without it, virtually everything in C is "undefined behavior". The same applies to type-punning through unions. The language explicitly made it legal to use unions for type-punning. But what you can type-pun and what you cannot type-pun will depend on the particular details of specific platform. Type-punning IEEE 754 `float` with 32-bit `unsigned` is sufficiently safe.
Obviously. The point remains; C doesn't care if you mangle your data or not. The use of the phrase 'single variable' as to what a union stores is simply to tell you that you cannot put one value in .foo and one value in .bar and have them not run over top of one another. It has nothing to do with you putting it in .foo and retrieving it from .bar.
The program likely crashes. On my computer (latest kernel/gcc), the string gets stored in read-only memory and any changes to it causes a segmentation fault. If you want to, you could allocate you own memory that is read, write, and/or execute only using the mmap() function.
The `%c` specifier for `fscanf` requires the corresponding argument to be the *address* of a character. So if you want to read a character into `letter[i]`, then you need to pass `fscanf` the *address* of `letter[i]`, which is `&amp;(letter[i])`.
Shouldn't it be argv[1] and don't you have to use atoi() to cast it to an int as well? So something like this: int n = atoi(argv[1]);
What you're looking for is tail-recursion.
Every first received (bit?) of 8 gets ORed into undefined output bit 0. The other 7 bits are superfluously multiplied by 1 before being shifted out into oblivion. Duh. 
Any iterative program can be expressed as a recursive program
Kind of close, this is greatly simplified from the original code; output was a previously zeroed out packet buffer (otherwise it would merge with the input) This is essentially binary to 8 bit conversion, so what you should end up with in this example is [0b11110101, 0b01101010 ] -&gt; [ 0xf5, 0x6a ] -&gt; [ 245, 106 ] Converting back requires the number of input bits if you don't have a multiple of 8 to begin with.
You could define a struct: struct result { int n_m1; // n minus 1 int n_m2; // n minus 2 } Now pass a pointer to that struct recursively along with the basis: fib(int n) { ... struct result r; fib(n-1, &amp;r); return r.n_m1 + r.n_m2; ... } Basically have the tail function fill in the prior two values into "r" and go from there.
This is actually more of a computer-science question then a C-programming question, but that's fine, it's still answerable. The answer to how to accomplish this isn't very obvious honestly, but the key is that you need to think about the program from starting from the beginning of the sequence rather then trying to work back from the end. Currently, your algorithm works like this: We need number 5 Number 5 = fib(4) + fib(3) We need number 4 Number 4 = fib(3) + fib(2) We need number 3 Number 3 = fib(2) + fib(1) We need number 2 Number 2 = fib(1) + fib(0) fib(1) = 1 fib(0) = 1 Number 2 = 1 + 1 = 2 fib(1) = 1 Number 3 = 2 + 1 = 3 We need number 2 ... As you can see, you work 'backwards', starting at saying you need 'Number 5' and work backwards to find all the numbers before it. As you can also probably see (Though I didn't expand enough to really show) there's going to be lots of duplication in this approach. When calculating 'Number 3' the first time, we had to calculate fib(2). But, we also need to calculate fib(2) for 'Number 4', meaning we calculate fib(2) more then once even though it's going to return the same value both times. This will happen for 'Number 3' as well, and lots of times for fib(2). This issue grows exponentially for higher Numbers, so with 'Number 10', 'Number 9' will be repeated twice, and 'Number 8' will be repeated four times, and etc... Thus, this is a very slow way to calculate the fibonacci (Which you may have already noticed). But, a big thing to note is that we *do* know the value of fib(1) and fib(0), they're both 1. And remember, we define the fibonacci like this: fib(n) = fib(n - 1) + fib(n - 2) And if you express it starting at the beginning with two 1's, you get this sequence: 1, 1, 2, 3, 5, 8, 13 And written, out, those values are just this: fib(0) = 1 fib(1) = 1 fib(2) = fib(0) + fib(1) fib(3) = fib(1) + fib(2) fib(4) = fib(2) + fib(3) fib(5) = fib(3) + fib(4) fib(6) = fib(4) + fib(5) Now, the cool (and obvious, when you think about it) thing here is that you only need to keep track of two actual values to calculate the next fib number. With the other approach, calculating fib(4) required calculating fib's 0 to 3 recursively. In this case though, calculating fib(4) only requires knowing the result of the last two additions, and thus you don't need to make any recursive calls at all. Imagine if we calculated all of this with separate int variables: int a, b, c, d, e, f, g; a = 1 b = 1 c = a + b d = b + c e = c + d f = d + e g = e + f There's an obvious pattern. In particular, note how calculating 'd' doesn't require the value of 'a', and 'e' doesn't require the value of 'c'. So when we're calculating those values we don't need to worry about keeping those values around. So you can just replace them. Like this (Note, you do need a temporary to do the swap, hence my 't' variable): int a, b; a = 1; b = 1; { int t = b; b = a + b; a = b; } The block of code preforms one iteration of the fibonacci, by taking the second number this iteration ('b') and making it our first number for the next iteration ('a'). It also calculates the second number for the next iteration, which is just 'a + b'. It may sound confusing but think about this loop: int num = 3; int i; int a = 1, b = 1; for (i = 0; i &lt; num - 1; i++) { int t = b; b = a + b; a = t; } That the same block of code, but in a loop. In this fashion, the more times we loop that block of code, the 'higher' fibonacci number we calculate. For number 3, we need to run it 2 times. For number 4, we need to run it 3. We have to run it one less times because we start with the first two values per-defined as 1 and 1. You could equivalently define it like this: int num = 3; int i; int a = 0, b = 1; for (i = 0; i &lt; num; i++) { int t = b; b = a + b; a = t; } This works the same, but you now need to loop 3 times for number 3, and 4 times for number 4, etc... This is because we start one step 'back' in the sequence (0 and 1 instead of 1 and 1). I mention that simply because I find starting with 0 and 1 easier then starting with 1 and 1, since you don't have to worry about looping one less time. It's easy enough to throw this into a function: int fib(int num) { int i, a = 0, b = 1; for (i = 0; i &lt; num; i++) { int t = b; b = a + b; a = t; } return b; } This returns the correct fibonacci value for all 'num's &gt;= 0. (With fib(0) defined as 1). Now, we have a 'problem', this isn't actually defined recursively! Personally, I would consider this 'better', or easier to follow then a recursive version, but defining it recursively sounds like a requirement in your case. I'll mostly leave this up to you since I've already described in detail the algorithm to calculate the nth fibonacci number using a loop. You should think of the recursive calls as 'iterations' of the loop though. If you're having trouble turning this into a recursive algorithm, feel free to ask for some help and I can try to point you in the right direction. I apologize that the above is a bit long-winded, I'd be happy to answer any questions if you have them. 
If you're familiar with arrays, you can write the value of fib(n) to an array, that way you're still making a recursive call but shouldn't hit 2 recursive calls. Generally, storing the input -&gt; output mapping is called memoization and that technique might be what they're going for. I'd ask your instructor if this is the solution they're going for, it's a little of a contrived problem when you know the fastest way already, so some guidance is a good thing
How did you upload your code like that?
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 5. [**Closed-form expression**](https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression) of article [**Fibonacci number**](https://en.wikipedia.org/wiki/Fibonacci%20number): [](#sfw) --- &gt; &gt;Like every sequence defined by a [linear recurrence with constant coefficients](https://en.wikipedia.org/wiki/Linear_Recurrence_Sequence), the Fibonacci numbers have a [closed-form solution](https://en.wikipedia.org/wiki/Closed_form_expression). It has become known as __[Binet](https://en.wikipedia.org/wiki/Jacques_Philippe_Marie_Binet)'s formula__, even though it was already known by [Abraham de Moivre](https://en.wikipedia.org/wiki/Abraham_de_Moivre): &gt;&gt; &gt;where &gt; --- ^Interesting: [^Metallic ^mean](https://en.wikipedia.org/wiki/Metallic_mean) ^| [^Carmichael's ^theorem](https://en.wikipedia.org/wiki/Carmichael%27s_theorem) ^| [^Pell ^number](https://en.wikipedia.org/wiki/Pell_number) ^| [^Fibonacci](https://en.wikipedia.org/wiki/Fibonacci) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpdhnvz) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpdhnvz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It's not a good idea to think about the problem by thinking about what kind of control structures you are going to need. Try to think of a way to solve the problem and then see what control structures are suitable. In this case, try to write down all strings coming from `01xx10x1x` in a systematic fashion. If you do this, can you write down how you did it in a detailed fashion? Tell me what method you would use. In the next step, we can translate that into a program together.
Thank you for spoonfeeding an answer! I wanted to give OP the chance to figure it out on his own but apparently that's not going to happen any more.
OP seems to have problems with getting ideas for how to tackle problems. Telling him what the right algorithm is (even roughly) is not going to help.
All righty, the only real requirement here, is that it has to be recursive. Okay, so, firstly, here are some example inputs and outputs I was given: ----------------------------------- **Input:** 01x0 **Output:** 0100 0110 -------- **Input:** xx **Output:** 00 01 10 11 -------- **Input:** 101x100x11x **Output:** 10101000110 10101000111 10101001110 10101001111 10111000110 10111000111 10111001110 10111001111 ------------ Something interesting I noticed, particularly regarding the last pattern is, of 8 different combinations, the first 4 versions of the first x was equal to 0, and the last 4 versions of that same x is equal to one. That's the total (8) divided by 2 (=4) for each group. Then the third x in the string switches off every 2. And the last x switches off every iteration. This might sound confusing the way I'm describing it, but here is a visualization to help: From the input "101x100x11x": - 101**0**100**0**11**0** - 101**0**100**0**11**1** - 101**0**100**1**11**0** - 101**0**100**1**11**1** - 101**1**100**0**11**0** - 101**1**100**0**11**1** - 101**1**100**1**11**0** - 101**1**100**1**11**1** The bold represents the x in each of the variations of the string. Notice that pattern? I don't know how we can use it, but it's all I've got right now from a systematic standpoint, aha. So, if I were to apply this logic to your proposed string, 01xx10x1x, I'd get... 1. - 010010010 2. - 010010011 3. - 010010110 4. - 010010111 5. - 010110010 6. - 010110011 7. - 010110110 8. - 010110111 9. - 011010010 10. - 011010011 11. - 011010110 12. - 011010111 13. - 011110010 14. - 011110011 15. - 011110110 16. - 011110111 At least, I believe it would result in this. I got 16 iterations because I counted up from the rightmost x and multiplied by 2 until I reached the leftmost x, then multiplied by 2 again. So basically, number of iterations = 2 raised to the number of x's, or 2^n Is that enough information?
&gt; Is that enough information? Is it enough information for you? How did you create the last list? Can you write down instructions on how to generate it entry per entry? I'm not really interested in what the list looks like (the problem description is clear), but rather I'd like you to understand how to make this list. Take a pen and a piece of paper and try to understand how you are creating the list from the string. Then write down the steps you took in English; we can later translate that into C.
Haha, I promise I came up with my response to your comment above before even reading Rhomboid's comment. I've just been under a lot of stress with finals week and all, and its been difficult to think lately, I guess. It's 4 AM and I have class tomorrow, and I'm sitting here trying to pound out these programs so my grades don't suffer. Thanks to both of you, by the way.
&gt; It's 4 AM Yeah, that might explain things. I think you might need some sleep.
Firstly, we can determine the number of variations of the original binary code based on the number of x's, through the equation of 2 raised to the number of x's. Let's call this number numVar. Secondly, in regards to the leftmost x in the series, in the first (numVar/2 = 8) variations, this x will equal 0. In the last (numVar/2 = 8), it will equal 1. For the second leftmost x, the x in the first (numVar/4 = 4) iterations will be equal to 0, then the next (numVar/4 = 4) will be equal to 1, and this pattern will continue to alternate throughout the variations. The same thing can be said for the second rightmost x, which would alternate every (numVar/8 = 2), and the rightmost x, which would alternate every (numVar/16 = 1).
1. Use a for-loop function to count the number of x's in the given string, and assign it to num_x. 2. Assign 2^(num_x) to the number of variations variable, which we'll call numVar. 3. For the first iteration, all the x's would be equal to 0. After this is where it gets tricky, because recursion is required, and I'm pretty sure I have to emulate the order in which these numbers are generated in order to satisfy the tester program. I'm not sure how I'd set up something that pumps out the n-th entry based on the input of a singular number, n. Unless, I maybe developed some kind of deep for loop like this: ...for numVar/2 iterations, x1 = 0 for numVar/4 iterations x2 = 0 for numVar/8 iterations x3 = 0 for numVar/16 iterations x4 = 0 ... The number of iterations gets halved each time until it reaches 1, then it will have reached the rightmost x.
I'm glad you found that part easy. Personally, I'm a bit surprised your professor/teacher didn't explain or show how to do the fibonacci iteratively like that, considering that it's not just a simple case of optimization.
For the approach you found, you don't need recursion. There is a different approach (cf. [Rhomboid's post](http://www.reddit.com/r/C_Programming/comments/2yw3pf/weird_binary_permutation_problem/cpdiy37)) that uses recursion, but yours doesn't need it. Again: Do not start with the control structures you use. Use what is required for the approach you chose, not what others tell you they used. You can compute 2^*num_x* with the C expression `1 &lt;&lt; num_x`. I give you one further hint: You can get the value of the *n*-th bit of a number *x* with the expression `x &amp; 1 &lt;&lt; n`. Observe the pattern in which the *n*-th bit of *x* changes as *x* goes from 1 to 2^*num_x*.
The notation `a &lt;&lt; b` is equal to *a* · 2^*b*; it's a bit-shift where the bit pattern in *a* is shifted left by the number of bits specified in *b*. I hate when I get an assignment that must be solved with technique *x*, but if it's that way I can't do anything about it. The approach of /u/Rhomboid is generating the numbers in the right order. Go for it.
The recursive version is by far the simplest and most natural option here. It could be coded in 2 lines and in fact this seems to me like a great example for learning about recursion. 
You've got to know how to implement ideas in C code before you can effectively select an algorithm to implement. In this case, the way you'd solve the problem on paper is actually not easily translated into C.
Well... you solve it first (even if your solution is huge -- so long as it works) and then compare with experienced coders' solutions afterwards; that's a much better way to learn. Even though it seems annoying at first :) You've got to encounter a problem to best appreciate it.
Yeah you're right, there has been some confusion between when something is an address and when it isn't, this makes it all clear now. I was up coding for a good amount of hours yesterday and it felt like i'd hit a brick wall when i couldn't get around this issue but i should be able to use this example to finish off my assignment. Thanks for all the help! (And to the other 2 posters)
Reading over what you wrote again, I realize I misunderstood you, sorry xD I thought you had figured out how to do it recursively. I'll give you a few hints. There are actually two ways to do it (I think). One of the other posters outlined, and then my solution. I'm *guessing* your instructor is referring to the other posters method, since that method requires pointers. IMO, 'my' method is better since it it's actually tail-recursive (It can be broken down straight into a loop), and the usage is less confusing. Focusing on the algorithm I outlined before, it just becomes a case of turning a loop into a recursive algorithm. If you've been talking about recursion, then I'm *guessing* the instructor has mentioned tail-recursion before. The basic idea behind tail-recursion is that your recursive call is the only thing that happens right before you return. The cool thing about this type of recursion is that it can be straight-up turned into a loop. Ex. int recur(int r1, int r2, int count) { if (r1 == 0 || r2 == 0) return count; printf("I'm in a retur call!\n"); return recur(r1 - 1, r2 - 1, count + 1); } This is a useless function, but it's just to show tail-recursion (Which the above is). Since we know this is tail-recursion, we can turn this into a loop. Turning it into a loop simply requires looping over the contents of the function, and replacing the variables holding the previous function arguments with the next set of the function arguments. You get something like this: int recur(int r1, int r2, int count) { while (1) { /* Start of function body */ if (r1 == 0 || r2 == 0) return count; printf("I'm in a retur call!\n"); /* End of function body */ /* Start replacing arguments */ r1 = r1 - 1; r2 = r2 - 1; count = count + 1; /* Done replacing arguments */ } } You can try it, it should (assuming I did it right) execute exactly the same as the previous recursive function. Notice how the body is *exactly* the same up until our 'return' that holds our 'retur' call. Instead of actually calling 'retur', we just replace the old variables holding the last calls arguments (r1, r2, and count) with the new arguments (r1 - 1, r2 - 1, count + 1). When we loop again then, it's *like* we call retur again, but infact we just gave the same recur new arguments to use. IMO it's a pretty cool optimization. The reason I bring this up is that our original fibonacci function is a loop very similar to this one, so you can turn it into a tail-recursive call. I'll give you a little nudge, this is a refactoring of the fibonacci alg: int fib(int iter) { int a = 0, b = 1; while (1) { if (iter == 0) return b; int t = b; b = a + b; a = t; iter = iter - 1; } } Notice how I implemented that algorithm using a 'while (1)', to make it similar to the other algorithm above. I got rid of the 'for' loop by counting down using 'iter' instead of counting up to iter using a separate variable. Thus I would recommend first splitting the contents of the while loop into the function body and the argument replacement. From there it should become a bit more clear what variable you'll be passing to your fibonacci function (You'll probably want two functions, one function that just takes the 'iter' value like above that calls another function with the starting values for some extra variables). 
Check out my blog post on this. It features a visualization. http://keithy.me/fibonacci-calc/
This must be one of those ridiculous exercises when the teacher actually tells you what the code should look like and how many calls you should make. I don't know what such exercises are supposed to teach, but you gotta do what you gotta do. An obvious way to approach this problem is to notice that after you perform your *two* recursive `fib` calls in your code, you *exit* from your current `fib` call. You *abandon* your current `fib `call. This is wasteful. Instead of abandoning your current `fib` call you can stay in the current call and make it do extra work. Specifically, you can make it perform the work of one of the recursive calls. That way you will get rid of one of the recursive calls. For example, instead of making a recursive call to `fib(n-1)`, let's add a cycle to the current call which will calculate `fib(n-1)` right here. We will keep a recursive call for `fin(n-2)`, but not for `fib(n-1)` unsigned fib(unsigned n) { unsigned r = 0; // 'r' is our future result, which we'll calculate as a sum // Now we are supposed to add 'n'-th Fibonacci number to 'r' do { // This iteration is supposed to add 'n'-th Fibonacci number to 'r' if (n &lt;= 1) { // Easy - add 1 and we are done r += 1; break; } // Otherwise, add 'n-2'-th Fibonacci number to 'r'... r += fib(n - 2); // ...and then ask the next iteration to add 'n-1'-th Fibonacci number to 'r' --n; } while (1); return r; } This is, of course, a very inefficient way of finding the n-th Fibonacci number, because of the dumb recursion, but apparently they require you to make that call...
I don't see any code, so I'm assuming you are doing something like: char array[ 9 ]; ... dostuff( array ); ... void dostuff( char *array ) { printf( "Why is this not nine: %d\n", sizeof( array ) ); } You can only use sizeof on an array that is local in scope to wherever you are using sizeof. If you pass it to a function, what is actually passed is a pointer to the first element. (Otherwise you couldn't actually modify the contents of the array inside the function.) Also, sizeof is going to give you bytes per element * number of elements when used in-scope: void arraysize( void ) { int array[ 5 ]; printf( "array is: %d\n", sizeof( array ) ); } EDIT: At the time of posting the link to the x-post wasn't resolving due to server issues.
I do not prefer `ncurses.h` over `curses.h`. The standardized API uses the include file `curses.h`; `ncurses.h` is not portable to other implementations of the curses API.
I'm really sorry, I had tons of work because of school and stuff but I'm free now. Do you still need help with this?
Well, long isn't a problem, if only I could get that far.
Not directly. What is your use case for this? Maybe there is a different solution for your problem?
I know this might not be helpful, but using a recursive function to calculate the fibonacci is super, duper inefficient. You can do it in a loop without any recursiveness. In fact, a naive fibonacci approach is often used to highlight how dynamic programming works, because it solves the same call several times. ...any chance the instructions said "using just *one call*" ? because in that scenario, what I just said solves your task. int N = 20; // finds the 20th fibonacci number int n = 0; int n2 = 1; for (int i = 2; i &lt;= N; i++) { int newVal = n + n2; n = n2; n2 = newVal; } return n2;
Regarding the border, that's an awesome idea-- the kind of thing I'd never think of just staring at my code. I was wondering about the char/decimal thing. It's easier to read as a char, but thought maybe because I'm comparing and incrementing it might be better to show as a decimal until printing. But now I know. Thank you! 
A character constant *is* an integer constant. The character constant&amp;nbsp;`'.'` is exactly the same thing as the integer constant&amp;nbsp;`46` (on an ASCII machine, at least).
You post isn't exactly readable, try formatting your code properly. Use four spaces before any code and other output. That will make reddit ignore markup symbols as well. 
Why was this downvoted? If you know the iterative solution to the problem you can convert it to a recursive program. This also happens to be the solution. 
Ok thank you for your help, but one more question: Having to deal with every type separately isn't it considered as redundant programming? I mean after all, I am going to write the same function three times!
What is this function doing that you can write exactly the same code regardless of the type of the input? You may be able to extract the common functionality (using a function that takes an argument of type `void *`, say) if there really is redundancy in the code.
None of what you described is possible. The closest you can come is passing a pointer to void, but then you'd have to also pass some other argument that tells what the actual type is. And you have to write 'n' different versions of whatever you were going to do with the variable; there's no way to access an array without the compiler knowing its static type. Here's a contrived example: #include &lt;stdio.h&gt; enum { TYPE_SHORT, TYPE_INT, TYPE_DOUBLE }; void sum(void *arr, int type, size_t num_elem) { if(type == TYPE_SHORT) { short *data = arr, total = 0; for(size_t i = 0; i &lt; num_elem; i++) { total += data[i]; } printf("Total: %hd\n", total); } else if(type == TYPE_INT) { int *data = arr, total = 0; for(size_t i = 0; i &lt; num_elem; i++) { total += data[i]; } printf("Total: %d\n", total); } else if(type == TYPE_DOUBLE) { double *data = arr, total = 0.0; for(size_t i = 0; i &lt; num_elem; i++) { total += data[i]; } printf("Total: %f\n", total); } else { puts("Unknown type."); } } int main(void) { short shorts[] = { 1, 2, 3, 4 }; int ints[] = { 500, 600, 700 }; double doubles[] = { 8.5, 9.25, 1.125 }; sum(shorts, TYPE_SHORT, sizeof(shorts) / sizeof(shorts[0])); sum(ints, TYPE_INT, sizeof(ints) / sizeof(ints[0])); sum(doubles, TYPE_DOUBLE, sizeof(doubles) / sizeof(doubles[0])); return 0; } There is no good reason to do it like this compared to writing three different versions of `sum()`, which has the advantage of the compiler being able to detect errors. In the example above there's a possibility to make an error by not matching the TYPE_FOO to the actual type of the array, which results in undefined behavior without any warnings. 
&gt; but that takes arbitrary array types and returns their size. That makes no sense at all. An array decays to a pointer when you pass it to a function, which means the array's size is not available to the function — in the example above it required passing it as an explicit parameter. What good would it do to have a function that returns that size? It would be a useless function that does nothing but return one of its parameters unchanged. &gt; you advice me to write three different functions for every type? No, not three different functions for each type — where are you getting that from? In the example there's one function that works with three possible types, but it would be better to write it as three different functions, each of which can handle one type. And there is no way to handle arbitrary types. You have to choose ahead of time what types you're going to support, they can't be arbitrary.
That function won't work anyway. You cannot pass an array to a function. Whenever you think you are passing an array to a function, what you are actually passing is a *pointer* to the first element of the array. So, in that code, the variable `array` is actually of type pointer-to-`int`. It's not an array! Therefore, `sizeof(array)` will return the size of a pointer-to-`int`, not the size of the array that the pointer points to. You cannot write a function to determine the size of an arbitrary array in&amp;nbsp;C. You cannot detect the length of an array in a function, because what is passed to the function is a pointer to the first element of the array. A function has no way to tell how long that array is if it isn't told that information somehow (and if there is no sentinel value at the end of the array, like the `'\0'` character at the end of a string). All `sizeof` expressions are evaluated at compile time, not at run time. Therefore, `sizeof` cannot be used for dynamic size calculations like the length of an array passed to a function.
That does not do what you think it does. You aren't passing an array to that function, you're passing a pointer. The function is computing `sizeof(int *) / sizeof(int)` which is going to be some constant that never changes, typically 2 (for LP64 and LLP64 platforms) or 1 (for ILP32 platforms.) 
I see, well thanks anyway :]
Then, how can we pass "The entire array" not a pointer? I come from a python background, where passing arguments is really intuitive so I admit that I am confused with those C particularities 
You can't.
You forgot to set `sx` to a meaningful value. Enabling warnings on your compiler would have caught that; please always compile with warning enabled. Also, you forgot to include `sys/types.h` which is a prerequisite to get `pid_t`.
The code is already indented and prefixed with blanks.
Thank you for formatting your code. For the future: You can edit posts after you made them by clicking “edit.”
Now that you made a [new post](http://www.reddit.com/r/C_Programming/comments/2z10sd) I did you the favour and deleted this one. Please continue with the discussion in the other post.
So what everyone has been neglecting to tell you is that you can write a macro for this. #define ARR_SIZE(array) \ sizeof(array) / sizeof(array[0]) This is type-agnostic and evaluates at compile-time to the size of any array, but it's not type-safe, so don't feed it a not-array. Of course, this is really not much better than simply writing `sizeof(A)/sizeof(A[0])` all over the place, but lots of people define this particular macro in their code.
`sx` is only set in the process forked after the line containing `if((sx=fork())==0)`. In the code following `if((rx=fork())==0)`, `sx` is undefined. I'm not sure what you intent to do with this code anyway.
is not a error message, is like "translated" from hexa to ascii, but i want to copy that message into a .txt file, but when i paste it in the .txt file it only copies the hexa values instead of the message translated.
I'm sorry, but I don't understand your problem.
What you're trying to do is called "generics" in other languages like Java or C++. This is not possible *directly* in C. There are a few possibilities: - Write multiple function (one for each type) - Pass a void* as a function argument and cast it Personally I'd suggest the first option with a little syntactic sugar with the preprocessor. You could for example define a macro that will be a proxy for your functions, something like: #define foo(type, arg) type##_foo(arg) This macro will call int_foo for foo(int, arg) and so on. 
Also, compiling with warnings as errors forces you to address warnings.
I dislike compiling with `-Werror` because gcc sometimes provides spurious warnings. It helps some times to turn off the offending warnings, but then I might lose out in cases where the warning is proper.
can you tell me which one is it?
a should be an int, not a char. EOF is negative, char can be unsigned. 
i want to use pthread.h, any idea how i can solve this?
&gt;i want to use pthread.h Should have said so. This "hello world" example i found on google implements pretty much what you want: https://computing.llnl.gov/tutorials/pthreads/samples/hello.c
You're not going to get much help if you don't post the code for your program.
Thanks! :)
I agree with you on the fact that `sx` is underfined for `rx`process, but how is it possible that I can send the signal to `sx`from `rx`and wake it up if the variable is undefined?
I'm not sure; it might be possible that `sx` assumes the value of 0 by chance so the signal goes to all processes in your current process group, including the process numbered `rx`.
hey Fuzzxxl... thanks for the response yeah i'm using windows 7 and this is the link to the main page of the espeak library api(http://espeak.sourceforge.net/index.html) thanks for helping :)
It is not with regards to the program. Both my program and a simple Hello World had the same problems. They run just fine once, then Eclipse starts screwing up after I trying running it again. Right now I got Code Blocks working so it is not my code, it is something with Eclipse. 
As /u/the-fritz mentioned, you can use C11's type generics to do exactly this. First you define the generic function as a macro: #define func(x) _Generic((&amp;x[0]), \ int*: ifunc, \ float*: ffunc, \ default: ifunc \ )(x) For arrays, you need the `&amp;x[0]`. Pointers work with just `x`. Then define your functions: void ifunc(int a[]) { printf("%i\n", a[0]); } void ffunc(float a[]) { printf("%f\n", a[0]); } That's it! For more information, check out [this article](https://gustedt.wordpress.com/2012/05/19/type-generic-functions-taking-pointers-or-arrays/) which contains exactly the example that you want (calculating array length).
This is the correct answer.
If the programs are really simple you don't have use an ide. Just edit locally on your machine with an editor (nodepad++ is good, i've heard) and compile with gcc at the command line. 
Better yet, stop using scanf all together. It's pretty terrible for any scenario where your input is not *exactly* formatted how you want. If there is any chance it's not the way it should be, you should really use something else.
Another nitpick: the signature for you main() function is wrong. You can do either `char** argv` or `char* argv[]`, but you can't combine them like you did. Your argv is a triple pointer when it should be a double pointer.
Holy shit So you are saying that I have been compiling in c89 this entire time? If that is the case, I feel like such a fool. And I thought that I did do that? wouldn't main(**int** argc, char *argv[]) do that?
No, I mean the _return type_ for main. So `int main() { ... }`. Side note, if you're not going to handle command line arguments, you do not need to declare them as part of the argument list for main. And yeah, you've probably haven't been compiling it to c11 if you're not saying `-std=c11` (gcc5 does default to gnu11, which is c11 with gnu extensions, but you probably aren't using gcc5). You should also always compile with `-pedantic`so it can yell at you about writing non-standard code. Warnings are good too `-Wall -Wextra`. 
FYI, GCC 5 will *finally* default to C11.
What "method of declaring" are you talking about specifically? Declaring of what? Your `main` is declared without a return type. It cannot be done in this way in C99. It cannot be done in this way in C11. Only C90 allows it. Your `unsigned int i` declared in `for` is only supported by C99 and later (including C11), but not supported by C90. Finally, the space before `%u` in your `scanf` format is harmless, but redundant. It does not achieve anything. 
Okay peeps, to keep the stupidity levels in this post down I am deleting it, because the information I am being given is starting to grow redundant. Thanks for the wonderful information. 
Please do not delete your post. It makes it so that people who have future problems like this difficult time finding it, and discourages people from helping you since they can spend a lot of time writing up an explanation that no one will ever see. It's pretty common etiquette. Imagine if everyone deleted everything once they got their answer. 
&gt; The default mode for C is now -std=gnu11 instead of -std=gnu89. [Source](https://gcc.gnu.org/gcc-5/changes.html). So, it's C11 plus the GNU extensions. As for release date, I'm not sure what the release date is besides "soon." GCC 5 is feature-complete for C++14, and is locked down to only fix regressions and documentation. [Phoronix](http://www.phoronix.com/scan.php?page=news_item&amp;px=GCC-5-Stage-4-Update) thinks it'll be March or April ... so any day, really.
Non-mobile: [IEEE floating point](http://en.wikipedia.org/wiki/Floating_point) ^That's ^why ^I'm ^here, ^I ^don't ^judge ^you. ^PM ^/u/xl0 ^if ^I'm ^causing ^any ^trouble. [^WUT?](https://github.com/xl0/LittleHelperRobot/wiki/What's-this-all-about%3F)
Thanks! Even when I specify how many digits I'd like %.6f, it stills shows 31.130001 instead of 31.130000. I guess my professor intended to show us this limitation. Thanks, dude!!!
Well, if you use `%.2f` you will probably get the desired `31.13` output. But in any case it will be a result of rounding at printing time. The variable will still hold something different from `31.13`. Which raises the question of what is meant by your "I have to give it 33.13".
Locks are usually used to protect data structures from simultaneous use. So you could make a variable, lat's say int turnA = 1; And before you print you check: //I Have a lock If (turnA) print &amp;&amp; turnA=0; else spin; //notice that you need to release lock if you do not have permissions to print otherwise you would deadlock //This is thread B -- I have a lock If (!turnA) print &amp;&amp; turnA=1; else spin; I don't know, maybe a silly example, but don't think of locks as system for locking code, but as a system of protecting shared data structures. If you notice in my example, only one thread has access to turnA (you need to get a lock, if you do not have permission to print you release the lock and sleep or do something else)
Well the focus here is for threads/locks. I'm using 2 functions just for ease of readability atm (as A/B can be later turned into 1 function that runs simultaneously) 
Yes I agree, I'm guessing it's a school project perhaps. I'm just saying think more of critical regions that your software has. It's data. When threads run same code at the same time, there is no threat that something will break, but problem is, the value of turnA can be cached by threadA and it will think it's okay to print while it is not. But since it is a shared variable, Intel cache has snooping which will synchronize shared caches when using locks (Intel has special instructions which run atomically) also, this cannot be reordered so cache has time to be coherent.
While your comment does sum up the general idea of a mutex, your code will actually not work in practice. Standard integer assignments are not atomic operations so thread A could actually read turnA, see that is 0 and decide that it can run. At this point the CPU suspends thread A to run thread B, which also sees a zero and decides to run. So thread B sets turnA = 1, and starts doing its thing. Then in the middle of thread B's critical section thread A gets scheduled to run again and B is suspended. Thread A will set turnA = 1 (even though it's already set to 1), and begin to execute its critical section. This is a race condition. To avoid this situation lock operations must be written using special CPU instructions which provide hardware support for atomic ops, such as CAS on x86 systems. That's why it's important to always use actual locks instead of just using ints updated manually.
what's the exact wording of the question? :)
Uninitialized pointer is not "a null pointer". 
Thanks for the response, Is there a more elegant way to do this rather than the ugly (but working Thanks, you) way you demonstrated above?
LibAVCodec is for encoders and decoders. LibAVFormat is for muxing, and demuxing.
How much do you need help with? Here's some tips on where to look for the functions and bits you'll need. - Getting the number of columns and rows from the input is going to need `argv`, which is the second argument to `main` and is type `char *argv[]` and `atoi`, which is in `&lt;stdlib.h&gt;` and converts a string to an integer. Old version - **probably not a good idea**: - To make an array that's variable size you need to use `malloc`, which is again in `&lt;stdlib.h&gt;`. You want a two-dimensional array, so you're going to need to call `malloc` in a loop to assign all the pointers. If you want to compare the data in columns, then you probably want to make sure that you index your array as `array[col][row]`. That will be slower to read in the data, but working on individual columns will be faster. Edited version: - To make a variable size array, you need `malloc` which is in `&lt;stdlib.h&gt;` as well. As was pointed out below, you want to allocate `nrows * ncols * sizeof (double)` bytes into one array, so you can hold all your data, then index it as `array[nrows*col + row]`, where `col` is the current column and `row`is the current row. Since each column will be all together in memory, it will be much faster to do analysis on afterwards. - To open a file and read from it you need to use `fopen`, `fclose` and `fscanf`, which are in `&lt;stdio.h&gt;`. `fscanf` takes basically (not exactly, but pretty much. A `double` needs `%lf` is the biggest difference) the same kind of arguments as `printf`, except you need pointers, not values. So a call looks a little like `fscanf (in_file, "%lf, %lf\n", &amp;dbl_one, &amp;dbl_two)`. **Edit:** Since I got into a discussion about speed concerns with /u/balkenbrij below, I ended up writing a test so we could find out what was fastest. It's not particularly pretty or overly neat, but if you would like to look at the code it's [here](https://gist.github.com/jakelishman/3ac8c8ec8953dcbead06). As a note, I used `strtoul` to convert the strings to `unsigned long`s, but if you're using `int`s then `atoi` would be fine.
Honestly, half of these function calls have been deprecated
It had indeed, been out-of-date and deprecated for a long time. But as of last month, dranger has updated everything. It's not perfect - the best source, if you are able to understand it, is in the "examples" directory inside the ffmpeg distribution. But as of last month, the dranger tutorial moved from "hopelessly out of date and doesn't even work" status that it enjoyed for the last few years, and into "acceptable"
&gt; You want a two-dimensional array, so you're going to need to call malloc in a loop to assign all the pointers. I'm not sure if that's the easiest way, what's wrong with allocating Xmax\*Ymax and using the offset Y\*Xmax+X? I never really understood why you want to allocate seperate rows even for more dimensions, i'd love to know why one would prefer one over the other. e: the main reason i use this is fragmentation btw, it's just a single allocated block of memory while when you malloc multiple times it could theoretically by fragmented. This can make a huge speed difference when working with matrices. Even looping them in the wrong order will make a huge difference; i had such a thing when using homebrew matmul in [fortran](http://www.reddit.com/r/fortran/comments/1v7x6z/array_operationscompiler_options/)
If you mean LaTeX source, it's a matter of preference; C is probably more relevant than document markup languages for programming resumes. If you mean baking a PDF with LaTeX, that's not the point.
(choice != 0) || (choice != 1) will always be true. I think you're trying to say (choice != 0) &amp;&amp; (choice != 1)
You want `&amp;&amp;` not `||`. As written, that if statement is always true.
Thanks!
Thank you much!
Yeah been having that issue too, i've just given up on it now since it was only worth a few marks
You give both of your semephore a starting value of 1. If you walk through you will see why you get two in a row each time. Set one of the semaphores to start at 0 and the other start at 1. Edit: You could also use the same thread function and just pass the parameters letter and semephore order differently, but that's not a functionality problem.
I never programmed for old systems - I'm still only undergrad at the moment, and I actually only learned how to program decently in the last two years. Allocating multiple times is something my first lecturer did, and even though I allocate in one big block when I do numerical stuff, my first instinct is to do it in a loop. I really should break that habit - I know it's not good when I actually think about it!
Don't worry about it. I didn't mean to lecture you.
I've made this mistake enough times that I look for it when things go wrong.
I have tried that (your first idea) but it leads to whichever function that has their semaphore set to 1 first to go first every time. Trying to get it so either 1 has a chance to start. 
I'm not certain that CPU cache lines matter when we're writing data to RAM, and if that's the case then we definitely want to transpose the data as we read it because we know that will make things faster when we use it later. I did a test with some quick code I stuck up on a [github gist](https://gist.github.com/jakelishman/3ac8c8ec8953dcbead06), and for `regular.dat` and `transpose.dat` being copies of each other, and 10 columns, 10000 rows with 100 repeats the average times were `2.686e-2`s and `2.677e-2`s, so there was no notable difference. Re-running the whole program produces some averages as low as `2.45e-2`s and as high as `2.80e-2`s, so there's no measurable difference between the two styles of indexing. **Edit** So I added a test for adding up the values in each column too, and found using the same settings that regular took `2.78e-4` seconds, and transpose took around half that at `1.45e-4` seconds, as expected. That said, the data operations take 100 times less time (though I was just summing the values), so it might have to be some reasonable amount of computation before it becomes worthwhile even thinking about! Also, when I increased the files to 100,000 rows (5MB files) then the read operations just multiplied by ten (essentially), but the gulf between the add operations widened significantly. The cache lines do play a big big part, as we expect. Here are my results, in milliseconds, for different numbers of rows. All experiments repeated 100 times: |**Operation** | 100 | 1000 | 10,000 | 100,000| |--|--:|--:|--:|--:| | Read, regular | `0.252` | `2.27` | `27.9` | `267` | | Read, transpose | `0.212` | `2.29` | `27.5` | `267` | | Add, regular | `0.00221` | `0.0374` | `0.323` | `8.85` | | Add, transpose | `0.00225` | `0.0149` | `0.146` | `1.42` | As we get more and more cache misses the time really shoots up - with 100,000 rows the regular one is 6x worse than the transpose one, and that's some serious time difference over a lot of calculations. The reading from the file appears to be unaffected by differences in the indexing, though.
so just choose which is a and which is b randomly.
Do you have to use semephores? You could do this with a condition variable too. Have both threads race to a variable, the first on there is evens the other odds. Then increment the condition variable and release, repeat the number of times needed.
Semaphores is the preferred method here, and the idea of a random generator crossed my mind but I felt that was going around the actual task at hand.
ok, so start them both at 0. The first one in to the function can up her own. Use a mutex to make sure only one of the semephores is uped.
To add to coryknapp's answer, he is suggesting that you don't return anything, but rather modify the variables in-place, like how `scanf` works. 
Don't want to just return a struct, which really is the easiest way? And no pointers? Return a _Complex double. ;) Edit: as a refresher, complex numbers have two components, a real and an imaginary part. They are often used as coordinates in math (look up the complex plane). They're a first class data type in C. Tah-da, problem solved. 
With the Development Tools including Xcode installed, the Mac is arguably the best programming environment on any platform. Unlike your current environment where the development environment costs an arm and a leg, Apple's development environments have a long tradition of being free. Prior to MacOS X, there were several expensive third-party development environments for the Mac, but Apple Macintosh Programmers Workbench (MPW) was absolutely free. The development environment for NeXTstep/OpenSTEP was free. For most of its history, Xcode was free. Under Snow Leopard, Apple moved Xcode to the Mac App Store and jacked its price up to $5.00. However, it is my understanding that this fantastic IDE is now free once again. Xcode is built around GCC, the GNU Compiler Collection. GCC includes Unix-standard C, C++, and many other languages. Although Java is now an optional download, Xcode includes built-in support for Java. You may run any of Xcode's supported compilers and many others from the Terminal command line if that is your choice.
This is a terrible method.
The two common ways to return multiple variables are: * returning a struct compromising the values you want to return * passing pointers to variables you want to write the values two All other ways to do that have limitations (like not being reentrant or being really uggly). You precluded the two possibilities, so my answer is: It can't be done.
A large part of answering questions is to understand what the person asking the question actually wants. Yes, technically your method works but it's not going to get through code review any time soon. My comment was made to discourage OP from using this approach because it's really a bad idea.
If you use that approach, the function is no longer reentrant. Keep that in mind.
&gt; Preferably without structs or pointers. Why? &gt; The flip side of this is a question like \`\`I want to accomplish *X*, but I don't want to use *Y*. What can I use instead?'' Which, again, is sometimes reasonable, and then sometimes *X* is closing a filehandle and *Y* is the \`close' function. &gt; &gt; — http://perl.plover.com/Questions.html
To give a bit more explanation, I start the array at size 100, because the user is instructed to enter the size of the array, and 0 &gt; size &lt; 100. So, I made the size 100, and I only ever modify the number of elements that the user specifies, and I only ever print the elements that have been changed by the user's instruction. However, in the function "mode" (which finds the element that happens most frequently in the range "size" of the array), I don't have "size". All I really need to do is find which index in "fcount" (frequency count) has the largest value, but I can't do that without "size" if I understand my problem correctly. Now then, when you say "use the first value in the array to store the array size", I'm not quite sure what you mean. And as far as the special value option goes, how would I know when to terminate it unless I knew the size that the user specified? Thanks for the responses, I appreciate the help.
Yeah, I thought that might be the case, but I figured I'd go to the internet for some input first before I bothered the TA.
OP's description doesn't forbid that. Just that each thread needs to print X times.
What I meant with “won't get through code review” is that code like this is clunky and does not belong into proper code. It's unacceptable and I don't want OP (who's clearly still learning) to think that he should write code like this.
Why wouldn't you use pointers? 
~~Just out of curiosity, would this not work for pushing on the end of the linked list, just more simply?~~ LINK add_element(LINK prev, DATA data) { LINK new = malloc(sizeof *new); new-&gt;next=NULL; new-&gt;data = data; prev-&gt;next = new; return new; } EDIT: Nevermind, I see yours is adding directly from the head, while mine adds to the tail.
But that requires pointers.
&gt; "A large part of answering questions..." -- is to pay attention to the actual question. He didn't want to use pointers or a structure. He said it right there. Plain as day. Some times you actually have to try to give people what they ask for. --- &gt; The general case is: &gt; &gt; 1. Someone wants to accomplish task *Y*. &gt; 2. They determine that a way to accomplish *Y* is to use facility *X*. &gt; 3. There is a sub-task of *Y*, say *Z*, for which *X* is ill-suited. &gt; 4. They come into the group and ask \`how can I use *X* to accomplish *Z*?'' &gt; &gt; This is a problem for people here trying to answer the real question, which is: &gt; &gt; *How can I accomplish Y?* &gt; &gt; But nobody can answer this question because the querent never mentioned *Y* at all, and so nobody knows that the real goal is to accomplish *Y*. Instead, they are likely to get a long list of more or less hacky ways to use *X* to accomplish *Z*, which is unfortunate. &gt; &gt; A more experienced programmer would not have chosen to use *X* in the first place. A more experienced programmer would have determined that *W*, not *X*, was the appropriate facility for accomplishing task *Y*. &gt; &gt; I like to try to guess *Y*, because I often feel that the best advice I can give is \`use *W* instead of *X*', and that the world is full of other people who will suggest the hacky workarounds. Guessing *Y* is very diifficult and error-prone. Worse, it's personally risky. Even when I am right, people may suspect that I'm being facetious. (\`\`The guy asked a perfectly clear question; why didn't you answer it?'') When I'm wrong, it's even worse, because I can't defend myself against charges of facetiousness by pointing out that my advice was good. &gt; &gt; Of course, the environment we have here where people do make facetious answers is conducive to that sort of misunderstanding. I wish people wouldn't do that, because it makes the environment distrustful, and the risky answers that I like to give are unsafe in such a distrustful environment. &gt; &gt; — http://perl.plover.com/Questions3.html
Yes, I know that it is possible to fiddle two bytes into a short, etc. I'm not questioning the fact that this is possible. Yet, doing so is not a solution (or a misleading solution at best) to OP's question. In the context of the C programming language, there are a lot of things you can do but a lot of them aren't a particularly good way of doing things, such as what /u/net_goblin suggests. “No you can't” is meant as in “No you can't unless you really want to do a clunky hack.”
But he does want a clunky hack. He knows the only non-clunky-hack methods already, and has dismissed them outright.
I know of this problem and it bites me quite often. What sucks though is when I purposefully ask a question that looks like an instance of this pattern but actually isn't. It's hard to convince people that they should stop looking for an underlying problem because there is none. Such questions often begin with a though process of “I wonder if…”
I'm not sure if he does. I think OP just hasn't realized yet that structs are the way to go.
Yes, it would. But for that you have to *know* the `prev` pointer, which is the pointer to the tail element of the list. This is exactly what I said above: it you want to have efficient insertion at the end of the list you have to *know/maintain* the pointer to the *last* element of the list. And, of course, you have to *know/maintain* the pointer to the *first* element of the list, i.e. you have to maintain *two* pointers. If you don't mind maintaining *two* pointers - go ahead and do it. But in this case it would make more sense to create a new "header" structure for your list that would store these two pointers together. 
This is not reentrant; it doesn't work if more than one thread calls the function supposed to return multiple values at the same time (cf. my remark from another comment).
He didn't say anything about needing it to be reentrant, did he? I simply removed them from his direct control, and disallowed him to have more than one coordinate pair. I didn't say it was a good idea -- but it is amusing to me.
I had a solution too without any bit fiddling, but it appears to have been downvoted.
The point is, while you state that the OP "clearly" is a beginner, you keep bringing in reasons which would be far too advanced for that case. I find this a major argumentative deficit. If the OP is too new for bit fiddling, why bring up thread/signal safety through reentrancy? And if we have a beginner, the probability of someone else using this code for serious stuff is actually extremely low.
http://pastebin.com/raw.php?i=gsUtqrd5
Tou have a typo getpoint (&amp;out); replace with getpoint (&amp;point);
 struct coord { int x; int y;}; struct coord foo(void) { return (struct coord){ 1, 2 }; } You just... return a variable or literal that is of a struct type.
You can't return an array--but you can pass an array (usually empty) to your function, which will place the values you want in the array. When it returns control to the calling code, the values will be there for you to work with, without you having explicitly returned anything from your function. It will look like this: int Arr[2]; getCoords(Arr); // then do stuff with the coords, which will be in Arr[0] and Arr[1] void getCoords(int A[]) { int x,y; //work out values for your coordinates A[0] = x; A[1] = y; }
It's used a lot in embedded programming. It's not that uncommon. There are no absolutes ( except this one.)
Are you sure? I thought here that `A` in `getCoords` has type `int *`, which is a pointer. It's just a pointer in disguise, because it's got array syntax. `A[0]` is just syntactic sugar for `*(A+0)`. For example, due to the syntactic sugar, `A[3] == 3[A]`. As such, this program will compile without warning (with `gcc -Wall -Wextra`) and produce the output `1 3`: #include &lt;stdio.h&gt; int main (void) { int A[] = {0, 1, 2, 3, 4, 5}; printf ("%d %d\n", A[1], 3[A]); return 0; }
You can return a pointer, which is a lot like an array. int *getCoords( void ) { int *rc = malloc(sizeof(int)*2); rc[0] = blah; /* X coordinate */ rc[1] = blahblah; /* Y coordinate */ return rc; } Yes, I know I didn't check the return value of malloc(). It's pointless to do so on modern OSs because of VM overcommits. Pedants can add that checking themselves. It's up to the caller to free that pointer when they're done with it: int *coords = GetCoords(); /* Use coords */ free( coords ); 
And if you want to do it without using malloc and free, you can pass by reference: int getCoords( int*x, int*y ) { /* Returns 0 on success, anything else on error */ if( x == NULL ) return -1; if( y == NULL ) return -1; *x = blah; *y = blahblah; return 0; } void func( void ) { int x; int y; if(getCoords( &amp;x, &amp;y )) { /* Error handling */ return -1; } /* Success */ 
Pointers and structs are concepts elementary to the C programming language. If you don't like using them, you are going to have a hard time programming in C.
I guess the downvotes are for being slightly insulting? But seriously, the answer to this question is "figure out pointers and structs".
Ah! That explains a lot! I completely forgot about strcpy(). Thank you so much for the help! Another question then: Do I still have to malloc() the string even when I've allocated memory for the stuct?
And assuming I do, when I free() the space of the struct, does it automatically free the space of the string inside of it?
&gt; "A large part of answering questions..." -- is to pay attention to the actual question. He didn't want to use pointers or a structure. He said it right there. Plain as day. Some times you actually have to try to give people what they ask for. +1 this so much. If a person is asking a question, assume they know they know what they're doing and why they're facing the restriction. Odd questions like are asked in a vacuum because the context tends to be odd and outlandish.
All right please post the rest of your code so we can help you properly, or at least where you define and initialise i, j, a, b, x.
`struct` defines a type. `typedef` does not define a type; it provides an alias for an existing type. This whole example is possible without `typedef`. In fact some programmers prefer not to use `typedef` with structs in C (I'm not one of them).
why is it when calling getCoords( &amp;x, &amp;y), you use '&amp;x' '&amp;y' if the function accepts pointers as its arguments? Doesn't the '&amp;' mean the address of what the pointer is pointing to instead of the value? Why do you not pass in the pointers?
We all have to start somewhere. Even Dennis Ritchie didn't have `structs` (or the equivalent construct) memorized as second nature in the beginning. 
As za419 said, I declared x and y as ints: int x; int y; If I were to call a function like getCoords( x, y ), it would not be able to change x and y. Any changes made would only apply inside getCoords. Example: int getCoords( int x, int y ) { x = 7; y = 3; return 0; int main( void ) { int x = 10; int y = 11; getCoords( x, y ); printf("X: %d y: %d\n", x, y ); } What do you think it will print out? It will print "X: 10 Y: 11". Why? Because getCoords can't modify things without going through a pointer. int getCoords( int *pX, int *pY ) { *pX = 7; *pY = 3; } int main( void ) { int x = 11, y=12; getCoords( &amp;x, &amp;y ); /* Convert int to int* */ printf("X: %d Y: %d\n"); return 0; } Now it'll print "X: 7 y:3". Does that make sense? The '&amp;' operator takes the address of something. It turns it into a pointer. If it's already a pointer, it'll make it a pointer to a pointer. The '*' operator is the opposite - it "dereferences" the pointer. So, above, pX is an (int *). 'Dereferencing' it makes it an int, which is what we want: *pX = 7; Because 7 is also an int. Does that make sense?
oh, thank you :)
&gt;It's pointless to do so on modern OSs because of VM overcommits. Could you go into more detail on that? To be honest, I hadn't heard this excuse to not handle errors in C before, so I might be missing something. It just seems to me like a bad example to give to an obvious beginner in the language, as I don't think what you're saying is completely correct (***tl;dr:*** *It's not actually pointless*). I mean, as far as I know, even on modern OSes it's not impossible for malloc to fail (if there is no block of free memory in the heap large enough to hold your variable, and the OS refuses for whatever reason to supply a new memory page to extend it). A considerable number of people disable over-commit on linux. And I know for a fact Windows 7 doesn't over-commit unless you actually call VirtualAlloc with flAllocationType set to MEM_RESERVE, something malloc doesn't use under the hood. I'm not sure if they changed that in Windows 8/8.1, but I doubt it. Discounting over-commitment, there are more reasons the OS might refuse to allocate a memory page (and thus causing malloc to fail), like exhausted *virtual* address space, or *per-process* limits on memory allocation (through linux ulimit, for example). My point being, if you don't check for failure, you might be entering undefined behavior territory, which is never a fun thing to debug. At most modern OSes make it *rarer*, not pointless. And then, once you leave such "modern OSes" for, for example, embedded systems (which if learning C is a very likely possibility in the future) and aren't used to checking for malloc errors (since you were taught doing so is "useless"), then you're pretty much screwed. I usually just create a macro to auto-abort (after writing something to stderr) if malloc fails, except if what I'm building really needs error handling for that situation (for example a library). With such a macro, malloc with basic error handling is just as much work as without. (Granted, on embedded systems, more complex error handling is most likely necessary)
You could put a char array instead of char pointer to your struct if you want. Then, the space for the string will be part of the struct, and will be allocated and freed together. So something like: char name[20];
First link leads to login page...
It is not correct to unconditionally claim that the OP *has* to use `malloc` and has to `strcpy` the original string to the freshly allocated memory. It is a matter of memory ownership and object lifetime, i.e. of 1) who owns the memory pointed by `name` pointer passed to the function by the caller, 2) how long that memory remains valid. If memory pointed by `name` is supposed to be handed over to the list (i.e. it is already properly allocated by the caller, already properly initialized and has the proper lifetime), then the current implementation is correct. All it needs to do is `new-&gt;name = name`. If the memory pointed by `name` is owned by the calling code, then this function cannot assume that `new-&gt;name = name` is a correct thing to do. This function has to allocate its own memory, which the list item will own, and `strcpy` the data there. Judging by the problem description made by OP, the `name` memory is indeed owned by the calling code and the list is not allowed to assume any ownership of that memory by doing `new-&gt;name = name`. I.e. the `malloc`/`strdup` solution is the correct one. But in general case it is not that straightforward. It is a matter of design.
That's a lot of lines of code to look at. You might be able to get more help if you provide more specific problems (which functions work or don't work? where are you stuck? what part you don't understand? etc)
I just hope your teacher doesn't google your code and find this thread. But I'll be saving this thread so I can implement this just for fun later on
That answer is _very_ incorrect. You need volatile any time a value being accessed could change outside of the function accessing it. For example, if there are multiple threads each accessing a shared global variable, it must be volatile. If it is not volatile, reads and writes are not assured to work between each of the threads or processes. Why? Because the optimizer can make assumptions that the value stays static through the whole loop. It can even get rid of the write if it doesn't see a subsequent read within the same function. Volatile is very important, and is definitely something that needs to be learned when dealing with threads, processes, and memory mapped hardware. http://www.embedded.com/electronics-blogs/beginner-s-corner/4023801/Introduction-to-the-Volatile-Keyword 
Like I said, my main goal for even mentioning it was just to get beginners thinking about it. Are you checking the return value of your printfs? There's lots of silly error checking, and lots of not silly error checking. Even if the OOM killer runs, it pretty much picks a process to kill at random. A better check might be to verify the arguments you're sending to malloc - are they reasonable? The number of times I've seen malloc _actually_ fail could be counted on one hand. Generally, the program is going to crash when that happens anyway - seldom cleanly. It's just fun to think about why we do what we do. If you can't justify it or explain what happens when the system is low on memory, blindly checking malloc() return values is not enough. 
Take a look at pthread condition variables. They're intended to allow threads to wait for or signal some condition. The pattern is very close to your first implementation...
Try compiling your code with optimization turned on, and watch what happens. Edit: -O3 if you're using gcc should introduce the behavior volatile will fix.
It's not about synchronization, at all. I'll say it again: It's not about synchronization. You can add all the mutexes you want - the compiler still can choose to optimize away accesses unless the variable is volatile. The code above might work sometimes, and it might not. If you add the 'volatile', it is guaranteed to work. Volatile tells the compiler that the value being accessed could change within the scope of the function, even if the function doesn't modify it. Without that, even with all the synchronization and atomic accesses, the compiler can still optimize the accesses away. Look at the link I posted above to embedded.com. It's a pretty good introduction to what volatile is and how to do it. That site is also a better resource than stackoverflow, which often has bad and incorrect answers. 
&gt; Now, I'm told this is a really really bad implementation because the while loop creates a formal busy waiting, i.e it keeps the CPU busy for nothing. Your ``while(counter &lt; 2);`` does indeed busy loop for no reason. &gt; Also, as I read here, it's not actually possible to pause a thread as it could be done with a process, so are the 2 implementation really different? Is the semaphore really pausing a thread? Note the subtlety between "pausing" a thread and "cause a thread to pause itself". A semaphore is a mechanism whereby a thread may pause *itself* until a shared resource becomes available. One could argue that "locking" said resource *de facto* pauses the thread but *crucially* this is at a time of the thread's choosing and not necessarily at the time the resource is locked. Contrast this with, e.g., POSIX signals whereby a process may be suspended at any time by sending it SIGSTOP without any co-operation from the target process and with no opportunity for the process to define when it gets stopped. &gt; If the use of semaphores is the way to go, how can semaphores be implemented under Mac OS? The exemplar solution you posted uses un-named semaphore which (IIRC) are not supported on OSX. In any case, again IIRC, the exemplar should really contain a call to ``sem_init``[1]. I'm by no means an expert on pthread so do verify this for yourself. Os OSX one has at least two options. Firstly, one could use a *named* semaphore via ``sem_open``[2] which is portable to other systems. Secondly, one could use the semaphore primitive in Grand Central Dispatch (GDC)[3]. So the question arises: how does the semaphore work? How is it different from your busy loop? In the absence of OS support, it is very difficult to implement synchronisation primitives without resorting to loops like this. (Said loops are sometimes called *spinlocks* if you want to see examples where their use is valid.) Even with OS support, locking can sometimes be expensive if taking the lock requires a context switch to kernel space and back. OSX and Linux took two different approaches to solve this problem. OSX layered a "fast-path" solution on top of pthreads (GCD) which doesn't need to go to kernel space in the common case of the lock not being held. Linux layered its solution (futex) below pthreads[4]. The result being that a portable ``sem_open`` solution will have slightly worse performance on OSX compared with the non-portable GCD solution. Both would be "correct" when compared to a busy-wait. All of this information has been gleaned from the first page of Google hits and the stack overflow answer you posted. Those with greater domain experience may correct me. [1] http://linux.die.net/man/3/sem_init [2] https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sem_open.2.html [3] https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW30 [4] http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library
Is c++ solution ok for you, here is a way to do it in modern c++: http://www.codeshare.io/JOFYh
Agreed. For learning it's probably best to ignore typedefs for quite a while. 
I would be really surprised if OS X doesn't support this type of semaphore.
FUCK YEAH! Buckland rocks!
I prefer [naturaldocs](http://www.naturaldocs.org/), but it seems mostly dead at this point.
Copious documentation in the source code really clutters it up. I prefer writing it separately.
Oh my god, I (seriously) feel like I'm meeting a celebrity right now. What year were you in? Were you in any of the classes that had videos taken of them? Richard was probably the biggest influence for me to get into computing, before that I was in health sciences, which I didn't like so much, but saw one of his videos and was blown away. Here's the story: it was New Years Day 2012 during winter break (I'm in the US) and I was in Bangkok for vacation and I had woken up sometime in the late afternoon after a pretty wild night out on the town, hung over so bad I could hardly move, and I saw on Reddit a video someone posted of him. The video was from several years ago, 2008 I think, when he was doing the Dracula game in one of his classes, and I watched him, while in bed, go into depth first and breadth first search and graph theory and so on and I was entranced. I didn't change my major right away, took some time off school to work after, but once I went back to school I changed to CSE, which is what I'm doing now, have a couple of years to go. I so wish I could have Richard as a professor, or even just meet him once, but alas I'm on the other side of the globe. I love him. I literally watch his videos for entertainment. Know if he's going to keep putting more up? It's been a while since he's got anything new out.
I'm a 2nd year student, I had him last year. Was not in any of the ones that are publicly available. he too has been a great influence to my computing and it's awesome how he's helping people everywhere around the globe! I am not sure if he wants to put more up, I know that last year was the first time he lectured 1917 (computing 1) for a while because he was sick/taking a break. New videos aren't coming out because the courses that he has taught haven't changed in content I suppose. ATM he's in malaysia or somewhere like that selling openlearning to their government... either that or probably some security conference (what he specialises in I believe)
I was also in his 1917 lectures last semester :D Such a great lecturer, I feel for the current first years who aren't able to experience his lecturing
 fscanf(input,"%d",&amp;votes[i]); Since you haven't actually said what issues you're having or how your data , I'm going to guess that you have a file full of integers separated by spaces. If that's the case, try changing the format specifier to " %d" or "%d " and seeing if it helps. You should really be checking the return value of fscanf (it returns the number of variables filled) to ensure that it's properly parsing the values from the file. EDIT: Also, what's going on here? while(fscanf !=30){ Is that supposed to be a counter? 
I generally put most of the docs in the headers (which would otherwise be fairly sparse anyway).
Not yet.
So, the value '30' being read in tells you that you are at the EOF correct? In that case what you want to do in your while is something like this: Set a flag "Is not 30" to true While flag is true { Get your next value Print some stuff If value = " 30" flip your flag to false } 
I haven't had much experience with POSIX threads, but I have done multithreading on an embedded MCU, so I'll try to help as best I can. From what you're describing, it looks like your producer is continually getting the 'empty' counting semaphore, so your consumer never has a chance to run until the producer's buffer is full. That's why adding a sleep(5) in the producer thread allows it to alternate. It gives just enough time for consumer to consume an item. As far as actual pattern or order desired, it really depends on your specific application. In my experiences, we always had a background producer running at a fixed rate which could not wait. In this case, your producer and consumer are both foreground threads and the producer is producing somewhat arbitrary data, so really either order works. 
I don't see why you'd need a flag in that case. You could have your code in a `while(1)` loop and just put `if (value==30) break;` inside the loop after the value has been updated.
Yep, that would work too. Anything that looks for the value to equ 30 rather than the address. 
Thanks for the reply! I figured it all out after sleeping on it and approaching it after breaking it all down! That's exactly what I ended up doing, can't believe I couldn't see my mistakes at first - guess I was too caught up into it.
In the traditional publisher-consumer problem there is 1 queue, which may be processed by one thread at a time, where there is 1 consumer waiting for the queue to be full, and many publishers waiting for the queue to be empty*. Here, there are 2 queues, each of which may only be processed by either 1 publisher or the consumer, where each publisher is waiting for 1 queue to be empty, and the consumer is waiting for any queue to be full. So, the mutual exclusion for processing each queue and waiting for the queue to be empty coincide, and you then need to signal and wait on either queue being full. I.e., the semaphore arrangement is different here.
Why would the producer/publisher be waiting for the queue to be empty? It's job is to fill so I'm assuming it'd wait for it NOT to be full to keep going. Same with consumer, it'd have to wait for one of the 2 queues to NOT be empty in order to proceed
i dont understand i tryed that. scanf("%d",&amp;a); while(a!=0).... still doesnt end when i put 0 on the command line....
paste complete loop code
Go over your code line-by-line in your head for a couple of loops. You've made a simple mistake.
It takes a value and turns it in to a pointer. An address, it turns out, is a pointer! An address is where something lives in memory. A pointer is also where something lives in memory. To turn something in to a pointer, you take its address. And to get the value, you access the pointer ("dereference") with '*'
Please indent your code with four spaces so it appears in a mono space font. Also, you already asked [the same question](http://stackoverflow.com/q/29182249/417501) on Stack Overflow. Please do as I told you and RTFM (read the fucking manual). `scanf` does not return what you think it does. You won't get very far in C programming if you don't read manuals.
Eclipse is just an IDE, which you type your code in. The compiler for C/C++ is either going to be gcc or g++. The compiler is the thing that actually translate c/c++ code into machine code, they are all the same. 
Hi, the scanf function ~~does not returns a value (not that i know) it only~~ saves a value taken from the default input (the keyboard) and saves it on a memory address (pointers, you should learn about them too) so when you call scanf("%d",&amp;a) you are reading an integer and saving it on the address labeled a. For this to work your loop should look like this: scanf("%d",&amp;a); while(a!=0){ r=r+a; //Tip: You can write this as r+=a and it does the same thing scanf("%d",&amp;a); } Good luck, hope this helps! EDIT: ~~Since scanf doesn't return any value you can't use it the way you are doing it on the loop restrinction~~ EDIT 2: scanf does return a value, it returns the number of items succesfully scanned. Thanks /u/FUZxxl 
Have you made any progress with this?
Also where can i find this documentation you are talking about?
Shouldn't you check both things?
If you are on a Unix, then in manual section 3. Otherwise, I seldomly refer to http://en.cppreference.com/w/c.
Er, scanf() returns something.
Have a look at this manual page for scanf from Linux: [scanf(3)](http://linux.die.net/man/3/scanf).
Please don't link to C++ documentation for C programming questions. C++ is not a superset of C, it is different from C in subtle ways.
Array and pointer are different type categories. The confusing thing is how an array is implicitly converted to a pointer. C11's Standard says &gt; **6.3.2.1 Lvalues, arrays, and function designators** &gt; &gt; [...] &gt; &gt; Except when it is the operand of the sizeof operator, the _Alignof operator, or the &gt; unary &amp; operator, or is a string literal used to initialize an array, an expression that has &gt; type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points &gt; to the initial element of the array object and is not an lvalue. If the array object has &gt; register storage class, the behavior is undefined. So, int A[10]; // the type of A is array of int[10] int *B; // type of B is pointer to int B = A; // good, A is implicitly converted to pointer of int (same as &amp;A[0]) B = &amp;A; // wrong, types are not compatible because the // implicit conversion doesn't apply with the &amp; operator. int (*C)[10]; //type of C is pointer to array of int[10] C = A; // wrong, types are incompatible due to the implicit conversion of A. C = &amp;A; // good, types are compatible. note that // sizeof(C) shall return the size of a pointer to int // sizeof(*C) shall return the size of an array of 10 int 
The doc I linked is for cstdio.
Awesome! I wish I would have been able to find this six months ago...
In addition to man pages, the POSIX spec is good for detail, lots of detail, but reads like legislation: http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html POSIX specs might just confuse you right now, but learning how to navigate and make sense of those could be very useful down the road.
This doesn't sound entirely convincing though. If we'd assume pointers and Arrays *are* equivalent, your B = &amp;A and C = A examples would fail as well. With that assumption, B would be a pointer where &amp;A would be a pointer to a pointer. A better example would be and int **D = &amp;A, and see if that works. If it doesn't, it's an immediate obvious example showing pointers and arrays are not equivalent. I'm not entirely sure if that actually works, give me five minutes. Edit: Well, gcc will let you do int **D = &amp;A, but it gives a warning: assignment from incompatible pointer type. And indeed, it doesn't actually work. When I give A[0..9] values, and try to print *D[2], it segfaults. That's actually neat: I now have an actual example to show people that Arrays and Pointers aren't the same thing.
You initialize `head` to `NULL`, and it doesn't seem that there's anything that changes the value of `head` before you attempt to access `head-&gt;next` in the line you have indicated. So that's an attempt to dereference a null pointer, which yields undefined behavior (probably a segfault). Try printing the value of `head` immediately before the line you indicated: `printf("head: %p\n", (void *)head);`. I bet it's a null pointer.
&gt; So how should I declare head instead of NULL. The problem is not that you have initialized `head` to `NULL`. That's probably a good value to initialize it to. The problem is that if `head` is `NULL` in `my_bestfit_malloc`, then you can't access `head-&gt;next`, so you shouldn't be doing that. You probably need to handle the case `head == NULL` separately, unless you use a sentinel node. I haven't really taken the time to analyze your whole program to understand what all of your variables mean, so you are going to have to think about what to do here. The important thing to recognize is that `head-&gt;next` doesn't make any sense if `head == NULL`, so you need to rethink what `my_bestfit_malloc` should do in that case.
Okay, thanks for the help. I really appreciate it!
&gt; Even when i'm sure the two strings are the same my string comp returns -1 instead of 0. How are you sure the two strings are the same? If `strcmp` is not returning&amp;nbsp;0, then the two strings are not the same. Does one of the strings have a trailing space or newline character, for example?
when i run the program with the printf uncommented it has the tow strings the same but does not equal 0 in strcomp 
Also, double check the documentation for strcmp() and what it returns.
You should post that output. And modify the printf to put quotes around the strings.
To be honest, you should probably get a proper book on C and get the basics down first.
&gt; Also, you should really consider using proper text for the cod when your right you are right, clean compile (i'm still kind of a noob). I appreciate the comments, and when I get around to a part two I will add in what you've said and credit you; if that is ok.
I think the way this article explains it, although correct, might only add to some of the confusion. It's really just explaining the difference between initialising an array and initialising a pointer, because they happen to look similar in the case where the initialiser is a string literal. I think it's more important to explain pointers and arrays in terms of the object model, which will emphasise that they are wildly different things: a pointer is a single object that contains the address of another object; an array is an object that contains a sequence of subobjects all of the same type.
The easiest explanation is that: * A variable holds a value. * The value that a pointer holds is an address. * An array is a series of variables of the same type. Nothing more is needed. &amp;nbsp; You can point to an array. You can have an array of pointers. They are two distinct ideas, and are not interchangeable.
Hmm, GCC compiles just fine and segfaults. I much prefer your compiler's "just don't compile" approach.
Okay, so what's the problem?
Then the two strings are not equal. What makes you think the two strings are equal if `strcmp` is returning a nonzero value?
this is the output Match: SBB001, StockN: SBB001 Value returned: -1 this is found in the printf following my strcomp
Put quotation marks around those strings in your output.
You should look in to [Microsoft's Component Object Model](http://en.wikipedia.org/wiki/Component_Object_Model), it is a clever way of allowing an asortment of languages (VB, C, C++, ASM) to all access an object. You can download the DirectX SDK (free) and look in to the C and Header files to see how they emulate objects and the 'this' pointer using the C language. You can also emulate some object-like properties by simply using good source file formatting. Say you have an object called Ball that you want to have some private and public variables and functions. Place the private variables and functions inside ball.c (as static) and the publicly available variables and functions in ball.h.
First of all, ***NEVER, NEVER, NEVER USE gets, UNDER ANY CIRCUMSTANCES!*** The `gets` function is literally impossible to use safely. It doesn't even exist in the most recent version of the C standard because it is an inherently broken function. If you are learning C from some source that is teaching you to use `gets`, then you need to stop using that source immediately and use something better. === You cannot compare strings with the `==` and `!=` operators. You need to use `strcmp` from `&lt;string.h&gt;`. === And even if you could compare strings with the `!=` operator, your logic is wrong. Think. The condition `(String1 != "S") || (String1 != "V") || (String1 != "C")` will **always** be true. * If `String1` is `"S"`, then `String1` is not `"V"`, so `String1 != "V"` will be true, which means that the condition (`String1 != "S"` **or** `String1 != "V"` **or** `String1 != "C"`) will be true. * If `String1` is anything else, then `String1` is not `"S"`, so `String1 != "S"` will be true, which means that the condition (`String1 != "S"` **or** `String1 != "V"` **or** `String1 != "C"`) will be true.
And that is exactly what /u/raevnos [told you to do](https://www.reddit.com/r/C_Programming/comments/2zu612/trouble_with_a_binary_search/cpmb5k9?context=3) in your other thread two hours ago.
A quick debugging tip: After 'gets(String1);' use a printf() statement to see what is contained in String1.
after i made that post my file got corrupted and i spent the past 2 hours redoing all the code i could remember. my apologies for missing it i have been a stressed re working it
&gt;It's really just explaining the difference between initialising an array and initialising a pointer, That section is looking at *accessing* data stored in an array, versus accessing data stored elsewhere which a pointer is pointing to the first element of. (Being a string literal is orthogonal). The article seems OK to me.
&gt; your code may be faster than C++, but it's harder to read so it's worse code that is a very good point, it is hard to read; very hard
__Formatting__ Keep your indentations consistent. For example, with your first if statement, put the end `}` at the same indentation level as the beginning of the statement. Meaning keep it directly under the `i` in `if`. __While Statements__ All your if statements that are embedded within the `while` loops could, and should, be under one `while` loop. In addition, within the `if` statements you don't need `!feof(in)` because you've already established that in the `while` conditions. __Files__ You only ever open `in` in the if statement at the beginning. You never open the range files, yet you write to and close them.
(this is probably a better question to ask in /r/programminghelp, but since you are already here) First let the compiler help you. If you are using gcc try: gcc -W -Wall -Werror -g3 -ggdb -o partition partition.c There are similar flags for clang. If you do this you should first see that you don't have valid syntax in your file. The compiler will tell you where. Next you will see that you don't open your output files, so there is no where to write your result. The logic of this program should go something like: while there are still values to read, get one { if value 0-30: FILE *current = range1; else if value 31-60 FILE *current = range2; ... ... fprintf(current, "%d\n", value); } You could also do the check with a series of ifs, or with cases. Also, what do you mean count the scores in a range? It seems like you may have left something out of the spec.
No Open Watcom compiler? It's free and open-source.
I dislike statements like "gcc supports C11." Yes, it supports the language features of C11, but gcc is just the compiler, not the standard library. If you're using gcc on Linux, then your libc is probably glibc, and glibc does not yet support the C11 `&lt;threads.h&gt;` functionality so if you want to try out some new C11 threading using gcc under Linux, you're going to be quite disappointed, even if you're using a bleeding edge version of gcc built from HEAD. And you might be a little bit annoyed at whoever told you that gcc supports C11. The same applies for clang. 
Just a note about your `if`/`else` structure: &gt; if(x&lt;=30) &gt; { &gt; /* ... */ &gt; } &gt; else if(x&gt;30 &amp;&amp; x&lt;=60) &gt; { &gt; /* ... */ &gt; } &gt; else if(x&gt;60 &amp;&amp; x&lt;=90) &gt; { &gt; /* ... */ &gt; } &gt; else &gt; { &gt; /* ... */ &gt; } You don't need to test `x&gt;30` in your first `else if` condition, because you already know that `x&gt;30` is true. If `x&lt;=30`, then the first block is executed, and everything else is skipped! Likewise, you don't need to test `x&gt;60` in your second `else if` condition, because you already know it's true. If `x&lt;=60`, then one of the first two blocks would be executed, and you wouldn't even be considering that `else if` condition.
You need to describe the problem better. &gt; But doesn't transfer any data over to those files. What does this mean, exactly? Are you saying that the files are empty? At least one of them should have at least one value. Note that you have a `return` statement as the last line of your `while` loop, so you're only ever going to process the first score before `main()` (and therefore the whole program) ends. The same applies for the code that prints the counts — surely you want to do that after the `while` loop has finished, not inside of it. Also, you probably want to use `"%d\n"` when printing to the files (or perhaps `"%d "`), otherwise you'll have all the numbers jumbled together with nothing delimiting them. 
You need to close your files. fclose(range1) fclose(range2) and so on.. 
I did that.. and still got the same problem with the constant print of info. Or were you just commenting that I needed to do that?
Read my comment again, and think about where you're doing the printing. 
AH! I got it! haha thank you very much, I didn't realize my printing was in the loop for some reason! 
No one has mentioned your incorrect use of the `while` conditions. `scanf` and `fscanf` return the number of variables successfully written. You need to check if `x` is equal to `EOF`. The statement in the `while` conditions could look something like the following. while (fscanf(in,"%d",&amp;x) &amp;&amp; x!=EOF) { /* other stuff here */ }
This test isn't right: `fscanf(in,"%d",&amp;x)!=EOF` . This is a fairly common error although I can't explain why it is so common. Instead it should be `fscanf(in,"%d",&amp;x) == 1`. The `fscanf` function returns either `EOF` or the number of successful matches. If you only check for `EOF` then your code will go into an infinite loop if the file contains something that is not an integer. It's also important to check that your files opened successfully (i.e. the pointers are not `NULL`). 
So is this correct or no? It does what I need it to do.. but is anything wrong? #include &lt;stdio.h&gt; int main() { FILE *in, *range1, *range2, *range3, *range4; int x, count30=0, count60=0, count90=0, count100=0; in= fopen("fileIn.txt","r"); range1= fopen("range1.txt","w"); range2= fopen("range2.txt","w"); range3= fopen("range3.txt","w"); range4= fopen("range4.txt","w"); //Error message if file doesn't open if ((in = fopen("fileIn.txt", "r")) == NULL) { fprintf(stderr, "Could not open fileIn.txt for reading.\n"); return 1; } while(fscanf(in,"%d",&amp;x) == 1) { //scores &lt; 30 if(x&lt;=30) { fprintf(range1,"%d\n",x); count30++; } //scores &gt;30 and &lt;60 else if(x&lt;=60) { fprintf(range2,"%d\n",x); count60++; } //scores for &gt;60 and &lt;90 else if(x&lt;=90) { fprintf(range3,"%d\n",x); count90++; } //scores &gt;90 else { fprintf(range4,"%d\n",x); count100++; } } //prints the total number of scores in all ranges { printf("range1.txt contains %d scores from 0 to 30\n",count30); printf("range2.txt contains %d scores from 31 to 60\n",count60); printf("range3.txt contains %d scores from 61 to 90\n",count90); printf("range4.txt contains %d scores over 90\n",count100); } //closes all files fclose(in); fclose(range1); fclose(range2); fclose(range3); fclose(range4); return 0; } 
Some nice crypto included, but for generating random numbers on a day to day basis I use dSFMT and SFMT, some nicely optimized "SIMD-oriented fast" mersenne twisters. http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/
A ring buffer is used in situation where there is one writer to a buffer, and one reader, so both can access the buffer concurrently. I don't think there is much use for a ring buffer without some concurrency.
Circular buffers can be used to implement FIFOs in an efficient manner. Two indices are defined, a head and a tail. These "point" into the array. A Boolean is also usually defined to differentiate between full and empty when head == tail. The advantage of using a circular buffer is you don't need to move data around as entries are pushed or popped off the FIFO. 
Can you please clarify what you mean by “circular array” and “sequential array?”
When writing an audio filter I use a circular buffer so there are less total shifting operations per cycle of filtering. EDIT: Like this https://www.youtube.com/watch?v=fdCAsZkjpSg
Thank you kindly for your reply. The get command is completely clear to me now, thanks for that :) However i'm still not quite understanding the host concept. Wouldnt freeiz.com be the host in this case? This is my output btw: http://www.heypasteit.com/clip/1VKA It comes down to: &lt;p&gt;The document has moved &lt;a href="http://error404.000webhost.com/?"&gt;here&lt;/a&gt;.&lt;/p&gt; 
As a side note, try it with telnet. Connect to the web server you want to talk to with telnet, and try sending the request. Type what I showed you above, but just hit 'enter' where you see \r\n. You should be able to play with it and figure things out. telnet www.myserver.com 80 GET / HTTP/1.1 Host: www.myserver.com Connection: close HTTP/1.1 200 OK &lt;html&gt;........... 
Just from a cursory glance, there's a ton of issues with the code. * You don't check errors from any network function, like bind() or read(). If bind fails, (e.g. the port is used by some other software) the program just goes on blissfully unaware that nothing is working. * You don't set the SO_REUSEADDR flag on the socket, which means that you have to wait a while before launching the program again after it terminates (so that the port goes out of TIME_WAIT state). * You trust the client to give you a proper HTTP request; there's a massive amount of buffer overflows etc. that can happen if it doesn't. * If the file requested doesn't have a file extension, you do strcmp() with a null pointer in get_mime_type(), which causes a segmentation fault. * The program doesn't check whether DOCROOT_DIR exist, and simply crashes if not. * The program can only handle one client at a time, which means that a very slow (or malicious) client will DOS the service. * There is no guarantee that read() and write() actually writes the amount of data you give to it; you have to read the return value and then write the remaining data again. This is probably why your images fail, since they are probably too large to fit inside the kernel socket buffer (which is 16KiB on my computer, for example).
you're not checking the return value of read(comm_fd, recv_header_buffer, HEADER_SIZE); sometimes you get 0, but continue as if you had received something.
That's another bug, thanks. Why would the server ever get null from reading the socket btw? This was one of a few causes for segfaults...
fork() is Linux only, and would work okay. It's not terribly efficient though, as every created child gets its own copy of the parent memory (and becomes it's own process, which has some overhead). Threads are much quicker, but not nearly as simple to use as fork. 
I suspect that it has something to do with the fact that your server offers a keep-alive connection. If you press (ctrl+F5) in Firefox/Chrome, the browser closes its connection to your server (and tries to start a new one). [On success, the number of bytes read is returned \(zero indicates end of file\)](http://man7.org/linux/man-pages/man2/read.2.html#RETURN_VALUE) [...] Also, [stackoverflow](http://stackoverflow.com/a/2416979).
Yes, if you use head + length, you need to "wrap" the computed tail on each use. This means "(head + length) % size" on each push. This is more computationally expensive than only doing the mod when "++tail == size" ( where no mod is needed at all as it wraps to zero).
`fork()` is [POSIX](http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html) and has been standardised as part of SVID since the beginning (1985). It's also possible that the fork has copy-on-write semantics, meaning only modified memory pages are copied. Process creation on Unix systems tends to be much cheaper than on e.g. Windows, given the number of processes that can be spawned even on a single command-line.
In other subreddits I frequent, we use the NSFW as a "completed" button. Guess you guys don't use it here. 
&gt; Network programming is kinda complicated [I've yet to see a solution to network code that doesn't either produce GCC warnings or silly looking unions](http://stackoverflow.com/questions/1429645/how-to-cast-sockaddr-storage-and-avoid-breaking-strict-aliasing-rules). 
I suppose you could convert all IPv4 addresses to [IPv4-mapped IPv6 addresses](http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses), and then using IPv6 sockets only with sockaddr_in6 directly. It worked okay when I tried it, but seems to be unsupported on some platforms according to google (i.e. Windows XP and older).
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 31. [**IPv4-mapped IPv6 addresses**](https://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses) of article [**IPv6**](https://en.wikipedia.org/wiki/IPv6): [](#sfw) --- &gt;Hybrid dual-stack IPv6/IPv4 implementations recognize a special class of addresses, the IPv4-mapped IPv6 addresses. These addresses consist of an 80-bit prefix of zeros, the next 16 bits are one, and the remaining, least-significant 32 bits contain the IPv4 address. These addresses are typically written with a 96-bit prefix in the standard IPv6 format, and the remaining 32 bits written in the customary [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) of IPv4. For example, ::ffff:192.0.2.128 represents the IPv4 address 192.0.2.128. A deprecated format for IPv4-compatible IPv6 addresses is ::192.0.2.128. &gt; --- ^Interesting: [^World ^IPv6 ^Day ^and ^World ^IPv6 ^Launch ^Day](https://en.wikipedia.org/wiki/World_IPv6_Day_and_World_IPv6_Launch_Day) ^| [^IP ^address](https://en.wikipedia.org/wiki/IP_address) ^| [^Site ^Multihoming ^by ^IPv6 ^Intermediation](https://en.wikipedia.org/wiki/Site_Multihoming_by_IPv6_Intermediation) ^| [^IPv6 ^deployment](https://en.wikipedia.org/wiki/IPv6_deployment) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cppsrtm) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cppsrtm)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Pelles is my favorite C environment!
Eh our professor didn't want us to use arrays but thanks for showing me how to do that with arrays!
I don't know much about C tools and meta and etc... can you give a ELI5 about this?
Thanks for the answer! I really like the fact that this subreddit is filled with helpful people ^^
You need to pass the number of bytes you want to read as an argument to fgets. It will read until (a) the number of bytes you specified is read, (b) a newline is reached, or (c) EOF is reached. Whichever happens first. edit: If a newline is reached, it is considered a valid character and will be included in the buffer fgets reads into, so you may want to remove it: fgets( buf, bytes_to_read, stdin ); buf[bytes_to_read -1 ] = '\0'; 
I think fgets goes until the new line. Read the docs to double check that. I'm sure there is some way to read until the EOF if you google hard enough.
Thanks! All problems solved then, /r/C_Programming saved the day once again!
Good on you, bud. That made the weird symbol and putty disappear.. Only problem is that that was a pretty much essential line for my assignment... which was working fine a few hours ago. T.T I can't stand programming in C......
[beej](http://beej.us/guide/bgipc/output/html/multipage/signals.html) Also maybe [this example](http://web.mst.edu/~ercal/284/SignalExamples/signalEX4.c).
For reference: http://pubs.opengroup.org/onlinepubs/009695399/functions/fgets.html
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Pelles C**](https://en.wikipedia.org/wiki/Pelles%20C): [](#sfw) --- &gt; &gt;__Pelles C__ is a lightweight [freeware](https://en.wikipedia.org/wiki/Freeware) [integrated development environment](https://en.wikipedia.org/wiki/Integrated_development_environment) for [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) and [Pocket PC](https://en.wikipedia.org/wiki/Pocket_PC) programming in the [C language](https://en.wikipedia.org/wiki/C_(programming_language\)) built and maintained by Pelle Orinius, featuring: &gt; &gt;* Support for [32-bit](https://en.wikipedia.org/wiki/32-bit) Windows (X86), [64-bit](https://en.wikipedia.org/wiki/64-bit) Windows (X64), and (deprecated) [Windows Mobile](https://en.wikipedia.org/wiki/Windows_Mobile) (ARM). &gt;* Support for the [C99](https://en.wikipedia.org/wiki/C99) and [C11](https://en.wikipedia.org/wiki/C11_(C_standard_revision\)) standards. &gt;* Support for most [SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions), SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard), and [AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions)(1) intrinsics (X64 only). &gt;* Integrated source code editor with call tips and symbol browsing. &gt;* Integrated source-level [debugger](https://en.wikipedia.org/wiki/Debugger). &gt;* Integrated sampling [profiler](https://en.wikipedia.org/wiki/Profiling_(computer_programming\)). &gt;* Project management. &gt;* [Inline assembler](https://en.wikipedia.org/wiki/Inline_assembler) for [X86](https://en.wikipedia.org/wiki/X86) and [ARM](https://en.wikipedia.org/wiki/ARM_architecture). &gt;* Integrated resource editor. &gt;* Integrated bitmap, icon and cursor editor. &gt;* Integrated animated cursor and video editor. &gt;* Integrated [hex dump](https://en.wikipedia.org/wiki/Hex_dump) editor. &gt;* Support for custom controls in the dialog editor. &gt;* Support for custom project wizards. &gt;The compiler is built on a modified version of [LCC](https://en.wikipedia.org/wiki/LCC_(compiler\)). As of version 5.00, Pelles C supports 64-bit. As of version 7.00 (RC1) Pelles C supports the [C11 standard](https://en.wikipedia.org/wiki/C11_(C_standard_revision\)). &gt; --- ^Interesting: [^LCC ^\(compiler)](https://en.wikipedia.org/wiki/LCC_\(compiler\)) ^| [^C ^date ^and ^time ^functions](https://en.wikipedia.org/wiki/C_date_and_time_functions) ^| [^C99](https://en.wikipedia.org/wiki/C99) ^| [^ANSI ^C](https://en.wikipedia.org/wiki/ANSI_C) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cprc4e4) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cprc4e4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Put a condition depending on that global boolean into the signal handler for `SIGUSR1`. You know, a signal handler can call functions.
One != me.
I could but as they say.. Bad things happen in 3s, I had a power outage yesterday and I my PSU is shot. Then my laptop got stuck in a repair disk loop.. and the assignment due date came and went.. So it was all for naught. :\
I was attempting to "write" that struct over a FIFO to the client code. As I told some other posters, I have a feeling the clients were unlinking their FIFO before Server had a chance to write to them. But I cant even fiddle with it because I lost TWO computers in one hour yesterday. PSU blew on my desktop and my laptop got stuck in a disk repair loop... This is not my week..
wat
&gt; my PSU is shot. Next time buy Seasonic.
http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
dont depent on code academy to get good at c. Instead code, code, code and code some more. What to code? Anything become curious of how things work from the most basic algorithm to the most complex. Do research here and on stackoverflow. Use pen and paper to write out what your algorithm does. use lots of printf statement to see the values of your variables at various state. don't be afraid to ask others to look at your algorithm. 
Learning C is also about getting to know the compiler and linker. Try to understand every bit that you are doing, and if you think you do, recheck it to make sure.
If you want to get your hands dirty, get a hold of *Advanced Programming in the UNIX Environment*, by Stevens and Rago and work your way through the book. Don't be scared by the word 'Advanced' in the title. It starts off gently with Files and Directories and provides simple examples for implenting common commands; e.g., ls. By the end you will have a better understanding of C and the operating system with which it shares a common history.
It's the best (imo) C compiler &amp; linker package for Windows. It's also tiny, free, and has a good community. It's macro assembler is almost as powerful as Microsoft's (www.masm32.com) and last I checked supports almost all of the macro syntax MASM does. Macro's can be important later on in programming as they allow you to solve certain problems more easily that C (or C's pre-compiler) simply can't handle.
Ooh is it standard compliant?
/r/dailyprogrammer/ Try to solve these challenges with C, it would be very educational for you.
Either post your code on a separate code sharing website, or put 4 spaces before each line to keep the original formatting. Right now your code is very difficult to read. It also looks like your mult() function is defined inside the main function, and you have a couple of braces that don't seem connected to any conditionals or loops. Why is mult() defined inside your main function? Why do you have braces that aren't connected to any conditionals or loops? Why are all your variables global? Why bother having a function that just multiplies two numbers together? Why do you have recursive calls to main()? Why do your puts calls have seemingly arbitrary combinations of slashes and backslashes with special characters? What do you mean your program won't run? Will it not compile? Does it give you an error message when you start it? Are you able to provide input but the results aren't what you expect? Have a look here and try following the suggestions: http://sscce.org/ What development environment are you using (IDE, compiler, OS)?
Nice, thank you for mentioning Project Euler! I forgot about that. That site is a very good site to simulate your mind!
So my question is that, where can i put the mult statements so that the program can run. In the program, if i take out the case 4 everything works fine. Im just further implementing case 4 to actualy do something instead of going back to the menu. Why not have global variables? I just put them at the top because its easier to see and keep track of I guess. I am required to use a function to find the volume of the cylinder, i know there are simpler ways of doing it I guess. ''uses a function to implement one of the menu options 3, 4 or 5. '' When the program starts, you see a menu with 6 options. if you press 1 for example, it takes you to a separate page and asks you to press another key. when you press another key it takes you back to the main menu. Its just an excercise to prove we can do loops. Put statements have slashes and special characters because when run it forms a spaceship so it gives the menu something nicer to look at. It will not compile, won't start. Because i dont know where to put these lines of code. float mult ( float one, float two ) { return one * two; } I am using codeblocks.
&gt; Only if bytes_to_read is the size of the buffer. That's what I was pointing out; the potential for a minor bug. buf[ strcspn( buf, "\n" ) ] = '\0';
You're technically correct (the best kind of correct) but while being familiar when the what your compiler and linker are doing won't help you learn the C standard but will certainly help you become a good C developer.
&gt; So my question is that, where can i put the mult statements so that the program can run. You generally can't have a function within a function in C. http://stackoverflow.com/questions/957592/functions-inside-functions-in-c main() is a function, so your mult() function has to be outside it. Try defining your function where you currently have the declaration. &gt; Why not have global variables? I just put them at the top because its easier to see and keep track of I guess. Global variables can be dangerous because it's harder to maintain control of them. Any variables that are only used within main() should be declared within main(). &gt; I am required to use a function to find the volume of the cylinder, i know there are simpler ways of doing it I guess. ''uses a function to implement one of the menu options 3, 4 or 5. '' Normally what that kind of requirement means is that you should have a function called volume() which takes a height and radius argument, and returns the volume. &gt; when you press another key it takes you back to the main menu. Its just an excercise to prove we can do loops. As your code is now, you're not doing looping. You're doing recursion. Your code will never reach your while() statement because you're return a value within the loop. EDIT: Btw, recursion of main() is bad. Have a look here: http://stackoverflow.com/questions/13948562/recursion-using-main-function /EDIT Even if you fix that, while (Key &lt; 7); This isn't doing what you want, so right now you're not doing loops properly. Key will be an ASCII character, not an integer. You want to be comparing against the character '7'. Note that a simple less than comparison is not enough, because that will also accept most punctuation characters http://www.asciitable.com/ &gt; Put statements have slashes and special characters because when run it forms a spaceship so it gives the menu something nicer to look at. Your original post ate some of the characters so your backslashes were mismatched. It looks okay now.
Are you talking about this OOC? http://ooc-lang.org/ I found these two threads on /r/programming from 5 years ago: http://www.reddit.com/r/programming/comments/9wj1r/ooc_the_soft_point_between_haskell_python_and_c/ http://www.reddit.com/r/programming/comments/a31jb/ooc_a_modern_objectoriented_functionalish/ Also, it doesn't seem to be very actively developed. Are you sure it's the best option for you?
I am not so sure. I have seen some people using rust with emscripten as well, but emscripten and rust is in its early stage as well. The syntax on OOC(yeah it is the one that you linked) seems so nice and looks like a more direct path to compile than rust. Thats why i am looking for help here. I think i am going back to regular C/C++... Wich i am not so confident on using. Still, any suggestions on how to do aproach this is welcome.
Agreed. I learned with Prata's C Primer Plus then just got straight to coding. If you want an online resource you can check out CodeAbbey.com for a broad range of challenge questions compatible with C.
Ok so I fixed a couple of things and took out those annoying mult function. void VolumeofCylinder(void) { printf("Enter the Radius: "); scanf("%f", &amp;r); printf("Enter the Height: "); scanf("%f", &amp;h); Volume = r * r * h * pi; printf("\n"); printf("Volume of Cylinder = %.3f", Volume); printf("\n"); } With ther above code alone, is there a way i can restrict the user so he is only able to input numbers and get an error message if text is input?
CodeAbbey.com that's something new, I need to check that out.
That's pretty much what scanf does. You should check the return value from your scanf calls. It will return the number of variables filled. Since you only take one argument at a time, you should ensure that scanf() is returning 1. Then just stick an if/else block around your Volume calculation.
What's the command and arguments you're using to compile this? Without even seeing it, I bet there's something missing from it.
And this is why I always introduce compiling from a cli.
* Write code. * Read other people's code. * Debug code.
Yeah, i am going fo it, thanks for the adivice, i am going to post my progress here on /r/C_Programming and share my experience with emscripten/SDL. Wish me luck!
 int table[5][5]; for (int y=0;y&lt;5;y++) { for (int x=0;x&lt;5;x++) { printf("table[%d][%d] = %d\n", y, x, table[y][x]); } }
Would that work the same if 5 was another variable? 
Codeblocks is not a compiler, it's an IDE. You need to create a project and add both .c files to it. That's how you tell the IDE that there are multiple source files that need to be compiled and linked. Merely having the .c file hanging out in the same folder is meaningless.
Did you correctly initialize name[i]? If that char* doesn't end in a NULL terminator, weird things may happen... Also, are you closing your fd afterward you're done with it?
yes I do close the file once it's done reading. name[i] is defined as a static array with the names of the files that it needs to read.
What command line are you using to invoke valgrind? Valgrind --tool=memcheck? Also make sure buf is large enough to hold the string. 
I am using valgrind -v --leak-check=full --default-suppressions=no and I increased the buf from 200 to 500 and no change.
Your question is underspecified. Would you mind elaborating?
Ok it was not on the last platform I was on. I looked a little and it seems like it is more often than not, thread safe. So you might check the libraries on your platform. You may have to link with a different library to ensure it is thread safe.
I finally got it :) would you mind quickly looking at this simple code and tell me how I can exit the program by pressing a letter, for example a? Can't find anything on google &gt;.&lt; #include &lt;stdio.h&gt; #include "switchio.h" int Values; unsigned char led_values; int main() { printf("\n\t\t Using Simulated Lights and Switches"); printf("\n\t\t Enter a number between 0-7"); do { Values = get_switches(); led_values = Values; put_leds(led_values); } while (!get_switches &gt;=0 &amp; !get_switches &lt;=7); return 0; }
I think you may have learned that 'trick' in another language, like JavaScript, but it does not work that way in C/C++ (although it will compile and probably run correctly most of the time). What the statement: if (string[0] ... Is really saying is: if (string[0] != 0 ... It, however, is **not** saying "if string[0] exists in memory" or "if string[0] exists" or even "if string[0] is valid". You are correct in your final line however: if (strlen(string) &gt;= 2 &amp;&amp; string[0] == '*' &amp;&amp; string[1] == '^') This will ensure that string is at least of length 2, so accessing array members 0 and 1 are guaranteed to be valid. In C/C++ and some similar languages there is **no** way to tell if something (pointer, array, etc) is valid. You *must* keep track of this stuff yourself.
If you're still stuck by the time you read this I have something you can try, it's a bit of a long shot. There is a quick and simple test to confirm your malloc() implementation is actually thread-safe, just wrap it in a binary semaphore so that only one thread is ever allocating at any given time. You can either install a binary hook on malloc(), or go through your code and temporarily replace malloc() with a wrapper function manually. The wrapper simply acquires the lock, calls the regular malloc(), and then releases the lock. This test can take less than a minute!
Also note that a "C-string" (the typical representation of a string in C) *should be null-terminated*. The definition of the length of a C-string is the number of non-null characters occurring before the terminating null byte. That is what strlen() gives you.
Is i a number that's a valid index for the array? If it's out of bounds, it could explain the segfaults.
Have you tried to compile with ASAN? It's usually pretty good at telling you exactly why something segfaulted.
Thanks, but now it doesn't make the operations in the if part, it shows me useless numbers
If it doesn't reach the **if** statements, it won't show you any numbers. If you are seeing numbers, then it means you are in the **if**. So that leaves your formula as being wrong. I should leave you to figure the math out, but I'll give you one free: If it is over 10k, divide by 100, mod by 10.
what's up with that letter spacing?
Thanks, it was a dumb problem, I was using "==" instead of "="
If that's really what you need to do, it sounds as though you need to read them as strings, not as floating-point numbers. Numbers like 999.999 and 10.3 cannot be represented exactly as floating-point numbers. If you want to keep these numbers exactly as they appear in the input, you need to read them as strings.
Yes I have tried to make sure they all are.
I've checked the indexing and it seems fine. It goes through this loop completely several times before it crashes.
I tried helgrind and it didn't give me much. --12805-- REDIR: 0x3070484e60 (libc.so.6:__GI_stpcpy) redirected to 0x4a0b453 (__GI_stpcpy) --12805-- REDIR: 0x3070480e80 (libc.so.6:__GI_strcpy) redirected to 0x4a09c1e (__GI_strcpy) --12805-- REDIR: 0x307052b630 (libc.so.6:__strcasecmp_sse42) redirected to 0x4a0f368 (strcasecmp) line 10: 12824 Segmentation fault (core dumped) ==12805== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) ==12805== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 
I really can't read it if you don't change your font. 
fopen() fprintf() fclose()
Booleans in C are of type `_Bool`. If you request the size of `_Bool`, the compiler will say it takes at least one byte (maybe more), not one bit. If you *really* want a 1-bit boolean, you have two options. You can use a bitfield, or you can use bit shifting to make it work. C++ has a special version of the `std::vector` data type that does exactly this. You can use it to optimize memory use if you have a ton of booleans, at the expense of extra bit twiddling (done behind the scenes). This tradeoff is rarely worthwhile, IMO.
C has a boolean type.
Only c99..... Right?
My bad, there is a boolean (_Bool) type added with C99, i just ignored how "native" it was.
 unsigned int x = *((unsigned int *)&amp;aui8_array[i]); is probably what you mean. However, it interprets the 4 bytes in host endianess. The first example you gave always interprets the data in the array in big endianess.
Yes, that's exactly what I meant. Sorry for the mixup. My uint32 is a typedef that we use on the platform. int can have 16 bits or 32 bits (depending on the platform) and I find this clearer. I also usually put an additional typecast like so: ui32_var =((uint32) *((uint32*) &amp;aui8_array[0]))); but I realise it's redundant so I should remove it. I do want to interpret the data in host endianess. 
You might need to flush the relevant stream or turn off buffering for that stream.
So it might not be able to access the data as 32 bit integer if the array is misaligned. Thanks, I did not think of that. The issue is that if I keep the first code, it will still not be portable if I switch to a platform with different endianess (I already had to rework the code because of that once). Is there a solution that takes both the alignment and the endianess into consideration? Short of checking the endianess and then doing the shift accordingly, I can't think of anything. 
`sizeof(bool)` must be at least `1`. 
Your answer is incorrect. A `_Bool` (the type is not called `boolean`) has a size of at least one byte and as the size is part of the platforms ABI, the compiler won't attempt to change it regardless of options.
ISO C: &gt; An object declared as type `_Bool` is large enough to store the values 0 and 1. ISO C++: &gt; Values of type bool are either `true` or `false` &gt; `sizeof(bool)` […] are implementation-defined These are the only limitations set for `bool` and `_Bool`. ABI is not covered by either ISO C or ISO C++ and is used only when calling library/external functions, it can be ignored inside program.
A .h file simply contains declarations for variables, types and/or functions that are actually defined in a .c file. For instance, let's say you have a function foo that takes in a char and returns a unsigned int. This function is defined in your .c file as follows unsigned int foo(char c) { // Do stuff return somenumber; } The corresponding .h file would have the following: unsigned int foo(char c); That way, any .c file other than the original one can call foo by simply including the corresponding .h file where it is declared. The compiler uses the declaration in the .h file to identify the function signature, i.e., the number and type of parameters, and the return type. The #include &lt;blah.h&gt; vs #include "blah.h" is unclear to me as well, but the convention I follow is that system header files are included using the angle bracket approach, while application header files use the double quotes. Note that I could still write #include "stdio.h", this is just the convention I follow. [This SO thread](http://stackoverflow.com/questions/21593/what-is-the-difference-between-include-filename-and-include-filename) may give you further details. The include guard (#ifndef __FOO_H_, #define __FOO_H_, ..., #endif), is a common way to ensure that header files are not doubly included by accident. There are multiple reasons for having one .h file include another, mostly because the included file is something like a common header for the application and declares a whole bunch of stuff that would be used by other parts. It can be the case that a.h includes b.h and c.h, but c.h also includes b.h, so you want to avoid b.h being included twice, so that's why you use the include guard. When you build your C program, you generally link with some libraries, one of them being the standard C library. The linker basically sets aside space for an object table, which kind-of maps the symbols in the library to the address space of the program. When the program is loaded, the loader will fill these locations with the actual address of the functions, which may be shared across multiple different applications or processes. This is dynamic linking. Static linking simply takes the code for these library functions and bundles it into your executable so there is no concept of shared code. In this way, you can take this compiled application and run it on any (similar) machine without a need for the original libraries. However, it does increase the size of your executable since you are not calling the shared code. .o files are the result of compiling a .c file. This file is eventually linked into your executable. A .a file is simply a collection of several .o files which form a kind of archive for future static linking. 
Check out SendInput [https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx]
This is pretty easy to accomplish using [SendInput](https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85\).aspx). However, since you are new to C, and OS programming, it will probably be easier to use [mouse_event](https://msdn.microsoft.com/en-us/library/windows/desktop/ms646260(v=vs.85\).aspx) instead. You should bookmark the [Windows API](https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85\).aspx) as it contains a list of most functions Windows supports, and how to use them.
couldn't you just use a union? union ui32_aui8 { uint32 ui32; uint8 aui8[4]; };
If you have some time, you should read the C [standard](http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf) Here the part about the includes: &gt; A preprocessing directive of the form `#include &lt;h-char-sequence&gt; new-line` searches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the &lt; and &gt; delimiters, and causes the replacement of that directive by the entire contents of the header. How the places are specified or the header identified is implementation-defined. &gt; A preprocessing directive of the form `#include "q-char-sequence" new-line` causes the replacement of that directive by the entire contents of the source file identified by the specified sequence between the " delimiters. The named source file is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read `#include &lt;h-char-sequence&gt; new-line` with the identical contained sequence (including &gt; characters, if any) from the original directive. Note the difference in what they include: "header" vs "source file".
&gt; So, if a macro or function is going to be used in more than one function, Nit: replace the second "function" with "file"
I think you'll understand it better if I explain *why* you need header files in the first place. The key to understanding this is that, when compiling, C compilers only look at the specific file of code they're compiling. Thus, if you have two files, `file1.c` and `file2.c`, when the compiler is compiling `file1.c` it has no knowledge of the contents of `file2.c`, nor that we plan on using the two files together. So now, imagine we have these two files: file2.c: struct bar { int foo; }; void foo(struct bar *b) { b-&gt;foo = 2; } file1.c: #include &lt;stdio.h&gt; int main() { struct bar b; foo(&amp;b); printf("%d", b-&gt;foo); return 0; } Compilation steps: gcc -std=c99 ./file1.c -c -o ./file1.o gcc -std=c99 ./file2.c -c -o ./file2.o gcc ./file1.o file2.o -o ./test_exec (Note, The last `gcc` line is actually using gcc to invoke the linker. This is handy because gcc knows how to use the linker correctly to make a proper executable out of the object files. Doing this directly with the linker is actually somewhat complicated, and not worth it unless you need to do something special.). The above is a single program which prints `2` to stdin and exit. Alone however, the compiler will refuse to compile `file1.c`. If you look at `file1.c`, it should be obvious why: There is no definition of `struct bar` and no definition of `foo`. Obviously you can't expect the compiler to compile code which declares a `struct bar` object on the stack when you didn't tell the compiler what a `struct bar` is so it can create one. The problem is that we defined `struct bar` in `file2.c`, but *not* `file1.c`. Thus, we could fix it like this: file1.c: #include &lt;stdio.h&gt; struct bar { int foo; }; extern void foo(struct bar *b); int main() { struct bar b; foo(&amp;b); printf("%d", b-&gt;foo); return 0; } If you use that `file1.c` and the above `file2.c` it *should* actually compile: The key here is that we provided `file1.c` with definitions for `struct bar` and `foo`, so when the compiler goes and compiles the file, it then knows how to make a `struct bar` and how to call `foo`, and everything is happy (The linker takes care of 'connecting' the call to `foo` in `./file1.o` with the actual definition of `foo` in `./file2.o`). There's an obvious issue with this approach though: duplication. Imagine if we wanted to add another field to `struct bar`, and imagine we used `struct bar` in 15 different program files! We'd have to go manually edit all 15 declarations of `struct bar` and make sure they match. Worse: Since the compiler only looks at one file at a time, it has no way of knowing that the `struct bar` definitions don't match, and the linker won't have any idea. Thus, if we mess-up a `struct bar` definition, the compiler and linker will happily compile the code, and then it will probably seg-fault for no obvious reason when you run it. The same thing can happen with `foo`. Imagine if we defined `foo` as `void foo(struct bar *b)` in one file, and `void foo(struct bar b)` in another! It's an obvious mess. Thus, the 'obvious' solution is to have some way of defining stuff like `struct bar` and `foo` in some separate location, and then telling each file to go read that file and treat it like it's part of this current file. That way, we could define `struct bar` in that one file, and then every file is using the same definition. That's what a header file does. Header files use the `#include` preprocessor statement. The important part to note about this is that the preprocessor actually runs *before* the compiler. So if you have a statement like `#include "foo.h"` inside of `file1.c`, the proprocessor actually opens `foo.h` and inserts the contents directly into the copy of `file1.c` that it sent to the compiler. The compiler never even knows that `foo.h` exists, or that the contents of `foo.h` wasn't always in `file1.c`. Thus, you have stages of compiling. Actual file1.c: #include "foo.h" int main() { foo(2); return 0; } Actual foo.h: extern foo(int bar); What the compiler sees: extern foo(int bar); int main() { foo(2); return 0; } As you can see, when we get to the compiler it just looks like one big file. This is extremely handy because we can turn the above code into this: bar.h: struct bar { int foo; }; foo.h: extern void foo(struct bar *); file1.c: #include "bar.h" #include "foo.h" int main() { struct bar b; foo(&amp;b); printf("%d", b-&gt;foo); return 0; } file2.c #include "bar.h" #include "foo.h" void foo(struct bar *b) { b-&gt;foo = 2; } Now, we only have one definition of `struct bar` that both `file1.c` and `file2.c` both use. `foo` also has it's own definition. Including `foo.h` into `file2.c` isn't actually necessary (There's no reason to declare a function without a body right before you declare it *with* a body), but including it ensures that you never have a type-mismatch on `foo`, because the compiler will refuse to compile code that has two definitions for the same function with different types. IE. A file with the lines `void foo(int)` and `int foo(int)` won't compile. For good reason - The compiler can't handle having two different functions both named `foo`. Thus, header files are nothing more then extra source files. The benefit of using headers is that it the definitions inside tell the compiler about symbols and definitions being used by other source files, and thus allows you to use those things in several different pieces of your code. Without them, you'd have to manually repeat compiler definitions in every file you use external functions or global struct definitions to tell the compiler "Hey! This thing exists in another file somewhere.", or "This is what this struct is supposed to look like". The reason why you don't need to reference the .c file in the .h may be clear to you now: There isn't actually any real relation between the two. One contains various definitions for use in source code, the other contains actual source code. It's common to have a `file2.h` corresponding to a `file2.c`, where `file2.h` is the definitions for all of the things in `file2.c`, but it's not necessary to keep that convention, nor extremely common to see programs that strictly adhere to that convention. In my example, `foo` is defined in `file2.c`, but I put the definition in `foo.h`. Likewise, `struct bar` is in it's own header, `bar.h`, which has no corresponding .c source code. As long as every file that need access to `struct bar` includes `bar.h`, and every file needing `foo` includes `foo.h`, it doesn't matter where you put these definitions. You're even allowed to declare the more then once. Ex. Have a header which declares the functions `foo` and `baz`, and then have a separate header used in other parts of the program that only declares `foo` and not `baz`.
(cont... Dang this thing got long...) Talking about `.o` files, they're actually pretty easy. They're just a 'intermediate' file containing a compiled version of a source file (Ex. a .c file). The .o file isn't a complete program, because the source used to create it isn't a complete program either (A .c file is just part of a bigger program). To that end, .o files contain 'references' to things that it needs from other .o files. In the above example, `file1.o` contains a 'reference' to `foo`, because `file1.c` has a call to `foo`, but `file1.c` doesn't contain the code for `foo`. The linker is the program that takes care of taking in all of our `.o` files, and turning them all into an executable. This step involves resolving all of the references in the `.o` files, so when it combines, say, `file1.o` and `file2.o`, it combines the compiled code and then inserts an actual call to the `foo` code where the reference to `foo` was in the `file1.o` code. In this fashion, it's possible to have errors that don't show-up when compiling but *do* show-up when linking. These are called `linker` errors. These only deal with things that the compiler had no way of knowing, so mostly just program wide things. For example, if we completely forgot to link the `file2.o` into our executable, the linker would complain that it can't find the definition of `foo`, because ./file1.o makes a reference to `foo` but we have no foo code to go with it in any of our `.o` files. The linker can't create an executable without resolving *all* references, so it has to throw an error. The reason the compiler didn't tell us about this is actually because we lied to it. We gave it the definition `extern void foo(struct bar *b)` in `foo.h`, but never defined a `foo` somewhere else. A cool thing about .o files is that they're nice and generic, because they're just compiled code and various symbols like function names. Because of this, you can compiled different languages all down to .o files, and then link them together with the linker having no idea they came from separate languages and compilers. Assembly is one such language. You usually stick Assembly code into '.s' or '.S' files, and you can compile those assembly files with an assembler into .o files. You can then link the .o file into your program like any other .o file. (As a note, the difference between .s and .S usually is that .S assembly will be run through the C-preprocessor before being compiled, which can be useful). Another cool thing to show this, you can actually make `gcc` spit out code at various compilation steps. You could do it separately if you want, but the `-save-temps` flag will output all the temporary steps. Ex: gcc -save-temps ./file1.c -c -o ./file1.o Will generate `./file1.o`, the object file containing the compiled code, `./file1.s`, the assembly code from `gcc` that was used to create the `.o` file, and `./file1.i`, which is the code after being run through the preprocessor (And thus, `./file1.i` is the actual source file that was compiled). The steps go in the order: ./file1.c -&gt; (preprocessor) -&gt; ./file1.i -&gt; C compiler -&gt; ./file1.s -&gt; assembler -&gt; ./file1.o With that in mind, in general `gcc` keeps most of those things internal, so it won't save the preprocessor output or the assembler output. Also worth noting, the '-E' file will stop `gcc` after the preprocessor stage, and give you just the `.i` file. And '-S' will stop after the C compiler sage, and give you the assembly. Static and Dynamic linking generally come-up when creating an executable. The idea behind static linking is simple enough. Say we have 'library1', 'library2', and our program 'foo' which uses both library1 and library2. Static linking just means that we directly compile all of the code from library1 and library2 into our 'foo' program. In general, this is done via archive files, `.a` files, which are nothing but a collection of `.o` files. Thus you can compile a `.a` file into your program like you normally would a `.o` file, and it will (in general) work as expected. So in our example, we'd just do: gcc ./library1.a ./library2.a ./foo.o -o ./foo To compile our 'foo' program. In contrast, 'Dynamic linking' is linking our code in a way that it makes use of code that's *not* in our executable. Thus, if we wanted to dynamically link against a copy of library1, we basically tell the linker "Hey, there's a copy of library1's code over here. Make my program use that". The linker and the OS take care of the finer points of actually loading the code from the library into memory when our program is loaded, so from our stand-point a dynamically linked program looks the same as a statically linked program. The main difference is now our `./foo` executable has a dependency on a file call something like `./library1.so`, where `./library1.so` is the file containing the code for library1. When our program is loaded, the OS looks for `./library1.so` and loads it into memory for us. Assuming the files `./library1.so` and `./library2.so` exist, you can compile like this: gcc ./foo.o -llibrary1 -llibrary2 -o ./foo The main difference is that, with static linking, you have no extra dependencies on `.so` files to provide code you need (Because the contents of the `.so` file is basically compiled right into your program), but with dynamic linking you can recompile the `.so` files without having to rec ompile your `./foo` file. Also with dynamic linking, multiple programs can make use of the same `.so` file. So there's advantages and disadvantages to each. In general, dynamic linking is the way to go on Linux machines. That's just because libraries can be 'tuned' to different distributions, so by dynamic linking you don't have to worry about compiling the libraries yourself, you can just use the ones provided by the distribution. It's also better for security, because if a security issue is discovered in a library you link against, your program will automatically start using the patched version if they replace the `.so`. With static linking, your program has to be recompiled with the latest version.
memcpy()?
&gt; How do I write a function in assembly and link it with C code? Put a declaration for the function in a header, and include that header in any .c file that is going to call the function. Put the definition of the function (i.e. the implementation in assembly) in a file ending in .s. (Use .S if you intend to use the C preprocessor, e.g. for shared `#define` values.) Then add a step in your build system to assemble foo.s -&gt; foo.o. You can actually do this quite easily by calling the compiler driver in the same way you'd compile a .c file, i.e. `gcc -c foo.s` will produce foo.o, and `gcc -c foo.S` will similarly preprocess and then assemble. Then add foo.o to your link command alongside all the other object files. If you're using make, then there are probably already a built-in rule to handle foo.s -&gt; foo.o, so all you have to do is add the .o file to your list of objects for a given target. It's also possible to do inline assembly, but that's significantly more complicated because you have to learn gcc's complicated mini-language for specifying the side effects of each asm statement so that its backend doesn't get confused. Consult [the manual](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html) for details.
Just wondering, why do you want to tell Windows to make the active window think the left mouse button is being held down? It seems like a very curious use case to me.
FILE* pointing to an actual file are fully buffered by default, so you'd want to do fprintf(fp,"Testing"); fflush(fp); 
Yeah I know I have not gotten that far yet. I just want the logging to work at this point. I think I will use ps -ef then grep it for sshd to make sure it is running or something like that. Then use sendmail or postfix to shoot out an email alert that it isn't running. The email part will be tricky but I should be able to work something out.
Ah the horror.
I like this style of error handling, but please indent your labels one level less and try not to leave that many line breaks. It's much cleaner than exceptions and encourages handling every error individually instead of swooping them up in a large `catch`. If you wanted to do proper error handling with exceptions, every single statement that could err out would need to be placed in a `try`-`catch`-clause which is 3 times more verbose than the mechanism you see in C or Go, although Go does it better.
That was it, thank you!!! I guess I'll have to do some more reading on how C handles file operations and how to work with buffering.
Does it crash or does the executable close? I forget if C is the one where you have to add a system("PAUSE"); before return 0; so the executable doesn't close immediately. 
You need to open the file, save the return (the file handle), and then read data from the file using the handle. Like this: http://www.cplusplus.com/reference/cstdio/fread/ Once you do that, you'll have the contents of the file to examine and you can keep working from there. Good luck!
Thank you so much! We haven't covered these commands in class yet. Can it be done using just printf() instead of those you list? I don't think my prof would care if I used those, but I think I want to try it out both ways.
Yeah, I'd assume that OP most likely was using some type of compiler and not using a terminal. 
Pass a pointer to it as an argument and update it within the function. You could have returned it, but you're already returning something else.
Well I just got back, and I'm not sure if I changed anything before I left or I'm simply retarded, it now stops working after the second input, it doesn't print anything, just stops working. I'm working with Code::Blocks with MinGW compile. http://prntscr.com/6nrnvh
&gt; Yea, you got it right, thanks mate. Note for myself: I went full retard, I should NEVER GO FULL RETARD. 
Can you post an example of this? I've never found a case where the C++ version of the standard libraries was different than the C ones.
Let me have a look.
use a memoization approach fib(n) table[0] = 1 table [1] = 1 for (i = 2 to n) table[i] = table[i-2] + table[i-1] return table[n]
What you're effectively doing is taking the log base 2 (plus one). There's lots of ways of doing this: see [this post](http://stackoverflow.com/questions/21442088/computing-the-floor-of-log-2x-using-only-bitwise-operators-in-c) on Stack Overflow.
Thanks for the advice. It is basically working the way I intended, though I'm having other issues now. I think what I need is to have my program react when I hit a specified key, even while another application has the active focus.
Make a 16-bit array of size 32,769. Set 1 to 1, 2 to 2, 4 to 3, 8 to 4, etc until 32768 to 15. Then simply: int bit_location = my_array["the uint16"]; Look-up tables are often the fastest way to solve problems. It is all a part of the CPU-Memory trade-offs. Waste memory to free up CPU cycles, or waste CPU cycles to free up memory. **Note** Some CPU architectures have special CPU instructions for detecting the first or last bit's set, or how many bits are set in total. And sometimes these instructions can execute in less than 1 cycle. So using those specialized instructions would be significantly faster than any C implementation. You can check your C compiler help file to see if they support intrinsic or special macro's for using these instructions.
It's actually a pretty funny solution to the problem. int a[32769]={[1]=1,[2]=2,[4]=3,[8]=4,[16]=5,[32]=6,[64]=7,[128]=8,[256]=9,[512]=10,[1024]=11,[2048]=12,[4096]=13,[8192]=14,[16384]=15,[32768]=16}; main() { int num = 0x0004; printf("%i",a[num]); }
[malloc needing a cast in C++](http://stackoverflow.com/questions/3477741/why-does-c-require-a-cast-for-malloc-but-c-doesnt) is an obvious example.
ah, haven't used much of math header
I'm guessing you're causing undefined behavior in `InitializePhone` caused by the way you're calling it on line 132. You don't need to multiply by `sizeof(phone)`; that's not how pointer arithmetic works. 
Valgrind is what you would use to diagnose low-level memory issues such as these. Without it, C can be downright hellish.
Given that there will only ever be 1 bit set, according to the rules of the question: int isset( uint16 v ) { switch ( v ) { case 1: return 0; /* returning which bit is set */ case 2: return 1; ... default: return -1; } } Not a terrible version.
To count the number of trailing zero, compilers usually have the intrisic __builtin_ctz(n) which relies on specific CPU's instructions. eg for x86 int f(int n) { return __builtin_ctz(n); } compiles to With ICC 13.0 -O3: f(int): bsf eax, edi ret With GCC 4.9 -O3: f(int): xor eax, eax rep bsf eax, edi ret With Clang 3.7 -O3: f(int): bsf eax, edi ret Note that bsf is not so good on atom https://chessprogramming.wikispaces.com/BitScan#x86Timing
&gt; phones.phoneArr = &amp;dynamicPhoneArray; No. Get rid of that ampersand, you don't need it. It is probably the cause of your problems. edit: Also what /u/wgunther said. You want phones.phoneArr to point to the block of memory you just allocated (i.e. be the *same value as* dynamicPhoneArray, not the *address of* dynamicPhoneArray). &gt; char * nameBuffer = (char*)malloc(phoneLength + 1 * sizeof(char)); As written, this turns out not to be a problem because sizeof(char) is one byte anyway. However, something like this would bite you if it were a bigger data type. Due to the order of operations, the '1 * sizeof(char)' is evaluated first, then added to phoneLen. What you probably intend here is (phoneLen + 1) * sizeof(char). It doesn't hurt to make judicious use of parenthesis to get rid of any ambiguity about what gets evaluated first. Then you do: &gt; memcpy(nameBuffer, name, phoneLength + 1); The "+ 1" in your malloc was, I assume, to make room for the null terminator. But here, you copy phoneLength + 1 in your memcpy, and don't set a null terminator. You should do a memcpy of just phoneLength, and then nameBuffer[phoneLength] = '\0';
And as it makes the code more clear, I'd prefer fn(&amp;myPhones.phoneArr[i]); 
Cause I didn't know it exosted
Flip the problem around and count the number of *leading* zeros before the single 1. That turns it into the exact same problem. The second answer on that page (using `&gt;`) is my favorite. Though as long as you don't mind being a bit platform-dependent, the best option is likely `__builtin_ctz` as has been pointed out in another reply.
attempt to write to a position past the end of the file. You should ftuncate(fd, 4096) first. If the file existed and had at least 1 byte in it and you weren't using O_TRUNC, this would have worked. Also, MAP_FAILED should be preferred in place of -1 for the return of mmap. A call to msync should also be used when dealing with maps to files after operations.
I haven't looked at it very hard, but your two malloc's at the top of the file... The assignments below each of them will attempt to write past the allocated area which is likely causing a heap corruption. *(x+1) requires malloc of at least 2*sizeof(int)
You change its value, but you return the new value. I have a feeling this function is not as encapsulated as it should be. Consider breaking it into smaller tasks. It'll be easier to debug. 
Slovenian :) And I've translated it. You're right, I didn't realloc y. Gonna try it.
Still same error. 2 0 2 1 0 4 1 9 This input works without any problems. When using realloc third time, it gives error.
Yes, that's the point. I need the new vaule to be returned in main.
Well, mmap is a bit weird really. The man pages really come in handy when programming on linux. When using new functions it may be worth reading through the relevant pages (edge cases and errors particularly).
You should use a struct and pass that in instead of passing in so many pointers to your function. That will greatly simplify your code, which may make the problem easier to see ( or go away entirely )
Realloc may move the pointer, as such, you probably need an int ** if you plan to use it for x and y. 
&gt; Can I store a pointer to my unique object in say, myArray[2][4]? Yes, you can. Just write `myArray[2][4] = ptrToObject`, assuming that `myArray` has the correct type. If the dimensions of `myArray` aren't known at compile time, you might want to use a one-dimensional array that is large enough and do index-computations manually. If you are short on memory, you might want to consider saving a structure with an index into an object array in each location of the array instead of a pointer. If you use bitfields, you might be able to get a structure compromising an index into the object array and the objects attributes down to two bytes. It is hard for me to answer this question without having further information about your problem.
Don't waste that much memory! It's doable in far less without loosing a lot of speed.
Any idea why gcc emits a `rep` prefix?
You're walking off the end of your array in the inner_matrix() function. Once you process the cell at a[9][9] (i.e., the last valid cell in the array), p == &amp;a[9][9]. Therefore p++ will effectively mean that p == &amp;a[10][0], which is less than &amp;a[10][10] (the terminal value in your predicate), and thus the loop will continue. You could fix your loop by changing the test to "p != &amp;a[n-1][n-1]", but why not just do nested loops? If you had, I dare say you wouldn't have had this problem (given that you got the loops right in main() -- though even there I would have used != rather than &lt;).
I beleive it has something to do with the undefined scenario when the operand is zero. "rep bsf" fills dest with zero when tzcnt is available
Other than the comments about walking out of bounds, this is the real reason it doesn't work.
This is more of a design problem than a C problem. You can design a 2D array as a pointer to a pointer to a pointer to a structure, where the structure contains a combination of relevant types and pointers. As you can see, this design can start being cumbersome quickly if you are not careful. But if you have an embedded system, you may not be able to afford to allocate memory for so many grid locations that contain no information (or duplicate information). You may want to think about how you can design it so that you allocate only memory that you use.
&gt; write your code in English As an American, I cringe a bit when I hear this, because it feels very ethnocentric to tell other people they have to use my language. But it's true. English is the *lingua franca* of programming. It makes things simpler for exactly the reason seen here: you can share code (and documentation) with any programmer in the world, and they can always read and understand it. Someone once asked Linus Torvalds, a Swedish-speaking Finn, why he wrote Linux in English. His answer was that it never occurred to him not to. It was programming, therefore it belonged in English.
Think about it this way: if you loop through the grid, you have to access a bunch of variables that you have to check to see if you want to use only to ignore many of them. You can use a different approach where you only think about the grid when you need to. For instance, you can iterate over your structures and do all of your processing. You can store your coordinates as members and process them once you've done everything else. 
I understand the benefits, but I'm having an issue seeing how exactly to implement it. If I have a static 2D grid that represents my field, I have a lot of unutilized empty space, but that was how I envisioned detecting collisions between objects (aliens and player, bullets, and aliens, etc...). I don't quite understand your last paragraph. I know there's a way, but I don't see how I can detect collisions etc... if I'm not referencing them to some 2D structure. Sorry I'm having trouble wrapping my head around this, let me know if I need to clarify the source of my confusion.
No problem. You're already aware that collision detection is going to be a difficult problem to solve. One approach to managing a difficult problem is to isolate it from other parts of your software. This allows you to work on other parts of the program without worrying about the problem. It also allows you to substitute a better solution later without rewriting the whole thing. The way that you are thinking about it is fairly intuitive, but it seems like it's the heart of your program. You can write it in a way that you keep a list of moving objects and their coordinates and eliminate unlikely collisions from processing or you can create a char[ ][ ] instead of the (possibly larger) *[ ][ ]. If you find that using a grid of structures works best, you can plug that in without changing the whole program. There are a lot of possible solutions to collision detection.
Here is a program that takes your input file (in.txt) and converts it to a binary number file (bin.txt) #include &lt;stdio.h&gt; int main(){ FILE* in = fopen("in.txt", "r"); FILE* out = fopen("bin.txt", "wb"); int number; while(fscanf(in, "%d", &amp;number) != EOF) fwrite(&amp;number, sizeof(int), 1, out); fclose(out); fclose(in); } 
Ahhh I think I understand. The intuitive way is my first intuition, where we create these objects in memory and track their movement across a 2D structure, because this is actually what is happening. The alternative as I understand it is to, instead of keeping track of the *actual* location in the 2D structure, represent it with a pair of coordinates of where it would be. Do this for all my objects so that I end up with a 1D array of all the objects on my field, but I'm calculating their positions and collisions "numerically" instead of "physically" (The words in quotes may not be the proper words to describe the situation but I think they make clear what I'm saying). Thanks for your help!
Thank you! I'm such a derp I should have remembered it.
This, unfortunately, doesn't solve the issue: .... len = stat_buf.st_size; n = len / sizeof(int); //This is number is wrong!! printf("%d\n\n",n); paddr = mmap(NULL,len,PROT_READ | PROT_WRITE,MAP_SHARED,fd,0); if (paddr == MAP_FAILED) perror ("mmap"); vet = paddr; for(i=0; i &lt; n;i++) printf("%d\t",vet[i]); //Prints rubbish printf("\n"); close(fd); .... The output is: 941634360 540221492 540291872 540162080 540225824 540162336 540160800 540225824 540095008 540094752 540226080 540422688 840970292 842473526 540422944 908079409 926294072 540619296 857748024 842407984 859185209 857749302 909647926 840970784 840970801 540620320 540619552 909451315 891301945 840970804 859250745 540488224 924856374 926097460 540555552 824194098 808919093 842407985 840972596 808984625 540423456 908079927 808919090 540424480 891302200 540357152 840971320 909320247 874525984 891302197 909647925 840972085 892936244 857748281 824194356 926294068 540356896 874525750 808788019 540489760 909582392 540555040 540293408 941635640 959586358 960045108 958412338 941635889 943071286 958412598 943005746 959586357 926359606
Thank you. Now I'm able to use `mmap()` correctly. This solved the issue! I'm gonna take a look at the quicksort now!
&gt; ...and this 2nd method is how most text editors do the deed. Not really as this method leads to corruption when the editor crashes in the process. Most editors actually work like this: 1. Open your source file read/write permission 2. Read everything from source file to a buffer 3. Insert your desired text into the buffer using memmove() and then strcpy() / memcpy() 4. Create a file on the same file system as the file to edit 5. Write the whole buffer to that file 6. Optionally call `fsync()` on the temporary file 6. Rename the temporary file into the name of the file you edit This method ensures that “save” is an atomic operation that doesn't lead to corruption if the system crashes
Thank you very much for your answer. I highly appreciate it. What open source projects you find interesting and would like to suggest?
Thank you for your answer. I'm almost done with college, and have a few years experience (I've started working right after high school). I would say that I "know" C, at least I know C at the college level where I was very successful in that field. I was thinking, since I already know a lot about C, why wouldn't I try and schedule the exam for certification, I mean, I don't have anything to lose (except 295$ :D). Specially after solving all exams on C++ institute over 90%. When I got there, questions weren't easy. Not at all. I needed 17% more to pass.
Think how you would iterate through a matrix column by column; then row by row. If you do one way from the source, and the other way into the destination, you have a transpose: static void transpose( const int * restrict src, int * restrict dst, int w, int h ) { for( int y=0; y&lt;h; y++ ) for( int x=0; x&lt;w; x++ ) dst[x*h+y] = src[y*w+x]; } int main( void ) { int dmat[6]; int smat[6] = { 1, 2, 3, 4, 5, 6, }; transpose( smat, dmat, 2, 3 ); printf( "%d %d %d\n", dmat[0], dmat[1], dmat[2] ); printf( "%d %d %d\n", dmat[3], dmat[4], dmat[5] ); } The "restrict" is C99, and means that you can't transpose a matrix into itself - the function clobbers values in the destination matrix anyway.
Lotsa good answers here, just my 2 cents - i think target usage environ is a factor too. Mean to say, if all the exposure this type coding will have is your own hobby stuff, then heck do that all day. If you're deploying onto Verison's production servers, then that's different, ya? EDIT: btw, i love doing shyt like this -- casting arrays into long ints -- or create your own double via 8 byte array cast? -- hells yes, lol. The ANSCI C guys would really give me a beating about stuff like this. I've come to respect their opinion more after I had my first headlong into a portability issue, but still can't resist tinkering and pushing the envelope. What's life for if you don't color outside the lines once in a while, am i rt? EDIT EDIT: You can add stuff to your code -- (just one module, make it part of your start-up routines) -- for specific endian checks -- something like this: char aui8_array={1,2,3,4}; ui32_var = *((uint32*) &amp;aui8_array[0])); if(ui32_var != 16909060) //hard-coded check for endian-ness printf("Endian issue ---- code error!"); 
`transpose` is not a built-in function.
oh ok. Sorry I'm really low level. Thank you though. Upon looking more in-depth, you have helped me solve it. Thank you man!
You could also do the same in just one for-loop: for(int i = 0; i &lt; rows*cols; i++) { mat2[i%rows][i/cols] = mat1[i/cols][i%rows]; }
FYI, "symmetric" does not mean what you think it means. What you mean is the word "square." Transposing a *symmetric* matrix is trivial—a [symmetric matrix](https://en.wikipedia.org/wiki/Symmetric_matrix) is equal to its transpose, so you don't have to do anything at all to transpose a symmetric matrix.
hey, thank you for doing the homework of /u/NotDescartes. Now he surely learns something.
If it makes you feel better, I didn't end up doing it this way. I just went off what he said originally and did it myself. 
I don't think lines end with `\n\r` anywhere.
Do not use `scanf` in this case! `scanf` is strictly for text input. Use a different function for that. I'm not sure what the content of `/dev/input/js0` looks like so I can't give you more detailed information.
http://c-faq.com/osdep/readavail.html
Queries will still be executed on server side. So query execution performance doesn't depend on the language you use to call for it. Perhaps the C version will be slightly faster iterating the results of a query, but that's because of the nature of both languages. I've used both, but currently I'm using the Go approach with the [native third party driver](http://github.com/lib/pq). Mostly because the database/sql package in Go is the one in charge to open and close SQL connections. [This might help you](http://go-database-sql.org/overview.html)
Oh scanf was for a different thing. Im using read() with the Linux joystick API, which defines a struct called js_event
Under production circumstances you'd utilize the power of the SQL database and not just utilize it as a dummy memory cache. A Pl/PGSQL function or in any of the other plugin languages you'd do the iteration and updating on server itself, potentially the biggest performance benefit you can hope to receive. Table design and proper offloading to server is in almost always A-X of performance, only Y-Z can be improved on the client software. 
&gt; BUT I have another struct that I might also have to parse, doing the same thing with types. Thus, if I wanted to recursively traverse all associated members of one of these structs, I would need to have some sort of secondary qualification from, say, "if type = 1", since more than one super-type can have the same enumerated types. What? &gt; My question, is can I check for a unique member of a struct at runtime, and use the result to make a choice as to which type im currently in? If I am understanding your question correctly, no, you cannot do that. It is your job, as the programmer, to keep track of the types of your variables in one way or another. The question "Does this object have a member called such-and-so?" is meaningless at runtime.
Ah, I see. I misunderstood your intent. How about you ignore how often the A button has been pressed and pretend it has been pressed either 0 or 1 time? You could also look into `select` and `epoll`.
You can use the enumeration values but make the variable containing them an `int`.
Ok. That's ok.
You lied! 
Agreed. OP needs to check compiler/linker help for setting stacksize to something Big. Have done this, works...resolves deep recursion issues. Additionally, i believe you have answered with precision: as I recall, it is a link (not a compile) option. TIP for OP: a function with a smaller parameter list will put less strain on the stack. Each function parameter is pushed onto the stack when a function is called, so keep the parameter list short -- use a struct and struct pointer as a single parameter if you really *need* to send a lot variables to a function that will recurse a lot.
Totally agree. There are times when goto makes sense vs. extensively re-working code just to avoid goto. I think goto has earned so much disdain because it can be addictively overused rather than thinking a problem through to a more compliant/standard/elegant solution - ie: the newb shortcut to run-time success. Accomplished programmers will likely use goto rarely, but also *would not be afraid to use goto* when it fit the occasion, regardless of the stigma associated with it. goto is available for a reason.
Don't have to malloc(). Use of the static keyword will enable retention of variable x in memory beyond the life of the function: int *f(void) { static int x = 42; return &amp;x; } 
I'd use getch() instead of picky scanf(): #include &lt;conio.h&gt; //for getch() while(state == 1) { //Checks if user wants to continue printf("Do you want to continue? (enter 1 to continue and 0 to exit): "); state = getch() - '0'; //waits for key press. Subtract the value of char 0 to get integer value while(state != 1 &amp;&amp; state != 0) { ... ... 
 int key, count = 0, delay=10; while(1) { count++; if(count == 1000) { key=getch(); if(key == 'f') delay--; if(key == 's') delay++; } Sleep(delay); puts("Hello world"); 
See bitmask.c and bitmask.h [here](http://github.com/jaccovanschaik/libjvs).
(`s/reversed/reserved/`)
Oops...
Some architectures don't allow unaligned loads/saves or if they do it's very slow. Using `unsigned long` as the size for your cell will be significantly faster everywhere. That said, I think you should consider what you're actually trying to accomplish: Arithmetic shouldn't look strange to you; just setting a bit is easy: #define N (sizeof(unsigned long)/8) b[a/N]|=1&lt;&lt;a%N; The kinds of things where we work with "big bit arrays" like bloom filters and (better) stamp hashing don't become more clear with a bunch of `bit_array_set_bit(a,b)` statements, and contrary to popular belief: Compilers aren't that smart. If you'll take it I'll offer you further advice: Don't write code that you don't need *right now*. Chances are you won't need it at all, and if you do *something about that need* might cause you to write it differently: If I'm going to allocate a 512mb array to use as a bit field for IP addresses, I'm not going to error check between each store.
I have researched a few bit arithmetic implementations (Boost, STL, etc.). I realized that I am not gaining much efficiency out of single bit-field setting clearing, but it is still a fundamental piece of each of the libraries. Thank you for the don't write extraneous code tidbit, It definitely makes sense. The fxn's I'm working on currently are string/file to/from bit-field modifiers. I feel those along with bitwise operators and shifts and rotates are the biggest point of my code.
&gt; was wondering how y'all build your solutions to bitlengths larger than 64 These days I'd steal from [ccan](https://github.com/rustyrussell/ccan/tree/master/ccan/bitmap).
There is a difference - in go there is cgo call overhead which is about ~160ns on 1.4.1 and ~48ns on 1.3.3; there is a recent perf. drop in recent versions due to moving to Go as the runtime... it will probably go back to ~30ns eventually. See [issue 9704](https://github.com/golang/go/issues/9704). Plus, there might be some additional performance loss in driver interface, sql package etc. Whether 30-160ns matters depends on the application. If it matters in Go, you can reduce the number of calls you make to C by batching. But, most likely some other operation will dominate the performance, e.g. disk IO. tl;dr; Do you get a performance win = yes; does it matter in the real world = it depends and most likely not.
I'd argue that the comments are fine. Better comments will come with experience. And it's always good to encourage more comments. (edit) Also when first learning this stuff it's useful to have these extra comments so you can use it as a reference and have your comments explain how the code works to you. 
 Null terminated character arrays Strings That being said, an enum type would probably add undue complexity. However I agree with your thing about switch statements. Maybe a function that contains the switch could be used?
Enumerated types are very useful for managing complexity. A misspelled enumerator is much more likely to be caught by the compiler than an incorrect literally. You can use enums to replace magic numbers with symbols that provide meaning to the reader, especially if the literal value is arbitrary. Because enumerators are integral types, you can use them in switches. You can add cases for each constant. Enumerator definitions are evaluated at compile time.
Use pastebin or the like for code. You're going off the end of the array from the looks of it. Bubblesort? Wow.
I think you might be right, nextPtr going out of bounds is the probable cause. I'm trying to think of a way to fix it. 
That was actually exactly the problem if I recall correctly. It's working like its supposed to now. Thank you everybody!
Don't delete the post, even if fixed. It could prove to be useful for someone in the future!
If you added a question to your post, I could try to answer it. Threading is highly platform specific, so it helps if you specify what platform you are working on.
I am sorry, i am using Windows 7, working in Visual Studio 2008(not that it matters). I want some form of validation of my design, of some sorts... at least my approach to threads in this case. At this point i'm having problems with the actual syntax of threads, how to create and how/where to tell them to start. I did have some brief encounters with threads but in Java. It's quite overwhelming for me right now, guess i'm looking for a place to start... A direct question for starters would be : How do i connect 2 independent process ? And how can i make another process change a variable in my current process ? Note that i do have access to the source code of both processes. Another one, a bit more vague, would be : How do i create/stop/join/syncronize threads in C ? Syntax and philosophy. Do i make separate source files for each thread functionality and import them in the main one ? As a side note i decided to use the main thread as the listener, since i already have an infinite loop there, and will wait for an event there.
I'm sorry, I'm not familiar with C programming on Windows and the Windows threading model. I hope someone else can help you. Also, it's spelled “syntax” in English (sorry).
No reason to be sorry, point taken. I edited it out. Thanks for the effort and time. But a general opinion of my proposed solution for my problem ... Do you think the actual design could work ? If no what should i look out for ?
I would try to see if there is a way for the database to inform you about changes; this is better than repeatedly polling the database. I'm not sure what inter-process communication mechanisms are available on Windows, but on Unix I would use a `select` call to wait until either five seconds have elapsed or the database tells me something happened. No multi-threading needed. You don't want to communicate via variables, as you can't read the content of variables while you are sleeping. On Unix, you can send a signal to a thread to interrupt (and therefore, prematurely terminate) its sleep. I think a similar thing is possible on Windows if you want / need to go for a multi-threaded solution. &gt; And how can i make another process change a variable in my current process? You can use shared memory to do this, but it's not what you want to do (see above). &gt; Do I make separate source files for each thread functionality and import them in the main one? C doesn't care about how your source code is laid out over multiple source code forms. You can put all the code into one source code form or split it up as you like. There are no constraints like in Java about how source code must be distributed over files.
I think there is an API in Windows to notify you when the content of a file changes. If Windows provides something similar to `select`, you can do this in one thread: Wait until either the file changes or five seconds elapsed. Notice though that you might run into problems if the program that modifies your file isn't done by the time you do your stuff. CSV files aren't suitable for this kind of operation.
Some ideas [here](http://en.wikipedia.org/wiki/Monitor_\(synchronization\)), in particular condition variables and spin locks. Dunno about Windows, but the standard C thread library supports condition variables with wait timers.
There are a few ways you could accomplish this. You could use a mutex or a semaphore to signal your thread after the write operation has completed, or you could use someting like WaitForMultipleEvents with a timeout to see if the file becomes readable. You could also use a shared memory area with mutexes instead of a file. Your search terms (lots to read!) are: mutex, semaphore, and inter process communication. You might want to look at pipes as well.
Years ago, I wrote a program that monitored files being semi-actively written to by another app in Windows. I don't have a solution for you in C but I can perhaps give you some insight on how you will be able to achieve what you trying. Every file in windows has three time stamped properties: Created, Modified, Accessed. Unfortunately these are not very reliable as Quoted from MSDN GetFileTime Function in C++: &gt; Not all file systems can record creation and last access times and not all file systems record them in the same manner. For example, on FAT, create time has a resolution of 10 milliseconds, write time has a resolution of 2 seconds, and access time has a resolution of 1 day (really, the access date). Therefore, the GetFileTime function may not return the same file time information set using the SetFileTime function. NTFS delays updates to the last access time for a file by up to one hour after the last access. NTFS also permits last access time updates to be disabled. Last access time is not updated on NTFS volumes by default. The most reliable of the three properties is going to be the Modified, I found the Access time is just utterly useless. But, as you read in the MSDN the Modified value can be delayed up to 2 seconds, so for faster reading on whether the file has changed, you should also check and compare Filesize and I would strongly consider performing an MD5 Checksum. http://rosettacode.org/wiki/MD5#C To save the work while allowing for new changes from 3rd party application, I wrote a function that would copy the newly modified file, edit it, delete/copy over the original. This allowed for more error checking, if the file was being accessed/modified I wouldn't be able to write over it, allowing me to discard the changes made from the copy and start the process over again, or use the information in the copy and modify both files. Hope this gives you a better idea of what you are up against.
You can use C11 Threads on Windows with [TinyCThread](https://tinycthread.github.io). Its only 2 files, so pretty easy to add.
You don't need threads to do any of this. In fact using threads will just make your program much more complicated and easier to fail. Use an event driven approach for everything. 
I suggest against using C11 threads. They are not widely supported and their interaction with other threading systems is unspecified. If you want to use a portable threading API, use pthreads. C11 threads are mostly a subset of pthreads except for some behaviour that is unspecified for C11 threads and some small differences.
Almost all thread APIs have primitives that allow a thread to wait upon another thread, signal a condition to a different thread, exclude all but one thread from travelling through parts of the code, etc. They are usually called something like semaphores, condition variables, mutual exclusion, wait, sleep, signal, and so on.
Thank you so much. I guess that was my only problem because I changed that and it works perfectly now. And thanks for the tip, I'm still pretty of new to this stuff so little tips like this help a lot.
if/else isn't a loop it's a conditional. You need a loop: for or while for example. The you are going to read a word, if the previous word is the same increment the count, if it's different start a new counter at 1, if it's the end of the file you are done.
Well a common entry point for C is "main". 
so when you say test, just instead of making functions, kind of test one by one in a main? like this?: #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct student { char firstName[20]; char lastName[20]; int PUID[10]; int age[3]; struct student *next; }; struct student *root = NULL; struct student *curr = NULL; int main() { root = (struct student *)malloc(sizeof(struct node)); root -&gt; next = 0; return 0; }
Thenewboston
What do you mean with “disjointed?”
No no no. If you care at all about becoming a good programmer, stay very clear of thenewboston. It's riddled with errors and bad practices because he only barely has a grasp on the concepts he teaches.
Out of pure curiosity, are there any browsers supporting HTTP over an AF_UNIX socket ? And can you describe an AF_UNIX socket in an HTTP URL ? 
What about #include &lt;stdio.h&gt;
C is not the best language to start with. I would recommend that you learn something modern like Python, and get pretty decent at it before delving in to a lower level language like C. Or go the other direction - learn to write in assembler, and when you finally start doing C you'll realize how much easier and more efficient it is! 
Not instructions for how to get the argv[1] number into a variable. let's assume you did that and assigned it a variable named tpc1_b. assuming you want each bit to occupy an index: i=length of tpc1_b; j=0; while(i) { array[j] = tpc1_b &amp; 1; tpc1_c = tcp1_c &gt;&gt; 1; j++; i--; }
It's already in an array. That array is called `argv[1]`. The first character is `argv[1][0]`, the second character is `argv[1][1]`, the third character is `argv[1][2]`, and so on.
Is this a homework assignment?
Take it one step at a time. How do you make a loop in C? How do you compare two strings to see if they're equal? How might you save the previous value to compare it to the current one? Where might you store the counts? If you don't know how to do it in C, do it in psuecode. Write your own English language description of each step of the problem, and the code will then be very easy to implement in any language. Learning to program is about learning to think. 
Even though it's expensive, I highly recommend [C Programming: A Modern Approach](http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504). It's a college text book with new concepts being introduced, explained, and practiced in each chapter. There's tons of detail, it's good for beginners, and can be used as a decent reference manual. The K&amp;R C book is conversely really short and it expects you to have a certain level of experience. It was the first book I tried, and I couldn't get past the 3rd or 4th chapter before getting stuck. I plan on revisiting it once I finish this more in depth book.
Does this apply to all of tutorials there?
&gt; Can C be used to write, for example, a solitaire app that you can open up on your desktop? Yes. There are lots of applications written in C. In the open source world, it's still sort of popular even as a language for writing desktop-ish apps. Some are vlc, mplayer, and xchat. I think large portions of GNOME are also written in C. Lots of GNU software are written in C, iirc. Other kinds of software people write in C include operating system (e.g. Linux), device drivers, embedded software. I can't really tell where C is mostly used though.
It applies to at least the C, C++, and Java tutorials, since these are the only ones I've browsed. Given what I know, I highly doubt the others are any better.
Alright thanks. Was going to check them out tonight, guess I have to find other resources.
The main advantage of C I would say is that it is easily portable to new architectures. Someone who codes in java for example may jump in and say blahhhh! java runs on any computer and doesnt need to be ported. However if you write a program in java you are pretty much limited to architectures that java supports. If you write a program in C you are also limited to architectures that have C compilers, but that is basically every architecture. So if you have helloworld.c the only thing that needs to be ported is the print function. Helloworld.java however needs to port the entire java runtime, then port the print function to execute. One example of an application of C is writing programs for microcontrollers. You often only have two choices for programming languages(C or Assembly). It is highly recommended to use C not only because it is easier, but also because code written in C can be easily ported to other microcontrollers. 
Quake 3 was made using C!
C can be used for anything. However it is mostly used for lower level things such as kernels, device drivers and the like. Having said that a lot of applications, especially on Linux, are written in C. For the past 20 years most desktop applications on Windows are written in C++ although the underlying Win32 API is actually C so any Windows app could be written in C. Now most people don't want to write a desktop or web app in C because generally it is easier to do it in another language like C++ or C# as they do make it a bit easier to do things like a user interface, networking, etc. with modern libraries. C is the lingua franca in the computer world though. Almost every library will have a C interface for example. 
It's a general purpose programming language. The limit is your imagination (and coding skills... And hardware...). You could write a small database system for instance, since you say you're interested in storing stuff and in data structures.
C is primarily used for OS (specifically *nix) development, utilities, game development and low-level hardware development. I became more interested in electronics since learning about C. If that interests you, check out http://arduino.cc. Kernel/OS development is a little higher level and if you use Linux, it's pretty interesting to see how it all works. By utilities, I mean command-line utilities. If you're not already working at a command line, you should definitely consider switching to it. I almost never touch a GUI when doing C development (I commonly use vim, clang or gcc, git, and ctags all from the command line). I haven't written too many C utilities myself, but I am currently working on [developing a compiler](http://github.com/charles-l/dobble). I've used C for some game development with SDL2, but it's more common to find C++ used in game development. The only disadvantage of using C instead of C++ is the lack of OO in C. If you decide to use C++, just use the OO and stick with common C idioms. I've seen more elegant C than elegant C++.
I like [SDL](http://libsdl.org/) for writing games in C, though it's been a while.
Thank you for the reply! There are a couple of specific issues I'm having: 1. The while loop I'm using to feed the grades into the array keeps cycling indefinitely after the first user input and I can't really think of how to get it to pause after each input to accept another. 2. I actually am having trouble initializing the array I'm using to store the grades.
Yeah, it can feel like defeat to ask someone to look over your code, but sometimes it's better to just ask for help instead of banging your head on the wall attempting to do it on your own.
Handmade Hero is C++, not C.
Alright, so this is what I've come up with so far. It lets me input three values, but after that the script crashes. #include &lt;stdio.h&gt; #define FREQUENCY_SIZE 11 // define frequency array size // function prototypes void getAverage(float total, int count); // void getStats(int b[]); // function main begins program execution int main(void) { float grades[] = {0.0}; // array to hold the grades float input = 0.0; float total = 0.0; int gradecount = 0; int i = 0; while(input != -1) { printf("%s", "Enter a grade (-1 to quit): "); scanf("%f", &amp;input); if (input == -1) { break; } else { grades[gradecount] = input; total += grades[gradecount]; gradecount++; } } getAverage(total, gradecount); } void getAverage(float total, int count) { float average; average = total / count; printf("Class Average: %.2f\n", average); }
C is nothing like JS...
 float grades[] = {0.0}; // array to hold the grades float This only allocates space for a single float. You need much more room than that. grades[gradecount] = input; total += grades[gradecount]; gradecount++; This is not the algorithm I would have chosen, because it requires that you constantly reallocate memory without limit. The solution that I have in mind only requires you to have a single array of 10 integers, each of which stores the count of grades within one of the given ranges.
It is C++, but it's as strictly C as can be. I think with some work, you could do the same in plain C.
Mostly cry... and programming microcontrollers.
I'm working on a multiplayer OpenGL action shooter game that's procedurally generated, in C
If the input has to be 32 chars than can't you just do the following? char array[32]; memcpy(array, argv[1], 32); or am i missing something.. 
Most anything you want really. In the end it's all machine code. A more useful answer though is that Javascript is designed to run in a scripting engine/virtual machine sand box (eg: the browser) and run consistently on any machine supporting "javascript" at the cost of functionality/speed (since it's limited to the VM/scripting engine it runs in). C however compiles to machine code that runs directly on the target hardware. This gives you performance and most all of the functionality of the target system at the cost of portability (since you can't pick up the compiled executable and put it on a different target system necessarily). So anything you want to write you can write in C and run it on a computer (with caveats). So you can write a program to run in OS/X or Linux or Windows and it can interact with the system as long as you know how to interact with the system. Easy stuff may run just at the console/command line but more complex stuff can control windows and take over the whole computer. The catch is, a lot of the libraries and documentation these days will expect you are using C++ and not C so you may have to do some extra work to get things to play nice (Direct X used to tell you exactly what you needed to do to make the C++ calls in C, but I haven't checked if they do lately). 
Thanks for introducing me to projecteuler!
The principle advantage of C is that it's the highest-level language that can be used to write a fully functional assembler. Bitwise operators, among other things, allow one to write assemblers and other gate-level code in C. 
Because John Carmack didn't know C++ :)
Your question is underspecified. What is an “array[32]?” What do you mean by “get?” What is a “32 number?”
If you use Linux regularly, you begin to realise that a LOT of popular software that is used is written in C. - mpd - ncmpc - mpv - ffmpeg - bash - grub - GNOME - The Linux Kernel - git - iptables - nginx - apache - the coreutils, i.e. ls, cd, man, who, grep, cat, sed, awk, cp, rm, mv...etc. I could go on.
thx dude
You can write an assembler in any language. As long as it can read a text file and output binary you are good to go. Nothing special about C in that regard.
An important thing to remember when programming in C vs Javascript as well... Javascript holds your hand and protects you from hurting yourself too bad. C will let you set fire to the system and won't tell you that you shouldn't do that. Stay away from pointers until you are sure that you understand what is going on.
http://www.avrfreaks.net/ has really good stuff. Stick with AVRs when first starting out. Its fairly well documented and has a great community around it. From there you can branch out to pic, Motorola, arm or TI msp430 platforms pretty easily. Its a lot of research but its one of the best self learning experiences you'll ever run across.
Honestly, just a lot of googling and messing around.
I guess I don't understand the difference.
I agree with /u/none_shall_pass that the question doesn't make sense, but I guess a function that calls itself?
In which context was this question raised?
Recursive functions or procedures refer to themselves. The classic example of a recursive function is the Fibonacci function, so I won't bore you with that, instead, imagine you're trying to define "the smallest out of a list of numbers". Now, the classic programming approach (this is pseudo-code, partly because i haven't written c in a while): function min(list) min_cand = list[0]; for (i = 1; i &lt; list.length; i++) { if (list[i] &lt; min_cand) { min_cand = list[i]; } } But what if you definied it this way: function min(list) if (list.length == 1) return list[0] rest_of_list_min = min(all_except_first(list)) if (list[0] &lt; rest_of_list_min) return list[0] else return rest_of_list_min The second function calls itself at the line min(all_except_first(list)). That makes it recursive. Now, you might be thinking "that's not very useful". And you'd be right, for this example. But there are certain problems that are much easier to solve recursively (quicksort and mergesort). Briefly, mergesort's algorithm is: Split the list in half. Mergesort the first half. Mergesort the second half. Combine the lists, looking at the first element of both and putting them into a new list based on which is smaller. The truth is, though, many recursive algorithms can be converted into iterative algorithms, and the converted version is much faster. There are some considerations that are a little beyond the discussion if you're new to this, but they cause performance to often be worse in the recursive solution. [SICP](http://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs) is a classic text in programming, and has a lot of information on recursion, if you're interested.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Structure and Interpretation of Computer Programs**](https://en.wikipedia.org/wiki/Structure%20and%20Interpretation%20of%20Computer%20Programs): [](#sfw) --- &gt;___Structure and Interpretation of Computer Programs___ (___SICP___) is a textbook aiming to teach the principles of computer programming, such as [abstraction](https://en.wikipedia.org/wiki/Abstraction_(computer_science\)) in programming, [metalinguistic abstraction](https://en.wikipedia.org/wiki/Metalinguistic_abstraction), [recursion](https://en.wikipedia.org/wiki/Recursion), [interpreters](https://en.wikipedia.org/wiki/Interpreter_(computing\)), and [modular programming](https://en.wikipedia.org/wiki/Modular_programming). It is widely considered a classic text in [computer science](https://en.wikipedia.org/wiki/Computer_science), and is colloquially known as the __wizard book__, due to the wizard on the jacket. It was first published in 1985 by [MIT Press](https://en.wikipedia.org/wiki/MIT_Press) and written by [Massachusetts Institute of Technology](https://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology) (MIT) professors [Harold Abelson](https://en.wikipedia.org/wiki/Harold_Abelson) and [Gerald Jay Sussman](https://en.wikipedia.org/wiki/Gerald_Jay_Sussman), with Julie Sussman. It was formerly used as the textbook of MIT introductory programming class and at other schools. Before SICP, the introductory courses were almost always filled with learning the details of some programming language, while SICP focuses on finding general patterns from specific problems and building software tools that embody each pattern. &gt;==== &gt;[**Image**](https://i.imgur.com/x1CCTDo.jpg) [^(i)](https://en.wikipedia.org/wiki/File:SICP_cover.jpg) --- ^Interesting: [^Drawing ^Hands](https://en.wikipedia.org/wiki/Drawing_Hands) ^| [^Pico ^\(programming ^language)](https://en.wikipedia.org/wiki/Pico_\(programming_language\)) ^| [^Meta-circular ^evaluator](https://en.wikipedia.org/wiki/Meta-circular_evaluator) ^| [^Metalinguistic ^abstraction](https://en.wikipedia.org/wiki/Metalinguistic_abstraction) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq7035y) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq7035y)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt;Because John Carmack didn't know C++ :) Or he knew better than to use it.
what about TCO? they might be structurally different but anything that you can do with looping you can also do with recursion.
I'm probably slower than most of the guys here but I don't understand the desired output. Can you post an example? How far have you gotten towards a solution? 
They are really different, but, if it helps: for x from 0 to 100: print x This prints all numbers from 0 to 100 and is a loop. def myPrinter(x): print x if x &lt; 100: myPrinter(x+1) myPrinter(0) This does the same, and is a recursion. Usually recursion is more expressible than flat loops since there are some things that are easy on recursion but really hard with loops - specifically, anytime you have more than one recursive call on your function (since that encodes a tree). To replicate that with loops you'd need to build a stack. Nevermind that paragraph, though. Just understand that anything you can do with loops you can with recursion, and vice versa - recursion is a function that calls itself, while loop is a piece of code (not necessarily a function) that is called several times by the compiler. Only practice will truly make you understand the difference. 
I'm not going to do your homework for you.
I don't get the question. Recursion and loops are pretty much the same thing. There is no special 'recursion' operator in a computer, its all done using jmps and conditions. recursion is just a loop that makes funky use of a stack
It sounds like he's trying to make [this](http://en.wikipedia.org/wiki/15_puzzle).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**15 puzzle**](https://en.wikipedia.org/wiki/15%20puzzle): [](#sfw) --- &gt;The __15-puzzle__ (also called __Gem Puzzle__, __Boss Puzzle__, __Game of Fifteen__, __Mystic Square__ and many others) is a [sliding puzzle](https://en.wikipedia.org/wiki/Sliding_puzzle) that consists of a frame of numbered square tiles in random order with one tile missing. The puzzle also exists in other sizes, particularly the smaller __8-puzzle__. If the size is 3×3 tiles, the puzzle is called the 8-puzzle or 9-puzzle, and if 4×4 tiles, the puzzle is called the 15-puzzle or 16-puzzle named, respectively, for the number of tiles and the number of spaces. The object of the puzzle is to place the tiles in order (see diagram) by making sliding moves that use the empty space. &gt;==== &gt;[**Image**](https://i.imgur.com/gp4E8wr.png) [^(i)](https://commons.wikimedia.org/wiki/File:15-puzzle.svg) - *A solved 15-puzzle* --- ^Interesting: [^List ^of ^impossible ^puzzles](https://en.wikipedia.org/wiki/List_of_impossible_puzzles) ^| [^GNOME ^Games](https://en.wikipedia.org/wiki/GNOME_Games) ^| [^Sam ^Loyd](https://en.wikipedia.org/wiki/Sam_Loyd) ^| [^Pebble ^motion ^problems](https://en.wikipedia.org/wiki/Pebble_motion_problems) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq7h4zd) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq7h4zd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Do you already know a language? Learning an entire language in a few days will almost never work...
Non-mobile: http://en.wikipedia.org/wiki/The_C_Programming_Language ^That's ^why ^I'm ^here, ^I ^don't ^judge ^you. ^PM ^/u/xl0 ^if ^I'm ^causing ^any ^trouble. [^WUT?](https://github.com/xl0/LittleHelperRobot/wiki/What's-this-all-about%3F)
Quicksort is an example of recursion that can't be implemented as a loop. Though it's possible to fake it by reimplementing a stack.
[Fibonacci Programming - Computerphile](https://www.youtube.com/watch?v=7t_pTlH9HwA) [Primitive recursive function](http://en.wikipedia.org/wiki/Primitive_recursive_function) [μ-recursive functions](http://en.wikipedia.org/wiki/%CE%9C-recursive_function) [Recursively enumerable](http://en.wikipedia.org/wiki/Recursively_enumerable_set) [Recursion theory](http://en.wikipedia.org/wiki/Computability_theory)
Endianness is only observable if you access the underlying bytes of the type. That's not what you're doing. Expressions like `val &gt;&gt; 8` and `val &amp; 0xff` are performed as operations on `uint16_t`, which means the endianness is not exposed. `val &amp; 0xff` is always the LSB regardless of endianness. You're only casting to `uint8_t` afterwards, but at that point it's just a formality to shut up any warnings; you've already isolated the byte in question, so the cast isn't really doing any work. Compare yours with a broken way of doing it: void brokenSend(uint16_t val) { uint8_t *bytePtr = (uint8_t *)&amp;val; outByte(bytePtr[0], ADDRESS); // MSB outByte(bytePtr[1], ADDRESS + 1); // LSB } This example assumes big-endian, and will fail if the system is little-endian, because it's accessing the bytes directly, rather than doing bitwise operations on the entire width of the value. Your version is fine, this example is bad and is given only as an example to compare against. 
Well, your output has trailing spaces at the ends of the lines, for one thing.
Well, I tried again, and that's not it. Thanks btw
What do you mean with “I am getting a wrong answer?”
Your way of doing things is the right way. Please continue coding that way. You might be interested in [this project of mine](http://github.com/fuzxxl/memf).
I know some C but I am essentially just barely a beginner. It has also been years ago that I last used C on a beginners level
I assume (s)he means that the website they are submitting to is telling them they have a wrong answer, but not necessarily telling them how they failed.
I guessed something like that. Any way, this question is vastly underspecified. It doesn't even tell me what the expected output is.
A definite possibility is that you are running into integer overflow. Two polynomials of degree 10,000 whose coefficients can be as large as 1000 can produce a product with coefficients larger than the maximum value of a (32-bit) `int`.
Ok. I must have overseen that link.
Your code will only work on platforms with an 8-bit char (byte), but other than that, no problems.
A basic echo server is a good first project. Just listen on a port, and when someone connects (use netcat for this!), echo each line they send back to them. From there you could do chat, if you want. From there, I'd actually encourage you to work towards a very basic HTTP server. The HTTP protocol is surprisingly easy, and the original server was implemented by Tim Berners-Lee in only a couple hundred lines of readable C.
Every program needs to have a `main` function. The examples you see in your book lacking a `main` functions are probably examples of how to write functions to perform various things. But, when they're used, they must be compiled together with some bit of code that defines a `main` function. Program execution does not happen the same way it does in C as it does in JavaScript. The `main` function tells the compiler what bit of code is ran when the program is ran. The return type of the `main` function _must_ be `int` (although the standard does leave some wiggle room for implementations to provide a way to provide other kinds of main function; this should probably be irrelevant to you though). `void` is not a valid kind of return for `main`. The confusion probably comes from Java which has a main method whose return type is `void`, or from a general understanding the C `main` function doesn't return anything because it can be compiled without an explicit `return` statement. As for why the compiler warns you when the type defaults to `int` when it's not specified, this is for historical reasons. Back in the day, you did not need to specify the return type (or even parameters) for things, and the compiler would assume that they were `int`s. This is ANSI C from 25 years ago, and is not good C today, which is why the compiler is warning you that you should not use implicitly typed functions.
main is not documentation, it is a function. It's special because it's the entry point, it's the first function called when you run your program. Shared libraries won't have a main, because they're libraries and not programs. Some random file that you look at won't have a main. Only one file in the whole project needs a main function. In older versions of C, if you don't specify a function's return value it defaults to int and you get a compiler warning. In newer standards you have to specify a return value. "void" is the nothing type. If the function returns nothing, you write "void" as its return type. If it takes no arguments, you write void where they arguments go when defining it (not when calling it). You can't have a variable of type void. You can have a variable of type "void*" (void pointer). In this case, it means it's a pointer to an unknown type (instead of to nothing).
main() is the first function called by the C library after it has self-initialized (by hidden code within your program). Some compilers offer several other (non-standard) functions that are called before main() gets called, for example so C code can initialize a system so that the C library can exist.
If you want to go really far, `main` doesn't actually have to be a function: http://jroweboy.github.io/c/asm/2015/01/26/when-is-main-not-a-function.html
What do you know about the endianess of the data in `aui8_array`? If the endianess of the data in there is fixed, then go for the first approach. If it depends on the host architecture, you might want to go for the second approach.
I think you should read about more sophisticated things you can do with `printf`. You can control the field width and justification; for example #include &lt;stdio.h&gt; int main() { printf("%-20s %3d\n", "Hello", 130); printf("%-20s %3d\n", "Printing things", 1); } 
I see, thanks!
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Unix, CP/M, BBS**](https://en.wikipedia.org/wiki/Box-drawing_character#Unix.2C_CP.2FM.2C_BBS) of article [**Box-drawing character**](https://en.wikipedia.org/wiki/Box-drawing%20character): [](#sfw) --- &gt; &gt;On many [Unix](https://en.wikipedia.org/wiki/Unix) systems and early dial-up [bulletin board systems](https://en.wikipedia.org/wiki/Bulletin_board_systems) the only common standard for box-drawing characters was the [VT100](https://en.wikipedia.org/wiki/VT100) alternate character set. The [escape sequence](https://en.wikipedia.org/wiki/Escape_sequence) Esc ( 0 switched the codes for lower-case ASCII letters to draw this set, and the sequence Esc ( B switched back: &gt;A [Bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell\)) script that displays all of the semigraphic characters: &gt;On some terminals, these characters are not available at all, and the complexity of the escape sequences discouraged their use, so often only [ASCII](https://en.wikipedia.org/wiki/ASCII) characters that approximate box-drawing characters are used, such as - ([hyphen-minus](https://en.wikipedia.org/wiki/Hyphen-minus)), | ([vertical bar](https://en.wikipedia.org/wiki/Vertical_bar)), _ ([underscore](https://en.wikipedia.org/wiki/Underscore)), = ([equal sign](https://en.wikipedia.org/wiki/Equal_sign)) and + ([plus sign](https://en.wikipedia.org/wiki/Plus_sign)) in a kind of [ASCII art](https://en.wikipedia.org/wiki/ASCII_art) fashion. &gt; --- ^Interesting: [^Code ^page ^852](https://en.wikipedia.org/wiki/Code_page_852) ^| [^Code ^page ^950](https://en.wikipedia.org/wiki/Code_page_950) ^| [^Box ^Drawing](https://en.wikipedia.org/wiki/Box_Drawing) ^| [^Code ^page ^850](https://en.wikipedia.org/wiki/Code_page_850) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq8tt6y) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq8tt6y)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
That is exactly what I was looking for! Thanks very much!
I've never come across any running on linux software that would be able to do that. There exitsts microapl's http://www.microapl.co.uk/asm2c/index.html, but it's a commercial project. Converting back to original c is impossible, because some information is put away during compiling (variable names, comments, macroses are replaced with their definitions and so on). You can use objdump. It would produce you asm code from binary, it could suit your needs.
Since it's a double linked list: 1. Pick a starting node. 2. Advance one pointer forward. 3. Advance one pointer backward. 4. Go until they meet again.
Yeah, that's what I said. There's a bit of finessing involved though. abc; p = a, n = a abc; p = c, n = b abc; p = b, n = c abc; p = a, n = a ... you just printed the starting node with your step three. Edit: Technically, any node in a circular-odd-numbered-list is the middle. 
Thanks.
It should actually be "how do you handle an even number of nodes". Because there actually is a middle to an odd number of nodes. You need to develop cases where each pointer can see the next. I was laying out the general ground work for OP. Once they get the concept down, they can work out the remaining details. If I did the whole thing for them, what would they learn?
What's the middle of four? 1 2 3 4 Is it 2.5 ? Because that's not a valid pointer location. See, you aren't counting the starting node when you're considering the remainders. You're ignoring it, which is why you run into the scenario of thinking that an odd number of nodes is the special case. It's actually the even number that has no middle. But these are the special cases that the OP needs to figure out how they're too be handled. Basically, if n = p and n != a, then you have an even number of nodes, and you have to decide which one (prev, or next) you want to make your middle: abcd; n=p=a abcd; n=b,p=d abcd; n=c,p=c ... n=p=c !=a ... but clearly c is not the middle
This works for C: [http://cppcheck.sourceforge.net](http://cppcheck.sourceforge.net) There aren't a lot of good free tools out there that I know of. Especially ones that check for Misra compliance. 
If you're going to program, you need to learn troubleshooting. If your tree works when you insert from one source, but not another, then it's clearly an issue with the source you are inserting from. That being the case, you should throw in some debugging code to see if you're actually fetching from that source correctly.
OP: &gt; yet when I look examples up online there are many programs which do not begin with that documentation. OP is confusing the top of the file (where he begins reading) with where the program's entry point actually is. Good summary on your part.
At best you're going to get something back that resembles C but is really prettified assembly. In general without some kind of debugging symbols, the original C code used to compile an executable is not recoverable, although tools like IDA can do a pretty decent attempt at it. 
Could you provide the content of the screenshot as text instead of a picture? Pictures are useless for copy-pasting and for blind people.
I threw in a code to print what im fetching and it is fetching correctly.
&gt; How is it determined that the file of the script is 868 bytes? You tell us — how did you come to that conclusion? Are you talking about the size of the file? A text file is just a series of characters. And by the way, it's not customary to refer to a .c source file as a script, because C is not a scripting language, at least traditionally. The size of the executable is larger than the size of the source for a number of reasons: - The program that you wrote has been turned into a series of machine instructions. The size of a machine instruction varies with the different types of hardware. On x86 a single instruction can be between 1 and 16 bytes, although most instructions are on the smaller end, averaging in the range of 3 - 5. A given expression or statement in C might take many instructions to implement. - The compiler inserts do-nothing instructions (nops) to ensure that things like function entry points and branch targets have a certain alignment. This wastes a small amount of space but increases performance. - The executable has a small amount of startup/initialization code from the C runtime library. Even if you compile a program that does nothing, you'll see that code statically linked in. You can see these as objects with names like `crt*.o` in your full link command if you use `-v`. - The executable may have a symbol table and/or debug information if it has not been stripped, depending on the flags you used when compiling. - The various sections and segments of the executable have certain alignment requirements, which wastes a small amount of space, which is negligible except for very small programs. - The executable has a series of headers that describe the contents, which also take up a small amount of space. - Assuming that your program is dynamically linked against libc, there will be a small amount of data needed to implement dynamic linking, such as a list of names of dynamic symbols and some kind of means of indirection (e.g. the GOT and PLT on ELF systems.) You can see how all of the above come into play by using a tool like objdump or readelf to look inside the contents of the binary. 
In short your program isn't just what you wrote, it includes everything your program *uses* ~~such as any #include files and any libraries used.~~
You're half right. Headers won't affect output size, However how libraries are linked or included depends on your compile options. Which I think OP is *static* linking causing the "outside functions" to be included in the final binary. 
If the current output doesn't matter, why do you provide it? Of course it matters! Just remember for the next time: Do not post images of just plain text. They are useless for almost all purposes.
FYI: you can use Fabrice Bellard's Tiny C Compiler (aka TCC) to make smaller exe files that aren't bloated with compiler optimizations. One reason the binary executable can be larger is because one line of code can be expanded into many cpu instructions. But also all the stuff the compiler includes for OS interaction, etc. Gone are the days where your code is all that the CPU sees. An interesting read: http://blog.erratasec.com/2015/03/x86-is-high-level-language.html#.VRMWtvnF-FU
Dunno about ELF, but Portable Executable has two alignments for sections: FileAlignement and SectionAligment (virtual memory). The default file alignment is 512 bytes (minimum). EDIT: Some numbers with MinGW-W64 The code: #include &lt;stdio.h&gt; int _tmain(void) { printf("Hello World\n"); } Compiler options | Output size (Byte) ----------------|------------------ None | 46,765 -Os | 46,845 -s | 16,384 -s -nostdlib -lmsvcrt | 3,584 (previous) + -fno-asynchronous-unwind-tables | 2,048 (3 sections + header) (previous) + -Wl,--file-alignment=1 ** | 768 ** Doesn't produce a valid executable.
The problem is the way you read input. The man page for `scanf` says: &gt;s Matches a sequence of non-white-space characters; [...] However, `\n` *is* a white-space character, which means that `user_input` will never contain a `\n`, which means that `change_string` will call itself endlessly. Adding those two lines makes the code work because `(i=='\n')` is the same as `(i==10)` (assuming your computer uses ASCII) and `i` will eventually reach that number. The code is still buggy because it will cause undefined behavior if the string has only a few characters. To fix the code correctly, stop when you find a `\0` instead of `\n`. Don't forget to check the first two characters too (your code currently doesn't do that). You may also want to use `fgets` instead of `scanf`: fgets(user_input, 20, stdin); The advantage of `fgets` is that it doesn't read more than 20 characters, which would cause undefined behavior. However, it *does* read the `\n` character unlike `scanf`. String handling in C is unfortunately quite complex.
one other thing I've found useful for this: you might not know it yet, but printf actually returns a value, which is the number of characters it has printed. You usually throw the return value away, but instead you can write `t=printf(" [whatever]");`, giving you the number of characters in your variable `t`. If you have more than one printf statement in the first column, for the subsequent ones do `t+=printf( whatever );`. To make use of this, you first set a `tab` variable equal to 40, say, then print your first column, then, in a loop which you cause to be executed `tab - t` times you print a space. And voila your second column will begin printing at the 40th character on the line. 
Well the current output doesn't really matter in this case. I was just wondering if there was a function in C that could be used to sort data into a table. That was my prime objective. I only threw in the image on the off chance people were unsure of what I meant when I was already talking about what it was currently outputting. 
That's REALLY useful. Thanks!
You can use objdump to examine the compiled program. I'm sure the .text section is quite small.
You haven't stated the problem that you're having or given the source you are having it with.
Well, I want to know if I can use a unique subroutine to calculate the salary of all workers, or if I have to make four subroutines for the four types of workers.
So, you've determined that you're *fetching* from the text file correctly. The next question you should ask is whether you are correctly *inserting* the values you have fetched, given that the insertion code is different for the two cases (one being in `main()` and the other being in `guardar()`). So, I would put some debugging code in `guardar()` to show you the tree you are building (or are supposed to be building) on each iteration. Looking at the value of `t` on each iteration should get you somewhere.
you could use another variable like: float all_salaries_added; ...and keep increasing that every time your saltotal variable gets updated. 
 int * calcMatrix(int min, int max){ int numInts = max - min; int * a1 = (int * )malloc(sizeof(int) * numInts); int j = 0; for (int k = min; k &lt; max; k++) { int r = k / N; int c = k % N; int sum = 0; for(int i = 0; i &lt; N; i++){ sum += A[r][i]*B[i][c]; } a1[j] = sum; j++; } return a1; } There's with formatting. Put four spaces before each line of code. You don't need to typecast malloc. Did you forget to include the header file for **malloc** by any chance?
Are you expecting it to print something every time you type a character? Because thats not what your code says. If you expect it to print something every time you type something, you need some braces for your loop. Its not python, where indentation counts.
Yes, that's precisely it . I mean, don't get me wrong, that's what I was expecting since I'm doing it by the book, and you have that printf there, for me it seems logical it would print the increment every time I type something, that's the point I'm not understanding, it I have a statement: printf("%d\n", nl); that should print the contend of nl formatted in 1 decimal point, followed by a newline character ("%d\n") isn't it? Feel free to tell me what's the point I'm not getting here. Thanks 
Non helpful question perhaps, but why are you looking to conform to MISRA C? I ask because generally people fall into two groups regarding MISRA: * Businesses developing software in industries that are required (or strongly recommended) to follow MISRA principles such as Automotive, safety related products, etc. For these companies, tools that cost $389 are no big deal. * Everyone else I was wondering if you had stumbled on MISRA as a sort of metric of code quality for your personal projects, or if you are in some other situation (start-up aimed at a safety industry) where you actually NEED MISRA compliance to pass certification, etc. IMHO MISRA C has a lot good ideas to it, but can go too far in some places, and certainly isn't an end-all be-all of code quality. edit: Feel free to PM me if you want to discuss in private rather than public.
Thank you man, I mistook \n with \0 have an upvote :).. I can't use fgets, I was asked to use scanf. (it's home work.)
I managed to fix it, thanks very much. It was a simple problem that i overlooked.
Generally I add the headers and library file to the linker and compiler path (using GCC it is is the -L and -I flags). That said some libraries, such as Lua are easy to build, so I will just put the source in my project generally.
&gt; a+b+c+d You seem to have the basics of it?
A larger integer type, such as `long` or even `long long`.
That book, although recommended by tons of people, is getting pretty old (1st edition 1978, 2nd ed. 1988). It was written by the authors of C before a C standard was even made. It's not the best book if you're an absolute beginner, because it wasn't written to be super descriptive and simple; it just concisely covers all the features you would need. There's also a lot of modern coding practices and updated C facts that the book is missing due to its age. (Like int main(void) for example) So you should either keep powering through K&amp;R, and just look up help online when you need it like you did here, or go for an easier book that will explain things more clearly. I got stuck in like chapter 2 of K&amp;R, and I switched to [C Programming: A Modern Approach](http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504) instead. Now I'm actually getting things and I plan on revisiting/completing K&amp;R later. 
As a general rule of thumb, locations like `/usr/include` should be considered off-limits. They are owned by and managed by the package manager, not you. Install your stuff elsewhere. Most libraries let you configure an install prefix, which is `/usr/local` by default, which means headers go in `/usr/local/include` and libraries in `/usr/local/lib`. These locations are generally part of the list of system search paths, so if you use that default you don't have to do anything extra. But let's suppose you don't have root privileges to write there. Let's say you're building libfoo and you want to install it somewhere under your home directory: $ wget http://libfoo.example.com/libfoo-1.5.tar.gz $ tar xf libfoo-1.5.tar.gz &amp;&amp; cd libfoo-1.5 $ ./configure --prefix=$HOME/mystuff $ make -j4 &amp;&amp; make check &amp;&amp; make install Okay, the library is installed. It's also a good idea to add `$HOME/mystuff/lib` to your `LD_LIBRARY_PATH` environment variable so that the dynamic linker can find .so files there. $ export LD_LIBRARY_PATH=$HOME/mystuff/lib # if it was empty before $ export LD_LIBRARY_PATH=$HOME/mystuff/lib:$LD_LIBRARY_PATH # otherwise (In reality, you'd add these lines to your shell's RC startup file, otherwise you'd have to type them every time you start a new shell.) Now let's build bar, a program which depends on libfoo: $ wget http://bar.example.com/bar-4.2.tar.gz $ tar xf bar-4.2.tar.gz &amp;&amp; cd bar-4.2 $ ./configure --prefix=$HOME/mystuff CPPFLAGS=-I$HOME/mystuff/include LDFLAGS=-L$HOME/mystuff/lib $ make -j4 &amp;&amp; make check This build bar. bar can be installed as `make install` if you want, or you can run it uninstalled from the build directory. Setting -I in CPPFLAGS tells the C preprocessor where to find the headers, and setting -L in LDFLAGS tells the linker where to find the libraries. (Note that this is the link editor, not the dynamic linker; these are two different things that need to be configured differently.) You can throw in some `--disable-shared` if you don't want shared libraries, and generally there are a ton of standard autoconf options, e.g. if you want to customize the CFLAGS you might want `CFLAGS="-g -O2 -march=native"` or whatever. All of the above assumes autotools packages, which hopefully is the case. Other build systems work differently, but the ideas are the same. 
that
I like to use imperial units: foot/fortnight.
In addition to this, [tcc](http://bellard.org/tcc/) can run as an interpreter for .c files with a hashbang, so that acts as a proper script, rather than needing the compilation step.
True, but this also gives the advantage that any compiler can be used. The script uses whatever $CC is set to, whether it's Clang, GCC, or even 8cc — and of course the optimizations that come with them.
You may want to make your `$tmpdir` be a ram directory, a lot of your latency will probably be disk i/o. Also, you may want your executable to be pre-compiled C; [`dlopen_gcc.c`](https://github.com/Viruliant/Viruliant.GitHub.io/blob/master/Cite/mkconfExample/dlopen_gcc.c) could be a good start.
I included the header, but the issue just resolved itself somehow. Thanks dumsubfilter!
That's because tcc contains its own linker which does a few things differently when it comes to the placement of data structures in the binary. The machine code itself is *larger* but if you don't have a lot of machine code, such differences might show themselves.
`#!` isn't valid in a C program
The compiler can warn you about those cases: GCC uses the `-Wwrite-strings` flag. It is actually enabled by default for C++, but not for C. $ gcc -Wwrite-strings write-string.c write-string.c:3:13: warning: initialization discards ‘const’ qualifier from pointer target type char *red = "h\n"; ^ $ g++ write-string.c write-string.c:3:13: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings] char *red = "h\n"; ^ 
Binary output, grouping for long numerical output, and the ability to choose point/comma (or possibly something else) for decimal separation.
I'll admit, not too often. But it's such a simple feature, and really a pain those times you do need it. Besides, `fgets` works on files ... what if you're parsing strings already in memory? That's much more common, for me at least. And remember that it applies to more than just strings, too (that's just the most obvious and common way to use it).
please give some quick examples to clarify what you mean
Binary output for numbers, pointers, etc., as you stated. Digit grouping, e.g. print a long integer as `10,000,000` or `10.000.000` or `10 000 000` rather than the much less readable `100000000`. Programmer's choice of decimal separator character, the two customary ones being `.` and `,`, though being able to choose any arbitrary symbol for both this and the group separator would be ideal. Regarding the last point, I believe many implementations change the separators based on Locale, but that is an awful API that no programmer should ever be compelled to use.
%r for recursive would be cool. I have a hunch that it's going to be in POSIX soon.
Several compilers have fairily good builtin misra compliance checker. Tasking is quite OK from that perspective (but their linker/locator omfg). So you have two options. If you are just doing a hobby project, noone would hunt you down if you use a time limited eval copy of a compiler with builtin misra checker, and execute the misra check with it. If you are into commercial development however, then cough up that 400USD for PC-Lint. That tool deserves it.
ipv4 and ipv6 formatting would be neat but will never happen.
for future reference, you can surround your code in triple-backticks on both sides for it to be automatically indented correctly. ``` /* Example */ ``` turns into: ``` /* Example */ ```
Would be nice if MS got around to supporting `%zu`, 16 years after it was standardized 
The separator would have to be determined by the current locale, not by programmer selecting it explicitly
scanf is crap anyway
Interesting, although because function names cannot be resolved at runtime, you'd have to provide a mechanism to register the callback function for each custom format specifier.
`scanf` is crap because people use it for user interaction, and it's horribly suited for that job. But when you want to parse formatted data (user input is not formatted!), it's a very useful tool.
`sscanf` is fine, if that's what you mean :)
Useless advice: Don't start with ncurses if you don't want to end up like me. Useful advice: GTK isn't bad. If you want "graphics" more than you want "GUI", there aren't a lot of great graphics libraries that I'm familiar with without going to full-blown OpenGL, which is *not* beginner-friendly, but you could try SDL, which will do what you want. A couple of (simple) higher-level graphics and game libraries are built on top of SDL, so any knowledge you gain with it should transfer pretty well.
Check out the SDL library. It's used in many professional projects, and easy to get started with. http://lazyfoo.net/SDL_tutorials/ https://wiki.libsdl.org/Tutorials
If you want to ignore my useless advice, then you should take a look at Unicode blocks U+2500 through U+257F for line-drawing characters, U+2660 through U+2267 for suits, and U+1F0A0 through U+1F0DF for single-grapheme card fronts and backs.
I liked using Qt last time I had to, but it inherits a lot of awful properties from C++, and its dependency on code generation isn't pretty. Also, I use MOC (Music On Console), so I'm slightly sad at Qt for petty namespace reasons. The documentation is good, though.
Some of the best libraries will be the ones you write yourself. Once you have built a list of useful functions that you tend to keep using again and again, from project-to-project, put them into a library, and simply include that library in new projects. Other people's libraries have seldom helped me write programs. That's just me, I guess. In my early days of learning, I began to realize the time I was loosing in chasing down the perfect library could have been used to simply build it myself. Exceptions are rare -- like the [uuencode library](http://en.literateprograms.org/UUencode_%28C%29) I found long ago, and then later, an excellent [JPEG library](http://www.ijg.org/). But even with the JPEG library, I wasn't content to use it as is, 'out of the box'. I was soon re-writing key decoding routines in mixed C and assembly for more speed. 'Course, today, most PCs are powerful enough so that the lag time waiting on an image to paint is more attributed to download speed rather than JPEG decoding speed. 
Sweet! I'm looking to write an [Unlambda](http://www.madore.org/~david/programs/unlambda/) interpreter, once I wrap my head around a couple of things.
Highly recommend this answer. If you're interested at all in game development, SDL is the best place to start on non-windows platforms. It also provides an easy way to get started with OpenGL (for once you have some experience. OpenGL isn't that beginner friendly), but gives you a higher level 2d api which is probably where you should start.
I think OP's username says everything about this thread that needs to be said.
I don't know if this is what you're looking for, but I would familarize myself with Linux/Unix. You don't have to necessarily know Linux/Unix to be a good C programmer, but everyone I've met with a solid understanding of Linux/Unix and how to develop for it has also been very good with C (particularly device driver and kernel developers).
`%r` is an old extension discussed in the days when `vprintf` was introduced. The problem with `printf` is that it does not easily allow you to write custom `printf`-like functions because inside such a function you only have a `va_args` instead of a set of arguments. `vprintf` was introduced as a band-aid to fix these problems but it's clunky, does not play well with localization and doesn't allow you to nest custom `printf`-like functions unless you make a `vprintf`-like variant for each of them. The specifier `%r` corresponds to two arguments: one of type `const char*` and one of type `va_list`. These two arguments are interpreted as if they were a call to `printf` on their own, so you can easily write custom `printf`-like functions like this: extern _Noreturn void err(int eval, fmt, ...) { va_list args; va_start(args, fmt); if (fmt == NULL) printf("%s: %s\n", getprogname(), strerror(errno)); else printf("%s: %r: %s\n", getprogname(), fmt, args, strerror(errno)); va_end(args); exit(eval); } It's easy to see that this mechanism is much simpler than `vprintf` and friends. The reason why we don't have it already is that the interaction between `printf` and `wprintf` via means of `%r` (there would actually be both `%r` for `char`-based recursion and `%R` for `wchar_t` based recursion) is tricky to implement. The proposal itself is very old, it dates back to the 80's.
You can use POSIX' `%as` which allocates a buffer for you. If you use `scanf` with `%s`, you probably want to use `fgets` instead though.
Dafuq? They don't support `%zu`?!
Typically an `invalid conversion` is caused by incorrectly casting `void *`. On a side note, you do not need to cast the result of `malloc()`. See this [post on stackoverflow](http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc). You can just write: int * a1 = malloc(sizeof(int) * numInts);
What does “64bit numbers” mean for you? C99 specifies `%jd` for an `intmax_t` which will be at least 64 bits if the compiler supports a 64 bit type. C99 also specifies the macro `PRI64` for an `int64_t` (in `inttypes.h`), so what are you looking for?
[I built on in go!](https://aper.dy.fi/lauri/bf-go)
Opengl is fairly simple to get running for a simple interface that's static like blackjack, have a look at that, SDL can interface with it or you can use something like glew, glfw, glut (freeglut3), etc
your welcome :) 
Yes they can. Look at dlsym(3)
SDL or OpenGL are probably the best places to start. You didn't mention what OS you are on though, if you use Windows and you fancy developing some mental health problems you could try Win32 :P
There's [yuck, a command-line parser generator](http://www.fresse.org/yuck/) that does what you want, only requirement is a C99 compiler but otherwise it's free of any dependencies. 
&gt; Can C be used to write, for example, a solitaire app that you can open up on your desktop? Yep
Wow, I did not know about those. I've been using %ld on platforms where sizeof long == 8, %I64d on Windows, and %lld else where.
pthreads.. I also find myself using Attractive Chaos' khash macros lately.
If at all, something for base *n* output where *n* is selectable.
dlsym is not part of ISO 9899:2011, it's only part of POSIX. The other thing is that the API is not going to work the way you imagine it to work because there aren't namespaces with symbols. This is going to be a nightmare with respect to shared libraries.
It's not constructive, as I originally said. C is so mature it has multiple redundant libraries. Asking which is better/more valuable is a vague, dumb question, and has gotten vague, dumb answers.
Thanks for the advice. * I like the idea of passing `argv[1]` straight to `fopen`. I'll do that soon. * I'll look into changing up that while loop. I've heard some people gripe about !feof(fp), but I haven't got around to figuring out why. * Do I just seek to the beginning by calling fopen() again? * The whole "non-brainfuck characters" thing I do was mainly for while I was getting it working, I could make sure that everything was nice and clean and working. Comment support is somewhere on the list of things to add. Seriously though, thanks for the input! I'll update it soon. 
Always a good exercise! Good job.
Read the cat source and learn about getopt().
&gt; I'll look into changing up that while loop. I've heard some people gripe about !feof(fp), but I haven't got around to figuring out why. http://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong The accepted answer is correct but long and complicated and not particularly essential to understand. Instead, just know that you loop through all the characters in a file by testing for EOF explicitly. It's idiomatic, more performant, and most importantly, correct. &gt; Do I just seek to the beginning by calling fopen() again? Learn about `fseek()` at http://man7.org/linux/man-pages/man3/fseek.3.html. &gt; Seriously though, thanks for the input! You're welcome!
POSIX already has this, the specifier is `'`; for instance, you can use `%'d` to get integers in decimal with digit grouping. This functionality is of course locale-dependent.
You should switch to C11, or at least C99
I've used [docopt](http://docopt.org/) for my pthon apps. They also have a C version, but I have never used it.
Lots of implementations have lots of different things; the question was what do you wish were standard in all libraries.
You could make your map instead: `map&lt;string, pair&gt;` where the pair is your line/freq. &gt; I would try to figure this out, but i haven't worked with c++ in two years and I have a calculus 2 test tomorrow so I'm trying to study for it. College sucks. Try not to get work done last-minute.
Well, POSIX is sn industry standard. Too bad Microsoft does not give a shit about POSIX 
You are overwriting all the pointers to individual lines in `pixelArray` by that fread later down. You should read the lines individually. And you probably have to read them bottom up as well.
so the "computer really uses" the parenthesis like this: ++i || ( ++j &amp;&amp; ++k) now i see where i was wrong. i was too much focused on the left associativity and thus assumed it would run like this (++i || ++j) &amp;&amp; ++k thank you
No, based on the output `++i || ++j` ran first.
The final for loop sets symbol=1 when you reach the null terminator of the string, as it's neither alphanumeric nor a digit. This is an effect of how you set up your char counting loop, as it will add 1 to the count when it reaches the null terminator (loop is not terminated until next time it's run). It is also possible to do all your checks in a single loop (without counting characters) if you want to. Hint: set all variables that indicate whether a given type of character has been found to 0 before the loop.
Try using using [ispunct()](http://www.keil.com/support/man/docs/c51/c51_ispunct.htm) for(i=0; i&lt;=numberOfChars; i++) { if(ispunct(password[i])) { symbol=0; } else { symbol=1; break; } } Also: use [strlen()](http://www.tutorialspoint.com/c_standard_library/c_function_strlen.htm) numberOfChars = strlen(password); instead for(temp=0; password[temp] != '\0'; temp++) { numberOfChars++; } Don't forget to include &lt;string.h&gt;.
I didn't even know about the strlen lol, the null terminator is what messed me up. The ispunct is probably what ill do. Thanks for the tips
`&amp;&amp;` has higher precedence than `||`. So the expression is `++i || (++j &amp;&amp; ++k)`. Then since `++i` is true, the `||` short-circuits and does not evaluate the rest.
If someone happens to enter more than 100 characters, you'll get a fun buffer overflow. fgets() allows you to set a maximum length after which the input will be truncated, preventing this. fgets(password, 100, stdin); will read from standard input either 99 characters or up to the first newline, whichever comes first, then add a null terminator. You should also add a message warning that input will be truncated to 99 characters.
No, the op has it correct now. Parenthesis don't imply order of execution, just the way in which operands are bound to operators.
Non-mobile: [&amp;&amp; has higher precedence than ||](http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence) ^That's ^why ^I'm ^here, ^I ^don't ^judge ^you. ^PM ^/u/xl0 ^if ^I'm ^causing ^any ^trouble. [^WUT?](https://github.com/xl0/LittleHelperRobot/wiki/What's-this-all-about%3F)
Considering how long it's taken to get rid of `gets`, I don't think that's really true.
N3990 was a proposal for an operator in C++ for rotations. 
[Link to N3990 paper and resolution](http://wg21.cmeerw.net/ewg/issue123)
Very well done! Implementing these programming languages is always a really fun exercise. They are especially awesome because of how simple they are usually, meaning they aren't too insane to implement. In terms of your code style, you seem to have a lot of comments explaining pretty redundant things. I'm actually pro-comment, but some of your comments are too much. I'd recommend removing some of the comments that explain really obvious things ("closes the file"). Also notice how you've got huge comments that span the entire line explaining what the next section of code does. Also note that you do everything in main. I'd really recommend extracting out these sections of code into their own functions. This makes the code easier to understand, and means you can use function names instead of huge comments to explain what is happening. Other than that your code is really nice, and the whole thing is real well done!
this
I know exactly what you mean. I do like having nice English comments explaining what is happening, because I believe it is easier to read English than it is to read and understand code (at least if the comments are clear and concise). If you're going to mention DRY though I hope you see some of the comments and the code basically echo each other and so therefore violate DRY :P And don't feel compelled to split everything to its own file, but having functions to do specific tasks is definitely the way to go. Looking at your code, I'd probably go for a *readFile* function to read in the file and populate your BF string, a *process* or *tick* function that contains the main bulk of the BrainFuck interpretter code, then maybe a *cleanup* function where you free your allocated memory (this could quite happily go in your main function though).
I tried that, but instead of giving the results for months 22, 23, 24, it prints 22, 23, 24 with the results from months 4, 5, and 6 
Ah yeah that would probably help, sorry. #include "stdafx.h" #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int years, months, index; double principle, rate, interest, dolPrin, princBalance, payment; printf("What is your Principle Balance? "); scanf_s("%lf", &amp;princBalance); printf("For how many years will you be making payments? "); scanf_s("%d", &amp;years); printf("What is the rate? "); scanf_s("%lf", &amp;rate); months = years * 12; payment = 6648.10; printf("\nPrinciple = %.2lf Rate = %.0lf%%\n", princBalance, rate); printf("Pay/Mo = 6,648.10 Years = %d\n\n", years); printf("Month Principle interest $ to princ Prin Balance\n"); for (index = 1; index &lt;= 3; index++) { principle = princBalance; interest = (rate / 100) / 12 * principle; dolPrin = payment - interest; princBalance = principle - dolPrin; printf(" %2d $%.2lf $%.2lf $%.2lf $%.2lf\n", index, principle, interest, dolPrin, princBalance); } for (index = 22; index &lt;= 24; index++) { principle = princBalance; interest = (rate / 100) / 12 * principle; dolPrin = payment - interest; princBalance = principle - dolPrin; printf(" %2d $%.2lf $%.2lf $%.2lf $%.2lf\n", index, principle, interest, dolPrin, princBalance); } return 0; }
Okay gotya, that would make sense. Thank you!
You can also just copy and paste the code in between triple-backticks ``` /* example */ ``` 
On a phone and only briefly looked, but change: assignRandomName(people[i], firstNames, lastNames); To: assignRandomName(&amp;people[i], firstNames, lastNames); Also, loop from 0 to 9, not 0 to 10. That is, change &lt;= to &lt; 
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #include &lt;time.h&gt; struct Man { char firstName[10]; char lastName[20]; }; void assignRandomName(struct Man *man, char *firstNames[], char *lastNames[]); int main() { srand(time(NULL)); char *firstNames[] = {"Jeff", "John", "Garrett", "Jason"}; char *lastNames[] = {"Matthews"}; struct Man people[10]; int i; for(i = 0; i &lt; 10; i++) { assignRandomName(&amp;people[i], firstNames, lastNames); }; return 0; }; void assignRandomName(struct Man *man, char *firstNames[], char *lastNames[]) { int randNum = rand() % 4; strcpy(man-&gt;firstName, firstNames[randNum]); strcpy(man-&gt;lastName, lastNames[0]); printf("Man has been given the name: %s %s\n", man-&gt;firstName, man-&gt;lastName); }; 
Rotation is simply not really a useful arithmetical operation. It is a special case. It would also be convenient to have other things, like have a small network daemon that spawns child processes in one command or have a command that does something with every file in a directory tree (recursively). I use it very often, but it is still a special case for many.
pastebin a MWE.
You are mixing pid_t, which is a integer type, with strings. You need to call execlp with strings only in the parent and in the children parse the strings back to pid_t. I'm guessing the compiler is warning you about this. Also in execlp you are ignoring the arg0 parameter which typically maches the name of the executable.
You need to convert the PID's to strings first. A string is not just something you can cast to - you should probably try to understand them better before continuing with things like multiprocess programs. It's probably best to use sprintf to create a string which you then pass to execlp. [strtol](http://www.cplusplus.com/reference/cstdlib/strtol/) is usually preferred over atoi btw. 
Let me Google that for you: http://en.wikipedia.org/wiki/Minimal_Working_Example
This is pretty helpful. Pointers are giving me a lot of trouble. So if I just use an array without selecting an element then C will give me the memory address, right? But if I'm trying to select an element out of that array, it gives me the data and I need to reference it with &amp;?
Thanks. I mean it works and I noticed and made the changes but you didn't explain them. I specifically said I'm having trouble with pointers, specifically
How d'ya think I found that page? It's linked to from http://en.wikipedia.org/wiki/MWE.
yes that's it, my example wasn't completely right (I was thinking of a char pointer instead of a struct pointer) but the main idea is there. 
The first question you need to figure out: how are you storing the lines? First, let's assume we know there's always going to be 3 lines to read in, as your example shows. In that case, your best bet is an array of arrays: char dna[3][LENGTH]; for ( i = 0; i &lt; 3; i++ ) fgets(dna[i], LENGTH, input); But, we don't know the number of lines until we read the file. So, there's two options. First, you can set an upper limit (just like you did with the length of each line) if you know there will never be more than some maximum number of lines. The second option is to do dynamic memory allocation: typedef char dna_t[LENGTH]; dna_t *dna = (dna_t*) malloc(lines * sizeof(dna_t)); for ( i = 0; i &lt; lines; i++ ) fgets(dna[i], LENGTH, input); ... free(dna);
you're welcome, and to be fair, everything is just byte arrays, but we've got compilers which are more helpful (sometimes 'helpful') than assemblers :D
Don't worry, I get what you're saying. `fscanf` is the usual way to read a number: int lines; fscanf(input, "%d", &amp;lines); But you have to be careful mixing `fscanf()` with `fgets()`. The "correct" way of doing this is to read in the line with `fgets()`, then use `sscanf()` to get the number from the line. But in your case, just read in a character using `fgetc(input)` after reading the number and before reading the lines of DNA.
&gt; Rotation is simply not really a useful arithmetical operation. It is a special case. If it's not useful why does every processor I've used support it in hardware. Why does every compiler I've used support it through intrinsics? I've used rotates enough in my professional career that it has bothered me enough to ask a question that after several different C standards not one has standardized bit rotations.
`fgets()` for the first line, `fscanf()` + `fgetc()` for the second line, and then a loop of `fgets()` for everything that remains.
You still haven't told me what you use rotations for. I remember to have implemented them exactly once, for my gameboy emulator which has several variants of rotations in 8 bit width. What rotation widths do you miss? Nibbles? 8? 16? 32? 128? 53 bits width? With carry? Without? With filling 0? Or 1? Or leftmost bit? Rightmost bit? 1 or all step sizes? Overflow with or without trap?
Ahh, tyvm! I stumbled across these one day and lost the URL. Been looking for them!
Bus I/O, hashing, cryptography. I can't remember a specific example atm. I think in all cases it was unsigned 8/16/32 rotates, not through an additional flag.
username has to be big enough to hold the string. If it's just a pointer, you'll have to allocate memory for it to point to.
I don't remember the details of what I implemented; it was close to 20 years ago. Either the compiler I was using let me do it (standards be damned, lots of compilers had loose conformance at the time), or I did some pre-processor mess or some such. It's even possible that I set out to create operators, realized I couldn't, and ended up defining inline functions rol and ror, and remembered it wrong. That said, it has always bothered me that C++ doesn't have it. Comes up in an awful lot of crypto and hashing stuff.
That should probably be if( index &lt; 3 || index &gt; 20 )
strcpy_s is not available because you don't have C11…
Technically they are part of C11, but please don't use them. They have been introduced by Microsoft in an attempt to lock you into Windows. They are not going to be supported by Linux in the near future.
&gt; I am beginning to learn C using the book "Beginning C, 5th Edition" by Ivor Horton That is your problem. You should use this book: http://en.wikipedia.org/wiki/The_C_Programming_Language
Do your own homework.
When you do `assignRandomName(people[i] ...)` you are passing a full structure (of type `Man`) to `assignRandomName`. Because `people[i]` is a struct, not a pointer. If your intention was to pass the full struct, and not a pointer, then you would need to alter the declaration of `assignRandomName()` so it reads: void assignRandomName(struct Man man, char *firstNames, char *lastNames) In case the change isn't obvious, it's that the "*" has been removed from `struct Man *man`. You see, `struct Man *man` declares a pointer. A pointer that points to a structure. Specifically a pointer that points to a `struct Man`. If you pass in a structure where you were supposed to pass in a pointer... it isn't going to work the way you expect. So if you want to pass in a struct, then make the changes I mentioned above. ... However, you probably DON'T want to pass in a struct. The reason is, C passes function parameters "by value." In other words the compiler *makes a copy of* the parameter, and hands *the copy* to the function. So in your case, *a copy* of `people[i]` would be given to the code inside assignRandomName(). Changes would be made *to the copy*. And when assignRandomName() exited, the copy would be silently thrown away. Thus, no changes would ever be seen back at `main()`. So what you probably want, is to pass in *a pointer to* `people[i]`. Then you can "chase the pointer" and find the actual struct. First, fix the `for()` loop. To make a pointer, you put "&amp;" in front of the thing you want to make the pointer to. So inside the `for()` you put: assignRandomName(&amp;(people[i]), firstNames, lastNames); You leave the declaration of `assignRandomName()` alone - it is already asking for a pointer. All good there. You will need to fix the code inside `assignRandomName()`, it is not using the `-&gt;` operator (access a struct via a pointer) correctly. I will continue when I get home... gotta close up shop now.
Yeah, I knew C makes a copy so I was trying to give the function a pointer to my struct so I could edit the struct itself. I managed to get the program working with the advice of others that have commented, but thanks for helping me solidify my understanding
Would you mind showing me the code to implement this? I'm just continuing to have issues... So far I found a way to read it all, but I believe it's saving the entire text file (formatting correct, mind you) as a single array. Here's what I have for that part: void makeArray(FILE *input,char firstDna[LENGTH][ROW]){ int i,j; for(i = 0; i &lt; LENGTH; i++){ for(j =0; j &lt; ROW; j++){ fscanf(input,"%c",&amp;firstDna[i][j]); printf("%c", firstDna[i][j]); i++; } } printf("\n\n\n"); } 
i suck at this!!! no programming background and im in first semester of computer programming T.T 
Okay, home now... the power is off here, I think because the late spring snow cracked a tree limb and snapped lines somewhere down the valley. So I had to fire up the generator before I could get back online. Anyway, the syntax for the `-&gt;` operator is `pointerToStruct-&gt;thingInsideStruct`. So these lines in assignRandomName() are wrong: strcpy(*man-&gt;firstName, firstNames[randNum]); strcpy(*man-&gt;lastName, lastNames[0]); `man` is a `struct Man *`, aka a pointer to a `struct Man`. So you don't need to add any *s to it. Because it is already a pointer to a struct. You just use the -&gt; directly on it. E.g.: strcpy(man-&gt;firstName, "This is some string"); Or in your case... strcpy(man-&gt;firstName, firstNames[randNum]); So overall, the fixed version of `assignRandomName()` looks like this: void assignRandomName(struct Man *thisGuy, char *firstNames, char *lastNames) { int randNum = rand() % 4; strcpy(thisGuy-&gt;firstName, firstNames[randNum]); strcpy(thisGuy-&gt;lastName, lastNames[0]); printf("Man has been given the name: %s %s", thisGuy-&gt;firstName, thisGuy-&gt;lastName); }; You'll notice I've used "thisGuy" as the parameter name. I did that for ~~the lulz~~ code clarity. I sometimes find it confusing when the same name is used for both a data type and a variable, so I tend to avoid that. ... Finally, as others have already noted, you have an off-by-one error in your for() loop. To say again what other people have said: when you do myArray[10], you are making an array with ten slots. But the slots are numbered starting with zero. So the ten slots are myArray[0] to myArray[9]. There is no myArray[10]. So your for() loop *should not* try to use myArray[10]. It should do its thing on myArray[9], and then stop. The for() loop is `for(i = 0; i &lt;= 10; i++)`. The for() loop will exit when that middle condition becomes false. The for() loop checks that middle condition *before* it executes the body of the loop. So let's consider the boundary cases here. Let's say the for() loop is about to start working on people[9]. So i = 9. Check the middle condition: 9 &lt;= 10 ? Yup, true. So the for() loop runs when i = 9. Now suppose i = 10. Check the middle condition: 10 &lt;= 10? Yup, true! So the for() loop will do its thing on people[10]. That's bad, because there is no people[10]! It should have stopped with people[9]. The easy way to fix this is to use &lt; instead of &lt;=. In other words the middle condition is `i &lt; 10`. Consider what happens when i = 9. Is 9 &lt; 10? True! So the for() loop runs for people[9]. What about when i = 10? Is 10 &lt; 10 ? Nope! So the for() loop does not run for i = 10. So you change the for() loop's first line to be: for(i = 0; i &lt; 10; i++) 
The problem with TCPL is that it hasn't been updated since the 80's. The language has gone through a couple of revisions since then. It's not a bad foundation for the basics, but it's not authoritative any more, the way it was in its first edition long before standardization. 
You can get a PDF of that book on the internet. It's a book for people who already know how to program; it's not too chatty and offers a great and correct description of the C language. Don't expect “The C Programming Language” too spoonfeed you; if you don't know what a pointer is, this book might not be for you.
Well, the stuff added in the revisions isn't substantial; these extensions shouldn't really matter for a beginner and you can have a look at them later on anyway.
Booleans, designated initializers and compound literals are all really useful things to pick up from the beginning.
Using int for bools has problems. 
There's a few things wrong with how you're doing this. The most important of which is reading the whole thing one character at a time. Don't do that. Use `fgets()` like I suggested earlier, or use `%s` with `fscanf()` (though this one is easier to get wrong). Here's some code that should get you back on track: char dna[MAX_ROWS][LENGTH] for ( i = 0; i &lt; length; i++ ) fgets(dna[i], LENGTH, input); Here, `length` is whatever that number is you read in earlier. One quirk of `fgets` is that the newline character ('\n') is stored in the string. You might want to remove that: dna[i][strcspn(dna[i], "\n")] = '\0'; (Don't worry about how this works, it's magic. You'll need to `#include &lt;string.h&gt;` to use `strcspn()`.)
I am actually somewhat curious myself. But I can assume it varies based on compiler and operating system.
Well I know what a pointer *is*, I know about referencing and dereferencing with \* and &amp;, I'm just having a fair amount of trouble using them correctly in my programs when dealing with arrays
Arrays in C are quirky. That's a bit unfortunate.
A better way to remove the newline: buffer[strcspn(buffer, "\n")] = '\0'; You're freeing the wrong thing here: free(ptr_newline); In `main()` you allocate a buffer for the input, and then immediately overwrite that with what the input function returns, resulting in a memory leak. I personally don't like that your reversing function allocates a new buffer. I'd rather do an in-place reverse, and let the caller duplicate the string if that's what they really want. This makes the function useful in more situations. For that matter, your input function could take a buffer as a parameter. This buffer could be allocated on the heap or stack, whatever the calling function wants. In general, having a function return allocated memory is sometimes frowned upon, since it requires the caller to free the memory, and that's not always obvious in large programs, resulting in memory leaks down the line.
Just a quick glance. There's no reason to cast the return of malloc. The `free(ptr_newline)` statement is a bug. Either `ptr_newline` is `NULL`, in which case it doesn't do anything, or it points at some part of `ptr_input_string` where a new line was; freeing this memory is undefined behavior since it was not an address returned by `malloc` (unless the first character was `\n` I suppose). (edit: oh, you return in the if statement. So that's just `free(NULL)` which does nothing ever) `*(ptr_reversed + i)` is clumsy; there is notation specifically for this, it is `ptr_reversed[i]`. Allocating memory in functions that isn't freed is dangerous in general, and should be done only when it's necessary to do so. In this case, for instance, allowing the function to receive a buffer to write to instead of making it's own space is often the less confusing route. You are leaking memory as well. In main, you are pointing `input` at some space, and then you reassign it in the condition in the first if statement. 
Abstractly, why's it not the same though? Isn't the linker just inserting those dlopen/dlsym calls on your behalf; what is "the loader" and how is it different from dlopen/dlsym, does it use anything lower level?
When you use dlopen() and dlsym(), the functions are not added to the symbol table of your binary. When you link against a shared library, those functions and names are in your symbol table / jump table. Caling foo() will work for shared libraries, but will not work if you use dlopen() and then try calling foo(). You can have multiple libraries dlopen()'d that use the same function names, but you can't link against multiple shared libraries with the same function names. You'll get an error that the symbol is defined twice. Play with the objdump, nm, and ldd tools on linux to get an idea of what's going on. Use objdump -t , you'll see what symbols are defined and undefined. 
I think OP is trying to figure out memory management, not just string reversal. That being said, another safe alternative would be to declare a static char array of BUFSIZE. BUFSIZE should be known at compile time. Also, why is strlen being cast? You don't ever use the signed side of the int. 
&gt; Is it essentially inserting dlopen/dlsym calls at the start of the program? If not, why not? When you use `dlopen` with `RTLD_NOW` and `RTLD_GLOBAL`, the result works actually pretty same as dynamic linking. However, linking creates a list of symbols that needs to be resolved before the program can execute. If any is missing, it won't run and `execve` will fail with `ENOENT`. Linker also does not resolve only function calls but other objects as well, eg. RTTI for C++. With `dlopen`, RTTI may not work correctly unless you use `RTLD_GLOBAL`. When you use `dlopen` and `dlsym` abd find that the symbol is not available, the program is already running so `execve` has succeeded. &gt; Does build time linking provide optimizations over dlopen/dlsym? Yes, all the symbols are loaded when the program starts and they are faster to use. Also, the linker does not need to care about thread-safety and concurrecy because there are no threads running so it can load the libraries much faster. In Unixes, the symbols are stored in a table which is easily cached by the CPU. The table can even be precomputed but that is not much used anymore for security reasons. In Windows, the linker actually changes the code so that it does not have any indirection. &gt; Does build time linking simply give extra type checking? No. For C, there is no type checking during linking. For C++, you need to use mangled names in `dlsym` and the type checking is therefore the same.
Thanks! This is exactly what I needed. Why is `strcspn` better? I see what you're saying about the `main()` function. I'm still thinking in terms of a higher-level language, so I'm not yet used to thinking about memory this way. As far as I can understand, I can initialize `input` to `NULL` and then set it to the heap memory that the input function returns. However, from what I understand, you're recommending I pass a pointer (either on the heap or on the stack, whatever the caller prefers) to both functions from the caller (`main`) and populate *that* memory. Did I understand you correctly? Thanks again!
I was comparing `string_len` to `i` - both of which are `int`s - in the `for` loop in `reverse_string`. Are you saying I should make `i` a `size_t` as well and just use `size_t` everywhere?
Thank you. All of those points are because I didn't really understand heap vs. stack too well. I'm actually going to rewrite it as you said (i.e. function receives a buffer to write to) which should clear most of that up. Thanks!
It's only better because it's cleaner to use. No temporary variables, for example, which is a direct cause of one bug. Everything you said looks right. Though to be clear, here's a bit of code: void get_input_string(char* string, size_t length); void reverse_string(char* string); int main() { char input[BUFSIZE]; get_input_string(input, sizeof(BUFSIZE)); reverse_string(input); } Or, allocating from the heap and making a copy: int main() { char *input = malloc(BUFSIZE); get_input_string(input, BUFSIZE); char *reversed = strdup(input); reverse_string(reversed); free(reversed); free(input); } And of course, you can mix and match however you want. (Note: `strdup` allocates memory that you need to free, just like your functions do. Even the standard library does this every now and then, and you have to refer to the documentation to know.)
It is `mmap`ped with `dlopen` as well
It'd be interesting to try to reverse the string in place now. 
Your code is very long. Could you put it in a paste bin please? Also, if you want to post code, put four spaces in front of every line of code so it comes out in a mono space font.
You don't have a return statement if none of the month strings match your input.
Noted and done. My apologies.
You're missing some basic stuff here. Threads share the heap, but not the stack. If each thread is allocating it's own array, or the array is local to the each thread's stack, then they won't. If this is a globally shared array between the threads, then you need to look at [synchronization](https://computing.llnl.gov/tutorials/pthreads/#Mutexes) between threads.
Noted. Added that in so I"m seeing that "Nov" is being returned as if it doesn't match any of the stated criteria.
Thank you for your cooperation.
You should implement a toy Unix filesystem. You'll learn a lot and have to make use of all those things... You could use a single flat file as your disk, and implement stuff like cat, ls, etc on top of it. This is a project you can make as complicated or as simple as you like. Plus I think it makes great example code.
Writing a brainfuck interpreter helped me a lot to understand what a pointer is and how they work.
http://floating-point-gui.de/
The difference between char * strcat(char *restrict s1, const char *restrict s2); and char * (strcat) (char *restrict s1, const char *restrict s2); is later is the function pointer, which takes two arguments and returns a char pointer. 
Well, size_t is not guaranteed to be a vanilla int, aka a signed int. I mean, it matters entirely on your environment, as size_t is only guaranteed to be unsigned 16-bit. But I have a hunch you would have problems if I tried to reverse a significantly large string. Try: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;limits.h&gt; int main(){ size_t max_size = (size_t)-1; printf("%u\n%u\n",max_size, INT_MAX); return 0; }
Hm. Not sure what you're getting at. I'm getting -1 for `max_size` and a rather large number for `INT_MAX` which I assume is the upper limit for `int` values. Also format specifier for `size_t` seems to be either `%zi` or `%zu`...
You changed something if you're getting a -1, as %u formats as unsigned. It would not print a negative number.
No, there is no difference between those two.
Might be you're talking about something else, but I was aware of the difference between signed and unsigned values. This is not my first encounter with C (first time around didn't go too well, but I did learn the difference between signed and unsigned). As far as I know (and in broad strokes), unsigned values cannot be assigned to negative values and therefore there is a larger range of positive values possible. And by all means, keep tearing it apart. And yes, I've found the header files.
Yes, that is what I meant. However, looking more closely at the C specification, I see that the `strchr` function is supposed to cast its second argument to `char`, so actually that first cast is necessary in order to be strictly compliant with the standard. In that case, there should also be a corresponding cast in the `return` statement; the condition of the `?:` operator should be `*s == (char)c`.
But, according to this page there is not! http://en.wikibooks.org/wiki/C_Programming/Strings#The_strchr_function
That implementation does not conform to the C&amp;nbsp;standard.
Like what? Readability? Issues using your code on various systems due to differing integer sizes? 
Lack of implicit conversion to bool is the main thing. For example: bool flag_test(uint64_t flags) { return flags &amp; SOME_FLAG; } is perfectly fine with true boolean, however with `int` then it will cause implementation-defined behaviour (probably returning `0`) if `SOME_FLAG &gt; INT_MAX` . Of course you can be aware of this issue and work around it, but it's worse than actually having a true boolean. 
&gt; Why is this? `(char)c` is necessary in both cases, it's a bug that it is not present in the second case in this code. From the definition of `strchr` in the C standard (ISO/IEC 9899:2011) section 7.24.5.2/2: &gt;The strchr function locates the first occurrence of c (**converted to a char**) in the string pointed to by s. The terminating null character is considered to be part of the string. The reason behind this is to support `strchr` being called with both `char` values, and with values returned by `getchar`. The `char` type may have negative values. Typically it has range `0` to `255` or `-128` to `127`. The former is more common on ARM and the latter more common on x86 / x64. However the `getchar()` function returns a non-negative value when it reads a successful character, even on systems with signed `char`. This is so that the `EOF` value is out-of-band. To use a specific example, we might have: int ch = getchar(); char *ptr = strchr(str, ch); Using the old ANSI code page; if the person types `é` then `ch` has value `130`. However if `str` contains the same character, and we are on a system with signed `char`, then the value of `*s` for that character will be `-126`. Then the test `*s == c` fails because `-126 == 130` is false. The cast is necessary to bring both operands into the range of `char`. **Technical notes:** 1. Casting out-of-range values to `char` is implementation-defined but we assume the implementation will define the obvious conversion else the system will be unworkable; 2. Systems exist that do not have 8-bit `char` but I am ignoring them for the purposes of this post. &gt; Also why do we need to cast s to a char at all (char *) s. Isn't salready a char pointer? No, it's a const char pointer. The `const` makes a difference. It is not permitted to implicitly convert pointers to const, to pointers to non-const as that would defeat the purpose of `const`. Example: const char *ptr = "foo"; char *p2 = ptr; p2[0] = 'x'; // oops In fact the second line of that snippet must cause an error, the `const` exists in the type system to guard against this. The function returns non-const `char *` because the same function is used to search in both `const` strings and non-const strings, and it is less annoying for the person using the function if it returns `char *`.
If you're just dealing with money, you can use cents as your unit and printf them as dollars.
It's to avoid a bunch of calls to `malloc` and `free`, presumably on a system where these calls are relatively expensive. Rather than freeing nodes when they are no longer needed, they are inserted into `freelist`. Then those nodes can be reused later, avoiding a call to `malloc`.
Here are some things you should take a closer look at: * *strcmp(&amp;statement[i],"=")* - Strcmp compares two strings. Would it think that "=" and "=" are equal? What about "= 0;" and "="? How would you compare two chars instead of two strings? Would strncmp be helpful here? * *strcmp(var_library[x],&amp;statement[i])* - What are the possible values of x in this for loop, and does it make sense to use it as an index for var_library? Don't be afraid to experiment with small functions that do a single thing at a time. Take your time to get familiar with loops, arrays and strings, then you'll be able to get them to do exactly what you want.
Everyone has explained why you're getting the behavior you're getting; in general, when you're working with currency (or anything else that generally uses fixed precision) there is no need to deal with floating-point math and the subtle errors that result. In this case, simply do all your math and store all your intermediate values as cents, and divide by 100 to output in dollars. You'll still have to touch floating point once or twice, for input and output (that or else hack around it with messy format strings), but you won't be propagating and amplifying the error throughout your calculations.
What does the term “dynamic array” mean for you?
^^ Currently doing that for one of my final projects it's pretty cool 
" *p++ means take the value pointed at by p, return it, then increment the pointer." cleared up a lot for me thanks.
(*ptr)++, not *ptr++
You will probably like to understand [operator precedence](http://en.cppreference.com/w/c/language/operator_precedence). The `++` operator takes precedence before the unary `*` operator. &gt;But, when you call *a++ on a char pointer, it seems to increment the pointer address by sizeof(char), to get to the next character in the array. So it doesn't increment the value of the character, it increments the memory address, which is kind of confusing. So is this understanding correct, and is this considered parametric polymorphism? Your understanding is correct, but `*a++` where a is of type `char *` will increment a by `sizeof(char*)` not `sizeof(char)`. To increment the value of the character and not the memory address, write it this way: `(*a)++` This isn't parametric polymorphism. C is not an object orientated language. C++ however, has templates.
whats the difference between ```sizeof(char)``` and ```sizeof(char*)```?
You're still incrementing the pointer, not the pointed-to value. As others have said, the post-increment operator has higher precedence than the dereference operator (unary `*`). [Print out this table and tape it somewhere near your computer](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence).
This subreddit is for C programming, not C++, so it would be inappropriate here. Post your question to /r/learnprogramming, and don't ask to ask, just ask. 
Ok, I remember what I wanted to do you said " *p++ means take the value pointed at by p, return it, then increment the pointer." so I thought ```*p++``` should return the value of ```*p + 1```, and leave the value of ```*p``` unchanged. I see now that ```*p++``` increments the pointer by ```sizeof(int)``` and just returns the int value at that address.
`sizeof(char)` yields the size of a `char`, which defined to be 1 since sizes in C are always in units of `char`. Specifically, on i386 or x86-64, `char` and "byte" are synonymous. `sizeof(char*)` yields the size of a pointer to a `char`, which can vary depending on the platform. Typically, on x86-64 it's 8 bytes and on i386 it's 4 bytes. *On these platforms*, this is in fact true for any pointer.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Free list**](https://en.wikipedia.org/wiki/Free%20list): [](#sfw) --- &gt; &gt;A __free list__ is a data structure used in a scheme for [dynamic memory allocation](https://en.wikipedia.org/wiki/Dynamic_memory_allocation). It operates by connecting unallocated regions of memory together in a [linked list](https://en.wikipedia.org/wiki/Linked_list), using the first word of each unallocated region as a pointer to the next. It is most suitable for allocating from a [memory pool](https://en.wikipedia.org/wiki/Memory_pool), where all objects have the same size. &gt;Free lists make the allocation and deallocation operations very simple. To free a region, one would just link it to the free list. To allocate a region, one would simply remove a single region from the end of the free list and use it. If the regions are variable-sized, one may have to search for a region of large enough size, which can be expensive. &gt;Free lists have the disadvantage, inherited from linked lists, of poor [locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference) and so poor [data cache](https://en.wikipedia.org/wiki/Data_cache) utilization, and they do not automatically consolidate adjacent regions to fulfill allocation requests for large regions, unlike the [buddy allocation system](https://en.wikipedia.org/wiki/Buddy_memory_allocation). Nevertheless, they're still useful in a variety of simple applications where a full-blown memory allocator is unnecessary or requires too much overhead. &gt; --- ^Interesting: [^Free ^List ^\(Liechtenstein)](https://en.wikipedia.org/wiki/Free_List_\(Liechtenstein\)) ^| [^List ^of ^political ^parties ^in ^Liechtenstein](https://en.wikipedia.org/wiki/List_of_political_parties_in_Liechtenstein) ^| [^Liechtenstein ^general ^election, ^February ^1993](https://en.wikipedia.org/wiki/Liechtenstein_general_election,_February_1993) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqh4vie) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqh4vie)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thank you soooo much! Ive posted on like 8 other forums before this and nobody noticed that! This isn't the first time that exact mistake has caused my lots of trouble either...I'll be sure to remember that from now on.
The asterisks are pointers (which you will learn about as you get more into C), but think of them as meaning "array" for now. In C, strings are not a special type of object, but merely arrays of characters. So, a char** is an array of arrays of characters, or an array of strings. ^([May I ask if you have experience programming in different languages? I'm kinda skipping over stuff on the assumption you do. If not, please let me know.])
FILE* is a pointer, but I don't think it has that "array" meaning, but more like the traditional "address" meaning (an "address to a file"). But when you learn more about pointers, you'll find that they're really the same. Some people write the asterisk next to the variable name as you describe. There is no difference other than style.
I'm not quite sure... I suspect there's a historical reason for it, because there's no good way to directly use a `FILE` object, only `FILE*`.
Learn C from a book, it will be much better than trial and error. The latter is a bad way to learn C as you do not know if you are doing it right, or seeing undefined behaviour that happens to appear to work right.
Use DDD and valgrind 
I copied your code into a file called seg.c and compiled as follows: gcc -g seg.c -o seg then start as follows: gdb seg set args 3 10 + run I get the following output: Program received signal SIGSEGV, Segmentation fault. 0x0000000000400780 in create_tree (index=0x7fffffffe480, argv=0x7fffffffe580) at seg.c:63 63 if(is_oper(argv[*index][0])){ So check line 63
I think it's just confusion. So if I run as `./a.out 2 3 +`, then argv[0] == "./a.out" argv[1] == "2" argv[2] == "3" argv[3] == "+" c is initially set to 4, because of these 4 inputs. then you subtract 1 from c in the else branch, so c is 3. Then you give a pointer to *argv + 1 to create_tree. And then you access `argv[*index][0]`. argv is {"2", "3", "+"} and `index` is 3. Since arrays are 0 indexed, you are reading behind the array and segfaulting. I think you had in mind that c is initially set to the last array index. That would be argc (the number of elements in the array) - 1.
Would you prefer English or Spanish? Please, ask your doubts. I will only point side topics in this comment. Also I know this is probably homework so I won't be giving you a complete solution. But I'll try to help you. Here are things. They are asking you for a *function*. What you are doing looks more like a *program*. While your approach isn't technically wrong, I'd think if I can adjust that issue. Here are some tips to improve your coding. 1. You're defining variables on a higher scope than the needed. 2. When using an if clause on two exclusive cases, try using if-else clause. 3. Try using the += operator. 4. Use {} on the if statements or do all the statement in the same line. This is an old debate, some people will argue this, but is easier this way. 5. If possible, define return value and arguments of the main function. About why your program is not showing the right answer I found at least two mistakes (didn't try the program nor the corrected one). One error is in the function promedio and the other could be said it is in the for loop, but is a more general logical error. Edit: promedio is not even called. You have the same error on your main function. And what does promedio return?
At the time you are going to calculate the average you already need to know how many even and odd numbers had been input. How can you achieve that?
Arrays and addresses
Well first you need to use `srand(time(NULL))` at the start of the program. This will "seed" the random generator with the current time. The seed is a number that the random number generator uses to make the numbers random which will solve your first problem. As for making sure the number is less than 1000, you can use the following: int choice = rand() % 1000; This will ensure the number is less than 1000.
The issue here is that rand() uses a PRNG (Pseudo-Random Number Generator) that needs to be seeded before it will begin returning integers. &gt;If no seed value is provided, the rand() function is automatically seeded with a value of 1. So basically, your program starts the rand() PRNG at the same point every time you run the program with the results being the exact same. To alter the seed, you need to call srand() with a seed before calling rand. If you're trying to get quick results, a popular method is to seed it with the current time. For example: #include &lt;time.h&gt; ... srand((int)time(NULL)); ... rand();
I changed c = c -2 and c = c - 1 to c = c -3 and c = c - 2. I don't get a seg fault at that point anymore, but now I think my problem is I'm not creating the tree properly, because when I try to test it out and print it its only giving me one value.
Some hoops to jump through if you want to use rand() for random numbers: http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx
When someone enters an odd number you can do odd_count++; Same for an even number, or alternatively int even_count = a - odd_count; Then you use this values when calculating the average. prompar = sumpar / even_count; Still here you will be doing integer division which will only work if sumpar is a multiple of even_count, which will not necessarily hold. Edit: extra suggestion. Use semiopen intervals always. This means when counting replace things like for (int i = 1; i &lt;= a; i++) by thing like for (int i = 0; i &lt; a; i++) The benefits of this are seen in more complex examples you'll definitely find in a near future. Edit2: btw, you are using if (i % 2 == 0) can you spot the error there?
I have this http://i.imgur.com/57TpskU.jpg But I get "1.#R" everytime I run it. Can't find the mistake in my code 
Hola. Ya que nadie más participa voy a continuar en español. Tratando de corregir errores eliminaste cosas correctas. Desconozco para qué necesitás resolver este problema, pero no nos estamos acercando a una solución. Lo primero que te recomiendo es usar servicios como pastebin.com para compartir código. En lugar de usar un screenshot y subir la imagen. Te resultará más rápido y me facilitarías las cosas. Voy a resaltar los problemas que veo en el código uno por uno y comentar por qué es un problema. Espero que eso te ayude a dar con una solución. Estás inicializando *sumaimpar*, pero no *sumapar*. Donde usás scanf("%d", &amp;num); if (i % 2 == 0) par++; if (i % 2 == 1) impar++; Tenés los siguientes problemas: 1. Dejaste de sumar los valores de *num*, cosas que necesitás hacer y al principio hacías. 2. A vos te interesa si *num* es par o impar, no si *i* es par o impar. 3. *par* e *impar* no están inicializadas. Corregidos estos errores, al final del *for* uno debería tener las siguientes condiciones cumplidas: 1. *sumapar* debería tener la suma de todos los números pares y *sumaimpar* la de los impares. 2. *par* debería tener la cantidad de números pares que se sumaron e *impar* la de números impares. Luego, la función promedio necesita al menos dos parámetros. 1. El valor a promediar 2. Sobre cuántos valores a promediar. Actualmente la función es float promedio(float b) { float x; x = b/i; } Esto tiene varios problemas. 1. La función no devuelve ningún valor. Debería devolver el promedio. Para ello se necesita usar un *return*. 2. *i* vale exactamente *a+1* al momento en que se llama la función, un valor que no nos interesa. 3. Al llamarla le pasás como parámetro la cantidad de pares o impares y nunca su suma (que, como mencioné, se dejó de calcular). Intenta ajustar tu código para usar la siguiente función promedio float promedio(float suma, float cantidad) { return suma / cantidad; } Olvidate de los valores *a - par* y *a - impar*. Una vez tengamos correcto el código te explico a qué me refería con ello. Saludos.
if peakAccel is an int then peakAccel/1000 is integer division. try: peakAccel / 1000.0
That makes sense. I have done that, however I am still not getting any output to the console from %f - I have even created: double xxx = 9.99; That doesn't print anything to the console either.
post the full code
Keep in mind that seeding with time only gives you one new seed every second, so if he's running this program a bunch of times very quickly he will also experience non-random behaviour
Another good way to get random bits is to read from /dev/random or /dev/urandom. FILE * rnd = fopen("/dev/urandom", "r"); int i = 0; fread(&amp;i, sizeof(i), 1, rnd); That can be useful for reading _lots and lots_ of random data. I use it some times but more often on arrays than on single ints. Obviously it only works if you have random or urandom so it is only portable on unix like systems.
So what's the question?
True. However that's normally standard practice for seeding rand() as far as I know.
"Will you do my homework for me?"
How do I parse a .dat file in c?
http://www.manpagez.com/man/3/fread/
Int/int= Int. Rounds to nearest whole number (float*) PeakAccel/1000= 0.005. Cast a float to peakAccell or make peakAccel a double or float.
&gt; What Every Programmer Should Know About Floating-Point Arithmetic &gt; or &gt; Why don’t my numbers add up?
I back. I wasn't able to test it out on my laptop (which was where I made the post) as there is something weird with it where I can't use certain time functions, and most responses had something to do with time. Saying that, it seems to work fine now on my desktop, and is giving me different values each run through.
&gt; I can't use certain time functions o_O
What's the reasoning behind the cast to int? I've been using it just fine without it.
I just need help getting started on it
Maybe I should say arrays and *pointers* are "roughly" the same. I think that's a bit more accurate.
Y además esta función debe tener un sólo parámetro, el numero de ciclos.
I would dare to say that it would work 99.999% of the time without the cast, but as a habit, I almost always do strict casting when the types are not guaranteed. By this, I mean that the type time_t is not explicitly guaranteed to be an integer, though I have yet to see it not defined as such on any *Nix system. Either way, going by the man page on sys/types.h: &gt; time_t and clock_t shall be integer or real-floating types. [sys/types.h](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/types.h.html)
Esto lo señalé en mi post inicial. No sabía ni cuándo debías entregarlo ni nada. Vos estás corriendo todo en *main*, pero la idea es que todo el código que tienes en *main* actualmente se encuentre en una función. Te cito a vos mismo &gt;the function will calculate and print in screen the average of all odd numbers and the average of even numbers. the function will not return and will receive as parameter the number of loops the user has to input y acá sugerí que revisaras el hecho &gt;Here are things. They are asking you for a function. What you are doing looks more like a program. While your approach isn't technically wrong, I'd think if I can adjust that issue. :) Pero primero que funcione y haga lo que deba. Luego que cumpla todos los requisitos. Edit: sí, sería usar void. Me olvidé de esa pregunta.
Posting your homework verbatim and asking for help is not going to get you much of a response. Put some effort in first, then if you run into a problem you can ask for help. If you have absolutely no idea - start by looking up how to declare a struct.
Why would it print out 24? Just because a bit of memory has a value (23) doesn't mean the next bit of memory has (24), when you increment your pointer from your int, you're moving the pointer to the next 4 bytes of memory which could be ANYTHING. The reason it works for the char one is because the next bit of memory IS a char because your string is stored in contiguous memory and are almost always ended by '\0' (null terminator) so you can do stuff like: while (*newch != '\0') { dostuff(); newch++; } And it will run until the memory *newch is pointing to == (0). Now if you had, "int a[2] = { 23, 24 };" it would then point to the next address from a[0] which would be a[1] and == (24) :P
This is definitely a homework question, so I'm not going to give you any code. I will however try to point you in the right direction. I'm guessing he gave you a file-format layout kinda like this: 20-bytes - Name (null-terminated char array) 4-byte - Timestamp (Integer) The idea is then to create a struct that can hold this data - Note that in this case, the order of the entries is important: struct entry { char name[20]; /* Array of 20 characters to hold the 'Name' entry */ int timestamp; /* 4-byte integer to hold the timestamp */ }; Once you have the structure created to match your binary data, you're going to want to look into the 'stdio.h' library header. I would google it, there is good information. You're going to be using the `FILE` interface to read a file. As noted, `feof` and `fread` are your friends here. Here are a few prototypes of interest: /* Lets you open a file specified by the string 'path', and opens * it using the mode settings from 'mode'. 'mode settings' are things * like 'read-only', 'write-only', 'read-write', and a few others. * * The returned pointer refers to the open file, and can be passed to the other 'f' functions. */ FILE *fopen(const char *path, const char *mode); /* Closes a file referred to by the FILE *. The FILE * is the same one you got from fopen() */ int fclose(FILE *); /* This prototype is confusing but useful. * The basic idea is that fread reads from the file given by the FILE * 'file' * 'ptr' is just a pointer to some memory to store the data read from the file. * This can point to *any* type of data. * * 'member_size' and 'member_count' refer to the size of each member, and the number of * members referred to by 'ptr'. So, for example, if you wanted to read 20 'int's, then you * could give the 'member_size' as the size of a single 'int' variable, and then 'member_count' * as 20, the number of ints. Since you're only reading one entry, your 'member_count' can * just be 1. */ size_t fread(void *ptr, size_t member_size, size_t member_count, FILE *file); /* Returns whether or not you have hit the end of the file when you attempted a read. */ int feof(FILE *); So for example, if I wanted to read a single 'int' from above from the file 'file', then I could do this: FILE *file; int data; /* file = fopen("File", "r") */ /* Open the file here */ /* Read a single member, with a member size of 'sizeof(data)' */ /* Read it into 'data' by passing the address of the 'data' variable */ fread(&amp;data, sizeof(data), 1, file); That's the basic idea of what you want to do. Obviously, since you're reading multiple entries one at at time you'll need to use a loop. `feof` can be used to figure out when you can be done with the loop and done reading the file.
You've got "1000.0" and he's got "1000". Those are different types. 
When you say you get an error when you "try do do time_t", do you mean you get a compile-time error when you declare storage of type `time_t`? Or when you reference it? Or is it a runtime error? Suggestion: Post the smallest possible program you can that gives you such an error, along with the console output of the compile. A kind soul might help...
&gt; Think about, there is truly no way to get a real random number. Why not the eigenvalue of a quantum system? 
 struct Word_setup *phrase; phrase = (struct Word_setup *) malloc(SIZE); i wonder why not just phrase = malloc(SIZE); in the second line ?
Pointers are tricky, you gotta pay attention to order of operations and all kinds of stuff, if you can master them (I still have issues with em after 15 years of "learning C/C++"), you're basically set. :P They're the magic that makes C work.
At the end of your code you say: &gt;I finished my whole program, with 0 compilation errors, yet for some reason it doesn't seem to accomplish my goal. But earlier on in the program you say: &gt;//****************THIS IS WHERE THE ERROR OCCURS***************************************************** &gt; //For some reason the compiler thinks that this syntax is incorrect. So, which is it? 
Just tried compiling it with Clang (Apple LLVM version 6.1.0). No problem compiling (no warnings, nothing). I also did not have any error between the lines you marked. Have you tried running it in GDB/Valgrind ? As a general note you should indent your code, this is really not readable.
I don't, they are very different. For example, pointers typically take up 4 bytes or 8 bytes, whereas arrays can be gigabytes in size. Again, the only thing they have in common is that pointers can point at arrays .
Actually, printf-sleep-printf really is the easiest way, however, the issue is that printf to stdout in Linux is buffered by default. What this means is that nothing will actually print until either a newline is reached or the buffer is flushed (happens by default at the end of your program). There are a few different ways to handle this. The first is that you can flush the buffer whenever you want, such as: printf("%c", ch); fflush(stdout); But, if you plan on doing this for something as long as a story, it would probably much easier to simply turn off the buffer while you're printing using setbuf(): setbuf(stdout, NULL); ... printf("%c", ch); ... So just turn off the buffer towards the beginning of your program and you should be good to go.
try using [fflush](http://stackoverflow.com/questions/1716296/why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-strin)
You're forgetting to flush your output: fflush(stdout) The function in this does what you want. nsleep is better for what you want I think, unless you actually want only second intervals, even if you do you can just use the .tv_sec field though: http://pastebin.ca/2977825
Thanks! I wasn't aware of the actual use of that function
I see... That explain that weird behavior of letting all sleeps run out then printing all at once... Thanks! It was super helpful, always learning new stuff in this subreddit :D
If you're getting "bad stuff", it means fopen failed for whatever reason. In order to see what went wrong, fopen will set the errno so you should know almost exactly what goes wrong. For better error reporting, I would recommed changing your first conditional block to look like this: if (fp == NULL) { printf("bad stuff\n"); perror("Nemesis.txt"); exit(1); } perror() will automatically print the message the system has associated with the errno and should give you a better idea of what's going wrong.
If fopen returns NULL, errno will be set to indicate the error. Try something like this: /* Include these headers */ #include &lt;string.h&gt; #include &lt;errno.h&gt; /* Change bad stuff to this */ if (fp == NULL) { printf(strerror(errno)); exit(-1); } You should see your error.
Here to help. Good luck with your program! :) And if you're looking for suggestions, something else I think might be pretty neat is to print out whole words at a time and have the delay be related to how long the word is. So the longer the word, the longer the delay.
Most likely it can't find the file you're trying to open. See the other replies for how to find that out. As for formatting: put four spaces before each line of code and your asterisks won't disappear.
\ \\\ / // nada =/
Programming, like most crafts, requires regular practicing, self-critique ("is this good? Can I improve it?"), and studying. Practicing gets your train-of-thought flowing, so you can express a solution. Self-critique allows you to consider different known approaches when you are done. This is because it takes experience to express more polished solutions. Finally, you need to keep studying so you can get acquainted to new methods and approaches, develop new mindsets, and improve your self-critique. It should not come as a surprise that this is a never-ending process.
Hola. A la vista parece que funciona perfecto. 2 últimas cosas (podes leer mi primer post para más ideas). 1 - El cálculo del promedio hacerlo al final del loop, no durante el loop. El cambio de código sería algo así for (int i = 1; i &lt;= b; i++) { scanf("%d", &amp;num); if (num % 2 == 0) { par++; sumapar = sumapar + num; } else { imapr++; sumaimpar = sumaimpar = num; } } prompar = (float)(sumapar)/par; promimpar = (float)(sumaimpar)/impar; 2 - El parámetro de promedio no sirve para nada. La idea sería consultar el número de valores necesarios primero y luego llamar a promedio. Algo así puts("Programa que calcula..."); puts("Ingrese la cantidad de números a sumar"); scanf("%d", &amp;a); promedio(a); Y borrar las dos respectivas líneas de la función promedio. Fijate que el valor que promedio recibe por parámetro no lo usa nunca, no está inicializado y lo pisa con uno luego. Es decir, recibir el int por parámetro no le está sirviendo de nada.
Here's a self-seeding rand() function you'll never have to initialize again. Tested, passes modest tests of even distribution (as well as stdlib version on my compiler anyway): //Returns a pseudo-random number 0 through 32767. int rand(void) { static long comprand = 1L; static int init_done = 0; if(!init_done) { comprand = (long)((unsigned int)time(NULL)); init_done = 1; } return(int)(((comprand = comprand * 214013L + 2531011L) &gt;&gt; 16) &amp; 0x7fff); } EDIT: [this site](https://www.random.org/) has some great *free* resources and thoughts on random number generation. "RANDOM.ORG is a true random number service that generates randomness via atmospheric noise." Especially check: "[HTTP API](https://www.random.org/clients/http/) to get true random numbers into your own code"
Fun aside: Depending on your terminal, you might be able to use the escape character `\b` to give the effect of someone backspacing their text.
[Make stuff fall out for free(after you've waded through muck)](http://youtu.be/h6Z7vx9iUB8?t=1h17m33s)
Did you figure it out yet? Are you on Linux, Windows or Mac? From where are you running the C program, and where is the Nemesis.txt file?
I have not yet. I am using Visual Studio 2012 on Windows. they're both in the same Visual Studio project folder.
It's nothing that's going to knock your socks off, but I particularly like GCC's C/C++ operand-omission extension to the ternary operator: If you would ordinarily type an expression like `x = p ? p : 0;`, GCC lets you instead type `x = p ?: 0;`. In a form like this, it's nothing special (though for long/qualified identifiers it sure saves screen space); where it really shines is when the operand in question has side-effects: int *doomsday_ptr (void) { static int ref = 0; return (++ref &lt; 10) ? 0xDEADBEEF : NULL; } int main() { // Oops! We've incremented the counter twice! int *p = doomsday_ptr() ? doomsday_ptr() : 0xFACEB00C; // Boom. GCC to the rescue. int *q = doomsday_ptr() ?: 0xFACEB00C; } A silly contrived example, but it illustrates the convenience of the feature beyond simply shortening expressions.
Are you perhaps failing on these ? strrev(rever); system("pause"); These are platform dependent and will fail on Linux
You should include the error message! Seconding studioidefix suggestion on platform dependent calls: strrev, and system("pause") If you do not have strrev you can define your own. And on another note, you are not handling capitalization. You also are doing more work than you have to with the copying and reversing (can be done in place), and also checking the entire length of string, but none of that is not technically wrong.
That could be done with less memory and fewer steps. One string is plenty and all the reversing and all that is unnecessary. A cleaner algorithm would be to take your string and compare the first character to the last, then the second to the second to last etc. You only need to step through half the string. Watch out for one off errors due to trailing newline characters or length vs array index. The meat would look something like: for (i=0; i&lt;(length/2); i++) { if (myString[i] != myString[length-i-1]) { isPalindrome=0; } }
GCC's statement expressions and `__auto_type` (or `typeof`). E.g. #define max(a,b) \ ({ __auto_type _a = (a); \ __auto_type _b = (b); \ _a &gt; _b ? _a : _b; }) https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/index.html#toc_C-Extensions (binary literals, various builtins (especially the upcoming overflow checks in GCC5), and vector extensions can be very nice as well but are more specific.)
Anonymous struct members are part of c11 now, but it's not exactly the same
To generate an EOF, you need to press Ctrl-D. In addition, to specify precision in printf() you need to use %.0f (and not %f.0). Using a double for this makes little sense, in any case.
A couple of things come to my mind even though I generally dislike extensions because they inhibit portability: * `#pragma ident` puts an identification string into the binary which ends up in the `.comment` section on ELF targets. Very useful to embed a version number or copyright string. This is reasonably portable and can easily be wrapped in `#ifdef` blocks. * All the POSIX stuff is really nice and reasonably portable. * The C99 functions are pretty cool even though they are not supported on Windows. * Look into the BSD functions `strlcpy` and `strtonum`. They are useful and safe.
If you are working in a terminal, then the arrow keys generate an escape sequence. To get this escape sequence, you need to turn off line buffering in the terminal driver *termios.* This is slightly complicated, you might want to look at a library like *curses* to do this stuff for you in a reasonably portable manner.
Just don't try to use that function anywhere else. :)
no, there isn't :)
&gt; So in that sense ++ is polymorphic? I really don't know how to answer that, I'm very much the amateur programmer still after all this time, but if you try it yourself with this: #include &lt;stdio.h&gt; struct myStruct { int i; char c[4]; }; // 8 bytes int main(int argc, char **argv) { char c = 0, *pc = &amp;c; printf("%p\n", pc); pc++; printf("%p\n", pc); int i = 0, *pi = &amp;i; printf("%p\n", pi); pi++; printf("%p\n", pi); struct myStruct s = { 0, 0 }, *ps = &amp;s; printf("%p\n", ps); ps++; printf("%p\n", ps); return 0; } You should see the pointer address increment by the size of the types. (1, 4, 8), I hope that helps? &gt;&gt; 
[yes, there is](http://arxiv.org/pdf/1107.4438v1.pdf) :)
U must try Clion. Very nice IDE for Mac, I use it everyday already from first beta.
If your approach to portability is “I tried with two compilers and both look like they support it,” you have no approach to portability. Go read some standards and platform documentation. Portability in C is the exact opposite of “it compiles on my machine.” As said before, the dollar in identifier names is a common extension but frowned upon as it's not part of the C standard. I don't know Cello really well, but they seem to do some nasty stuff to make C look like an object-oriented language.
because phrase is a pointer of type `struct Word_setup`, and malloc return a pointer of `void` type, and so you must convert it. But I ended up solving my error, thakns though
So, any chance we can see the results of this survey?
This is true for most of the items here, but I see union type-punning all over the place. I don't use it myself, but a LOT of people seem to think it's OK, and I don't know if/when it is. I have definitely memset structs and assumed that padding would remain zero.
A RPN (Reverse Polish Notation) calculator will help you learn how to work with string parsing and such. 
Threads and signals are an annoying combination. How are they behaving differently?
Please do reply to one of OP's comments if you think it is "easily explainable."
I see a few problems here. First, get rid of alphamatch[]. It's needless. Second, think about the two loops. Which is faster - testing each character 26 times, or testing each character once? How might you decrease the execution times? Do you think you need to loop through and test each character against each one in the array? C has some cool features, like 'c' - 'a' is 2. That might help you figure out the problem. 
I do not know what kind of OS the server is running, but most computers in our lab run XUbuntu 14.04. My inefficient code does work on my computer with gcc -Wall -std=c99 but I'm thinking the timeout can't be avoided with my code as-is. 
The first test shoves "The Happy Prince" by Oscar Wilde, of some 18,000 characters, into the program. 
I was thinking about doing just that but was thinking if making another array was the ticket. Now that you've posted I've gotten the will to fight on. Thanks for the reassurance, you've made me the Happy Student! 
I am in progress with crossplatform) Of course I need some help, because I don't have so much experience in portability. I will be grateful for the advice what to start from. Gone search some best-practices docs.
dude, it's not :) for us it is random because its virtually impossible to recreate the same conditions which will generate the same numbers. but if those exact same conditions could be recreated, the numbers would not be random at all. it doesnt matter how "quantum" you go :)
Console rpg game on ncurses like rogue. Also add some online in that game. (dream of oldfag)
Could someone who knows the standard come in and clear this up? Because I thought it was undefined behavior, but I can't actually find any evidence for or against it.
The flow of logic is this... When SIGUSR1 is delivered it sets a global flag "foo" and halts the scheduling of new tasks on all threads. Then, if and only if SIGUSR2 is delivered while "foo" is set, then it queries some stuff on each thread. Then, if and only if SIGUSR1 is delivered while "foo" is set, foo gets unset and the program continues execution. So in the shell it would look like: 1. kill -10 &lt;pid&gt; (halt) 1. kill -12 &lt;pid&gt; (resume) 1. kill -10 &lt;pid&gt; (continue) The above works exactly as expected. In user code it should look like: 1. kill(getpid(), 10) 1. kill(getpid(), 12) 1. kill(getpid(), 10) What I am seeing from this however is SIGUSR1 gets delivered and set "foo" but sometimes SIGUSR2 gets hit before all threads are halted, and sometimes the resume gets hit immediately after the halt. Clearly a race but I assumed the two kill commands behaved the same. 
Ok, it seemed like a long-shot that all threads would be signaled but it also felt like a possible explanation for the behavioral difference. I will look up some examples on masking signals. Thanks! 
oh shit. I had no idea -_-. Welp. That's that then :P
If you want exceptions, you will need C++.
Ok, thanks. Unfortunately, we're restricted to using C in the assignment. Exceptions aren't vital to what I wanted to do, I just thought they might have been nice.
C doesn't have exceptions, so throwing one at all would be impressive.
A common pattern in C is to set `errno` and return `-1` from a function to indicate there is an error. While `-1` could indicate a valid return value, it's only an error if the return is `-1` and `errno != 0`. http://stackoverflow.com/questions/9856822/should-i-set-errno
In C we use [setjump/longjump](www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html) to implement exception handling.