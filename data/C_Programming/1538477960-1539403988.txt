Best explanation ever!
Positive it is the same code, I just copied it again, still same error. Debugger confirms your findings, code works like it should in there. I am running this code in Code::Blocks, so that must be the problem. I will ask my teacher about it next time I see him then.
You're just confirming my belief that new programmers shouldn't use IDEs that insulate them from working with the compiler directly.
What have you tried?
You can do your own homework.
+1 You should be able to come up with a solution by yourself since this is a really trivial task if you already worked with for loops. Just build a single loop to print the first line with N columns of the output and then think about how you could archive printing the remaining N-1 lines. Hint: a single for loop does something N times and you want to do something N x N times. 
As a developer with about 25 years of c and c++ experience when I see something like that my approach is to go find whoever wrote it and tell them to do it properly. ( it is very rare you ever need anything like that and if you do I'd insist on some typedefs to help understand it)
//Read in N // while flag = 1 // Check if N is not in the range (0 &lt; N &lt; 10) //Print error // Ask the user to re-enter input // else // set flag = 0 // print * 1 2 ... N-1 // print ——— line // for i=1 to N // for j=1 to N // if j = 1 //print i | i // sum = i // else // print sum += sum
&gt; Was this incorrect? No, it's correct, just pointless. If you ever find code like that outside of a textbook, you're probably looking at something written by a “rockstar programmer” who should have been fired years ago but they don't dare because nobody else understands his code. &gt; Seems like the pointers to int wouldn't be right since each [3] would contain 3 pointers to int themselves As I wrote earlier, a pointer to an array is equivalent to a pointer to its first element. So a pointer to an array of pointers to int is equivalent to a pointer to a pointer to int. It helps if you draw a diagram with one box for each pointer or array element and an arrow from each pointer to the object that it points to.
If it's code from our organization, I would check "git blame" and then quietly contact the person who wrote it and politely ask what the absolute fuck they were thinking.
Lol...I thought it was YOUR channel. Ok...thanks!
Actually, there are some rules you have to follow ( the Right-Left rule) and when you understand them it's much easier. Check this one [http://cseweb.ucsd.edu/\~ricko/rt\_lt.rule.html](http://cseweb.ucsd.edu/~ricko/rt_lt.rule.html) we used it in class.
have you tried valgrind, video drivers can be an odd source of memory issues... as a side thought have you tried GLFW3 its rather good!
Seems pretty easy but like the other person said. What have you tried?
Thank you, I will try this when I get back 
It returns a pointer to a structure. Example: BST_Struct *newStruct = new BST_Struct; Return newStruct;
For loops and ASCII values
I did end up trying valgrind but it took a few minutes to get through SDL_Init() with leak-check=full. I find ASAN to have better diagnostics too I looked at glfw but for exploring OpenGL I’m not really using the features of either. SDL runs on mobile, so if I make something it can be ported easier, or at least that’s my logic
I sure wouldn't name a variable the same as a standard function...
You need to open the file in binary mode when both reading and writing. On Windows line-end conversions will take place otherwise. 
I changed the write mode "w" to "wb" and read mode "r" to "rb" and it works now. many thanks jedwardsol! very appreciated!
His training is mostly in Europe these days, though. 
&gt; If you MUST program on windows, I'd use a different language, like C#. It's true that the Win32 API is quirky in C, but *this* recommendation is just beyond the pale. 
&gt; If you need to learn C on Windows, then learn it under Visual Studio, since that's the industry standard. I suppose this is what we get when we use propaganda statements like "is the industry standard". Anything that's actually an industry standard doesn't need a caveat like that. Do you know anyone going around saying that TCP/IP is the industry standard? MSVC/MSVS doesn't support C very well, because Microsoft developed an early enthusiasm for and commitment to C++. Then they got very jealous of Java, and when they couldn't control it, made their own version called C# (quite the marketing name, as is usual at Microsoft). I suggest that people do what Microsoft wants, and simply don't use MSVS for C on Windows.
It's dividing offset by 4 ; right-shift twice is the same as dividing by 2 twice. Then it's using that as an index into the `virtual_address` array, and setting that element to `value`
[removed]
Recent versions of GCC responded with alacrity to Clang's better output, and have really improved GCC from what it used to be. Our C toolchains are better than ever, and Clang/LLVM is largely responsible for it (ASan, diagnostics, etc.), even if you don't use Clang/LLVM. While we'll always have those who prefer trendy new languages, it makes one wonder if C wouldn't even have lost mindshare temporarily if we'd had decent commitment to toolchains during that period, instead of Microsoft going off on a tear for C++ and then C#, GCC starting to write portions of itself in C++, the rise of dynamic interpreted languages, etc. 
okay. That's what I felt like was happening. [Here's the context](https://lauri.xn--vsandi-pxa.com/hdl/zynq/xilinx-dma.html), can you think of any reason it's being done this way in particular? 
The subtle thing about segfault is that it can mean several things, but it usually means you're not initializing memory properly. If you've been using static allocation (as /u/ontomtid suggests) or `auto` allocation on the stack, you most likely won't have a feel for when you need to allocate memory. This is especially true if you've been recently using any language with automatic memory management, which is most of them and especially the scripting and dynamic-typed languages. Coming from anything but assembly usually means not having a feel for manual memory management. Usually the quickest path to learning memory management is wrapping each initialization in a `malloc()`. Coming from a dynamic language, that also tends to cause the programmer to think about types and pointers in the process of allocation. 
`offset` is a byte offset into the address space. But `virtual_address` is an array of `unsigned int` which are 4 bytes long on this hardware. So `virtual_address[0]` is at address 0, `virtual_address[1]` is at address 4, and `virtual_address[2]` is at address 8.
I agree 100%. When I first read OPs post this was the exact way I processed my way through it. I forget who taught that to me since it was back in college. In the K&amp;R book they wrote: &gt;char (\*(\*x\[3\])())\[5\] and then went into a rather complicated looking grammar on how to parse complex declarations. Using what /u/Practical_Cartoonist wrote (and what I learned way back) makes it so much easier to read. I love that C allows you to do this, but I always wonder why I'd ever want to. :)
&gt; I was thinking about creating some form of a desktop application in c, but seems like it would be better to just learn c++ if I wanted to do that. I've seen people do that for some very vaguely defined reasons. Mostly because they feel like that's what other people do, and less because it's inherently a good idea. * Something that would couple together your web experience would be a very basic HTTP/1.0 or HTTP/1.1 webserver in C. Most production webservers and proxies are written in C, but it's a task that can be accomplished in any reasonable language. The first HTTP/1.1 webserver was written in Common Lisp. * Libraries are very, very frequently written in C. If you wanted to develop a public API, or had a need for a general-purpose library with good performance, perhaps try that in C. * I think there are few static webpage generators in C. Something that took an established text format, like RST or CommonMark, and made compliant HTML would be nice. Especially for situations where you want few runtime and compile-time dependencies, because most of these solutions require a whole dynamic language runtime stack. Not so suitable to run on a small server device or router or hypervisor host. * C and the WWW are extremely compatible, even though the web has historically leaned toward interpreted languages, etc. [Look at the performance benchmarks here for one reason why.](https://www.techempower.com/benchmarks/) 
You know, advising people to use C for only boring projects is how C gets a reputation as a boring language. Yes, it's a little more complicated to use for certain kinds of tasks, because of the memory management and because you're explicitly in charge. The key is to use that to your advantage instead of your disadvantage. And if the task genuinely doesn't benefit from that, perhaps it should be a shell script anyway.
Okay so....is that function changing bits in virtual_address, or is it doing something else? 
That's why you make a C library and import it to a higher level language project that doesn't require all the boilerplate. You don't need C to handle windows. 
I'm so confused, I do not understand. What does all this look like in memory space? 
That's the convention wisdom, yes. But in many cases, once you're using a few good C libraries for the functions, there isn't all that much boilerplate left. You could have, potentially, 200 lines of Ruby or 300 lines of C, much of the difference being `#define` macros. And the Ruby version would likely require a big Ruby runtime, whereas the C version would not. There would presumably be less of a difference with Go or Swift or C++, but then C++ requires its share of boilerplate as well. I have no problems with calling C from higher-level languages, but I do want to remind everyone that higher-level languages are no silver bullet by any means, and that all problems need analysis. If we all ever tended to write functionally-equivalent programs with different architectures it would be easier to see the strengths and weaknesses of different approaches objectively, without relying on echo chamber wisdom. 
This is called serialization btw.
This is some sort of work queue right? Here's an entirely different way to go about this that's both simple and correct. * Keep track of the number of items in the queue using only a semaphore. When the queue is empty, consumers will block on `sem_wait()`. If they're released from `sem_wait()` then it's guaranteed that there's an item waiting for them. * When there are no more items and it's time to shut down the queue, append N "poison" items (for N consumer threads). When a thread removes a poison item, it exits. * When the queue is full (always bound your work queues), have the producer thread act like a consumer and consume an item to make room. As a work queue, this means you should spawn one fewer producer threads. Alternatively, use a second semaphore to count "empty" slots in the queue so that the producer can block on it. No need for `thread_bit` or `exit` variable. You'll still need a mutex to lock the queue while you manipulate it. 
Just so you know, this is not guaranteed to work, if you are reading the file on another system than you wrote the file. That is because the exact way a struct is represented in memory is not defined in the standard, it's up to the compiler.
I think I have it figured out. Thank you for the help. 
&gt; an inside-out right-to-left rule AKA "the clockwise/spiral rule": http://c-faq.com/decl/spiral.anderson.html
An alternative, rather than a "poison" item, is a nonblocking sem_wait and a nonblocking wait on a condition variable. Preferably with a timeout on the sem_wait for a new item.
somethings in my head are finally making sense, thanks :D
I think it's because they didn't have Python or Perl to bang out some quick code that doesn't need to be maintained.
Yet he never daid he reads it back on a different system . The way I read his post, he's writing and reading the data on one system, using a program compiled with the same compiler. 
Unfortunately I'm not capable of understanding this.
&gt; declaration to match with usage. I don't know what this means. I don't understand any of this: int (*(*f)(int))[10] *f is inside parentheses because () has higher precedence than * but we want * to come first. So usage *f gives you a function type. (*f)(int) gives you a pointer. *(*f)(int) gives you an array. Finally (*(*f)(int))[N] gives you an int. So, the declaration reads: f is a pointer to a function taking an int parameter, returning a pointer to an array of 10 int. 
What page? I notice when people give up on helping you they always say that. Unfortunately I think It's just an IQ thing. 
Not that I blame you for not wanting to help. It must be frustrating to explain something beautifully and someone to just not get it. It's frustrating on my end too. I understand simple examples but then people give me more complicated examples and they just don't make sense. I can't ask in IRC as they tell me I shouldn't even be asking about complicated examples, they say they are random questions but they always stem from conversations like this. I can only conclude it must just be IQ.
Or maybe because it hasn't clicked for you. I used to think complicated C declarations were pure sorcery. But reading K&amp;R helped me understand why the language is designed that way and how the declarations worked too. There's also an exercise in it which prints out declarations in English given C code. When you said you didn't understand "declaration match with usage", I thought you still haven't fully understood the basics. That's why I suggested the k&amp;r which is the best C book IMO. 
I've looked at so many books, tutorials and videos now. I don't think one more is going to make a difference. You either get these things or you don't. C is not what I thought it would be. I did halfway decent with javascript but C. It's just crazy hard for me. I might look at that book but at this point, It will just be one of many others I've looked at and when the tough examples start coming, I don't think I'll be able to get them. At my age, I'm going to have to think about stopping throwing good time after bad. No need to keep feeling bad about it.
Personally, I found tutorials and videos lacking when I first started learning to program. There's simply no substitute to a good book and K&amp;R is _the_ book for C - the first thing I would recommend to any beginner in C. If you are having a hard time understanding pointers and memory for example, I suggest you learn assembly cuz that will help a lot. Programming from the ground up is a really nice asm book. Teaches asm to a complete beginner to programming. 
Wow, didn't know that.
You have to recompile your code every time you change it.
How would I do that? 
How did you do it last time? Did you run a gcc command in the terminal or did you press the build button in xcode? 
I used gcc on the command line. would I need to go through gcc to recompile? 
I don't personally use Xcode, but do have it. I created a C project and in my Xcode there is a menu called "Product" which has several options including "Run", and "Build for...". Also, in the main code window I have a toolbar with a Play button icon, which also appears to let you compile your code: https://imgur.com/a/iWW6BEQ 
Thank you! that worked! i can't believe it was a simple as that
This kind of async programming? [https://nikhilm.github.io/uvbook/introduction.html](https://nikhilm.github.io/uvbook/introduction.html) Or this kind... [http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html](http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html)
Tip: check what a Makefile is, you'll find it useful
To compile: $ gcc -Wall -std=c99 program.c -o programName To run: $ ./programName Is this what you’re looking for?
ill keep that in mind thanks
Boxed question mark sounds like it's printing out undisplayable characters, likely something the terminal thinks is unicode. So you are likely pointing to garbage and printing it. ch2 is what is printing as ? right?
Jog my memory for me... Once `fgetc()` reaches the end of the file, what does the next call to `fgetc()` return? EOF? or does it keep reading memory?
One issue... http://c-faq.com/stdio/getcharc.html
I'm not seeing the question marks, but my guess is that it's the Invalid Replacement Character from Unicode, U+FFFD
yes that is what is printing it &amp;#x200B;
&gt; it only outputs the seperators That is what I'm seeing. So back up and think about what you want to do... 1. you've got an input file that we can pretend is a flat array 2. `fgetc()` advances one step and returns what is at that index 3. You want to check if it's an operator, so you run through all 6 to check if it is any, print if so 4. Then you check if it's a separator, print if so 5. If it is neither, save the character in a buffer to build up a full word 6. Repeat until end of file. 7. Print the word you built up and say if it's a keyword or identifier Right? Now look at what you wrote and see if that is what it's doing. If not, change it. You had the pieces and you tried to cut and paste your way to glory. 
what the heck is Xcode ?
Ok I took a look at it with that perspective and it seems like I can get them all to print out! thanks for that. Now it seems like some are in the wrong order though
I C what you did there
ptr3 is a pointer to an array of 5 ints. So ptr3+1 is a pointer to the *next array* of 5 ints, 
Yes, it is. But I used +1 so I could use the word 'next', instead of working out how to describe +4
Array indexing with `[]` has a higher operator precedence than dereferencing a pointer with `*`, so `*ptr3[4]` is actually equivalent to `**(ptr3 + 4)`. The equivalent of `*(*ptr3 + 4)` using `[]` notation is `(*ptr3)[4]`.
sorry I don't understand
Why does this work: *(*ptr3 + 4)); and this doesn't: *(ptr3 + 4)); All three pointers point to the same location in memory.
ah .. that is why I have never heard of it. got it .. could have google'd it of course but sometimes a trivial question only needs a trivial response 
Haha no worries! Questions are always good anyways. Glad I could help 
You only have 1 array of 5 ints. So *(ptr3 + 4), which you have in the line which "doesn't work" is dereferencing an out of bounds pointer. What were you expecting that line to do?
ptr, ptr2 an ptr3 all point to the same memory location. I expect anything pulled from that memory location to behave the same. I have no clue why it doesn't.
Or, better, read https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html?m=1 
Are you familiar with "Pointer Arithmetic"?
&gt;If you make 'keyword' 'const', the compiler may be better able to optimize the code. How?
Wow that’s actually pretty awesome! Thank you!
&gt;I have never encountered an implementation (outside of academic experiments) that checks or enforces array bounds either at compile time or at run time Visual C++ has security switches ([/GS](https://docs.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=vs-2017), for example) which turn on such checks. The [static code analyzer](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-analysis-for-c-cpp-overview?view=vs-2017) in the product will also diagnose some potential out-of-bounds accesses.
`EOF` is reported on end-of-file, but keep in mind that this doesn't mean that `EOF` is returned perpetually. For example, when the file is extended, new data is available and the next read returns data. `EOF` just means “end of file right here and now.”
`ENOCODE`
Why do you just keep repeating yourself and trying to refute what people are saying? You obviously don't understand what is happening. It doesn't matter that all three pointers are pointing to the same memory location. They have different types. When you do pointer arithmetic on a pointer, 1 == sizeof(*ptr). In other words, adding one skips to the the next element in a theoretical "array." The first two pointers are pointers to ints, so they behave as expected - they "jump" to the fourth int after the first. The third pointer points to an array of 5 ints. That is, it expects a series of 5-element arrays repeated over again next to each other in memory. Moreover, sizeof(*ptr3) == 5 * sizeof(int) now. So when you do ptr3 + 4, you're going to the fourth *array* after the first *array*.
Actually, I haven't used double before, so I\`m trying to do my best with floats. I still have a lot to learn.I\`m going to try isnan(). Thanks a lot! 
Yeah, it\`s a good idea. Thanks!
A double is like a `float` except its more precise.
The declaration char *sweepSpace1(char *sentence); declares `sweepSpace1` as a function taking a pointer to `char` returning a pointer to `char`. Compare this to char sweepSpace1(char *sentence); which declares `sweepSpace1` as a function taking a pointer to `char` returning a `char`. The asterisk before the function name simply indicates that the return value is of pointer type. Generally, the declaration syntax of C looks like this: &gt; *type declarator* where *type* is some primitive type and *declarator* is an expression involving the identifier you want to declare that has the the indicated type. For example, if you declare char *sweepSpace1(char *sentence); that means “if I write `*sweepSpace1(someCharPtr)`, then the resulting value is of type `char`.
Placing the asterisk to the left is not a good idea though as that's not how the C declaration syntax works.
Then your mental model is wrong. For example, consider a type declaration like this: int* (foo[4]); In your mental model, this looks like an array of four pointers to `int`. Actually, it's an a pointer to an array of four `int` as my other comment explained. Placing the asterisk next to the type name is extremely misleading.
Yes, on POSIX systems you can also read "beyond" EOF on the terminal when the tty is in canonical mode: see the description of EOF under [Special Characters](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap11.html#tag_11_01_09) in the POSIX standard.
Means it returns a pointer to char. So, it takes a string (Sentence) and returns a modified? string.
This should help: https://stackoverflow.com/a/1670290
Page 122. &gt; The syntax is an attempt to make the declaration and usage agree.
Xcode does not include GCC. the gcc/g++ executables are just symlinks to Clang.
Excellent explanation (not that my opinion means anything :-p ) Responses like this demonstrate the best of Reddit.
So you never wrote int* p, q; and wondered why `q` has the wrong type?
&gt; When I run this ptr, ptr2 an ptr3 all point to this memory location: &gt; &gt; 0x7ffd6d039580 ptr1, ptr2 and ptr3 do all point at the same address, yes. But print out the value of `ptr+4`, `ptr2+4` and `ptr3+4` ptr3 has a different type to the others, so `ptr3+4` *is not* the same as `ptr+4`
cc: /u/Fedacking
I write the asterisk next to the type. I am aware of that problem and just don’t declare multiple variables in one line.
Same as above. I dont declare multiple pointer variables in the same line
Those aren't multiple pointer variables.
I know. What I am sayibg is I wouldn't write &gt; int \*p,*d
Oh I mean just for function return types. I generally do: int* function() While putting the asterisk next to the function name works, it looks like a variable when I skim through my code. Regarding pointer declarations, I am aware of that and put asterisks next each variable; int *a, *p; This is just more readable to me in my opinion.
If it's short and simple, where readability isn't a priority. 
The syntax is an attempt to make the declaration and use agree. That's what is in my copy. Heh, no wonder my search didn't see it. Thanks for the direct link!
So what's wrong with int d, *p
Hey check this out. Changing it like this prints the new memory address that is always 80 (bits or bytes?) off. Why is that? https://hastebin.com/noyizumozo.pl
Hey check this out. Changing it like this prints the new memory address that is always 80 (bits or bytes?) off. Why is that? https://hastebin.com/noyizumozo.pl
Wait, I think I see why it is 80 off. Each in is 4 bytes. The pointer to the array of 5 ints is 20 bytes long. I'm adding 4 so that's 4 *20 or 80 bytes off. 
The memory addresses are the same but the actual variable names have some kind of information in them making them do different things to the memory locations?
&gt;Using *ptr3 changes the type from "pointer to array of five ints" to "array of five ints." And so when you add 4, you're going to the fourth int after the first. Yeah but then you're putting another * in the mix after (*ptr3 + 4)...the one in the front *(*ptr3 + 4). What's that outside * doing?
Can we suggest different subreddits too? There's /r/C_Homework and /r/learnprogramming 
*(ptr3 + 4) is always 80 bytes off. https://hastebin.com/noyizumozo.pl 
Please sticky this post.
You can use "std::cin&gt;&gt;answer" instead of "scanf("%c",&amp;answer)" and it works
Yes. To be precise, it's `5 * 4 * sizeof(int)` bytes off, which is 80 if an `int` is 4 bytes.
C_homework is dead and learnprogramming is too generic
It's simple [Pointer Arithmatic](https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm). I'm sure this has been explained to you before (I'm sure I saw a similar thread earlier) The answer hasn't changed, you just haven't fully understood how the + operator is working with your pointers. 
&gt; They also contain information that makes operations on them behave differently? Yes. the information is the type int *ptr ; int (*ptr3)[5]; ptr has type `int *`. ptr points at an int. ptr3 has type `int (*)[5]`. ptr3 points at an array of 5 integers. They are different types of pointer.
Like other mentioned, Postman is definitely worth trying out. It makes it incredibly fast to test and speeds up your workflow. If you need any reference on how to use Postman to test API during development, this [post](https://buttercms.com/blog/postman-testing-the-api-development-environment) is a good reference 
scanf is a really awkward way to get terminal input. In well over 20 years of professional coding, the only place I have ever seen it is college coding assignments. Instead, read a line with fgets and then parse it (with sscanf for example).
Put a space after the %d or before the %c so `scanf` eats it. But `scanf("%c")` isn’t used all that often—fgetc or getchar would usually be better alternatives.
Oh cool! So this is the most elegant way to do it with scanf? Funny enough, this is for a college assignment and we aren't allowed to use anything other than printf and scanf, because technically we haven't learned about that yet, and they want us to make do with what we have :p &amp;#x200B; Thank you so much!
Oh thank you so much! It works :D No in the functions themselves I used getchar (The lecturer did tell us about that one) It that made it way easy, because in that way I could have a counter that told how many chars were put in, so it could decide if it needed more space.
I didn't know multi threading is part of async programming, thanks :D actually I was looking for where to learn about implementing async functionality in C (inner workings), but I think your first options answers my question. thanks again \^\_\^
Thank you! It works! Yes, in the function I used getchar (the lecturer told us about that one, so we were allowed to use it). It made it much easier, because in that way I could use a counter that counted how many chars were put in, so the function could decide if it needed more space
It already is.
The exact location is irrelevant as long as the compiler knows the path to include these files. You could always do a `locate`to find the actual location, but I can't see why that would be necessary. 
&gt;The [] syntax is generally preferred when talking about arrays or buffers. There is no buffer type in c right? A buffer is just an array?
Yes, I'm not entirely sure if macOS has it but it feels standard enough for it to be there. Your filesystem should be indexed so that it doesn't take long at all. Try `locate stdio.h`
Mostly yes. I tend to draw a distinction between something like int a[8]; vs. int *a = malloc(sizeof(int[8])); due to the `sizeof`/etc. differences.
Hmm interesting. It does have locate command installed but it just tells me to build a database, which I did and it still doesn’t work :/
The compiler takes your source code, just plain text, and chews it up and parses it, then spits out a file with a bunch of assembly instructions in it. If you change the source code, it doesnt change the file with the assembly in it. You have to make the assembly file again from the new source code.
 i'm sorry. pls translate from russian потому что вы после символа "c" жмете enter - тоже символ. то есть: a == a? \n == a? a == a? \n == a? a == a?
Type echo '#include &lt;stdio.h&gt;' | cc -E - and check what directories it mentions in the output to find out where the files are located.
That is pretty much what I've done save one or two minor points.. typedef int buffer_item; /* queue struct */ typedef struct queue { int front, rear, size; unsigned capacity; buffer_item* array; } buffer_t; /* thread_args struct */ typedef struct thread_args { int id; int maxProd; } thread_args_t; /* the mutex lock */ pthread_mutex_t mutex; /* the semaphores */ sem_t full, empty; // semaphores for full and empty /* the buffer */ buffer_t b; // here is the buffer btw /* the item */ int item; // this is the work, it just iterates /* thread bit */ int thread_bit; // this is the best way I could think of to terminate threads // all threads have access to this, but using `exit` locally // was to protect against access and modif. outside mutex lock // see original post // here are the producer and consumer threads void *producer(void *param); /* the producer thread */ void *consumer(void *param); /* the consumer thread */ ... So what you're suggesting is: mutex_t m; sem_t full, empty; maxProd = 20; item = 4; *producer { &amp;w_empty; &amp;m; item ++; enqueue(); &amp;m; &amp;s_full; } v queue = [ ][4][3][2][1] ^ *consumer { &amp;w_full; &amp;m; dequeue(); &amp;m; &amp;s_empty; } ----------- item = 20; *producer { &amp;w_empty; &amp;m; if(maxProd) enqueue(p); term(); &amp;m; &amp;s_full; } v queue = [ ][p][p][p][20] ^ *consumer { &amp;w_full; &amp;m; if(p) term(); &amp;m; &amp;s_empty; } &amp;#x200B;
Well, not in /r/C_Programming, because that's not C, it's C++.
I don't completely follow your illustration but I think you've got it.
/u/vesche gave a correct answer. But, did you notice the repeating patterns in your code? There were two: 1. Repeated instructions: printf, scanf, score change. 2. Repeated data: the questions and answers all have the same structure (though the detail - the text of the questions and the answers - would presumably be different). If you repeat identical instructions in a program, this is, almost always, better represented as a loop. If you have repeating data in your program, this is almost always better represented as a data structure, often an array. If we transform your program into a loop over an array, we get something like this: #include &lt;stdio.h&gt; int get_user_response() { int response; do { response = getchar(); } while (response == '\n'); return response; } int ask_and_mark_question(int question_number, const char *question_text, char correct_answer, int *done) { int response; printf( " %d.)______________\n%s\n", question_number, question_text); response = get_user_response(); putchar('\n'); if (response == correct_answer) { return 1; } else { return 0; } } struct question_def { char *text; char correct_answer; }; enum { NUM_QUESTIONS = 3 }; struct question_def questions[NUM_QUESTIONS] = { { "a.a b.b c.c d.d", 'a' }, { "a.a b.b c.c d.d", 'a' }, { "a.a b.b c.c d.d", 'a' }, }; int main() { int i; int score=0; for (i = 0; i &lt; NUM_QUESTIONS; ++i) { int done = 0; score += ask_and_mark_question(i+1, questions[i].text, questions[i].correct_answer, &amp;done); if (done) { break; /* user gave up */ } } printf("\nYour Total Score is %d out of %d\n", score, NUM_QUESTIONS); return 0; } 
I posted a sticky: https://www.reddit.com/r/C_Programming/comments/9l0vuz/asking_for_help_what_to_do_when_your_program/ Thanks to all the contributors to this thread who made improvements to the text.
Nope. I think it's a dumb convention that the parsing works how it does, but I've still never made that mistake. Since pointers can be of different size than the thing they're pointing to, the \* should definitely be handled as if part of the type, IMO.
Homework and questions are perfectly on topic.
/r/cpp/
Or use blank lines top and bottom and indent every line between by 4 spaces.
&gt; Also, *(a + b) is strictly equivalent to both a[b] and b[a]. I don't know what you man here.
Product of the times, I guess. I really like Rust's declaration syntax for arrays, it makes declaring them for any type easy. let (mut a: i32, mut b: i32, mut c: i32, mut d: i32) = (1, 3, 5, 10); let a: [&amp;mut i32; 4] = [&amp;mut a, &amp;mut b, &amp;mut c, &amp;mut d]; // array of 4 mutable i32 pointers
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I really don't like it, it is especially annoying to write `mut` all the time for no good reason.
Well, it is for a pretty good reason. It keeps track of which variables you want to allow mutation of, erring on the side of caution so that immutability is the default.
You can always see how numpy does this, but if you want contiguous arrays you'll have to generalize what's explained here: http://c-faq.com/aryptr/dynmuldimary.html
Having everything immutable by default sounds like a nightmarish kind of tight coupling when you want to extend the API to actually allow for the modification of a structure member. It's also kinda pointless in most cases and forbids useful constructs like this: struct foo; foo.x = ...; do_something(); foo.y = ...; foo.z = ...; /* now use foo */ instead, one has to create a bunch of useless variables and initialise the structure in one go, making for unnecessarily verbose and hard to understand code.
Hey thanks! I took a look at how NumPy does it, but I'm not a professional C developer and it was confusing to me. I know they "broadcast" for example 3D arrays into a stack of 2D arrays for calculations. I don't get it how to store it.
If I want to understand for example 3D CArrays as a linear stack of 2D CArrays, I need just to create a "void * relationship" as a vector of address pointing to 2D CArrays? (my english sucks, tell me if I wrote something weird)
It's really not bad at all as long as you're structuring your code properly for the style. If you need to allow modification of a structure member, all you need to do is make the member mutable in the struct declaration.
figure it out? 
The simplest explanation for `ptr3` is that it is the type to which a two-dimensional array decays. So given, e.g.,` int foo[10][5]`, the expression `foo` would decay to a pointer of type `int(*)[5]`. Since `foo[i][j]` is equivalent to `(*(foo+i))[j]`, `foo+2` needs to yield a pointer to the start of the row `i` of `foo`, which means that adding `i` to `foo` needs to scale `i` by the size of each row.
I did! Thanks for the help!
Ops Sorry, you are right! What about fflush(stdin) ?
What's it printing instead?
It prints the value 2 and I need to get one
Read the release notes next time dude. "The Command Line Tools package installs the macOS system headers inside the macOS SDK. Software that compiles with the installed tools will search for headers within the macOS SDK provided by either Xcode at: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk"
Definitely missed that. Thanks for pointing it out!
&lt;&lt; is a bitshift operator.
Shouldn't the line that calculates the voltage be after you get the input from the user? 
at the moment I'm getting error code C4700
This sub is for C, not C++.
I moved it 
You could say it's a cin posting c++ questions in a C thread
Oh thanks. Could you re-phrase your comment as a section of updated text please?
When you say, "You need to get one", is the problem that you keep getting 2 every time you run it? If so, are you entering the same seed every time? If you're using the same seed, then you'll get the same random number sequence on every run.
That depends on what machine you are programming for; on some machines it might be slower, on others it might be faster. The only kind of machine where this code is definitely faster is one without bitwise instructions but a fast multiplier. If the machine has conditional move instructions, the if statement might be faster. 
Your Condition - 1 logic is messed up. bools CAN contain any value between 0 and 255, but they almost always only contain a 1 or 0. X * 0 == 0. 0 * X == 0 also.
What is true though is that NaNs will totally ruin your day with this kind of code.
[@congelar's latest tweet](https://i.imgur.com/Yw9NDHR.jpg) [@congelar on Twitter](https://twitter.com/congelar) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
The only way to be sure is benchmarking, but unless you're doing hundreds of thousands of tests like this in tight loops, the difference would be negligible. One thing you could do is try part of the code in godbolt site and see what the assembly would be. I wouldn't be surprised if the compilers optimized the regular if or even turned your alternative into a regular jump.
Forgot to add, instead of "Missing" , it should be written "Complex" for complex numbers, but I do not know how to make that, while outputting.
This can still get you into trouble: int* function(), foo; (I'll show myself out)
On the terminal, there is no portable way to detect that. You can only detect if `Ctrl` was used with a key because then, the character you get is different. 
Doesn't work or doesn't compile ? Being precise will help you solve your problems.
Because you missed a bunch of semicolons, especially after function declarations. 
I presume you'd encountered numerous compiler errors, from what I can see, your function prototypes and function calls need semi colons after them. 
i forgot the semi colons lol 
thank you
Just a typo but on [msort.c:295](https://github.com/sjmulder/msort/blob/master/msort.c#L295) I think you want: assert(nread == sf-&gt;dstsz); not assert(nread = sf-&gt;dstsz); 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sjmulder/msort/.../**msort.c#L295** (master → c1d3de4)](https://github.com/sjmulder/msort/blob/c1d3de42e8d8701b75a75259adfc7f01596ec8b1/msort.c#L295) ---- 
Ouch! Fixed, but I'm surprised the compiler didn't catch that with all the warning flags.
If you were not using debug mode, then assertions were turned off anyway.
Sorry, can not check it now. I do not have installed MSYS 2 on current PC. Also, I read somewhere (do not remember exactly where) that next official mayor qt release will be 64 bit only. 
For project I did with Lee algorithm. But I have it in C++. I want it in C. Not understanding how should I change to C. Now bit frustrated.
Also you are calling the functions implicitly, which is not allowed in C99. You need to call the function after that it has been declared. 
https://en.m.wikipedia.org/wiki/A*_search_algorithm Very eays with Google
The real question is whether anybody has code for spam filter that blocks this shit.
This is why I'm a fan of the type* style for declarations. It's obvious it's a pointer being made. I don't often do multi declarations of pointers so that side of things is not an issue for me.
On the new reddit there is no **side panel**
What do you mean by this? can you give me an example?
You looks like that you’ve come from a higher level language like python where you can write codes like this: Foo() Foo(): Print(1) See I called the function foo before it was declared. That’s called an implicit declaration. In C, more specifically, C99, implicit declaration is prohibited. Therefore you need to write code like this: Void foo(){ Printf(“1”); } Int main(){ foo(); Return 0; } Note that I defined what foo is before it was called in main. Almost a good practice to put main at the end of the script.
A unary operator is any operator that has only one operand (a single input). [As the Wikipedia article explains](https://en.wikipedia.org/wiki/Unary_operation#C_family_of_languages) there's only a handful of them in C. If you get a unary operator error when compiling your code, it means the compiler understood something you wrote as a unary operation, but it couldn't be completed because either the input or the output (or whatever handles the output) can't make sense of it.
can you please elaborate on the 1 operand part, thats what i dont understand
For example, `-` (“minus”) can be both binary and unary: * binary (accepts two arguments): `1 - 2` -&gt; subtraction * unary (accepts one argument): `-1` -&gt; negation
If your program doesn't work, just go to reddit or irc and ask, someone will tell you that they aren't there to do your homework, or just generally condescend at you, and in the meantime you can figure out your problem!
This is C++ not C. But you could have a similar problem with a C structure v-&gt;push_back(...)
No problem. Let's take the simplest example possible. Let's say you have a variable containing a small number, and you want to print it out. You could do it like this: int x = 5; printf("The number stored in x is %d\.r\n", x); Which would, of course, print out: The number stored in x is 5. If you wanted to print the negative of that number, you could use this: printf("The negative of the number stored in x is %d.\r\n", -x); The minus symbol used in the above example works as a *unary operator*. It applies *only to one input* (the "x" in this case) and gives its output only based on that one input. So this would print out: The negative of the number stored in x is -5. On the other hand, you have what are called binary operators - these require *two* values in order to give you an output. Examples include basic operations like adding, subtracting, multiplying and dividing.
/r/cpp_questions is the place for this You need `v-&gt;push_back(...)` or `(*v).push_back(...)`. The former is usually preferred.
/r/cpp_questions is the place for this You need `v-&gt;push_back(...)` or `(*v).push_back(...)`. The former is preferred.
How about this: * Your example code snippet of the problem. You can link to a service like pastebin or a github gist where you've uploaded the code snippet or include it in your post as a **properly formatted code block** by either indenting every line by an additional four spaces (when using the markup editor) or by using the "Code Block" button (available under the "..." menu in the fancy pants editor).
The LSB is bit 0. The MSB is bit 7. So there should be a 0 and 7 in your code somewhere.
For what? I'm taking the LSB of both variables and trying to switch them.
First clear the bit you want to be able to set later: p = p &amp; 0xfe; Then set the bit (you have to use a mask to only get the LSB, otherwise you're ORing all bits): p = p | (b &amp; 0x1); 
I learned the anti-clockwise spiral, so start with the inner-most identifier, "names is a" spiral anti-clockwise you would go out the bottom of names and come to "an array of length 10" keep going to "char pointers"...similar for the second start inside the parens, then you hit the pointer before you exit the parens and then keep spiraling... If that's not your favorite way to do it there is always: https://cdecl.org/
As a char (8 bits), 1 is 0000 0001 in binary. If you bitwise AND this value with another char, you will get 0000 0000 or 0000 0001, depending on the LSB of that char. Likewise, `x &amp; 254` gives you everything except the LSB of `char x`. 254 is 1111 1110 in binary. So `(x &amp; 254) | (y &amp; 1)` is `x` with the LSB of `y`.
x++ and x=x+1 are different
It's no problem. Thanks anyways!
The syntax `a[b]` means and is treated the same as `*(a+b)` by the language and compiler, and the syntax `b[a]` is treated the same as `*(b+a)` (which is the same as `a[b]` or `*(a+b)`). So you can use the operators interchangeably. `&amp;a[3] == &amp;*(a+3) == a+3`, for example.
I only used it for short programs in C from the book hello world, simple calculations and etc and it worked fine. I have not used it for anything other than that.
Thanks for the suggestion. I've actually already tried that approach but it's a little slower because of the processing upfront and at the end (bunch of _puts_' instead of a single _fwrite_). About 20%, IIRC.
References aren't part of the C language. (Though for me i dislike the term pointer so in my mind I say "reference" whenever I think about pointers bc it's more a more descriptive term for what pointers are and do)
Unless you are talking about something obscure enough that I've never run into it... They are the same thing. "Reference" is just in reference to "Passing by reference" as opposed to "Passing by value". When you PbR you are passing the address of a variable into a function and putting it into a pointer (as opposed to just passing the value of the variable into the function). A Pointer is a variable that stores and address and points at a memory location. A reference is the address of the memory location that is in the pointer.
Are you asking about function arguments? about "passing by reference" or "passing by value"?
Are you using C++? C++ has both pointers \* and references &amp;. References are really just syntactic sugar (a convenience) for pointers. C has no references, though.
Oh crap, I thought I put that in the original post. Yes it's C++, I just couldn't find a C++ subreddit to post in.
To explain what OldWolf2 was getting at, both `x++` and `x = x + 1` are expressions so have values. `x++` has the value of `x` before the increment while `x = x + 1` has the value of `x` after the increment. `++x` is the same as `x = x + 1`.
Here's a little more clarification on "passing by reference" just in case it's helpful. Let's say you have a struct like this: struct my_struct { char name[16]; char message[64]; }; All in all, this struct's size is 80 bytes. That's pretty big. Let's say you also have a function which does something with one of these structs. void struct_stuff(struct my_struct s) { printf("%s\'s message: %s\n", s.name, s.message); s.message = "goodbye"; } Function parameters in C are *local,* meaning that changing `s` by setting its message to `"goodbye"` will *not* change the message of whatever you called `struct_stuff()` on. When `struct_stuff()` is called, whatever you put for the `s` parameter is copied into `struct_stuff()`s stack. Changing it there will not change the original. However, this means that every time you call `struct_stuff`, 80 whole bytes of stuff are being copied around, which is pretty performance heavy. You can avoid this performance overhead if you pass by reference: void struct_stuff(struct my_struct* s) { printf("%s\'s message: %s\n", s-&gt;name, s-&gt;message); s-&gt;message = "goodbye"; } If you pass by reference, taking a pointer to a `my_struct` instead of a `my_struct`, only 8 bytes will copied into `struct_stuff()`'s stack, significantly improving performance. However, because `s` now points to data in the stack of the caller, changing `s`'s message here WILL change the original.
They’re the same..
As noted, references are kindamostly C++ syntactic sugar for pointers. As reference: As pointer: int &amp;a = b; int *a = &amp;b; a = 4; *a = 4; printf("%d\n", a); printf("%d\n", *a); There are two kinds of reference in C++, though, rvalue and lvalue references; there’s only pointers in C.
No they aren't... Compare output of `printf("%d\n", x++);` and `printf("%d\n", x=x+1);` 
500.0 gallons ≈ 1,892.7 litres ^(1 gallon ≈ 3.79 l) ^(I'm a bot. Downvote to remove.) _____ ^| ^[Info](https://www.reddit.com/user/Bot_Metric/comments/8lt7af/i_am_a_bot/) ^| ^[PM](https://www.reddit.com/message/compose?to=Ttime5) ^| ^[Stats](http://botmetric.pythonanywhere.com) ^| ^[Opt-out](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=Don't%20reply%20to%20me&amp;message=If%20you%20send%20this%20message,%20I%20will%20no%20longer%20reply%20to%20your%20comments%20and%20posts.) ^| ^[v.4.4.6](https://www.reddit.com/user/Bot_Metric/comments/8o9vgz/updates/) ^|
Add an if statement for the printf statement!
Smart. Thank you! 
It really depends on how technical you want to be about your usage of the word async. :) [https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean](https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean)
Your first paragraph is completely wrong. It would make slightly more sense if you said "value" instead of "precedence"
In well structured code it's always obvious where code comes from or goes to. GOTO can violate this, whereas loops are very explicit about their domain. Types compile away altogether, but I imagine you still use those. If by "jump out" you refer to exiting loops, consider using `break` instead. It too is just a goto under the hood, but the semantic intent is valuable to programming clarity and debugging.
No, the result of `x++` is the old value of `x`. The result of `++x` is the new value of `x`. Precedence has nothing at all to do with this. I don't know why you linked a precedence table. "Precedence" describes how we decide which tokens make up the operands of each operator. For example in `++x[5]`, precedence is used to determine whether it is `x` that is incremented, or `x[5]`. In the code `x++` there is no need to invoke precedence because there is no possible ambiguity in parsing. The operand of `++` is `x`. 
Dijkstra wrote his famous article “goto considered harmful” and a generation of programmers was told to avoid goto at any cost, often without really motivating why. Nowadays, “goto is bad” is a meme that keeps going around, strengthened by most programmers complete unfamiliarity with this construct. The goto Dijkstra complained about doesn't exist anymore and an absolutist stance in this regard is rather pointless; I suggest reading Knuth's response “[structured programming with go to statements](http://fuz.su/~fuz/doc/spwgts.pdf)” for some good counter arguments.
It's also prohibited in the Google Coding standards which is how a lot of small/mid-size companies structure their code base. 
Programs should be loops within loops (according to the prevailing theory). GOTO wrecks that- it lets you break out a loop and jump smack into another completely unrelated one. It makes code impossible to understand-"Spaghetti Code". Even the author can't read it after a few months. It creates unmaintainable code. If you're using GOTO you don't understand how to structure shit.
There are good uses of GOTO, but it's quite rare and usually limited to error handling. If your code become "spagetthi code" and unreadable, then I think there's more to it than a GOTO statement.
Use of goto does not necessarily lead to spaghetti code, in fact using goto to jump out of a deep nested loop is more readable than using conditional loop.
They are the same thing EXCEPT a pointer is an address- A NUMBER. The reference points at an object, but you can't treat it like a number and the memory location is "none of your business". 
It's not at all about how efficient the final code is, but about maintainability and extendability. Tracing through goto program flow, and changing it, isn't always that easy. It's handy when used well, but I think any programmer should learn to live without them before using them, and use them only when it actually makes code cleaner. I don't know if you've seen C code written by scientists used to FORTRAN, but it has a very distinctive flavour to it.
No. You NEVER need GOTO. Error handling? Set an exit condition and break out of the loop. Now you have ONE WAY out with an error and when you add more code, you can add to that WAY. Using GOTO lets you just jump ANYWHERE in no standard fashion. If your just coding for fun that's fine but in the You Get Paid To Code world, that's a shitty thing to do the guy who WILL inherit that code someday. I've had to work with hundreds of peoples code- most of them I never got the chance to meet. It REALLY matters!
Well, I've been a paid C-developer since 2002, and some of the places I've worked, they've not used GOTO and had a good way of resolving those situations in their coding standard. Other places have been using GOTO, and as long as you have a reasonable coding standard attached to it, it does not make the code unreadable. There's usually more than one "correct" way of doing things, and I tend to listen to the people I work with and we decide together how to get well structured code (with or without GOTO).
I'd add that it can be helpful to use goto if you're trying to break completely or partially out of nested loops. If you have, say, three nested while loops and something happens within the innermost loop that makes you want to get out of the nested loop situation entirely, this could be a "proper" use of goto. Then again, you could have some flags in every loop telling you to break if it's set. Yes this sounds confusing. The fact of the matter is it will likely all compile down to the same code anyway...
Please don't troll here.
The best analogy to this that I've heard is that it's like starting a sentence with "and" or "because". It can lead to some bad practices if you try to do it without really knowing what you're doing. So, in general, people learning the language are just told not to do it. But there are some cases where it can make sense. You just need enough experience to know when it's needed and when you're just being lazy. 
Also forbidden in any safety-critical coding standard as MISRA (initially automotive but now widespread in aerospace on European ECSS or DO-178). It is considered unsafe and prone to bad design faults. 
You can't always do that because you may have: while(!error) { if (thing() &lt; 0) error = 1; DoMoreThings() } And there you have, instead of setting error = 1, what you want there, is to break. But what about this? while(!error) { for (i = 0; i &lt; 10; i++) { if (thing(i) &lt; 0) error = 1; } DoMoreThings() } But that is not what you want, because you don't want to continue the for loop if there's an error. And you also don't want to DoMoreThings(). So you can't set error and compare on the outer while loop. So what do you do? You goto: while(1) { for (i = 0; i &lt; 10; i++) { if (thing(i) &lt; 0) goto for_failed; } DoMoreThings() } for_failed: fprintf(stderr, "Your program failed"); 
I read that entire article after some reddit thread recently and it was very enlightening about all the different arguments for and against goto 40+ years ago. There are a few Dijkstra quotes in the article from Knuth's discussions with him on the subject, and from what I understand even Dijkstra's position was not quite as absolute as we would think.
I've had some real disasters trying to refactor long-lived code that has gotos in it. I also find it unpleasant to review. 
Please do not post pictures of code. I have removed your post so you can repost your question with code as text instead of a picture.
It's really not difficult to take the code in the picture and type it out into a post. Also, you should really do tests yourself. That's the whole point of a test.
On a TEST these are presented as jpegs and you are required to predict the result, not to run it on a compiler. 
Yes, he wasn't really happy about the article either because people were making a religion out of it and to be honest it still happens. I was taught that gotos and continues are evil, only break was accepted by my professor and we sticked to that suggestion because we didn't want to fail the exam.
The question is quite simple, do you know how and what this code does or not? If not, leave it for someone else who might be more knowledgeable on the matter, and is willing to help. 
Your comments are mostly useless. Think about what you would want to see in your code if you had to look at it a month in the future, and what you would need to read to get up to speed on anything tricky. For example: float func(float x) //declaring our float-type function. { return (6*pow(x,2)+29*pow(x,1)+14)/(32-(1*pow(x,5)));//the function itself } That's a lot of magic, and you say nothing about what this even represents. Also, see: if (32-(1*pow(arr[i],5)) == 0) //check if there is dividing by 0. Why 32? Why 5? You might know now, but will you in a month? Anyway, let's think about this actual problem. else if (creal(arr[i])+cimag(arr[i])) You get the real component of the number, and add the imaginary component. What are our cases? Number = 5. Then we have 5 + 0. Number = 5+2i. So, we have 5 + 2 = 7. So what? If you are checking for complex, then it should have a non-zero imaginary component right? You can (probably) say: else if (cimag(arr[i]) != 0) For a start though, I would print these values to see what you're even dealing with. 
do you mean: `printf("Complex %d + j%d\n", creal[0], cimag[0]);` or something like that
Yeah, thanks a bunch for so deep comment! There are a lot of comments due to it’s kind of project work, so it should be explained everywhere. I got you, I’ll try that way, thanks :)
Rust added [loop labels](https://doc.rust-lang.org/book/first-edition/loops.html#loop-labels) for this very reason.
ok I not fully understand what your problems is... A number is complex when have an imaginary part, so for example you can loop your array and when you have `cimag[i] != 0` then that number is complex
You should paste the code, simply with correct code formating. [https://www.reddit.com/r/web\_design/comments/neukr/posting\_code\_snippets\_properly\_on\_reddit/](https://www.reddit.com/r/web_design/comments/neukr/posting_code_snippets_properly_on_reddit/)
I am a little surprised the compiler caught that free mistake of yours. But it's right. There should be one free per malloc. You've asked the library to give you a "memory allocation" and you are now releasing that allocation. It's kind of like renting a tux. Even if you're not going to wear the jacket, you don't return it separately. You return it all at once. And yes, freeing is totally fine. Better in this case is not using malloc at all, since everything is known ahead of time. In that case you would use a static array and not malloc or free. 
Please switch back to pasting code in here, it's much better. Make sure you indent each new line with four spaces so it'll be formatted properly and look like this. When you run `free` you free all the memory that was assigned to that pointer, you don't free each element individually. `free(list)` as you have it now is correct, as list is pointing to the memory that was assigned with `malloc`.
I just need to find a complex number and I know how to find it, but I do not know how to print is as condition in my code, so that was a question. Sorry about being miss-understanding. 
If you are still trying check for each imaginary part on the array, then when the condition is true you simply printout that position `for (i = 0; i &lt; last_place; i++)` `{` `if (cimag[i] &lt; 0)` `printf("Complex %d - j%d\n", creal[i], cimag[i]);` `else if (cimag[i] &gt; 0)` `printf("Complex %d + j%d\n", creal[i], cimag[i]);` `}` and you are done! &amp;#x200B;
Oh sorry you have to apply some kind of module function on imaginary part before printout so to avoid the two minus signs
Thanks for the clear reply! And I will make sure to paste code here next time :)
Thanks for the clear reply!
Sorry &gt;&lt; Will paste it next time.
The rule is that you post your code as text. My job is to uphold the rules. If you don't want to put effort into your questions then kindly ask elsewhere.
C# does have pointers. 
Try to follow [this](https://www.reddit.com/r/C_Programming/comments/9l0vuz/asking_for_help_what_to_do_when_your_program/?ref=share&amp;ref_source=link) makes it easier for everyone.
When you are programming an embedded part that is in device that saves lives, and you get an address error. GOTO will bring you to your backup code. You're just wrong.
check off-by-one errors. // first loop while (temp != list + 10) // terminates when temp == list + 10 // second loop while (temp != list) // temp start with the value list + 10 (off by one error) // loop stops when temp == list (off by one error, should be list-1)
The Linux OS has many gotos in various functions -- they are basically used as manual exception handling because C doesn't ha e exceptions. They can be used well, but it is very easy to use them poorly as well. 
I don't want to speak for all of those industries, or all companies in those industries, but as someone who has seen a lot of 'safety critical' code, it's not anything to aspire to. Most of the standards have waivers, and few 'required' clauses. Go-to can avoid at least a few anti patterns in C.
At least with C, I think people consider setjmp and longjmp to be a different class of tool than goto. I agree there is a preference order for constructs to use, but ultimately you want to choose the one that makes your code mirror the logical flow chart representation of your code. I use the same argument for early returns versus carried return values (your flow chart probably doesn't test a ret variable 10 times). I've mostly liked using go-to for cleanup / unwinding before exit of a function.
I love that feature. At first it looked quite unusual but it is a breeze to use.
We're a surly bunch of people when it comes to screen shots of code, but we're a helpful bunch when you have questions about the language. The main reason I don't like images of code myself is that I can't copy it and try compiling and running it without typing it in again. It's also much easier to see it in the post if it's not that large a segment of code.
This is unrelated, but you're using `%i` as your modifier to scanf and printf, when you should be using `%d` for integer values (d stands for *decimal* in this case)
As far as I know pointers and Referenzes aren't the same in C++. Of course both are address but Referenzes are fixed, pointers aren't. The Differenzen is how you deal with them. Unlike a pointer a Referenzes must be initilized. A Referenz is always the safer way to deal with data because it is the direct linkt to obj. It should be treated as the object itself. For the most cases: Unless you are not about to do some arithmetic stuff with your pointer (like loop through an array) use a Referenz. 
Or, you can use Pastebin and give us a URL to the paste.
Safety critical code is about the process.
The same is true of exceptions.
Well, there's a problem here. Actually, more than one. `&amp;arr == arr` is bad code to begin with. I mean, technically a C compilers will allow it, but it's at least a warning to most compilers because they result in different types. If we presume a declaration like `int arr[5];`, then `&amp;arr` is a pointer to an array of 5 integers, while `arr` will decay to a pointer to int. Comparing or otherwise mixing pointers to different types is bad. It turns out, though that these pointers point to the exact same place in memory ... but then we get into C's strict aliasing rules, so I'm not totally sure you can guarantee that the comparison will be `true`, it might be undefined behavior. I'll let someone else weigh in on that. The point of that statement is probably to say that string literals are arrays. `"hello World"` is equivalent to `{'h','e','l','l','o',' ','W','o','r','l','d','\0'}`, an array of characters. Assuming that `arr` in the original statement is an array, then the comparison is somewhat apt (but with the same caveats as above). Even so, there's other problems. You didn't write your question this way, but I *think* there's problems with saying `&amp;"hello World" == "hello World"` -- I don't believe C requires that two string literals with the same contents have the exact same address. Or maybe that's only if they're in two different compilation units? If you didn't understand the above, that's half my point. The statement you're asking about requires a lot of intimate knowledge of C to tease out the details of whether or not its true, or even whether the original statement is even defined behavior. I've tried very hard to understand these details, and I still only know just enough to stay away from what this code is trying to do. But there are some lessons that should be learned here. For example, string literals are arrays. Also, it also somewhat demonstrates pointer decay ... in fact, that's worth discussing briefly. It's often said that pointers and arrays are the same thing in C. This is a misunderstanding, and you'll shoot yourself in the foot if you believe it. However, C does have two features that lead to the confusion: pointers can be treated as arrays, and arrays can decay into pointers. The former means that I can take `int *a` and the language allows syntax like `a[10] = 1` -- it treats `a` as if it points to the start of an array, and then does the appropriate indexing to find an item in that array. The latter means that I can also do `int *a = arr;` -- `arr` isn't a pointer, but it will produce a pointer to the start of the array if needed. That code is the exact same as `int *a = &amp;arr[0]`. So maybe that's what the original question is about? `&amp;arr[0] == arr` is a true statement, with none of the caveats I mentioned. The same concept applies to string literals, so `&amp;"hello World"[0] == "hello World"` works the same way (except I'm not sure you're guaranteed that those two literals have the same address ... see above). Confused yet? Sorry...
I updated my post to give the context. I don't know how to answer your question. 
I didn't write a single `goto` in professional/production code for the first 20 years or so of my career. Everyone I learned from accepted the "goto considered harmful" trope and I just kind of accepted it. I changed my mind after spending a lot of time working with the [Redis source code](https://github.com/antirez/redis/search?q=goto&amp;unscoped_q=goto). I think that using a `goto` is the cleanest way in C to exit/fail out of nested logic where you're doing allocations.
I got an error at ' print f(sum) '
The syntax of the printf is quite different. It should be: &amp;#x200B; printf("%d", sum); &amp;#x200B; Where d is the specifier format for decimal integers
Thank you it worked. So what about if it is a star (*) ? Is that considered an integer as well ? 
What do you mean with a star? Do you want to print a "\*"?
`printf` expects a string, so you will need to pass it as a parameter like `printf("%d", sum)`.
Understood. Thank you !
I'm not sure anyone in that thread is completely correct. But I didn't read it all in detail. "hello world" and &amp;"hello world" are not the same. Take some time to try and understand this example. (Note I swapped the meaning of `p` and `q` from my 1st snippet) #include &lt;stdio.h&gt; int main(void) { const char strings[][12] = { "hello world", "forty two!!", }; const char *p = strings[0]; const char (*q)[12] = &amp;strings[0]; printf(" %p %p \n", p, q ); printf(" %c %s \n", *p, *q ); printf(" %c %s \n", *(p+1), *(q+1) ); } Try to predict what it will print, and why.
I'd leave those kind of things right now, anyway for a character you should use the char type ( it's still an integer type, but you should really study from a book those details). You declare it like this: char a = '\*'; printf("%c", a); 
The cleanest and most easily worked with form of RAII in C is done with `goto`; it's even in the Linux kernel. Because doing it with `goto` prevents your code turning into a giant indented pyramid of `if … else` conditionals. Plus, using the `goto` method for RAII in C also falls neatly into the precept of don't repeat yourself. Compare, for instance: rc = openSocket(); if (!rc) { rc = createSharedMemory(); if (!rc) { rc = prepareSemaphores(); if (!rc) { processData(); seterror(ALL_GOOD); destroySemaphores(); destroySharedMemory(); closeSocket(); } else { seterror(SEM_FAIL); destroySharedMemory(); closeSocket(); } } else { seterror(SHM_FAIL); closeSocket(); } } else { seterror(SOCK_FAIL); } showerror(); Now, using `goto`: rc = openSocket(); if (rc) { seterror(SOCK_FAIL); goto sock_error; } rc = createSharedMemory(); if (rc) { seterror(SHM_FAIL); goto shm_error; } rc = prepareSemaphores(); if (rc) { seterror(SEM_FAIL); goto sem_error; } processData(); seterror(ALL_GOOD); destroySemaphores(); sem_error: destroySharedMemory(); shm_error: closeSocket(); sock_error: showerror(); Which one is easier to add an extra step to? The second, of course. While the first the "Tower of Power" gets bigger and you need to reduplicate the entire tear-down process. If you want a better example, [here's a properly formatted program that actually works](https://vilimpoc.org/research/raii-in-c/).
The context is Why does this work int main(void) { printf("%p",("Hello World" + 1)); return 0; } But this gives a compiler error int main(void) { printf("%p",&amp;("Hello World" + 1)); return 0; } The answer has nothing to do with the difference between &amp;"hello world" and "hello world" ("hello world" + 1) is a pointer to the letter `e`. "hello world" decays to a `char*` pointer to the letter `h` But the result of that calculation isn't a something you can take the address of. It is similar to int a; a = 3; (a+1) = 3; // error int *b = &amp;a; int *b = &amp;(a+1); `a+1` has a value. But it isn't a value you can assign to. Or take the address of.
I can't say that I like this idea; I think it's hard to read because the position of the label does not really indicate where execution continues (at the statement after the one labelled statement).
There's Glib and AUR off the top of my head. I for one am a fan of Glib.
C doesn't have templates, making "generic" libraries very tricky to make. Typically, of you want more involved and complicated code, you at least switch to C++, but likely even something higher/newer. 
Those are not portable, but was more interested in ds instead of event driven stuff but Ill give it a proper look.
Good point I never really considered it that way, I guess portability is a dream or the only solution is vms.
You could also make a helper function which runs the loops and just return anywhere within it.
Good catch just seeing that now, also that’s a handy function. Is it more efficient as well?
Wait, what? &amp;#x200B; What are you trying to be portable across? If you want to run on different hardware but have the same OS, you can recompile and everything will normally work.
Not for this I was just saying in general, or for a future project I plan to do. And across different OSes
It's just a different idea, you don't specify where you go but what you stop executing. Just like using break in C, it does neither specify where you go to.
http://www.drdobbs.com/cpp/the-x-macro/228700289
I'm bigbadpig there.
You are probably searching for [X Macros](https://en.wikipedia.org/wiki/X_Macro). Basically: #define ENUMS X(ETC1) \ X(ETC2) \ X(ETC3) \ X(GOTCHA) \ X(MAGIC) enum { #define X(name) EN_ # name // TODO: Look up if thats the correct way to concat ENUMS #undef X EN_END }
**X Macro** X Macros are a technique for reliable maintenance of parallel lists, of code or data, whose corresponding items must appear in the same order. They are most useful where at least some of the lists cannot be composed by indexing, such as compile time. Examples of such lists particularly include initialization of arrays, in concert with declarations of enumeration constants and function prototypes, generation of statement sequences and switch arms, etc. Usage of X Macros dates back to the 1960s. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
[This reply](https://www.reddit.com/r/C_Programming/comments/9lnjb1/what_does_this_mean_hello_world_would_be_the_same/e786n7r) is a pretty good explanation for what's going on. For more information, google the terms "rvalue" and "lvalue" (which were used in the error message).
The point with labelled continue is that if I have a labelled statement, I expect control to go to that statement because the label visually marks the statements, and not the statement after it. It would be much clearer and intuitive if the label was attached to the end of the loop; perhaps like this: while (...) { ... } : label;
nm I got it going, thanks!
 printf(sum) is incorrect, you should use format specifiers such as printf("%d", sum); &amp;#x200B;
It just has a different semantics and is to be read differently, it needs time to get used to of course, but I find it rather clear if not clearer even. Just like with a loop it's semantically clear even that on termination there's a jump to after the loop.
Hahaha ya, C is a really “stupid” language.
Don't screenshot your code. Copy and paste it into reddit and format it so we can read it or put it in a paste service. Even without the massive reflection this is horrible to read, and we need to be able to copy-paste.
Your `dankestmeme` function: &gt; int dankestmemes(void); has no body in which it returns a specific `int` ....
This is why being neat and tidy with your indenting is so important! Your `dankestmemes` function is not defined in file scope; instead, you've nested its definition within your `main` function. This would ordinarily be a syntax error, except that you are accidentally making (incorrect) use of a [GCC extension](https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html) to the language.
Creating a separate header file would also have been a useful thing to do to avoid this type of error. 
Ritchie would be proud of the fact that you are using C to code meme-related stuff. You declared a function inside another function.
_Generic. Even MSVC is adding support.
I don't know where you found that monstrosity but if you keep looking at it you'll go blind.
lol, thanks for the laugh. It's part of an buffer overflow exploit. I'm currently doing my OSCP and it's one of many exploits i have to modify in the lab. I just have nfi what this line does :( I'm *guessing* it's appending "something" to myVariable. But what's the 2600 for? bytes? location in myVariable? I'm a crap programmer in the most basic of languages....
if the type of myVariable is char*(or its a char array) that sounds about right.
Oooo I cant wait till I find out who you are just wait 
So do you want us to debug your code? 
TIL. I've never gone into the "unsafe" area of the language because it didn't seem.. safe. 
&gt; Hey, I am getting this annoying "first defined here" error Err, the actual error is the line before that. It also tells you which two libraries are involved.
Dereference (as a `long pointer`) the address of element 2600 of the array `myVariable` and to that memory location assign the address of the string of characters that spell "something" roughly at least.
a real beauty
There used to be a website that would decode C types to english. It was a beautiful thing and now I can't find it and I'm sad :'(
the C people species is on the verge of distinction on the internet :(
You have a curly braces problem in the code you pasted. The dankest memes function should be declared separately from main. 
Thank you so much! I removed -lglew32 from my linker thing and it worked, I have been stuck at this problem for 3 hours.
&gt; Originally, instead of "free(list);", I did "free(temp);" within the 2nd while loop, and it couldn't compile. Always provide the errors that the machine gives you. Also, I'm wondering what compiler you are using. I used gcc 7.3.0, did something similar and it didn't complain. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(int argc, char* argv[]) { int* list = malloc(10*sizeof(int)); int* tmp = list; for (int i = 0 ; i &lt; 10; i++) { *tmp = i; tmp++; } printf("%d\n", list[2]); tmp = list; free(tmp); } 
Did you read the sticky about asking for help?
This is a great explanation of a monstrosity of a line code ;-) There are however two small mistakes. The array has a size of at least 2601 elements and this particular line OP posted accesses the 2601st element of the array.
Harsh but fair. Still, getting openGL up and running can be a little daunting since it's packaged in so many parts. I'm sure my eyes glazed over during the process when I was a younger engineer. :)
&gt; *(long*)&amp;myVariable[2600] = "something"; &gt; It's part of a buffer overflow exploit. I'm currently doing my OSCP and it's one of many exploits i have to modify in the lab. I just have nfi what this line does It's probably just a '90s-style classic stack buffer overflow in an environment without modern exploit mitigations (stack canaries, DEP/W^X, ASLR, etc.). If so, "something" is an address that will find its way into corrupting a saved return address, a function pointer, or some such in the target process. The target process will return/jump to that address, where you'll have managed to place your own machine code to be executed. You wouldn't write a remote exploit with such a line, because it assumes the attacking system and the target system have the same endianness. (It could also be an aliasing violation, but never mind that.) If you paste the target program, I can tell you precisely what the exploit is doing.
&gt; Try replacing a complex code's flow control (if, else, for, while, etc) to goto's and you will understand. Goto's make the code really hard to read and follow correctly. It's a really nice exercise to fully grasp why the other flow control constructs were invented, and why you should prefer those. That's a bullshit argument. You generally do not use goto statements to replace if statements and loops, but rather to implement kinds of control flow that are very different to replicate otherwise, for example: * loops where on the first iteration, only the bottom half is executed * breaking out of deeply nested loops * if-then-else cascades with shared branches Knuth's paper shows that it is not always possible to replace control flow that uses goto with control flow using just if statements and loops without introducing new variables. These new variables are sometimes clearer, but often they make the code more complicated to understand at no real benefit.
&gt; const char *p = strings[0]; &gt; const char (*q)[12] = &amp;strings[0]; &gt; printf(" %p %p \n", p, q ); &gt; Try to predict what it will print, and why. The use of %p with a char (*)[12] is definitely undefined. The use of %p with a char * is potentially undefined, depending on how one prioritizes "The argument shall be a pointer to void" (7.21.6.1#8) and "A pointer to void shall have the same representation and alignment requirements as a pointer to a character type" (6.2.5#28, with a footnote stating this implies interchangeability). 
This is why I love C even though I dont fully understand it 😂
&gt; Will C community ever get something like boost? In my experience, pthreads has been pretty easy to implement, and you only need a few ifdefs to add windows support too. 
You are getting your rows and cold reversed.
The code works, I just need to know why it works this way. 
Why would you expect it to be 3? What two numbers do you think are being multiplied together? Take note that when you use a brace-enclosed initializer list, any elements of the object that do not have an initializer value are effectively zero-initialized.
The compiler takes 3 from {1,2,3} and tries to multiply it by str[1][2] aka the third argument in {3}, but there is non present, so how you get 0 and not 3 or any other multiple of it? 
Why is not automatically set to 1, for example? 
I don’t really know, but 0 kinda makes sense. If you don’t initialize a variable it holds the value of the memory address it gets assigned to, so if you initialize some variables in an array I think it’s safe to assume you know what values the others should have.
Thank you 
Oh that's a neat extension. I don't know when I'd ever use it, but still nice to know it exists.
Not only is it a picture of a monitor your formatting is way off. It honestly hurts to look at.
few things * don't use globals, especially not one-letter named globals * I'd rather not see any commented-out code * this block : bvoid discard(int id) { if (id == l.num_tasks) { l.num_tasks--; return; } else { for (int i = id + 1; i &lt; l.num_tasks; i++) { strcpy(l.t[i - 1].description, l.t[i].description); l.t[i - 1].state = l.t[i].state; } } l.num_tasks--; } doesn't need the `else` indentation level since you return inside the if block
The array str\[1\] is initialized to {3, 0, 0} at the beginning as you left it for the compiler to fill them in.
Still, C is a great language to use when learning about this kind of stuff because there’s not much of an abstraction over the syscalls and stuff
Ah, I didn't know that! In that case, where would be the most appropriate to inquire about this? Is there another sub reddit that's more dedicated to OS/Unix? Also, any recommended Unix course that you can think of that would delve into processes?
Lol god bless you
https://www.youtube.com/watch?v=DxjBfzXFKo4 That's what they really mean
s is already a pointer to the start of the string. So right now this is incrementing a pointer to the pointer 
[I looked at this code](http://cad6.csie.fju.edu.tw/c++%20how%20to%20program/code_examples/ch05/fig05_14.c.html) and saw how it did things. Why does it work for that one, but mine doesn't work??
Every single course covers basics, pick one. More detailed info is [here](http://www.tldp.org/LDP/tlk/kernel/processes.html).
`*` dereferences a pointer (i.e. gets the value in the memory that is being pointed to). The reason for that line is to move the pointer forward but it doesn't care about what is being pointed at.
Whoops, you're right. My bad.
 Player* p = (Player*)malloc(sizeof(Player*)); You're allocating for an `Player*` (a pointer), not for an `Player` (a struct).
Thanks man 
Try this: char foo[] = "ABC"; char *s = foo; s++; printf("%s\n", s); *s++; printf("%s\n", s); This will print out two lines. The first one will be `BC`, as we moved s along one place. The second will be `CC` as we incremented what the pointer points to rather than incrementing where it points, and the ASCII value of B plus one is C. You then get the original C as the position s is in hasn't changed.
You can read the relevant sections of an OS textbook like Tanenbaum or Silberschatz. They provide examples in C. 
Thanks!
Ahh that fixed it. I tried learning C++ in the past before C so that's probably why I put the cast in there. &amp;#x200B; Thanks!
It's a common "mistake". Most of the time it won't affect anything, but the compiler will spit out a warning with `-Wall -Wextra` IIRC.
rearrange the loop and make the if statement the while condition
Hey, thanks for your reply. I just tried that and I'm getting the wrong output now:( for example: when i enter 2 as my input i expect the output to end with 1.64
Also &gt; When I debug I get this Well no, you(@OP) weren’t actually getting anywhere near debugging, that was the linker shitting itself before an executable could’ve been created to be debugged in the first place. I get the idea of teaching people C/C++ inside an IDE, but they seem to be thoroughly hobbled in terms of understanding what the hell the IDE actually does for them.
As someone who as worked for aerospace, science and energy industries for almost 20 years as a safety-critical systems engineer, I have not only used them, but also I've been involved even in the development and review of these kind of standards (primarily **ECSS** as **ESA** engineering personnel). It is common knowledge among the developers in these sectors to avoid the *"goto"* statement, as many other restrictions (for instance, an else if statement requires a mandatory else statement, or forbid the use of the *"break"* statement unless it is inside a *"case"* statement. If a code attempts to pass through a qualification or validation process, these will be really strong requirements to take into account. &amp;#x200B; Of course there are waivers, but they are really unusual and almost unseen as the criticallity level of the system raises. C is a low-level language, with structured programming features which allows nowadays to design any necessary pattern with no need of a *"goto"* statement. It's use is not only considered poor design, but also extremely unsafe, unreadable and turns verification into a nightmare. &amp;#x200B;
That's plain wrong
I see what you are trying to do, but I think you overly complicated it. Try to erase it and just go simple. If you have a "not punctuation" character, you print it, and say "hey boolean, I got a word here". If you reach a punctuation after a word, you print a newline, and say "hey boolean, I got no more words here".
Why do u ask this question while already learned loop? L
http://man7.org/linux/man-pages/man1/break.1p.html
Your code doesn't compile. Please post the actual code you tried. That said, option== 'n' || 'N' doesn't do what you expect; it's always true as `'N'` is nonzero. Perhaps you wanted option == 'n' || option == 'N' instead.
I have changed my options from y or n to 1 to 0 here's the previous code: #include&lt;stdio.h&gt; main(){ int sum, num1, num2; char choice, ent; do{ printf("Enter Two numbers."); scanf("%d%d",&amp;num1 ,&amp;num2); sum= num1+ num2; printf("%d",sum); printf("\nAgain?Y/N"); scanf("%c%c", &amp;choice, &amp;ent); }while(choice=='y'||'Y', !='n'||'N'); } 
Your while statement is a train wreck. Try something like this: while (choice == 'y' || choice == 'Y' || choice == 'n' || choice == 'N')
it just ended the program, I wanted the y to loop and the n to stop the loop.
Take a look at those two: readASymbol++; statements. In each case, what is the _next_ statement executed by the computer?
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/WfFYweL.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e7b23up) 
Well, I suspect there is an issue with the code you did not provide.
Why not global vars? Also I'd argue that the `else` makes it clear, but I see your point. Tbh I plan on creating a program to add these comments to github, but yeah. What do you do when you can't think of a variable name? 
No it works, just looking for style pointers and such from more experienced c programmers.
I guess I haven't tried writing out the pseudo code, but I dont think I'm over complicating it either. I could've used bool instead but that doesn't make the program less complicated. There are three blocks that the character could possibly go through and that's it. If the character is a symbol, or a new line, ignore. If the character is a space, output a newline. If a symbol hasn't been gathered, output the character. I'll try rewriting and seeing if I get any closer.
Normally terminals are responsible for their own line editing. As a consequence, they do not provide any input to a process reading from the terminal until the user has entered a complete line (typically signalled by them hitting Enter). Since you want to receive input as and when the user provides it, you need to switch the terminal into [non-canonical mode](https://www.gnu.org/software/libc/manual/html_node/Canonical-or-Not.html). That does mean, however, that you are now responsible for all line editing. There's a reason [whole](https://tiswww.case.edu/php/chet/readline/rltop.html) [libraries](https://github.com/antirez/linenoise) [exist](http://thrysoee.dk/editline/) to solve this problem.
That makes sense 
You could look at [readln](https://tiswww.case.edu/php/chet/readline/rltop.html). On the plus side, it's widely available. On the minus side it's not all that easy to figure out and/or use. There are probably better libraries out there.
What if is the target system is *nix based systems and I'm intended only to build a cli tool? And I will try to do some researches about what you called the raw mode, thanks a lot.
I was talking generally, I just wanted to know how to check if some of these input was used, what if the combination was `shift+enter` ... etc
I will look for ncurses and give it a try, I'm have to build an editor that accept a multi line text via the terminal, but from my search on the INTERNET most of the examples/tutorials is talking about checking against the `\0` which is means the `Enter/return` key, which is not the proper thing in this context.
You declared height, width and numComponents as unsigned ints when the function signature takes a signed int.
I've only really done this in an embedded environment, but you ought to be able to use getchar() or an equivalent to get a byte at a time and process it.
{code} test
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
You cannot detect if just `shift` or `ctrl` (or `alt` or `super` for that matter) have been pressed as these keys do not generate input on their own. You can detect `ctrl + something` because if the user presses `ctrl + something`, you get `something &amp; 0x1f` as a scan code. Likewise, if the user presses `alt + something` you get `something | 0x80` as a scan code. Note that unless you are in raw mode, not everything the terminal sends is passed through to your program unchanged. For example, the terminal sends `cr` when you press the enter key and `lf` when you press `shift + enter`, but normally the terminal driver translates `cr` to `lf` in the input. I recommend you to read the book “terminfo and termcap” (O'Reilly) for how to program terminals.
Can you explain what your code is supposed to do?
For the love of god, turn on all available warnings in your compiler. Then fix them. Then you'll know the answer.
Check Desciption
Your description only says what the intended output is, not what its logic is supposed to do. There are some errors in your code and to explain them best, I need to know what you intended to do first. 
Yeah, there's two problems with this in most environments (but perhaps not embedded environments). First, as noted in my other comment, terminals on POSIX-compatible systems have their own input queue management. Strictly speaking this isn't part of C itself, and other C implementations can (and probably do) behave differently, but I doubt the OP is on a system in which all input is processed immediately. Second, it's not necessarily the case that an arrow key produces one character of input. On my system's terminals, each arrow keypress actually generates _three_ characters of input.
OK, try this: while (choice == 'n' || choice == 'N')
Please note that getchar returns int, not char. For one thing, int is need to return EOF. 
One easy reason (potentially). You are casting a 64-bit pointer address to a 32-bit integer, and then dereferencing it. 
Perhaps, instead of reinventing the wheel, you ought to look into using a library like [GNU Readline](https://en.wikipedia.org/wiki/GNU_Readline).
ok. thanks for help. &amp;#x200B;
Right? the pointer before the type is confusing me
its for a hw assignment, we are implementing a shell. its extra credit to implement the arrow key feature... I was more wondering just how to get the 'listening' affect (...listening for arrow keys). Would using this library have any conflict with the system calls im using such as write and read?
I know to to recognize the arrow keys, I just need to know how to listen for it... without pressing enter.
which of the three libraries would work with my read() design? again im just reading in strings in a loop right now... and I want to have arrow keys detected before pressing enter and other strings submitted by pressing enter
The only part that gets modified in main is the contents of str. The value of "c" is unchanged because the language uses "pass by value" semantics. Thus, you get: str\[0\] = str\[0\] str\[0\] = str\[1\] ; b str\[1\] = str\[2\] str\[1\] = str\[3\]; c &amp;#x200B; and str\[2\] is unchanged. &amp;#x200B; &amp;#x200B; &amp;#x200B;
scanf is the function for what you are asking for... but be careful because you have to account for any input other than what you desire.
In C strings are "null terminated," meaning that the end is determined by a special character (`'\0'`). You can truncate a string by inserting this character somewhere in the middle.
Good answer 
Is it for learning or functional purposes? If you want something functional you can use \[readline library\]([https://tiswww.case.edu/php/chet/readline/rltop.html](https://tiswww.case.edu/php/chet/readline/rltop.html)) which already implements all that (line editing, history and can support autocomplete). 
BTW the correct return value check for success is `== 1`. Sometimes people manage to come up with the erroneous `!= EOF`
 map[nums[i]-min] = ++i This is undefined behaviour since you use `i` and modify it in the same statement. GCC even warns about it.
Is your compiler MSVC? it does not fully support C99.
Nope, it's GCC in Linux
Thanks, I'll look into that... Tbh though I receive no warning while compiling even with -pedantic
&gt;`t=(x*x*t)/(2.0*i*(2.0*i-1.0))+t;` The problem occurs in this line depending on the values of the operands to the division when `i=0` as that causes the dividend to become 0: You'll get: * `+inf` if `x*x*t &gt; 0` * `-inf` if `x*x*t &lt; 0` * `nan` if `x*x*t == 0`
I'm no C expert but I'm pretty sure you can't multiply integers with floats in compiled languages. The parts where you're assigning bottom and t, you are multiplying doubles (decimal numbers) with your iterator i (an integer or whole number). I know Java doesn't like that, and I assume C doesn't either. Look up how to cast integers into floats so you can do math with them.
The `-Wall` (and `-Wextra`) should enable most warnings.
You're absolutely correct. I'll use these by default from now on, thanks!
Oh I forgot to meantion to enable optimizations (`-O3`) since that way it inspects the code more closely and gives even more warnings.
is it a problem with my logic or how I wrote it? Do you know any fixes for this?
When you add 4 it changes it back to a pointer at the new memory location so the outside * gets the value at that address. This also works. printf("%d\n%d\n%d\n",*(ptr + 4),*(ptr2 + 4),(*ptr3)[4]);
then I'm an idiot and shouldn't chime in on things idk about, sorry everyone
We can't answer that without knowing what you're trying to achieve. BTW, the `t = a / b + t` part is usually written either `t = t + a / b` or `t += a / b` for clarity. Unless, of course, what you actually meant was `t = a / (b + t)`.
Is there an Exception Code in the window that shows “APPCRASH”?
Notice how you've declared `n` as an integer. It won't ever not be an integer. What instead happens if you try to input an integer is that scanf will fail and not write anything to `n`. That unitialized n value is what causes the crash (this is basically what raevnos wrote as well). I think it's good practice when you start to learn C to always initialize your variables. Thus change `int n;` to `int n = 0;`. Then the code will no longer crash, it will however still be wrong. When you get more experienced you'll know when you need to initialize or not. If you read the manual for isalpha and ispunct you'll notice it says the value has to be a valid unsigned character value or EOF. If you input anything larger than 255 in the scanf that won't be the case. So those functions will crash on those input values. Instead you need to check if scanf actually scanned a number. It will return 1 if it did but 0 if it didn't, as specified by it's manual. I've made a habit to always read the RETURN VALUE sections of the manuals as they're often very informative on how to use the function. Note that you can't really do this in a loop, because since scanf failed to scan it wouldn't consume any input, and the next call will just instantly fail again since it tries to parse the same input. If you want to avoid that, use something like `fgets` or `getline` to read a line of input and then use `sscanf` to scan it for values. I've pretty much always ended up doing that instead of using `scanf` which is very rare to use.
&gt;it's not necessarily the case that an arrow key produces one character of input Right, my code is handling the escape sequences. And it also implements the sort of terminal command history OP's talking about. Turns out to be a little more complicated than it looks at first glance, and I had to tinker with a couple of different shells to figure out how I thought it ought to behave. 
Since it’s for homework, try the routines from `&lt;termios.h&gt;`. They’re wrappers around `ioctl`, which you can also use. `man tty_ioctl` will tell you about the `ioctl` side of things, and you can `man tcsetattr` or `man termios.h` to get the termios side. You’ll want to put the terminal into “raw mode.” Keyboard commands will be sent as escape sequences just like you’d send to control the terminal (`man console_codes`); IIRC ↑ is the same as the CUU command, `\x1B[A`. Make sure you restore everything about the terminal when you exit, normally or abnormally. That includes signals and `atexit` stuff. Use the `reset` command in the calling shell if you bork your terminal by accident.
If you intend to process terminal escape sequences yourself, you wouldn't use any of these libraries.
The initial t is equal to one, the t after that is equal to the equation t=(x\*x\*t)/(2.0\*i\*(2.0\*i-1.0)) plus the past t right before it. Then this operation would be repeated an n number of times depending on what the user plugs in. At least that is what I'm attempting to do.
But the initial `i` is 0, leading to the first itteration being boiled down to: `t = x * x * t / 0 + t` Which is what is causing the undefined behaviour
I understand my mistake now, thank you for all of your help.
The reason the OP's code might be faster is that it can be pipelined easier -- there are no jumps/comparisons, only multiplies and adds. So, while the code as a single operation may be equal or slower, if it's inside a tight loop it could be many times faster than a ternary.
What I'm saying is that OP is asking about the wrong thing, he's talking about replacing an if with this, when what he's really asking about is conditional assignment. 
Take a look at your circle_pi function and ask yourself why you're declaring variables as int type when you want to have decimal precision. What is an integer? Can an integer have decimal precision by definition?
Thank you I changed the variables to doubles.
Yikes. I know a few shitty Indian colleges keep questions exclusively like these print(d, d, I++, --i). Makes me want to shoot someone 
Godbolt (and of course -Wall) is your friend with this type of question... https://godbolt.org/z/mHGt1O
Says the guy asking for other people to provide solutions to his homework assignment... P.s. this isn’t stackoverflow. There aren’t any rules (afaiko) precluding someone from echoing another’s response. How about showing a little grace and humility that someone would take a few minutes of their time to help you (in spite of it being a repeat) instead of responding with snark. 
Put `-lm` at the end of your compiler command.
I've heard this before but I'm new to the concept. Where do you mean by the end of the compiler command? Like at the end of the line with the sqrt? Not entirely clear Thanks again
You have to link the math library with the `-lm` flag when linking your binary, as per the [man page](https://linux.die.net/man/3/sqrt). I don't see a way to do this on that particular website's interface. Use a real compiler like gcc or clang. 
Any compiler I've ever worked with, but I don't use Windows boxes as dev machines. [This explanation might help](http://www.network-theory.co.uk/docs/gccintro/gccintro_17.html).
Which compiler version are you using with the jdoodle site? I tried the same, and it works with the gcc compilers but not with zapcc.
the newest one, 8.1.0
Yeah, sorry. It doesn't really work. I'd initially just tried calling sqrt() with a compile-time constant as the argument, instead of a value calculated at runtime. Presumably, gcc is optimizing away the sqrt() call, thus obviating the need to link the math library. Zapcc apparently does not. So yeah, the others are right. I don't see a way to link the math library, so you won't be able to use math functions with this web site.
Assuming you are using `gcc`: `gcc main.c -o executable -lm` You need to link the C math library, i.e., `-lm`.
I assume that, by "sublime", you're referring to the text editor? The "-lm" that everyone is talking about is an argument to the compiler (or more correctly, linker) execution. The "-lm" is not part of the source code. This would make more sense to you if you were invoking the compiler and linker from a CLI. A gui wrapper, such as jdoodle, hides those details.
I understand all of this, as I said I understand what is happening. I don't understand why it works. I should have explained better what it is I don't understand. *dest++ and *source++ I thought these pointers to the base address of the array could not be modified? Why are we allowed to increment them? And once we do increment them, how does that not effect the values in the calling method?
As a parameter, char x[] is equivalent to char *x. And pointers are passed by value, so the copy in the called function is different than the copy in the caller.
Thank you, that answers the second part of my question. The following code: int main() { char string[2] = "hi"; printf ("%s\n", string); *string = *string + 1; printf ("%s\n", string); } Results in: hi ii The 3rd line of main is increasing the value at the address of the pointer, instead of the address of the pointer. In the example in my OP why does dest++ and source++ increase the address of the pointers instead of the values at the address of the pointers? Based on the code in OP, I would expect the code in this post to result in: hi i
G++ or Clang and a good text editor. 
Read this for some info about order of operations regarding pointer arithmetic: https://stackoverflow.com/questions/5795771/order-of-operations-for-pointers
This post on stackoverflow: https://stackoverflow.com/a/19136941 seems to contradict the code in OP, unless I am misunderstanding something.
`*x++` is parsed as `*(x++}`, not `(*x)++`.
AH it worked!!! I could kiss ye! thank you!!
Ouch, you're declaring a char\* and not initializing it. It has a junk value pointing to some memory location and then asking scanf to write data to that location. That will either segfault (most likely) or write data to some other location (less likely, but it can happen). You need to allocate some memory for scanf to read a string into. You can either declare a char array on the stack or allocate some memory on the heap. void Texture() { char surface[128]; scanf(" %127s", surface); printf("The surface is %s\n", surface); }
That's just coincidence because you've chose a string with characters that are sequential in value. So, incrementing the value of the first character is the same as assigning the value of the second into the first. Try the string with values that aren't sequential (say "hh") and you'll see that it's different. P.S. your array needs to be of length 3 - there's an implied \0 in that literal, which needs space in the array.
From what I just found, you need to install "command line tools for xcode" either through the Apple developer page of the Xcode preferences. You should at least be able to run gcc/g++ through the command line now.
I understand why hi is becoming ii, but it doesn't seem consistent with the behavior of the code in the OP, which is what I'm trying to understand.
I understand how the increment operator works. Based on this post: https://stackoverflow.com/a/19136941 I don't understand why we're allowed to increment those pointers, since they have array type.
Because it loses that distinction when it was passed to a function. Function parameters that are arrays are really just pointers.
What you are misunderstanding is how C treats arrays in different contexts. That answer discusses arrays allocated in the local scope, where it's true that you can't change the value of the array. In the code you are discussing though, the arrays aren't allocated in the local scope. They are passed as function arguments. In C though, an argument char dest\[\] is equivalent to char \*dest. What happens is that C will pass the pointer to the array dest as the argument, and not the array itself. Because of this, inside the function strcpy4 you can use dest just like a char\*, meaning you can change its value using pointer arithmetic operations.
Just use C++.
You can wrap C++ code in a C API though - no point re-inventing the wheel.
Yes - I can. But I want to do this. 
I also want to know this, so I hope you get a good answer! I’m also developing something in C, which has to be in C.
In that case a is an array and arrays are not lvalues. It would be valid if you used b = &amp;a[0] for the increment, which is what's silently happening when you pass an array to a function : it degenerates into a pointer that is passed by value 
Within the function you operate on a copy of the pointer to the first array element. Since it is a copy, changing the pointer will not affect where the array name points. Essentially like this: int arr[10]; int *ptr = arr; ptr++; // legal because it's a pointer. Won't affect arr It's no longer an array, it's a pointer.
A better approach would be to use a language that compiles to C. Basically the same as macros, but with better errors.
Okay so the distinction between arrays and pointers in C causes a lot of confusion so I'm gonna do my best to clarify what's happening here. When you declare an array on the stack like this: `int a[5] = {};`, a is not an lvalue. You cannot assign to a, a is a compiler construct, to allow you to manipulate the contents of 5 neighbouring int. a is not actually backed by a pointer, you can get a pointer to a, but you can never change what a refers to, in the same manner that when you declare an int `int x = 0;`, x now refers to a stack location and there is no way to change the location it refers to, i.e.: `a = b;` is illegal, in a sense it's sort of the same as trying to assign a value to the reference of a non-array type variable: `&amp;x = b;`. `&amp;x` is just a value that's known to the compiler, you can't assign to it anymore that you can assign to 5. In strcpy4, dest and source are not actually arrays. They are pointers, you cannot pass an array, and the innermost array type always degenerates to a pointer type, this is to prevent passing large amounts of memory around with function calls. void array_fn(char dest[5][10]); is actually equivalent to: void array_fn(char (*dest)[10]); Now you may wonder "but why the hell does the second array type not degenerate?". Well, that's because when you call the function you're only going to pass a pointer, that pointer will point to arrays of 10 chars, but you're not actually copying those chars. When you increment that pointer, the address it holds will be increased by `sizeof(*dest)`, which is `sizeof(char[10])`, which on most systems is 10 bytes, and it will just skip over 10 elements from the starting address and get to the second char[10]. In contrast, if the innermost array type did not actually degenerate, you'd be passing an array of 5 char[10], each char[10] would be passed as is and copied, that is, passing 50 chars. Okay, so why the HELL is declaring functions with an inner array type allowed? `strcpy4(char dest[], const char source[]);` especially if the compiler will just silently treat it as a pointer type anyway? (also, notice that the array type has no size, which will degenerate to a pointer type regardless of whether it's the innermost type, if there is no size information the compiler will assume it's a pointer, i.e.: `void fn(char strings[][])` is actually `void fn(char **strings)` while `void fn(char strings[][50]` is actually void `fn(char (*strings)[50])`, in one case you're telling the compiler "I will pass a pointer to pointers", in the other, you're telling the compiler "I will pass a pointer to arrays of 50 chars", which is very different) So why? Probably because arrays and pointers have almost identical syntax and usage in most cases, but in the cases where they don't, it's confusing as hell, and in some cases passing small arrays by value would be nice, right now if you want to pass just a few values you have to wrap the array in a struct. struct array5 { float data[5] }; int main(void){ struct array5 a = {}; struct array5 b = roots(a); // yup, can totally do that and pass an array by value, you just have to declare a struct. } Key points of this comment: - Arrays are not lvalues, in the same way that the stack address pointed to by stack variables are not lvalues. - In function declarations, if the innermost type is an array type, it automatically degenerates to a pointer type, and there's nothing you can do about it. - All array types that do not have a size in function declarations are equivalent to pointer types (this is not the case in struct declaration where it means variable size array).
Don't try to make C more like other languages; doing so is futile. Instead of maps and filters, use loops. Instead of a garbage collector, be disciplined about your memory allocations. String manipulation is surprisingly comfortable if you use `open_memstream` to have a `FILE` backed by an automatically reallocated buffer. Dynamically resized arrays are easy enough to implement that you can inline the implementation wherever needed. Hash tables are one of the few truly mandatory things on your list.
you know c++ and c# exists
Like others mentioned, jdoodle doesn't seem to expose a way to add flags to the compiler, so you can't pass -lm to link against the standard math library. I recommend you look for a different online compiler or, better yet, you install and learn how to invoke a C compiler on your local system. For other online compilers, I found [https://repl.it/languages/c](https://repl.it/languages/c) and [https://ideone.com/](https://ideone.com/). Both work with `sqrt` out of the box, so you don't have to manually link against libmath. Both sites give you an older GCC version, but for learning the language they're both good enough.
That would be news to me. Citation needed?
Vala
didn’t see that thread! will do!
I don't want to sound an evangelist ( really I don't), but perhaps it's time to learn there are a few really good alternatives to pure C, like C++, Rust and Go.
Thank you
thank you
Your other reply was the piece I was missing, thank you
Thank you
This was very helpful, I very much appreciate the thorough explanation. Thank you.
Not quite sure; but I think it's for reading and writing. Also see `fmemopen`.
Try running it with memory sanitizer or in debugger. Nothing is wrong on the first sight
Glad it was, the distinction of array and pointers is something that is seldom hammered onto by teachers and tutorials and it's very subtle, so I'm happy it was clear enough for you to understand :)
No segfault or access violation when I compile and run this code in GCC, nor should there be any, there is no undefined behaviour here and all memory accesses are sane. If you're getting a segfault with this code your compiler is not standard compliant.
&gt; Even though arrays and pointers are interchangeable in C they are not &gt; some compilers may consider an `int *` on the stack being used for something like p[2] to be a segmentation fault. Segfaults are runtime errors and do not depend on the compiler. There will be a compile error if you try to assign to an array but that's not happening here, a is accessed through an alias named p, and it is only read anyways. This code shouldn't segfault in a sane environment.
It's more like `*(string = string + 1)`
" however if I place the file within several subdirectories and then run," &amp;#x200B; What is actually giving the segfault in this case -- are you sure it's your executable?
Once you get to the point of adding a garbage collector to C, you're using the wrong language. The way you'd have to do it is through good discipline, and limit what you can do in the language. Here's a contrived, but trivial example. &amp;#x200B; { void *m = malloc(100); fprintf(somefile, "%p", m); } Okay, m is out of scope now. Can you garbage collect that memory or not? What if you read that memory location back in again using scanf? &amp;#x200B; The reason that higher level languages have the features they do is that people were using C and said, "Wow, wouldn't it be great if a language had these features that C doesn't?" And then they wrote a language. &amp;#x200B;
They can produce different results within the limits of the standard, and valid (as in no undefined behaviour) C cannot result in a segfault as far as I'm aware. What is possible however is that invalid C (i.e. invoking undefined behaviour) will segfault with some compilers and won't with others, or even with the same compiler with different optimization settings.
They differ in precedance and value. In post fix notation, (expr)++, expr is evaluated to a value and returned, then incremented by 1. In pre fix notation, ++(expr), expr is evaluated and incremeneted by 1, then returned. 
You clearly aren't running the above code. 
The standard way to parse options is with `getopt(3)` see the [man page](https://linux.die.net/man/3/getopt)
As I start reading it: strncmp("-", argv\[i\], 1) &amp;#x200B; Why not just check the first character? &amp;#x200B; Also -- why the global state array? Perhaps have a struct for options. &amp;#x200B; And just process a character at a time from the file as you read it -- no need to try to read a line and do something with the line. 
I see nothing wrong with the code. Something's probably wrong with your environment or how you compiled/linked it. It's hard to guess without knowing what you used or seeing the executable. Maybe if it depends on a .dll that's present on your desktop or the other folders for odd reasons, that'd cause that kind of behavior if it's the wrong version.
I wouldn't store the option values in commands[0], commands[1], etc. You should give more descriptive names. Maybe a struct with a field for each option instead of an array. As for the actual parsing, use a library. You could write your own (and it's a good exercise), but using a standard one improves readability. For something simple, there's getopt ("man 3 getopt"). If you someday need long options, there are getopt_long and GNU argp.
Will do, thanks.
i am reading character at a time using fgetc though.
&gt; whats the use of return 0; ? Your operating system is expecting the program to tell it if the program ran successfully. That's what the `return 0;` does: 0 means "everything went fine." There's a special macro `EXIT_SUCCESS` you can use instead of 0 if you want. Of course, you could return something besides 0 if something goes wrong. Anything non-0 will work for that, or you can use the `EXIT_FAILURE` macro. &gt; my programs run fine with or without it. It's optional. If you leave it out, the compiler will put it in there for you. Note, however, that this is unique to `main`. Any other function that claims to return a value should return something explicitly, or it will be undefined behavior to use the returned value when called. Compilers will warn you when you get this wrong (and if your compiler doesn't, turn up the warning level until it does).
ISO/IEC 9899:201x 5.1.2.2.3 Program termination ... reaching the } that terminates the main function returns a value of 0. ...
I think he means: argv[i] == '-'.
oh, yeah that makes sense.
i did look into this , i tried it out and it was getting confusing but i think youve explaned it alittle better ill give it another shot.
Try fixing the main function declaration to return an int, and return 0 at the end. You didn't specify a return type, so the compiler implicitly defaults to returning an int. Since you don't actually provide a return statement to meet that implicit return type, the compiler is using something unintentional from your call stack as the return code to your runtime environment. Maybe this isn't playing nicely. Longshot, but it's a fix you should make regardless.
Surely you mean `argv[i][0] == '-'`.
The others had already given answers for beginners. I just wanted to show the source of the behavior. I wasn’t trying to be a jerk.
You could have written your comment in a way that somebody who does not already know about this behaviour understands it, too. Right now, you haven't even cited a complete sentence and the chance that OP knows wtf ISO/IEC 9899:201x is is pretty low. 
Again, others had already given good answers. I intended my comment to be ignored if incomprehensible, or deciphered if the reader were so motivated. I meant no malice.
Why does it have to be in C?
As a wild guess, the OS X stdio implementation doesn't try to read from the underlying file descriptor again after a read fails once. You can test this by using `clearerr()` before every call to `fgetc()` and see if the behavior changes.
Thanks, that worked! Would you consider this a feature or a bug?
We're obviously missing something important. None of this should segfault. Also, There's no need for `&amp;a[0]`. `a` is already a pointer to stack data. You can just say `int *p = a;` and get literally the exact same assignment.
What do you mean by "not a secure language"?
because the rust fanboys that need their static analysis tools baked into the compiler like to conflate "secure" with "my compiler does way more than just compile"
Unless the standard explicitly describes what should happen (I don't know if it does off the top of my head), I think it makes sense to try reading again after hitting the end of the file in case something external added data that can now be read from the descriptor.
If we're going that way I'd say a more POSIX way to read files is unsing `int fd = open(...)` and then something like fgets / fgetc
The statement "\*(p+2)" is the violation. An int is 4B wide (usually). p is initialised to a[0] - "a" being 10B 
Okay, I've read the manual for `fgetc` many times but I've missed this crucial part: If the stream is at end-of-file or a read error occurs, the routines return EOF. The routines feof(3) and ferror(3) must be used to distinguish between end-of-file and error. If an error occurs, the global variable errno is set to indicate the error. The end-of-file condition is remembered, even on a terminal, and all subsequent attempts to read will return EOF until the condition is cleared with clearerr(3). I printed the values of `feof` and `ferror` before calling `fgetc` and `feof` always returns 1 after it hit EOF the first time and `ferror` always return 0. So it might actually be the libc version that Ubuntu uses that does this wrong. I have to investigate what `feof` and `ferror` return on the Ubuntu machine to be sure. I'll definitely read the manual a few more times than usual next time... 
Mostly because of the way it handles memory chunks. It allows memory to be copied without verifying the sizes of the chunks that are beging copied. This forces programmers to rely on each other not making mistakes and being adequately defensive from attacks. The most drammatic security breaches are caused by programmers who allow bigger chunks of memory to be copied to or from the their maximum sizes. Another issue with C is that it has several instances of undefined behavior. This gives the language flexibility, but can be a problem when trying to ensure big complex systems are secure. Read about the Debian fiasco. This is not to say that C is a bad language. Or that it shouldn't be used for systems programming, of course.
Rust is superior, we are everywhere
As with all languages, It’s not that the language isn’t secure, it’s that one can write less than secure code. You’ll see a lot of rust/java/ doesn’t allow x or something of that nature. Learn to write secure code and then it won’t matter. Also what is deemed “secure” is a point in time snapshot. No doubt rust and other “secure” languages have their fair share of vulnerabilities that we just haven’t figured out yet. 
Pointers to arrays point at the first memory location of the array, and as you increment the value of a pointer you're actually stepping along the array by setting the pointer equal to the next memory address.
Mostly because it doesn't have array bounds checking. When you write a program in C, you need to check your array bounds yourself. If you miss a spot, then an attacker can exploit an array overflow to put arbitrary data on the stack, and effectively take over your program. If your program runs with high-level privileges, or it's part of a service, then the attacker can take over your system. There are other weaknesses in C, but that's the big one.
Nah my dude. Segfault is when the kernel gets mad and asks you to leave.
Because its relatively easy for noobs to shoot themselves in the foot with it. Todays security is all about training wheels, side rails and padding on every surface so special snowflakes dont hurt themselves.
By secure you mean memory safe. Just because something is designed to be memory safe doesn't mean it is actually memory safe. Type confusion bugs are a great example of this, there's lots of oversight. No language is secure, it's only as secure as the developer is able to make it.
Well that’s a bit of a sweeping generalisation. Suppose you have a C project, and you suddenly need a feature that exists in, say, boost (and not in any alternative C library). Do you stick to your C purist position and implement the thing from the ground up, or put together a wrapper so that you can exploit the required functionality in boost?
You should have written it in crayon with smiley faces on it instead of directly quoting the ISO like a big jerk. Maybe he doesn't know that ellipsis are actually for when you are omitting surrounding text like that and only thinks they're for assholes. Best I can come up with. Thanks for quoting the actual standard though.
Well, lint throws "warning: old-style declaration or incorrect type for: main" and really, yeah, you should define a return type for main() as "int" or maybe "void". The pointer assignment there is fine. Sure, yeah, you can go right ahead and ask for the address of the first element of the array "a" and don't let anyone tell you otherwise. The compiler won't care at all and you get the exact same result even if you said "int *p=a;" however the human beings that read your code will be perfectly fine with "int *p=&amp;a[0];" which is clear. Try a little clean up : 1 2 #include &lt;stdio.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char *argv[]) 6 { 7 int a[10]; 8 for(int i = 0; i &lt;10; i++) 9 a[i] = 2; 10 int *p = &amp;a[0]; 11 printf("%d",*(p+2)); 12 return EXIT_SUCCESS; 13 } 14 That works fine everywhere. Also, yes, I did check with the compiler and line 10 is fine either way and the compiler doesn't care at all. Humans care. I prefer that you be clear in your thinking and thus line 10 is fine as it stands. 
&gt; we are everywhere If by "we" you mean people that submit "Have you considered rewriting it in Rust?" issues on GitHub, then yes.
Boost is an example where I would not under any circumstance let it get anywhere near my project. Boost is mainly a data structure library and heavily template based; I can hardly imagine a use case where a use of Boost is isolated to just a small area of the code and as such there is just no point in using Boost in a C project. Generally, introducing C++ code into a C project opens a huge can of worms, mostly related to portability and compatibility. It's just not worth it. That said, there are situations where using a C++ library is acceptable. It mainly boils down to these questions: * do we need any C++ code to use it? With well written C++ libraries, the answer should be “none” and using them is mostly fine. * if we need to write C++ code, how well can we isolate it from the rest of the project? If it boils down to writing a single file of glue logic and that's it, using the library is an option * does the C++ library register static initialisers or throw exceptions at us? These things (and others) cause side effects that you really don't want to have in a project that is otherwise oblivious about these possibilities, especially with respect to exceptions * does the C++ library require us to instantiate templates in our program? If the answer to this question is “yes,” then it's likely that the library cannot be updated independently from our program so using it might be a terrible idea from a maintainability point of view Notice how boost ticks every single of the “keep it away from the project” boxes. I wouldn't even use Boost in a C++ project to be honest. It has always been this huge pain in the ass everywhere it was used.
No, people who like rust. Not simple minded fanboys like you seem to think all of us are
What I complain about is that to someone who is not familiar with the C standard, the entire comment reads like gibberish. It's a proof to people who already know what's going on. For beginners, it's useless gibberish that makes them feel dumb if anything.
if you are more than a simple fanboy then I recommend actually showing it by leaving comments that are more than just trolly "lol rust r better"
That’s what it’s in. I as a solo developer do not have the time to rework this entire price of software and still hit the delivery deadlines. 
Like so many things, it comes down to cost versus benefit. I used boost as an example because I’ve incorporated a few components of boost into a legacy C code base in the past, and the various issues you mention, while valid, were more than outweighed by the benefit of being able to leverage existing tried-and-tested code which would otherwise have taken a lot of time and effort to write from scratch. YMMV, as they say.
Why is that?
&gt; legacy C code base why is C legacy?
Just wondering, since when are ellipsis for assholes?
Mostly when people say things that they think are obvious, even if they aren't. "You should've know that..." "It's on the first page..." Things like that. I'm sure you've seen it and it can be pretty off-putting.
Because if you try to detect overflows like this: int stupid(int a) { return (a+1) &gt; a; } the compiler will optimize it to return 1 always. And there are many cases like this: https://blog.regehr.org/archives/213 
It’s a legacy code base, which was originally all C (there was no decent C++ compiler for the target hardware when it was first written). Over the years new features have been added, some of which have leveraged C++ libraries, in order to save development time and effort.
Ignore him. getopt is already in POSIX.
Yes, I have seen those uses. I just thought those people were using it incorrectly. I didn't realize they were using it to be extra obnoxious.
In `print_fc`, instead of using `getchar` for the standard input case, you can just assign `stdin` to `f`, which will simplify the code (just don’t close standard in). Also if you are targeting Linux, you can use [`sendfile`](https://linux.die.net/man/2/sendfile) to do a more efficient copy (just note that you need kernel version 2.6.33 to have the out fd be anything other than a socket)
There's a difference between saying, "C is legacy" and "legacy code base." &amp;#x200B; If you have a code base that, today, you would have chosen C to implement it in, then it's not legacy at all. If you would pick some other language to write it, that makes it a legacy code base -- especially if a rewrite has already started.
You misread him, he's talking about reading files.
As of C99, main implicitly returns 0 if you don't have an explicit return statement. Even if he's using an older revision of C, I wouldn't expect that to segfault because every arch I've ever seen uses a general-purpose register for return values, so the worst-case scenario would be that it returns whatever garbage data happens to be in the register.
Can you name some of your favorite static analysis tools for C? 
Show us the command used to link your program and the error message.
scanf
I believe some compilers don't add this, and so the program will return a random number.
Yes.
This is the required behavior as of (IIRC) C99. If your compiler doesn't default `main` to returning 0 then it's either out-of-date or not standards compliant.
Perhaps we should also include a tutorial on using a debugger. Something like https://cs.baylor.edu/~donahoo/tools/gdb/tutorial.html After all, you can't ask Reddit to solve all your programming problems.
it's Windows x86-64 Tiny C Compiler. Which is mostly C99 compliant. But apparently not for this.
Tiny C Compiler has a built in memory and bounds checker compilation option, if that counts.
That's very strange, to be trying to even partially support C99 and neglect this really low-hanging fruit.
I believe you are doing a lot of things wrong, but the main one in this case is that you have to convert the string into a number -- likely using atoi() for simplicity instead of casting.
You can't convert a string to an int with a cast. Use the `strtol` function to interpret the string
 for(init_statement; conditional; iterator_statement) { statements... } is the same as: init_statement; while(conditional) { statements... iterator_statement; } do...while is the same as while, except the conditional is evaluated at the end of the loop instead of the beginning, meaning a do...while loop will always run at least once.
Syntactic sugar, really. For loop has a loop initialization statement, the loop conditional, and the period-end action statement. The while loop and do-while only contain the conditional, so you need to put in the loop initialization and period-end action yourself. The for loop and while loop evaluate the conditional before entering the loop while the do-while evaluates it afterwards, so it's possible for the first two to not enter the loop at all, while the do-while executes at least once. Other than that, they're the same thing, and compile to the same code. Which one you want to use depends on what you're doing.
A continue statement will skip the while loop's iterator_statement but not the for loop's iterator_statement.
Is this just for practice/self-edification? I was under the impression that all of the GNU core utils were already written in C. 
If you use `fscanf` it makes it easy to use either a file or stdin bases on args.
FreeBSD too. I did something similar awhile back as an educational exercise. It was cool to look at how GNU and FreeBSD did things differently in tools with the same purpose.
Without the error message it's impossible to know. Off the top of my head it could be that your libraries are in a different location at home vs at school (assuming Linux). If you're on Windows then I have no idea.
You can compose conditions with Boolean operators || (or), &amp;&amp; (and) etc. look up &amp; read about Boolean operators and Boolean algebra generally.
Oh, then by oh means, carry on, fren. 
Yeah, it was kinda ambiguous, I've heard this phrase also be used as "*legacy C* code base" instead of "*legacy* C code base". It comes down to the emphasis, hence my question.
so is any there anything like if i place my cusrsor on a variable name and it will highlight its type we have used in our code at the same place???
Dude, pls add the code to the post and don't tell the code.
What’s the code? Show us what you have so far, we’ll help you, just not write the whole code for you lol. 
Easiest to setup is probably the ctags support. Simply run ctags -R in your project root and start vim from that directory. Then you can use ctrl-] to jump to definitions and ctrl-t to jump back to where you were. You'll have to re-run ctags -R to update it. There's probably a command to show the definition in the status bar as well but I don't know it by heart. This is more of a vim question than a C question though... might want to try a vim subreddit for more help. There's probably several other ways to set it up. You can also try [i or [I but I don't really use those so I don't know much about them.
There's the easy way: Use an IDE, and there's the hard way with vim: Install something like [YouCompleteMe](https://valloric.github.io/YouCompleteMe) / ctags.
Interesting, thanks!
r/vim for the vim subreddit.
Lots of people don't seem to be aware of using the `,` operator in C to chain statements like this.
If you can't somewhat easily see your variable declarations, your functions are way too long. Functions should be around 60 lines ideally. If you're using at least C99 you don't need to declare every variable at the start of a block: you can declare them as close as you want to where you need them. E.g. loop iterators defined inside the loop construct ( for(int i = 0; ...) ). To have a reference for function and struct declarations in vim I recommend using splits, either vertical or horizontal.
This is a subreddit for C, not C#. The two languages are completely unrelated.
Here's a sneak peek of /r/csharp using the [top posts](https://np.reddit.com/r/csharp/top/?sort=top&amp;t=year) of the year! \#1: [What's the difference between Value Types &amp; Reference Types](http://www.mathwarehouse.com/programming/images/pass-by-reference-vs-pass-by-value-animation.gif) | [58 comments](https://np.reddit.com/r/csharp/comments/98ydqr/whats_the_difference_between_value_types/) \#2: [How to make your users love you 101](https://i.imgur.com/aUIJYKk.png) | [30 comments](https://np.reddit.com/r/csharp/comments/99kh95/how_to_make_your_users_love_you_101/) \#3: [Microsoft announces Visual Studio 2019](https://venturebeat.com/2018/06/06/microsoft-announces-visual-studio-2019/) | [200 comments](https://np.reddit.com/r/csharp/comments/8p39se/microsoft_announces_visual_studio_2019/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
What is the difference? 
One is sharp and the other one isn’t. No but really though they are two different languages.
I just said that since this is not the right sub to ask. This is a sub for C, not C#. Just trying to point in the right direction ^^
&gt; The standard way to parse options is with getopt(3) It's *amazing* how many commands implement their own parser.
Why are you polling IO in the interrupt instead of just using pin change interrupts?
The size of the file will be the size of the data type you're writing to the file, so in this case, the file will be 4 bytes. (Make note that some compilers/systems/languages will interpret a signed integer as 2/4 bytes)
I can still try ! 
That's the spirit.
2 bytes, you writing two chars and each of this chars is 1 byte, because it's string not int you writing in file.
If `ld` returns an exit status of 1, that means it failed to link your program. `ld` always gives an error message in this kind of situation which you can read to find out what the problem is.
Nope, OP is writing text to the file; as /u/BarneyStroustrup already said, at the end of the day the file is going to contain the two bytes `"12"`.
If button one is pressed and was previously unpressed use not(start) Then if button 1 is not pressed mark it as released If button 2 is pressed reset counter and set start to 0
What have you tried?
How do you it is not an int? 
Nothing
Then try to do this on your own and come back when there is something you are stuck on. Nobody on this subreddit is going to do your homework; it's your job to do your homework, not ours.
Because you open the file in "wt" (write text) and the fprintf will convert the int to a string represantation and write that to the file. if you want to write the byte values of the int to a file open it in "wb" (write binary) mode and have a look at fwrite
&gt; FILE* fp= fopen("a","wt" ); &gt; fprintf(fp,"1%d",num); &gt; Can I assume anything about the size of the file it is suppose to create? That depends how formal you wish to be. "A text stream is an ordered sequence of characters composed into *lines*, each line consisting of zero or more characters plus a terminating new-line character. **Whether the last line requires a terminating new-line character is implementation-defined.** Characters may have to be added, altered, or deleted on input and output to conform to differing conventions for representing text in the host environment. **Thus, there need not be a one-to-one correspondence between the characters in a stream and those in the external representation.**" (7.21.2#2)
You might find this interesting: https://youtu.be/MCuzvy79WWQ
Please fix the formatting of your code.
Sorry kid, it’s your thread - you bear the burden of reading every response; not everyone else. When someone is kind enough to respond (dup or not), say thank you. Telling someone that spent time trying to help you that they wasted space is tactless and a good way to lose out on further feedback. P.s. extra credit or not, it’s still part of your homework assignment that your asking others to help you solve. When I was first starting, the common refrain was RTFM or RTFC - so be happy that you get dups. 
Got it, Thanks man
Thank you very much dude
To add to this excellent description, `strlen` does *not* count the terminating zero. So `srrlen("no more") ` will return 7.
What happens when you try to compile it?
OP does know this; he explicitly wrote: &gt; in the end I have ''no more'' string, strlen for which is 7
The question was _what_ have you tried, not _did_ you try.
U can use a lightweight IDE like vscode 
Thank You 
nothing, there is an error. But the question is whether there is an evaluation from left to right occurring or not. 
What are you asking? C always evaluates tokens from left to right.
&gt; If you're on a 32 bit platform sizeof will return 4. Only if you pass a type with a size of 4 bytes. An array of 10 chars has a size of 10 bytes, regardless of platform.
&gt; If you're on a 32 bit platform sizeof will return 4 No. It will return the size of the type (or rather be replaced inline with the size of the type at compile time) in this case the type of str is char[10] so it will be 10.
Note that OP is taking the size of an array here of chars here. This should not be affected by 32 or 64 bits.
If there's a syntax error, then your question is kind of meaningless. It's not valid code, so you can't really say what would happen. Now, if you're asking the question, what would happen if the second argument happened to be "++num || 1" instead, then the answer depends on operator precedence. Operator precedence says that ++ is evaluated before ||. Also, || is short-circuit evaluated, which means that if it's left operand is non-zero, the right operand doesn't get evaluated. So, in this case, you'd perform pre-increment on the variable "num". Its value would be updated to 6. And then that 6 is used as the left operand of the || operator. And since 6 in no-zero, the || operator evaluates to 1 (note that that's not the "same" 1 that's on the right-hand side). It might be interesting to note that the optimizer will likely realize that regardless of whether or not "++num" evaluates to non-zero, the 1 on the right-hand side of the || operator will guarantee the result will always be 1. So an optimizer might translate the call to something that looks more like this (though in machine code): ++num; printf("%d\n", 1); 
No it doesn't. You have operator precedence to account for. For example, "2 + 3 * 5" evaluates to 17, not 25. Also, evaluation order of operands is undefined. For example "f() + g()" can invoke f and then g or g and then f - whichever order the compiler decides.
I said evaluates tokens, i.e. ++i will evaluate immediately because it is a complete token, but "2 + 3 * 5" is an expression, not a token, and will only evaluate once the expression is considered to be understood as complete.
&gt; in this case the type of str is char[10] so it will be 10 This is because sizeof(char) is defined to be 1, even for weird platforms where the size of a char (CHAR_BITS) is not the usual 8 bits. Just felt the need to clarify that. You are correct, of course.
yes, all other sizes are relative to the size of a char.
 Dont quote me on this But i think that the only reason that sizeof returns 10 is because you called it in the same scope of its declaration. If for example you passed that array into a function, sizeof would instead return the size of the pointer. 
timer2 is being used as a debounce for two button inputs. Button 1 is used to start and stop the counters `cs` and `s`. Button 2 is a reset for the variables `cs`, `s`, `min` and `start`.
This question doesn't have much to do with C. In any case, figuring out the size of non-monospaced text before you've rendered it is extremely complicated – possibly impossible if you can't control the exact environment you're going to render in. What if somebody wrote "iiiiiiii" as opposed to "MMMMMMMM"? There's 8 characters in both, but the second is much larger. You'd need a table with the width of every character in the font you're using (including [kerning](https://en.wikipedia.org/wiki/Kerning) and [ligatures](https://en.wikipedia.org/wiki/Typographic_ligature)) – and that's assuming the person viewing your image even has that font installed. What if somebody includes "﷽"? That's a single Unicode character with huge differences in size depending on what font renderer you're using. What if somebody entered a newline? A vertical tab? Or any other of the 5613 Unicode characters that do funky things with the text? One possible (but extremely ugly) solution would be to have a piece of JS embedded in the SVG that resizes either the text or the box after the text rendering is done, as the actual size is available by then. Another is to do a rough strlen() of the text and then use that to scale the box multiplied with the average letter width, cropping anything that falls outside with `overflow=hidden`. It'd hardly be a dependable solution though.
The `def(num)` line is equivalent to int i; for (i = 4; i &gt; 1; A = A * --i); So A gets multiplied by every int less than it (24 = 4 x 3 x 2 x 1).
Because the compiler will allow you to do things that are "unsafe", like accessing memory that has not been explicitly allocated by your program. I don't consider this a fault of the language or the compiler. I have written a lot of cheats and cracks, and doing so in a language other than C would be a nightmare. The fact of the matter is that this business with "safe" and "secure" native languages has really been a fad for the last few years. And ultimately, any native application, regardless of the compiler or language, has the same capabilities as an application written in C. Just because the compiler for Rust or Crystal (especially this one, it's U L T R A strict) don't allow you to write code that does something wonky (like jumping to code on the stack) doesn't mean they prevent the underlying architecture from allowing it.
PVS Studio
&gt; Todays security is all about training wheels, side rails and padding on every surface so special snowflakes dont hurt themselves. As much as I try to avoid espousing opinions like this one, this really is more and more the case. That being said, I would phrase it differently. I think this is all a byproduct of "pop coding" and increasing accessibility of development resources. It's unfortunate to think that the increasing popularity of programming has been spurring on attacks against systems and practices that have historically not been problematic. I would certainly hope that's the case, as I would like to see more computer literacy. Unfortunately, rather than developing computer literacy in individuals, we seem to be lowering the bar.
4 to 1
Yeah, there's a lot of inexplicable reinventing the wheel. My only guess as to an explanation would be that one of the platforms targeted by the developer has a poor getopt(3) implementation. I can't imagine ignorance of getopt, as you are bound to run in to it if you start trying to implement your own parser.
i=4 (4&gt;1 enters loop) a=4\*(4-1); i=3(3&gt;1 enters loop) a=(4\*(3))\*(3-1) i=2(2&gt;1 enters loop) a=((4\*3)\*2)\*(2-1) i=1(1&gt;1 is false so it comes out of the loop.)
Aside from the other stuff, bear in mind that you’ll see all kindsa crazy shit in the wild, including `int`-to/from-pointer casts, but the only mostly-safe, warningless cast between pointer and integer uses `uintptr_t`—which IIRC doesn’t need to exist per standard, but pretty much always will. If you lack `&lt;stdint.h&gt;` or `uintptr_t`, you can *usually in practice* use an `unsigned long`. But yeah, just casting the pointer does nothing and isn’t what you want. You’re treating a memory address as an apparently-smaller (guessing you’re targeting x86-64?) signed(!) integer, so the value you get is (and is allowed to be) thoroughly useless.
You can debounce in the pin change interrupt just the same.
&gt; i gets increased Let's start with the difference between i++ and i-- &amp;#x200B;
There's 2 different `n`s. You can rename one of them for clarity int foo(int x, int n) { while (n &gt; 0) { int static N2 = 1; x *= x; --N2; } return x; } So this is an endless loop. `n` is never changed, so it will always be greater than 0.
"++i" is two tokens: the "++" operator and the variable "i".
 `!||` doesn't make sense and this won't compile. With `||` the left hand side is evaluated. Only if the left hand side is false will the right hand side be evaluated.
`++num!||1` is not valid code and should not compile. The `!` is especially strange. I hesitate to answer your question since it might depend on what the correct code should look like. Instead, I'll refer you to the [c operator precedence chart](https://en.cppreference.com/w/c/language/operator_precedence), because not everything is simply left-to-right.
Strongly recommend doing `fgets`, then tokenizing the string you get. You can do enum token_type { TT_ERR = -1, TT_EOF = 0, TT_LPAR, TT_RPAR, TT_COMMA, TT_IDENT, TT_KW_ADD, TT_KW_SUB, TT_KW_EXIT, // etc. }; struct token { union { struct { const char *start, *end; } string; uintmax_t integer; } value; enum token_type type; }; First you separate operators, integers, alphanumeric “identifiers,” and whitespace/end of line. Assuming you’re processing ≤1 line at a time, you can leave `value.string` pointing into the source string. Once you have identifiers, convert to whatever official operator token type (e.g., `TT_IDENT` → `TT_KW_EXIT` for `exit`) if you recognize them; if it’s an error otherwise, break then. Once you have tokens (you can just do an array), you can parse the expression out very easily.
You've posted 3 questions now in a few hours all along the lines of "what does this code do", and given they're missing a return type for main(), I'm guessing you're copying from some ancient textbook? Have you tried to figure these out on your own at all? This one you obviously didn't even try to compile...
Fair enough but the point still stands, no need to be pedantic
&gt; As much as I try to avoid espousing opinions like this one, this really is more and more the case. That being said, I would phrase it differently. I did this on purpose, marrying my disdain for the rising political correctness culture and the "security" culture, in an attempt to show that its a larger societal problem, not just programming. You are absolutely right though, its always like this in the tech sector of shitting all over the old thing to prop up the new thing. Maybe because the new thing is unable to stand on its own? ;) 
Even without !||, a logical a OR of integers using a %d format string doesn't make sense. I imagine it's undefined even though it might print 1.
|| evaluates to an integer, so %d is right
The result is well-defined. Remember that C didn't have `_Bool` for the longest time, so `||` with integers is intended to work. It's explicitly defined as producing the value 0 or 1, and it's just fine to use `%d` on that integer.
&gt; Its always like this in the tech sector, of shitting all over the old thing to prop up the new thing. I just want to know where it all came from. It's been a whirlwind. One minute everything is fine, the next minute you're being poo-pooed off of the gnome bug tracker for daring to ask where type-ahead went.
Try using a language without `a += 1` or equivalent. Then you'd understand.
The increment and decrement operators were created for convenience because they are rather common.
Two things: 1. When conditions are tested and updates happen. There’ve been some “is the same as”es in this post; they’re not strictly true but the translations are close enough. 2. What `continue` does. This *is* different for `for` loops. A `continue` in a `for` loop will jump to the update, then run the condition normally; a `continue` in a `do`/`while` or `while` loop will jump straight to the condiition.
It was probably [inspired by a PDP-7 feature](http://www.bell-labs.com/usr/dmr/www/chist.html): &gt; People often guess that they were created to use the auto-increment and auto-decrement address modes provided by the DEC PDP-11 on which C and Unix first became popular. This is historically impossible, since there was no PDP-11 when B was developed. The PDP-7, however, did have a few `auto-increment' memory cells, with the property that an indirect memory reference through them incremented the cell. This feature probably suggested such operators to Thompson; the generalization to make them both prefix and postfix was his own. Indeed, the auto-increment cells were not used directly in implementation of the operators, and a stronger motivation for the innovation was probably his observation that the translation of ++x was smaller than that of x=x+1. 
I heard it was because punch cards were a bitch and `++` was way easier than `a = a + 1`
[They] were so preoccupied with whether or not they could, they didn't stop to think if they should. 
this question doesn't fully make sense. Typically you would create your own data structures in C, while C++ offers a lot of off-the-shelf data structures via STL. &amp;#x200B; &amp;#x200B;
&gt; What’s the difference of Data Structures in C vs C++? The languages LoL.. No, really. &gt; Are they even different? Do you know data structures is language-agnostic field?
That’s why I came here to ask, so no huge difference.
There can be, but generally they're not related to the language, but to small engineering trade-offs in order to tune it them to solve different problems.
Can you give me an example of a data structure? 
Then the answer to &gt; is evaluation \[occurring\] from left to right is "it's not" &amp;#x200B;
And you'll probably get some static analyzer yelling about variable shadowing
I love this question so much because there's a fundamental misunderstanding embedded within it which is hard for me to really put into words. I guess its sort of like asking "whats the difference between a program written in Java and one written in C" 
Thank you very much!
&gt; An operator like ++ at the C level allows a C programmer to take advantage of the optimized instruction set of these microprocessors. Not arguing against `++` here, but `+= 1` and `a = a + 1` are fairly easy patterns to spot and simplify at the optimizer level, or even the parser level. I would expect that only the most primitive compilers fail to do this. Also, &gt; Because every ASM instruction takes the same amount of time (1 clock cycle) This is not true on _some_ architectures. There exist scenarios, particularly on x86 (which I am most familiar with) where more than one instruction may be enqueued and completed per cycle. Additionally, there exist scenarios where an instruction may preoccupy an execution unit for more than one cycle. For reference, [this is the document I'm basing these statements off of](https://www.agner.org/optimize/instruction_tables.pdf). To quote the above, &gt; Reciprocal throughput: This is also called issue latency. This value indicates the average number of &gt; clock cycles from the execution of an instruction begins to a subsequent inde- &gt; pendent instruction of the same kind can begin to execute. A value of 1/3 indi- &gt; cates that the execution units can handle 3 instructions per clock cycle in one &gt; thread. However, the throughput may be limited by other bottlenecks in the &gt; pipeline. Picking a random architecture, in this case the first one in the document - `AMD K7`, you will find instructions that execute in less than one cycle (meaning that another instruction may begin executing within the same cycle) as well as instructions that execute in as many as **188** cycles (e.g. the next instruction will be executed after N cycles). Even better, because post-modern CPUs are more akin to virtual machines than actual CPUs, there could _theoretically_ exist situations where the execution time is indeterminate and can only be measured after having executed the instruction.
You could write it as s -= 1; t -=1; while (*(s += 1) = *(t += 1)) ; Although admittedly that is hacky. But the former version is also sort of hacky too I guess.
The sizeof wouldn't change, your str variable is still 10 characters long, so you end up with 10 - 7 which is 3.
No, we were all using keyboards back then, and keypunches had the same keyboard layout that terminals have.
`--i` is the same as `i = i - 1`. So I gets overwritten every loop until it equals 1
What does it do, and what have you tried? First step would be to read the documentation for scanf. 
Oh, good to now: I was told the bit about punch cards or something like it over ten years ago in a college, so I could easily be remembering it wrong. 
If I am reading it right, on some of the tokens there is a number for column and row and on others there is only a number for row?
https://www.youtube.com/watch?v=jAdspOtgciQ
Your format string doesn't match your data. The first `%d` is obviously there to grab the column number, but it only exists one time per data set. So you can use this to read the first entry, but nothing else after that. I see two ways of solving this. The first is to tokenize the input (maybe using `strtok_r`). You might already be doing this, since there's a variable named `token`. Then, you do a simple `sscanf` on the first token to get the column number, and put another `sscanf` with the format string `"%d/$s"` in a loop to get all the rows and actions. The second way is a bit fancier. `sscanf` naturally ends on space boundaries, so let's use that. You'll still want to explicitly read the column in a separate step. For the loop, instead of tokenizing you use the `%n` format specifier to determine the end of the last action read, and then offset your input string with that offset the next time through the loop. I actually like that second version, it's clean and efficient. I like how it looks as a `for` loop: int offset; sscanf(text, "%d%n", &amp;dcolumn, &amp;offset); for ( int pos; sscanf(text + offset, "%d/%s%n", &amp;row, action, &amp;pos) == 2; offset += pos; ) printf("Column: %d row: %d action: %s\n", dcolumn, row, action);
I don't know why no one is giving you some sort of concrete answer, since it's pretty simply. C doesn't include a standard set of data structures. Most systems include some, however. Try (at the shell): man 3 queue ... for instance, and compare that API (you can see implementation by opening /usr/include/sys/queue.h) to, say the C++ STL implementation and API for list and queue. Obviously if you want to fully understand differences in both structure and use, it helps to know both C and C++ reasonably well. 
I used punch cards my first year in college (my school was on the trailing edge of technology.) I actually learned to program an 029 keypunch so I could type faster. Those bloody cards were 5¢ each. Imagine being charged 5¢ for each line you typed into a terminal. This reddit post has cost me $.30 already. But even then, I don't think saving a few characters by typing "a++" instead of "a = a + 1" would have been worth it just to save on punch cards. I first saw the "a++" and "--a" idioms shortly after learning to program the PDP-11. My thought at the time was "I see where that comes from; how elegant". Those idioms really do have their place in any modern language.
This subreddit is for C, not C# - even though their names are similar, they're completely distinct and vastly different languages. I'd recommend /r/csharp instead.
Oh, I just thought because of the names, I’m sorry but thank you.
Hey Charlie, This is a subreddit for C, rather than C# (similar names, but really rather different languages). You're probably best off asking on /r/csharp -- maybe check the sidebar for their suggestions first (particularly "[C# Fundamentals: Development for Absolute Beginners](https://mva.microsoft.com/en-US/training-courses/c-fundamentals-for-absolute-beginners-16169?l=Lvld4EQIC_2706218949)" which looks like it might fit the bill for you!). 
Thanks a lot, I will have a look now. 
My guess is that OP needs to install some library or another. We'll need to see the error message.
&gt; But even then, I don't think saving a few characters by typing "a++" instead of "a = a + 1" would have been worth it just to save on punch cards. IIRC it wasn't to save money, it was that typing anything was a pain, so they tried to make everything as short and concise as possible. Honestly, thinking back on it, it kind of sounds like a weird retelling of why so much of C's commands are in shorthand: limited hardware resources. Hell, it might not have even been punch cards, I just remember it was something hard to type on--I was very new to programming back then so I could have easily misunderstood my instructors uhh anecdote(?). 
Let's put it this way size of evaluates the size of data-type of the variable, in this case to 10, size of array. strlen evaluates the length of string vitz, finally is 7. 
hello all, i have to create this program using a while loop for my C class. been about three days trying to figure it out on my own, so i resorted to trying to look it up online. i have found it on line, but every source uses a for loop, which we haven’t learned yet, and i don’t understand which variables they’re using and so forth. anything helps, thank you for your time :)
What’s your problem?
Or as a co-worker would always say: Increment and Dincrement. Never intentionally.
Let’s imagine you use an integer called i in your while loop, and for each iteration of the loop, you increment i. You would have something like int i = 0; while (i &lt;= 6) { //Do things i++; } Does that give you a hint?
well yes, this is as far as i have gotten more or less, i know that there should be a variable for the rows, but i don’t know how to construct the variable that counts the numbers that way.
A for loop is very much like a while loop. for(i = 0; i &lt; N; i++) { statement1; statement2; } is equivalent to i = 0 while(i &lt; N) { statement1; statement2; i++; } 
so then i could make another loop that states that as long as “S&lt;=i” then it would print out spaces?
these loops be crazy
How do people write generic data structures in C? Cast to void*? 
Both functions are somewhat out dated in the real world. Firstly the "sizeof" thing is not really a function at all. The compiler will compute whatever "sizeof" should be and stuff the result into the output assembly language and then the assembler and linker just take that in a literal values. There really is no such function as "sizeof" and you won't find it in any header anywhere. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc,char *argv[]){ size_t k = sizeof(unsigned char); fprintf(stdout,"%d\n",k); return EXIT_SUCCESS; } Take the above and ask gcc to output assembly language on whatever machine you are on : $ gcc -m32 -march=i386 -mno-default -std=c99 -S -o h.s h.c Then look for a call to the function sizeof. You won't find it. It doesn't exist. $ cat h.s .file "h.c" .text .section .rodata .LC0: .string "%d\n" .text .globl main .type main, @function main: .LFB1: .cfi_startproc leal 4(%esp), %ecx .cfi_def_cfa 1, 0 andl $-16, %esp pushl -4(%ecx) pushl %ebp .cfi_escape 0x10,0x5,0x2,0x75,0 movl %esp, %ebp pushl %ecx .cfi_escape 0xf,0x3,0x75,0x7c,0x6 subl $20, %esp movl $1, -12(%ebp) movl __stdoutp, %eax subl $4, %esp pushl -12(%ebp) pushl $.LC0 pushl %eax call fprintf addl $16, %esp movl $0, %eax movl -4(%ebp), %ecx .cfi_def_cfa 1, 0 leave .cfi_restore 5 leal -4(%ecx), %esp . . . However look closely and you will see the literal value 1 being stuffed into some memory region that is 12 bytes less than the contents of the register %ebp. That is the literal value one for one byte. That is the sizeof(unsigned char). Change the code : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc,char *argv[]){ size_t k = sizeof(double); fprintf(stdout,"%d\n",k); return EXIT_SUCCESS; } So now we have sizeof(double) in there. movl $8, -12(%ebp) Run the code and you will get 8 as your output. There never was a call to sizeof and there never will be. So that leaves strlen() which isn't very helpful in the real world where unicode and utf-8 character strings are everywhere and they are the norm. We have to stuff them into database records and fetch them later and strlen() is really not helpful at all. 
Just to add on, Sizeof is a macro, run by the preprocessor. Which means that as far as the compiler is concerned the value returned by sizeof is a compile time constant.
sizeof is not a preprocessor macro. It is an operator. While you are correct that it is generally evaluated at compile time, it can be evaluated at run time, for e.g. VLAs.
sizeof is not a macro (nor it is a function). It is *not* run by the preprocessor. It is an operator, similar to how `!` and `~` are operators. And /u/lank3y is crazy if they think strlen and sizeof are "out dated" or "not very helpful in the real world". strlen() is fantastically useful wherever Unicode is used: it tells you the number of bytes used by a string.
I've written my own, and i cast to a void* and track the size of the object to do it.
That's not your problem It is perfectly valid with : int *p = malloc(sizeof(int)); free(p); int *q = malloc(sizeof(int)); for p and q to have the same value. Show your code.
You should post your code, or at least a mock up of the code. This will help people understand what you are doing. But from the sounds of it; I would create two functions, one that returns a pointer to a struct and takes as arguments the primitives you wish to store in the struct. This function can handle allocating memory for your structs. A second function takes as an argument a pointer to a struct and frees any allocated memory on the struct and the struct itself.
As an example, Ill use a 'head' struct that stores basic info on the data structure and a pointer to the first 'node' struct. 
Yeah just went out for dinner so I can post some for the code when I get back. The struct has three char * and one int. I use the character pointers to hold the strings of text I read on each line.
hrm interesting. I guess that incur a very small probably almost negligible run time overhead, no?
When you pass the pointer back to the caller, are you passing a pointer that points at the stack or at the heap? The stack frame of your function is cleared on return, but heap data isn't, and the caller can be passed back a pointer to data there. If your structs are statically sized, you don't even need to pass back a pointer, you can return the entire struct, though this may carry overhead.
Strings are 1 dimensional arrays, not 2 (like in my example, tho it's not at all obvious) so you would need to free them when you free'd the struct, but you would not have to loop over the strings contents to free it. example: typedef struct idk { int one; char *string1; char *string2; char *string3; } idk; void idk_Deinit(idk *wat) { if (wat != NULL) { free(wat-&gt;string1); free(wat-&gt;string2); free(wat-&gt;string3); free(wat); } }
Why didn't you just compile the c++ program on a similar machine then move the binary to your servers?
I updated the post with some code. My problem is kind of like your example, but I was trying to use p after freeing it. 
Maybe it was just the way I implemented it, but I think that is the general idea of what I tried to do (without the two functions, though). I just don't have a perfect grasp of the whole struct and pointer thing yet. I updated the post with some code. 
I updated the post with the problematic code. I think I am passing pointers that point to the heap, but I could be completely wrong. I honestly don't know if my struct is statically or dynamically sized, as I don't have a perfect grasp of pointers. I would assume they are statically sized, but I could be wrong.
I was curious about that ( from time to time ) as I am about many little things. So let's kick out the pre-processed source and have a gander : $ gcc -m32 -march=i386 -mno-default -std=c99 -E -o h.i h.c $ grep -v "^$" h.i | grep -v "^#" | cat -n - | grep "sizeof" 420 size_t k = sizeof(double); So it is still there in the pre-processed source. That h.i file is 427 lines long once the blank lines and comments are stripped out. Results in the exact same assembly of course. 
If I had an instance of the struct in your example that was not a pointer, could I then deallocate the whole struct using `free(idkInstance)` , or is it always necessary to deallocate all of the variables within a struct individually?
All of the Sco servers I can access at work don't have CC installed, so I don't really have access to any similar machines with the compiler. I also tried compiling it on one of my computers running Linux, but couldn't get the binary to run on the Unix servers. Some basic knowledge of C might come in handy later anyway. 
holy moly I keep getting things wrong today
Thats because the array size can be infered from the struct definition right?
C is not umbrella term for all the Cs ;)
I don't think this is done much. Usually one creates a structure and the functions which operate on that. But indeed, like the sort function you could pass a void * and cast it to your type. If you have only a subset to support you could also use a union of the values to pass as an argument. You could of course recreate a lot of c++ functionality in c but personally i think this is usually overkill and makes things unnecessary hard.
Why did they implement `if` statements if you can just use inline assembler and some `jmp`s?
Because of this, you can reassign an array that is a function parameter (whereas normally you cannot reassign an array): https://ideone.com/v19tWu
Looks like you need newlines in your `printf`s too. They're all gonna print on the same line if you don't include a `\n` at the end of your string. If you're not actually formatting strings, you should be using `puts` instead of `printf`, it adds the newline for you automatically and has less overhead. The struct is statically sized because its size is always the same. `sizeof(struct lineData)` is `3 * sizeof(char*) + sizeof(short)`. If you had something in there like `char message[];` then it'd be dynamically sized, because you could have structs of varying size depending on how big each one's `message[]` was. There are several things that I notice, so I'll step through one by one. I pastebinned your code [here](https://pastebin.com/MXpbCdm5) so that I could have syntax highlighting and line numbers. The line numbers I'm using are going to be offset from the line numbers in your real code because you left out your `#include`s (which is fine). First thing I notice is you do this: fpr = fopen(fileNameIn, "r"); if(fpr == NULL){ This isn't actually *wrong*, it works perfectly fine. However, I find it more readable and more concise to do this instead, which works the same: if((fpr = fopen(fileNameIn, "r"))== NULL){ Second. On line 32, you make this call: sprintf(temp1, "%d", count++); `sprintf` takes a pointer as its first argument. Then, it writes a string to wherever the pointer is pointing at. So if the pointer is pointing to a buffer of size 1024 bytes, you can safely write a string 1023 characters long, plus 1 byte for the NULL terminator. But `temp1` isn't pointing at a buffer. In fact, it's not pointing at anything. You created it here on line 4: `char * temp1;`, but then don't do anything with it until your `sprintf`. Writing data to a pointer that hasn't been initialized (assigned a value) is **undefined behavior**, a technical term which means "bad and you should not do it because it might break the universe, or at least probably your code." You make basically the same error on the next line, with *temp = 'd'; Since `temp` is also an uninitialized pointer, and trying to write `'d'` wherever it's pointing, this breaks. strcat(temp, temp1); Breaks for the same reason. You're attempting to write whatever `temp1` is pointing at to the end of wherever `temp` is pointing at. First thing I would do is fix your pointers. What you need to do that is make buffers that you can actually write stuff into. One tricky thing about C is that `char[]` and `char*` are actually the same thing by different names. If you make a buffer of size 1024 with `char buf[1024]`, then `*buf` is the same as `buf[0]`, `*(buf + 1)` is the same as `buf[1]`, etc. The `[]` indexing syntax is essentially a syntactic sugar to make your life easier. All that `char buf[1024]` does is make a buffer that can fit 1024 `char`s in it and make `buf` a pointer to it. What you should do first is figure out a reasonable max length for the kinds of strings `temp` is going to be handling. I'll assume it's 64 just to make my life easier so I can give you an example. char temp[64]; - while(currentLine = getLine(fpr)){ temp[0] = 'd'; snprintf(temp+1, 63, "%d", count++); // snprintf is safer than sprintf because it'll never accidentally write past the end of the buffer. Next thing, I had a look at your `processLine` function: lineData * processLine(char * line){ lineData * out = malloc(sizeof(lineData)); if((int)line[1] == 88){ out-&gt;ln1 = cobolGen(5, "filler", line); out-&gt;filled = 1; } return out; } First thing there, your `malloc` isn't error checked. Always make sure that your `malloc` was successful. If for some reason it wasn't, your program is going to immediately crash in flames. lineData* out = NULL; if ((out = malloc(sizeof(lineData)) == NULL){ return NULL; } This way, if your `malloc` fails, `processLine` will return `NULL` to the caller instead of crashing. This means you have to error check your `processLine` calls in main too: if ((cobolLines = processLine(currentLine)) == NULL) { printf("Uh oh spaghettios! A fatal memory error happened :c\n%s\n", strerror(errno)); // clean up and exit Assuming you *don't* crash and burn horribly due to unchecked `malloc`, what you wrote *is* allocating heap data and assigning `out`a pointer to this heap data, which is what you want. But, `processLine` is assigning that memory to a `lineData` pointer, but doesn't initialize its `ln2`, `ln3`, or `filled` members. `malloc` does NOT clean up memory before it gives it you. If you don't set `ln2`/`ln3`/`filled`, they're going to be equal to whatever random garbage happens to be on the heap at that location. So, the first thing you should do after you `malloc` that memory is this: lineData* out = NULL; if ((out = malloc(sizeof(lineData)) == NULL){ return NULL; } memset(out, '\0', sizeof(lineData)); This will make that data all fresh just for you. Your `ln1`, `ln2`, and `ln3` will be NULL, and `filled` will be 0. Second thing there, `line` is a string / `char*`. Indexing it with `[1]` is fine as long as you're only calling `processLine` on strings that are long enough to index with `1`, but you can't just cast whatever's there to an `int` and be on your merry way. I'm guessing you want to see if `line` has the string "88" at index [1]. The best way to do string comparisons like this is usually with `strcmp` or `strncmp`, which you'd do like this: if (strncmp(line+1, "88", 2) == 0){ However, since this is an exceptionally short comparison, I honestly would just do this instead: if (line[1] == '8' &amp;&amp; line[2] == '8'){ Now, this is assuming I was correct in guessing that you wanted to see if `line` has `"88"` in it after the first byte. If you weren't trying to do that, and were trying to see if the byte at `line[1]` has the value `88`/`0x58`/`'W'`, then you should just compare it to `'\88'` instead of casting it to int, it's cleaner: if (line[1] == '\88') I can't tell what your next line is doing without knowing what `cobolGen(5, "filler", line);` does. You're assigning `out-&gt;ln1` to the return value of `cobolGen` which could be fine, but could also be not fine. I'm going to assume that `cobolGen` is doing some kind of heap allocation and giving you a pointer to that heap data, kind of like `processLine` is doing. If that's the case, then this assignment is fine. However, in light of the `char*` bugs we've covered, I would double check `cobolGen` to make sure it's doing what you want and isn't experiencing a similar bug, i.e. writing to an uninitialized buffer. lines 39 - 47, there's nothing special going on there. All fine. line 49, you have a memory leak. Not the worst thing in the world, but also not a good thing. free(cobolLines); This does free the memory allocated during `processLine`'s `malloc`. However, this does NOT free the data pointed to by `cobolLines-&gt;ln1`, `-&gt;ln`, or `ln-&gt;3`. You should free those before freeing `cobolLines` unless for some reason you need that data to stick around. You can do it like this: void freeLineData(lineData* ld) { char* cptr[] = {ld-&gt;ln1, ld-&gt;l2, ld-&gt;l3}; for (int i = 0; i &lt; 3; i++) { if (cptr[i] != NULL) { free(cptr[i]); } } } - freeLineData(cobolLines); My last comment is this: every time your `while` loop goes around, you're `malloc`ing room for a `lineData` and then `free`ing it at the end of the loop. This isn't the worst thing in the universe, but it would still be much better if you didn't do that. You can avoid this cycle of `malloc` and `free` by `malloc`ing once BEFORE your loop, rewriting `processLine` to use that memory instead of `malloc`ing, and then `free`ing that memory once your loop ends. However, that's secondary. If you do decide to fix your memory cycling, you should do it after you fix the other issues.
Based on that second paragraph, this is my perception of what you're going for: // initialize a pointer char *line = NULL; // loop while( condition ){ assert(line == NULL); line = malloc(sizeof(char) * length); // do stuff free(line); if(line != NULL) { line = NULL; } } Assert is your friend. Your while loop has an assignment rather than a logical comparison. Also, where are you using malloc/calloc/realloc ? You can't free something you didn't do a heap allocation on. Lastly, since you're reading lines of a file, why use dynamic memory at all? Why can't you make a string like: "char line[256]" and use functions from string.h to copy/manipulate that? Heck, if you do it right, you can even make it "const char line[256]", followed by memcpy trickery to get the compiler on your side. When you test your code on a computer that wants to be friends and will let you install new stuff, I suggest installing valgrind. Then run: $valgrind --leak-check=full ./program_name . You'll get all kinds of output about memory usage.
Deallocate internally outward. Just like doing algebra. Think of C and sructs and C memory like the builder pattern in oop and everything is created with hacked dependency injection. Then do the creation process in reverse to clean up.
Interesting! Thanks for the info tidbits!
In the while loop, I thought I could use an assignment because `getLines` will eventually return `NULL` , breaking the loop. Since `getlines()` is not portable, I created my own implementation that would return `NULL` when the end of the file is reached. As for the memory allocation, it is all done in `processLines`. It returns a pointer to the memory that it allocates so that I don't have to move data around. The attempt at dynamic memory is basically just a way to learn the language. Since memory allocation is a pretty rare thing programming languages, I thought I would try it out. It also will probably help the servers I am running the code on, as those things use pretty weak processors and are used by a large amount of people at once. I will try out valgrind on my Linux machine later, as that sounds amazing.
You can **only** use `free` on a pointer that you originally got from `malloc`. If you call `free` with any other kind of pointer, you will cause memory corruption, and behavior of your program may become unpredictable and erratic.
I've been picturing pointers in the C++ sense, which is kind of throwing me off. When I code in C++, I really only use pointers for objects, which ultimately need to be deleted. Associating `malloc` and `free` makes a lot more sense.
(n)curses has a lot builtin, to clear the screen use `clear`, to make getch not wait use `timeout`. I've created a small toy program with curses which might be of some help, the screen functions are [here](https://github.com/ascheepe/roids/blob/master/screen.c)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ascheepe/roids/.../**screen.c** (master → 7ba1d9b)](https://github.com/ascheepe/roids/blob/7ba1d9bae0158e454a7e983ef23517f1b1fe961b/screen.c) ---- 
Sadly, this is true even when the parameter has a static size specifier, which one might expect would make sizeof return the specified size. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void printSize(char const *funcName, size_t size) { printf("%-10s: sizeof(foo) = %zu\n", funcName, size); } void sizeOfFoo(int foo[static 10]) { printSize(__func__, sizeof foo); } int main(void) { int foo[20] = {0}; printSize(__func__, sizeof foo); sizeOfFoo(foo); } Output main : sizeof(foo) = 80 sizeOfFoo : sizeof(foo) = 8
I don’t know, they just bragging but thanks to you too for answering 😄
I'm not really upset that optimizations turn on extra warnings, since quite a few warnings don't matter in practice when there's no optimization being done, but I am very upset that none of `-Wall`, `-Werror`, nor `-Wpedantic` turns that warning on.
Better go back to that lecture or use a tutorial.
Thank you so much buddy, I really appreciate that, I had started to get some useful clues to achieve what I want, thank you again.
You skimmed over the most important built-in data structure in C?
Do note I'm familiar with ncurses but I've done a couple of terminal programs. Clearing the screen can be done using some combination of chars sent directly using fprintf (either redraw entirely or just modifcations). For non blocking input you need to set your tty using termios api such that you ll get an event sent right way. You can poll/select on it and respond right way. Google should provide examples for both. 
Thank you very much mate 
Thank you for the so very helpful comment 
What do you understand about arrays already? It can't be "nothing". 
Thank You
Thank You very much 
I have, all of them, and regarding this code I know it's erroneous. That said, that's no why I asked, but rather what will be the direction of evaluation in a code, despite it being erroneous. 
You're welcome. Good luck with your programming :)
The easiest way I can think of to do this would be to read an `int`, make sure the next character is a '.', then read another int. Once you've read a floating point number, there's no way to distinguish whether the user input a 5 vs. a 5.0
No, that's because the expression you pass to `sizeof` actually has array type.
Look up `scanf()` in your favorite C textbook or library reference.
Exactly the attitude I’m talking about. 
For that matter C is somewhat outdated too, but low-tech (such as myself) are obliged to learn it. C is the peripheral nerves of the body, while C++ and others are the central nervous system. 
For that matter C is somewhat outdated too, but low-tech (such as myself) are obliged to learn it. C is the peripheral nerves of the body, while C++ and others are the central nervous system. 
The code is errorneous; there is no direction of evaluation because there is no evaluation going on. Your question is as if I pointed at scratches on a wall and asked you what the meaning of the story is; there is none because the scratches aren't even text.
&gt;Would anyone be kind enough to spend their time typing out something I could have found on Google?
No matter. C has no finals and plenty of pointers.
I compiled this using gcc 7.3.0 on Ubuntu 18.04 and got no segfault. 
Maybe not related but I wrote a Tetris type game with SDL and after pressing a key my pieces would fly out the side of the window (I hadn't added the code for checking for the edge of the well yet). I don't know if a key press was being read multiple times or if it wasn't being removed or what but I added a flush to different places until I found a spot that made everything work right.
Yes. They're different token classes in C, so if it weren't possible to do as you wish, one wouldn't be able to write a lexical analyzer for C in C. 
Take a look at the stickied post and then get back here with more information. https://www.reddit.com/r/C_Programming/comments/9l0vuz/asking_for_help_what_to_do_when_your_program/ The answer for you right now is: Yes
DNUR RUS
You'll have to use a signal value that the data cannot take, if it's possible, use 0 because it's easy to initialize arrays to 0. Depending on the range of valid values you could also use a signaling bit but that's a little more advanced. More details on the exact context would help to answer your question.
http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html
Unfortunately there isn't enough information here to help you. For example, we don't know if `FillTriangle` is supposed to be called by `DrawTriangle`. We need to see code in order to offer advice that is both helpful and appropriate. Perhaps you could upload the _unmodified_ code that they provide to GitHub, so we can see it? Or at least put a ZIP archive of the code up on Google Drive and give us the link?
Avoid ncurses for now. The stuff you need to do is trivial to implement using basic IO. Having some experience with that would also make it *much* easier to understand ncurses later. Check console_codes(4), or any documentation on "ANSI terminal control sequences". That's the stuff you need to output to clear screen and move the cursor. For instance, `puts("\033[H\033[J")` erases the whole screen and `puts("\033[3,4H")` moves the cursor to position (3,4) on the screen. The "\033[" fragment is often called CSI in the docs. Read about the raw mode and make sure you're using it. Learn how you use `select` or `poll` to pause execution while listening for input. I would actually recommend `select` here because it updates the timeout. Also check read(2) and write(2) and try to use them in conjunction with `select`.
I understand that you're learning, but in this particular case the workload would be reduced if you avoided dynamic memory allocation altogether. Doing lot's of calls to malloc/calloc/realloc has a place - but one of the advantages of C is recognizing how little you have to do it in order to get certain jobs done. Here, take a look at this software: https://github.com/ElementsProject/lightning/blob/master/lightningd/lightningd.c That starts at main. The software I linked is being installed on Rasberry Pi's and sold as a plug &amp; play hardware/software combo. Look through the source code and see how much of a workload they're putting on the stack vs how much they're putting on the heap. I've learned a lot from revisiting this repository over the past few months.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ElementsProject/lightning/.../**lightningd.c** (master → 1e467bb)](https://github.com/ElementsProject/lightning/blob/1e467bb9866f0dbcfe0fb54f964f35893e29859a/lightningd/lightningd.c) ---- 
Might be worth getting to grips with linear algebra/transforms too. 3blue1brown has a good series about it which will help you understand it conceptually.
Got it
really don't need to use matrices for scaling and translations but yeah, it would make it much more general, and I can't recommend 3b1b's linear algebra series enough, made me understand transforms on a much deeper and intuitive level!
I think I have a better understanding of the pointers now. Thanks a lot for your in-depth explanation!
No problem, hope it helps 👌
Ooooo that makes sense now. Thank you!
Wtf. That actitude only brings you to a particular place man. Not a nice one btw.
Go back and read the lecture. If the lecture isn't clear, there are hundreds of explanations online. Arrays aren't the kind of thing you can just forget after your project or exam... you will use them throughout your coding career. Google is your best friend... [C Arrays Tutorial](https://www.tutorialspoint.com/cprogramming/c_arrays.htm)
That's a cool assignment. You can use the DrawLine function to fill the triangle: just draw all the possible lines.
Use calloc to make the 2d array which initializes all the elements to its NULL value and if you need to check for values in the array use a nested for loop and check each index. Also can really help if you dont post code to look at.
Hi, some time ago I wrote a terminal tetris clone using C and ncurses library. Here the [repo](https://github.com/MarcoLucidi01/tetris_clone). As already said, for waiting, look for `timeout()` function, for `getch()` newline issue, look for `cbreak()`, also I remember I found a way to not clear and redraw the whole grid at each refresh, but clear-draw only "slots" that have changed, this reduced glitch effects a lot.
"a = a + 1" _doesn't_ mean the same as "a++." "a++" is an expression that returns a value; it returns the original value of a, before a was incremented. That's because it's the "post-increment" version, where the "++" goes after the variable name. There's also a "pre-increment" version which does the opposite. The assignment statement "a = a + 1" technically also returns a value. You _could_ write something like "b = a = a + 1" and b and a will both get a + 1. But I think that would be pretty widely regarded as confusing, poor style. The pre-increment and post-increment operators don't literally allow you to create program logic you couldn't create any other way, but they allow for some convenient short-hand idioms, as other posters have pointed out. 
Source code: [https://github.com/1991viet/ASCII-generator](https://github.com/1991viet/ASCII-generator)
That subtraction.. this is beyond hacky
Why apologize for posting off topic in a sub when you can just not post it? 
Also, even assuming all that is fixed, the loop won't actually reverse the string, it'll just copy it.
Was just gonna say that. 
Think about the logic of your for loop. You're copying the i'th element of the array `s` into the i'th element of array `newname`. Ignoring the fact that `newname` isn't declared properly (as nemotux already mentioned), try and think about why that bit of code doesn't actually reverse the string and think about what it actually does. Sometimes it is helpful to try using an algorithm yourself with a pen and paper.
As mentioned in some of the other comments, `newname[i] = s[i];` won't reverse your string, it'll copy it: you need to add another direction to your loop by adding a second counting variable, but going in the opposite direction. Once you add that additional direction (`--i` and `++h`) you can store the current character to `newname`, change the value of `s[h]` to the value of `s[i]` and then after the for-loop, copy the contents of the now reversed `s` to `newname`--or just not return anything: you should read about C scope. 
exactly.. without saying the same, a little clue ... your last i'th element from s.. should go to your first element of your newname... and at the very end of the loop, the first character from s should go to the lastone of newname... you are just copying on same position but on from "right-to-left"
That's a pretty big clue, haha. 
Haha silly me.. i forgot about how little the clue should've been... 
the syntax “x == v1, v2, v3” does not do what you think. You are accidentally using the comma operator. You need to compare the variable to each value, or use greater than less than checks. 
Im not 100% sure if your IF statement is bulletproof. if (peopleServed == 2, 3, 4, 5) Try something like this: if ((peopleServed == 2 || peopleServed == 3 || peopleServed == 4 || peopleServed == 6)) || -&gt; OR &amp;&amp;-&gt; AND &amp;#x200B; &amp;#x200B;
You are trying to multiply a bill times a percentage depending on the number of people served, yes? What is "\*"? Is this a typo or your code?
I don't know about the "runs as if it was 1" bit, but I don't think your "if" statements do what you think they do. Specifically, you can't compare a single value to a list like that; you have to compare to each value in turn. Instead of if (peopleServed == 2,3,4) you need if (peopleServed == 2 || peopleServed == 3 || peopleServed == 4) where "||" is the logical "or" operator. More to the point, though, is that this kind of logic is better served with a "switch" statement. Look it up.
uhhm im not even sure how that got put there in reddit but theres not "\\" in my actual code
ohh so you mean "x==v1==v2==v3" like that? &amp;#x200B;
OMFG IT WORKED THANK YOUYUUUUUUU
ok so i got it to run but what does != do?
actually you will eventually find you need variable == value1 || variable == value2 || variable == value3 or variable &gt;= value1 &amp;&amp; variable &lt;= value3 
ohhh ok ya it actually only worked for a value greater than 20 thanks
I'm not sure if this has anything to do with it, but this part looks weird to me: "(%i") Are those quotes placed properly?
It means "not equal to", so if you wanted to exclude a value, that'd be one way to do it. 
The question on my mind is should the function mangle the input or return a whole other pointer? Like : 1 2 #include &lt;stdio.h&gt; 3 #include &lt;stdint.h&gt; 4 #include &lt;stdlib.h&gt; 5 #include &lt;string.h&gt; 6 7 char 8 *reverseString(char* s) { 9 if (s==NULL) return NULL; 10 11 int j, k = strlen(s); 12 if (k==1) return s; 13 14 char *foo=calloc((size_t)(k+1),sizeof(unsigned char)); 15 for (j=k-1;j&gt;-1;j--) 16 strncat(foo,s+j,(size_t)1); 17 return foo; 18 /* memory has been allocated and not freed */ 19 } 20 21 int 22 main (int argc, char *argv[]) 23 { 24 char *bar = calloc((size_t)(128),sizeof(unsigned char)); 25 strcpy(bar,"\"A man, a plan, a canal: Panama\""); 26 fprintf(stdout,"----------\n%s\n----------\n",bar); 27 fprintf(stdout,"----------\n%s\n----------\n",reverseString(bar)); 28 free(bar); 29 return EXIT_SUCCESS; 30 } 31 n$ ./alpha | sed 's/^/\ \ \ \ /' ---------- "A man, a plan, a canal: Panama" ---------- ---------- "amanaP :lanac a ,nalp a ,nam A" ---------- However gdb clearly shows memory allocated and then never freed in the function. My thought would be just to transfer the reversed string back into s and then free(foo) and return s. 
where did you get pos.h and screen.h from? No where to be found on FreeBSD 11.2 and no where to be found on Debian other than compiz dev packages.
have to agree that 3blue1brown is awesome
Hey the squished Utah teapot is still out there ! Gotta love OpenGL and here we are about 35 years after I first saw that on an Apollo workstation. Yep .. fun times.
nightmares of users that enter trash .. been there .. done that. Wrote a finance app (many) years ago and accounting users would enter "(1234.56)" for a negative value. Others would input the string "zero" or even "same as 4". Saw that crap.
It's possible you want strncmp instead of strcmp. strncmp lets you limit the search; strcmp will "keep going" with the compare if one string is longer than the other. 
If `s` points to the beginning of an array, then `s -= 1;` is undefined behavior.
I am so very glad that I didn't have to deal with trying to write the parser for that accounting program, it sounds like a nightmare to deal with all that stuff. And I'm sure it got better! But yeah, you're very right. Trying to control inputs is about as useful as herding cats. You've still got to deal with every possibility!
Found the person who's never used maxima. :) It's prompts look like "(%iNN)", where NN is a counter that increments for every command. 1, 2, 3, etc.
You'll want to use strstr probably. But this code is not great. You can't ignore the return value from read, it might return a lower number of bytes than SWOLL. It also doesn't NUL terminate the data it reads, so you shouldn't be using any str* functions that expect the NUL byte to be there until you've fixed that. Also the program you communicate might send the characters one by one (it's up to it to decide). Read will in that case just read them one by one, and your code doesn't handle that. If you know it doesn't do that I suppose you can ignore that problem though. I would however consider using fdopen to get a FILE* you can use fgets on etc instead of using read directly. Finally fflush(stdout) has no effect on write. They operate on different levels. Write is per definition unbuffered (it's actually the function called by fflush). Mixing printf and write isn't a great idea but I suppose it works in practice.
After you realloc matrix on line 47 then matrix[3] has an uninitialized value. You send that uninitialized value into realloc() on line 53, making it crash. Valgrind would've told you this quite clearly, if you have it available.
When you're reallocating: first you reallocate row: no problem here. Second, you reallocate all columns, even though the column size hasn't changed, here I'm guessing it's because you want the reallocation code to be generic and work also if you increase the number of columns and not just rows. The problem is that you reallocate every element of row, but you just realloced row, the last element is not initialized, you never allocated any memory to it: you're trying to realloc unallocated memory. That's undefined behavior. On some systems, the memory manager will see that the memory you're trying to realloc was never allocated and will just behave like malloc, on others it might crash. The proper way to do this is: int newRow = row+1; matrix = realloc(matrix, row * sizeof(int*)); for(int r = row+1; r &lt;= newRow; r++) matrix[r] = malloc(column * sizeof(int)); row = newRow; One last word about diagnosing this kind of problem yourself: if you're on linux you can run your program through valgrind, and it will tell you something like ==4688== Conditional jump or move depends on uninitialised value(s) ==4688== at 0x4C31CDC: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==4688== by 0x108AAC: main (test.c:53) and then all you have to ask yourself is "at what point am I touching a variable that I never initialized"?
I only have code blocks, thanks for your answer. But how do i set this uninitialized value, i still don't get it properly and it bothers me a little :/
I created them but i linked only to the screen functions. If you click on [roids](https://github.com/ascheepe/roids) you'll see the whole lot of files. Apart from the screen init which sets up cursus keyboard.c gets the user input. It's way to big for such a small 'game' but it was meant more as an exercise for using a form of objects in c. That's why it's full of structures for each thing and function pointers in these structures which are the methods for these things.
If you're going to swap the string in place, you don't need to allocate any memory at all. char* reverseString(char* s) { size_t len = strlen(s); for(int i = 0; i &lt; len/2; i++){ s[i] ^= s[len-i-1]; s[len-i-1] ^= s[i]; s[i] ^= s[len-i-1]; } return s; } The 3 lines with ^= are swapping with the XOR trick but you can just use a temporary char if you think that's more readable.
Okay thanks, so if i understand (i hope so), we "jump" directly to the new row that we created with realloc to create there the columns ?
You just have to write to it before you read it. In this case there's no need to reallocate all the lines when the number of columns haven't changed, since you're not changing the size of those arrays. Instead use malloc to create the new line only, similar to how you write values in the new line only. Alternatively you can write NULL to matrix[3] before calling realloc (but only matrix[3]). Then you've initialized it to a valid value for realloc. 
Yes, you could also realloc the first few rows that are already allocated, and once you get to the end of those, start using malloc: int newRow = row+1; matrix = realloc(matrix, row * sizeof(int*)); int r = 0; for(;r &lt; row; r++) matrix[r] = realloc(matrix[r], column * sizeof(int)); for(; r &lt;= newRow; r++) matrix[r] = malloc(column * sizeof(int)); row = newRow; this way you don't realloc the new ones *just* after allocating them the first time.
Yeah, all Python's basic operators are just methods on classes so I don't see why they couldn't implement pre- and postfix increments. Although I guess it fits with their "mission statement" to have only one way to do something. 
Exactly this. What OP's code would've achieved otherwise was casting the pointer, which from time to time is actually needed (although iirc uintptr_t or whatever is the only type guaranteed to be able to hold a pointer cast to integer) 
By "characters" do you mean graphemes or code points? If it's code points, I think that's useless. At least I can't think of any possible situation where it could be useful to know how many code points are in a string. Graphemes (or glyphs) can be useful to know if you are building an application that's doing visual layout (like a text editor or something), but that's fairly rare. That's about it. For anything else, especially doing database operations, the only thing you might want to know is the number of bytes used to store. The number of code points, number of graphemes, etc., would not be useful.
No. They should be static in the .cc to limit them to compilation unit scope. 
Interface can be vague. If you are only planning on calling a function within one c file, then move the prototype from the h file into the c file. No need to give out type definition for things that other modules will not use.
First, you may be confusing _declarations_ with _definitions_. This is a function declaration: int add(int x, int y); This is a function definition: int add(int x, int y) { return x + y; } To answer your question though, a header file should only contain the declarations needed by users of the header file. (I'm deliberately avoiding the terms public and private here, since they're somewhat nebulous and can mean different things at different times.) Moreover, if you have a function in some C file, and that function is not needed outside that C file at all, it is recommended that you mark the function `static` so that it has what's called "internal linkage". This ensures that there the function cannot be called from outside that C file, even if something were to accidentally declare it elsewhere.
The other advantage of marking it static is that you get better optimization because the compiler can analyze all calls to it, since they're in the same translation unit. 
Thanks for the answers! 
This is why some people use special internal header files: A header (usually with a different extension such as .ih) that is included in all .c-files that make up your library or 'module', but not to be used by consumers of your code. The first thing the internal header does is to include the normal header, and after that it defines/declares everything that is required for the inner workings of the code.
Might also be worth it to explicitly point out that it can be useful to have multiple header files with different roles. For example, one header file can be used to provide visibility to functions that are accessible across different C files within a library, but not visible to clients of the library. And a second header file can be used to provide accessibility to just the functions that clients of the library should use.
looks like a good plan. I'd recommend starting to write C code in parallel to your reading books and tutorials. The "Text" and "Files" sections in the Mega Project list look like a good place to start.
In general, no. But if you need to use inline functions or macros, you often end up exposing things you don’t want public. For example, if you’re inlining some quick parameter checks: inline int doSomething(void *param1, const char *param2) { extern int doSomething__unchecked(void *, const char *); if(!param1) return -1; if(!param2 || !*param2) return -2; return doSomething__unchecked(param1, param2); } For this situation, you can do an `extern` declaration inside the function body and it kinda won’t exist in the outer scope, unless something else tries to use that name, in which case it kinda will. Names of things not exposed should be marked specially somehow so users don’t see them as stable/well-defined. Along the same lines, `struct` and `union` bodies can/should be left unstated in the headers when possible, since the `struct Whatever` tag can exist independently of the struct body; however, if an inline function or macro needs to get at the body of the struct, it’ll need to be in the header.
I like The Linux Programming Interface by Michael Kerrisk if you are focusing on Linux/Posix OSs.
21st Century C and C Programming A Modern Approach
Is that what you would do if you wanted to include an internal function in your unit tests? Define some separate, special header files?
I can not highlight the parenthesis part enough. I could fill a book with bugs i introduced because I do not used proper parenthesis in macros.
\#define's purely replace code vith another code, ignoring precedence, etc. Therefore *SUBTRACT(asd, fgh)* will be replaced with *asd-fgh*. Your second example should resolve to: *num_one-num_two-num-three* Instead of: *num_one-(num_two-num-three)* That's because an expression like *SUBTRACT(5, 2-3)* will be replaced with *5-2-3*, which equalls 0, insead of 6. When making preprocessor definitions it recommended to surround arguments with parentheses to prevent these errors from happening. So your SUBTRACT definition should look like: \#define SUBTRACT(a, b) (a)-(b) Now, *SUBTRACT(5, 2-3)* is replaced with *(5)-(2-3)*
Perfect. I figured the output would lack parentheses unless I explicitly wrote them in, I just wanted to check with people that know what they're doing more than I do. Thank you!
Books are essential (and that looks like a good list), but the best approach in my opinion is just to write code. Write until you get stuck, read up on how to resolve it, and maybe read up on topics that are related to cement your understanding. As you go over topics in the books, come back to old code and go back through it with your new understanding and make it better.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Qqwy/c_treat/.../**hash_map.h** (master → f1bb753)](https://github.com/Qqwy/c_treat/blob/f1bb7539b48bc8a61fe06641c438f08835e0ff0e/src/treat/hash_map/hash_map.h) * [Qqwy/c_treat/.../**hash_map.ih** (master → f1bb753)](https://github.com/Qqwy/c_treat/blob/f1bb7539b48bc8a61fe06641c438f08835e0ff0e/src/treat/hash_map/hash_map.ih) * [Qqwy/c_treat/.../**hash_map** (master → f1bb753)](https://github.com/Qqwy/c_treat/tree/f1bb7539b48bc8a61fe06641c438f08835e0ff0e/src/treat/hash_map) ---- 
this sub is about C and not C++. also: please format your sourcecode when posting
C doesn't have 'vectors' it has arrays. Your wording leads me to believe you're working with C++ and not C, please redirect your C++ related question to r/cpp_questions. If I'm wrong, and you're just using a less common nomenclature, we can't really help you without looking at code or knowing more. You haven't even fully explained the problem, or your logic behind it. For instance, do you have to find all solutions, or just one solution? What does your algorithm look like in plain english or pseudo-code?
So, why does it work other times, but doesn't work when it's the exact same thing? I mention this in another comment. What do you by "overflowing"?
Aren't they approximately the same? Guess I was wrong.
"overflow" means "write past the end of" string s1("I Love Pizza"); string s2("Doooooooo"); s1.append(s2); s1's constructor allocates space for exactly 13 characters and then writes 13 characters into the space. append then puts another 9 characters on the end - overflowing the buffer. 
Thank you for your help. My issue is with C++ as you thought. Since this is the wrong subreddit ill consider this solved. Sorry for the inconvenience. 
Hoo boy ... you're about to incur the wrath of /r/c_programming. Don't you dare try to call them "approximately the same!" They're related and share a common subset (most C programs are also valid C++, for example). But the idioms and techniques used are wildly different. You really should take this question to /r/cpp_questions. And please, please format your code when posting. There should be a stickied post on this sub to explain how. Actually, with that much code it's even better to put it on a code hosting site and just provide a link.
Yes, but you can't fit 22 characters in a buffer that is only 13 characters long. Make the buffer bigger. 
Actually, this happens multiple times per day. You're not the first to make the mistake.
I did. 
Will do, thanks! 
Then you didn't do it correctly. 
&gt;Mystring&amp; Mystring::append(const Mystring&amp; str) //??? &gt; &gt;{ &gt; &gt;len = len + str.len; &gt; &gt;buf\_size = len+1; &gt; &gt;strcat(ptr\_buffer, str.ptr\_buffer); &gt; &gt;return \*this; &gt; &gt;} How?
That isn't growing the buffer. `strcat` blindly writes where it is told. It doesn't make the buffer big enough to hold the new data.
....your sanctimonious criticism is ineffective.
So, how do I effectively make the buffer bigger?
You've calculated the new size that is needed (`buf_size`) Now you need to use `new` to allocate a buffer of that size.
Oh, so make a new char array with the size equal to that buf\_size. Then I guess make ptr\_buffer = to that new char array? Or am I still not getting it?
To make a good C library, it's a good idea to be strict about this, and make "public" effectively equivalent to ABI. So, if it it is a header available to users (the stuff that could go in \`/usr/include/mylib/\` for example), then it \_is\_ public by definition. Changing it can break things. In other words, no.
Here are some helpful macros that I use for colored text. \#define BOLD() printf("\\033\[1m") // Cursor bold \#define FOREGROUND\_COLOR(x) printf("\\033\[3%im", x) // Set foreground color \#define CLEAR\_ATTR() printf("\\033\[0m") // Clear bold/color attributes // Color identifiers \#define COLOR\_BLACK 0 \#define COLOR\_RED 1 \#define COLOR\_GREEN 2 \#define COLOR\_YELLOW 3 \#define COLOR\_BLUE 4 \#define COLOR\_MAGENTA 5 \#define COLOR\_CYAN 6 \#define COLOR\_WHITE 7 To set the text color to blue, you would do the following: FOREGROUND\_COLOR(COLOR\_BLUE); To undo the color setting: CLEAR\_ATTR();
Look up "symbol visibility" in the documentation for your compiler and/or linker. GCC, for instance, has a `visibility` attribute that can be attached to various symbols.
I do this as a matter of convention for all my programs. Prefixing a function name with the name of the module it is defined in helps to read, follow, and debug the code. And there is the added benefit of a decreased chance of a name collision. If your modules are designed well, having the module name as part of the function name is helpful for others to understand what the function is responsible for. For example: // File: stack.h typedef int item; void stack_init(void); void stack_push(item); item stack_pop(void); &amp;#x200B;
IMO there isn’t much difference between libraries and programs in this sense. It’s whether you expect anyone (ever) to use the code in more than one application, or in more than one organization. If so, you need to be neurotic about namespacing, and you should prefix anything you’re not intending be treated as a fundamental part of the language. (E.g., who knows what knobhead `#define`d `x` to 3; because they did, the `int x` in your function argument list is now bogus.) It’s a little ridiculous that C11 didn’t include any provisions for namespacing—the scoping rules have certainly always been porous—but then I suppose lots of stuff about C is ridiculous.
The other answers are right, but only if you’re actually writing to an ANSI-supporting terminal. This is true of 99% of UNIX/Linux terminals, but IIRC it’s a special setting per Windows terminal window, since DOS/Windows programs normally use out-of-band methods to set attributes. Technically UNIX/Linux support any old terminal with or without ANSI escape sequences, which is why the termios database and ncurses are things; therefore, fully portable \*ix software should make sure it’s actually got something ANSI-supporting before throwing escape codes around willy-nilly, lest you accidentally direct some misbegotten old hardware heap to self-destruct, and what a shame that would be. In practice, most terminal hardware made from what, 1975? on supports at least basic ANSI escape codes, and I’ve never come across a remotely modern \*ix terminal emulator that doesn’t support them since UNIX originated on DEC (requiescet in pace) systems that were usually paired with DEC serial terminals.
Only do so if your function names aren't sufficiently unique otherwise.
Do not spam.
Thanks for the head's up. Doesn't that still mean his/her quotes are still misplaced?
\&gt; I have been trying to solve a N-queens problem using a 2D boolean vector and recursion. &amp;#x200B; I'm out!
No. They're trying to find the start of the prompt.
Where is your code?
&gt; assignment &gt; my code There is no code posted. Also, a lack of planning on your part does not constitute an emergency on everyone else's in helping you get your assignment done.
This is more of a linear algebra problem than a programming one, also where the code?
&gt; Or should it be practiced in any moderately sized program? Once you start writing code more regularly, you realize it is just easier if you assume your one off program will be reused and folded into a future project. So I always do something like this to code I write. Even if it is a couple hundred line "throw away" program.
It might not be the "right" way to do it, but one way I've done it before is to include the `.c` file itself - this allows you to get access to any `static` variables/functions as well.
You can look at how I print log output in my project [here](https://github.com/VKoskiv/c-ray/blob/master/src/logging.c) The `initTerminal()` function disables output buffering, and also contains code to enable ANSI escape codes on Windows terminals. Once you run that code, you can just use the standard escape codes like normal, and they work properly on UNIX and Windows.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [VKoskiv/c-ray/.../**logging.c** (master → 9f19009)](https://github.com/VKoskiv/c-ray/blob/9f19009af6e0afa7eade9306a88de972f154bbfe/src/logging.c) ---- 
+1. Best explanation. 
No, because it's dumb. How many loggers do you expect your users to include alongside your own for example? It's pretty unlikely for them to do that.
Java was the language with finals btw.
yes, it's undefined behaviour actually
uintptr_t isn't even guaranteed to exist
&gt; Sometimes it is helpful to try using an algorithm yourself with a pen and paper. YES For every non-obviously correct function, I'll do this for at least a few iterations to make sure it's at least semi correct before committing.
I generally side on the allocate a new copy so the user can later decide which version they want to keep.
No? I'm fairly sure it's a standardized type that any C99+ compliant compiler will provide through the stddef.h header 
It's defined by the standard as an optional feature
Programming in the environment provided by a given operating system is a very, very different thing than OS development. I'd suggest looking into a book on Linux driver development.
See /u/full_step's response to OP.
You chose the two sloppiest languages to compare C to, and then said, "Let's not even go there" with C++. &amp;#x200B; C++ does fix a lot of issues with C. Templates help with the concept of generics. More recently, it's included lambas as first class objects, as well as ranged for loops. All while maintaining the compatibility with C to do lower level things. &amp;#x200B; Other language are much, much safer than C, making working in groups across large codebases practical -- heck, the fact that C doesn't have namespaces makes it problematic to even link against other files.
Thanks😊
I've been programming in Python for about 6 months now (it's also technically my first language). I honestly love it, but list comprehension is something that I have no idea why people think that's readable. It seems more confusing to me, probably because I'm new to this. Either way, there are pros and cons to all languages. What if you want to make a simple app where you don't need to micromanage memory? 
In that case I'm gonna go ahead and edit my post to add some more detail.
I recommend trying out golang.
I used to write a lot of C and C++ in a previous job. Used to get really frustrating doing anything much in C once you get used to using the STL or Boost in C++. If you like C you should check out golang. It’s a similar style language with some nice concurrency features.
"However, almost nowhere does a language force you to use the abstractions it provides. It's nearly always an opt-in approach." - It does not matter if I want to use them or not as code written by others is often more difficult to read than your own. "You are not actually even saying anything about C++. Either drop it from your comparison list or write your reasoning about that language out" - Sorry I don't drop it because i find C++ complexity a bit overwhelming. I won't 'even go there' because there is plenty of C/C++ 'wars' out there on google. try out a more varied diet of languages - yep, thanks for the advice :)
It's ok if you don't want to 'micromanage memory', C does not force you to do this!
I have C Programming: A Modern Approach but haven't looked at it in a while. 21st Century C is on my to-buy list once I'm comfy with what I'm doing now. Thanks!
Javascript is the most closest to C IMO and not as anal as as C++.
C is the only language (outside of ASM) where I actually feel like I am programming a computer. Where I actually feel like a computer scientist. Everything else feels like Legos. 
Yep, you pretty much describe where I am on the topic. I work with C on a daily basis (I work quite a bit with interfacing to hardware), but I'm working on transitioning code to C++ where possible. While they can do a lot of the same things, whenever I work in straight C, I find myself missing some of the abstractions that can technically be implemented in C, but require a lot more work and sacrifice a lot of safety to do so.
C is actually pretty far from doing any computational science. It's closer to computer engineering than computer science. &amp;#x200B; Python, Haskell, and Lisp/Scheme are closer to "Computer Science" type concerns.
It sounds like you are writing fairly simple "pipe calculation"-type problems in C. If you need to maintain arbitrary amounts of state, you immediately have to micromanage the memory in C. This goes from reading input from files or even doing large numeric calculations with arbitrary precision. &amp;#x200B; It seems like C is good enough for you because, 1, you are working alone on your own problems, and 2, you are doing pure math on inputs that are read on fixed-size and known inputs without concern of improper data.
"doing large numeric calculations with arbitrary precision" I did that using GMP and I really didn't have too worry too much about memory management. But again, how long is a piece of string?
&gt; most projects would be virtually impossible to do in C What have you been smoking‽ While a lot of projects may require a different approach in C than in an object oriented language, C is a Turing complete language.
Yes, you are using a library, with someone else having written the memory management for you. Much like using another language. &amp;#x200B; And you never asked the first time -- "how long is a piece of string?" What are you talking about?
Care to explain what abstractions mean in programming? If a language is not OO like C, we still can do OOP in that language right? So why being an OOP language is a big deal like C++? And how do people tell whether a language is an OOP language?
Brainfuck and Intercal are also Turing Complete. Karl the Robot is Turning Complete. Conway's Game of Life is Turing Complete. &amp;#x200B; However, nobody would suggest building a product using any of those as the underlying language.
Does the language naturally support classes and objects? And OOP is so 90s. It's all Duck Typing today.
The statement was, "most projects would be virtually impossible". I wasn't trying to say that some languages aren't better for some tasks than others. I was just saying they weren't impossible (or even virtually impossible).
Neither did I.
Are computer science and computational science the same thing to you?
&gt;C is the only language (outside of ASM) where I actually feel like I am programming a computer. While C is certainly closer to hardware compared to e.g. Python or Haskell, C is actually defined for an abstract machine modeled after the PDP-11. C implementations do stuff to give you the illusion that you are programming a faster PDP-11. Modern hardware topics like caches or pipelining are not reflected in C. So while you can of course always say you "*feel* like programming a computer", it's not really accurate. &gt;Where I actually feel like a computer scientist. Check out turing machines or alternative computation models like µ-recursive functions, register machines, GOTO/LOOP/WHILE programs or lambda calculus. These are beautiful and you can reasonably prove things about them. That's actual computer science. C and other languages are just the dirty tools to do practical stuff. :)
It gets into your definition of "virtually impossible". Clearly, enough time and programmers can write anything in one language in any other Turing Complete language. That's not a very interesting statement. But, if I need to have 10x the engineering effort for the same result, you're basically saying that a project now costs 10x more, which makes it "virtually impossible". And I would say the difference between a large C codebase and a large codebase in some other language is likely 3x-5x, and in some cases, 10x.
&gt; unreadable code can be created as effortlessly without or with abstractions See for example the obfuscated c code contest. 
This is a very novice view of programming in general. I use multiple languages daily, including C and Python. They all have their uses.
I am currently on a project with embedded systems and the code is using c++.
I wrote a Python bot that connects to Facebook and downloads you chat history then let's you select a group chat and replies to messages using Markov chain generated answers all because or a joke made at lunch in said group chat. It took me like 2 hours, including looking up the libraries I needed. Try that in C
On the other hand, I've been writing code for 40 years. Most of that time has been spent writing and maintaining C code. I have found, that for the types of problems the code I've worked on was written for, C has been very productive. In places where C++ was used, the cost of maintaining the code was much higher. I'm not trying to make a general statement here. I'm not claiming that C is inherently better than C++ or any other language, I only giving my experience. Also, I'm only limiting the languages because, aside from assembly language, those are the only ones that have been used for projects I've been involved with. I don't know where you came up with C being 3x to 10x more expensive than other languages, but my experience says otherwise. There may well be instances where you are right, but I don't think that's a very good general metric.
Seconding this.
Not even remotely close. Literally whole entire universes apart.
I said "virtually impossible" as in "technically possible but unrealistic to the point where it doesn't matter"
Don't bother. Nobody in the industry cares about certificates.
I have never heard of a C++ certificate (am from Sweden). My honest opinion is that a degree and/or portfolio, eg. a GitHub profile; and most importantly, real work experience carries much more weight.
If you're working on a project well suited for C the difference could be negligible but imagine writing a mobile app in C, which is actually a real option. 10x the code doesn't look so crazy then.
Enterprise software is a force unto itself, of a far older, deeper, and more fundamental nature than the data/code it encompasses. You become an unremarkable initiate into some perfectly normal-seeming bank—okay, everyone has a kinda haggard, haunted look and there’s this strange chained-orphan-wailing noise coming from the server rooms at night, but hey, there’s a good benefits package— One day you peek into a darkened meeting room, everybody’s silent, stone-faced, wearing robes. The VP of Systems Development for East Asian Prospective Finance Extension in Pursuit of Increased Inroads into Governments of Same begins chanting quietly, and everyone in the room starts swaying. A PowerPoint presentation begins—first a title page and executive summary, then more and more complicated graphs and questionable clipart, slides flipping faster and faster, until suddenly there’s just a whirling blur, no bulletpoints legible. A sudden flash of light from the projector! The screen begins to shimmer a bit, and you’re treated to a brief, vertigo-inducing glimpse of some dark, hulking mass sillouhetted against the vantablack Ur-Substrate. Everyone except the VP of etc. etc. Bribery prostrates themselves before it. Perhaps it notices? It has no recognizable focus or directional vector; it remains a dark, shifting mass of software, some from ages long past and some added recently. You gaze upon it, and feel a madness growing—here you see a chunk of Java 1.4, over there some Perl 2.0 around Bourne shell scripts around COBOL, over there for some reason there’s a Netscape 2.0 browser window displaying text from some antediluvian dialect of SQL, part of the SSO process perhaps?, and there somebody’s grafted on two entirely separate Node services. A haze of data is being sprayed out from the various parts—not quickly, but enough to obscure the full extent of the Nameless Stack. A team of blindfolded, quivering, semi-competent DBAs is led in from an antechamber and instructed to stand before the portal into the Void. They do so with few whimpers, having long since been broken to arbitrary exercises of authority. The invocants stand now! The chanting rises in intensity! Suddenly the DBAs are no longer of this realm, and are precipitated headlong inwards towards the Nameless One! It become-consumes them, disregarding their inaudible wails. You recognized one of the DBAs before, but now you catch a glimps of him Integrated into the Nameless Stack, mindless, expressionless, manually feeding output from one program into another. The chanting stops; the presentation resumes on a positive note, and the room is now filled with quiet applause. You sneak away, unnoticed, shaken. The Nameless Stack gave rise to enterprise software, and it will permit its continued existence as long as the sacrifices continue. As a result of the outlay of DBAs, the bank survives its descent into yet another layer of virtual machines and successfully implements Copy-and-Paste-as-a-Service, saving them 0.02% of operating costs per annum. You’ve now acquired an inescapable opium habit and a curiously racist tinge to your offhand anecdotes. This is the way of things. Namespacing is no concern to the Nameless Stack. It sees a name as just another datum, no different than an offhand literal `0`. The Elder Ones will misuse/abuse whatever language or platform or framework or employees they’re fed, and the ecosystems in question will become their Abominations.
sure watch some vids, but there is no substitute for actually coding ! you might try a site like this [https://www.w3resource.com/c-programming-exercises/](https://www.w3resource.com/c-programming-exercises/) see something specific you don't know about, by all means go square eyed....
int a; int main() { int a; } These are 2 different variables, both called a. They have different scopes and, within main, the local *shadows* the global.
Can you give a print random number example please? The one I came up with made me give up on the language.
Could you list some examples of things almost impossible to do in c?
It depends on what your algorithm is. Generally, you can declare multiple variables with the same name in different namespaces: ``` // global int a; int main(void) { // local int a; { // a new namespace, a different variable int a; { // another namespace, another different variable int a; } } } ```
Not in my embedded device your not.
C is a decent language - And this isn't a dig on the language itself, but I've seen a lot of code that has few spaces, as if the programmer wants to eliminate all whitespace in order to save space or something. For example: for (int i=0;i&lt;10;i++) As you've said, readability != conciseness, but I've seen a lot of code lacking in whitespace, IMO making it more difficult to read.
While I agree that C is not best suited for rapid prototyping , I wonder why you think you cannot get shit done in C? You can implement nice interfaces, abstractions, data hiding and encapsulation in C. Sure manual memory management is a thing, but with encapsulation and abstraction this is a managable problem. Care to elaborate?
I like the comment from Simen with regards to http://lambda-the-ultimate.org/node/5534 "C is not a low level language." "The fact is that most of these points are also true of assembly. And assembly is the lowest level programming language that 99.9% of programmers will ever touch. So, the conclusion would then be that there are no low-level programming languages in existence. But that takes away a very useful way of thinking of and speaking about things. Level of abstraction is a continuum, and it's very useful to be able to speak about the difference between C, which is a relatively thin layer over the underlying computing model, and something like Java, which is a thicker level, and then you have your Javascript, Ruby, Prolog, Haskell et al which exist even further removed from that underlying model. This remains true even if the underlying model exposed by the machine code is itself a kind of virtual machine emulating an obsolete design, hiding away things like multi-level caches and out-of-order execution and a million other details that didn't exist in 1970. A pet peeve of mine is when people redefine words to mean things that people who use them don't intend when they use them, and then writing exposés showing you how everything you thought you knew was wrong. I have no quibbles with the technical content of the article, I just disapprove of the tone and message behind it. Programmers aren't that naive: those who work with C or even higher-level languages in domains that require absolute performance do know about and think hard about things like cache coherency, ILP, and the like. It would be nice to have an article that explained these things in detail without simultaneously trying to invalidate a useful shorthand way of speaking about things and also pretending like the audience consists entirely of naive fools. By Simen at Tue, 2018-07-10 00:09 
an autogenerated thing 1000's of lines long... what could possibly go wrong, using make in conjunction with pkg-config isn't some how less professional just more KISS [https://en.wikipedia.org/wiki/KISS\_principle](https://en.wikipedia.org/wiki/KISS_principle)
Why are you hating list comprehension.? Functional programming is great.
I agree and do most of my development using higher level languages and would probably get frustrated with reinventing the wheel all the time if C was my primary work environment. But, when I really want to explore and totally grok a new concept I enjoy doing it in C first. For example, when I heard about Donald Knuth's Dancing Links implementation of the Exact Cover algorithm I implemented it in C to solve Sudoku puzzles. The most enjoyable programming I have done in a long while. Programming in C always brings me back to why I studied Computer Science in the first place way back in the late 80s.
I learned a hell of a lot from binge watching Handmade Hero on YouTube. 
Hey, not the person from above, but there is the \`math/rand\` package -- package main import "fmt" import "math/rand" import "time" func main() { seed := time.Now().UnixNano() rand.Seed(seed) fmt.Println(rand.Intn(100)) } This is setting the seed based on the current time (so the output isn't the same for each run) then I run rand.Intn(100) which gives a number from 0 - 99
The one I made ended up having to construct a time-since-X object with a date object used in the constructor and then a conversion to seconds or something to then pass to the seed and then call the random function and print it.
I personally enjoy using [meson](http://mesonbuild.com/index.html).
Tell your son to do a personal project instead using c++. That way he'll learn it better and have something to show for it during interviews where he can talk about design / tradeoffs, etc. 
The compatibility between C an C++ is a two-edged sword. I think it's the source of the majority of complaints people have, but it's also what made it a popular language in the first place.
Exactly. I come from Java and besides embedded systems there is no good reason for me to use C, except there is something about it which is fun... so I end up making projects in my free time in C which last way more than if I had done them in Java. 
Python is too boring man. There is nothing like reinventing the wheel and blowing up your computer because you wrote the wrong memory block.
I want to also say cmake is really great. One thing you may miss from autoconf is the documentation, it’s pretty useless, but there are good tutorials for modern cmake.
Masking global variables by declaring local variables with the same name will get you straight to hell, specially if others have to read your code. 
C is such an old language all books about it can be found illegally for free online. I dont like youtube tutorials because they are too slow for me. The "harder" the topic gets the crappier tutorials get too. &amp;#x200B;
Let me clarify something for you: Strictly speaking, C++ is an imperative,_class oriented_ language, because you can only modify the structure of objects through their classes, rather than modify instances themselves directly. Only when C++ gets proper reflection capabilities (and there are some proposals out there that maybe will be included in the next C++ standard) is it not only class-oriented, but really object-oriented. Duck Typing is orthogonal to the concept of Object-Oriented programming (although it is usually used in the context of OOP, which would make it a subset of OOP-languages, and therefore still conflicts with what you wrote in your comment). Common Lisp could be considered a 'duck-typed' language. As for programming OOP directly in C: Yes, it is possible and there are multiple resources out there of people implementing their own object system. However, there is nothing stopping you (or another programmer) from mis-using it, because polymorphism in C means that you need to perform a manual cast somewhere (to look up the vtable), which the compiler cannot do in a safe manner, so you're on your own. That said, if compatibility is not that important, there are a couple of compiler-addons that make life easier for you (like [__attribute ((constructor/destructor))](https://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Function-Attributes.html) in GCC, or [statement expressions](https://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Statement-Exprs.html#Statement-Exprs), [nested functions](https://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Nested-Functions.html#Nested-Functions) etc.). Also, some stuff can be emulated using macros, such as this [proof-of-concept traits-system I built](https://github.com/Qqwy/c_treat).
Check out the built in qsort(). You write a function to tell it how to compare your elements and give it the array and compare function and it will sort for you.
In standard C? Functional programming, because lambdas, and by extension higher-order functions are not supported. And (safe) polymorphism (both parametric polymorphism and, even more so, return-type polymorphism).
What about when there is no wheel that fits your axle? Do you spend your time hacking together a shim to attach an available wheel to your axle? Often you spend just as much time on the shim as you would have to make a properly fitting wheel. Admittedly, you can often use a preexisting wheel. Knowing when to shim and when to make a new wheel- that's what experience gets you.
I really like Lisp (I've used Racket, but close enough). It's fun to write and fairly straightforward imo. Prolog? That shit is intense. Probably the strangest non-esolang I've had to use (for a class).
Which language is yours? Maybe I can help you find some material.
That's *almost* how you do random numbers in C: srand(time(NULL)); // ONLY DO ONCE IN PROGRAM ... int random = rand() % [max]; // gives number in [0,max)
azerbaijani
Yes, but probably for educational reasons (or "lets see if this is even possible") rather than for production-readiness. And the same thing can be said of most languages that see some use out there. :-)
For people who feel very stongly about one single language, here's some recommended reading for you: [Beating the Averages](http://paulgraham.com/avg.html) by Paul Graham. Don't become a Blub Programmer! :D
Indeed. And it also is not helped by people using the post-increment operator when they meant to use the pre-increment operator, because they are not using the outcome value of the variable before it gets incremented in any meaningful way! ;-p _Seriously though, intent matters when writing code. Even in details like this. "but the compiler will optimize it away" is not a good argument, because it's about the other people reading your code, not the compiler._
Things is i get bored with books and can't focus if it isn't story or something like that. And i get what you say i will practice while watching tomorrow take notes, write down codes. My goal is learn fundamentals and pass my class not really thinking to have future in C but who knows time will show. 
I have crafted an exquisite heap of shit for writing C code. https://github.com/ikbenlike/libend
Don't switch build systems just because you think yours isn't cool. Do Makefiles work for you? If so, use Makefiles.
No template libraries. No object abstraction. Manual memory management. Poor package management tools. Poor to nonexistent error/exception reporting. C has its place. It's just easier and faster to do it in other languages with little performance loss in a broad set of applications. 
Youll have a hard time if books bore you... I get that you dont give two craps about C, and that is fine. I dont give two craps about many other languages either. It depends on how hard your class is and what is considered as basic. Since you dont care much about C it would make even more sense to reduce the time spent on it by reading books/online articles rather than watching unnecessarily long C videos on youtube. 
I'm not concerned about being cool. I just want to know if I am missing something that might be important. Perhaps my programs would be more portable if I used something like autoconf? Why does it seem to be a standard for so many open source projects?
I use Make for most. If I need more configurability, pkgconfig often suffices. Sure, autotools is more flexible (and yes, CMake and Meson don't beat autotools when it comes to Unix-ish compat, by *far*) but it's also kinda ugly. In my experience CMake and Meson have always lacking at some point.
Well yes, you've got to get a handle on that. Do you have portability problems with your code right now? If so, autoconf (or cmake) might help. There's another benefit to using another build system: locations (paths). This is especially important if your project has dependencies. If you're reliant on other libraries, for instance, autoconf and cmake are great at determining (a) if those libraries are installed; and (b) where they're installed.
Isn't it just some wrappers around pthread create/join? Futures are different foncept. Proper futures ("proper" in the way they work in most of languages) should allow you to provide value at any time from any thread (with reasonable limitations ofc), and then some consumer of a future should be able to check if it has value. Also future should be able to notify consumer about value appearance. This implies some sort of event loop. Also: - Don't use double underscores, it's reserved for compiler and libc stuff. It's generally ok to use them with some prefix (Future__ in your case), but you have too broad name (__generic). - Aliasing void* is pretty useless and misleading, in my opinion. It's C, void* is bread and butter. - Warnings should go to stderr, and even with that it's not good error/warning handling strategy altogether.
Gcc
Yep. I googled it after posting and I was like "Oh no...what stupidity have I typed"
No fren, I call it ‘discovery.’ We advance from these discoveries. :)
Not to mention, what would be OP's method of writing the equivalent in C? 
 in C11/17 atomic types were introduced to the standard library which handle multithreaded variable access. Also gnu c (also clang) supports lambdas through nested functions and statement expressions. You can create a struct which holds a type enum, size, and a void* value. Then you know what the void* references and can cast it for arguments and return values. C doesn't really look to restrict the user, just assumes they won't touch stuff without the proper tool. For example, make a struct that keeps track of what part of the union was set and use exclusively functions to set and get from it. While some of these solutions may not be pretty, they still work if you really needed them. 
Although I too love C, I agree. You can even make it shorter and more readable using zip: combs = [(a, b) for a, b in zip([1,2,3],[3,1,4]) if a != b]
You could generate it in pieces and then use bitwise operations to put them toghether. `long long` is 64 bits wide, so I would generate 2 random ints (32 bits wide) and then shift one over 32 bits (taking care that there's no garbage values pulled in) and add in the other. Something like this: long long rand = 0; long long r1 = rand() % [half of max]; // Note, these will only be filled to 32 bits wide long long r2 = rand() % [half of max]; rand = (r1 &lt;&lt; 32) &amp; 0xFFFFFFFF00000000; // I just want to be sure that only the top 32 bits are affected rand += r2;
Not sure that's performing the same thing. The original example is taking a product, but your point still stands if you use itertools.product() instead of zip. 
Oops, you're totally right.
No, computational science was an odd autocorrect issue. 
No watching videos is useless 
&gt; in C11/17 atomic types were introduced to the standard library which handle multithreaded variable access. That, I knew. But it turns out that since C11, there also is a `&lt;threads.h&gt;` which I did not know about. So we do not need to rely on posix-threads anymore! Yay! &gt; Also gnu c (also clang) supports lambdas through nested functions and statement expressions. Yes, through language extensions that are non-standard, which is exactly why I mentioned it. 
`x64 native command prompt` -&gt; `cl file.c -o file.exe`
llvm everything.
CMake.
or list(filter(lambda x: x[0]!=x[1], zip([1,2,3],[3,1,4])))
Open up a console and run the `vcvars.64.bat` in your Visual Studio installation to set up the full command line environment for that console. That will put `cl.exe` and such in your path.
As a fun exercise, a number of occasions I've fired up Borland inside DOSBox and written 16-bit real mode C programs (along with the DOS version of Vim). Open Watcom can also fulfill this role.
cc and gcc
Tangentially related, if you're looking to see what specific compilers would do with your code, I learned about a tool from an older \[Embedded FM episode\]([https://www.embedded.fm/episodes/190](https://www.embedded.fm/episodes/247)), which was an interview with Matt Godbolt, who developed and runs \[Compiler Explorer\]([https://godbolt.org/](https://godbolt.org/)). I haven't played much with it but it appears to support a couple languages, and quite a few compilers.
&gt; that a project now costs 10x more, which makes it "virtually impossible" Sorry, but you're wrong. "Virtually impossible" is *very different* than "Not Cost Effective". No, nothing is impossible in C that can be done in other languages. It has nothing to do with how much it costs, or how many developers it would take, etc, etc. The argument that something is "impossible" with C is simply wrong. 
No, they aren't. Been coding JS for 20+ years, and learning C for year. I also have been programming Assembly for 35+ years. C to me is like a cross between Assembly an Javascript. They certainly aren't "universes apart". Javascript was invented with the direction that it be a C-like language, so yes, it is like C in some ways. No, not in all ways, but it's not "universes apart" - that's just nonsense an shows how little you know about Javascript or other languages that are actually "universes apart". 
The argument is "virtually impossible". As I said, you could code everything in Conway's Game of Life as well. Or just a straight Turing machine. But that would be insanely stupid. Much like doing most projects in C.
&gt; But that would be insanely stupid. According to *you* and *your* experience. If you want to gatekeep something, maybe pick a different subject. You haven't given any evidence to support that something is "virtually impossible" in C, you're just throwing out hyperbole. 
Is this what y'all are talking about? https://en.wikipedia.org/wiki/Futures_and_promises
**Futures and promises** In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program execution in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is yet incomplete. The term promise was proposed in 1976 by Daniel P. Friedman and David Wise, and Peter Hibbard called it eventual. A somewhat similar concept future was introduced in 1977 in a paper by Henry Baker and Carl Hewitt.The terms future, promise, delay, and deferred are often used interchangeably, although some differences in usage between future and promise are treated below. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
You don't need vsc to use windows.h... Mingw64 comes with windows.h and you can even write and compile windows PEs on Linux.
Delete them? Try a few things out and see what happens.Also I would suggest revisiting the course material (lectures or textbook) or consider reaching out to your professor for some additional help. A there is no shame in asking for help. Your prof will be a good resource and you should start and open dialogue with them. 