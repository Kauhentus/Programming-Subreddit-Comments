Freeing memory when you're done with it is how you avoid leaks. Storing every allocation in a big list, to be freed at the end, is stupid
I like to mix the two. The ctypes method and the Python C API. Probably like ctypes more because then you can run all the C through Valgrind. CPython is not Valgrind clean... I like C for bit and bytes stuff. It just better for that stuff and means you can reuse it anywhere, including Python.
You suggested straight up not freeing the memory and just letting the program exit.
Why would you wait til the end of the program to free something that you're not using? If you have to have a special data structure just to retain the pointer to some memory so that you can free it later, you might as well free it right away instead
Windows does the cleanup for you. There is no memory leaks. 
You may technically be allowed to do that but it's still very poor practice and could easily result in a memory leak when changing your code. That's like saying "let's not close our files or wait for our child processes because the OS does everything for us and we don't need to think for ourselves."
This is the only correct, good-practices answer in this thread.
It's actually the way to do it if you want your program to exit quickly. And there's no reason to think for yourself in this scenario because the end result is the same. Also child processes don't matter. Processes don't share memory. 
Because it doesn't sound like freeing memory is the focus of this student's assignments. It's an organized way to submit assignments that don't leak.
My problem was that all examples are trivial and I have trouble "leaping" from toy "hello worlds" to something useful.
You're a troll.
I wrote an API for a web service with the elliptical curve algorithms in C++, and the API in Python, using Cython as the glue between them. Basically, everything that needs to be fast, I do in C/C++, and then the glue is in Python. It makes it **way** easier for others to **use** your library, but all the benefits of C. &amp;#x200B; In fact, Reddit's old [codebase](https://github.com/reddit-archive/reddit) is done this way (Disclaimer: I do not work for Reddit). High performance routines are written in [C](https://github.com/reddit-archive/reddit/blob/master/scripts/traffic/parse.c), and everything is wrapped in Python.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [reddit-archive/reddit/.../**parse.c** (master → 753b174)](https://github.com/reddit-archive/reddit/blob/753b17407e9a9dca09558526805922de24133d53/scripts/traffic/parse.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e9rmop0.)
Good bot.
For the specific use case you mention, I don't have experience. &amp;#x200B; However, I have on a decent occasion had a project mainly in C that would have support scripts in Python or the testing system would be all in Python (pytest for example) &amp;#x200B; It might be my experience shadowing my bias here, but when you say Python for security in particular, do you mean using Python for things like pen-testing or network traffic related things? Please don't take me the wrong way when I say this, but C allows programmers to write code that can be exploited if they are not very careful, and Python doesn't strike me as much better. If I had to write something where the code base itself needed some security from the language level, I'd probably jump to something with strict and narrow typing systems so that the compiler yells at me when i try to do something unsmart; Python and C don't really offer that out of the box.
Well, imagine you are working on some production code and you have a hundred thousand of `free` calls interspersed all over your code, and as your project grows and develops, you (and the other developers working on the code) need to move those `free` calls around all the time because you're always freeing memory when you're done with it, and "when you're done with it" changes all the time. It's a bad approach.
You know, K&amp;R is a terrible `C` programming book by now. The examples are great, but the book is frequently offering bad advice and addressing issues that no longer exist.
This one's pretty good: http://shop.oreilly.com/product/0636920033677.do
&gt; Freeing as you go is a bad approach Utter nonsense.
Well, imagine you are working on some production code and you have a hundred thousand of free calls interspersed all over your code, and as your project grows and develops, you (and the other developers working on the code) need to move those free calls around all the time because you're always freeing memory when you're done with it, and "when you're done with it" changes all the time.
They wouldn't leak anything because every thing is freed by the OS when the program closes. Keeping a linked list of all references just increases memory usage and cpu cycles. It would only be useful to track allocations in a long running program where you periodically run a garbage collector. Freeing everything at the end is why some programs (games) take forever to exit - and why it easier to just alt-tab, right click task bar, and close the program. The OS will instantly free all memory and file handles. It's instant because the OS initially allocates a block of virtual memory for the program to malloc from, to free it just makes a note that, that memory is now free. Now, if the program has confidential memory, that is important to be freed. Because after being terminated by the OS, the next program to get that virtual block of memory would be able to read previous contents of the memory want cleared - because the OS does not clear the memory, just makes a note that it is free. 
I know this might not be helpful now but I'm about to do exactly that. I'm rewriting a program of mine from C++ to C (a library with all the logic and a CLI/TUI program) and I plan later on to use Python in unison with that for a GUI to see how nicely they integrate.
Of course, but usually for school assignments they check that `free` was called as many times as `malloc` as part of the criterion for a valid assignment submission.
Work-related: I use python a lot for its machine learning libraries and easy-to-use dataframe libraries like numpy and pandas. I had a custom function that performed an operation on an array in O(N) time, that took a slightly tedious amount of time (10-20s every time I ran it which could be multiple times a day). So I took the time to learn how ctypes works, rewrote the functions in c, and passed the numpy array to the c function, where it took under a second. (I actually went back to python after realising that there was an O(N) algorithm for what I wanted, and it ran fast enough without needing to call into C anymore). --- Fun related: I've been writing a game in pure C and SDL on and off for literally the last 2 years or so. Just the other day I managed to get a python interpreter working inside the program and I'm really proud of it! The interpreter is off by default, but at any time while the game is running, you can press the i key, and the game will pause on that frame and start the python interpreter. Then you can send commands from your own terminal into a named pipe with ``cat &gt; pypipe``, and you can alter any part of the game's state at runtime!
Ah yes, so we should write garbage code because the consequences will only last while our bloated monster program is running and not after. /s
Answer to a question from someone I almost forgot about. &amp;#x200B; I just got sick of hoping everything or most of everything was going to work so I started writing some code that at would later become part of this project. Also at the time I just started learning C and did not think to serf on the internet looking for a framework.
&gt; imagine you are working on some production code I do. For software that has to to run for weeks or months at a time. &gt; you have a hundred thousand of free calls interspersed all over your code, I don't let my projects get into that kind of a mess.
Pointing out best practices is trolling now?
C is beatiful language and if you are in, I can only recommend it. Thing is, as already said, it is really hard to program in it for someone, who has just experience high-level language such as Python. But do not worry about it. There are so many thing you do not have to worry about in Python such as pointers and memory allocation and also freeing the memory you allocated. If you gonna learn C you will be able much more to know and realize what happens in your program then in the Python. In Python, you have methods which do stuff for you and in C you have to program much of it for yourself. Still, if you want to learn this language I would maybe recommend you C++ or Objective C. I would prefer C++, because here you are able to do thing such as classes, polymorphism etc. C++ is most certainly one of the best languages in the world hostory in my opinion. You can do exactly the same stuff like in C, but you can do far more. And the possibility of classes actualy prevents (at least I hope) from writing confusing spaghetti code (from a part). And finally, you were asking for a book. Well, from my experience, books aren't very good recource for learning a programming language. Better way is just picking up some project, starting some app of your own and learn things just by doing it. If you are looking for some resources, then [https://en.cppreference.com/w/](https://en.cppreference.com/w/) is a really good documentation. And if you are looking for some book, peak in there: [https://goalkicker.com/?fbclid=IwAR0a6WXdFrQi-TU01tAgMOlNGAvsm9pXd-G4GrOaLZ2xL6eETX4DAvZ4cNY](https://goalkicker.com/?fbclid=IwAR0a6WXdFrQi-TU01tAgMOlNGAvsm9pXd-G4GrOaLZ2xL6eETX4DAvZ4cNY). I think you will find that usefull. Well, good luck to you!
Answer to a question from someone I almost forgot about. I just got sick of hoping everything or most of everything was going to work so I started writing some code that at would become part of this project. Also at the time I just started learning C and did not think to serf on the internet looking for a framework.
These are opinions, and they will change with experience. You don't feel safe using handling certain features, which is perfectly ok; it says nothing about the features themselves. There's most certainly not a lot of discussion on how to write portable code for dead platforms in there. A mention or two maybe. The reason it doesn't discuss high level abstractions is that C is a low level language. I get the feeling that you, like most people; just don't like C very much. But it is what it is, deal with it or find another language.
I think the GObject universe would disagree (reference counting).
This is absolute nonsense. If you're writing a short living program which allocates things which are always used, you can get away with it. However, proper programs run for a long time, and this sort of 'practice' is a damn good way of ending up with the OOM situation.
I understand, thank you for the thorough response! 
I highly suggest K.N. King's "C Programming: A Modern Approach". It's a solid book that's designed to be a textbook but is readable and concise. The problems are also very good.
Bitwise operators confused me a little, but in retrospect since I'm used to learning things very quickly that's what made me not wanna move forward. I shall try once more! Lots of folks are saying that C is a difficult language compared to others but I don't care frankly, it is appealing to me because it's a systems language and I'm a systems guy (well, was, I worked as a root cause analyst for mechanical systems).
Yum is no longer used in Fedora, replaced with dnf.
Hey there! Sorry I replied from another account. Bitwise operators confused me a little but only because I'm used to learning at a faster pace, so I should definitely try once again with K&amp;R. Others have told me that C is a difficult language but I frankly want to learn it and write sophisticated applications with it, and only go for C++ when I really need to. I picked C because it's a systems language and I'm a systems guy (I did root cause analysis for mechanical systems for a while) so I'm used to complexity! 
typedef struct my_s { ... } my_t; my_t *ptr = malloc(sizeof(*ptr)); free(ptr);
One can make the argument that the C standard threading library incorporates the quirks of Windows.
"Other parts of Mozilla" sounds like one company to me.
Any modern `C` style guide forbids the examples I gave. The opinion of anybody paying people to write new `C` code is that you shouldn't do any of that stuff, and it's not language features, it's language abuse. Writing portable code for dead platforms is just one example. There are plenty of outdated concerns that get paragraphs and even sections devoted to them. This is very bad for beginners. `C` is not a low level language, but even if we did say it is, a good `C` book will for example talk about using the Common Initial Sequence idiom. I actually like `C` a lot. Learning `C` to program in `C` like it's 1989 and nobody has learned anything since then is a very poor idea. Take a look at the description of this `C` book: http://shop.oreilly.com/product/0636920033677.do I suppose you can recommend K&amp;R to people who want to program like dinosaurs.
My point is: `typedef struct` `{` `char *thing;` `} my_t;` &amp;#x200B; `my_t *ptr = malloc (sizeof (my_t));` `ptr-&gt;thing = strdup ("Hello, world");` &amp;#x200B; `free(ptr);` `// The memory pointed to by ptr-&gt;thing is not free()d`
i mostly agree, but i would not call C simple. And to be honest i think C is not just more difficult to learn it is also more difficult to make anything with C. Somebody who can't fight through a book like K&amp;R will probably not have a lot of fun using C in a project. Especially compared to python, which makes most things extremely easy/simple to use.
No, because it allocates the size of *ptr, which is the size of the dereference of the pointer. It's better not to use the type name because if the type name changes later to `my_other_t`, you will introduce a bug that is hard to detect. Obviously there are frequent cases where you won't need to free any struct members. Let simple code be simple.
 #include &lt;stdio.h&gt; typedef struct { int one; int two; double three; } my_t; // Should be 16 bytes int main (void) { printf ("Size is %zu\n", sizeof (*my_t)); printf ("Size is %zu\n", sizeof (my_t)); return 0; } test.c: In function ‘main’: test.c:13:39: error: expected expression before ‘my_t’ printf ("Size is %zu\n", sizeof (*my_t)); The `sizeof` operator needs an expression, it can't dereference pointers.
Please do not post pictures of code. I have removed your post so you can repost your code as text instead.
Dude you're not paying attention. You don't do `sizeof(*type)` you do `sizeof(*pointer_to_type)`.
Can’t isn’t really the word I would use, I need to set aside more time, I figured I’d be able to take some shortcuts but this isn’t really the case from what I understand so far. I do actually enjoy it though, pointers and dereferencing and knowing that I’m so very close to the metal is very satisfying.
Thank you very much!
Thanks!
Will take a look, thanks! 
Python actually is a lot better. The largest class of bugs is memory safety, which pure Python had in only extremely rare circumstances (due to issues in the implementation). The problem is, very few languages are performance and memory safe, so you often use extensions (even NumPy) which may have known memory safety issues (even on public issue trackers, with no concern for the ramifications). Using pure Python removes most of the risk and forces you to find an issue in the underlying language implementation (doable, but hard).
I know and love C, to be honest. I've worked a number of jobs where I used it extensively, mostly in the embedded field. I also know Rust, done a bunch of personal (crypto-related) project with it and I've hung around the Mozilla office trying to fix Firefox bugs and check out Servo (with mediocre success). I also know C++, haven't used it outside of personal projects, but yeah. Note that the last time I used C++ was like 5-10ish years ago, and I kinda know what's new in it, but not really. My point was, Rust's borrow checker is theoretically awesome but also a bit overkill, for example it doesn't let you do some things that are safe but you can't convince it of that. What I meant was, what if you just took a good old type system, like that of Haskell, or a cleaned C++-kind type system, or maybe even use Rust's type system with the traits, and put it on top of C? That way you can exclude some classes of bugs and you can write more expressive code (like, you can try to eliminate `void` pointers and replace then with something more semantic). That would be something that I could see people actually use (I'd love to have used that when doing embedded!) but you won't have that resistance against a wholly new language as you have with Rust. Do you get what I mean now?
I worked on a system used to generate geographical databases used for simulators. We had one engineer who didn’t understand the concept of freeing memory properly. Long story short, the system was left up over the weekend for a test, and the whole system came to a screeching halt because all of the memory was consumed by blocks of memory that hadn’t been freed properly. Writing C programs means YOU manage your resources. If you don’t learn this early, your coworkers will hate you. Or they will laugh at you and talk about you behind your back, even YEARS later! Right, T?
&gt; C is not a low level language TIL that accessing memory is not low level anymore
Some idiot writes an article claiming C isn't low level because it has an abstract machine of a computer and people repeating it. *sigh*
I thought of that solution but that will make the loop too long.
`foo()` is a function meant to step through a string `s` and returns an integer `i` equal to the numbered space where a character `c` occurs within `s`. If `c` does not occur in `s` then `i` is set to `-1` and that is returned. `a` should be `7`. `b` should be `-1`. In the future I recommend compiling the code and playing around with it to see what it does.
From one of the comments there - &gt; Except that's a really bad analogy. It's more like you set up guard rails, and every time your vehicle hits a guard rail you change the algorithm it uses for navigation until it can do a whole run without hitting a guard rail. That’s what we call machine learning nowadays.
I see now, thank you
An integer on my computer is 4 bytes. How does this relate? Do I first convert it to bits?
On basically all common systems, there atlre 8 bits to a byte. A 4 byte integer is 32 bits, and therefore can hold 2^31-1 values.
As long as you're not programming on some esoteric system, CHAR_BIT will be set to 8, meaning that are 8 bits to a byte. C89 guarantees at least 8 bits to a byte, however, some DSPs and embedded devices may not have 8 bits to a byte, and may rather have 12-16.
Although you seem to be using your dumpmem() function for smallish size values (4, 8, etc.), it can in principle be used for extremely large values too, larger than what could fit in an int (like say an array larger than INT\_MAX on a 64 bit system). So the suggestions to use size\_t are to help making such functions correct generally, not just for your specific use case. It may not affect you here, but it's the "why": size\_t should almost always be used as the type of a variable containing the size of a C object (arrays, pointers to allocated memory, etc.). That's just what it's there for, to make code that works for the general case. The "unsigned int" suggestion is a separate issue, and I would ignore that suggestion until you learn more; size\_t is the more correct type for both "size" and "i" (imo).
 In your case is as simple as copying everything between two separators which in these case are newlines or a newline and the EOF.
hi, thanks for answer, could you show me the code? the txt file have the numbers: 1 2 How can i get the "2" value, or search for the second line and assign it to a variable?
Do your homework brother. Learn how to load a text file into a char buffer, iterate trough it and find think of a way to find the starting index for line and two and its ending index so that you can then use memcpy into a fresh char ptr and free your your original char buffer with unnecessary information.
could you at least tell me what functions should i use?
could you show me some code?
&gt;Can this loop through 8GB of data--the dumpmem function? The answer is "it depends". Since you say below that an int is 4 bytes (32-bits) on your platform, the answer in your specific case is "no". The "size" variable cannot even be set to an amount equaling 8GB, and since you assign "data" to a variable that points to chars, this means \*in that specific case\* the answer is "no". But, there are a number of ways in which this code could be modified slightly to make the answer yes, assuming you have a system that is capable of addressing more than 32-bits of RAM. &amp;#x200B; First, if you have a 64-bit system, the type "size\_t" (and possibly "long") can hold a count of chars that is sufficient to do the indexing of a char array of length 8GB. So, a type of size\_t for "i" and "size" would be sufficient on such systems; it works because the size\_t type would be bigger than the int type, and thus hold larger values. &amp;#x200B; \*Another\* way, would be to cast the "void \*" of data to type larger than a "char \*", so that each index value represents a size larger than 1 char. For example, casting data to "int \*" on your system where an int is 4 bytes (thus 4 chars), means that even a 32-bit int index could address values greater than 8GB (basically, up to about 16GB). Note, this is best done only when data is actually pointing to ints, or some other type larger than a char, and even then one has to be careful about overflowing the "i" index value. In such cases, "size\_t" is still the better choice; size\_t is just meant to hold sizes and avoids some of the problems that can arise from using int. &amp;#x200B; Remember, in C, the expression p\[i\] is exactly equivalent to \*(p + i). Ie. the compiler changes array indexing expressions to pointer arithmetic, and "pointer arithmetic" in this case is adding a pointer value (p) and a number value (i). Note that in the \*(p + i) expression the C compiler \*always\* scales the integer value up to match the size of the type, and uses a value large enough to hold that expression. This is why, in the example above where the int "i" variable may only be 32-bits, and "p" points to ints, the pointer arithmetic can address a value larger than 32-bits. Basically, the compiler converts the int into a type large enough to make the pointer addition correct (ie. 64-bits). \*But\* the value it starts with is still just 32-bits (in this case), so don't confuse that with expecting the int "i" variable to hold values larger than 32-bits. That's just why it's generally safer to just start with an index variable type of size\_t, that's large enough to hold all the address space values in the first place; the variable is larger, but the compiler has to do less work to convert it to the right size when indexing. &amp;#x200B; In short, using size\_t for the "size" and "i" variables would make the answer a definite "yes" (on systems that support addressing greater than 8GB of memory).
The PDP-11 is why I tell people to always use `hton()`/`ntoh()` in pairs and not just use `hton()` to go either direction. Sure, no one is going to make a middle-endian box anytime soon without damn good reason, but there is no reason to risk it. Plus it shows intent in the code. The Motorola 68000 alignment issue came up on a job interview I had 2 months ago. Whatever the current version of that chip the company was using for an embedded project had the same concern.
There's a problem in the exponent, extra -1, no? 8 bits, 2⁸, 256 different values, and so on...
Do you understand what exactly fgets() does? 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
`(65&lt;=str[i]) &amp;&amp; (str[i]&lt;=90)` is just `str[i] &lt;= 90`. Your conditions are wrong. 
Whatever your line reading function is, if you need third line, you have to read previous two first and just ignore them.
thanks, that's the l-value concept, right?
In C, strings are null-terminated. That is they have an extra `'\0'` character at the end to signal the end of a string. That means that the string `"abcdefghi"` consists of the 10 characters `'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', '\0'`.
Don't thank me yet. That was not *the* problem. Here's a cleaned up (a bit) version of your code: ```c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; const char* taz(const char* const str, char * new_str, unsigned long long i, unsigned long long pos) { printf("To taz: \"%s\", index: %llu, char at index: %c\n", str, i, str[i]); if ( i == 0 ) { return new_str; } else if ( 65 &gt;= str[i] &amp;&amp; str[i] &lt;= 90 ) { new_str[pos] = 90 + (65 - str[i]); } else if ( 97 &gt;= str[i] &amp;&amp; str[i] &lt;= 122 ) { new_str[pos] = 122 + (97 - str[i]); } printf("Tazzed: \"%s\"\n", new_str); return taz(str, new_str, i-1, pos+1); } const char *whirled(const char * const str) { size_t str_length = strlen(str); printf("kontrolle. eingegebener string: \"%s\", laenge des strings: \"%lld\"\n", str, str_length); char *new_str = (char*)malloc(str_length); const char* output = taz(str, new_str, str_length - 1, 0); return output; } int main(int carg, const char **varg){ if ( carg != 2 ) return -1; printf("Die verwürfelte Version von \"%s\" ist \"%s\".\n", varg[1], whirled(varg[1])); return 0; } ``` Now, see why "Tazzed" lines in output have empty strings. Debug that issue. BTW, I fixed the line `const char* output = taz(str,...`. You forgot about nul byte.
I'm surprised about the HP Saturn being 4 bits, but all C data types are multiples of 8 bits. Surely there must have been a way to use the native 4-bit type?
The what now?
Aren’t chars defined to be the smallest supported type on a platform? For an 8bit-byte, you’d use uint8_t
In the rare case that you really need to copy some characters without the terminating zero, see memcpy or strncpy.
Think it thru first, THEN type it out. Recurse with the first character, to eventually get the last character inverted and when the recursion returns, replace the 1st character.
By the way, you also have a bug in the following line. You need a format specifier string for `printf`, e.g. `printf("%s", buffer)`. Or you could also use `puts` if you want to print a string and a new line. If you don't put a format specifier string as a first parameter, it will treat in this case `buffer` as the format specifier string. This can be a problem if you would put e.g. `%d` or `%s` (among all the others) somewhere into `buffer`. The result would be that your program would treat the memory addresses after `buffer` as `int` or `char *` and would print them out.
Actually, \_I\_ should think first, before pressing SEND. Couldn't make it work the "really neat" way I thought it would. &amp;#x200B;
I worked on an awful lot of these over the years. I have a lot of fond memories of the 6502 and 68000. I'm surprised that they didn't mention that the 8051 has no good way to access stack space, so most C compilers use a pseudo-stack which prevents recursion. As a result there is no ANSI compliant C implementation that I'm aware of.
Yeah sorry, 256 values but up to 2^8-1.
I've programmed on a DSP platform where `char` was 16 bits. There was no 8-bit type because the hardware had no concept of it.
TIL that the C standard defines the minimum size of data types, based on [wikipedia](https://en.wikipedia.org/wiki/C_data_types): &gt; signed char | Of the same size as char, but guaranteed to be signed. Capable of containing **at least** the [−127, +127] range; &gt; unsigned char | Of the same size as char, but guaranteed to be unsigned. Contains **at least** the [0, 255] range.
No, that's exactly not what I mean. C++ is a different language. Some might say that it's an ugly mess of a language, which is debatable. TypeScript is a superset of JavaScript that compiles down to JavaScript. That's what I'm looking for, something that you can kind of inject into a C project, that compiles down to C itself. C++ mangles names, so you can't just mix and match it. 
For some reason I see 2 small(8-1) on my screen, instead of 2 small(8) and normal size -1. Maybe it's this browser that shows it wrong? Let me too try the superscritp button: Surely 2⁸ - 1 is 255, 2^(8-1) is 128.
hi, can you show me the code to do it, read the 3 line? thanks
You confuse the term “byte” (least addressable unit) with “octet” (8 bit quantity). On many machines they are synonyms, but as the article illustrates, there are some machines where a byte is made of more or less than 8 bits. The C standard mandates that a byte has at least 8 bits, so on machines where this is not the case they have to do some tricks, like treating two bytes as one.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Oh didnt realize sorry
i just need the code, please give me some code, my txt file has the specs 12345 line 1 12212 line 2 How can i get the second line, and pass it to a string in my code? Thanks for any help(code)
I'm not going to do your homework for you, sorry.
ok thanks, i'll look into these sites
i just don't understand why it's so complicated, i'm new at C, but i can code for a language called mql4, and it's based on C, on mql4 there is a simples function "filereadstring ()", you can easily get any line you want, i don't know why there is no such thing on C, because it's the father of mql4
Thanks, that's clear and well put
Well, I know the basics, data structures implementations... But I had never worked on any real world project... for "online" I mean working outdoor not at a company desk.... hope u understand
Morocco
This can make things difficult as Morocco is not in the EU and not part of any other agreement I know of that makes international work permits easier to get.
What fraction of C programs would anyone ever want to run on a PDP-11? A far more relevant issue today is recognizing that even though: 1. The authors of the Standard didn't want to preclude the use of the language as a form of "high-level assembler" [they *explicitly* say so in the published Rationale], 2. The Spirit of C includes the fundamental principle "Don't prevent the programmer from doing what needs to be done" [again, an explicit quote from the Rationale], and 3. Many compiler writers throughout the years thought the notion that compilers should uphold the Spirit of C that they saw no need to explicitly document that they did so. the faction with control of influential compilers favor a dialect which they claim to be "official", but which is openly hostile to such principles. 
&gt; But I had never worked on any real world project... This will be your biggest hurdle. Even with a bachelor's degree a lot of companies won't accept anyone without some form of real world experience. You need to look for projects you can contribute to, create some projects of your own, or find internships that will accept you with your limited experience. &gt; I mean working outdoor not at a company desk.... hope u understand If you don't want to work in an office and you want to develop software you're looking for remote work which is usually not a possibility employers want to provide to entry level employees. Typically, companies that allow remote work only offer it to workers with provable experience without a lot of supervision; they want to know that they can rely on you to do work without people physically there to make sure you're doing it. Based on what you've told us I think you have a lot of work to do before you can consider getting a developer position, much less before you get a remote position. As before, I recommend bolstering your github to help show your expertise. You may also have luck with recruiter services like [triplebyte](https://triplebyte.com/) who will look at your skill set and try to match you with companies that are looking for employees like you. If nothing else, they can help show you where you need to improve. Hope that helps. Please keep asking questions and providing more information; I'm always happy to help however I can. Also bear in mind that my suggestions are not sureties, there are other avenues available to you and some may be better for your needs.
Implementations can be divided into four categories, with the Standard having newly added the fourth: 1. Those which support any kind of threading, where `errno` is inherently threadsafe [because there's only one thread]. 2. Those which do threading via some means not recognized by the Standard, which processes `errno` in a fashion that happens to be thread-safe. 3. Those which do threading via some means not recognized by the Standard, which processes `errno` in a fashion that isn't thread-safe. 4. Those that do threading via means recognized by the Standard, which requires `errno` to be processed in thread-safe fashion. Conforming implementations of all four kinds still exist, and the Standard has done nothing to affect the thread-safety of `errno` in #1 and #3 (where it was already thread-safe), nor #2 (where it still isn't). 
The page you linked to contains C++ code, not C.
Can you post what errors you get with QueryPerformanceCounter? Because it's what I use in my projects and find it really simple to use.
What errors are you getting and how are you getting them? Is QueryPerformanceCounter() returning zero, or is it your compiler, or something else? This function is really trivial to use, so there must be some confusion.
my txt file is 12345 line 1 22232 line 2 1111 line 3 i changer in your code fopen to fopen ("myfile","r"). I'm running linux, but still, it does not get the 3 line. What should i change? Thanks &amp;#x200B;
what's next, you are gonna show me code in assembly? I'm 100% sure that you know there is a simple way to do this, your code does not even work
Do you have an error? It works for me: ``` shell$ cat myfile 12345 line 1 22232 line 2 1111 line 3 shell$ cat print3line.c #ifndef _POSIX_C_SOURCE #define _POSIX_C_SOURCE 200809L #endif /* !_POSIX_C_SOURCE */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { FILE *fh; char *buf; size_t len; int count; if ( (fh = fopen("myfile", "r")) == NULL ) { perror("fopen()"); return 2; } len = count = 0; buf = NULL; while ( count++ &lt; 3 ) { if ( getline(&amp;buf, &amp;len, fh) &lt;= 0 ) break; } fclose(fh); if ( count == 4 ) fprintf(stdout, "%s", buf); else fprintf(stderr, "File too short\n"); free(buf); return count != 4; } /* vim: set ft=c sw=4 sts=4 et: */ shell$ gcc -Wall -Wextra -pedantic -pedantic-errors -std=c11 -pipe -o print3line print3line.c shell$ ./print3line 1111 line 3 shell$ ``` 
It works. If you don't know what my code does, get the manual and read. It's a very simple piece of code, nothing fancy.
The existence of mixed-endian system upon which almost no code will be expected to run doesn't seem like a portability issue that today's programmers should spend any effort worrying about unless they happen to be vintage-hardware enthusiasts. At the language level, there aren't really all that many hardware variations programmers would need to worry about. If a program avoids reliance upon the relative sizes of pointers and integers, and uses `intN_t` etc. whenever possible, the specs of 99% of platforms would imply four dialects of C: * Little-endian platforms where a `uint16_t` promotes to 32-bit `int` * Big-endian platforms where a `uint16_t` promotes to 32-bit `int` * Little-endian platforms where `uint16_t` promotes to a 16-bit `unsigned int` * Big-endian platforms where a `uint16_t` promotes to a 16-bit `unsigned int` Many programs will never have to run on any platforms other than the first two types, and a fair number of those would never have to run on anything other than the first type. Unfortunately, each of the above is split into multiple sub-dialects, including one which is unsuitable for most purposes involving low-level programming, and one of which needlessly impairs many useful optimizations, making portability a more difficult problem today than it was in 1990.
Yes. It might be slightly iffy (i.e., warning-worthy) to some compilers because the `[4]` doesn’t include room for the implied NUL at the end of `"abcd"`. (In which case—sans NUL—now I think on it, you really shouldn’t be running `strlen` on it. If you leave the `4` out entirely, it’ll size the array correctly for you, and that size should end up as ≥5 or otherwise `strlen` might break things when it wanders off the end of the array. Or worse, the compiler might see that `strlen` will be wandering off the end of an array, and then it’s free to do pretty much whatever with your code.)
The formatting of your code currently makes it unreadable, please put four spaces in front of each line of code. Next, look up the documentation for (fscanf)[https://linux.die.net/man/3/scanf], you seem confused about the arguments it takes.
 char *in_file = "input_file.txt"; char *out_file = "output_file.txt"; int main() { FILE *in_fp, *out_fp; fscanf("%d", "input_file.txt", &amp;MAX_ENTRIES); int i = 0, j, numOfStuff; time_t cur_time = time(NULL); So from that website I am missing an int at the front of the code, FILE *stream, const char *format? I have another fscanf in my document that works that doesn't have FILE in it and doesn't have any stars to denote pointers either though... Is it 100% broken on that lol because that format makes it hard to do. 
Need full code for better explanation on what's going wrong; use GitHub Gist or similar code sharing service, or read the rule #1 from the sidebar. FWIW, your code does not have the declaration `MAX_ENTRIES` and is using `fscanf()` wrongly. I recommend you to have a look at [`fscanf()`](https://en.cppreference.com/w/c/io/fscanf) and [`fopen()`](https://en.cppreference.com/w/c/io/fopen).
I don't see where you declared MAX_ENTRIES as an int or something before you tried copying a value to it. I also don't see where you opened any files and stored the file pointer in a variable.
Everyone talked about architecture and not of the most important: The simple and elegant beauty of C. A 30+ love story for me ;)
I think that did it const int MAX_ENTRIES = fscanf("input_file.txt", "%d"); is giving me no errors. I didn't realize fscanf didn't define it lol
So your entire point is that it isn't likely that code will run on a Middle Endian system, which is something I conceded in my original post? 
please look through the basics of file input/output. You have clearly the wrong idea of how to access a file in C. 
You should be asking your professor for clarification, not Reddit. My best guess? Since there's no menu option to input the data, I don't think the user is supposed to be involved at all. Just generate two arrays with random data inside them.
i just needed a simple piece of code to read a line in the text and pass to a variable, i lost days because of this, and the other guy show me the most complicated possible way, for a newbie. There's even another one telling me to use pointers to do it, pointers in C are for high skilled programmers. If you want to help me, just please give me a funcion: searchstring\_line ( name\_file , search\_line) &amp;#x200B; that would be great
Makes sense, thanks a lot for the explanation :)
I would email her but she takes a while to respond. Thanks for the advice
- The C Programming Language, 2nd edition. - The Practice of Programming - APUE 3rd is good buuut it uses *shims* so different functions are wrapped, and 2 o 3 examples don't work under OpenBSD. In real life, you'll get similar shims with full of #ifdef's, so IDK. - The Design and Implementation of BSD 4.4 Operating System is good to know the internals and learn about system calls. Not a much code but loads of implementation and tips on processes, signals and how do they behave.
1. calculate how many spaces you need 2. use another loop to print that many spaces.
The 286 stuff refers mostly to real mode AFAICT, which is how most people dealt with x86 in the old DOS days. —So it’s really centered around the *8086*, not the 286; very few changes were made to the real-mode-available parts of the ISA in the 186 and 286, just things like removing `POP CS` (opcode 0F, now used as an extender prefix) and adding shifts-by-immediate (previously, only shifts by 1 and CL were permitted). Most compilers cared more about the possibility of there being a 8087 or 80287 FPU attached, than they did about the specific CPU type. What the article was referring to mostly was the memory models compilers supported, which dictated how big your code, stack, data, and heap could be. If you were running in the tiny model, everything had to fit into 64KiB (.COM files used this), meaning your code+data pointer sizes were 16-bit and so was `size_t`. If you were running in the large model, pointers were segment+base and therefore 32-bit, but single memory blocks had to remain within a 64-KiB window. The huge model used a linearized form of the full address (segment\*16+offset) instead of separate seg+offs components, and so `size_t` per the huge model *could* therefore be up to 20-bit IIRC. For some modes, code and data pointers were different sizes, and when a segment wasn’t included in the address, code and data regions could have identical pointer values. On top of the memory models, you had to qualify some static-lifetime thingummies as `__far` or `__near` or `__huge` to specify where that object could live and how it had to be accessed; accordingly, you often had to qualify your pointers so they could accomodate the address of whatever you were referring to. (E.g., a pointer to `__near` could not accept a `__far` address, but a pointer to `__far` could accept a `__near`.) The 80286 *specifically* was what I was hoping the article’d discuss more. It added 16-bit protected mode, which was its own special kind of (quasi-inescapable) crazy. (Not sure why 286 was mentioned at all without that factoring in.) In real mode you had fixed segment bases (every 16 bytes) and sizes (=64KiB), and through those you could access a 20-bit (=1-MiB) physical address space (+change once A20 was a thing). In 16-bit pmode, you had access to a 24-bit (=16-MiB) physical address space and every segment was defined independently from the others, with no correlation between the number in the segment register and the physical range the segment referred to. Segments could be set to start at any 24-bit base address, and their sizes could be set to anything ≤64 KiB. You really were limited to 16-bit everything, so no huge memory model was possible—the memory model could only really dictate which pointers included segments and which ’uns were offset-only. (And you couldn’t get back into real mode without resetting the processor or using the LOADALL instruction, which was of course undocumented. Because of all this, I’ve heard of code dipping briefly into 16-bit pmode for things like expanded memory emulation, but I’ve never heard of any DOS-based code that actually *stays* there. IIRC Xenix was like the only OS that could actually use it fully, maybe OS/2 as well?) Fortunately, very few people ever had to deal with 286 pmode; most people started in on pmode once the 80386 came along, since it extended segment size to 32-bit (=4 GiB), added in paging, and added the VM86 mode to awkwardly emulate real mode from within pmode. Also frightful tricks like “unreal mode.” 32-bit software *could* do the same kinds of segmentation crap that the 16-bit pmode software could, but fortunately most OSes/compilers/ABIs just set CS/DS/SS to span the full 32-bit space and use paging for the rest of the protection scheme, giving everyone a nice VAXish flat model that was mostly maintained into the 64-bit era. We should all be thankful that 48-bit pointers were not a thing, because that’s what a large-ish memory model would look like on the 80386. Also, nitpick: The Symbolics C `long` size is wrong, should be ≥32 bits (both because the C standard requires it and because the compiler does it). The linked manual has LONG_MIN -2147483648 minimum value of a long int LONG_MAX +2147483647 maximum value of a long int ULONG_MAX 4294967295U maximum value of an unsigned long which presumably means it’s a two’s-complement 32-bit value. Anything sub-32-bit would be incompatible with C89.
So, let's think about it. Suppose that we are trying to do this for N rows. Then, the composition of each line will be like this: For Mth row where M is between 1 and N inclusive, * Print `N - M` spaces. * Print `M` asterisks. And to do this, you will need 3 loops, one loop that prints `N - M` spaces, another loop that prints `M` asterisks, then the last one that embraces both loop for `N` rows. ---- As in your sample, Let's see when N is 5: * 1st row: we need 5 - 1 = 4 spaces, then 1 asterisk. * 2nd row: we need 5 - 2 = 3 spaces, then 2 asterisks. * 3rd row: we need 5 - 3 = 2 spaces, then 3 asterisks. * 4th row: we need 5 - 4 = 1 spaces, then 4 asterisks. * 5th row: we need 5 - 5 = 0 spaces, then 5 asterisks. And then you will get this: * ** *** **** ***** Now the only thing left is to translate this logic into code, and that is your job to do.
I'm not really a c programmer, but I would say zero computers have ever run C. Object code is produced by C compilers and run on these machines, but it's kind of like asking how many computers run coal. Power plants produce electricity from coal, but you wouldn't say your tooth brush or coffee pot runs "coal". Processors run instruction sets. Compilers and assemblers produce opcodes for these instruction sets. Unlike assembler, compilers emit byte code that is designed for multiple architectures. You could, for example, write a C compiler that produces byte code to run on BEAM or the JVM, ARM or the zilog Z80. None of these machines (virtual or not) run "C". Operating systems typically have libraries to make it easy for C programs to work with them, but this is part of the operating environment. Under the hood, it will always be the instruction set of the processor. Hope that makes sense?
Thanks. We just started learning C in college and your explanation actually helped a lot.
use a nested for loop, the outer loop is the line number, the inner loop positions the indentation on each line.
ok i give up, thanks for your time
It would hold 2^32 values. An unsigned int could hold any number between 0 and 2^(32)-1. A signed int could hold any number between -2^31 and 2^(31)-1
Put parens around your exponent 2^(8)-1 Becomes 2^(8)-1
Happy coding!
Try `man 3 getline` first and remember what I've said in my first comment.
&gt;your code does not compile, it's shell script, but i have no idea how to work with it, can you show the code only in C?
I will study your code, thanks for now 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [superluserdo/Generic-Dynamic-Vectors/.../**vec.c** (master → 3bf4158)](https://github.com/superluserdo/Generic-Dynamic-Vectors/blob/3bf41584b1d05e6ecf7cce35254ab15a04eea111/vec.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e9u93vm.)
21st Century C is good. Explores all the tools you usually end up using like gdb, valgrind, auto tools, etc.. Expert C Programming is also excellent as well as The Standard C Library by Plaguer.
Also, what I found very useful after going back to learning C after years of programming in other languages was relearning how to implement basic data structures in C that you got for free in those other languages like stacks, queues, trees, hashes, etc. There are books out there specific to that. 
 for(i = 0, i&lt;max; i++) { draw(i,i); } That will draw a diagnol line
IMHO, the designers of the 80286 and 80386 failed to recognize one of the great things about the original 8086 design: not only can code which works with objects less than 64K limit address arithmetic to one part of an address, but code which manages objects with 16-byte granularity can do likewise with big objects. If e.g. a text editor rounds all line lengths up to the next multiple of 16 bytes, it can store the addresses of all the lines in a document using two-byte pointers instead of four-byte pointers. If the 80386 had used 32-bit segment identifiers, with the upper part used to select a segment descriptor and the lower portion shifted by an amount specified in that descriptor, then languages where pointers identify allocated objects, rather than individual objects within an allocation, that would have allowed the use of 32-bit references to identify objects within a 64GiB or larger address space. 
Fix the "eyes glaze over" problem. Just push through Kernighan &amp; Ritchie "The C Programming Language" (K&amp;R). It does only cover C89 but the newer features can be easily learned on top of that. The book is very dense and almost every sentence contains important information. There's also Harbison &amp; Steele for detailed C knowledge and "Advanced Programming in the UNIX Environment" by Stevens &amp; Rago for detailed POSIX knowledge, as well as the C11/POSIX standards, but these resources are neither short nor really a lot of fun to read. I'd suggest to do projects and read sections from these when you need to.
It's not exactly a bug; `buffer` is a vid format string. But it is good security practice to use a literal format string instead, in case `buffer` might contain `%` in some future version of the program
Malloc just returns you a block of memory, you decide what to do with it and where to store variables using pointer arithmetic.
You'll probably enjoy Beej's guide to C programming. Currently, it's a working draft, however, I still found it as a great learning resource. The author has a good sense of humor, the material isn't dry and boring, and the contents are easy to understand and digest. &amp;#x200B; [http://beej.us/guide/bgc/](http://beej.us/guide/bgc/) &amp;#x200B; He also made other great guides like network programming in C which I found helpful. That, and other guides can be found here: &amp;#x200B; [http://beej.us/guide/](http://beej.us/guide/)
What did you mean by "Sure, no one is going to make a middle-endian box anytime soon without damn good reason, but there is no reason to risk it," if not to imply that the risk of code being called upon to run on a middle-endian box was at least as significant as other risks that programmers often fail to accommodate? Did I not understand your intention?
Ironically, on *many* platforms, an implementation that statically allocates automatic objects would be superior to one that uses an actual stack for most purposes that don't need recursion. Among other things, implementations that don't have to support recursion can guarantee that if there won't be enough memory to run a program, it will get rejected at link time instead of malfunctioning unpredictably at run time. That to me seems vastly preferable to the "allocate some stack space and hope for the best" semantics of more "conventional" C implementations. 
What are the 8 boxes? Bytes? Does the red curve mean that malloc has returned those 4 bytes to the caller? What are the blue circles for? "in use" by who?
malloc returns a pointer to memory and the only guarantee you get is that subsequent calls to malloc won't return memory that overlaps with it. I'm not sure what you mean by 'create a new variable'.
Just a side note: this is commonly referred to as "array decaying" if you want to google more about this.
I agree in general with this, although implementations I've seen on the 8051 aren't great. It isn't very standard though and does mean it's not really C.
I think that what you're asking is: If I malloc x bytes (for a character array) but only use up x - n bytes, will the "unused" memory that I allocated be available for other usage. If that's your question, then I believe that the answer is technically no. The whole point of allocating heap space with malloc is to ensure that you have that space available. That said, you could always forcibly use the "unused" space by storing data with pointer arithmetic. At least I think so. I'm honestly not very proficient with C and try to keep learning by tracking this sub and trying to answer any questions on my own (normally without posting).
You could do this with a char array, just fill it from the end to the beginning (don't forget to leave the '\0' terminator).
\#include &lt;stdio.h&gt; int main(void) { FILE \*file; file = fopen("a.txt", "r"); char a\[1000\]; fgets (a,100,file); fgets (a,100,file); printf( "%s",a); fclose(file); return 0; } Here it is, the code. I have a strong feeling that you were trolling me, why did you do it? 
yes, but why not give me the code already? i lost 1 day the code is very simple \#include &lt;stdio.h&gt; &amp;#x200B; int main(void) { FILE \*file; file = fopen("a.txt", "r"); char a\[1000\]; fgets (a,100,file);// here you can place a while to get x line printf( "%s",a); fclose(file); return 0; }
Your code: 1. will work incorrectly if a line is longer than 999 characters, 2. will work incorrectly if there's less than 3 lines in a file, 3. does not conform to DRY principle, 4. does not check for errors. Simpler and shorter does not mean well written.
&gt; Then I saw the bit addressable CPU used for some early 90s Midway arcade games. Imagine that pointers don't point to a byte position, but a bit position. You still have this feature on Cortex-M4, it's called bit-banding and it's pretty neat. For each address, you can calculate a memory area where each bit counted from that address is. 
The Standard may not recognize such implementations, but I'd regard the dialects used by the better PIC and 8051 implementations as honoring the Spirit of C(*) far more than the most aggressively optimized dialects favored by gcc and clang. I wish the Standard would recognize that it's more useful to define the meaning of programs than to require that all (or even most) implementations be capable of process them. Given that the Standard wouldn't allow a conforming implementation to behave in arbitrary fashion any time a function is nested more than two deep, there's no real requirement that recursion be supported *usefully*. Given that, which would be more useful--to say that implementations must accept programs that use recursion but may behave in arbitrary fashion when two-deep function calls are executed, or to allow implementations to reject programs that they can't process usefully? (*) As described in the published Rationale documents for the Standard, the Spirit of C includes the principles "Trust the programmer" and--more fundamentally--"Don't prevent the programmer from doing what needs to be done." I interpret the two together as implying "Trust that the programmer knows more than the compiler writer about many things, including what needs to be done". 
It's been removed from Cortex-M7, so relying on its existence (other than for speeding up special code) isn't recommended.
ok i understand, good bye
What do you mean by less smoothly? Apart from possibly relying on size of pointer, most 32 bit code runs as-is when compiled for 64 bits as int was left at 32 bits.
I just always use #ifdef CPU_HAS_BITBAND #define BITBAND_SRAM_REF 0x20000000 #define BITBAND_SRAM_BASE 0x22000000 #define BITBAND_SRAM(a,b) (*((volatile uint8_t *) ((BITBAND_SRAM_BASE + ((uintptr_t) (a)-BITBAND_SRAM_REF)*32 + (b*4))))) #define BIT_SET(val, bit) (BITBAND_SRAM(&amp;(val), (bit)) = 1) #define BIT_DEL(val, bit) (BITBAND_SRAM(&amp;(val), (bit)) = 0) #define BIT_CHK(val, bit) (BITBAND_SRAM(&amp;(val), (bit))) #else #define BIT_SET(val, bit) (val |= BIT(bit)) #define BIT_DEL(val, bit) (val &amp;= ~BIT(bit)) #define BIT_CHK(val, bit) (val &amp; BIT(bit)) #endif
And this is C. Wrong sub.
C &gt; C++
my bad. I'll go find the right one
my bad.
Prior to the advent of C99, the closest thing to a fixed-sized 32-bit type in the microprocessor arena was `long`, and I see no good reason most implementations shouldn't be able to support code that expects `long` to be 32 bits. Most code doesn't care, but there was never any need to break code that did.
No problem brother. Good luck, references dont exist in C. You always pass a copy of the value in C, even with pointers to pointers.
ohhh no worries not felling offended; I just wanted someone with more experience to confirm what the correct answer was thanks again
If you have `char a[]` as a function parameter, it is *adjusted* to `char *a` prior to any further analysis. It's actually impossible to pass an array to a function in C. You actually pass a pointer to the first element of the array (and no other information such as the array's size). 
sizeof() will only give you the size of memory being allocated for that variable. an array is a chunk of memory with multiple elements, but the actual label is just a pointer to the first element, so when you use the sizeof function you are getting the size of that first element. this is both the beauty and downside of arrays; it uses very little space, but it does not contain much information. you have a few options of how to combat this. First, you could pass a second value into printCharr() to denote size like so: void printCharr(char a[], int size); second, you could use a data structure type that stores more information, such as vector, which has a size() function. third, you could do what strings do and denote the last element of the array with a special character. with strings, it is a null character '\\0'. you have a loop to print each element as you do in your current code, but have the condition be to continue while (a\[i\] != '\\0'), which can be simplified to !a\[i\]. finally, you could have a global variable for the size of the array that can be used from anywhere in the code. for an early programmer, i'd recommend the first. it is the method that a textbook will most likely give, and is pretty straightforward. some may recommend the global variable first, but it's generally frowned upon for most application in higher programming, so i'd be careful about relying too heavily on global variables.
The code you found works fine for most stuff if you use it as a macro instead of a function
IIRC, some compilers like gcc have extensions that could be used to catch the situation when NUMBER(array) is given something else than an array as the argument.
We need more information in order to help you. What's changed since these programs were working? Can you share source code?
The format string of printf() can do various things. You could use left/right alignment and field width for similar effect. Like "%-6s" etc. But I don't know, you were likely supposed to learn to use loop constructs here.
&gt; The size information is lost when passing the array to a function Why?
What I think you are asking is if local variables are stored in as-yet-unused areas of malloc()ed memory, and the answer is "no". In practice, malloc() allocates memory from the "heap", and local variables are allocated on the "stack" (typically). The "stack" is used by the program for temporary value, such as the address to return to when executing a subroutine, arguments that are passed to functions, variables used within functions, and return values from functions. When main() starts, there is relatively little on the stack (maybe just the variables used by main(), but as functions are called and return, things get put on and taken off the stack over time as needed. Generally the stack isn't meant for huge amounts of data, which is why (for example) it isn't a good practice to allocate large arrays in C functions (ie. buffers), since those can use excessive amounts of stack space. Use too much, and the operating system can kill the program, or other worse side effects can occur. &amp;#x200B; So, to allocate a large buffer in a function, even one that is only going to be used within that function, the preferred method is malloc() which gets its memory from the "heap". (note - this isn't the same as the 'heap' data-structure, it just has the same name). There are actually multiple ways to allocate that memory under-the-hood, so for now just realize that the "heap" is meant to allow much larger memory allocations than the stack, and furthermore, the lifetime of those allocations can last beyond the lifetime of a function call (or block scope); the pointer to the malloc()'ed memory can be passed to different functions, etc. and will exist until it is free()'ed. &amp;#x200B; All this is actually an oversimplification. "automatic" variables in C can be allocated in a register, and malloc()'ed memory can be obtained from other areas of the program's address space (such as with mmap()), but this is meant to get you started. [https://en.wikipedia.org/wiki/Memory\_management#HEAP](https://en.wikipedia.org/wiki/Memory_management#HEAP) [https://en.wikipedia.org/wiki/Call\_stack](https://en.wikipedia.org/wiki/Call_stack) &amp;#x200B;
First one is simple, you should use printf format that matches your arguments. Assuming various things, 4294967295 is 0xFFFF'FFFF, 32 onebits. In a 32bit int it's the same as -1. Add one, and it becomes 0x1'000'0000, which overflows the int, result becomes 0.
Because you can't pass arrays by value in C, attempting to pass an array to a function will automatically pass a pointer to the first element. The `sizeof` operator works at *compile time* and uses type information to return the size of the variable's type, which is lost when passing it to a function, since only a pointer is passed. Historically I guess it sort of made sense to prevent passing arrays by value altogether (sort of, because you can still pass large structs around, so yay consistency) because that meant copying large chunks of memory, nowadays it mostly seems to me like an archaic construct that was initially put in place to prevent bad programming, but is now causing much more trouble than it's worth.
"Deep C secret" with a fish on the cover hehe. But is it a bit old?
OMG, i'll try to learn phyton, c is more complicated than i thought, thanks for answer anyway
int is a signed value ranging from -2,147,483,648 to 2,147,483,647 . When you go over 2,147,483,647 it overflows and wraps around to -2,147,483,647 then counts up from there. Use an unsigned int or a long int.
These functions copy and duplicate strings: `strcpy()`, `strncpy()` and `strdup()`. 
It seems you think that variables and manually allocated memory are in the same space, they are not. When you declare a variable `int x = 5;` it is not usually stored next to anything that you allocate using malloc. You can get more information on this by searching for "stack vs heap" on google. As far as the "even if there is unused space, things will go after the allocated block", that is correct, nothing will be stored in the allocated block unless you store it there yourself, even if there is "free space" (it's not actually free: by allocating it, you tell the OS that you're using it). Whether the next allocated block will go right after or not depends on many things however, so it could go even further, or it could go before, the OS will just make sure that there is no overlap.
 UINT_MAX = 4294967295 // on your system z &gt; UINT_MAX // z is too big for an int and an unsigned int z - (UINT_MAX+1) = -90 // After one round of subtraction, z will fit into an int and is converted The specific rules for the conversion are a bit tricky, but it's related to this clause in the standard: "if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type." Which is where the (UINT\_MAX + 1) comes from. I believe that since this ultimately involves conversion to a signed type, the result is actually implementation defined.
Read your compiler warnings
You quoted the rule for converting signed to unsigned. This code converts unsigned to signed, which is a different rule. (It is indeed implementation-defined).
Technically not an overflow; overflow is defined as the result of an arithmetic operation being out of range. This is usually called *out-of-range conversion*. An important distinction, since overflow is undefined behaviour whereas out-of-range conversion is not undefined. 
Worth mentioning OP will have to change the print modifier from `%d` to something like `%u` (for unsigned).
To go into a little more detail, `int` is represented by 32 bits, simply a binary number 32 places long. Since binary is just 1's and 0's, we run into the problem: how do we represent negative integers? The way this is solved is by letting there be two types of integer: `signed` and `unsigned`. `signed` means that the highest order bit (the bit all the way to the left in the number, ex: **0**000...1101) will represent positive (0) or negative (1). `unsigned` means it won't do that -- the left-most bit will just behave like all the other bits. This is why `unsigned int` can store values [0, 4294967295], and `signed int` can store values [–2147483648, 2147483647]. `unsigned` can store larger integers, because it can use that 32nd bit as another bit, but it has to be positive. Important: The `int` type in C is always `signed` by default. Your integer, 4294967206, exceeds the maximum value of `int`. So when you cram that number into an `int` and print it as `%d`, the computer looks at it and thinks that the left-most bit (which is a 1) represents negativity. So it prints a negative number, in this case -90. To understand why it is -90, you'd have to learn about two's complement, which isn't too bad but is probably outside the scope of an ELI5. 
Your question is, what’s the reason the convention is argv and argc? 
Yes!
&gt; So my question is: Is this entirely a coding style thing that says "this is how you're supposed to pass arguments to the main function"? If it is, can anyone explain why it was chosen to be this way? As in the rationale? So the C standard says that you can define main in two ways: int main(void) or int main(int argc, char *argv[]) Supposing you use define main based on the latter, it then says this: &gt; If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup. The intent is to supply to the program information determined prior to program startup from elsewhere in the hosted environment. If the host environment is not capable of supplying strings with letters in both uppercase and lowercase, the implementation shall ensure that the strings are received in lowercase. In POSIX environments (linux, unix, etc.) and Windows this usually translates into being supplied an argument argv[0] which contains the "program name" and then argv[1...argc-1] containing command-line arguments. This is not a coding style but rather a convention that's understood. However if you're asking specifically whether the name should be argc/argv, this is definitely a coding style choice. &gt; Also: "This will (in practice) be 1 plus the number of arguments, as virtually all implementations will prepend the name of the program to the array." Why will implementations prepend the name of the program to the array? Is it an identifier of some sort needed to run the program successfully? The C standard says this about argv[0]: &gt; If the value of argc is greater than zero, the string pointed to by argv[0] represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment. If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1] represent the program parameters. Having the program-name is handy, for example in many linux/unix tools that report usage/error messages, they might use the program name to report error messages, e.g.: $ cp /bin/cat /tmp/foocat /tmp/foocat: illegal option -- p usage: cat [-benstuv] [file ...] In the above example cat uses argv[0] which contains /tmp/foocat to report the usage error that there's no illegal option -p. It can be informative like that. There's definietly other use cases but that's the one I can think of off the top of my head.
Ok, but why is it either the name of the program or an empty string? As to windows, that's a great piece of information, thank you! 
That's a great answer, thank you very much! 
You could store the array size as the first element in the array and update the value when you add or remove elements from the array. When you pass a pointer to the first element, you will easily be able to check the size. 
Because that's what the standard says it must be (§5.1.2.2.1). And the standard says that because that's what most C implementations that predated it did. And they did that because they wanted to remain compatible with Dennis Ritchie's original C compiler so they could compile the same programs with little or no modifications. And Dennis Ritchie's compiler did that because that was the way Unix works. And Unix does that because Dennis Ritchie and Ken Thompson thought it was a good idea at the time.
Thank you! 
We've had this discussion a number of times now. I even did a poll a while ago to determine why people visit this subreddit. Here is a summary of what I think about it: * just from the number of posts, this subreddit would be quite dead if it wasn't for the questions * the survey showed that a majority of the participants actually wanted “question” type posts and only a small minority actually had problems with them being there. As always, a large part just didn't care. This ratio might have shifted as the subreddit has four times as many subscribers now as it had back then, so I might have to redo the survey. * an attempt was made to create both a homework-only subreddit (/r/C_Homework) and a no-question subreddit (/r/cprog). Neither really took off which I take as an indicator that /r/C_Programming's current approach is fine. However, /u/malcolmi's account (the guy who runs /r/cprog) is inactive, so perhaps with renewed leadership the chances might be better. That said, from my informal observations I get that the people who interact with question posts are also largely the same people who interact with other posts, so I don't think there is such a huge rift between people who want to answer questions and people who want to read news about C. 
Well, that's the thing about \`C\`. It's too small to have much to bicker about, and everybody likes it the way it is. It's also not the language of choice for making cool visualizations. So, what's left is mostly people getting to know \`C\`. That said, in the past few days, I posted a project that generates X macros from \`C\` header files, and I starred and skimmed the source of an open source implementation of crypto currency that someone else posted. There are some high quality posts like the ones you're seeking, it's just that there's fewer in \`C\` compared to \`Python\`. But hey, maybe this is up your alley: [https://github.com/kozross/awesome-c](https://github.com/kozross/awesome-c)
I understand that it might be annoying from a professional's perspective, but as a beginner these questions are very helpful. Yes, technically we could all do our research and find a solution ourselves. But especially as a beginner this can be really frustrating. Sometimes the instructions are not 100% beginner proof and we just need a professional to take a look at it. I haven't posted anything here, I've just been lurking for a few weeks and as a freshman in computer science, some of these questions help me a lot. 
There are also many times fewer news about C, every once in a while someone will write an article about a C oddity or a new library, but for the most part, people use C for low level stuff and interoperability, it's a much lower profile language by nature than Python or Javascript, and that's ok. C is not exciting, it's the old reliable.
Exactly. Incidentally, this is one large reason why I use it.
The beginners difficulties are largely conceptual. That's often hard to crack with "an hour of reading".
There is a very active community and moderation in /r/Python. You may not be aware of it, but this post is almost a replica of a recent post in the Python sub about how to get rid of the homework questions.
Same here.
I saw it indeed, thanks
Agreed. I think this sub should be reserved for questions that can't be answered through a Google search.
There are... You just need to go to [old.reddit.com/r/c_programming](https://old.reddit.com/r/c_programming) to see them.
**Sieve of Eratosthenes** In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially test each candidate number for divisibility by each prime.The earliest known reference to the sieve (Ancient Greek: κόσκινον Ἐρατοσθένους, kóskinon Eratosthénous) is in Nicomachus of Gerasa's Introduction to Arithmetic, which describes it and attributes it to Eratosthenes of Cyrene, a Greek mathematician. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks everybody, fixed the issue and uploaded a new version to GH.
Redirection to r/learnprogramming would be useful. Maybe it could be added to the sidebar?
oh.... Thanks!
That is in the sidebar.
OP said they can't use arrays, so that would be difficult.
What have you tried?
I agree, lots of questions recently that could have been solved by a little research. It seems that asking instead of looking is what people do now?... Before we had newsgroups and IRC for that kind of thing, now we have reddit instead. But its easy for us "professionals" to forget we were stupid once too ;)
I was just realizing that myself. That pretty much just leaves trail division.
if you dont understand the fundamentals of programming, the "easier" language wont help you either. IMO even python has too much weird shit and is too loosy goosy for a beginners language, i honestly recommend a recent BASIC variant or even Pascal for actually learning structured programming. Once that is down, then switch to a more advanced language.
I come here because I'm trying to learn C and I often plug those "homework" questions into MSVS to see If I can understand what's going on. Tech articles are interesting and so are posts by people who are working in the industry. I like reading about some coding project at work and the responses. 
As a non-guru-level C programmer, just a guy who writes code, I am happy to help people with their basic misunderstandings writing and compiling and running C code. One of the most common misconceptions is people think C is a "language" of the same type as python
I think it's there to give compiler vendors the opportunity to optimize complex arithmetic, upon the request of the scientific computing community around 1999 when there were a lot of proprietary vendors, as well as to standardize the extension given that most vendors at the time had their own non-portable versions of the extension available anyways. So, there was a good reason to include it at the time.
I was able to come up with a code that gives me odd numbers :\\ I don't know how and what I can do to make the code print only prime numbers. I'm adding the code, and a sample. FYI - I'm super new to coding, this is a part of homework in ansi-c course. &amp;#x200B; [https://imgur.com/a/AgqUqyM](https://imgur.com/a/AgqUqyM)
Supposedly it was first published in 1994. I like it because it tells several real life stories that involve the language and has some nice humour. For example: "*You know that you've definitely found a problem when the authors of the original report on C tell you* *that "some of the operators have the wrong precedence", as Kernighan and Ritchie mention on page 3* *of The C Programming Language.-"* or "*You're probably wondering what possible reason there could be for re-using the static keyword with* *these wildly different meanings. If you find out, please let us know, too."* When talking about static functions and static variables lol.
I’ve just been running them over the internet. I’ll try to figure out the problem in a day or two. I want giving me any message of what was wrong. Could my cywig or whatever it’s called files for clion on windows need to be updated? Would they go from working to not working?
Ah, I see. To find if a number is prime, check if it is dividable by any number less than it. If it is only dividable by 1, it's a prime. Once you solve this, the rest is easy.
Thanks for the reply. I am refreshing on my c that I never really learned properly. Thought it was about time since I really like the language and I am trying to apply to junior positions as a new graduate. I will look into the memory leak and see if I can fix my code. 
I assumed you know how printf works. &amp;#x200B; #include &lt;stdio.h&gt; int isPrime(int n) { // start from 2 untils the sqrt of n // abd check if it's divisible by any of them for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) return 0; } return 1; } int main() { printf("Enter a number bewtween 7 and 8000\n"); int n; scanf("%d", &amp;n); int primeBefore = n; // decrement primeBefore until it's prime while(!isPrime(--primeBefore)); int primeAfter = n; // increment primeAfter untile it's prime while(!isPrime(++primeAfter)); // do some printing printf("%-20s%10d%10d%10d", "Prime nums:", primeBefore, n, primeAfter); return 0; } &amp;#x200B;
I agree. There aren’t enough articles about novel C use cases to sustain the sub. Those beginner level questions often lead to interesting discussion between more experienced C programmers, and that ends up being a really valuable way to start engaging with people’s programming mindsets. It might be cool to have a daily thread organized around a C language feature or use case to generate discussion, but personally I don’t have the experience necessary to lead that kind of discussion. 
When you declare a regular variable, like `int x;`, this tells the compiler that your function needs enough stack space for an `int`. When you compile and run, and the function is called, stack space is created and your variable is given a memory address. The computer is dumb. It doesn't understand things like names. When you use `x` in the function, the computer just refers to it by its memory address. Creating an array variable like `int x[5]` tells the compiler that you need enough stack space for FIVE ints instead of 1. When your code gets compiled and run, stack space is allocated, and the variable `X` gets a memory address again. The memory address of `x` refers to the BASE of the array. The base of the array has room for one `int`. Since an `int` is 4 bytes in size (assuming you're on x86 architecture), the SECOND `int` can be accessed by adding 4 to the address of `x`. The third can be accessed by adding 8, the fourth by adding 12, the fifth by adding 16, and so on.
It has! But you have to do it yourself. For example python have numpy, a library for array manipulations for scientific computations, thats is writen in C for performance. So back in C you only have to do the same thing with the arrays nativily, not problem at all!
 f = f % 10; In this step, you replace `120` by `0`. Are you sure that's what you want?
 f = f % 10; When you run that line with `f = 120`, `f` would then be `0`, thus at `f = f / 10` it stays at `0` and the loop condition `f &gt; 0` isn't true anymore. Simply either store the result of `f % 10` to an another variable or use it directly as an argument to `printf`.
Thank you so much for the reply and helping fix some of my (many) mistakes. I have been so lost with Arrays while trying this that I would never have caught those mistakes in the first place. For some reason the rangeSalary was messing with me because I have 9 salary groups and I know they go from 0 - one less number so I just got confused.
I don't know why I put it like that I'm changing it now, thanks.
Code review is a great idea. I'm about to open source a C-based firmware project I've been working on alone for a long time and would love to get some input.
Nothing of substance changed in these revisions. If you know C99, then going through the brief list of changes is sufficient to get you up to date. For most programmers, the changes are irrelevant. It's not like in C++ where every new language revision changes the way you program wholesale.
you could do something better, you can define a macro with the qtty of sales people and replace it in the code. With that you can analize a lot faster the error only by changing this qtty, and the get back to sixteen again. \#define SALES\_PEOPLE\_QTTY 16
Yeah, it was more a demonstration of the math showing why the numbers work out the way they do rather than quoting the "gospel" conversion rule. Another way to look at it mathematically is finding the literal "two's complement" for -90, which is it's "complement" with respect to 2\*\*N, where N is 32 on this system. ie. 2\*\*N == UINT\_MAX + 1, and 4294967206 + 90 == UINT\_MAX + 1, or (UINT\_MAX + 1 - 90) = 4294967206. So -90 is the two's complement of 4294967206. The implication is that on this system, the bit pattern that represents 4294967206 as an unsigned int, is the exact same bit pattern that represents -90 for an int.
Gsl. Written in C. 
You can do that whole thing without any array offset notation. 
``` #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { /* An array of 14 char elements */ char array[14]; /* We can access each element by its index number, starting from 0, up to length of an array minus 1 (13 in our case) */ array[0] = 'I'; array[1] = ' '; array[2] = 'a'; array[3] = 'm'; array[4] = ' '; array[5] = 'a'; /* An array is just a continuous block of memory, and variable holds a pointer to its first element, which means we can do pointer arithmetic on it */ char *half = array + 6; strcpy(half, "n array"); /* Because we copied a c-string "n array", element 13 of our array will get a nul byte ('\0') automagically and array becomes "c-string compatible" */ printf("%s\n", array); /* Prints: "I am an array" */ /* Elements can be read by accessing them by their index number also. The type of read value is the same as a type of all array elements (char in our case) */ printf("%c%c%c%c%c%c\n", array[3], array[2], array[6], array[9], array[11], array[12]); /* Prints: "manray" */ /* To make a copy of an array, we can just copy entire memory block, as it is guaranteed to be continuous */ char new_array[14]; memcpy(new_array, array, sizeof(array)); printf("%s\n", new_array); /* Prints: "I am an array" */ /* Please note: `sizeof(array)` will work only in scope, where array is defined. After passing it to a function, visibility is lost and compiler will see only a bare pointer. `sizeof` in that case will return 4 or 8 on 32bit and 64bit architecture respectively, regardless of how many elements that array holds. */ return 0; } ```
I'm not sure I understand what you mean. &amp;#x200B; &amp;#x200B;
Everything you need to know is right here, any which way you need it. [All about C pointers](https://www.reddit.com/r/C_Programming/comments/9xz363/master_c_pointers_right_here_read_it_and_weep_c/)
If you have and array (int arr[5]) or a pointer all of the following are equivalent: *(arr + i); *(i + arr); arr[i]; i[arr];
You just replied with nothing BUT array offset notations in your reply. If you read the code, it not only demonstrated that, but co-mingled both notations with up to four dimensions. That was the point of the post. So, uh , thanks
There's pointer notation and array offset notation. The first two are pointer nofation, the last two are array offset notation. Some call it array index. So, uh, your welcome. 
 int buffer[5][7][6]; An element at location [2][1][2] can be accessed using array subscript notation: buffer[2][1][2] or pointer notation *( *( *(buffer + 2) + 1) + 2). There is a difference. 
Personally, I'm using cygwin/GCC and [cppreference.com](https://en.cppreference.com/w/) to learn about certain parts of those things. I get by on good documentation, but they have bits of sample code here and there when I need help.
The second version won't work. 
Really all that's new is _Generic (which can get tricky when you have nested _Generic calls) I learned the syntax for that from [Rob's Programming Blog](http://www.robertgamble.net/2012/01/c11-generic-selections.html) and then _Atomic, and other multithreading related stuff, tho that stuff is really complicated and not really compatible with learning from a blog.
Oh that's really cool, I didn't know about that one.
You're wrong on the Windows front. ANSI: Windows supports main with argc and argv for CLI apps. it also supports WinMain for GUI ones. Unicode: wmain or _tmain. For all variants, you have to call GetCommandLineA for a single ANSI string containing basically a concatenated version of argv. for Unicode, call GetCommandLineW. then to split the command line string into a struct that contains an argv-like array of strings and argc simply call CommandLineToArgvA or CommandLineToArgvW.
Not that I can tell: $ echo "void functionname() {}" &gt; test.c $ clang -c test.c $ objdump -t test.o test.o: file format Mach-O 64-bit x86-64 SYMBOL TABLE: 0000000000000000 g F __TEXT,__text _functionname It does prepend an underscore, but that's about it. I don't call that mangling. This I call mangling: $ clang++ -c test.c $ objdump -t test.o test.o: file format Mach-O 64-bit x86-64 SYMBOL TABLE: 0000000000000000 g F __TEXT,__text __Z12functionnamev But interesting point about a macro-based type system. How would that look like or work? Do you have any examples?
Heres a real example of "printf using garbage from the stack" and why thats bad: #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int x = 4294967295; printf("=== Sizes\nlong:%d\nint :%d\n", sizeof(long), sizeof(int)); printf("x: %lu\n", x); printf("%lu %lu %lu %lu %lu %lu\n",x,x,x,x,x,x); printf("x: %lu\n", x); } The output: === Sizes long:8 int :4 x: 4294967295 4294967295 4294967295 4294967295 8589934591 4294967295 4294967295 x: 4294967295 From gdb: 0x00000001004010c3 &lt;+67&gt;: mov r8d,DWORD PTR [rbp-0x4] 0x00000001004010c7 &lt;+71&gt;: mov ecx,DWORD PTR [rbp-0x4] 0x00000001004010ca &lt;+74&gt;: mov eax,DWORD PTR [rbp-0x4] 0x00000001004010cd &lt;+77&gt;: mov edx,DWORD PTR [rbp-0x4] 0x00000001004010d0 &lt;+80&gt;: mov DWORD PTR [rsp+0x30],edx 0x00000001004010d4 &lt;+84&gt;: mov edx,DWORD PTR [rbp-0x4] 0x00000001004010d7 &lt;+87&gt;: mov DWORD PTR [rsp+0x28],edx 0x00000001004010db &lt;+91&gt;: mov edx,DWORD PTR [rbp-0x4] 0x00000001004010de &lt;+94&gt;: mov DWORD PTR [rsp+0x20],edx 0x00000001004010e2 &lt;+98&gt;: mov r9d,r8d 0x00000001004010e5 &lt;+101&gt;: mov r8d,ecx 0x00000001004010e8 &lt;+104&gt;: mov edx,eax 0x00000001004010ea &lt;+106&gt;: lea rcx,[rip+0x1f32] # 0x100403023 0x00000001004010f1 &lt;+113&gt;: call 0x100401140 &lt;printf&gt; And the values of the stack immediately before the call to printf: (gdb) x/gx $rsp+0x20 0xffffcbc0: 0x00000001ffffffff (gdb) x/gx $rsp+0x28 0xffffcbc8: 0x00000000ffffffff (gdb) x/gx $rsp+0x30 0xffffcbd0: 0x00000000ffffffff If I had used "%d" (which the compiler says is 4bytes), then that garbage "1" you see hanging out wouldn't matter. 
Unless you have a special locale, printing occurs left-to-right, top-to-bottom. And since your loops start at zero, the first thing printed (ie. the "top left" corner of the printout), will be at array location \[0\]\[0\]. If you want the array location \[0\]\[0\] to appear at the bottom left corner, one of your indices should be counting backwards, so that the \*last\* value it has in the loop is zero, not the first value. HINT: rather than modifying the loop variables and loop conditions, make another index variable and calculate it from the proper loop index variable so that it counts down to zero.
Are you stuck with using a loop, or are you allowed to use other functions such as `sprintf()`?
thanks!
great
&gt;great, thanks for answer
I'm in agreement with you here. I actually don't mind the homework questions, I don't think there's enough C-related content to fill a subreddit, anyways.
yeah I want to call malloc in the function, but do this for any type.
Thats so cool, I gotta read more up on input and output streams.
Are you trying to do something like this? int* array; init(&amp;array, 5); And do malloc inside the init to create array of size 5?
Better to.use an enum so the debugger can see it.
That's what void and casting is for. Incidentally this is why malloc returns void.
I don't think it should be a binary "yes/no" to beginner questions. What I think OP means isn't about beginner questions, it's about: 1. Things that can be solved by reading K&amp;R, doing the exercises, and exercising yourself (programming); 2. Things that can be covered by #1 but people forget (happens to everyone); 3. Drive-by questions with a combination of bad formatting, little context on the problem itself, little introspection from the author ("I tried X and expected Y but.."), or other bad question stuff (see http://www.catb.org/esr/faqs/smart-questions.html); I'll grant that (3) can be really annoying at times -- sometimes you can have a genuine problem that you can't figure out (put = instead of ==) and working to solve such forum issues happen to create different issues ("closed because StackOverflow"). I am, of course, in favor of amateur questions. Kind of reflects badly on someone who's too good for them, methinks.
My APIs usually have a xyz_new and xyz_free with allocator hooks.
Well, the names are changed, and I think technically it is also still called mangling. Anyhow, try it with \`extern "C" {}\` and it'll be \`\_functionname\` like in the first example. &amp;#x200B; Sure, you can find tons of examples of a macro type system in \`BoostPP\` \[docs\]([https://www.boost.org/doc/libs/1\_68\_0/libs/preprocessor/doc/index.html](https://www.boost.org/doc/libs/1_68_0/libs/preprocessor/doc/index.html)). Click on the \`Data Types\` link and take a look. You can find a detailed write up discussing \`BoostPP\` and the project's motivation as well as some implementation details \[here\]([https://www.boost.org/doc/libs/1\_68\_0/libs/preprocessor/doc/AppendixA-AnIntroductiontoPreprocessorMetaprogramming.html](https://www.boost.org/doc/libs/1_68_0/libs/preprocessor/doc/AppendixA-AnIntroductiontoPreprocessorMetaprogramming.html)).
strtok() is troublesome in a couple of ways. Sometimes you need to read :: as an empty field. Also, sometimes you pass the token to a subroutine, which uses strtok again, for another purpose. Upper level strtok cuts short. There are alternatives, strchr(), strsep() (if you have it) and such.
Great answer! 
&gt; the survey showed that a majority of the participants actually wanted “question” type posts and only a small minority actually had problems with them being there. I bet you’d have rather different distribution if you asked users about their programming experience at the same time and plotted the first result for people with &lt; 2-3 years of experience vs for people with more.
"dumb" was a poor choice of words. &gt;Why shouldn't they be included? They really need to be there for scientific computing. It seems out of line with the kind of stuff that C is mainly used for, i.e. systems programming. I think it might be better to keep the standard library as minimal as possible (there's already a C++) and just leave complex numbers to a dedicated math library. Otherwise, why stop at complex numbers? Might as well add standard numerical math algorithms if you want to target scientific computing. It feels kinda random. On the other hand, the other answer to my comment mentioned compiler optimizations. That might be a valid reason. 
Good point. I have not performed such analysis.
Thanks ill be looking into them and figure it out
From a quick glance, a couple of issues: * You define `ch` as a `char`, but `fgetc()` returns an `int`. * On line 62, you call `free()` with an argument that you *know* is `NULL`. It's harmless, but also pointless. * You can avoid the `break`s on lines 81 and 86 by inserting an `else` between lines 82 and 83. * On line 76, you set `ptrTraverse` to `NULL` (because there is no next word yet). Then you set it to point to a newly allocated `character`, but nothing else references it, so you're effectively starting a new list hanging in thin air, with no connection to `linkedlist`. * On line 78, you call `malloc()` without checking the return value or initializing the memory it points to. How did you miss this when you ran your program through a debugger?
Since those functions work on matrices, I assume that you are passing in pointers to those matrices, so they are transformed in place. Alternatively, you can pass in pointers to the existing matrix and to a new, empty matrix of the same dimension and write the result of the transformation into the latter.
I think I've caught on to what you mean. here's my revised program, hopefully taking in at least most of the suggestions I've gotten: https://gist.github.com/ishraq0/fdf093c0e787b7ae500ddb915d343f90
Writing my own function was to practise my pointers, I am aware of other functions that exist and do the job better, but thanks for pointing it out. Your program seems to have some problem(s?) in encrypting. Try using the example to verify your program's correctness: keyword: monorail plaintext: The kids can call you Hoju! ciphertext: Fvr yzda nmb pocl gzg Vbxl!
You need more pointers. One for the first word, one for last and current word (where you will append new word, should one arrive), one for last character of current word. And one for the new character. You might use 2 separate types, struct word and struct character, but that's peanuts.
This looks better. That said: * `EXIT_SUCCESS` and `EXIT_FAILURE` are macros used for the exit status given to the operating system. Using them as return values for other function is unconventional. The usual convention for functions is to return a nonnegative result on success and `-1` on failure, though there are many conventions. * Instead of `if (size == 0) {size = 10;}; size *= 2;`, you could also choose a growth function with a linear component, avoiding the branch: `size = size * 2 + 10` for example. * In this line of code: if (!(*addr_text)) {free(tmp); return EXIT_FAILURE;} you use `!` to check if a pointer is `NULL`. While many programmers do this, I think it is a bit confusing at times. I prefer if the idiom `if (!foo)` should be reserved for when `foo` is actually a boolean value, but you can decide about that yourself. * I'm a bit confused by your indentation style. On the one hand, you give every opening brace its own line, but then you start writing one-line `if` statements. The latter is often a bad idea as the debugger can only tell you which line you are on. If the body of the if statement is in the same line as the controlling expression, there is no way to know if the body executed or not. Why not adopt this kind of style? if (foo) { ... } else { ... } This is fairly normal. Also read the style(9) document I linked earlier. 
To allocate an array dynamically you need to know the type of elements it's supposed to hold, because that determines the size of memory block to allocate (num_of_elements * size_of_single_element). You can pass the element size as a third argument, but I'm not sure if that's what you want.
I also get a warning from GCC when I try to do this: `char *ptr = strinp;` instead of breaking it down into two lines. What would be the reasoning for that?
Ah. I didn't do extensive testing of my code, so that's not surprising. The difference is that I go to the next character of the keyword with every character in the input, including characters that aren't encrypted (notably the space key). The fix is pretty simple: for ( size_t i = 0, j = 0; i &lt; n; i++ ) if ( isalpha(plaintext[i]) ) plaintext[i] = (isupper(plaintext[i]) ? 'A' : 'a') + ((tolower(plaintext[i]) - 'a') + (tolower(keyword[j++ % keyword_len]) - 'a')) % 26;
Motherfucker!!
&gt;Instead of if (size == 0) {size = 10;}; size *= 2;, you could also choose a growth &gt;function with a linear component, avoiding the branch: size = size * 2 + 10 for &gt;example. I think that's better, adopted. &gt;I'm a bit confused by your indentation style. On the one hand, you give every &gt;opening brace its own line, but then you start &gt;writing one-line if statements. The &gt;latter is often a bad idea as the debugger can only tell you which line you are on. If &gt;the body &gt;of the if statement is in the same line as the controlling expression, there &gt;is no way to know if the body executed or not. &gt;Will do. I thought one-line statements might make them stand out as exit points. Are there any repercussions in using EXIT_SUCCESS and EXIT_FAILURE macros? &gt;Also read the style(9) document I linked earlier. Didn't find one?
Excuse me?
I was yelling at C and mostly, myself - nothing towards you. Thank you :)
Extra NUL gets printed and discarded in the depths of computer. Remember "0123"[3] is '3'
Whats the warning?
`$ man operator` will show you operator precedence
&gt; Will do. I thought one-line statements might make them stand out as exit points. The `return` statement is already a dead giveaway. No need to highlight this additionally. &gt; Are there any repercussions in using EXIT_SUCCESS and EXIT_FAILURE macros? No, but technically you can't rely on their values being 0 and 1 and it's going to really confuse people when you use them. &gt; That reminds me, any advice on how/when to use &lt;stdint.h&gt;? My advice: use the fixed-size types from `stdint.h` when you need a variable of exactly that size. If a variable of at least that size does the trick, prefer built-in types like `int` or `long`. That said, always use `uintptr_t`, `size_t`, and `ptrdiff_t` when dealing with pointers converted to integers, object sizes (and array indices) and differences between pointers.
Thanks.
Would you say that I need to make another character pointer for your 4th point?
I guess I still am a noob when it comes to using pointers, so I don't put too many of them in my program. I should though, as you said :P
No, frankly, I think you need to start over. The data structure in your diagram is not unreasonable, but the data structure your program is trying to build is nothing like it. Go back to your description of the problem (or the assignment text if this is a school assignment), underline every noun or verb, and ask yourself how to represent that noun or verb in code.
There's an old idiom for handling lists. I don't know if showing it helps or hinders you, but anyway, here goes: struct word *wp, *words = NULL, **wtail = &amp;words; struct character *cp, **ctail = NULL; ... wp = malloc(sizeof (*wp)); wp-&gt;next = NULL; wp-&gt;w = NULL; *wtail = wp; wtail = &amp;wp-&gt;next; /* stays at end */ ctail = &amp;wp-&gt;w; /* new word begins */ ... cp = malloc(sizeof (*cp)); cp-&gt;next = NULL; cp-&gt;c = c; *ctail = cp; ctail = &amp;cp-&gt;next; /* stays at end */ The 'tails' do just that, they keep track where the list terminating NULL pointer is.
It's not ugly, is it? `var(type, name, value);` is the only macro you'd use in the source code. Also, it's not really a 'squeeze', it's extremely robust. Countless `C` and `C++` libraries use `BoostPP` or `P99` to provide portable, dependency free library code. Also, look at something like [Google Test](https://github.com/google/googletest/blob/master/googletest/samples/sample8_unittest.cc). Extremely cool and widely used project that requires you to spit out macros left and right, but it's so worth it.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [google/googletest/.../**sample8_unittest.cc** (master → d593250)](https://github.com/google/googletest/blob/d5932506d6eed73ac80b9bcc47ed723c8c74eb1e/googletest/samples/sample8_unittest.cc) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e9z0hms.)
Try making a link post instead of a self post.
Long time lurker here. I actually use a lot of the posts by the newbies as practice for myself. I wouldnt say I am a complete beginner as I am in data structures and algorithms in C. But, I do firmly beleive that their easy beginner questions has solidified my understanding of the language. As long as people keep answering their "hw" posts I will keep reading the responses!
[C How to Program](https://www.amazon.com/How-Program-8th-Paul-Deitel/dp/0133976890/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1542561202&amp;sr=1-1&amp;keywords=C+How+to+Program) (Deitel &amp; Deitel) - Great book that introduces C programming as well as concepts of programming, and a bit about C++. One comment I would make is that you're trying to do too many things. Pick one and work at it until you get to a point of feeling "fluent". You'll know you're fluent when you feel that you can express anything that you like in the language.
[21st Century C](http://shop.oreilly.com/product/0636920033677.do) is great, and it explains how to use `C` on a high level as well as introducing you to tools that must learn how to use alongside `C`. Avoid `The C Programming Language` as your first `C` book. It's out of date, full of bad practices, and has irrelevant (for 2018) information scattered throughout. It's a classic for a reason though, and it makes for a great second book. The examples, exercises, and intuition are excellent. You just need a frame of reference first, so you can sift past the cruft and bit rot when you read it.
I think you overuse `monospaced fonts` lol. But I still feel like it would be faster and a lot more robust if I took the time to write my own transpiler than if I did something with C preprocessor directives or m4. I've used the former and I've worked projects that use the latter, and they probably have their place, but I'm not convinced that they are the right tool for the job.
1. C Programming: A Modern Aporoach 2. 21st Century C 3. Expert C Programming 4. The Linux Programming Interface 5. The Standard C Library 6. A Tutorial On Arrays And Pointers In C by Ted Jensen 7. A book on Advanced Data Structures in C 8. A book on Algorithms in C 9. Beej's various guides to programming
Thank you so much. I will be drawing out your algorithm for understanding. I've written helper print functions to help me understand these lists :D I will most certainly understand pointers better after some testing, failing, but succeeding in the end.
At some point, you have to admit the language is missing things. And you have to admit that language development has come a long way since 1972. &amp;#x200B; Instead of coming up with crazy ways to do generics in a language that was developed before the term was, use C++. Or better, use a language that is much safer than C and C++. Something managed. &amp;#x200B;
We really need to stop recommending this book; it is truly outdated. I know, it's brief, and it was by the creator of the language, but things really have moved on. 
What's the complete error message including the line number? The 1st problem I see is boolean full(int *top, const int N); N is a macro. So this line is really boolean full(int *top, const int 100); 
I agree. It's just sad to see it go. The content and explanations it provides are still valid in my opinion however the examples should be updated, it really just needs a good spring cleaning.
convert it to a string, remove the digit required, then convert back to an integer
 Get first digit f with mod 10 divide by 100 to remove 2 digits multiply by 10 to add 1 digit add the first digit f &amp;#x200B;
Line 35: syntax error before 'stack'
Literally me when I fix the bug 😂😂😂
cs50 from edx and c programming from Duke University on Coursera. &amp;#x200B;
Line 35 is (*stack)top=-1; `stack` is a type, so `*stack` is meaningless . What is this meant to be doing?
Yo thanks a lot! I didn't think of it this way, but It really makes sense.
I thought about it, but we still haven't started using strings so its expected of me to solve it using numbers.
Thanks. Sadly I can't use strings. But I solved it!
Initialize the stack pointer to -1.
What stack pointer? void initialize (int *top){ The function takes a pointer to int. Perhaps this should be a pointer to a stack? How were you going to call this function? Seeing how a function is to be used can help in work out what's going wrong. 
What about people who are forced to use C or prefer it over C++?
A few things: The argument name in the prototype and declaration for initialize do not match, which will give an error. You also can’t give a variable the same name as a type (stack). Both of these are ambiguous to the compiler, so it doesn’t know what you mean syntactically. I see you are also trying to initialize a member of the stack struct, however that line is missing the ‘.’ operator. The correct syntax would be (*top).top = -1. Though personally I would recommend dereferencing the pointer using the -&gt; operator (a little more readable) example: top-&gt;top =-1
The Absolute Beginner's Guide to C is an excellent book for anyone just starting with C or if you need to brush up on your C. I read it after having taken a long break from C programming and it really makes a lot of difficult subjects very simple to understand. I recommend it to all of my friends at my school where we program in C. I think it would be the best for you being completely new to it.
Who is forced to use it? And why not just use C++ for the things you want, like containers? You can code everything as if it were C. 
Can't you just point the data entry in your struct to the data parameter that's passed into the append func? also if you have a tail reference and it's a doubly pointed linked list use those to get to the end of the LL. also you're gonna hafta update those and fill out the prev/next entries in your node struct
I'd call by reference. Also, I found what my mistake was. You are correct. It turns out that during the initial function declaration, instead of using the pointer I wanted to initialize as a parameter, I was supposed to be using the stack. So instead of declaring void initialize (int *top); I should be declaring void initialize (stack *par); which in turn means that in the body itself I should have written void initialize (stack *par){ par-&gt;top=-1; } which cleared up the syntax error. &amp;#x200B;
With that in mind, I'm revising the rest of the functions.
It's only missing things if you expect it to be something else. There is no such thing as type safety in C; and it's a major feature, not a bug. I realize that's not what everyone is looking for, but blaming the language because it doesn't fit your needs and/or preferences is just silly.
yeah exactly like this.
if I wanted to store a "buffer" of memory would I use `char *` and allocate memory accordingly since that’s the smallest datatype?
I wouldn't call it a bug, but I'm certainly not calling it a feature. Horses constantly eat and shit, which is one reason that even poor quality cars took off so quickly. That's not a bug in a horse design, nor is it a feature of horse design. It's simply the way horses were made. &amp;#x200B; In the same way, C has a very limited concept of types. This causes no end of trouble and is the source of many, many security bugs. While free-climbing large mountain sides certainly makes you feel more manly, it is a very risky endeavor that most people trying to get work done should avoid. 
&gt; but i'm not entirely sure what to do with the *data Change your initalize_node() function so you can pass in the data and update the node-&gt;data. &gt; Is what i've done anywhere close to the correct solution? Your append implementation is that of a singly linked non-circular list but your list and node struct definitions suggest you should be implementing a doublely linked circular list. In which case, you would append by using list-&gt;tail not list-&gt;head. You need to consider edge cases like what if your list is empty, what if it only has a single node, and appending to a list with more than one node is the easiest to implement. Generally speaking you have six pointers you may need to update: * list-&gt;head * list-&gt;tail * node-&gt;next * node-&gt;prev * list-&gt;head-&gt;prev * list-&gt;tail-&gt;next I suggest you create some test cases and a print function that you can pass your list into and print the contents out as an ordered list along with an option to choose forwards or reverse traversal. This will aid you greatly in debugging and conceptualizing the data structure.
Up vote for the linux programming interface, and might recommend understanding unix linux programming by Molay
I’m taking the EdX C programming for Linux courses right now. My first real C since college, 20 years ago. I really like the CodeCast browser module, which incorporates an audio lecture along with an editor and debugger. I haven’t used many C books while taking the courses, other than Internet references. CodeCast is great for learning, definitely better than going to a lecture, listening and watching code being written on a blackboard, and later going to a lab and logging in to a mainframe to do my homework!
I can't understand the pseudocode , please elaborate.
i just cant wrap my mind around algoritm that is my problem. for(i=1; i&lt;=n; i++){ sum= sum+ i\*(i+1)\*(i+2)\*(i\*3) but this isnt right
this isnt pseudocode just algoritm for sum of N numbers
 int bizarre_sum(n) { int i = 1; int sum = 0; for (i = 1 ; i &lt;= n; i++) { sum += pow(i, n+1); } return sum; } &amp;#x200B; And for everyone annoyed at other people doing his homework -- realize that it's one more incompetent developer who you'll be judged against.
So fix the loop and you're done. Or post the homework problem you're trying to solve.
that is the part i need help with. The correct loop. problem doesnt say anything more, just: "write program that can calculate sum for S=1\*3+2\*3\*5\*6+…+n\*(n+1)\*…\*(3\*n) "
Look at this tutorial, http://pw1.netcom.com/~tjensen/ptr/pointers.htm
 int product(int n) { int p = 1; int i = 1; for (i = 1; i &lt; (n*3); i++) p *= i; return p; } int bizarre_sum(n) { int i = 1; int sum = 0; for (i = 1 ; i &lt;= n; i++) { sum += proiduct(i); } return sum; } &amp;#x200B;
Follow up: what forces the buffer flush on app exit? How does one register a function to app exit?
Definitely 'Pointers on C' 'Expert C Programming' and 'C Traps and Pitfalls'
Then ask your school for help, it's already hard fixing code that is posted, imagine fixing code that is not.
Harvard CS50 also recommends it as the supplementary text if students want a book to study from. 
the last term of the expression is already the algorithm that you have to implement! last term will be the received n number multiplied by 3 and you have to iterate that term again n times
Sounds like a gem. I will check it for sure. Hope the author could please publish a new edition.
First impression, you don't have a newline character, "\n", on your questions. It might be good to have one at the beginning and end of the what is the capital question.
Unfortunately, that doesn't fix it
So what should I do to fix that?
yeah, you were right. Thanks.
yeah, you were right. I got it working now. Thanks.
Check if the character is a new line. If so continue on reading the next character.
C for dumb people
I tried a `printf` on `again` just to check if there was a new line character, but there wasn’t. Wouldn’t that mean that’s not causing the problem?
No, use `scanf()` properly. Or better yet, don't use `scanf()` at all; use `gets()` (or preferably `fgets()`) everywhere.
Please upload your code to something like gist.github.com / pastebin.com, or use Reddit's Markdown formatting to format your code properly. We'd like to help you, but only if your code is properly readable.
&gt;pastebin.com [https://pastebin.com/xmw1cuUp](https://pastebin.com/xmw1cuUp)
Is there someone competent to help me?
The printf is where it prints numbers. When do you want stars to show up? If you want all numbers greater than 0 to be printed, just put that condition in an if statement around the printf.
So what would you recomend for building a website what program, software i find that dreamweaver (Pirated) is good because i get to see what my webpage will be like and i can change it pretty quick so what would you suggest using otherwise?
A couple things: Where is NGrade coming from on line 11? I don't see it defined anywhere unless it's in the //insert code portion. But, it's being passed to your function. You've declared your function as returning a char, but it's returning NGrade which is a float. It might help up post the error that you're seeing too. 
You are not declaring the variables you use to call the function (Ngrade, assnum, i). Try doing so before the call. If you had tried to compile the code, that warning would appear... Easier than posting to reddit.
`Ngrade`, `assnum` and `i` are never initialized. The return type of `GradeFromPercetange` is `char`, but is returning `Ngrade` --- a `float`.
&gt; GradeFromPercentage(Ngrade, assnum, i); Where are the values being passed to this function coming from? Inside main you will need to declare these variables. 
\&gt; I really just want this function to be reusable throughout code &amp;#x200B; that's good! Your mistake is here: &amp;#x200B; 11: GradeFromPercentage(Ngrade, assnum, i); &amp;#x200B; Ngrade, assnum, and i are parameters to your function. But they are not declared. &amp;#x200B; You could ask for user input in the function like you do. Then, you do not need to pass the variables into the function. However, this will restrict you to use stdin. Nothing necessarily wrong with that, but I think it would be better to ask for user input first, and then call the function which only does some calculations.
main should be doing the for loop with getting input from the command line for grade percent then using the input from scanf to pass to the GradeFromPercent method and get the grade as the return value. float percent = scanf... char grade = GradeFromPercent(percent);
Try flushing the input after your `scanf()`. Add this line, `fflush(stdin);`.
 int diceA,diceB,diceC,diceD = rand()%100; You're just initializing diceD here. You need to initialize each variable seperately.
`int diceA,diceB,diceC,diceD = rand()%100;` This line does not do what you think it does. You are only initialising the variable diceD with the call to `rand()%100`. The other variables diceA, diceB and diceC are only declared and have an undefined value. (The value is equal to whatever happens to currently be in the memory cells at the time of declaration) &amp;#x200B; If you want to initialise your variables with random numbers correctly, you would have to do something like the following: int diceA,diceB,diceC,diceD; diceA = rand()%100; diceB = rand()%100; diceC = rand()%100; diceD = rand()%100;
Thank you! As I poke and plod, I'm sort of realizing that I already knew most of C, and despite all the hype about how hard it is... I actually like it. (Not saying it isn't hard, because it is!) But it's enjoyable. I like how I don't have to use a framework or worry about doing it "the pythonic way". C feels very liberating. Kind of amused that I'm probably going to end up writing the same binary safe string library everyone else probably writes, but that's probably a tradition? :) 
No need to be rude to folks trying to help. Let's start with what you've posted as there is a gap in the formula that you need to detail out. If we take what you wrote as S=1*3+2*3*5*6+...+n*(n+1)*...*(3*n) and break it down you'll get the following details: S = 1 * 3 S += (2*3*5*6) (parenthesis added to show operation) S += ... S += (n*(n+1) * ... * (3*n)) (outer parens added to show operation) what are the ellipses indicating in the two lines? There appears to be no pattern in the formula that would indicated what they stand for and there are no parenthesis to show groupings. Using the first one going from S = 1 * 3 S += (2 * 3 * 5 * 6) S would be 183 every time at this point, then your adding more to it. What does the ... next translate into, what is the pattern of functions to apply up to **n**? Do you have any descriptive text on the problem?
Thank you. This did solve my problem, but why is it that the code kinda works to begin with? Genuinely curious on why I was given 3 random values when making this mistake, but it fails when trying to make 4.
Thank you, that solved my problem.
The memory allocated for the variables is on the stack. since it's not being initialized, the value of the variables will be whatever was already on the stack. It won't be random, but will depend on whatever was using that memory previously. If you really want to know how it got the value it did you'll need to do some detective work to figure out how it got the value you were seeing. A debugger will provide you with that information.
IMHO, this sort of thing is one of the few valid uses for variable-length arrays (VLAs). #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int width = 400; int height = 300; unsigned char (*image)[height][width] = malloc(width * height); for (int y = 0; y &lt; height; y++) for (int x = 0; x &lt; width; x++) (*image)[y][x] = rand(); printf("P5\n%d %d\n255\n", width, height); fwrite(image, width, height, stdout); free(image); } 
`*(ptr + offset)` is not more pointery than `ptr[offset]`, it's just less readable.
You're receiving a lot of useful feedback in the other comments. The learning how to ask for help suggestion from u/thisIsJohnStone is perhaps the best advice in the comment section. There's a bit of confusion here though. Your function signature for GradeFromPercentage has 3 variables in it: Ngrade, assnum, and i. I don't understand why you have defined these to be parameters. Reading the code for the function, Ngrade is a float that is read from user input. Unless you expect the scanf to be moved outside of the GradeFromPercentage function, then you probably want to remove it from the parameter list and define the variable in the first lines of the function. The same applies for the assnum variable. The i variable is only used in the for loop and can be defined on the spot: `char GradeFromPercentage() {` `float Ngrade;` `int assnum;` `...` `for (int i = 0; i &lt; assnum; i++)` `...` 
https://pastebin.com/cUTP3hVL I used the advice I was given and have progressed to here. New code, new struggles.
Worse. I’m new to this, I don’t know what I’m doing. Reading half this stuff puts my brain to sleep lol
That’s the thing. Pointers, syntax to use to declare arrays and variables in different places, I can’t get it in. My goal is to create a grade system using reusable functions that can be used in other functions. I need to be able to create a program that allows he user to enter up to 100 assignment grades and output the marks to the grade. The grade is converted to a percentage which I’ve done but needs a grade. Also, I know vaguely how to do it. Almost not at all
Okay, I have to ask as this point: Why are you doing this in C? Is this a school assignment or did you decide to learn programming and chose C for some other reason?
"Mastering Algorithms with C" - Kyle Loudon
My school assignment. It’s fun when you understand it, just the climb up to learning sucks. Especially when you feel you’ve tried every way to understand it and it still doesn’t go in 
A couple of questions. When you say "real time", do you mean "real fast" or actually "real time" with hard limits? And how many timestamps are you checking, and how fast do you need to update?
By realtime i mean current time. We agreed on up to 5 timestamps at once. A My code for reading the text file was this: // Manipulate txt file here std::ifstream Fileloc; // Load User File [Fileloc.open](https://Fileloc.open)("TimefromUser.txt"); std::stringstream strStream; strStream &lt;&lt; Fileloc.rdbuf(); std::string strUser = strStream.str(); Fileloc.close(); This clearly will not work anymore.
That explains a lot. For future reference, please announce that you're looking for help on a school assignment. It's not against the rules and it provides a lot of context about what you're asking even if you're not aware of it. You should probably work on the pseudo-code algorithm to solve your problem before writing any actual code. For example: 1. Prompt the user to input a numerical grade. 2. Call a function that accepts a numerical grade and returns an alphabetical grade. 3. Save the returned alphabetical grade in an array. 4. Prompt the user to see if they are finished inputting scores.
So, you're about to get some grief for asking a C++ question in the C programming subreddit. &amp;#x200B; However -- I'm missing the problem. Why not just read in the whole file into memory, split the streng on the separators (like a newline), and the process to your heart's content?
https://pastebin.com/0LEjQ85A This is as far as I've gotten. No clue how to start really.
Yeah i honestly though i the c++ subreddit. After i've used a timestamp i have to delete it. So i can't just do that, if you know what i mean?
I suppose that's what must be done. Thanks for the reply! +1
but where's far and near? i doubt you're really doing it
I'm late to the party, and this likely isn't directly, applicable to the issues you're dealing with, but as a best practice, you really really want to avoid using floating point decimals when dealing with currency. Floats are notoriously inaccurate, and can be a bit temperamental when using comparison operators ie == =&lt; &gt;= etc A good common practice is to convert everything to cents, and use ints instead, then just convert back to dollars when you have to display to the user.
Different kinds of code benefit from different kinds of platform features. It's good for people writing code to be aware of the kinds of platforms upon which it may be called in future, and be mindful of the limits of such platforms, but that doesn't mean one should limit oneself to features that are supported by every platform in existence. If there's a 10% chance that code might need to be ported to a platform that lacks a feature, exploiting the feature and accepting a 10% chance of having to rewrite some code may be better than the effort required to achieve good performance without it. BTW, I wonder how the cost of bit-band hardware compared with the cost of simply having a memory range where writes can only set bits--not clear them--and another where writes can only set bits--not clear them. Such an approach would use up less address space than bit banding and allow multiple bits to be set and cleared simultaneously. Further, it would be fairly simple and inexpensive to construct an SRAM array that could accommodate such operations directly, without a read-modify-write sequence. I wonder what advantages bit banding has over such an approach?
If your array sizes are fixed `char (*arr)[rows][columns] = address` should do the trick. Row and column have to be constants.
C is simple and elegant if one recognizes the principle "A quality implementation intended for some purpose should not make it harder to accomplish that purpose than a simple implementation." There are many situations where simple implementations for various platforms would have to go out of their way *not* to provide useful features beyond those mandated by the Standard. Different platforms will offer different features, but if one views C as a simple recipe for converting platform descriptions into language dialects, the dialects one would derive on many platforms would include a wider range of semantic capabilities than could be expressed in more formally-defined languages. 
but this doesn't work when you specify an address (without malloc) or am i doing it wrong? $ cat ptr.c #include &lt;stdio.h&gt; typedef unsigned char BYTE; int main() { BYTE (*a)[200][320] = (BYTE (*)[200][320])0xa0000000UL; BYTE *b = (BYTE *)0xa0000000UL; printf("a = %p\n", a); printf("&amp;a[100][160] = %p\n", &amp;a[100][160]); printf("&amp;b[100*320+160] = %p\n", &amp;b[100*320+160]); } $ ./a.out a = 0xa0000000 &amp;a[100][160] = 0xa0627000 &amp;b[100*320+160] = 0xa0007da0 The address is off when i also specify the rows.
hmm that actually sounds pretty good, thanks for the suggestion!
Well you don't always need that. With watcom for instance the 32bit compiler works without. The 16bit compiler needs an `unsigned char far *`. For the C64.. well i think it's wonderful cc65 even exists.
Aren't you guys using too many \[\] and extra difficult cast ? I get what I would expect from int h; int (*arr)[3] = (void *) 0x1234; int main() { h = arr[1][2]; movl arr, %ecx movl 20(%ecx), %ecx movl %ecx, h } &amp;#x200B;
I just realized there's a simpler way than a complete gcc linker script. Neat absolute accesses result from extern int HW[2][3]; ld --defsym HW=0x1234 test.o
oh wow that's neat, i'm going to save this :)
that's very interesting indeed, so a cast to void* would be much nicer. I didn't think of that and got to the ugly cast from the warning 'initialization from incompatible pointer type'. Should've thought about void * being a bit special! Thanks!
I'm not sure how to begin even responding to this question... Are you asking us to code your problem for you?
error: too few arguments to function `putc`. https://pastebin.com/bHzEBVA3 What's wrong right now? :P I appreciate the help.
Google photos has unlimited photo uploads, at the cost of them doing some compression to your photos. Most won't notice and you would have to be pixel peeping anyways.
Does your church not have access to Heaven's cloud service? Any decent almighty offers his followers a free backup service.
Is this what you mean- https://stackoverflow.com/a/4659161
Is this a "do my project for me" post, or are you looking for help on how to think about the project so you can build it yourself?
Do you have to print it directly? Or can you build it some other way and then print the result? The subject is "help with a matrix" .. suggesting you want to build the spiral in memory and then print it.
Yes. The default type of a literal is usually `int`, and you can't assign an `int` to a pointer without a cast. The thing is that you are using malloc, malloc already returns a `void*` type, so the cast is not necessary any more.
&gt;i still use some very old compilers, some don't even know c89. Why ?
Nest you for loop, change counter variable for each nested loop. 
`putc('0' + k, stdout)` sorry.
You can make a C program that does anything by using an editor.
Does Rust allow code to regard each object as a sequence of bytes, and arbitrarily modify the bit patterns stored therein? The ability to do that is a fundamental part of C, which eliminates the need for the language to support polymorphic functions for I/O, memory copying, etc. but makes it impossible for C to support various invariants that may benefit compilers in other languages. 
Treat it as base 2 addition with carry. T=0, H=1 Ie. to get the next outcome, add one to the current outcome 
Really nice read, simplistic explanations and something not written about often enough.
All you need is a text editor and a browser. I think most web developers use Atom or Sublime for their text editor. I've also heard good things about VS Code. If you need a web page now, go ahead and use Dreamweaver but it will never do the job as well as a person writing code by hand.
I am not sure what the problem is. I initialized x and n to random values and I still get the same output, which is 1. My scanf reads and gives the correct values for the variables.
King is great. Very fluid writing style. 
First, it's very OS dependent. Second, it's even very OS-version dependent. However, if you hunt through the Linux source code, for example: [https://github.com/torvalds/linux/blob/master/kernel/fork.c](https://github.com/torvalds/linux/blob/master/kernel/fork.c) &amp;#x200B; And then find the code for "wake\_up\_new\_task", you'll see it's putting the new code on the run\_queue. So, then the question becomes, "When does the new task get to run?" Well, this is now dependent on how many cores you can schedule on, as well as how long the current process has left on its slice of time. &amp;#x200B; So, the short answer is, "It depends."
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [torvalds/linux/.../**fork.c** (master → f2ce106)](https://github.com/torvalds/linux/blob/f2ce1065e767fc7da106a5f5381d1e8f842dc6f4/kernel/fork.c) ---- 
&gt;where does that ambiguity comes from Between any two user processes on unix, which executes first? Since there is no default ordering for processes, and fork() simply creates another process, there is no defined semantic for which process executes first. On a multiple core system, there need not be a "first", they could both start executing at exactly the same time. Defining either one to run "first" would only ensure the other process gets necessarily delayed for no benefit. That said, vfork() \*did\* define child to run first (and until exec or completion) before the parent ran again. It's considered a relic and a kludge.
I thought you were talking about tagged unions? In a language which doesn't allow any way of accessing storage in weird ways, a compiler can offer tagged unions without having to generate lots of run-time checks in the machine code. Adding such a thing to C would have a much greater run-time costs because compilers would need to allow for the possibility that a `char*` had been used to access a union in "interesting" ways.
The core problem with error and exception handling is many many functions can return either an error (with (possibly) some supplementary information) or a value. A very common bug is failing to check for an error, and hence using undefined value. If the pattern was to return a language enforced tagged union.... and the only way permitted by the language of accessing the value was to switch() on the tag... then a large class of errors vanish. The vanilla union for type punning a region of memory may continue to exist as a (semi) unrelated entity.
use an hex reader
`outcome = 1;` `outcome &lt;&lt;= N;` `printf("%d outcomes", outcome);`
Binary files are well, binary... Nobody reads binary in 0 and 1s, that is torture. Hexadecimal is used instead, each letter represents 4 bits so FF would be 11111111 in binary. &amp;#x200B; As for how to do this, next time use Google, it is faster than waiting 17 minutes for someone to answer. How do you open files in C? With `fopen`, what is the documentation for it? That you can open a file both in text and in binary. What is a byte? It is an`unsigned char`. How do you read a file? With `fread`. &amp;#x200B; With these in mind, you just open one of your sample files in binary, use fread to read them into a char buffer and then print the numerical value of each unsigned char in the buffer in whatever format you want, hexadecimal, binary, decimal, ternary.... &amp;#x200B; To write it, the same, open the file in binary form and just write to it.
Thanks for the help! I wasn't thinking in terms of hexadecimals. I'll try working with that and see where it takes me.
Reversing the string in place. Printing it afterwards with a single call to printf or puts, just to see if it worked.
It's also a question of how long the first one will run. No matter who goes first, they keep taking turns or even run in parallel if there are resources for it.
If a function isn't going to be able to do anything useful if any of the functions it calls reports failure, and if code won't particularly care which one of the functions it calls supports failure, having to manually add error checking on every function call isn't helpful. Having a language insist upon it in cases where programs need to use returned values might help, but I don't know if doing that would help with functions that don't return values but may affect objects' states in critical ways. I've seen a number of approaches that libraries can use for error handling to minimize the need for explicit error-checking code, including signals, latching error states, etc. I'm not sure that an approach which would enforce manual error checking would be better than e.g. having library functions accept a pointer to an error-status object with the following semantics: 1. If the pointer is null, attempt the operation: if it succeeds, great; if not, trigger a fatal error. 2. If the pointer is non-null but the object's error value is non-zero, trigger a fatal error without attempting the operation. 3. If the pointer is non-null and the object's error value is zero, attempt the operation; if it succeeds, great; if not, set the object's error value. In this way, code which isn't prepared to recover from a failure need not bother passing an error object. Code which passes an error object and fails to check it will trigger a fatal error the next time it attempts an operation using that error object. BTW, I'd like to see a means of allowing for the possibility that implementations may guarantee that malloc() will never return null (but may trigger a fatal error), or that running out of memory for malloc() will never trigger a fatal error (but may return null), or may allow such behavior to be configured. The present semantics on many systems, where it might return null or return a pointer to storage that might not actually be available when accessed, seems like the worst of both worlds.
Do you have double math() declared or actually placed before it's used ? You should have received a compiler warning about %lf vs int, but ...
You really need to familiarise yourself with a debugger. Better sooner than later. 
Thanks for the replies. I've already worked it out using bitwise operations, I've been wondering if there was a simpler and more intuitive way
Except why would we need any of that shit? My code is for multimedia, why in the hell would I need a hash map or linked list for?
It is simply not defined which of the two run first. And even if it was defined, that would be a rather useless restriction to have: say, it was specified to have the child run first. So you fork and then the child runs. Now before the child can do anything useful, the scheduler hits and now the parent runs, effectively making the situation be as if the parent was scheduled first. So for this reason, it is not specified which of the two run first.
then use some soyshit language like javascript, or ruby, or python, or fuckin rust, or go. Not all languages need to be exact copies of each other. Those soyshit languages dropped pointers and manual memory allocation in favor of that shit, why do we have to include their stupid shit.
It's called a race condition. The same thing happened when you tried typing "first"; your left and right hands working at the same time.
What do you mean code by hand?
https://github.com/alexeyneu/glsl-base/blob/bb7eae8f12045c35b3eb93b5eeacd0fcba7eaaff/t.c#L111
Ask in [https://www.reddit.com/r/cpp\_questions/](https://www.reddit.com/r/cpp_questions/)
Where did I say that all languages need to be the same? Hell, where did I even say that C needed any additional features?
C++ is off topic in this subreddit. Please ask in /r/cpp_questions instead.
This is a question about C++, not C. Try asking in /r/cpp_questions instead.
Old 8bit machines :)
Right? I've never understood why people would prefer to do pointer math, than just use array access syntax. it's a lot cleaner and easier to understand.
In RHEL, child executes first and parent later whereas in Ubuntu parent executes first and child later. So it's OS dependent.
r/learnc
People are not trolls just for having opinions different from yours. In fact, I very much agree with /u/thekernelcompiler in regard to the things suggested.
The magic concept you are looking for is called: an Array. I'm unfortunately pressed on time so I cannot give you an example, but now you at least know what to search for. 
Absolutely not an expert on this but maybe you can have a while loop on one process waiting for the other to return so effectively you’ve queued the processes.
Unfortunately I don't have time to look at this fully right now, but a couple of things: int getEvenNumber (int []); This function returns an `int`, not a pointer to an `int`. You need to declare it like this instead to return a pointer to `int`: int *getEvenNumber (int []); This won't work: holderArray[i]=array[i]; You've declared holderArray as a pointer to an `int`, which is fine, but you need to allocate space for it. At the moment it doesn't point anywhere, which is why you'll be getting segmentation faults. Learn how to enable warnings with your compiler, and learn what those warnings mean.
Hi, The first thing you should do is listen to what the compiler is telling you. When I compile your program I see lots of warnings: cc -O0 -ggdb -Wall array.c -oarray-debug [Link to all of the warnings.](https://pastebin.com/3L44pdLW) Many of the warnings are just because you're using variables before initializing them to anything. You'll learn more if you work through some of thes issues but you'll need to change your `getEvenNumber` function to take the length of your array because `sizeof(*array)` is the same as writing `sizeof(int)` for a variable of type `int []`. You can illustrate that with a program like this: #include &lt;stdio.h&gt; int arraySize(int array[]) { printf("sizeof(*array) = %zu\n", sizeof(*array)); } int main() { int foo[255]; arraySize(foo); } Your `getEvenNumbers` has a few more issues. I went ahead and wrote a small program to get even numbers from an array. You can [find it in this pastebin](https://pastebin.com/gJJ6NZnc)
&gt; OpenAPI Generator allows generation of API client libraries (SDK generation), server stubs, documentation and configuration automatically given an OpenAPI Spec (both 2.0 and 3.0 are supported). --[github README](https://github.com/OpenAPITools/openapi-generator#overview)
OpenAPI is a way of specifying HTTP REST interfaces via YAML or JSON documents. Think of it like a gRPC, CORBA, or whatever RPC you are familiar, but using standard HTTP and JSON/XML. Not really significant, specially if its quality is similar the C++ generators'...
treat warnings as errors, in the long run it makes your life much easier...
What is `scanf`’s return value? I suspect it’s 1, meaning it’s only actually reading `x`, and I’d wager it’s because there’s whitespace separating the inputs that you aren’t accounting for in your format string. Try throwing a space on either side of your format string and between the `%lf`s, see if that helps. More generally, `scanf` has several possible modes of failure. You should *always* check stuff that takes input from outside the program; in addition to weird breakages being confusing for you or whoever ends up running your program, you’re potentially exhibiting undefined behavior by making use of `N` without actually reading it in, unless it’s initialized prior.
Are you some sort of old Sinclair ZX81 era collector, or you work with dumb but strong industrial machines ?
i don't know if this is related to the error you're getting, but it might be an oversight (or i'm just mistaken) but shouldn't tail-&gt;next be pointing to head? and head-&gt;prev should point to tail, instead of both pointing to NULL ? 
Only if you are making a ring. This is not it.
Food for thought. If your list has one item, and you delete it from the tail... what happens to list-&gt;head ?
aah yes yes. only other thing I notice here is that the code keeps calling free instead of the free_node function that's written it looks to me like that might be causing issues when you get down to the free_linked_list function. 
Should be set to NULL i'm assuming?
Working from home probably has certain advantages, huh? ;) 
On the file that I'm editing there is no main function, it's literally just function declarations and their arguments already set up and I just fill it in. I have another file which contains the Node and LinkedList definitions as well as the empty declarations of the functions, as well as a testing file which I run this against, if that's what you mean, then it's [here](https://ideone.com/aNlFKV) althogh I didn't create this and i'm not allowed to edit it either.
Time to work on debugging skills. I’d start by commenting out all three tests... see if it still fails. Then uncomment them one-by-one to figure out which one fails. This gives you pointers of where to start concentrating on to find where the code is wrong.
You have an error in `append_linked_list()` and `prepend_linked_list()`. Data is set in Node only when `list-&gt;head` is NULL (`list-&gt;tail` in case of `prepend_linked_list()`).
OK, there's couple of things. I stopped debugging. Apart from not setting data in Node when condition is not fulfilled, there's a bigger problem with list as an object. You have to remember that calling `free()` does not set variable to NULL. If you don't reset it yourself, it will still point at a memory that is freed, but not cleared. You have to figure out what to do with list variable when you remove the last node, because it's not in a state you think it is.
You need to rethink the body of your loop: if(sequence[i]%j!=0) count++; if (count &gt; 2) break; else sequence[i] = i; `sequence` is uninitialized, so that's a problem. And then you index it with `i`, which isn't in a valid range. And I'm not sure what this is intended to be doing in the first place.
scanf returns the number of conversions it successfully performed. It always has, but presumably your new setup has a higher warning level or static analysis turned on, so that now you're being warned that you are ignoring important information.
"scanf" returns a value and you're not checking it. The program isn't correct.
Yeah, I think the answer that u/kumashiro gave is related to this.
It *must* be set in both cases. I would just set it right after node initialisation, which will work for both cases.
Apologies. My current intro to programming has not enforced checking a scanf statement, other than to make sure it’s within a value of say 1-10 within a few specific programs. In regard to data validation, we only just finished loops, so I can validate with an if statement. Is this necessary for EVERY scanf reading in a user’s input? 
it should get all the prime numbers in the interval between n1 and n2 but I do not know how to do stop validate this operation
&gt; I just don't understand why it is happening on acceptable code, and how to make it stop, so that I do not have to verify every user-input. It's happening because your new compiler has an additional warning. The code was never *really* acceptable, but now your compiler is warning you. You make it stop by checking the return value and validate the user input. It's a good habit to have, so you might as well start now. But ... if you insist on not seeing that warning ... there's probably some compiler flag to disable the warning. Or, you can do: (void)scanf("%lf", &amp;base);
Not only is it important to validate user input, you'll quickly discover in real world programming you need to do a lot of argument validation. Programming is all about API contracts. That's why the man page for scanf is so long and thorough. It documents the precise behavior of what the function does. Programs that don't validate are typically chock-a-block with latent bugs. Any professional worth his salt would have pointed out this problem in a code review without the compiler needing to tell you.
Good job! :)
You could explain what this is about. I had never seen this bool function. Anyway, thanks for your help
Is that basically what you were talking about? Thanks for the help btw!
&gt; Rerun with --leak-check=full to see details of leaked memory
I got it thank you
Oh my fucking god! If you're gonna paste code, indent it by 4 spaces to get proper code formatting. int main(int argc, char *argv[]) { // like this. return 0; } If your code is *that* long, please paste it to https://gists.github.com/ (you should have a github account anyways) or on https://hastebin.com if you don't understand `git`. 
 The stack tells you that it is GSTVAL that's allocated in newGSTVAL called by insertGST. You even have a comment there :- GSTVAL * newVal = newGSTVAL(t, value); // FIXME: Free 
So simply posting a link o my code is preferred to posting it all in the description? I was unsure about that.
Since you only have one format specifier, `scanf` will return `1` on successfully converting to that format, since it returns the number of successful conversions. Or `0` if it couldnt do it. 
&gt; My first thoughts go to creating an if statement after the scanf, to make sure a number was entered, and not a character. Yup, that's the point. `scanf` will tell you how many of the format specifiers (just one, `%lf`, in this case, but you can do more than one at once) were successfully parsed. If the user entered something that can't be read by this format (a character is a great example), `scanf` will return 0 instead of 1. Then you can do something reasonable about this. Another example would be reading from a file (`fscanf` works the same way). You might prematurely encounter the end of the file before a character can be read. Or maybe something else wrong happened (the file doesn't exist for example). For a simple program like you're writing, it probably doesn't matter. But in the "real world" you really have to think about all the error conditions, because one day something will happen to trigger these cases ... and then you start getting emergency phone calls at 2 am from angry customers.
Yes, when your code is that large. Also, if posting here, inset every line by 4 spaces with a newline at the top and bottom
Cool, edited my post with Pastebin links. Thank you
Exactly. If you have just a little bit of code (a single function), you can post it here, properly formatted (by indenting all of it by exactly four spaces). Otherwise, post it somewhere else. It would be really good if you use https://gists.github.com/, because it means that we can clone it using `git`. Also, it's always better to reduce your example to the smallest possible code, because if people decide to help you, that'll make it easier on them.
So far as I can tell, it's essentially impossible to use `scanf` in a way that will is guaranteed to behave reasonably for all erroneous inputs. A program that isn't going to check the return value from `scanf` should initialize any objects which are supposed to be set by `scanf`, to allow for the possibility that they won't be, but if anything unexpected happens with `scanf` the stream will often be in a uselessly unpredictable state. 
I'm never quite sure how much code to actually post when looking for help, so I always post too much as opposed to too little. Sorry about that.
Your professor *should* know the reason for this. 
Or use stdbool.h
Well, if you can walk all of your nodes from top to bottom, keep the known bottom location and known top location, and have a variable for both, you can free the bottoms progressively until you hit the top when you need to. It's a lot of work (I know I couldn't be assed to do it), but that's one strategy.
Interesting. I appreciate the help. I have been totally unaware of some of the specific processes in regard to the commands. I was under the impression that scanf reads in and stores a user's input value, and as far as I was aware, that was it. At least that is all we have been told. Hence, the very little data verification I have done, other than ensuring they are inputting values I have specified, such as sentinel loops, while, do-while, etc etc. My class has been structured around reading about a specific topic, then writing a program the next class using it, and never diving deeper into what we are doing. 
I emailed the professor about it, again, because we have been writing code like this for the whole semester, and they replied saying they have never seen the error before. 
I would seriously question why that professor is teaching a class in C. Or at all, for that matter. 
Do a recursive function like this pseudo code I'm typing on my phone. Void free_list(*list) { if (list-&gt;next != NULL) { free_list(list-&gt;next } free(list) }
&gt; `(void)scanf("%lf", &amp;base);` IIRC, gcc doesn't care. I had tons of trouble with code that doesn't check return values because it *knows* it can't fail (everything is set up just right in advance) getting rejected by the CI system due to that warning, despite `void` casts. You have to use `-Wno-unused-result`.
&gt; If I have no particular limitations on what they can enter, how exactly would I validate the numbers they will enter, given all are valid? All aren't valid. There are bounds to what can be represented numerically on a computer, and they are dictated by the data types you choose. In fact, there are an infinite number of real numbers that cannot be represented as a floating point data type on computer hardware. In your case, you can rely on "scanf" to validate for you, by checking it's return value. If the input can be converted to a double data type, it will return "1". 
Exactly. 
Thank you so much this worked. void free\_list(character \*character) { if (character-&gt;next != NULL) { free\_list(character-&gt;next); } free(character); } &amp;#x200B; In int main() { free\_list(linkedListArr\[0\]); }
You can start with [using scanf()](https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm) to read a value from the keyboard.
Consider using %10 to parse out individual digits. % is the modulo operator that will return the remainder of a division. So 12345 % 10 = 5 Also, integers should round down after division, so 12345 / 10 = 1234
Is this a linked list or an array of struts? 
Are you being forced to take programming or did you sign up for this? Arrays are just groups of things, an element is one of the things inside an array or group. When declaring an array the number in the \[\] brackets states how many elements the array will have. When using it elsewhere it means that you are referring to the element in that index. //Array of 5 chars char happyArray[5]; //Element is whatever is on index 3 of that array. char element = happyArray[3]; And now the fun part: Index start at 0 and arrays can go to hell, I cant remember when was the last time I used one, I just use pointers because that is what they degrade to as soon as you pass them trough a function. 
This sub is got the C Programming language. Try asking your question at r/cpp
C++ is off topic in this subreddit. Please ask in /r/cpp_questions instead.
In addition to the explanation provided by the community, I also want to highlight the benefit to automatically generate the C client based on the OpenAPI specification (v2, v3). It can be a huge time saver if your REST API contains many endpoints (e.g. 100) as it would take some time to manually create the C client. Even though if the REST API has only a few endpoints at the moment, one can also benefit from OpenAPI Generator as it supports many different languages e.g. Java, C#, TypeScript, Haskell, etc. OpenAPI Generators also includes server stub generators covering many popular frameworks such as Java Spring, PHP Slim, Python Flask, etc so that users can start with the contract-first approach when designing REST APIs.
You want to loop over the entire string, but your loop will only ever run once. That's because you have an if/else block -- either one or the other will always execute, and both the if and else condition return. &amp;#x200B; You'll want to move the else block outside of the loop. 
Thank you very much! Its working now.
 int containsUpperCase(char *ptr){ for(int morelogic = 0; x &lt; strlen(ptr); morelogic++){ if(isupper(*(ptr + x)) != 0) return 1; } return 0; } &amp;#x200B;
strlen() as a loop condition is a nice way to get accidentally quadratic algorithms
Its OP's program, not mine!
Most compilers optimize it to a single strlen call even without pointer to const char. If that's not the case I would go for: int contains_upper_case(char const * const str) { size_t const n = strlen(str); for(size_t i = 0; i &lt; n; i++) { if(isupper(str[i])) { return 1; } } return 0; } Or just: int contains_upper_case(char const * str) { while(*(str++)) { if(isupper(*str)) { return 1; } } return 0; }
Or the third way: Check for scanf's result.
Why would you define valid and invalid when you can import a huge header and use the FALSE and TRUE macros. And yes, they were originally x but my inner stack overflow came out.
&gt; Why would you define valid and invalid Just following OP's convention. &gt; but my inner stack overflow came out. I don't get it.
I know, just wanted to make the joke :)
Fair enough. :D To be pedantic, this wouldn't really be the place to check for NULL unless this were some robust library function. If NULL gets in here it means whatever was supposed to collect the password ended up with NULL, which already constitutes a show stopper. From there it's a matter of whether you want to segfault or print out some gibberish and exit slightly gracefulier.
Indeed. You are hired.
Hah! I actually thought you were being obnoxious by calling your counter "morelogic". I'd like to think I'm not obnoxious but I work with people who would disagree.
There is no better feeling in this world than being obnoxious, except for coding your own kernel in a ternary computer.
That won't work well, because for many of the types that `scanf` reads, there is no value that can't be set by `scanf`. So you have to check the return value.
The yy prefix for variables and functions is meant because lex stores context in global variables that contain common names in English. The prefix helps to avoid name clashes with user variables and functions. IIRC you can change the prefix with an option.
It doesn't work because you are not calculating the average.
I think you should sketch out how you would solve this problem before writing the code. If someone asked you describe, in words, how you would solve this problem, what would you say? Try to see if you can break down the problem into sub-problems, then solve those. It looks like this requires you to know... How many words there are, and how many letters there are. Solve those separately. As for why your current code doesn't work, take a look at your two while loops. If the first character isn't a space, that first while loop won't do anything, since it only continues to loop when it encounters a space, hence the word count would be 0.
I just write my own lexer and parser for a project. My lexers usually read from a filestream two characters at a time.
Hi, i've re-written my solution, does this look correct? &amp;#x200B; \#include &lt;stdio.h&gt; &amp;#x200B; int main(void) { // calculates the average word length of a sentence &amp;#x200B; float word = 0.0f, letters = 0.0f; char ch; float average = 0.0f; &amp;#x200B; printf("Enter a sentence: "); &amp;#x200B; while ((ch = getchar()) != '.') { if ((ch = getchar()) != ' ') { letters += 1; } else word += 1; } &amp;#x200B; &amp;#x200B; average = letters / word; printf("Average word count:%.1f", average); } &amp;#x200B;
How does it interact with a parser, like Bison?
I haven't run it, but you're calling getchar twice there. Call it once per letter, then then use the result of that, ch, after that. Something to be wary of though, I think you'll always be one word short, since it assumes each word has a space associated with it, so you'll need to take that into account. (e.g. consider a sentence with one word, there will be no spaces in that, hence words will be 0. Personally I wouldn't make words or letters floats, I'd make them ints/unsigned ints, and use use a multiplier when computing the average (average = (1.0 \* letters) / words)
Hi, thanks so much for your help, was unfocused so I couldn't solve the problem properly. Think i'll have to brush up on my concepts as well, but thanks for helping!
Oh? I thought he was making a funny joke..
Now that's a motivation I can get behind!
If your goal is to overflow Flex, why not help improve and promote an existing competitor, such as Lemon, instead of further fragmenting the field?
That is not average. Google "cumulative rolling average". 
i can't understand about char’s max and min how to judged the max and min what character？
Lemme ask you something: Why is there an else? Lemme ask you something else: Why is this formatted like an asshole wrote it?
Hi there, &amp;#x200B; `*argv[]` is a two dimensional Array. That means that you can acces the letter by using `printf("%c%c", argv[1][0], argv[1],[1]);` . You can write these two into a new char array and compare your new char array with `strcmp(variable, value you want to compare with);` . strcmp returns a zero if the two strings are the same. i.e.: `if(strcmp(a, b) == 0) /*do stuff*/`
Thanks!
Hi there, &amp;#x200B; think about using `strcmp()` instead of `==`.
Because why not make your own to learn?
Post in /r/cpp or /r/learncpp. This sub is for C
1) Not C. 2) Formatting. 3) Drop the class. &amp;#x200B;
Then your goal is to learn, and that's perfectly legitimate, but OP specifically mentioned wanting to overthrow Flex.
Have look at the standard library string.h, it have the functions for string manipulatation. But anyway I think those what you need for comparing strcmp and strncmp And maybe you might need copying so check strcpy
I'll take a gander over the upcoming holiday (American Thanksgiving) and I'll give some feedback. I have some ideas for potentially cleaner code, not sure if it'll be faster, but that's what trial and error is for.
On every push you re-`malloc` the memory and only set the "latest" element, and thus the previous values are "lost" and trying to access them results in undefined behaviour (/garabage values). You may want to use `realloc` instead. Also, be sure to check whenever `malloc`/`realloc` returns `NULL`.
First one makes sense, you can even define `n` in the `for` loop initializer. The second one skips the first character.
I haven’t learned about fgets or sscanf yet. What do they do?
Use `strncmp()`
Iam not allowed to used realloc by the task.. 
Then "simulate" `realloc` by `malloc` ing more memory, migrate/copy the old data to the new array and `free` the old memory.
The behavior of `scanf` is defined if an individual character it receives is outside the range that are valid for a type. Behavior is not defined if it receives a sequence of characters which would individually be valid for the type, but which represent a value the type cannot hold. On a 32-bit system, If one uses `scanf("%d",&amp;someInt)`, behavior will be defined if the program receives `123q`, but not if the program receives `9123456789`. If all valid inputs would be below 1,000,000,000 one could restrict inputs to nine characters, but an attempting to read a 10-digit number with `%9d ` would take the first nine inputs while leaving the tenth digit pending in the input buffer, where it would then be processed as the next input item. Such behavior might be "defined" but I don't think I would call it reasonable or useful, especially in an interactive application. The Unix approach to input buffering may be fine for connecting the console to a program whose purpose is to accept data from an input stream. On multi-tasking systems with limited memory (an obvious factor when Unix was designed), the reduction in swapping compared with having an application process individual bytes may be sufficient to justify the UI degradation that results. For interactive applications, however, "raw" mode is better. Too bad the authors of the Standard have refused to define any standard means of handling non-buffered console I/O even though most systems could support it, and other systems could be accommodated via macro and function to test availability. 
Thank you! 
I wanted to learn and even tho the Lemon source code was definitely better I still did not quite understand it. The author says it is just two source files but the main one is huge. Even tho my Lexer is very unsophisticated Lemon probably inspired me more than flex tho. 
Cool, thanks a lot, after all this is hopefully supposed to be a community project.
Any chances to share all the code to be able to built it, I would check it. At least tnode.h is not available. Cheers! ;)
Im also overthrowing Bison (Dunning-Krugger anyone), unless I figure out a way to interconnect it. 
np.
The speed at which any particular process executes C instructions may generally vary arbitrarily from zero up to infinity [the latter actually being possible if e.g. a compiler given a loop with no side-effects decides to elide it, even though its exit condition could never be satisfied]. Following a `fork`, the speed of the parent and/or child might momentarily drop to zero, allowing other processes to execute any amount of code between the fork and succeeding operations. Consequently, in the absence of synchronization, instructions in different processes may be arbitrarily interleaved.
You can develop standalone C/C++ applications with gnome-builder, just start a empty Make project. Anyway what I use is vscode with some essential (to me) extensions like clang command adapter which lint errors and auto complete function (because the integrated Intellisense don't work for me)
I'm missing something -- are you just stalling from writing the actual thing you need? By do you need a program to make a lexer, instead of just writing your own? Why are you interested in writing a parser-generator, instead of just writing a parser for your purpose?
I am on a massive crusade trying to make the wheel rounder on every field. My canvas is a crappy ThinkPad running Mint. Writing a general purpose lexer and parser will allow me to better reinvent the wheel. 
Any chance that you could reach farther by standing on the shoulders of giants? Perhaps join the project and work on Bison and make it even better? http://savannah.gnu.org/projects/bison/ 
By the way, "not understanding the code" is the absolute worst reason to write something from scratch, since you'll likely end up making something much worse.
For many embedded-systems or low-level OS programming tasks, C is the best language. It might also be the best language for some specialized number-crunching applications that receive only trusted input; I would think modern Fortran or Go would generally be better, but such applications are outside my field of expertise. A program that may receive untrustworthy input should not use `scanf` to process it. A program that is guaranteed to receive valid input can process it correctly without having to check the return value from `scanf`. Checking the return value from `scanf` may allow a program to reject *some* invalid inputs that could otherwise have wreaked havoc, but the only ways I know of to handle inputs robustly is to treat them as a series of bytes or lines [and, in the latter case, add special handling to allow for the possibility of lines being unexpectedly long] and then parse the contents of those lines. 
You missed the point of my comment. The professor is imminently unqualified to be teaching a class in C. Not that the class should not be taught in C.
But you aren't rewriting flex. All you've done is created the sleleton for a parser that people write from scratch. Your code already picks which tokens to make. &amp;#x200B; If I wanted to define a number as \[0-9\]\[a-z\] &amp;#x200B; I need to edit all of your code, instead of using a simple expression in flex.
First you need to check how big the file is, so you know how much you need to be reading in. Then you make a loop to read byte by byte into your buffer.
C has yet to offer any "simple" ways of processing potentially-untrustworthy floating-point input. Adding all the code necessary for robust floating-point input validation would make the program much longer, and totally obscure the lessons the professor was trying to teach. The only real use I know of for "scanf" is when trying to write simple programs that won't need to deal with invalid inputs, which is precisely the use to which it is being put here. If the main *purpose* of the program is to illustrate the use of functions like `triangle()` and `rectangle()`, I would not see input validation as necessary nor even helpful toward achieving that. Indeed, from a teaching perspective, having the program behave in somewhat wonky fashion if the student types something other than a number might be a *good* thing. 
You need to know how many words there were and how many letters were. Words are separated by spaces. A very naive approach would involve counting all the letters in the stream and then counting all the spaces. If you have 6 letters and one space that means there are two words and the average is therefore 6 /2 = 3 &amp;#x200B; The problem with this is that if the input has more than one space between words your program will give wrong results. So instead you can make a function which skips all spaces until it finds a letter. Once it finds a letter this means you found a word so you increase the word counter by one and start reading an increasing the letter counter until you find a space which signals the end of the word. You then just repeat this process over and over again.
I am by no means an expert C developer but I've been using Atom with the [ide-clangd](https://atom.io/packages/ide-clangd) extension. It's pretty good and gives you all the typical IDE stuff like autocompletion and code linting. I haven't really needed anything more, though the documentation lookup isn't the greatest (you can use hyperclick for go-to declaration though + the man pages in the terminal, so maybe that's a moot point). 
Create a header and code file and use the header as your public api. Other code includes your header file (i.e. stack.h and stack.c)
Okay, “C is not object oriented” is wrong, as OO is not language-dependent concept. Sure, in Java or C++ following OO principles is easy as they support the concept in language level, but you can do OOP in C, too; the example being `FILE` I/O. Now, in C, we modularize things using header files. These files (extension: .h) contain only the declarations of variables (rarely) and functions, structures, etc, and the accompanied .c files contain actual implementation/definition of those functions and structures. This is how APIs are made in C.
I have an 8 bit PIC with 368 bytes of RAM and I want to write a driver to connect a keyboard via a serial port and use it as a calculator connected to a 16x2 screen. The calculator needs a lexer, a miniature one. I can modify my Lexer source code to completely throw away the part that reads an alphabet and also throw away all other built in datatypes that match strings and just leave the built in number datatype and hardcode the math symbols. I do not know how much memory that would use but I am guessing not a lot. &amp;#x200B; I also have a 32 bit PIC with 128K RAM that I want to use my lexer on. This other one although technically a micro controller is more of a computer as it has more memory than 1980s computers. It is the perfect canvas to fully rewrite the wheel tho. Its beautiful.
There are a lot of full set solutions for that book on github, next time you get stuck in some practice, try looking there. I'll post you my own solution: [https://github.com/OOQQ/C\_Programming\_A\_Modern\_Approach\_2Ed/blob/master/07\_basicTypes/074\_prgPrj013.c](https://github.com/OOQQ/C_Programming_A_Modern_Approach_2Ed/blob/master/07_basicTypes/074_prgPrj013.c) Cheers.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [OOQQ/C_Programming_A_Modern_Approach_2Ed/.../**074_prgPrj013.c** (master → d017445)](https://github.com/OOQQ/C_Programming_A_Modern_Approach_2Ed/blob/d0174456a49d109352deecfcfd918af769dfc4fd/07_basicTypes/074_prgPrj013.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply ea6lg4b.)
There is no point in having a standard lexer. “Overthrow” is a weird choice of words here.
By the way, here is a scanner for summing up numbers: %{ int sum = 0; %} %% [0-9]+ { sum += atoi(yytext); } . {} %% main() { yylex(); printf( "sum is %d\n", sum); } If I can the file "scanner.flex", and then run "flex scanner.flex", and then run "gcc -o /tmp/scan [yy.lex.cc](https://yy.lex.cc) \-lfl " I'll get a binary I can run: &amp;#x200B; $ /tmp/scan &lt;&lt;&lt;"Why is 6 afraid of 7? Because 7 8 9." sum is 37 You may already understand all of this, but I thought I'd show what flex is actually doing, since it might take away a lot of the annoyance of the rest of your project. But, if you're having fun, have at it.
try if(ret == NULL) { return Valid; } else ...
I can’t believe I hadn’t thought of that. Thank you!
Thank you for the input. Also extended question: I did always wonder how FILE worked when doing a file input. Is this how we call the FILE object? How is this declared? Sorry if my questions doesn’t make sense
1st one reads one line from FILE stream, 2nd one is just like scanf, but takes input from a buffer. Easier to stay in sync. You find the details in corresponding manpages.
It wasn't mine.
&gt;Paradigm: Imperative (procedural), structured \- Wiki: [C (programming language)](https://en.wikipedia.org/wiki/C_(programming_language)) When a language's standards simply do not support all of the principles in the object oriented paradigm you can safely say said language is not OO. you can do OOP in C, too; the example being FILE I/O. Just because a language *has* objects doesn't mean that language supports an object *oriented* paradigm. By that I mean the language is not OO friendly. &amp;#x200B;
Maybe because C programmers are cut from a different cloth and realize that conferences are largely boondoggles for less-than-average programmers who think a conference will give them some secret sauce to getting ahead in their field. Or maybe they're all just very jaded and cynical. Like me.
Wait... C11 was a *minor update*?
C itself is such a small tightly defined language I don't think there are too many "pure" C talks that could appeal to a professional. Most of the complicated libraries/C projects have their own conferences. 
glad to see this. There's lots of interest in C conferences and I think it could happen. But one HUGE obstacle is Microsoft's focus on C++. If they would also support C99 I could imagine a conference could happen
You can't calculate primes on the fly 
Write a program where a user will input a variable. Compare the input variable with else? 
Nahh, C18 was minor. C11 was medium.
Microsoft mostly does support C99 now a days, everything except VLAs I think. and they're adding support for C11 in VS 2019 (probably)
Over the last twenty years, there is has been a severe divergence between the language compiler writers want to process, which is suitable only for a few specialized purposes, and the much more widely useful language employed by low-level programmers. While the latter language is by no means perfect, almost all of the formal work done on C has been focused on the far less useful version of the language favored by compiler writers. If a group of compiler writers were to make a serious effort to define a version of the language which was focused on defining ways for programmers to do the things they need to do without reliance upon Undefined Behavior, I'm sure many programmers would be interested. Unfortunately, such action would almost certainly have to be undertaken without the authors of clang or gcc. The Spirit of C which is described in the Standards' charter and rationale documents (but has for whatever reason been omitted from the Standards themselves) focuses on letting programmers do the things that need to be done, but the driving philosophy of clang/gcc assumes that the authors of the Standard intended to forbid programmers from doing anything they didn't explicitly allow. The authors of clang/gcc have doubled down on the principle that any programs that do things not defined by the Standard are "broken", and it seems doubtful that they could ever acknowledge that they've been insisting on limiting themselves to a dialect which is really only suitable for--at best--a tiny fraction of purposes for which C is used. 
At the moment no, I've only filled in the initialise_queue and initialise_stack functions and just put returns in the rest of them as I wanted to see if these work before moving along.
C is so well entrenched that it tends to be a topic that is deeply embedded into other disciplines. Linux kernel conferences, for example, are mostly about C, but they're not "C conferences" per se. 
&gt; double free or corruption (fasttop) You're likely trying to free the same address twice. This maybe be sure to one of the *_pop() functions returning the same value. Run this through valgrind to find out what
Right. So when you call pop_stack then free the return what exactly are you freeing?
Yeah, especially compared to all these Rust confs I'm seeing nicely coverged on YouTube.
Nothing I assume. So should I just stick with the errors until I manage to get it done and then it may be fixed?
The thing is i'm not freeing anything, in the code that I did I've not used free yet as that's the next function, unless you mean the free in the main, which probably wouldn't work as the pop functions haven't been created yet (initialised but not created, all they have is return)
What do you mean by the Node and char** ?
I haven’t dabbled much in systems language communities, but I get the impression that most C programming has shifted to C++, yeah?
Regardless of whether the professor gives a hoot about the 9return value of scanf, the student's compiler does and the professor should know why and be able to help explain it to the student and show how to make those compiler warning go away. Either by checking the return value or turn down the level of compiler warnings and the pros and cons of each. 
&gt; Maybe they’re all just very jaded and cynical. Like me. 👍
It's funny. I said basically the same thing years ago.
Nothing of substance changed. As it should. 
Unless the professor actually tries to use the compiler in question, it would seem entirely plausible that he had never heard of a compiler that would reject code that ignores the value of `scanf`. The Standard does not allow a conforming compiler to behave in such fashion (outside the "One Program Rule" catch-all which would allow a capricious-but-conforming compiler to do just about anything with almost any source file), and I'm not sure why anyone would want such non-conforming behavior. It would make more sense for some coding standards to forbid `scanf` altogether, but I see little reason to allow it only when the return value is checked. 
Compiler is visual studio. 
Most C Programming has remained C. Systems, language design, networking, embedded, drivers, databases, etc.. One big exception is game programming. 
I'm unaware of any versions of MSVC I've used squawking about ignoring scanf's return value. I don't remember when I last used `scanf` with MSVC (or even if I ever did) but it seems likely this behavior is fairly new. Unless the course uses MSVC, I don't blame the prof for not knowing of any quirks in the latest version.
because C++
No always C 
&gt; I was going to use flex and bison but I changed my mind after reading flex's source code. Do you mean the actual flex and bison source code or the source code they generated? You arn't supposed to understand the generated source code, its a highly optimized. You can handwrite a finite state machine that does exactly the same thing as the generated flex code but that is a lot easier to read, although handling file wrapping can get a little tricky. If you are interested in handwriting compilers I suggest picking up a copy of the venerable "dragon book", a.k.a "Compilers: Principles, Techniques, and Tools". Pro-tip: LL(1) parsers tend to be easier to hand write than LR(k) parsers such as the LALR generated by yacc/bison.
Both were too much for my brain. I started reading that book before writing my Lexer but only got to page 70 or so until my urges to write code and cause segfaults took over and forced me to write a Lexer and get my hands dirty. Now that I am almost done with the Lexer part I will go back to read it. 
I haven't heard that about C11. Where did you see that?
Because it’s an old ass language that’s as unsexy as it gets and that doesn’t sell tickets.
What is PL&amp;C ? &amp;#x200B;
If you are a professor in C Programming I would hope you would know about compiler flags for some of the more popular compilers. It's the -Werror flag in gcc. If you want to continue using it, you have to check the return values of functions. A quick search shows VS made this change in 2013 to follow Security Development Life cycle updates. Apparently new projects enable "SDK check" by default now, which treats these warnings as errors. To disable it, go to project properties -&gt; Configuration Properties -&gt; C/C++ -&gt; General -&gt; SDL checks -&gt; No. That professor should know this by now or at the very least, help the student figure this out. 
Can you give a concrete example?
Because c is like a hydrogen atom .
Basically c is like hydorgen atom
Were these ever recorded?
In the language Dennis Ritchie invented and documented in 1974, objects were attached to sequences of bytes in memory; writing an object would change the associated bytes in memory, and changing the bytes in memory would change the value of an object. This relationship allows simple implementations to support many useful abilities without having to make special provision for them. According to the Rationale, the authors of the Standard didn't want to preclude the use of C as a form of "high-level assembler", but the Standard itself fails to recognize the legitimacy of code that uses the language in that fashion. Looking at proposals like http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2294.htm#provenance-and-subobjects I see little interest in allowing programmers to specify when they need compilers to recognize the possibility of access patterns other than those explicitly provided for. 
Honestly I probably do need to see if Intel does a conference or something on using AVX and the like. It can get hard to find good information online when you get to lower level stuff.
Look carefully at your inner for loop. Which variable are you testing vs. which variable did you mean to test?
If only people with close to your level of knowledge and understanding attended, that would be great. How much money do you make from a conference with, say, 100 people attending? Long live Oracle sponsered Java in the Enterprise conferences!
&gt; PL&amp;C probably "Programming Languages &amp; Compilers"
Conferences are also a good place to meet and talk to people that have solved different problems that wouldn’t have normally encountered. Do you really think it’s largely for less-than-average programmers?
From the manager' twitter... https://twitter.com/UlziiLuvsanbat/status/1052976061431013377
FILE *file file
Oh sorry that wasn't originally in my code, typo here I'll edit the post. Thanks for clarifying
Can you please show us how you execute this program? (The command)
Yes, this is correct.
And the compiled program is in the same directory as the text file. Right?
Well, this would be the main problem. The file you're trying to open and then close doesn't exist. There are two types of file paths: absolute and relative. -Absolute paths are the same, wherever you run your program on the system. Your text files absolute path is probably something like /home/user/Desktop/textfile.txt or C:/Users/user/Desktop/textfile.txt. This is the same wherever you are. -A relative path on the other hand is relative. If you try to open just "textfile.txt" in /home/user/Documents/homework, the program will look for the file at /home/user/Documents/textfile.txt. Conclusion: you try to open a file that doesn't exist. Add the file to the directory you are running your program in OR give the text files absolute path as an argument to the program.
Error handling is your problem. `fopen()` returns NULL on error, but you don't care. Then you are trying to close the handler, that is essentially a NULL pointer and program crashes on dereference. What you **should** do is check for error and print meaningful error message on stderr. That way you would know why the file cannot be opened and your program would exit cleanly instead of falling down the Weeping Cliffs of Negligence in a ball of white-hot fire, screaming "YOLO!" ;) 
0-3 = 4, you need to subtract one from the high end. because counts start at 1, not 0.
Looks good, modulo formatting. One thing: when autoincrementation/autodecrementation order does not matter, we write it in suffix notation (`counter++`). It's easier to read. 
&gt; Hello, curious to know if my code is correct? You should come up with a whole bunch of test cases, each comprising some input and some expected output. Then check your code against these test cases; find out whether the _actual_ output matches the expected output. If you're methodical in your choice of tests, this is a far better approach than simply eyeballing the code.
Very cool
Other people hit the nail on the head. Here's a line that may help you: &gt; if (!file) return -1; 
This
No, it's not good at all. It will replace every '\t' character with exactly 5 spaces regardless of what came before it. That is not how tabs work.
That's what `counter` is for
You can write object-oriented code in pretty much any programming language. Some make it easy and some make it hard. C and Lisp are good examples of languages which, while not expressly designed for object-oriented programming, support it relatively well.
The claim that `FILE` is an example of object-oriented programming is misleading. `FILE` is usually a typedef for some sort of struct which contains all the information the standard library needs to read data from or write data to a given file. On a POSIX system, that usually means a file descriptor, a buffer, and some metadata which controls how the file is used (for instance, whether writing to it is allowed at all). That doesn't make it an example of object-oriented programming. What does, though, is that many C libraries also store function pointers in the struct, which means that the same functions, or methods — `fgetc()`, `fprintf()`, `fscanf()` etc. — can do very different things based on how the file was opened. For instance, POSIX defines `fmemopen()` which allows you to use the standard stream API to write to a region of memory rather than to a file, and FreeBSD has a library (libfetch) which presents FTP and HTTP / HTTPS connections as `FILE`s that you can `fread()` (or `fscanf()`, for that matter) from. See [`funopen()`](https://www.freebsd.org/cgi/man.cgi?query=funopen&amp;sektion=3) for insight into how this is done in the BSD C library. If you want to know more, I would suggest looking at the source code of a small C library, e.g. [musl](https://www.musl-libc.org/). You will find `fopen()` etc. in [src/stdio](https://git.musl-libc.org/cgit/musl/tree/src/stdio).
 #include &lt;locale.h&gt; #include &lt;stdio.h&gt; #include &lt;wchar.h&gt; int main(void) { setlocale(LC_CTYPE, ""); wprintf(L"\U0001f914\n"); return 0; } This assumes your locale is set to something that supports Unicode.
in windows all you do : ``` FILE *xf; xf = _wfopen(L"...", L"w+"); //copy paste symbols to visual studio fwprintf(xf, L"..."); ``` now you appropriate file. What you prefer doesn't matter. next: ``` #include &lt;fcntl.h&gt; FILE *xf; xf = _wfopen(L"...", L"r+"); wchar_t remmi[50]={}; fwscanf(xf,L"%s",remmi); _setmode(_fileno(stdout), _O_U16TEXT); wprintf(...) ```
It's already in binary, most likely, but I assume you are not allowed to do it by looking at the floating format. &amp;#x200B; Take away integer part. Compare the fraction to .5, if equal or bigger take away .5. That's one bit. Then compare to .25, ... and repeat as many times as you wish.
Did Dennis Ritchie ever weigh in on this? I'd actually really like to hear more about this, and maybe see some example code that makes a good case for these features. Does anyone know of anything like this? Reading those proposals in the link you posted, I was kind of surprised to learn that some of those things are forbidden. But I guess I can see why - they would require guaranteeing a certain memory layout. Obviously C already does this to some extent. The question is exactly how far should the standard go. Am I understanding this correctly?
Sorry, the indentation was correct originally when I was making the post, didn’t see it got messed up. And thank you for the feedback, I have forgotten about new line scenarios.
Because in Soviet Russia, C program you...
A personal license for CLion is actually: $89.00/1st year $71.00/2nd year $53.00/3rd year onwards The $200/year is for oganizations.
Because everyone out there is trying to beat C by being the next C, and doing it poorly. Before GCC had basically killed everything there may have been hope, but in the 1970's the only real tech conference where they'd talk about C would be the USENIX stuff, or stuff run by the likes of the ACM. But in the era of 'script language of the week' is the way to go, there is no room for C, instead to show off how close modern CPU's can push stuff to 50% or so of C, but of course it'll never be as good, no matter how much they try otherwise... And even if they could push TCL to C like speeds, the trendy market moves to fast, and nobody is going to mature any trendy language long enough.
Format your code.
What?
#FORMAT YOUR CODE.
I edited this many times, but somehow, the code is not shown properly.
ok, got it.
&gt; As far as I understand it, "a\d*c" should match anything string that is like a444c, a0c, a31243243c, but not something like abc,akc, b5c, a3f and so on. `*` means '0 or more of the preceding item' so it will match `ac`. It won't however match `abc`. If you want to match one or more then use `+` instead of `*`. I don't think `\d` exists in this implementation of regex either, so you'll need to use `[0-9]` instead.
clang (version 6.0.0-1ubuntu2) with `-Wall` (`-Wfor-loop-analysis`) can point out this mistake: $ clang amoghrane.c -Wall amoghrane.c:5:19: warning: variable 'i' used in loop condition not modified in loop body [-Wfor-loop-analysis] for (int j = 0; i &lt; 3; j++) { ^ 1 warning generated. 
This is my code: include &lt;iostream&gt; \#include &lt;string&gt; \#include &lt;vector&gt; \#include &lt;fstream&gt; \#include &lt;algorithm&gt; \#include &lt;cstdlib&gt; **using namespace** std; **class** Bst { **public**: Bst( string node ) { **this**\-&gt;value = value; **this**\-&gt;left = NULL; // &lt; left node of bst **this**\-&gt;right = NULL;// right node of bst } **int** freq; // allows the couting of words in bst/ string value; // strings the words so they can be extracted Bst\* left; Bst\* right; }; Bst\* tree\_insert(Bst\* tree, string item) { **if** (tree == NULL) tree = **new** Bst(item); **else** **if** (item.length() &lt;= tree-&gt;value.length()) **if** (tree-&gt;left == NULL) tree-&gt;left = **new** Bst(item); **else** tree\_insert(tree-&gt;left, item); **else** **if** (tree-&gt;right == NULL) tree-&gt;right = **new** Bst(item); **else** tree\_insert(tree-&gt;right, item); **return** tree; } std::vector&lt;std::string&gt;stringV ector; **int** main() { vector&lt;string&gt; Search; ifstream infile; infile.open("doc.txt"); string anything; **if** (infile.is\_open()) { **while**(infile&gt;&gt;anything){ Search.push\_back(anything); // pushing back new variables } } **for** (string i: Search) { cout &lt;&lt; i &lt;&lt; endl; } **if** (infile.is\_open()) // opens and reads the text file **while**(infile&gt;&gt;anything) //gets the words into a node in a bst by placing them in a vector Search.push\_back(anything); **else** cout &lt;&lt; "Unable to open file" &lt;&lt;endl; infile.close(); **return** 0; }
That’s the wrong sub, mate. You need one about C++, not C. Also, saying something like “I’ve been working all day and still can’t do it” won’t help you get much help (sic) because people can’t read your mind and thus don’t know what concrete issue you’re facing. So, please explain it as thoroughly as possible and show the code you’ve written. Good luck!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
`a\d*c` is not a valid [POSIX ERE](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04).
mikestew at Hacker News has the perfect answer: https://news.ycombinator.com/item?id=18505081 &gt; Because though there might be building trades conferences, there are no hammer conferences. Oh, there will be tool vendors at the building trades conferences, there might be sessions on "Efficient Hammering Techniques Using Machine Learning", but there are no conferences about hammers. Don't forget about the blacksmith conference next week, they'll have hammer vendors, too. &gt; I dunno, a Ruby conference kinda makes sense because one will mostly build web sites with it, so it's really going to be a "Building $FOO with $TOOL" kind of thing. But C is so widely used, it's like having that HammerFest 2019 with everyone from people splitting wood with a sledghammer to jewelers with their teensy little tapping tools. I just don't see the diamond workers drinking with the lumberjacks at the hotel bar after hours. :-) I jest, but it's mostly about networking anyway, otherwise just watch the videos online. 
lol
I'd imagine that would be covered as part of the GNOME project's conferences. There are kernel conferences. There is even a conference for GCC (now bundled into the GNU tools cauldren.) 
Thanks for the reply
If you wanted to get extra fancy: Add another int to your Stack struct for tracking the total allocated size of your array. You can start off with an array that can hold say 8 or 16 things. In push() you can check to see if pushing a new item will make your array longer than the memory you already have allocated and if it will then allocate _double_ the memory you already have (e.g. you start out with an array able to hold 16 items, when pushing the 17th item you allocate space for 32 items). This doubling of memory will cut down on your calls to malloc() which will in turn keep the performance hit of context switching down. 
This comment chain is discussing whether or a language can be considered an OO language. I said C has objects in my original post, and I even showed OOP using C in my last post. The point is, C is not an OO language. You might want to read up on the building blocks of OOP: https://en.m.wikipedia.org/wiki/Object-oriented_programming Namely under the "Features" section. You will quickly notice any C language standard doesn't support the majority. * Open recursion(this/self): Completely impossible in C. * Polymorphism: Mentioned before, non-existent. Requires work-around. * Inheritance: Minimal. A struct a guaranteed to point to its first member, so it's somewhat doable. * Encapsulation: Minimal. Struct members are always public. You either need opaque pointers to hide everything or a sub-struct for the "publics". These are **not** the makings of an OO language.
nice. isn't that so much better?
Very good metaphor.
Thanks!
There are 2 prefixes you can use to denote a Unicode codepoint. `\uXXXX` and `\UXXXXXXXX` the lowercase form MUST have 4 hex digits, pad with 0's if need be. the uppercase form MUST have 8 hex digits, at least the top two of which will be 0.
the `L` prefix is for a "widechar" aka UTF-16. if you're trying to use UTF-32, you have to use U as the constant prefix. for UTF-16 the non-Windows prefix is `u` and for UTF-8 the string constant (but if N2198 is accepted in C2x, character constants too) is `u8` Note that these prefixes belong outside of the string/constant, while the `\u` and `\U` prefixes belong in front of each codepoint WITHIN the string/constant. Examples in case you're confused: UTF-8: u8"\uXXXX\UXXXXXXXX" u8'\uXXXX' UTF-16: u"\uXXXX\UXXXXXXXX" u'\uXXXXXXXX' UTF-32: U"\uXXXX\UXXXXXXXX" U'\UXXXXXXXX' One more note: the \u, or \U prefixed codepoints must be the Unicode Scalar Value, aka UTF-32 codepoint. DO NOT try to use the UTF-8 or UTF-16 encoded form after the \u or \U constants, it won't work, and it's not a bug.
Use regex101.com to test your regex against example strings. That's what I do anyway.
Dennis Ritchie was vocally opposed to the inclusion of a `noalias` qualifier which would have been a somewhat more severe form of `restrict`, to the point that he threatened to publicly denounce the language if it was included. The example given as justification for what have come to be known as the infamous `strict aliasing` rule was: int a; void f( double * b ) { a = 1; *b = 2.0; g(a); } In an example like that, I think most people--even Dennis Ritchie--would recognize that little purpose would likely be served by requiring all compilers to allow for the possibility that a programmer might somehow know that the space immediately preceding or following `a` could be safely overwritten, and intend that the assignment to `*b` overwrite the contents of `a` and whatever is next to it. The K&amp;R2 book makes vague reference to those rules, but doesn't think they'll affect most programmers, most likely because they never expected that compiler writers would use them to justify assuming, given something like: struct s1 {int x;}; struct s2 {int x;}; union U { struct s1 a1[8]; struct s2 a2[8]; } u; int silly_test(int i, int j) { if ((u.a1+i)-&gt;x) (u.a2+j)-&gt;x = 1; return (u.a1+i)-&gt;x; } that there was no possibility that `*(u.a1+i)` and `*(u.a2+j)` might identify the same storage, notwithstanding the fact that both are quite conspicuously derived from the same lvalue `u`. Interestingly, gcc and clang would recognize that possibility if code had used the syntax `u.a1[i].x` and `u.a2[j].x`, but since that operator is *by definition* equivalent to the syntax given above, I see no reason to regard that syntax as reliable if the other doesn't work. I find it unfortunate that some people think really complicated rules are necessary, when a really simple principle would suffice: compilers may treat operations on seemingly-unrelated objects of different types as unsequenced in the absence of evidence that sequencing would matter, but quality compilers intended for various tasks should recognize idioms that are commonly used while performing such tasks. Consider the following four functions: uint32_t test1(uint32_t *p1, char *p2) { if (*p1) *p2 = 0x80; return *p1; } uint32_t test2(uint32_t *p1, uint16_t *p2) { if (*p1) *p2 = 0x8000; return *p1; } uint32_t test3(uint32_t *p1, uint32_t *p2) { if (*p1) *(char*)p2 = 0x80; return *p1; } uint32_t test4(uint32_t *p1, uint32_t *p2) { if (*p1) *(uint16_t *)p2 = 0x8000; return *p1; } uint32_t test5(uint32_t *p1, uint32_t *p2) { if (*p1) *(uint16_t volatile*)p2 = 0x8000; return *p1; } In which cases would you say there is more evidence that the operation involving `*p2` might interact with a `uint32_t` such as `*p1`? In `test1`, I'd say there's no real evidence but the Standard would block what would generally be a useful optimization by requiring that compilers acknowledge the possibility. In `test2`, there's no evidence of interaction and the Standard would allow compilers to assume there is none. In the rest of the functions, I'd say no implementation claiming to be suitable for low-level programming should have any problem recognizing the pointer conversions from `uint32_t` to other types as clear evidence of a potential relationship between operations on the resulting pointers and operations on `uint32_t`; the last example even goes so far as to attach a really huge neon sign with the `volatile` qualifier. Note that if 6.5p7 were to say that the only lvalues that are allowed to *alias* are those whose types match precisely, but recognize that quality compilers should recognize accesses to a freshly-derived lvalue is an access to its parent when practical, that would define how implementations should process `test3` to `test5`, while allowing compilers to optimize `test1`. 
wow, thanks for info
Why not just do? `void use2darray(double **array, uint64_t DimensionX, uint64_t DimensionY);` What does that declaration style offer that modern declarations don't?
Start [here](https://en.wikipedia.org/wiki/Berkeley_sockets) for an explanation of what they are, then Google “introduction to BSD sockets” or “introduction to sockets programming” for tutorials.
One of my most awesome professors in college who has now retired always said 'Everything's a file in linux'. Now there are a few weird exceptions but it holds up for virtually everything you'll do. A socket is in fact just another type of file. Just like a regular socket on a wrench or something similar, I like to explain sockets as a single end of a connection. It's not a connection itself, but it's one half of what makes a full connection. You need two sockets, one sending and one receiving, in order to make a full connection and transfer data. Sockets are primarily used in IPC (Inter Process Communication) and in sending and receiving data over network interfaces. I would read up on the [sys/socket.h](http://pubs.opengroup.org/onlinepubs/7908799/xns/syssocket.h.html) file in order to understand how the structure works. I don't have my computer to boot up and look at my specific socket programming examples, but after googling a few things I believe that [this](https://www.geeksforgeeks.org/socket-programming-cc/) offers the most comprehensive look at how sockets work graphically and then also has a good client/server model program as well.
&gt; \d means match any digit character once In a Perl or PCRE regex, sure. In a POSIX extended regex, no.
In Unix **everything** is a file, so yes, a network socket is a file... That said, in C programming you'll likely work with it in an abstracted way. In network programming, the server will typically use the following functions: socket -- creates a listening socket bind -- binds the socket to a listening port listen -- starts listening for client connections accept -- accepts the client connection, and returns a client socket that can be used to send/recv data The client program will typically use the following functions socket -- creates the client socket connect -- connects to the server socket so the client socket can send/recv Either of the parties can close the connection by using close. I'd recommend googling a socket programming tutorial (and/or YouTube videos explaining the concepts) to fill in the gaps, as going into the details is way beyond the scope of this response. As always, once you actually start messing with code, man pages are your friend.
Username checks out
Let's say, client socket (1.2.3.4:1111) wants to connect to the server socket (5.6.7.8:2222) and server accepted the connection from client, then the server creates a new socket(5.6.7.8:2222) and listens on it, won't it create a collision between the old socket and the new socket?
Hey man thank you
While a socket is connected between a client and server, attempting to open a new one and listening on the same port will fail because two sockets cannot listen on the same port. That's a hard rule for all OS's out there, one listening socket on one port maximum. However, if the server and client connect on a different port even if it's the same parent process it will work. Think large scale applications with multiple network instances running like Steam. In fact, I can't remember the port ranges but Steam reserves about 20 network ports for that purpose. 
Check out beej's guide to network programming. 
Okay, I will
That means, the server will create new sockets with different port number and will listen on it?
Exactly. If a new connection is needed, then there has to be separate sockets, a separate connection, on a separate port. This eliminates the possibility of collision, data loss, entanglement, and other fun goodies that would happen otherwise. 
The accept() system call extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. The newly created socket is not in the listening state. The original socket sockfd is unaffected by this call. -MAN page I didn't get this before, now I know that the server socket which client socket tried to connect to will create a new server socket and client socket will get connected to the new server side and the old server will be listening on the same ip:port. Right? 
yeah https://msdn.microsoft.com/en-us/library/69ze775t.aspx last
What does initialize_node look like?
Node *initialise_node(void) { Node *newnode; newnode = (Node *) malloc(sizeof(Node)); if(newnode == NULL) { fprintf(stderr, "warning: unable to init node\n"); free(newnode); return NULL; } newnode-&gt;next = NULL; return newnode; free(newnode); }
If you have a new connection that's been on the queue and just connected, it could be a completely different client so the IP can change. But a new connection will only be accepted by the server if the port is not in use. Therefore if a connection is initiated by a client to a server on a specific port but that port is in use with another connection, the server will usually block (if programmed that way) until the last connection is closed, thus opening the port and the server will then accept the pending connection.
The server does not create a new listening socket. When it accepts the connection, it gets a new socket which represents that connection. It then continues to listen for new connections on the same old listening socket while handling the one it just accepted on the new socket.
I'm sorry, but that is *completely* wrong. Please stop feeding OP incorrect information. Go read the man pages, or go find a simple server application and read the code.
Okay got you,thanks for your replies:)
Don't listen to them. They're wrong. I have to hit the road right now, but if my other comments in this thread aren't enough, I will try to explain in more detail later.
On second thought, could you just post your entire code to a gist or something? I'm not seeing anything that immediately jumps out, so I'm trying to rule out that you did something silly like not initializing list-&gt;tail.
Thanks for your time:)
Yup -- there's your problem, as I expected. You never initialize list-&gt;tail in your initialize_linked_list function, so when you check if(list-&gt;tail == NULL) you'll get an unconditional jump.
So when i initialize the list i need to set newlist-&gt;tail = NULL as well? 
And just realized I missed your second question - you can use [atexit](http://pubs.opengroup.org/onlinepubs/9699919799/functions/atexit.html) to register a function to be called when the process exits. 
Yup... Otherwise newlist-&gt;tail is just going to be whatever junk values happened to be at that location on the heap at the time that you malloc'd it.
Ahhhhhh i can't believe i missed that ahah, thanks a lot saved me a lot of time!!
Not really a tip for mid-term, but in general a good programming course is actually trying to teach you how to think about problems and there solutions in a way that leads you to the right algorithm. Most developers will know several languages really well and others casually by the time they graduate, to the point where the specific language doesn’t matter too much. 
No prob. Pass it forward to the next guy.
C curriculum order is not necessarily universal, even if "pre-array" gives us a pretty good idea of the material. It would be easier to answer more specific questions. Are there any practice problems in particular you're struggling to understand? What do you mean by hard mathematical tasks?
\#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; int main () { char c, prev, startL, endL; int first = 1, n = 1, m = 0; while (1) { scanf ("%c", &amp;c); if (c &lt; 'a' || c &gt; 'z') break; if (first) { first = 0; } else { if (abs(prev - c) != 1) { if (prev &lt; c) { startL = prev + 1; endL = c - 1; } else { startL = c + 1; endL = prev - 1; } for (n = 0; startL &lt;= endL; startL++, n++) printf("%c", startL); printf(" %d\\n", n); m++; } } prev = c; } printf ("Vkupno: %d\\n", m ); return 0; &amp;#x200B; Example: Input: bcjfmbX Output: defghi 6 ghi 3 ghijkl 6 cdefghijkl 10 4 &amp;#x200B; The confusing part is from if(abs... up to the end.This one is not mathematical but I will give you mathematical one &amp;#x200B; \#include &lt;stdio.h&gt; &amp;#x200B; int main() { int n; int x; int p, q, i; int brojot, eq; int temp\_x; &amp;#x200B; scanf("%d %d", &amp;n, &amp;x); temp\_x = x; &amp;#x200B; for(brojot=n-1; brojot&gt;=0; brojot--) { i = brojot; eq = 0; while (i) { p = i%10; x=temp\_x; while (x) { q = x%10; if (p == q) { x = temp\_x; // printf("%d\\n", x); eq++; break; } else { x=x/10; } } &amp;#x200B; if (x == temp\_x) { break; } &amp;#x200B; i = i/10; } if (eq == 0) { printf("%d\\n", brojot); return 0; } } return 0; } &amp;#x200B; This one is for totally different digits. Sample input 45 and 8 and sample output is 44. This is bad google translate copy for the task requirment From the standard input two integers N and X are entered. To find the closest number smaller than N, which is totally different from the number X. One number is totally different from another if and only if no one of the numbers on the other number appears in it. 
Got me. I just want to print the character and so far no one has shown me the exact code to do it. I'm on a linux box. I'd think somehow you could do this using exactly f0 9f a4 94 in the code somewhere. If you believe you've got it, what's the exact code/program you would use?
Got me. I just want to print the character and so far no one has shown me the exact code to do it. I'm on a linux box. I'd think somehow you could do this using exactly f0 9f a4 94 in the code somewhere. If you believe you've got it, what's the exact code/program you would use?
Yea I've read about finding the problem's solution and that is what I mainly struggle right now besides some thingies in the syntax. Since I started programming 2-3 weeks ago it's kinda hard for me that I directly jumped to C which I've read about it that its maybe the hardest one to get into next to Java maybe idk.
Got me. I just want to print the character and so far no one has shown me the exact code to do it. I'm on a linux box. I'd think somehow you could do this using exactly f0 9f a4 94 in the code somewhere. If you believe you've got it, what's the exact code/program you would use?
Got me. I just want to print the character and so far no one has shown me the exact code to do it. I'm on a linux box. I'd think somehow you could do this using exactly f0 9f a4 94 in the code somewhere. If you believe you've got it, what's the exact code/program you would use?
Got me. I just want to print the character and so far no one has shown me the exact code to do it. I'm on a linux box. I'd think somehow you could do this using exactly f0 9f a4 94 in the code somewhere. If you believe you've got it, what's the exact code/program you would use?
you must do it yourself
People who use C to accomplish low-level tasks have no reason to expect the Standard to make any effort to describe a language which would be useful for them, and those who are trying to find more ways to "optimize" a dialect described by the Standard to do things that could be done (often better) in other languages have abandoned interest in the needs of people who need to use C to do things other languages can't. There's no reason the language should have diverged into the two separate camps, but I'm not sure who would really benefit from a talk such as I describe. People who need to use C for things other languages can't will agree that compilers should do all the things described, and those who maintain "modern C" compilers will continue to simultaneously claim that there's no need for the Standard to define things compilers would be free to do anyway when appropriate, and no basis for programmers to expect compilers to do things not defined by the Standard. What's I'd like to see would be an open-source multi-target compiler written in a modern widely-available language like Javascript (which has some pretty horrid semantics for a lot of things, but has efficient implementations available on many platforms), which is focused on making it possible for programmers to efficiently process code which specifies the operations to perform, rather than making heroic efforts to replace a requested sequence of operations with some other more efficient sequence. It's neat, for example, that gcc can take something like: // Store a 32-bit value as a sequence of four octets, in little-endian fashion void store_uint32_b(void *p, uint_least32_t x) { unsigned char *qq = p; qq[0] = 0xFF &amp; (x); qq[1] = 0xFF &amp; (x &gt;&gt; 8); qq[2] = 0xFF &amp; (x &gt;&gt; 16); qq[3] = 0xFF &amp; (x &gt;&gt; 24); } and convert it to a 32-bit store, but allowing programmers to write: // Store a 32-bit value as a sequence of four octets, in little-endian fashion void store_uint32_b(void *p, uint_least32_t x) { *(uint32_t volatile*)p = x; } would make it possible to achieve the same performance with far less complexity. 
Ritchie's language included a Common Initial Sequence guarantee to allow programmers to write functions that could operate on a number of similar structure types. "Modern C" no longer supports such semantics, and there are proposals to eliminate the ability to use a re-cast a pointer to a struct member to access the enclosing structure. 
The latter would receive an sequence of pointers to sequences of doubles, while the former would receive a pointer to a sequence of sequences of doubles. If one has e.g. `double myArr[4][4]`, one could pass its address to the original function directly, but could not pass it to yours without first creating an array of four pointers holding `myArr[0]`, `myArr[1]`, `myArr[2]`, and `myArr[3]`. Although many compilers would allow a function to be written as e.g. void doubleItemsIn2dArray(double *d, unsigned rows, unsigned cols) { for (int i=0; i&lt;rows; i++) for (int j=0; j&lt;cols; j++) d[i*cols+rows] *= 2.0; } and called via `doubleItemsIn2dArray(myArr[0], 4, 4);` the Standard would regard any use of the pointer to access anything outside the first row as Undefined Behavior. 
This will only work in a UTF-8 locale. That includes many Unix derivatives, but *not* Windows, which uses UTF-16 (or UCS-16 until... Vista, I think). My version will work in any locale.
&gt; so far no one has shown me the exact code to do it. I did, right [here](https://www.reddit.com/r/C_Programming/comments/9zdmv0/how_do_i_printf_or_wprintf_or_something_a/ea8agr4/).
Yep — you put that better than I did. Thanks for clarifying it. I was mainly attempting to address OP’s problem of not being able to see those particular bytes in the code, for whatever reason.
&gt; the `L` prefix is for a "widechar" aka UTF-16. No. UTF-16 is a multibyte encoding, not a wide encoding. The exact internal representation of wide characters is implementation-defined; the only guarantees you have is that it's fixed-width and 0 is 0. &gt; if you're trying to use UTF-32, you have to use `U` as the constant prefix. There is no such thing as UTF-32. `U` is for 32-bit Unicode code points. And it's a *literal*, not a constant. &gt; for UTF-16 the non-Windows prefix is `u` No, `u` is for 16-bit Unicode code points.
I did, and someone else mentioned [Beej](http://beej.us/guide/bgnet/).
No one is going to help you with your code formatted like that. Intent code blocks with 4 spaces to make it Reddit-friendly. In terms of understanding what's going on in the first snippet, write down a (short) arbitrary input on paper, and then go line by line interpreting it precisely the way the compiler would. Don't try to keep it all in your head (at this level). Write it down, then be the compiler, and execute the instructions. If you don't understand how a single expression works, Google it, then build yourself a super-quick trivial example that uses that expression.
About the code. I had it from a pdf file and idk why it didnt paste the spaces. Sorry bout that. About interpeting it. I try some method by adding more printf's after every integer or other thing's change. That way I see how it came where it is. And the expressions, yeah, havent thought that haha I tend to write my codes without help and I get stuck and I get sad and quit but Im not quitting anymore. I wanna learn this cause I wanna work with it post college or maybe between college time.
Adding printf's is fine, but that's a separate exercise. The purpose of interpreting it on paper by hand is so you can learn to see what happens *before* your code runs rather than simply trying to put the pieces together with clues from it's output. If you really, really want to learn to program, the trial-and-error shotgun approach will only take you so far. You need to understand what every single expression and every nugget of syntax does. Be. The. Compiler.
Oh, that last line was really epic. Thanks for this. Appreciate it. Also additionally my algorithmic thinking isnt really developed yet cause I barely had any IT class in high school. I mean I had but for the lulz. The teacher sucked honestly.
The C rule I was thinking of was: typedef struct { // base members } Base; typedef struct { Base base; // derived members } Derived; Which guarantees you can always cast from one struct to another and keep those base members intact. I'm a bit confused what you're talking about.
The first sample code is an example of ASCII arithmetic. A char is an integer type, which means that even though we are working with letters in the problem (eg, 'a', 'z', etc), behind the scenes it is actually a number! See this [table](http://www.asciitable.com/) for the relevant symbol -&gt; number codes. In your example, the user's input letters are considered in pairs. So we can see that `if(abs(prev - c) != 1)` is a simple check for if the letters are next to each other in the alphabet. There is nothing to print in that edge case. The code that follows sets `startL` to the smaller of the two ascii values. Then, the for loop prints all the ascii values up until `endL` by adding 1 to the previous startL. This operation is performed for every pair in the user's input. Note that only lowercase letters are permitted -- 'A' through 'Z' are higher on the table, and will be considered the end of input, like 'X' in your example input. The same goes for any other symbol -------------- The second sample code is showing an application of quotient and remainder. If you do not know, integer division in C truncates the result, in other words, `5 / 2 = 2` rather than `2.5`. But sometimes the remainder of a division is useful, as in this case, which is provided by `%`, the modulo operator. We are testing for 'totally different' using these operations to look at one digit of brojot at a time compared to X, accomplished using truncated division and modulo. Since N = 45, the first loop over brojot is brojot = 44. `44 = 10*q + p` is a helpful notation. Notice that `q = 44 / 10 = 4` and `p = 44 % 10 = 4`, neither of which == 8. Therefore the solution is 44. Maybe hard to see because 44 has the same digits in both the ones and tens place. For 57 and 8 the solution would be 56 because `56 = 10*5 + 6`, and neither 5 nor 6 are equal to 8. I don't know if I explained the math clearly enough, but maybe that will give you some insight. Let me know if you need any clarification.
Can you put your code on pastebin or some other site so that it is easy to copy and run?
Arrays get degraded into pointers to the first element as soon as you pass them trough a function. The ampersand is not needed. Try it that way. It should work although Im not 100% sure since I never use arrays, I just use pointers.
Sorry I havent done this before would I do It there and add a link?
[You can find that here..](https://www.youtube.com/watch?v=FMz-2fQrJcw)
I looked up the error code. You are passing a const char* where char* is expected it vice versa. In C strings are const char *, which means they are immutable and modifying them is dangerous or at best undefined (also dangerous).
I'm not trying to modify it though right I believe the code just copies elements from it but if I want to continually take user input more than once later on it cant be const right? 
Prefix, infix, postfix... are you coming or going?
https://pastebin.com Paste and share the link 
You are mixing the concept of 'string' and 'char' in that your format specifier is for a string, but you hand it space for a single character. This is then overwriting memory with a zero. 
Removing ampersand gives me the same errors haha I appreciate the help though :)
Neither, I am :) But mixing prefix and infix is fine? Because that's what pretty much every language out there does. I could have made macro calls (which take compile time argument after ```:```) look the same as function calls, but I wanted them to stand out more visually. One of the biggest issues with Forth/Lisp syntax is that everything looks the same. And I get it, it's also their strength; it's simply a different compromise.
Now that I had the time to look into it, the issues are as follows: 1. the signature for the function should be as follows float flightTimeCalc(char *cityAndTimes) 2. strchr will be called as follows: pComma = strchr(cityAndTimes, ','); pColon = strchr(cityAndTimes, ':'); After making those changes it ran for me, and it seems to be doing what you intended it to do, or not, that's up to you.
Trivial improvements to your `isPrime()` function: * If N is even and greater than 2, it's not prime. * Only check numbers up to ✓N for divisibility.
I did manage to get it working this makes a lot of sense as to why it was broken. Thanks for everything!
I’m guessing they’re a pseudo file then? 
Actually I figured it out doing it the way I was describing. #include &lt;stdio.h&gt; int main(void) { printf ("\xf0\x9f\xa4\x94\x0a"); return 0; } 
I figured out a super simple way. Thanks for your explanation! #include &lt;stdio.h&gt; int main(void) { printf ("\xf0\x9f\xa4\x94\x0a"); return 0; } 
Are you allergic to learning?
No problem, even god himself (Ritchie) admited operator precedence was wrong on his book.
Well, the thing to remember is that there’s a divide here between user-space and kernel-space. In the kernel, a socket is a socket. There is a control structure representing your socket that contains all sorts of details like the address family, addresses, ports, datagram/stream mode etc. That structure is held in kernel memory space and is used by the socket API functions to do things for that socket, but critically these vary between implementations and platforms and might not be 100% portable. In user-space, that information is not readily available anyway because it is outside the memory space of your process and accessing kernel memory directly is a no-no. Rather than exposing that kernel memory to the process, the OS exposes a file descriptor to the process which, for all intents and purposes, *looks* like a file and works with the standard portable POSIX function set. Any operations made on that file descriptor are translated by the kernel into socket API operations, meaning you can write portable POSIX socket code once and do not need to worry about all those niggly platform-specific implementation details. 
[my thoughts on the title](https://i.imgur.com/O41P1BL.png)
Indeed, but even with UNIX domain sockets, you are still indirectly triggering socket-abstracted functions in the kernel with every operation on that descriptor - it’s just that there is a file that acts as the endpoint rather than a protocol-address-port tuple and therefore a “physical” representation of the socket endpoint on the filesystem exists. 
Assuming the input is ASCII, upper-case letters have bit 6 set and 5 clear while lower-case character have bits 6 and 5 set. You can convert an upper-case character to lower-case by setting bit 5 (or adding 32), and conversely, lower-case to upper-case by clearing bit 5 (or subtracting 32). Try something like this: if (ch | 0x20 == 'y') { printf("yes!\n"); } or if (ch &amp; ~0x20 == 'Y') { printf("yes!\n"); } 
I saw that but how can I use a doubly linked list with that?
It seems like the question is actually "how do I output UTF-8" Well the good news is that if your console supports UTF-8 Locale then you can just cat the file contents and job done. If your console supports UTF-8 but does not enable it by default, you might try `setlocale(LC_ALL, "en_US.UTF-8");` If it does not support UTF-8 locale but does support UTF-16 locale (e.g. the windows console) then you have to do some more work. For xample call an OS or library function to convert UTF-8 to whatever your console supports. 
&gt;There is no such thing as UTF-32. https://en.wikipedia.org/wiki/UTF-32 
&gt;find it in this pastebin Sorry to bother you again but I'm a bit confused with line 38 of the code in the pastebin. I was wondering if you could explain that so I could understand. Thank you.
Adding a null-terminator and using `puts(bytes);` would also be a good approach (instead of using the OS call) 
Dope
/uj Do these people not realize that these conferences are for advertising a product. C isn't a product and no one would benefit from throwing so much money into advertising it.
I don't think trade conference is quite accurate description since most of them don't deal with the trade, just with specific product or business. Basically the same as difference between E3 and Blizzcon.
It doesn't work for "jack123", unless you've got a serious bug you're not showing us. &amp;#x200B; You're never including \[0-9\] in the set of valid characters. You need an addition check for that. It should be: &amp;#x200B; if( (s\[i\]&gt;='a' &amp;&amp; s\[i\]&lt;='z') || (s\[i\]&gt;='A' &amp;&amp; s\[i\]&lt;='Z') || (s\[i\]&gt;='0' &amp;&amp; s\[i\]&lt;='9') ) return Validname;
Check where you are returning and what you are returning. Your invalid return only returns outside the for loop and isn’t considered on each individual character. 
You are not counting numbers. You are also returning true as soon as you see a valid character. But you need to return true only when you have seen all characters a nd they are all valid. You can do this by returning early for invalid characters. 
What you are talking about is the term green threads. I recommend reading the Wikipedia page. I would explain it much worse than any article online could. The opposite of a green thread is a kernel thread. I believe multiple green threads can be mapped to a kernel thread
You are right. Whenever you have more threads/processes in a Running state (ready to execute instruction) than you have CPU cores, the operating system kernel must choose between them using a scheduling algorithm. Scheduling is a big topic on its own, but if you're using a typical operating system, a good guess is that your operating system is probably using a variant of Round-Robin. The kernel will put all your Running state threads into a queue. When there's a free core, it'll pull the first one off the queue and put it onto the CPU core to execute for a short period of time (likely on the order of 1 millisecond). After that short period of time, the operating system will preempt the thread, put it at the back of the queue, and give the next waiting thread a chance to execute.
Okay, so using pthread is never really parallel computing like CUDA even if the thread count is lower than core count because the CPU is also shared by other programs. Thanks, that completely cleared my question!
Funny, I was toying with a similar idea in my head not too long ago!
You're very close, your logic is just reversed. In the for loop you want to check if the current char *isn't* an A-Za-z. &amp;#x200B; Working example: int name(char s[]){ for(int i=0;i&lt;strlen(s);i++){ if( (s[i] &lt; 'a' || s[i] &gt; 'z') &amp;&amp; (s[i] &lt; 'A' || s[i] &gt; 'Z') ){ return Invalidname; } } return Validname; } You can see the only changes I made where reversing all logical operators (`||`s to `&amp;&amp;`s, `&gt;=` to `&lt;`) and switch the return values.
These things happen :) The ideas are all out there somewhere, I don't claim any more credit than finally buckling down and doing it.
&gt; The ideas are all out there somewhere Everything is a remix after all. I'm just saying that the timing of this post is a funny coincidence.
Sure, that happens to me a lot. Right around the time I'm solving a specific problem, it's everywhere. Some of it is simply increased awareness and perception. But I'm pretty sure I don't come up with most ideas, some of them amuse and startle me as much as others.
&gt; Some of it is simply increased awareness and perception. That's probably it. Kinda like how you find an item you were looking for earlier while looking for something else.
Sorry I don't know what you mean? 
&gt; pthread is never really parallel computing like CUDA Never? No. Rarely? Yes. &gt; even if the thread count is lower than core count because the CPU is also shared by other programs So is the GPU, which might or might not be more busy than the CPU. Point being that technically, it depends.
make the seive using the list.
can you pay me?
Yes, thank you:)
Really, that guy is the best resource 
Try asking in r/cpp. 
The languages described by both editions of "The C Programming Language" allows that in useful fashion, but the Standard, as interpreted by gcc and clang, does not. An example contrived for simplicity: struct s1 {int x;}; struct s2 {int x;}; union U { struct s1 a1[8]; struct s2 a2[8]; } u; int silly_test(int i, int j) { if ((u.a1+i)-&gt;x) (u.a2+j)-&gt;x = 1; return (u.a1+i)-&gt;x; } If `i` and `j` are zero, then the two integers are guaranteed to have the same addresses, but neither gcc nor clang will recognize the possibility that operations on one would affect the other. 
Thank you so much! 
&gt;It would be better style to write \n instead of \x0a. Why? Honestly I just like how you can see exactly what the machine is doing in memory. &gt;And it is not good security practice to use printf without a literal format string; Why? Thanks for any explanation. 
Syntactic sugar as far as I know. If you really want to change the value you just need the memory adress. No, I do not use it. The only const variables I use are predefined char pointer variables that will actually crash the program if I try to change them since they are defined at compilation time and stored in read only memory.
"Dennis, if your goal is to overthrow assembly, why not help improve and promote and existing competitor, such as BCPL, instead of further fragmenting the field?" 
If it wouldn't be useful, there won't be a 'const'. Just google for it and within the first results you'll find the answers to all your questions.
Useful for everyone reading your code 
Take out the line after the return statement (it's incorrect and unreachable)
Careful here. If you declare a value const the compiler can optimize it out, or even store it in multiple places (such as embedded in San instructions)
This is embarrassing. Do I have permission to let the earth eat me? I remember reading const was meaningless but maybe that was really old literature, or maybe that did not ever happen. Anyways, that is right, const variables can be put into read only memory which will segfault if you try changing it. Ill contribute to the sacrifice by down voting my own comment lol.
I use it all the time. It’s like a mini “assert” to prevent me or more importantly someone who uses my code later from misusing a variable.
For now its pretty good. Thanks man. Im 30 mins from starting the test 
It's a little more than syntactic sugar. Just because you can change the memory address in the background doesn't mean it'll work. The compiler will make assumptions based on that const, stuff like only
Really cool! About the multitasking: What kind of memory model do you use? How preemptive is it? 
It's not null either
What problem is it causing ? Compilation error ? Runtime error ?
Runtime error I think. That's the only error notif i get - "execution error on test 2". But actually, I put an if statement to check for null, and it works fine now. But test 2 BST's first left node is not Null, that's what's confusing me, I shouldn't need an if statement. If it has anything to do with it, test 3's left node is null. But then it should stop execution on test 3, not test 2.
Can you show what's inside test2 ? Also you should show what the rest of the program is, just an isolated function (which by the way should return a bool ...) is very hard to diagnose you know... I suspect the problem comes from the call site.
That's the whole program right now. I deleted everything else to isolate this problem. Test 2 is just a BST. Root node is 9, children 8 and 5. 8 has two children, 2 and 6. 5 has no children. 
One possibility is `isBinarySearchTree`is typed as returning a bool but doesn't return anything so the presence of the second printf could affect the return value.
Unless there are odd requirements in your task, simply (response == 'y' || response == 'Y') could do as well.
Oh damn yeah that fixed it, thanks
that's actually the only code in my program right now - apparently i need to return a bool, that screws things up. thx for the help
oh wait no that didn't fix it, i forgot i had my if statement that removed the problem &amp;#x200B;
Couple of days ago there was talk about physical memory access. Say, the screen area on an 8- or 16-bitter. char (*screen)[320] = (void *) 49512; char (* const screen)[320] = (void *) 49512; I didn't try a real retrocompiler, just fooling on a PC. Both above forms are okay, but the latter one (and cc -O) makes screen writes absolute accesses, variable 'screen' gets optimized out.
Well, it is not doing what it should do... And your problem is still here if you pass a tree with only a root node (i.e. no left node) it will crash. Try to think of the problem like this : what does it means to be balanced in two conditions, if I have children nodes and if I don't have any (how to check if they exists ??). Maybe you know about recursive functions...
Some old implementations of pthreads used green threads, mostly proprietary Unixes that are now dead, but almost entirely userspace pthreads implementations did/do exist. 
Several people, myself included, told you that you were wrong and gave you correct solutions, with increasingly detailed explanations. You rejected that information and even claimed that nobody had answered your question. This particular byte sequence *sometimes* prints a thinking face on *some* systems. In fact, the systems that it works on are also the ones where it is most likely not to work. The correct way to achieve what you want is the code that I gave you literally 20 minutes after you posted your question. If you can't accept that and can't be bothered to read and at least *try* to understand the explanation, you have no future in programming.
Everything, apparently.
So what is your question? Is your program not compiling? Or is it not running as expected? Or are you seeing some runtime error?
Please don't post pictures of code. Always post code as text instead. Read http://idownvotedbecau.se/imagesofcode for why.
Either it's going to produce that byte sequence or it's not. That byte sequences is ALL that matters on my system and guess what, it works EVERY time. EVERY SINGLE TIME! You're no god of programming. You're a little man that can do one thing ok and you like to belittle others just learning. You have no idea what anyone's future is. I didn't ask you for your treatise and I certainly didn't ask you for your snide comments you troll. Go bug someone else when you feel like you can't satisfy your wife. Have your children been beaten today. You're probably also good at that. 
&gt; Either it's going to produce that byte sequence or it's not. It will, on a UTF-8 system. But your head is stuck so far up your ass you didn't even *try* my code, did you?
You're a sad little man and you have my pity.
Because they explicitly said they weren't allowed to use `toupper()`, and I assume that also means they aren't allowed to use `tolower()`.
Your head is stuck so far up your ass you can't read my original requirement. &gt;preferably using those hex values in the program code. It appears to be 4 bytes. I could give two shits if yours works or not as it's not what I wanted. Now, kindly go fuck yourself.
By the way, I don't need to program as I just learn a bit here and there for fun and I have been wealthy for a long time. I'd never hire an asshat like you that can't follow directions and is more interested in name calling than doing something the way someone asked.
`\n` means newline, `\x0a` is harder to read and encoding-dependent. Well, imagine someone edits your file to contain `%s` instead of the utf-8 character, then your printf will cause udnefined behaviour.
&gt;\n means newline, \x0a is harder to read and encoding-dependent. I understand this. &gt;Well, imagine someone edits your file to contain %s instead of the utf-8 character, then your printf will cause udnefined behaviour. I don't get this. I'm not sure what would happen. I'm just printing out that thinking face with: printf ("\xf0\x9f\xa4\x94\x0a"); So I can't imagine that is super risky or something. Maybe I'm wrong.
Oh right. My point still valid. You have multiple combinations like these that you don't need previous knowledge of the actual ASCII values and it's simpler to understand the intention. if(ch == 'y' || ch == 'Y') if(!(ch - 'y' &amp;&amp; ch - 'Y'))
&gt; `if(!(ch - 'y' &amp;&amp; ch - 'Y'))` I think you mean either `(ch != 'y' &amp;&amp; ch != 'Y')` or `(!(ch == 'y' || ch == 'Y'))` ([De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)). 
Threads are by definition *concurrent* computing. They may also be *parallel* computing, if you have more cores/processors then you have threads/programs running. In general, parallelism depends on hardware being available. For example, CUDA is usually considered parallel because a GPU have hundreds of specialist cores that do SIMD operations. I suggest you look up "parallelism", "concurrence" and "SIMD".
Useful for making sure stuff goes to `.rodata` instead of `.data`. Admittedly not everyone cares about that, but some people do.
My guess is that `tree-&gt;left` is `NULL`, but the compiler optimizes out the assignment when `num2` is not used, so you don't dereference `NULL` and don't crash. That also explains why the program works when you add `NULL` check. As for why `tree-&gt;left` is `NULL` in the first place... there's not enough information to tell. You need to give us the complete code and input as text, not as an image.
Nah, they are both for truthness. If ch is 'y' or 'Y' it will evaluate true `if(!0)`.
You said originally that the characters were read from a file. Plus it's a reasonable assumption that you might want to develop this program to do more than print that one character...
&gt; C doesn't use green threads. C uses software "native" threads. It depends on the implementation. FreeBSD used to have two pthreads implementations, one of which was [M:N[(https://en.wikipedia.org/wiki/Thread_(computing)#M:N_(hybrid_threading)) (kernel-assisted green threads). I believe the concept originated in Solaris. There is also the [GNU Portable Threads](https://en.wikipedia.org/wiki/GNU_Portable_Threads) library which is N:1 (completely independent of kernel assistance) and provides a POSIX thread API layer in addition to its native API.
I personally think it can be overused. I've seen coding styles with "absolutely make it a const if it isn't changed!" &amp;#x200B; I tend to look at code as "less typing is better", and make const mean something to you. So, for example, I would 'const' a scaling factor or a known limit that comes from an cited reference. I wouldn't const a calculated variable in a function simply because I didn't intend to change it again. &amp;#x200B; int GridACircleWithEventlySpacedPoints(const Point *center, double radius_m, double granularity_m, Point **array_of_points) { const double kPi = 3.14159265358979323846; double area_m2 = kPi * radius_m * radius_m; ... &amp;#x200B; Even though the area isn't a going to change in this function, I (personally) don't mark it as constant because I don't want my eyes to think it's anything special -- like Pi. area\_m2 is actual variable between function calls, while kPi isn't. &amp;#x200B; But that's my personal style preference more than anything else. The compiler can determine if you change a value during the course of the call or not. And if I change the area for any reason later, that's on me to be clear about what and why I'm doing it, and the 'const' isn't going to save me. 
Const as default is pretty useful when threading gets involved. Race conditions and threads operating on the same piece of data is one of the most common headaches I've encountered. That along with using some transactional interface to shared memory will mitigate ~90% of the headaches involved with multithreaded applications in my experience. 
Threading isn't going to affect a local variable. I agree with the transactional interface on shared memory, although most times it's too heavyweight when a scoped muted will suffice.
`printf("\x25\x73\x0a");` is exactly the same as `printf("%s\n");` - you're just using the hex values of the characters instead of their ASCII representation. It's also not valid, as it's expecting you to pass it a pointer to char, but you're not passing it any variables. What are you actually trying to do? If it's printing out `%s\n` to stdout then use two percent signs, e.g. `printf("%%s\n");`
I didn't downvote you. I'll look at it.
&gt; It's also not valid, as it's expecting you to pass it a pointer to char, but you're not passing it any variables. Why does it work with just text then? printf("test");
`puts` will work too, though be careful mixing `puts` and `printf`. Does this make it any clearer to you? #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char str1[] = "\x25\x73\x0a"; char str2[] = "%s\n"; if (strcmp(str1, str2) == 0) { printf("The strings are the same\n"); } } This program will print "The strings are the same" and exit.
Because there's no format specifiers in there. See the 'Format of the format string' section here: http://man7.org/linux/man-pages/man3/printf.3.html
I see. Thanks!
No, `printf` doesn't go near those strings in my example there. In memory `"\x25\x73\x0a"` and `"%s\n"` are exactly the same, there's no conversion going on at all.
`\x` is limited to ASCII, anything above (and including) 0x80 isn't allowed.
Those two strings are the same, look at henry's demonstration. Compiler reads the sequence \\x25 inside a string constant, and takes it as single % character. ASCII values. Also, you can type in "abc\\x00def" (or just \\0) to a program, but if you try print it, it's comes out "abc".
It's undefined behaviour. Anything can happen
None of the escapes here are above 0x80, so I'm a little confused about your response.
In my own test with modern compilers, anything that allows the compiler to prove the value isn't changed is sufficient to get the optimal result. This includes using local scope or using `static`. // global, not modified in translation unit static char (*screen)[320] = (void *)49512; void foo(int i, int c) { (*screen)[i] = c; } void foo(int i, int c) { // local, not modified in function char (*screen)[320] = (void *)49512; (*screen)[i] = c; } // global, cannot be modified char (* const screen)[320] = (void *)49512; void foo(int i, int c) { (*screen)[i] = c; } These all optimize equally in GCC and Clang to just what we'd want: foo: movsxd rax, edi mov [rax + 0xc168], sil ret I also compiled with Borland Turbo C, and it's so bad at optimization that it doesn't matter what you do, `const` or not. (Using a `far` pointer just makes the constant bigger.) _DATA segment word public 'DATA' $ijfmlmaa label word db 104 db 193 _DATA ends _TEXT segment byte public 'CODE' assume cs:_TEXT,ds:DGROUP _foo proc near push bp mov bp,sp mov bx,word ptr DGROUP:$ijfmlmaa add bx,word ptr [bp+4] mov al,byte ptr [bp+6] mov byte ptr [bx],al pop bp ret _foo endp _TEXT ends 
It's cooperative, not preemptive; it runs one task at a time and the only way to switch is to `yield`. I always end up craving fast fibers one way or the other, and they're difficult to get right unless built into the core.
`auto` intensifies
I misread 0x0A as 0xA0 tbh :/
&gt;regex101.com Thx! \[0-9\] did the trick... &amp;#x200B; No part two ... extracting the numbers ... :D
Thanks for the site, bookmarked :)
That'll happen :) Not to pick on you, but I can't seem to find anything that says \x only handles ASCII values. I'm looking at Section 6.4.4.4 of the ISO standard ... do you think I'm misinterpreting it?
static. Of course :) Trying those on 32 bit freebsd, clang and gcc, they all become, similar to your's, movl 8(%esp), %edx movl 4(%esp), %eax movb %dl, 49512(%eax) The benefit I was looking after, const \_or\_ static, was screen[1][2] = c; movb ..., %al movb %al, 49834 Hardcoded x, y doesn't make that much sense for screen writing, maybe for double uarts or something like that.
C does not have errors that can be "thrown".
Using MBCS, I can code "\xF0\xCA" and get what I expect, even though both values are greater than 0x80. Above, you say that values over 0x80 aren't allowed. \x isn't limited to ASCII (whatever that really might mean). If I'm making a wide character string, I can code L"\x6771\x4eac" and I have "東京", which are the kanji for Toyko, the capital city of Japan. These are both greater than 0x80 and not limited to ASCII.
Because you haven't actually implemented the logic of that method. Based on the name `isBinarySearchTree` I assume it's supposed to take a tree and determine whether it's properly constructed such that it's a **binary search** tree. Just returning `true` is not a fix because when you get a non binary search tree it returns the wrong answer. What is a binary search tree? It's a tree where **all** the children in the left sub-tree are less than the value in the node and **all** children in the right sub-tree are greater than the value in the node. To fix your code, you need to take that description and convert it into code (and no, I won't spell it out for you as this is obviously a learning exercise). P.S. don't post your code as an image.
sorry for answering so late. you'd generally use a file descriptor for most anything that's input/output if you're writing a C program for a unix system. f.ex. `stdin`, `stdout` and `stderr` are 0, 1, 2, so you can do `fputs(1, buf, len)` and it would write to the console. and i think you'd get a file descriptor if you're accepting socket connections, as well. and if im not mistaken, functions like `fstat` take file descriptors as input.
&gt; MBCS You mean UTF-8? MBCS is a microsoft specific term that AFAIK only encodes UTF-8... The proper way to encode Unicode is to use \uXXXX or \UXXXXXXXX for each codepoint...
&gt; edited in 2011. EVERYTHING in my libraries, except _Generic macro calls compiles in C mode in VS 2017.
Nice summary and very helpful. Thanks.
This is a pretty straightforward task - which part are you stuck on? Yes, you will probably want to use an `if` statement. Show us what you've written down so far. [This person](https://www.reddit.com/r/C_Programming/comments/9zi86h/trying_to_allow_my_program_to_accept_all_letters/) had a very similar problem recently, have a look through that thread and see if anything helps.
[Try asking your classmate](https://www.reddit.com/r/C_Programming/comments/9zi86h/trying_to_allow_my_program_to_accept_all_letters/)
This is great, thanks. 
Yeah, I agree. Use `const` for added clarity. In your example, I know from the function declaration line that the `center` pointer will not be used in the function body to store anything, without even looking at it, and `kPi` is a true constant. Thanks for the example.
I can't use topper though I don't think. Requirements want me to follow a specific structure. 
The fact that a pointer is qualified `const` does not entitle an implementation to make any assumptions about whether anything might affect its target, nor even whether the pointer itself might be used to do so. The combination of `const*restrict` qualifiers is far more powerful in that regard, since it guarantees that no objects accessed via the pointer (or others derived from it) will be changed in any fashion during the pointer's lifetime. Thus, given something like: void bar(void); void foo(int const * restrict p) { if (*p) bar(); return *p; } a compiler wouldn't have to know anything about `bar()` to know that it would be entitled to return the value of `*p` that was read in the `if` statement. Unfortunately, `restrict` and `const*restrict`] is only usable for objects accessed via pointers. If there is an object whose value will only be changed under certain unusual situations, and was only used in one calibration unit, it might be possible to write something like: extern uint32_t configStorage[4]; // Likely placed by linker static uint32_t const * restrict configValues = configStorage; void changeConfiguration(uint32_t newConfig) { configValues = 0; flashWriteBytes(configStorage, newValues, 16); configValues = configStorage; } to allow a compiler to assume that consecutive accesses to e.g. `configValues[2]` that aren't separated by actions that change the address in `configValues` will always read the same value. This would in turn allow a compiler given a loop like: for (int i=0; i&lt;100; i++) { foo(); if (configValues[2] &amp; SOME_FLAG) bar(); boz(); } to hoist the comparison out of the loop even if it knows nothing about the effects of `foo`, `bar`, and `boz`. Unfortunately, this approach has a couple of significant problems: 1. A compiler will generally only be able to make those optimizations if `configValues` is a static-qualified pointer whose address is never taken. 2. Accessing things through `configValues` would likely be more expensive than accessing through `configStorage` in cases where the value isn't cached. It would be much more useful to have a qualifier that would invite compilers to assume that, within any particular execution of a function or loop wherein the lvalue is identified "by name", any action that modifies the lvalue will involve the use of that "name" within the loop. The existing "register" qualifier would seem a nice choice, if the constraint against taking the address at all were eased to instead limit the use of the resulting address, and the constraint against using it with objects of static duration were eliminated. In a situation like the above, it would be necessary for the compiler to know whether the called functions make use of `configStorage` by name, but that could be accomplished via an "incremental-build-friendly" two-step process where all files are pre-scanned, a combiner produces for each file a file with information about things imported thereby [leaving that file alone if nothing changes], and then all files are compiled. The prescanner would, for each compilation unit, produce a list of functions therein and the ways in which it uses external symbols. Unlike "whole-program optimization" methods that would essentially require always rebuilding everything, the use of a pre-scan approach would only require recompiling portions of the project whose dependencies are changed. Incidentally, this general approach to building would allow for a category of implementations that wouldn't need to rely upon the "one program rule"'s allowance of arbitrary behavior, by adding a `__STATICALLY_SAFE` directive, such that all potentially-recursive portions of the code were guarded by: if (__STATICALLY_SAFE) ...complicated_stuff that may involve recursion else ...simpler_stuff that doesn't involve recursion ...and all calls to code outside the implementation were marked with maximum stack usage, it would be possible to statically-determine the maximum amount of stack that each function could require if every `__STATICALLY_SAFE` were to yield zero, and from that to determine how much stack space would be required at every `__STATICALLY_SAFE` directive for it to safely yield a non-zero value. This would make it possible to guarantee that while it may be necessary to abort complicated operations because of stack limits, stack overflow would be impossible. 
I'm using size_t instead of int because the C `sizeof` operator returns a size_t. For this code either could work but it's a good habit to get into as for very large values an `int` might overflow whereas a `size_t` is guaranteed by the standard [to be able to store any object size/array index](https://en.cppreference.com/w/c/types/size_t). If you were calculating the size of a very large array (like in the following example), the integer will overflow: #include &lt;stdio.h&gt; #define TWO_BILLION 2000000000 int main(void) { size_t st_huge_array = sizeof(long) * TWO_BILLION; int int_huge_array = sizeof(long) * TWO_BILLION; printf("Using a size_t = %zu\n", st_huge_array); printf("Using an int = %d\n", int_huge_array); } As for line 38, it's just a trick you can use in C if you have declared the array in the same function and in the way I declared it. You can break down what's happening by executing this code: #include &lt;stdio.h&gt; int main(void) { int my_array[10]; /* The size of the whole variable "my_array" */ size_t total = sizeof(my_array); printf("The total variable size is: %zu bytes\n", total); /* Now we can get C to tell us the size of a single element (in * this case by asking for the size of the first entry */ size_t element = sizeof(my_array[0]); printf("The size of my_array[0] is %zu bytes\n", element); /* And now we can just divide the total size by the size of each * element in order to get the number of elements */ printf("%zu / %zu = %zu\n", total, element, total/element); } Note, that this trick does not work if you have passed the array to another function, because in C it will decay to a pointer and the sizeof trick will return the wrong value. That's why a lot of C library functions will take a pointer to an array along with the number of elements (e.g. [snprintf](https://www.geeksforgeeks.org/snprintf-c-library/).).
Judging from the support forums, some compiler writers take the attitude that programmers are supposed to serve compilers, as opposed to employing compilers as tools to help them perform tasks. The Spirit of C is described in the published charter and rationale documents for the Standards as including the principles "Trust the programmer" and "Don't prevent the programmer from doing what needs to be done". I'd suggest that in light of the second, the first should be interpreted as, in part, "Trust the programmer *to know what things needs to be done*". The compiler writers, however, interpret it as "Trust the programmer to abide by restrictions written by people who have no particular knowledge about what the programmer needs to do". Obtrivia: the first version of Tetris that ran on the IBM PC was written in Russia using Turbo Pascal, not C. 
I think it is reasonable, readable, and useful to declare many objects on one line if all are of the same type, and either all are initialized to "simple" values, or none are initialized at all. Although people with good eyesight will find that today's screens no longer have the limited vertical range of those in decades past, the readability of code for people with somewhat more limited eyesight can be improved by minimizing vertical sprawl. 
I think the confusion is happening because while you definitely *can* use `\x` with values greater than 0x80, the result is relatively undefined. You can probably safely expect the binary bytes of course, but I don't think the standard even bothers with how those binary bytes relate to the locale during compilation or during runtime.
Well you got me. I don't understand it. Clearly it fails with printf and works with puts so it must be doing something.
It works with puts.
I'm confused between your statement and example. It seems more like puts is the generic version as it doesn't do anything special with formatting or anything but just outputs exactly what you put in there.
Look at the ASCII table. Characters are grouped quite nicely. It shouldn't be a problem for you to utilise this :)
OK, sorry about that :). You have it exactly right, `puts` just outputs a string, nothing more, nothing less, any transformations you see (like `\x25` to `%`) are happening on the level of C compiler or C preprocessor, not in `puts` itself. I was trying to make the comparison not from the point of view of the language, but of how you use it. You can give any number of things of any data type to `printf`, and as long as you have the right format string, it can deal with that. `puts` only deals with the one string.
In general, code which uses `fopen` should at minimum ensure that it yields a non-null pointer before attempting to do anything the file in question. If the code will not be able to do anything useful in the event that the operation fails, it should exit in a controlled fashion. For programs that are intended for immediate one-off use, running on implementations where attempting to use a null file will result in a predictable failure, it may be reasonable to omit such checks if it is unlikely that the operations could fail in the useful lifetime of the program. If a program is intended to be more generally usable, however, it should check `argc` to ensure that any necessary arguments are specified and fail with a suitable message (typically specifying the purpose of the program and/or the expected arguments) if they're not, and also check to ensure that any `fopen` operations are successful (failing with a suitable diagnostic indicating what went wrong if they're not). 
"not sure what syntax to use" holy shit drop the class man.
Look [here](https://ascii.cl/) -- "\x25" gets interpreted by the compiler as a string with the hex value 0x25 which, if you look at the table linked, corresponds to "%". If you keep following this exercise, you'll see "\x73" (hex value 0x73) is equivalent to "s", and "\x0a" is equivalent to "LF", also known as a newline, which is represented as "\n" in code. Your computer has no concept of "characters"; in memory, they're represented as integers, which at some point gets mapped to symbols to be displayed. ASCII is the most common way to map these integers to symbols, which is what the table I linked shows. "A", 0x41, 65, "\0x41" -- these are all the exact same value in memory.
I guess in some ways it's a matter of preference. Idk which is more efficient for the compiler and which works better during runtime. I guess I'm just used to working in a text editor and I like having everything on a separate line unless I'm declaring a few null variables.
if break else.. this sub is more entertaining than programminghorror.
Every time you find a new longest word you overwrite the shortest with the previous longest for some reason 
Lol, can't. Else I have to drop the degree.
 dinfo-&gt;shortest = 0; if(length &lt; dinfo-&gt;shortest) Are any words shorter than 0? You need to make `shortest` start out with a value at least as big as the length of the shortest word.
Okay, I see how that works, but how can I fix it? Because if I don't set the shortest word to something then it just comes back as zero. I tried setting it to the size of the buffer but that still did not work. Thanks for the help.
Degree? If you can not handle this assignament, are you sure you are aiming for the right degree?
Someone asked the same thing yesterday and I was dumb/nice enough to post the whole code for that same casecheck function. It may have been you or one of your classmates.
Set the shortest word to the length of the shortest word...
If we're going to be pedantic, most runtime errors are either signaled by the operating system or the CPU itself. In some cases there are failed assertions which are somewhat similar to throwing an error. Everyone will know what you mean if you say threw an error anyway, just technical terms here. (Although the actual error would be useful to us if it gives you one)
&gt;Is it same as #define BUFFER NULL ? No. In this context, there is no special meaning to the curly braces, they will be literally substituted into the source code when the BUFFER define is used. &amp;#x200B; What this type of construct is typically used for is with initializing, say, an array of structs, where the first struct element is a pointer, and the second an int. This macro (BUFFER) can be used in place of a {NULL, 0} initializer, typically to visually indicate that it is initializing a buffer (which is a pointer to memory, and the buffer size). &amp;#x200B;
 &gt; You mean UTF-8? MBCS Yes.
Read up on function definition and function declaration. 
Can anyone google what the implicit declaration of a function means? Thanks.
Well, during compilation, they're just the specified bytes, right? At runtime, they're also the specified bytes ... until someone decides to do something with them like send them to some locale-specific feature of the language or operating system. Are those claims ever not true? There's certainly the neutral "C" locale, too.
Oh, yeah. I am a legit dumbass xD. Thanks for the help.
As much as I hope so, I would hope for c to upgrade more with new features that may streamline the programs
Which features do you miss?
Oh not feature that I miss, but updates, heck even internal updates or syntax sugar
Don’t get me wrong, change for change sake is a fools way of life, change to facilitate updates is something that Is good, c has a very conservative standards committee while c++ much more open. Simple things like Apple Proposal for change were rejected despite it being simply syntactic sugar .
I think those claims are exactly true, and that *that* is the "problem" :). Because what that really means is that the exact same executable can *appear to* give very different results to different users. Say, * 你好 * ä½ å¥½ * � And because most users think those strings are completely different, it's reasonable to eschew using \x80+ unless the circumstances make the effect well-defined. (And it also means that if *all* your users are on utf8, you can use it just fine.)
Instead of being condescending, commenters could have told you that there's a difference between function declaration and function definition. Declaration is just the skeleton version of the function that is just its name, return type, and arguments; it looks like this: `void foo(int argument1, int argument2);` &amp;#x200B; Definition is the declaration + a block of code afterwards to actually run; it looks like this: `void foo(int argument1, int argument2){` `printf("now doing function stuff \n");` `}` &amp;#x200B; You can do something called forward declaration, which just means that you make a declaration before the code that calls the function, but only actually define the function later. meaning function A could know about function B before either is ever defined, letting you call B from A, even if A was declared first. [https://ideone.com/RQB9jB](https://ideone.com/RQB9jB) is an example of this, note that nothing is stopping the program from just running in an infinite loop (which looks like a hang or crash), if you want it to stop you would need something to stop it (such as a counter variable that limits how many times they can call eachother, or user input that tells it to stop)
What website is this ? 
The fact that they're giving you a pointer to the data and the *size* of the data implies that they want you to make a copy of the data and put the data in the queue. So presumably, they expect you to implement the `Queue` data structure and a `Node` data structure to represent an item in the queue. The `Node` structure will hold a copy of the data (or a pointer to a copy; how you implement this will be up to you) as well as the bookkeeping elements involved in implementing the queue. The example they gave isn't a good one. Translated to English, `entry` is an array of pointers to nil-terminated strings. So entry[i] is a pointer to one string. `strlen(entry[i])+1` is the length of that string plus the terminating nil. So the function push_queue() has been passed a pointer to a string plus the number of bytes you'll need to allocate to hold a copy of that string. ---- Minor pedantic points: casting the pointer to (void *) was pointless unless you're using an older version of Microsoft C or C++, as `void *` doesn't need casting. Multiplying by `sizeof(char)` was also pointless, as `sizeof(char)` is always 1.
The example is from a test program I'm given but I'm using ANSI C to write this program, the specs I'm given above the function in comments are: /* add entry to end of queue *queue */ /* allocate storage of data_size bytes in new entry */ /* copy data referenced by *data to entry */ /* allow data to be NULL */ /* return pointer to newly created entry */ /* print an error message and return if queue is NULL or empty */ I should have probably elaborated this is for a library for a queue and i have to structs queue which is a doubly linked list and a node which is: void *data; struct Node *next; struct Node *prev; so i don't quite understand how they want me to use the info given to allocate into the void \*data? From what i understand you're saying to create a copy of the data and point \*data at that copy in the node? &amp;#x200B;
Yep, I understood it with the help of previous comment and digging a little more through the source code. My dumbass thought the curly braces were used for mapping NULL to 0(which should already be that way IIRC). Apparently, I need to revisit the resources I used to learn C in the first place as my understanding of C has become rusty in just a year.
Either these different outputs are because of bugs in what was done with the string (that is, how the program ask the OS to present it to the user), or I'm not following your point.
Think about when your function exits the `while()` loop. I would add `printf()` statements inside your `while()` loop so you can observe the string comparisons. Also, I would move the following out of the `while()` loop: strcpy(word_copy, word); mystrupr(word_copy); /* makes word uppercase*/
Okay, it seems that it is not checking with every word in the dictionary and when it gets to the words that don't start with a then it automatically results it to not zero. But how do I fix this? I am sorry but I just can't seem to wrap my head around it.
 char * (*ptr)[2]=malloc(sizeof(char * [2][2])); I tried mallocing ptr this way and it worked. So just asking is there a difference between how i am mallocing here and in the post. Is it because data isn't arranged sequentially in the ptr array in my post that is why the qsort can't access all the elements as it should?
Forget about using the multi-dimensional array indexing notation with malloc'ed memory. That's added complication, and it's \*not\* the same as a C multi-dimensional array with static dimensions (ie. 2x2). The fact you have multiple mallocs to make your emulated array means it cannot be a single contiguous piece of memory. &amp;#x200B; You want to operate on 4 elements, so malloc space for 4 elements, ie. malloc(4 \* (sizeof char\*)) Then to treat it like a 2x2 array, instead of using ptr\[i\]\[j\] notation, do something like (ptr + j\*2 + i). You can see that in a double loop where i and j range from \[0,2), this will address exactly 4 contiguous locations. Now, depending on what you want those two dimensions to represent, a sort may put you elements in somewhat arbitrary order. But that was true with the 2x2 array case as well. It's not clear why you want to sort the array as a whole, and not each subarray individually, for example. But at least qsort won't crash when you actually give it a single contiguous chunk of memory of the correct size.
Thanks for the advice and help. Understood.
You need to find a way to keep checking failed words until you have gone through the entire dictionary (EOF) - so if the word is bad and it is not EOF continue the loop.
Oh I see! Thanks so much for the help! That makes sense!
I would argue that nullptr is useful for clarity of intention: if(badlyNamedPtr == nullptr) But even then, it's a stretch (implicit truthiness is implied with "!badlyNamedPtr").
The signature `char * strcpy(char * dst, const char * src)` makes sure the caller does not swap the arguments by accident.
Sidenote regarding the /\* gets rid of newline \*/, sometimes a file does not end in a newline.
IMHO, that not a bad way to do it. The "hairiness" is concentrated to that one point, later it's convenient to index. If ever required, \[j+x\]\[i\] is neat, no need to add parens like (j+x)\*2. But, matter of taste.
Missing variable. union union\_typename { ... } variable\_name;
Oh, I see! Fixed once I appended a variable_name and started calling the union members. Thank you!
It works with `puts` because `puts` doesn't do anything with the string you pass to it other than writing it to standard out. `printf` however parses the string looking for format specifiers that start with `%` then puts the content of the variables passed in the right part of the string, or if there aren't any format specifiers in the first string passed to it it will simply write that string to standard out. In your case the first argument passed to `printf` is `"%s\n"` which tells `printf` you want to print out a string and a newline, but you've not given `printf` a string to print.
Nah, it is a very valid question! C macros are not known for their readability =/. 
Not necessarily, you can create an 'unnamed' or an 'abstract' Unix socket that has no connection with the filesystem. See man 7 unix
Those are the exact same string, interpreted as utf8, iso-8859-1, and a failure parsing it as utf-16. My whole point is, C doesn't care, so you can't *just* use them and expect every user to see the same thing. If you do the same thing in a higher-level language (or in C with the right set of functions, but definitely not printf), the runtime will try to convert the string to the right user-dependent representation.
I'm in bed so i'll cant really run your code to test my theory right now, but I think when you do `*map[x][y]` That resolves to: `*(map[x][y])` because array accesors have higher precedence than the deference operator: https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages
No. Its not.
Edit: SOLVED for the moment being, but this led to another problem. I am trying to solve it, but if I can't, then I will make a new post in addition to this one. P.S. Thanks for your help
With a good visual aid it can be as efficient and also entertaining. 
It sure is! How could it do that? It's obviously right, right? I'm sure your compiler is broken! Have you tried rebooting? I think maybe the guy that owns the website you're pretending to compile on is just screwing with you while he sits around picking through other peoples code.
I really, really like this. Adding in a couple: * Grand unified theory of pointers and arrays. Arrays are pointers. Pointers are arrays. Fully grasping pointer arithmetic is essential. * C is a pass-by-value language. This is especially important for those who learn it after learning Java or python, for example.
[Here](https://pastebin.com/NdzkUa58) is a pastebin with the fixed code. Personally, I think that I would have the read function return a map - this would get rid of the triple pointer. map** read_map(int &amp;map_size_x, &amp;map_size_y); I would probably also use a struct to hold the map. The struct would also hold the map size. This would simplify the code and could also hold other information such as the current player position, inventory, health, etc.: typedef struct { room **map; int map_size_x; int map_size_y; } map_t; 
Yes - it needs parentheses around the *map. So it should be `(*map)[y][x]`. Not a C guru, but I would guess that this due to the '[]' having a higher [precedence](https://en.cppreference.com/w/c/language/operator_precedence) than `*`. So it is trying to do *(map[y][x]) instead of (*map)[y][x]. 
A stack-based language is one in which a stack, implicitly accessed by most operations, is a fundamental part of the programming model. Languages which maintain a program stack ("TheStack") for storing of ActivationRecords and/or parameter passing as an implementation detail, but keep the programmer from manipulating TheStack directly, don't count. This includes most imperative programming languages (CeeLanguage, CeePlusPlus, JavaLanguage)--in each of these, the program stack could be replaced with an alternative data structure (for example, heap-allocated activation records, like SmalltalkLanguage has). Likewise, providing a stack data structure in the library also doesn't count. 
You should post this in r/csarp or r/CSharpHomework. This sub is about the C programming language.
Also, this is personal preference, but I always make 2d structures like this one dimensional and I just do arithmetic to get the 2D equivalent coordinates
Fair enough. I think that’s personally because it takes a special person to be able to present and capture people’s attention and there simple aren’t enough people that can do that. So you end up with boring lectures. 
C can be implemented without a stack. The standard does not mention the word even once. 
Pointers are not arrays... https://stackoverflow.com/questions/3959705/arrays-are-pointers Also see "Deep C Secrets" by Peter Van Der Linden I'm pretty sure C is not always pass by value either, arrays are passed as pointers.
Seriously; I'm dying to know what algorithm the professor had in mind.
Unless a program happens to use recursion, the notion of a stack really isn't relevant. There are some implementations that implement dialects of C that mirror the Standard except that: 1. All floating-point types use 32-bit precision, which falls short of the ten-digit precision the Standard mandates for `double`. 2. Recursion is not supported. Some of these implementations target platforms where use of a C-style stack would horribly degrade efficiency. To avoid that, these implementations statically allocate objects using the same amount of memory as would be required to accommodate worst-case stack usage (assuming that all combinations of function calls which exist in the code could actually execute) but don't actually use a C-style stack. While some of these implementations have a hardware stack which is used to hold return addresses only, some don't even have that, storing return addresses the same way as other automatic objects. A more important principle that the notion of a stack is that C's suitability for a wide range of tasks flows from Spirit of C which is described briefly in the charters and rationales for the Standards, but for some reason omitted from the Standards themselves. C was designed to be a simple language, but simple implementations that recognizes the principle "Don't prevent the programmer from doing what needs to be done" can make it possible for programmers who are familiar with their target environments do things far beyond the imaginations of the authors of the Standard or the implementations in question. The authors of one of the limited implementations described above, for example, may have had no idea that it would be used to implement a system with a graphical display with proportional fonts as well as a flash file system, but it was. What's important is that the implementation allowed code to access the hardware registers necessary to drive the LCD display controller and flash chip. The implementation knew nothing about the effect of writing various addresses in various sequences. All it had to do was perform the addresses in the sequence specified by the program, and trust that the programmer knew what sequences would be required to achieve the necessary results. Unfortunately, there's another principle programmers need to realize: many compiler writers are more interested in processing the minimal dialect described by the Standard, than one which actually satisfies the needs of programmers trying to perform common tasks. Those who need to do nothing beyond processing trustworthy input may find the "maximally-optimized" dialects offered by clang and gcc adequate for the purpose, but the only way to make clang and gcc behave in a fashion that is particularly suitable for many other purposes is to disable some optimizations. 
You and me both. A doubly linked list using the sieve and making it work for 86 million numbers in under 5 minutes...
My best guess is that you're supposed to delete items from the list as they're determined not to be prime. The list gets shorter real fast, but this is still a horrifically inefficient way, in both memory and cpu. Consider: using arrays, the sieve can be implemented using one **bit** per candidate. Using a doubly-linked-list, it's two pointers and an int per candidate. I can't help but wonder if OP mis-read the assignment.
Well, if that's all you took from the statements, &amp;#x200B; I didn't say it was \[a stack based language\]. &amp;#x200B; But since we're being pendantic, *it doesn't have to.* The language grammar definition is itself a stack expression.
Sadly I didn’t... we can’t use arrays. We have to use DLLs...
Pointers are, like all function arguments, passed by value.
COBOL is a *procedural* language. BASIC is an *interpretive* language. It has nothing to do with the PC. Not all computers are PCs. Not all computers and CPU have dedicated stack pointer. Not all CPUs operate on stacks or have dedicated stack manipulation registers ala BP/SP Wikipedia...gee.
Anything is possible, of course. Knowing what a stack based language is implies many things. &amp;#x200B;
You're too literal. I was describing the toolset that you need to learn C. I didn't say C is or is not stack based. 
I only know how to do that in imaginary time. so sorry.
You are missing a header guard in instructions.h :) &amp;#x200B; otherwise, this looks really quite good! &amp;#x200B; What's it with all the unused parameters? Did you do that to have a common interface?
Some minor things that catched the eye: read\_input\_char() locks up if input ends too soon. load\_program() accepts 1 byte program. LOAD\_OR\_ERROR() could have do { } while (0) brackets.
If you want to download the challenge materials without giving up your email address: curl -o synacor-challenge.tgz -XPOST -d "action=signup&amp;email=$RANDOM@example.com&amp;password=x&amp;twitter=&amp;firstname=x&amp;lastname=x" https://challenge.synacor.com/
Ah, damn! You can tell that I developed this without an IDE. Yep, that's it exactly. Some of the instructions need access to the Execution struct, others don't.
I'm not motivated to finish the rest of the challenge, to be honest. I got everything I wanted to get out of it by implementing the VM. I'll have to read someone else's write-up, though, for sure.
Thanks for the review! &gt; read_input_char() locks up if input ends too soon. Not sure what you mean. If input ends, doesn't it mean that the program has ended? The use case described in the spec is that the VM requests user input, the users enters a full line of text and presses enter. &gt; load_program() accepts 1 byte program. Good catch, this never occurred to me. I think the program behaves reasonably in this case, however. $ echo -n $'\x01' &gt; test.bin $ hexdump -d test.bin 0000000 00001 0000001 And when printing out the first couple of memory cells (each value is a short): [kevingalligan@localhost SynacorInC]$ ./synacor test.bin 1 0 0 0 &gt; LOAD_OR_ERROR() could have do { } while (0) brackets. Cool, I had to [look this up](https://stackoverflow.com/questions/4674480/do-whilefalse-pattern) to understand the usefulness.
NP. The link actual referenced atexit and then I remembered reading about it many moons ago...just forgot.
What did you mean by "stack-based language"? Early implementations were very much tied to the way the machine's stack worked, as evidenced by the 1974 C Reference Manual, making the C of that era very much a stack-based language. But if that's not what you meant, then what *did* you mean?
i am not fluent in it yet but so far it feels like i was given all the paints and pencils in the world and was told to create a masterpiece. the more you use it, the better you get at creating the piece you want. just felt like sharing my thoughts
Thanks for sharing! This is exactly how I felt as I was becoming more proficient in 3D modeling! Quite interesting! :D 
 if(result &amp;&amp; !EOF) { fclose(fp); return WORD_BAD; } Here's your problem. [`EOF`](https://en.wikipedia.org/wiki/End-of-file) is a macro that expands to a value that is typically non-zero (it's implementation dependent, for instance on glibc it's `-1`). So the negation operator (`!`) will end up taking a value that will usually evaluate as true in a conditional (your `if`) and make it evaluate false. Your `if` will never have a true condition as written.
**End-of-file** In computing, end-of-file (commonly abbreviated EOF) is a condition in a computer operating system where no more data can be read from a data source. The data source is usually called a file or stream. In the C Standard Library, the character reading functions such as getchar return a value equal to the symbolic value (macro) EOF to indicate that an end-of-file condition has occurred. The actual value of EOF is implementation-dependent (but is commonly -1, such as in glibc) and is distinct from all valid character codes. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
However when I use feof I have the same problem except instead of displaying None it shows all of the words. So does that mean that that will not work either? Also thanks for your reply.
Could you show use how you're trying to use `feof()`?
The moment you see someone else's code, and you understand everything you see (as in, no new keywords / syntax). One reason I love C is because it's small, you can reach a point that you know "everything" C has to offer, and you can fit it in your head while programming and be comfortable and confident when choosing how to do something.
&gt; Sorry if my problem is really obvious and for the trouble. Don't worry about it; most of us love to help, and everybody starts somewhere. Your post is honestly much better than most of what we get by way of questions. As for the code you just posted, if you're going to use an `else` you don't have to check the value of `result` again, because the `else` is only triggered when `result` is non-zero and `if (result)` will always be true if result is non-zero. Moreover, your original code seems to indicate you want to return `WORD_BAD` when you haven't reached the end of the file, but the sample using `feof()` will only return `WORD_BAD` when the end of the file has been reached. Unless I misunderstand the nature of your function you may want to change that block to: if (result == 0) { fclose(fp); return WORD_OK; } else if (!feof(fp)) { fclose(fp); return WORD_BAD; } Hope that helps.
On a few platforms, pointers to different kinds of objects use different representations. Consequently, the Standard does not require that implementations allow a `void**` to be used to access any kind of pointer other than a `void*`. On commonplace platforms, however, all pointers use the same representation, making it possible to write functions that can maintain linked lists and other such structures containing any kind of pointers, at least when processed using implementations that respect the principle of "Don't prevent the programmer from doing what needs to be done". Unfortunately, some compilers are too willfully blind to recognize that in something like: void update_pointer(void **p) { *p = realloc(*p, whatever); // Simple example } THING *update_thing(THING **ptr) { if (!*ptr) update_pointer((void**)ptr); return *ptr; } the fact that a `THING**` is cast to `void**` before being passed into `update_pointer` is an indication that the function might affect a `THING*`. When using such compilers, it will generally be necessary to disable many optimizations wholesale to ensure proper operation.
Use [https://linux.die.net/man/3/uuid\_generate](https://linux.die.net/man/3/uuid_generate) , which uses UUIDv1. UUIDv1 are disclosing a lot of information, which is great. Use UUIDv4 if you're afraid of leaking your timestamps and MAC addresses.
This is non-standard behaviour with Microsoft's C library. Standard C requires that the exponent have at least two digits, but no more than necessary. A bit of Googling says that setting the `PRINTF_EXPONENT_DIGITS` environment variable to 2 may help.
&gt; 8.392e+002 This display arguably conforms to C90, but it doesn't conform to C99 and C11, which require that the number of exponent digits be at least two but no more than necessary. MinGW relies on the Windows C runtime, which didn't a C99/C11-conforming %e until Visual C++ 2015: https://msdn.microsoft.com/en-us/library/bb531344.aspx &gt;In previous versions, the CRT would always generate strings with three-digit exponents. For example, printf("%e\n", 1.0) would print 1.000000e+000. This was incorrect: C requires that if the exponent is representable using only one or two digits, then only two digits are to be printed. &gt;In Visual Studio 2005 a global conformance switch was added: _set_output_format. A program could call this function with the argument _TWO_DIGIT_EXPONENT, to enable conforming exponent printing. The default behavior has been changed to the standards-conforming exponent printing mode. So you'll need to use _set_output_format if available, or you'll need to get MinGW/gcc to link your program with a newer version of the Windows C runtime. You can get a newer version of the Windows C runtime from a recent release of Visual C++ Redistributable.
You cannot have 4 different returns. Either the file does not open, or you find the word in it (those can return early) 3rd, or you don't. Last one needs to go thru the whole file.
TIL C19 added classes to the standard C implementation.
They're juuuuuuuuust different enough from CPP classes to make source compatibility impossible.
Not a comment but a question: why is the instruction_buffer an array of 1? Does it mean something special compared to having a single variable?
Oh my gosh! You are right. Thank you so much. That makes perfect sense because it should be checked after the whole file has been read. I was making it way more difficult than it had to be. Thank you!
I don’t think it would be different, functionally speaking. I prefer the array because it’s consistent with args_buffer.
chuckling, you forgot "unlimited stack". 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
This is C++ code (as evidenced by including the C++ header `cmath`). Also, this is a weird challenge which sounds a lot like you trying to dupe people into fixing your code.
Maybe that include is one of the mistakes to find? But yeah, this looks like a trap. Who's interested in solving it should not post the result. 
Since I can't actually supply an unlimited stack, I picked a nice, simple cap. ;-)
Issues in no particular order of severity: (1) it's possible to crash the VM or corrupt memory through various instruction sequences because `set_reg()` doesn't sanity-check `register_code` and `value`; (2) it's possible to crash the VM because the mod instruction allows a division by zero; (3) the VM won't work on a big-endian machine; (4) `stack_push()` leaks memory when `realloc()` returns NULL -- you check for the NULL, but because you didn't use a temporary pointer, you've lost the ability to free the memory that was pointed to by `stack-&gt;elements`; (5) depending on the system, it may be possible to cause one or two numeric overflows within `stack_push()`, leading to memory corruption; (6) `load_program()` erroneously rejects a program that has a file size equal to the amount of available memory -- `fread()` doesn't set the end-of-file indicator in this case, so `load_program()` assumes the program is too big; (7) partial instructions aren't detected.
I agree. 
I agree. 
It s like bible of programmers every programmer should have it even don t read
K&amp;R! 
Copy of the Gutenberg bible. First bible to be ever printed. Circa 1455. Colorized. &amp;#x200B; &amp;#x200B; THAT SHOULD HAVE BEEN THE TITLE OF THIS PIC OP
It doesn't necessarily get worse here every day, tho.
You’ve got fun 'n' games! 
`a` is a pointer. a pointer is an address, but it is also a value, in memory. It's in memory, so what is it's address? It's address is `&amp;a`.