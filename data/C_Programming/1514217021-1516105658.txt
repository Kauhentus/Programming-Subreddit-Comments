I have. Have you read that I want to know when shift/alt/ctrl/windows key is pressed? How would you distinguish Ctrl+I from Tab? Ctrl+M from enter? Shift+letter from shift+letter with capslock turned on? I have also heard of S-lang. ncurses and s-lang are **obsolete**.
Does it really matter though? All those apps I mentioned still managed to get around the issues without needing to add X11/Cocoa etc.
Of course it does. They're restricted. That's especially true for editors - I can't add the shortcuts I want. For example, I wanted to add `^I` key bind for nano, turns out I can't. Same with `^M`. Same with hundreds of other key binds I would like to add. So either I have to accept these inconveniences when using a lightweight editor like nano or vim or I have to use a hogbeast that pulls hundreds dependencies just to get the window up. I want a middle ground. I want a terminal emulator that sacrifices backward compatibility with older applications in exchange for ability to create powerful and lightweight applications for it. Sure you can eat soup with a fork - it does the job, but I want some spoon luxury.
I will take this into consideration
Thanks for the help!
I will change how it is implemented thank you
My main thinking was too create a command line parser that could be used with subcommands. For instance like `git submodule add`. Does getopt already provide a good way to do this? Also I'll change the behavior. Thank you
You can pass arbitrary argument lists to `getopt`, just pass the list after the subcommand and everything should be fine.
Oh well, I suppose the downvotes mean that there isn't any and people are mad when you tell that a library with roots in 1977 has gotten some things wrong and does not reflect the current realities, which is of course the utter dominance of the IBM keyboard. It's sad, really. This refusal to change and stubbornness of keeping the old way (if it ain't broken don't fix it) only shows that C and UNIX philosophy in general is dying. For example, C11 threads are not implemented as of 2018 in glibc. You have to use something like `tinycthread`. `fopen`'s "x" subspecifier too. C++11 threads are fine though, although the language is the anti-thesis of UNIX philosophy. Another ones would be the refusal of people to abandon `vim` and `emacs` despite the rest of the world using "Mico$oft's" key bindings - I doubt people will agree to change their habits when they can just use something like CLion or VisualStudio (a bloated, proprietary IDE), even lightweight solutions using something UNIX-y like I've proposed would be possible. `sndio`, `musl` are a couple of fresh breaths into the void, but I doubt they will get much adoption out there. `wayland`'s future is better off, it seems. **/rant** **TL;DR: I guess I'll have to make my own.**
Instead of else ifs, just use if. I'm willing to bet you're running into a mutual exclusion issue with your else if statements. Not sure why, but I've had this happen before. Just use a bunch of ifs instead of else ifs. Hope this helps. 
&gt; Instead of else ifs, just use if. No! The point of else if is that your program won't have to compare the strings again every time. If you already have one match you know it's not going to match anything else, no need to check again. If this is causing issues for you, you are doing something very wrong.
Asymptotically speaking, those checks will be O(1) cost which won't add to the overall execution of the program. I imagine strcmp() does an iterative check, and as soon as something isn't the same returns. I've had situations where mutual exclusion makes it so other checks don't execute. It's something to try, and won't cost any hiccups in performance, so why not? 
&gt; I've had situations where mutual exclusion makes it so other checks don't execute That's the point, if you want the other checks to execute, you don't use else if, but in OPs case he should use else if. Why doesn't the compiler just put NOPs all over the place? I mean, they're O(1) right, so why not?
I think ncurses is a bit of a red herring. As you're probably aware, ncurses sits between the text-based app and the terminal emulator (or possibly between the text-based app and a terminal-emulator library such as VTE, an unimportant detail). All ncurses does is provide some convenient abstractions so that the text-based app doesn't have to bother issuing ioctls to determine certain terminal parameters or querying termcap/terminfo to find which escape sequences and whatnot the terminal emulator uses. The problem is that ncurses can't magically disambiguate key codes from an uncooperative terminal emulator that insists on overloading its key codes. In these diagrammed situations, assuming an uncooperative terminal emulator... terminal emulator ==&gt; text-based app (stdin) terminal emulator ==&gt; ncurses ===&gt; test-based app (stdin) ... ncurses achieves nothing. Disambiguating your TAB and CTRL+I isn't going to be possible if the terminal emulator doesn't cooperate by sending distinct key codes. Once you have that cooperation, you can replace ncurses with something smarter like libtickit (or its libtermkey component) or perhaps achieve your libc-only goal by eliminating the middleman and interpreting the key codes directly. So this all starts with the terminal emulator, which you seem to realize. I'm not aware of any terminal emulators that behave in a completely 'modern' way out of the box, but people have managed to use X resources and whatnot to reconfigure their terminal emulators to send distinct CSI codes.
The compiler is a translator, there's no reason for it to do that. However in some pipelining scenarios, NOPs are inserted in order account for data hazards, but I digress. This was a suggestion that worked for me at some point. OP is free to do whatever he/she likes. 
Thanks, I somehow missed that. Sleep is important.
Worked fine in Plan 9 http://doc.cat-v.org/bell_labs/pikestyle
I actually wrote a vim plugin for this a few months back. There are links to the docs for C11 N1570 on the repo :) https://github.com/joereynolds/vim-c-manual Or to save you a click http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf
What you want is not a terminal emulator. The whole point of a terminal emulator is to be somewhat like a terminal. The terminal abstraction doesn't admit the behaviour you want because it is fundamentally character oriented (so no transferring whole 32 bit integers without having them interpreted as four chars) and the way terminals work involves a trip from the terminal to the kernel back to the terminal just to display characters you typed. You want something entirely different, consider building your own thing with SDL. It's going to be quite unlike terminals though.
&gt; ncurses and s-lang are obsolete. s-lang may be, but ncurses is far from obsolete. It's an industry standard and used under the hood by 99% of applications that do complicated things in the terminal.
You fundamentally can't have that with terminals because that's how terminals work. In ASCII, a newline and Ctrl-M are the same thing. There is no way to distinguish the two. This is not fixable. You want something that is not a terminal.
Better to cache so it costs as little do it properly. Which is why I don't think it will gain you much as I bet gcc and clang optimize this as much as it's worth. Add SSD and the uncached IO is fast too.
&gt; It's sad, really. This refusal to change and stubbornness of keeping the old way (if it ain't broken don't fix it) only shows that C and UNIX philosophy in general is dying. That comment just seeps of self-righteousness and smugness. If you want to see what happens when you break compatibility every other version, look at web hipster programming languages where everything breaks all the time and code written a year ago won't work anymore because some random API changed. That's not the world I want to program in. I want programs I write today to compile and work in 20 years without any changes in the source code. A tool that does not provide this is not worth using. &gt; For example, C11 threads are not implemented as of 2018 in glibc. C11 threads are a piece of bullshit. They provide a subset of the functionality pthreads provide and pthreads are the more compatible and better industry standard, so use them. The only point of pthreads is to wrest the power to define the future direction of multi threading from the POSIX committee to the C committee, a shit move since the latter has been bought out by Microsoft. &gt; Another ones would be the refusal of people to abandon vim and emacs despite the rest of the world using "Mico$oft's" key bindings - I doubt people will agree to change their habits when they can just use something like CLion or VisualStudio (a bloated, proprietary IDE), even lightweight solutions using something UNIX-y like I've proposed would be possible. People don't want to abandon vim and emacs because they are strictly better than what Microsoft provides. I for my part have tried IDEs and found every single one to be a bloated piece of shit that keeps me from developing software effectively. I want a tool I can 100% understand. A tiny editor like nano provides that. A bloated piece of shit IDE does not. 
Common example is tar 
true and as already mentioned, it's written in the guidelines of the standard, I was just too tired to not miss it
Most compilers are smart enough to recognize the include guards the first time they read a file and will not read it again. 
The downvotes are cause you’re being a dick
It's more readable if your if/else if flow matches your actual program flow. Otherwise, the reader might get confused for a second and consider why you didn't just write an else if.
Which version of Visual Studio? Offhand, the first code shouldn't compile. While the first line of that ends up creating a temporary part_mouth (which is immediately destroyed... probably surprising behaviour to you, but does conform to the language), I don't see why your compiler is allowing you to invoke a non-static method on a type. Clang does correctly complain about "cannot use dot operator on a type".
2017, it is. Very confused. Well, it's just a curiosity, I suppose.
Odd. On my version of VS 2017 it simply doesn't compile. I get "main.cpp(58): error C2143: syntax error: missing ';' before '.'" which is as expected.
?!??!?! At this point, I'm hypothesizing ghosts.
C++ != C
whoops
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. in /r/cpp_questions.
So? What is your question?
Hi, there are many mistake in your code. 1) why are you using argc and argv if you aren't using any arguments of argv ? 2) struct it's better declare out of Main 3) in gets don't need &amp; for the string 4) you have to put # before include and define 
tar is a bad example as it doesn't follow the utility syntax guidelines. How about [make](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) instead?
I think the closest things in that regard are kitty and alacritty.
`u` `U` and `u8` are Unicode string literals... `L` means long, I'm pretty sure it means Unicode in that context as well but I've never written it that way so I'm not 100% sure.
You make a loop. For example: while (1) { // ask question } Alternatively, you use goto: question: // ask question goto question; There are many ways to achieve this. Function calls, different types of loops etc. The correct way depends on each situation. 
Thank you very much for taking time to answer me and for your response.
what about a do-while loop
You can put the prompt inside a function. To return to the prompt, you just call the function again. For instance: void userPrompt(){ // Choice 1 // Do choice 1 stuff // Then call userPrompt (); to get back to this menu // Choice 2 // Do choice 2 stuff // Then call userPrompt (); // Choice 3: exit the loop } Edit: I hope that reads clearly, I don't know how to get that to format properly
Thank you very much. I think this is the best option for me. 
It's a clean solution and it's easy to work with when you have to make changes later
there are multiple jump statements you can use such as: goto statement break statement continue statement exit() function
I think what you mean is that *from* the second iteration it doesn't let you input the *name*. Hint: Add a puts() to clear_keyboard_buffer() that will print a message whenever clear_keyboard_buffer() runs.
Relevant with the goto suggestions: http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html 
goto has limited use cases, breaks and continues are mostly only relevant in loops, exit() will cause the program to quit. I don't really see how these are helpful here?
To have some text display as code, you need to indent it with 4 spaces. To produce Hello World You must type Hello World
`realloc` is basically `malloc` with the new size, `memmove` and `free`. (But implementation can optimize this process because they've got more information they can use, like just extending the current allocated block, producing the same pointer) So the pointers `arr` and `newArr` are invalid and shouldn't be accessed anymore, since the pointer in `newArr2` is the current one. So only use `free(newArr2)`.
&gt; As per the accepted answer the old memory should've been cleared but it didn't. I was able to access memory and was able to change value on old address. There is no guarantee, in the C standard, that the memory will be cleared. Once you've called `realloc` or `free` on a pointer, the system is allowed to do whatever it wants with the memory behind that pointer—which may include clearing it, or reusing it for other data, or doing nothing and leaving it as it was before. Because accessing freed or reallocated memory is [undefined behavior](https://en.wikipedia.org/wiki/Undefined_behavior), a _correct_ program should never be able to tell the difference.
**Undefined behavior** In computer programming, undefined behavior (UB) is the result of executing computer code whose behavior is not prescribed by the language specification to which the code adheres, for the current state of the program. This happens when the translator of the source code makes certain assumptions, but these assumptions are not satisfied during execution. The behavior of some programming languages—most famously C and C++—is undefined in some cases. In the standards for these languages the semantics of certain operations is described as undefined. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
On the stack overflow post you keep saying you can access the old memory. Sure, you can *in this case* because `realloc` extended the allocation you had already made. *In general*, `realloc` can give you any new block of memory it wants. That's why calling `realloc` on a pointer invalidates *all* previous references to that allocation. As a roundabout way, that answers your question: since everything else is invalidated, you call `free` on the *last* time you `realloc`d.
Meh. I think the goto-fear is way overblown. Yes, code can get hairy with long/many goto-jumps, but any code can get hairy. Many times a goto can be cleaner than trying to fit a loop/switch/break.
Even after freeing memory, it is allowing me to modify the value at the memory location. This is a strange behaviour. I think once the memory is freed, access should be restricted unless it is allocated explicitly again.
But shouldn't it be made inaccessible unless it is allocated again explicitly by the program? What's the use of freeing it then if program is still able to use it even after freeing? It's really weird.
In my case, memory was not extended. It was given a completely different address.
Okay, well even in that case, there's no guarantee that `realloc` will zero the memory. It just returns it to the list of blocks that can be allocated again. But again, there's no guarantee about any of that working. That's why calling `realloc` *invalidates all previous pointers* to that block; it's undefined behavior what's in that memory block now. 
You're in for a fun ride.
&gt; I think once the memory is freed, access should be restricted unless it is allocated explicitly again. This is not true. When you free a block of memory, the memory is not necessarily returned to the system right away. In this case, you can still access and modify this block of memory without getting an immediate segmentation fault. However, doing that may lead to incorrect results sometimes randomly.
This is the explanation I was looking for. Thanks a lot.
But what you're doing is undefined behavior and that is one such behavior. Just don't rely on it. The standard doesn't say that the implementation needs to restrict access to it, so the implementation can make it faster. It just gives the responsibility to you, the programmer, who is using such functions. To restrict access, you would something that creates an exception/signal when accessing such memory, and memory is divided in pages, so to mark a page as invalid you would either need to put each allocation on each page (wasting memory) or cram memory on the pages, but when a block of memory should be restricted, mark it as invalid, and in the handler check if it really tried to access an invalid block, or a valid one, but that just makes the program slower.
What do you mean by "made inaccessible"? The C standard already forbids you from accessing it. Do you want the compiler to reject your code if you access memory after freeing it? Unfortunately, that's impossible, at least in C—the compiler has no way to know, in general, which pointers you've freed and which you haven't. Do you want your program to crash at runtime? [AddressSanitizer](https://en.wikipedia.org/wiki/AddressSanitizer) will do that for you, at the cost of making your program run much more slowly. &gt; What's the use of freeing it then if program is still able to use it even after freeing? Calling `free` (or `realloc`) tells the operating system that the memory is safe to re-use, because your program no longer needs it. What happens to the memory after that is the operating system's decision.
**AddressSanitizer** AddressSanitizer (or ASan) is an open source programming tool by Google that detects memory corruption bugs such as buffer overflows or accesses to a dangling pointer (use-after-free). AddressSanitizer is based on compiler instrumentation and directly-mapped shadow memory. AddressSanitizer is currently implemented in Clang (starting from version 3.1) and GCC (starting from version 4.8). On average, the instrumentation increases processing time by about 73% and memory usage by 340%. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It *is* inaccessible as far as the language is concerned. Anything can happen if you violate the contract you made with the memory allocator and try to use an address you no longer have permission to access. It could crash your program, it could silently corrupt some internal data structure, it could do anything. So don't try to access it.
Thanks for this clear explanation.
Remember that not all systems even have an MMU. If you're working in the embedded world you might have at best an MPU that can protect blocks of memory by task, but frequently everything is in one unprotected address space. The system has no way to *stop* you from accessing any address. Free a block of memory and the allocator marks it as available - that's it.
Calling free tells the C runtime that the memory is safe to re-use. The runtime then may or may not subsequently give the memory back to the operating system, in which case a segfault would notify you of an erroneous access.
Yeah, I didn't want to overwhelm OP with all the details, but that is a more accurate explanation.
"GoTo Considered Harmful" Considered Harmful https://news.ycombinator.com/item?id=11056434
No, he should actually use a switch statement. and the whole point of if else if is that it's boolean logic, only 1 option can match, if you use multiple if's, the pieces of logic are independent of each other. A can be true and therefore would run, and if b is true it would run as well.
Use getopt (I say this as someone that's written their own command line parser, mine is called [CommandLineIO](https://github.com/bumblebritches57/BitIO/blob/master/libBitIO/src/CommandLineIO.c) It's a huge PITA for very little benefit, literally the only reason I've written my own is because I have unique requirements, and need cross platform support.)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bumblebritches57/BitIO/.../**CommandLineIO.c** (master → ca80b3c)](https://github.com/bumblebritches57/BitIO/blob/ca80b3c15484f3fd885e6b4acdcddbdc763b654b/libBitIO/src/CommandLineIO.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drsjbmw.)^.
Memory is allocated from the OS on a page by page basis (because that's the finest granularity of access control afforded by an x86 cpu). Memory access control is done by hardware so if a page is allocated to your process with read access you can read it. It's not part of how C works, it's part of the hardware architecture. Other architectures may be different. Malloc/realloc are part of the c library and interface with the os to get memory pages (VritualAlloc on windows, mmap/sbrk on unix-likes). They then devide those pages into smaller chunks that fit your allocations, all while managing the book keeping. 
Is your second version entering the loop body more often? As a diagnostic, you could have a counter that just increments in the loop body and print that with your timing, to compare the work done per case. On a modern CPU I'd expect the two expressions would be equally efficient unless the compiler sees something in your data that allows for an optimization. You could look at the generated assembly to confirm, or try your test with optimization explicitly disabled.
Seems strange. Can you post your whole code, including the bit that's counting the iterations?
I have no clue what you are trying to do. But, I think there are 2 or 3 things going on here. Sorted vs. Unsorted List, and != (not equal) vs. &gt; (greater than operation). So given that looks like C language it may come down to the assembly language. What hardware platform? X86? I would check the number of clock cycles used by the primitive operation (instruction set). And of course if we get really into it, there is the whole [caching](https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips) thing that the hardware does.... Then again we don't know the flags you used to compile the code either.
I added part that count iterations.
If you want to go somewhere goto is the best way to get there. That said, have you heard of our lord and savior do-while?
I had to make list which hold lots of elements but all elements must be unique so I first made it unordered and got awful performance, then I thought that performance would improve if list is ordered (since in average it would take less time to check weather element is in list) but performance got even worse. Both programs are executed on x86_64 platform. Programs are compiled with default flags (`gcc -o foo source.c`).
Post an assembly diff
I added relevant parts.
Try with optimization enabled (-O2 or -O3) and see if that makes a difference.
&gt; But shouldn't it be made inaccessible unless it is allocated again explicitly by the program? What's the use of freeing it then if program is still able to use it even after freeing? It's really weird. malloc()/calloc()/realloc()/free() on a Unix/Unix-like system such as Linux are not system calls. They're part of libc and manage the kernel-mode allocations made by system calls such as sbrk()/mmap()/munmap()/mremap(). Because they're part of libc, they run in user mode, not kernel mode, and therefore have no more privileges over the address space than your program itself. The only way to get the kind of enforcement you expect would be to rewrite the allocator so that it uses crappy algorithms and expensive system calls. The allocator can't stop you doing stupid shit that may introduce buggy behavior or even security vulnerabilities. On Linux, glibc's allocator (a ptmalloc2 derivative) has since 2004 tried its best to sanity check memory accesses, but it's largely "after the fact" -- i.e., it won't stop you using memory you've freed but will try to detect that you've done so. The reason you free() is to manage memory footprint. If the kernel has given the libc allocator 1MB of memory to divide up for your program, then free() lets the allocator know that it can reuse memory chunks without making expensive requests to the kernel for more memory. The allocator may add internal bookkeeping information to these freed memory chunks, so if your program keeps using those memory chunks after they've been freed, you're likely to corrupt that internal bookkeeping information. 
Generally, the two are just as fast. There are some limited architectures with a speed difference, but not good old x86. I am not sure what causes your problem. I had to do some benchmarking myself, but I don't have time right now to do that.
How are you running them? Is the slow one running first and bumping the CPU/OS out of power saving mode?
Here's a theory one why the ordered list may be slower. In the unordered list, you're probably mallocing the elements sequentially and just adding them to the list. Malloc may be handing out the elements in successive memory locations. Traversing this list means you're accessing successive memory locations. The cache should help. In the sorted list, you lose this property since you're now accessing the elements in the order of where they sort. To do a "fairer" test you could scramble the order of the unordered list. Testing is hard... 
I wrote a similar VM some years ago, with pretty similar syntax. I never wrote another VM in the same language though, that's pretty cool. I also never completed my debugger. The first few Project Euler problems are great for example code, FYI.
This is a smart theory. `cachegrind` may help substantiate it.
Both tests against an ordered list and != against ordered and undordered lists should show where the work is going.
The only difference is je vs jge as you'd expect, so it might be caching as others have said.
You are right. I made function that traverses list and calculates sum of its elements, and it is 10x times slower for ordered version of list. I also tested both versions with cachegrind, and results look strange to me: both versions have about same number of D1 misses, but unordered version makes more LLd misses. And strangest part is that when run with cachegrind ordered version 30% faster (compared to unordered version also run on cachegrind).
&gt; lts look strange to me: both versions have about same number of D1 misses, but unordered version makes more LLd miss Tried both ways, result are consistent. 
This is the only significant difference in the instruction stream: 169b: 3b 45 c4 cmp -0x3c(%rbp),%eax 169e: 74 28 je 16c8 &lt;_search+0xd4&gt; 16c0: 3b 45 c4 cmp -0x3c(%rbp),%eax 16c3: 7d 28 jge 16ed &lt;_search+0xbb&gt; There's comparable opcode latency here, and both instruction pairs are macro-fusible. As a couple of others have correctly speculated, this is cache-related. What you're seeing is a classic locality-of-reference effect. This is consistent with the cachegrind output.
But it looks to me that cachegrind output is not consistent with previously measured times as it shows about same number of misses in both cases (also as I mentioned before programs behave differently when run with cachegrind). 
Doing so might not be as hard as you think but it might result with your code suffering from bugs that are going to be hard to detect. There are programs that might help with it, as checkmarx, and it is also achievable by coding slowly and detecting those on the go. Good luck.
Maybe you do `#include&lt;string.h&gt;` somewhere?
Segfaults are a result of high complexity within the code. Thar are programs that might help with is, as checkmarx, but it is recommended to make sure you try to detect the errors as you code. Good luck!
You probably also need `-ffreestanding` since you're providing your own standard functions.
A few things: - You don't need an explicit `return` at the end of a void function - Not sure I agree with using negative indexes to index backwards from the end of the vector. This is used in languages like python, sure, but I've not seen is emulated in C. - Your `index` method returns 0 if the index is invalid. This hides error cases (accessing outside of the vector) and confounds incorrect usage with correct usage (I got `0`, was my index correct and that is that actual value, or was my index incorrect?). I think this should be an error case, just like accessing an invalid index in a normal C array. - IMO, the `size` attribute should be `length`. When I think "size" I think "size in bytes". When I think "length" I think "amount of elements" - Not every `if` needs an `else`. Lines 21-23 aren't necessary, and 41 doesn't need to be in an `else` - A complete vector implementation needs a way to remove elements and also shrink the amount of space currently allocated. - I don't agree with your `VEC(T,N)` macro implicitly calling the `T##_init` method. This is C, so I, as the programmer, expect that I should explicitly call "constructors" and "destructors". If you do keep this, then the `T##_init(&amp;n)` should be in a `do {T##_init(&amp;n)} while(0)`. See [this stack overflow question](https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for) for why, exactly. - This is in a header, so you'll need to do some more finagling to not run into multiple definitions when using this in multiple files with the same type. Marking all of your functions as `inline` would do it, though my preferred way is to follow the approach that stb does it on his [github](https://github.com/nothings/stb). Basically, you detect a macro like `VECTOR_IMPLEMENTATION` in your header. If it is defined, then you define all of the functions and function bodies. Otherwise, you only define function prototypes. This will make it such that each method is only defined exactly once.
By moving structures between functions and classes you put your code into a danger of high complexity which might the code lead to suffer from bugs and errors that are hard to be detected unless using some programs such as checkmarx. Make sure you do it correctly and you should be OK. Good luck.
Adding to what has been said: * You are not checking if `realloc` succeeds, and then you're using the result like that. * You don't need to move items to the new memory block returned by `realloc`, it does that by itself 
Line 28 is unnecessary - realloc copies the data. Worse, `capacity` isn't updated in this function
My two cents: *You don't need to copy the original array after allocating with realloc *Dynamic arrays are usually implemented such that the resizing of the array is handled implicitly by the API. Since this is C, I suppose having more developer control is good, but your insert function should at least return a status code imo. *A two times growth factor isn't optimal at all (even though it's what C++'s STL vector uses). That being said, I think for what most people use C for, a standardized dynamic array isn't that useful.
I started programming in python, so I have some holdovers from that. Admittedly, I have no plans of using this code, I just did it out of curiosity.
Agreed, I really just did it as an exercise. As for the GF of 2, what would you personally recommend?
You'll find [this](https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Array_resizing/) helpful i think. I have seen the cube root of 2 resizing in the wild, used by Mark Adler in `Puff` [here](https://github.com/madler/zlib/blob/cacf7f1d4e3d44d871b605da3b647f07d718623f/contrib/puff/pufftest.c#L37).
2 isn't the best growth factor because it creates a hole in memory that will never be large enough to reuse in the next rellocation. Theoretically the best possible growth factor would be phi (as in 1.618...) but normally you use 1.5 or another fraction around phi. A more in-depth explanation can be found [here](https://crntaylor.wordpress.com/2011/07/15/optimal-memory-reallocation-and-the-golden-ratio/)
The optimal growth factor very likely depends on how the vector is used in real applications. As with anything relating to speed: measure, measure, measure! Also ... it might not matter as much as you might think. I can't find the article right now, but I remember reading something on how `realloc` is implemented in Linux. Paging and virtual memory (so anything within a page doesn't need to be copied when the vector grows) means that just adding what you need isn't necessarily a bad policy. Or adding capacity in increments of the page size.
Somebody mentioned phi, but I feel like floats are just a general pain to work with.
If you need something general, you could check C++ vector growth factor. I doubt you can do any better for general use cases.
C++ uses 2
C is a beautiful language because of how much control it gives you over the computer. The ability to directly manipulate memory and traverse it is what makes C so awesome, but also so difficult to learn. However, as someone who did programming in Java as well, I think C programming is quite similar to Java in syntax (with the exception of pointers and pre-processors). I think as long as you have patience, you'll get the hang of it.
Thanks :3
An important point missed about your use of realloc is that you're risking undefined behavior. If realloc returns a non-null pointer and that pointer is different than your original pointer, your original pointer is no longer valid and must not be accessed. The way I like to write that is: void *tmp = realloc(data, new_size); if (tmp == null) { // Handle failure } // And immediately overwrite data as the old value is now invalid. data = tmp; This is especially important when writing multi-threaded code as once that original chunk of data is freed, it can be allocated to a call in a different thread.
The growth factor isn't specified. Gcc's libstdc++ uses 2, but that's a poor choice because the allocator will never be able to reuse space from an earlier incarnation.
came back from a few jars at my local and ended up adding a bit more.... // Vec has 4 components so it can be used for quaternions too... typedef struct { double x,y,z,w; } Vec; void* createUniverse(); void destroyUniverse(void* uni); /// muhahahaha void setGravity(void* uni, double x, double y, double z); void* createBoxShape(void* uni, double ex, double ey, double ez); void* createSphereShape(void* u, double re); void* createBody(void* u, void* shape, double mass, double x, double y, double z); void bodyGetPosition(void* body, Vec* pos ); void bodyGetOrientation(void* body, Vec* r); void bodyGetPositionAndOrientation(void* body, Vec* pos, Vec* r); void bodyApplyImpulse(void* body, Vec* i, Vec* p); void bodyGetLinearVelocity(void* body, Vec* v); void bodySetRestitution(void* body, double r); void* bodySetFriction(void* s, double f); double bodyGetFriction(void* s); void* stepWorld(void* u, double dt, int i); void collisionCallback(void* u, void(*callback)(void*, void*, const Vec*, const Vec*, const Vec*) ); 
Sure, it's not bad. But why not go directly to the original authors: http://cs.indstate.edu/~cbasavaraj/cs559/the_c_programming_language_2.pdf (A random PDF version, just did a Google search for "K&amp;R C programming language") It's probably the best reference on the language I've seen. (To be fair, it doesn't cover modern changed C95 and onwards). But that stuff is easy enough to pick up once you've got a good handle on the language.
\*ahem\* In principle, yes, the worst case running time is bad. However, in a case like this, it's highly unlikely to have any issues. We can reason about the *expected* runtime for such algorithms. Namely, choosing N unique elements out of a set of M total would take O(M log(M / (M - N)). For small N (like we have here) this is going to be linear in M on average. 
The best way to learn almost anything with programming is to run the code yourself (preferably in a debugger) and observe the behavior in detail. If you're having issues getting a debugger to work, liberal use of printf() is your friend. For a better understanding, break up the line return (num % 10 + sum(num / 10)); into smaller statments. Save the results of sum(num / 10) and num % 10 into variables, and add some printf statements to trace through the recursion so you can observe the behavior in more detail. For example: printf("Summing digits in %d\n", num); // I've intentionally NOT given these meaningful names so you can work out what they're for yourself. int a = num % 10; int b = sum(num / 10); int result = a + b; printf("Sum of digits in %d is %d\n", num, result); return result; If you want a better visual of the recursion, keep track of the nesting level and add the corresponding number of tabs to the beginning of the printf() statements. 
#pragma once could cause compatibility issues 
I will try. Thank you for your detailed explanation!!!
I would guess that you haven't allocated enough space for the password in your struct.
I'm not sure why that worked, but it did. Thank you!!!!
The authors of Facebook’s C++ library argue that a factor of 2 is the worst choice since it prevents previously allocated blocks from being reused as the vector is growing; they chose a factor of 1.5. https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebook/folly/.../**FBVector.md** (master → cadfe2c)](https://github.com/facebook/folly/blob/cadfe2cdced5c15f1a3e836dba01e931d09d2763/folly/docs/FBVector.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
So your fix helped, but now the program crashes once the fscanf function executes. Do you have any idea why?
The K&amp;R book is the best. Beej's is just too silly which makes it too wordy but, then again, I learned C in 1985.
can't sleep...... really sucky glu thrown together nasty demo https://www.youtube.com/watch?v=Hx6MV7qOOqQ 
Thank you!
KN King's C Programming: A Modern Approach is pretty decent for a newer book. 
That's what I liked though. It's silly, but I managed to surprisingly pick up most of the concepts pretty fast. I was just wondering if that's enough for a solid foundation or not
Beej's isn't bad, but I seem to recall holes in the coverage of the topic. An example that comes to mind is how a malloc memory pool would work. I don't remember anything in beej's that covers that. The K&amp;R book has a section that talks about it and has code. I guess any single source is bound to have holes. So, maybe consider more than just one source? In any case, the fact that you're seeking out knowledge vs. expecting you'll get everything you need in class probably speaks well about your future success as a programmer. Happy coding.
You need to post a minimal complete example.
C strings are null terminated arrays of characters. When you read in your password it filled up the password field and spilled over into the username field of the next record. Then when you read in the next username it overwrote the tail end of the password. Printing a string prints characters from the start of the string until it finds a null character (the terminator). Since the username overwrote the password's null terminator, print will carry on until it finds the terminator at the end of the next username.
Thanks! I'm only doing C because we've got an entire semester of it and I'd like to get it out of the way. I'm hoping to jump into Python ASAP. Anyway, I'll be referring to that book from now
The problem is that the program is not guaranteed in finite time. A program that works 99.9999% of the time is still a broken program. Like putting this in your program: if (!rand()) while (1);
I personally don't think that beej's guide to C is a good primer, though their networking guide is excellent. I prefer C Programming: A Modern Approach to anything else (I've read K&amp;R but it is dated and may get you into bad habits).
The naive solution works 100% of the time. True, it might never terminate, but if that happens, that says a lot more about the pseudorandom number generator than it does your code. It's effectively guaranteed to terminate in a reasonable amount of time. The odds of it running forever are infinitesimal. As another example: in cryptography, large prime numbers are important. Such large primes are often discovered through trial and error, and ultimately, when everything is said and done, we believe the number to be prime with some probability p. Java's implementation for generating large primes is advertised as failing with 1/2^100 probability (i.e. - the number it generates isn't necessarily prime). This is tolerated out in industry. We're here debating over whether the 0 probability that this program runs forever is too high. (once again, assuming that the PRG behind rand is working in a normal way) Sorry if this comes across as rude, but do you fear spontaneously combusting? You've got better odds at that happening to you than for the naive solution to run in quadratic time or worse. Probabilistic algorithms aren't necessarily flawed - they can be incredibly useful and easy to implement. The question is whether we lose anything significant when they experience a worst case scenario, and whether or not we can tolerate the rate at which we expect such a case to occur. Now, if N ~ M, as in the previous example, the naive solution runs in linearithmic time, which, frankly, isn't bad. It could be bad, if this is being doing on large enough input, or it is being run in a tight loop, in which case, the knuth shuffle would work better. Note, however, that that has its drawbacks - that requires O(M) auxillary space, whereas the naive solution uses O(1). Once again, a tradeoff that a programmer has to reason about. For large enough M, the "right" solution might not be feasible. Because if your malloc fails, then your solution *does* only work 99.999% of the time. 
Additionally, I'd recommend looking up tail call optimization. Recursive solutions aren't always appropriate, and can have large space requirements you may not expect. Part of understanding recursion is knowing when to not use it (although, as a general rule of thumb, I'd recommend starting with the easiest implementation first, and then revising if that doesn't satisfy your project's requirements). 
https://www.humblebundle.com/books/be-a-coder-books Referral free link. ***** ^^I'm ^^a ^^bot.
ansi C is portable. modern C is an insulting joke. if you write code in modern C youre masturbating in the wrong language. K&amp;RC second edition is all you need. 
C is the foundation of all computer science. Wanting to just "get it out of the way" tells me you will never be a good programmer.
No referral leaks please.
Considering I'm planning on moving to finance after my undergrad anyway, I'll take that trade
I am constantly surprised about the new things I learn about this, widely considered "simple" and "tiny" language. I've learned about `static` in the variable list, from [here](https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_73/rzarg/static_array_index.htm) and [here](https://stackoverflow.com/questions/3430315/what-is-the-purpose-of-static-keyword-in-array-parameter-of-function-like-char). I've learned recently that you can use `{[x] = 4}` instead of `{.x = 4}` from a comment in [here](https://news.ycombinator.com/item?id=13547797). I've only recently switched to Alpine linux to try out the new C11 threads in musl without using a tinycthread wrapper. I remember times when I was confused that you couldn't alter a string literal even though it wasn't `const`, or when I found out the troubles casting `const void **` to `void **`. Who knows how many gems are still hiding there, that I haven't explored. C is truly a magnificent language.
In all modern operational system, C99 is ubiquitous. Embebbed C89 is de facto and C99 bleeding edge! 
Probably easiest to write the code and experiment with the scoping. Also whoever published that book with code being in a non mono spaced font...
&gt;K&amp;R has a lot of bad practice for nowadays pattern coding! K&amp;R teaches you the language, not the etiquette. &gt;In all modern operational system, C99 is ubiquitous. if you define modern as "most recent garbage", but i dont. to me openbsd on a sparc from 1992 is modern. &gt;Embebbed C89 is de facto and C99 bleeding edge! C99 isnt even a standard yet. let me know when ANSI has an official and complete verified implementation of the C99 standard template library in portable C89. then C99 will run standard on everything. until then everybodys a fucking hipster in my book. 
You, sir, can ya please tell what field do you work to know that much? Sincere question! 
i manufacture network-oriented cyber defense systems and cyber weapons, smoke a lot of hashish, and fuck with terrorists pretty much all day for my personal amusement and for great justice (the flaming fist of baby jesus and all that jazz). let me know if you are curious about infrastructural scalability or alqaeda. 
haha nope, that is enough! thanks! 
oh come on theyre not gonna come kill you just for talking to me on reddit. maybe if you were an arab muslim living in bahrain (where i am legally a terrorist), but youre pretty safe just sitting there in your first world neighborhood. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/downvotedbyretards] ["ansi C is portable. modern C is an insulting joke. if you write code in modern C youre masturbating in the wrong language. "](https://www.reddit.com/r/downvotedbyretards/comments/7mn5yo/ansi_c_is_portable_modern_c_is_an_insulting_joke/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
King's book cover first C89 C code then he talks in a separated section about the newer syntax of C99. So it is a C89 book with C99 fully covered! But thank you to enlight that C89 still standard! I will focus more on it! 
I agree with the other post, you should deffo grab a compiler and play around. In the mean time, to answer the question at hand, I believe you have answers 2, 3, and 4 correct. Answer one: The variable x here is not a declaration of a variable. It's part of a function prototype. In the function itself, you can see the programmer has actually called this variable y. This is valid because variable names in function prototypes are optional. Thus, x is never in scope. I recommend whenever you read an answer like the one I have given, you play arround with everything I have said. Play arround with using different names in prototypes, or no names at all. 
state of the art: learnbchs.org the man is a god. do everything he says every day for the rest of your life. youll be fine. 
I dunno, sometimes I code in C++ I'm no expert but it seems to encourage massive multiple abstraction in an even worse way than Java, often there are little tricks that are denoted by a tiny bit of ascii soup, which can be less than readable, and the bit I loath with a passion, any time I've had some kind of memory corruption in C++ its just been a painful experience... Give me a stable straight forward "boring" old language with out all these new fad features that so many languages just *must* have... I *might* and I mean might just investigate what using C with a garbage collector is like (http://www.hboehm.info/gc/) but I'm not sure that just doesn't encourage laziness ! Enjoy learning C, you might get a horrid shock learning C++ ! heck if I'm honest I probably only use my own comfortable subset of C....
Don't just delete your questions once you get an answer. In this case it doesn't matter much since it's a trivial issue, but for a more involved question it robs the discussion from the community.
It's not awful, but Beej's C guide also contains enough errors that I wouldn't recommend it to anyone. 
It's not *awful*, but Beej's guide to C contains enough errors that I wouldn't recommend it to anyone. I second K&amp;R. 
As for C with GC, you might be interested in the Go programming language.
It's ok...but you should look for a more formal guide or book if you want to learn C fully.
c++ != C
maybe not... I looked but didn't find may wrappers for even quite simple things like OpenGL (that I was happy with) or even major libraries like bullet physics... but then that was a little while ago....
Yeah, it's pretty new, so it's natural that the ecosystem/toolchain is pretty weak for now. I'm just saying it's probably the closest to what "modern C".
I agree about the errors. It has the same problem that many C "tutes" have: a breakdown in technical accuracy once it starts reaching beyond 5-line toy programs. Many of these are language lawyer nitpicks, but many are not, such as Beej's comment that the *printf() "%f" format specifier requires a float argument ("The argument printed this way should be a float"). I consider the default argument promotions pretty important for C understanding, but "tute"-flavored C instruction tends to omit the topic entirely. Here are some other topics that tend to be omitted entirely: * default argument promotions * aliasing rules * integer promotions * usual arithmetic conversions * integer overflow * sequence points Well, sometimes the signedness aspects of the usual arithmetic conversions get covered but only with an erroneous aside about how signed types will always be converted to unsigned types if the two should meet. Given the security repercussions of this, it's not a language lawyer irrelevancy. 
Heh, turns out it's not a bug and the implementation cannot provide both one's complement `int` and `int32_t`. Still quite interesting!
Um, by scope here are you sure they dont mean the different scopes. Namely Block Prototype Program File And Function. Or are you supposed to figure out the lines where they are visible? And the best way to learn this is to fool around by yourself trying out all sorts of stuff with a compiler. Best one imo is gcc cause it's the OG compiler of sorts. So, good luck. Happy Programming!
I think you should be declaring `FROM` and `TO` as `volatile`. Also, why the upper case variable names?
It's pretty unhelpful to delete the question. You have got out of it what you wanted - a solution to your problem - but the community gets no benefit for the help they gave you, because people who come after can't read and benefit from the discussion.
Oh, good point. I guess I am used to the convention of making global variables uppercase.
Why do you think that? In C, volatile has little to do with concurrency.
&gt; The `array[i]` and `[i]array` trick is nice too. You mean `i[array]`?
Your compiler isn't yelling about how you're using TID?
Incorrect: **x** at line 02 has function prototype scope. This terminates at the end of the function declarator (line 02). The three other answers in (a) are correct. (b) is probably correct enough for the sake of this test, but technically speaking, a storage class isn't a foundational concept in the way that linkage and storage duration are. There are storage-class **specifiers**, which are only syntactic elements. **v** has no explicit or implicit storage-class specifier, but it does have implicit external linkage (a *function* declaration without an explicit storage-class specifier *does* have an implicit storage-class specifier of **extern**, but this doesn't say anything about its linkage, which could be either external linkage or internal linkage depending on prior declarations). Likewise, **w** has no explicit or implicit storage-class specifier, but it does have implicit automatic storage duration.
C++ is off topic in this subreddit. Please post C++ content elsewhere, e.g. to /r/cpp.
Nah, I am using CLion, but what is wrong with the way I am using TID? How else can I pass an int?
You keep passing a `void *` to printf with formats that expect `int`s, which is undefined, plus this line: TID = (int)TID; should be spitting out a bunch of warnings if it does actually compile. 
yup, my bad
There are a lot of bugs and mistakes in the C standard. It's impossible in practice to make such a large technical document be error-free. Would be nice if C had a committee that was active in accepting and fixing defect reports. I guess nobody wants to finance such a thing.
I’m not certain but I think it would be valid for the compiler to load the global variables into registers before the while loop and do any operation exclusively in the registers, never writing to the actual address where the variables are stored. And I don’t think OP wants that. Do correct me if I’m wrong, though.
I find proportional fonts makes printed code more comfortable to read, as long as it lines up, e.g. variable names are directly below each other if there are declarations on adjacent lines. It's easier to make it line up in a book than in an editor, but [elastic tabstops](http://nickgravgaard.com/elastic-tabstops/images/columnblocks_coloured.gif) can make proportional (sans-serif) fonts look good even on the screen.
Could you elaborate on this for someone who has very little idea what you're talking about? I started with K&amp;R C, should I be using KN modern C instead? Is there anything wrong with KN?
What're these bad habits? I'm sticking to K&amp;R for now, is there any reason to use KN instead? What about cs50?
It's not so much that your int can't represent INT32_MIN as it is that your unsigned int can't represent INT32_MIN. &gt; Imagine this situation. int32_t is an extended integer type and it's represented in two's complement (as the standard required int32_t to be represented). This means that INT32_MIN is -2147483648 (0x80000000). Correct. &gt; Meanwhile int is a standard integer type and it's represented in one's complement (as the standard allows). This means that INT_MIN is -2147483647. Correct if we assume a 32-bit int with no padding bits. &gt; Now correct me if I'm wrong, but I think both types have the same width Correct. They both have a precision of 31 and a width of 32. &gt; So the rank of int32_t is lower than that of int. Correct. &gt; Now 6.3.1.8 (usual arithmetic conversions) says (emphasis mine): &gt; &lt;...&gt; Otherwise, the integer promotions are performed on both operands. Then the following rules are applied to the promoted operands: If both operands have the same type, then no further conversion is needed. Otherwise, **if both operands have signed integer types** or both have unsigned integer types, **the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank**. Not so fast. We first need to consider the integer promotions. Because the integer conversion rank of int32_t is less than or equal to the rank of int and unsigned int, and because an int can't represent all the values of int32_t, the int32_t would be converted to an unsigned int. &gt; So if understand it correctly, in this code block: &gt; int32_t x = INT32_MIN; &gt; int y = 1; &gt; x + y; // What happens here? &gt;In the expression x + y, x has to be promoted to int, and INT32_MIN is outside of the range of int. Incorrect. As noted above, the expression `x` would be converted to an unsigned int. This in turn would trigger a conversion of `y` to an unsigned int. The behavior of `x + y` would therefore be well-defined. This would all go according to plan were it not for 6.3.1.1#3: "The integer promotions preserve value including sign." An unsigned int would fail to preserve INT32_MIN. Similarly with the stdint.h requirements: a constant expression of type unsigned int can't have the value -2^(N-1). 
c89 is supported on everything (this is a compiler issue). c99 is somewhat well supported. c11 is bleeding edge. you should only learn c89 or ANSI C. anything that requires newer standard template libraries is probably better written in another language anyway. K&amp;R's second edition of their book covers C89. thats the best one to learn the language. if you want to learn to code properly though you will need more books. look for a book called traps and pitfalls in C. that teaches you fucked up stuff about pointers. theres other books on secure C programming. remember that the security guys have the highest standards so thats stuff you should focus on. if you want to read code written by godly figures check out the works of the openbsd guys. they are fucking legendary. look at all the new code written for stuff like relayd, openssh, libressl, vmd, and stuff like that. thats how a real man codes. not insects like you and me. 
Pre-C11, this is a bit hand-wavey, but basically the compiler is not allowed to assume that the global variables aren't modified by pthread_mutex_lock() etc., so they serve as a kind of compiler barrier that forbids that optimization. C11 has a memory model that explicitly supports multiple threading, and so forbids that type of optimization unless the compiler can prove no other threads modify those variables, which it obviously cannot do.
Fair enough, however adding `volatile` does no harm and ensures no weird bugs for compilers in C89/99 mode, so I'd still add it.
&gt; you can use `{[x] = 4}` instead of `{.x = 4}` This does not appear to be true. The first syntax can only be used for arrays, not structs, and x has to be an integer. The second only works for structs 
Yep. The [code mentioned](https://git.suckless.org/st/plain/x.c) in that comment is: static void (*handler[LASTEvent])(XEvent *) = { [KeyPress] = kpress, [ClientMessage] = cmessage, ... which declares an array of functions. The names `KeyPress`, `ClientMessage`, etc. are macros that expand to numbers (which can be seen in the header [X11/X.h](https://www.apt-browse.org/browse/ubuntu/trusty/main/all/x11proto-core-dev/7.0.24-1/file/usr/include/X11/X.h) at line 181). 
&gt; Now to my understanding and it seems that 6.5.2.2 (function calls) does not contradict me, though I might be wrong, the default promotions are: &gt; &gt; char to either int or unsigned (implementation specified) &gt; signed char to int &gt; **unsigned char to unsigned** &gt; short to int &gt; **unsigned short to unsigned** &gt; float to double The default argument promotions are the integer promotions along with float to double (6.5.2.2#6). The key idea you seem to be missing in a couple of your posts is that, for types undergoing the integer promotions, whether the promoted type is int or unsigned int depends on whether int can represent all the values of the original type. If it can, an int promotion occurs; if it can't, an unsigned int promotion occurs (6.3.1.1#2). This has been the rule since the original ANSI C standard and differs from the pre-standard rule that had unsigned types being promoted to unsigned int regardless of what int can represent. The promotions in your list I've placed in bold therefore aren't necessarily correct and depend on what int can represent on a particular machine. In fact, the typical consumer machine is going to promote unsigned char and unsigned short to int. POSIX/SUS guarantees that unsigned char is promoted to int, as a result of the ISO C extension that CHAR_BIT must be 8. The ISO C guarantee that int can represent the values of all signed integer types of smaller conversion rank and that unsigned int can represent the values of all unsigned integer types of smaller conversion rank is 6.2.5#8, which I'll add to my comments in your other thread about int32_t/int because I think it's a more direct demonstration of what's wrong there. &gt; This is all fine and dandy when you know the exact underlying types passed to the va_list (except for char, which AFAIK is impossible to retrieve portably because its signedness is implementation specified). There are problems with a straightforward use of va_arg() in the absence of portability tests. The types int and unsigned int aren't compatible types, so using, say, a va_arg() type of int for a promoted char is undefined behavior *if* the char has been promoted to unsigned int *and if* its value can't be represented in an int (it's not undefined behavior if the value can be represented in an int, given the exceptions for type compatibility offered in 7.16.1.1#2). Personally, I enjoy these kinds of discussions, but I never bother writing code with DSPs or whatever in mind. In fact, I can't remember the last time I wrote something using only the ISO C standard library. The big secret about language lawyers, at least the ones I've known, is that when it comes time to write code, they don't actually bother worrying about language obscurities and instead palm a lot of stuff off as "quality of implementation" issues. &gt; int8_t and int16_t, deducting through logical limit observations, are guaranteed to be promoted or already be of type int. However it's very dubious to rely on my original "logical" limit observations, so I'm seeking your (and the standard's) confirmation on this deduction (I may be missing some corner cases I'm not even aware of). int8_t: This is an easy guaranteed promotion to int. Its exact range is well within the minimum range of an int. int16_t: This is a tougher guaranteed promotion to int. An int is not guaranteed to be able to represent the value -32768, even on a two's-complement machine, where the bit representation may be a trap representation (6.2.6.2#2). However, **(1)** the minimum range of an int guarantees that an int has a width of at least 16 and a precision of at least 15; **(2)** int16_t has an exact width of 16 and an exact precision of 15; **(3)** therefore, by (1) and (2), the rank of int is guaranteed to be greater than the rank of int16_t (6.3.1.1#1), either because (a) its precision is greater, or because (b) its precision (and therefore its width) is the same, with int being a standard integer type and int16_t an extended integer type; **(4)** therefore, by (3), the int16_t range must be a subrange of the int range (6.2.5#8); **(5)** therefore, by (3) and (4), if int16_t exists, it will be promoted to int. &gt; the same holds for uint8_t and uint16_t, except the underlying type is unsigned uint8_t: This is an easy guaranteed promotion to int. Its exact range is well within the minimum range of int. uint16_t: This will be promoted to either int or unsigned int, depending on whether int can represent the values 32768-65535. &gt; int32_t may or may not be promoted to int int32_t: If int has a width of 16-31, the rank of int32_t is greater than the rank of int, and no promotion occurs. If int has a width of 32 or greater, the rank of int32_t is less than the rank of int, and a promotion to int occurs. &gt; Same holds for uint32_t but for unsigned uint32_t: This can result in no promotion, a promotion to int, or a promotion to unsigned int. &gt; In yet other words, how to determine whether I should use va_arg(va, int) or va_arg(va, int32_t) to retrieve int32_t passed to the variadic function without invoking undefined behaviour on any platform? A system with C99 int32_t may not have C11 type-generic expressions. If you just want something that works without _Generic or any preprocessing clutter, cast the int32_t argument to a long, retrieve via va_arg() as a long, and store back into an int32_t. A long bypasses the integer promotions because a long has a greater rank than an int / unsigned int (6.3.1.1#1). The minimum long range covers all int32_t values with the exception of -2147483648. However, if int32_t exists, then long is guaranteed to be able to represent the value -2147483648, for, using a similar argument as above, **(1)** the minimum range of a long guarantees that a long has a width of at least 32 and a precision of at least 31; **(2)** int32_t has an exact width of 32 and an exact precision of 31; **(3)** therefore, by (1) and (2), the rank of long is guaranteed to be greater than the rank of int32_t (6.3.1.1#1), either because (a) its precision is greater, or because (b) its precision (and therefore its width) is the same, with long being a standard integer type and int32_t an extended integer type; **(4)** therefore, by (3), the int32_t range must be a subrange of the long range (6.2.5#8). 
The main bad habit is mot understanding/appreciating the dangers of some of the functions, particularly those involving strings. For example, they show you how to write your own strcpy without any explanation of the risks. You'll also miss out on all the changes made to the language since ANSI C, although frustratingly there is to the best of my knowledge no introductory book which covers C11 (there's C in a Nutshell but that is a reference guide rather than an introduction).
In C it's more conventional to use uppercase names for things set with `#define` or enums, most global variables I've seen are lowercase. Also by your logic TID should be lowercase as it's not a global variable.
watch out while using those external library as they can sometimes make the code a lot more complex, which might lead to errors and bugs among the code. Although there are programs, such as checkmarx that might help with it, I'd recommend you to know exactly what you do. Good luck
&gt; Or are you supposed to figure out the lines where they are visible? It does say "indicate the line numbers" in the question ;)
I feel awfully stupid now. Please forgive me
hahahahahaha
I'd recommend you to control your input flow and make sure you keep the amount of complexity low as it may to errors as these you have. There are programs that detecting those such as checkmarx and others but it's recommended to make sure you code slowly and detect those on the go. Good luck!
Style wise I quite like the [Linux Kernel coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html) As for printfs for debugging, it can be quick and easy but these days I prefer a debugger, like gdb.
What do you mean by tracing?
You know , like there is a code and you have to trace it and write the output. Kinda like exam questions in universities 
 if (n == -1) return -x; // No need to calculate for negative first roots. x^-1 is not -x in general. In fact it's not true for any real number. Also this: if (n == 0) { if (x &lt; 1) return -1; // What? Seriously? Negative x AND n is zero? else return 1; // No need to calculate zero roots. } If `n` is 0 then the result is undefined, not 1, regardless of what `x` is. Because the function computes x^1/n and 1/0 is undefined. It would be better to signal this through `NaN`.
If you want to help a student with easy answers, like - how to return a value, minor mistakes etc. please pm me. I'm in need of some short answers and a mentor to ask, instead of posting post after post waiting hours when I'm studying... would appreaciate it. 
This is why indians have such a bad rep...
*The C Puzzle Book* by Alan R. Feuer contains pretty much nothing more than "What does the following program print?" puzzles.
Google should be your best friend in that regard.
No blog spam please.
Thanks, I will check it out 
This is a wonderful book that I would recommend to anyone looking to boost their C creds
&gt; x^-1 is not -x in general. In fact it's not true for any real number. You're right. x^-y is (1/x)^y . I've fixed it now. &gt; If n is 0 then the result is undefined, not 1, regardless of what x is. I wasn't aware that intentionally returning NaN was even a possibility. But looking it up, [I see that it is](https://stackoverflow.com/questions/1923837/how-to-use-nan-and-inf-in-c). Thanks for letting me know that returning it is even a possibility.
Thanks for the link. I've bookmarked it and printed it to PDF, so I can look at it later. I'll have to look into the GDB debugger when I start attempting more advanced code.
Wrong sub. This is for C. Also when you post it on a more appropriate one, 4 spaces in front of every line to format code for Reddit.
Thanks. My mistake. I assumed that C++ fell under any non-objective C. I'm barely on chapter 5 of my intro book. Thanks anyways.
r/cpp_questions should be helpful.
Here's a sneak peek of /r/cpp_questions using the [top posts](https://np.reddit.com/r/cpp_questions/top/?sort=top&amp;t=year) of the year! \#1: [What are some beginner friendly C++ github projects?](https://np.reddit.com/r/cpp_questions/comments/61cucu/what_are_some_beginner_friendly_c_github_projects/) \#2: [C++ without ever using the letter i in your code?](https://np.reddit.com/r/cpp_questions/comments/5ztsku/c_without_ever_using_the_letter_i_in_your_code/) \#3: [How to (re)learn C++?](https://np.reddit.com/r/cpp_questions/comments/7hgpj3/how_to_relearn_c/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
If you define the struct type memory_data within the function, it will be out scope for the rest of the program; all other functions will have no definition for that struct. I'd start by defining the memory_data struct at a global scope. That way, when you define memData as a memory_data type, the other functions in your program will know what it is. I'm not particularly familiar with the semantics of passing structs between functions in C, but fixing the definition's scope should help. I'd presume that once that issue is fixed, you'd be able to return and use a struct just as easily as any other value type in C. Hope this helps!
PS: Sorry for the code formatting I can't seem to get it the way I want.
You can't use three backticks to format code on reddit. Instead, you need to put four blanks in front of every line of code.
Thanks, I changed it.
 void reverse_string(char* str) { ... str = temp; } Assigning a value to a parameter doesn't have any affects on the caller. Parameters are similar to local variables but get their values from the actual parameters used in the call.
Check when you are terminating your for-loop. Walk through your code manually with a short word like "bird" and see what it does. Your error should pop out at you pretty quick.
To debug this, you should print out every character of "temp" in a loop before reverse_string returns. 
Well I'm not having an actual error. In the first piece of code it seems "innaiG" can only exist in the reverse_string function it's scope, when I actually want it to be shown in the main function it's scope as well as I want to print it there. In the second piece of code it solves that problem. But I get confused with pointers. If we look back at the first example 'str' is already a pointer so why do I need to declare it as a pointer to a pointer and then dereference it, and then let it point to temp to be able to print "innaiG" in the main function.
Looks good now. Thank you for your cooperation.
I also realized you weren't doing it "in place". If blame the initial formatting but really it was just a poor reading on my part.
C is copy by value. So, let's assume you have a pointer P, that is stored in address 0x0A, and points to 0xFB. When you pass this pointer to a function, the value of the pointer (0xFB) is copied to your function variable, say func_P. This new variable will be stored in, say, 0xDE. Notice, that func_P does indeed point to the same place as P, allowing you to perform operation on the address 0xFB. However, when you change where func_P point to, this will not affect P, because they are not the same variable, they just pointed to the same place(initially!).
If you don't want to pass a double pointer to the function, you can do: char * reverse( char * str ); and then, in main: str = reverse(str)
Also, it's not a good practice to do a malloc without a free. The best way to do this operation would be to reverse the string 'in place', without allocating new memory. If you instead need a copy of the string but inverted, the inversion string should not be the one doing the memory allocation.
First of all, let's be specific about your variable `name` that you want to reverse. `name` is a 4- or 8-byte value on the stack that holds the address of a constant string. That address is somewhere in a read-only section of memory. Really it should be declared `const char *`. You could get around this read-only problem by declaring it as `char *name = strdup("Gianni");` which is allocated on the heap, or `char name[] = "Gianni";` which is allocated on the stack (generally speaking, make a copy of the string literal). All parameters in C are pass-by-value. This includes pointers. That means that if you pass in your `char *name`, the function will get a new `char *` that points to the same location. You can change the memory at that location if it is a valid location, but you cannot change what location `name` points to. If you want to be able to reverse a passed-in `char *` rather than return a reversed copy, you have to overwrite the passed-in string with its reversed version. You also have to make sure that the passed-in `char *` is not actually `const char *`. The reason that the second approach works is that you're passing in a copy of a pointer to a pointer. . That constant string is stored in a different section of the executable's memory space. With the original function, you were just passing in the location of the string pointed to by `name`. This time, you're passing in the location of the variable `name` on the stack. The call `reverse_string(&amp;name)` is creating a temporary object with the value `&amp;name` which is the address of `name`, and a copy of that object is provided to `reverse_string`. So `reverse_string` now has the location of your `name` variable and can change it from pointing to a string literal in read-only memory to the newly created reversed string that was just allocated off the heap. The problem with this approach is that before, your string was in read-only memory and didn't need to be free()'d. After being reversed, it is on the heap and needs to eventually be freed. You now have to keep track of whether any given string has been reversed before, because if you do the following you will leak memory: char *str = "I live in read-only memory"; reverse_string(&amp;str); // str now points to a newly-allocated string on the heap reverse_string(&amp;str); // str now points to *another* newly allocated string // on the heap, and we've lost the pointer to the previous // heap-allocated string so we can't free it. A better idea is to provide either a `void reverse_string(char *)` that reverses non-const strings in-place, *or* a `const char * reverse_string(const char *)` that *returns* a new string so you can control when to free the old string if necessary. The second approach requires dynamic memory management so be careful. The first approach requires you to make sure you're working with strings your function owns and can modify. C does not have memory ownership semantics in this sense itself but it is something you should think about.
A simpler, metaphorical explanation of what's happening to your first reverse_string(): Think of pointers as a person literally pointing at a box that has a value in it. If I pass a pointer (person A) to a function, that function has its own person (person B) who is initially pointing at the same box. You can walk up to either person, look at what they're pointing at, and go change what's in that box, but if you ask person B inside the function to point at something else, person A is still pointing at the same box because person A and person B are different people. In the case of your second reverse_string(), your person A is pointing at the box with the string in it, but when you call reverse_string(&amp;name), `&amp;name` means "make a new person who is pointing at person A." Now inside your function, your person B is a new person pointing at person A. So inside the function, you can go up to person B, look where they're pointing, which is person A, and then go up to person A and ask them to point at a different box. You were able to find person A this time because person B was pointing at them instead of the box they were pointing at.
Addendum: Arrays in C *seem* to be pass-by-reference, but what's really happening is that C does not support array-type parameters, only pointer type parameters, so when you pass an array to a function, that array decays to a pointer. this is because the only difference between arrays and pointers is at compile time and associated with the variable, not its value. Thus, int a[] = {1, 2, 3, 4, 5}; sizeof(a); // 5 * sizeof(int) int *p = a; sizeof(p); // sizeof (int *) Both `a` and `p` hold the address of the array at runtime, which is a scalar value, but at *compile time*, `a` also knows its length, which is why `sizeof()` can calculate the size of _array variables_. (_note_: *not* array values).
Thanks for both the simple and the more complex explanation. It's a lot to process but I will take a better look at it and hopefully learn from it :). 
Looks great! Will try it soon.
Hey johnwebdev, I took a look at the code and have some feedback. First of all, your code style is really clean. Which makes it easy to read. Big thumbs up. Some small stuff: I would add a #define GRID_SIZE (81) and replace all your 81s with. It just makes it easier to read even if you'll never expand on different sized sudokus. If you are learning C I would add -Wall --pedantic --Werror -Wextra as well as setting the --std. See: https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html Enable all warnings you can find :) and learn why you get them. Then you can disable them if you have a good reason. Learning the compiler is required to some extent, and it will give you some good hints on what could be wrong. Then I must say that I am a bit confused by some of your functions. Some take pointers to Grid, some take the value and will copy the whole thing. It might be me missing something relevant, but I think all your functions in especially sudoku.h should work on pointers to Grid and Position. As rule of thumb, any struct or larger type should be moved around as a pointer unless there is a very good reason for it. When you do this it's a good idea to learn about const as well. I also suspect some functions could be static / file local, such as position_on_grid. I hope you can appreciate my feedback and make some use out of it. Cheers
I am the author of the software. I can answer any questions about the code or the development process in this thread.
Wow, thank you very much for taking the time to look through it and for offering such detailed feedback! I don't know much about the compiler, so that's something I'll have to look into. Some of the functions in sudoku.h clone the grid because they solve the game, but I don't want the grid input to be changed (is_new_grid_valid). In these cases, even though I'm not modifying the grid, is it still better to have a pointer to the grid as an input? Thanks again!
In general you should always pass structs and arrays as pointers, because otherwise you're making unnecessary copies which can be very slow. When you call `is_new_grid_valid`, you make one copy of the grid, but then you call `clone_grid` which makes two more copies (one when you call the function and another one with `new_blank_grid`). So you make three copies of the grid even though you only need one which you store in `trial_grid`. Use a `const` pointer if you're not going to modify the parameter, e.g. `const Grid* grid`.
Got it, thanks for the explanation!
I've had a lot of use out of GLFW3 rather than SDL for context creation, might be worth a look, I'm wrapping parts of bullet physics at the moment, might be of use to you? feel free to PM me...
Just out of curiosity, why did you prefer GLFW3 to SDL? Anything you wanted to do but couldn't achieve with SDL?
Yes, quite so.
Note that this subreddit is about programming in C, general computer science questions are off topic, consider posting your question to /r/compsci or /r/askprogramming instead.
In addition to what else has been mentioned: * There's a missing &lt;stdlib.h&gt; inclusion for malloc(). * reverse_string() contains a one-byte heap overflow with a NUL write. A one-byte heap overflow with a NUL write has been exploitable on some platforms (such as older Linux/x86 glibc for most allocation lengths satisfying length % 8 == 4), so you have to be careful with this kind of thing. Valgrind should detect the overflow.
In a similar vein I would also #define the keys used, for example #define NEW_GAME (‘n’) for readability on the switch statement. 
Tones of things to learn programming
lot of extra baggage with SDL, GLFW is *specifically* designed working with OpenGL 900+KB vs 120kb makes it a static link candidate about the only thing you're missing is extension loading (I usually use glLoadGen) and some means to load a texture - I have some old version of loadPNG hanging around for this...
The code looks really good, but I have critics on the usability and the makefile: - If I don't provide an argument, I've got a empty grid. (if I provide even a random character, it works...). - there is no --help or -h options, in fact the only documentation is on github. (For advanced options, you could use something similar to "getopt") - The makefile is just wrong. It will recompile everything all the time, and it won't work if there is a file called "output"... Actually, it is equivalent to a bash script + some issues. I would advise that you learn how to create a proper Makefile. - why not support arrow keys?? VIM-like key bindings are cool but it's just stupid not to use key that were made for this purpose. - As a final improvement, you sudoku game should use some colors and box-drawing characters. It also should be centered in the terminal in my opinion. Concerning the code itself, I second everything /u/Xplodeme wrote.
No blog spam please.
I assume `gint` is an normal `int`, so `boolean` would accept any integer. (Probably `0` is false and everything else is true, or so)
Yeah you are correct. I think i get it now. I'm suppose to create a boolean x and send it to the function. It makes sense now. The function is running multiple tests and if one test fails it won't try the next test and print it out. Thanks for the help!
This is well done. Nice work! Here's a list of things I noticed: * It doesn't matter too much in practice, but Makefiles are typically spelled with a capital M. * As was already pointed out, your Makefile is currently nothing more than a gloried shell script. It's not making use of any of make's features to avoid unnecessary recompilation / linking. Here's a suggested alternative: CFLAGS = -std=c99 -Wall -Wextra -O3 LDLIBS = -lncurses obj = c-doku.o helpers.o interface.o sudoku.o testobj = helpers.o sudoku.o tests.o all: c-doku check: tests ./tests c-doku: $(obj) $(CC) $(LDFLAGS) $(CFLAGS) -o $@ $(obj) $(LDLIBS) tests: $(testobj) $(CC) $(LDFLAGS) $(CFLAGS) -o $@ $(testobj) -lcmocka c-doku.o: c-doku.c sudoku.h interface.h helpers.o: helpers.c sudoku.h interface.o: interface.c sudoku.h sudoku.o: sudoku.c helpers.h sudoku.h tests.o: tests.c helpers.h sudoku.h clean: rm -f c-doku c-doku.x $(obj) $(testobj) * Regarding `get_cursor_position()`: int* get_cursor_position(Position* position) { int* cursor = malloc(sizeof(int) * 2); cursor[1] = (position-&gt;x * 2) + 1; cursor[0] = position-&gt;y + 1 + (position-&gt;y / 3); return cursor; } It's conventional for the caller to allocate the two integers in this situation. Generally it would be an automatic (e.g. stack-allocated) array rather than a heap allocation with `malloc()`. Example: int cursor[2]; get_cursor_position(position, cursor); Or even: int x, y; get_cursor_position(position, &amp;x, &amp;y); * Beware that `getenv("HOME")` could possibly return NULL. * In `memset(box.values, 0, 9 * sizeof(int));` note that you could use an expression like `sizeof(box.values)` for the third argument since it's an array. In general you should avoid an expression like `sizeof(int)` and use the name of the thing you're talking about instead. For example, to talk about the size of one value: `sizeof(box.value[0])`. That way you're not repeating yourself, so should you change the type in the future your code won't risk being broken. 
I have already tried to implement most of these points, thank you very much for taking the time to write them. 
Amazing, thank you very much for this. I was a bit lost on what to do with my Makefile. Are they any resources you would recommend for learning more about them? I'll get to work on implementing the other points now!
I've written a tutorial myself: [A Tutorial on Portable Makefiles](http://nullprogram.com/blog/2017/08/20/). Once you've got a handle on things, [the specification](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html) makes for a good reference.
Maybe I don't understand but wouldn't you need to do some inline assembly here to do a valid hardware specific test?
Thanks for your Link. Actually the stackoverflow post says (2nd answer): "I strongly suggest using compiler intrinsics instead of direct assembly." http://www.agner.org/optimize/vectorclass.pdf
*sigh* The C programming language is, by definition, hardware agnostic. You want a specific hardware type test. However you are in the C Programming sub. One of us is confused and it may very well be me but there is no way you will get what you want without looking at assembly.
Okay, it can very well be me too! 
You're creating a type called gboolean from gint. Whoever did that is an idiot tho, and you should just use _Bool/bool directly.
Okay, good to know. 
Isn't C API supposed to be (done) in Bullet 3?
Thanks. This was one of my goals with making this file format - something simple, transparent, and easy to write a parser for like .OBJ but also supporting skeletal animation and potentially anything else my engine may need in the future. I haven't managed to find any other formats like that. The closest would probably MD5Mesh and MD5Anim but this format has it's own quirks such as specifying the joint weights as a separate list. Everything else seems to come with a lot of baggage and is pretty daunting when you're first starting out learning about skeletal animation. I realized I have an error in the documentation though - I don't mention that for non-root joints, the bind transformations and keyframe transformations are relative to the parent joint. So you need to "walk up" the joint heirarchy, multiplying by the transformations of the parent joint until you hit the root joint. Only then you will have the final joint position in object space. I will update this when I have the chance.
&gt; AddressSanitizer (or ASan) is an open source programming tool by Google that detects memory corruption bugs such as buffer overflows or accesses to a dangling pointer (use-after-free). AddressSanitizer is based on compiler instrumentation and directly-mapped shadow memory. AddressSanitizer is currently implemented in Clang (starting from version 3.1[1]) and GCC (starting from version 4.8[2]). On average, the instrumentation increases processing time by about 73% and memory usage by 340%.[3] https://en.wikipedia.org/wiki/AddressSanitizer
How does it compare to the valgrind suite of tools?
https://en.wikipedia.org/wiki/Bitwise_operation Not trying to be snarky here, but the Wikipedia page presents a lot of useful information on the subject. There's not really much to it though. You just have two operands, some predefined logic is applied to it and there is an outcome.
There isn't much to learn. Write down the truth table of the operation you need and then see how to make it out off and, or, not, and xor. That's all there is to it.
&gt; Where do I learn to send emails and sockets and other things like that? [This one](v) is a good start. Sending emails is hard, let the `sendmail` command do this for you.
the idea is super simple what i ask is when and why to use it. For example the other day i was implementing a socks5 proxy server in go i had issues splitting the port number in big endian i simply stringified int hex first then split but i saw one guy used some bitwise magic to achieve the same result it was a true sorcery. This is what i am talking about
the idea is super simple what i ask is when and why to use it. For example the other day i was implementing a socks5 proxy server in go i had issues splitting the port number in big endian i simply stringified int hex first then split but i saw one guy used some bitwise magic to achieve the same result it was a true sorcery. This is what i am talking about
The other comment quotes Wikipedia saying it less than doubles processing time so i guess it’s faster than valgrind 
you use bitwise operations when you need to access bits... tbh I'm not sure how this is confusing you.
I've never used valgrind, but it is quite useful. It can tell you what line you messed up on, including buffer overflows, memory leaks, etc.
check out some libraries you think are cool and look up tutorials on them. also if youre on linux try to understand the rest of the toolchain like make and gcc. this will help a lot when developing "real" stuff.
i'm aware of htons and similar functions still my question is all about the idea of bitwise operations not network byte order my method worked too but in comparison to the way using bitwise stuff, mine, i believe, is extremely slow and there are lots of unnecessary steps 
Yap I love it... Got a tip about it a few months ago and it's been really helpful cleaning up tricky bits of code. However, it's important to remember to disable it and recompile before testing with valgrind or other tools... (together it's a bit of a mess).
Well, as /u/FUZxxl said, write it out. Write out what you have and what you want. Bit by bit. Look at it. Look at the differences. Look at the similarities. Which bits do you need to change. How can you do that? Also write out the other guys solution for the socket thing bit by bit and Look at it. It’s all about practice and just getting used to the way of thinking. 
W. Richard Stevens' Unix Network Programming is the bible for socket programming.
I much prefer using ASAN and UBSAN to valgrind.
Um I didn't say anything about those functions in fact they're pretty much useless. Write your own, that's what I did, they were literally the very first functions I ever wrote while learning how to program. Masking and shifting ARE bitwise operations, the fact that you're doing them in groups of 8 for byte swapping doesn't change that fact. 
&gt; One of the pluses about doing code instrumentation is that it can run much easier on embedded platforms since it doesn't require an entire external program, and is supported (in theory) by any architecture that the compiler supports. We use address sanitizer and undefined behavior sanitizer at work on an armv8 target with 2MB ROM / RAM space. Using valgrind is impossible in our use case. It depends a lot on your use case, but for example for safety related stuff, I would not use something that instrumentates the code under test. I just had a quick try and looked at the assembly, and the code is heavily modified by `-fsanitize=address`. Of course, if it is just one extra help and not something on which you blindly rely, that's not a problem either. Is it too cumbersome to run the code and Valgrind in a simulator/emulator/virtual machine with larger memory?
Cool... you could use curses to have it update every few seconds sort of like the `top` program
https://graphics.stanford.edu/~seander/bithacks.html
Exactly
Looks like you should break the loop when either string has a zero char (null terminator). Otherwise the loop will just cycle until it hits unequal bytes. You've been lucky not to get crashes from invalid memory accesses.
The Hackers Delight books are also a good resource for this sort of thing
Seconded. For the kind of use case that OP is asking for, this book (though I personally did not like its presentation) would be ideal to get a headstart.
Valgrind triggers if your program takes action on a data whose value is indeterminate. For example, if you read an uninitialised value and then branch on its value, or send it to an output file. This is a very powerful idea, but I believe it's usefulness is limited by cases where it can't tell whether a value is indeterminate (e.g. reading from off the bottom of the stack in an area used by a previous function call, perhaps, I'm not sure). Thus, it does overlapping but on the whole different things to asan.
Ah thanks for the suggestion and I have added the usd now as default. It was because of the way the api treated the currencies.
Are you talking about splitting say; a 4 byte variable into 4 single byte variables?
https://www.udemy.com/c-and-c-programming/?couponCode=FREE1111
I would not trust ANY C and C++ book/course... There is almost NO similarity between them and a ton to learn.... Improbable any course/book can cover that much in quality
This video is about how if statement concept is used in c programming language or c++ programming language.
Content in languages other than English is off topic in this subreddit. Also, please don't post this sort of video.
This is complete nonsense. Modern allocators don't work like that. There are good reasons to use φ instead of 2, but they have more to do with the fill ratio than with heap fragmentation.
In practice, AddressSanitizer (asan) slows your program down by a factor 2–3; valgrind often by a factor of &gt;10. If you need to wait for minutes until a bug shows up, asan will make your life much easier. In addition, asan checks both stack and heap overflow. Valgrind only checks heap overflow if I am right. That said, asan may miss some events. It is still good to run valgrind even when asan gives you a clean bill.
Ummm why are you doing that? Let ntohs and the likes handle it, it creates portable code.
yes it does but i want to learn how the basics go 
A great tutorial, thanks! It has definitely helped me understand makefiles better. 
`b[0],b[1] = i &gt;&gt; 8, i &amp; 255` and `i = b[0]&lt;&lt;8 + b[1]` b[0] and b[1] are the bytes of the number and i is from that converted back 
This is a simple bit shift. &gt; i &gt;&gt; 8 It shifts all the bits of `i` to the right by 8. The low byte is discarded and the high byte is shifted down to the position of the low byte. The end result is to extract the high byte. This is a simple bitwise AND: &gt; i &amp; 255 It's ignoring the high byte and selecting only the low byte (those bits that match the binary 11111111 pattern of 255) When combined, they extract the high and low bytes into `b[0]` and `b[1]` respectively. &gt; b[0],b[1] = i &gt;&gt; 8, i &amp; 255 The second examplen is used to recombine two bytes into a high/low byte pair. &gt; i = b[0]&lt;&lt;8 + b[1] We take `b[0]` and shift it right by 8 bits to move it into the high byte, then add on the low byte in `b[1]`
This is just simple byte masking out of a 16-bit word. It helps to draw a picture of a 16-bit word, with a letter repreresenting every bit. Use the same letter for each block of bits that go together. In this case, you have two 8-bit values in a 16-bit word. So: i = HHHHHHHHLLLLLLLL The magic number 255 is the mask. In binary, 255 is: 255 = 0000000011111111 Note that the 1s line up exactly with the L bits in your word. Using the &amp; operator will remove the bits that are 0, and keep the bits that are 1. i &amp; 255 = 00000000LLLLLLLL This isolates the L bits from the original word. The shift operator &gt;&gt; shifts all the bits to the right by 8 bits, discarding the left-most bits that get shifted out. i &gt;&gt; 8 = 00000000HHHHHHHH This isolates the H bits from the original word. Tip: be careful about your variable declarations when right shifting. On some architectures, a signed i when right shifting may be an arithmetic shift, which won't work like you want it here. It's usually best to declare your variables unsigned when bit twiddling. I'll leave the second statement as an exercise for you to figure out.
When shifting left, arithmetic and logical shifts are equivalent, so that's not an issue. So I'll only talk about right shift. For unsigned numbers, right shifts in C are an arithmetic shift. For signed numbers, the result is implementation-defined. C doesn't say what the result is, but your compiler vendor will tell you. An arithmetic shift is a very common choice.
To better understand your question; what is it you're trying to do with a bitshift?
everthing, I just ask out of curiosity.
so for example gcc would use arithmetic right shift on signed integers? If true, then this helps me clarify those concepts in my mind. 
The rules for the bitwise shift operators are based on division and multiplication, not the notion of arithmetic vs. logic. From a public ANSI C draft: &gt; The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has an unsigned type, the value of the result is E1 multiplied by the quantity, 2 raised to the power E2, reduced modulo ULONG_MAX+1 if E1 has type unsigned long, UINT_MAX+1 otherwise. (The constants ULONG_MAX and UINT_MAX are defined in the header &lt;limits.h&gt; .) &gt; The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 divided by the quantity, 2 raised to the power E2 . If E1 has a signed type and a negative value, the resulting value is implementation-defined. In any case where arithmetic vs. logical shift would make a difference, the results are implementation-defined, so it doesn't make sense to categorize the bitwise shift operators in C as arithmetic or logical.
Yes it is meant to be sign preserving. Edited Post.
thanks for the detailed answer. I was just curious because in IA32 assembler there are two different shifts and I thought wrongly, that C would decide for one, instead it seems C keeps itself more independent from one particular architecture at the cost of some easy code portability in some cases. Another thing to keep in mind.
You could do `#if (-1 &gt;&gt; 1 != -1)` since the preprocessor does know about shifts
I don't know a finished Programm that does this, but if you are __brave__ you can write one yourself: The C Vector Extensions (and Vector Types) in gcc: https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html The functions you can use on those types: https://gcc.gnu.org/onlinedocs/gcc-4.5.3/gcc/X86-Built_002din-Functions.html#X86-Built_002din-Functions (scroll half way through until you reach: "The following built-in functions are available when -mavx is used. All of them generate the machine instruction that is part of the name.") I never did this so I don't know how this exacly works. __Edit:__ I got some Code, look at this Video https://www.youtube.com/watch?v=Pc8DfEyAxzg he made his source Code public. It is written in C++.
Well, it's theoretically possible that the implementation defines the result to always be -1. But this is probably safe in the real world.
You will want to take a look at your c complier for the answer.
I haven't read the whole project, but is there a reason you aren't storing the board state as a character array? &amp;nbsp; It would require some significant refactoring, but I think you would do best to initialize the board as `char board[9] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };`. Then as moves are made you can change individual slots of the array with `'X'` and `'O'`. &amp;nbsp; If that's not possible, then you'll have to change `gridChar()` to accept an integer value as well as the index within the array. From there, you can change `case 0:` to return the character equivalent of the given index.
I haven't had a lot of luck finding too many http server resources in C. My favorite is the [Rosetta Code C example](https://rosettacode.org/wiki/Hello_world/Web_server#C), which might give you somewhere to get started for a basic server. I find that there are a lot more resources for networking if you search for "TCP/IP" with C. Of which you can find this [Introduction to Socket Programming](http://r.duckduckgo.com/l/?kh=-1&amp;uddg=http%3A%2F%2Fwww.csd.uoc.gr%2F~hy556%2Fmaterial%2Ftutorials%2Fcs556-3rd-tutorial.pdf), or [TCP/IP Sockets in C a practical guide for Programmers](http://r.duckduckgo.com/l/?kh=-1&amp;uddg=http%3A%2F%2Fcs.ecs.baylor.edu%2F~donahoo%2Fpractical%2FCSockets%2FPracticalSocketC.pdf). There's also the [Beej guide to Networking](https://beej.us/guide/bgnet/). A little bit of a tangent, but bluetooth uses a lot of the same concepts, so you can also find [short example programs like this](https://people.csail.mit.edu/albert/bluez-intro/c404.html) for sending messages over bluetooth.
Hi! There used to be a place called Stack Overflow Documentation which had C snippets, however Stack Overflow Documentation was shut down, so being CC-BY-SA content I downloaded the content and produced this C programming notes PDF to share I think you may find the PDF useful, I discover new things when reading through, if there are any negative (or positive :)) issues with the book please let me know, this C programming notes book is a book I want to improve
Thank you! That's great.
Fantastic, even if the site was still online having everything in one PDF is great for searching, offline reading etc. Thanks for putting this together.
&gt; I was afraid that was the case. Thank you for your assistance Newt! 
Thank you so much for your detailed explanation! Here's what I did: if(string1[i]=='\0' &amp;&amp; string2[i]=='\0') break;
I did this: if(string1[i]=='\0' &amp;&amp; string2[i]=='\0') break; and am now trying to figure out how not to make "hello" equal to "hello world"...
1. void fn(void) { int iExitFlag = 0; //Can use a bool if your compiler supports it. while(0 == iExitFlag) { //set iExitFlag to 1 when ever you want to exit } }
2. Would take a while to give you an example here so I'll send you a tutorial instead: https://www.tutorialspoint.com/cprogramming/c_file_io.htm In this example it's just writing a string to a file, but it's not so difficult to modify that code to work for a struct.
3. Not sure what you're asking, do you want like an array of structure elements you want to search through? 
**1** I don't quite understand what you're getting at. What do you mean by *return to main*? If you you're in a function and you want to return to the caller function, just use a *return* statement. **2** For example: &amp;nbsp; /* txt looks like this: 1 2 almafa 3 4 barackfa 5 6 citromfa */ struct str { int a, int b; char c[256]; }; struct str array[1000]; int main(void) { /* fopen() and the likes */ while (i &lt; 1000 &amp;&amp; fscanf(file, " %d %d %255s", &amp;array[i].a, &amp;array[i].b, array[i].c) == 3) { i++; } /* fclose() and its friends */ return 0; } &amp;nbsp; **3** It is not crystal clear to me what you mean by *search in a struct*. Do you want to find a struct in an array that has a *special* property (like its member named *a* is exactly 42)? If so, then use a simple loop to iterate over the entire array and check the values of the *a* members. **4** For example: &amp;nbsp; int main(void) { int chosen, run = 1; scanf(" %d", &amp;chosen); while(run) { print_menu(); do { printf("choose: "); } while (scanf(" %d", &amp;chosen) != 1); switch(chosen) { case 0: run = 0; break; /* similarly... */ default: printf("I don't know how to do that...\n"); break; /* the default case will run if the value of 'chosen' does not correspond to any value listed in the other 'case's */ } }
4) this is pretty easy. Print out your menu, have a getchar or a scanf or whatever to read your keyboard input and then use a switch statement to select what you want to do from the user input.
Congratulations on making your first project in C programming language. You have made a smart move by publishing it on Github and developers all over the world can get to see your code and offer recommendations as to how you can get to improve your application. You will definitely improve your coding skills by a huge margin at this pace. Concerning your code and the working of your application; I recommend you for the good work you have done. The application works well and the style with which you have written the code is really good. Your code is clean and has been neatly written. However, I would suggest that you create a warning module to prompt a user to only make only valid entries. You can make the warnings to work at the beginning of the game and be hidden when you feel a user has known the rules of the game. In conclusion, if you wish to improve your knowledge in C language or in any other programming language, you may wish to go to a good programming school like Holberton School (https://www.holbertonschool.com/) and learn the fundamentals of Software Development. You will get credibility on graduation and the IT industry will be in your hands thereafter. 
Java and C have a few differences. If you already have some knowledge of Java programming you will find it easy as they have a lot in common. Here are just a few of them that you may wish to note; 1. The commenting system is the same for Java and C programming language 2. In relational and arithmetic operators, there is no significant difference. 3. Control constructs: The major Java and C++ control constructs are essentially identical. The differences appear for newer variations such as Java's "for each" construct that will be mentioned in the section on Arrays. 4. Primitive Types: The Java and C++ primitive types are nearly identical 5. Execution of a C++ or Java program is just the same in that the runtime system will look for an appropriate entry point named main and initiate execution of your program by causing control to start at the first statement of the identified main function. Setting up GCC to compile on Mac Os High Sierra is not that difficult either. Just look up online on how you can go about that. If you wish to study more on Software Engineering you can enroll in Holberton Programming School (https://www.holbertonschool.com/) and learn all the concepts related to Software Engineering. Good luck. 
Sweet, very useful. Thanks for your efforts!
1. kérdést ugy értettem hogy vizsgálok egy beirt számot és ha a szám formátuma megfelelő akkor a TRUE-n megy át és fut tovább a program, viszont ha a FALSE ágon fut le akkor dobjon vissza és irja ki hogy nem jol értam be és kérje újra. 
(Valószínűleg nem fognak örülni, hogy nem angolul megy a csevegés, de sebaj.) A szám beolvasásánál már a scanf is meg tudja mondani, hogy jó-e a beolvasott szám; a visszatérési értéke mindig annyi, ahány darabot tudott beolvasni azokból, amely dolgok formátumsztringben szerepelnek. scanf ("%d", &amp;i): /* visszatérési értéke=1 ha sikeresen beolvasott egy számot; ezt tudod ellenőrizni az if-ben */ A ketteshez meg azt tudom mondani, hogy ha kiirattál valamit, akkor az biztos megvan a memóriában, mondjuk egy tömbben, ami struktúrákat tartalmaz. Abba akkor még tudsz pakolni adatot. A kereséshez meg mész végig a tömbön egy ciklussal és benne egy if-fel nézed, hogy megfelel-e a keresési kritériumnak. A fájlkezeléshez pedig már megírtam, hogy hogyan olvashatsz be, a kiiratás annyiban különbözik, hogy az *fprintf()* függvény használd.
I'm so glad to have been of help (: you should use an OR instead of an AND though because the two strings could be of different lengths
köszönöm! :) 
Wow thanks, that would be the highest honor! :D
Thanks :D
former adjunct lecturer here. i will try my best to upload everything by the end of this month. you can 'Star' the repo to bookmark it. happy coding!
There is no language called C/C++. What language of these two is actually your favourite language?
Note that you can portably retrieve a regular expression indicating if a string matches “yes” or “no” in the current locale using `nl_langinfo(YESEXPR)` and `nl_langinfo(NOEXPR)`. You should use this if your program is intended to be used by people who speak languages other than English. It's also a nice exercise in using the POSIX interface. You can find some example code that uses this interface to check if a string is “yes” or “no” in [this gist](https://gist.github.com/fuzxxl/e4177a30ba6b047e749dd08288d177c1).
&gt; for (;;) might be a bit cryptic at first glance for the unexperienced reader `for (;;)` is actually the recommended idiom as it doesn't have a magic number and generates better code when compiling without optimizations.
This is amazing thank you! 
Huh, that sounds interesting. Never thought about i18n, but if I did implement that, `yn` might become a pretty cool project. I'll definitely look into it, thanks!
&gt;I realized I needed to learn about architecture , allocation , addressing , bit-shifting, heap, stack, buffer overflows ? Etc. Try the book *Computer Systems: A Programmer's Perspective*. Otherwise, you'll have to be a lot more specific about what you want. Bit shifting in C, for instance, can bite someone in the ass who's familiar with only the language-agnostic general idea of bit shifting, because there are obscure representation issues, counterintuitive promotions, undefined behaviors, etc. Learning about buffer overflows can take 10 seconds or 10 months depending on precisely what it is you mean by learning about them. The general idea is available in 10 seconds. Defensive skills take longer but can be learned entirely within the realm of C (contrary to common developer opinion, it's not simply a matter of knowing about strncpy, snprintf, and whatnot). Offensive skills require specialist knowledge outside of C that can take months to acquire. 
Wow! That's a lot to digest, thanks for taking the time to reply. I'll probably be commenting on this periodically. Firstly, regarding some standards choices and the `Makefile`, I wanted to design those as a personal reference for a generic C project - I realize I have been a little broad but that is intentional. The only project-specific choice I made was using `tcc` which resulted in a binary half the size than `gcc -Os` - would definitely not use it for medium+ size projects, and you can always just edit `config.mk` or pass `CC='gcc'` to `make install`. I made sure to note that in the project README. About `^D`, `--help` and some other bits, I'll be developing `yn` over the next few days and plan on adding stuff like that :)
Oh yeah, I was also having trouble with the `\n` thing. Check out this [past commit](https://github.com/JoshuaRLi/yn/blob/bbb6d9eeb32815ee0ed014fcc7b45f8140908569/yn.c), where I threw away all stream characters with `getchar` up to and including `\n`. This allows for the prompt to repeat only once with arbitrary length input, which is ideal, but the problem is that you'd have to hit RETURN twice to get a new prompt if you submitted &lt;= BUFSIZE number of chars. I gave up and just `fgets` with a reasonably sized input buffer. Any tips on how to fix that? I was struggling with it for a while.
Started udemy a little while back myself and am learning C++. My advice is always remember that udemy courses are almost always on sale so don't ever buy them at full price. Wait 'till the next sale. Overall material wise, for the 10$ I paid for the C++ course, I'd say it's been teaching me decently so far. 
Can you explain what socket programming is? I read online but I don't understand. It would be much appreciated :) Thanks
You could use `getline()`. I also recommend you to configure `stdin` to be unbuffered in your application so it works more nicely with scripts.
What you really need to get your first job is your own work that you can demonstrate. The easiest way to build this portfolio is through formal training (In the UK this would be collage courses, university or apprenticeships). It's not impossible to be self taught and get yourself a job but it will be a lot harder to get your foot in the door and even get an interview.
looks great! any chance for lecture notes and hw assignments?
I'm in the UK, currently doing my A-Levels. I didn't do that well in my GCSE's - got mostly C's and the odd B. My school doesn't teach A-Level ICT or Computing, so I had to settle with BTEC ICT SINGLE. I also take Geography and Politics. I tool ICT at GCSE and got a B. I'm thinking of doing an apprenticeship once I finish with 6th form but that's a couple years away from now. So what kind of work can I currently do? Other than learning these different languages.
I think building a website in .NET core and angular5 should be enough for any junior dev job, and you'll learn enough to be able to move to other technologies. In my opinion skip PHP and VB. I shudder just thinking about legacy crap I have to deal with because I know those two. Even if you know them, lie!
So having proof of some sites I've built and putting them in my portfolio would increase my chances of getting my first job?
Mainly focus on your A levels. Getting good A level results will give you the best opportunities after school. Apprenticeships are few and far between so companies that run them can afford to be picky. Rather than learning different languages just start with C#. you can do a lot with it and it will give you a good basis for OO.
A lot. Especially since with .NET core/C# you prove you can use a high level language and a framework that's becoming a standard for new development and you can relatively easily transition to java. There are a lot of other things tied up with a .NET core backend, like IoT, ORM, etc... And with angular5 you prove you know html/css/scss/js/ts. In addition, python is currently sought after a lot.
I don't see how your question is related to the C programming language. While this is a very interesting topic to discuss, it is sadly off topic in this subreddit. Please ask elsewhere.
You can write backend code in C if you really want to...
Hello, Your solution is here with requested changes [C Tic Tac Toe Game Project With Source Code](http://www.programmingwithbasics.com/2016/03/c-program-for-tic-tac-toe-game-project.html)
You sad pedant. The kid just wants advice in how to persue a career in programming. How is that off topic in a C programming subreddit?
I went through a stage where I used to collect Udemy courses, buying them through StackSocial. They often do "Pay what you want" sales. Right now it's a "White Hacker Bundle". When I got round to trying the courses I found a fair few of them weren't the greatest of quality. I kinda got the vibe it was a "guy in his bedroom" scenario. I believe they're currently selling any course for $10 with the right coupon (Possibly 18NEWYEAR111) so make sure you're not paying hundreds. It's not worthwhile. Final thing, I'd personally have recommended CS50 - Harvard University's Computer Science course is free through edx.org and has taught me so much from the basics to pointers, data structures, etc. I'm still going through it at my own very slow pace!
My job is enforcing the rules and the topic. Just because he wants to pursue a career in programming doesn't mean he gets to ignore the topic. Plus there are a bunch of other subreddits where this is on topic, so why not post there instead?
He isn't ignoring the topic. The subreddits topic is programming. He's asking about programming.
No I understand why you did it. That's why I called you a pedant. I just don't agree with your actions. The kid has no experience; for all he knew the first response to his question could have been "C is a perfect language for what you want to do, here's how you do it..." Instead of trimming everything that doesn't specify c programming why don't you work on making this subreddit a more inviting place to be??
Why should I care about a newcomer who is not even directly interested in C and probably won't be a future contributor to this subreddit? On the other hand, I do care very much about people who are interested in C and don't care about posts like this one as these are the people who keep this subreddit alive and filled with content. I don't think it is justified to keep off topic posts up just because they come with an inspirational or sob story attached. This just annoys people who come here for the technical content and C programming questions, which is the main topic of this subreddit. If you want to discuss high school student's future aspirations or help them pick a laptop, you should subscribe /r/computerscience as that's apparently their main sort of content.
What sob story? Just asking for some advice is all I was doing my man.
In your post, there is no sob story (that's why I wrote “inspirational or sob story”) and I do in fact find your question very interesting. It is just that this is not the right subreddit for this post, so please post somewhere else. This is because this subreddit is specifically about the C programming language but your question is about programming in general, which is not on topic.
Fair enough, my apologise.
As a C student I must Thank You for this! 😀
It is C unless OOP is required
Thanks WilFenrir! :D
Thanks ooqq! I am sure you are a C A++ student! :D
I don't know what's a generator, but callbacks are nothing more than function pointers: there's nothing advanced about them. &gt; Any recommendations on books or tutorials? Cormen et al. of course.
C Interfaces and Implementations by David R. Hanson
A generator is simply a function that can be used as an iterator: int even_numbers() { static int i = 0; i += 2; return i; }
Firecode.io is a great start to have some hands on practice. Always try to find the most efficient solution to a problem. I usually find them on geeksforgeeks.org or the mycodeschool youtube channel but the latter isn't really advanced. I heard leetcode.com and codefights are advanced but I've never used them and would start with firecode.io anyways.
Yeah I got mine for around ~4$ and so far the guy is really good and explains stuff to the max and he's very funny
Why would you want to do that?
They're like streams as has been said above. They're lightweight, built into the language in many cases (Python, PHP, Go and I think Node too in its latest releases) so they're convenient. They allow you to consume data lazily, so you don't need to load everything in memory at once, or don't need to generate a set of data in one go but rather on a per-instance basis as more elements from the set are actually consumed.
Could you reorganize the presentation so the two files are side-by-side?
Wouldn't it help if the files presented were actually C? "Main", strcpy to a const string, variables starting with double underscores, comparison functions to qsort that subtract signed integers which can lead to undefined behavior and also makes the compares non-transitive which is bad. And most of the "code" seems to be generated by someone who has seen C on a post card once. Only the code with the Google copyrights was correct and in that case it's impossible to tell because it actually followed a proper code style so it could have been written by anyone.
Best practices aside it is what it is. I suspect its homework cheat/plagiarize detection thus the sloppy styles
Sorry, many of the code samples were written by students, and some were tampered with by a machine. That's part of the study ;) 
Hmm sorry, I'll see if I can find the issue with Firefox. (I've been primarily using Chrome) By C/C++ experience, I meant C OR C++ experience. If it's ambiguous, I can reword it! Update: It works for me on Firefox, and it looks like Qualtrics surveys should work on most browsers. Sorry, I'm not sure why it's not loading for you. 
Thanks for the feedback--I can try! I'm hesitant to change too much at this point since it's "live", but I'll try experimenting on a different copy and changing this copy if I get it figured out (meanwhile, if anyone has any javascript experience... :P )
For verifying the correct key, one idea might be to - at encryption time - stick a known-good checksum at the end/beginning of the file. On decryption, if you can't read your checksum back, the key is bad or file corrupt. Then just remove the checksum before outputting the decrypted file. Note known-plaintext attacks; so make sure you're doing your enc in a way that isn't vulnerable to this. 
Hey, that’s a pretty good idea! You’re saying to check if the checksum contains all readable characters, right? If the key was wrong, the checksum would definitely appear all wonky due to the presence of non-readable characters. Is that what you’re saying, or do I have you completely wrong haha
Basically that. It doesn't need to be all readable characters. Something as simple as a chosen constant would work. Like, append deadbeef to the end of the plaintext file, then encrypt. On decrypt, after file is decrypted, check that deadbeef is at end of file. If the end is anything but deadbeef, either someone has messed with the encrypted file, it's corrupt, or the key was wrong. 
The first rule of cryptography is don't roll your own. It's harder to get right than you think, even when you take into account the fact that it's harder to get right than you think.
Everything wrong with one function: char * generate_dec_path(const char *path) { char *dec_path = malloc(strlen(path) + 1); strcpy(dec_path, path); strcat(dec_path, ".dec"); return dec_path; } - Buffer overflow - No error handling - In the first line you compute the length, but don't reuse it in the following lines. - Basically a reimplementation of `asprintf(3)` char * generate_dec_path(const char *path) { char *dec_path; int check = asprintf(&amp;dec_patch, "%s.dec", path); return check &lt; 0 ? NULL : dec_path; }
All I see is badly laid out code in every case. 
The ones with `Main()` are schoolwork—the parts that are correctly indented were provided by the instructor and the parts that aren't were filled in by the students. Whoever grades these probably has a wrapper or driver that calls `Main()` after some preparation, which probably includes redirecting `stdout`.
Just copy the code into something like notepad++. that lets you split the screen to show two files side by side.
Two quick things I'm seeing: First SHA256, while a good hash function, is too fast to be used for deriving keys. Use a Key Derivation Function to transform your password into an encryption key. bcrypt, scrypt, argon2, PBKDF2, etc should all work. Secondly, you don't perform any authentication of message integrity on the files before decryption. If an attacker was to flip any bits in the ciphertext, those bits would be flipped in the resulting plaintext, which is not good. You need to add something like an HMAC to the encrypted file blob. Make sure to encrypt-then-mac when generating the HMAC to prevent any potential issues. Validate the HMAC before decrypting the file. If validation fails, the file is either corrupt or being tampered with. Crypto is hard, even for experts, keep that in mind. There's a reason people shouldn't roll their own for anything worth using. Other issues regarding buffer overflows and a lack of memory safety have already been mentioned.
TL;DR: OP's first published program is crypto, what could go wrong?
Sure, that's what they claim, but the Hamming distance between 'Don't roll your own crypto' and 'Please roll now our crypto' is 42. Clearly the answer to the universe is to delve into entropy.
In your write routine, you didn’t say how you initialized list[i]; maybe writing garbage at that point, so later read it right back. You should not serialize binary pointers. IMO, use the list array indices or add a string table in the serialized file, then store the index into that array. That way, if reader and writer are different programs, you don’t run into issues as how memory is laid out or allocated.
The problem at hand is students cheating by copying each other's code.
Congrats! I'm currently trying to learn C# too! Any resources that helped you?
why don't you simply check if the first character of the input matches either "y" (run the character through tolower) and deny on anything else. That should do the trick with a lot less hassle.
Certainly more lightweight than trying to compute and return the entire set in one go. I don't know how expensive it is to save function state across iterations but in most languages that implement this it would be more convenient and faster than using streams. Even if the cost of using generators were higher than, say, using a for loop, it'd still be worth it in the sort of situations where you need to consume/compute MBs of data.
Remember that C is a different language than C# ;) you might be looking for /r/dotnet or /r/csharp
Here's a sneak peek of /r/dotnet using the [top posts](https://np.reddit.com/r/dotnet/top/?sort=top&amp;t=year) of the year! \#1: [Explaining LINQ to a 5 year old](https://twitter.com/bewidec/status/935573858136051713) | [38 comments](https://np.reddit.com/r/dotnet/comments/7ge3sx/explaining_linq_to_a_5_year_old/) \#2: [How .Net was Started](https://i.redd.it/7agry8pn1avz.jpg) | [43 comments](https://np.reddit.com/r/dotnet/comments/7a0we2/how_net_was_started/) \#3: [Visual Studio 2017 will be released on March 7](https://blogs.msdn.microsoft.com/visualstudio/2017/02/09/visual-studio-2017-launch-event-and-20th-anniversary/) | [19 comments](https://np.reddit.com/r/dotnet/comments/5t1ftp/visual_studio_2017_will_be_released_on_march_7/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
The generator pattern is a fine design pattern for many applications. However, you should not think of it as being as lightweight as—say—a for loop iterating through an array and thus you shouldn't use it just for convenience where a for loop would also do the trick.
So with regards to the HMAC, I should add the HMAC to the encrypted file, and then when decrypting, should I separate the actual encrypted data and the HMAC into two buffers and validate the data against the HMAC? That sounds about right to me. It could also double as a key validator, right?
C#? I assume you meant C haha. I mainly used the [K&amp;R book](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628) along with [*C Programming: A Modern Approach*](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504) to learn the language, and various posts on here to get some tiny tidbits here and there.
Yeah, I may have used the word "lightweight" a bit liberally, when I really meant "lightweight, in comparison to full-blown streams". They're convenient to use in many languages because they're part of the language or the standard library but not more convenient than a for loop in every circumstance. Generators work very well when you need to process large amounts of data and perhaps may not have enough memory to hold all of it, or perhaps you want to start returning data as soon as possible and keep the data trickling through until there's no more.
There’s some uncheck fread()’s, fseek()’s, getpass() can fail too. Just because something is unlikely to fail does not mean it can’t happen. If it has a return value, check it. Anything string related that takes an upper bound is literally better then strcat and strcpy. Use strncpy, strlcpy, snprintf, whichever. Yes, the way you create your enc path is technically fine. But the idiom is wrong and fragile and shouldn’t be used. For your dec path the fragility actually bites you since you already allocated too little space. Calling free() doesn’t clear the contents of the memory you just freed. So your key and passphrase are still in memory somewhere. You could memset() them but that opens up another can of worms where your compiler decided it’ll optimize away memset() because the buffers aren’t used anymore afterwards. I noticed you mentioned you didn’t figure out how to check if someone specific the correct key for decryption, authentication helps with this too. You should look into it. You could for example from your password generate enough key material via a KDF so that you have an encryption key and a MAC key if you want to use an HMAC to cover the ciphertext.
&gt; lightweight, in comparison to full-blown streams Seems like a comparison between apples and oranges to me. You know, streams can too provide an interface modelled after the generator pattern.
Ah, those darn file functions. &gt; If it has a return value, check it. I'll keep this in mind forever, thanks haha. Calling `free()` doesn't actually clear the memory? Huh. So *that's* why the example code in the LibTomCrypt documentation zeroed out the key and IV. What exactly do you mean by: &gt; generate enough key material via a KDF so that you have an encryption key and a MAC key I just skimmed through some overviews on KDFs and they seem to only output one key. Do other KDFs output more than one? Or are you saying to use the same generated key for both encryption and the HMAC?
KDF's generate a series of bytes. If you need 32 bytes for your AES key and say 32 bytes for your HMAC key you could just have it generate 64 bytes and split that in half. That is totally fine to do.
Send a verification mail to the address asking the user to reply or click a link.
If you search around, you'll find plenty of plagiarism detectors like MOSS, which professors use to detect student cheating. I work at a university, and my supervisor can click a button, go get a a coffee, come back, and the tool will tell him who's cheated. These automatic authorship attribution tools are also used when (for whatever reason) we have access to one code sample and want to know who wrote it--maybe a whistleblower leaked a piece of software, or a hacker wrote a piece of malware. Yes, humans are *quite* bad at this, but machines are quite good. I've written a classifier which can predict authorship of code with an accuracy of 90%; and some state-of-the-art classifiers can actually do much better ([reference](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-caliskan-islam.pdf)). My research does not repeat this previous research, but rather builds upon it. I've built a tool to automatically evade these classifiers. This is extremely relevant today, especially with organizations like the CIA who have written code to do exactly this ([reference](https://nakedsecurity.sophos.com/2017/04/05/wikileaks-spills-source-code-files-for-cias-marble-framework/). 
That's the point :P 
Because that goes against the point of the study--see my response to u/nderflow
Ah gotcha. Thanks.
i only need a correct format. i dont need legit email 
There are lots of rules so you'll have to decide how thorough you want to be and what false-positive and false-negative rates you're willing to accept. Regular expressions are a common way https://regular-expressions.mobi/email.html?wlr=1 
thanks for reply ! I search a bit easier way to check email. I need something that check the typed email like this: _____ @ ____ . ___ so the main thing is that : 1. the email cant start with '@' or '.' . 2. '.' cant overtake '@' 3.the lines can be only letters. sthg @ sthg . sthg like this. And actualy thats it, nothing else.
Correct, the HMAC would validate the encrypted data. It would also act as a key validator as generating an HMAC with the incorrect key would fail to validate. Even still, there are pitfalls. HMAC is constructed in a specific way to prevent length-extension attacks, so don't write your own. You also need to verify the HMAC using constant time comparison. OpenSSL has the function CRYPTO_memcmp for this purpose. If you use a short-circuit comparison like normal memcmp, you leak timing information about the HMAC, allowing an attacker to forge their own HMAC.
Cool. And I don’t think I’d be able to write my own even if I wanted to haha. Thanks so much for the detailed information, by the way. Really helping me out :)
Ah yes, assumed OP meant C# 
Checking malloc is a waste of time. If malloc fails, your OS is in pretty bad shape anyway. Any malloc failure routine will probably just consist of calling exit, but if it's going to segfault then it makes no difference. Totally not worth the effort imo.
Yeah because failing gracefully is the same as getting terminated and potentially leaving sensitive information in memory or in your core file.
Maybe you're right.
`for` vs `while` loop isn't really your problem; you need to think about what you want this loop/program to accomplish. Sum all odd integers below a certain number? 
Good for learning, but don't write anything security related in C; there are just too many pitfalls.
Qualtrics was blocked by Ghostery on my Firefox 
&gt; I always wanted to have an easy-to-use file encryption/decryption command line tool. OpenSSL and GPG required commands that were too long to remember. Shell scripts are a thing, you know. Or aliases, if your shell supports them. Or shell functions. It's cool that you learned a lot by making this thing, but your reason doesn't warrant rewriting an existing program from scratch. Use the right tool for the job, etc. Just to be clear, I don't want to discourage you from learning. I would've just made something I couldn't replace with a shell script if I were you, that's all.
Yes, I know it’s a loop function I just can’t figure it out, this is the only thing I am struggling with and I’m learning 3 languages at the same time
I echo the not checking unless you do it correctly. I've had several bad experiences with websites that wouldn't allow a valid email.
 // print middle of sqaure row = x - 2; What is the value of `x` here? 
So I'm kinda new as well, but I think after printing the first row your X equals 0. Therefore the next lines won't work 
A good way to debug something like this is to walk through the program yourself, line by line, and keep track on a sheet of paper what the values of each of the variables you are using are after each line. I believe your problem lies with the x variable so keep an eye on that.
&gt;WCGW OP might just land a job as head of infosec at some big name company like Equifax or Adobe
-2, cheers.
Yea that's it alright. Forgot a few \n also. 
Is Reddit turning into a gateway to stack overflow now? I see more posts on Reddit that are little more than links to SO
&gt; and a dot after it if it's not a local address. There's nothing preventing a top domain from having an MX record. "[ai](https://en.wikipedia.org/wiki/.ai)" has one, for instance, so "username@ai" is totally valid.
also it'd be great if the hide file button actually worked. Currently it closes the flie but fills the space it took up with whitespace, which kinda defeats the whole purpose.
C/C++ isn't ambiguous, he's just an asshole.
Wrong subreddit, you should delete this and repost to /r/C_Homework
 #include &lt;stdio.h&gt; int main(int argc, char *argv) { int width = 10; printf("&gt; "); if (scanf("%d", &amp;width) != 1) return 0; for (int cur = 0, start = 0, end = width -1; cur &lt; width; cur++) { if (cur == start || cur == end) for (int i = 0; i &lt; width; i++) // print solid line putchar('*'); else printf("*%*.*s*", width - 2, width - 2, ""); putchar('\n'); } } 
I reckon I'm too late to be much help with this, but I didn't see much actual help that worked within the apparently arbitrary constraints. Hopefully this is still of interest to those who tried. This week I thought I'd try the exercise, but only got halfway. The trick so far is to realise the we can mimic the action of the array/loop algorithm, without arrays and loops because the number of temperature values is fixed at a relatively low count, and loops can be "unrolled" - by just performing the same action sequentially by simply running repeated hard-coded commands. Or at least repeated function calls, thus avoiding simply copy/pasting the repeated parts. #include &lt;stdio.h&gt; int main(void) { int hr01=0, hr02=0, hr03=0, hr04=0, hr05=0, hr06=0, hr07=0, hr08=0, hr09=0, hr10=0, hr11=0, hr12=0, hr13=0, hr14=0, hr15=0; int temperature=0, duration=0, temptemp=0, count=1; int most_frequent=0, appearances=0; void compare4d(int a, int b) { if (a==b) { temptemp=b; count++; } else { if (count &gt; duration) { duration=count; temperature=temptemp; } count=1; } } void find_duration(void) { compare4d(hr01,hr02); compare4d(hr02,hr03); compare4d(hr03,hr04); compare4d(hr04,hr05); compare4d(hr05,hr06); compare4d(hr06,hr07); compare4d(hr07,hr08); compare4d(hr08,hr09); compare4d(hr09,hr10); compare4d(hr10,hr11); compare4d(hr11,hr12); compare4d(hr12,hr13); compare4d(hr13,hr14); compare4d(hr14,hr15); } //testdata: //33,33,33,34,34,34,34,35,35,34,33,33,33,33,32 printf("Enter the heat values: \n"); scanf("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i", &amp;hr01, &amp;hr02, &amp;hr03, &amp;hr04, &amp;hr05, &amp;hr06, &amp;hr07, &amp;hr08, &amp;hr09, &amp;hr10, &amp;hr11, &amp;hr12, &amp;hr13, &amp;hr14, &amp;hr15); printf("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i\n", hr01, hr02, hr03, hr04, hr05, hr06, hr07, hr08, hr09, hr10, hr11, hr12, hr13, hr14, hr15); find_duration(); printf("Temperature: %i\n",temperature); printf("Longest duration %i hours\n",duration); // cheat mode (haven't figured out how do the frequency generation functions yet) most_frequent=33; appearances=7; printf("Most frequent value: %i\n",most_frequent); printf("Number of appearances: %i times\n",appearances); return 0; } 
If 8 spaces is too much for you use less... With respect to `make`, the official documentation is actually pretty ok. For any other issues you can't solve looking there, Google on a case by case level will answer just about anything else immediately. I'd recommend learning about proper build systems like `cmake` in the future as they really can do wonders.
http://www.network-theory.co.uk/docs/gccintro/
Just keep in mind that `printf` can use `malloc`, as can other I/O functions. If `malloc` fails, your options become a little more limited. 
Also, test drive development would help catch stuff like this.
I'm glad I came back to this thread and saw your comment bc I would have never guessed that C functions have documentation in the Linux man.
Glad I could help out
https://www.slideshare.net/mobile/olvemaudal/deep-c This can be a good start to learn something more about C than the basic stuff. It's pretty short but it has a lot of concepts worth understanding.
Check out man pages on your BSD terminal for most C functions. You'll learn more from them, too. A lot better detail than any Linux man page.
BSD documentation and man pages are far better.
I think 4 spaces for tabs is what's usually done. I'd guess the Linux kernel says 8 is to try and limit the amount of nesting you do by producing ugly code that either overflows of doesn't fit on the screen. The more layers of nesting you have the more complex your code will be to read and debug, it's good practice to no more than 2 or 3 layers.
This is true.
If you are in it for the long haul, you can also have a look at the book The C Programming Language, written by Brian Kernighan and Dennis Ritchie(the creator of the C language). It has a good write up of the language's features(control flow, structs, pointers etc.) as well as most of the regularly used parts of libc. It personally helped me a lot when I started but many people find it a bit difficult to follow. You can easily find it online in pdf format, so take a look if you'd like but don't get disheartened if you can't always follow it. For coding style, kernel style is good, but nowdays I'd say skip the columns limit and use whatever tab length you prefer. Most editors allow you define the tab length so it's easy to change it to whatever you want, just don't use spaces instead of TAB.
No blog spam please.
I don't know. However, such a trivial program is a bad test case as it doesn't do anything that can really be optimized. You are basically measuring the time to start up and terminate the program, which can indeed be a little bit higher in a C program compiled to Javascript due to the extra cost of initialising the C standard library. Try a program that actually computes something instead.
would you suggest anything ? 
Probably even counting prime numbers would do.
Also emscripten produces asm.js, which (probably) just uses more code than a simple `console.log`.
It doesn't do the encryption and it doesn't have an interface so it doesn't really provide any value.
I've written a bunch of articles on C, mostly between an intermediate and advanced level: http://nullprogram.com/tags/c/
And I still have to read and hear people saying C is not used anymore.
There is a pattern: the more vocal people are about something being most definitely dead, the more alive it is.
Java is alive! Java is alive! Java is alive! Java is alive! Java is alive! Java is alive! Java is alive! Java is alive! Java is alive! Java is alive! I hope it'll work.
It doesn't work the other way round sadly.
Please stop spamming this already.
People use software that's written in C all the time. Linux, Apache, nginx, PostgreSQL, systemd - all are written in C.
For me there is no other book but the K&amp;R book. I'm competant in C, but hardly an expert. This book is my goto refrence when a question arises. I wish there were books like it for the compiler and other build tools.
Your site looks a bit jacked up on mobile.
Yeah, but that's mostly just the header. I've never figured out how to fix this, and my conclusion has consistently been that mobile web browsers are mostly garbage — dethroning IE6 from its old position. If you check "request desktop site" in your browser it usually fixes it, even though this should really make no difference (neither the server nor CSS even checks for this). 
Sounds like you're asking someone to make your homework. At least show off what you thought off. What you tried. And were you are stuck. 
Printing is entirely a library routine and will be the same in either case. What you're measuring is the time it takes to spin up the VM, load a standard library and call into it. You're not measuring any optimizations or code performance. Try writing code that actually does computation. A common and simple one to implement is the Sieve of Eranthoses.
https://stackoverflow.com/questions/2039444/why-are-drivers-and-firmwares-almost-always-written-in-c-or-asm-and-not-c
It happens because of the high complexity, which makes the problem hard to be detected unless you use programs as checkmarx. Connectivity derives a lot of errors and it's important to fix them.
No other language has conio.h library like C :) - Raj Shanti Kapil
Sir, drivers can be written just as easily in C++. - Raj Shanti Kapil
When manipulating many arrays at the same time it might become a bit problem, as for it's high complexity, that lead to errors that are hard to be detected. There are programs that may help with it, such as checkmarx or others but it's also achievable by keeping things simple. Good luck.
C++ doesn't have a fixed ABI that foreign code can call. Only C does. Hell, I use Rust for systems work, and even it doesn't have a foreign ABI; it uses C's.
C++ is hard to make freestanding. C is not. 
How so, sir? - Raj Shanti Kapil
Not as well, and not as easily.
None of these features require runtime support, they just need a smarter compiler :) Feature|Implementation :--|:-- Templates | Just macros that expand to type, can be done by preprocessor Function Overloading | Namemangling Objects | Namemangling for methods Virtual function | Table of pointers, like a jump table Inherritance | Objects + Virtual functions Polymorphism | Virtual functions Exceptions | C already has this in setjmp/longjmp, just add syntactic sugar New/Delete | Syntactic sugar for malloc + calling constructor I agree you can do everything in the table by hand in C ... but it takes effort - Raj Shanti Kapil
Sure, but then you'd necessarily be just transpiling to C... Consider memory management, for instance. If you want to "new" in kernel space, you need to compile that to somehow bifurcate behaviorally on where you want to allocate, and that's just metaprogramming a usage of "malloc" or "calloc," at which point why are you writing a new compiler and not just using C, which is arguably more effort than just using C in the first place.
You can't though, because he's talking specifically about C++. It's not supplied as a detail-specific counterargument to using C++ as a basis for an OS--it's merely to convince you that the guy that created Linux thinks C++, in particular, is a bad idea for that. If you messaged him asking for more specificity, he might reply with specific examples.
The sidebar has a bunch of books for programming in C. If you can afford it, K&amp;R is worth it. If you can't The C Book by Banahan et al. is a great free alternative. If I'm being honest, I can't in good conscience suggest C as your first language. C is very low level, meaning it gives you a lot of control, but you have to do pretty much everything yourself. It's a great language to learn because it forces you to learn so much, but it's a daunting task for a newcomer. Python is probably more the speed you're looking for; it will allow you to see meaningful progress in your education at a more immediate pace than C would. Hope that helps.
Hi, Thank you very much for replying my post, well you gave me books from which i can start learning but I’ll consider python as a first language. Thanks ! 
https://www.youtube.com/watch?v=RnEiH406f3s If we're posting random long videos with no explanation might as well post something entertaining :) - Raj Shanti Kapil
It looks like you meant to reply to /u/myrrlyn's comment, but your reply seems to be a bit disrespectful. If you want people to explain something, generally being polite is helpful--if nothing else, by now you should be convinced that more than a few people think it's still worth learning C. Perhaps they know something!
I don't think i've been disrepectful. - Raj Shanti Kapil
I thought C was alien a few months ago, coming from C#, and Go. But after reading K&amp;R, I think C is a pretty simple and beautiful language. I'm glad I'm learning it since I'm also the type of person who learns more by knowing why and how things work. Working with higher level languages never really satisfied my curiosity. C did. There's so much to learn! 
object oriented languages are shit, procedural is the shit.
Procedural works for small sized programs, but as soon as you want to write something larger the overall architecture and design is going to play a much larger role. You can avoid using polymorphism and use a switch statement instead in one function ... but if you do that in 10 function it's going to make the code almost impossible to maintain :)
Again, the entire point of that was that it's Linus, and about C++...
Define "superior." If you mean that the tool set that C provides can be viewed as a subset of the one that C++ provides, you're not wrong but that doesn't make you right. C++ was meant to build upon the functionality that C gave us, in particular with the advent of object oriented principles. However, viewing the world through that lens is in my opinion reductionist to the point of absurdity. There are different use cases for each language. There are going to be times when C++ won't work for you but C will (and obviously vice versa). C++, especially using more modern standards, is wildly different from C, and to learn the former in a practical manner will not give you the skills to produce a proper C solution when you need it. In fairness, it's your decision and C isn't for everyone. I'm not going to say you have to learn or use C, but to conflate differences with superiority seems far-fetched to me. I use both, and I prefer C, but I don't think I would ever try to convince strangers (especially ones in a forum explicitly designed to discuss its usage) that C++ is pointless. Excuse me if this is inappropriate, but it sounds like you know C++ and are looking for any reason you can to justify not learning C. 
The Linux kernel's success makes this incorrect.
No, because it uses polymorphism. It uses function pointers to achieve objected oriented programming.
&gt; conio.h You still live in 1994? Amazing!
&gt; conio.h You still live in 1994? Amazing!
I think you may be misunderstanding.
Stupid troll
I just used graphics.h a few minutes ago.
You might want to change that unless you are also a student in the broken Indian CS education system. These libraries have been obsolete since the 90s. SDL2 or Allegro are nice C libraries if you want a recommendation.
I don't think i've insulted you sir
I thought we were making jokes about using old header files. Were we not?
Hello sir. Can you post the code as text? :)
I think printf() internally runs with a strlen() comparable function wich needs a string other then "" to determine it's ending. Try removing printf("") or replace "" with "/0"
This do { if(i%current-&gt;prime==0) { break; prm=false; } } while(primes-&gt;next); is an infinite loop, since `primes` never changes. You are not getting the `before for` output because it is buffered - put `\n` at the end of each debug `printf`.
https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html
Sir, by default the interrupt signal terminates the program. The program has no chance to dump its buffers. You can make the interrupt signal call the exit function which will tidy up all the program state before quitting. This way you will see the printf output even when killing the program with CTRL-C :) I have attached a demo #include &lt;signal.h&gt; #include &lt;unistd.h&gt; void interrupt_handler(int sig) { exit(0); } int main(int argc, char *argv[]) { struct sigaction sa = {.sa_handler = interrupt_handler, .sa_flags = 0}; sigaction(SIGINT, &amp;sa, NULL); sigemptyset(&amp;sa.sa_mask); ... rest of code ... 
As you said, C is better for low level access and performance. If I want higher level, I will skip Java and C++ and go straight to Python. It's performance can be in par with Java and overall it's a better language. Java set out to solve a lot of problems with C/C++ and did a decent job at some of those. Since then there have been several more modern languages, including Python, that have taken the lessons from Java and fixed many of it's shortcomings. I know there have been improvements in that time but I haven't found any practical benefits to using Java since the mid 2000s.
Again: Do not post your code as a picture. You must post code as text. If you do this again, I will remove your post.
I can also recommend you to learn how to use a debugger. This way, it's much easier to see what your program is actually doing. 
There is an industry standard ABI for C called the SysV ABI. With C++ and other languages, it varies from compiler to compiler, even on the same platform.
Function pointers are not polymorphism. They can be used to implement polymorphism though. Polymorphism is a design pattern. Why does it need to be baked into the language at great complexity cost when you can implement it using the tools at hand fit for the specific task at hand?
Python's performance is nowhere near Java's. 
Python predates Java by a few years.
(mutters under breath) perhaps I'm a software engineer at an aerospace research lab where I write flight software in C because C++ in kernel space is how we make everyone sad ¯\\_(ツ)_/¯
https://gcc.gnu.org/wiki/plugins
I used to program in C++. While I was careful not to use features like polymorphism and inheritance, I saw the light and returned from my heresy to the elegant, effective, less buggy, world of C because I got sick of the bloat of the ******* Standard Library (ten times worse than that of C, sections of which I admittedly don't like either) and the ISO committee's bolting on of random features no one needs. I also realized that the implementation of OOP on top of C goes against the philosophy of Kernighan, Ritchie &amp; Co. and that the way it was implemented is terrible. If you want OO (which I'm not sure has ever been efficiently implemented), go use Rust or Go or some other newfangled language. Anyway, there's a reason (perhaps many reasons) why open-source *nix developers (the heirs of the creators of C) don't like C++; no one really does except perhaps the Great Satan of Redmond, who are known for their terrible code, bad design decisions (the original WinAPI was designed by interns; I could write a whole book of stuff like this), and lazily coded, overpriced (Win10 should cost $**-**10, it sucks) terrible products.
C is the best we have for low level programming but there is a lot of undefined behavior in it. Also it has no useful support for atomic subsections or other multi threaded constructs. More simply put, "For low level programming, C is the worst language in the world, except for all the others".
Currently I'm on an in-kernel networking driver and a [de]serialization processor; we have projects that do intensive math on the data we get back but I'm not on those yet, mostly because I'm not skilled at MATLAB and that's where we do a lot of the analysis work.
Check out the subreddit /r/learnprogramming. They have a lot of good advice for beginners.
Maybe I should check out Python in more detail. What I really dislike about it though is its duck typing. What's the point of being able to omit the type in a function declaration, if: * you have to add an if statement in order to catch invalid parameters * you have to add a comment specifying what the parameter actually is, so other people know how to use the function It just doesn't make sense to me why someone would want that. Sure, you can simply omit these things, but that simply ignores the problem.
Exactly! Usually who says it is just ignorant of that fact... or web developer.
Exactly! But one thing that I think it could be misleading: Arduino. I think people could benefit more by simply programming in AVR. It's easy and straightforward. 
&gt; The truth is that there is not "best language", right? We have to choose one that is more likely to be the best for our problem. Exactly. That's why I was wondering why you dislike Java (or C++) so much. There are problems where you can't use Java (hard real-time systems for example). On the other hand, I wouldn't want to write a standard desktop application in C nowadays when Java is just fine for that. C also seems to be a bad choice for server software because of its lack of memory safety (just look at all the buffer overflow vulnerabilities). AlienAlmonds said he would prefer Python over Java for most high-level-stuff. It's fine for small stuff but I wouldn't want to use it for larger projects. Java is nice here.
Isn't the best argument, that a C++ compiler author needs 2h to explain why linking C++ is so hard... a pretty good example why low-level stuff sucks with C++? Imagine debugging this shit.
Please don't post this sort of content.
Right, well... choice? :D I mean, I like simplicity and I like control. I like things to be done exactly the way I want, even though it could be wrong for machine X, but run on machine Y; **if that is what I want** (I'm not saying people should write code that benefits from UB or ID, I'm talking about liberty and control). The things I dislike most programming language like Java is the imposition of things, the overwelming complicated construction to achieve a simple solution. I don't believe that writing a desktop application in Java is a lot easier than in C.
No, I landed in the wrong place...
I thought this was a good explanation. Was anything factually incorrect? 
Things which seem obivous to a experienced programmer may not be obivous to a complete beginner.
As a student who has 3500 pages worth of good solid reference source books, it's EXTREMELY intimidating to try and figure out where to even start. YouTube has been hella good to me so that it's not as overwhelming while I'm doing pre-class self teaching. 
The blind leading the blind
Making a tutorial video is an assignment in some courses.
You have an extra ";" at the 3rd line, that's the problem. Those kind of errors must be handled quickly and it's harder when the size of the code grows. There programs that help with it, as checkmarx but it's important to keep in mind that they can be handled on the run and save your time. Good luck!
You can always look on C's manuals, just make sure you learn correctly as in C, everything is a little bit more complex, which requires a lot of work whenever there is bug to detect. There are programs that helps with it, such as checkmarx and other equivalent. But a good practice is always important. Good luck!
There are some tools for tokenzing and parsing, namely `flex` and `bison` (replacing `lex` and `yacc`). If you wanted to do it yourself, there is `strtok_r` which is helpful for tokenzing. For parsing, as it's an assembly language, it's probably pretty simple to parse. Just making a little state machine would probably be enough, but you could also do recursive decent or something if it's easier to organize like that. 
For the simple problems (reading files) Google and StackOverflow should suffice. If you want the real deal go get the [Dragon Book](https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools) and work through it.
http://www.davidsalomon.name/assem.advertis/asl.pdf
Are you going to upload the lecture note as well?
Link to Twitter, containing a link to a URL shortner, which links to an affiliate link to [this page](https://www.udemy.com/learn-advanced-c-programming/).
Are you trying to write c programs for game boy by chance? Z 80 seems most common in that hobby atm. If so, they're are a few already existing that I've seen on their wikis abs such. IIRC they don't produce great binaries because z80 is a sort of non traditional target these days.
I had a feeling it was called an assembler, wasn't too sure though. I've gotten to a point where all of my tokens are stored in a giant table. (Example: LD A,$45 is stored separately as LD, A, and $45) Now I'm just trying to figure out what kind of structure would be best for searching through all the opcodes and possible parameters in order to match a single opcode and the following parameters. I need it to be fast, how would I do this?
yep they are coming
Best of luck! I've been writing an emulator for fun, and my next step is a disassembler. I'm not a sort frequent reddit user any longer, but keep me in the loop if you want!
&gt; I'm just trying to figure out what kind of structure would be best for searching through all the opcodes and possible parameters in order to match a single opcode and the following parameters. Match just the opcode. Looks like there are 251 "opcodes" (a lot of which are simplish variants of each other), and four oddball prefixes (CB, DD, ED, or FD). Make an array of 255 function pointers, and use the opcode to index into the array. Then call the function so indexed. It's probably not the *absolute* fastest way, but it's damn fast.
I'll try it out, thanks a bunch.
Generally I just joke that syntax is "magic words", and that a CPU is a "magic rock that can think". It takes the edge off having to explain how a turing machine works. Then you can come back when people have more knowledge an experience and explain how assembly works, or point them to a Ben Eater video which does a much better job of explaining this stuff than I ever could. Calling it magic has the added side effect that people think "magic doesn't exist" and will often try to figure out how the stuff works on their own.
Not the guy you replied to, but... We use a combination of C and C++ for embedded work and it would be nice if there was a language that was less verbose (like D) that had the same zero abstraction cost of C. That said, I don't really mind C... It's just easy to look at features of higher level languages and wish you had them sometimes.
Function pointer syntax is tricky, and in an array it's even worse. Be ready for a lot of crashes, memory problems, etc.
Well, he introduced functions and then mentioned sines. However, printf is not a function in the mathematical sense as it is not idempotent because of a side effect. This is the whole point of functional programming. 
[removed]
My guess would be because the T stands for template and void pointers suck
Well, for one, C doesn't have generic data-types. You could argue either way on this one. Go is a relatively new language that famously (or perhaps infamously) does not have generics. C++ went the other way and included templates. At worst, you could implement your data structures in a generic-ish way by using opaque pointers (void *) instead of pointers to the correct type of data. However, you lose some type safety in that. Another way you could do generics is by creating template files and running them through a textual replacement program. So, for example, you would have a struct: struct vec_&lt;!t&gt; { &lt;!t&gt; *data; size_t maxSize; size_t currentSize; }; and its associated functions: void vec_&lt;!t&gt;_add(struct vec_&lt;!t&gt; *self, &lt;!t&gt; toAdd); etc Generally, C takes the approach of "let the programmer implement things as he or she sees fit." This means having a minimalist standard library. It's not like C doesn't give you any library functions, though. The C standard library has many helper functions, including, but not limited to, those for strings and math. The C standard library actually has a lot of useful functions, depending on your use case. I'm sure you're familiar with a lot of it already. It is a bit sparse on data structures, however.
Actually, there is a library by Alexander Stephanov with most STL functionality, implemented using macros. Google is your friend. 
Assemblers are usually easy. Got the code of one hand copied from a book I bought back in the day (in BASIC). You open the file. You read the lines one by one. Then for each line, you read the first token and the characters match "LD" then you call the function that decodes "LD" with the rest of the line. Then that function builds the sequence of bytes directly from the parameters it identifies (first parameter until the comma and then after the comma, make distinction if the params are immediates or registers and so on). Like I said assembly is usually simpler, no intermediate representation needed nor optimisation. 
&gt;This is actually very similar to how C++ compiles templates. It finds all the datatypes used for a given template, then spits out the code for that template for each of the used datatypes. No doubt this is a huge factor in C++'s slow compilation times!
Your point makes sense. Because I have used Rust for a while, I do enjoy it, Rust has a great standard library including some decent data structures and algorithm, such BTreeMap, Quick-sort/Merge sort, etc. But when I switch back to C, if I want to use a Hashmap/Linkedlist, I have to build it by myself, it bothers me a little bit.
WTF is a “digit number”?
There are lots of C libraries with data structures you can use so you don't have to always reinvent the wheel. glib, for example.
Pretty good satire but I'm not sure it belongs here.
Yes, glib is great. But it is not `built-in` library, and it is not easy for C to install 3rd library as easy as Rust does. Just brainstorm, is there any possibility for C to has a package manager like cargo/pip/npm ?
I haven't checked this, sounds great. 
apt, pacman, yum, pkgin, etc. work great.
&gt; is there any possibility for C to has a package manager like cargo/pip/npm ? There are plenty of package managers for C libraries. They are called apt, pacman, rpm, …
I wrote an assembler for Gameboy, and I used flex and bison to avoid having to write the parser myself. https://github.com/gusfm/gusgb/tree/master/src/as
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [gusfm/gusgb/.../**as** (master → ed9dbd4)](https://github.com/gusfm/gusgb/tree/ed9dbd45ff68fa0ee04a1a83767acb6adec93868/src/as) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dscxu9e.)
This is awful.
Yup. No wonder languages which compile to C (like Nim does) are able to achieve phenomenal compile times (relative to C++).
clib, conan, cpm, ... As this is something bolted on recently, there is no *standard* package manager, however.
https://www.reddit.com/r/rust/comments/79xqad/cisco_has_built_a_c_package_manager_written_in/ a C/C++ package manager written in Rust
If you must target Windows, MSYS2 has pacman and lots of native versions of libraries.
How do I reference the "write_thread" local variable buf at https://gist.github.com/promach/3751054163042d255f818724934799ed/1cb05b8194a69719d66589e25fdd2a92c832ddd1#file-fifo-c-L270 from within main() function ? 
A [thread local variable](https://en.wikipedia.org/wiki/Thread-local_storage) is a thing, and I don't see any in that code. Terminology matters. On a related note, can you use the standard C11 atomic types and operations (I assume all that sync fetch and add stuff is atomic)?
I don't target Windows(and I prefer not to), I just want to point out those package manager are not portable, 
&gt; I assume all that sync fetch and add stuff is atomic Yes according to https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html 
What are you talking about? All i'm finding is STLPort, and it's written in C++, not C.
So, the way I code 'buf' at line 270 is not a thread local variable. fifo.c: In function ‘main’: fifo.c:399:17: error: request for member ‘array_input’ in something not a structure or union write_thread-&gt;array_input[i] = i; ^ fifo.c:400:16: error: request for member ‘array_hardware’ in something not a structure or union read_thread-&gt;array_hardware[i] = 0; ^ fifo.c:456:21: error: request for member ‘array_input’ in something not a structure or union if( write_thread.array_input[i] != read_thread.array_hardware[i] ){ ^ fifo.c:456:51: error: request for member ‘array_hardware’ in something not a structure or union if( write_thread.array_input[i] != read_thread.array_hardware[i] ){ 
Take a look at this: http://stepanovpapers.com/gclib.c
Please don't post these.
This one is actually pretty decent which is why I left it up.
Such libraries exist (e.g. glib) but are rarely used. C programmers tend to implement data structures ad-hoc as needed for the task at hand.
You don't. Local variables are local to the function you declared them in. Either make the variable global or declare it in `main` and pass a pointer to the variable to `write_thread` instead of declaring it there.
Check out buckaroo. Haven't tried it myself but it looks like the most mature.
No. I won't ban someone just because he doesn't agree with you.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
[removed]
Good question. Try hanging out in the #gcc channel on Freenode and ask the gcc developers. They are probably happy to help you.
CMake?
I have this error https://paste.ubuntu.com/26346029/ with https://paste.ubuntu.com/26346032/ It seems to me that malloc() is needed in this case. Could anyone advise ?
That's amazing. But it's mostly &lt;algorithm&gt; I still miss basic containers like map/dict and priority queue (aka heap)
I'd recommend using C++ then :) If your friendly local compiler supports -std=c++11 it rather matters not much at all. 99% of the time you can make arrays work. Also - priority queue very much != heap... 
Or I got it wrong or the others got it wrong, but I laughed and I understood your comment as humorous way of joking about chden's comment. People think that writing C code is unsafe, but in reality the unsafe aspect of C is due its liberty and the assumption that the programmer knows what he/she is doing. There is no such thing of "lack of memory safety". There is though the lack of programmer experience.
Yes, I see that now. Thanks for pointing that out. I still think this is a pretty good hello world rundown. I think the video communicates enough about functions to get the point across.
&gt; It's just easy to look at features of higher level languages and wish you had them sometimes. True, I can relate with that. Have you done any embedded project with Lua? I think it's a good choice when you don't care much about speed on an embedded project*. And it has a somewhat easy way for C binding. * I confess I haven't done any, I just read about it a lot and seems to be the general consensus towards it.
The root interaction in kernel and driver stuff is the ioctl() call. It it quite very much not OO at all. 
Many times an assembler is listed as a type of compiler, so a dumbed down definition of compiler and assembler would be: *Def. (compiler): A tool to translate from language A to language B.* *Def. (assembler): A **compiler** that translates from assembly language to machine language.*
I would characterise a *compiler* as being *a tool that translates a program from one abstraction level into another (typically lower) one.* An assembler is not a compiler as assembly (not counting macros) is merely a human-readable presentation of machine code but not a fundamentally different level of abstraction. This difference is important when considering the techniques used to build compilers and assemblers. You can easily build one-pass assemblers that parse a single instruction at a time, translate the instruction into machine code and write that into the output. This however is typically not possible with compilers except if the language has been carefully crafted (like C or Pascal) to support this. And even then, this sort of compilation is not really the way compilers actually work, but it is pretty much how assemblers are written.
Dumb question, wouldn't it be `man 3 qsort`?
haha
Fair enough, this definition is consistent albeit I guess uncommon. In many CS books this distinction is not emphasized, mostly because it's not much needed, I guess. Calling "assembler" a type of "compiler" makes it easy to categorize as well and it's pretty clear that assemblers work in a far more trivial way, compared to compilers. Calling assemblers different from compilers, to me, comes unintuitive because that distinction feels forced. Just because translating from assembly to machine language is a rather trivial task that can be done one-at-a-time and there's no (or just a really really small) difference in abstraction between these two languages, I don't see the point of not calling this process compilation. Note that there are also compilers between high-level-languages of roughly equal abstraction, these'd need a new name too. I find it far worse when people say that compilers "translate directly into machine code" which is strictly wrong and a pest that's found more and more on the Internet.
stumbled onto this when looking at linmath.h don't know its origin but GLFW examples are using it for basic vert / matrix math, its almost *shudder* a template
Libraries usually don't have different names in different Linux distributions. What they might have is different package names. For example libcurl might be in the libcurl-dev, libcurl-devel, or curl (tool and library bundled together) package. They also might have different install locations. This is something that a tool like "pkg-config" helps sort out. I understand though that some libraries don't have any pkg-config support. In those cases I'm sure patches are welcome.
&gt; I find it far worse when people say that compilers "translate directly into machine code" which is strictly wrong and a pest that's found more and more on the Internet. clang does this actually. And so does gc, the Go compiler. It is becoming less and less popular to emit textual assembly code as that's just an extra step slowing down compilation that can be omitted.
Yes, it's true that there are of course compilers doing this although even clang emits llvm bytecode iirc (but only internally). But just making this statement by itself is a gross oversimplification, and simply wrong as it stands.
Here's what I use: * For std::string I use [antirez's SDS](https://github.com/antirez/sds) * For std::vector I use [attractive chaos kvec](https://github.com/attractivechaos/klib/blob/master/kvec.h) * For std:: unordered_map I use [attractive chaos khash](https://github.com/attractivechaos/klib/blob/master/khash.h) Attractive Chaos has other generic data structures in the klib project but I don't use them. Klib is implemented with macros.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [attractivechaos/klib/.../**khash.h** (master → 0cb3e7d)](https://github.com/attractivechaos/klib/blob/0cb3e7dc5250d9ff25f60c4e906dfefd37f2a28a/khash.h) * [attractivechaos/klib/.../**kvec.h** (master → 0cb3e7d)](https://github.com/attractivechaos/klib/blob/0cb3e7dc5250d9ff25f60c4e906dfefd37f2a28a/kvec.h) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dsd79we.)
Well, qsort() is often taken as [an example](https://stackoverflow.com/questions/10775087/what-things-or-in-what-cases-can-make-c-slower-than-c) to argue C++ is faster than C. It amplifies the weak point of C.
It used to be possible to compile standard C++ to standard C. Not sure about newer C++ standards though.
This is ugly as hell and results in code that requires more time to read and understand.
No, this is not a C library. It even doesn't compile due to function overloading that C doesn't have.
I presume that you are not talking about CFront, right? That sounds very interesting indeed. I assume this would have been around C++98? And yeah, the newer standards are way too complicated to imagine transpilation into C!
`man` will pick the lowest numbered man page with a matching name if unspecified. If there's no 1 or 2 page, 3 page it is. 10:23:34 edge@debian ~$ man qsort | head -5 QSORT(3) Linux Programmer's Manual QSORT(3) NAME qsort, qsort_r - sort an array 
Please be civil.
The difference is that `stdio.h` is a portable standard interface whereas `conio.h` was only ever available on DOS, a fairly outdated operating system very few people use today.
This subreddit is for programming in C. I applaud your wish to learn programming, but this is really not the right place to ask questions about programming in general. Try /r/learnprogramming.
This is a misconception. Prior to C++11, STL is slow to compile primarily caused by its heavy internal dependencies. Code inlining itself only contributes to a small part. In fact, you can implement a complex container like hash table or red-black tree in ~1000 lines of code (LOCs). Inlining 1000 lines won't greatly slow down compilation. The problem with STL is that even for the simplest data structure it brings a memory allocator and other invisible stuffs with &gt;10,000 LOCs and it encourages to do that for each type in each .cpp file. Properly using templates/macros won't have that a big impact to compilation speed. It is just the design of STL that hurts in this respect.
Thanks a lot for clarifying it.
I doubt that's related to templates
glib is a pain to work with. I like implementing linked lists myself, it's simple enough to inline anywhere and let's me tweak it just right. BSTs too. BSD has a nice implementation of red-black and splay trees as preprocessor macros, [tree.h](http://bxr.su/OpenBSD/sys/sys/tree.h). There's also [queue.h](http://bxr.su/OpenBSD/sys/sys/queue.h) for linked lists and queues.
Memory's another issue. I'm storing all of these tokens and opcodes in two giant arrays before they are eventually written to a file. I wonder if there would be any issues if the source code was too big, seems like I'm using tons of memory there.
 &gt;Also, who makes the STL? Who maintains it? Is it Compiler specific? OS specific? Are the Algorithms discussed in the comity and updated every decade or so? &gt; The C++ standard defines what the assorted algorithms and data structures do, and their runtime complexity. Compiler developers are free to pick any appropriate way to implement them given the restraints (in practice everyone uses red black trees for map, though). Generally each major compiler provides its own standard library implementation. (Clang often uses gcc's instead). C++ is on a 3 year release cycle, not a decade scale one like C. Lots of support for parallel algorithms was added in C++17 (implementation is taking a while compared to other changes, alas) as an example of how it evolves. C++11 hashtable types are another. And if you don't want to use it, you... just don't? You lose a lot of functionality by ignoring the standard library, though. Might as well just use C in that case, unless you want to be complicated and use some third party replacement library.
&gt;I And yeah, the newer standards are way too complicated to imagine transpilation into C! They're not too complicated to translate into machine code. That means they're not too complicated to translate into C. Or JavaScript. Or any other language. 
How large is “giant?” Consider making the opcode array just as large as needed. Reading in all the source code and storing its token in an array is okay, I think fasm does it this way, too.
You might want to check out the `pkg-config` tool designed to solve the first issue.
&gt; is there any possibility for C to has a package manager like cargo/pip/npm ? No. Please don't even suggest this. Package management is the rôle of the distributor, not the language. I absolute hate with passion languages bringing their own package managers. It's always without exceptions a terrible shit show to get the versions aligned with everything around it. &gt; But it is not built-in library And it should most definitely not be! The C standard library should only provide interfaces that are reasonably difficult to implement without platform or operating system specific code or interfaces which are generally very useful (like `printf`). I am against putting random data structures in the standard library as they won't be suitable for most purposes anyway. I mean, look at `hsearch()` and `tsearch()`, two attempts at putting generic data structures in the libc. Nobody ever uses these, they just eat space on my disk.
You can specify length and alignment in the format specifier. int a = 100, b = 10000, c = 1000000; printf( "%12d %12d %12d\n", a, b, c); printf( "%-12d %-12d %-12d\n", a, b, c);
**If I were**
I've started playing with Go, it's indeed an interesting language. And talking about embedded projects and Go, a few days a"Go"* I saw this: https://reconfigure.io/ -&gt; Program FPGAs with Go! And I'm seeing a few people talking about Rust for low-level/embedded projects. *right? right? no? okay :(
I wish for a better language for embedded but haven't found one yet. C is best suited for low level memory access, consistent timing, etc yet most of the constructs to achieve those things are not well defined in the language. For example bitfields are incredibly useful for mapping peripheral resisters to C structures but there are several cases in which bitfield usage results in undefined behavior and are therefore shunned by many coding standards. Features like atomic blocks, soon locks, memory barriers, etc that are useful for safe interrupt handing are not defined by the standard so it's slightly different for every chip. There are valid reasons for some of this but in general C needs to define some of its undefined behaviors. Beyond that, C's standard libraries certainly show their age. In many cases (low rate, noncritical tasks) I'd gladly trade some runtime speed for array bounds checking, smart pointers, etc. Other improvements could be made as well, such as exception handling, better scoping, etc (some of which are already in gcc but not standardized). If you ever have any specific questions, feel free to ask.
For Java there's JNI. I have used it in the past on Windows for getting some hardware info with Nvidia's API, with the help of Sheng Liang's `The Java Native Interface`. If you're stuck let me know.
It is definitely advantageous to not use anything from STL (libc++) because that may not be available on the target platform. Not using C++ constructs (classes, references, range-based for loop etc.) on the other hand is not really needed, they generally do not depend on any external library (exceptions and RTTI do so you are recommended to not use them). To test, you can compile .o files with C++ compiler (with disabled exceptions and RTTI) and try linking the generated .o file(s) with C linker. If it works, you are good.
C is the lowest common denominator, so to speak. Since you're trying to allow for use from as many languages as possible, using C for the interface is the right way to go. If you're compiling with C++, just use `extern "C"` and you'll take care of name mangling -- to the rest of the world, it's a C function. But for the implementation of the function itself, that really doesn't matter much. In the end, you just get machine code and you're done. The caveat is that you can't throw any exceptions that would leave this function (inside is OK, but once you leave it you invoke undefined behavior, I believe). Also, I would highly suggest making sure any libraries you use are statically linked (though that goes for C as well). 
thanks, it took some fiddling between which variables would be justified left and right, but it worked. 
Are you using iostream and cout? If so, this is not a fair comparison. cout is a stream and thus comes with a lot of features write or printf don't have. Including but not limited to needing an object layout, virtual function table, and more standard library dependencies. This is not a limitation of the c++ compiler but rather of the c++ runtime library.
how can he fix it?
Another neat feature with printf is the "*" format flag, that'll allow you to specify the field width as an argument (thus easily set at runtime) before your value. So `printf("%d\n", val);` would become `printf("%*d\n", fieldWidth, val);`. I use this all the time for formatting string fields where the string length of the field isn't known (and should be derived from the data). 
You can also use the return value of printf, which (a little-used feature) gives the number of characters just printed. I use this all the time by defining a variable as the width I want a column to have, then subtracting the return value of printf from it, then printing the remainder number of spaces before the next field to be printed. It's sometimes less messy than using formatting characters within the printf string.
Mother of god. How did this go past me? Thank you for the heads up! EDIT: Works also for the number of decimal places: ("%.\*f", 4) EDIT2: Works also for srings: ("%\*.\*s", reservedLength, actualLength, string)
No problem. Glad to be of help. I remember having the same "how did I not know about this" feeling when I found out about it :-)
Udemy is a pretty good site to learn from, but make sure you do it correctly, as c is a very complex language and every error is a real problem to solve. And although there are programs that helps with it, as checkmarx, I'd recommend to make sure you you know it as much as you can.
tsearch would be much nicer if it used a balanced tree (the glibc implementation uses red-black trees iirc, but most other versions don't, so hope you don't add elements in sorted order). I used it a few times many years ago (these days I just use C++ and std::map). hsearch is just plain crappy, fragile design and is rightfully shunned.
Definitely not, but I'm always wondering if there's a better and more efficient way to get these things done. My mind's probably stuck on the processor this is being assembled for, I keep on forgetting that this stuff is nothing for modern CPUs.
&gt; The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming. - https://en.wikiquote.org/wiki/Donald_Knuth#Computer_Programming_as_an_Art_(1974) I've been programming for 20+ years now, and 9 times out of 10, I still cannot come anywhere near correctly guessing where my code is going to be slow. If you want to *actually* know where your code is slow, then profile it. *Never* optimize before profiling. You are not smart enough to guess where your code is slow. Nobody is.
What's the reasoning behind the `register` arguments? Does that actually alter the calling convention or something?
Writing a basic shell in C is a very common project in Operating Systems classes. So sure? 
Is there something in the C standard that demands a certain sorting implementation? Wouldn't it be possible for a particular implementation of qsort to be as fast as C++'s sorting function? Not denying you here, but I'm genuinely curious.
It should still be possible to translate C++ to C. They're all Turing Complete, after all.
I think this is a great first project! It’s interesting and the painterly demo gif is cool to watch. If you’re willing to experiment I think you’d find some interesting possibilities doing this on gpu rather than cpu.
That's pretty impressive for a first project, keep it up! I'm not a guru though, but if you're interested in some code commentary: 1. In `main()` you can check if first symbol is `-` and then use simple `char` comparison, it may result in shorter code for one-letter arguments (this is a subjective matter though). 2. Spacings and empty lines are irregular in code. 3. You're barely checking for runtime errors where they can appear, for example - in all your `malloc()`'s. Probably you need to check values for some divisions too.
I guess that is nearly impossible as long as you pass function pointers. With the current qsort() API, compilers won't be able to optimize the code as much as STL.
Very unlikely. The problem is all the function pointer indirection.
Calculator?
This is only slightly relevant but I'll post here just because... I'm working with a javascript library that is an emscripten port from C++, and one major issue is polymorphic functions.. namely that they aren't handled very well, so if you're planning on casting a wide net, maybe keep your function interfaces very simple, and don't rely on differentiation by parameter type/count. Cheers!
How much of a beginner? Calculating primes. Pretty easy to figure out something your self. Also has lots of depth if you want to get into it using online resources.
This. You may also want to read a style guide to help you more easily read your code. Great work keep going!
For one, you wrote 'd%' where you should have written '%d'
Thx all of you guys
Binary calculator
Please don't post code as pictures. Always post code as text!
Please don't post this sort of content.
Line 9 should be else if(b&gt;c) (no semicolon). 
Start writing sorting algorithms, learn to think recursively with structures like binary search trees and start exploring tre standard libs and what the OS offers you 
Haven't tested it myself (yet), but this [collection of command line arcade games](https://github.com/stillmotion/terminal-games) seems like a good place to start. (Beyond the standard K&amp;R book).
As for misunderstanding me... yes, maybe I was a little unclear. I didn't claim pthreads are the best thing since sliced bread. I personally like the simpler C11 approach... ... However, many features seem to be missing from C11 threads (for example, how does one control the stack size for the new thread?)... On practical terms it seems that the POSIX API is more flexible than the one proposed by the standard... the fact of the matter is that in 2018 more systems support pthreads than C11 threads. As for the rest, I'll just agree to disagree.
Writing a shell that can do anything of substance is a bit tricky and requires a good grasp of the UNIX API and the way processes, files, pipes, and signals work. I recommend you to start with something simpler.
Thank you fine sir, you da real MVP! 
I wondered this too. Will formulate my questions after work!
Work your way through [this list](https://github.com/karan/Projects). They are challenging without being too daunting. Have fun!!
I’m having a terrible day. Nobody use this! 
Thank you
Hello, I think the undefined behavior that is being alluded to is because there are 2 statement pointer, one for the binding of b and the other for the binding of c. Whenever you have 2 statement pointers, it is up to the individual compiler to decide which will occur in which order. So even though there are parentheses, it is possible that the compiler will not return the value of b. If I had to guess, though, this code would be pretty uniform across clang, gcc and the rest of the standard compilers. A better example of the behavior would be the statement x = 1; x = x + 2(x++); this one has 2 different behaviors, one on clang and one on gcc (I know this because I've seen it). Look at the c best practices for statement pointers to give you more info. 
I see. But wouldn't by that logic be this also undefined? if ((b = a + 2) != 3) do_stuff(); I see this pattern a lot, so I assumed it's correct. Thanks.
&gt; So even though there are parentheses, it is possible that the compiler will not return the value of b. The value of the expression inside those parentheses is well-defined. The actual assignment of this value to `b` might happen whenever the compiler decides, but nothing else in the statement depends on `b`, so everything's kosher here.
I can't explain why it's undefined behaviour but if I saw that in a project I was working on I would rewrite it: b = a + 2; c = b - (a - 1); A nested assignment like that looks ugly af, I feel sick looking at it. I guess you can't guarantee b will be re-evaluated before c is.
You're welcome! And when you get to pointers, [read this tutorial](https://pdos.csail.mit.edu/6.828/2014/readings/pointers.pdf). It will help make things click for you.
[Exercsim](http://exercism.io/) Is a good place to start. They are exercises, not projects though.
Thanks again really appreciate it!!!!! 
What is a *statement pointer?* I've never heard this term before.
I learned a lot while recoding standard C function with just write, malloc and free
I wonder if the author of this material saw something like this: c = ( b = a++ ) - ( a - 1 ); And decided to change it to make it 'original', not realizing that "a + 2 " isn't the same.
To get a first approach of the UNIX API you can try to recode by yourself the ls command. this is what we do in my school. i can upload you the subject if you want
There are no "side effects", so there's no undefined behavior. The results of the code OP posted are quite well defined. Specifically, 'c' will contain a + 2 - ( a -1 ) = a + 2 - a +1 = 3. At the end, b will contain a + 2, c will contain 3, and the whole operation will return the value of 3, but that's ignored/irrelevant.
(Note: this is better suited for /r/cpp_questions, since this sub is more about C than C++.) &gt; I am aware that C++ is an extension of the C language, and that traditionally it has been taught to students with much difficulty. Yes and no. C++ is *mostly* backwards-compatible with C, so that almost every C program can be fed into a C++ compiler and will compile and run correctly. There are some exceptions and edge cases, but this is largely true. However, if you think about C++ in this way you'll be seriously holding yourself back. These are two very different languages and should be treated that way. Everything from the high-level program design to the way individual algorithms are written should be done differently. Unfortunately, very few schools have picked up on this. Most teach a very strange hybrid of C and C++, basically C with `cout` and `new` instead of `printf` and `malloc` and then teach how classes work. I believe this is what leads to the difficulty for students to learn the language. Since you're at school, whatever hybrid they're teaching is what you'll have to learn. In some ways, this is a good thing: you can just write the C code you're accustomed to and gradually incorporate C++ into your toolset. The ability of C++ to support this style is part of what allowed it to take off. The downside is if your school teaches one of the more absurd hybrids, absolutely prohibiting using `std::string` and `std::vector` for example. Then you won't actually be learning C++ at all. And so we get to the phrase, "Don't let schooling interfere with your education." My suggestion is that whenever possible you should see if C++ has a better way of doing something than you might have used in C. And then use that instead when you can. A great example are strings. In C, strings are represented as a null-terminated array of characters. C++ still supports this, of course, and it's still a useful tool in some situations, but C++ also has `std::string`. Working with this class is often much easier than with a C string. You can use it like any other value type, returning it from functions, copying it, comparing with `==`, etc. You're less likely to make mistakes that crash the program. It can sometimes produce faster code. If you feel like using `malloc`, stop. There's a better way in C++, and it's not `new` (which is probably what your class will teach you). Maybe you really want `std::vector` to hold a dynamic array. Or maybe you want `std::make_unique` to handle a single dynamic instance with single-owner semantics. Or maybe you want `std::make_shared` to get shared-owner semantics. Learn the right tool that C++ gives you whenever you can.
I think it was supposed to be c = (b = a + 2) - (b - 1); because increment is used in the next example.
It's a lot easier to learn on Linux. There's nothing to set up. 
In my honest opinion, Unix-like operating systems are far and away a better option for learning C. I'm assuming Linux or similar is not a viable option for you, but if it is take a step back and consider it. With that out of the way, I can't help you with the description you've provided. This is partially because I don't usually use Windows as my OS for development, but largely due to you describing the problem in a relatively vague manner. I strongly recommend you share your input and the output you receive with Cygwin64. The same goes for the message you're receiving with Code Blocks
Sounds like you never actually installed a compiler.
Gcc is the GNU C Compiler. It'll be on an any Linux distro by default, I think
This is an example of what I input: #include &lt;studio.h&gt; int main() { printf("Hello World\n"); return 0; } Errors say: -bash: syntax error near unexpected token '(' -bash: syntax error near unexpected token '"Hello World\n"' -bash: return: can only 'return' from a function or sourced script.
Get [msys2](http://www.msys2.org/). Run from the msys terminal: pacman -Syuu pacman -S mingw-w64-x86_64-toolchain Now you should have gcc and glibc installed, you can run the compiler from the `mingw64.exe` shell with `gcc` or add `&lt;path to msys64&gt;\mingw64\bin` to Code Blocks. 
It's also possible to set up gcc on a Windows PC and run it through cmd after adding it to path. Works like a charm
Ugly? Yeah. Undefined? Nope.
Did you just write that piece of code directly into the terminal? You need to create a .c file with that code in it and then call the compiler (for example: gcc test.c -o app)
Oh. Um ... hmm.... well, that explains things. One day you'll look back on this and think, "Wow, I was such a noob!" You're trying to type in a C program at the command prompt, and that's not going to do what you're hoping. What you need to do is put that simple program into a file, and then you'll run the commands to compile the contents of the file and execute them. Right now you're typing at the command prompt that will let you run the text editor and compiler. I suggest watching [this video](https://www.youtube.com/watch?v=PaBWzPriMZ8) which will step you through the process with a very simple editor (nano). You probably need to re-run the setup to install this editor. And yes, there are many more capable editors out there, but that will give you the idea of what you should do. Later you can try out a few other editors to see what you like the most. (Also, "studio" in your program above should be "stdio")
#include &lt;studio.h&gt; Do you mean '&lt;stdio.h&gt;' ?
In my opinion the other answers telling you that you need to download different shell environments or a Linux operating system are not necessary. Cygwin is fine for writing and testing simple programs. It sounds like a you are missing the C compiler called gcc. You can check by entering "gcc -v" into the Cygwin terminal. If it's missing, what you need to do is run the Cygwin installer again. Click through until you get to the "Select Packages" page. Then type "gcc" into the search box and select "Full" in the View drop down box. Left click on the arrows on the line that contains "gcc-core" so that it lists a version number instead of saying "Skip." Then click next to go through the rest of the installation process. The process you will have just completed is essentially the Cygwin equivalent of installing packages to a Linux operating system. The Cygwin installer is essentially its "package manager." I don't know if Cygwin included a C compiler by default at the time your book was written, or if maybe they listed some installation options that you overlooked. It may be a good idea to go back and check that they didn't advise you to install any other Cygwin packages.
What do you mean by &gt; '.' cant overtake '@' because there are millions of people with '.' in the local part (left-hand side) of their email address.
&gt; Sieve of Eratosthenes FTFY
thank you!
How do I bring up the installer again? The only thing I can open is the program. Also typing in "gcc-v" says "command not found."
It's just an info, just a "better don't do this (next time)", everything else has already been said.
I think getting a Rasberry Pi might be easier, but I have no experience building computers either. 
The bold is because reddit sees the `#` and tries to make a heading out of it, but that character is used for other things when programming so this sub modifies the formatting a bit.
There are a lot of good guides online, but it might be a bit too much if you're just starting out. Maybe look into getting a Linux virtual machine to run with virtalbox. It's really easy to set up, and you can do it on your current windows machine.
That would be awesome!! 
&gt; “This file is too big to show” I’m sure it was cool though.
The installer is just the file you downloaded to install Cygwin with.
I agree, that's why I think this example would be well defined (even though by the books it's undefined, I wouldn't imagine it doing anything but what you would think), but I think the example was to teach the possible dangers of multiple statement pointers. 
By the books is completely, perfectly, unquestionably well defined.
This is well defined because != acts as a statement stop so the compiler sees b = a + 2; if (b != 3) do stuff; however, in the previous example, parentheses do not act as a statement stop, nor the bindings. so behavior is undefined (except this particular example would be pretty ubiquitous if I had to guess). Statement pointers are an amazing aspect of c, that I would recommend looking into if you want to be a great programmer in c. 
They are a tool used by the compiler to determine which statement should be executed in what order. I've often heard them called sequence pointers, which is what I have found it mostly called in literature, but my prof that worked with me on my compiler called them statement pointers so I've gotten in the bad habit. 
I think you are more confused than your audience.
https://github.com/adjust/pg_c_dev/raw/master/slides.pdf
Thanks again very helpful ✌️✌️✌️🙂🙂🙂😊😊
if dual booting Linux isn't an option for you, have a look at https://docs.microsoft.com/en-us/windows/wsl/install-win10 which lets you install a rather better unix like front end than cygwin. find a decent text editor you are comfortable with to make an executable you first need to create a c source file you might name it for example main.c once you have saved your code, using the command line move to where you have saved the file (look up the cd command) assuming you have installed gcc gcc main.c -o main.exe above all read, and search the internet, as and when things occur to you, and you could do no worse than learning how to use Unix like system like for example Linux as it will generally improve your skills and improve your understanding... good luck!
"vectors" re just straight up retarded. it's a fucking array. linked lists are easy enough to implement, that it'll take you an hour to make your own, optimized for the problem you're solving, instead of some one size fits all bloated piece of shit.
I did that a bit (then came back because it doesn't really offer anything I can't live without, tho operator overloading would be nice). the transition is pretty easy, classes are basically just structs with functions inside them (which is why your executable has grown 3 times) the only thing I wasn't able to wrap my head around in the weekend I partially reimplemented one of my projects, was templates, those are some complicated motherfuckers.
Nigga would it really kill you to stop putting random abbreviations all over the place? You saved a total, of like, 6 characters...
If I just need a generic container of indeterminate size I typically use a dynamically allocated array (vector). This is partially because allocation and reallocation is simpler, but also because traversing the array is faster. The only time I would consider a linked list is if I know I'm going to have to do a lot of insertions or deletions at arbitrary points in the list, but even then I'd have to consider the rest of the use case for it. All that being said, there's a world of value in learning how to properly design both a linked list and a vector. Even if you end up using one more often than the other, it's never going to hurt to have both. You could certainly find a worthy implementation floating around github or similar, but I find more often than not that if you're programming in C it's better to roll your own. Hope that helps!
The easiest thing for you to do is download Visual Studio 2017. Get the free community/single dev edition (I forget it's exact name) and install just the C++ dev stuff. That'll include everything you need. if you have any questions or shit doesn't work after that, it's probably because of microsoft's nonsense, in that case feel free to install Clang/C2 as it's called in the feature selection page of the VS installer.
Is there a way to make it output leading 0's instead of spaces?
Don't worry so much about memory allocation. On a 64-bit machine, a simple linked list structure with just two pointers (one to the data and one to the next element) will be 16 bytes, which is commonly the smallest allocation unit for a slab-type allocator, which means allocation is very cheap. You can embed the next pointer in the data structure instead, but then each item can only be in one list at a time, or you have to include a next pointer for each list it's going to be in.
Stop spamming this already.h
do you use a specific implementation, a library or header file?
No. I implement this ad hoc every time I need it.
&gt; factor of Φ which is 0.5 × (1 + sqrt(5)). Dat fib sequence Why not 2?
Most people don't have problems with C++ execution-performance wise but with the language itself. Compared to the clean design of C, C++ looks like a patchwork and clusterfuck of "fixes" and "features" and many cases of "not a bug, it's a feature!". A very incomplete list of things that suck: * templates are the worst way to implement meta-programming and generics, they are ultra-powerful (arguably unneeded powerful) but crazy. Just look at the error output that fills your screen when making one typo at using a boost library... * also templates: Templated things have to go into the header. Because the users of these things need to know about it. This... sucks. It may be the best way to implement it ontop of something that's roughly C -- but then they should've killed the pseudo C compat altogether. But *then* nobody would use C++. * The syntax of most modern features (eg. lambdas, "`=0`", ...). * Compile times -- again, because of the C heritage * Unparseable. The syntax is crazily complex. Shitty for humans *and* compilers or linters or ... Much stems from the fact that it's a horrible mix of C and some language that's so "modern" that it has to embrace every trend in programming paradigms. C syntax and toolingwas designed well and precisely for a C semantic and usage. Anyone changing these concepts heavily (as C++ does) should also change the syntax and things like eg. how you "include" a header file, possibly replacing it with a module system (which they are *trying* todo in the next years... decades after the release of C++). Virtually any modern compiled language is better for the job than C++ -- but they don't have the libraries. The "environment" is what keeps this monster alive. And the belief of some code-monkeys, thinking "C++ is C improved". It's not. They are different languages for different people.
I wouldn't characterize dynamic arrays as bloated, maybe [this benchmark](http://coliru.stacked-crooked.com/a/80d91e109ea0a643) can convince you? Personally I think that linked lists are almost never 'optimized for the problem you're solving'.
Idk about the java part, but learning C before C++ is a great idea. I originally struggled to learn C++ and gave up after a couple weeks, moved to C, and when I came back (not that i'm really "back" but i have half a clue what i'm doing in it now) it's much easier to understand. That said, i still don't have the foggiest idea how to write a template.
Just stick a `0´ in there before the length but after the alignment. printf( "%012d %012d %012d\n", a, b, c);
The golden ratio naturally appears in a number of systems, not just the Fibonacci Sequence. Moreover, it has the interesting property that Φ^2 = Φ + 1 (the proof of which is trivial). This allows for the growth of an array at increasing powers of Φ to be calculable in both polynomial and linear scales with relative ease. Some people prefer this for its versatility, and some of use just like being math nerds.
If you grow by two, you will create holes in your heap, because you cannot reuse previously allocated blocks, even if they are next to each other. Growth by 2: [ 4 ] [ 4 ][ 8 ] [unus][ 8 ][ 16 ] [ unused ][ 16 ][ 32 ] Growth by 1.5: [ 4 ] [ 4 ][ 6 ] [unus][ 6 ][ 9 ] [ unused ][ 9 ][ 12 ] [ unused ][ 12 ][ 18 ] [ 27 ][un][ 18 ] 
&gt; it has the interesting property that Φ^2 = Φ + 1 x=2 satisfies the amazing equation x^2 = x + 2! &gt; allows for the growth of an array at increasing powers of Φ to be calculable in both polynomial and linear scales with relative ease What do you mean by that? I'm familiar with math terminology but never heard of 'calculable in polynomial/linear scale' 
i send you a pm
Good and old fixed-size array, *mostly*. For example, I'm working on a game, and having a fixed limit of objects that a scene is good practice. My program shouldn't grow infinitelly. If I really need more, I will increase the size of the pool in the source code. In this case, I also don't care about reordering objects in the array, I just parse the entire array, and update the objects that are "active". Nowadays, I only use linked-lists when I'm developing GTK+ applications (GList) to keep my code in conformance with the rest of the API.
For performance-sensitive applications where the data will be iterated over in tight inner loops in high numbers it makes more sense to go with a more cache-coherent strategy.
I almost invariably use either a statically or dynamically allocated pool. If I know for fact that the needed number will never grow above a certain amount, and it's not that big, then I'll just have a static array from which allocations are made. Even for linked lists I still just allocate a buffer that should be large enough for almost all cases, to avoid reallocations, and sometimes use prev/next pointers that are actual pointers, and sometimes array indices in the pool - so that I can sometimes have an API with an opaque type that keeps the code all self-contained in the corresponding C files. Performing many malloc() and free() calls on tiny pieces of memory can lend itself to memory fragmentation, which means your program will consume more and more memory even if you're freeing what you're not using because you start forming bubbles that aren't big enough to allocate from, so new allocations must be made at the end of the heap causing the heapsize to grow. Also, in programs that must be highly optimized and perform a lot of work in tight inner loops (i.e. iterating through the list hundreds of millions of times per second) cache misses can play a huge part in bogging down performance tremendously, and so it makes more sense to have as much of your data packed together tightly in memory, such as with an array, instead of many tiny allocations spread throughout memory. I pretty much always go with just a fixed poolsize unless the data I need to work with is super huge (at least hundreds of megabytes) and going about dynamically sizing the pool is a must. EDIT: I *never* do individual allocations for nodes anymore. Maybe I conveyed as much, but that's only something I ever did super early on learning to code.
very cool. never occured to me how easy it could be.
Do you think you could put a gist up so I could see an example?
Sure thing! [This is from some code I currently work on](https://gist.github.com/fuzxxl/125cde1f20583ca5f2e8bface7088b42). 
If I need to keep things in a list it's usually in a list from `sys/queue.h` which is available from any reasonable BSD-influenced system (or just a local copy which I have pretty much everywhere). Generally I rarely have a use case for "store this thing I can't modify" types of interfaces, but I very often manage my own structs and to store them in any other way than inline would be a crime. No allocations, no screwing around. The macros are a bit of an eyesore, but you get used to them. struct thing { int stuff; const char *other_stuff; TAILQ_ENTRY(struct thing) list_link; }; TAILQ_HEAD(,struct thing) queue = TAILQ_HEAD_INITIALIZER(queue); void code(struct thing *thing) { /* ... */ TAILQ_INSERT_TAIL(&amp;queue, thing, list_link); /* ... */ } For arrays, or vectors as the kids call them, I use an array and realloc. No reason to make things complicated. There's almost never any reason to design an API around putting a thing into an array. Just put the thing into an array, don't add 15 seconds compilation time for 50 thousand lines of generics if what you mean is `if (off == sz) { a = realloc(a, sz += sz?16:sz/2); } a[off++] = thing;` (usually a, sz and off are in a struct and have better names and it's pretty ugly to squeeze in everything on one line). Of course, in C++ I drink the coolaid and use STL like mad since it's included anyway, but in C there's really no reason to make things complicated.
&gt; I'm familiar with math terminology but never heard of 'calculable in polynomial/linear scale' these two things do not fit together in the same sentence
I think C can get you wherever you need to, you can actually achieve anything through it. It's true that it;s sometimes get a bit too complex which makes it vulnerable to bugs and errors that are hard to be detected. There programs that help with it, such as checkmarx and other equivalents but a lot of practicing can help you achieve the results you want.
I did already with not the best results seeing as they all use ladder logic. My reasoning was that because its running in VS maybe someone here would know.
Well if i understand him correctly, what he's saying is true for any algebraic number. Take the polynomial of the number and write the highest power in terms of the others. If the polynomial is of order `n` then any power of that number is an affine combination of the first n powers of it.
Sorry friend. I hope you get it worked out, but it's just not specific enough to apply in this sub.
This is a good answer. Very good, indeed. Just one addition: &gt; the limit on this if you were wondering quickly approaches 50% of available memory as iterations increase. Note that all of this + my scenario is only true for an overly simplified implementation of malloc. For example, glibc will switch to page based allocation at M_MMAP_THRESHOLD ~ 128 KB. Then things start to become ~~more complicated~~ simpler.
Thanks! I meant to ask about your implementation example and how standard it was, but I got a little sidetracked. Aside from source code could you suggest specific resources for learning models like the one you describe above? 
&gt; You're not wrong to say that 22 = 2 + 2, but that is a result of the definition of squares (22 = 2 * 2) and the special property of 2 that 2 * 2 = 2 + 2. Uh yeah it's a result of the axioms of the field of real number and the definition of squares lol. So is the fact that the number (1+sqrt(5))/2 is a solution to x^2 = x + 1. &gt; You are wrong to conflate these properties as mere properties of numbers, as these properties are distinct to these two numbers respectively. What? &gt; I leave this as an exercise to the reader, but it can be shown that for any positive, integral power of k Φk can be written as F{k}Φ + F{k-1} where F{k} is the kth entry in the Fibonacci Sequence (Hint: use mathematical induction). As such, the golden ratio is a prime candidate, because for the kth iteration of growth there is a linear function of Φ that is equivalent to Φk. Yeah, i said below *any* power of an algebraic number can be represented as a combination of its first n powers. For Φ the coefficients of the comb are F(k) and F(k-1). You can do this for any polynomial eq. Here's for the one i gave for 2: 1. x^2 = x + 2 2 Say x^k = a(k)x + b(k) 3 Find a(k) and b(k) knowing this must hold for any k &gt;= 0 by multiplying with x and matching coeffs we have a system of linear recurrences, solve those to find a(k) and b(k). I'm not gonna do that here because it's not worth it .... =&gt; a(k) = 2^(k-2), b(k)= 2^(k-1). So x^k = 2^(k-2) x + 2^(k-1) . The sequence 2^k is for 2 what the the Fibonacci numbers are for Φ. Yes it's silly that those coefficients are in terms of 2 itself! But so are the Fib numbers in their closed form: F(n) =(Φ^n - conj(Φ)^n )/sqrt(5). What i'm saying is that the fact Φ^k has a linear equation in terms of Φ is of no importance. Undoubtly using 2 as a ratio is gonna waste more mem in some cases, if you only use 2^n + 1 bytes then you've wasted 2^n - 1 bytes because you allocated 2^(n+1) . &gt; The difference here though is that 2 is a member of the rational numbers whereas Φ is not; this means that there are no rational numbers that can represent Φ and as such it is a better placeholder than 2. What? Where did this come from? 
C is a language. C++ is a language. "C/CPP" is not. Pick one. If it's C++, see the sidebar on /r/cpp_questions. If it's C, K&amp;R.
21st Century C
sick project
https://www.codingame.com/start
The only license
Can you please explain this better? Are you talking about realloc? I'm a little lost on your second table of 1.5 growth.
Thank you 
Could you just go through all the elements of the matrix and check if the element on the opposite side of the diagonal is the same? For example, the conditional statement would be something like: if ( matrix[i][j] == matrix[j][i] ) { continue; } else { // unsymmetric elements break; }
Unfortunately I don't think so, I'm from Sweden! Now if you are too then perhaps ;)
&gt; Aside from source code, … No idea. I learned this the hard way, going through other peoples code (eg. libarray, dietlibc, libstdc++). „To become a good programmer you have to first and foremost become a good reader.“ ­— Mark Twain.
I would recommend on practicing as much as you can, as C, with it's complexity, tend to make a lot of problems. Errors and bugs rise and they are very hard to be detected, and although there are progrms that helps with it, such as checkmarx, is it very important to practice a lot, as much as you can.
Australia! :P
Then the probability is low to undefinable low :p Never been to aus. I dl'ed the rest of the books you posted, php, js, bash and so on Got to say it again, You da real MVP!
This looks really nice.
What's the issue with the MIT license? 
there are 4 types of open source developers that stratify into 3 parts of the open source spectrum. A) the AGPL types: these are thieves that are trying to make a business model out of open source. they are assholes and they know it. idiots use AGPL code because they have no clue, thus becoming part of the asshole industrial complex. B) the gplv3 types: these are idiots who think they have it all figured out. they are assholes without knowing it, but they are still part of the asshole industrial complex. C) the lgpl/gpl2 guys: these guys have the correct general idea about things when it comes to software but when it comes to the law they think bloated nonsensical comformity to madness is a great fucking idea.they think licenses are there to protect code from humans. this is fucking stupid. they watch too much startek and they are larping a fantasy. they arent assholes, theyre just annoying retards that happen to be unintentionally supportive of the asshole industrial complex. D) the BSD/MIT types: almost all of the useful code in the world comes with this license because computer science has nothing to do with the law and the copyfree licenses are there to protect the programmer from stupid humans. they are the last beacon of hope against the asshole industrial complex and they are immortal because their code shall live for ever. 
Reallocate does the memcpy internally. Also that code is missing error checking. 
Fuck you.
Note that you could already fit the 18 sized block into the space provided by 4 + 6 + 9.
Falls wir uns mal wieder auf dem Congress treffen sollten, bekommst du dafür wieder ein Bier. ☺
Ok. Da freu ich mich schon drauf! RemindMe! 24 Dec 2018 "Bier von /u/kloetzl"
I will be messaging you on [**2018-12-24 14:53:49 UTC**](http://www.wolframalpha.com/input/?i=2018-12-24 14:53:49 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/C_Programming/comments/7peu77/linked_list_vector_what_implementation_do_you_use/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/C_Programming/comments/7peu77/linked_list_vector_what_implementation_do_you_use/]%0A%0ARemindMe! 24 Dec 2018 ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dsirb5i) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
As for a beginner, I tend to suggest to keep practicing until you're close to perfect ( as much as possible) because C tend to be very complex which makes errors really hard to be detected after programming. And unless you use some of those programs, such as checkmarx, It is very important to make sure you have as less bugs as you can, for you own safe. Good luck.
I think that as a beginner you should practice a lot. Try some projects among the web, things like sorting and so. Make sure you learn well before you jump to bugger projects, as C is very complex, and with this complexity, every bugs becomes a hard job to detect. Although there are programs that helps with it, such as checkmarx, it is important to make sure you know as much as you can and it's going to save a lot of your time. Good luck.
Yeah, it does, thanks so much for the write up! I think I'll progressively learn what's taught in my college and knock out two birds with one stone. Unrelated. If I wanted to work as a quant/work with large sets of data in general, what language should I aim to learn? I'm currently e joying C a lot so I think I'm gonna stick with it for 6 months atleast, but what should I try for after that?
Fuck the downvotes, this is real truth
Here's some feedback. For the implementation, I just scrolled through, finding low-hanging problems. [`CMakeLists.txt`](https://github.com/Gikoskos/simbly/blob/master/CMakeLists.txt) * `target_compile_options(simbly PRIVATE -Wall -Wextra -pedantic)` And you just assumed the compiler is a gcc-compatible compiler. Move this with an `if` checking the [`CMAKE_C_COMPILER_ID`](https://cmake.org/cmake/help/v3.0/variable/CMAKE_LANG_COMPILER_ID.html) if it is a `GNU|Clang` compiler. * `target_compile_options(simbly BEFORE PRIVATE -O3)` See above * `target_compile_options(simbly BEFORE PRIVATE -g)` CMake already defines `-g` when doing a debug build with a gcc-compatible compiler. Also, there is [`CMAKE_C_FLAGS_DEBUG`](https://cmake.org/cmake/help/v3.0/variable/CMAKE_LANG_FLAGS_DEBUG.html) for the debug build-type. * `target_compile_definitions(simbly PRIVATE "_GNU_SOURCE")` And you got glibc lock-in. Maybe you want to use one of the POSIX defines ([`_POSIX_C_SOURCE`](http://man7.org/linux/man-pages/man7/feature_test_macros.7.html)), if you don't use any GNU extensions. * I'd say having errors "hanging off" in the `else`-part is not very good "programming", instead replace it like `if(HAVE_GET_NPROCS) message(FATAL_ERROR "xyz") endif()` just before the "main" block, so the script exists early and you save some indentations. * CMakes `FindThreads` can also find thread libraries that aren't pthreads. Check [`CMAKE_USE_PTHREADS_INIT`](https://cmake.org/cmake/help/v3.0/module/FindThreads.html). * Link to [`${CMAKE_THREAD_LIBS_INIT}`](https://cmake.org/cmake/help/v3.0/module/FindThreads.html), since `Threads::Thread` seems to be a [CMake 3.1 addition](https://cmake.org/cmake/help/v3.1/module/FindThreads.html), but you say your CMake file is still made for CMake 3.0.2. Update the version, or use the variable. * Also, while not strictly `CMakeLists.txt`, in your [`README.md`](https://github.com/Gikoskos/simbly/blob/master/README.md) file you say to build use `make`, however the correct cross-platform command is `cmake --build ..` (`--config Release` optional for multi-config build systems) [`src/common.h`](https://github.com/Gikoskos/simbly/blob/master/src/common.h) * You use `/* xyz */` for the first comment, but suddenly use `// xyz` to comment for the rest of the file. (inconsistency) * The `TERM_`-macros indicates you require a ANSI-compatible term, which not all might do (e. g. CMD for Windows &lt;10) * You include `voids.h` like it is a system header file `&lt;&gt;`, but it should be just a normal file (`""`), since it isn't a default header file. * I wouldn't consider the many includes from standard stuff be good for an "global" include file. [`src/error.c`](https://github.com/Gikoskos/simbly/blob/master/src/error.c) * Do do you put the `TERM_`-macros into the string at runtime and not a compile time? (Like `TERM_BONW "Failed call:..." TERM_RESET TERM_BONW "on condition: xyz" TERM_RESET `) [`src/exec.c`](https://github.com/Gikoskos/simbly/blob/master/src/exec.c) * Beginning at line [517](https://github.com/Gikoskos/simbly/blob/master/src/exec.c#L517), there is a commented out function. Why not let it stay there or surround it with `#if 0 ... #endif`? (And then I got bored of reviewing... sorry)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Gikoskos/simbly/.../**CMakeLists.txt** (master → d8a6608)](https://github.com/Gikoskos/simbly/blob/d8a6608e4a4d68ce9cdd161baec7dc3d991c084b/CMakeLists.txt) * [Gikoskos/simbly/.../**error.c** (master → d8a6608)](https://github.com/Gikoskos/simbly/blob/d8a6608e4a4d68ce9cdd161baec7dc3d991c084b/src/error.c) * [Gikoskos/simbly/.../**README.md** (master → d8a6608)](https://github.com/Gikoskos/simbly/blob/d8a6608e4a4d68ce9cdd161baec7dc3d991c084b/README.md) * [Gikoskos/simbly/.../**common.h** (master → d8a6608)](https://github.com/Gikoskos/simbly/blob/d8a6608e4a4d68ce9cdd161baec7dc3d991c084b/src/common.h) * [Gikoskos/simbly/.../**exec.c** (master → d8a6608)](https://github.com/Gikoskos/simbly/blob/d8a6608e4a4d68ce9cdd161baec7dc3d991c084b/src/exec.c) * [Gikoskos/simbly/.../**exec.c#L517** (master → d8a6608)](https://github.com/Gikoskos/simbly/blob/d8a6608e4a4d68ce9cdd161baec7dc3d991c084b/src/exec.c#L517) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dsj0xmb.)
Here's a sneak peek of /r/downvotedbyretards using the [top posts](https://np.reddit.com/r/downvotedbyretards/top/?sort=top&amp;t=all) of all time! \#1: ["erdogan is better than bin salman"](https://np.reddit.com/r/saudiarabia/comments/78xlaj/4chan_pol_on_mohammad_bin_salman/doxpkm6/) | [0 comments](https://np.reddit.com/r/downvotedbyretards/comments/79086b/erdogan_is_better_than_bin_salman/) \#2: [programming: "for now you should write ANSI-C (c89) code for portability."](https://np.reddit.com/r/C_Programming/comments/6jie1h/next_c_standard/djep6hj/) | [0 comments](https://np.reddit.com/r/downvotedbyretards/comments/6jx68w/programming_for_now_you_should_write_ansic_c89/) \#3: ["computer science has nothing to do with the law and the copyfree licenses are there to protect the programmer from stupid humans. "](https://np.reddit.com/r/C_Programming/comments/7pkkx3/created_containers_library_using_c/dsinjc9/) | [0 comments](https://np.reddit.com/r/downvotedbyretards/comments/7ppsov/computer_science_has_nothing_to_do_with_the_law/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/downvotedbyretards] ["computer science has nothing to do with the law and the copyfree licenses are there to protect the programmer from stupid humans. "](https://www.reddit.com/r/downvotedbyretards/comments/7ppsov/computer_science_has_nothing_to_do_with_the_law/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Mixing union accesses like that in general is undefined behaviour. Everyone still does it because it's reliable and predictable in a lot of cases, but it's still UB. I don't think there's anything about array members in particular that would cause more trouble.
Ehm actually, it's a bit more difficult. [Footnote 95](https://stackoverflow.com/a/33633460/417501) allows people to access union members other than the member last written to and as array members are adjacent in memory, the members of `matrix` and `matrix2D` overlap as you might expect and everything works fine. Not even strict aliasing is violated as the types match. Though, the more common approach to this sort of situation is to realize that `matrix2D[0]` is the same as `(int *)matrix2D` and can be used to access all array members of 2D array in a linear fashion.
My man!
I guess my point was that the reduction I performed on Φ is something that can be done without anything beyond the formulation of a rational field. At the point of using a real field you can reduce the problem further to the point of absurdity that is obviously achievable for 2 within a rational field. But, why would you? You're right to point out that the reduction isn't something groundbreaking, and I never really meant to tout it as such, but Φ provides a wider array of tools in a limited format than 2 does. I think that's a completely reasonable justification to use it as a growth factor over 2 or most other values between 1 and 2 for that matter.
Are you looking for this in C (this subreddit) or C# (which your post says)? Either way the answer is similar. You know how many loop iterations there will be, which means a `for` loop is best suited for this task. That should get you started. 
C# is off topic in this subreddit. Please post C# questions elsewhere.
depends on sizeof(int) and word alignment of the system I think
C#
This is perfectly fine, what exactly did you think might be undefined? 
Not really sure, I was just told it was.
It's unnatural. The only kind of union arrays should have is with Christ. I am the vine; you are the branches. Whoever abides in me and I in him, he it is that bears much fruit, for apart from me you can do nothing. — John 15:5
made me exhale air out of my nose more than I normally would. 10/10
Thank you!
I believe identifiers starting with two underscores and identifiers starting with one underscore and a capital letter are reserved, but not identifiers starting with one underscore and a lower case.
&gt;offset and space seems like a really unfortunate choice of names. Maybe length and allocated_bytes would convey their meaning better. Also, why are they ints? data_size is the size of bytes per element, offset is the current amount of elements, size is the capacity of the array before needing to be resized. Thank you for pointing this out, and I will change the variables names to be less confusing. &gt;I don't like that I have to go through a pointer to even get the length of a vector. I make it so you have to call the vector_size to get the size. This is to discourage the user from changing attributes of the struct because then my invariants would no longer hold. &gt;Why do you take the size param as const? Also, you forgot to check for a negative size, leading to UB. This is an internal function called from the vector.c file. Any function which calls this and is exposed in the interface verifies that the size it is calling this internal function with is valid. The size variable specifies how many elements to resize the vector to.
[C11 draft section 7.1.3](http://port70.net/~nsz/c/c11/n1570.html#7.1.3): All identifiers that begin with an underscore are always reserved for use as identifiers with file scope in both the ordinary and tag name spaces. 
Yeah I read section 7.1.3 and it seems to me that if I declare it in a function I can use _var_name, but if it is outside of a function I cannot. To be safe, I will just never start identifiers with an underscore.
it doesn't. but for example if sizeof(int) is 2 and the architecture is 4 aligned, sizeof(int[2]) could be 8 instead of 4
This sub is for C...
&gt; But even that isn't quite clear: what happens if the objects have two different sizes (an int and a double, maybe)? Is it defined which bytes you get? To use the example of a 4-byte int and an 8-byte double, after writing the int, the 4 bytes of the double not shared with the int take on unspecified values. From C11 6.2.6.1#7: &gt;When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values. This, however, is different from saying that the double as a whole takes an unspecified value, which is a common misinterpretation I've encountered and which would rule out the trap representations mentioned in footnote 95, given that an unspecified value must be some valid value and not a trap representation. What actually happens is that the double as a whole takes an indeterminate value, and an indeterminate value is either an unspecified value or a trap representation. This terminological distinction matters because it's the trap representation that introduces the potential for undefined behavior.
Why do you need someone to recreate this game for you? Can't you just play the original game?
Well, then better start learning! You are supposed to do school work on your own to show that you learned something. That's the whole point. Paying someone else to do it for you won't help you understand the subject and usually won't help you pass the course either; teachers can usually see that it wasn't you who wrote the code.
There's xscorch but it's an X11 game.
I know I know Every single work he give to us I did and I understood to that "problem" But now he give us "hard" projects And whole class have problems to do complete project. We didn't do anything with mapping map in console. 
Where? 
Then find out on your own how to do that. You can use the libSDL (use Google to find documentation) to draw things on the screen.
There aren't any more tips I can give. Use SDL to read input from keyboard and mouse and to draw things on the screen, that's about it.
Google.
Ok thanks a lot BTW can I then send you the code so you can tell me what would you rewritten etc.? 
You can post your code here and we can as a community review it. However, I am not going to help you review code in private as it is very important for me that every review I write and every help I give is useful to all people who have the same problem you have, and not just you. If you are not allowed to post your code, there is unfortunately nothing I can do.
Of course I'll post it normally there and no in private :) 
In that case, I am happy to help you!
I recommend you to avoid the acronym UB; it is ambiguous and can stand for either *unspecified behaviour* or *undefined behaviour,* the difference between which is significant. Also, it's very confusing to use acronyms like this when talking to people not closely familiar with the C standard.
I'm not going to debug your code for you. 
Untested fixes: * **fillRandomWords():** Replace the erroneous `return (char)r;` with `puzzle[i][j] = r;` This is why you can't seem to fill the entire array. You're not actually storing anything to replace the space characters. * **fillPuzzleWithWords():** Get rid of `fillRandomWords();` You already call this in main(), and the three word-fill functions aren't going to work properly if you call it too early. * **putHorizzontalWord():** Change `rCol + strlen(word) &lt; 10` to `rCol + strlen(word) &lt;= 10`. This is safe. For instance, a 4-character word starting at array column 6 yields 6 + 4 == 10, but the array columns used are 6, 7, 8, 9. * **putVerticalWord():** Change `rCol + strlen(word) &lt; 10` to `rRow + strlen(word) &lt;= 10`. You seem to have copy-pasted and overlooked an edit of rCol to rRow. * **putDiagonalWord():** Change `rCol + strlen(word) &lt; 10` to `(rCol + strlen(word) &lt;= 10) &amp;&amp; (rRow + strlen(word) &lt;= 10)`. A diagonal word requires an overflow check for each dimension. Additionally, you should be more consistent with your use of ROWS/COLUMNS. You've sprinkled a lot of magic 10s throughout the code.
A linked list would do the job. Either use a dedicated structure provided by e.g. glibc, or integrate it into baseBound: struct baseBound { ... struct baseBound *next; }; When you want to add another result from a recursive call you need to be careful: allocating the struct's on the stack won't work for this anymore. Instead you would return a pointer to it and allocate it on the heap: `struct baseBound addrData = (struct baseBound *) malloc(sizeof(struct baseBound));`.
It's undefined behaviour in ANSI C
There's a typo in your declaration; it should be `struct baseBound *addrData`
http://kingjamesprogramming.tumblr.com
[removed]
Thanks for your reply. I'm really muddling my way through with the pointers as I haven't used them much so far in my programming. The only reason I've set this up like this is because it was the only stuff I could find through googling that kinda sounded like what I needed to be doing to get the array of combos to grow as needed rather than setting up a static amount of structs in the array to begin with. What would the correct version of those first 2 lines look like if I were to set up the array and realloc command correctly? 
Please post your code as text, not as an image. I have removed your post so you can try again with your code submitted as text.
 combos * combo = NULL; combo = realloc(combo, numofcombos * sizeof(combos )); combo[numofcombos-1].teamA1 = sorted[0].name;
 float name = (name); scanf("%f", &amp;name); What are you typing for your name?
No problem. Just resubmit your question with code as text. Make sure to read the submission guide.
I will cmd +r and the "Enter your name, weight, and height" question appears, so I enter a name a weight and a height, hit enter, and it comes out with "0" instead of what I entered prior! 
To have a dynamically allocated array, you only need a pointer, not a pointer to a pointer. You allocate the total amount of space needed, then index off the pointer. combos * combo = malloc(num * sizeof(combos)); combo[2] = /* value for third element here */ **edit:** realloc is fine, I just used malloc because I'm on mobile and can't remember realloc arguments offhand.
that comes on there standard in Xcode, should I then go to learnobjectivec for better answers? 
even when I post a weight or height as 6.5 or 145 in the prompt it puts zeros... 
What are you typing for your name? If scanf fails to parse `dandyfagginess` as a floating point number then the characters `dandyfagginess` will remain in the input stream. The program will then get to `scanf("%f", &amp;weight);` which will also fail to parse `dandyfagginess` as a floating point number. `scanf` returns whether or not it managed to read any input. Always check the return value from functions.
so what should I put in so that I can have a name first but still have it push out the weight and height 
To read a string, use `%s` in scanf's format string. Note as well that `name` will need to be a char array, not a float . http://en.cppreference.com/w/c/io/fscanf
I tried putting it as a char and a bunch of error messages kept coming up but I’m going to give the “%s” a try! Thanks you! I’m very new to this!
I am not 100% sure if Apple provides this as an extension to C, but I think this is an Objective C feature for which you can find better help there. But it appears that this is not really part of your problem anyway, so feel free to check out if you get help here.
When I do this the “name” goes NULL
Can you post the updated code?
 void convertData(char name,float weight, float height){ name = name; weight = weight * .453592; height = height * 12 * 2.54; } int main(int argc, const char * argv[]) { @autoreleasepool { printf("Enter your name, weight, and height:"); char name = (name); float weight = (weight); float height = (height); scanf("%s", &amp;name); scanf("%f", &amp;weight); scanf("%f", &amp;height); printf("%c you weigh %.2f kg. and are %.1f cm. tall!\n",name, weight, height); } return 0; } 
This time when I plug in the answers it output, "C" for my name portion, I put in 150, it put 150 and the height was still at "0" 
Here is what it output after running it. Enter your name, weight, and height:Brock, 250, 6.5 B you weigh 250.00 kg. and are 0.0 cm. tall! Program ended with exit code: 0
`name` must be an array of characters. 1 character isn't enough to hold a name. char name[100]; You shouldn't do float weight = (weight); initialising a value with itself is meaningless. `float weight 0.0f` is better/ 
Thanks for your reply! I appreciate you taking the time to help.
I don't see it mentioned in other comments, but for future reference the pointer to a pointer you have in the original code would be the way to go if you wanted to dynamically allocate a 2D array. You would have to call malloc and friends multiple times though; once to allocate the number of rows (an array of pointers), and then for each row you would allocate the number of columns in that row using sizeof whatever type you are storing.
With printf, %c prints a single character. %s prints a string. You need to call `convertData` for it to do something. You call it in the original code, but not in the updated code. But even then it isn't going to do what you want. void convertData(char name,float weight, float height) { name = name; weight = weight * .453592; height = height * 12 * 2.54; } weight and height are local variables. If you change them in the function then nothing happens to the variables in `main`. A better way to do it is by returning the changed value float feetToCentimeters(float feet) { return feet * 12f * 2.54f; }
Yes, because you only have one char. You have to create a char array (name[]) (check the internet for „c scanf char array“) this should provide a correct answer
How do I declare feet so that the math can get done to the feet and lbs 
I got my full name to show up. Thank you so much
[Here](https://classicreload.com/res/scorched-earth.html) is a version that can be played in the browser. Is this supposed to be a text based game? Are you expected to have animations? If this is a pure text program, you could use a 2D array to hold your map. The map would be rendered as ASCII art. If you haven't learned how to control output to the screen, you could just clear the screen and re-draw the map every time the map is updated. I think if you want people to help you, you are going to have to do something more than post do my work for me. 
For games in the terminal you can check out [this repository](https://github.com/stillmotion/terminal-games) for some basic examples. In general you can use commands in your program to clear the screen, move the cursor to a specific X,Y position in the console, set the color of a character and the background, then write a character. You can write your program so that it loops and reads inputs from the keyboard and updates the screen accordingly. Some of the better resources I know of on this subject are unfortunately in Japanese. The Tokyo Institute of Technology has this pdf [テトリスを作ろう](http://www3.nit.ac.jp/~tamura/pdf/tetris.pdf) (let's make Tetris), which goes over how to make a tetris clone inside the console using POSIX calls. There's additionally [this blog post](http://itouhiro.hatenablog.com/entry/20121119/tetris) that go over the concepts behind making Tetris. Though sorry about these being in Moonrunes, some of the code or examples might give you something to go off of. For something like this, find a similar example that you can get started with, and then think about how you can work from there.
&gt; I recommend you to avoid the acronym UB; it is ambiguous and can stand for either unspecified behaviour or undefined No. It's not, it is [widely known](https://en.wikipedia.org/wiki/Undefined_behavior) to stand for 'undefined behavior'. &gt; Also, it's very confusing to use acronyms like this when talking to people not closely familiar with the C standard. There's [Google](http://lmgtfy.com/?q=what+does+UB+in+C+mean).
**Undefined behavior** In computer programming, undefined behavior (UB) is the result of executing computer code whose behavior is not prescribed by the language specification to which the code adheres, for the current state of the program. This happens when the translator of the source code makes certain assumptions, but these assumptions are not satisfied during execution. The behavior of some programming languages—most famously C and C++—is undefined in some cases. In the standards for these languages the semantics of certain operations is described as undefined. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
So when you have arguments to a function like you do, copies of the data are passed to the function, not the actual data. To do that you need to use a pointer. To illustrate my point, add in a printf( "%f %f %f", name, weight, height); at the end of your convertData function. You will see the function changes the data locally to the function but it does not stay changed when the function returns to main. Again for what you want to do you need to use pointers.
Visual studio, Eclipse, Codeblocks, C-Lion you name it...
Try compiling with `-O0 -g` and open it in a debugger.
If you are just starting out, I would recommend not using a IDE and instead starting with a good programmers editor (Atom, Notepad++, Geany, VS Code etc.) and compiling your programs from the command line. For the kind of programs that you will be writing, a IDE does not provide much benefit while introducing the complexity of setting up and learning a complex piece of software. Furthermore, if you start by learning how to build your programs from the command line, you will have a better understanding of the process that happens behind the scenes in a IDE. This will make learning to use IDE easier and easier to trouble-shoot problems with a IDE.
That does look like Objective-C. Make sure you created a "command line tool" project and that you selected C as your language. 
If you think it is beginner friendly to go “just fucking Google it” then you might have not understand what *beginner friendly* means.
It's an acronym, that's what i do when i don't know what an acronym stands for. Is it worth arguing over small stuff like this lol?
Yes it is worth arguing. Definitely.
I just use Notepad++ for all my projects. If you are coming from python with out programming experience in c/c++ your problem probably lies in compiler setup. YouTube as some decent videos on the process, however it is pretty tricky the first time. Mingw(*your PC architecture*) is what you should be searching for.
Please ask Windows questions on /r/windows. This subreddit is about programming in the C programming language, your post is off topic.
I used code blocks as a reasonably simple IDE for starting out when I was at uni. Some of the bigger ones (e.g. eclipse) are better for big projects but not for writing little exercise c code. These days I use vim (which I was using for years like a super simple text editor with a few quirks and have recently discovered is amazing if you know what you’re doing!) 
I'M SO SORRY FOR THE PRINTF STATEMENT IT WAS A JOKE crap um uh how do i delete imgur shit :0 
[(...) = (char *) malloc(...)](http://i0.kym-cdn.com/photos/images/original/001/102/878/396.png)
i enjoy watching the world burn 
This is hard to google as C benchmarking turns up results that have nothing to do with C. Here is a 'google' benchmarking lib that I found: https://github.com/google/benchmark Is this good? Or would you recommend something different?
which one of the methods I posted are your referencing? 
You could take a loot in how to get the system time. Then you can get the starting time and end time. So you can calculate the difference and have the computation time. 
Consider when you eventually have to change the API for a function or method, you can (usually) make the needed changed without breaking backwards compatibility with previous versions. Python also supports decorators that allow you to change a variable access into setter and getter functions, which is useful in cases where the logic grows in complexity it you start needing back end stores. I haven't really used Python 3 much (stuck in 2.7 works for now) but I understand there is improved support for strong typing.
thank you this is very helpful! the only think is it requires a maximum size for not exceeding - should I set an arbitrarily high max value such that the EOF or '\n' won't be filled? 
thank you this is very helpful! the only think is it requires a maximum size for not exceeding - should I set an arbitrarily high max value such that the EOF or '\n' won't be filled? 
thank you this is very helpful! the only think is it requires a maximum size for not exceeding - should I set an arbitrarily high max value such that the EOF or '\n' won't be filled? 
https://stackoverflow.com/questions/253030/best-way-to-format-if-statement-with-multiple-conditions
if (a=3 &amp;&amp; b=4) { //do something only if both conditions TRUE } if (a=3 || b=4) { //do something if at least one condition is TRUE }
Yes, you can use the logical operators AND `&amp;&amp;` or OR `||` to combine conditions. If you want to check that a is 3 and b is 4, do the following: if (a == 3 &amp;&amp; b == 4) Similarly, if you want to check that either a is 3 or b is 4, do the following: if (a == 3 || b == 4) With C (and most likely C++) you get short-circuit behavior. With OR conditions this means that if a is 3 then it will not check b against 4 since enough of the conditions have been met for the statement to be true. Also, be sure to use the relational operator `==` rather than the assignment operator `=` when comparing things. For more specific C++ questions you'll want to look at /r/cpp_questions, this is the C subreddit.
For an if statement, you will want to compare by using two '='. So "if (x == 3) { do something }". If you want to do the something only if both a is 3 and b is 4, then use "if (a == 3 &amp;&amp; b == 4) {something..}". The &amp;&amp; means and, so it checks for a==3, and if thats true checks b==4, and if thats also true, does the something. If you want to do the something if either a is 3 or b is 4, then use "if (a == 3 || b == 4) {something..}". The || means or, so it checks if a==3 and if thats true does the something, otherwise it checks if b==4 and if thats true does the something.
This is not very good. The Haskell lib does this better. It essentially does what you have said repeatedly and calculated the median and reports this. It also reports the variance, gives warnings if that is quite high, and also calculates a mean runtime by disregarding any outliers. This is important for microbenchmarking.
You want to look up logical operations. But I’ll give a quick run down. it’s perfectly possible to have lots of statements in an if using and, or and not. So the if statement for when a AND b = 0 would be (sorry for formatting, I’m on mobile so I don’t know if this will work) if ((a == 0) &amp;&amp; (b == 0)) If you want to say a OR b then use || and if something is meant to be NOT zero then use !=. If each individual statement is in brackets you can chain lots together, and even use brackets to evaluate one set of logical statements. 
Sure i totally get that. But system time is easy 
with what source code exactly? 
Well, if you are using Linux you should take a look at [perf](https://perf.wiki.kernel.org/index.php/Main_Page).
Thats what I tried, but its no good. This is the first exercise...uhh:(
just started. How can you mix ints and floats?
C++ is off topic in this subreddit. Please ask C++ questions elsewhere, e.g. in /r/cpp_questions.
Because the compiler knows how to do the type conversion between ints and floats. It's called an implicit type conversion. That's not what this exercise is about though. If you do 4/3 and assign the result to an int. Then do 4.0f/3.0f and assign the result to a float. If you then print the two results to the screen you'll see they're different. 
Thanks
That's not a good idea.
Why not? It's not particularly hard to write a good benchmarking harness.
Complete loss at this point.
So do you have no coding experience at all? What is this exercise for? Seems like a weird place to start if you're completely new to programming.
 #include &lt;unistd.h&gt; #define P3CODE "import math;r=10;print(4/3*math.pi*r**3)" int main(void) { execlp("python3", "python3", "-c", P3CODE, (char *)0); return 0; } 
The error is in `music.h`, line 6. You have an extra semicolon that should not be there.
But I still get the error on line 9 of main.c
Also semicolon
but shouldn't there be a semicolon after main()? it still tells me "expected ";" before ":" token
Oh you're right! Thanks alot for the help.
Don't use things that aren't in the C standard. If you must use other things, use those in the POSIX standard. If that's not good enough, look for a portable library that hides any OS specific things.
Thanks
You mean besides the fact that it's C++ all the way? You can't even include the library in a C project...
Write OS agnostic wrapper interfaces for things that are not in libc. Here good knowledge is required of what features different operating systems offer. Pick the lowest common denominator among them, then write `#define`s/`typedef`s that expand to the correct underlying data structures &amp; functions of the OS. 
You could use [SDL](https://www.libsdl.org/), it's a cross-platform library that's perfect for making games. It can even be compiled to wasm using emscripten.
Okay. Still looking for a C based library. It's theoretically possible to call Cpp code from C, but that doesn't make sense here. I could use the Haskell Criterion lib to benchmark the C code via the Haskell C FFI. There was an article on that.
Yeah, I kind of overlooked that. Searching for "C" code is a bit harder. 
PS: 'pdqsort' is a drop in replacement for 'std::sort'. So I am goggling C wrappers for that.
This is probably better off asked in a C++ sub. This one is for C.
You should re-read the documentation for fputs().
POSIX extends standard C with several ways to do dynamic memory allocation with stdio. If you are using the scanf functions, you can add the assignment-allocation character *m* to your conversion specification to have scanf allocate an appropriately sized string buffer for you: char *userin; scanf("%ms", &amp;userin); Note that you now need to pass a pointer to userin, because scanf is going to set scanf to point to the newly allocated buffer. open_memstream is another, more universal solution. It lets you use stdio functions like printf and puts to write a string buffer that will be resized as you write: char c, *userin; size_t userin_len; FILE *buf = open_memstream(&amp;userin, &amp;userin_len); while ((c = getchar()) != EOF) putc(c, buf); /* fflush or fclose buf before accessing userin */ Both methods can fail and return error indication, you should handle these in your code. Consult the manual for your POSIX implementation or the POSIX standard itself. You must also free userin when you are done with it.
Use the oldest version of the C standard that can fit your needs. Basically, there's pretty much nothing in C11 that you might need that C89 doesn't have. So don't use the new features if you can avoid it. I'm dealing with this myself right now; I'm porting a bunch of software from Unix to Microsoft C under VS2010. I keep getting burned by features that the authors of the Unix code used that Microsoft's compiler doesn't support. A few things I've bumped my head against: * Declare your variables at the top of a block, not in the middle. Not all compilers let you do declare them in the middle. * I usually use /* ... */ comments instead of // comments because I know they're 100% portable. * Don't use GNU extensions. * Use memcpy() and memset(). Don't use bcopy() or bzero(). * Be careful using functions like strlcpy() or getopt(). For every function you call, look at the man page near the bottom under "Availability" or "Conforming to". I can tell you right now that strlcpy() doesn't exist in older Linux systems. * raj-shanti-kapil's advice is excellent. For example, I never use basename(3) in my code, because you never know what operating system will have it. I wrote my own which I call Basename(). It's like three lines of code and now I never have to worry if it's portable or not. * If you're going to be porting to Windows, be prepared to weep. This is where you really want to keep your os-specific stuff isolated.
As already mentioned, `fputs()` and `fgets()` are not the right functions to use here. Also, while reading and writing to the same file (`"r+"` mode) some "precautions" must be taken: &gt;7.21.5.3 The fopen function &gt; &gt;[...] output shall not be directly followed by input without an intervening call to the fflush function or to a file positioning function (fseek, fsetpos, or rewind), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. https://stackoverflow.com/questions/42046611/reading-and-writing-to-a-file-at-the-same-time-in-c Lastly, you could use `fseek()` to skip the header. At the moment, you skip 10000 * 2 bytes since your buffer size is 2 bytes but you increment the counter only by 1. 
Sorry, I'm new here.
Thank you! :)
Thank you!! 
Thx bro!! 
Not to be that guy but, "resauces"?
 char *file_name = malloc(30 * sizeof(char)); char *filepath = malloc(64 * sizeof(char)); Arguably a style choice, in some cases good for getting a size_t into the calculation, but note that sizeof(char) is always 1, by definition. char glitch; You're better off using an unsigned char for this. Then simply do `glitch = rand() % 256;` later in the code (removing the cast). printf("\nFile name: "); fgets(file_name, 30, stdin); This typically isn't how a filename is passed to a program. It's a burden on the user. It imposes an arbitrarily small limit on the length of an image filename when many POSIX-conforming systems support a filename length of at least 255 bytes, excluding the terminating null. Many images saved from social-media sites, CDNs, and whatnot have a hash-like naming scheme with filenames that would easily exceed your limit. Typically you'd get the image filename from argv[1], which also saves you the hassle of some things to follow. int i = 0; while (file_name[i] != '\n') i++; file_name[i] = '\0'; fgets() stores a newline character only if there's room for one. This code could therefore exhibit undefined behavior, some possible consequences being a memory access violation or corrupted heap data. Look up the strcspn() way of handling this. strcat(filepath, "/Users/&lt;my user name&gt;/Desktop/"); `filepath` still points to uninitialized memory. strcat(), unlike strcpy(), looks for a null character, so this will work only if `filepath[0]` is a null character. On many systems, this will be the case purely as an accidental consequence of how the allocator interacts with the kernel, but you shouldn't depend on that. if ((FP = fopen(filepath, "r+")) == NULL){ I recommend using binary mode even when a system ostensibly doesn't distinguish between binary and text mode. The mode would thus be "r+b". Even better, open argv[1] "rb" and argv[2] "wb" instead of doing an in-place update on the one file. You'll see why in a moment. while (fgets(chunk, 2, FP) != NULL){ if (chunk_counter &gt; 10000 &amp;&amp; rand() % 60 == 0){ glitch = (char)rand() % 256; fputs(&amp;glitch, FP); } else fputs(chunk, FP); chunk_counter ++; } Both instances of fputs() are going to fail to write null characters, and the first instance may write more than you expect. Look into getc()/putc(). There's a more obscure annoyance when you open a file in update mode rather than using two separate files. C11 7.19.5.3#6: &gt;When a file is opened with update mode (**'+'** as the second or third character in the above list of **mode** argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the **fflush** function or to a file positioning function (**fseek**, **fsetpos**, or **rewind**), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. 
Thanks! will try that!
No problem.
Just use an editor like atom and gcc on linux system to start learning, maybe git to organize projects and files. As a beginner all the ide's have to many options and then you have to learn an ide and a new language. When you have complex projects with a big amount of files etc. you can switch to an ide, but for now, go the simple way.
One should have some fun while coding :)
Fair enough :)
Note that you can install clang and GCC for windows because everything else hurts badly.
You've removed the engine?
Very cool stuff. What resources did you use to teach yourself? I'm just starting out in C but this is the kind of stuff I'd like to do one day.
Oh cmon .. I loved that. As well as the UTAH teapot thrown in because no one does anything in OpenGL without the teapot. Speaking of which .. what the hell do we need to issue ye all inclusive magic "make" : LIBS = -Lcandle/build $(shell sdl2-config --libs) -lglut -lGLU -lm -lGL -lGLEW \ -lpng Also what's with the embedded "shell sdl2-config --libs" ?? Damn .. SDL2 is a dependency hell on Red Hat Enterprise Linux 7.4 : --&gt; Finished Dependency Resolution Error: Package: SDL2-devel-2.0.3-9.el7.x86_64 (epel) Requires: mesa-libGLES-devel Error: Package: SDL2-devel-2.0.3-9.el7.x86_64 (epel) Requires: libxkbcommon-devel ********************************************************************** yum can be configured to try to resolve such errors by temporarily enabling disabled repos and searching for missing dependencies. To enable this functionality please set 'notify_only=0' in /etc/yum/pluginconf.d/search-disabled-repos.conf ********************************************************************** Error: Package: SDL2-devel-2.0.3-9.el7.x86_64 (epel) Requires: mesa-libGLES-devel Error: Package: SDL2-devel-2.0.3-9.el7.x86_64 (epel) Requires: libxkbcommon-devel You could try using --skip-broken to work around the problem You could try running: rpm -Va --nofiles --nodigest bloody hell ... I want to compile this .. 
I just force myself into projects, and each year that passes, the code evolves, also, by using third party libraries you start to understand the patterns that make code cleaner and generally better. If you want to improve your C, check out this repo, it has many libraries and resources: https://notabug.org/koz.ross/awesome-c
I never used Red Hat, but SDL2 is always useful to have installed, especially if you plan on developing graphical applications. the teapot was just for loading and physics tests. I have basic GJK implemented.
Pretty easy, since you just need to write a C-compatible header file with the signature you want (`int * sort_int_array(int * array, int numElements)`) with then the call to the C++ method in the impl method. **Header** ``` #ifdef __cplusplus extern "C" { #endif int * sort_int_array(int * array, int numElements); #ifdef __cpluspus } #endif ``` **Source** ``` #include &lt;algorithm&gt; int * sort_int_array(int * array, int numElements) { auto first = array; auto last = array + numElements; pdqsort(first, last); return array; } ```
That's easily avoided by using fgets(buffer, 128, stdin) instead of scanf. My layman suspicion is that you can only abstract your way away from using a fixed-size buffer, not remove the need for one, and even solutions like using POSIX's memstream, the OS is doing your work for you and probably hiding a fixed-sized buffer in there somewhere. In fact if you look at the definition of the open_memstream in the [source for memstream](http://piumarta.com/software/memstream/memstream-0.1/memstream.c), you'll see it allocates a struct which contains a fixed-sized buffer of 4096. Good luck finding answers, I'd be interested to know if I'm wrong and you find a way.
I'm using SDL for threading, input and window creation, if you want to contribute and substitute SDL for OS specific functions but keep it portable to linux and windows, you are very much welcome. What other libs are unnecessary?
Why not just use a profiler?
How do you do that portably with sub millisecond precision? time_t is a standard unix 32 bit, second based system...
Don’t do non standard stuff with the preprocessor 
the “number” variable is a 32-bit signed int. it has a range of +/- 2^31
And can you distribute such executables with bundling a bunch of libraries as well?
If you're opensource you can of course just link the glibc even statically, but yes, you can distribute glibc and link dynamically quite well, IANAL tho. Or use a more liberately licenses libc. On Windows you always need to bundle the Visual C Runtime too, so it doesn't really matter *what* you bundle.
&gt; We can get rid of all this by hashing the keys before we put them in the hash table. I.e. we just apply a hash function hash(key) → k and then use k instead of key as the key to the hash table. &gt; &gt; The only caveat here is that we must hash they key into a large enough key space to be (statistically) sure that we don’t have any collisions, because if hash(key_1) = hash(key_2) we won’t be able to store both key_1 and key_2 in the hash table. Our hash tables tend to be reasonably sized, so a 64 bit hash is enough, but you could go to 128 bit if needed. This means their hash table has a small chance to fail randomly, which seems unacceptable to me no matter how small the rate is. When they solve this problem, they will come back to traditional hash tables with cached hashes.
This: ` int number = 1;` is your problem. `number` is a 32 bit integer here, and overflows inside of the function before you return it as a 64 bit unsigned integer. When working with large numbers like this, it's always important to make sure you start with a long if you plan on ending with a long.
[-2^31 , 2^31 - 1] in two's complement. This gives the odd result that -(-2^31 ) = -2^31.
Looks like it is behaving correctly. 2^32 = 0 because that is an overflow of a 32 bit int, signed or unsigned. `long` is 32 bits in Windows, btw. If you want 64 bits, you should use `long long`. Or include stdint.h and look up how to use that. 2^31 = a negative because you are trying to print 2^31 as `%d`, which is a signed 32 bit int. This value is represented as a 1 in the leftmost bit and the rest 0s. The range of 32 bit signed ints is [-(2^31), 2^31 - 1]. So this looks like -(2^31). If you want to print unsigned, it's `%u` (`%llu` will print `unsigned long long` types).
Thanks. I'm still having the problem. So I attempted to narrow it down by doing this. #include &lt;stdio.h&gt; main(){ unsigned long int x; x = 4294967295; printf("%d", x); }; But my output is -1 
Like I explain in my comment, you are interpreting x as a signed int because you use `%d`. `%u` will fix that.
C doesn't have builtin arbitrary precision integer arithmetic, unlike some other languages. However there are libraries, with GMP being perhaps the most popular, that provide multi precision arithmetic. You could write your own in fact: just break huge numbers into words and apply the standard math algorithms in software. Here's for example a program that computes x^y for the given command line args using GMP: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;gmp.h&gt; int main(int argc, char *argv[]) { mpz_t x; unsigned long e; if (argc &lt; 3) { fprintf(stderr, "Usage:%s [base] [exponent]\n", argv[0]); return EXIT_FAILURE; } mpz_init(x); if (mpz_set_str(x, argv[1], 10)) { fputs("base is not an integer\n", stderr); return EXIT_FAILURE; } e = strtoul(argv[2], &amp;argv[2], 10); if (*argv[2]) { fputs("exponent is not a integer\n", stderr); return EXIT_FAILURE; } mpz_pow_ui(x, x, e); printf("%s^%lu=", argv[1], e); mpz_out_str(stdout, 10, x); putc('\n', stdout); return EXIT_SUCCESS; } Compile with `-lgmp` You can go nuts with GMP and write a program that parses and calculates the result of math expressions given as strings :D 
&gt; No lists, no trees, no strings, no queues, no sets, etc. &gt; We found that arrays and hash tables are the only thing we only absolutely need. lol
%d should be %lu 
Specifically, Windows does that
That's really cool, just something I wanted to do for myself. You could add some other generic data structures like a stack or a queue or anything else that you can think of.
Thanks! I do plan on adding more data structures like stack/queue/priority queue in the near future. 
Hopefully your compiler is issuing warnings. Those warnings probably provide quite a bit of insight into what you're seeing.
512 lines of highly readable C! I was expecting line noise.
When implementing red-black tree, you don't need to keep the "parent" pointer. This saves 8 bytes on 64-bit systems per entry. Similarly, I believe you don't necessarily need `**bucket` in `HashTableNode`.
Looking deeper into it, although it’s true that you don’t need the parent pointer, it does simplify operations and makes them faster. It also makes the API more user friendly because some functions/macros are able to forgo the RBTree parameter thanks to the parent pointer. Overall, this is a trade off between speed and memory. I’m keeping the parent pointer based on the assumption that if you are using a red black tree, you probably aren’t in a crunch for memory. As far as the **bucket pointer in HashTableNode, it is possible to get rid of this. After looking into how this could be refactored, the only caveat is I need to remove one function (hashtable_remove), but the functions hashtable_remove_key and hashtable_remove_all will still exist unchanged. While hashtable_remove is a convenient function, hashtable_remove_key can literally be used everywhere hashtable_remove can be used. As such I’m going to go ahead and get rid of the backwards pointer and this function. Thanks for pointing this out, I will credit ya.
Put 4 **spaces** before each line to format code for Reddit. If you have compiler errors, include them.
error: too few arguments to function call, single argument 'nb' was not specified 
ok i understand, so if i want the code to work must i type and could you please explain what arguments are in short..
I'd say you take a step back and redo your basics. You're attempting recursion while you haven't even yet tried basic function calls and parameter passing.
You could also use qtcreator for generic c++ projects. As anyone else tells you, you might have to learn IDE specific things in addition to c++. So start small to see what's going on behind the mighty IDE. Good luck!
wow well done!
Make a binary tree! https://visualgo.net/bn/bst?slide=1https://visualgo.net/bn/bst?slide=1https://visualgo.net/bn/bst?slide=1https://visualgo.net/bn/bst?slide=1https://visualgo.net/bn/bst?slide=1
Convert the integer into a string!! https://visualgo.net/bn/bst?slide=1
You need to convert the "(" into a string! https://visualgo.net/bn/bst?slide=1https://visualgo.net/bn/bst?slide=1https://visualgo.net/bn/bst?slide=1
 void insert(stack *head, int elem) { stack *newNode = malloc( sizeof(stack) ); newNode -&gt; data = elem; newNode -&gt; next = head; head = newNode; // this does not do what you want it to. } Your insert function tries to update the top of the stack (`head`), by assigning a new value to the function parameter `head` in the insert function. As you're changing a function parameter, the update will not be visible in the main function, and `head` in the main function will always point to the element with data 10. One way to fix this issue is to make the `head` parameter of the insert function a pointer to pointer to stack, which will allow you to update the value of `head` in the main function from the insert function.
This is a really cool project but is really it a software renderer? They initialize SDL with the SDL_RENDERER_ACCELERATED flag. Unless I misunderstood something.
Hey, last two lines of your reply. I believe I am doing that, I understand that function creates it local copies unless and until we use pointers that the change the original content in the main function. ( and I believe I am using pointers here ). And Head parameter is a pointer pointing to the stack, but it is still not updating the value of head in the main function from the insert function. I really thank you for your response. 
To do cross language benchmarks? 
No, 2-pointer rb-tree is not slower. IIRC, you just need a stack to keep track of parents when descending the tree. This barely adds more operations. In addition, cache misses are the limiting factor. Removing a parent pointer won't incur more cache misses. As I have compared 2- and 3-pointer implementations nine years ago, 2-pointer rb-tree is as fast. Major rb-tree implementations such as C++ map, BSD/jemalloc and libavl all use 2 pointers.
What exactly is your problem? Also, you might want to use `qsort()`.
The problem is that I don't know if is my code for scoreboard right and then how to call it from menu to see the scores I have to find what is qsort() 
That isn't fucking source code, it's a word math problem... Did you magically time travel from first grade where you don't know what a word problem is?
Fair enough. I will look into how to implement this later on today when I get the time. 
Hey, thank You. I am able to run the program successfully. I need you to check a similar program. This is the link https://ideone.com/rl4NMR . This program is just an implementation of a linkedlist. No restrictions to insert only on the first position like stack. ( this program does not follow LIFO principle ). I have not used any pointer to pointer in this program. I see no problem in executing this program. Then why I am facing a problem in the original question all above? 
Your linked list implementation is incorrect. Take a look at [this modified version](https://ideone.com/cLLedq) to see why; I've added an additional statement at line 107 that triggers the bug.
Yup, the SDL_RENDERER_ACCELERATED flag gives you memory close to the GPU for GPU accelerated functions like screen rotation, but pixel writing is still done pixel by pixel by the CPU (moving 800x600 pixels alone, without any shading or any extra work, is so slow on the CPU). You're right about the math, it's all CPU and it's comparatively instantaneous compared to the pixel transfer. If you were able to thread this program across 8 CPUs (80x60 box of the 800x600 screen for each CPU) then you'd be getting pretty close to video cards of the early to mid 2000s.
Add a space in the format string: `" %c"` to consume the newline char. Otherwise `c` is immediately set to `\n` because that's what remains in the input buffer after reading the number. 
Oh thanks a lot, it works!
Please read up the submission guide on how to post code
wtf is with all these great projects lately. makes me feel inadequate :'(
wow...thanks!
Looking at the code, it looks exactly like what would be run from OpenGL. So your basically doing what would normally be done on the GPU on the CPU in order to provide or more consistent use experience? Or maybe in the case of 800x600 I guess the cpu is more than fast enough. What's the main reason for making it cpu based?
What year is it?
Deitel and Deitel ​sucks if you ask me. How about K&amp;R's classic [C Programming Language](https://smile.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628)?
K&amp;R every fucking time.
OpenGL is a complex API, relying on hardware external to the CPU. Once you distill something complex and third party into something lightweight and native, people get excited.
Neither of these are really good. Read Kernighan &amp; Ritchie “The C Programming Language.”
You've got *DSL* in readme and *DLS* in description. Nice graphs.
why is everyone suggesting k&amp;r? this sub starts feeling more and more like a cult lol
float isn't accurate enough, use double.
yeah, you are compeletly right. it work. but now, how to know that number is not fit . I mean 4.2 is only 4.200000 right. why it not fit ?
I have another question, when should I use douple or use round
Thanks! Solved :)
It’s not thread safe, but that’s not really a drawback. It doesn’t really make sense to concurrently update the GUI.