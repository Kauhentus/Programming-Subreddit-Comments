And what is the alternative?
You missed out key information. When you try to compile your program, *what happens exactly*? When you try to run your program, *what happens exactly*? For more tips on how to ask questions in a way that actually gets you help, see http://www.catb.org/esr/faqs/smart-questions.html
Putting the final touches on version 9.0 of [MightEMacs](https://github.com/italia389/MightEMacs.git), an Emacs editor designed for speed and ease of learning and use. Has lots of nice enhancements.
They're assuming OP is in an introductory data structures and algorithms class. Which, since it's the end of the semester right now, may well be the case and the OP is looking for a solution to a problem that anyone who has taken the class knows it the Traveling Salesman Problem. If this is a lesser class, it may well be something much simpler than we're assuming. 
C &gt; C++ will this start a war?^/s
Recursively. Even though that doesn't help in any way.
Back in the day, the saying was: Pascal is a squirt gun loaded with distilled water. C is a .45, which by default is pointed at your foot. Which would you give beginners to learn with, and which would you rather have if you had a real problem to solve?
following the unix philosophy and not having a one size fits all tool? if you just can't abide by that, at least use libAV. they've at least cleaned it up a bit.
Yes, but you have to remember these semantics. And you have to remember the semantics of the dozen other combinators you use besides `&gt;&gt;=`. Each one is a little bit to remember and together it's quite much for something that can be replaced with if-statements.
&gt; I want to focus my mental capacity on the logic of my program, not on the subtle behaviour of the error handling monad. I've programmed enough Haskell to be able to appreciate the simplicity of not having to do that. I wasn't talking about Haskell, I was talking in general. My experience is that code in C and Go is harder to read because all those if statements get in the way of the normal program flow and obscure it. Basically, when more than some 70% of the code is error handling boilerplate, it becomes hard to follow the good path. It's like when someone speaks and someone else constantly interrupts them with additions that are technically true but not relevant for you at the moment. 
On the contrary, if only the happy paths are explicitly spelled out, it can become frustratingly hard to assess what actually happens in case things go wrong. Depending on the task at hand, the behaviour in case of failure can be more important than the happy path. This is for example the case in all safety-critical code, in all code that is exposed to the internet (where failure happens all the time and security problems must not be created from incorrect error handling) and all library code (which must make sure that its error handling is flexible enough to all the caller to handle errors in arbitrary ways). Both approaches (hiding the sad paths vs. making everything explicit) have its upsides and downsides, but I have in my ten years since I started programming found, that making everything explicit is so much simpler to understand that the first option is not really an option for me anymore. One reason for this is that with implicit error handling you have to constantly keep in mind all the subtleties of the way your error handling framework works. That's pretty taxing for something you supposedly want to hide away. This effect grows stronger when you frequently have to read through other people's code. Each project which hides away sad paths does so with different conventions and before you can understand the code, you first have to understand the conventions and subtleties of their error handling frameworks. This is often prohibitively taxing and forces you to make do with an incomplete understanding of the logic, which is something I really do not want. With explicit error handling it's always clear what exactly happens. The code is easy to follow as all effects are local and directly tractable. If error handling is explicit, I can read and understand other people's code as well as my own old code quickly without having to check all the time what exactly is happening in sad cases. In practice, explicit error handling is not so bad, too. The trick here is to have one entry point in your program or library where you do all the things that can fail and validate the incoming data, and then you can program the rest of the code in a pretty straightforward manner without too much error handling. Of course, you still have to check for invariants along the way, but you can do so using unstructured assertions (unstructured because they have the non-local side effect of aborting the program) as each assertion hit indicates a programming error as opposed to an external error you need to deal with gracefully.
&gt; Depending on the task at hand, the behaviour in case of failure can be more important than the happy path. The behaviour in error states and corner cases is usually very imporant for the robustness of the program, but is not important when I'm trying to figure the overall structure of a piece of code. Also, I too like when error handling is explicit, but I don't like when the error handling bits occupy disproportionally large amounts of space in the source code. &gt; but I have in my ten years since I started programming found, that ... :D &gt; One reason for this is that with implicit error handling you have to constantly keep in mind all the subtleties of the way your error handling framework works. Yes, but you don't really get rid of that, because with C/Go-style error handling you need to keep checking that each explicit case, each of the dozens of if conditions is implemented correctly. With a product type used instead of a sum type, you need to manually verify in each case that the person used it as if it were a sum type (ie. is not using both fields at the same type). Both of these issues have been a source of problems for me when programming in C and Go. I prefer to learn a bit of theory upfront than having to deal with it over and over again later. However that is not popular in today's times when time-to-market and quick profit is much more important than quality or education of programmers. 
&gt; Also, I too like when error handling is explicit, but I don't like when the error handling bits occupy disproportionally large amounts of space in the source code. They don't actually. In my code (as I tried to say in my previous comment), there is a lot of error handling in the parts that interface with the operating system or the user and then the error handling is very little in the internal modules where I can make reasonable assumptions about the invariants in my data. Of course, you can also write spaghetti code with error handling everywhere, but you can do the same with implicit error handling. Especially exceptions tend to make programmers think that they can just ignore all errors because an exception is surely going to be generated. &gt; :D What sort of argument is this supposed to be? &gt; I prefer to learn a bit of theory upfront than having to deal with it over and over again later. However that is not popular in today's times when time-to-market and quick profit is much more important than quality or education of programmers. I do know a good deal about type theory. However, as every language has different ideas about how to instantiate the ideas behind type theory into its type model, there is a lot of context to learn for every language you want to program in and conversely, for every language you want to read programs in. I rather not want to spend that effort for the umpteenth time.
I recommend King's Book. He is Associate Professor at Georgia State University and teaches as a teacher would do...EVERY detail... It covers C90, C99 as point major differences between those! 
I tried to follow your instructions but each time i was getting some weird results, i tried many times but was not able to do what i need. as the combination of paranthesis, addition and multiplication is complicated and each time i am doing something wrong which is resulting in wrong results. if you have time and is possible for you can you please write me half of the code i mean for tmp13 or tmp24 , which will help me in understanding and writing it in a correct way. Thank you
Nobody is going to try to help answering that question. I suggest you delete it and resubmit with a descriptive subject, and actual content in the question. People don't have time to teach you how to use a game engine. Follow tutorials, buy a book, watch videos for that. But if you have a specific question, people might help. What are you specifically stuck on? What have you already tried? What part of your code do you think is the problem. I personally won't be able to help you as I don't program games. But if you want anybody to help you, improve your question. 
&gt; They don't actually. In my code (as I tried to say in my previous comment), there is a lot of error handling in the parts that interface with the operating system or the user and then the error handling is very little in the internal modules where I can make reasonable assumptions about the invariants in my data. So what you're saying is that C/Go style of error hadnling _is_ hard to read, but that's ok because you're library's core code doesn't have to deal with many errors? &gt; What sort of argument is this supposed to be? Well, what sort of argument was your _"I've been programming for 10 years"_ supposed to be? I've been programming for longer than that but I don't consider either of our year counts to be particularly impressive and even if they were it's still wouldn't be relevant for the discussion anyway. &gt; However, as every language has different ideas about how to instantiate the ideas behind type theory into its type model, there is a lot of context to learn for every language you want to program in and conversely, for every language you want to read programs in. Eh, yeah, but the contexts tend to be pretty similar to each other. If you introduced me to a new language featuring exceptions there probably wouldn't be anything surprising or hard to understand for me unless the language did something very original and unusual. It's not like you're starting completely afresh and oblivious of previous experience with each new language. In fact, with each new language it's more and more like getting familiar with just another library or something like that... There are of course some languages that are particularly hard (like C++ or Hakell) but IMO that's rather unusual. 
Are you aware of whether I have correctly written my code for the 1-d random walk? 
The logic looks fine, but: * You use floating-point arithmetic where integer arithmetic would do fine. * You use way too many parentheses and too few spaces. * Your indentation is inconsistent. * Please don't post images of code.
Thanks very much. With regards to the 1d code I was wondering whether or not the number of walks had been repeated 1000 times for 100 steps and the average x value value against step number for 1000 walks had been outputted correctly. Is that the case?
Cute, but: 1. OP didn't say whether they were supposed to return to the starting point. 2. OP didn't say their professor asked for a general solution rather than just one for the cities on the list. 3. OP didn't say the solution had to run in polynomial time.
I'm starting to wonder whether you're really asking for help with your own code, or for confirmation that a solution you found online is correct.
I can understand why you're wary of giving out help due to my apparent lack of knowledge, but no, I have genuinely written this code and am a relative newbie when it comes to programming. The reason why I am curious about my 1-d random walk code was because I was able to successfully perform the code for 1 walk but when I tried to replicate the code for 1000 walks I received answers that didn't align with what I expected.
I tool a look to comment on it, but you only posted an image of your code, which is not very useful. Either post it inline, correctly formatted, or use a [pastebin](https://en.wikipedia.org/wiki/Pastebin).
**Pastebin** A pastebin (or text storage site) is a type of web application where users can store plain text. They are most commonly used to share short source code snippets for code review via Internet Relay Chat. The first pastebin was located at pastebin.com. Other sites with the same functionality have appeared, and several open-source pastebin scripts are available. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I'm not sure why you think a graph is not the input. &gt; he gave us the task of creating an algorithm to find the most efficient route from the list and to give him the new itinerary. The problem assumes you know the cost of getting from one city to another regardless of the original itinerary. If all you have is the original itinerary then you can't really optimize the solution. Admittedly, Dijktra's algorithm is not the solution but the problem can still be modeled as a graph walk. As others have stated, this is the classic traveling salesman problem and the solution is to find a hamiltonian path through a weighted graph.
&gt; https://pastebin.com/eBCecqvb Code corresponding to the 1-d random walk 
You are reading the real parts of the numbers into an array of doubles in real[]. These numbers are simple doubles. They have no imaginary part. You are reading the imaginary parts of the numbers into an array of doubles in imag[]. These numbers are simple doubles. They have no imaginary part. You combine the real parts and the imaginary parts into fshift[]. Then, you loop over ROWS and COLS, printing the real part of the values in real[][]. But the values in real[][] are double. You can call creal and cimag on them simply because there is an [implicit conversion from double to complex](http://en.cppreference.com/w/c/language/arithmetic_types#Complex_floating_types). You also print cimag(imag[i][j]) but the implicit conversion of some value *x* to complex will presumably generate (*x*, 0i). Calling cimag() on such a quantity of course will produce 0. 
First off, "weird results" does not give me any insight of where you may have gone wrong. Second, seeing as I still don't understand what you're trying to achieve, I cannot really write any correct code for you. I'm gonna try to explain once more, trying to be even more thorough: The order of operations in your situation is really quite easy and as a matter of fact the same as you learned in calculus: In the absences of parentheses, multiplications are evaluated before additions. So, if you have a matrix with `M` rows and `N` columns which is stored in row-major form in a one-dimensional array, int array[M * N]; and you want to access the matrix element in row `i` and column `j` you need to multiply the row index `i` with the size of the row (i.e. the number of columns) `N`, to find the matrix element (i, 0), and then add the column index `j` to get your element, so you have the following mathematical function to calculate the array index of the matrix element (i,j): `m(i, j) = i * N + j`. Translating this into something you can use to both read and write the corresponding element of an arbitrary array you get the macro MATRIX from my previous post (assuming a fixed number of columns `COLS` -- this value was `N` in the previous paragraph): #define MATRIX(arr, i, j) (arr)[(i)*COLS + (j)] the parentheses around `arr`, `i`, and `j` in the macro ensure that if I pass a compound expression as any argument to the macro, the compound expression is evaluated before the array subscript, multiplication and addition. With this macro you can now swap elements of the matrix as follows: // Swap array elements at (d,j) and (d+ROW2,j+COLS2): int tmp = MATRIX(array, d, j); MATRIX(array, d, j) = MATRIX(array, d+ROW2, j+COLS2); MATRIX(array, d+ROW2, j+COLS2) = tmp; 
The input is an unordered set of cities and their geographical longitude/latitute coordinates. Sure, you can create a graph of it as the first step in your program, but it's not the input to your program.
What did you expect, and what did you get? Here's what I get from my own reimplementation of the same logic: 1 0.001 0.225 2 -0.011 0.453 3 -0.009 0.665 ... 98 -0.001 21.483 99 -0.014 21.702 100 0.007 21.989 
Now, I know this is splitting hairs here, but an unordered set of cities and their coordinates is already a graph. The "edges" are implied since I think it is safe to assume you can catch a direct flight between any city pair. The weight of the edges can get tricky but if all we have is the geographic distance between cities then the only thing you can really optimize for is travel distance.
Ah, I was curious as to why the simulation did not result in different vales for each run of the code. I achieved the same values, however I was expecting larger &lt;x&gt; and &lt;x^2&gt; values. 
 double complex fshift[ROWS][COLS]; fshift[i][j]= (creal(real[i][j]), cimag(imag[i][j])); `double complex` makes no sense. this shouldn't compile unless you have `#define complex` And the 2nd line evaluates to the cimag term. The comma there is the comma operator. Show the full program
Why were you expecting a larger *x̅*? It should be immediately obvious that *x̅* will tend towards 0 since the probabilities of going forward and backward are equal.
I'd definitely prefer to use a debugger to inspect values at certain points (making sure they match what I'd expect at that point), rather than muck about with code modifications to try to isolate the problem, and sift through the remainder by hand. The latter sort of feels like adding printfs to check values in the middle of the code make sense -- something that you might resort to if for some reason you can't use a debugger. The debugger has the advantages of (among others) 1) handling some things automatically (e.g., doing the math, running the loops), and 2) showing you the process and results of what the program actually does, rather than what you *think* the program does (that mismatch is... always? the source of any given bug).
I assumed further iterations of the random walk would be required to produce values of that magnitude. 
I'm not sure what you mean by “values of that magnitude”. I tested a single iteration, and the value of *x* never went outside *[-4, 4]*.
Yes, but each x value at each step is larger by a certain factor. Essentially, I was questioning as to whether I should be achieving an x value equal to say 0.001 at step 0 rather than 0.01 at step 0. I do understand what you are attempting to convey however. With regards to the 3d random walk I am unsure as to how I may find &lt;r&gt; and &lt;r^2&gt; (assume it may require Pythagoras) , would you potentially be able to help me with that?
Pythagoras twice: * *d_xy = √(x²+y²)* * *d_xyz = √(d_xy²+z²)* * *d_xyz = √((√(x²+y²)²)+z²)* * *d_xyz = √(x²+y²+z²)* 
Thank you very much. I massively appreciate you helping me with this.
[removed]
This line is incorrect: fshift[i][j]=(creal(real[i][j]),cimag(imag[i][j])); In C the expression `x,y` means to evaluate and discard `x`; and use `y`. This is called the *comma operator*. So that code is equivalent to: fshift[i][j]= cimag(imag[i][j])); There may be other problems too, just this one stood out at a quick glance 
&gt; So what you're saying is that C/Go style of error hadnling is hard to read, but that's ok because your library's core code doesn't have to deal with many errors? Yes, when you are deeply familiar with one specific error handling scheme and know its quirks in and out, then it is indeed easier to read than explicit error handling. However, that is rarely the case in real world scenarios where you have to deal with different people using different conventions in different languages all the time, so the advantage isn't really one in real life. &gt; Well, what sort of argument was your "I've been programming for 10 years" supposed to be? I've been programming for longer than that but I don't consider either of our year counts to be particularly impressive and even if they were it still wouldn't be relevant for the discussion anyway. I said “but I have in my ten years since I started programming found...” as a figure of speech. The exact time I'm programming doesn't matter too much, what I tried to convey is that this is the conclusion I draw from the experience I made with different error handling schemes. &gt; Eh, yeah, but the contexts tend to be pretty similar to each other. If you introduced me to a new language featuring exceptions there probably wouldn't be anything surprising or hard to understand for me unless the language did something very original and unusual. Yeah, okay. But how do you find out that the language doesn't do anything weird with their exceptions? You can only know if you start to read the language's documentation and specification. The possibility of quirky behaviour hidden in the language's design introduces complexity I don't want to waste time ruling out. &gt; It's not like you're starting completely afresh and oblivious of previous experience with each new language. Yes indeed, but there is still a lot to understand when it comes to what things are idiomatic and what aren't. Also, you need to learn the conventions of the error handling scheme which if not explicit from the code can differ in various ways. &gt; There are of course some languages that are particularly hard (like C++ or Haskell) but IMO that's rather unusual. Or Rust. Or Lisp. Or Ocaml. Or F#. So generally, all the languages sophisticated enough to support high-level implicit error handling schemes like those you want to use. Go on the other hand is easy enough to pick up and be productive in in an evening.
Please wait at least an hour to answer this one in case OP is still writing the test.
Im practicing for a test this week. This question is from an older test. Sorry If I wasn't clear.
That's okay. However, there have been many people in the past trying this trick and it's always a bit sad to see people cheat. In your case, observe that the type of an array cell is `char` (a character). If you want to print a sequence of characters as a string, you need to take the address of the first character so the function can find where the next characters are.
Remembering those semantics is trivial. Plus you don't have to use all the combinators, just use the ones you want to use, and just like with any language you have to remember how functions that you use work. 
Practical C Programming 3rd edition is also a fine choice. I'm using that in conjunction with the K&amp;R book to learn C.
What do you mean it "will not work"? And there is no call to strcmp in the code you posted.
Cases 3 and 4 are undefined behaviour, and that is the answer you should put The `%s` specifier in `printf` means that you are supposed to pass an address. The behaviour is that the character at that address is printed, and then the character at the next address in memory consecutively after that one, and so on, until a `'\0'` character is reached. When you give `mat[0]` as argument, since that is an array type (the first row), it means `&amp;(mat[0][0])`. (`A` means `&amp;A[0]` when `A` is an array and you use it in a context where a pointer is expected).
Opps, this is slightly edited version. I tried replacing it with strncmp to see if that was the problem. It was not
This is the part where the code seems to always have a problem
What's with all the backticks?
&gt; But how do you find out that the language doesn't do anything weird with their exceptions? You can only know if you start to read the language's documentation and specification. Yes, which I have to do anyway, even with Go. &gt; Go on the other hand is easy enough to pick up and be productive in in an evening. Yes, but then you have to use stuff like `errcheck` because the new guy on the team messed up error handling again (I've seen this happen multiple times in real life). I don't know man, I get the overall sentiment and all, but I'm not really convinced the complexity avoided, seems to me it's more likely just postponed... 
I am new to programming and have asked few questions here before. I am still trying to understanding that formatting for code on reddit
Thank you for your help i solved my problem
I did another way and solved my problem to an extent and got my required result. but the method which you suggested is the one which I like most and I prefer to solve the problem according to that i wrote the following code for (d = 0; d &lt; ROW2; d++) { for (j = 0; j &lt; COLS2; j++) { tmp13 = MATRIX(array, d, j); MATRIX(array, d, j) = MATRIX(array, d+ROW2, j+COLS2); MATRIX(array, d+ROW2, j+COLS2) = tmp13; tmp24 = MATRIX(array, d+ROW2, j); MATRIX(array, d+ROW2, j) = MATRIX(array, d, j+COLS2); MATRIX(array, d, j+COLS2) = tmp24; } } but i was not getting the output matrix shifted and by shifted i mean fftshift where for the case of a matrix 1st and 3rd quadrants are interchanged and 2nd and 4th quadrants are interchanged. the code which i am using to acheive this is below for (d = 0; d &lt; ROW2; d++) { for (j = 0; j &lt; COLS2; j++) { tmp13 = fshift[d][j]; fshift[d][j] = fshift[d+ROW2][j+COLS2]; fshift[d+ROW2][j+COLS2] = tmp13; tmp24 = fshift[d+ROW2][j]; fshift[d+ROW2][j] = fshift[d][j+COLS2]; fshift[d][j+COLS2] = tmp24; } } in this method i had defined fshift as double complex fshift[ord1][COLS]
yah,,, i figured it out and changed it like this and then it worked fine.. thank you
Hey guys, i'm having an issue with printing off some stuff. I'm supposed to be reading in from a text file an entire book (in this case, the book of Dracula) and i'm supposed to process each word. I have a few loops taking care of the line reading and separating of the words (using fgets to get the next line and strsep to parse the line), and the way i have it set up is every time it sees a word for the first time, i insert that word into a hash table. After i insert the word, for debugging purposes, i printf the word that was inserted into the hash table. These are the first two words in the book and on the repeat of the word it prints this little box. It should be skipping this word completely but it is clearly making it into the processing section because that's where the printf("word: %s"); is located. What is this thing and how do i get my program to ignore it? I can post my code if that would help.
void process_book(hash_table *h, FILE *fp, int bookNum, info_t *stats) { char delimit[] = " @#$%^&amp;*+=_|&lt;&gt;``,.-!?;:()\"[]\\\r\n\t"; char line[256]; char *word[256]; book_word *newWord, *found; int i, j = 0; //read one line at a time for processing while(fgets(line, sizeof(line), fp) != NULL) { i = 0; printf("\nLine: %s\n", line); if(j == 100) exit(1); //ingrement number of lines read stats-&gt;lines[bookNum]++; j++; //read until white space is found //bzero(word[i],strlen(word[i])); word[i] = strtok(line, delimit); while(word[i] != NULL) { //increment number of words read stats-&gt;words[bookNum]++; //search for pre-existing words found = hash_search(h, word[i]); //condition for new word if(found == NULL) { //increment number of unique words in individual and both books stats-&gt;unique[bookNum]++; stats-&gt;both++; //allocate space for new word newWord = (book_word *) malloc(sizeof(book_word)); //bad malloc check if(newWord == NULL) exit(1); //insert new data into data block newWord-&gt;word = word[i]; //increment frequency counter if(bookNum == 0) { newWord-&gt;count[0] = 1; newWord-&gt;count[1] = 0; } else { newWord-&gt;count[0] = 0; newWord-&gt;count[1] = 1; } hash_insert(h, word[i], newWord); printf("Word: %s\n", word[i]); } else {//condition for pre-existing word //increment frequency counter found-&gt;count[bookNum]++; } i++; //bzero(word[i], strlen(word[i])); word[i] = strtok(NULL, delimit); } } }
I think posting your code would bring better insight to help you. 
So, if your matrix is defined as `double complex e_m[ord1*COLS]` you should probably use `MATRIX(e_m, d, j)` to access matrix element (d,j) and not `MATRIX(array, d, j)`...
It's some type of non-printable or non-ascii character. To debug, try printing out a hex representation of it instead. If you're doing ascii only, you could do a boundary check on each character. If you're trying to read a different encoding, you might have bad input data.
&gt; following the unix philosophy and not having a one size fits all tool? Except that the UNIX philosophy doesn't always work, because some projects simply can't be written like this. Could systemd have have managed cgroups effectively and efficiently outside of PID1 like everything else? Somehow, I doubt it. &gt; libAV Unfortunately, most distros seem to have chosen FFMPeg. It's always not the technically-superior project that wins, but the more popular one. :/
Great example, systemd, the biggest project to get hated on specifically for not following the unix philosophy. That's literally the reason it's hated so much.
How??
I didn't find remembering the semantics of all the monadic combinators people like to use easy at all because there are so many of them and they differ in more or less subtle ways.
It's very simple: Put four blanks in front of every line of code. Put one blank line between the code and the surrounding text. That's all you need to do.
Reusing your word array for every item you add to that hash table might have something to do with it. It's certainly a problem you'll have later if not here.
How can i deal with that? Should i free/null the line variable before i call fgets for the 2nd+ time?
Store newly allocated copies of strings.
~x is not equal to -x. ~x is the bitwise complement of a and equal to -x - 1 on a two's complement machine. So x + ~x + 1 is equal to x + -x - 1 + 1 is equal to 0.
What does `~x + x` evaluate to?
Thanks! For ~4, e.g. (100)2 ~3 = ~(100)2 = (011)3 But for ~x, I'm not sure how to flip it unlike integers? Also, would the answer be the same if it's an unsigned integer? Thanks! 
Yeah, the answer would be the same for unsigned integers.
Thanks! I was wondering if Also, ~x is always equal to -x-1? And why? 
Can you elaborate on that, please? I attempted what i think you meant and now its splitting words in half and hashing them separately. 
Try to work it out yourself! What happens when you flip all the bits in a number? What happens when you negate a number? 
That did the trick! For this but at least. Going to have to remember that for the future.
Update: Now i have it not reading that non-printable character in anymore, but it is now skipping words that have not occurred yet. For example, when i print the first 100 words that have been hashed, i'm looking through and it is looking at the book's table of contents. Each chapter is in roman numerals, and i'm supposed to take in each roman numeral as its own word. Every roman numeral is reading in as a new word except for "ii". Any ideas?
The code looks, in essence, correct. There are a number of style issues with the code but the code is correct. I was somewhat surprised by the fact that your ad-hoc PRNG generates the right distribution, but it does. As for the style issues, I'd move the PRNG into a separate function, as well as the code for the individual trial (i.e. the loop for m). Last, the file extension ".xls" is normally used for Excel spreadsheets, not tab-separated data. 
Every time you use word[i] it refers to an address in line. What's stored at that address changes every time you call fgets with line as an argument, and when the function exits that memory goes out of scope and can't be used. So you need to allocate a copy of the current string and store that in your data structure.
What are `test.largeWord` and `test.wordCount`? You never increment `wordCount` in your `for` loop. Why don't you use a pointer? For example, struct comp *cp = values + wordCount; cp-&gt;checked = cp-&gt;rankCheck = cp-&gt;rank = 0; ... Much easier and cleaner. If you could edit your post as FUZxx suggested, it would be much easier to follow.
I'd like to see the code of the OP.
oh okay, that makes sense. thanks!
 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; int AlphaDetector(char *Input); int main() { char UserInput[64]; do { printf("Give me some input:"); fgets(UserInput, sizeof(UserInput), stdin); //Reduce redundancy } while(AlphaDetector(UserInput)); return 0; } int AlphaDetector(char *Input) {//Should be called non-numeric counter. int AlphaDetect = 0;//Need int for at least 32 bits and not 8 bits. char Numbers[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; //Don't need to specify size here. //You may want to assert() that Input is not NULL. for(; *Input &gt;= ' '; Input++) { //Break on any character below space. See ascii table. fgets() will put the line feed character at the end before NULL terminator. int NumberCounter = 0; //Limit scope for(; NumberCounter &lt; sizeof(Numbers); NumberCounter++) { if(*Input == Numbers[NumberCounter]) { break; } } if(NumberCounter == sizeof(Numbers)) { AlphaDetect++; } } //Always use brackets for multiline blocks. return AlphaDetect; } 
Return type is `void`, not `void*` void process_function(union sigval val);
systemd wouldn't work as well if it just blindly followed the UNIX philosophy. Neither would the Linux kernel. systemd and the Linux kernel are both better off for NOT following a philosophy that doesn't properly fit all use cases. The UNIX philosophy is best followed by knowing when to apply it and when not to.
This comment `//in**C**rement number of lines read`has a typo and its superfluous. If you really want to use the total of unique words in your stats struct, consider using total_uniques instead of both. What's the purpose of `newWord-&gt;count[i]` ? If you are inside a unique counter why you do `newWord-&gt;count[1] = 0` ? Make sure `hash_insert(h, word[i], newWord)` really copies the word because the pointer at word[i] will go out of scope. After 256 unique words your function starts to write in unlocated memory. This `word[i] = strtok(NULL, delimit);` needs to be inside your else.
Can you give an example? Because I strongly disagree. The ways in which say `traverse`, `fmap`, `&gt;&gt;=`, `*&gt;` and `replicateM` differ are not subtle and also not surprising.
The project is reading in two different files and counting the number of lines read and times a unique word appears in each individual file. Those are just the stats that the teacher is asking for. Doesn't really have much to do with functionality. count[i] is an int array of size 2 that just keeps the unique count separate in my head.
Your programme doesn't do what your blurb says it does. I mean, it just keeps saying "Give me some input" until the input only has numbers. Another point is that just because a character in the input is not a number, does not make it in the Alphabet (or alpha?), so the name AlphaDetect is confusing. Additionally you might want to look at http://www.cplusplus.com/reference/cctype/isdigit/ in &lt;ctype.h&gt; and save yourself a bunch of code.
Oh shit, I'm a dummy. 
I have no expierence with systemd soooo
You need to check the arrays for valid entries. Since you're reading in numbers and it doesn't look like they're bounded you need to have a different way than a special number. You can use a typedef struct to keep track of the number and a valid field. Your arrays would then be of that struct type. 
The small `0001` may mean character value 1 (`0x0001`)
Your function and variable naming game is on point. But you should declare your function prototypes in a header file, or just move the whole function above main. generally main is the last function. One other change I'd make is I wouldn't call strlen in your loop, either use a while loop until you hit the null terminator, or accept the string length as an argument. as it is, strlen is looping over your string until it hits the null terminator itself, and you're then relooping over the same data, cutting it's speed down by half. I'd give it a solid 8/10
backticks are generally just for single lines of code (and short, it'll overflow the screen otherwise) `This string is wayyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy too long for backticks`
`scanf()` returns the number of items that were read in. Check the return value each time you call it, and repeat until it's 1.
........ wow i didn't make that connection. That makes so much sense. 
That's exactly what the blurb says it does
Do not post pictures of code. Always post code as text!
This is pretty half baked advice. Doesn't even talk about wrapping macros in do while.
Depends on size of data type, but result in binary will be all zeroes. ~x is just x where you replace all ones with zeroes, so if you now do addition (binary OR), then in each bit summation, you will get 1 and 0 which results in 1. So for signed type it's -1 (need to do 2's complement) and for unsigned types it's the MAX value of give type which can be reached without overflow.
The article is in several places either incorrect or could use some improvements First off, a macro is created by preprocessor directive `#define`. Not all preprocessor directives are macros. `#ifdef` is used in conditional compilation, `#include` is source file inclusion - those are not macros. Secondly `__FILE__`, `__LINE__`, etc. can be used anywhere, not just in macro definitions, as the article seems to suggest. Obviously this: int foo( const char * s ) { printf("%s: %d - %s\n", __FILE__, __LINE__, s); } int main( void ) { foo("Error"); } will print the file and line of the location of the `printf` call in function `foo`, not the location of call to `foo` in `main`, which would happen if `foo` was a macro. As for debugging macros, you can't step through the expansion, but you can see the final output of the preprocessor, which might make it easier to spot mistakes. For gcc and clang the flag is `-E`, for msbuild it's `/P`. Now in the **foreach** example, why not put the declaration of `curr` inside `for`, to avoid *Pitfall 4*: #define LIST_FOREACH(curr, list) \ for (ListNode *_node = list-&gt;first, *curr = list-&gt;first; \ _node != NULL; curr = _node = _node-&gt;next) Speaking of *Pitfall 4*, the problem is not with the macro containing multiple lines, it's with macros containing multiple statements. Macro in a single line: #define MODIFY(arr, index) arr[index] *= 5; index++; will still break, however if it contains a single statement over multiple lines, it will work as expected #define MODIFY_ODD(arr, index) \ if ( index%2 ) \ arr[index++] *=5; int main ( void ) { int arr[5] = { 1, 2, 3, 4, 5 }, i = 0; while (i &lt; 5) MODIFY_ODD(arr, i); for (i = 0; i &lt; 5; ++i) { printf("ELEMENT %d: %d\n", i, arr[i]); } } I would also include discussion about operators `#` and `##` that can be used in macros. First one converts the macro argument to a string literal: #define PRINT_I(x) printf( #x "= %d", x) int main ( void ) { int i = 5; PRINT_I(i); //Output: i=5 } the other glues two tokens together.
Maybe I'm pedantic, but I'd move AlphaDetector above main to remove the prototype declaration. I'd also make it static. 
No, you should not use 0x30 when you mean '0'. That's bad code. if( value &gt;= '0' &amp;&amp; value &lt;= '9' ) That is the correct way to do it.
Fine. Make an enum, with a variable like ASCIIZero = 0x30 and compare it that way. Using character literals is ugly af.
I think you meant "all ones" in your first sentence
&gt;So here's some context to why I made this little program. &gt; &gt;I'm trying to understand arrays a little bit more and how to iterate through them. I also plan on making a Hangman game in the near future as well. &gt; &gt;This program takes a user's input, checks if there are any alpha characters in the input, if there are, ask the user again to input only a number. &gt; &gt;Here's the code: &gt; &gt; #include &lt;stdio.h&gt; &gt; #include &lt;string.h&gt; &gt; #include &lt;stdint.h&gt; &gt; &gt; int AlphaDetector(char *Input); This line is unnecessary. Define the function before you use it. Capitalizing the first letter is an unorthodox practice. The function name should be a verb like int detectAlpha(char *input); &gt; int main() { &gt; char UserInput[64]; 64 is a magic number. Use a named constant. &gt; &gt; do { &gt; printf("Give me some input:\n"); &gt; fgets(UserInput, 64, stdin); &gt; } &gt; while(AlphaDetector(UserInput)); &gt; &gt; return 0; &gt; } &gt; &gt; int AlphaDetector(char *Input) { &gt; int8_t ArrayCounter, NumberCounter, AlphaDetect, NumberDetect; Why are these type int8_t? You don't rely on them being that size. This is unnecessary complexity. Use `int` and don't include stdint.h. Declare one variable per statement. &gt; char Numbers[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; &gt; &gt; AlphaDetect = 0; &gt; NumberDetect = 0; &gt; &gt; for(ArrayCounter = 0; ArrayCounter &lt; strlen(Input); ArrayCounter++) Why do you you calculate the string length every time? It doesn't change. Why calculate length at all? Take a look at this example: int detectAlpha (const char* input) { int foundLetter = FALSE; for (; *input != '\0'; input++) { int isLowerCase = *input &gt;= 'a' &amp;&amp; *input &lt;= 'z'; int isUpperCase = *input &gt;= 'A' &amp;&amp; *input &lt;= 'Z'; if (isLowerCase || isUpperCase) { foundLetter = TRUE; break; } } return foundLetter; }
No offense dude, but you're the one coming off as a bit hostile. Plus, the other commenter is correct; character literals are the clearest, most correct, and most portable way to go here.
Really? I'm coming off as hostile when you're the one that barged in, randomly started ranting about how your way was right, and are now accusing me of being hostile?
Using variables like "ASCIIZero=30" is the opposite of clear, concise code. I've been writing C code professionally for a VERY long time. I can assure you that I know what I'm talking about here. A quick, obvious sign of an inexperienced C programmer is using magic constants like 0x30, or macros or variables to hide the obvious. Abstraction is supposed to increase clarity - not decrease it. 
You gave bad advice to OP, and then got upset that others tried to help you see why your advice as poor. Bye. 
I'm sure you would ! Its changed since, I've dropped ode for chipmunk as constraining ode to 2d didn't work well with trimesh... I have since added switches, when you put a drum in a switch, it will open a particular hatch (to allow access to other parts of the level), the hatches telescopes open/closed in segments.... might be time to do a progress video soon...
In the comment you responded to I was talking about matrices being defined as 2D arrays, which do in fact require a `memcpy` or similar for copying.
Yes, you are coming of as hostile. Your code was bad, you need to learn how to take constructive criticism... His function and variable naming isn't even very good.
&gt; Yes, which I have to do anyway, even with Go. The point is: If the language semantics used in a piece of code you try to understand are sufficiently obvious to the point where there is clearly no more than one way the code at hand can be understood, you don't need to actually read the language specification to understand what the code is doing. I can just read and understand it without having to get into the language's mindset first.
The 'program' is in my opinion a bit too short to be reviewed, especially if you don't do anything fancy (except checking if an string consist only of digits in an inefficient manner), but I'll do it anyway. You missed to check if `fgets` was successful. It is successful when the pointer returned by it is the same pointer you gave it as the first parameter, otherwise it is `NULL`. (eg. when reading EOF or some other read error occurred) (See [C99 Draft 7.21.7.2](https://port70.net/~nsz/c/c11/n1570.html#7.21.7.2)) Also note that `fgets` also puts the `\n` character when it encounters one (and returns after reading and storing it), so if you input a number less than 64 characters, it would always detect a non-number, the `\n` character. Your `printf` statement doesn't use any formatters and has a `\n` at the end of the string, so you can also just use [`puts`](https://port70.net/~nsz/c/c11/n1570.html#7.21.7.9) or [`fputs`](https://port70.net/~nsz/c/c11/n1570.html#7.21.7.4) function. In fact, gcc would already convert it to an `puts` call. In your `AlphaDetector` function, where I would prefer a name like `DigitDetector`, since you only check for digits, not digits and letters, you can replace most of it by just using the [`isdigit`](https://port70.net/~nsz/c/c11/n1570.html#7.4.1.5) function.
I can't because our chips need to work as fast as possible with as low energy as possible, so having java or python is not an option. In fact C can be slow depending on the chip, that is why in some cases assembly is the option . The robots we are working on need to be crazy fast so we need to get as low level as we can.
We make battle robots, in my case I am working in a robot where the robot that wins is normally the one that can process faster, that is why I am now trying to program an arduino direct to the registers, without the arduino software so we can gain some more milliseconds.
&gt; dsBuffer-&gt;lpVtbl-&gt;QueryInterface(xyz) That's the same as ``IDirectSoundBuffer8_QueryInterface(dsBuffer, xyz)``.
I tried that and it doesn't work.
Is there a reason not to use `isdigit` or `isalpha` from `ctype.h` in your example?
No it's not, a loaded gun is perfectly safe. A gun is an inanimate object no different than a rock or a tree. Are rocks and trees unsafe? Depends on the context of usage! Why would a gun be unsafe in a kindergarten? Wouldn't you need humans inside the kindergarten for it to be unsafe? What if the kindergarten was on Mars and there were no humans on Mars. Is the gun still unsafe? Safety is a human concept assigned to humans. Objects are not unsafe. C is a safe language, only bad programmers make it unsafe. If C was unsafe, it would not run school buses that our children use.
Use those functions.
True, but it is only generated by the MIDL (unless explicitly defined, like in `dsound.h` case) and when MIDL is used, you would have to define the macro `COBJMACROS` before including the header file, otherwise they won't be defined. `dsound.h` seems to be an exception for this, but I wouldn't trust it without defining `COBJMACROS` beforehand.
What about [`-fmax-errors=1`](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)? Also, for me, causing a fatal error on a warning/actual error seems to be a bit 'dramatic', since it is not really a *fatal error*, but just an *error*.
Some times the actual error is elsewhere and the first error message you get is misleading. Telling the compiler to not bother with other error messages some times makes it more difficult to find out what is actually wrong with the code.
I think it's a good idea to have this flag for development because it helps code hygiene. But never-ever put this in your release. It certainly will break builds on different platforms and compiler versions.
I don't think that is what people mean when you ask them if a language is safe.
Either way... this is not really helping me with my problem.
What is the error then?
I figured it out, I needed to include ``dxguid.lib`` in my compile. Works fine now!
Thanks very much for the help. I followed your advice and the code appears to be a lot easier to follow.
I think you might be thinking of `-Werror` instead of `-Wfatal-errors`. `-Werror` turns all warnings into errors (which is bad for release builds, like you said). `-Wfatal-errors` makes the compiler stop after showing the first error (not warning).
Or at least post code of pictures!
Yeah I meant but something went wrong. 
Well yes, but then you need to keep writing and reading roundabout code. It's a tradeoff just like any other and opinions differ on what side of the tradeoff pays and when. For example to me Go feels sort of like if people ignored that there is a word "chair" and instead kept refering to it as "that thing you sit on by a table". The flipside is when there are to many complex names for too many things - functional or OOP programmers might seem to Go programmers like a group of Inuits having 15 different names for snow. I think in case of Go it sort of makes sense to do what it does, since it's a kind of a teenage language rebelling against the society and it's still figuring things out ("What even is a chair? Do we need them?"). My prediction is that given time Go will figure out some of the 'needlessly complex' things are useful and will tone down the rebellion a notch... 
indeed
There is no rebellion in Go. The toolkit Go provides essentially supports the style systems programmers have been programming in for years. There are no experiments in Go and no big novelties either. That's the whole point. It's the grumpy old man's language with all the tools a Ken Thompson needs to write software and nothing else.
&gt; Removing a layer of abstraction (e.g. a data structure being generic) removes complexity at no extra cost. I am writing my programs like this and I'm doing just fine. I don't see how the extra complexity received from using generic programming would help me solve my problems better. It's just useless extra complexity. So, you are not using `map`, slices, and arrays in your programs. Is that right?
Yes I do, though I rarely use maps. What sort of argument is this supposed to be? 
You do understand those are *generic* types?
I hate `-Werror` while I'm actively developing new code. Yeah, I know that's an unused variable, I haven't written the code that uses it yet! So my policy is to use `-Werror` on nightly builds and production binaries. Developers know that warnings on trunk are not tolerated. But, as pointed out already, that's a different flag than OP's asking about.
&gt;Removing a layer of abstraction (e.g. a data structure being generic) removes complexity at no extra cost. Is that a general statement?
The difference is that there is a bounded increase in mental complexity from a fixed set of parametrized types but unbounded complexity from arbitrary user defined generics. Plus the latter comes at a great complexity with respect to how generic types interact with the rest of the language. That's one of the things I have been talking about the entire time, not sure how you missed that.
That's total bullshit IMO. C is unsafe because it is easy to make mistakes while using it that lead to vulnerabilities or unexpected behaviour. By following your logic, a programming language that wiped your hard drive whenever it encountered an invalid memory access would be safe, would it not?
No. Some abstractions are helpful, others are less helpful. Generally, the cost of an abstraction (both runtime cost, compile time cost, programmer time and mental capacity) must outweigh its benefits. The point why I think generics are not a good feature is because there is almost never a need for generic programming outside of a few fairly common data structures. It's less mentally taxing to just hard code these few cases into the language and remove the mental complexity of having generics everywhere from the programming language. This has the accidental side effect of stopping programmers from picking weird-ass data structures all over the place where a hash table or array would suffice, making other people's programs easier to understand.
Further note that these are *parametrized types.* And you can't actually do generic programming with them with Go. Generic programming is the ability to create your own parametrized types and work with them without specifying the instance of the type parameter. Neither is possible with Go, so I don't see where your point is.
Well the error message said it all. You are missing a closing } in the end of your file. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions. Also, do not post pictures of code. Always post code as text!
Maybe this makes it more clear: long *lptr = (long *) &amp;buf[50]; *lptr = 0xbffffe8c; The left-most `*` just "dereferences" it so you can insert a value into the location of `buf + 50`.
Can you give an example?
Oh nice, I get what's going on now thanks. One more question though, is (long *) &amp;buf[50] persistent, does it mean that from now on, this address will be a long pointer even if not stored in a variable? Casting an address is new to me.
&gt; C code is used in school buses that drive children to school, on airplanes that carry the world's population around the planet, on satellites in space that handle most of the world's communication systems, it is used to run experiments and simulations we derive important medicine from, and it's used to run and maintain the International Space Station, for some quick examples. I'm just going to keep quoting myself over &amp; over. You cannot logically call something unsafe that is used for all of humanities important tasks like space flight, medicine, schoolbuses, communication systems, etc. C is the safest language which is why it's used in all of my above examples. It's also why Linux &amp; Microsoft force everyone to code their device drivers and firmware in C. Microsoft's entire WDK only supports C.
Here's my 2 cents. Pros: - Takes you right to the first error - Faster to dump you back to your cmdline Cons: - As mentioned - error could be elsewhere - Good editors let you step through the errors anyways The way I use it is I pass `-Wfatal-errors` when I'm debugging directly from the command line. In my editor (I use vim but most editors have similar features) I set it up so that I can step through to view each error one at a time. Sometimes the line numbers get a bit messed up as I fix them, but short source files are a rule of mine so it usually doesn't become a big problem.
No, it's not persistent. (You also have to be careful when doing this, or you can end up violating the strict aliasing rules ... but that might be a discussion for another day.)
It won't be persistent. Casts instruct the compiler to temporarily treat the expression on the right as having a different type.
If wordArray[indexTwo] is a space, then you never write to temp[indexTwo], leaving that character with an undefined value.
Bleh. Thanks!
There's a few things going on here. To start, `temp` is not initialized to anything, so if you're not careful you can end up with some garbage. That's where a lot of the weirdness in your result is coming from. Had you initialized it with `temp[50] = ""`, that goes away. Likewise, you never explicitly null-terminate your result (the initialization I showed takes care of this as well). Your inner loop starts at `1`, but I think you probably want it to start at 0, or else duplicates of the first character wouldn't count. There's a better way of keeping track of duplicate letters. Make an array of 26 booleans, initialized to `false`, and set to `true` when that letter is encountered. Read back out the ones that are `true` when you're done. But if you want to keep a separate string, you'll need another index for this string since its length is smaller by definition.
Huh? Go isn't a systems programming language. Its primary usecase is network services. Most gophers like it because it's trendy and easy to write a CRUD application in (and also, I suspect, because ignoring many programming concepts is considered a good thing unlike in other languages). 
Just to be clear - I didn't read your code so I don't really know if this is the right answer or not; but it would have helped debug it. What I commented there isn't a trick or a technique, rather it's thinking about the data you're processing. If you're starting out developing, understanding data is a skill you'll have to pick up. So when you say you'll remember it in future - yes, you should, but not as a debugging technique, more in terms about inspecting and thinking about the data and encoding you're processing. Those of us that have been writing code for many years still come across weird unexpected data in our day to day work.
&gt;You cannot logically call something unsafe that is used for all of humanities important tasks. Well, I just did. Are you going to respond to my point? Because under my definition of unsafe it’s not contradictory to say that X is unsafe and simultaneously recognise that X is widely used. You seem to be just sticking your fingers in your ears and claiming that the existence of non-buggy implementations of C code somehow exclude the fact that buggy and/or vulnerable implementations are very easy to write.
What makes parameterized types that complex to you? Is this hard? list&lt;pair&lt;string, int&gt;&gt; varName Why should a programmer reimplement a container for a specific type?
&gt; This program takes a user's input, checks if there are any alpha characters in the input, if there are, ask the user again to input only a number. Maybe I am being pedantic, but to me this says: * Take the user's input - (the programme does this) * Check's if there are any alpha characters in the input - (sort of does this, what it actually does it check if the input has only numbers, which is not actually the same thing as checking if there are any alpha characters. e.g. '%' is not an alpha character) * ask the user again to input only a number. - (does not do this, it just goes back to the beginning of taking user input, there is no message to the user about asking for only a number)
&gt; Why should a programmer reimplement a container for a specific type? The proposition is that in 99% of cases, an array or a hash table is sufficient. In the other 1% of the cases, the data structure you need is so specific that it can't be reused for other tasks easily anyway and implementing it for one type only isn't a problem. I've never seen this hypothesis fail. &gt; What makes parameterized types that complex to you? It's much more challenging to think about what actually happens in your program, where performance problems come from, how the data is laid out in RAM (for cache locality) when everything is abstract. It's also terrible to debug a program with generic code because once the debugger hits a break point inside some generic function, it can be very difficult to figure out how this has actually been instantiated. To understand what actually happens, you need to know the context around the generic code (i.e. how the type parameter has been instantiated). That's the same reason code that uses inheritance is tricky to debug and understand: the behaviour of code is not immediately obvious as a function call doesn't actually resolve to exactly one function so it can be very hard to understand what is actually happening. Further problems are introduced with features like copy constructors that cause complicated and fragile behaviour when you copy objects whose type is the parameter as an innocent assignment can suddenly cause arbitrary complicated behaviour. This is made worse by things like copy elision where the C++ compiler may or may not decide to get rid of a copy and the corresponding copy constructor call. It can be very hard to understand what is actually happening under the hood once a problem occurs and usually the only way to find out is too peel the layers of abstraction one by one, a tedious and frustrating task. I want code to be mostly context free. That means, I want to be able to take a single function in isolation and be able to understand exactly what it does without having to look at all the code around it. I want to be able to understand the exact behaviour of a piece of code in my program without having to look through twenty layers of interacting abstractions. For example, in your example, I have to go through both the code for `list&lt;T&gt;`, `pair&lt;A,B&gt;`, and `string` to understand how `varName` is laid out in memory and what happens exactly when I modify some part of the variable. I have to look through the source code and documentation of the class to understand if either has value or reference semantics and if it is allowed to copy them. Each time I look up the manual takes a couple seconds, but the time adds up and I have to keep all that in mind when reading the program which is fairly taxing. When I write the same thing without custom parametrised types it's much easier to understand what is happening as I only have to learn the semantics of a handful builtin types instead of a rich generic library of data structures. With this tool in hand, I can quickly understand the semantics, layout, and behaviour of data structures because there is no magic that can hide this from me.
go koolaid or just new to programming ans hasnt seen complicated code bases
To understand what is wrong, first I need to know what your code is supposed to do what what you think it is supposed to do.
 if (*prtljaga==NULL){ You must check the value of the pointer, not what it is pointing at. *prtljaga is uninitialised data so anything can happen if you read it.
it is supposed to take numbers and store them then print them via function
fixed it,still the same :(
What's still the same? You haven't said what the program is meant to do, and what it actually does.
it is supposed to take numbers and store them then print them via function it it compiles but crashes when running it 
sorry for lack of info
When you fix a bug, you should always check to see if you've made the same mistake somewhere else.
I remember once missing a semicolon on the last line of a header file which caused the compiler to give errors halfway down another file which included that header. It was extremely frustrating to find. 
&gt; buggy and/or vulnerable implementations are very easy to create. That's true for anything, so by your definition, everything is unsafe. By my definition, everything is safe so long as the context allows for it. C is a safe language so long as a competent person is coding it. &gt; Are you going to respond to my point? I started this comment thread, and I brought up the first point which you have still not responded to: &gt; C code is used in school buses that drive children to school, on airplanes that carry the world's population around the planet, on satellites in space that handle most of the world's communication systems, it is used to run experiments and simulations we derive important medicine from, and it's used to run and maintain the International Space Station, for some quick examples.
&gt; I am writing my programs like this and I'm doing just fine. I don't see how the extra complexity received from using generic programming would help me solve my problems better. It's just useless extra complexity. http://wiki.c2.com/?BlubParadox
I did respond to your point, because I specifically mentioned the fact that whether or not something has non-buggy implementations has no bearing on whether it’s ‘safe’ or not. &gt;That’s true for anything You completely missed the point. I’m talking about *how* easy it is relative to other programming languages. It is a simple fact that you cannot null pointer dereference i brainfuck so in that sense at the very least brainfuck programs are less prone to vulnerabilities, would you not agree? Your definition of safety is absurd (and you’re just defining it as such to avoid talking about the issue), as far as I can see. We really don’t agree on the definition so let’s just drop it entirely. I don’t care about your definition and I think it’s not worth discussing (since you already admitted nothing is unsafe) so here’s the real discussion we should be having: Is it easier or harder to create security vulnerabilities, memory leaks, undefined behaviour etc in C programs than it is in other higher level languages? 
I know this paradox and I don't think I'm subject to it. Before I started to program extensively in C, I used to program in Haskell a lot. You can still see this from my golden Haskell badge on [Stack Overflow](https://stackoverflow.com/users/417501/fuz). I have then consciously decided to eschew Haskell and other high-level languages in favour of a low-abstraction style provided by languages like C or Go because I grew sick of how Haskell's high level features make programs way more complicated than they could be because the idiomatic style leads people to overcomplicate everything with fancy abstractions and judicious use of generic data structures and high-level combinators. When I look at the Haskell code I wrote back then, I have trouble understanding it because everything is so complicated, even when the underlying logic is very simple. My C code on the other hand has always stayed just as simple to understand as it was in the beginning because there is neither a need to impress other people with complex code nor is this possible or seen as desirable.
It's hard to tell from your code, but your problem might be with the way you use `strncpy()`: it doesn't add a null terminator if the string being copied is larger than the limit you specify. So if you use `strncpy()` to copy up to 2 bytes and then use `strncmp()` to compare up to 3 bytes (or `strcmp()` to compare the whole strings), the result will undefined. For example, this code prints a non-zero value even though you copy `s` over `t` and then compare them. #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char s[3] = "hi"; // s contains "hi\0" char t[4] = "xxx"; // t contains "xxx\0" strncpy(t, s, 2); // t now contains "hix\0", NOT "hi\0" printf("%d\n", strncmp(t, s, 3)); } 
If by "fixed it" you mean you turned it into if (&amp;prtljaga==NULL){ Then no, you didn't fix it, if `prtljaga` is a pointer, then `&amp;prtljaga` is a pointer to a pointer, and in this case it will never be null.
You definitely violate the strict aliasing rules by doing this. If you know what system you're on, it's probably going to do the thing you think, but if you aren't very careful, you're going to get bad behavior, and it's almost certainly not portable.
I would use a while loop with a counter instead of a for loop, and only increment the counter when you have a valid entrie. So, something like this: int cnt = 0; printf("Please enter %d integers\n", array_size + 1); while(cnt &lt; array_size) { printf("Please enter integer %d: ", cnt + 1); scanf(" %d", &amp;input); if(input is valid) { // whatever test you need to check for a valid input array[cnt] = input; cnt++; printf("\n"); } else { print("Input %d is not valid. Please enter a valid integer\n"); } }
`buf` is an array of `char`, so it's not a violation.
If we were working in space allocated by `malloc`, then `*(long *)&amp;buf[50] = 0xbffffe8c;` would repurpose that `sizeof(long)`-byte block of the allocation as a persistent `long`. However, when working in space with a declared type, `char buf[200];` in this case, it cannot have its type reset -- it's always a char array no matter what. So this code actually causes undefined behaviour. (You can only write to a long if there is actually a `long` object there or able to be created by the write). 
In fact, casts create a new value based on the expression which is being cast. (Sometimes, but not always, the new value has the same representation as the old) 
I don't you know about Go's escape analysis mechanism. Or how its `.a` files aren't actually static libs. Or how its default `int` is actually a `ptrdiff_t`.
Put 4 spaces in front of each line to format code for Reddit. Pay attention to your compiler warnings. If you're not getting any, turn then on (-Wall -Wextra for gcc and clang)
Ok I put it in block code.
Now read the warnings, figure out what you're doing wrong, and fix them. That'll leave one logic error unless you found and fixed it at the same time.
You should get together with the author of [this post](https://www.reddit.com/r/C_Programming/comments/7ixa1b/what_is_this_symbol_and_how_to_i_tell_my_printf) since it looks like you're in the same class.
We are not. Mine is general text and not Dracula. though, I will admit the projects are similar. 
Will you be able to cope with the bounded mental increase in complexity when generics get added to Go 2.0 or you'll switch to some other programming language?
What is the type of `array` and what is the architecture of the target machine? Also, your code formatting seems off. You can edit your post and start each line with 4 extra spaces..
That doesn't matter, they still add a bounded increase to the mental complexity. I wish Go didn't have them, just imagine how much more readable and easy to understand the code would be without them. I'd create a proposal to remove both `map` and `[]` (slices with arrays) from the language in Go 2 and add registers instead. I'm dead sure that will be a more friendly solution for the modern simple high level language.
j++ is slower than ++j. 
[hypot()](http://en.cppreference.com/w/c/numeric/math/hypot) is a thing. Also, 4 spaces in front of every line to format code for Reddit.
Huh, didn't know there was such a thing as hypot(), thank you
the reason that `hypot` exists is that `double`s aren't precise think like dollars and cents - there's a "smallest value," the penny if you try to do math on dollars and cents, like giving a tip, or at gas stations, sometimes you have to round off to the penny doing math the way you did in extreme cases repeatedly can compound that error `hypot` is for when you need serious precision (because not very many people know how to cope with that)
You should tell us the problem you're encountering. You only say it is "ruining your code". How is it?
Well here is the fruits of my labor. This is actually a random number guessing game. Also, I'm using uint8_t here since I don't need anything more than 255 or negative numbers. Figured why use the extra memory when I don't need it...granted we're talking about a few bytes here and there. Here's the code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; static int nonIntDetector(char *input, unsigned int stringLength) { uint8_t inputCounter, intCounter, nonIntDetect, intDetect; char Numbers[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; nonIntDetect = 0; intDetect = 0; for(inputCounter = 0; inputCounter &lt; stringLength; inputCounter++) for(intCounter = 0; intCounter &lt; 10; intCounter++) { if(input[inputCounter] == Numbers[intCounter]) { intDetect++; break; } if(intDetect != inputCounter) { nonIntDetect = 1; puts("Numbers only, please."); goto nestedLoopBreak; } } nestedLoopBreak: return nonIntDetect; } int main() { uint8_t playAgain, loopChecker, randomNumber, intInput; char userInput[16], anotherGame[16]; loopChecker = 1; puts("Random number guessing game."); do { randomNumber = arc4random_uniform(101); do { do { printf("Enter your guess: "); fgets(userInput, sizeof(userInput), stdin); } while(nonIntDetector(userInput, strlen(userInput))); intInput = atoi(userInput); if(intInput &gt; randomNumber) puts("Too High."); else if(intInput &lt; randomNumber) puts("Too low."); } while(intInput != randomNumber); puts("You win!"); do { do { puts("Another game?"); puts("1. Yes, 2. No"); fgets(anotherGame, sizeof(anotherGame), stdin); } while(nonIntDetector(anotherGame, strlen(anotherGame))); playAgain = atoi(anotherGame); if(playAgain == 2) { playAgain = 0; loopChecker = 0; continue; } else if(playAgain == 1) loopChecker = 0; } while(loopChecker &amp;&amp; puts("Invalid option.")); } while(playAgain == 1); return 0; }
segmentation fault 
Have you tried using breakpoints to find which line gives you a segfault?
I think I might have found the problem independently. And yes, I have spent hours using GDB. I know that strtok was the problem
Also you have in your code head-&gt;word,slice; this seems to be a typo; head-&gt;word is not initialized Additionally, you're not checking if slice == NULL
Compile with `-O3` . The compiler knows the hardware better than you do. Unfortunately I suspect your instructor would not accept that as an answer...
Assuming x points to an array of `double *`'s, the second element isn't pointing to anything valid. Or if it's a pointer to a single `double *`, whatever memory is next isn't valid.
Missing closing }'s can do this.
`char* word [1240] = {'\0'}` is an array of 1240 pointers, each of which are initialized to be a null pointer. `fgets (word , 1240 , fp)` is an error due to type mismatch of the first argument. If you don't see an error message you need to change your compiler settings until you do see an error. You are missing out on important information from the compiler that would have pointed out your mistake. You probably meant `char word[1240] = { '\0' };` , which would be an array of 1240 characters. Can you explain what you intended to do with `head-&gt;word,slice;` ? 
 for (int i = 0; i &lt; N_TIMES; i++) { int j; for (j=0; j &lt; ARRAY_SIZE; j++) { sum += array[j] * N_TIMES; } break; }
While I haven't checked your code, it might be a good idea to read up on the semantics of strtok() and its pitfalls. A simple web search (e.g. duckduckgo or google) should do the trick.
[] has higher precedence than * your *x[i] needs to be (*x)[i] 
The issue is *x[i] Array access has a higher operator priority than pointer dereferencing, so what you're actually doing is `*(x[i])`, rather than `(*x)[i]`
Excellent, that works perfectly! Thanks!
Ralusp's code, modified to be compiled (no dangling references to macros and variables): #define ARRAY_SIZE 1000 #define N_TIMES 1000 long foo(void) { long sum = 0; long array[ARRAY_SIZE]; for (int i = 0; i &lt; N_TIMES; i++) { long j; for (j=0; j &lt; ARRAY_SIZE; j++) { sum += array[j] * N_TIMES; } break; } return sum; } ******* compiles with no extra options on godbolt.org [gcc 7.2] to: foo(): push rbp mov rbp, rsp sub rsp, 7912 mov QWORD PTR [rbp-8], 0 mov DWORD PTR [rbp-20], 0 cmp DWORD PTR [rbp-20], 999 jg .L2 mov QWORD PTR [rbp-16], 0 .L4: cmp QWORD PTR [rbp-16], 999 jg .L6 mov rax, QWORD PTR [rbp-16] mov rax, QWORD PTR [rbp-8032+rax*8] imul rax, rax, 1000 add QWORD PTR [rbp-8], rax add QWORD PTR [rbp-16], 1 jmp .L4 .L6: nop .L2: mov rax, QWORD PTR [rbp-8] leave ret Hope you know AMD64 ASM. The above, though not very readable, can be understood by anyone familiar with machine-generated ASM and capable of actually hand-coding smallish functions in ASM (gasp!), which is often useful when you really need to optimize. Whereas, with -O3: foo(): sub rsp, 7888 pxor xmm2, xmm2 lea rax, [rsp-120] lea rdx, [rsp+7880] .L2: movdqa xmm1, XMMWORD PTR [rax] add rax, 16 cmp rdx, rax movdqa xmm0, xmm1 psllq xmm0, 5 psubq xmm0, xmm1 psllq xmm0, 2 paddq xmm0, xmm1 psllq xmm0, 3 paddq xmm2, xmm0 jne .L2 movdqa xmm0, xmm2 add rsp, 7888 psrldq xmm0, 8 paddq xmm2, xmm0 movq rax, xmm2 ret This involves packed shifts and whatnot, but the since the compiler knows the NUM_TIMES and ARRAY_SIZE, it can optimize things to avoid costly multiplication. Of course, if you don't know those at compile time, then things get uglier.
for (int j = 0; j &lt; ARRAY_SIZE; j++) Same j loop code. Done. 
Can you explain this?
Just edited. Thought that I should include an explanation. Still confused?
That makes sense thanks!
 &gt;Nah, C still has dozens of stupid breaches in it's type system making it nearly impossible to build any huge secure program. Any typical C program/lib has a lot of unmaintainable macros, void* shit, NULL ptrs, unchecked array bounds, and is unmaintainable mess, Yes, and there are standards, such as MISRA, which rectify all of this. You clearly haven't read shit on the Toyota incident, nor have you actually done your homework. If you had, you'd be aware that companies who fuck up this bad do so because they neglect standards *that have been proven* over the years *and also provide automated tooling* for conformance testing. &gt;just like openssl (and nearly any other big C project). OpenSSL was being maintained by one developer, and the foundation's resources were a joke when the bug was found. Furthermore, it was fixed immediately, and they clearly weren't using tooling which already exists for the purposes of analyzing source code to make sure it complies with various standards. It literally doesn't matter what language you use if you're not following best practices. &gt; &gt;It is a year 2017, we have dependent types, GADTs, parametric polymorphism, RAII/advanced GCs, and people still try to write something in a 40 years old language, where you can add character to an address or get 40th element of an array of size 30. That's silly. It's silly, but it isn't going to change in the embedded world. There are already solutions which accomplish exactly what Rust's initial goals were, and also in an efficient manner. Most embedded programmers are also *smart*, because they know that jumping on hypetrain band wagons, no matter how good they sound, rarely ever leads to a positive long term outcome. &gt; &gt;&gt; it was written in Java. &gt; &gt;Java is also an ugly algol descendant with nulls. Again, standards and automated tooling alleviate the risk of null dereference issues happening. &gt; &gt;&gt;Also, way to cite one meme-tier example out of literally thousands of mission critical projects &gt; &gt;If some invariants could be encoded with some help of the language, that should be done. There is a thing called progress, type systems and PL theory advanced a lot within last four decades. Of course. But that doesn't justify going to Toyota or some other business and encouraging them to rewrite their software in Rust. That's going to cause far more harm than good. If you want to use Rust, I think that's fine. My issue is aggressive approaches in persuasion and ignorant propaganda your community spreads, which includes Toyota's blunder. You're not fucking helping the situation. At all.
I need to keep the number of additions in the inside for loop the same 
No problem. Not sure why everyone else is giving you super sophisticated nonsense and/or wrong code. Best of luck.
&gt; such as MISRA, which rectify all of this. Which is a great example showing why C is harmful. Language should prevent such things by its own merits. &gt;It's silly, but it isn't going to change in the embedded world &gt;hypetrain band wagons Sure, 40 years old ideas from academia are nothing but hype, for sure. Embedded developers are conservative not because they are smart, but mostly because they are ignorant programmers. I have a degree in electrical engineering and worked in a hardware field for a while after graduation, I've never seen an embedded programmer aware of type theory, PL theory and so, most of them had no CS education and new only C. And this kind of aggressive ignorance is kinda unique to embedded programming only, since in electronics nobody else ignores theoretical background. &gt;People who are good developers There are no good C developers, as practice shows.
Pretty good for a beginner! You need to check the values returned by `scanf` in order to detect failure though.
It's being aliased to `long*`. You may alias anything to `char*`, but in general aliasing one type to anything that is not `char*` is a violation. You can see why this is a violation because the long* isn't even aligned.
if you did while('\0' != input++) { ... } ... would that work the same as your for loop?
A precedence rule worth remembering in C: Post-fix is strongest Pre-fix is 2nd strongest Infix is weakest. Post-fix includes: * Array subscripting (also array sizes in types): `foo[x]` * Field access: `foo.x` or `foo-&gt;x`. * Function calls (or function types): `foo(x)` * Post-increment/decrement: `x++`, `x--` Pre-fix includes: * `sizeof` operator: `sizeof x` * Ptr dereference/type: `*x` * Pre-increment/decrement: `--x`, `++x` Infix includes: * Various operators: `x + y`, `x - y` 
Wait, why would that be the case?
&gt; I was talking about matrices being defined as 2D arrays Your matrices are unions and can be copied by assignment. Otherwise, you wouldn't be able to pass them by value—they would devolve to pointers. And even if they weren't structs or unions, I don't understand why you use loops to copy them instead of `memcpy()`. &gt; the point is that implicit copies (such as through the assignment operator) I assume that you meant “explicit”, not “implicit”.
It's not. This is sometimes true in C++ for user-defined types with expensive copying. But in C, or in either language with an int? Nope. Since in this case it's not using any side effects, your compiler will likely generate the same instruction for both post and pre increment. 
Put 4 spaces in front of every line to format code for Reddit.
Ah, thank!
&gt; bounded increase in mental complexity This is copy-pasta gold.
&gt; I don't you know about Go's escape analysis mechanism. This one indeed sucks a lot since it isn't really obvious which variables are fast stack allocations and which variables are slow heap allocations. &gt; Or how its .a files aren't actually static libs. Doesn't really matter as that's transparent. &gt; Or how its default int is actually a ptrdiff_t. That's an advantage because it makes choosing the appropriate type less of a hassle. In Go, `int` is always the right type to use. No problem here.
No. Your while condition increments the pointer before doing stuff. The for loop increments after stuff is done. 
I hope you didn't format your code like this. You should check the return value of "scanf", it returns a negative number on failure you could encounter some pretty awful bugs this way. Other than that, pretty nice! Happy coding:)
How would i go about checking it? Thanks
Thanks!
The [documentation for scanf](https://linux.die.net/man/3/scanf) (your compiler probably comes with documentation that's specific to the library it uses, the linked page is for GNU/Linux systems) explains what the return value means. From that page: &gt; RETURN VALUE &gt; Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed, and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has completed, and without a matching failure having occurred, EOF shall be returned [CX] [Option Start] and errno shall be set to indicate the error. [Option End] If a read error occurs, the error indicator for the stream shall be set. Your existing code looks like this: scanf("%lf", &amp;a); Because the result is not assigned to anything, the result is being ignored. To detect the errors, make a change like this: int conversions; /* ... your other code ... */ conversions = scanf("%lf", &amp;a); if (conversions != 1) { perror("unable to read a double-precision number"); return 1; /* See explanation below. */ } If the `scanf` conversion failed, we don't have the information we need to compute the result of our program, so we have to stop. The `return` statement ensure that we don't continuw with our `main` function. It returns the value 1 because (by convention) C programs return 0 to indicate success and some other value to indicate that a problem occurred. The `perror()` function call emits an error message on the standard error output, which is a helpful thing to do when there is a problem. We don't send error messages to sthe standard output because this lets them get mixed up witht he program's regular output. 
&gt; it returns a negative number on failure, For some failures, but only because `EOF &lt; 0`. More generally it returns the number of input items successfully matched and assigned, or `EOF`. 
I would argue that a language is just a tool and the objective and architecture matter more. Tezos is building theirs on OCaml and IOHK have a pretty kick-as* project called Scorex written in Scala mainly: https://github.com/input-output-hk/Scorex
More importantly, C++ is off-topic here.
That's not always the case. Esp embedded gear where you're lucky to have a compiler that works. Also o3 can break shit, even on x86.
Well, time for me to quote myself: &gt;(You also have to be careful when doing this, or you can end up violating the strict aliasing rules ... but that might be a discussion for another day.) And then hang my head in shame, because you're right.
My understanding is that prefix is one instruction faster per loop because of the ordering and magic and stuff... Unless it depends on the compiler, ofc. I usually assigned the trick to gcc. (still a student and I haven't done embedded in about 8 months) 
 int *p, *end_of_array = array + ARRAY_SIZE; for (p = array; p != end_of_array; p++) { sum += *p; } Make an integer pointer `p` and use it to walk the array, incrementing it by the element size on every step instead of recalculating a new offset. This might or might not save an instruction inside the loop, depending on how smart your compiler is (or how smart you tell it to be).
&gt; Your matrices are unions and can be copied by assignment. Yes my matrices are unions, but the ones from ccVector I was comparing them to aren't. That was the entire point of that comparison. Here's the paragraph I'm referencing: &gt; I wrote this to replace ccVector in my projects, which actually uses pointers for matrices. The main pro of that approach is that you can do m[i][j] directly by typedefing your matrix type as a 2D array. The downside is having to juggle pointers and needing a copy function. &gt; I don't understand why you use loops to copy them instead of `memcpy()`. I don't, now you're just making stuff up. My library doesn't have any dedicated copy functions, pass-by-value and assignment operators do that already. If I were to add a class of functions that work with pointers-to-mat4 I'd have a copy function which uses `memcpy` internally. &gt; I assume that you meant “explicit”, not “implicit”. I meant implicit, though I guess pass-by-value would've been a better example than the assignment operator, which could be considered explicit. I guess my clarification only served to confuse things more, so nevermind. 
Thank you very much! Its nice that people like you take the time to explain things to noobs like me
 star_one = the_universe.named_stars[counter].star_one_serial; star_two = the_universe.named_stars[counter].star_two_serial; dist_two = the_universe.named_stars[counter].distance_one_two; You have this section reversed. You`re reading from the empty `named_stars` entries and storing those values in a variable. 
Thank you, that fixed the problem!
It's okay, I had to look it up to remind myself what it was. I forget that C technically doesn't let you arbitrarily munge bits in whatever format you want, and how seductive it is to end up writing platform-specific assembly in C instead of writing C.
I’d recommend doing something like gcc ETC. 2&gt;&amp;1 | less which lets you scroll through errors more cleanly. As others have said, `-Wfatal-errors` is fine for the first stage of development where you’re likely to have major syntax errors but less useful/desirable later on.
ah ya know..... less of course....
You can create new variable like int i, j ,k;
What have you tried? Do you understand what the provided code has done?
Everybody was a noob once. But there is a lot of code out there written without error checking. It's a kind of pollution; it's good for everybody to help clean it up / prevent it.
This sub is for C, not C++. You want /r/cpp_questions or /r/learnprogramming. When you post your question on those other subs, please include your code so far. There's absolutely no way to know what the problem is by what you've given. See the sidebar of those subs for how to post code.
Whoever created the C/C++ term must be really proud...
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Yeah, I absolutely hate it. Makes people think it's the same language and the two words C and C++ can be interchanged.
I still don't know how to print a hello world in C++. Even though one said once that printf works too! haha
There is a lot of C ide with greater support for C or C++. Xcode for I all read is very good for C/C++ but not that best one. There is Qcreator, Clion, Codelite ... 
Yup, the LLVM compiler in Xcode has first-class C and C++ support, and Xcode is a decent IDE. Create a “Command Line Tool” project for macOS to get started.
Are you learning C or are you learning C++? Xcode is an IDE. I recommend you to ditch the IDE as a beginner and use the compiler directly from the command line as this way, it's much easier to understand what is actually going on when compiling your program.
Xcode is definitely great for learning C and C++ and/or creating Makefiles, etc. If you get into a bit more, I'd recommend switching to a more customizable IDE (my IDE of choice is CLion, it's free for college students). Happy coding!
Only if you're doing something wrong.
I would be shocked if a modern compiler emitted different code for these two scenarios.
You say that but just the other day I ran into a legitimate compiler bug on embedded gear that was caused by o3. Also try installing gentoo and use o3 for everything. Good luck with that. 
See also atan2
First of all you've made good points. As a general note I should aggree that comments defenetly help as well as the strict coding discipline. However comments are not a part of the language itself, they help as much in any other language from Assembly to Haskell. 1. It was not about function pointers per se but rather about syntactical construction compared to the languages with kewords and postfix type notation. 4. In languages with declaration keywords var/val/let/etc. this is not an issue since there is no ambiguity. Such problems in fact led to a lexer hack tricks (although afaik clang does this in a more generic fashion producing ident tokens). 5. They in fact do. Moreover you may abuse it exploting ABI (although it is most likely either implementation defined or undefined behavior). 6. Yup trigraphs my bad. 8. I do like stuff along the lines of: int *a = (int[]){1, 2, 3}; int b = *(a++); // b == 1 It does still complicate language grammar and increases it's complexity espsecially for newcomers.
I know some 20 years C programmers that won't call themselves proficient in C...slow down boy!
Haha sorry I should say “comfortable” with it!
Do some programming in C. That's the most effective way to refresh your knowledge.
I mean you can always go classic and get the Bible of C: https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628 Pretty much the go-to for serious C development. I imagine there are other more modern ones, but the exercises in this book are more than enough to get you re-acclimated. 
I agree that’s probably my best option and I will hopefully get lots of practice in but I was just hoping for something to quickly go over the concepts like memory allocation and pointers in case there’s something I forgot. Thanks for the input!
Thanks I’ll check it out!
|| is logical OR. c = a++ || --b c = 0 OR -1 At least one of the terms is true, so c is true. 
C being such a small language, I'm curious to know what old timers learn about C. 
Thank you! Kinda strange 0 || -1 returns 1. So will c in this example will return true for any single-digit number (aside from 1) so long as there's 0? The decrement makes more sense now. Loop is broken once 3 &gt;=4 evaluated. 
 In C, 0 evaluates to logical false, everything else evaluates to logical true. Therefore your statement is c = false or true which means c is logical true. 0 || -1 ( == 1, or true) is different from 0 | -1 ( == -1, which is also true)
`||` is not a mathematical operator, it's a logical operator. It will always return either true or false regardless of the operands, and it will never return anything else. It evaluates each operand in order from left to right, and it stops as soon as it sees the first true value. The reason is because the logical-or of `true` with anything else must be true, so there is no reason to continue evaluating other expressions to the right. This is called short-circuiting. In C, 0 is false and anything non-zero is true. So it continues evaluating expressions until it gets the first non-zero result, and then it's done. Whether the numbers are single-digit, or positive, or prime, or whatever doesn't matter.
To answer your update a will be incremented before the `||`. so int a = 0; c = a++ || printf("%d",a); will print `1`.
I assume you mean *object-oriented*. I'm not sure what *objective-oriented* programming would look like...
&gt; I'm not sure what *objective-oriented* programming would look like... Set a goal, write code that achieves that goal?
Please edit your question, add four spaces in front of each line of code and remove all the fricking backticks.
You can roll through K&amp;R in a week but that's not a bad thing. There's a reason it's the Bible
Just use `strtol()`.
`0 || 0` is `0` , all other cases of operands for `||` give `1`. 
 #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { double a, b, value, result; printf("Enter value for a\n"); scanf("%lf", &amp;a); printf("Enter value for b\n"); scanf("%lf", &amp;b); if (scanf("%lf", &amp;a) || scanf("%lf", &amp;b) != 1) { perror("unable to read a double precision number"); return 1; } value = ((a*a)+(b*b)); result = sqrt(value); printf("The hypotenuse c is %lf", result); return 0; } 
If `-O3` breaks your program, usually it is because your program had a bug. Yes, compiler bugs do happen, but in that case you can work around the bug specifically, or disable optimization for that part. 
The output should end in `\n` or else the last line may not be displayed. What will happen if someone types "banana" when they're supposed to put the value for `a` ? 
It's waiting for input again because you're calling `scanf` again.
It is still the single most useful book on C.
What do you mean? It's the same number of additions?
The compiler should generate the same code for postfix and prefix when the value of the expression is to be thrown away. E.g. `int x = ++j` is faster (on most architectures) than `int x = j++`, as the afterthought of a for loop they will be the same.
What's the difference?
Im working on that, but cant figure out how to make it work
Solved ! Thank you again lol
The C Programming Language by Kernighan and Richie was used for my machine organization class. It has plenty of exercises to work on, and it's free on GitHub.
Cool. Thank you. I will know tell my course my dumb mistake and hope they forgive me for apparently lying to them. 
If you want a specific size of integer (like you seem to be wanting [here](https://github.com/zack-bitcoin/amoveo-c-miner/blob/master/sha256.h#L20)), you should use specific sizes. `stdint.h` has definitions for `int32_t` and the like. Also just a style thing, I'm always fond of using the actual type (like `int32_t`) rather than a `typedef WORD`. Explicit is better than implicit. Although there obviously are advantages in changing the `typedef` in just one place rather than all thru the code.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [zack-bitcoin/amoveo-c-miner/.../**sha256.h#L20** (master → 470a26e)](https://github.com/zack-bitcoin/amoveo-c-miner/blob/470a26e329c834fc0e8593601f03338bab5e1355/sha256.h#L20) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Good suggestion. Thank you.
Awesome I'll check it out tonight!
Should there be a break statement at the end of your hash2integer's for loop? That seems wrong since it will only ever loop once. It also looks like that algorithm is doing additions and shifts based on the number of trailing zeros in each byte of h. You might be able to look for more optimal trailing zeros functions and benchmark them against what you have. Having that many branches is almost always bad for performance.
The other comments on the thread addressed it. You need to check the return value of `scanf`; if it is not exactly `1` it means there was an error. At that point the easy option is to abort the program. (Recovering and asking for new input is a bit more complicated)
I fixed it thank you!
More like how to IMPLEMENT C
how about? while('\0' != *input) { ... ++input; }
Yes
hash2integer's input is something like this: "0000054345" it starts with a bunch of zero bytes. The continue catches each of the zeros, so the for loop loops once per zero byte. The rest only runs once, you are correct. It looks for leading zero bits on the next byte. For clarity I should take them out of the for loop, this was a confusing way to write it. I agree that shifts might be faster than multiplication, it is worth trying out.
If you're going to do that route, why not do the multiply after the loop. for (int i = 0; i &lt; N_TIMES; i++) { int j; for (j=0; j &lt; ARRAY_SIZE; j++) { sum += array[j]; } sum *= N_TIMES; break; } 
I don’t? Xcode is unmitigated garbage. I can’t fathom why anyone would like an ide that crashes on them every 10-15 minutes and puts weird random settings in seeming random spots. To each their own I guess. 
No worries! Like I said, I use CLion. However, for someone just learning, Xcode is not the worse. I’ve never had any issues with crashing, or randomness, as you say, when using Xcode for iOS dev, so maybe a fresh install would fix some of that? Everyone has their preferences in CS, so yeah, to each their own.
Was going to say something like this. There is nothing inherently _wrong_ about typedefs like WORD or CHAR. But the fixed size types are more verbose, and they don’t look like (to me, at least) somebody shouting in code.
https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
Ah you are absolutely right. I missed that continue statement. Given that the long chain of ifs and else ifs really only runs once per call that might not be something to worry about after all. If you mean shifts over multiplying and dividing by powers of 2 I wouldn't be concerned; the compiler will do that for you.
For `hahs2integer` you should be able to drastically simplify the long chain of `if`s. Basically all you're doing is checking what the highest set bit in `h[i]` is, and then doing some shifts on `h[i]` based on that value. So you should write a function that returns the position of the highest set bit (Which would be a value between 0 and 7, along with an error value like -1 to indicate the value has no set bits), and then do all your math based on that value.
The more efficient (albeit uglier) way to do this would be to use a switch statement with fallthrough, like so: ``` switch(h[i]) { case 0: x += 8; y[1] = h[i+1]; break; case 1: x += 7; y[1] = (h[i] * 128) + (h[i+1] / 2); break; case 2: case 3: x += 6; y[1] = = (h[i] * 64) + (h[i+1] / 4); break; ``` etc. You could also do something like: ``` if(h[i]) { int j = 7; for(; h[i] &gt;&gt; j; --j); x += j; y[1] = (h[i] * 1 &lt;&lt; j) + (h[i+1] &gt;&gt; j); } else { x += 8; y[1] = h[i+1]; } ``` A combo of the two approaches would minimize branching.
Seems to me there's a buffer overflow at line 110 if the mining_input file is longer than 74 bytes.
This is C++ and not C.
C was the first language I learnt, and I used XCode. I certainly got along with it well enough.
Thank you
does your client "know", that for every request it has to build a new connection? usually you just keep a connection open until on party closes it.
After rewriting the Windows bits to work on Linux, your server replies to multiple requests just fine, as long as they are sent on different connections. Like /u/Egging_McNut said, your client needs to be aware of this, or you need to keep your client connections around until the client disconnects. Example (I removed the calls to the missing non-standard functions `strrev` and `strupr`). Client: $ nc localhost 8989 test test $ nc localhost 8989 blubb blubb $ Server: $ ./simpleserv Socket created. Bind done Waiting for incoming connections on port 8989... got test got blubb ^C $ 
Thank you for replying, I was testing the server with puttytel, the second time i type something i receive nothing from the client. Is this normal? I havent build a client side yet. 
I'm using puttytel to test the server, I haven't build a client side yet. 
It's expected given your server code as you close the connection after sending a reply. I would not say it's normal, as a lot of server software will keep client connections open until the client disconnects. "Generic" clients, such as puttytel, telnet, or netcat (nc), will not automatically reestablish the connection when the server closes it. As an example, netcat simply exits when the server it was connected to closes the connection. For your server implementation, you'll have to tell puttytel to reconnect (I'm not sure if this is an option), or close and reopen puttytel if you want to get multiple replies. 
Don't the different servers have different IP addresses?
yeah, was thinking about that. but wasn't sure how i can correcly implement it. But thanks for thinking with me
`stdint.h` was already mentioned. `memory.h` is a non-standard header, and appears to be nothing more than an alias for the standard `string.h` header. Just use `string.h`. You don't open `nonce.txt` in binary mode. Since you open `mining_input` in binary mode I assume this matters to you. You've got an out-of-bounds accesses in `test_hash()`: BYTE bhash[32]; for (int i = 0; i &lt; 66; i++) { bhash[i] = 0; } // ... sha256_update(&amp;ctx, bhash, 66); Just use an initializer anyway: BYTE bhash[66] = {0}; Though this function doesn't do anything other than print the hash of 66 zeros. Use `SHA256_BLOCK_SIZE` rather than 32 when that's what you really mean. Makes the code easier to understand and helps with mistakes like the above. Not that this matters much since it only happens in throwaway test functions, but when you have large-ish arrays that don't change, making them `static` will avoid copying that data onto the stack on each invocation. For example, this: BYTE nonce[32] = { /* ... */ }; Would become: static const BYTE nonce[32] = { /* ... */ }; And the pointless 32-byte copy is eliminated. For the `const` part to work correctly in `test_check_pow()`, you'd need to add `const` qualifiers to the pointer arguments of `check_pow()`. It's not necessary to use `const` at all, but it ensures the static array doesn't accidentally get changed somewhere. A more clever `next_nonce` could be faster, such as operating on 32 or 64 bit integers at a time. The current version is essentially a bigint in base 256. It might be worth optimizing since this is core to mining. No need for `rewind(f)` in `write_nonce()`. The file has already been truncated. `ftell()` returns a `long`. While it probably doesn't matter in this case, it's better not to arbitrarily truncate the result. You've got some useless comments. Examples: fseek(fileptr, 0, SEEK_END); // Jump to the end of the file int filelen = ftell(fileptr); // Get the current byte offset in the file fclose(fileptr); // Close the file 
I suspect `hash2integer()` could be rewritten as one or two lines of code, but I don't fully understand what is supposed to do, or why the loop is short by one. It wouldn't kill you to write some comments... From a performance perspective, there is a lot of duplicated work here — buffers that are reinitialized to the same value for every hash attempt, etc. If you were serious about this, you would inline the sha256 implementation and strip it down to the bare minimum you need, removing all loops and conditionals. You can prefill a 128-byte buffer with the data, difficulty, length and padding and only change the nonce. Even better, you can place the data in the first half and the nonce and difficulty in the second and save the sha256 state after the first half instead of re-hashing the same data every time, and you can integrate the logic of `hash2integer()` into `sha256_final()`. Oh, and you'll want to uncomment [line 94](https://github.com/zack-bitcoin/amoveo-c-miner/blob/470a26e329c834fc0e8593601f03338bab5e1355/amoveo_pow.c#L94).
Lots of great comments. Thanks a lot Skeeto. 
&gt; it's free on GitHub Not legally.
These are great ideas. thanks a lot.
difficulty is 2 bytes, in this file it is written in base10. So a maximum of 5 letters "65536". Thank you for the suggestion.
I haven't read you code, but sounds like you're doing something like bitscan. Check out the x86 `bsf` and `bsr` assembly instructions. 
hash2integer is for proof of work difficulty. It is something like (number of leading 0 bytes)*256 + (the byte made by the first non-zero bit followed by 7 more bits).
Great suggestions, thanks a lot. De Bruin is a great idea for mining because I would only have to change 1 bit between nonces instead of adding 1 to a 32-byte value. I had never heard of bsf and bsr instructions, but it looks like they might be doing exactly what I need.
Right. It could be written in about three lines of code, especially if you use a lookup table.
that header has some other useful types people may not be aware of: intN_t Width of exactly N bits. int_leastN_t The smallest of width of at least N bits. int_fastN_t The fastest of width of at least N bits. intptr_t Pointers can be converted to it and back. intmax_t The largest integer type. Used by preprocessor.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/amoveo] [The C language community gave Amoveo a lot of help. It is a great community.](https://www.reddit.com/r/Amoveo/comments/7jj9t4/the_c_language_community_gave_amoveo_a_lot_of/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Report back with performance difference. I'm curious. The only time I've ever used the instruction was in C#. To call it I allocated unmanaged memory and assigned x86 OP Codes to it, then assigned that memory to a delegate. The overhead of calling a delegate plus the transition from unmanaged to managed code ended up causing it to be 3x slower than a C# De Bruijn function
Programming in C by Stephen Kochan is also worth checking out.
*palette
I've played around with png exports in the terminal before, this is my first attempt to come out and make a GUI. GTK seems to be one method of creating a user interface while using 100% C code, so I figured I might as well post it since some people might be interested in making stuff like this.
You should open links in private browsing so you see what the links look like to other people, it's just a meaningless login page to me. Also /r/C_Programming is generally not for C++ related content, /r/cpp would be more appropiate.
&gt; palette Fixed (the readme's at least). I'll let the code demonstrate what a pathetic native English speaker I am.
Also... you do realize that git keeps a history of all changes you make to your code and that you can go back and forth, right? And that you don't need to check in a new file every time?
Yes, I realize that. But I still like doing it the crappy way. It makes trial and error a lot easier than trying to remember which git or branch to revert back to. There's always code to refer to, and it makes it easy to see the progression.
What does your compiler say when you try to compile that?
Nice!
I'm not sure why you'd want to embed the struct in the function (I tend to put mine in header files) you could always malloc and return a void pointer...
Sorry for that.
If you're reading a byte at a time, fgetc() works fine. Larger chunks? fread().
Ah ok, I tried to read up a bit on fgetc() on tutorialspoint but couldn't quite understand it. If I had a file called in, what would x = fgetc(in) be? Would it be the whole file or just the first byte?
because the length of the arrays that are created in the structure are determined by the function it is embedded in. 
http://en.cppreference.com/w/c/io/fgetc
So how would the function that receives the structure know the lengths? You'll need a generic structure, defined outside the function, and manually do some allocation inside the function. The structure will also need the lengths of the allocations so the caller knows what to do with the data
in the function the arrays within the structure are populated as well. my intention was then to return the structure so it can be used elsewhere 
Dude... Learn git. &gt; There's always code to refer to, and it makes it easy to see the progression. With git this is as easy as `git diff HEAD~3`, to see the changes made by the 3 last commits. &gt; trying to remember which git or branch to revert back to. Well if it's of any help to you, you could name all your branches: 1, 2, 3, 4, 5... just like your folders.
Would this book go over the fundamentals of programming? In the sense of teaching beginner's from square one?
Great game with great textures. Ever notice how things like the characters mouths are textured differently depending on the camera angle in cutscenes? That src folder, though... you’re perfectly avoiding the entire point of version control software. Spend some time looking up best practices and such. I guarantee you’ll find it a worthwhile investment. 
Yep, I just finished my first semester as well and this book helped me a lot. Then again this is the only book I've read about C, but I don't really see how it could get much better than this.
You have a bunch of incorrect printf format codes. Fix these first. test.c: In function ‘extended_euclid’: test.c:17:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 2 has type ‘long long int’ [-Wformat=] printf("%ld %ld %ld %ld %ld\n", a, b, ee1.d, ee1.x, ee1.y); ^ test.c:17:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 3 has type ‘long long int’ [-Wformat=] test.c:17:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 4 has type ‘int’ [-Wformat=] test.c:17:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 5 has type ‘int’ [-Wformat=] test.c:17:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 6 has type ‘int’ [-Wformat=] test.c:24:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 2 has type ‘long long int’ [-Wformat=] printf("%ld %ld %ld %ld %ld\n", a, b, ee3.d, ee3.x, ee3.y); ^ test.c:24:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 3 has type ‘long long int’ [-Wformat=] test.c:24:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 4 has type ‘int’ [-Wformat=] test.c:24:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 5 has type ‘int’ [-Wformat=] test.c:24:5: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 6 has type ‘int’ [-Wformat=] test.c: At top level: test.c:29:15: warning: return type of ‘main’ is not ‘int’ [-Wmain] int long long main(int long long argc, char * argv[]) { ^ test.c:29:15: warning: first argument of ‘main’ should be ‘int’ [-Wmain] test.c: In function ‘main’: test.c:33:1: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 2 has type ‘int’ [-Wformat=] printf("GCD = %ld\n", ee.d); ^ test.c:34:1: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 2 has type ‘int’ [-Wformat=] printf("x = %ld\n", ee.x); ^ test.c:35:1: warning: format ‘%ld’ expects argument of type ‘long int’, but argument 2 has type ‘int’ [-Wformat=] printf("y = %ld\n", ee.y); ^ Also, if you want long long literals `int long long a = 288300744897986560;` and `int long long b = 28830074489;` you need to suffix the constant with 'LL'. You're also writing `int long long`. I'm not sure if C interprets this as just a `long long` (or `long long int`)((or something else)), but `long long` or `long long int` are the standard ways to specify int that must be at least 64 bits in size.
`x` and `y` are of type `int`, which isn't large enough to store the results you're expecting. Make them `long long` like you've done elsewhere. Make sure you get the `printf` format specification right. `%lld` is for `long long int`, `%ld` is for `long int`, and `%d` is for `int`. And remove the excess `long long` modifiers on your declaration of `main`.
sorry , i have fixed the code! but still i cant get it right , if i but small numbers insted of 288300744897986560 and 28830074489 it works normally......
u Rock Ty , it worked!
&gt; i have fixed the code! but still i cant get it right So, how do you expect to get help? Show us the code.
Look Up? 
so there is another problem now! the programm wont work with 20digit number for x and 20digit number for y, i get the warning: integer constant is too large for its type 
What have you tried so far? Where are you stuck? Nobody here wants to do your homework for you.
You can't put a variable-length array inside a struct: &gt; 8 A member of a structure or union may have any object type other than a variably modified type.^(105) In addition, a member may be declared to consist of a specified number of bits (including a sign bit, if any). Such a member is called a bit-field;^(106) its width is preceded by a colon. [Source.](http://port70.net/~nsz/c/c99/n1256.html#6.7.2.1p8)
Awesome, I'm considering on ordering it right now! I want to feel confident while I'm learning, and this seems to be an excellent choice.
Lol those folders
Your title says it all. Write tests.
It has tests. If you include the tests, that would make it longer than 135 lines.
And corporations contributing to it or profiting off it does not get in the way of it.
Stray semicolon: int main (void);
There must not be a `;` at the end of `int main(void)`
That would be just the first byte. Each call to `fgetc()` returns the next byte in the file. With `fread()`, you can read multiple bytes at once.
C++ projects are off topic in this subreddit. Please post C++ projects elsewhere.
well i'll tell you the truth i made the algorithms and pseudo-code but i do not have a lot of experience with c and basically the challenge was to make a program in c with their respective algorithms and pseudo-code like i'm completely stuck with the c program i have to hand out that challenge tomorrow everything i have seen online only gives me ideas but when i try to run the program it doesnt work. 
There's quite a few problems with that, but 1 at a time... What has to happen before your code assigns values to the fields of head? Where does that thing happen?
might not be related, but you should definitely initialize and clean your wordholder with \0
FWIW, many of the performance recommendations you've gotten here are questionable. You can check actual results, if it even matters, with [Compiler Explorer](https://godbolt.org/). And remember that the only proof of optimization improvement is measurement.
In the program's header file is this: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; //Node structure----------------------------------------- struct Node { int timesUsed; char* word; struct Node* next; }; //functions----------------------------------------------- char* title(char* file); struct Node* createNode(struct Node* head, char* word); struct Node* wordList(FILE *fp, struct Node* head); void printThrough(struct Node* head); 
Will do
Tags, not branches. If I cloned a repo with dozens of numbered branches I'd end up killing the maintainer. Even with tags it's bad practice. Ugh this hurts me.
Any help would be appreciated!!!
While your full code is certainly useful, my questions are in regards to wordsList()
Point taken. I'll take the time to learn to use Git for future projects. Thanks for the feedback.
But you (a) didn't indicate you had edited your code and (b) you didn't update your code to fix the problems people already told you about. 
C++ is off topic in this subreddit. Please post C++ content elsewhere.
Yes it is true, humans are very bad at identifying bottlenecks. Thank you for sharing this tool.
but the code works perfectly fine (the problem is with 20digit numbers for x and y). btw it is a c code , gcc -o ........ if u didnot noticed
İn c 0 is False and all other numbers is True 3th can be converte to true(5) &amp;&amp; true (j==6) 4th can be convert to true(5) &amp;&amp; false(0) and so on
Thank you so much. Makes so much sense. Nvr thought about it that way. Thank you!
In C, false is defined as the numerical value 0, and any other integer will evaluate to true. 
Thank you for the help!
Thanks for the suggests. I can tell by the score of my previous comment that people have strong feelings about using Git effectively. I'll take sometime to try and learn how I can adapt Git's functionality into my coding practice and do better next time.
Look up.
What is the output exatcly only problem i see here /0 problem for example you have 2 word first is word01 second is word2 when u add to list and print in order you will see word01 and word21 if you are seeing this kind of output you should add wordHolder[j] = '/0' before copy operation. 
As the others said, 0 is false and any non-zero value is true; but what they left out is that a comparison, conjunction, disjunction or negation always evaluates to either 0 or 1. This means that you can do fun things like `(bool-expr) * x` instead of `bool-expr ? x : 0`, and that you can turn any expression into a boolean expression (i.e. convert any non-zero value to 1, leaving zero alone) by prefixing it with `!!`. The latter tends to annoy people who don't realize that it's just `!(!(expr))` and not some strange new operator that they've never heard of. Note that C99 added a built-in boolean type, `_Bool`, which nobody uses, and the `&lt;stdbool.h&gt;` header, which defines `bool`, `true` and `false` for convenience, and which *almost* nobody uses. Old habits die hard, I guess. Plus, they don't fully replicate the equivalent feature from other languages since you can't reliably *compare* anything except a boolean expression to `true` unless you normalize it first using the `!!` trick. Hmm, I should check if gcc and clang recognize this construct and optimize it away...
Better use `intmax_t` from `&lt;stdint.h&gt;` than `long long`.
/u/ferraristealer already told you everything you need to know. You did not fix all the mistakes they pointed out. In cases like this, it helps to add `printf()` calls here and there. For instance print out the values of `a` and `b` *before* doing anything else with them. Also, please learn to indent your code.
You'd be returning something that nobody else knows what is. And like /u/Snarwin says, your code won't even compile because VLAs are not allowed in struct or union definitions.
When I try to run your program, it doesn't work either. But that's mostly because I don't *have* your program, so I just banged on the keyboard with my eyes closed for a minute or two and tried to run the result. But maybe if you tell us what you tried, what result you expected, and what result you actually got, we might be able to help.
I was able to resolve the problem. You are right, it had to do with the fact that wordHolder was not set to '\0'. Thanks for trying to help
"Git gud" seems to be the overwhelming response. I'll learn git and try to do better next time.
In terms of Git functionality I don't think that numbering branches would be the best use of git either. The numbers help me keep track of code. I can't remember what arbitrary functionality I implemented or at what time, but I can remember that around "05" the code looked like this, or that at "17" i switched over to something else. So I think I can emulate this approach by simply adding numbers onto the front of my commits.
I wouldn't call this good code. First of all, recursive functions are a terrible idea (at least in C) if, as with most math-related problems, iterative solutions are anywhere near as easy. GCF, factorial, nth Fibonacci number... They all are far more efficient on all common hardware when using an iterative process. Secondly, the code is not well-formatted. Thirdly, printf() is terrible, like a significant part of the C standard library (at least it's not as bad as the immeasurably ugly C++ standard library, which worsens with each new standard). It has more problems than I can list here, among them hackability, obsolescence, and much more. Don't use it; instead, use itoa() and fputs() if your library provides the former, or write your own alternative.
Yes, it is. And I thought GCC was the best compiler available! I should do an in-depth comparison using a variety of medium-size functions such as a partial implementation of string.h sometime.
i tried to run the program making a for loop for the arrays, well i think i have no other options 
If no comparison is provided, it means `!=0` "is not zero"
That's what the commit messages are for. Each commit has a short one liner describing what it does, and optionally a longer explanation. No need for numbers
`scanf` buffers the input, and if it fails, the same input is in the buffer. Which means if you don't clear it, then it will hit the same problem the next time it loops. You should really check the return code of `scanf` and handle this appropriately.
Well, that explains everything! No — wait — it doesn't — because you still haven't told me anything about your program, or how you ran it, or what sort of error you got. You understand that to get an answer, you must first ask a question, right?
Following on from my original post, if I run your program I actually get the opposite of what you're reporting, which is that the loop will only ever run once. When I debugged it I could see that the last `scanf` was picking up a newline character, which isn't 'Y' or 'y' so the loop terminates.
I think scanf reads the '\n' character, instead of y/Y/n/N. Maybe.
well, i put a space before "%d" in the last scanf: i.e scanf(" %d",&amp;option). Now all works fine and dandy. I still don't know why it works, though.
shove a bunch of pointers in a simple linked list implementation
Right? every time I look through microsoft's docs I have to open a text editor to translate their short/word/dword/ etc to regular, sized types that I NEVER manage to remember.
I'd recommend running with a loop over your input and take care char by char. Just make sure you don't make things too complex as this might leads to suffer from bugs and errors that are going to be hard to detect, ans unless you're using some programs such as checkmarx it is going to be a hard work to do that. Good luck!
You would not believe how many times I've made the same mistake, usually when I write the header before the code and just copy-paste the prototypes. And I've been programming in C for 25 years...
I wouldn't recommend on doing it, as it might going to complex things up and you might result with your code suffering from bugs and errors. And although can be detected with programs as checkmarx but I'd recommend on avoiding those complexity problems.
 if (i != 0 &amp;&amp; j == 6) if (i != 0 &amp;&amp; k != 0)
thank you!
thank you!
Not a solution to your problem, but you should use getchar instead of scanf for the yes/no input
How was your experience with GTK?
SDL is more aimed toward games and such. It provides an API for audio, video, input and whatever, and does not supply widgets such as checkboxes, radio buttons, lists, tables etc out of the box. When it comes to C, I suppose GTK is the go-to solution (at least, under Linux). When it comes to C++, Qt seems to be one of the winners there.
This conversation made me laugh so hard. I just wanted to let you know that your efforts haven't gone to waste.
I have nothing against Intel, Google, Facebook...IF they stop spying and data collecting massively I am fine to use any of their services But I can agree if all that for now! haha
A do-while loop executes its body at least once - it will do so before reaching the while test for the first time. You want a while{} loop, not a do{}while
rirc is a small side project I've been working on over the years. It's not nearly done, but it supports the functionality I use daily. I figured I'd offer it here as an example as a small-medium sized C project that a C newcommer could wrap their head around. Feel free to ask questions!
I don't get it. How is this any different than just `#include "foo-a.c"`? Lots of people already do this -- mostly embedded systems where a monolithic build like that has certain advantages since the compiler has access to all the symbols at compile time (basically a poor-man's LTO). On the other hand, there's very, very good reasons to have a separate compilation model. Not the least of which is allowing for incremental builds! That's not something you throw away lightly, just so you don't have to deal with `make`.
Do you mean this? #include "foo-a.c" #include "foo-b.c" This would work just fine. So if you would compile `foo-library.c`, you directly get a object file/library file. However, compilation might take a while, and you lose the ability to only compile selected source files (e. g. they have been changed since last compilation) if that is the only way to build the library. But there are libraries that generate such amalgamation file(s) (e. g. [SQLite](https://www.sqlite.org/amalgamation.html)).
 #include "foo-a.c" #include "foo-b.c" will fail if these two files contain `static int bar = 42;` for example. That why I mentioned "compilation unit" term. Check this: https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_015.HTM Visual C/C++ has pretty convenient `#pragma comment(lib, "OtherLib.lib")` that just an instruction to linker to include the library. So it is doable in principle. And `#include source "otherlib.c"` is similar to this - it compiles (if needed) and links .obj file(s). As of incremental builds... we do have .pch mechanism that is about incremental compilation of .h files. So why not .c ? 
Practical example from my [Sciter Engine](https://sciter.com): I have libpng patched by support of aPNG (animated PNG extension). It works on all platforms but not Linux. Even my .so contains all png_*** functions compiled statically, Linux SO loader substitutes steals them and substitutes by the one contained in some .so in Galaxy far, far away. Yet, in order to use libPNG you should compile it with headers containing particular version of libPNG. So the system shall contain all all libpng.so versions that are used by other applications. Thus I am not sure I understand that "for a reason". Theoretically - yes. Practically - no. 
&gt; is more complicated In 90% of cases simple #if / #elif construct is enough. 
True, but then again in 90% of cases a trivial Makefile is enough. If that's the only thing this is replacing, it's not worth the added complexity to the language/compiler/linker.
This is cool. Also kinda funny because I've been working on and off on an IRC server implementation (to get my hands on C networking): https://github.com/tehcyx/circ Haven't had too much time to progress and I'm thinking of transforming this to CMake, to learn how that handles multi platform building, since I switch platforms often.
You should check your file I/O operations for failure. That is, take their return value and examine it for whatever result is used to represent "this particular call failed". It's number 6 in [Henry Spencer's 10 Commandments for C programmers](https://www.lysator.liu.se/c/ten-commandments.html). Still worth reading though these days commandments 4 and 9 are a bit dated.
Hah, I dig the naming scheme. This started as a means to learn about C networking too, several years ago, and I just kept going with it. I use it daily so that helps with the motivation. There's some very old code in rirc that desperately needs updating, I learned a ton about good C over the years working on this.
&gt; You've described exactly what modern compilers do with precompiled headers already. Precompiled headers aren't anything so fancy. The compiler is completely dependent on the build system to track dependencies and recompile the header, and that process is stupidly simple: just dump the compiler's state after preprocessing and parsing a header file to AST. The compiler can load this up like a checkpoint and proceed to compile the next file. But you're right: if we can do this with headers, we can do it with compilation units. Because we already do: when the compiler has done everything it can with a single source file, it writes out the results in the object file to be linked later. Of course, the compiler is still dependent on the build system just like it is for precompiled headers. &gt; Instead of inventing those modules why not to add that simple [to use and understand] feature? `#include source` is easy to use and understand ... but it's not nearly enough to solve what C++ modules are trying to do. And even those aren't trying to replace the build system *at all*. In fact, the C++ committee has been very explicit about not making the compiler do the work of the build system with this feature. Also, you might want to look into the more recent versions of C++ modules instead of Clang's version, which won't be standardized. &gt; To do not create additional entities... Sources compiled in by #include source "foo.c" may use active #defines seen at point of inclusion. Thus you can pass defines from host file to child. That's an interesting benefit. In fact, I could see implementing this with a feature somewhat similar to precompiled headers: take a snaphot of the current state before compiling the child source file, and then restoring that state when you're done. That would allow parent macros and definitions to flow to a child, without contaminating between children. I'm not sure allowing children to see macros defined in the host is a good thing, I'll have to ponder on that.
Maybe try r/C_Homework/. 
I'm new to C, and programming in general but how do i start to learn how to write programs that don't rely on user input/output (if that makes sense)?
you need problems to solve that the user can't do themselves. Try and complete programming challenges given by sites like https://projecteuler.net/archives . Maybe look at some solutions to the easy problems and implement them yourself, then try some without looking at an answer.
I'm just beginning C now, so I know only about scanf(). Maybe I'll use getchar() later. Thanks for the suggestion!
Yeah, it was reading '\n' as its input character. Adding a space before the %c specifier instructed scanf() to ignore all whitespaces, and that solved the problem!
Yeah, it was. It was reading the Enter pressed on previous scanf() as '\n' character. Thank you for your replies, they were really helpful :)
Haven't heard of this yet. Will give it a read. Thanks
For the first problem you might want to take a look at the merge part of the [MergeSort](https://en.wikipedia.org/wiki/Merge_sort) algorithm. The idea is basically like this: 1. Allocate an array of size N + M 1. For each element in the new array, take the smaller element from arrangement A or B and move to the next element of that arrangement
So you want a makefile, except written in a different syntax? cmake is close enough, I guess. Everyone wants their own build system because they think that their idea is sufficient for all simple use cases. Except that everyones all simple use cases are slightly different so a general purpose build system that covers a sufficient portion of them will end up being as complex as the thing it replaces. How does your simple system deal with lex/yacc? How do you deal with compilation flags that are required on one flavor of linux and not supported on another (this is probably the biggest problem I have with building stuff today since in their infinite wisdom linux systems decided to make completely different operating systems all use the exact same standard identification in uname)? How do you tell your system that you're linking with a C++ library with a C interface and therefore need to use a different linker (more and more libraries are turning into C++ under the hood)? How do you deal with that library being built with different versions of symbol mangling depending on linux flavor (a problem when dealing with pre-built protobuf libraries today for example). Your simple example covers exactly one interesting behavior - compiling different files on different operating systems. Something you can actually trivially solve in actual C (I'm not aware of any OS out there that can't be identified with a simple ifdef), so it solves an unnecessary and trivial problem and without that it is nothing other than a list of source files. You can achieve the same thing to build your thing by providing a one line shell script for unixy systems and a bat file for windows.
I understand you've fixed your bug. But here is a style tip. Move the user prompt and user input into a separate function. You could call that function `again()`.
Re-inventing the wheel is most of the time just "learning how it's done". Wish I had more time to finish this.
Yesterday I was looking for alternatives to ccmake but I don't remember finding meson.any strong points in favor of it?
Since you didn't provide any code, we can't answer the efficiency question.
I don't see how your proposal solves the reported issue in that post. At some point, you will need to compile this file, at which point you still have all the problems mentioned there.
This is just for qn2 7am, and i gotta do it all the way to 6pm. it works, just wondering if theres a better way int x; int total8am = 0; float avg8am; float diff8am; for (x = 0;x &lt; 6;x++) { total8am = total8am + eightam[x]; avg8am = total8am / 12.0; } float diff8amSH = eightam[0] - avg8am; float diff8amPS = eightam[1] - avg8am; float diff8amlib = eightam[2] - avg8am; float diff8amcanteen = eightam[3] - avg8am; float diff8amEN10555 = eightam[4] - avg8am; float diff8amEN10556 = eightam[5] - avg8am; if (diff8amSH &lt; avg8am) printf("PM25 reading at Sports Hall is Lower than Average\n"); else if (diff8amSH &gt; avg8am) printf("PM25 reading at Sports Hall is Higher than Average\n"); else if (diff8amSH = avg8am) printf("PM25 reading at Sports Hall is Equal to Average\n"); if (diff8amSH &lt; avg8am) printf("PM25 reading at Play School is Lower than Average\n"); else if (diff8amSH &gt; avg8am) printf("PM25 reading at Play School is Higher than Average\n"); else if (diff8amSH = avg8am) printf("PM25 reading at Play School is Equal to Average\n"); if (diff8amSH &lt; avg8am) printf("PM25 reading at the library is Lower than Average\n"); else if (diff8amSH &gt; avg8am) printf("PM25 reading at the library is Higher than Average\n"); else if (diff8amSH = avg8am) printf("PM25 reading at the library is Equal to Average\n"); if (diff8amSH &lt; avg8am) printf("PM25 reading at Canteen 1 is Lower than Average\n"); else if (diff8amSH &gt; avg8am) printf("PM25 reading at Canteen 1 is Higher than Average\n"); else if (diff8amSH = avg8am) printf("PM25 reading at Canteen 1 is Equal to Average\n"); if (diff8amSH &lt; avg8am) printf("PM25 reading at EN10-5-55 is Lower than Average\n"); else if (diff8amSH &gt; avg8am) printf("PM25 reading at EN10-5-55 is Higher than Average\n"); else if (diff8amSH = avg8am) printf("PM25 reading at EN10-5-55 is Equal to Average\n"); if (diff8amSH &lt; avg8am) printf("PM25 reading at EN10-5-56 is Lower than Average\n"); else if (diff8amSH &gt; avg8am) printf("PM25 reading at EN10-5-56 is Higher than Average\n"); else if (diff8amSH = avg8am) printf("PM25 reading at EN10-5-56 is Equal to Average\n"); 
I'm not sure that's much of an improvement... #include &lt;stdio.h&gt; #include &lt;cs50.h&gt; int main (void) { { printf("how much change?\n"); { float change = get_float(); { { do { printf("how much change?\n"); { change = get_float(); } } while (change&lt;0.0); } } int a = (change/25); int b = ((change - (a25)) / 10); int c = ((change - (b10) - (a25)) / 5); int d = ((change - (b10) - (a25) - (c5)) / 1); printf("%i\n",a+b+c+d); } } } ...and that's *after* I cleaned it up a bit.
Im learning it from the original book "The C Programming Language". 
Tony Royce - C Programming is what I initially learned from. Really great book. Takes you from the basics all the way up. (there's one question I still can't do to do with triangles, so don't worry too much about getting every question) 
Stanford's "Essential C": http://cslibrary.stanford.edu/101/
`#include source` will work with any existing build systems: makefiles, IDEs, etc. Simple as that. To include library in makefile - add one .c file. To include library in IDE - add one .c file. And you can use it without makefiles, this will compile and build executable if rootfile.c includes sources of all what you need: &gt; cl rootfile.c 
Any idea if you can use SIMD for executing operations on multiple members of the vector at the same time?
No idea what allows/prohibits/hints the compiler when to use SIMD. Anyway, C itself has no notion of SIMD. If you're interested in that kind of performance, wouldn't it be better to write it in inline assembly anyway?
&gt; Is it easier or harder to create security vulnerabilities, memory leaks, undefined behaviour etc in C programs than it is in other higher level languages? It is neither easier nor harder. It takes approx. the same amount of lines of code to program any of those things you listed in any programming language.
Please show me some Java code that contains a memory leak. Or some Javascript code that has a race condition. Or some Rust code that contains a null pointer dereference. Or some Go code that contains a buffer overflow.
Look at your code. Do you see how much of it is just almost the same code repeated over and over? This is usually a symptom of structuring your data incorrectly. You should learn how to use arrays and structs to structure your data, and how to use loops to handle your data without using the same code over and over. In the assignment description the data is structured as a table. You can structure it the same way in your code using 2-dimensional arrays. - Make an an array `float diff[][]` where the first dimension is the time and the second dimension is the location. - Put the names of the different locations in an array using the same indices as the second dimension of the diff array. `char *places[] = { "Sports Hall", "Play School", "the library", ... }` - Use loops to manage your data.
Let me Google that for you: http://lmgtfy.com/?q=java+memory+leak
Beej's Guide to C?
I would use a `while` loop with `scanf` using the `%x` specifier to read in the numbers. From there you can use bit shifting or a `struct` with a bit field to parse out the op code and operand.
If you are impatient you better calm down first. There is a lot of bad apps made from hurried programmers that did not learn enough and yet complains about how the language works! 
Duplicating effort and reinventing the wheel is a time honored unix tradition
No they should make as many things as they can - no one is forcing them to release stuff into the wild, and actually working on a project in a new language is the best way to learn it.
Ok, and how many lines of code does it take do do in each?
The 0x prefix means that the rest of the number is to be interpreted as hex. If you convert to binary, it will be clearer why those particular numbers are being used 0x20 = 0011 0000 0x3f = 0011 1111 0xc0 = 1100 0000
Do you have any homework or a job you want me to do for you as well? Do you want me to clean your room? What other jobs of yours do you want me to do for you?
You're being completely dishonest if you're trying to tell me that memory leaks are as easy in C as they are in Java. You're also ignoring the fact that in many languages buffer overruns are not possible, so your original statement "those things are as easy to do in any language" is incorrect.
if you say so! 
A number is a number, decimal, octal and hexadecimal are ways to represent those numbers. In C, prefixing a number with `0x` makes the compiler interpret the number as hexadecimal than decimal. Prefix the number with a `0` to make the compiler interpret the number as octal. (Note that there is no way to specify a binary number AFAIK) Thus the numbers `0xCF`, `0317` and `207` are the same numbers. If you convert `0x3F` to binary (e. g. the windows calculator can do it, switch to the programmer mode), it is `0011 1111`, which is a mask to get the 6 bits containing the "number", throwing away the two bits that correspond to an opcode. `0xC0` is the inverted version of `0x3F`, so the code related to it always sets these for some reason (not enough context) (and then subtracts `256` of it, for some reason.. sign extending maybe? No idea).
1.2 million search results for java memory leaks. Just make a for-loop allocate an object for 4.2 billion iterations. You sound like a 21 year old CompSci student who's quoting what your prof told you. Garbage collection != no memory leaks possible. Single-threaded execution != no race conditions possible. myBuffer[1000000000000000000000] = 12345; ^ There you go, a single line buffer over-run in any language.
Nice ad hominem. I never said garbage collection meant no memory leaks, I just said that it meant that memory leaks are *much harder to do*. Which is true in the case of Java, because you don’t have to worry about explicitly destroying objects like you do with `free` every time. That alone is a significant burden from the programmer, is it not? And single threaded execution does pretty much mean no race conditions, unless there is a problem with the underlying runtime. Memory leaks are much rarer problems to have in Java than in C. Race conditions are much rarer problems to have in Javascript than in C. And your buffer overrun won’t even compile in a lot of languages. Even if it does, the majority of remaining languages will crash, negating much of the possibility for a security vulnerability. Think about if heartbleed had happened in say a python library. It would have not been a problem at all.
Good bot
Here, have an upvote. K&amp;R is still really good to learn C, even if it's starting to age now. 
Check out the `dirname` function to peel back path elements layer by layer.
Check out `strtok` which will tokenize a string for you. `strchr` may also be of use to you.
Thanks. I managed to do it on my own :O without any function :(
ISO C does not have binary literals but most compilers support C++-style `0b00111111`
Have you looked into fprintf?
Check out the printf functions.
my assigned output is binary file, but fprintf is for text file right
The | and &amp;s are bitwise operators. They aren't specific to hex literals.
Here is your solution. #include &lt;stdio.h&gt; int main() { int n, i, cube; for(i=1; ;i++) { printf("\n\nEnter the Number "); scanf("%d",&amp;n); cube=n*n*n; printf("Cube of Number %d is = %d",n,cube); } return 0; }
Is the format literally a character 'O' followed by a binary representation of a number? If so, just fputc('O', out); fwrite(&amp;intvar, sizeof intvar, 1, out); 
Try /r/C_Homework
i havent learn fputc i am afraid it cant be implemented in my program
it's not in my syllabus i am afraid i cant implement that
You haven't been taught basic stdio functions? That's pretty sad. Anyways, [here you go](http://man7.org/linux/man-pages/man3/fputc.3p.html). Now you know fputc().
You can reach the same result as `fputc` using `fwrite`. How to do this is left as an exercise to the reader.
If you want to output a sequence of chars (`'O'`, `'0'`, `'0`, `'1'`). `fprintf` will do that for you. The issue of whether your file is 'binary' or 'text' is somewhat blurred if you're just writing a sequence of chars to the file. Your post makes it sound like a sequence of chars is what you're attempting. Now, if you were really doing a 'binary' file, I'd expect you to want to output an `'O'` followed by an `int` (as in a 32 or 64 bit value, not a sequence chars representing the digits). This would mean two calls to `fwrite`, one for the `'O'` and one for the `int`. You'd use corresponding (properly ordered) calls to `fread` to read the data back in. That fact that you want want leading zeros on the numbers makes me think this is unlikely since that's inconsistent with the binary format. If this assignment really stipulates a 'binary' file, what I'd expect is the order would be represented by a struct and you'd use `fwrite` to write out the order (a struct) in one shot. More info on the precise file format and which calls you're allowed/disallowed is needed to get a better answer. 
Are those static asserts for struct packing there to catch mistakes in your own code or are there some edge cases when compilers will make them the wrong size?
strtok isn't a good option unless you are certain that you can modify the original string. It's also not thread safe. 
The book that u/Osagiel recommends, sometimes referred to as K&amp;R, is the best way to start learning C. It does a fantastic job at keeping things simple and it's all very easy to pick up. You could probably finish the entire book over the weekend and have a running start on writing C. Coincidentally, the 2nd edition recently became free https://archive.org/details/CProgrammingLanguage2ndEditionByBrianW.KernighanDennisM.Ritchie
Making a modifiable copy of a string is trivial, as is using `strok_r` if you require thread safety.
Generally, you'd use intrinsics (e.g. `_mm256_add_ps`) as opposed to inline assembly. It fits in much easier with existing code, and given a competent compiler, should be just as fast.
[Is this what you wanted?](https://www.dropbox.com/s/hsa02eumxjglpz6/RandomWalk2.exe?dl=0)
What am I looking at.
&gt; I would also recommend reading "Advanced Programming in the UNIX Environment" Not a book for the impatient. &gt;The best resource I've found for C are the man pages What man pages describe loops and functions and switches?
Too silly.
If you’re impatient, then search the internet about loops and functions and switches. Man pages describe specific functions and the book goes into detail about threads and networking as concisely as it can. All languages, especially C, require some patience to understand the basics. People have already mentioned K&amp;R C, which I think is a good place to start. Once you know the basics, the next step is to take these resources I mentioned and have them open while you write code.
Are you retarded? Please identify yourself to me as I can make your life a whole lot "easier". haha JK just talk to me and I will be your saviour
Thanks! So many more things to learn.
Parse the string from left to right and check for the existence of every piece along the way.
So strdup first. I don't think a toy application is going to be multithreaded.
Congrats, you did someone's high school programming problem for them.
In C, zero evaluates to "false" and anything non-zero evaluates to "true". Here's another example that loops down from 5. Once it hits 0, the condition evaluates to false and the loop finishes. $ cat tmp.c &amp;&amp; gcc tmp.c -o tmp #include &lt;stdio.h&gt; int main(void) { int i = 5; while (i) { printf("%d\n", i--); } return 0; } $ ./tmp 5 4 3 2 1
Which functions have you been told that you can use? It's almost impossible to write a useful program without standard library I/O functions like that. If you specify what exactly the question was and what you've been taught, we can help you out.
Are you enjoying yourself?
I don't understand what you're trying to say, but I can confidently tell you, no, there's a reason C isn't implemented like that. #include literally just copies and pastes whatever file you give it. I.e. you can do this: `foo.c` #include &lt;stdio.h&gt; void foo() { printf("foo\n"); } `main.c` #include "foo.c" int main(void) { foo(); } Let's build and run it... $ gcc main.c -o main $ ./main foo Separate compilation units that can be built independently and then linked later (either statically or dynamically) is a *feature* of C. Yes, you could write your program that included literally every .c file of every tool that you're using, and then build that. That's a crazy amount of dependency though. You need all of the source code, for example, so kiss proprietary software goodbye. It's also way more compilation than is needed. It's inefficient and rigid (not flexible). Does that make sense? Am I understanding your suggestion?
&gt; Visual C/C++ has pretty convenient #pragma comment(lib, "OtherLib.lib") that just an instruction to linker to include the library. So it is doable in principle. And #include source "otherlib.c" is similar to this - it compiles (if needed) and links .obj file(s). It sounds like you're resistant to just linking the objects after they're compiled. Why do you think it's preferable to link that in the source code rather than in the Makefile?
I believe C will gain support for the `0b` prefix in C2x.
This assignment is terribly written. 
He, not me, said he was impatient to learn C. You said to read the man pages to learn C and it was the best way. How would one learn the basics of C through man pages? &gt;All languages, especially C, require some patience to understand the basics. Then your answer should have been, "You can't.", cause he said he has no patience.
The standard doesn't guarantee the will be packed.
C11 vector library.
so, where is your sourcecode? it's hard to spot a problem if it isn't there...
hi well i keep writing it and erasing it i have nothing useful, I have tried a million things. The best I can do is read the entire file and write the entire file, I'm wondering if there's a way I can just read parts of it. I could try writing again but it isn't much use i dont know what to do anymore 
I am not on my computer right now and am rather new to coding in C++ so I cannot give you any exact code for now but got some approaches you could take. Firstly, use "std::getline()" to get the text from the file and iterate over the entire string. When iterating over it make sure to get rid of all the spaces. After, iterate over the spaceless string and check for colons, and whenever a colon is found just add all the integers after to a new std::string using "+=".
have you tried googling "c read part of file"? anyway try `fgets()`
hi, fgets() gives me an entire line including text so it is not being helpful thanks for response
thank you i'll read about that command i appreciate the help a lot
look into the string.h and stdio.h library. There are many useful functions that can help you.
well now you have a line of text, that's better than nothing. Have you heard of `strtok()`? 
if you are programming C and not C++ then this doesn't work
No such thing as `std::` in C. No builtin string type either. 
As I stated earlier, other people already mentioned resources to learn C basics. I just brought up the next step. "You can't" is a useless answer, just like your replies to my comments :)
ok thanks yes I'm using C
It sound like what you are trying to do is a [control break](https://en.wikipedia.org/wiki/Control_break). If I understand you correctly, you are trying to produce output something like this: Header column1 column1 column2 column3 ================================ Order# 1 item1 item1 item1 item2 item2 item2 Order# 2 item1 item1 item1 item2 item2 item2 item3 item3 item3 Totals If this is the case, you need to save the OrderID, then test to see if it changes. When it changes, you will print out a new record header and update the current OrderID. 
**Control break** In computer programming a control break is a change in the value of one of the keys on which a file is sorted which requires some extra processing. For example, with an input file sorted by post code, the number of items found in each postal district might need to be printed on a report, and a heading shown for the next district. Quite often there is a hierarchy of nested control breaks in a program, e.g. streets within districts within areas, with the need for a grand total at the end. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I understand a lot better now thank you :)
yup exactly this output, i tried to copy orderId to current id then check with if statement if same then i will print out the foods, if not then i update the current id right?
`cut -f2`
`b` holds a single char. Every time you assign to `b`, the previous value of `b` is replaced with a new value. So at the end of the loop, `b` will contain the last character that was read from the file. Note that the function is incorrect as it is written: If the file is just one byte to short, it returns `(char)EOF` instead of `'\0'`.
Oh dang, I am so sorry, I mistakenly thought you were talking about C++
What this does is read one byte at a time `i` times and return the last one. It returns `'\0'` (which is just a fancy way of writing 0) if it reaches the end of the file before reading `i` bytes. Note that this function does not handle I/O errors, leaks a file handle every time you call it, and is written in the most unnecessarily complex way imaginable. Even if you're not allowed to use `fseek()`, you can do: unsigned char read(int i, char *file) { FILE *f; int ch, j; f = fopen(file, "rb"); if (f == NULL) return (0); for (j = 0; j &lt; i; ++j) { ch = fgetc(f); if (ch == EOF) break; } fclose(f); return (ch == EOF ? 0 : ch); } I kept the original prototype, but it would have been better to have it return an `int` instead of `unsigned char` and just return `ch` at the end, since as it is, if it returns 0, there is no way to tell if it failed or if it actually read 0 from the file.
&gt; If the file is just one byte to short, it returns `(char)EOF` instead of `'\0'`. Nice catch, I didn't notice.
We are allowed ot use fseek(), but thank you for this. 
I would test to see if the OrderID changed. If it did I would print out a record header. Something like this: currentID = "XXXX" Print header WHILE not EOF read record IF record.ID != currentID Print record header currentID = record.ID END IF PRINT record END WHILE
okeii let me try, thx for the reply, really appreciate it :)
i think i still need a while loop outside out your first statement because where can i get the current id assignment
Looking at it another way, you now have the whole line read into your programs memory, and can do what you want with it. From there you could try searching for the colon and reading the integer after it. Look into functions like sscanf, fscanf, etc.
Ahh, that explains it. Thanks
I don't think the name of the variable can be the name of the type 
So I can just change the first state to an arbitary name?
Yes, that should work.
&gt; I just brought up the next step. Which is my point. It doesn't answer the question and that makes your answer pointless here.
I replaced it with s so I have s *state but now I get an error message saying unknown type name.
If you wrote `s *state`, you declared `state` as a pointer to something of type `s`. I think you want this to be the other way round, so your variable name is called `s`.
Be sure you try out your function with a file that doesn't exist to see how it handles that scenario. How will your code respond if 'in' comes back NULL?
Ah that did work thank you! On a similar note, I have a function called: new_state(state, file, i, 1); This expects an expression before state, replacing it with variable s just gives the error s undeclared and using the state *s gives the same expected an expression error.
Could you post the full code? I'm not exactly sure how what your code looks like.
Will do
Okay, when you call a function like this: new_state(state *s, file, i, 0); it's wrong to declare `s` again. Remember: each variable is declared exactly once. So in this case, correct would be new_state(s, file, i, 0); However, this still fails as there is no variable named `s` in scope. To fix this problem, you have to declare a variable `s` somewhere in `main_function`. Every variable must be declared before it can be used and variables declared in functions are only visible there. So to correct your code, declare `s` for example like this: state s; But note that now since `s` is a variable of type `state` as opposed to a pointer to a `state`, you have to take the address of `s` when passing `s` to `new_state`: new_state(&amp;s, file, i, 0); A question left to you: you could also declare `s` to be a pointer to a `state` by declaring state *s; and then passing `s` to `new_state` like this: new_state(s, file, i, 0); However, if you do this, your program won't work. Why is this so?
Is it because declaring state *s is just pointing to the structure of state and so is just allocating space but isn't actually holding anything it ponits to, so technically isn't anything until you give it an address?
You missed the point completely. Compilation of this // all.c file #include source "a.c" #include source "b.c" using command line: &gt; cl all.c is essentially this: &gt; cl all.c a.c b.c where `include source`s skipped from compilation of all.c but added into the list of sources of the compiler/linker. What problems do you see with that? 
Also after changing new_state, draw and new_pen to &amp;s and adding state s; to main_function I still seem to get the error message expected declaration specifiers or ‘...’ before ‘&amp;’ token for &amp;s
1. not all platforms use makefiles. 2. IDEs are tend to do **not** use makefiles at all. 3. There are different malefile mechanisms. Code::Blocks uses XML based project formats. CLion uses CMakeLists. XCode its own. MSVC its own. Proposed mechanism (probably combined with unified compiler plugins infrastructure) will allow to share libraries between all of them including GNU make, JAM (boost), premake, etc. 
Please show me the updated code.
Exactly! You got it.
Answering the question is second-priority to providing useful information. Feel free to disagree.
I like your IRC client a lot :) I've been using it for a while now.
keep looking! haha
http://libgen.io/book/index.php?md5=8DA872E974D71A3DA307F439DC269560
check what group /dev/tty0 is, add the user to that group (don't know for sure it would work, but worth a try!)
That's my point. It doesn't answer the question. But we could go on and on about it.
No requests for illegal copies of books please.
That's in the `tty` group. I tried adding my user to the same group and also running `setgid` and `setegid` in my program. Even after running `chgrp tty [file]` and `chmod 2755 [file]`, it's still unable to give me a file descriptor for `/dev/tty0`. I have yet to get to the `ioctl` call, but I believe I may have a solution to that bit, file capabilities.
`int f(int)` defines a function that returns an `int` and accepts one `int` as the first parameter. `int f(void)` also defines a function that returns an `int`, but it takes *no* parameters.
I don't think you can do this as that's a massive security hole if possible: a malicious program could change the virtual terminal to snoop passwords from the user.
&gt; if I'm using void everything is simpler. What is “to use void” supposed to mean?
I assume OP is just using globals.
Answering the question is not a requirement for commenting on a post. See above comment.
Well then, why don't you just seek to the correct position?
This is incorrect use of `feof`, the loop is wrong and may mess up the last character. I hope that isn't code that was given to you by the "teacher". 
Please be civil.
how? it's kinda blindingly obvious when the VT changes...
An attacker could prepare the other VT such that it has the same content as the current one. You won't notice the difference.
Suppose I have a function that takes a function and divides it by two. Let's call this function div(). If I use "int div(int)" then I can give it 4, and it returns 2. However, if I want to do the same thing for "int div(void)", then I have to set a global variable beforehand in the caller function. This might seem simpler now, but imagine I accidentally flip the two lines which set the global variable and call the function. So, that instead of setting and then calling, I call and then set. This would mean the function would return something I don't want it to return. So, if my function uses a value, it is better in the long run to pass this value in as an argument.
Much more convenient
Don't use printf(), at least not for character strings without extra arguments like %d; instead, use puts("random string") or fputs("random string", output.txt). Also, while there's no problem with using puts(), DO NOT use gets(), instead use fgets(), which prevents buffer overflows, tied to stdout.
I couldn't read the code as the formatting on reddit mobile is terrible but you have two options. Make the vondition evaluate to something false or use the `break` keyword to stop the loop immediately.
Also if you cannot find said ID why not have a boolean to keep track of if you have found one.
i cannot use break because if i put an if staement inside the computer will scan 1 record and if the first scan not the record user type in the loop will be exit automatically, and i have used boolean "found" i my code.
No comments, no examples, no context, just a link to a page of code. Responding with the title again isn’t helpful. 
You want to provide instructions to the linked in code rather than in the upper level makefile. Is that right? 
It would be easier for you to learn how to link things correctly in whatever environment you’re using than try to get some unnecessary new standard established.
Also, if you use globals then x = div(y) / div(z) is hard to write. 
`fscanf` will only read one entry from the menu file.
yea, so i need to loop in order to find wht user keyin 
This code is simple enough that auto-vectorization shouldn't be a problem for most compilers, assuming you tell the compiler to do it (*i.e.*, `-O3`, or at least `-ftree-loop-vectorize`). Turning on various SIMD ISA extensions (SSE, AVX, NEON, MSA, whatever your CPU supports) is also important, of course… That said, it wouldn't hurt to make it a bit more robust by adding some annotations (*e.g.*, OpenMP 4 SIMD, Cilk Plus, [GCC loop-specific pragmas](https://gcc.gnu.org/onlinedocs/gcc/Loop-Specific-Pragmas.html), [clang pragma loop hint directives](http://llvm.org/docs/Vectorizers.html#pragma-loop-hint-directives)…) You're still probably not going to get great performance unless the compiler can figure out the vector length at compile-time, and the API doesn't make that easy.
Simplest way to do it is to express the loop condition as `y &lt;= stepy*y1`. You can even do the same for the other case `x &lt;= stepx*x1` and that will eliminate the need for swapping. The other way would be not to swap based on comparison between `x` and `x1`, but first calculate and compare `dx` and `dy` to see which coordinate will the loop iterate over. If it's x-coordinates (`dx &gt;= dy`) swap if `x &gt; x1`. If it's y-coordinate (`dy &gt; dx`), swap if `y &gt; y1`.
Please don't write misleading subjects,had I known that you are asking for some one to do your homework I wouldn't have bothered opening it
Check the result of `fscanf`. If it didn't read the whole order, check the result of `feof` to see if the whole file was read, then exit if needed.
Ask for an extension and don't ask others to do your homework for you. If you come with specific C related questions we may help with that.
Better get coding then.
I feel like you asked a specific question ("Why pick int over void") when the fact that you're asking these questions shows you have trouble understanding functions as a whole. I recommend going back and looking at your class on functions for help, but maybe I can give it a go. So why use functions at all? Functions help you automate an action. They're a piece of code you'll never have to re-write again, because you can just call the function instead. So let's say for example I have a program where, for some reason, I tend to do this action a lot: I take a number, divide it by two, add one, then multiply the whole thing by itself: int result = (x / 2 - 1)(x / 2 - 1); and I do this maybe a dozen times in my program at various points. But I'm a programmer and I'm lazy, so i decide to make this specific action easier. Instead of having to write this twelve times, I can use a function (written on one line for formatting convenience): int myfunction(int x) {return (x/2 - 1)(x / 2 - 1);} Now, to break down what this says: I'm declaring a function called "myfunction", it takes an int as input and spits out the result of that annoying calculation as output. The important part is the concept of input, because now I can call "myfunction" on *any* nunber and it'll do this much faster than if I had to type it all: int result = myfunction(1); int result2 = myfunction(41); etc. If "myfunction" took no input, if it looked like "int myfunction(void) then I couldn't feed it specific values, because a function is *self-contained* and the only inputs it should get from the outside world is what's passed as parameters.
It's 100 lines of primitive code.
Unfortunately this doesn't work, I tried it before implementing the current messy solution, and again this morning on your suggestion, hoping I had simply made a mistake before. What happens in this case is that when the swap happens _after_ the value of dx and dy being adjusted to their absolute values, the for loop will keep running forever in certain cases, as the check for y &lt; y1 will never be satisfied if the step is -1. I'm taking another look at this today, but the closest I've come so far is a scenario in which only lines with negative large slope do not plot. If anyone is willing to clone that repo and play around for a bit I would be grateful, its driving me crazy. Thanks
Oh, thanks for the advice... But did I say anywhere that I don't know how to use makefiles? I am already compiling my [Sciter](https://sciter.com) for five different platforms + maintaining samples for 4 different IDEs. I am using several external libraries other than my own. I see that zoo each day in real life. As an example: [Skia](https://skia.org/) uses GYP build system. Some other library uses premake, another one uses [jam](http://www.boost.org/build/) ... Legion is the name of them. 
If you clone the repo's [testing](https://github.com/Ethan-ks/bresenham-siml/tree/testing) branch, you will see the extent to which I have got it to work without the extra conditional. Still the problem lies with negative large slope, including a vertical line with negative slope. The result can be seen [here](https://ibb.co/cNSdZm)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Ethan-ks/bresenham-siml/.../**c35b0a1a94184f89b4e0b5ce6d2c4b2d6ea42169** (testing → c35b0a1)](https://github.com/Ethan-ks/bresenham-siml/tree/c35b0a1a94184f89b4e0b5ce6d2c4b2d6ea42169) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drdoqup.)^.
Well, after swapping the endpoints you need to recalculate all the dependent values like `dx`, `dy`, `stepx` and `stepy`. When iterating over `y`, `stepy` should then always be 1, just like in your initial code, `stepx` is always 1.
I don't often use windows but a while back I needed to compile something for a windows user, I ended up installing the Linux subsystem for windows, which made things a lot less painful than my memories of mingw... https://docs.microsoft.com/en-us/windows/wsl/install-win10
Why not go full instead of those homeopathic projects in Windows trying to mimic capabilities of the glorious GNU Linux platform. Windows is painful if you are not an end-user! 
C# is off topic in this subreddit. Please post C# questions elsewhere, e.g. to /r/csharp.
This subreddit is about the C programming language. Please ask general programming questions and post general programming discussions elsewhere, e.g. in /r/programming.
Or just rip the bandaid off and go all-in and install a proper Linux distro.
* GSL: You'd have to download a Windows build, including headers and DLL. Looks like [GnuWin32 has one](http://gnuwin32.sourceforge.net/packages/gsl.htm) * MEEP: This isn't supported on Windows. At best you can use Cygwin. Regardless, you can't use it with Mingw-w64. If you insist on doing this on Windows, consider doing all your development within Cygwin. Cygwin will make it much easier to install and use GSL, too. * OpenMP: Typically comes with Mingw-w64. Depends on how you install it. This is the easiest of the bunch. 
MSYS2 gives you a package manager (arch linux's pacman) to make installing mingw64 stuff easy.
Ha! I agree but i'm hoping my builds will be used by others and so i'm trying to make it end-user friendly
Install a Linux distro, even if inside a virtual machine. It will all make sense.
WSL is pretty decent, I've used it before and it worked fairly painlessly for me on Windows
oh! 
I can generally recommend you to use SSE intrinsics where possible. It's just much easier than writing assembly and you get the advantage of the compiler being able to choose VEX encoded instructions when available. Also, the compiler might be able to optimize your intrinsics, yielding better vector code than you originally wrote.
is it possible for the hand written assembly to be faster? should I test which is best for each case?
It is possible for hand written assembly to be faster if the compiler “optimizes” your code to make it slower. However, this rarely happens (I have never seen that happen). Generally, intrinsics are at least as fast as handwritten assembly as every intrinsic directly corresponds to an instruction. You can translate your assembly to intrinsics simply by replacing every instruction with the corresponding intrinsic. Another advantage of intrinsics I didn't mention before is that the compile can inline functions written in C with intrinsics but can't do so when the function is written in assembly. This can give you a nice extra speed boost since the compiler can avoid the overhead of a function call (saving and restoring registers, potentially loading data into vector registers). Inlining also enables other optimizations like hoisting computations out of loops, constant propagation, or common subexpression elimination.
ah ok thank you. I think I'll go with intrinsics then doesn't seem like there's any disadvantages to them
It's easy to use msys2 to install OpenBLAS, which I would highly recommend anyone doing if they wish to get into scientific computing. Though, I think Intel's MKL is available for personal use too.
Arrays don't get passed to functions. What you really have is void name(char *charname[){ So now you can see why scanf("%s", &amp;charname); is wrong
I'm afraid I don't follow. Are you saying Charname needs to be a pointer rather than an array? If so, I'm confused how I would pass the string up.
charname is already the right type to pass to scanf; you don't need to take the address of it.
Are you asking how you *detect* that the record is not found, or how you exit the loop once you have detected this situation?
how to exit the loop when the record was not detected
I use a simple IDE called ZinjaI, but it is a C/C++ IDE. Being a beginner I needed a lightweight IDE, that is cross-platform. (Link: http://zinjai.sourceforge.net/index_en.php?page=portada_en.php) 
ICC and modern Clang can sometimes optimize inline assembly, as long as it’s not too complicated or directive-laden.
If you are using ICC then all you need is a few pragma directives and compiler flags and it will do a better job at vectorization than you will, or at least that was my experience. 
When you pass arrays with pointers only the first entry is passed. Correct me if im wrong
I have to make code that's fast for both amd and intel systems, will the intel compiler actually do this? I thought I read somewhere that it intentionally added instructions that are harmful to amd or something like that, don't take my word for it tho.
You should almost never write assembly directly in a modern program. If you really think some chunk of your code isn't fast enough, you should first profile it. Then profile it again. And again. Find out where it's spending most of it's time. Next, look at the architecture of the code that's taking the most time. Can you design it in a way that it can run faster? If you've done all that and still actually feel like you can do better, start with the compiler's generated assembly and go from there. You probably won't be able to beat it though. 
Never mind then. Intel’s compiler is known to produce unoptimized code for AMD. You are better off going with Clang or GCC. 
thank you!
An array is represented in C as a pointer to the first element in the array. Passing an array without dereferencing it passes the address of that element, not the value itself. 
But for ex: a[]={3,5,...} When you call a by a pointer does it not equal to {3}? 
C uses pass-by-value semantics. When you pass a variable as a parameter to a function, its value will remain unchanged after the function call. The way you pass in choice, choice1, and choice2 is unnecessary, as their values are not changed after intro(...) exits. To do what you're trying to do, you would need to pass in a pointer to these elements (note - it's still using pass-by-value semantics; however, by passing in the address of a variable, we can modify it within a function call). Additionally, there are a few other issues you might want to address. 0. You use multiple if statements to check the user input. A more idiomatic way to do this in C (if you're comparing against constant expressions) is to use a switch statement. 1. You don't validate the parameters you read in using scanf. If the user doesn't enter an integer, you're using bad values. 2. While your use of recursion is clever, it may be better to use a loop instead. This way, it is clear exactly what portion of the code need be repeated. Additionally, it would get rid of a potential bug for compilers that don't offer tail call optimization, which could result in a stack overflow error. Lastly, it helps with maintainability. Namely, you might want to refactor this code in the future so that some initialization js done first in intro(...), and then the user input is queried. Since you currently recurse, you might make a second call to something you intended to be run once. 
 long a[] = { 3, 7, 5}; long x; x = a; /* x gets the address of 3 */ x = *a; /* x gets 3 */ x = *(a + 1); /* x gets 7 */ x = a[1] /* same as above */ Really, array notation in C is just syntactic sugar. So, passing in a pointer to the first element feels the same as passing in the whole array - you can still make accesses to the other elements. Because all an array is a chunk of memory, which you access using an address to one element, and an offset between that element and another. As a result of this, a lesser known bit about C is that, since addition is commutative, an array access arr[N] works with the names flipped, i.e. N[arr], since both evaluate to *(arr + N). 
GCC actually can automatically convert some code to vector instructions. I forget the specifics, but there's a cmdline switch. https://gcc.gnu.org/projects/tree-ssa/vectorization.html
I'm aware but I'd rather make sure it happens
Yea, you can just disassemble the exe and look for yourself. If it's not doing it then I imagine the code needs a simple restructuring in order to trigger the code in the compiler that recognizes a situation warranting vectorization.
mine is not a program but a library of sorts I guess I could make sure that gcc autodetects it but I don't see the point of it's just as fast, especially since I'd have to rely on whoever it compiling it to have that option toggled too
I know, thanks for the input. This is just a rough program I started today, I'm planning on adding in all that stuff in the future.
I don't know what exactly you mean by "call a by a pointer", but the likely answer is "No". As mentioned elsewhere, in C an array is (essentially) just a pointer to the first element of the array. So when you pass an array a to a function, you are passing a pointer to the first element.
So is this after fscanf(), or the strmpc(), or what? But in any case, you can exit a loop with a break statement. I think your real question may be "After the array, how do I tell if I exited because I found it, or because of a break"...in C there is no way to say "run this code only if the loop terminates naturally", you need to use a separate variable; but in this code, you already have the "found" variable which will work.
Pretty much never, unless you really need to. Your time is almost always better spent on something else. Especially simple things like linear algebra the compiler will probably do a good enough (or better) job of vectorizing anyway (your time is best spent fiddling with compilation flags and reading the generated code) and also it has probably already been written so it's much better for you to just steal someone elses code and maybe spend some time understanding it and improving it rather than rolling your own. Programming is a trade off between software performance and programmer performance. Yes, you can almost always squeeze out a few more microseconds here and there, but it's almost always only worth it when your time (current and future) is worthless or you're writing a general purpose library that will be used by dozens of other projects or you're writing for a client who has lost count of the number of racks of machines they have and 5% less CPU used rounds down to a significant number of physical machines they won't need to buy in their next upgrade cycle. But when it comes time to hand-optimize things, I go for the intrinsics because that allows the compiler to inline things a bit better and linear algebra is pretty much the only place where inlining still helps. Raw assembly is only relevant when you're talking to hardware directly and need it as an optimization defeating device (locking, special registers, such things).
You’ve already got a number of good answers (and yes, to add one more vote for intrinsics I’ll add that assembly should always be the last resort, for small specific library routines, e.g. a highly optimised memcpy). I just wanted to add that this issue, and many other common beginner SSE questions are very well covered on StackOverflow - try browsing questions with the [sse] tag - there is a lot of useful info to be found. 
Very helpful answer, much appreciated. Thank you!
Wasn't it forbidden after antitrust lawsuit? 
The lawsuit just stops Intel from intentionally producing code that's slow on AMD machines. There's nothing requiring them to implement AMD optimizations.
 void new_state(&amp;s, char *file, int i, int j){ That's a syntax error, as you've seen. What type is s? And a parameter/variable definition of `type &amp;name` isn't valid C even if you add that in.
Yeah I realised I should've been state *s, but does this mean it should change when calling new_pen(s)?
The line `void new_state(...) {` declares what arguments `new_state` takes and what their types are. Thus, each entry in the parameter list is a *declaration* with type and all the shebang. However, when you call a function like in the line `new_pen(s);`, that's not a declaration and you don't specify types there. The compiler already knows what type `s` has at that point and it also knows what arguments `new_pen` takes.
I'd say leave it up to the compiler to decide. LLVM has vectorization enabled by default (which you could override by disabling) but uses a cost model to decide whether or not it should vectorize. [Here's](http://llvm.org/docs/Vectorizers.html) some information about it. Notice that you can still force the compiler to vectorize regardless of cost model outcome but it might mean the code will run slower. Good luck!
difficult if you want a 64bit windows exe, thankfully I often don't so have a saner experience, incidentally I found WSL to be not as efficient as the "real" thing...
Visual Studio is okay for a beginner and okay if you want to develop software for Windows. However, note that Microsoft's C compiler is very bad at supporting modern C features like atomics or variable length arrays. Many of these are not available. &gt; GCC keeps not executing my a.exe files though because "Permission is Denied" and I'm not sure why. It's not a compiler's job to execute programs. What exactly are you doing to get this error message?
Probably trying to recompile while the program is still running. Windows doesn't allow that. Neither does Unix, technically, but the compiler usually replaces the old executable with a new one rather than overwrite it, and that isn't possible in Windows.
&gt; Neither does Unix, Depends on the Unix and the file system you use. Not all file systems (especially network file systems are notorious for this) have the machinery to support reporting `ETXTBUSY`. You also don't get an `ETXTBUSY` when trying to write to a shared library in use, you just get a crash.
Visual Studio 2017 can use Clang with full C99/C11 support. You will need to install the Clang toolchain using the VS setup app and switch the compiler to Clang instead of the default cl.exe per project basis. You can also use Visual Studio 2017 with GCC and GDB if you connect to a Linux machine or to WSL (Windows Subsystem for Linux) installed on the local machine. 
Please use a pastebin or format your code correctly, it is really hard to view it on mobile. 
Your function prototype should not have an address-of operator but should rather take a pointer as an argument: *state *s* as you've mentioned elsewhere. then, when calling the function, you need to pass it a pointer to the state you want to modify -- i.e., you need to give ti the address of your memory you've allocated within your main function -- so in your function call, you still need *&amp;s* as you have above. Function prototypes need variable type specified explicitly -- but you never specify the type of the variable when you're actually calling it.
bash on Ubuntu on Windows makes it a lot easier.
Right, sorry I didn't exactly phrase that the best. So, I wrote the basic "Hello World!" program just to make sure that the compiler was working but when I tried to type gcc HelloWorld.c into the command prompt I'll get the following: "ld.exe cannot open output file a.exe: permission denied"
Is there already a file `a.exe` in that directory? Are you allowed to create files in this directory? Make sure no `a.exe` exists and you have the permission to create files in that directory.
Using the address of operator in the function header to pass by reference is C++, not C.
Introductory courses to Data Structures are just that: introductory. There's a reason your teacher has you do this kind of stuff. All complex things are built out of simple things, and stacks, queues, lists, etc. are all of your building blocks. If you want more in-depth exposure, look no further than here: https://www.amazon.com/gp/aw/d/0262033844/ref=mp_s_a_1_1?ie=UTF8&amp;qid=1513620322&amp;sr=8-1&amp;pi=AC_SX236_SY340_QL65&amp;keywords=cormen&amp;dpPl=1&amp;dpID=41-1VkO%2B1lL&amp;ref=plSrch# This is usually the de-facto book for advanced algorithm studies. Be warned: lots of math and use of induction based proofs are present in this book. You NEED a good bit of mathematical expertise to really get the most out of this book. But this is as advanced as it gets before diving into research papers. 
With smart code set up and modern compilers, you often don't even need to resort to explicitly calling intrinsics which can lock you into an architecture. There was an old page kicking around that I liked for this because it went through example code and the resultant assembly, but I can't find it, but the gcc page does a good job: [gcc autovectorization](https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html) That said, I agree with your sentiment that intrinsics should be used instead of assembly if possible.
Sorry I can't help much, as I don't think I have the code for this anywhere, but I can tell you that it works. [simple c demo I did a couple years back](https://www.youtube.com/watch?v=OUyenzoXNws)
It's more of a successor of C++ than of C. Take C++ and dial back the most unfortunate design decisions. A hardcore C developer will probably like D better than C++, but that's not exactly an hard bar to clear.
http://www.cs.princeton.edu/courses/archive/spring17/cos226/assignments.html All of the assignments have the specifications provided in Java. However, it should be simple enough for you to write code with the same interface in C. 
 p1.horiz+p2.horiz horiz is an array of 2 floats. You cannot add two arrays together.
Thank you, now it compiles \(^_^)/
The biggest issue for me is that D doesn't seem to have reached either widespread adoption or fulfilled a useful niche. One thing I've learnt over my programming career is that good design and pleasant syntax are meaningless if no one uses your language. I like some of the ideas in D, but I think any attempt to make a 'better' C/C++ is likely to fail unless it is either compatible (i.e. has lots of syntax sugar but effectively translates to C/C++) or there's a high-profile backer (e.g. Go has Google).
C is modern, isn't it?
did you do this with the *C* API ?
Go simplified the entire toolchain, it’s on another level.
I recommend reading the book "The C Programming Language". It contains an introduction to C and some exercises/problems covering most problems you'll stumble upon in computer science. As far as I can remember there's a PDF of it online. I hope that helped you. Cheers!
Timeless
My bad, I went looking through my old code folder and it was the c++ api.
Aged like a fine wine or cheese.
I like it, but it doesn't solve any problems that C developers aren't willing to suffer. 
To me, Go very much is the C philosophy of programming but lifted into a different domain. i.e. One where a runtime is fine. The thing about Go though, is that in C I will find myself writing runtime enabled generic code, while Go doens't even feature such things. So it also feels like it's trying to recreate C too much. D I think suffers from not getting a solid launch, and essentially having other alternatives beat it to the punch. C++11/14/17 basically takes away the flame of D's original mission statement. Go brings back the simple static natively-compiled language to the world of interpreters, dynamic typing, and vms. Rust raises the bar on static compiled languages and arguably solves the more foundational problems of that language domain. So D wasn't really chasing the most critical shortcomings of C++, a reason why people just waited for C++ to get better. The one cool feature of D that I'd really like a reason to play around with, is [-betterC](https://dlang.org/blog/2017/08/23/d-as-a-better-c/). Which has been intriguing me ever since I first heard of it. 
Wrong subreddit, try r/cpp
Thanks! 
Thanks! 
also, what OP wants is called CGI
Rust is better in every way...stronger typing, more FP influence, is backed/used by Mozilla and [many others](https://www.rust-lang.org/en-US/friends.html), and is rapidly gaining popularity.
I want to like D but platform support really kills it. They even have a compiler switch that turns D into a better C. Unfortunately I don't think I'd ever use it until more work is done to get it working on more BSD platforms. I guess I am in the same boat as /u/pwaring.
Oh, it happens more than you think. I tried several times one night a week or two ago to get GCC and Clang to emit identical instructions to the SSE4.2 strlen() on http://www.alfredklomp.com/programming/sse-strings/ (minus the "add rax, rcx" which is obviously a copy-paste typo from the function above it or something) using the _mm_cmpistri function found in &lt;immintrin.h&gt;, BUT every time I failed. Though I wasn't in top form that night, being low on sleep. And yes, I did use asm goto, and respectfully believe it's about as evil as any pointer.
yeah I bought this thinking it would help with my data structures class... come to find out not so much
Keep in mind that D interfaces with C very easily. https://dlang.org/spec/interfaceToC.html
&gt;So D wasn't really chasing the most critical shortcomings of C++, a reason why people just waited for C++ to get better. That and people/companies already had massive repos of existing code that it would take unnecessary additional effort to convert to or interop with a different language.
C++ is off topic in this subreddit, please post C++ questions to /r/cpp_questions.
This looks extremely familiar. Are you in Alberta perchance? We may have had very similar classes if that was a data structures and algorithms class. At any rate, you've gotten some good answers. Hope you understood everything!
I'm guessing you're at the point where you can basically pause and ask for user input(text), or run full-tilt in an infinite loop? Google Beej networking. Been probably 20 years since I've referenced it so hopefully it's still relevant, but you're looking for the asynchronous (non-blocking) portion and I remember there being a simple server-client example that should help you grasp polling for events. Fundamentally similar to how most video games which aren't textual handle their main loop, so you could follow a beginner game tutorial as well.
It's compatible at the level that you can link C and C++ libs with D programs and you can link D libs against C and C++programs.
To me that is the major selling point of Go. Being able to compile (and, more importantly, cross-compile) easily is a big win, even if it's arguably a feature of the toolchain rather than the language.
garbage collection is a hard no, even in external libraries.
Install C2/Clang, it's leagues better than both gcc and MSVC.
it doesn't even support generics and just got support for bools, 16 years late.
Why not just link the library into your executable with the -L (lowercase tho) flag? like `$(CC) -o ExecutableName -c ExecutableSourceFile -lLibraryName` My linker anyway will only copy in the functions that are actually used.
didn't like it at all due to (from memory) name mangling which is why I had to link with $(CXX)
I don't really fuck around with C++ but I'm pretty sure this is a well handled problem. Also, you said the library offers a C API? why aren't you using it?
We don't want to do your homework. What have you tried so far?
&gt; it doesn't even support generics Do you mean the `_Generic` keyword? Nobody uses that anyway. Same thing with booleans.
I think C++11 and Rust killed D. If D didn't have widespread adoption until then, now it's hard to lift interest. C++11 made C++ feel more modern, and people who want to go further are being attracted to Rust.
This is what all the extern "C" stuff is about. Basically, take the functions/headers you cherry pick and then expose them with C linkage, e.g. MyApi.h #ifdef __cplusplus extern "C" { #endif #include "CherryPickedHeader.h" #ifdef __cplusplus } #endif 
D seems to have a problem of not knowing its niche. Unlike Rust, it requires a GC for safely destroying memory, and pretty much no modern user of C/C++ can abide runtime penalties for the sake of safety (if they could they’d use another high-performance GC language like Go or C#, which have much stronger communities than D). If you ignore the GC then you’re as unsafe as C++ and so what are the benefits? A less mature, less featureful language with more consistent syntax? Sure, if C++ and D were developed at the same time then D would be the better language (although C compatibility would probably have caused C++ to still ultimately win) but the advantages over C/C++ are so minimal at this point that I can’t see it taking off, despite being developed by extremely smart people and being a very good language if you look at it on its own. Honestly the only language that I can see taking over from C/C++ right now is Rust, because it has a real compelling selling point in that it’s 100% memory safe. A lot of C/C++ code is memory safe too, but plenty of it is slower as a result of (for example) defensive copying, which Rust avoids entirely. As a result, on large codebases Rust can lead to faster code than C/C++. For example, the fastest Ethereum client in the world is Parity, written in Rust. There are many, many more features necessary before Rust is production-ready for most companies instead of fringe early-adopters like Mozilla and Parity, but its pitch is much more compelling than D. That’s not even considering D’s major language design mistakes like the split stdlib and the fact that non-GC code can’t call GC code even with an explicit arena or explicitly leaking memory (at least, not as far as I know).
ah didn't occur to me you could "extern" a whole block *and* a header.... thx
I intend to but with mixed libs I've had linking issues like: undefined reference to `__cxa_pure_virtual' etc when linking to a library with C++ code in it as well as the C API
Wrong sub.
I would like to know why it terrifies you..
So, I typed in the usual `gcc HelloWorld.c` and it compiled an a.exe file but when I tried to execute it it simply said `Access is denied.`, at which point the file disappeared from the folder (I think it was deleted but it wasn't in the recycling bin so I'm not sure) Seeing as the first a.exe file was no longer there I tried again but this time when I typed `gcc HellWorld.c` it spit out the following, `c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/ld.exe: cannot open output file a.exe: Permission denied collect2.exe: error: ld returned 1 exit status`
This happens every time I try to compile under a different name too. For instance, I tried `gcc HelloWorld -o HelloWorld` and it compiled a HelloWorld.exe file that won't run because `Access is Denied` at which point HelloWorld.exe disappeared from the directory. If I try `gcc HelloWorld -o HelloWorld` a second time I get, `c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/ld.exe: cannot open output file a.exe: Permission denied collect2.exe: error: ld returned 1 exit status`
GNU m4
I generally just use Bash; set up a few functions that print things out with indentation etc., and it’s pretty easy to filter through a mostly-C file, pick up an embedded Bash script, and insert its output into the code. There’s m4 also (usually via autotools), but that’s moderately hellish to use correctly/safely and it has no understanding of C tokens (e.g., quoted areas, comments), so it’s not very easy to embed.
It doesn't really solve the issues I'm concerned with. I'm more interested in Jai (assuming it ever comes out)
Literally just wrote my own but end up not using it because I lose out on repetition memorization that is remembering things by repeating them. If your looking to to do the same I'd recommend python or perl likewise if you are writing the same code over and over I'd find a way to generalize it and put them into seperate units or even a library.
Do you have an anti-virus program running? If yes, try disabling it. &gt; gcc HelloWorld -o HelloWorld That doesn't make any sense. The correct compiler invocation would be something like gcc -o HelloWorld.exe HelloWorld.c note the correct file extensions and correct option and operand order.
C++ is off topic in this subreddit. Please post C++ content elsewhere.
I would guess on AV too. I had similar issues before.
You evil evil person you.
[Inspired by Rob Pike](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html).
That's one of my favourite articles! My take on a binary IO library looks [like this](http://github.com/fuzxxl/memf).
I've got [BitIO](https://github.com/bumblebritches57/BitIO)
Just looking at one of the unit test automation suites for embedded C, unity + cmock + ceedling, and it looks like they do a lot with Ruby. Haven't used it since grad school (2010) but I recall the string handling being excellent.
Try /r/C_Homework
Geany is my go to on Windows for C.
Someone said: &gt; D is for C++ programmers who like C++; &gt; Rust is for C++ programmers who don't like C++. &gt; Conclusion: C++ is for no-one.
&gt; Do you mean the _Generic keyword? Nobody uses that anyway. I was about to be so mad &gt; Same thing with booleans. Til I got here lol
If you just want to display it then: cout &lt;&lt; b[x] &lt;&lt; endl; X basically will be the location the user inputs. 
You're in the wrong subreddit, this one is for C, not C++. That being said, you'll deprive yourself of a learning opportunity if you don't try to figure these problems out yourself. I recommend reviewing breadth-first search and depth-first search, and trying out some simple cases on a sheet of paper with a pencil.
 I'm still getting a compilation error. #include &lt;iostream&gt; using namespace std; int main() { int x; int b[x] = {11, 45, 62, 70, 88}; cout &lt;&lt; "Please enter an integer between 1 and 5 to print an element from the array: " &lt;&lt; b[x] &lt;&lt; endl; cin &gt;&gt; x &gt;&gt; endl; cout &lt;&lt; "The element is: " &lt;&lt; b[x] &lt;&lt; endl; return 0; } I feel like I'm making some careless error. Plus it's 3 am so that might have something to do with t. 
Arrays are a fixated size I believe. Int b[5] = {.....}; Your first cout statement don't do the "&lt;&lt; b[x] &lt;&lt; endl;" Just " &lt;&lt; endl;" The reason why is because compiler doesn't know what 'x' is yet. Only until user inputs that value it'll know.
lol yeah like kids today work stuff out on paper and pencil first...
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
Please don't post [the same question](https://www.reddit.com/r/C_Programming/comments/7l05my/need_help_from_c_masters/) twice.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
Why do you expect the two compilers to generate identical code? There are so many different choices to make, it's highly unlikely they are going to do that.
C# is off topic in this subreddit. Please post C# content elsewhere.
Have you looked at fido? [https://github.com/evilsocket/fido](https://github.com/evilsocket/fido)
For window libraries (specifically with the use of OpenGL), there are a few options. 1. Freeglut - extremely simple window library. It provides an OpenGL context and callbacks for input. Tutorial for how to use it is [here](https://en.wikibooks.org/wiki/OpenGL_Programming). 2. GLFW - Similar to FreeGlut in that it is extremely simple. Adds a few small benefits like window hints. It is also the library used in the OpenGL Red book, the example code can be found [here](https://github.com/openglredbook/examples). 3. SDL2 - Lots of emulators and programs use SDL. More often than not, most of the resources for SDL are written in C++. One of the more well known ones is the [lazy foo tutorials](http://lazyfoo.net/tutorials/SDL/index.php). 4. GTK - The GTKGLArea widget was added in GTK+ allowing GTK to handle OpenGL context. The benefit is you can also add buttons and other windows. Tutorials for how to use it can be found [here](https://dashgl.com/). For math libraries there are two main options, [mathc](https://github.com/ferreiradaselva/mathc) and [linmath](https://github.com/datenwolf/linmath.h)
Depends what kind of game you are making. Take a look at SFML too, its quite nice.
I finished my "game" project using allegro. It was very easy to learn and use 
I used to use Raylib. It is really easy to understand and use, but it lacks of a good documentation.
I know it's an older article, but I can't remember if I have've seen on this sub since I'm following it, so I thought it could be useful for some people, as it was very helpful for me. I hope it's ok to post it.
Put four spaces before each line of code. Also, this is C++ code but you've posted in a C programming subreddit. You may get better answers at /r/cpp_questions 
[removed]
Kindly Support Our Website and like our Facebook page whose link is given in description............
Thanks for the answer! Well, this project is just about gaming. so I'm kinda torn apart from what to choose. Is OpenGL used by all the other libraries? Or should I use it because it's better graphically or easier to use? What's the main difference between using a library with OpenGL and one without? I don't mind being learning something a bit different as long as it's better or it gives me something that I can use in the future. Also sorry if I seem a little confused, but I've never worked with these kinda things. If it helps, the game project is a 2D turn-based top-down / isometric simulation about zombies killing humans.
Thanks for the answer! The game is a 2D turn-based top-down/isometric simulation about zombies killing humans. Why do you reccommend SFML over the other libraries?
Thanks for the answer! Did you like working with allegro? Did you use it or any knowledge you learned from it on there onwards?
Thanks for the answer! Raylib's website seems to have the most User Friendly interface from all the options, so thats good :P. Did you like working with it? Did you use it or any knowledge you learned from it from there onwards?
I never said I recommend it over others, just that it is worth checking out :) It is quite simple and easy to use, multi-platform and has plenty of bindings (its made in C++, but C bindings are available too) 
Oh sorry, my bad. Would you recommend it instead the other options then? Sorry for the inconvenience, but I don't know any of the libraries so I don't have a comparison point.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions. Also consider fixing your formatting.
No blog spam please.
Do not repost the same content in quick succession. Do not blog spam.
Thats an excellent article, thanks for sharing.
I would recommend SDL2. Striaghtforward and capable. Will also handle your input and sounds for a game. 
OpenGL stands for "Open Graphics Language", it's the language and API that allows you to send commands to the GPU for rendering an image on the screen. If you're looking for something top-down you might start with this [Invaders-clone](https://dashgl.com/Invaders/) tutorial to get familiar with drawing sprites on the screen. You can branch off an modify from there.
Nemiver is great. However, since gnome-builder (an IDE) got debugging capability it now covers my needs.
NCurses only if you want it to be run in a terminal. SDL2 if you want cross platform 2D/3D graphics.
Ok, I learned something new! So these libraries you mentioned use OpenGL right. The other ones don't use OpenGL or am I missing something? What's the difference? There are so many different things it's hard to choose with no knowledge.
Thanks for the answer! I know the pretty basic stuff that Ncurses uses ASCII, and the other ones are meant for more general stuff. I'm still a bit undecided on which to use though, SDL2 seems to be the most used.
I'd say SDL2 is the most future proof. It is used by valve and many other game companies. 2D hardware accelerated graphics is pretty straight forward, and you can easily move on to 3D with OpenGL if you want. It is also extremely portable (Android, iOS, macOS, Linux, Windows etc). 
What is the time complexity of this supposed to be? Are you allowed to sort the arrays?
I'm sort of confused. For each array do we distinguish duplicate elements? So say for: `arr1[] = { 2, 2};` `arr2[] = { 2, 2, 3};` For you, does that mean you want to track that their were 4 matches between `arr1` and `arr2`? For each 2 in arr1 onto each 2 in arr2? It sounds like you merely want to count how many times a number occurs between two sets, for all pairings of sets. This sounds like a homework assignment, but your issue doesn't sound like it has anything to do with C itself, more understanding how you'd solve this from a programming perspective. Generally full solutions to assignments aren't given here, but help with language details or other nudges in the right direction certainly offered.
&gt;The other ones don't use OpenGL or am I missing something? What's the difference? To be honest I've only used the options that use OpenGL directly. The alternative is something like SDL2 which has it's own 2D drawing API, which will handle calls to the GPU for you. I haven't looked into or tried those options, so I can't say specifically how they are implemented or how they are different. &gt;There are so many different things it's hard to choose with no knowledge. You pretty much don't know until you try them yourself. I started with webgl, switched to Freeglut to get some perspective of how OpenGL was handled in C. Moved on to GLFW because of it's use in the OpenGL Red Book. Dabbled with SDL2 a little bit before settling on GTK. You really won't know until you try them. Each time you try one it gives you a little more perspective and when you switch to another one it becomes, "oh they handle input like this.", or "the main loop acts like this.", and because you have the experience it makes it easier to try another. 
Yes, I read about it today in Fedora magazine. I still need to give GNOME Builder a proper try. I know it is still in development, and the last build I ran was really early. Despite that, tne thing that gets me excited about Nemiver as an embedded dev, however, is the support for remote targets and non-standard GDB binaries.
Loled
/r/C_Homework
I work in security, but not cryptography, so I can't really speak to whether or not your algorithms are good - don't use strcpy - don't strcpy onto a string on the stack - don't strcpy onto a string on the stack using input given by the user. - argv and argv are standard names for the arguments given to main. IMO you should stick to these. - Not sure why you declare your loop variable the line before you use it in the loop. You aren't using C89 because you're mixing declarations and control flow; might as well stick the declaration in the for loop - perror doesn't exit the program, so continuing logic after calling perror is incorrect. - These are small programs where array sizes are just "known" but you really should get in the habit of passing array sizes when passing arrays to functions. - in program 2 you calculate probabilities using a mix of floating point (doubles) and integer (int) arithmetic. you should cast notequal, equal, and sum to double before finding the probability. - In that same block of code, I'm not sure if it's possible for sum to be 0 (from an algorithmic standpoint it may be impossible, but from me just glancing at the code it seems 100% possible), but if it is that's a division by zero. - I see a mix of hexadecimal and decimal numbers. Stick to whatever is most applicable to your use case. You're doing bit twiddling and counting to 256 a lot, so hexadecimal is more appropriate. - I personally don't like single line statements without braces (`if(...) statement;` rather than `if(...){statement;}`). This is up to preference though. One benefit of always using braces even for single statement, is that if you add a statement and you forget to add the braces then your second statement will always execute. Already having the braces makes this mistake pretty much impossible. - `uint8_t` from stdint.h should be preferred over using `unsigned char` - IMO you should prefer `bool` from stdbool.h and `true` and `false` over `int`, `1` and `0` for doing boolean logic. - in some cases you are comparing against true/false (e.g. `if(mything == 0)`). in C, `0` evaluates to false and every other value evaluates to true. This means you don't really need to compare with 0 or 1 or whatever, you can just do `if(!mything)` or check a point that way `int* ptr = malloc(sizeof(int*)); if(ptr) use ptr;`
is strncpy ok or is there a whole other set of string-functions used in security? 
Strncpy doesn't null terminate if the source string is too long. For that reason alone I would personally avoid using it since it lures you into a false sense of security, but nevertheless if you use it correctly then it's safer than strcpy.
Hello again. Thank you for the respons. Indeed this is a assignment, and I'm in my starting phases of learning C :) I will repost it at /r/C_Homework I didn't know it existed, Thank you!
well, basically if you need OpenGL go with SDL. Otherwise, check into Allegro and SFML. Do a quick read at how it works and decide what you prefer better. I never heard of Raylib, so I might be missing something :)
`strncpy` is a special purpose function. It won't do what you expect and you shouldn't use it for the purpose of copying strings. I recommend you to use `snprintf` instead: char buffer[SOME_SIZE]; len = snprintf(buffer, SOME_SIZE, "%s%s", str1, str2); if (len &gt;= SOME_SIZE) { /* error handling for truncation here */ } You can also use `strlcpy` from BSD, but it's not a standard function.
`strcpy` is just as “safe” if you use it correctly (e.g. by checking the buffer sizes beforehand). Functions are not inherently unsafe, they just have different invariants which may be more or less difficult to ensure.
&gt; I have a struct declared in a header file What follows is a declaration of a variable with `static` qualification. A `static` variable is only visible in the translation unit it is declared in. If two translation units declare the same static variable, each translation unit gets its own, separate variable. It doesn't matter if this declaration is located in a header file. To fix this problem, just remove the `static` keyword. While strictly speaking a violation of the C standard, this works as long as no `-fno-common` is specified during compilation. To make the code strictly correct, change `static` to `extern` and in a single translation unit somewhere define `settings`: struct { unsigned window_width; unsigned window_height; } settings = {};
Homework questions are not off topic in this subreddit! However, feel free to ask in /r/C_Homework, the people there are as good in answering questions as our readers are.
That work's thanks. I realised I could remove the static and it would work, just wanted to do something a little more to specification, so the extern suggestion is very nice.
&gt; is there a whole other set of string-functions used in security? Microsoft developed the “bounds checking interface” which is a bunch of functions whose name ends in `_s` to “fix” common mistakes people make when using C string manipulation functions, but it [didn't quite turn out to be a panacea](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm).
Don't set the RPATH and use libtool to build your libraries, preferably through Autotools.
&gt; This means you don't really need to compare with 0 or 1 or whatever, you can just do `if(!mything)` This is considered bad style unless the name of the variable or function being tested clearly marks it as a predicate. A classic example is `strcmp()`, since `if (strcmp(a, b))` does *not* mean “if `a` and `b` are equal”, as opposed to a hypothetical `strequal()` function that would return non-zero if the strings were equal. &gt; `if(ptr)` This is always considered bad style.
You still want the struct definition in the header, though, not in one of the translation units.
You want the *declaration* in one of the headers and the *definition* in one of the source files. A common trick is to have a macro `EXTERN` or similar that is defined in `foo.h` like this: #ifndef EXTERN #define EXTERN extern #endif In the single translation unit where you define the variable (instead of just declaring it), you write #define EXTERN #include "foo.h" However, I must say that I really don't like this sort of trick as it makes finding the definition even more difficult than it already is.
You might be surprised, but you can program with C89 just fine and the code you write this way is not fundamentally different from code written in modern C11.
&gt; Did you like working with it? Yes, because it letting you to organize your code how you want. For example Raylib doesn't provide a [game loop](http://gameprogrammingpatterns.com/game-loop.html), but **you** are responsible to create it. &gt; Did you use it or any knowledge you learned from it from there onwards? No, I don't. Because now I'm studying different programming languages and problems.
I haven't tested or really looked at this, but I think the issue may be that you're trying to reference a macro before it's defined. The C preprocessor is a single pass, so order matters. Can you try putting your `#define LVL` before you `#define LST` or `#include &lt;macros.h&gt;`? If you intend to use multiple `LVL` definitions in a single source file, you may need to move some of this to a separate header/C file.
&gt; Can you try putting your ``#define LVL`` before you ``#define LST`` No because the entire point of the macros is to be able to do this many times over: #define LVL lvl02 LST(01, 1, 2, 3) LST(02, 4, 5, 6) LST(03, 7, 8, 9) TFrame LVL[] = { FRM(500, 01) FRM(500, 02) FRM(500, 03) FRM(500, 02) FRM(500, 03) FRM(500, 02) }; #undef LVL
I thought the same, but it you try and see it doesn't work as-is
https://stackoverflow.com/questions/1489932/how-to-concatenate-twice-with-the-c-preprocessor-and-expand-a-macro-as-in-arg Apparently the standars says you need "At least 2 levels" of macros for inter-macro translation. So I go this to work the way you want: #define LVL lvl01 #define PPLST(a,b,...) uint8_t a##_##b[] = { __VA_ARGS__ }; #define PLST(...) PPLST(__VA_ARGS__) #define LST(...) PLST(LVL,__VA_ARGS__) #define PPFRM(a,b,c) { b, sizeof(a##_##c), a##_##c }, #define PFRM(...) PPFRM(__VA_ARGS__) #define FRM(...) PFRM(LVL,__VA_ARGS__)
Does the first line of code need to be there for it to work? I need to define LVL after the macros, and multiple times!
Here's what I came up with: #define PASTE(x,y) x ## _ ## y #define PASTER(x,y) PASTE(x,y) #define LST(a,...) uint8_t PASTER(LVL,a)[] = { __VA_ARGS__ }; #define FRM(a,b) { a, sizeof(PASTER(LVL,b)), PASTER(LVL,b) }, 
Thanks! It worked.
Don't ask me why it works, though. I'm still not sure. The preprocessor gets funky sometimes.
The thumb rule about assembly is, if you don't know if you need it then you don't. :)
I would never dare ask someone why their C macro works. Everyone at this point understands some instances of black magic are taking place in the preprocessor and it's best to not ask questions.
I'm talking about the definition of the struct itself, not of the variable. Your example places the struct definition in the translation unit that defines the variable, which won't work.
I don't like magic :\^). I hope this comment explains the issue well. In short when a macro parameter in a macro's replacement list is preceded by a `#` or preceded/succeeded by a `##` it causes that particular occurrence of the parameter to not be expanded. So here: #define HELLO hello world #define MAKESTRING(x) #x printf(MAKESTRING(HELLO)); this becomes `printf("HELLO");`, because the `x` parameter is preceded by a `#`, so it will not be expanded. In this example it will: #define HELLO hello world // same as before #define MAKESTRING(x) #x // ditto #define MS_INDIRECTION(x) MAKESTRING(x) printf(MS_INDIRECTION(HELLO)); In `MS_INDIRECTION` the parameter is not preceded by a `#`, so it'll be expanded into `hello world`, which is then passed into `MAKESTRING`, so we end up with `printf("hello world");` In your code `LVL` isn't even a parameter, so you need to create a macro like this `PASTE(x, y) x ## _ ## y`, but then in `PASTE(LVL, b)` `LVL` is not expanded, because in `PASTE` the parameter succeeded by a `##`. Adding another level of indirection like /u/boredcircuits' `PASTER` causes `LVL` to be expanded to `lvl01`, because inside of `PASTER` `LVL` is not preceded by `##`, then `lvl01` is passed to `PASTE` which gives the desired result.
Double-underscore, and leading underscore followed by capital letter, are reserved for implementation use
Rename them to your liking
Have you tried running your code in a debugger? If you're getting a segfault, you're probably accessing memory somewhere you aren't supposed to. Either a malloc(), free(), or pointer or array access has been messed up. Debug it! Add printfs.......or use gdb. 
Just wondering: Are you making a compiler proper (compiles to object code) or a compiler/linker (compiles to ELF/PE binaries)? What language(s) do you want to compile? What CPU architecture(s) do you plan to target? Please elaborate. If you only want to target a single architecture, you should become as well versed as possible in code optimization for that architecture. If you want to target multiple architectures/languages, then you should probably make a modular (3+ stage) design. Also, if you have friends/classmates who have enough skills to help you, you might want to ask them to share the load, simply because there is so much to design and write. Also, you should become familiar with the API of your OS; ideally, for reasons of efficiency and convenience, your compiler would only need the C library and system calls to run, as opposed to using various 3rd party libraries. This will also make people who are creating OSes (like me) to be more likely to use your compiler, since they need implement no more functionality than that required for a shell. (As opposed to LLVM, which requires Python to run.) Additionally, recruit volunteers to test your compiler and see if it produces correct code for their programs.
When you compile it, run it with the -g compile flag and debug it with gdb. You can set a breakpoint for that last test, which I think would be this line, right? &gt; dotest("315411 165 53195 87 318638 107 416122 121 375312 193 59", "{{15, 0, 315411}, {15, 3, 87}}"); Also, make sure you're compiling it with the same version of C as they are, which seems to be Clang 3.6/C11
You're trying to use 'fahrenheit' but you've never told the computer what it is. You need to declare it, like you did for celsius, before you use it.
As this is my very first attempt at this could you provide me with an example?
You need to instantiate a variable called fahrenheit firstly put int fahrenheit; under your int celcius; Or above doesn’t matter. There’s other things wrong but that will get you through that error.
Thank you I have almost got it, still getting a value of zero... hmmm I'll figure this out 
Okay as others have said you haven't declared fahrenheit: where you have int celsius; You also need int fahrenheit; However there's more to it than that: * You currently have the line to edit fahrenheit commented out with the // - as such you won't do any of the conversion to it, and this will fail as you are trying to print something which has not been used. * In the line where you do the maths: //Fahrenheit = factor * celsius/100 + 32 * You won't actually affect the fahrenheit integer - case is important in coding, and Fahrenheit is not the same as fahrenheit. * You also have not declared "factor" anywhere - the maths is going to fail here too. If you need any more of this explaining please feel free to ask :)
So the lines after //‘s are comments Anything after // is ignored at compilation. It’s not registered as code on that same line I’m guessing your teacher set up the assignment for you to do but put comments in to say what you should do. Essentially you have to code the calculations the comments say. Right now all you do is Get input for celcius Output for fehrenheit But there is no calculations in between that does the conversion.
Also another hint/random thought - if it's just Fahrenheit to Celsius you need, the easiest formula (imo) is to calculate fahrenheit = celsius * 1.8 + 32 Or for Celsius to Fahrenheit: celsius = (fahrenheit - 32) / 1.8
Please do not post code as images. Always post code as text!
Considering the terrible code formatting on mobile reddit this is a godsend.
define fahrenheit
No. The purpose of homework is that you learn something from doing it, not that you copy it from other people on the internet.
How the fuck am i supposed to learn from a homework i got today and it needs to be turned in by tonight at 23:00, and with that i need to do two more assignment. The teaching system is FUCKED!
&gt; i got today and it needs to be turned in by tonight at 23:00 I don't believe you. There is some part missing in your story.
How can i send you a screenshot?
https://imgur.com/a/ZPRtD here you go
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/x6M9h65.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20drm7t2z) 
I still don't believe you; “last modified” doesn't mean “homework was given that day.” It just means “the last correction occured that day.” Plus I've not even seen your exercise sheet, could be something really simple.
Holy shit you guys are obnoxious, why can't you just help a brodda out. I haven't slept this week at all because of quizes and im supposed to learn something in less than 10 hours, gimme a break, if you weren't going to help just fuck off and don't try to make yourself look smart. Cunt.
The basics of a banking problem aren't even that hard. Get a database with an id, cash and pin. It a wants cash from b. Edit a to have less cash and then if that is successful add money to b. The security. Optimisation. Speed. Reliability and usability is a totally different story 
And by guys i mean the cunts that are downvoting, you included
I'm sick and tired of people who want others to do their homework for them. If you want help, post your code and where you are stuck. Then people come and help you out with those parts. But what's not going to happen is someone giving you code to submit as your own. That's just shitty and won't even help you, neither right now (teachers find out this sort of thing) nor in the long run.
I just write these things in Tcl. If you'll have a text file of templates then refer to those it's a bit easier: --- text file --- ::A_TEMPLATE_FOR:: for ([set var];[set var ] &lt; [ set lim ];[set var]++) { [set do_thing ] ; } --- Tcl code to exploit template -- set y [ get_template ::A_TEMPLATE_FOR:: ] set var k set lim 42 set do_thing " table\[[set var]\] = ([set var]) * 10 ; " puts [ subst $y ] 
im outta here, pcout
If you were assigned the homework today and it's due today, it's reasonable to ask for an extension, surely?
Hrmm now that you mention it. But im still new to this thing, its my first year in college, only the 3rd month, do i write the prof a mail or smth, or do i contact them somehow on the site where the homework was given. What is more appropriate?
Take a look at [rand\(3\)](https://linux.die.net/man/3/rand). Generate a number than use division and the remainder to determine position in the array. Addendum: As mentioned below you'd have to make sure the array didn't already have a value at the randomly generated position, so it could be expensive with bad luck. Depends on if you care.
Put the numbers 0-399 in an array. Shuffle it. Use the 1^st 50 positions.
This isn't about looking smart, it's about trying to give you good advice. You **will** get caught plagiarizing. Professors run homework through tools that are very good at catching this, and you better believe they scan a huge site like Reddit. 
I think this approach unnecessarily complicates the problem.
Can you type your questions out and post them here?
On the contrary, this approach excludes the possibility of writing to already used cell.
Why go the extra mile though? Nobody uses a compiler that doesn't support C11 anyway.
What's wrong with just asking them here?
That's a pretty bold statement. Outside of gcc, clang, and icc, C11 support is still rather spotty. So if you want to develop software for Windows, embedded platforms, or exotic operating systems, there is often no way to get a C11 compatible C compiler. Some systems go as far as only supporting ANSI C.
That's exactly what I thought about your statements.
Ah, sorry , I needed exact points in a program... But my friend helped me, thank you for quick answers! 
I've experimented with a few with varying degrees of success. Of course no matter the language, the efficiency and performance are affected by how you implement it. I've found that bitsquid's is the easiest to understand and to implement with decent performance. But nothing is stopping you from making your own.
I'm trying to design a truly safe language which is as competitive with C as possible, and is done right with modern tooling and so on, with the ability to mix directly into C codebases at zero cost. ziglang (https://github.com/zig-lang/zig) is a significant inspiration. I recognize that this will take help to get complete, but I think I can get it to a minimal useful starting point, and if I can I think interest would bring more people to it.
There's no need for a second array. Just operate directly on the 20 x 20 (as an array of 400). Put the desired value in the first 50 elements. [Shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle). Done.
**Fisher–Yates shuffle** The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite sequence—in plain terms, the algorithm shuffles the sequence. The algorithm effectively puts all the elements into a hat; it continually determines the next element by randomly drawing an element from the hat until no elements remain. The algorithm produces an unbiased permutation: every permutation is equally likely. The modern version of the algorithm is efficient: it takes time proportional to the number of items being shuffled and shuffles them in place. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Sounds like a home assignment. I'd say the best response to that assignment is to come up with a method yourself.
If the number of carrots was equal to the size of the field, you could've used the inside-out variant of the shuffle so you wouldn't have to fill the array beforehand.
Why are you left-shifting cout?
Agreed.
As this post suggests. Use rand to generate 50 random positions in the 20x20 array. This is the easiest way. All you need is 50 random values, rand will do that for you with the correct seed.
I'm not sure I see your point. If the number of carrots was equal to the size of the field I wouldn't need to shuffle at all. But, I do agree you could modify the shuffle to also do the initialization of empty elements - eliminating the need for two passes over the field.
You can use a simple xorshift to generate some numbers within your range. The initial for the xorshift could be the int value of the arrays address for example. Or you simply use rand() and srand() to generate some random numbers. 
That's not going to work unless a single cell can hold multiple carrots
OP is not very clear on this, but I assumed each carrot held a unique value.
HAIIO BHAI
HALLO BHAI
I said 50 random values, not one. Each value corresponds to one of the cells in the 20x20 array.
Yes, then you'd have to fit multiple carrots in a single cell if you got the same value twice
Try to divide your program to small parts and do every part alone, by example in this program you will need to read 15 numbers and to save them then to check if the number is odd or even and so on. If you need further help I will be glad to help, and I don't think this subreddit is the suitable place to ask, ask on /r/learnprogramming or /r/cpp_questions to avoid having your post deleted by the moderators. Good luck!
What have you tried? You're not going to get someone to write your homework here, but you will get help with debugging what you've already done. Good luck!
What have you tried. Looks like you only need to store two values, so this is possible without using a array . Show us what you did and we can help.
I have a test tomorrow and I’m wondering where I can ask my questions and get answers . Can I do that in reddit?
It is not like they can’t check if the value is unique or if there’s already a carrot at the position.
Yes, you can do that of course, we are all here to help.
Thank you sir
No problem, PM me if you need more help.
Basically what he said. I'm assuming you know how to read in numbers (likely `std::cin` if C++), check if they're odd (just check if divisible by 2), and calculating the average (sum and then divide by count). I would recommend using four variables for this. One to read the number in to, one to use as the sum, one to use as a count of odd numbers, and one as the count of total numbers read. r/learnprogramming is probably a good start for questions. Now, if you're talking about asking the questions during the exam, good luck convincing people it's not against the rules.
I would not recommend trying to ask reddit during your test. That will not go well for you.
Is there any rules against that?
The only rules would be what the teacher/professor sets. If he say's that outside help is OK, then it is. If he says it's not, then it's not.
C++ is OT here, there are other subs for that language.
What do you do if there's already a carrot there? You can't just throw it away?
I'm not sure how to do the most frequent number without an array (without hacks), you cannot just save the currently most frequent number and it's number of appearances. 
You generate another random number and check if the new position is empty or not. You keep a counter to know when you eventually fill 50 positions. 
Indefinite worst case performance is not a good idea.
...so write it? at the very least take a crack at it and ask us for our opinion on your solution...
if new_num == last_num {currentmax++; if currentmax &gt; totalmax {totalmax++}} Something like that
Premature optimization is the root of all evil. It is a homework assignment.
If you have a list like that: 5,5,5,1,2,1,2,1,2,1 You'd have 5 as the most frequent in your example, if I understood you correctly, because you can only save a constant amount of data, eg. the currently most frequent number and it's occurances -- you cannot save the occurances of any other number which'd be needed for determining the most frequent. It's because the problem has a space complexity of O(n), simply due to it needing to save all the previous amounts, unlike the "longest continuous temperature" where, as soon as you've found a new value, all older values can be discarded because they aren't continuous anymore.
Use fgets() to read a string. Go read the documentation on it. For FILE use stdin which is the keyboard as your source.
It sounds like you may need to learn how to use a [debugger](https://en.wikipedia.org/wiki/Debugger) to step through your code. With a good debugger, you can execute your program line by line and see where it is deviating from what you expect. This is an essential tool if you are going to do any programming. Further reading: [How to debug small programs](https://ericlippert.com/2014/03/05/how-to-debug-small-programs/).
**Debugger** A debugger or debugging tool is a computer program that is used to test and debug other programs (the "target" program). The code to be examined might alternatively be running on an instruction set simulator (ISS), a technique that allows great power in its ability to halt when specific conditions are encountered, but which will typically be somewhat slower than executing the code directly on the appropriate (or the same) processor. Some debuggers offer two modes of operation, full or partial simulation, to limit this impact. A "trap" occurs when the program cannot normally continue because of a programming bug or invalid data. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
In your code, in the cicle for, you are comparing until 25, but the string could have a lenght minor of 25. If you want use that way, you can use the first version of my code , else you can use the second that use the function STRCMP of C. #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;ctype.h&gt; #include&lt;string.h&gt; int main() { int i,n,iseq=0; char string1[25], string2[25]; printf("Enter the first String :\n"); scanf(" %s",string1); printf("Enter the second String :\n"); scanf(" %s",string2); /** First version ** if(strlen(string1)&lt;strlen(string2)) n=strlen(string1); else n=strlen(string2); for(i=0; i&lt;n; i++) { if(string1[i]!=string2[i]) { iseq=1; break; } } ********************/ /** Second version **/ if(strcmp(string1,string2)!=0) iseq=1; /*******************/ if(iseq==0) printf("Equal!"); else printf("Not Equal"); return 0; } 
 char string1[25], for(i=0;i&lt;=25;i++) The valid indices for an array 25 elements long are 0 .. 24. You're reading 1 past the end of the array, scanf(" %s",string1); string1 and string2 start uninitialised; if you type "bob" then only the 1^st four characters of string1 are meaningful - the rest are still undefined.
There are multiple flaws in your code. Let's address them one by one. You are using conio.h which is non-standard header which is fine if you are coding for windows, but makes your code non-portable. int main() is not valid form of main function. In C you need to write int main(void) instead to tell that main takes no arguments, empty parentheses mean that main takes an arbitrary number of arguments. You are not using the variable j and it is unnecessary to declare i and iseq before they are used. You are using scanf for reading strings, which is bad because scanf breaks the string on the first whitespace character encountered, use fgets instead. The flaw which makes your code work incorrectly is the fact that you are checking i from 0 to 25 (26 characters in total) which means that you are reading from the index 25 of the strings which might contain any character, because you shouldn't have access to those memory addresses. Your indentation is only 1 space and isn't even always applied which makes reading the code difficult. You are using printf incorrectly by giving it iseq as argument, when your format string doesn't have %d in it.
The deal with premature optimization is that you should measure your code before applying optimizations. Your code can't be measured because it's going to vary randomly from 50 loops to infinity. Definite worst case performance is always better than indefinite, it's not a premature optimization, and this is likely the point of the assignment
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. in /r/cpp_questions.
I wonder how you plan to output strings without using pointers or arrays.
`int main ()` is valid in C. `conio.h` also appears in ncurses, a popular library available for many operating systems. All variables must be declared before use; the OP declaration of `iseq` is correct and necessary. It is valid to give extra arguments to printf (although surely not what OP intended). And you didn't mention the main problem. (comparing past the end of the strings)
Aside from the minor flaws pointed out by others, my guess is that you're problem is you're comparing the entire array, not just the data entered by users. Depending on compiler implementation, any variable that isn't given an explicit value contains junk data. Sometimes compilers clear any any junk data, which is nice, but we shouldn't depend on this behavior. To illustrate, say your user enters the string "hello". C uses the escape code '\0' (NULL) to indicate the end of a string, so it will have that value appended to it bringing the length of the string to 6 characters. The remaining 19 could have any random value, because no value was ever written to them. So to fix your problem you should compare the strings, character by character like you have been, but also add an if statement to check if either of the current characters is equal to '\0' and break if one of them is.
No, int main() is not valid signature in C, even though it works on most compilers. Yes, all variables must be declared before use, but in this case j shouldn't be declared and i should be declared in the for loop. The best place for iseq is just before the for loop. Passing extra arguments to printf isn't good practice even though the code still works. If you had read my comment with thought, you would have noticed that I mentioned the fact that OP is reading from the index 25 of the strings. 
The main problem is reading from the indices before 25 and after the end of the input . (E.g. input `bar` twice, then when `i` gets to `4` it reads uninitialized memory). The problem with index 25 only occurs if two identical words of exactly length 24 are entered. Entering a longer word would cause UB due to buffer overflow at the point of input. [See here](https://stackoverflow.com/a/29195400/1505939) for `int main()` discussion 
#include &lt;stdio.h&gt; int size =10; void longestCont(int temp[]); void longestFreq(int temp[]); int main() { int temp[size]; for(int i = 0; i &lt; size; i++) { printf("Enter the heat values: "); scanf("%d", &amp;temp[i]); } longestCont(temp); longestFreq(temp); } void longestCont(int temp[]) { int val, cnt = 0; int tempval = temp[0], tempcnt = 1; for (int i = 1; i &lt; size; i++) { if (temp[i] == temp[i - 1]) tempcnt++; else { if (tempcnt &gt; cnt) { //store the old values val = tempval; cnt = tempcnt; } //store the new values tempval = temp[i]; tempcnt = 1; } // End of loop check if (i == (size - 1)) if (tempcnt &gt; cnt) { val = tempval; cnt = tempcnt; } } printf("Temperature: %d\n", val); printf("Count: %d\n", cnt); } void longestFreq(int temp[]){ int val, cnt = 0; for(int i = 0; i &lt; size; i++) { int tempval = temp[i]; int tempcnt = 0; for(int j = 0; j &lt; size; j++) { if(temp[j] == tempval) tempcnt++; } if(tempcnt &gt; cnt) { val = tempval; cnt = tempcnt; } } printf("The most frequent value is %d. Freq = %d\n", val, cnt); } Got it only using arrays 
There are 2 places you call malloc; to get a list of sequences and to get a list of integers. There are 3 places you call free; 2 of them undo the mallocs, the 3rd is wrong.
In addition to all the other flaws, (most notably the off by 1 error) you're comparing past the end of the string. You're always comparing every byte in the buffers, even if you're comparing the 6 character string "hello" to the 6 character string "hello". (I do mean 6 characters, not 5. If you think "hello" is a 5 character string you're wrong. Think about why.) If there's garbage after the end of the string, and those garbage bytes don't happen to be the same, (there's no reason why they should be) it will end with not-equal. You need to figure out how to end the iteration when the end of the string is reached, and how to handle it correctly. ie, "hello" should not compare equal to "hello world" or vice versa.
Hybrid interpreter/compiler, and still very raw; but simple in straight C with a novelty or two thrown in; feel free to have a look: https://github.com/basic-gongfu/cixl My advice would be to focus on the problems you want to solve instead of dogmatics and ceremonies, keep it simple and get something working. Classical compiler literature tends to focus on building classical compilers, which is fine if that's what you're doing but largely a waste of time otherwise from my experience. Good luck!
This line allocates one block of memory of size `n * sizeof(Sequence)`. This is a single pointer (an array of Sequence structures): Sequence *sequences = malloc(n * sizeof(Sequence)); When you go to free the memory you correctly call `free(sequence[i].arr)` as the array is another allocation, but there is no need to call `free(&amp;sequence[i])` as you only need the one `free(sequence)` call at the end. If instead you had chosen to allocate a `Sequence**` block of data you would need to free each struct in the array, because every `sequence[N]` would point to a `Sequence*` whereas your `Sequence[N]` points to a `Sequence`. Your program stops segfaulting for me by simply changing your free loop to this: for(int i = 0; i &lt; n; i++) { free(sequences[i].arr); // free(&amp;sequences[i]); } free(sequences); However, you also have an uninitialized data problem with `lastAns` which will not likely crash your program but will be whatever was at the memory when it is declared, until it is set in your `if (t == 2)` block.
 Sequence seq = { initialized: 1, capacity: capacity, size: 0, arr: malloc(capacity * sizeof(int)) } That foo: stuff does not look like C... did find a reference to it in GCC documentation where it's an alternative designated initializer syntax that's listed as being obsolete since gcc **2.5**. So yeah. Don't do that.
In Perl, look up 'chomp()'. 
The requirement is a bit silly as strings are technically arrays, too.
The submission guide tells you how to post code correctly formatted. Also I thought you were to *not use arrays*?
Usually those requirements are about the actual algorithm rather than the output (Note it's not even mentioned in the printed assignment). But I wonder, if they'd be allowed to store the input once in an array -- otherwise I don't see any solution for the "most frequent" problem without (ab)using the call stack for saving the data because that way the space complexity is O(n).
“longest continuous period” is definitely possible. Just keep track of the longest continuous period encountered so far and the length of the current period. Most frequent value however is not unless you are allowed to make multiple passes through the input.
What do mean? snprintf and asprintf exist
Yes. Look up `sprintf`.
C is turing complete, so anything is possible.
Yep, the first is possible, the latter... not so much, although due to the limited range you can simply encode the values and store them in integral ints, a solution for an input range of just 0..15 (for simplicity): #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;inttypes.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #define MAX_APP 15 #define MAX_LEN MAX_APP #define CODE_BITS 4 #define MAX_TEMP (64/4) -1 int main(void) { unsigned input[] = { 5, 5, 5, 1, 2, 1, 1, 2, 1, 2, 3, 1, 5, 3, 4 }; size_t len = sizeof (input) / sizeof (input[0]); assert(len &lt;= MAX_LEN); // idea: As we have maximum 15 inputs, each number can occur only // 0..15 times. We can encode each number of occurance using 4 bits, // using the least significant 4 bits for the number of appearances of // 0, the next 4 for 1 etc. -- this makes us use 4*i bits for inputs // in the range of 0..4. uint_least64_t code = 0; // 16*4 bits -&gt; 0..15 supported as input // simulate "reading input" for (unsigned i = 0; i &lt; len; i++) { unsigned c = input[i]; assert(c &lt;= MAX_TEMP); // get current count: shift and mask uint_least64_t count = (code &gt;&gt; (c*CODE_BITS)) &amp; MAX_APP; count++; // clear old amount code &amp;= ~(MAX_APP &lt;&lt; (c*CODE_BITS)); // set new amount code |= count &lt;&lt; (c*CODE_BITS); } // now determine the maximum unsigned mcount = 0; unsigned max = 0; for (unsigned n = 0; n &lt;= MAX_TEMP; n++) { uint_least64_t count = (code &gt;&gt; (n*CODE_BITS)) &amp; MAX_APP; if (count &gt;= mcount) { mcount = count; max = (unsigned)(n); } } // precision of 16 because we want to print the count of our (max) 16 // input temperatures printf("code: %#.16" PRIxLEAST64"\n", code); printf("%u was most frequent with %u appearances\n", max, mcount); }
 #include&lt;stdio.h&gt; #include&lt;conio.h&gt; int main() { int i,j,iseq=0; char string1[11], string2[11]; printf("Enter the first String :\n"); scanf(" %s",string1); printf("Enter the second String :\n"); scanf(" %s",string2); for(i=0;i&lt;sizeof(string1)/sizeof(string1[0]);i++) { if(string1[i]!=string2[i]) { printf("Comparing\t%d:%d\t------------&gt;\t%c:%c\n",string1[i], string2[i],string1[i], string2[i]); iseq = 1; }else{ printf("Comparing\t%d:%d\t------------&gt;\t%c:%c\n", string1[i],string2[i],string1[i], string2[i]); } } if(iseq==0){ printf("Equal!",iseq); }else{ printf("Not Equal"); getch(); } return 0; } i have made some changes to the code so that you can see what is happening. First problem with your code was "off by one error", meaning that the loop ran 26 times even though the elements were 25(including null byte character)(case if you input 24 elements)... And "scanf" marks the end of the string with '\0' meaning if your first input is "hello" and second input is "hello" it is stored as {'h','e','l','l','o','\0',} in memory but since the loop is running even after going past through null byte, looping through the uninitialized elements whose value is random so your code's 'if' condition was true and isseq was assigned value '1'. Idk if this is all there is to it.. i myself started learning C a couple of days ago :) 
Possibly capacity:capacity initializes it with itself rather than the function parameter
[No](https://gcc.gnu.org/onlinedocs/gcc-7.2.0/gcc/Designated-Inits.html#Designated-Inits).
That page doesn't seem to cover the case of the initializer having the same name as the member being initialized. All it says is that `y: yvalue` has the "same meaning" as `.y = yvalue`, but I wouldn't trust from that that the behaviour is the same in the case of the names being the same. 
Imagine an array of length 8. You enter a 4 letter word, abcd. The first 4 elements are set to a,b,c,d and the 5th element is a null character indicating the end of the string. Anything past the 5th element is uninitialized and will contain garbage data. String a = [a, b, c, d, /0, y, h, p] String b = [a, b, c, d, /0, w, s, v] Both arrays are equal up until the 6th element. When you come across a null character (0) you need to stop comparing because the string is over. I'm assuming you're using msvc. Put a breakpoint in (left side of text area) next to the line with the for loop and inspect (hover over) the values of string1 and string2
What else is it supposed to refer to if not a variable?
Even the universe?
#include&lt;stdio.h&gt; #include&lt;conio.h&gt; int main() { clrscr(); int i,j,iseq=0; char string1[25], string2[25]; printf("Enter the first String :\n"); scanf(" %s",string1); printf("Enter the second String :\n"); scanf(" %s",string2); for(i=0;i&lt;=25;i++) { if(string1[i]==string2[i]) iseq++; else if(string1[i]!=string2[i]) break; } if(iseq!=0) printf("Equal!"); else printf("Not Equal"); getch(); return 0; } oh boy fixed it, you just need another else if statement to break counting the iseq ,if its not matching i.e the stings zeroth characters
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int i,j; int a[20][20]; for(i=0; i&lt;20; i++){ for(j=0; j&lt;20; j++){ a[i][j]=rand(); printf("%d ",a[i][j]); } printf("\n"); } return 0; } check this one out,use 3*3 array for clearer visualisation
The member. Similar to how `void f(int x) { int x = x;` initializes the local variable `x` with itself (not with the parameter).
Take a look at preexisting programs https://github.com/carlos8f/zenbot
The kind of coding you would do for Computational Physics is very different to what you would need to interact with a brokerage API. If you wanted to do that in C you would need to be thinking about implementing a network client of some kind.
No idea
You could actually forget about `free` entirely here. The operating system will reclaim memory on program termination. Since you need all of your data right until the end of the program, calling `free` is redundant. This is only recommended for very simple programs like this that run for a short period of time.
Have you tried reading the [C standard](http://iso-9899.info/n1570.html)? It explains what these prefixes mean. There is really no better way to understand this than to read the standard.
Thanks you!
Note that asprintf is a GNU extension. You can use open_memstream and fprintf to achieve the same in a POSIX compatible manner.
The page you linked says how to define an array /* defines an array of 10 integers */ int numbers[10]; 
Yeah, I did try to add that lessen to the exercise but most have done it wrong, since I moved on and trying to solve it otherwise. Will revisit and see what I can do. Thanks!
The submission guide tells you how to post code correctly.
Please stop shilling your product. People don't go on reddit to see advertisements.
See https://en.m.wikipedia.org/wiki/List_of_electronic_trading_protocols.
I did not use allegro since - but what i learned was useful on many occasions. As for working with it i can say i did not have many headaches :P
Well, anything that is turing computable, of course.
Yup. Havent slept well and now that I came back to the computer and read your answer, I can clearly see that I missed one line in the examples given. Doh! Facepalm! Anyway, thanks for the reply. At least it led me to this subreddit for future, not so dumd, questions.
I totally missed the int numbers[10] thingy and just realized I had to change numbers -&gt; grades in the array. Learning is fun!
Your solution has the exactly same problem as the original code...
`int i = ‘1234’` is valid. The prefixes are just for avoiding narrowing/sign extension. Useful for coming with magic constants in enumerated or whatnot. https://godbolt.org/g/ajVnpJ
&gt;The page you linked says how to define an array &gt; &gt; /* defines an array of 10 integers */ &gt; int numbers[10]; &gt; This array is not defined. It is only declared.
Nope. C11 standard (6.7-5) states: A declaration specifies the interpretation and attributes of a set of identifiers. A definition of an identifier is a declaration for that identifier that: — for an object, causes storage to be reserved for that object; — for a function, includes the function body; 119) — for an enumeration constant or typedef name, is the (only) declaration of the identifier. `int numbers[10]` reserves space; so it is a definition.
Well if have a minimal programming background I would recommend K&amp;R's book as it "assumes" one knows that much! If you want to thoroughly know C, King's Book "A modern approach" is a go, he teaches as a teacher would. As for MacBook, there is a lot of famous C programmers using that $hit from apple! So you are fine! haha Though I would recommend you use Neovim or Spacemacs for Macs! Good study! 
pointers, pointers, pointers. And handling memory. &gt;Apparently my school uses gcc to compile so can anyone explain what this is and help me set this up on my MacBook running High Sierra? My recommendation is try to find some simple "Hello World" tutorial just to get up and running. In the end you'll probably get all this information during your course though, and you seem to be a curious person, honestly you'll probably get the hang of it pretty fast.
If you've gotten comfortable using Java tools I recommend using CLion as an idea. It's not free but it works pretty well. As far as learning the language, pick a project, pull up some Google and dig in.
Read also this article to put you in perspective of the differences between Java and C https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/ the guy is a bit condescending, but the article is gold 
It's great you want to get a head start! This way it'll be easier for you to reason about the different concepts that you'll see once you start your class. Java and C are similar in that they an imperative style for the most part. Even though Java has been adopting new and modern features, you can still discern the imperative style in Java code. They also share similar syntax for for/while loops, if-else statements, and variable declaration. I'll also link some useful stuff that will hopefully help get you up and running with C: * The C Programming Language by Brian Kernighan and Dennis Ritchie has already been mentioned in the comments here. It's a classic, and it'll definitely help you get started with the language. * [The C Book.](http://publications.gbdirect.co.uk/c_book/). The sidebar also has some extra resources if you want to check it out. * [List of Free C Books](http://www.iso-9899.info/wiki/Books). * [This reddit post](https://www.reddit.com/r/C_Programming/comments/74uqp1/a_book_that_dive_into_much_more_detail_in_c/) also contains suggestions to dive deeper into C once you've mastered the basics. You might want to check them out if you feel you want to learn more about C. * This old [BYTE magazine article](https://archive.org/stream/byte-magazine-1983-08/1983_08_BYTE_08-08_The_C_Language#page/n65/mode/2up) over C. This is more of a fun read over the history of C. Don't use it as an actual reference for C. * [Essential C.](http://cslibrary.stanford.edu/101/). This contains several pdfs over pointers and some data structures. * Pointers have also been mentioned in the comments. There is almost always one chapter dedicated to pointers in every C book. If you feel you're struggling to understand them, don't worry. Pointers baffle even the most experienced of programmers at times. And you can always post on this subreddit should you have any further questions c: As for installing gcc on your laptop, Try installing Homebrew if you don't have it installed (https://brew.sh/). Installing gcc should be as easy as: brew install gcc. If you have any extra questions, don't hesitate to ask. Best of luck and happy holidays!
&gt; Are there a lot of similarities between Java and C? No, because Java is an object-oriented-only language, whereas that concept really doesn’t exist in C\*. That said, as long as you understand that functions (or ‘methods’ in Wrongspeak) are the main units in C code, you should be fine. GCC stands for ‘GNU Compiler Collection’. It’s a compiler for C, made by the GNU project that (IIRC) is already installed on OS X machines. Open your terminal and issue ‘gcc --help’ for more info. That said, I prefer Clang, but GCC isn’t a bad choice. \* There are good arguments to say that structs are objects, but they aren’t in any way that you would understand them. Don’t worry about that for now; your school should explain better.
The ISO/IEC 9899 standard is the definitive version of the C programming language. There are dated revisions which apply to that version of C, e.g. C99, C11, C90/C89. The official version of the standard requires payment, but there is almost always a draft available of version the committees vote on which is freely available.
Cuz i never intended to solve it. I just wanted to show him why the code was not working( the ascii value of the compared characters is printed by the code). And you can input 10 alphabet characters to make it work but yeah this code isn't complete...
 #include&lt;stdio.h&gt; #include&lt;conio.h&gt; int main() { int i,j,k,l,compare,iseq=0; char string1[25], string2[25]; printf("Enter the first String :\n"); scanf(" %s",string1); printf("Enter the second String :\n"); scanf(" %s",string2); for(k=0; k &lt; sizeof(string1); k++){ if(string1[k] == '\0') { break; } } for(l=0; l &lt; sizeof(string2); l++){ if(string2[l] == '\0') { break; } } //printf("%d\n", k); //printf("%d\n", l); compare = (k &gt; l) ?(k): (l); //printf("%d\n", compare); for(i=0;i&lt;compare;i++) { if(string1[i]!=string2[i]) { printf("Comparing\t%d:%d\t------------&gt;\t%c:%c\n",string1[i], string2[i],string1[i], string2[i]); iseq = 1; }else{ printf("Comparing\t%d:%d\t------------&gt;\t%c:%c\n", string1[i],string2[i],string1[i], string2[i]); } } if(iseq==0){ printf("Equal!",iseq); }else{ printf("Not Equal"); getch(); } return 0; } I think this was the output he wanted :) 
One big difference that messed me up when I went the other way was that A) C has no classes, you can just declare functions. B) in C you have to declare functions first before you can use them where in Java you can just put your functions in whatever order 
Super interesting article. I also agree that Java does not teach students what a computer is ACTUALLY doing, but just how to construct the logic of a modern program. My school taught me the CS1 class in Java, Data structures in C++, then Algorithms and Operating Systems in C.... I thought it gave me a very nice slope into tough topics and I think it's a great transition for students
You might also find the GNU C Library docs useful https://www.gnu.org/software/libc/manual/html_node/index.html along with the POSIX specification http://pubs.opengroup.org/onlinepubs/9699919799/
What will probably make adjusting to C the toughest is trying to break the habits you got from using Java. For instance, you can no longer get away with initializing a variable without setting it equal to something. I mean, you still can, but the value can be anything. Probably the biggest thing though is the pointers and memory allocation. Another thing we take for granted in Java is the garbage collecting that happens under the hood. In C, that isn’t the case. It’s now your responsibility to not only do that, but to also know when to do that. It’s been awhile since I’ve worked with C, but I’m actually retaking a C course in the Spring. This was all I could remember. I’m sure there’s much more.
Folks I'm on the in the different boat altogether. I've been programming in C for over a decade, I'm pretty comfortable with Python and overall OOP concepts and design patterns. I'm trying to learn C++, and one of the biggest challenges I'm facing is, I find C++ extremely verbose ( compared to C and Python.) Any recommendations how do I go about it.? 
Hi there! I think that whereas what you describe would be an interesting project for command line parsing, the syntax that you've specified seems to not conform with what most people would expect of "typical" command line arguments. Incidentally, because people do want to agree on a standardized way to parse command lines, the `getopt(3)` function is part of the standard library to accomplish exactly that (at least on Unix-like machines). As such, learning how to use `getopt` is quite useful because it's pretty much the standard way command line arguments are handled. Of course, that shouldn't stop you from building your own project for educational purposes; however, that being said, maintaining the format people have expected for decades from CLIs is probably a good idea too from a usability perspective. The manual page (`man 3 getopt`) and/or the [POSIX specification](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getopt.html) describe it in more detail; the example programs provided in them might help too.
hello, it has been 18 hours since you posted this and i hope you have found the solution to it. if not you can have a look at this: my native language is not English but i will try to sound as clear as possible. so, as per the exercise, your output/answer should be **85** (which is the average of **three numbers**, one being 80, the other 90 and another on which is an unknown number which you have to find) and also, you have a missing "grade" variable. well firstly, you should try to declare a variable for holding the three numbers together: so you use an array of three numbers(three?? yes, cuz you have to find the average of three numbers): the array will be grades[3]. since you are dealing with **integers**, 80 and 90, as a result, the **type** of the array must be an "int". the declaration becomes as int grades[3]; lastly, about the unknown number, thinking mathematically, the second number should be 85. 80+85+90 = 255 255/3 = 85 which is the desired output. __________ . . . int grades[3]; grades[0] = 80: grades[1] = 85; grades[2] = 90; . . . __________ In short, declare grades as an array of three integers, put the second entity in the array as 85. i expect this to be helpful to you. if there is any mistake, please tell me i am also learning this language and i agree that learning is fun! good luck. 
That would be really unusual and confusing. 
That's usually not the task of the shell. Most programs use getopt
I think the additional flexibility is a maintenance liability (and I feel the same way about almost all features that are "free" or "fall out of the implementation"). As a separate consideration, I think this behaviour could be surprising to users who are used to POSIX getopt semantics.
These are all great answers! Thank you very much!! 🙏🙏🙏
The `getopt` parser can already allows you to do something like this, but slightly different. I recommend you to stick to `getopt` as its behaviour is part of the IEEE 1003.1 industry standard. &gt; dog -bn poodle zach That's okay, but a bit confusing. In `getopt`, you would have to write this as dog -bpoodle -nzach or dog -b poodle -n zach which is a bit clearer.
The authoritative specification of C is ISO/IEC 9899:2011. It costs CHF 198 and is available from ISO. You can get the last draft named N1570 on the internet.
`strcmp` returns 0 if the strings match.
Hi dude, the problem is that the strcmp returns 0 if the strings match and not a NULL value. So in your if statements you to put for example this line of code: if (strcmp(command, "ls") == 0) { //If the string match, do this instructions } Another thing is that in your case, the scanf of a string don't require the &amp;.
I already tried with == 0 but it doesn't match the strings at all
Print the string and see what it is.
it prints out the correct string
Make sure that there are no extra spaces or newlines after the string. If it’s still not working, paste your whole code again so we can see.
Also, move all your includes to the source files (.c/.cpp). Your compiler won't have to open the same file 50 times only to find an include guard.
I checked and there doesn't seem to be. Here is the code : https://pastebin.com/RE5uGkNP
NULL is guaranteed by the standard to compare equal to zero, but I agree it's bad practice to use it with non-pointer values.
Try adding `\n` to the end of your printf calls. Altervatively, call `fflush(stdout)` immediately after each call to printf. Otherwise the terminal won’t display the text.
`fgets` stores the newline char too when reading a line
Unless it reaches end-of-file, fgets will also transfer the newline into your buffer. The goto is redundant. It's going to loop anyway because of the while(1).
The problem with that approach, though, is that you have you now have to include your .h files in a very specific order and your source files will explicitly include headers that they don't directly use; whereas, if your .h files also include the .h files they need, neither of these things are issues.
any article that treats c and c++ as the same language doesn't deserve to be read, sorry.
Did you even read the article? Every problem that the author outlines applies to both C and C++. The first couple of sentences just about C++ is a little misleading, but the rest of the article is correct.
the very first point confounds the two languages, so I stopped reading after that. every other point may be right, but if the author doesn't understand the difference in c and c++, what's the point?
&gt; fflush(stdout) Thanks for the advice! It turned out I had to use scanf instead of fgets an use a fflush(stdout) to make sure the strings matched...
&gt; what's the point? The rest of the article?
I understand you disagree with me, and I'm trying to explain to you that if I read a technical article with basic mistakes up top, the author loses credibility and I won't make it to the bottom. I'm not the only one like that, there are many things I'd like to read during the day, and your comments don't qualify.
Gcc is actually an alias to clang on recent osx versions. 
I've *heard* once that one could even combine non–option-argument–options with one option-argument–option (this being the last in the combined option) too -- but I haven't found this in the POSIX standard just now. Do you know more about that? The idea is: cmd [-a] [-b] [-f file] to be allowed to be executed as cmd -abf somefile
Have you heard of ncurses?
[12.2 Utility Syntax Guidelines](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html): &gt; Guideline 5: &gt; One or more options without option-arguments, followed by at most one option that takes an option-argument, should be accepted when grouped behind one '-' delimiter. 