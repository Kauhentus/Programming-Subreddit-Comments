Thank you. You can add your own sorting algorithms to it and see how it unfolds. Its a great way to learn :)
üëçüèª
Yes. A service is a normal PE executable that calls some SCM APIs when it starts.
Yes, it can. However, if all you're talking about is a program that can accept a TCP/IP connection and respond, it doesn't need to be a service, which has a specific meaning in the Windows API. A simple program that is in a terminal window could do that. However, if you want to make it a real service that is run by Windows in the background and started automatically and all that, then yes, I'm sure you can do that as well.
Yes, I did this exact thing recently. Just make the executable and use a tool that sets it up as a service.
[Not possible from userspace](https://stackoverflow.com/questions/48368776/access-to-kernel-memory-from-userspace-task-struct). Are you writing your own kernel?
I am not willing to write an essay here, but: &amp;#x200B; It's explicitly stated, in the name, that it's semi generic, and it does work on non POSIX systems, as far as I know microcontrolers are not POSIX, and I have tried it on many (stm, esp, avr, msp). I can't or don't want to use C++ sometimes, this is not made to replace C++ STL, I just found it to be the most fitting implementation, so I also use it to compare them. I made it compatible for the highly unlikely case where something written using this may be used in C++, and the only things needed to be changed to do so were replacing `restrict` with `__restrict__` and static type casts. I wrote benchmarks for the things I thought to be more important and used hyperfine witch evaluates with the same outer conditions, and even with biases, they would occur equally in the tests for both mine and C++ programs, still I am in search for more precise benchmarks, I would be glad if someone wrote some of them. And I don't see how the STL is secure, throwing an exception is the only thing it may do, and that is no solution in my eyes. When I said no undefined behaviors I meant the case when someone follows the rules, inserting guards in every functions would slightly reduce the performance (look at vector fetching), it is up to the programmer to evade failures, and if you want your `malloc` to warn you when out of memory you could write a wrapper around it. I don't want to see `malloc(n, 1)`, I don't know what it means, where `malloc(n, sizeof(char))` clearly tells me that I allocate an array of `char`\-s. My answer about the `inline` question was just looking at the performance, no need to lecture me. I tried many hash functions, this one proved to be the best, if you find a better one I would be glad to see it. I repeat, I do not want to use C++ sometimes, but for example I may want to use a hash map in my C project, and the libraries I have seen so far witch have those things implemented are much harder to use and much uglier. I don't understand the 1980's reference. I didn't use files nor strings in my benchmarks, so no need to mention them. (answered respectively).
Is there an alternative I could use to map out memory sections, .bss, data, text, heap, stack etc. I am thinking of reading the exe from proc and grab the sections from that. Would that work?
Things like "process memory sections" are not part of the C language spec, so I don't believe there is any portable way to even know if those things exist. &amp;#x200B; There are some way to probe some of these things without using platform-specific functionality, e.g.: heap: you could perform a series of malloc calls and see if the returned buffers are all in the same range of addresses and at what point it starts failing. stack: you can examine the address of stack variables to see where the stack is (or if there is one!) and in which direction it grows, and make increasingly deep recursive calls to see when you run out of stack memory. code segment: examine the addresses of function pointers to your program's functions; this would at least give you a range of addresses that are (probably) a contiguous code segment. data segment: examine the addresses of static variables; again, this will give you a range of addresses that are (probably) a contiguous data segment. Const static variables or string literals may be placed in a separate read-only segment. &amp;#x200B; Actual kernel data structures like virtual memory mapping tables are generally not stored in such a way that user processes can see them. Your particular platform may have system calls or other ways to access such data (like /proc on Linux). You may also be able to write ASM code to look at the currently loaded page tables, but it looks like generally user processes are not allowed to read the relevant control registers: [https://stackoverflow.com/questions/7415515/how-to-access-the-control-registers-cr0-cr2-cr3-from-a-program-getting-segmenta](https://stackoverflow.com/questions/7415515/how-to-access-the-control-registers-cr0-cr2-cr3-from-a-program-getting-segmenta)
I don't think so. Reading the binary file will give you the addresses of the memory coming from it, but that's all. I don't think you will be able to guess the addresses of the stack or heap since they don't exist in the binary.
 &gt;Does this also apply to cpp? You probably shouldn't ask C++ questions in a C language subreddit. There are several subtle differences between the languages, even in the bits that *look* similar.
What are you actually trying to do here? Why aren't you allowed to read from /proc/self?
If you disagree with me explain why, don‚Äôt act like a 5 year old.
Just a project, not reading from proc/self/maps was just a restriction. I can read from proc file system, just cant read from maps to get the information.
Thanks for your reply I have managed to get the information back using the dl\_iterate\_phadr function.
Thanks for all of your replies I have managed it with dl\_iterate\_phadr function.
in c, no. by people who may or may not write programs in C, there are frowners.
dun do it hacker jo dun do it
Goto's are only frowned upon due to historic reasons. Early in the 60's and 70's everyone was new to programming, and jumps/goto's were littered around code like crazy. It was called spaghetti code since it was difficult to follow program logic. That lead to several decades of Comp Sci professors banning goto's and disallowing their students from using them, which lead to it being frowned upon. However, there are definitely proper times to use goto's as they will **speed up execution** and/or **improve code clarity**. The internet is filled with great examples of when to use goto's. But with that in mind, know this: * You never need to use them. * Usage cases are rare and as a new or intermediate C programmer you wont need to use them.
&gt; I have gotten away with not using GOTO in my decade of programming. Curious if there is any cases where If statements wouldnt suffice... Maybe I'm picturing my own state systems. You never need to use goto, but sometimes it's definitely better to use it.
I know little of C#, and you're right in the sense that you can use pointers to pass a reference to functions, but pointers in C are really more transparent than that. They are a memory address. They represent a position in memory, and by assigning them to a specific variable, they represent the memory location where that variable's data is stored. You have to dereference them to alter the data, and the reason is because if you don't do that, you can manipulate the value of the pointer itself. IE, +1 to a pointer without dereferencing will cause the pointer to point to the next bit of memory after that variable you assigned it to. Which may sound crazy or not useful at first, but you can do some really useful thing with them. You can also do some really stupid things with them.
I don't know C#, but there are still funny little things in C to be aware of. Like: int main() { char *c = malloc(sizeof(char)*7); char *temp = c; strncpy(c, "dummy", 6); *c++; printf("Hello World, %s.\n", c); strncpy(c, "dummy", 6); *c += 1; printf("Hello World %s.\n", c); printf("Hello World %s.\n", temp); free(temp); return 0; } You might think those two increments would behave exactly the same. But the output is: Hello World, ummy. Hello World, eummy. Hello World, deummy.
Oh, I know about dereferencing, I suppose I just didn't think of it when posting, since you don't need to do it in c#. I understand it, without dereferencing, you're affecting the memory address, instead of the variable it's pointing to. Could it be that if you point to an element in an array, adding to the pointer gets you to the next element? I'm just guessing.
This is correct from what I understand, with the caveat that it's not bit by bit (you need to add by the bitsize of the elements of your array). Array variables are themselves a pointer to the first element in an array.
Good on you. I swear half the problem beginners have with pointers is just being scared of them. If they're not scary, they're not that bad. I will say that pointers aren't *just* `ref`, though. C allows you to do arithmetic with them in ways that you can't in C#. But the idea is still the same.
It depends on the type of the pointer. If you have a ```struct some_big_struct *``` pointer, adding 1 to it will give you a pointer that's ```sizeof(some_big_struct)``` further along in memory. If you were to cast it to a ```unsigned char *``` pointer, adding 1 to it would only point one byte further along in memory.
Yeah, I thought that might be the problem, I don't know how memory works, though. When I wrote it, I was thinking that a single memory address has to point to a single variable, and it can be any size, I suppose the memory address of a variable is just the starting point of that variable? I should stop speculating, because I could be completely wrong, I suppose I should just wait until I learn more.
Yeah, I figured that a bit after I commented. I was thinking a memory address can hold any amount, but I suppose making a pointer to an int variable, will just give you the starting address of that int, and subsequent addresses are just different parts of the int?
What do you mean scared? If you mean doing stuff with pointers that haven't been initialised, then I already took the precaution of using a virtual machine, since I'd be scared it could crash my computer, or worse.
That is correct, but there's even more that you can do. Here's a sample from a memory allocator I wrote. The variable `chunk` used here is a `struct chunk *`, and `len_checked` is a `size_t`. if (len_checked != total_len) { chunk += CHUNK_REAL_SIZE(chunk); len_checked += CHUNK_REAL_SIZE(chunk); } Chunks of allocatable memory are organized linearly, but can be different sizes, and I needed to be able to get the *next* available chunk if the current one wasn't large enough to accommodate however much memory the caller needed. Since each `struct chunk` internally stores its own size, and since the next chunk lives right after the current one, adding the size of the current chunk to the address of the current chunk gives you the address of the next chunk.
Maybe "scared" is the wrong word. I should have said "intimidated". A lot of beginners, when they first see pointers, immediately say "holy shit I can't do that". (It doesn't help that they've often heard from older students that pointers are hard). I was saying it's good that you're not scared/intimidated by them. It's awesome that you found a similarity in C#.
You can think of memory as a big array of bytes, and pointers are just indices into that array. The type of the pointer only really determines what happens when you do arithmetic on it. Casting between an int * and a char * does not change the value of the pointer at all, it just changes what ptr++ or ptr[i] do. So, yes, a pointer to an int actually points to the first byte in that int. If you were to cast that pointer to an unsigned char * and access it like ptr[0], ptr[1], etc., you'd get different parts of the int, cast to char.
They aren't really intimidating to me. Maybe to complete beginner who has never programmed at all, but if you know a bit about programming, and even better, ref in C#, then they're easy. Learning about ref in C# was also easy, so it's not like I had to struggle for hours with that. I'm sure there's something I'm missing, since it doesn't seem that hard, maybe it's because I haven't really looked into stuff about memory.
&gt; I suppose the memory address of a variable is just the starting point of that variable? Correct. I'm not an expert, either, so take what I say as the broad strokes of it, but the memory addresses are addresses of individual bits in memory (well, the virtual memory provided by the OS). The size of a variable means that a pointer to the address immediately after that variable's 'pointer' is just going to point to another bit in that same variable. So, if int x = 10 and *x is 100005, the value referenced by a pointer to 100006 is just the 1 bit in 1010 (8 + 2 = 10). There's a lot of nuance here I either don't know or understand, but that's the basics of it I do think I get.
&gt; What are your opinions on the goto statement? I used to think the goto hype was overrated, then I got a job supporting legacy Fortran... Judicious use of goto can still be useful. But rarely do you need them.
Could that be because it's doing *(c++)?
I think beginners are more scared about pointers with multiple levels of indirection, like in array of arrays. It's not really that hard but throw in the obscure syntax for consts, pointer to arrays, function pointers, and I can see why people are scared. It's really about the syntax mostly. int *(*(*f)(void))[10] This is a pointer to a function taking no arguments returning pointer to an array of 10 pointers to int. Now look at this with a different syntax (Go ish) and you'll see its the syntax to blame. *f(void) *[10]*int You also learn about "arrays are pointers to first element" which is garbage. Arrays get decayed to pointer first element except when its not an argument to sizeof, alignof and some other things. Lots of misinformation in this area - beginners need to be careful. My recommendation: Every beginner must read the new testament (K&amp;R 2).
Thanks. I'm reading through a free ebook from one of the guys working at raspberry pi. I personally don't like some of his whitespace conventions, but it's free, only 90 pages, and it feels nice to get up and running quickly. I'm not sure if it's a great start, but I'm enjoying it so far, I'm probably going go through cs50, too, then probably get k&amp;r.
Yeah... which actually is (at least on [this compiler](https://www.onlinegdb.com/online_c_compiler#)) the same as doing c++, or c += 1. But I'm still used to seeing code making the pointer explicit for whatever reason....
&gt; they're almost exactly like using the "ref" keyword in C# The ref keyword achieves the same goal as one of the uses of pointers, but they are not the same as pointers. In the case of C# and C++ references, they're aliases instead of pointers. An alias introduces a new name for a variable, possibly with a different scope than that variable. Behind the scenes they're implemented with pointers (or however C# works), but they are no, themselves, pointers. There's only one thing you need to know when you're working with pointers: a pointer is just the address of something else. That's it, there's so much apprehension when it comes to learning pointers, but that's about as complicated as your mental model of pointers needs to be. So your example of passing a value by reference (or passing a pointer to a variable in C-speak) would look like this. void embiggen(int *i) { *i = *i + 1; } int main() { int perfectly_cromulent = 10; embiggen(&amp;perfectly_cromulent); } When you call embiggen, you use the address of operator. So instead of passing the value 10, you pass the _address of_ the variable `perfectly_cromulent`. Since you have the address of an integer, you can read or write to memory at that address. The dereference operator is what does that (a pointer is like a reference, and _de_referencing it makes it act like a normal variable) and there are two in `embiggen`. The first is on the left of an assignment operator. This means "take whatever is on the right side of the assignment operator and store it in the address from the i variable." And then the one on the right, since it's not on the left of an assignment operator means "go to the memory address from the i variable and read an integer value." By thinking of pointers as variables that hold addresses (since that's what they are, after all) you can very easily reason about what's happening in your code. So why _shouldn't_ you think of them as references? References are different. You can't store a reference and use it later, but you can store a pointer and use it later. int *spider_pig = NULL; void embiggen(int *i) { spider_pig = i; *i = *i + 1; } void woozle_wuzzle() { if(spider_pig != NULL) *spider_pig = *spider_pig + 1; } int main() { int perfectly_cromulent = 10; embiggen(&amp;perfectly_cromulent); woozle_wuzzle(); } Nothing new or exciting is happening here, we just have one more pointer variable in the global scope: `stored_pointer`. We have one more assignment that's easy as long as you think of pointers as addresses: `spider_pig = i`. The `spider_pig` variable is a pointer, it just holds an address and i is a pointer, it holds an address. So that assignment just copies the address from i into `spider_pig`. Later, when you call `woozle_wuzzle`, it looks at the address stored in `spider_pig`. In that if statement, it's not dereferencing the pointer variable so it's looking at the address, not the value at that address. So if `spider_pig` is not NULL (NULL is really just 0, an address that means "this pointer doesn't hold an address to anything"), then dereference it as you did in `embiggen`. References can't be stored. You can pass them to functions and the function parameter becomes a reference but you can't change what it references later. It's a different beast all together. Do not think of pointers as references because they're not references. What they are isn't difficult, just sit down and think about addresses. There are also more things pointers can do that references cannot such as pointer arithmetic (which, again, isn't hard, it's just modifying the addresses a little bit), but save that for later. However, if you continue to think about pointers are references, you aren't going to understand how things like pointer arithmetic works. You don't need to be apprehensive, you don't need analogies like "it's like a reference." They're only going to slow you down and make you a worse programmer. Pointers are just addresses, just think of them like addresses.
&gt; to the next 'slot' in memory, you need your pointer address to be *x + sizeof(int) on your system But keep in mind that the pointer arithmetic will take into account the size of the thing being pointed to. For example, adding 3 to a char pointer adds 3 bytes, but adding 3 to an int pointer (assuming 4 byte ints) will at 12 bytes. See: int main() { char *c = "ABCDEF"; int i[7] = {1, 2, 3, 4, 5, 6, 7}; char *d = c + 3; int *j = i + 3; printf("sizes are %lu %lu\n", sizeof(char), sizeof(int)); printf("%d\n", j[0]); printf("%c\n", d[0]); } Output will be: sizes are 1 4 4 D
Thanks, I realise that they aren't references, but I just recognised that they are used in a similar way. I think I already kind of understand pointer arithmetic, I edited into the original post. Thanks for mentioning that they're pretty much addresses, though. I thought that if a function takes in a pointer, you have to give it a pointer, I didn't think of just passing the address using &amp;. I would've figured it out sooner or later, since I just checked the book I'm reading, and I'm only a few pages away from it, but your explanation was pretty good. Also, I'll note that in C#, I think there are two types of references, the ones you can use in parameters of methods, and then refs to objects. Say I have an class called Test, I can make a variable/reference "Test foo;", then set it later on "foo = new Test();", but that's a different thing.
&gt;Thanks for mentioning that they're pretty much addresses, though Not pretty much, that's all they are and nothing more. They're just addresses. If it helps even further, they're just unsigned ints and the numbers they hold happen to be addresses to memory locations of values you're interested in. I really encourage you to get rid of analogies like references and fuzzy terms like "pretty much" when reasoning about pointers. Pointers are simple. If you make them simple and look at only what they are, you'll understand them faster. One final thing that really helps is to draw pictures. To figure out what variables you have in a function, draw a box and label it with the variable name. For every non-pointer, write the value in that box. For every pointer, draw an arrow from that box to another box that the address points to. So in the example, the box for i in \`embiggen\` after it's called from main should point to \`perfectly\_cromulent\`. Note to word "point to." Pointers "point" to other objects in the vernacular, in the diagram and conceptually. To figure out if you need to dereference that pointer, think about whether you need to follow the arrow or not. If you need to follow the arrow (such as with both uses in \`\*i = \*i + 1\`), then you need a dereference operator. If you don't need to follow the arrow (such as with \`spider\_pig = i\`, which changes what the pointer points to, but not the value of the thing pointed to), then you don't need a dereference. Pointers are a hurdle for people learning C, but the hurdle is only so high because people tell them that pointers are hard. They're just... not. I remember I was terrified of pointers, I thought they were so complicated because the book I was learning worked me up so much about it. They said pointers are advanced concepts and it'll take you a long time to learn them. What this book didn't tell me was that pointers are just addresses, it used analogies and tried to show you how to use them without just telling you what they were. It was a really crappy book and I regret learning from it, it helped perpetuate the "pointers are hard" crap that really shouldn't ever be uttered to someone learning. They're just addresses, just always keep that in mind. Which book are you reading, BTW?
 int a = 10; // a is on the stack int *ptr = &amp;a; // ptr is pointing to the stack Just in case you didn't realise, but ptr here is holding an address on the stack. It's going to go badly for you if you try to use it after the current function returns. Typically you would use malloc to get permanent space on the heap (until you free it). int *ptr = (int*) malloc(sizeof(int)); *ptr = 10; // do stuff free(ptr);
I'm reading a free ebook, it's only 90 pages, but I like to get started quickly, and I'm enjoying it so far. It's by someone who works at raspberry pi. I'll mention that it's not the books fault, he mentions that pointers are just the address of a block of memory with a variable in it. It was just my knowledge of ref in C# that made it confusing, I suppose, since they seemed so similar. I also took a sneak peek at a pdf of k&amp;r, and that also makes it clear "A pointer is a variable that contains the address of a variable." I sort of knew how to use them, I was just detaching them too much from standard variables. For example, 10 is an integer value, but I wasn't really thinking of an address as a "pointer value".
I'm not familiar with the book. The book I recommend is C Programming: A Modern Approach. If you're in the US, you can pick up a copy from Ebay for quite cheap. It is quite long, but if you just take it one chapter at a time, it's not difficult to work through. Also, if your book has exercises, do them. Do them all. Reading about something and putting it into practice are completely different things. You'll learn 10x as much from exercises as you will from just reading.
Definitely not the same due to operator precedence. If in doubt, use brackets. &amp;#x200B; [https://en.cppreference.com/w/c/language/operator\_precedence](https://en.cppreference.com/w/c/language/operator_precedence)
I understand. The top two lines would've been in the main function, I know that variables declared in a function get destroyed after the function is over.
Thanks, but I tend to get really demotivated by huge books. I'll probably just use a combination of the current book I'm using, cs50, and I'll probably get k&amp;r, which people seem to think is a must read, even if it's a bit outdated. Also, the book I'm reading doesn't really have exercises, since it's only 90 pages, but I'm typing out the programs. I'll probably look up some exercises online at some point. I'm not looking to get a job or anything, just a hobby.
K&amp;R is not incredible for its text. It's very terse and it's written for experienced programmers who want to learn C. The exercises, however, are great. Do them, you will learn so much from them. If you get stuck, there is "The C Answer Book" which is just a book showing how to complete all the exercises.
Wholeheartedly agree with the points (no pun intended) made regarding syntax. I wouldn't be surprised if the frightful reputation pointers have amassed over the years is in no small part due to their syntax in C, rather than a conceptual thing. I'd much rather explain (in a language with clearer/less syntax, maybe assembly) how pointers work, rather than how, say, classes work! (at memory address $0022 : $0046) (at memory address $0046: $0001) LDA #$0022 ; load the literal hex value $0022 into A LDA $0022 ; load the value stored at address $0022 into A ($0046) LDA ($22) ; treat the value stored at address $0022 is an address. load the value at that address. In this case, $0046 is stored at address $0022, so we load whatever is stored at $0046, which is $0001. I think the lack of any typing at all actually serves to highlight just how basic pointers are; **Any** address can hold a pointer, everything is just bytes. Whether it's interpreted as a number or an address is up to the chosen instruction.
&gt; A lot of beginners, when they first see pointers, immediately say "holy shit I can't do that" My experience was more like, "Well this seems weird but okay, I'll give it a try. What the fuck is a general protection fault?" I was self learning from a textbook, though. I don't know why, but after graduating college, they seemed to make more sense, and I didn't even take any CS classes.
[Confusion and anxiety over pointers](https://en.wikipedia.org/wiki/Use%E2%80%93mention_distinction) goes back a lot further than C, and further than computer science.
**Use‚Äìmention distinction** The use‚Äìmention distinction is a foundational concept of analytic philosophy, according to which it is necessary to make a distinction between using a word (or phrase) and mentioning it, and many philosophical works have been "vitiated by a failure to distinguish use and mention". The distinction is disputed by non-analytic philosophers.The distinction between use and mention can be illustrated for the word cheese: Use: Cheese is derived from milk. Mention: 'Cheese' is derived from the Old English word ƒãƒìse.The first sentence is a statement about the substance called "cheese": it uses the word 'cheese' to refer to that substance. The second is a statement about the word 'cheese' as a signifier: it mentions the word without using it to refer to anything other than itself. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
‚ÄúFor c programming‚Äù? I‚Äôm a part-time hack, but I use three options - any will work: 1) Vi as the editor and command line compilation 2) Xcode (just choose command line app and select C as your language 3) JetBrains IDE ‚ÄúCLion‚Äù
It's pretty easy to do this on any system or OS, but you will need to customize your process for each target's version of exception/interrupt handling. Simply initialize a pointer to 0, and try to read a byte of memory from it. Then try to write a byte to it. Record what happens within your handlers. Increase the value by 0x1000 (for 4k memory page sizes), and repeat. Do this for the entire memory range. Optimizations (skipping much larger memory zones for 64-bit) can be made as well to speed it up, for example increasing the skip amount from 4k to 1m or more when multiple access violations happen consecutively. This is my favourite way to get a memory map since OS's, VM's, and malware can and do lie to you about what memory is in use, available, mapping rights, etc. As long as your process doesn't crash on memory access violations because you use a proper handler to handle those errors, you can brute force a complete memory map pretty quickly.
I recommend VIM as your editor, you might wanna do some configuration beforehand (as line numbering, color, etc). Easy to use and works really well. To compile code, use GCC. It's based on UNIX, very simple, yet very reliable. There are a lot of other stuff that you can use to help your programming, such as GDB, Valgrind and Git, but those are the basic tools that you'll need: VIM and GCC. You can use Homebrew to install them, check it out [https://brew.sh](https://brew.sh)
Apple's own Macintosh Programmer Workshop (MPW)
I‚Äôd say the ref keyword in C# is actually like a pointer to a pointer. Normal reference types are actually pointers. Aliases as I understand it would be different labels for the same object; so if I had object a, and created alias of b; if I assigned (not mutate) to b then a would also change. This doesn‚Äôt happen. As mentioned both C#&amp;Java remove point arithmetic and being able to point at arbitrary points in memory. For better or for worse.
I like Sublime Text
&gt; I am not willing to write an essay here Why are you asking for suggestions, if you're just going to dismiss the most serious of them? Your evidence is **anecdotal**. Why do I need to repeat myself? Here are the words from C standard specification for [`postfix-expression -&gt; identifier`](http://port70.net/~nsz/c/c11/n1570.html#6.5.2.1p1): &gt; One of the expressions shall have type ''pointer to complete object type'', the other expression shall have integer type, and the result has type ''type''. **... and from [Annex J2](http://port70.net/~nsz/c/c11/n1570.html#J.2)**: &gt; The behavior is undefined in the following circumstances: &gt; &gt; 1/ A ''shall'' or ''shall not'' requirement that appears outside of a constraint is violated (clause 4). You asked for advice... so why is it that you're brushing this aside? I suggest you see a psychologist so you can learn to better jump over this hurdle that cognitive dissonance is causing... it makes you look like a *complete ass* when you argue with formal specifications like this.
You know, I was going to cite the standard (as I am known for doing) against this person who is using anecdotal evidence (you), to show you you're arguing with the standard... I got the first citation wrong, now I can't be bothered putting in the effort for you, as you're defeating the point for your own post. **Get over your cognitive dissonance; you're acting delusional**. Kinda like the people I see who insist that a *buffer overflow* needs to cause an exception... or the people who claim that an *uninitialised variable is always zero*... these people defining the undefined behaviour, just as you're doing, are equally delusional. Stop asking for advice if you don't actually want it. [Peace.](https://stackoverflow.com/questions/6793262/why-dereferencing-a-null-pointer-is-undefined-behaviour)
The problem is that when you are entering the data into points 1 and 2, they are pointing to NULL, so you must create some objects to which ptr1 and ptr2 point to, then assign some data to them. &amp;#x200B; void enterPoint(Point1* &amp;ptr1, Point2* &amp;ptr2){ printf("Please enter a first point x and y\n"); ptr1 = new point; scanf("%lf%lf", &amp;ptr1-&gt;x, &amp;ptr1-&gt;y); printf("Please enter a second point x and y\n"); ptr2 = new point; scanf("%lf%lf", &amp;ptr2-&gt;x, &amp;ptr2-&gt;y); }
Well because you are pointing both ptr1 and ptr2 to NULL and then trying to store the user input data in them. You want to (atleast I hope thats the goal) to store the user input points in two structures. The issue is you are creating two (pointers to struct) and pointing them to nothing. You need to allocate a block of memory for both the pointers and store the user input data in them. try initializing the pointers by allocating memory to them. &amp;#x200B; \*ptr1 = malloc( sizeof (struct point) ) &amp;#x200B; and then run the program. It should work.
[Null pointer dereferences in the Linux kernel resulting in complete system compromisation](http://tacxingxing.com/2018/02/22/linuxkernelexploit-null-dereference/)... you think the only possibility is "throwing an exception"? Pffft, C doesn't even support exceptions... what the hell do you _actually_ know?
Ohhh... I see... that makes lots of sense....! Thank you so much for help. I know it could be torture to read beginner's code and fixing it üòÖ Hope to get to the point that I can help someone soon. Thank again!
&gt; Array variables are themselves a pointer to the first element in an array. Even though array variables are implicitly converted to a pointer, arrays are not pointers: - You can't manipulate an array variable but only its members (`int arr[2]; arr++;` is illegal). - `Sizeof` reports different results for arrays and for pointers.
YESSS it works with the input part! I think I'm starting to get my head around a little. Thanks heaps! üòÅ
&gt; When I said no undefined behaviors I meant the case when someone follows the rules... Here-in lies the problem; you're not following the rules, and so it doesn't matter if the downstream programmer follows the rules, because you ruin it for them. &gt; My answer about the inline question was just looking at the performance, no need to lecture me. Uh huh, and my response to your answer is that `inline` does more than you think it does, and you're wrong... The C++ STL doesn't use `inline` for a reason. &gt; I tried many hash functions, this one proved to be the best, if you find a better one I would be glad to see it. Where is your book? &gt; I didn't use files ... What do you call [this](https://gitlab.com/ado0/sgc/blob/master/benchmark/c_src.c#L309)? I would add that there's a null pointer dereference there, too, but I know the response will just be to brush it aside... why are you asking for suggestions, again? &gt; nor strings ... utter delusion... **where's your book?**
Happy to help!! Have fun coding!! :-)
I definitely will üòá
&gt; no need to lecture me. Do not ask for suggestions and then brush aside suggestions like this. You're painting the picture of someone who's hurt by the facts and doesn't want to read any more... if this is the case, you might as well **forget about the book and learn to pick fruit instead**. You do have a book, right? Or are you just guessing and relying upon others (who have read said books and learnt how to produce correct code) to pick you up? Let us be clear on something... there are too many facts in a textbook to cover here. Even if we reduce the scope all of the common pitfalls, the amount of information you need to cover is more akin to **a book** than a subreddit.
edata tells initial, sbrk(0) tells the current end of data area. You probably knew, but maybe worth mentioning.
This is my last reply, since this is getting out of hand. &amp;#x200B; I did take the advice of many people, added custom allocators as far as I thought possible in C, changed the makefile, changed the licence and many little things. `malloc` is the only allocator used here, or a `malloc`\-like function, and I don't want to implement `new` or anything else. I clearly said STL throws exceptions, not C. Where did I not follow the rules ? Someone said I should inline a few functions, where I said that it didn't change anything looking at the performance, that is it, and it did not inline anything without optimization, I have checked it, there are tools. I searched online for the best hash functions and tried many, even the one `std::string` is using, the one I use had the best distribution, at least for all the English words. You should take a better look at the benchmarks, I don't measure the file reading part, it falls off since I measure the wanted task many times and divide the results by the number of measurements, if you iterate through a list a few hundred times, I think reading from a 2 line file would make less then 0.1% of the execution time, you don't need a book to see that, do you ?
To be clear, this persons code *does* invoke undefined behaviour. Every time he uses \`fopen\`, \`malloc\` or \`realloc\` without logic checking the return value, this is a potential for null pointer dereference, and one that's fairly easily triggered by an attacker at that. Kernels have been exploited like this. OP wants to use us as an encyclopedia on a number of topics, and I highly recommend from this point forward we have the strength to say... **where is your book?** Heck, this entire debate could've been avoided if only he read [more from his compilers manual than just `-flto`](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html#index-fsanitize_003dleak)... we should not encourage selective reading and reasoning in this language.
 typedef struct point Point1, Point2; That's ... ticklish. You don't need a separate type for each argument though, just *Point pt1, pt2;* would do.
[removed]
This might be a legitimate point... when his code doesn't invoke undefined behaviour... but for the moment his code does invoke undefined behaviour, so this point doesn't hold any value what-so-ever. When OP says "it doesn't invoke undefined behaviour", NEVER trust them! You should know it's far more difficult to prove that something _doesn't_ invoke UB than it is to prove that it _does_, and _people are blind to these bugs_ as we've seen from the likes of heartbleed... They seem to think there's this behaviour that is expected (e.g. uninitialised variables default to 0 and so people assume that to always be the case, buffer overflows don't cause crashes and so people don't notice them so easily, etc). In this case, OP seems to think a null pointer dereference is required to generate an *exception*... need I say more?
What didn't you like about it? The code presented invokes UB. The qualification turns out to be valid criticism in this case... &gt; If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined. -- [C11/6.5.3.2p4](http://port70.net/~nsz/c/c11/n1570.html#6.5.3.2p4) &gt; The value is that of the named member of the object to which the first expression points, and is an lvalue. This last quote was on the topic of [the `-&gt;` operator](http://port70.net/~nsz/c/c11/n1570.html#6.5.2.3p4). Which object do you suppose the first expression points at when said pointer is a *null* pointer? &gt; If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.
&gt;typedef struct point Point1, Point2; hmmm.. I don't think I understand what you mean. Though I thought I probably don't need to do something like that? haha but I didn't know the other way so I had to just wing it üòÇ
Here-in lies your flaw, pink_echoes (no offence, we all have them). When OP said something along the lines of "it doesn't invoke undefined behaviour" ... *you believed him*. Remember, there are many people out there who don't have a fucking clue about the definition of "undefined behaviour"... but they'll happily pretend that they do, even when there's evidence to the contrary staring at them face-to-face.
man I wanna play robotron you should make. dat
I've never seen that syntax, how would you even declare the function that points to? gcc doesn't like `int **f(void)[10]`: `error: ‚Äòf‚Äô declared as function returning an array` `int *(*f(void))[10]` returns a function pointer? And when would it be useful to have the size determined like that?
simply typedef struct point Point;
No blog spam please.
Consider being less demeaning.
The parentheses are important. You declare the function without `(*f)` in the function pointer syntax. Like this: int *(*f(void))[10] The parentheses are important because of the precedence rules. `()` binds tighter than `[]` binds tighter than `*`. Pointers to arrays are not really necessary. You can just have a pointer to pointer instead, but then, you don't know the size at compile time. Knowing the size can be useful sometimes. For example, lets say I want to take in an array of exactly 10 ints. I can take `int *` as a parameter or `int (*)[10]` which one is better? The latter of course, because the compiler will complain if you pass a pointer to anything other than 10 elements. In the former case, you don't even know if its pointing to an array element. In the latter case, you do.
Do be aware that the `new` keyword is C++ rather than C.
What other restrictions are there?
Note that this just gives you the sections of the program that were loaded. It does not tell you about what other data has been mapped into your address space. Incidentally, that's why I decided not to recommend this option to you.
This does not account for other mappings such as the stack and is generally not a good approach. Some modern UNIX systems do not even have `sbrk` anymore.
Thanks, that really helped!
Also, you're passing `double distance` into `calculateDistance`. You then immediately overwrite `distance` and then return the result. Either don't pass in an argument you do not need or pass in a pointer to a double and then write to it. I would lean towards the former. This issue won't really cause problems per see but it is unnecessary complication and confusion for the next person that reads the code.
Oh, actually, taking another look at your main function the first time you call `calculateDistance` you're not capturing the return value but you are using it for the second call (in `printf`).
what is the problem?
It says "A label can only be part of a statement and a declaration is not a statement."
It says "A label can only be part of a statement and a declaration is not a statement."
Are you sure that type is defined at that point in compilation?
To declare vars in a switch case you need a scope, so just tug a pair of {} in there and you'll be good to go
Do you mean OP0_ARITH_SUB? Yes it is defined to be 0x5 at the top of the file
Oh my god that solved it! Can't thank you enough my dude. Have a silver!
Just get a PDF of K&amp;R 2nd ed then... I'm sure Kernighan won't mind, and Ritchie would have given it to you. It really is an important book to grok. You should run the examples.
Curious case. Do you need those vx and vy a lot in the switch ? You could put them on the top, like switch (...) { uint16_t vx, vy; case ...
I only needed them in that branch, solved by putting the case inside {}
You‚Äôre declaring 2 new variables. Often compilers only allow that at the start of a new brace level. Try moving the declarations to the start of the function.
Thanks. Solved likewise.
Not entirely true, you can simply add a ; after : and then write your code; there is an arcane reason why you cant declare as first sentence. But the scope is much better since otherwise is mixed with other case.
If im not mistaken thats Visual Studio, doesn't it warn you about that ?
This is actually Cypress PSoC Creator. I changed the font to Consolas to make it somewhat more familiar. Doesn't have dark mode though :((
I appreciate the pun
Do not post photographs of code. Always post code as text instead!
pssst, the code ?
Okay my bad, I wasn't aware of that, but I also wanted to emphasize exactly what the error looked like. BTW, can you mark this as solved?
We don't have a way to mark questions as solved. Just leave the post here. But whatever you do, do not delete it!
As others have noted, your pointers need to point to allocated memory. The best way of doing that for your example is not with malloc() though ‚Äî dynamic memory allocation should only be used when necessary. I suggest (after making the fix from /u/oh5nxo) you declare the variables as: Point a, b; And call the functions with: function_name(&amp;a, &amp;b); That is how most C programmers would do it. Some other notes (in order of merit): The isEqual() function should return an int rather than a double, it should lose the third if() statement, and there's no call for &lt;= rather than just &lt;. There is no need for the distance variable, just do "return sqrt((pow((ptr1-&gt;x - ptr2-&gt;x),2)) + (pow((ptr1-&gt;y - ptr2-&gt;y),2)));". Also, if you did need a distance variable in the calculateDistance() function it should be declared in the body of the function, not as an argument. Rather than pow((ptr1-&gt;x - ptr2-&gt;x), 2) I would declare a new variable inside the function, double dx = ptr1-&gt;x - ptr2-&gt;x, and replace pow(dx, 2) with dx*dx. No need to call math library functions when a simple multiplication will do. I don't use typedef on structs, I would instead write "struct point var_name;" for every declaration. The main advantage is that as the program gets longer with more files it's easier for someone new to your code to only have to look up one thing, the struct definition, rather than first having to look up what the typedef is. This is not something every programmer agrees with with though.
Sounds good
Upvoting just because you actually formatted your code. What a breath of fresh air. And now my response: avoid scanf. Use fgets or one of its variants. The API for scanf is unintuitive. I've never really been about to wrap my head around it , which is probably just a result of me getting frustrated with it, giving up and being unwilling to try and understand it as a result üòÖ.
I'd love to use fgets or fscanf, but this is a class exercise and we haven't gotten up to file operations as of yet, so I've got to only use scanf.
Typedef takes a type {int, char, point} and renames it. You don't need to rename your struct for each variable. Typedef isn't the variable declaration. It's just a name definition. So to get two variables of type Point you'd use: Point pnt1, pnt2;
If it's scanf-country, scanf("x y"); while (scanf(...) == 2) { }
when you say \`typedef struct point Point1, Point2;\` what you are saying is "make the type Point1 equivalent to struct point, and make the type Point2 equivalent to struct point" that would be like having type \`int1\` and type \`int2\` ... what you wanna do is write \`typedef struct point Point;\` - or something like that, it doesn't need to be called \`Point\` it could be anything you like: \`point\`, \`Point\`, \`Unicorn\`, \`UnIcOrN\` so now you can use it like this \`Point point1 = { .x = 1.0, .y = 3.3}\` this creates a local struct variable called point1, of type \`Point\` (which is the same as \`struct point\`) which holds a variable x equal to 1.0 and a variable y = 3.0... and obviously you can than create your pointer of the same type \`Point \* point1\` ... (as others have pointed out you need to allocate memory to use it properly in your case)
The reason: The swicth case is one of three kinds of label. Labels need to be succeed by a statement. In C language declarations are not statements. In C, a statement is (C11 standard draft): ¬ß6.8 Statements and blocks statement: labeled-statement compound-statement expression-statement selection-statement iteration-statement jump-statement For the `{}` solution you have a compound statement. For the single `;` you have a expression statement, often called the null statement.
The compiler would have provided an error message, which is text and you could post instead. :) And if you really want a picture, there is this thing called a screenshot.
I wasn't sure if the pun was intended but, still very much appreciated :)
Yes, will do next time for sure. I was so frustrated that I just wanted to post it in the moment :P
Looking at the output and comparing it to /proc/self/maps it seems to do enough to fit the project criteria so I'm going to go with it. Cheers for the advice and comments though much appreciated
You're doing myprogram &lt; file.txt ? The `getchar()` call is going to consume a character from the stream. Test the result of `scanf` instead.
Demeaning? You should look up the definition of that word. I did not demean him. If I had called him an idiot, that would have been demeaning. Pointing out the obvious is not demeaning.
Have we ever suggested using gist from github for this? Seems like a perfect place for them
It is a good place. I usually suggest a ‚Äúpaste service of choice.‚Äù
Cool! But which microcontroller is the sample code on the README.MD meant to be compiled and run on?
The languages described in both editions of K&amp;R work that way. The language processed by clang and gcc with optimizations enabled adds a lot of additional complexity and ambiguity. Given something like: struct FOO {int x,y; float z; } foo; struct BAR {int x,y; double z; } bar; union U { struct FOO f; struct BAR b; } uarr[100]; int get_foo_y(struct FOO *p) { return p-&gt;y; }; void set_bar_y(struct BAR *p) { p-&gt;y ++; }; int test(int i, int j) { if (get_foo_y(&amp;uarr[i].f)) set_bar_y(&amp;uarr[j].b); return get_foo_y(&amp;uarr[i].f); } the language processed by clang and gcc does not allow the array element passed to `get_foo_y` to also be passed to `set_bar_y`, even though nothing in K&amp;R1 nor K&amp;R2 hints at such restrictions.
Should it not be **p\[i\]-&gt;y = 9.0**, since **p** is a pointer?
Yes; I write this sort of code. Clang/LLVM will also work. For a sockets program you'll need at least `-lws2_32`, and you should consider `-static` if only for development.
[Petzold Fifth Edition](http://www.charlespetzold.com/pw5/) is still the most-cited reference on Win32 as far as I know. That edition is from 1998 and I believe is still in print. There's a "Sixth Edition" but it's for C#. Yes, the Win32 API is fairly baroque. Take heart, though: if you're not writing GUI directly, you can write "mostly POSIX" C, with the occasional `#ifdef _WIN32` or substitute macro for the Win32 weirdness. There are a few examples around. Try [this one with MinGW](https://www.transmissionzero.co.uk/computing/win32-apps-with-mingw/), or [this one from Microsoft](https://docs.microsoft.com/en-us/previous-versions//aa383690\(v=vs.85\)).
No, whilst you are correct in saying that p is a pointer, p[I] is not.
Do people use MinGW or MinGW-w64? I tried to download MinGW, which was blocked, and I was told it was "malware". All I can find on that is this: https://www.scmagazine.com/home/security-news/vulnerabilities/bug-in-mingw-w64-windows-app-development-environment-results-in-exploitable-executables
Yes, Windows doesn't have nearly the smooth library support as Linux.
Thanks, my idea is to support many different micro controllers, now I am trying to focus on the atmega328 (e.g. arduino uno) but in the future I would also like to support ESP32/8266 and ARM M0 and more.
One obvious problem in solvemaze() is your while condition. You say while((xpos != xend) &amp;&amp; (ypos != yend)) Your intuition is if the maze is really solved, we need to have xpos == xend &amp;&amp; ypos == yend That is correct. But because of the AND in your while loop, the function will stop once either one of the conditions is satisfied. It needs BOTH to be unsatisfied to continue. So if it finds a spot in the maze where either the y or x position is satisfied, the loop will stop without having found a solution. You need and OR statement here. Good luck from there!
Is the size of your maze array correct? It looks like there are 22 columns (0-21) in the text file and your array is 21 wide (0-20). Are you loading the maze into the array correctly? I'm guessing that "r" and "c" are supposed to be the right and bottom boundaries of the maze, should you be setting a new value for "r" when the maze is selected and having another variable for the row of the top of the maze instead of checking against -1? You might want to copy and paste small chunks of your code to a new file and printing something out to check if each step is being performed the way you expect.
I do have a if(xpos == xend &amp;&amp; ypos ==yend) portion to print the final array once it has been solved. The while loop should be doing the "down, right, left, up, backtracking" move-set while the x-postion and y-postion have not found the ending positions simultaneously. I did try to change to the OR statement but I got the same results. I'm going to try to break the code apart check each step later. Thank you for the input though, it's very appreciated.
Yeahh, I need to account for the row changing for every new array. I'll try to break the code apart and test it in pieces. Thanks for your input.
Good idea. Breaking into smaller pieces that you know are correct is super valuable. Think of the while loop statement you need to determine when the maze is solved as the opposite of the ‚Äúif(xpos == xend &amp;&amp; ypos ==yend)‚Äù you just made. This statement basically says ‚Äúthe maze is solved!‚Äù Your while statement should be ‚Äúwhile(the maze is not solved!)‚Äù, by putting a logical not in front of your statement that the maze is solved. !(xpos == xend &amp;&amp; ypos ==yend) ==&gt; xpos == xend || ypos ==yend This is different than !(xpos == xend &amp;&amp; ypos ==yend) ==&gt; xpos != xend &amp;&amp; ypos != yend Which you‚Äôve used and is incorrect. Logical not flips the and to an or, it doesn‚Äôt flip the equals to not equals.
Also, check out your IF statement logic. I‚Äôm not super clear on what you‚Äôre trying to do from a quick skim but you basically have If(down) { do something } If(right) { do something } If (left) { do something } If(up) { do something } Else { backtracking } You may want to be chaining these together with if, if else, if else, else, etc, because right now the first four ifs will always be checked but the else only depends on the last one. it seems weird the last else logic would only apply if the last if statement fails. Wishing you luck as you break it up!
It might help to draw something out so you can see the ranges of numbers. I pull out my graph paper a lot when I get confused.
Wasn't the typical way to solve a maze a "chalk on your right hand" ? I mean, while you walk, you draw a mark on the right wall, relative your walking direction. You won't enter a place that already has the mark. Might remember it all wrong.
Looks pretty decent from videos I saw on youtube - even has some kind of revision control. I would've been too young to be exposed to old IDEs but I figure that usually they didn't come with a revision control.
I'm missing one thing -- in your example, and in your API, what are the rules for memory management?
Yep! I'd get to that soon. Thank you! Now I'm focusing on c.. I can't wait to learn about C++ though üòÅ
oh... I just need some time to think it through.... I think I got what you mean.. will try to apply that to my code. Thank you so much!
yeah I fixed my code as you said and it worked perfectly. Now I need to understand how üòõ
I see. I didn't know how to use struct properly. Now I know and need to keep practice! Thank you for the explanation!
Did I do it right? üòÖ
Hey, thank you so much for the explanation. This is so helpful! I'll keep them in mind. Thought people would be annoyed by my question and almost deleted this post, but I'm so happy that many of you help with my shitty code üòÇHope one day I'll be able to help someone! Thanks again! :)
Malloc and heap..? üòÇüòÇüòÇ It wasn't intended but I could say it was üòâ
wow I actually understood. I'm so proud of myself. lol
i use **vim** as my text editor and **gcc** as my compiler, whether i'm on a mac, or on linux.
Thanks!
I'm trying to replace my excel spreadsheet of classes of my current plan. Having some code to automatically do it would be awesome!
Clang-CL
Xcode.
Unless you installed gcc with homebrew, you're actually using Clang.
It's possible that is the cause but it's also possible that you got it from a malicious source or that a genuine source was compromised. In general, it's probably not a good idea to download software to your work computer unless you have your IT departments approval.
Thanks! I forgot it is the same as *(p+i)
yeah forgot to say that, homebrew's the first thing i install when i'm on a mac
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define DATA_SIZE 1000 int main() { /* Variable to store user content */ char data[DATA_SIZE]; /* File pointer to hold reference to our file */ FILE * fPtr; /* * Open file in w (write) mode. * "data/file1.txt" is complete path to create file */ fPtr = fopen("database.txt", "a+"); /* fopen() return NULL if last operation was unsuccessful */ if(fPtr == NULL) { /* File not created hence exit */ printf("Unable to create file.\n"); exit(EXIT_FAILURE); } /* Input contents from user to store in file */ printf("Enter contents to store in file : \n"); fgets(data, DATA_SIZE, stdin); /* Write data to file */ fputs(data, fPtr); /* Close file to save file data */ fclose(fPtr); /* Success message */ printf("File created and saved successfully. üôÇ \n"); return 0; }
Where did you download it from?
Is that related to C programming? Some remarks/questions? Do you know all courses, their preconditions and credits? If so, keep them in a structured format (CSV, JSON, whatever there is) such that you can manually change that and have a computer read it as well. If you want to optimize something, then there surely is a criterion (objective function). You may just build an integer linear model with your data and solve it with some free solver.
MinGW-w64 is the better way to go as it has active development. You did not indicate which site you downloaded the package from so it may be as others have mentioned... it was not the original site. MinGW-w64 comes from mingw-w64.org. Also, Msys2 uses MinGW-64 and is a much more updated package than Msys. Whatever site you downloaded from put the URL into Total Virus.
&gt;Do you know all courses, their preconditions and credits? Yup. &gt; You may just build an integer linear model with your data and solve it with some free solver. I have no idea what you mean
There are several points: 1. Why do you need a C program to add trivial data to a text file? One may build that, but I guess a text editor is just as good. 2. What is your actual optimization problem? What are the constraints, what is the objective function?
I‚Äôm just curious if you *have* to do it in C. Other languages are much easier in this regard Also is it possible for you to use a library which helps with CSV files? Or perhaps you can use a database like SQLite? As much as I can see of the program you are getting the input to your database correct? You want to now display a prompt for the user to type in the subject?
OP should start with something like SQLite, and then start thinking about algorithms. This problem is a variation of the knapsack problem, so not doing prior research will probably lead to this program taking longer to create and run, than actually trying it by hand.
I downloaded it from the main site: https://osdn.net/projects/mingw/downloads/68260/mingw-get-setup.exe
Those two links have nothing to do with why it would be blocked as malware. Either you got it from a bad source, or it's simply a false positive. The first link is about Mingw-w64 not supporting ASLR, which is, disappointingly, still not yet supported by that toolchain. It's lacking an number of such hardening features. This doesn't make your applications automatically vulnerable. It just means that the vulnerabilities they already have are easier to exploit. Since [Window's implementation of ASLR is significantly less effective](https://devblogs.microsoft.com/oldnewthing/?p=93301) than other operating systems, it's not as important as it might otherwise be. The second is about an vulnerability in Mingw-w64 that came about to due nonstandard behavior in Microsoft's own `msvcrt.dll`. Under certain circumstances it *may* introduce a vulnerability to applications compiled with Mingw-w64, but this doesn't make it malware.
https://osdn.net/projects/mingw/downloads/68260/mingw-get-setup.exe
Seems like a false positive: https://www.virustotal.com/#/url/bfcd8e79866fffb2ead590e6f3d03233993770a7734c344a2e34752f93e7b7ea/detection Better to get it from the official source anyway.
I think I remember Clang from my FreeBSD days. Can it make Windows services?
I thought that was the official site, the wikipage links to it. Or do you mean compile it from the source code? (with what?)
That is what I suspected, but the Software Police had already declared it a mortal threat, and me with it.
That virustotal website looks awesome, I will use that in the future, thanks!
Ah, I see now that's the official download site for MinGW. Don't bother with MinGW, though. You're much better of with the confusingly-named fork, Mingw-w64, which has mostly supplanted MinGW these days. Looks like there are several options on the wiki: https://mingw-w64.org/doku.php/download (I mostly use it as a cross-compiler, and even when I use it as a native compiler I build it myself. So I'm not sure which is the best way to get Windows binaries for Mingw-w64 these days.)
Not really. You need to do one or the other. Either pass a pointer to a double or return a double. Doing both is wasteful and annoying to use. I'd recommend just returning the double so you do t have to deal with passing in pointers. If you change the signature to return the double you'll need to change the first call to capture the return value. `double d = calculateDistance(...);`
Where is the code?
asking for help is very important too
C++ is not C.
MinGW always gets flagged for me.
Bro, indent your code with 4 spaces for it to show up as a block. like this ------------ #include&lt;stdio.h&gt; /* Swaps strings by swapping pointers */ void swap1(char **str1_ptr, char **str2_ptr) { char *temp = *str1_ptr; *str1_ptr = *str2_ptr; *str2_ptr = temp; } int main() { char *str1 = "abcd"; char *str2 = "efgh"; swap1(str1, str2); printf("str1 is %s, str2 is %s", str1, str2); getchar(); return 0; }
Your function is taking a double pointer which is a pointer to pointers, you can think of it as an array of strings. Just change the input to just char* and change temp to just char
That won't work. This will: swap1(&amp;str1, &amp;str2);
This won't work for two reasons: 1) Most likely when you write `char *str1 = "abcd";` the bytes for the actual string are in read only memory. So in your swap routine, you're going to try to write into read only memory and your OS will most likely terminate your program (I say most likely because it depends on hardware and OS). That said, if you wrote `char str1[] = "abcd";` the bytes for the actual string will be writable and this may seem to work; which brings us to point 2. 2) Even if you're on hardware/OS where read only memory works, this would only swap the first `sizeof(char *)` bytes. If you're compiling for 32 bit hardware this may just swap the correct bytes around. But try swapping bigger strings: char str1[] = "abcdefghijklm"; char str2[] = "opqrstuvwyz"; and you'll only swap the beginning of the string.
&gt; To answer your question, the problem is that the parameters are expecting an array of arrays (an array containing multiple strings) and you're assigning a single string to that. No. The swap1 function wants the address of a pointer to a character array.
ok i understand &gt;parameters are expecting an array of arrays but i cant understand what is actually happening with the memory. Is this what is happening? variable memory value|memory address \*str1 ---------------&gt; \[abcd\]|234 \*str2 ----------------&gt; \[efgh\]|235 if, \[0824\]|abcd \*\*str1\_ptr----------------&gt; \[0824\] then \*str1\_ptr---------------------&gt;\[abcd\]
This code might make it more clear #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;inttypes.h&gt; void print_dereference(char **ptr) { printf("Dereference of %p = %" PRIuPTR "\n", ptr, (uintptr_t)*ptr); } int main(void) { char *str1 = "abcd"; char str2[64]; memset(str2, 0, sizeof(str2)); char str3[64]; memset(str3, 0, sizeof(str2)); str3[0] = 42; print_dereference((char**)str1); print_dereference((char**)str2); print_dereference((char**)str3); } Types are lost at runtime, so if you try to dereference a `char*` as if it's a `char**` then it's going to attempt to read whatever bytes are there as an address. This likely segfaults with some random string like `"abcde"` and then whatever happens to come after that in memory.
\*str1\_ptr is 0x64636261 (assuming how dad's i386 lays out "abcd"). \*\*str1\_ptr is illegal, you cannot use \* on 0x64636261. str1\_ptr is the same as str1, what ever it happens to be (even 234).
Yes, ignoring all the other answers, this seems like the problem. Although I'm curious why the compiler didn't complain about passing the char* when the parameter is defined as a char **.
gcc does.
Not following that, really. str1 is the address of string "abcd" == a1. str2 is the address of string "efgh" == a2. The function "swap1" wants you to give it the addresses of two *addresses* to swap. aa1 == &amp;a1, and aa2 == a2; Now "swap1" will replace the contents of a1 (which is an address) with the contents of a2, and put the old contents of a1 into a2. It's swapping two pointers. It's no different than swapping two integers.
So does Visual Studio. Actually it also complains about the char *str1 = "abcd"; assignment, so I changed it to be char str1[], but then it won't let me pass the &amp; of that directly to swap1(), had to create a second variable. But then it does work as expected when you change it to pass the &amp; of the char * to swap1().
str1 == 0x10000000 str2 == 0x20000000 Memory starting at 0x10000000: abcd... Memory starting at 0x20000000: efgh... All "swap1" is doing is asking you to give is the addresses of the values at str1 and str2, so that when you leave that function: str1 = 0x20000000 str2 = 0x10000000
Yes, it is. It offers nothing you can't do otherwise, the only benefit is in making badly organized code. C isn't a batch script, you don't need to use it, and frankly you shouldn't.
Not sure what you're seeing. If a create a simple "test.c" and compile it with "cl" from the "Developer Command Prompt" it works fine.
If this does not help, please ask follow-ups. First, remember that all parameters in C are passed by value. If you had a function void swap_no_effect(char *s, char *d) { char *t = s; s = d; d = t; } and called it like char *a = "abcd"; char *b = "efgh"; swap_no_effect(a, b); the changes to the pointer values made in `swap_no_effect` would not be visible upon return from the function. Second, what you are passing to \`swap1\` in your case are pointers to pointers. So, str1\_ptr -&gt; str1 -&gt; "abcd". Couple that with the first point, and it becomes possible to subvert the copy-by-value semantics by passing a pointer to what you want to change. So, in the function swap1, you *can* change the values of what the pointers target *and* see the results after the function returns. Dereferencing str1\_ptr yields str1. Inside str1 is the address of "abcd" in memory. By changing the contents of the address stored in str1 (again through dereferencing/assigning str1\_ptr) you can get it to point somewhere else without running afoul of the copy-by-value semantics. After `*str1_ptr = *str2_ptr;`, we have str1 effectively pointing to the address of the string "efgh" in memory. The use of the temporary is required for obvious reasons when doing a swap like this. Does that help? I tried to make the following diagram to help as well: [Diagram](https://i.imgur.com/EGy0SAu.png)
You're right, I get the same thing doing it that way. I created a C++ console application and pasted it in; so if course that means it is going to treat it as C++, but interestingly when I compile with /Tp, which is supposed to treat it as C, that gives a *different* error about swap1() parameters...then I tried from the dev command prompt copying all of the options that Visual Studio claims it is passing to cl, but then it starts failing randomly on precompiled headers so I gave up.
Hah. Well, this is why I avoid Visual Studio, unless someone has already given me a working Project/Solution. :)
Ok thank you!
True but C++ works with C as a subset and incorporated the definition as part of the C++ language and last of all C is the foundation of C++.
Oh, yes, seeing `memset()` when an initualizer would have worked just fine is one of my pet peeves.
&gt; `&amp;(int) {1}` cool, didn't know about that syntax.
Do you have a problem with C++?
Pfff. Millennials. /s
It's called [compound literal](http://www.drdobbs.com/the-new-c-compound-literals/184401404), another C99 feature.
Nor did I. I'm gonna take a stab at what I think it is doing, but if I'm wrong someone please correct me: Declare an inline struct, cast to an int and retrieve a pointer to it. Am I correct?
Yeah, I was gonna say. I've just started learning arrays, and if you make a pointer to the first element, then +1, it goes to the next element. I was also confused when I added 1 to a pointer, that it didn't increment the address by 1, but I suppose by the size of whatever the type of pointer it was.
 struct addrinfo hints = { .ai_family = AF_UNSPEC, .ai_socktype = SOCK_STREAM, .ai_flags = AI_PASSIVE, // use my IP }; The comma after AI_PASSIVE seems out of place. It won't throw any warnings or errors, but it's not necessary.
&gt; Where do people learn about stuff like this, just by reading the standard? I think I mostly learnt by reading code written by people smarter than me. I only read relevant sections of the standard when the static analyzer complains about some werid edge case.
That's true. I'll fix it when I get back to my computer.
Some style guides recommend not initializing variables in the declaration, because it can lead to harder to read code. Those style guides will also usually recommend only declaring variables at the beginning of the function - and having a struct initialized in the variable declaration block seems cluttered to me.
This is actually slightly dangerous. The difference between memset and assigning zero is that the standard doesn't specify whether there will be any non-zero bytes in the struct (the padding could still be garbage values).
Just in the past half decade compound literals work everywhere. Microsoft resisted for a long time. Using them feels very slick. They can also be used as static initializers, which is really nice.
There's two additional benefits. * If the structure you're memsetting contains a pointer, setting all its bits to 0 isn't technically a NULL even if it happens to work on pretty much all platforms out there. A system could (in theory) have 0x0 be a totally valid memory address and NULL represented by some specific trap bit pattern. A designated initializer will create proper NULLs no matter what they look like. * If the struct contains padding, the designated initializer won't necessarily set it to zero. This is presumably a little faster, as well as desirable when you're running the program in valgrind ‚Äì it will then alert you if you're accessing the padding anywhere by mistake.
It helps prevent an annoying compilation error later when you add a field and forget to add the comma. This actually matters when you have long build times! (24 hour builds are not uncommon even in the C world)
Because OP either turned compiler warnings off or ignored them.
C is not a subset of C++.
I'm finally *mostly* on board with C99. The embedded systems world moves slowly.
&gt; Those style guides will also usually recommend only declaring variables at the beginning of the function I have seen a few guides recommend this but never read a good justification. I think it's mostly a holdover from older versions of C which forced you to declare all your variables at the beginning of the function.
Hi ZoDalek, &amp;#x200B; I have some suggestions for your program. It would definitely be a good idea to add a man-like page in your GitHub README page to make it easier for us to use your program. &amp;#x200B; I also highly recommend you post a .gif or photo demonstrating your program at the very TOP of your README. This will instantly give people a good impression of the main advantage of your program: that it is faster than hexyl and does not require us to install the Rust and cargo packages. &amp;#x200B; I think you should also take the liberty to include a LICENSE an Copyright information at the very bottom of your program. You have far more people starring your program than even my own. I bet some of those people are concerned about the ethics in using your program. &amp;#x200B; If you would like an example of the kind of README page I am talking about, feel free to see my own !\[hexdump project\]([https://github.com/tanveerasalim/TSCD](https://github.com/tanveerasalim/TSCD))
C is the language I'm most comfortable with and hopefully I can learn more due to the fact that it's major part of my future studies. I've got the database to write to the txt file, just need to figure out how to give them weight by credit s and read the prerequisites and cross check them with a previous txt file.
First point because there are two txt files that get cross checked with each other. My actual optimization problem I guess is making the most efficient schedule given already done classes and future classes limited to 15 credits per semester and adding summer classes
It's called a right-foot traversal. It only works if there is a continuous wall between the starting point and the exit, and will not always give the shortest path. The general solution is to convert the maze to a graph and use a standard graph traversal algorithm such as Dijkstra or A\*. To create the minimal graph for any given maze, start by making a vertex for each bend, intersection, and dead end, and an edge for each corridor section. Next, remove every vertex of degree 1 and its associated edge. Finally, remove every vertex of degree 2 and merge its associated edges into one.
I would recommend not using typedef at all until you fully understand the type system.
I wish the checking pointer before free was true for everything. Very annoying using custom embedded allocation libraries that are inconsistent.
Are you sure about that?
I said something about posting this once every six months, not once every month. I have removed this post as it does not contain anything new over [the previous post](https://www.reddit.com/r/C_Programming/comments/b5budt/meson_build_system_project_templates/).
Yeah, maybe it's for portability to older standards. I tend to use both of those conventions, just because they improve my readability and understanding of my own code. If a variable is used in multiple places in a function, I know I can look at the top of the function for the declaration instead of hunting around for where it was declared.
&gt; TL;DR: Use C99‚Äôs designated initializers instead. Because it‚Äôs 2019! And foresake ANSI C compatibility for no reason at all? Not a good idea.
Good point. I noticed it because I use R a lot, and when you add extra commas, you get an error. &gt; data.frame(T1 = rnorm(n = 100, mean = 0, sd = 0.5), + T2 = rnorm(n = 100, mean = 0, sd = 0.5), + T3 = rnorm(n = 100, mean = 0, sd = 0.5), + E1 = rnorm(n = 100, mean = 0.25, sd = 0.5), + E2 = rnorm(n = 100, mean = 0.25, sd = 0.5), + E3 = rnorm(n = 100, mean = 0.25, sd = 0.5), + ) Error in data.frame(T1 = rnorm(n = 100, mean = 0, sd = 0.5), T2 = rnorm(n = 100, : argument is missing, with no default
Will good to see you again and no this is not a copy of a post, just my release after my hard work of testing the prototypes and getting feedback from a live audiences from meltable subreddit's.
I do understand that and I appreciate your hard work. However, this subreddit is not the appropriate place to post every single release of your project.
Sure thing because I'm done with sending release note for live prototypes for both C and C++ subreddit's anyway. Next target Rust.
yes, most C features are supported by C++ but there are some incompatibilities.
That is very silly.
In addition, not clearing the padding can be a security bug (information leakage). For any struct that will be sent over a network or security boundary (i.e. between user/kernel), this article is actively bad advice.
I know about the incompatibilities with some C fetchers but other then that C can be used with C++. I am not saying C++ can work with C or some other crazy thing.
Could you put this post back I am cleaning out all of the old prototyping post at this moment. Thanks.
I don't see why not, and it's ABI compatible with MSVC. BTW, Clang-CL isn't just regular Clang, it's Clang with a MSVC compatible "driver" (aka CLI) so that it's a dropin replacement for Microsoft's CL compiler.
Nope.
Used to work on a system that would hard freeze on a double-free or free of a nullptr. Not all systems pay close attention to the standard, especially older/embedded compilers.
That's disgusting do people unironically do this?
Lol I remember when I used to code like that
It's not useful to anybody to be concerned about imaginary implementations where NULL is not zero :P
No they won't. Uninitialized fields are set to 0.
How often do you use an ANSI C compiler..?
Well, virtually everything sent over networks is serialized these days. IDK, if I were to go and check right now what clang and gcc actually do with this behavior and verify that the padding on those implementations will always be zeroed, then I'd say to hell with it, nobody uses any other compiler anyways.
 return(!!cond);
Quite frequently. For example, just a month ago [I was porting Nethack to Ultrix 4.4](https://www.reddit.com/r/nethack/comments/b8ik3m/a_little_patch_to_compile_nethack_361_on_ultrix_44/).
I'd probably just write a wrapper that checks for NULL and override with a #define for that system only. Anything wrong with that?
Hmm yeah.. I can‚Äôt wait to understand things better!! üò£
I remember writing a switch that checked every case individually and did nothing with them, then the default was an error.
Good by.
I didn't even know this worked tbh.
Atom + clang
See you!
Your second point is factually wrong: "If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration." 6.7.9:21 and then 6.7.9:10 "If an object that has static or thread storage duration is not initialized explicitly, then: * if it has pointer type, it is initialized to a null pointer; * if it has arithmetic type, it is initialized to (positive or unsigned) zero; * if it is an aggregate, every member is initialized (recursively) according to these rules, and any padding is initialized to zero bits; * if it is a union, the first named member is initialized (recursively) according to these * rules, and any padding is initialized to zero bits; " in n1548. I also disagree with your first point. I want all of the elements of a list to be the same, syntactically. This means I don't have to perform more than one operation to add or remove an item. I don't want special case syntax. It has the side benefit that adding a new item only shows up as one change in line-based diffs.
Aaand why not just use a more up to date compiler?
Typically, you'd go with the first approach. If the database gets too large, you should consider using a different file format.
Because the person who wants to use my application might not have a modern compiler for his system.
Why does he need to compile it?
Good software is distributed as source code such that it can be compiled on any platform, even those the author didn't foresee when programming it. Binaries are useless if someone wants to use my software on an unusual system I didn't make a binary for. And given that creating portable binaries is annoying on many systems, I'd rather avoid this.
&gt; nobody uses any other compiler anyways That's an interesting statement. I very much use MSVC in my day to day professional life, my company uses it as our only compiler on Windows platforms. I'm curious if we're in a tiny minority here, as it seems like native Windows compiling is still a very large use case?
Every embedded system I've worked with is either restricted to some customised ancient version of GCC or is their own compiler implementation. They most definitely don't support C99 stuff. MSVC barely does.
 grep -v '^3' oldfile &gt; newfile mv newfile oldfile That'll be faster than reinventing a subset of grep. I'd strongly suggest you use CSV (comma-separated value) format to allow for spaces in the name, and to make it easy to import your file into a spreadsheet to work with.
Most people already use `for (int i = ...)` or compound literals or initializers or intermingled declarations and code or single-line comments anyways. I feel like you need a really good reason these days to choose to not use the two decades old standard.
MSVC has complete C99 support as of a few years back.
Yeah you can check MSVC too. But it's primarily a C++ compiler.
I don't use any of these features normally. My reason is portability. I believe this is a very good reason.
I mean, if there's any reason to suspect that anyone will want to use your code on systems for which there are no compilers made in this millennium, then that's a good reason, but come on, C99 is _a lot_ nicer to write than C89. If there's no realistic reason to expect that your code will run on systems for which you can't compile C99, is it really worth sacrificing comfort and ergonomics just for some purely theoretical portability benefit? Maybe the answer is a "yes" on your part, and I certainly won't try to convince you that you personally should switch to C99, but you must at least see why most C programmers probably want to write C99.
In my opinion, there are very few syntactical changes in C99 that make programming any easier. Programmin in ANSI C is not that much of a difference to programming in C99 and if you get a vast amount of extra portability as a bonus, the choice is often not hard to make. Of course there are many situations where I program in C99 or even C11. For example, when I write programs that inherently need to make use of some of the new facilities. Or when I write programs that cannot be portable for some other reason.
I'm actually not 100% sure what's going on there with r and q; I'm tempted to post a new thread about it. But... I'd never write code like that on purpose, and I've never read any code written that way on purpose, so I'm not too worried about it. :p
I see this all the time - some standard was violated or some other agreed upon interface was not implemented to spec, so the code monkey at the time came up with what they thought was a witty workaround. This of course was not an isolated event, but a pattern of failure. Now, 40+ years later, I stand alone before a house of cards on the precipice of utter ruin, tasked with making a change. Fix the system, even if that means replacing it.
What did I forget this time!
Yeah, but even if you `memset` the structure, there's no guarantee that the compiler won't store information back into the padding bits later. That may not be "as bad," but there's still a possibility for leaking some information.
Really? It supports `_Complex` now?
It worked! I'm still not getting the right results because it's now going through walls....but it performed all the way until the end! That's still a huge step out of my rut. I changed all of my conditions (about six total, including the conditions that satisfy what cell you can travel on) from (xpos != xend &amp;&amp; ypos !=yend) to !(xpos == xend &amp;&amp; ypos ==yend) &amp;#x200B; sorry for my errors formatting code.
Looks like support for `_Complex` is a [complicated subject](https://docs.microsoft.com/en-us/cpp/c-runtime-library/complex-math-support?view=vs-2019), and VLA support is nonexistent. Good point. However, C11 made both of those features optional, and for pretty good reasons.
Tldr I want to make things harder for my self because reasons
POSIX dictates that all-zeroes is a representation for `NULL`, fortunately for all the socket-based programs out there.
The trailing comma cleans up diffs/logs in your version control system. If you later revise the code to add in another field, only the new line shows up in the diff.
MISRA!
I don't know if you posted in the wrong sub or if you're specifically looking for stuff in C. I went through this playlist of videos on programming a sidescroller game in C using SDL last summer and it taught me a lot about using C and basic game mechanics. [https://www.youtube.com/playlist?list=PLT6WFYYZE6uLMcPGS3qfpYm7T\_gViYMMt](https://www.youtube.com/playlist?list=PLT6WFYYZE6uLMcPGS3qfpYm7T_gViYMMt) &amp;#x200B; If you're looking for more general gamedev advice take a look at [https://www.reddit.com/r/gamedev/](https://www.reddit.com/r/gamedev/) &amp;#x200B; I'm currently during some courses in Unreal but that's C++ based. Unity(which is C#) and Unreal seem to be the most popular game engines to learn these days.
Yeah that's what i was searching for, thanks! üòÅ
Where is your `string` buffer and `key` declared?
Not always an option. Microsoft broke bliddy C compatibility decades ago and is now stuck at partial C89 support.
&gt; `return (cond);` Why the parentheses?
Yeah, http://c-faq.com/null/machnon0.html "setting all its bits to 0 isn't technically a NULL" is not correct. It's the compiler's job to convert your all zeroes to whatever internal representation is for a null pointer.
http://c-faq.com/bool/bool2.html explains why we don't compare pretty much anything to TRUE in C. Also return is not a function so it's usually a bit better to write: return cond; (though I make an exception for sizeof... I don't even know why. Maybe K&amp;R?)
So when new fields get added unknown to you, strange and interesting things happen.
Binary dists are the worst. Go and find that source 20 years later.
Without trying the code, I think that the first loop with the fgetc call has the effect of traversing line n while the loop with fgets stores line n + 1. Then the cycle repeats. You could just use the fgets call, keeping in mind that fgets also stores the newline character. I think my approach would be to store each line in a list node, rather than an array element. That way removing any particular line is simply a matter of unlinking the node from the list. This would let you optimize for files of any size, but of course YMMV.
I think the compiler‚Äôs job is only to convert an integer-constant-expression 0 to `NULL`, so that static casts like `(void *)0` work. Anything in a struct field would fall outside that; if the ABI happens to treat all-zeroes as `NULL`, then that‚Äôs what happens. If all-zeroes isn‚Äôt `NULL` per ABI, then in-field all-zeroes wouldn‚Äôt be `NULL`, even there were an explicit cast from (all-zeroes) `int` to `void *`. So OP is right in that regard, and it‚Äôs why POSIX has to specify explicitly that all-zeroes in memory is a valid representation of `NULL`. An all-zeroes initializer would be fine regardless, because that would include an i.c.e. 0.
Looks like you rewrite 1,2 with 3,4. But still without actual code hard to say. Try new variable for 3,4
It's hard to know what's wrong since you didn't provide any of the relevant code or structure definitions, but I'm going to guess your bug somehow happens because you didn't malloc a new student for the second insert. You just overwrite the data for the first one.
Yeah it all happens in a loop.
Not clear. If you want help provide the code
It looks like you have two entries in the linked list, but both are pointing to the same structure since you did not create a new one.
Third option could be to update the deleted line with something that does not change it's size. Like a # to turn it to a comment.
sizeof (type) needs that ().
&gt; malloc is the only allocator used here, ... I hate to repeat myself. My original problem was with your use of `realloc`, and you appear to have misread that as `malloc` somehow... if you're here for suggestions, perhaps you need some glasses? Furthermore, the way you suggest utilising `malloc` later on is blatantly wrong; `malloc` only has one argument. This leads me to believe you don't know C too well. Remember, you're here asking for suggestions, don't go brushing this one aside... _where is your book?_ &gt; Where did I not follow the rules ? Again, I hate to repeat myself... I feel like this is a running theme. You know, you can claim there is no UB over and over, but being blind of the reality will not help you here. You need to check the return value of `realloc`, before you overwrite your original pointer. Otherwise you get a memory leak when `realloc` fails, and that's the least of your problems because then you will *hope* to get an *exception* which isn't required... &gt; it didn't change anything looking at the performance Perhaps if you put your focus solely in performance, you'll miss the functional differences of `inline`... the features that *don't* impact performance, but *do* restrict how your code may be utilised... what you need to do is *stop with the selective focus*. In your case, it's invalid to use `inline` because the C++ STL doesn't use `inline`. Performance has bugger all to do with it; **there are things you can do with the C++ STL that you won't be able to do if you use `inline`**... do you understand, yet? If not, I would suggest that your *book* should tell you something about `inline`. &gt; You should take a better look at the benchmarks On which OS? With which CPU? ... and which process/thread scheduling algorithms? Using which compiler version? Can I use `-O3`? Can I use `-fsanitize=undefined`? Why would you read into the benchmarks of something so heavily flawed? As I said earlier (notice the running theme), you could remove the safety checks from the logic within C++ STL, and the C++ STL will be (broken in the same ways that your code is broken, but...) faster... then maybe you have a fair comparison.
declarations were all before the loops. Regards to the i index in two places i took out the condition `string[i] != '\0'.` I messed around with the braces for the loops as well and its now printing texts with 1, 2, 3 shifts etc but the ASCII doesn't wrap. Heres the console output. `Enter encrypted text:` `TESTING` `Decrypted text: UFTUJOH` `Decrypted text: WHVWLQJ` `Decrypted text: ZKYZOTM` `Decrypted text: ^O]^SXQ` `Decrypted text: ^T]^X]V` `Decrypted text: ^Z]^^]\` &lt;-- Then this line continuously repeats .
Isn't that overly complicated? for key for i if Z, = A else if A..Y, ++ print key, string
&gt; Does c++ get more interesting? Not so much on this subreddit, as this sub is for C, not C++. Questions about C++ are better asked in /r/cpp_questions. That said, *why* do you want to get interested in coding? Are you trying to write a program to complete a particular task? Are you wanting to learn it to become a software engineer? Or are you just interested in learning it for learning's sake?
Ah thanks for that I will post a thread there. And I have some ideas for programs that I would like to write. I also would like to learn programming just for the sake of learning.
Python might work for your. It's an absolutely beautiful programming language and it's very easy to write. It also has many libraries that will allow you to develop anything very quickly.
That sounds very intriguing. I will look up some online courses!
Okay, well, working on some programs that directly benefit you - that solve a particular problem you're having, for example - can be a way to make coding more interesting, as it can give you 'puzzles' to solve along the way: "How do I get my program to do X? Why isn't my code doing what I expected it to do? How can I make my code easier to understand and extend?" /u/BearedWax's suggestion to try Python is, i think, a good one, as it's relatively easy to get started with, and has a large ecosystem of software to help you along. Good luck!
Thank you so much for the suggestions :)
Shouldn't any struct that is sent like that have `__attribute__((packed))` anyway, avoiding that issue entirely?
It's an older coding style that has stuck around in some places for some reason... I have to use it at work
&gt; declarations were all before the loops. I don't think you understand me. Obviously the declarations were all before the loops -- otherwise your program wouldn't compile... Show us the declarations, so we can *rule out* that you messed something up in the declaration. By omitting code, you're leaving things for us to guess. Don't do that. Don't make people guess when they're trying to help you. &gt; I messed around with the braces for the loops as well and its now printing texts with 1, 2, 3 shifts etc but the ASCII doesn't wrap. Don't leave anything for us to guess about. If you've updated the code since initially posting, provide updated code, so we're not debugging old code. &gt; Heres the console output. Without the full code, the output is meaningless to anyone trying to figure out the problem. &gt; Also i think i should re-initialise the string after each loop because it applies the shift to the previously shifted string. If your intention is "do X thing to a string Y times", then your best bet is to use two buffers. The first buffer holds the string that you read from input. The second buffer is the `decrypted` string. Here's an example (I haven't tested/compiled this, but it's enough to get the gyst of it): /* * decrypt_char() implementation omitted. * Function converts c using key unless `c` is '\0' * Otherwise returns 0 */ char decrypt_char(char c, char k) // I'm assuming that key is an char? { char x; if (c) { // handle the single character decryption logic. return x; } else { return 0; } } void decrypt_string(char *e, char *d, char k) { while ((*d++ = decrypt_char(*e++))); } int main(int argc, char **argv) { int bufsize = 100; // The two buffers declared here char encrypted[bufsize], decrypted[bufsize], key; fgets(encrypted, bufsize, stdin); // I really hate starting loops at 1... but this is just to keep as much // of your logic/code as possible. for (key = 1; key &lt;= 26; key++) { // this line doesn't modify `encrypted`, so you can re-use it each iteration. decrypt_string(encrypted, decrypted, key); printf("Decrypted text: %s\n", decrypted); } return 0; }
The statement was a universal statement of "if you have issues with -O3 your code invokes undefined behavior" which is not true, there are legitimate compiler bugs that only appear in -O3. This discussion was totally independent of the correctness of the code. Of course if you have UB, we don't need to discuss further.
Gcd reccurent formula int gcd(int a, int b) { return a % b == 0? b : gcd (b, a % b);} Cause in your case you evaluate all possible gcd of every pair it makes sence to reuse previous computations int memo[n][m] = {-1}; int gcd(int a, int b) { if(memo[a] [b]! = - 1) return memo[a] [b]; return memo[a] [b] = (a % b == 0? b : gcd (b, a % b)) ;}
Thank you, that is a better solution.
If I wanted C++ I would be using C++
No, initialized registers are 0xdeadbeef
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit.
Please show your full code.
Only if type is more than one token long.
https://michaelroeleveld.nl/src/downloads/primes.c Here is a program that calculates primes blazingly fast. Maybe you can tie isPrime() into your code while looping through the array?
Yes. It is trivial to write a C program that won't compile as C++: int main(void) { int class; } There are plenty of less trivial differences as well, especially when it comes to pointers. Prior to C99, you could easily write a C program that was also valid C++ but behaved differently.
return(condn't);
Hmm? Had to check, and I cannot make clang or gcc accept int i = sizeof int; error: expected parentheses around type name in sizeof expression.
Hm. You are correct. Curiously, though, this works: int i = sizeof 0;
cppreference.com tells that it's sizeof (type) or sizeof expression. Another historical accident, maybe.
What about this? On a 32 bit system struct Cube { char volume:7; char weight:8; char color:6; char lenght:5; char unusedPadding:6; //padding to reach 32 bits } struct Cube testCube = {0}; //assign everything to zero in declaration. Including padded bits. testCube.volume = 3; etc.
Half the fun right there
Same here. It‚Äôs the preferred style at the company I work for. But for personal projects I omit them.
Next time, please do not delete your post after receiving an answer. That's just bad style. How are future people with the same question going to make use of the answers presented here if you deleted your post? By deleting your post, you not only denied them this resource, you also erased the effort of all the people who helped you. That's kind of a shit move to do.
This is good advice I try to give to classmates. Another one I try to point out: if (cond == TRUE) should just be if (cond)
I was having trouble figuring out what was going on until I enabled optimization. Check this out: $ b CC=gcc CFLAGS=-O0 $ ./weaksym Ahoj! $ b CC=gcc CFLAGS=-O3 $ ./weaksym Hello! Behavior from GCC changes depending on optimization. When `-O3` is enabled, `greeting` is inlined into `main` and the decision is taken away from the linker. This is what always happens with Clang: $ b CC=clang CC=-Os $ objdump -d -Mintel weaksym.o 000000000000000a &lt;main&gt;: a: 50 push rax b: bf 00 00 00 00 mov edi,0x0 10: e8 00 00 00 00 call 15 &lt;main+0xb&gt; 15: 31 c0 xor eax,eax 17: 59 pop rcx 18: c3 ret Notice it's clearing `edi` with zero before the call? That's a very inefficient instruction for clearing `edi`, since it should be using `xor edi, edi`. That's actually a relocation, to be patched in with the string address, since it's a call to `printf` not `greeting`, which takes no arguments. We can verify this with `readelf -r`: $ readelf -r weaksym.o Relocation section '.rela.text' at offset 0x200 contains 4 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000000001 00030000000a R_X86_64_32 0000000000000000 .rodata.str1.1 + 0 000000000006 000a00000004 R_X86_64_PLT32 0000000000000000 puts - 4 00000000000c 00030000000a R_X86_64_32 0000000000000000 .rodata.str1.1 + 0 000000000011 000a00000004 R_X86_64_PLT32 0000000000000000 puts - 4 Relocation section '.rela.eh_frame' at offset 0x260 contains 2 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 000000000034 000200000002 R_X86_64_PC32 0000000000000000 .text + a The `mov edi, 0` instruction starts at offset `b`. That puts the relocation at `c` (just after the opcode). Note the relocation offset at `c` for `.rodata.str1.1` (e.g. a string). So your problem is that the weak symbol you're trying to replace is in the same translation unit as the caller. The linker isn't necessarily involved in this call, so you can't reliably override it. Move it out to another translation unit.
clang **-no-integrated-as** does something differently, instead of 2b: e8 d0 ff ff ff call 0 &lt;greeting&gt; it turns to 2b: e8 fc ff ff ff call 2c &lt;main+0xc&gt; 2c: R_386_PC32 greeting
Only if the compiler is set to ANSI Non-Vegan mode using the "--cruelty" flags.
Pretty sure xlc has no such flags
Wow! Thank you very much for detailed explanation! Now I understand what was happening. When I put the weak symbol into dedicated object, it works fine. Also, using the `no-integrated-as` (as hinted by /u/oh5nxo) works as well. I guess I need to play with `readelf` and `objdump` to be able to deduce these things on my own next time.
Thanks for pointing that out! It actually works with this!
You have to use the --sarcasm flag to enable it.
If a thread is detached, it does not need to join back into its parent to release its resources (and neither can you join it). This is useful when you want to have a thread that just does its thing without joining back with its creator.
You're supposed to eventually join with every thread you create. Until the join, the thread's resources are not reclaimed. The exception is detached threads which automatically free their resources when they return.
Knowing IBM it's another FRU &amp; part number to order such a great feature set.
I think I messed up in my question formation. My exact question is what is the difference between explicitly calling pthread_detach() and not calling pthread_detach(). In my example code, if I were to comment out my function call to pthread_detach(), what does it imply
That implies that your thread, once terminated, wants to be joined into some other thread. I.e., some other thread can call `pthread_join` on it later on to get its exit status and to know that it terminated. Until this happens, the thread still consumes resources. If you detach your thread, the thread cannot be joined and all its resources are immediately released once it terminates. If you don't join a thread that has not been detached, you leak its memory. If you try to join a thread that has been detached, behaviour is undefined.
Thank you, that's a clear explanation
Until the compiler guys crank it up another notch :) The world is going to the dogs
Thank you so much for the links. They seem to be helpful and well explained. I will read them. I have been studying from [this](https://en.wikibooks.org/wiki/Windows_Programming) source for the last 3 days. I'm dropping the link too just in case someone reads these comments in the future.
this was surprisingly detailed :o nice document
Unless you are developing a game for a very specific platform which only supports C, you are after unnecessary headache. There are widely used game engines which makes developing games very easy. I never heard of one that supports developing in C, and that makes sense. Handling thousands of objects and actors in C doesn't make sense. So I think you should direct your attention to popular engines so you have lots of documents to learn from. Unity is the most popular right now.
Actually this will not necessarily set the padding bits to zero. But your implementation might.
Do not post pictures of code. I have removed your post so you can repost it with code as text. If you can't get the formatting right, use an external paste service and link to the code paste.
srand() just seeds rand() it doesn't return anything, hence your error. Call srand() on its own to seed random number generator and call rand() when you need a random number. Read this http://www.cplusplus.com/reference/cstdlib/srand/.
https://www.amazon.co.uk/Linkers-Kaufmann-Software-Engineering-Programming/dp/1558604960?SubscriptionId=AKIAILSHYYTFIVPWUY6Q&amp;tag=duckduckgo-iphone-uk-21&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=1558604960 good book if you want to know more. easy read too for a nerdy topic!
Original: https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/CompilationProcess.png
Yes, so assuming that with bitfields, there are no additional padded bits the compiler handles, and cube fits into 32 bits, everything would be zerod at initialisation.
Sure, if you manually pack your structs to ensure that there is no compiler generated padding, then you've avoided padding in your struct, and you can use C99 initializers without worrying about garbage values for the padding bits since there are no padding bits.
This is somewhat unrelated to your question, but which edition of this book do you have? The C code in this book, particularly in the earlier versions, is full of errors. Do not blindly copy the code and then hope to study it in a working state.
Short answer (skipping a lot of detail since your question is not very specific): The OS/library you‚Äôre using will do that for you.
Note: The above returns the correct value (i.e., `b`) if `a` is zero, but will result in a divide-by-zero error if `b` is zero. If you wish not to support values of zero on entry, it would be good to add an assertion at entry: assert(a != 0); assert(b != 0); Better yet: if (a == 0) return b; if (b == 0) return a; if (a &lt; 0) return -gcd(-a, b); if (b &lt; 0) return -gcd(a, -b); The checks for negative input are necessary because C's modulus operator `%` results in undefined behavior for negative values.
I'm using the 1st edition released in 1990.
mingw-w64 is a maintained fork of mingw (which is some combination of abandoned or refusing to fix bugs).
&gt; MinGW-w64 comes from mingw-w64.org. That site doesn't offer any direct downloads -- it redirects to SourceForge for the source and one particular set of pre-built binaries; and other providers for binaries.
That site is the old mingw
IP doesn't do that. It has a header checksum that you can use to verify that the header is (probably) okay, but other than that, it's not IP's responsibility to determine whether a packet has been transmitted successfully. This is TCP's job, another layer on top of IP.
\#include &lt;stdio.h&gt; \#include &lt;string.h&gt; &amp;#x200B; int main () { char string\[100\]; int i; int key = 1; &amp;#x200B; &amp;#x200B; printf("Enter encrypted text:\\n"); fgets(string, 100, stdin); while(key &lt;= 26) { for(i = 0; (i &lt; 100 &amp;&amp; string\[i\] != '\\0'); i++) { if(string\[i\]&gt;=65 &amp;&amp; string\[i\]&lt;=90) { string\[i\] = ((string\[i\] - 90) + key) % 26 + 90; } } printf("Decrypted text: %s\\n", string); &amp;#x200B; key++; } return 0; }
This sub us for C programming. Try r/csharp
by putting a transport-layer protocol on top of it
The OS-provided TCP does a good job of stream-building, but that‚Äôs its purpose and that‚Äôs what it does. On top of this setup you can overlay cryptographic signatures to detect any attempted changes to content (e.g., from a MITM attack) and ‚Äúguarantee‚Äù the data originates from some specific person/thing. Also ‚Äúpacket‚Äù.
Hi, I am still doing some research for the memory management, do you have any suggestions? However I would like to use less pointer as possible (I will do clean up in the next days) to avoid side effects. Poll/Select seems a good idea, I am also planning to change the message management! Thank you!!!
Consider a trade school for programming. I‚Äôm not familiar with trade schools, but hear they‚Äôre cheaper and faster. Community college is also an option. Consider experimenting with Unreal Engine. It‚Äôs free to try out, very powerful, and uses C++. Unity is a competitor which uses C# (a different language, but one worth picking up down the line). r/learnprogramming has plenty of resources to help. There are a variety of C++ subreddits (this isn‚Äôt one of them!) that have resources as well. Those subreddits will be far more helpful than this one (unless you take up an interest in game programming in C). Don‚Äôt get discouraged. Plan out how you want to spend your money and don‚Äôt rush into any educational programs unless you know it‚Äôs worth it. Good luck!
Alright thanks for the info. I‚Äôll definitely look into it and hopefully will find somewhere to learn everything
Try /r/cplusplus, /r/cpp, or /r/cpp_questions since those are C++ subreddits.
I am not a C++ programmer, but I‚Äôve experienced good results with Udemy courses for Python and JavaScript. I usually read several articles online to find which courses are the most worthwhile and then try and purchase them during their routine 90% off discount specials! FWIW, I‚Äôm about to finish with a masters degree in environmental science, but I have never taken a formal CS class for either of these languages. I expect to work as some form of data analyst/GIS developer once I finish up.
Yeah that‚Äôs what I‚Äôm using right now is Udemy and I learned a bit with it but it started to get way too hard. It was more of a tutorial instead of a lesson. I also used codecademy to learn C++ and I learned quite a bit but I‚Äôd have no idea how to apply what I learned to programming with the engine I‚Äôm using. I might just redo the Udemy course and maybe it‚Äôll click eventually. I was just kind of curious how many people have become experts in programming without college and how they did it
There‚Äôs no easy way to become a true expert without sweat equity, but that doesn‚Äôt mean you have to break the bank. If the Udemy stuff isn‚Äôt clicking yet, then I‚Äôd recommend starting a simple project that is more inline with your personal interests. I never could have tread through such murky programming waters if I didn‚Äôt absolutely need to learn a skill for a specific project. At this point I‚Äôve built up enough of a foundation throughout the years where I feel confident in my ability to pick up almost any new tool that may be required of me to get the job done.
Note that if you want to be employed in a company at some time you'll need more than knowing game development. Most educational programs should also teach you about things like project management, foreign languages, company management... The specifics can vary and you sound like you're from the US which I know very little about, but the fact is that a company will prefer an average developper that can fit in a team than an extraordinary developper that knows nothing of how companies work. I'm sure there are other options than college, but keep those in mind when deciding.
The harvardx computer science principles course at edx.org was what taught me C. The final Javascript part is complete rushed garbage and they barely explain anything and I recommend just not doing that part. https://www.edx.org/course/cs50s-apr-computer-science-principles-harvardx-cs50-ap
Try Udemy they have a lot of different courses about game development , programming , cyber security etc.
VSC and the teminal (Makefiles etc)
https://blog.feabhas.com/2012/06/the-c-build-process/ is another original
There is a really good unreal course that covers how to write in c++ by Ben tristem on Udemy. Loads of hours and really good community of people that ask questions you might have. I'll link when I get onto a computer.
https://github.com/mvillaloboz/open-source-cs-degree
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Without having read all the comments I'm just gonna say what I've was told (All the time) when I started with game dev and asked sort of the same question. &amp;#x200B; Just start! However works for you, but just do it. Pick a project, maybe a clone of a simple game?, and start working through it. Learn what you need when you stumble on the problem. When you're done, repeat. (This was told to me a lot and often. I also read it in similar threads) For me personally school is a great place to be, because you talk with like-minded and you "speak the language" all day. What I mean by that is the same as learning any spoken language. Reading about it and learning all the rules is great, but you need to speak it everyday and often to get it to stick. When I was done with school I joined a game dev community in town and I try to hang with them every week. &amp;#x200B; Also this takes time, don't rush it to much. Actually the brain sometimes doesn't pick up important stuff when stressed and overloaded. &amp;#x200B; Game dev is fun and good luck on your journey! :) Happy coding!
I've only had a quick read through but a few things spring to mind. * You assign space for 200 words, but don't check if `j` ever exceeds that. * You assign 20 characters for each word, but there's no checking if `k` goes over that. * 2000 is a hell of a lot bigger than 20... * Instead of using 65, 90 etc you can use `'A'`, `'Z'`. e.g. `if ('A' &lt;= currentLine[i]...`. Doesn't make any impact on the execution of the code but it makes it easier to understand what you're doing. You might also want to look at the `isalpha` and related functions in `ctype.h`.
Wow, this is just a straight copy of a Feabhas article
The linked-in article was a direct copy...
I've removed this article as it has been ripped off [this article](https://blog.feabhas.com/2012/06/the-c-build-process/) without attribution.
I've notified the original author. Ahmed has disabled comments, funnily enough.
Thank you so much! I just had no idea what to fix.. thought it could be a big text file so I set it 2000 just in case. Probably too big.. Thanks again!! üëèüëèüëèüëè
&gt; Ahmed has disabled comments, funnily enough. I logged in to linkedin to shout at him for that. But linkedin only tells you comments are disabled AFTER you log-in. Before that it makes it look like there's 0 comments and comments are allowed. Another dastardly trick linked-in has pulled just to make me log in. But the jokes on them, I made sure not to go into my inbox and click accept on the 50 recruiters waiting.
&gt; And to say that MSVC barely supports C99 features is not correct. But it's also not-incorrect. If it can't do VLA then it doesn't support C99. It doesn't matter that C11 made it "optional".
Lookup docs for fscanf and fprintf/fputs. Also check safe versions of those.
- From your description of what you need to do, I don't think you really have to read the text line-by-line or save the words in arrays. (In fact, I notice that you aren't ever reading from your arrays, you're just writing to them.) Just read one character at a time using fgetc, and for each character, decide whether it gets printed or not. I would not save the words in an array unless you are required to do that for some reason. (In a language like C# or Python I might use arrays of strings because they're easy to work with, but in C they are inconvenient so I'd avoid them unless I really needed them.) - You are using malloc to allocated a block of memory whose size is known at compile time. While this works fine, most people would simply create a fixed-size array in that case. On the other hand, one nice thing about malloc is that you can enlarge the block if necessary (using realloc), but you aren't doing that. You could take advantage of malloc/realloc to allow your program to enlarge your buffer if needed, that way you wouldn't be limited to some fixed line length that had to be known at compile time. However, as I said above, I think you can get rid of the line buffer entirely. - Don't put numbers like 2000 in your code. Define a symbolic constant (e.g. `#define CURRENT_LINE_LENGTH 2000`), then use that constant in your code. - When you fail to open a file (`inputFile == NULL`), you should make sure that all of your cleanup gets done before exiting the program. You allocated memory with `malloc`, but that only gets cleaned up when the program finished successfully, not when it fails. (In this case there are no bad effects, but you should get into the habit of cleaning things up properly, because in more complicated programs it will matter a lot.)
Keyword "barely." It does support C99 except for unpopular features (VLAs) and the support for `_Complex` is nuanced because they didn't want to make it inefficient by making it portable, it looks like (I didn't read too far into this, but it looks like they support all the C99 `_Complex` related function calls, but the `_Complex` type itself is not used because the MS team disagreed with the spec). I'm sure there are other caveats, but it's still really nice to have the parts of C99 that are there. And MSVC is honestly more of a C++ compiler anyways.
Oh, you aren't checking for null ('\0') at the end of `currentLine`. I'm guessing that's where your program crashes. Whenever you read a string you need to remember to check for the null terminator. (Unless you already know exactly how long the string is, then you can use the known length to avoid running off the end of the string.)
cpp is the C preprocessor. You are not writing filenames on a FAT system, so use the +'s.
\#include &lt;iostream&gt; \#include &lt;string&gt; &amp;#x200B; using namespace std; &amp;#x200B; struct Node{ string driverName; int position; Node \*next; }\*head, \*tail; &amp;#x200B; /\*int nodeCreate(string dri, int pos){ Node \*node = new Node; node-&gt;driverName = dri; node-&gt;position= pos; node-&gt;next=NULL; if(head==NULL){ head = tail = node = NULL; } else{ tail -&gt; next = node; tail = node; } } &amp;#x200B; int nodeDisplay(){ Node \*node = new Node; node = head; while(node != NULL){ cout&lt;&lt; node-&gt;driverName; node = node-&gt;next; } }\*/ int main(){ Node Left; Node Right; int t; int i; int j; int p; int m; char b; string d; cin &gt;&gt; t; for(int x = 0; x &lt; t; x++){ cin &gt;&gt; b; cin &gt;&gt; m; cin &gt;&gt; i; cin &gt;&gt; j; for(int h = 0; h &lt; i; h++){ cin &gt;&gt; d; cin &gt;&gt; p; Node \*node = new Node; node-&gt;driverName = d; node-&gt;position= p; node-&gt;next=NULL; if(head==NULL){ head = tail = node = NULL; } else{ tail -&gt; next = node; tail = node; } } Node \*node = new Node; node = head; while(node != NULL){ cout&lt;&lt; node-&gt;driverName; node = node-&gt;next; for(int g = 0; g &lt; j; g++){ cin &gt;&gt; d ; cin &gt;&gt; p ; Node \*node = new Node; node-&gt;driverName = d; node-&gt;position= p; node-&gt;next=NULL; if(head==NULL){ head = tail = node = NULL; } else{ tail -&gt; next = node; tail = node; } node = head; while(node != NULL){ cout&lt;&lt; node-&gt;driverName; node = node-&gt;next; } } } } } &amp;#x200B; These are my progress as of now
I have actually heard this recommendation a couple of times that for security critical software where speed isn't too important, you should use `-O0`.
This feels very much like a homework assignment, so please understand that any advice will likely be guidance. I haven't looked closely at your other comment with your current status. One thing to note is that, assuming you're targeting C, your `#include` statements need to change - you won't have `iostream`, for instance. A'so note that working with a C string is quite different that a C++ string. If you're not targeting C, then this might not be the best subreddit for your question. Please recall that a class is fundamentally little more than a struct with associated functions to operate on that struct. Those functions are implicitly tied to the struct, so you get a kind of namespace. Classes also offer inheritance, but this project appears to not depend on that. So, I would recommend breaking down the C++ code into the data and the functions. Try to name the functions meaningfully. When looking at the data, look at what functions C++ is giving you implicitly (e.g. the std::string stuff -- constructors, resizing, etc). This (breaking down to data and functions) may need to be repeated a few times, until you've broken it down enough for C. After you've essentially surveyed the code, then you can put it together in a maintainable fashion.
This is one possibility. I've heard of people who run their high-security code under valgrind so they can immediately abort on memory errors.
My personal list solution is like this: struct list_node { void *data; struct list_node *next; }; struct list { struct list_node *start; struct list_node *end; }; So you keep the start and end of a list in it's own structure. A list_new function just returns calloced memory of size list. The other functions take a struct list * as it's first parameter, for example: int list_add(struct list *list, void *data) { struct list_node *node = malloc(sizeof(struct list_node)); if (! node) return 0; node-&gt;data = data; node-&gt;next = NULL; if (!list-&gt;start) list-&gt;start = node; if (list-&gt;end) list-&gt;end-&gt;next = node; list-&gt;end = node; return 1; } The if statements check if it's the first item (!list-&gt;start) or if it needs to adjust the last item (list-&gt;end) before adding the item to the end. (it's a bit confusing i think). Anyway, that should be the hardest part, the other functions can just walk the list while list-&gt;next contains a valid pointer; struct list_node *node = list-&gt;start; while (node) { struct list_node *next = node-&gt;next; /* do something with node here */ node = next; } An for statement would be nicer i guess.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Have a look at [Z-machines](https://en.wikipedia.org/wiki/Z-machine). This school project can be definitely rewarding and interesting.
Oh, that's a good idea as well. Though your program crashing unexpectedly could also cause other security vulnerabilities.
You replace the occurrence of class on line 11 with struct. The only difference between the two is default visibility, but you are explicitly setting that
That's the tricky part.
Given: void test(int mode) { static int literal_1 = 1; if (mode &amp; 1) action1(&amp;literal_one, 1); if (mode &amp; 2) action2(&amp;literal_one, 2); action3(); } a compiler can simply pass a constant address to `action1()` and `action2()`, and this will work even if `action1()` and/or `action2()` causes a copy of the pointer to be stored somewhere and used later. Change the code to: void test(int mode) { if (mode &amp; 1) action1(&amp;(int){1}, 1); if (mode &amp; 2) action2(&amp;(int){1}, 2); action3(); } and a compiler that can't see into `action1()` and `action2()` will be required to generate less efficient code, since the lifetime of each compound literal will start when code enters the enclosing block end end when control leaves that block. If `test` gets recursively invoked, the nested calls will need to pass the addresses of new objects of type `int`. On the other hand, if `action1` and/or `action2` stores the passed-in pointer for use by `action3`, wrapping the call within a compound statement would break the code, since the lifetime of the compound literal would no longer extend through the call to `action3`. If there were a concise syntax for static const compound literals with semantics similar to string literals (e.g. compilers are allowed to put literals with the same value at the same address), I'd use that, but no such syntax exists.
Do professional c programmers actually use the methods outlined in that book or is it useless in the real world?
I would look at things like SDL2. [http://libsdl.org/](http://libsdl.org/) There are a ton of tutorials and you do not need a virtual machine. It is going to be a non-trivial project, so be prepared to work like crazy. Good luck!
C99 has never mandated any circumstances in which implementations must implement VLAs in *useful* fashion. Instead, it grants implementations free reign to do anything whatsoever if a program tries to create a VLA that's "too big", as well as free reign to arbitrarily decide the maximum size of VLA objects to support. Thus, the Standard imposes no requirements on the behavior of any program that creates any objects of VLA type, imply that--*by definition*--all such programs invoke Undefined Behavior.
I think he may be hinting that there maybe no answer.
you might want to look again. the answer is nine.
Here's a free online C compiler --&gt; https://www.onlinegdb.com/online_c_compiler# I pasted your code into main(), threw in some tabs for readability, and modified the existing printf at the end to be: printf("Hello World %d", x); The answer was 9.
I'll give you a couple of pointers to get you started. C is actually not that complicated once you get started with it. Learn about using printf() to output a variable to a console, and maybe start using an online compiler for simple things to get the hang of it. Also, use braces and tabs properly to get a readable program structure. Like so- int x = 9; if (x &lt; 10){ x = x + 10; } if (x &gt; 10){ x = x - 10; } else { x = 10; } Stick the above with a properly formatted printf statement to output x into the following compiler. [http://www.onlinegdb.com/online\_c\_compiler](http://www.onlinegdb.com/online_c_compiler)
Oh. Thanks for helping an idiot out.
compilers do the job of translating from one language to another. c compilers generally translate from C to a native executable format recognised by the operating system you open a text editor, save the file, invoke any compiler you have available on the source file--commonly "cc -Wall file.c" on unix-like systems--then run the file that was produced, which would be "./a.out" in this case.
You can't invert with &amp; nor |. Take a look at some truth tables, with your left hand side being what you'd use in your bitmask, and the right hand side being the bit. There is another common bitwise operator you'll have to use to perform the inversion, and you can identify it by looking at the truth table.
You invert bits by xoring with 1 0 ^ 1 = 1 1 ^ 1 = 0
XOR the \^ operation right?
Would this be correct? ((test | 0x73) &amp; 0x1F) \^ 0x15
No problem. The need for there always to be a main() function in a C program is probably something that gets easily glossed over, and you might not expect that if you've only dealt with command lines or more scripted programming languages. Good luck!
Ah, I see. Thanks!
https://en.wikipedia.org/wiki/Bitwise_operations_in_C
**Bitwise operations in C** In the C programming language, operations can be performed on a bit level using bitwise operators. Bitwise operations are contrasted by byte-level operations which characterize the bitwise operators' logical counterparts, the AND, OR and NOT operators. Instead of performing on individual bits, byte-level operators perform on strings of eight bits (known as bytes) at a time. The reason for this is that a byte is normally the smallest unit of addressable memory (i.e. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
pick up a book, have a read about bitwise operations
No. 0x73 = 01110011 0x1F = 00011111 0x15 = 00011001 To clear 2 msbs, &amp; with 00111111 To set 3 lsbs, | with 00000111 To toggle the rest, ^ with 00111000
&gt;00111000 ah, so it would be ((test | 0x07) \^ 0x38) &amp; 0x3F
You can also use printf statements throughout the program structure to see how the program modifies x.
 if((~(test &amp; 0xC0)) &amp;&amp; (test &amp; 0x07)) { test = test ^ 0x28; }
Yeah.
Is this "test" happen to be a register you are manipulating ?if it's the case then this method should be used instead left/right shifting of 1/0 should be used
 &gt;I'll give you a couple of pointers to get you started. Mini heart-attack after reading this line
lol
Please format your code properly for easier reading. It tells you how in Reddit's Formatting Quick Help, right below your text box.
Your professor wants you to compile that code, but hasn't shown you how to install and use a compiler yet? What text are you working from? That should be something you learned before even talking about variable or conditional statements. It's kind of hard to learn C without compiling C, after all. It's also not a complete program, just a fragment. I'm not familiar enough with Windows (I'm assuming you're using Windows, are you?) to tell you how to install a C compiler other than "install Visual Studio." But here is a complete program you can run to see the result of this. #include &lt;stdio.h&gt; int main(void) { int x = 9; if (x &lt; 10) x = x + 10; if (x &gt; 10) x = x - 10; else x = 10; printf("x = %d\n", x); }
Think I've done that now? Very beginner...
This looks like a debouncing issue. The problem is you are not counting the times the button is pressed, rather the times the loop sees that the button is pressed. Debouncing is the keyword you should be looking up.
You are checking whether the button is depressed every loop but not waiting for its release. Your count is likely reaching 8 on every press.
Ahhhh right, so if I would incorporate this with the denouncing example?
You did it perfectly.
So as the other guy said above should I add mix this with the denouncing demo?
I'm not familar with the debouncing demo myself but you should definitely learn why and how you need to debounce switches. Imho Just trying to mash an an example in there wont get you very far.
Oh yeah absolutely. The demo shows exactly how it works and should help me out a lot. Thanks for your time though.
int f(int x, int y) { if (y == 0) return x; // f*(x,y) = x + f(x,y-1)* otherwise }
I'm not sure what the example is and I also have never used the arduino to be honest. The debouncing concept will come up a lot in working with hardware. Read up on the concept and then look at your implementation again.
oh my god i actually might be retarded thank you so much.
&gt;Here's an article I found helpful tackling the same thing. Both HW and SW debouncers shown &gt; &gt; [http://www.ganssle.com/debouncing-pt2.htm](http://www.ganssle.com/debouncing-pt2.htm)
Google "bit twiddling" and behold your answer awaits ;)
Bit shifting can also total less instructions which is one of many other reasons they are preferred. However, if you're that hard on clock cycles then that's the least of your worries.
That book looks like it has a lot of stuff. Is there any point where we can stop and still learn lots? Is it actually applicable in the modern world?
I've sorted this now, though I wouldn't mind if you would check my latest post for a quick skim over of "my" finished code. &amp;#x200B; Thanks.
oh god thank you so much! Much much appreciated!! I'll sit down and fix it one by one.
hmm yeah that's right, I wouldn't know the length of the string. Good point! ty!
Yep! Thanks for help!
Which one?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
[Hacker's Delight](https://www.hackersdelight.org/) Scroll down to Chapter 2, Basics. It's a nice PDF. [Here's a PDF of the whole thing.](https://doc.lagout.org/security/Hackers%20Delight.pdf)
I would get rid of `delay(...)`. That is not a good way to do anything related to time. You should use the method that you used for debouncing the button, i.e. if ((millis() - lastTimeIDidSomething) &gt; period) doSomething(); lastTimeIDidSomething = millis(); It will take a bit more than that to manage the state of lightOn/lightOff, but hopefully you get the idea. FYI if this is for Arduino it's actually C++.
\#define ANYTHING\_BUT\_ZERO(x) (x != 0)
 any, "the c programming kanguage (second edition)" by ritchie &amp; kernighan's good
Excuse me, but I think it's #define EVERYTHING_BUT_ZERO(x) (x != 0)
Just stop when you don't feel like you're not getting much out of it. Nearly all of the examples/problems in the book are very specialized applications of semaphores. Most synchronization problems need nothing more complicated than a mutex or a condition variable. So think of the book as practice for reasoning about synchronization challenges.
Short answer: no Long answer: everything is possible with work. You'd be to define functions to handle removing 0's from your set. The C11 standard has some macro typing in it. So you could use lessons from this https://en.cppreference.com/w/c/language/generic Then you could make cases for things like int*.
I assume the `loop` function keeps getting called repetitively? If so, why do you keep incrementing the `count` variable if you're only interested in it being superior equal to 6? Is there somewhere else in your code where you're doing something else at a different count value? If not, then if it keeps incrementing enough times (e.g. `while(1) { count(); }`), you could hit an integer overflow.
You can definitely do that in C! After all, Bash came from somewhere. Here is a link to the documentation over the subject: https://www.gnu.org/software/libc/manual/html_node/Processes.html#Processes
Thanks!
Well that is definitely what I am looking for but I am unable to use the necessary header file since I apparently "have no rule to make stdlib.h" and I have no idea what I am doing around makefiles. I honestly thought that I woulnd't need a rule for that to begin with but who knows with xv6.
This community exists to discuss the C programming language. Please redirect your question to r/cpp_questions.
O ok!
The rest of what you‚Äôre doing sounds pretty gnarly, but makefiles don‚Äôt have to be. Just google ‚Äúmake tutorials‚Äù and I‚Äôm sure you‚Äôll find lots of tutorials
I have been looking through every link that I could find about my error and I have found nothing that has anything to do with adding basic headers like stdlib to makefiles. It seems like something that doesn't need to be done at all so I am thinking that the issue lies somewhere in xv6.
It sounds like you may have a misunderstanding about Makefiles yeah. It's too much to describe here, so I'll again point you to some documentation: https://www.gnu.org/software/make/manual/html_node/Introduction.html Check out the sample Makefile provided once you read through how rules work.
Ok yeah i didnt really fully understand what makefiles did. I also found out that xv6 does not support basic header files like stdlib.h and stdio.h apparently so unless i do MAJOR changes to the operating system then i cant use the originally linked solution unfortunately. I really appreciate the help though!
Those are very serious limitations. I doubt that is the case. Is this using a Linux kernel?
xv6 is a separate operating system that I am using for a class right now so it is the xv6 kernel that I am trying to program in at the moment. Also would you possbily have any knowledge about how to use the exec() function to call multiple arguments in a row? I think that this might be the solution to my problem but all of the documentation about the functions makes it seem like you can only call executable files in a row and now commands.
yeah, drop the FATHER definition an just write `r != CHILD`
I don't understand your question, but from what I'm guessing you're confused about how to continue calling `exec` after you've done so once. I'd recommend iterating through a linked list of job types you define that hold an argv variable for use in your call to `exec`. If xv6 doesn't support glibc I'm not sure what to tell you. I find it very unlikely that is the case and you might have misunderstood an error message regarding it. Perhaps you don't have glibc installed or the filesystem might be organized differently to what GCC expects by default (I.e. you might need to add a -I argument to your invocation of GCC). Either way, use a `find` command to search for `stdio.h` in your `/usr` directory to see if anything shows up.
Man pages are online. Probably your best resource on the C API.
Are you trying to write a program that encrypts a file from scratch? How much experience do you have with C and how much do you understand about the AES algorithm? If you just want to find code to do it for you, check out [this implementation](https://github.com/kokke/tiny-AES-c)
Does the [C Reference](https://en.cppreference.com/w/c) works for you?
Have you looked at how the `fork()` and `exec()` system calls work in xv6, and considered compiling each of your files as its own user-space program? If you know what the executables' names will be, you could probably get what you need by `exec()`ing them. I've been doing some different assignments than yours with xv6 this term, so I unfortunately don't know the specifics of your project, but running a user program from within a different one is something I've done.
If you are on Unix or Unix-like system, you have access to a handy manual. Type `man function` (for example `man malloc`) in terminal to view manual page for this function. Some may require adding a page number, for example `printf` is also in Bash and if you want to display manual for C, you have to request it with `man 3 printf` or `man -a printf` and close pages you are not interested in. "See also" section on each page may be useful too. Type `man man` to learn more about this help system. On Linux, you may have to install additional package to get C man pages.
This is what I rely on and it works well.
yeah i will have to type a program that counts the number of words in it and then proceed to encrypt it. my experience with C is really basic, took a mod in my first year in uni. and only learnt the theory part of AES. i‚Äôve never code it before.
Are you allowed to find an open source AES interpretation and use that in your program? Or are you supposed to write it from scratch
i guess it‚Äôs okay to use an open source AES interpretation
As well as the man pages on UNIX there's also the POSIX standard: http://pubs.opengroup.org/onlinepubs/9699919799/ Can't link directly due to frames (? it's 2019?!) but click on "System Interfaces" in the top left frame then "Introduction" in the bottom left frame and start from there.
Excuse me, but I think it's #REAL\_NUMBERS\_BUT\_ZERO(x) (x != 0)
https://wiki.osdev.org/Tutorials Without more specific questions, osdev is the only reasonable place to start IMO
Thank you
 #include &lt;stdio.h&gt; int main() { int *x = 9; if (x &lt; 10) { x = x + 10; } if (x &gt; 10) { x = x - 10; } else { x = 10; } printf("%i\n", (int) x); return 0; } Compiler won't like it, but it should work :)
Smart people once said: "Whenever you try to build a new operating system, you'll just get another Linux distributive"
How do you want to use `FATHER`?
Try /r/programminghelp? Based on the questions you're asking, it doesn't sound like you have a good idea of what you're even trying to do. This is also a homework problem on a toy architecture so it's outside the scope of regular C discussion.
This is a hard task and until you have a general idea where to start, I recommend you to avoid this.
[Introduction](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap01.html).
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
98% of everyone with such questions these days just searches the web for the specific keywords of their question. You usually get stuff like [this](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation) and [that,](https://people.cs.clemson.edu/~levinej/courses/S15/1020/handouts/lec01/MemoryAndMalloc.pdf) which to be honest is the kind of thing you would spend half an hour in the engineering library at a research university to find. Life is different now.
That works but you lose all the menu links.
Not too many people here with a degree in psychology or psychiatry but I'm sure there's a sub for stupid questions like this.
I've only heard that said about UNIX, never Linux, and I first heard that 30 years ago.
 I'd just like to interject for a moment. What you're referring to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX. Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called "Linux", and many of its users are not aware that it is basically the GNU system, developed by the GNU Project. There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called "Linux" distributions are really distributions of GNU/Linux.
I think I get what OP's saying. Xv6 is a tiny Unix-like teaching OS created just for MIT's OS dev course. The standard C lib hasn't been ported over, hence its unavailability in user space. Looking at the source repo, it looks like there's only a few popular subset of functions implemented like \`printf\`
You can't run C files. You can compile C files. I guess what you want is Inter-Task Communications?
I second this. And for some commands, you can also use ```info``` as in ```info gcc```
Or `pinfo`, which is much nicer to use (lynx navigation).
When reading a file, there is a "pointer" stored internally that keeps track of where in the file you currenty are. fgetc will advance this "pointer" by one char. fgets advances it by a full line. This is probably the reason you miss every other line, fgetc already exausted the first line, so fgets actually reads the next one! I would suggest you use fgets to read the file line using a loop. Then you can use string functions (strcmp, strncmp, etc.) to figure out if you want to add the line to buffer or not.
What distros are you running? I tried man malloc but no results. I use RHEL and Solaris at work. I have an old raspberry pi and recently switched to BSD, so will try these once I‚Äôm home.
That is an enormous and thorough resource! Thank you very much!
Oh I‚Äôm aware I could just follow a tutorialspoint explanation on this or that function, etc. I was more enquiring about a website that has it all more or less together, in some offical format. Other posters have given me enough resource. Thanks though.
That is incredible! And I admit that URL did pop up in one of my searches, however I dismissed it as it‚Äôs cpp. I see they‚Äôve got C stuff as well (didn‚Äôt want to confuse myself with CPP concepts)
I'm not sure about RH, but on CentOS you need to install "man-pages" package (`yum install man-pages`).
If GNU really wants people to refer to a Linux system as GNU/Linux, they should add an advertising clause to the license. As it stands now, the bot post is just complaining that people are playing by the rules.
The same happened to me, when you search a keyword you got both results on Cpp and C references.
idk but start by learning how to program the computer you have with an assembly language or whatever, learn how to interface with the hardware--io devices, disks, memory, etc--through that, then go from there...
Didn't know about this one. Thanks
I've never used xv6, but a quick read says it's similar to Unix v6, so can it support using the Mashey Shell, which supports scripts, or something similar?
It sounds like you're looking for a magic hammer to solve problems that aren't actually nails. What you're asking for, and what you're trying to accomplish are likely miles apart. What's the use-case you're trying to solve? We can likely suggest a more appropriate solution.
Hi OP, I end up dealing with these questions daily, so I'll pop in my advice. I'll start here &gt; I know that I want to get bits cleared and set, so I need the | and &amp; operators. First, know you're bitwise operators The following work on bits in place &amp; -- bitwise AND -- result for a particular bit is 1 iff both input bits are 1 | -- bitwise OR -- result for a particular bit is 1 if either input bit is 1 ^ -- bitwise XOR -- result for a particular bit is 1 iff one input bit is 1 ~ -- bitwise NOT -- flips all bits in the input to the opposite The following operate on the entity as a whole &gt;&gt; -- right shift bits by a certain amount &lt;&lt; -- left shift bits by a certain amount To do you bit manipulation, I generally would write out what I'm doing in binary, then convert to hex as needed. So, for your #1, clearing the 2 msbs in an 8bit entity, I know I can do that with an AND while having the two msbs of the operand as 0. That's 0b0011_1111, or 63 decimal and 0x003F. So to get the step one done, I need `test &amp; 0x003F` in some flavor or another Then repeat that thought process as needed. It'll become something you don't think about eventually
Thanks for the advice. The reason i am so sure that those libraries dont exist is because my TA got back to me and confirmed that they are not supported. I tried looking for them anyway just to double check and sure enough they are not in there. I think our professor gave us an old ass version of the operating system on purpose so that we couldnt use more modern stuff for whatever reason.
Cplusplus.com (despite its name) has information on c function arguments and small very basic examples.
Is there an option is turbo c++ to build a 64 or 33 bit binary? How old is that compiler?
i dont know i run this dos shell from dos box within turboc++
So I was looking into using exec() and I am not sure that I fully understand how to use it properly. I know that I am supposed to pass it a filepath to an executable but it seems that I cannot just call the exec function multiple times in a row. This does seem to be the solution to my problem I just do not know how to properly use it and tbh the documentation that I have been finding is more confusing then anything else.
I was just trying to make something like this: #define CHILD 0 #define FATHER "non 0" int pid = fork(); switch(pid){ case(CHILD): // ... case(FATHER): // ... } Now, you cant do #define FATHER !0, because thats a logical not, so its value is 1.
&gt;FATHER is everything but 0 in the context of processes ids
Yeah, ik, just wondering if it was possible
I don't want to know what it is but rather how you plan to use it.
Excuse me, but I didnt want to use fully boolean expressions, to be able to use FATHER inside a switch case
Ah. Dosbox dynamically recompiles 16 bit code to either 32 or 64 bit code. Sounds like the binary really is a 16 bit binary. You need a compiler that can make a 32 bit or a 64 bit binary. Also. Dosbox runs dos binaries. Likely your binary, in addition to being a 16 bit binary, likely also requires a dos runtime. You need a more recent compiler if you want to run the binary directly on the OS.
Why do people still use turbo-c++? Try and find a modern compiler, so you can learn modern c++.
I had a feeling that was what you're trying to do. The typical way to handle it (that you should burn into your memory) is... pid_t pid = fork(); if (pid) { // parent // do parent stuff } else { // child // do child stuff } If you must, then go ahead and add the inline comments (`parent` and `child` so you can remember. Otherwise, this type of code-block should be so engrained in your mind that you can interpret or produce it fluently. It's really quite standard and straightforward -- adding macros just adds unnecessary complexity.
oh thnx buddy
Well, yeah, i just liked the way a switch statement looks like. Thanks for the help!.
&amp;#x200B; \#define CHILD 0 \#define FATHER "non 0" int pid = fork(); switch(pid){ &amp;#x200B; case(CHILD): // ... case(FATHER): // ... }
PJ Plauger from Bell Labs put out a book called *The Standard C Library* in which he implements the original C89 library, complete with literal photocopies of the relevant parts of the C standard. It's not hard to find a PDF.
That is not possible as numbers are equal only to themselves. However, you could use a `default` label for the FATHER case.
When you call `exec`, your program will resume only after the program you've called has finished. That means you can call exec many times in a row, but not at the same time. If you need to run programs in parallel, take a look at `fork`. Just call it and check the return value. If it's zero, you're now in a child process (from which you can call `exec` without interrupting your main program), otherwise, you're still in the parent process.
Okay, I'll stick to the classic if / else, thank you!
I dont need to run these things at the same Time just one after the other. Would i simply need to use a wait for one call of exec to finish then call the next?
I just started on this journey myself, already have some programming experience and still finding it a difficult task. PM me if you wanna team up, perhaps we can work on it together? I wanted to create my own OS for specific reasons, as to which some are accessibility, concentration on tasks stuff like this I tried to think of what I can‚Äôt find in any other OS (except Mac OS X probably?) but yeah I am trying to start with the basics and work my way up.
Checkout r/osdev . The sidebar has a ton of references, tutorials, and the like.
I would recommend "delay" rather than "avoid". Delay keeps it as a long term goal, give a purpose to learning.
Sorry, I was wrong in my previous reply. `exec` replaces the current process, so any code after the `exec` call will never be run. So in order to achieve what you want, try something like this: ``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; int main(int argc, const char** argv) { for (int i = 0; i &lt; 5; i++) { fprintf(stderr, "Running process %d...\n", i); int pid = fork(); if (pid == 0) { // we're in the child process now char* const args[] = {"/bin/date", NULL}; // exec replaces the current process, the // child process ends after this call execv(args[0], args); } int status; wait(&amp;status); fprintf(stderr, "Process %d has finished.\n", i); } return 0; } ```
Because they are Indian
&gt; turbo c++ India
No. You will need to fork a process, then wait in the parent for the child to exit. You can test which process is which using the return value from `fork()`. Note that if everything works correctly, `exec()` will never return. I would suggest looking at the xv6 implementations of the `fork` and `wait` system calls and using grep to find uses of them in the existing code base that you can use as examples, too.
 i would love to team up with you dude
Chris Wellon's blog series is good for minimalist C library design, and he has excellent examples on his Github too: https://nullprogram.com/blog/2018/06/10/ For a more opaque approach, check out: https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413
Why not use `default` as /u/FUZxxl suggested? int pid = fork(); switch (pid) { case -1: perror("fork"); return 1; case 0: printf("child\n"); break; default: printf("parent\n"); }
I keep things pretty modular by separating various systems and structures into their own C file, and expose an interface via header files. I usually do pool allocators, where I allocate a pool of objects to allocate from, returning a simple integer as a handle to the object so that if I run out of space I can just realloc the pool usually doubling it in size (really depends on the nature of the code though) and the existing object handles will all continue work as expected. Only in very few instances will I actually expose the data structures themselves, depending on how much code needs to operate on them or have access. Other times I'll just expose an opaque API to retrieve certain properties of objects.
Alrighty ill definitely try that. Thanks for the help.
Honestly, I never expose structs. I forward declare the struct in it's header, but the actual struct is hidden in the source file with setters and getters.
Yeah, it's slower going than writing in a more abstract language, but the bottleneck isn't in how fast you type the code, but how well thought out your structures and algorithms are.
All C libraries, as in every library written in C? Absolutely not.
You could look at "21st Century C" by Ben Klemens (O'reilly) - specifically Chapter 10 "Better Structures". Good C programming is work (or a "chore") to some. But that is price you pay for the performance that you will get when using C. You could use C++ and have your cake and eat it too. It is just my opinion, but I believe you can be a really good programmer without understanding C (and/or assembly language). However, great programers - no matter the language - always seem to have a good knowledge of C. They understand how memory works under the hood because they have all had experience in manually managing memory. So if you are learning C, I would still learn how to do those "chores". All those "nice built-in data structures" are still built with these basic tools.
The situation is that my projects get large and complex enough that it helps to divide up the code that operates on structs across multiple source files, instead of having single C files that are become tedious to navigate through all the time. I think of it like having a hierarchy of sub-hierarchies. Then I'd have a header file specifically for exposing an API just for interacting with the system that those data-sharing C files comprise. Granted, I'm the only person ever working with my code so I can get away with not adhering religiously close to OOP principles, but my projects are tens of thousands of lines of code and it can definitely get annoying trying to do everything in a single C file for a given data structure that's thousands of lines by itself.
You can imitate some of the more important aspects of OOP in C. What I normally do is create a struct and a group of functions that operate on that struct, giving the functions a prefix that indicates which struct they operate on. For example: typedef struct Robot {...} Robot; Robot* Robote_Create(); // allocate memory with malloc, initialize the struct void Robot_Move(Robot* robot, int direction, int distance); void Robot_Speak(Robot* robot, const char* message); void Robot_Destroy(Robot* robot); // clean up any child data structure, then call free(robot) Make sure you only access the Robot data structure through the Robot_ functions. This way, you avoid creating dependencies on its internal implementation. By sticking to this rule, you get encapsulation. Inheritance is harder to imitate, and not really useful most of the time. If you do have a use for it, there are two straightforward approaches that I know of. - Tagged union. Look at SDL's [SDL_Event](https://wiki.libsdl.org/SDL_Event) for an example of how to do that (after understanding how it's used, [look at the source code](https://github.com/zielmicha/SDL2/blob/master/include/SDL_events.h)). Generally you process tagged unions in switch blocks that do different handling for each tag value. - Function pointers in your struct. Set the pointers to different implementations of the methods that you need. As for data types: **Arrays.** These are usually the go-to data structure in C because they're straighforward to allocate and iterate over. **Linked lists.** Also popular. C programmers don't usually create a linked list data type that looks like the classic Lisp implementation (i.e. `struct Node {NodeData* head, struct Node* tail}`), instead they'll create a struct that has all the data for each node, plus a member that points to the next/previous node. **Hash tables and tree structures.** These get harder to deal with in C but are perfectly doable. Since the implementation is much more complex, you'll usually want to write them in a generic fashion so you can reuse the code with different data types as members. The usual way to do this is to use `void *` for the values (i.e. making them weakly typed), then cast them to the needed type when you retrieve them. (If you've ever used Java or C# before they had generics, it's the same idea.) You can try to avoid the pitfalls of weak typing by wrapping the accessor functions with strongly typed versions. You can even wrap the basic data structure type. For example: typedef struct Hashtable { ... } Hashtable; // hashtable implementation with void* values Hashtable* Hashtable_Create(); // calls malloc and initializes void Hashtable_Add(Hashtable* ht, const char* key, void* value); // weakly-typed add method void* Hashtable_Get(Hashtable* ht, const char* key); // weakly-typed get method typedef struct HashtableOfRobot { Hashtable ht; } HashtableOfRobot; static inline void HashtableOfRobot_Add(HashtableOfRobot* ht, const char* key, void* value) { Hashtable_Add(ht-&gt;ht, key, value); } static inline Robot* HashtableOfRobot_Get(HashtableOfRobot* ht, const char* key) { return (Robot)Hashtable_Get(ht-&gt;ht, key); } This allows you to reuse the code for your implementation and still get some type checking, at the cost of writing a couple of extra functions for each type you want to work with.
For production usages or because the course hasn‚Äôt been updated in forever?
As for memory management, yes, it's a big pain and you need to be very careful. The key is to be very clear about which pointer "owns" an object, and make sure that 1. free is called on the owning pointer before it becomes unusable 2. no code can try to access the pointer after it is freed. If you're having trouble, try Valgrind, it can be really helpful in tracking down memory errors.
Also, there's a book by David R. Hanson called *C Interfaces and Implementations: Techniques for Creating Reusable Software* that deals with this. I haven't read it myself, but it seems to be the only popular book on the topic.
I'm not Indian, my purely anecdotal evidence is based on Indian coworkers telling me that's what they used in school over there instead of the big 3 compilers.
Well if it's guaranteed to be allocated memory and terminate in a null byte then it won't do anything harmful. Will look a bit funny though.
Some google searches enlightened me further. Thank you.
&gt;21st Century C thanks for sharing book
C# is off topic in this subreddit. Please post C# content to /r/csharp instead.
I recommend the book 'The C Programming Language' by Brian Kernighan and Denis Ritchie aka the C bible. Ritchie was the original author of the language, and the book still holds up as a great introduction to it.
FYI, for formatting code, triple backticks don't work on Reddit like they do in Discord. Instead, you have to indent each line by at least 4 spaces. \ So when you type out this (minus the forward slash) it becomes this
Yeah, i actually ended up with this one. Thanks to both of you
There have been books written on the standard library; not sure how much more detail they go.
`char *`, `signed char *`, and `unsigned char *` are kinda like `void *` in that they can alias anything, so it‚Äôs relatively safe to cast to/from them as long as you‚Äôre not violating the rules on either end. (E.g, you can cast from `signed int *` to `unsigned char *` to `unsigned int *`, but not `float *` to `char *` to `double *`.) Usually things like UTF-8 should use `unsigned char` or whatever `uint_least8_t`- or `char8_t`-like equivalent, since you usually don‚Äôt want non-ASCII code units to be treated as negative. `char` is especially messy because it can be signed or unsigned, depending on compiler mood. Bitwise stuff is also safer on `unsigned char` than on `signed char` or signed `char`, since `&amp;`, `|`, `^`, and `&gt;&gt;` can break if an operand is negative. UTF-8 shouldn‚Äôt *by itself* cause `printf` to segv unless you‚Äôre using some weird encoding for NUL like CESU-8 (C0 80)‚Äîother than NUL, bytes is bytes.
Thanks!
Honestly, i've forgotten all about my OO roots and went back to basics. I've treated C programming much more procedural with functional concepts than OO concepts. Typically what I do is create a memory arena for all of the memory needed by the program up front, then let all the systems that i've created to power the program carve out any memory it needs from the arena. I've written my own allocators to ensure that memory is handled properly in a way that makes sense for the cpu to consume it (trying to get as cache friendly as possible) All of my structs are treated as simply data, and nothing more. My functions operate on the structs data to do whatever it needs to do but if i were to have a struct for Customer, i'd never have a method like `Customer.updateName(new_name)'` My data structures tend to be arrays unless i need more, because arrays are extremely cache friendly. Memory management isn't really a chore, but its something to be more mindful.. you can't just keep calling `malloc` and `free` all over the place unless you want to loose track of who owns what. Anyway, just some brain-dump thoughts on how i write my C code.
Theres also http://devdocs.io that lets you select different documentations i.e a C reference, and a C++ reference and query them all at once, i found this site very useful. It also works completly offline as it lets you download the docs entirely. It also has a vim plugin that lets you open the documentation page for word under cursor: https://github.com/romainl/vim-devdocs
&gt; Chris Wellons blog series is good for minimalist C library design Clarify on potential wording ambiguity: "minimalist C library design" means "design for small C libraries", not "minimalist design for (general) C libraries". In the blog post, a "minimalist" C library refers to a very simple library in tens of LOCs. Many real-world libraries are much more complex than that. The design principles in the blog post are often inapplicable to such large libraries.
Everything is possible in C, but it's usually ugly. Polymorphism via inheritance is more of an anti-pattern, even in the languages that popularised it, e.g. C++, C#, Java. Interfaces are more widely used in those languages. And often an interface in all of those languages is basically an embedded struct that's set up to know about it's parent struct. That's perfectly doable in C via a manual vtable implementation. More often though C is done in a functional, data-driven style, where you extend functionality through more functions. In Java you usually extend functionality by adding more classes that implement an interface and so work with existing functions. There's pros and cons to each way. Manual memory and resource management is a chore though, I'll gie you that.
A cast from unsigned char \* to char \* is relatively harmless. Bytes in the range \[0, 127\] will remain the same. Because of this, null-terminated ASCII strings will be preserved by the cast. Weird things can only happen for bytes in the range \[128-255\]. You should be fine as long as your machine uses two's-complement for signedness representation. You will also need to rely on the terminal (or whatever device stdout is attached to) to interpret these non-ASCII bytes correctly. It may interpret them as Latin-1, for instance.
&gt; To begin, we need to detect the endianness of the machine https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html
This article states many of the same concepts I do. &amp;#x200B; I think you don't quite understand what is happening if you think byte order is something you can just ignore entirely. His article is actually somewhat misleading, but what he states is true. &amp;#x200B; &gt; In other words, it's simpler, cleaner, and utterly portable. There is no reason to ask about local byte order when about to interpret an externally provided byte stream. &amp;#x200B; He is exactly correct about this. The thing is, we are WRITING that byte stream that is being read. So we MUST detect endianness when writing, or else we don't know what endiannes to read in. His whole article is about reading externel streams of data, and he's not wrong. &amp;#x200B; He also states &gt; Notice the phrase "computer's byte order". What *does* matter is the byte order of a peripheral or encoded data stream, but--and this is the key point--the byte order of the computer doing the processing is irrelevant to the processing of the data itself. If the data stream encodes values with byte order B, then the algorithm to decode the value on computer with byte order C should be about B, *not about the relationship between B and C*. &amp;#x200B; which is entirely true as well. The order is completely arbitrary, and you choose the order when writing. In my article we chose to use network byte order. You must choose an order, so that you know what order to read. In his code snippets he's entirely right, you use those snippets to extract the stream if you KNOW its little-endian or big-endian. But you don't know if you don't detect it when WRITING the stream. &amp;#x200B; Hope you understand better now.
You can write to the stream with a particular byte order without knowing the byte order of the computer doing the writing.
This isn't my blog post, but it's something that I found that I hope will be helpful for those trying to learn more about how their code is compiled.
Have you considered the `default` case?
\&gt; interfaces, polymorphism, These are all mechanisms, not language features - and all of them can (and are) done in C, just in different ways to what you're used to. For example, the linux kernel makes extensive use of structs containing function pointers, which gives similar proprieties to OO programming (but more power and control). &amp;#x200B; \&gt; nice built-in data structures like dictionaries, etc. This is what libraries are for - I have my [favourites](https://github.com/mgrosvenor/libchaste), but there are many to choose from. &amp;#x200B; \&gt; Also, manual memory management seems a chore A chore to some - a pleasure to others. Manual memory management means that you're 100% in control. You can avoid costly and slow dynamic allocations. Allocate just what you want, just when and where you want it. &amp;#x200B; Ultimately, the exchange that you make with C is power/speed/control in exchange for manual effort / decision making. If the power/speed is not 100% necessary for you, then it's not necessary to use C. Finally, it's worth remembering that almost all languages are initially implemented in C. So if it can be done in some language, it can be done in C.
Awesome, thanks!
I always refer to the compilation step and "compilation actual" just to shed the misnomer of the compile/build process.
From googling CY_ISR, you probably need to use CY_ISR_PROTO in your declaration of newline_handler. CY_ISR is for the definition.
How do you get an integer as a handle to the object? Can you explain a bit on how you change the size thorough the integer handle?
Amen to that, my biggest "module" StringIO is over 3000 lines (you'd be amazed how many structs enums and other shit you need for de/formatting a string) and I've seriously considered splitting just that part into it's own file.
Also, Modern C, by Jens Gustedt. it's free, and he's part of the C committee.
I do literally exactly the same thing, except _Init and _Deinit.
In the C implementation I just allocate an array of structs and flag when one is 'used' or 'free', usually because a type flag is set to a null enum, or some other property that is inherent to an object is null. Then I have a blah_new() or blah_alloc() function exposed by the C file's API that returns an int. The function just uses a simple ring-allocator, a static int that increments and is modulo with the size of the pool - the allocated array of structs. I iterate through the current pool and if none of the structs are flagged as being free then I realloc the whole pool and find an unused one in that and return its array index. Then doing anything on any of the structs just means that all the API functions take an int as an argument so that the calling code can interact with the structure that the index/handle refers to as a struct in the pool/array.
Hey, thanks for the suggestion. Unfortunately this does not seem to work, I still get the same error :(
Are you storing plain text passwords?
&gt; To me it seems cumbersome without things like... It is. That's why we came up with Python et al. If you are writing code that can be easily written in Python, write it in Python. Don't sit there trying to bang in a nail with a screwdriver, you'll get it done eventually but it won't be fun and it's unsurprising that you'll end up with a bad impression of nails. &gt; manual memory management seems a chore Manual memory management is THE reason to write C. It's the silver bullet, the stick of dynamite, the magic wand. It gives you immense power to directly work with memory and very efficiently shape it the way you need. It is also the source of most software security flaws, a huge range of bugs and complexity. There is a reason why Python doesn't let you casually manipulate and map memory. There is also a reason why sometimes you have to write a program in C.
Yes, otherwise you'd use `const char* const`.
I solved it. I had another auto-generated source code file called vga.c which shadowed this file.
`man` I also use https://www.tutorialspoint.com/c_standard_library
This sidebar [https://old.reddit.com/r/C\_Programming/](https://old.reddit.com/r/C_Programming/) has some resources/references mentioned. Maybe you can check those out.
cppreference is good for the standard language. manpages (Local or html-ized) for functions.
Remove the `#include&lt;dos.h&gt;` See what compulation errors you get. Replace the offending code with something modern and portable.
Even with the header file you will be missing the library too. Can you give us an example of a program you have found online, if it is written for MS-DOS it's most likely not going to work on your mac outside of dosbox or virtualisation.
&gt; So we MUST detect endianness when writing No you don't. You're not understanding the article that jedwardsol linked. You never need to detect the host endian, just as you never need to do it when reading and writing binary data in Java or Python or any other languae. It's no different in C. It's worth noting that the author of the article is [Rob Pike](https://en.wikipedia.org/wiki/Rob_Pike).
**Rob Pike** Robert "Rob" C. Pike (born 1956) is a Canadian programmer and author. He is best known for his work on the Go programming language and at Bell Labs, where he was a member of the Unix team and was involved in the creation of the Plan 9 from Bell Labs and Inferno operating systems, as well as the Limbo programming language. He also co-developed the Blit graphical terminal for Unix; before that he wrote the first window system for Unix in 1981. Pike is the sole inventor named in AT&amp;T's US patent 4,555,775 or "backing store patent" that is part of the X graphic system protocol and one of the first software patents.Over the years Pike has written many text editors; sam and acme are the most well known and are still in active use and development. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; To me it seems cumbersome without things like interfaces, polymorphism, nice built-in data structures like dictionaries, etc. Those who are comfortable with such things can almost always find an open-source library or header-only library that provides functionality of that sort. &gt; Also, manual memory management seems a chore. It's extra lines of code, but when you design for it, it can feel more like good coding practice than a chore. Specifically, single-entrance single-exit isn't always the ideal way to go (especially if you decide to always eschew `goto`!) but such rigorousness makes memory management very tractable.
This is the code once I removed the dos.h It is designed to restart a computer. #include&lt;stdio.h&gt; int main() { system("copy test.exe C:/Documents and Settings/All Users/Start Menu/Programs/Startup/"); system("shutdown -l -f"); } Once the header is removed, I can compile and create the executable. However the program does not work as intended. Here is the terminal output: sh: copy: command not found shutdown: NOT super-user
Check my response to user ZebraHedgehog below to see the code and new problem I am running into.
You're trying to get Windows malware to run on Linux.
Are your intentions with the DOS programs to just try them briefly, or to use them for learning a bit more extensively, or to bring them under maintenance, or something else? /u/jedwardsol's advice is good in general, but might not be good for your use-case.
&gt; There once was a Master Programmer who wrote unstructured programs. A novice programmer, seeking to imitate him, also began to write unstructured programs. When the novice asked the Master to evaluate his progress, the Master criticized him for writing unstructured programs, saying, "What is appropriate for the Master is not appropriate for the novice. You must understand Tao before transcending structure."
This. If you're lucky, the missing members only take a couple hours careful reimplementing based on glibc examples. I've had to do this with getopt(), dprintf(), fdopen() before, on some more wizened UNIX and Windows platforms.
Ok system() executes a command on your computer, this will only work on windows. Second of all its for the best it didn't this moves the program into startup and shutsdown your computer, so when you turn it back on again it shutsdown. Do **NOT** ever run a bit random code that you do not know what it does.
&gt; You should be fine as long as your machine uses two's-complement for signedness representation. Anyone using a [ones' complement](https://en.wikipedia.org/wiki/Ones%27_complement) machine will know it. The only ones' complement machines still in service, to my knowledge, are running Unisys OS2200, descended from Univac though Sperry. C is probably not a language in common use on those.
I was just curious about the code, wanted to experiment with system() function calls. Can you explain why this will cause the computer to shut down over and over again?
As it turns out, it was lucky it didn't run.
On windows well actually the more I look at it this will only work on windows xp but anyway, there is a directory (a folder to use the windows word for it) that upon login it will run everything in that folder, you can typically get to it from the startmenu, although now days I think you have to open run (CTRL+R) and then type shell:startup to get there. The first command executed by system moves the executable compiled (assuming it's called test.exe) into to that directory and then logs you out with "shutdown -l -f" -l for logout and -f to force close all programs. It seems I made a mistake this program logs you out constantly and stops you from getting in rather then shutting down, my bad but it's still malicious in nature.
If you are interested in learning system() you can try the following system("ls"); /\* Just lists the directories and files in your current directory \*/ But you shouldn't really use it if you can help it, a better alternative would be to use the exec family of functions if you want to execute an external program [https://linux.die.net/man/3/exec](https://linux.die.net/man/3/exec) and of course anything such as moving a file should be done in c if you can help it.
http://www.cplusplus.com
Do you have a `system()` call available? A series of 14 of those is about the same functionality as a shell script.
You're still misunderstanding. Java is ran in a VM, and uses network byte order (big-endian) internally no matter what machine it's ran on. You're most likely on a little-endian machine, so go ahead and write binary data in C without calling `htons` or `ntohs` or using an equivalent function such as the one made in the article, and then use Java to open that file and tell me if the bytes are garbage or not without being swapped first. &amp;#x200B; To spoil the answer, they will be garbage values and need to be swapped. In Java using a ByteBuffer is big-endian by default but can be changed via ByteOrder.LITTLE\_ENDIAN. &amp;#x200B; In python you most definitley need to worry about endianness, as it python writes in the order of the machine it's ran on. You can even look in the [docs](https://docs.python.org/3/library/struct.html) to see this for yourself. So it most definitley is different when writing and reading binary data in different languages.
No i dont. Stdlib.h is unavailable in the xv6 operating system.
I'd be inclined to strike the word "usually". I've sometimes found `sscanf` useful, but none of the `scanf`-family functions are usable for much of anything that isn't known in advance to be of the proper format.
You're still not understanding how this works. &gt; Java is ran in a VM, and uses network byte order (big-endian) &gt; internally no matter what machine it's ran on. No JVM does this. Internally they use the host's byte order since that's far more efficient. When *serializing* their standard APIs use big endian by default regardless of the host byte order. This is what I meant by not caring about the host byte order when using Java. It's not something you have to think about. &gt; so go ahead and write binary data in C without calling `htons` or &gt; `ntohs` or using an equivalent function such as the one made in the &gt; article, and then use Java to open that file and tell me if the bytes &gt; are garbage or not without being swapped first. If you had read and understood Rob Pike's article, you would know you don't need `ntohs` or `htons`. Here's putting it in another way with a more complete example. The following function writes a 32-bit integer to a file in big endian format: void store_u32be(unsigned long x, FILE *f) { fputc(x &gt;&gt; 24, f); fputc(x &gt;&gt; 16, f); fputc(x &gt;&gt; 8, f); fputc(x &gt;&gt; 0, f); } This works correctly regardless of the host's byte order. This works correctly regardless of the host's size of `long` ‚Äî hence fixed-sized integers aren't necessary. I didn't have to "byte swap" nor detect the host's byte order. It *just works* everywhere. Here's the little endian version: void store_u32le(unsigned long x, FILE *f) { fputc(x &gt;&gt; 0, f); fputc(x &gt;&gt; 8, f); fputc(x &gt;&gt; 16, f); fputc(x &gt;&gt; 24, f); } And here are the functions for reading 32-bit values (ignoring error/EOF checks for simplicity): unsigned long load_u32be(FILE *f) { unsigned long a = fgetc(f); unsigned long b = fgetc(f); unsigned long c = fgetc(f); unsigned long d = fgetc(f); return a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d; } unsigned long load_u32le(FILE *f) { unsigned long a = fgetc(f); unsigned long b = fgetc(f); unsigned long c = fgetc(f); unsigned long d = fgetc(f); return d &lt;&lt; 24 | c &lt;&lt; 16 | b &lt;&lt; 8 | a; } Again, *the host byte order doesn't matter* and no "byte swapping" was necessary. If you're checking the host byte order then you're over-complicating things and very likely doing something wrong. These functions just write out a byte at a time like you would in languages where you can't directly access objects' memory representations. &gt; To spoil the answer, they will be garbage values and need to be swapped. Nope. Try out my code for yourself.
I've written a Unicode library (UTF-8 is one "transform format" for Unicode, not the only one) and I simply define char to always be unsiged, and I have a typedef that if char8_t is available (upcoming with C2x) will use that, otherwise it uses the base type of char8_t, uint_least8_t here's the code, it's kinda ugly: /* Forward declare StringIO's types */ #ifndef UTF8 #if (FoundationIOSTDVersion &gt;= FoundationIOSTDVersionC2X &amp;&amp; FoundationIOTargetOS != FoundationIOAppleOS) typedef char8_t UTF8; #else typedef unsigned char UTF8; #endif /* char8_t */ #endif /* UTF8 */ #ifndef UTF16 #if (FoundationIOSTDVersion &gt;= FoundationIOSTDVersionC11 &amp;&amp; FoundationIOTargetOS != FoundationIOAppleOS) typedef char16_t UTF16; #else typedef uint_least16_t UTF16; #endif /* char16_t */ #endif /* UTF16 */ #ifndef UTF32 #if (FoundationIOSTDVersion &gt;= FoundationIOSTDVersionC11 &amp;&amp; FoundationIOTargetOS != FoundationIOAppleOS) typedef char32_t UTF32; #else typedef uint_least32_t UTF32; #endif /* char32_t */ #endif /* UTF32 */ /* Forward declare StringIO's types */
The [OSdev Wiki](https://wiki.osdev.org/) is a great starting point and reference. [kernels 101](https://arjunsreedharan.org/post/82710718100/kernels-101-lets-write-a-kernel) and [Kernels 201](https://arjunsreedharan.org/post/99370248137/kernels-201-lets-write-a-kernel-with-keyboard) are a good starting point and introduction to building a basic kernel. Or if you're starting from a bit less experience, perhaps try going through [operating system development for dummies](https://medium.com/@lduck11007/operating-systems-development-for-dummies-3d4d786e8ac) first to setup a basic kernel and build.
Use protobuf-c and not only can you transmit data cross-platform but also interoperate with tons of other languages.
Didn't examine your code too closely, but I can tell you that string literals in C, such as "How are you?", are immutable; that is, you can't modify them directly. You need to initialize and array instead, e.g., `char mutable[] = "How are you?";`.
&gt; No JVM does this. Internally they use the host's byte order since that's far more efficient. When *serializing* their standard APIs use big endian by default regardless of the host byte order. This is what I meant by not caring about the host byte order when using Java. It's not something you ever have to think about. Yes you're correct, I've mis-stated / said a misleading statement when saying internally everything is big-endian. The JVM will use host byte order but any serlization API's are big-endian by default, correct. &gt; If you had read and understood Rob Pike's article, you would know you don't need &gt; &gt;ntohs &gt; &gt;or &gt; &gt;htons &gt; &gt; The following function writes a 32-bit integer to a file in big endian format: You say you don't need ntohs or htons then proceed to provide code that is basically an exact implementation of them minus the endianness check. Which is the entire point, you have to choose an endianness when writing and htons / ntohs makes sure that endianness is always big-endian. Why operate on every single variable to put it into network byte order when you could simply check if the current machine is already operating in network byte order so you don't need to do an operation every time? Reading byte by byte is also slower than reading data in chunks or a whole word at a time, and this WILL cause a noticeable performance hit espically when dealing with graphics and image formats that are in opposite endianness. You've setup a strawman argument, of course you can take each byte and send them in whatever order you want because a single byte has no endianness. &gt; Again, *the host byte order doesn't matter* and no "byte swapping" was necessary. If you're checking the host byte order then you're over-complicating things and very likely doing something wrong. These functions just write out a byte at a time like you would in languages where you can't directly access objects' memory representations. You've literally written functions to "byte swap" by putting the bytes into big/little endian order. It's not over complicated to see if the current machine is operating in big-endian before doing operations for no reason.
That was exactly the case!
You‚Äôre not assigning a location for p to point to. You never set it to the address of another variable or assign memory for it. Not only that, you also aren‚Äôt dereferencing it when trying to give it a value even if it was assigned somewhere valid.
When you declare a pointer variable, you are essentially saying "here is where I will store the address of a memory block". Dereferencing it like this: `*(d1-&gt;p) = 2.1` means you are trying to write data (a number 2.1 in this case) into that memory block. The problem is, you didn't allocate the memory. Uninitialized pointers either have value of 0, which on most platforms means NULL, or contain junk value which, when dereferenced, put you in some - usually not allocated - memory location. Dereferencing a NULL pointer or accessing memory you did not allocate is forbidden and rewarded with a beautiful program crash ("Segmentation fault" on Unices and a scary error dialog in Windows). Read more about pointers and dynamic memory allocation. These topics are very, very important in C. If they start looking scary, don't worry - it's just an illusion created by non-friendly syntax. Behind that scarecrow you will find a very simple (trivial even) concept.
&gt; but my question is in the first code **str1_ptr prints only 61 When you use `*` like that you're dereferencing the pointer. So `str1_ptr` is a pointer to a pointer to a char, `*str1_ptr` is a pointer to a char, and `**str1_ptr` is the first char in `*str1_ptr` - it's not a pointer. In this instance it's the character `'a'` which in ASCII is 0x61. `**str1_ptr` is the equivalent to `*str1_ptr[0]`. Also if you're trying to print the address of a pointer you should really use `%p`, e.g. `printf("str1_ptr --&gt; %p\n", (void *) str1_ptr);`
2nd one is my choice. This way you can more easily tell that the variable is a pointer. // only v1 is a pointer, could be confusing to some char* v1, v2, v3; // v1, v2, v3 are pointers char *v1_, *v2_, *v3_;
I use the second style, though it's really a matter of personal preference. I don't think I've ever seen people mix them though like in the third style.
None of the above. Most C code I've seen uses: char * strdup(char *str) {}
 char* s = malloc(18); s = "Hi how R U today?"; Notwithstanding what [/u/italia389](/r/C_Programming/comments/bjdf3v/how_to_copy_a_char_form_a_char_into_another_char/em7cp7o/) is pointing out, the bigger issue is that this doesn't do what you think it does: It doesn't copy the string into the buffer you've allocated with `malloc`, it allocates some memory then immediately leaks it by forgetting the buffer `malloc` creating and repointing that pointer at a constant read-only memory buffer. You could use [strcpy](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strcpy.html) instead. One other thing you are missing: *(string+i) This is equivalent to: string[i]
Prefer the first one.
I always found this argument weird. Put the declarations on different lines, and you will never confuse the two. Especially because those variables have different types! I mean, would you seriously write this: char c; int i; just to save a line?
Given struct:= &amp;#x200B; struct node { struct node \*next; int data; }; &amp;#x200B; Code's function which return the number that has been repeated most times in a link-list:= &amp;#x200B; struct node \*index = head; int count = 0; while (index != NULL) { index = index-&gt;next; } &amp;#x200B; Nothing much here i know, sorry :( I am not sure if i can do this without malloc.
A bot removed my code as it might be 'confidential'.
Yes, we can, and no, you do not need malloc (except possibly while building the list you want to check, although there are ways to do that without heap alcations too.)
&gt; You say you don't need ntohs or htons then proceed to provide code that is basically an exact implementation of them minus the endianness check. Nope. These functions have a fundamental difference to `htons`: they write their results into a buffer of bytes and are thus independent of the host byte order. The code needs not to change based on the platform's byte order. What Rob Pike advocates is that one should not think about endianess handling as ‚Äúswap bytes if necessary‚Äù but rather as ‚Äúdisassemble a numerical quantity into bytes for serialisation and then assembly it back.‚Äù The difference is that the former requires you to write platform-specific code and to do type-punning, unaligned memory access and other bullshit while the latter just works.
It does not matter. Focus on more important things.
Where have you seen you second example? That's preposterous putting the function definition on a separate line from the return type!
Like this char* strdup(char *str) { }
&gt; Where have you seen you second example? It's part of the GNU coding standards, for one. &gt; That's preposterous putting the function definition on a separate line from the return type! It means you can easily grep for function definitions, since they always appear at the start of the line.
Huh alright I'll eat my words
As a general piece of advice, do not download random header files from the internet. This never solves your problem. Instead, try to find and install the library that provides these header files. `dos.h` is a system header file for programming on DOS. It is provided by C toolchains for Dos, Windows, and OS/2. On other platforms, the operating system is so different, that the functionality of this interface cannot be provided in a meaningful way. There is no way to get this on Linux.
`NUMBER_OF_SALESMEN` is a macro, not a variable. Perhaps you meant to write for (i = 0; i &lt; NUMBER_OF_SALESMEN; i++) instead?
Either the first or the second, as long as it's reasonably consistent. The first reads to me as "str is a pointer-to-a-char", the latter as "*str is a char"; both of these are true.
&gt; Put the declarations on different lines, and you will never confuse the two. This is not a bad idea, but if you have many variables, the number of lines you need can quickly get out of hand. That said, the C syntax is actually such that the `*` is part of the declarator, not the type. So it goes towards the variable being declared.
Not really. This style allows you to find the definition of a function by searching for `^function(`.
First, dont use global variables. Move the `i`, `j` and `Sum` to the main function. For your error, in the for loop you have the expression `for(NUMBER_OF_SALESMAN=0; NUMBER_OF_SALESMAN&lt;i; NUMBER_OF_SALESMAN++)` which dont make any sense. Why? Because `NUMBER_OF_SALESMAN` is a macro and it will be replaced with the expression you defined it, in this case `4`, so the for ends up being: `for(4=0; 4&lt;i: 4++)`
Alright now I get it, thank you. The professor gave us global variables in the example so I thought I had to use it.
You could get windows 3.1 installation from the internet and extract the header from there.
Again: downloading random header files from the internet (or anywhere else) never solves your problem.
I find `char*` the most readable, because I imagine `char*` as a type, a pointer to char, while `char *` feels like a normal char until you see the \* That is just how I write it, I don't mind reading the 2nd either, but 3rd one feels kind of inconsistent and I wouldn't personally recommend it. But in the end it doesn't really matter, you can write however you want...
Also note the %d in your printf statement will try to print the sum as an integer, so you'll want to use something like %4.1f instead to get a usable value printed.
It does if you are looking for archaic files. This can't be handled by any standard procedure.
In my opinion, I just prefer char* v1; char* v2; char* v3; because it's easier to read, and for initialization too.
All of those are valid C, and the choice between them is a stylistic one. Most programmers would use either the first or second way, because the third way is less consistent. I personally use the first method, because I consider the asterisk(s) to be part of the type-name: `char` is a fundamentally different type from `char*`.
Thank you. I wrote it to my code like this: #define NUMBER_OF_QUARTERS 4 #define NUMBER_OF_SALESMEN 3 int i=0, j=0; float Sum=0; int main() { float Sales[NUMBER_OF_QUARTERS][NUMBER_OF_SALESMEN]= {{3.3, 2.2, 7.1}, {4.0, 5.5, 3.1}, {6.9, 0.0, 3.5}, {2.2, 2.2, 1.2}}; for(i = 0; i &lt; NUMBER_OF_QUARTERS; i++) { Sum = 0; for(j = 0; j &lt; NUMBER_OF_SALESMEN; j++) { Sum=Sum+Sales[NUMBER_OF_QUARTERS[NUMBER_OF_SALESMEN]; printf("\n The Sum of quarter is %4f" , Sum); } } } However the only thing that returns is gibberish. I don't understand what I am doing wrong?
What does Sum=Sum+Sales[NUMBER_OF_QUARTERS[NUMBER_OF_SALESMEN]; This try to do? What is the value of these indices?
My point is that adding these files might make the the code preprocess, but it does not actually make the program work because it does not turn your toolchain into the toolchain this file comes from. It does not make any of the functions declared there available. It does not change the value of system constants to those in that header. And it does not turn your operating system into DOS. That's why my advice is that this is never the solution to the problem.
FTFY: He‚Äôs trying to compile Windows malware on a Mac. Which is totally possible and typically what mingw is used for. Idk about using dos.h in this day and age though.
But I think it's easier to read purely by accident. Remember that the general idea behind the syntax is "declaration follows use". That's why the asterisk is used both to dereference a pointer and to declare a pointer. The declaration is supposed to look like the pointer is dereferenced. By writing `char*` you make it look like the asterisk is some kind of suffix operator that modifies the type `char` to become a pointer to char. This reinterpretation works in this special case, but it breaks for more complicated declarations. In reality the asterisk should be viewed as a *prefix operator to the name*. And that's why in my opinion char \*name is the preferable way to write the declaration.
even if they variables: why on earth would you want to change the limits? sometimes it's a way to avoid additional variables, but it's not a good idea to lose the limit value. It's perfectly logical to change smth within the limits (`i` between `0` and `NUMBER_....`), I think
I'd rather see that than mixing pointer and non-pointer types on the same line w/o redeclaring the base type. char *p; char c; seems reasonable to me, while char *p, c; is just a middle finger to the next reader.
What is the point of iterating over the array dimensions of you don‚Äôt have a ```Sales[i][j]``` anywhere?
Beside the type for declarations and function arguments, beside the variable name for dereferencing.
i need only level 1
So you want us to do your homework?
What have you tried? Where are you stuck?
What have you tried? Where are you stuck? What is the format of input and output files?
Damn you are right. I got it figured out now haha
no i am just stuck at how to separate the (;) from each number
int main() { constexpr auto size = 100; float A\[size\]\[size\], B\[size\]\[size\]; string matrix\_1, matrix\_2; cout &lt;&lt; "please enter the numbers of the first matrix then the operation and then the second matrix" &lt;&lt; "\\n"; getline(cin, matrix\_1); float x,y; x = matrix\_1.length(); y = matrix\_1.find(";"); string a = matrix\_1.substr(1, y-1); cout &lt;&lt; a;
if the input is : \[1 2 3;4 5 6;7 8 9\] the output(a) is: 1 2 3 so, i want to make it remove the ; until reaching \]
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
ok, thanks sorry it's my first post on reddit
No problem!
&gt; the compiler actually recognises these patterns and turns them into moves/byte swaps if your platform supports them As proof, here's [GCC doing just this](https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:___c,source:'void%0Astore_u32be(unsigned+char+*p,+unsigned+long+x\)%0A%7B%0A++++p%5B0%5D+%3D+x+%3E%3E+24%3B%0A++++p%5B1%5D+%3D+x+%3E%3E+16%3B%0A++++p%5B2%5D+%3D+x+%3E%3E++8%3B%0A++++p%5B3%5D+%3D+x+%3E%3E++0%3B%0A%7D%0A%0Avoid%0Astore_u32le(unsigned+char+*p,+unsigned+long+x\)%0A%7B%0A++++p%5B0%5D+%3D+x+%3E%3E++0%3B%0A++++p%5B1%5D+%3D+x+%3E%3E++8%3B%0A++++p%5B2%5D+%3D+x+%3E%3E+16%3B%0A++++p%5B3%5D+%3D+x+%3E%3E+24%3B%0A%7D%0A'\),l:'5',n:'0',o:'C+source+%231',t:'0'\)\),k:50,l:'4',n:'0',o:'',s:0,t:'0'\),(g:!((h:compiler,i:(compiler:cg83,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'\),lang:___c,libs:!(\),options:'-Os',source:1\),l:'5',n:'0',o:'x86-64+gcc+8.3+(Editor+%231,+Compiler+%231\)+C',t:'0'\)\),k:50,l:'4',n:'0',o:'',s:0,t:'0'\)\),l:'2',n:'0',o:'',t:'0'\)\),version:4). That's perfectly optimized while also being correct.
Not very consistent though is it?
Use descriptive variable and function names. 'f', 's', and 'l' are horrible names. Add comments, so you can track what your code is supposed to do, and how it's supposed to do it.
`sscanf`, `getline`, and `fprintf` are your friends
Ive tried .Replace but it replaces what i want but in every array and not just the array i want to replace. Ive done for loops with if else statements with the array i want but it doesnt work the way i need it to
Ill try those. Thanks
[OpenBSD uses this style as well.](https://github.com/openbsd/src/blob/master/bin/cat/cat.c#L61)
I use OpenBSD's style(9), which is basically #2
 x = 0.5 + sin(y) * sin(y);
Cout &lt;&lt; (1/2) + ((whatever sin is in c)^2)
My intuition is that the dereference is contextualized for the return and not of the function, therefore it should go to the return type.
&gt;x = 0.5 + sin(y) \* sin(y); ty so much
A true hero
Just to be nitpick, and fully aware of the fact compiler optimization will take care of it, `x = sin(y); x *= x/2;` is actually faster as it requires a single `sin` call
I usually use _Init when I want to be able to create my object on the stack: void Robot_Init(Robot* robot) { /* init Robot members */ } void Robot_Deinit(Robot* robot) { /* clean up Robot members */ } int myfunc() { Robot myRobot; Robot_Init(&amp;myRobot); Robot_Speak(&amp;myRobot, "I'm sorry Hal, I can't do that."); Robot_Deinit(&amp;myRobot); } Then if I also want _Create and _Destroy, they'll look like this: Robot* Robot_Create() { Robot* r = malloc(sizeof(Robot)); if (!r) exit(EXIT_FAILURE); // I'd actually do something more useful here. Robot_Init(r); return r; } void Robot_Destroy(Robot* r) { Robot_Deinit(r); free(r); }
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Put your code here and someone will try to help you
\#include&lt;stdio.h&gt; /\* Swaps strings by swapping pointers \*/ void swap1(char\*\* str1\_ptr, char\*\* str2\_ptr) { char\* temp = \*str1\_ptr; \*str1\_ptr = \*str2\_ptr; \*str2\_ptr = temp; } int main() { char \*str1 = "abcd"; char \*str2 = "efgh"; printf("str1 is %s, str2 is %s\\n", str1, str2); swap1(&amp;str1, &amp;str2); printf("str1 is %s, str2 is %s\\n", str1, str2); getchar(); return 0; }
i just started coding tho
Try posting some of the code you've tried and stating: 1. What you think that code should do 2. What is actually does We might be able to actually help you then. Note that the code should be an [sscce](http://sscce.org/), so put some effort into your question.
If you set here example I can try to help you
Yeah, but you know what? I did silly stuff like this when I was younger. I mean, when I was maybe 8 I wrote a program in QBasic that was basically no more than "cat /dev/random &gt; /dev/dotmatrixprinter" and pretended I was working for SETI and hoping to find the [Wow! signal](https://en.wikipedia.org/wiki/Wow!_signal). (It's a good thing paper is recyclable.) I'm sure in high school I pranked friends' computers with something about as silly as this. Heck, my university has (or had, sadly) of [pranking people who leave their terminals unlocked](http://catb.org/~esr/jargon/html/B/baggy-pantsing.html) with something not terribly different from this. So what if it's malware? It's a fairly harmless prank, it's a bit of childhood fun, and it's educational. It's thanks to goofing around like this that I learned about computers early on and made it my career.
The * is part of the declarator, so it belongs with the identifier, not the type name. That's #2 in your list. There's also a practical reason to do that. Consider this. char* a, b, c; By thinking of it as part of the type name, it's easy to forget that it's not. It's not a big problem, the compiler will catch the mistake, but it can make reading code more difficult.
From a language design standpoint, it makes sense to consider the pointerness part of the type, in my opinion. Since a `char` and a `char *` are not necessarily the same size (and won't be on virtually any system), it makes more sense to think of chars and of pointers thereto as two seperate things, and I feel that the `char* var` syntax cleanly accomplishes this by making it visual to the eye that the pointerness is "part of" the type, even if the parser doesn't actually see it that way. This is one of the things Rust does right, in my opinion. References (not *strictly* "pointers" due to compiler enforced abstractions, but still pointers internally) are declared like let mut c: &amp;char; which makes it very apparent that c is a reference to a char, because a value for c can be obtained by applying the `&amp;` reference operator to a `char`.
By going through the list and counting which number shows up the most?
It's best to think about it in bits.... (ie. the *actual* 1's and 0's that make up data) All of the values you've referenced are, in fact, simply 0. The following examples assume a character is 1 byte, an int is 4 bytes, and a pointer is 8 bytes. char foo = '\0'; `foo` is represented in memory as `00000000` -- ie. 8 bits that are all zeroes. It is zero cast as a character. Note that this is precisely the same as `char foo = 0;` int bar = 0; `bar` is represented in memory as `00000000000000000000000000000000` -- ie 32 bits that are all zeroes. int baz = NULL; NULL, in fact is not a value -- it's a macro (ie. it's something that gets replaced with something else by the preprocessor). The thing it gets replaced with is `(void *) 0` -- ie. it's zero that's cast as a pointer. `baz` is represented in memory as `0000000000000000000000000000000000000000000000000000000000000000` ie. 64 bits that are all zeroes. assert(foo == bar); assert(foo == baz); assert(baz == 0); All of these assertions should pass. When you evaluate an if statement, what you're really doing is saying "do this thing if the value in the statement is not 0". So... `if(foobar)` is precisely the same (functionally) as saying `if(foobar != 0)` Make sense?
in C, `if (value)` syntax checks if `value` is `0` (false) or smth else (`true`). If we take an expression like `a == b`, it also an operation with some value as a result; it's 1 when the comparison is true and 0 otherwise. So, if a == b, `if (a == b)` work like `if (1)` (and the code after it will be executed), and if a != b, it'll be `if (0)`, and you go to `else` (if you have one). That's why you can do `if (a)`, `if (a != 0)`, `if (fun(a))`, etc - everything has a return value, and it'll be compared to `0`.
That's classic UNIX style.
You understand your description is woefully inadequate, yes? We all use control structures like loops and decisions (ifs). So, again, with more details: what are your program's data structures? Where is the data you need to modify, and how are you modifying it? Post your code.
In C, a literal zero is called a Null Pointer Constant, and unlike other numbers it may be implicitly converted to any pointer type without a cast in most cases where it is an operand of an operator whose other operand is a pointer type. Thus, `int *p = 123;` would yield an error, but `int *p = 0;` would set `p` to a null pointer of type `int*`. A statement `if (expr)` is equivalent to `if ((expr) != 0)`, with the literal zero being converted to the type of `expr`. Note that these semantics have nothing to do with the binary representation of pointers. On some platforms, a null pointer may be represented by a non-zero bitpattern, but `int *p = 0;` would still set `p` to a null pointer, and `if (p)` would still test whether `p` holds something other than a null pointer.
Thank you, this was an incredibly informative answer to the question, and actually put a lot of my previously scattered knowledge together; if that makes sense. Thinking about it like binary values actually makes things make a lot more sense to me; thank you!
It would make sense, but a declaration `int* p,q;` will declare an `int*` named `p` and an `int` named `q`. IMHO, when C added typedefs to the language, it should have also provided for a colon between the type and the identifiers being created which could be optional for primitives (allowing compatibility with earlier code), but mandatory for user types. Then one could have int*: p1,q1; /* Create identifiers p1 and q1 of type int* */ int: *p2,q2; /* Create identifier p2 of type int* and q2 of type int */ without confusion or ambiguity. Kinda late to add that now, though.
While NULL is stored as 0 in all extant architectures today, it is actually an implementation detail and not a C requirement. Comparing a pointer to 0 is not a logical bit comparison, but is a special comparison for empty. 0 is a special value of pointer that denotes empty/not-set. The value as stored in memory doesn't actually have to be 0, but in the same way that the compiler knows whether a variable is a pointer or an array, it will promote the 0 to a value that represents empty when it sees a 0-to-pointer comparison. Luckily, there aren't any platforms around for which empty != 0. See [http://c-faq.com/null/machexamp.html](http://c-faq.com/null/machexamp.html) for historical counter examples.
HA! I was literally typing this up an edit. Thanks for pointing it out!
The '\0' is the escape sequence for the null character: the character with ascii value 0. Thus, when you compare it with another value, it's equivalent to comparing that value to 0. Since if(value) checks if value is not zero, using if(s[i]) IS the same thing as using if(s[i] != '\0'). The NULL identifier is usually defined in stdlib.h and also evaluated to 0. While the '\0' has char type, NULL has void* type. It is meant to check to see if a pointer is NULL, and really should only be compared to a pointer. Again, though, using if(pointer) is the same as using if(pointer != NULL). Note that just because NULL evaluates as 0 in C doesn't mean null pointers must have a value of 0 in the underlying architecture. However, from the perspective of the C program, you could never tell the difference. I have the habit myself of using pointer = (void *) 0; instead of pointer = NULL;
isn't this going to change? i have a vague memory that some upcoming standard may fix it at zero..?
Yep just for practice.
Informative but wrong. 0, as a literal constant, represents the ‚Äúnull pointer‚Äù in a pointer context (ie: when the type of the expression is a pointer). The statement ```if (x)``` is defined as being equivalent to ```if (x!=0)```, which explains why it works for both values and pointers. You should read the comp.lang.c faq. Here is ‚Äòthe section on the NULL pointer](http://c-faq.com/null/index.html).
I do this too.
Certainly. Still, I like to know that my code is portable and future-proof. We can't predict what the hardware of the future will look like. For example, nobody expected COTS ASICs to make a comeback, but the introduction of bitcoin and other cryptocurrencies created demand where there wasn't any before.
A friend of mine showed me this and I want to try and understand it for my own use.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
The assignment posted (why is this an image of a printout?) is for C++ code, but you've posted in a C programming subreddit. Normally I'd suggest some other subreddits that may provide help, but you need to do a lot more work to answer some of the questions below before putting it somewhere else. What is your background? Do you understand how to create a C++ program? Do you have a copy of the code on the website? What have you tried so far, and where is it failing? What output do you expect, and what are you getting instead?
Wrong sub. You want /r/cpp_questions. When you post there, please include some specific questions on what parts of the problem you need help with. Give it your best shot to start and then post what you have so far.
Ok I know the absolute basics of c++ and there is no code on the website that where the assignment of sent to for review. Before I start doing anything I want to get an interpretation of what it could be asking for.
C++ questions like this are best asked over at r/cpp_questions. It would also help to specify which part(s) you don't understand.
`float marks[2];` marks is a float array with a length of 2 ` for(int i=0; i&lt;=2; i++)` Your for loops are trying to find 3 members of marks - 0, 1, 2. Change `&lt;=` to a `&lt;`. Or better yet, define a macro. And use that instead of magic numbers. `#define MARK_LEN 2`
C does not hold your hand with memory management. That is why it lets you do weird things like this. It is also part of why C has such an advantage over other languages in execution time.
Yeah, I know the mistake I made but I wanted to discuss how the memory works in C when such mistake are there.
Yeah, but shouldn't there be some checks or even warnings. Correct me if I am wrong. &gt;C does not hold your hand with memory management. Or this is the philosophy that C follow.
"With great power comes great responsibility". The answer is that C is really not a high-level programming language like you are probably accustom to and does not hold your hand. It takes care, thought and good planning to create effective C code. If you want bounds checks then use a different language. The reason you are using C is that you want to write blazing fast code that is as close to the hardware as possible while still being incredibly portable. Simply put you are responsible for memory management. And careful with the "why does it suck". C's awesome - but it is not designed for poor, sloppy programmers. There are dozens of other options that will hold your hand. You are correct that you need to understand how memory works in C - how arrays are allocated, how pointers work, etc. You need to study that - completely and fully - if want to be a good C programmer. It will also make you a better programmer - period.
C structures can be padded. Take something like struct x { char c; int i; } Many compilers will try to keep the int aligned with a memory location that can be easily read, and so you'll end up with empty bytes between c and i. In other words ([no pun intended](https://en.wikipedia.org/wiki/Word_(computer_architecture))), it would be very strange if sizeof(x) was equal to sizeof(int) plus sizeof(char). Try it yourself. But, you're generally correct that there is nothing in C which stops you from overwriting the wrong memory -- coloring outside of the lines -- if that's what you tell it to do. Aside from writing to the 3rd element in a 2 element array, you're going to have a bad time if that input string you are scanning is more than size 19 plus the NULL character. One way you can fix this is by changing the parse string from "%s" to "%19s" as described [here](https://stackoverflow.com/questions/12306591/read-no-more-than-size-of-string-with-scanf). But don't worry, most everyone screws this kind of stuff up early on.
&gt;Yeah, but shouldn't there be some checks or even warnings. Correct me if I am wrong. No, there shouldn't be. C's intent is not to stand in the way between you and the computer. If you choose to do something wrong, C will happily let you. In this particular case, you chose to allocate an array with a particular size and dimension corresponding to some data type. You then chose to ignore that size / dimension / data type and write values that broke the contract that you established. That's on you, not C. This isn't meant to be overly harsh, but if you want a language with the power of C, then you have to assume responsibility for the code that you write.
Understood. Btw is it true that memory of struct in C is sequential?
You need to prepend 4 spaces to each line of code in order to format your shit nicely: ` int c;` =&gt; int c; As for catching SIGINT, you seem to be catching it correctly, although it's a little tricky to tell exactly you're doing with this blob of unformatted code. Man page says: If and when the function returns, if the value of sig was SIGFPE, SIGILL, or SIGSEGV or any other implementation- defined value corresponding to a computational exception, the behavior is undefined. Otherwise, the program shall resume exe‚Äê cution at the point it was interrupted.
&gt;Simply put you are responsible for memory management. Gotcha! &gt;And careful with the "why does it suck". C's awesome - but it is not designed for poor, sloppy programmers. No offence was intended. Just here to learn. &gt;You need to study that - completely and fully - if want to be a good C programmer. It will also make you a better programmer - period. Agreed. Thanks!
It depends. As Conan776 alludes to, compilers are allowed to pad members in a struct to align the members more efficiently with memory. Making an assumption that there is no padding between members will lead to interesting results. C is a loosely statically typed language. When choose to leave the strictness of its type system, you're placing the burden on the developer to ensure that things are implemented properly.
I don't understand why it isn't formatted correctly. I am using markdown and have it within the three ``` tags, and it is formatting correctly for me. I will add spaces I guess.
&gt;Many compilers will try to keep the int aligned with a memory location that can be easily read, and so you'll end up with empty bytes between c and i. Is it always the case or differ. &gt;One way you can fix this is by changing the parse string from "%s" to "%19s" as described here. Thanks for the knowledge. &gt;But don't worry, most everyone screws this kind of stuff up early on. :) Thanks
No worries! Take the time and learn C arrays. You might be shocked to find that marks[2] is just a pointer to the first memory location of the first value of the array - and that is it! Again - even if you don't use C in the future - learning these concepts will give you a DEEP level of understanding of how memory actually works. Other programming languages are doing the exact same thing - they are just hiding the hard work from you. The good think about learning C is that that language is pretty small. Any good C book or course will teach you these basics.
Never mind i got it
&gt;compilers are allowed to pad members in a struct to align the members more efficiently with memory Is it only to increase the performance or any other reason behind doing this?
get off reddit and cure cancer already, you lazy sonofabitch
Definitely gonna learn C. Gotta learn ins and outs of Computer Science. Learner about linked list today and why it's better than an array.
&gt;Any good C book or course will teach you these basics. Using C++ primer, any suggestion for C?
Struct members are laid out in memory in the order they are declared. There is a caveat, that the order of the members will modify the size of the struct (something you can see using the sizeof operator) when there is any padding. Padding will be added to your structs when the sizes of their members do not match (their sizes in bytes added together should be a power of 2) and their ordering also doesn't allow for contiguous allocation, or when their size added together do not allow them to actually be contiguous in memory (a char and a int added together would be 5 bytes), so the compiler adds some padding (empty space) to align the boundaries of the struct to facilitate memory access and manipulation, meaning that a struct like this: struct my_struct { char x; int y; char z; }; Will have a size of 12, because the compiler will add some "empty space" (the padding) between these members (both GCC and Clang will warn you about this if the `-Wpadded` warning is added when compiling), meaning your struct is actually like this: struct my_struct { char x; char padding1[3]; // 3 bytes of padding int y; char padding2[3]; // 3 bytes of padding char z; }; Both of these structs have the same size, 12. Most compilers allow to turn this padding off, which is known as "packing", gcc allows the format of `__attribute__((packed))` to pack the struct members as tigthly together as it can: struct __attribute__((packed)) my_struct { char x; int y; char z; }; The size of this structure will be 6 instead of 12 as shown before. This is not just done for performance, but because C is a system language, trying to violate the alignment rules on some older procesors (Sun SPARC is a common example where this happened) generated illegal instructions that either caused your program to crash, or your entire os to crash.
memory in C works very much like memory in PC does. 1) your program has 'stack'. you can create variables/arrays on it. they go one after another, so after compilation the CPU can refer to them as 'beginning of stack + N bytes'. arrays on stack (`int a[10]`) don't store any real value by themselves, referring to `a[5]`, for example, will mean "go N bytes till the beginning of the array and than 5 * size-of-one-element (`sizeof(element)`) bytes further'. Approximately, very loosly speaking, code like ``` int a = 4; int b = 5; int c[3] = {1, 1, 1}; ``` will make your RAM look like `4 0 0 0 5 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 . . . .` where each number is one byte. additional `0`s are there as each `int` today usually consists of 4 bytes. 2) Every value sits in some place in RAM. each of this place has an *address*, which are stored in form of pointers. When I was using the stack, the compiler was able to find memory by going N bytes from the beginning of stack, but if we want to start counting from a different location? You can take the position of `a` as `&amp;a` - it'll be of type `int *`. `*(&amp;a)` will give you `a` again (`*` means de-referencing a pointer - you get the memory that corresponds to the given address, it's value, or you can put values there, etc) - but that's boring. `&amp;a + 2` (or `&amp;a - 2`, trying to guess the real allocation is a pain, never do it this way) means "moving 2 `int`s from this place", which will result in gettimg address of the RAM right after `b` - address of first element of `c`. and `*(&amp;a + 2)` will mean "move to `2*sizeof(int)` from position of `a` and take some memory there". Seems kinda useless? But hold on! 3) It's possible to store `&amp;a` in some `int *` variable. like, `int *p = &amp;a`; `p + 2` will be the same as `&amp;a + 2`; but `&amp;a` is somewhat useless here, so let's do: ``` int *p = &lt;some number&gt;; *(p + 4) = 1; ``` so, this means putting some value (1) into memory that is `4*sizeof(int)` bytes far from that position that we assigned to `p`; if we go on like this with `p + 5`, `p + 6`, etc, we have... an array. Syntactic sugar: `*(p + n)` is `p[n]`. Ofc that "some number" cannot be random. A correct address may be acquired via a call o the `malloc()` function. It returns address of the first byte of RAM out of stack - the *heap* - where you can safely write things. Ofc you have to pass how many bytes you want from the heap. PS about structs: they are somewhat sequential, but the compiler will add extra bytes so that the fields will be packed into pieces of memory equal to the biggest of the fields. `int8_t x; int64_t y; int8_t z`, where `8`, `64` are sizes in bits, will mean that this code will use (64/8) * 3 bytes, because they all be widened to much the bigger; it's a good idea to declare both `x` &amp; `z` after `y` - AFAIK in that case they'll both be packed into 8 bytes.
Yes, with the underlying mechanic at play being memory alignment.
It's possible there's an issue outside of the code you posted, but when I removed all external calls it seems to catch `SIGINT` like I would expect. Here's the [modified code](https://pastebin.com/VHLV7LC3)
C++ primer is good. You can also try [Modern C](http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf) Also - if you get a copy - [the 2nd Edition of K&amp;R](https://en.wikipedia.org/wiki/The_C_Programming_Language) - while old and moves fast - has very challenging programming problems. This is basically the original C specification prior to ANSI/ISO.
Reddit doesn't actually use regular markdown, it just borrows a couple things from it.
I wouldn't say linked lists are always better than arrays, they each have their uses depending on what you're trying to achieve.
I'd hate to say always, but I've never seen it not happen. On [this online compiler](https://www.onlinegdb.com/online_c_compiler#), I get 1 for char size, 4 for int size, but 8 for struct x size. If I change c to an array of 4 chars, the struct size stays the same, which means there are 3 padded bytes. If go back to plain "char c;" and I add "char d;" after "int i;" I get it up to 12 bytes, but if I put d between c and i, the size goes back to 8 bytes. Same weirdness will happen to the variables you declare in a function. Just something to be aware of that if you do write beyond the bounds of an array, especially a char array, you might get lucky and write into padding and never know the difference, until one day you move the elements of the structure around or your function variable declarations around and your errors will make themselves known.
It may run as if it's normal. It may crash the app. It may crash your machine. It may crash your machine and corrupt your harddrive. It may become a future exploit that allows russian hackers to steal the credit cards 1 million orphans. Hard to say really...
From a style perspective, I recommend always explicitly using NULL when checking for a null pointer. Yes, you can check it against 0 (at least on any modern platform, but on some old platforms without byte-addressable memory pointers are actually structures) but NULL serves as a reminder that it's a pointer you're checking. It's functionally the same (NULL is just a macro for 0 on any modern platform) but it helps show intent.
It's old Reddit vs new Reddit vs phone apps
&gt; int bar = 0; &gt; bar is represented in memory as 00000000000000000000000000000000 -- ie 32 bits that are all zeroes. &gt; &gt; anytype *baz = NULL; &gt; NULL, in fact is not a value -- it's a macro (ie. it's something that gets replaced with something else by the preprocessor). The thing it gets replaced with is (void *) 0 -- ie. it's zero that's cast as a pointer. &gt; &gt; (for the pedantic experts or the confused newbies amongst you, note that anytype is not a type -- it's just my filler word to say that baz is a pointer for to something.) &gt; &gt; baz is represented in memory as 0000000000000000000000000000000000000000000000000000000000000000 ie. 64 bits that are all zeroes. Not quite always true. This holds for a modern 64-bit OS, but embedded platforms may have different pointer sizes. For instance, a 16-bit PIC may only have a 16-bit address space, such that anytime *baz = NULL; would actually be represented as 0000000000000000 i.e. 16 bits that are all zeros. Also, int is not always a 32-bit value. Again, for a 16-bit PIC compiler int maybe defined as 16 bits, while long would still be 32 bits. So for int bar = 0; long xyz = 0; bar would be 0000000000000000 (16-bits) and xyz would be 00000000000000000000000000000000 (32 bits).
You can change the padding on almost any compiler with a `#pragma pack(x)` statement, where x is the alignment.
I don't create stucts on the stack lol, I really just use the stack for local variables.
Thanks for the recommendation.
Gotcha! Thanks.
I just did a glance of the code and notice that on line 17 you are not passing the address to scan. You have: scanf("%s", s.name); I believe it should be: scanf("%s", &amp;s.name);
Lol, nobody uses regular markdown. Everyone interprets it their own way.
Damn, thanks for such an informative insight.
Thanks man for the informative insight. Learner something new today.
So a couple of things: 1. The program is exiting because the CTRL-C is causing fgets() to hit an error and return NULL. You need to use ferror() and feof() to distinguish between this case and the end-of-file case. 2. You can't call fprintf() (or any of its printf() friends) inside a signal handler. It isn't async-signal-safe, and you run the risk of corrupting memory. Luckily, you don't have to, since hitting CTRL-C causes the "\^C" to be output without you needing to add code to do it. Well sort of; which brings me to ... 3. The "\^C" that's automatically output isn't going to your program's stderr. It's generated by the operating system and/or the shell and output directly to your terminal, outside of your program. You can see that this is the case by redirecting stderr from your program. You should talk to your TA/prof on this point.
In case of a string (character array), the variable itself points to the first element of the array in question. Thus, there is no need to use the '&amp;' operator to pass the address.
For fixed sized arrays, use #define for the array size. Not only does this help prevent some bugs, but it also helps make your code self documenting and easier to modify. &amp;#x200B; \#include &lt;stdio.h&gt; &amp;#x200B; \#define SIZE 10 &amp;#x200B; int main() { int array\[SIZE\]; &amp;#x200B; for(int i = 0; i &lt; SIZE; ++i) { array\[i\] = i; } &amp;#x200B; int i = 0; while(i &lt; SIZE) { printf("array\[%d\] = %d\\n", i, array\[i\]); } &amp;#x200B; return 0; }
See my assumptions above.
Yeah, but that's kind of an advanced trick, which I've never really played around with.* And overriding the default packing to a lower x -- when it even works on non-x86s platforms -- breaks the whole "easily read" thing, which tends to screw up performance in ways not worth the extra memory savings on the stack, except in some really niche cases. (*And I've been in situations where I've needed to be nitty enough to make sure, as in the example above, that c, d and i are in the best order because the system I'm running might need all the 4 extra bytes here and there that it can get.)
Ah, guess I overlooked that statement.
&gt; On some platforms, a null pointer may be represented by a non-zero bitpattern We always say this without further qualification. Out of interest does anyone have examples of what common platforms actually use?
I believe ‚Äúpointerness‚Äù is actually called indirection and it is part of the definition of a type.
Sometimes it is useful to try different optimization levels. With gcc -O3 I get warnings about subscripts above array bounds. Without -O, silence.
You can suppress the `^C` by placing the tty in raw mode. But don't forget to switch back before exiting...
Nope, Àãpadding2Àã will be placed after ÀãzÀã since the alignment requirement for ÀãcharÀã is 1 (assuming a modern mass-market CPU). Padding is still required to ensure proper alignment of subsequent structs in an array, since the presence of an ÀãintÀã in the struct pushes its alignment requirement to 4.
&gt; Many compilers will try There is no ‚Äúmany‚Äù or ‚Äútry‚Äù. Padding is either required or prohibited by the ABI. All compilers for a given platform will follow the exact same rules unless otherwise instructed by pragmas or command-line options.
&gt; Is it always the case or differ. See [here](https://www.reddit.com/r/C_Programming/comments/bjnmi8/help_me_understand_how_memory_works_in_c_and_why/emanlnc/).
&gt; Same weirdness will happen to the variables you declare in a function. Not necessarily. They might not even exist in memory, or they might overlap if the compiler determines that they are not used concurrently.
Not quite. An array (any array, not just an array of `char`) is not a pointer, but it devolves into a pointer to its first element in most contexts.
&gt; In C, a literal zero is called a Null Pointer Constant No. A literal zero is an integer literal which can be implicitly promoted to a number of different types. A null pointer constant may be a literal zero or a null pointer constant cast to an appropriate pointer type. I think it can also be a constant expression which evaluates to 0 at compile time, such as `1-1`, but I'm not sure and I don't have my copy of the standard at hand. Many implementations define `NULL` as `((void *)0)` to catch common mistakes.
`NULL` can be a bare `0`. No cast is required.
`'\0'` is an `int`, not a `char`.
Right. But what if you're declaring multiple pointers? char* p, *q; // makes no sense char *p, *q; // that's more like it!
Right. But what if you're declaring multiple pointers? char* p, *q; // makes no sense char *p, *q; // that's more like it!
You are right that the asterisk acts as a prefix operator in some contexts. But in a weird way, the asterisk is also a suffix modifier. When you cast from one pointer type to another for example you write `(char *)malloc(N)` rather than `(char) *malloc(N)`. It's worth noting that nearly every major language descended from C has revised its pointer syntax in some way to correct these perceived inconsistencies.
In addition to performance, in some systems unaligned memory access is simply not allowed and will generate an exception.
string1 and string2 are not large enough to hold a string longer than one character.
Check out C FAQ 5.17. You‚Äôd be hard-pressed to find those machines in the wild but they do (or did) exist.
I would suggest to define a max constant to the size of string, but pay heed to this approach as it could crash your program if the input is more than how much the array can hold ( buffer overflow). You can circumvent this constraint by using a dynamic memory allocation if you're familiar with pointers.
http://www.buildyourownlisp.com
In the old days compilers would usually pack stuff in a way that they appeared sequential. But it was slow as it'd involve a get shift and masking around. Instead most things now do boundary allocations, so if you have weird sized structures things get silently padded, and you get strange and interesting corruption. Just google the fund around things like -mno-ms-bitfields , __attribute__((packed, aligned(1))) etc. Welcome to hell.
&gt; Nope, padding2 will be placed after z since the alignment requirement for char is 1 (assuming a modern mass-market CPU). True, this is what I get by trying to remember this from (no pun intended) memory. Thanks.
https://github.com/danistefanovic/build-your-own-x https://github.com/tuvtran/project-based-learning#cc
oh god. it's a pretty stupid mistake right? thanks for pointing it out!
Yep. I'm still trying to get used to malloc and stuff, so I'll try with that. Thank you so much!
It's an easy mistake to make: It's quite common for people to think of strings as single, primitive values rather than as regions of memory, especially if they are used to working with other programming languages.
&gt; Why we need to do this since in the previous line we already declared a,b as integers? The C language does not have any introspection facilities. The `scanf` and `printf` functions do not know the types of the arguments you are giving them.
http://www.cplusplus.com/reference/cstdio/scanf/ If you look at the actual function definition, theres only one explicit parameter passed in (the format). The rest are variadic arguments. The function needs to know what arguments you're passing in, or how you want to interpret said arguments, hence the format specifiers.
Thank you.
That code is very ugly. If you find yourself wanting to use a goto, think very carefully about whether you can replace it with an if statement (conditional forward jump) or a while statement (backward jump). Also, you should give your variables names that are greater than one letter long, and that describe the purpose of the variable. For example, better names for t, z, l, and r would be `root`, `zeroNode`, `left` and `right` respectively. Same goes for goto-labels, if you still end up needing them. Here's an example of some code that performs the same thing as the first `traverse` function; without goto, without cryptic variable names, and without recursive calls: void traverse(struct node *root) { push(root); while (!stackempty()) { root = pop(); if (root != zeroNode) { visit(root); push(root-&gt;left); push(root-&gt;right); } } } You may notice that the inner part of the while loop looks almost exactly like the original `traverse` function.
&gt; alignment is based on the biggest member of the struct No, it is based on the member with the largest alignment requirement, and your own `int64_t` example is a perfect illustration of that. On x86, `double` and `long long int` / `int64_t` are 64 bits wide but are aligned on 32-bit boundaries. So that struct will only contain 6 bytes of padding, for a total size of 16 bytes with a four-byte alignment requirement. A more blatant example would be a struct that contains a few `int`s and a large `char[]`. The latter would be the largest member of the struct, but has no particular alignment requirement.
you can look at man(3) of 'stdarg' to get some info on how functions with a varying number of arguments are implemented -- you'll see that when retrieving arguments a type must be specified
&gt; On x86, double and long long int / int64_t are 64 bits wide but are aligned on 32-bit boundaries. So, since I don't have a C compiler nearby, is `_Alignof` a good way to test this? I'm pretty sure you are right but I've only tested for any of the above with a 64 bit compiler.
You can use `_Alignof` in C11, or something like this: struct { char c; int64_t x; } s; printf("%zu\n", (char *)&amp;s.x - (char *)&amp;s);
You're telling printf the type of the variable, because all printf is getting is memory address.
&gt; In fact, C may be part of the problem: in C it's easy to make byte order look like an issue. If instead you try to write byte-order-dependent code in a type-safe language, you'll find it's very hard. In a sense, byte order only bites you when you cheat. This is a very insightful angle, namely the appearance of importance. I work in hardware and low level software, and I rarely have to think about it even. Really the only time I get reminded of byte ordering is when looking at dumps since it can show, for example, instructions with bit patterns that, off the cuff, feel wrong, but it's only my brain being dumb and overthinking
No. Otherwise Java won‚Äôt ByteOrder.LITTLE_ENDIAN and ByteOrder. BIG_ENDIAN
To be extremely pedantic, this line i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24); can have undefined behavior if `int` is 32 bits or less. That's because even if data is an `unsigned char *`, `data[3]` is promoted to `int` for the shift (according to integer promoted rules). So if `data[3]` has the highest bit is set (i.e., it's 128 or more) the shift will set the sign bit of the resulting `int`, which is undefined behavior. You can see it if you compile this program #include &lt;stdio.h&gt; int main(void) { unsigned char data[4] = { 0, 0, 0, 128 }; unsigned int i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24); printf("%d\n", i); } with `gcc -O2 -Wall -o test -fsanitize=undefined test.c`, it will print something like this when you run it: test.c:6:65: runtime error: left shift of 128 by 24 places cannot be represented in type 'int' The solution is to cast `data[3]` to `unsigned int` before shifting it, so something like: i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | ((unsigned)data[3]&lt;&lt;24); (some people will prefer to use `(uint32_t)` instead of `(unsigned)`, some people prefer to cast every `data[i]`, not just `data[3]`, some people will prefer to add parentheses around the cast, but you get the idea).
I agree with the blog post and I admit I made the mentioned mistake before. Just want to add that perhaps the most common case when byte order gets in the way is to dump an entire struct. Also, byte order can be tested dynamically. In 99% of cases, there is no need to use #ifdef.
An integer literal zero is not the only allowable form of Null Pointer Constant, but as a grammatical feature, the sub-expression `0`, by itself, does not behave as a value of any particular type that is capable of representing anything else.
Good article. There‚Äôs some nuance to it that wasn‚Äôt apparent from the title. I.e., &gt; If the data stream encodes values with byte order B, then the algorithm to decode the value on computer with byte order C should be about B, not about the relationship between B and C. I hit this exact issue when writing some code at work. I had to write some json over IPC and I wanted the reader to have some way to know that it read the entire message. My first thought was to write a 4 byte message size before writing the json. But after the go code got a little messy due to byte ordering (the writer is C, the reader is go), I decided to use a similar strategy to HTTP. Except use the ASCII record separator rather than two new lines.
Good point!
&gt; Just want to add that perhaps the most common case when byte order gets in the way is to dump an entire struct. And this programming pattern is something you should strongly avoid. Do not write structs from memory to a file. Always perform proper marshalling.
That's a point. In [my implementation](https://github.com/fuzxxl/memf/blob/master/src/fiddle.h) I have addresses this issue, too.
I agree that in a perfect world this would be a reasonable approach. With the compiler I'm using right now though `i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24);` produces a lot of slow code. Treating the data as unsigned characters and moving the bytes to the correct places generates small quick code. As much as I'd like to write architecture and compiler agnostic code, it's not always possible, and telling people that they shouldn't worry about it can be detrimental. And before someone says, "you are using the wrong compiler", it's not up to me. It is determined by management.
Thank you for the informative reply! This was very helpful to me to read over, and I really do appreciate the time spent on it.
In such cases, you can turn this idiom into a function and then optimise the function in a platform specific manner. What matters is that the idea of host byte order does not intrude into your business logic. If there is a single place where all the optimised, platform dependent marshalling code lives, that's okay, too (but should be avoided if possible).
It's a problem with large amounts of data. Ideally I just want copy a pointer, but if I use the endian agnostic approach it's at best a memory copy, at worst it's a lot of unnessessary operations.
You've been burned before that you saw this so quickly?
No mention of htons(), htonl(), and friends? You can wrap up your conversions in macros and keep the ifdefs in the macro definitions, and when a conversion isn't needed it adds zero code. It also gives you the ability to easily make use of inline assembly in the macro in case your target has a byte swap instruction that you want to be sure to use. Using a named macro also makes the code easier to read and makes the intent clearer. I've got a lot of code shared between Coldfire and Cortex-M4 targets. Network byte order is big-endian by convention, so that's what's used for interchange. Conversion to and from local endian-ness is generally done at input and output and is otherwise left alone in memory.
 n = p[0] + p[1]*0x100 + p[2]*0x10000LU + p[3]*0x1000000LU; fickst!
SDL is relatively easy to use and quite powerful.
Hey Everyone, I'm learning algorithms and trying to implement it. I'm facing the following problem *Sorting doesn't work when the array size exceed 4*. It would be great if someone can help me resolve this issue. Thanks :)
I'm familiar with the htonl, htons, ntohl, and ntohs family of functions, is that the standard for non-network handling of byte ordering as well?
Hm, i'll be sure to give it a look then. What can you say about graphics.h? Am I better off using SDL instead?
I'm not sure why you got downvoted. This article was written in 2012 and is a bit weird, I learned the same thing, to use similar helpers that are host architecture aware. If the helper isn't needed it's just no-oped away by the compiler.
I don't know much about SDL, but it's 100% possible to load a picture or a part of it and draw whenever you want to. I was able to create a (pretty bad) terminal emulator this way (I had a picture with font with it). and you want to google for SDL2, I think. There are two versions, and the second one is more modern and preferable.
&gt;Always perform proper marshalling. Do you know any good online resources on this topic?
That would be much cleaner and I like that idea. Shame.
The idea is you never need an #if directive for endianness when exchanging data, period... htons and ntohs aren‚Äôt standard C but POSIX so they aren‚Äôt truly portable like the simple one liner in the article (though see the top comment in this thread regarding safety to that one liner). Though regardless, htons and ntohs has been the way to do this for many many years and it states intent very clearly and is a recognizable idiom and your code wouldn‚Äôt be incorrect for using them in my opinion.
You need two loops for the bubble sort. See if [this page helps](https://www.geeksforgeeks.org/bubble-sort/)
I see, thanks for chiming in! I do realise now my suggestion is pretty tailored to linux C developers. I'm not too aware of the history for POSIX vs standard C, but that's some homework for me to read up on.
You need two for() when sorting
[removed]
Write your struct member by member and manually sanitize each field like you should be anyways and you‚Äôll be fine. Writing a whole struct at a time is not only bad because of byte order, it doesn‚Äôt allow you to sanitize data and it very well likely could have different padding than expected.
[Raylib](http://www.raylib.com) makes both the lines and the collision checks very easy.
Use SDL, it‚Äôs widely supported and gives you ways to draw images, get input, windowing, etc. It‚Äôs very low level but gives you just the essentials. If you don‚Äôt care about doing tons of amazing effects with shaders, you won‚Äôt need OpenGL/Vulkan or anything, you can straight up make your game with just SDL.
I won't do anything very complicated, I think SDL I'll work just fine them. The only holdup now is that idk I we're allowed to use engines... I'll check that with my professor, hopefully we can do so
Hm, I get it. SDL will do just fine, and I think if I use graphics.h instead, it would be a lot, a lot more work, because I would have to do a lot of stuff from the ground. Thx for the help
Thanks, Let me take a look.
Thanks Pal :)
I'll be sure to check it out too. Do you think it's better than SDL for my project? People in this thread have been saying good things about SDL
Why not OpenGL?
Idk much of it, can you tell me about it?
OpenGL is the old standard for computer graphics. It's easy to draw things on it, not sure about movement thou.
tl;dr Leaky abstractions https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/ Saying you should or should not care about byte order is missing the point. At the end of the day, you have to know how a computer works, or you're just cargo cult programming and guessing whether or not byte order matters for a specific use case. Because the author is vastly oversimplifying, byte order does matter sometimes.
Hmm, people in this thread were saying SDL is very good for my needs, so I think I'll stick with it.
Making the colon mandatory for user types would have allowed the language to be parsed without a symbol table, which is IMHO something good language designs should try to do. Given something like: volatile int p,q; typedef int x; void test(void) { x*p; extern volatile int x; x*q; } The line `x*p` declares an automatic object named `p` of type `int*`, while the line `x*q` fetches the values of volatile objects `x` and `q`, multiplies them, and discards the result. If object declarations included a colon, no such ambiguity would exist.
I'd say go for it. Give us a feedback later.
Ok, I'll be sure to
I'm pretty sure we all have at least one of these.
Not sure about better but imho [much easier to grasp](https://www.raylib.com/cheatsheet/cheatsheet.html). I think raylib even uses SDL internally for some parts.
SDL is not an engine by any means, it's summed up as: &gt;Simple DirectMedia Layer is a cross-platform software development library designed to provide a hardware abstraction layer for computer multimedia hardware components.
Uh, so it just makes life easier? If I were to guess
Another common mistake is that if `data` were plain char then `(unsigned)data[3]&lt;&lt;24` still fails due to potential sign extension. Also this all fails miserably on 16-bit `int`.
&gt; At the end of the day, you have to know how a computer works, or you're just cargo cult programming and guessing whether or not byte order matters for a specific use case. One platform I code for (where the vendor supplies the compiler), it was ARM7 big endian; then the vendor changed to ARM9 little endian and I didn't notice for a couple of years, was confounded one day when dumping memory to debug an issue and finding the bytes in unexpected order!
&gt;Whenever I see code that asks what the native byte order is, it's almost certain the code is either wrong or misguided. And if the native byte order really does matter to the execution of the program, it's almost certain to be dealing with some external software that is either wrong or misguided. Is this really true? I've written some code that deals with reading &amp; writing WAV audio files, and from what I've read in the WAV audio specs, WAV files are normally little-endian. So if you're writing audio data to a WAV file, I'd think you'd need to check the machine's endianness and if the machine is big-endian, you'd need to swap the byte order before writing audio samples to a WAV file (if the audio samples are 16 bits or more)? And similarly, if you're reading a WAV file on a big-endian system, I'd think you'd want to swap the byte order of the audio samples before manipulating the audio?
I think the method above was meant to demonstrate what a compiler would need to take in order to deconstruct a recursive program. The end result would look like what you've posted. I wasn't able to understand a simple way of applying this method. The author removed it from subsequent books. I was hoping to find someone who might've seen something like this, maybe in a compiler class. Thank you for your detailed response.
The idea outlined in this article is that you should not think this way. Instead, you should understand a file as a stream of bytes that can be assembled into values by your program. You don't need to know anything about your platforms endianess to do so and writing code that does not make any assumptions about your platform's endianess is easier to write and much more portable.
I like C programming A modern approach by K.N King I got it for my first C course and I think it is very thourough. The only prevoius experience I had with programming was a college course in Java I have nothing to compare it to though Edit: I think i mean high school instead of college. The school you are going to if you are around 17
Thanks for the recommendation though!
yeah, there are invalid operands to binary &lt; operator. you have Course operands when it works only with scalar operands. it's on this line... if (pNew-&gt;course &lt; (*pp)-&gt;course) I'm sure you haven't read this before.
I did the same thing to your grandma maybe you should try talking to her.
Yes, and I agree, though it seems there could be problems when trying to open files saved by other systems of the opposite endianness. If a program simply writes a series of integers (for instance) to a file, and then you try to read that file on a system that has opposite endianness, I'd think the values would be wrong if the software isn't aware of endianness differences. There would have to be a spec saying the file format stores its values with a certain endianness. Similarly, I've heard of "network byte order" being big endian (I think), and I've seen code that converts host to network byte order and vice versa when sending data to/from a network.
You're in college, you took a class on C, but you still don't know the differences between C and C++? And, after taking this class that you just finished, you say you need a book to learn C? Did I get that all right? And what does C++ have to do with your question anyway?
I can second C Programming: A Modern Approach. I also liked Let us C. My Intro to C course assigned a book authored by Kochan et al and I would recommend against it. I haven‚Äôt picked up K&amp;R yet but I plan to.
Thanks for the help! I picked it up just now
The relational operator &lt; does not automatically do comparisons of your Course type. You need to define what it means for Course Foo to be greater than Course Bar in a function and return a pointer/value to that struct.
member course is of type Course which is struct you cannot compare struct objects with '&lt;'. you probably need a function that compare 2 Course objects.
this has nothing to do with the C language
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/macbook] [Is the new 2018 MacBook Air enough for c#](https://www.reddit.com/r/macbook/comments/bk1a9l/is_the_new_2018_macbook_air_enough_for_c/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Are you using Visual Studio on Bootcamp with Windows ? Or are you using mono on macOS? How big are your projects ?
Not big projects, idk what I will use for this(
It should be fine. I recommend 512 to 1tb if you want bootcamp with visual studio .
What about ram?
Go for 16gb
I'm going to setup a crowdfund that donates a dollar every time someone confuses C#/C++ for C on this sub.
htons, htonl and friends are missing little-endian support and 64-bit support, unfortunately. It would be better to use [the endian functions](http://man7.org/linux/man-pages/man3/endian.3.html) but they're non-standard and so less portable. Sometimes you're just stuck :(
Agreed- I should've been clearer. For the more general and complex cases you mention, do you recommend any resources or the resources referenced in this thread? Most of the toy projects I do simple wrap other libraries.
This is a great article
This is good series of youtube vids on making a game using sdl https://www.youtube.com/watch?v=JPAyj85tJ5E&amp;list=PLT6WFYYZE6uLMcPGS3qfpYm7T\_gViYMMt
They're trivial to write yourself, though. I've got macros called something like from\_little\_endian\_xx for when I need to, for example, parse a Windows BMP file header (in little endian format) on a Coldfire CPU. On a little endian system, the macro does nothing. When you're using this: `i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24);` ...you're either going to be copying and pasting all the time, or typing it in from scratch, and it may not be difficult but it's easy to make a typo and screw things up. Much better to use a macro with a meaningful name.
The entire memory space is copied over (duplicated) when you fork. The two process do not share any virtual memory at all. You can share a region of file-backed (or anonymous) memory between multiple processes using `mmap`, but I'm not sure that's what you actually want to do. Re: pipes, what you *actually* want to do is create the pipe, fork, then close opposite ends of the pipe in the parent &amp; child respectively. When you call `pipe`, you pass it an array of two integers. The pipe creates two file descriptors, and writes one to each of the spots in the array that you pass it. Writing to one file descriptor can be read from the other. So, you use pipe, then fork, then in one process (ie. the parent), you close one end of the file descriptor, and in the other process, you close the other file descriptor. ie. int fd[2]; pipe(fd); pid_t pid = fork(); if (pid &lt; 0) { // fork failed exit(1); } if (pid) { // parent process close(fd[0]); } else { // child process close(fd[1]); } With this setup, now you can do one-way inter-processes communication through the file descriptors. So you can write to `fd[1]` in the parent process and read from `fd[0]` in the child process. (Or vice-versa.... but not both -- This specific example can *not* be used reliably for two-way communication.) Read up on inter-process communication in Advanced Programming in the Unix Environment by Stevens &amp;&amp; Rago.
Which is kinda scary that so many people who think they are programmers do that.
I believe his point is instead of reading/writing integers whole, write each octet (obtained with mask-and-shift) in whatever order you decide for your file format, and for reading, read it in byte-by-byte and create the int that way (with shift-and-combine). No matter which system your code runs on, it'll function the same way.
Ignoring that the question is offtopic: A $5 Raspberry Pi Zero is sufficient for programming in C#. The other two things could be done on any laptop that's less than a decade old.
Can‚Äôt be done.
Because you‚Äôve provided zero information, or code. You might have well asked how to write code for a mars lander.
the structure s* in each process will point to different memory of the same contents. Changing s in one will not affect the other (assuming you're using standard malloc). &gt;How do I access to the parents "s" from the child? You'll need to do some restructuring, but you have two options. one is to use posix shared memory and instead of using malloc, use mmap with MAP_SHARED. The other is to look at the clone syscall. Fork on Linux will ultimately use Clone, but you can pass flags into clone to control address space sharing.
*If the pipe gets freed in one process*, is a strange question. The filedesc variables, 2 integers, are the same in both processes, copied by the fork like all variables. They refer to the same shared pipe, which lives outside of your processes. The pipe itself is not copied by fork. Nothing to free in a pipe, just 2 ends to close.
Not your question, but you don't need to recursion here. Just walk pp into the proper place, taking &amp;left or &amp;right until \*pp is NULL.
&gt; If a program simply writes a series of integers (for instance) to a file, and then you try to read that file on a system that has opposite endianness, I'd think the values would be wrong if the software isn't aware of endianness differences. The point is that you do not write integers to the file but rather bytes that make up these integers with a defined byte order. As the article says: file byte order matters, host byte order does not. The idioms given in the article allow you to convert from file to host byte order without knowing what the host byte order is. That's what it's value is.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
https://github.com/rby90/Project-Based-Tutorials-in-C
`htons` and `htonl` are design mistakes in the socket API. They should have never existed in the first place. The whole point of the article is that having a bunch of conversion code wrapped in `#ifdef` is a fucking stupid idea and can be avoided easily by not making assumptions about the host architecture.
&gt; The entire memory space is copied over (duplicated) when you fork. Hi, sorry, what is the running time of fork()? I mean, does the memory space gets copied linearly ( O(n) ) or is there some other clever trick? I am asking cuz in my field, bioinformatics processes can have upwards of 64GB memory space and, well, 64GB takes a long time to copy.
&gt; You'll need to do some restructuring, but you have two options. one is to use posix shared memory and instead of using malloc, use mmap with MAP_SHARED. * not thread safe
I don‚Äôt think there‚Äôs a ‚Äústandard‚Äù answer here, depends on the OS. On Linux, I believe it‚Äôs COW - copy on write - e.g., no memory is actually copied per se until you write to it.
You might want to consider using threads instead of fork in this use-case
The virtual memory space is copied over, but the physical memory only gets copied when a write occurs, and even then, the memory space is broken up into multiple pages, so a write to the stack wouldn't necessitate copying over the entire heap, for example. It also certainly doesn't require copying over the code region. When you get into understanding page tabling, there's actually a bunch of fun stuff that's going on under the hood that's all obfuscated from the user. In fact, what's even cooler is that all of this memory virtualization is happening at the hardware level by the translation lookaside buffer, so it's actually even faster than you'd think.... In other words -- for all intents and purposes, the virtual memory space is copied over, but you, as the user, really only rarely will need to worry about it.
 Structure *s = (Structure *s)malloc(sizeof Structure) &gt; How do I access to the parents "s" from the child? You can't. At least, not just like that. The parent's "s" lives into the parent virtual space, which you cannot access from the children. What you could do (warning: I haven't tried this), however, is set up shared memory before forking and allocating "s" from the shared memory segment. Then in the children you should still have the address of the shared memory s.
&gt;can be avoided easily by not making assumptions about the host architecture And I'm saying wrap that repetitive and ugly code up in a macro. If you want to use the idiom from the article, fine, but put it in a macro so you only have to get it right once and it's clear what you're trying to do.
&gt; And I'm saying wrap that repetitive and ugly code up in a macro. If you want to use the idiom from the article, fine, but put it in a macro so you only have to get it right once and it's clear what you're trying to do. Good idea! I made [a bunch of inline functions](https://github.com/fuzxxl/memf/blob/master/src/fiddle.h) for this purpose.
mmap is thread safe....
The author's point is that your program shouldn't need to know or care what endianness the machine is using, and it shouldn't have `#ifdef`s to check for the machine's endianness. Since you're reading from a file format that's known to be little-endian, you should always read from the file using a function or macro like `littleendian_to_hostendian`, and you should always write to the file using `hostendian_to_littleendian`. And those macros *can* be defined once in a way that doesn't require knowing the host's endianness, although due to bad compilers it's common that they are done so that the no-op case is in fact a no-op. This is just like how networking code words. "Network" order is big-endian, which is used in IP, TCP, etc. The `htonl` and `ntohl` macros are "host-to-network" and "network-to-host". It just so happens that "network" is a synonym for "big", but that's irrelevant. If you're writing portable code, you *always* do your reads and writes using those macros, and then it's guaranteed to work on any system. You *never* check whether you're on a big-endian system and skip the `ntohl`.
I could probably use this in some of my code.
If the OS+hardware support VM, usually just the page tables get copied on `fork`, maybe + a couple pages of the stack, and the actual page contents get copied on an as-needed basis, left shared otherwise. You can also set things up so the page tables (really, most process-related data structures) are copied on demand as well. If there‚Äôs no virtual memory but there are access protection mechanisms (e.g., x86 protected-mode segmentation) you can usually do similar tricks where you mark writable things read-only and copy when the right fault comes in. If everything‚Äôs all treated as a single protected entity (e.g., one big data segment), then you do end up stalling for a while when the copy happens, but it‚Äôs not as bad as copying the entire address space and you can usually mitigate that by beaking up the larger entities into smaller ones. If there are no protection mechanisms, full-blown `fork` sucks badly, and yes it does end up being linear wrt the amount of allocated memory.
&gt; How do I access to the parents "s" from the child? Until one process or the other modifies `*s`, you are accessing the parent‚Äôs `s`. When/if a copy happens, though, you don‚Äôt access the parent‚Äôs `*s` unless you specifically mapped that region so it would be shared after `fork`. &gt; Do i need to free s in both processes? Yes. The heap management structures are copied along with everything else, so both parent and child should be `free`ing what they‚Äôve `malloc`d. &gt; do pipes work? ‚Ä¶what happens if the pipe gets freed in one of the processes? Yes, and pipes are one of the easiest ways to communicate between processes without messing with a bunch of temporary files along the way. If you open a pipe before forking, each process will have a FD referring to each end of the pipe. The pipe will be destroyed from the kernel‚Äôs point of view when all four FDs are closed‚Äîmost filesystem- or FD-related things are reference-counted, and this is no exception. You can run into race conditions if both processes try to use the same end of the pipe at once; you can rely on a write of a single byte to be atomic, but for anything larger it‚Äôs easy for processes‚Äô data to get mixed up if they both try to write into the pipe, so usually one process will close the end of the pipe it doesn‚Äôt need, leaving one FD referencing each end afterwards.
&gt; Hi, sorry, what is the running time of fork()? I mean, does the memory space gets copied linearly ( O(n) ) or is there some other clever trick? The clever trick is called copy-on-write: The memory isn't copied until one process or the other writes to it, at which point only the page which got written to is copied. A page is typically 4 kilobytes, so copying a whole page isn't a huge operation. &gt; I am asking cuz in my field, bioinformatics processes can have upwards of 64GB memory space and, well, 64GB takes a long time to copy. If that memory's mainly being read, it isn't a big deal. If all of the processes are modifying their own copy, well, you're going to need a lot of RAM.
üòÇüòÇüòÇ
&gt;Hint: %.f prints the float with ‚Äúprecision‚Äù digits after the dot.
Have a look at [this page](https://docs.microsoft.com/en-us/cpp/c-runtime-library/scanf-type-field-characters?view=vs-2019), and at the data type of your variable. float : temperature Also looks like you have a stray character here, double-check your code.
You're quite close and should be able to debug this. I recommend adding a printf statement that prints the value of `pRoot-&gt;course.szCourseId` and `pszMatchCourseId` on each call to search and pay close attention to the first couple of outputs.
Walk the whole tree or maintain an index.
It's quite obvious that it's (supposed to be) a sorted binary tree.
You are looking for "format specifiers" [https://www.geeksforgeeks.org/format-specifiers-in-c/](https://www.geeksforgeeks.org/format-specifiers-in-c/) You can read the float.. and print the values using them. The hint is the biggest giveaway ... how to print the float value.. couple that with dot format specifiers and you got your code.. Hope this helps..
Unrelated to your question, only because it's quite ugly to read and needlessly expensive : please only call strcmp once and store the result in a variable.
Alright thank you for the input, I will make sure to fix that
following
I'm not a big fan of Computerphile on YouTube, but I think this video is extremely well made and I believe he does what you're looking for here. https://youtu.be/1S0aBV-Waeo. If I understand your question correctly, you're going to need to insert the byte code into the buffer and then start execution at the beginning or the buffer. You can use a nop sled for spacing.
Also a great, but very in depth read http://phrack.org/issues/49/14.html
Check out liveoverflow. He has a video that will do exactly this IIRC.
I have done what you suggested and I'm stumped. For each course that is registered if it goes to the left then it will only go to the left...and if it goes to the right then it will go only to the right. Snippet of output: STUDENT REGISTER ENG1023.001 pRight: HIS1043.002 ENG1023.001 pRight: MAT1214.003 ENG1023.001 pRight: MAT3013.001 ENG1023.001 STUDENT REGISTER GEO1013.005 pRight: HIS1043.002 GEO1013.005 pRight: MAT1214.003 GEO1013.005 pRight: MAT3013.001 GEO1013.005 STUDENT REGISTER MAT3013.001 pLeft: HIS1043.002 MAT3013.001 pLeft: CS1713.002 MAT3013.001 pLeft: ART2113.001 MAT3013.001
thank you, I'll look into this
Also: if (&lt;) { left } else if (&gt;) { right } else { equal }
Unless you made the same mistake in the insertion function, you're consistently going in the wrong direction and need to swap `&lt;` and `&gt;`.
Look at the first example: pRight: HIS1043.002 ENG1023.001 pRight: MAT1214.003 ENG1023.001 The course ID you are look for is "ENG1023.001". In the first call, you check in against "HIS1043.002" and in the second call you check it against "MAT1214.003". Are you getting closer or farther to your result?
I'm getting further away...I made a dumb mistake
Whatever address overwrites the return address will be popped into rip. All he's asking you to do is declare a function and then overwrite the return address with the address of that function.
I want to clarify: the desired function doesn't exist. The source c code is fixed. I have to somehow push the correct byte code for my custom function onto the stack and execute it from there
Oh I read it as it is in the code but not called.
Thanks anyways. Live overflow is a interesting channel üëç
I can't declare a function. The source c code is fixed.
What architecture/toolchain are you using for this exercise? Windows/Linux/MacOS/other? x86/x64/ARM/other?
Your post says you have to create a function, but you can't create a function from outside of the program. That doesn't make any sense. If you're exploiting fixed code then your assignment is to do one of two things. Either you're supposed to inject runnable code into the process and jump to it (easiest way to do this is to stash shellcode in an environment variable, then overwrite the return address with the address it lives at) or, since glibc is loaded by your program at runtime and its functions are available to you, perform a call to one of the functions living there and supply it arguments via the stack. Could also do ROP but that's almost certainly too advanced.
Yeah sorry I wasn't too clear. Hard to explain something I don't get too well myself lol. But there shouldn't be shell code or anything too complex. The only thing we have to work with is an input file which is written to a buffer, and apparently we have to somehow execute the code we passed inside said buffer (which our prof somehow made possible using mprotect or something). Sorry I can't make it more clear haha
Submitting code into a buffer and jumping to it is shellcode 101.
Maybe I'm wrong then. There shouldn't be any command shells open as the only purpose of the injected code is to change 1 value in an array. Does that still count as shell code? If so how would I go about doing this
Is the array on the stack?
I just checked. It's global. Makes it even harder because idk anything about global storage
Doesn't make it much harder. "Shellcode" generally refers to any injected code. In this case, all you need is some shellcode capable of changing the array value. There are two things you need to know: * The address of the buffer where your shellcode will be written. You don't need the *exact* address, just close enough. If you can write 500 bytes before you hit the return address, and your shellcode is 50 bytes, then you can fill the other 450 bytes with a junk instruction (usually NOP, 0x90). Managing to point the instruction pointer anywhere within that 450 byte range will cause it to start executing NOP instructions from wherever it hit, then "slide" down the chain of NOPs until it reaches the injected code at the bottom, a technique called a NOP slide. * The address of the array value to overwrite, so that your shellcode can change it. The program itself is obviously capable of knowing a global array's address, so you can literally borrow the exact same assembly if you need to https://godbolt.org/z/shP62l. And, even if the program never even accesses the array, you can still inspect the array address and values using GDB.
Nope, you misunderstood the intent. `htonl` and friends actually do it wrong. What the author says is that in addition to not swapping bytes, you should simply never directly read data from outside into structures. Instead, you should read data into an array of characters and interprete these as numbers. That's why the author's conversion function does not swap bytes but rather assembles bytes in an array into numbers. Apart from avoiding platform specific code, this also fixes numerous problems with unaligned memory access and strict aliasing.
Maybe my explanation wasn't perfect. You're right, `htonl` and friends have a fatal flaw in that they take in an integer *value*, rather than taking in a *pointer* to some bytes which represent a [possibly unaligned] integer. Using `htonl` correctly when alignment is unknown requires taking an integer value, using `htonl` to obtain a network-endian integer value, and then memcpying or byte copying that value to its final place. Which of course may be particularly wasteful on machines that support unaligned access and could have directly written the network-endian bytes in place if the API had been using pointers to bytes. But my point was that, whether you're using the mediocre `htonl` or a better API designed to read and write directly from a stream of bytes (whether a network socket, file, etc) as the author recommends, the steps in your application should always be the same, and should not need to know or care what the host's endianness is. Portable code will *always* call `htonl` or the author's unnamed functions. Maybe the author's suggested macros/functions are a bit more efficient, but honestly I don't see their "revelation" as being any different than the standard practice that should be drilled into everyone when they first learn to write networking code: know and define the endianness of your input/output formats, never ask what the endianness of your host is, and always use some function (whatever that API may be) to convert between I/O-endian and host-endian.
It sounds like what is being asked is for you to create your own shell code and have that executed by the program. Here‚Äôs the steps you could take (there are multiple approaches.) Write a new program that does nothing but call a custom function you‚Äôve designed. Compile that program and look at it in a debugger such as gdb. Extract the assembly instructions for that particular function, this is now your shell code that you want to execute. From here send the payload as you did before, in the format of [padding][eip][shellcode] which is effectively ‚Äúinjecting‚Äù your function into the program on the stack. Get eip to continue execution at the first instruction of your shellcode. You‚Äôre now executing your ‚Äúinjected function‚Äù.
Binghampton university, CS 220? If so, stop violating your honor code with this nonsense.
Thanks!, got it figured out, it was 4Am, around 10h working, and i could not get sleep thinking about that error. Sometimes taking a rest is the best.
Sadly, WSL does not support quite a few system calls, including several IPC mechanisms, and POSIX message queues are one of them.
Asking for help figuring out logic is violating the code now? You see me whip out the code anywhere?
The D3DX9 SDK is pretty easy to learn, and it comes with a help file with all of the documentation: https://www.microsoft.com/en-ca/download/details.aspx?id=6812 It's my favourite graphics API to use still after all of these years.
what ur learning isn't related to c programming and ur professor is a small minded insect. find someone who will teach u to write a compiler. then u'll have small minded insects picking holes in ur software calling it a 'c programming class' lmao
The term "cheat" is insightful, because it implies that the author views programmers as trying to achieve some unfair advantage, or that programmers are trying to shirk their duty to serve compiler writers.
What do you not like about their videos?
A sigaction call should provide better control over the handler's behavior than sifnal , e.g. making the handler reset automatically to the default after it's used (one shot), how child processes respond, and lots of other stuff. When a system call gets interrupted by a signal, the action can (but need not always, it depends on the call) cause errno to be set to EINTR, which the program can check. The signal(7) man page details this, and the system calls' individual man pages should indicate whether the call is restartable.
The program needs to tell the difference between, for example, whether the varaibles in the argument list are expecting the characters '1','0', or the string "10". The stdarg man page (for Linux at least) does have a good example of how to use format specifiers to interpret data for a variable argument list.
A few notes for you: 1. Are you sure you want to use `CourseNode *allocateNodeTree(Course course)` instead of `CourseNode *allocateNodeTree(Course *pCourse)` (which is more efficient)? Then change the assignment in the function to `pNew-&gt;course = *pCourse;`. 2. You don't have a member in `Course` for the course name, which I assume is your main question/issue. You need a `char *` for that and will have to `malloc()` a string for it (with the terminating null byte) separately in your `allocateNodeTree()` function and `strcpy()` it in. (BTW, might not `createNode()` be a better name?) 3. Once you have the course name member, you can `strcmp()` the names from each `Course` struct to compare courses in `insertTree()`. It would be good if you showed your code that calls `allocateNodeTree()` so that could be reviewed also. You're almost there.
What do you mean by safe? sizeof(whatever) is a constant calculated at compile time.
If you compiled the shwon code to a library, and a consumer wrote the following, would it give the correct size #define BIGGER #include "foo.h" int main(int argc, char** argv) { printf("%d\n", foo_get_size()); // Expected output: // 8 }
&gt; If you compiled the shwon code to a library, and a consumer wrote the following, would it give the correct size It will return whatever the value of `sizeof(Foo)` was the time the library was compiled.
Seeing as how that's incorrect behavior for what I'm trying to achieve, how should I do things right?
&gt; Seeing as how that's incorrect behavior for what I'm trying to achieve, how should I do things right? See my edits.
No. The value you get from foo_get_size() would depend on whether the source file defining it was compiled with the BIGGER flag. struct Foo may also have a mismatched size, which causes weird stuff to happen.
I am also interested in the answer to this question.
why would it be dangerous? hehe if the type of Foo may change between implementations may as well make the whole thing opaque... /* foo.h */ typedef struct foo Foo; int foo_size(void); /* foo.c */ struct foo { int normal; #ifdef BIGGER int bigger; #endif }; int foo_size(void) { return sizeof (struct foo); }
Unfortunately that won't work super easily here. The extra member is a mutex that's only defined if the user has `#define ECS_MULTITHREAD` before including the library and it's used to make sure all of the code can be thread safe if needed. I guess I can just release two different versions of the same library, one with locks and one without. I'm sure I'll figure something out regardless. Thanks for the help and insight
Yeah, that's what I was concerned about. Thanks for the information :)
You should try to avoid having configurability exposed using preprocess definitions in this way. Let's say this library is itself used by two different libraries A and B, then some application is built against A and B. What happens if _only one_ of the A and B libraries were built with `ECS_MULTITHREAD` enabled? It would be better if the library itself indicated whether it was built with multithread support. If some application (or some other library) needed multithread support, it could interrogate the library first and refuse to operate if the feature was not compiled in.
 size_t foo_get_size(void) { // Is this safe? return sizeof(Foo); } Why on earth would you do this in the first place? `sizeof(Foo)` is a static, hardcoded value inserted by the preprocessor, this literally compiles as size_t foo_get_size(void) { return 8; }
Each word is a single array
Coenting so I find this later
I‚Äôll try this. We have man pages for everything program wise (ls, etc.) just not c stuff. Thanks
No, but everything that ships with the compilers (C99 standard, for example)
Thank you, this is one of the best comments in this thread and deserves many upvotes/more attention.
Walk along both the source list and the destination lists and copy node values. If destination needs to be extended with additional nodes, access it through pointer to pointer to node.
Yeh same, thought they just needed to overflow a buffer with a function pointer somehow.
In such cases I usually write a function, that returns all elements of a linked list as a dynamically allocated array. I record the list length (number of elements/nodes), updating the structure member on each list update. This can be used to determine how much memory needs to be allocated for an array. The rest is just traversing the list (sometimes backwards for LIFO data) and copying elements to the allocated array. For an array compatible with c-string, you need one byte more to terminate it with zero (null byte), otherwise there will be no way to detect where the string ends. Recording the list length is not needed if your list is short - you just have to traverse it twice: to get the number of elements and then to copy data.
Sure, but it's best to write code that's clear, and you're confused about that, so don't produce that yourself.
Please do not post pictures of code. Instead, post your code as text in your post.
But why does sizeof(FILE) work? #include &lt;stdio.h&gt; int main(void) { printf("%zu\n", sizeof(FILE)); return 0; } This program compiles without warnings and prints 216 as the size.
it's declared in the header, at least in ur libc. makes the implementation easier, but the interface, not as cute
SDL2 is very, very low level. Any kind of GUI more complex than a basic button is gonna take some definite effort.
How are htons, htonl and friends missing little-endian support?
All I need is two lists, one text box and few buttons. I guess this would be easy to implement.
I have developed a GUI system based entirely on SDL2. It is indeed very low level and I literally started by drawing individual pixels in the right places until I had windows and text and keyboard input... But then again my application is very specialized so I wanted 100% control over the GUI system. If you don't need that much control it's just not worth the effort. After 1 year developing this thing I already wish I had used something like GTK.
This is very true
If by text box you mean an area where you can type text, then that's definitely non-trivial. You'd need to manage yourself the input system, implement some kind of text wrapping, add scrolling if needed, etc.
Yeah. I had implemented input system in the past so this is actually easy for me but text wrapping and scrolling does not seem easier to implement. So that is better to use something like GTK? I am so worried about customization and Windows support but I want to spend more time designing and implementing interface not writing such lowlevel code.
Nice. But still I want to support Windows, Linux and Mac OS and customize each control of my graphic interface.