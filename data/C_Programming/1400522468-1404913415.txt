That's not relevant. /dev/mem is a file were every offset represents a physical address. If you write something to offset 0x1337 in /dev/mem, the result will be a write to offset 0x1337 of the physical memory. Using mmap(), you can get a "window" into the physical memory – you can request the kernel to map a certain physical address range into your address space. You can't predict where the window will end up in your address space, but you know where the window points to. Here is some example code: void *map_physical(uintptr_t base, uintptr_t length) { int fd; void *mapping; fd = open("/dev/mem", O_RDWR, O_CLOEXEC); if (fd == -1) return (NULL); mapping = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, base); close(fd); return (mapping); } This function will give you a pointer to a memory object that corresponds to the physical memory at *base* with length *length*. For instance, this code writes the 16-bit value 0x1337 to address 0x4223: mapping = map_physical(0x4223, sizeof(uint16_t)); if (mapping == NULL) /* fail */ *(uint16_t*)mapping = 0x1337; munmap(mapping, sizeof(uint16_t)); Of course, in a real application you would map a larger chunk of physical memory (like the area a certain device uses) into your address space and repeatedly read and write data to / from it.
Have you looked into Cygwin or mingw? Both provide the ability to bridge the gap between Linux and windows. Indeed our embedded platform is programmed primarily on windows using Cygwin and cross compilers and then merely tested on the embedded Linux hardware.
I think OP did not use Windows. I think he came from DOS.
Well he said he used DOS in the 80s and 90s. 
Many people did. DOS != Windows.
Obviously ^^ . But did is the operative word there. Reckon you will struggle to find someone still working with DOS. 
textanswer isn't a string. Check the documentation of puts()
Fixed that, now it only works for a single letter. Code: char answer[40]; printf("\nInput your answer (case sensitive): "); scanf("%c",answer); if(fgets(str,40,fp) !=NULL){ char textanswer[60]; fgets(textanswer,40,fp); if (strcmp(answer,"A")==0){ printf("Correct!"); } else { printf("Incorrect!"); } } fclose(fp); } That words, but if I set anything else in the strcmp() (example "Arch") it will not work.
Why are you using "%c" in scanf while declaring the answer as a character array of 40 characters? If you want to read in a string from the command line (console/stdin), you need to specify "%s" as the format specifier.
That's because you instruct scant() to parse exactly one character with %c.
oops, you're right, I missed the variable declaration and just assumed he was using two strings. my bad
Okay, so here is my code now, and it prints out the two values to be compared. They are exactly the same, yet it says they aren't. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { char ch; char input[1]; int lineCount = 1; char str[60]; FILE *fp; char EOL='\n'; fp = fopen("data.txt","r"); // read mode if( fp == NULL ) { perror("Error while opening the file.\n"); exit(EXIT_FAILURE); } printf("The question is: "); while( ( ch = fgetc(fp) ) != EOL ) { printf("%c",ch); } fread(&amp;input, sizeof(input), 1, fp); printf("\nPick a number from 1 to %c", input[0]); int i = input[0] - '0'; for(i;i &gt;=0; i--){ if(fgets(str,40, fp) != NULL){ puts(str); } } char answer[40]; char right[40]; fgets(right,40,fp); printf("%s",right); printf("\nInput your answer (case sensitive): "); scanf("%s",answer); printf ("%s and %s", answer, right); if (strcmp(answer,right)==0){ printf("Correct!"); } else { printf("Incorrect!"); } fclose(fp); } 
They aren't exactly the same. Remember that `fgets()` reads and returns the newline, but `%s` with `scanf()` does not. 
Better, `%39s`.
 char ch; printf("Enter a character:"); fflush(stdout); ch = getchar(): return 0;
Thanks that worked, I'll look up the fflush() function. I'm working through "The C Programming Language" and they haven't mentioned it yet.
Output is buffered. There's no guarantee anything will be written until the buffer is flushed, which won't happen automatically until getchar() stops blocking and reads input. See [here](http://www.gnu.org/software/libc/manual/html_node/Flushing-Buffers.html) for more. Edit: Link is not ANSI C, but still good info.
You're probably looking for http://www.reddit.com/r/cpp and http://www.reddit.com/r/Cplusplus
Thanks for the advice, Actually the project compiles in pure C, we just used a C++ compatible IDE. All the C++ features like classes are much too slow for realtime raytracing. 
Whats with all the down votes guys ? Comment if you don't understand or dislike something ! Programming Subreddits are so infested with silent haters : P
No source, you mentioned C++ for apparently no reason in a C subreddit... Those alone would net you downvotes.
No source code?
A couple of ideas: * sort the array before doing you i + 1 check * use a hash, where the keys are your random numbers. Hashes are probably an intermediate concept but should be available as part of your libc.
Checking I+1 doesnt work, because there isnt anything there yet. Doing I-1 would be better, but still doesnt account for lower numbers matching. And then the new random number has to be double checked again to make sure it didnt get another number in the list. Your can of course brute force it, by checking the entire list on every new random number. Or use another data-structure to store the unique numbers (like a hashtable)
is there any number range? if not then just: i * 10 + rand() % 10 UPD: i thought a bit about it and it looks like either extreme hardcore: bayesian filter, or brute force (look through whole array up to i) or keep array sorted and figure out the place where to put the number with modified binary sort (instead of finding index you find a position where to add it or -1 or another special value if such item already exists)
Oh that's true! Thanks for the tip, thought it would work otherwise but it makes sense. Well I'm new at programming so I don't know how bruteforce works. Isn't there a simple solution to check for double entries? 
It looks like you want the series of numbers from 1 to 10 in random order without repeats. If that is your goal, first fill an array with the numbers 1 through 10, then shuffle the array using [Fisher-Yates](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle). Don't try to generate the individual numbers. 
As other said, use brute forcing (look for duplicates in a loop up to the last index for each element). I'd use a sorted array and then randomise indexes or a set (or something similar)
Oh sorry, it looks like that because of the %10+1 but that was my mistake. Let it be %50+1 or something else, it just needs to be random generated numbers.
The fastest approach will be a closed ended hash table. Define a hash function (simple is n%10 like you did, more complex is to use some polynomial-based function to "randomize" the index a bit). Then starting at the index, search forward. Struct table { Int value; Bool valid; } table[10]; int written = 0; for (int i = 0; i &lt; 10; i++) table[i].valid = false; while (written &lt; 10) { int N = rand(); int D = hash(N); while (1) { If (!table[D].valid) { table[D].valid = true; table[D].value = N; written++; break; } else if (table[D].valid &amp;&amp; table[D].value == N) break; D = (D + 1) % 10; } } If you want even shorter run times, separate the hash table from the output list and make the hash table "large" so as to reduce the probability you get hash collisions. The above will have O(1) search time complexity. 
As other commenters have pointed out, if you just need 10 random numbers from 1 to 10 with no duplicates, it's better to shuffle an array with the numbers from 1 to 10 in it. However, I'll answer the more generic question which I think you're asking: how can I generate *N* numbers in the range 1 to *M* with no duplicates? Firstly, and obviously, *N* &lt;= *M*. If *N* is roughly the same size as *M* then use the array-and-shuffle method. If *N* is smaller than *M* you want to use a sampling approach which is a little more subtle but still fairly straightforward. Pseudo-code [disclaimer: this is written off the top of my head, off-by-one and other errors may lurk]: 1. `N` &lt;- desired size of output 2. `M` &lt;- maximum number in output (i.e. choose random values from 1 to `M`) 1. `output` &lt;- empty array 2. for `m` from 1 to *M*: 1. { Trivial case of the first `N` values } 1. if `m` &lt;= `N` then 1. append `m` to `output` 1. goto next iteration 1. { Otherwise, for subsequent values there are `N` values in output and we've considered `m`-1 values previously. The probability that this new value is in the output is `N`/`m`. (See exercise 1.)} 1. `r` &lt;- random integer from 1 to `m` 1. if `r` &lt;= `N` 1. { `m` will appear in output. Set a random element of the output array. Note that in C one needs to use 0-based indices rather than the 1-based used here. } 1. `idx` &lt;- random number from 1 to `N` 2. set element `idx` of `output` to `m` Look carefully through this pseudo-code and implement it in C. Particularly, work through the code in the case where `N` is 1 and `M` is 2 and see why that works. Exercises: 1. Is my statement "the probability that this new value is in the output is `N`/`m`" subtly wrong? What assumptions have I made generalising the `N` = 1 case? 2. Google "sampling random values from lists without replacement" and read up on this technique. It is a very common interview question. 3. How would you check the the program to make sure that all the numbers from 1 to `M` have an equal chance of ending up in the output? Can you write a program to check the output?
the 2nd! I need to generate 10 numbers in the range 1 to m with no duplicates
I updated the original post to contain some more details.
If you have a hard time visualizing this, download [Stellarium](http://www.stellarium.org/). It's free and visually adds the coordinate system. It will give you a better understanding of how it works. You can also put in your coordinates and find the angels. Good luck!
Brute force is what you'd do if you were filling the array yourself, and adding each new random entry a week later (so you wouldn't remember any of the previous ones). "OK, I've got 23 as the third random number. Is it in the first entry? Second entry? Nope, good, I'll add this."
You may also look into using a [heliostat](http://en.wikipedia.org/wiki/Heliostat).
No source is required in C_programming as this is a discussion subreddit, i mentioned C++ because thats exactly what the program was written in ( therefor it has all the features of a modern well supported language ), the core and point of interest in a raytracer is always going to be pure C for obvious reasons. I figured YOU guys of all people would easily understand such nuances.
They were severe, the penalty for making just one L3-miss per-pixel is very extreme. Unfortunately referencing a class member causes dependent sparatic aliasing memory access, and in some cases may even incur an unpredictable branch, not something you can afford to be doing hundreds of millions of times a second. Removing all classes ( let alone virtual memory functions and declarations ) is the only way to approach this kind of performance. We also don't use static individual functions - the core is a monolithic marching kernel.
Understanding pointers really is key to deeply grasping everything in C. your computer is just a calculator with memory. C is just math equations with pointers. Everything in C ( functions, variables, arrays, etc... ) is actually just a pointer - what separates various features is a little bit of use-specific math. You must FULLY understand pointers to be an efficient C programmer.
One easy way to solve your problem is to create two for-loops that's nestled and: Loop a) Stores a "random" number in possition i, and then Loop b) controls if there are any dubble entries, if there is: generate a new "random" number and restart loop b. (Basically each new number that's added in possition [i] is compared to all other entrys before that) int main() { int array[10], i, j; srand(time(NULL)); for (i = 0; i &lt;= 10; i++) { array[i] = (rand() %10) + 1; for (j = 0; j &lt; i; j++) { if (array[i] == array[j]) { array[i] = (rand() %10) + 1; j=0; } } } return 0; }
&gt; They were severe, the penalty for making just one L3-miss per-pixel is very extreme. Unfortunately referencing a class member causes dependent sparatic aliasing memory access, and in some cases may even incur an unpredictable branch, not something you can afford to be doing hundreds of millions of times a second. Not wanting to be rude, but you sound like a Markov chain which has been trained on a book on hardware. That being said a) I wanted reproducible numbers and b) nothing you've said here is any less true of structs. Indeed the difference between `class` and `struct` is there precisely to allow you to say "no Mr Compiler, I'm cleverer than you." &gt; Removing all classes ( let alone virtual memory functions and declarations ) is the only way to approach this kind of performance. We also don't use static individual functions - the core is a monolithic marching kernel. "Virtual memory functions"? Really? Unless there's some deep kernel juju going on, you're using functions which operate on virtual memory :). "Virtual functions", on the other hand, are different and I explicitly excluded them in the original post. I'm going to have to echo some other commenters and say you sound like someone *trying* to use big words without necessarily *understanding* them. This is in no way meant to belittle your acheivement, it's just a note that people will probably appreciate it more if you don't come across as, well, to put it bluntly, a cocky arsehole.
&gt; Were gonna wait on releasing the source until someone sends us a shutdown in the form of a more efficient primary visibility resolver ( 3D raycaster ). I'm not sure I understand this sentence but without the ability to measure the efficiency of your code (i.e. having source or, at the very least, a runnable binary) how is someone going to a) determine if their solution is more efficient and b) decide it is sufficiently better to send to you? So you're not going to let people run it until someone shows that they can beat it? And, in the meantime, not publish any numbers which *let* people decide that? Seems strange. &gt; The only system we currently know for sure beats our system is Unlimited detail by Bruce Dell. unfortunately we cant compare against his source either : P Last time I checked, that system was a point cloud renderer. (And, additionally, as a by-product of it's algorithm one that did spatial anti-aliasing which your system quite obviously does not.) Your system is a axis-aligned bounding box voxel renderer. Similar but not *quite* comparable.
&gt; I figured YOU guys of all people would easily understand such nuances. See? *This* is why people are downvoting you.
Please indent all code with 4 spaces so the formating does not get broken. Also a short description of what you are trying to achieve will make it easyer for people to help you. "do the entries from a file for 1000 values" is not terriby descriptive.
Lets try that. thanks for the tip
Besides the fact that the resolution, framerate and computer specs are dispalyed clearly... no tracer even comes close that we have seen ( with the given resources ) so were confident we'll have no trouble identifying. Anti-aliasing ( pixel coverage ) is neither simple nor fixable. The case of high frequency missmatch which unlimited detail deals with is a form of undersampling called minification - their technique is logically equivalent to a 3D mip-map, it is not a correct fix, it does not help with anistropy and frankly such coverage approximation techniques are trivial to implement even in our archaic 'axis-aligned bounding box' system. Thanks.
I ran your code trough a style fixer and added some comments of my own. #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main () { int i,j,k,a,b,c,x,y,z,ll,ul,m,ct=0; int w[ct] [3]; /* array of size [0][3] */ int data[1000] [3],mpik[1000][4]; int mpx[1000][4]; int wc[10][3]; x=0.1;; /* int can not hold a decimal value, use float or double */ for (i=0.1; i&lt;=1; i=i+0.1) { for (j=0.1; j&lt;=1; j=j+0.1) { for (k=0.1; k&lt;=1; k=k+0.1) { w[ct][1]= i; w[ct][2]= j; w[ct][3]= k; ct=ct+1; } } } printf("Enter values of A,P and U one by by\n"); for(a = 0; a &lt;=1000 ; a++) { /* scanf returns the number of values read. You want to verify that * it returns 3 in this case. */ scanf("%d,%d,%d",&amp;data[a][1],&amp;data[a][2],&amp;data[a][3]); } k=0; for(i=1; i&lt;=ct; i++) { for(j = 0; j &lt;=1000 ; j++) { mpik[k][1]= w[i][1]*data[j][1]+w[i][2]*data[j][2]+w[i][3]*data[j][3]; mpik[k][2]=w[i][1]; mpik[k][3]=w[i][2]; mpik[k][4]=w[i][3]; k=k+1; } } printf("Enter values of lower limit\n"); scanf("%d",&amp;ll); for(i=1; i&lt;=k; i=i+1) { if(mpik[i][1]&lt;=ll) { c=0; mpx[c][1]=mpik[i][1]; c++; mpx[c][2]=mpik[i][2]; mpx[c][3]=mpik[i][3]; mpx[c][4]=mpik[i][4]; } for(i=1; i&lt;=3; i++) { for(j =1; j &lt;=10 ; j=j++) { wc[i][j]=0; } } for(i = 1; i &lt;=c ; i++) { for(j = 1; j =3 ; j++) { if (mpx[i][j]=0.1) { /* this asigns 0.1, == is a comparison. */ wc[1][j]=wc[1][j]++; } switch (mpx[i][j]) { case x: wc[1][j]=wc[1][j]++; /* This continues into the next case. I assume you have * forgoten a break statement. */ //break; case 0.2: /* switch on a decimal value only matches /exact/ matches, * 0.19999 wil not. I expect you mean something like * if( mpx[i][j] &gt; 0.2 &amp;&amp; mpx[i][j] &lt; 0.3 ) * If so, this is easier with a giant * if(...) {...} else if(...) {...} */ wc[2][j]=wc[2][j]+1; case 0.3: wc[3][j]=wc[3][j]+1; case 0.4: wc[4][j]=wc[4][j]+1; case 0.5: wc[5][j]=wc[5][j]+1; case 0.6: wc[6][j]=wc[6][j]+1; case 0.7: wc[7][j]=wc[7][j]+1; case 0.8: wc[8][j]=wc[8][j]+1; case 0.9: wc[9][j]=wc[9][j]+1; } } } /* I added the last two }'s. You should verify that placing them * on the end was correct. */ } } 
Well thanks i have studied computer hardware : ) We have not developed a fully OO version of the tracer against which to compare and because of our results with the test-cases we tried; random-world-access, ray perspective rotation and marching were probably not going to try. The exact performance dent incurred by use of c++'s class hierarchy is extremely simple to determine; it is just a standard pointer deference. The reason class dereferencing is unacceptable in performance critical code relates to the behavior of the cache - namely it necessarily a dependency of the following dereference, The location of each class pointer is not inherently task coherent and will therefor often not be cached - causing sparatic memory access, Lastly the class address itself is inherently very close to the data within that class - which will stress cache-line aliasing when mixed with ambiguous pointer code ( ofcoarse we always apply -strict aliasing to the raytracer anyway ). You should have no trouble determining the exact penalty for using OO in any particular case, remember it's just a memory access with the properties stated above ( it is very common for badly managed memory to have all these properties and more ). Using structures is nothing like using classes; none of the above stated properties hold true for structures. In fact, the exact format of all structures is known at compile-time so they are simply an abstraction of constant address offsetting; we certainly do use structures. There is certainly no performance penalty for using structures as they make no effect on the assembly. I was referring to "virtual functions" and "virtual declarations" (a another name for dynamic memory allocation), very basic features of C++. Kernels are simply tasks which are repeated - think of them as the body of loops, we put all our code into a large single loop which processes chunks of work in-order to avoid the processing stalls incurred by function calls - there is no juju involved I'm afraid. the performance dent incurred by function overhead is also very simple to solve - the cost usually slightly higher than that of a branch. ( too high ) I know exactly why i use the words i do, I do not know what makes you think i don't 'necessarily' understand them, i will be happy to prove you wrong should you develop any specific complaint. I can't imagine what you might say to belittle a program ?, unless of-coarse you have a much better one.. I'm very sorry if i appear to you as a cocky arsehole - all i can say is maybe you should take some care in developing your obviously informed judgments - next time wait until YOU understand what someone is saying before assuming they don't. Thanks : )
So sip was already installed on my system, I tried to uninstall it but since it was critical to other major packages (like the KDE Desktop etc.) I didn't uninstall it and decided I will try to build PyQt first. Since the PyQt package I have downloaded also has a sip directory, I thought it would compile it too, no ? 
&gt; Actually there is a significant difference; structs are like an abstract const class; there dereferenceing is free and we use them. There is one difference: the compiler is allowed to re-order the layout of classes in memory. That's it. Sorry. You can use structs in C++ exactly as classes if you want to preserve ordering. &gt; Sorry, "Virtual functions" and "dynamic memory" i thought you'de be able to understand what im talking about. Sorry, my telepathy is weak today. I have to go on what you wrote rather than what you meant in your head. &gt; Better luck understanding next time buddy. *rolls eyes*
&gt; If someone doesnt understand the relationship between C and C++ then they should not down vote Based on that non-understanding. &gt; If someone doesnt know whether source-code is appropriate or not, they shouldnt down vote based on the presence of lack of source code. Since you want to squirm and spin your own words to such a degree, may I offer related advice?: If someone doesn't understand the importance of tailoring a post to a particular subreddit, they shouldn't post in that subreddit. If someone doesn't understand that C programmers are probably interested in *actual* C code rather than assertions about algorithms, that someone should probably not post in a C subreddit. 
&gt; Besides the fact that the resolution, framerate and computer specs are dispalyed clearly... no tracer even comes close that we have seen ( with the given resources ) so were confident we'll have no trouble identifying. Neither framerate nor resolution are in the YouTube description as of Thu May 22 14:37:25 BST 2014. What with YouTube re-encoding I cannot trust the framerate or resolution of the video to match. Let's be charitable and assume, in the absence of other numbers, the YouTube video's actual maximum resolution of 640x360 and 30 fps. Since I have to take your numbers at face value, I shall take benchmark figures from other raytracers at face value. Picking a CPU raytracer at random from the Google hits, we have https://embree.github.io/ which on a comparable (but *not* identical) CPU claims around 10M ray/s. This is on a generic 'sea of triangles' scene after building a BVH. I'm assuming that your system has *some* form of heirarchical data structure and is not just a "sea of boxes". Let's assume, therefore, that comparing pre-calculated BVH to your pre-calculated structure is fair[1]. On a 640x360 image, this translates for 43 fps which beats what I can determine from your YouTube video alone. Now, *obviously* your renderer might be better than this. But can you see that I have no way of *testing* this? Rather than believing your assertions my prejudice (and that of others) will be that someone who attempts to throw buzzwords and claims with no numbers to back them up and with no actual code to test is full of the proverbial. &gt; Anti-aliasing ( pixel coverage ) is neither simple nor fixable. The case of high frequency missmatch which unlimited detail deals with is a form of undersampling called minification - their technique is logically equivalent to a 3D mip-map, it is not a correct fix, it does not help with anistropy Low-pass box filtering a 3D voxel field will not suffer from significant anisotropy-related artefacts. To put it another way: the image of a cube has roughly the same aspect ratio no matter which direction you look at it from. Anisotopy-correction is required for "minification" of planar textures (such as the surfaces of your voxels), not point clouds. Again, I'm not claiming UD or your system to be any better or worse than each other. Just that they're not quite equivalent and that UD has a significant advantage over you just in terms of the problem it's trying to solve. If I may be colourful: if you took the time to climb down from your high horse for a moment I was indicating that UD out-perfoming you does not reflect poorly on your system. &gt; and frankly such coverage approximation techniques are trivial to implement even in our archaic 'axis-aligned bounding box' system. Indeed. Trival. (Or, at least, well understood.) It certainly doesn't require additional rays to be traced to get texture filtering as good as modern raster graphics. Removing edge aliasing will require additional tracing however. In your system you'll need aniotropic MIP-maps to correct the texture sampling. In the UD system the spatial-box filter is just that: spatial. [1] Already I have to make significant assumption because there's no *actual* implementation I can play with.
You are failing to comprehend. I said "Whats with the downvotes?, Comment if you don't understand or dislike something !" I have in absolutely no way revoked, skewed or spun that message, maybe try a little harder while reading : ) The rules for C_Programming are extemely simple Your advice regarding Reddit is dead wrong and your wording appears to carry the spitefulness of a frustrated child. BTW. I have plenty of C code over here buddy, and i really appreciate being able to share what i have made using C in this here, C programming forum, I'de be quite happy to share techniques and source with whom-soever i determine not to be an angry half-wit : )
That code does not compile. Please provide a short, self-contained, compilable example that demonstrates the problem you are having. $ clang -std=c99 -Wall -Wextra -o program program.c program.c:3:25: warning: declaration of 'struct VGA' will not be visible outside of this function [-Wvisibility] void paieska(struct VGA vgas[100], int c) //Search function ^ program.c:3:33: error: array has incomplete element type 'struct VGA' void paieska(struct VGA vgas[100], int c) //Search function ^ program.c:3:25: note: forward declaration of 'struct VGA' void paieska(struct VGA vgas[100], int c) //Search function ^ program.c:7:13: warning: implicitly declaring library function 'printf' with type 'int (const char *, ...)' printf("Iveskite ieskomos plokstes pavadinima (TIKSLUS PAVAD... ^ program.c:7:13: note: please include the header &lt;stdio.h&gt; or explicitly provide a declaration for 'printf' program.c:8:13: warning: implicit declaration of function 'gets' is invalid in C99 [-Wimplicit-function-declaration] gets(bufferis); ^ program.c:11:25: warning: implicitly declaring library function 'strcmp' with type 'int (const char *, const char *)' if (strcmp(bufferis, vgas[g].name2) == 0) // if foun... ^ program.c:11:25: note: please include the header &lt;string.h&gt; or explicitly provide a declaration for 'strcmp' program.c:15:29: warning: implicit declaration of function 'system' is invalid in C99 [-Wimplicit-function-declaration] system("PAUSE"); ^ program.c:16:29: warning: implicit declaration of function 'nrlist' is invalid in C99 [-Wimplicit-function-declaration] nrlist(vgas, c, g); ^ program.c:9:18: warning: expression result unused [-Wunused-value] for (g; g &lt; c; g++) // c is the array count of my structure array ^ program.c:25:28: error: array has incomplete element type 'struct VGA' struct VGA vgas[500]; ^ program.c:25:20: note: forward declaration of 'struct VGA' struct VGA vgas[500]; ^ program.c:26:13: error: use of undeclared identifier 'FILE' FILE *csv; ^ program.c:26:19: error: use of undeclared identifier 'csv' FILE *csv; ^ program.c:27:17: warning: implicit declaration of function 'pildymas' is invalid in C99 [-Wimplicit-function-declaration] g = pildymas(&amp;csv, vgas); ^ program.c:27:27: error: use of undeclared identifier 'csv' g = pildymas(&amp;csv, vgas); ^ program.c:36:13: warning: implicitly declaring library function 'scanf' with type 'int (const char *restrict, ...)' scanf("%d", &amp;choice); ^ program.c:36:13: note: please include the header &lt;stdio.h&gt; or explicitly provide a declaration for 'scanf' program.c:40:29: warning: implicit declaration of function 'list' is invalid in C99 [-Wimplicit-function-declaration] list(vgas, g); ^ program.c:43:29: warning: implicit declaration of function 'insertion' is invalid in C99 [-Wimplicit-function-declaration] insertion(csv, vgas); ^ program.c:43:39: error: use of undeclared identifier 'csv' insertion(csv, vgas); ^ program.c:46:29: warning: implicit declaration of function 'edit' is invalid in C99 [-Wimplicit-function-declaration] edit(csv, vgas, g); ^ program.c:46:34: error: use of undeclared identifier 'csv' edit(csv, vgas, g); ^ program.c:54:29: warning: implicitly declaring library function 'exit' with type 'void (int) __attribute__((noreturn))' exit(0); ^ program.c:54:29: note: please include the header &lt;stdlib.h&gt; or explicitly provide a declaration for 'exit' program.c:59:13: warning: implicit declaration of function 'fclose' is invalid in C99 [-Wimplicit-function-declaration] fclose(csv); ^ program.c:59:20: error: use of undeclared identifier 'csv' fclose(csv); ^ 14 warnings and 8 errors generated.
The framerate is displayed during the video - because it's a frame rate. The video resolution is exactly as it says - verify that using mspaint. If you have trouble calculating how many millions of rays per second that is then just ask, it's super easy ; ) Anisotropic surfaces are surfaces which are close to oblique from the perspective of the camera, they generally result in extreme under-sampling. it has nothing to do with "Low-pass box filtering", aspect ratios or point clouds, no one has solved sampling anisotropy. i don't know what the heck you Though i was talking about. Implementing mip-mapping is extremely easy, each pixels world surface collision distance is known, i just select from a number of different sized textures based upon that distance, there is nothing more to it, it's a cheap trick to get rid of jaggies / "high frequency sampling missmatches" it also drains alot of detail and it's just generally a poor excuse for filtering... i have versions here which do various kinds of filtering however the version i used in the video is unfiltered as its irrelevant to performance (it can even be a place to cheat some extra performance). I'm sorry you don't have the data you'd like, but the relevant data is available... the world contains approximately 10,000,000 triangles, the tracer correctly resolves 6,912,000 rays per second ( at 1920x1080, while the program is not recording each image to disk we get 20,000,000 ).. what else is relevant ?
It's the first function in my OP pastebin
Bad timing on your post hey.. Anyway structs are value types, classes are reference types.. they are not equivalent - structs Are fast - classes Are slow. ( that is; assuming your really pushing the the pedal to the metal )
I'm on my phone and very rusty. So, void paieska(struct VGA vgas**[100]**...) In the header: void paieska(struct VGA*, int); In menu() struct VGA vgas**[500]**; Wait I'm confused. What size is this supposed to be?
See the list of resources in the sidebar.
Your program appears to be constructed based on a very flawed understanding of how C works; there are too many problems for me to list out right now. I think your crash is most likely due to `g = pildymas(&amp;csv, vgas);` because `int pildymas(FILE*, struct VGA*);` means that you are expecting a `FILE *` as a parameter, but since the line `FILE *csv;` says that `csv` is already a `FILE *`, using `&amp;csv` at your call site means you're supplying it with a `FILE **` instead, or the address of the variable `csv` on the stack. You are going to scribble all over your stack that way, and it's no surprise that things are getting corrupted somewhat randomly. Please turn on your compiler's warning facility and fix the warnings. It's not just being a pain, it's trying to help you get your program right. You should be getting pages of warnings from that code. If you fix them all and still have trouble, then come back for help.
The number in the brackets in the function definition means nothing to the compiler. You can't actually declare an array parameter; C just allows using the brackets as an alternate syntax for declaring a pointer parameter.
Please turn on the option for your compiler to produce warnings. It will catch many of the things pbeard_t very helpfully pointed out for you, though probably not all of them. I am guessing that your crash is primarily due to the fact that `int w[ct][3];` is allocating a 3-element array on the stack (since `ct` is 0) and you are writing far more than 3 values into it because your `for` loop initializing it is actually an infinite loop. Adding the floating point literal `0.1` to an integer truncates the `0.1` to `0`, so your loop counters never increment but your `ct` index does. It's happily writing `0` throughout your entire stack space until it reaches an address that causes a segmentation violation. Your compiler should be warning you about assigning floating point values to integer variables; if it's not, you should increase its warning level.
These are linker errors. The code compiled correctly, but it refers to some symbols that should (I am guessing) be in the libqpycore library but are not. The missing symbols look like they are from the Python C API; if that's not statically linked into libqpycore, then you may need to add an extra -l parameter to the link rule in the makefile to add the python library. Look at the docs for python's API to see how to run the tool that will give you the right build flags to link with it.
Fixed as much as I could, these five remain: http://i.imgur.com/9SEm52c.png Is it wrong to think that 1-4 are harmless? What does the fifth entail?
Well, "harmless" is relative in the world of floating point. Using doubles gives you much better numeric precision. But you should not get crashes from these warnings. Floating point literals are `double` by default; append the letter `f` to a floating point literal to make it `float` instead. E.g. use `1.5f` instead of `1.5` if you're assigning it to a `float`. The differences in the warnings seem to be due to the difference between assignment and initialization. Basically they're the same issue in slightly different circumstances.
they even invented utf-8 :)
Will I be changing the makefile manually or indirectly ? (change another source file that will the makefile) ?
Sorry, I'm not familiar enough with the Qt build process to tell you for sure how it works or what you'll need to know to fix it. I usually try to manually run the command that failed and reproduce the failure, then experiment with things until I can get it to succeed. Then I look into fixing the build system with the change that I already know works.
Also, you need to think about how your `if`/`else` statements work. &gt; if (userInput == 1) &gt; { &gt; printf("Your selection was Call Me Maybe\n"); &gt; printf("Lryics here\n"); &gt; } else { &gt; printf("Please give me a valid number\n"); &gt; return 1; &gt; } Think about what this code does. If the value of `userInput` is&amp;nbsp;1, then it prints the lyrics for "Call Me Maybe," and if the value of `userInput` is anything else (including 2&amp;nbsp;or&amp;nbsp;3), then it prints "Please give me a valid number" and *exits the program* with status code&amp;nbsp;1. The rest of the program won't even be executed if `userInput` is not&amp;nbsp;1, because the `else` block here will be executed, and that block includes the statement `return 1;`, which will terminate the program.
Yes, but `scanf` converts that for you. That's what the `%d`&amp;nbsp;specifier is for. That specifier tells `scanf` to read characters that represent an integer, convert those characters to an `int` value, and store that `int` value in the corresponding argument. You aren't reading a *character* from standard input when you use the `%d`&amp;nbsp;specifier—you are reading an *integer value*.
Oh thank you for my bug there
Since there are so few vowels to compare against this could be done with a switch statement using fall-through. Technically it would be faster, but yours is more scalable if you add more to your filter than just vowels. You checked for the number of arguments passed in with (argc != 1) and print the proper usage, but then you don't return (or exit) from main(). Also, I'm sure you know this, but VOWELS[] is already a global variable so it could've been used in is_in() without passing it in as a parameter in main(). But it's probably good practice to pass arrays/pointers like that. I liked it though. I've actually never used the ctype library before. I should remember to use it next time I'm playing with chars. I found a real gem under stdlib a while back in the form of qsort(). It's a sort where you specify the data types and comparison function. Neat!
An excellent first try! /u/Niten had a lot good suggestions. I'll add that your error message, and possibly your usage statement, should go to standard error using fprintf(stderr, "string..\n"); Your usage statement isn't correctly formatted. It is missing the \n character from the second string and from the first string, or at least add a space after the %s, your choice. Your "input" variable type should be "int" not "char". I know, it seems counterintuitive, but check the return type of fgetc() and the first argument type of fputc().
&gt; Your "input" variable type should be "int" not "char". Oh good catch, I totally missed that.
I've been programming in C for almost 5 years now and while I don't mess with strings all that much, I've never seen or thought to have the for loop condition of b[i] That's pretty slick! I would've had: int is_in(char a, char *b, int len); and called it like: is_in(tolower(input), VOWELS, sizeof(VOWELS)/sizeof(VOWELS[0])) Thanks!
Apart from the little wrinkles mentioned elsewhere, the only moderately serious thing I can think to say is that for any serious use, you probably don't want to be processing/buffering the data one character at a time.
So for example copy/paste the g++ command line with all options and manually add missing -l flags. I did this once, but I didn't know in what file to add this missing -l flag. It's remarkable how relatively easily you can find programming experts but so few building experts O_o. I'll try the mailing list again.
&gt;but UTF-8 in particular may work just fine For certain values of "*may work just fine*" which mean "*doesn't work*".
I like your indentation style! Here are a couple of suggestions: * Don't be too smart. It is said that you need to be two times as smart as when you wrote your program to debug it. Therefore, if you write a very smart program, you're not smart enough to debug it. That said, don't use fancy things like for (i=0; b[i]; i++) obey the rule of thumb that you should only use things as conditions that are actually logical values. Use something like this instead: for (i = 0; b[i] != '\0'; i++) * your "can't happen" is unneeded. Every good compiler will detect that this place cannot be reached and throws out your printf. * Your usage code does not print any newlines. I doubt this is expected.
Nope. Works perfectly for UTF-8. Any byte in a UTF stream that doesn't represent an ascii character has the highest bit set, so all non-ascii characters will be passed through, and this script will still strip out all a, e, i, o, and u characters, while leaving everything else unmolested. Perhaps you meant it doesn't work because it fails to strip out non-ascii vowels. In which case you're right, but in a trivially obvious way: The script will indeed fail to strip out, for example, α, и, or ü characters. 
It might help your debugging if you print the value of what the user entered, such as: scanf("%d", &amp;userInput); printf("You entered: %d\n", userInput); If you do this, you'll see (as another commenter noted) that you've read their input as an integer and not an ASCII character. Once you do that, and remove the "userInput - '0'" piece, you can go back to a switch statement (which is a logical choice here). #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main (void) { int userInput=0; printf("Please give me a song: Your choices are, \n\n1. Call me maybe\n\n2. Team \n\n3. Happy\n"); scanf("%d", &amp;userInput); printf("You entered: %d\n", userInput); switch (userInput) { case 1: printf("Call Me Maybe\n"); break; case 2: printf("Team\n"); break; case 3: printf("Happy\n"); break; default: printf("Please give me a valid number\n"); } }
Here's a suggestion for a speed optimization, at the cost of a constant 256 bytes of memory: Every time you evaluate a character, you perform up to five comparisons, and you perform the full five comparisons every time you encounter a non-vowel (which is most of the time, in normal text). Instead, try creating a data structure which contains the pre-calculated results of the comparison for each possible character, and just access the results directly. To do this, you create an array that is 256 bytes long, where each index corresponds to the numeric value of a possible character (array[65] = A, array[111] = o). #include &lt;string.h&gt; const char vowels[] = "AEIOUaeiou"; char vowel_match[256]; unsigned char c; int is_vowel(char a) { return vowel_match[a]; } int main(int argc, char *argv) { /* Initialize vowel_match */ memset(vowel_match, 0, 256); for (c=0; c&lt;len(vowels); c++) { /* set vowel_match[x] = 1 where x is a vowel */ vowel_match[vowel[c]] = 1; } /* Do stuff */ } Now you are doing one array index operation, and zero if statements for each character in your input stream, with a fairly small cost up front for computing the vowel_match table. If you are dealing with very short strings, it might be slightly slower for very short inputs (equal to or less than the length of VOWELS), but you could save the start-up cost by pre-computing the table, so it is already created at compile time. It would make the program a little uglier and a little faster. char vowel_match[256] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, ... 0, 1, 0, 0 }; /* Not accurate */ These optimizations are by no means essential. Your program does what it's supposed to do, and five comparisons aren't particularly. However, it is useful to learn about common data structures, because using the right one can make a huge speed difference in a program of any significant size. **Edit:** Also, by including upper and lower case vowels, you can leave out the tolower() call, and save a function call for every character in the string.
&gt;Perhaps you meant it doesn't work because it fails to strip out non-ascii vowels. This program's raison d'être is stripping vowels. By definition failing to strip vowels (ASCII or otherwise) means that it is not working.
Vowel is difficult to define. Is "y" a vowel? Is j? Is ÿ? Suddenly, we have a program which has to consult the locale to figure out what a vowel is.
Learn to visualize your program as instructions operating on data stored as bytes in addressed memory. This is another way of saying "master pointers." There's a good book, [*Understanding and Using C Pointers*](http://www.amazon.com/Understanding-Using-Pointers-Richard-Reese/dp/1449344186), which may help with this. With most modern languages, you can think in terms of the abstractions the language provides, and get pretty far. For example, you can program in java thinking about your program in terms of classes and methods, and public and private data. This won't work with C. You're dealing with numbers stored in memory. Even when you are dealing with an abstraction like strings, you have to remember that the string is just numbers stored in memory. Any attempt to gloss over this fact will end in pain.
&gt; First, prefer a const char pointer for VOWELS, as this is not intended to be mutable data. More information here. That's really interesting to me. My first programs where written in embedded C (back in my mid-teens), but when I hit uni we were taught C# for the first year. In C#, strings are immutable by default (they get copied when more data is inserted, I believe). So, I'd always thought that char[] (which is what a string is) were always immutable. Thanks for the info.
&gt; It's remarkable how relatively easily you can find programming experts but so few building experts O_o. That's because build systems suck!
&gt; (input = getchar()) != EOF I had no idea you could do this outside of Perl. That's really good to know! So even though `input` is now the result of `getchar()` we're still testing the result of `getchar()` against `EOF`?
C has string literals, but doesn't have strings as a special datatype. C strings are just a convention regarding how to treat a sequence of `char` in memory that's terminated by a NULL `char`. String literals, when assigned by value to a char *, decay to a pointer to an allocation of static extent that's initialized by the compiler and ought to be treated as immutable; mutating it is undefined behavior. But they can also be used to initialize a char[] variable, in which case mutability is just fine because the contents of the string literal are copied into the allocated array. A wrinkle in this picture was introduced by ANSI C which introduced the `wchar_t` type. Support was extended to a more useful level by an '95 addendum. These changes standardized the `wchar.h` library, which provides the `wchar_t` type for storing "wide characters", a `wint_t` type as an integer type large enough to store any `wchar_t` value, and a series of functions like those in `string.h` for working with NULL-terminated arrays of them. These changes included wide-string literals, which are syntactically like standard string literals but with a `L` prepended: e.g. `L"This is a wide string literal"`. If you use these (or any compiler support for non-ASCII charsets), be aware that the size and encoding of `wchar_t` is implementation-defined, as is the way to actually put non-ASCII characters into string and wide-string literals.
The `sizeof` operator is defined to always return `1` for a `char`, so there's no point in dividing by `1` to determine the number of elements. On the other hand, the compiler will most likely optimize that away for you, and I suppose you might prefer to use the idiom for determining the number of elements in an array everywhere you want the number of elements in the array rather than its size in `char`s. This way of always passing a length parameter for string functions is arguably safer than relying on NULL-termination, but both rely on programmer discipline to ensure that you won't access beyond allocated boundaries; either way you need to define some strict conventions for working with strings, document them, and ensure they're followed in order to avoid undefined behavior and attendant bugs, many of which could cause serious security flaws.
Yep, technically we're testing the value of `input` after the result of `getchar()` is assigned to it. From the [C standard §6.5.16 [PDF]](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf): &gt; An assignment operator stores a value in the object designated by the left operand. An assignment expression has the value of the left operand after the assignment, but is not an lvalue. The type of an assignment expression is the type the left operand would have after lvalue conversion. (Note: the linked document is not the official C11 standard, but is the proximate draft of the standard publicly available from ISO. [See this page for more information](http://www.iso-9899.info/wiki/The_Standard#C11).)
Wow! Thanks for the details.
True. The covention makes it easier to avoid errors though, like a forgotten or extra *. 
Yes, the reason being is that "char" type is not designated signed or unsigned. With ISO C, the signness of char is implementation-defined. Therefore, code like "(input = getchar()) != EOF" will work just fine on a signed char system, but fail on a unsigned char system. By using int, you (and those functions) sidestep the whole signedness mess.
Is it actually being downvoted? I see it as +5 right now.
Here's how I would do it: #include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; bool is_vowel( unsigned char const c ) { static bool const table[ 256 ] = { ['A'] = true, ['E'] = true, ['I'] = true, ['O'] = true, ['U'] = true, ['a'] = true, ['e'] = true, ['i'] = true, ['o'] = true, ['u'] = true // Any non-specified elements default to `false`. }; return table[ c ]; } int main( void ) { int c; while ( c = fgetc( stdin ), c != EOF ) { if ( !is_vowel( c ) ) { fputc( c, stdout ); } } } I'm not one to prioritize speed, but this will be significantly faster than your code or /u/Niten's. The `is_vowel` function is compiled into just two operations: movzbl %al, %edx cmpb $0, table.1944(%rdx) While this code is similar in spirit to /u/jcdyer3's, their code is (a) more complicated, and (b) slows start-up time by setting up the array at run-time. My code has `is_vowel`'s `table` compiled into the `rodata` (read-only data) section of the binary, ready to work with straight away. The above syntax used in the definition of `table` uses [designated initializers](http://www.drdobbs.com/the-new-c-declarations-initializations/184401377). Many C programmers like to pretend it's still 1995 and think these new-fangled (as of 1999) inventions are scary. Ignore them - C99 brought a ton of really nice stuff, and your code will be much better if you make use of it. Although my code only uses `const` twice, you should use it whereever you can, because it makes your code much easier to understand. If a reader can look at an initialization, and be sure that that value won't change throughout the rest of the scope, they can reason about the rest of the code much easier. `const` helps decrease the load on your reader's working memory. Also, note that C does have a boolean type - you just have to include `stdbool.h` if you want to use it. Whenever you have a binary value (i.e. true or false, on or off), you should use `bool`. It's no more efficient than using `char`, but it makes your code easier to reason about. When you have a function returning a `char`, you're saying that this function can return 256 different values - not 2. You've had a few responses suggesting an expression like: while ( ( c = fgetc( stdin ) ) != EOF ) { ... Although it's not a big deal in a simplistic example like this, you'll see lots of C code that goes way overboard with this kind of syntax. For simplicity and consistency in my code, I just never use that syntax. Instead, as above, I used the comma operator to separate it into two expressions, because that reads from top to bottom (as good code should, IMO). Similarly, you'll see code like: char * x; if ( ( x = malloc( 128 ) ) == NULL ) { Your `if` expressions should **only** be testing for logical values - not changing state. I think this alternative reads much more naturally: char * const x = malloc( 128 ); if ( x == NULL ) { This way, the `if` expression is much clearer as to what it's testing. Also, by taking out the assignment, you can use `const` on the pointer! There are lots of ways you can write bad C code. I could go on for hours about best C programming practices. I wrote this [C Style](https://github.com/mcinglis/c-style) document a few months ago (it pissed off a lot of people in this subreddit) - my opinion has changed on a few sections, but I think it might still be valuable. I'll update it some day.
In addition to what /u/zifyoip said, the decimal value of the ASCII character '1' is 49 (0x31 in hex). And the decimal value of '0' is 48 (0x30 in hex). 
The point of doing that even on a char array is exactly as you stated in your second paragraph. It's a good habit to get into in my opinion. You could also argue that you could've used strlen() as well, but as far as arrays go, I like the sizeof(myArray)/sizeof(myArray[0]) idiom, especially since changing the array element type doesn't necessitate changing your code like the following two things would: sizeof(myArray) /* assuming a char array */ sizeof(myArray)/sizeof(char) /* same thing */
&gt; debug_enabled doesn't check for calloc failure, and seems to leak if debugging is disabled. And what's up with the size of the allocation? How can that hold an indefinite number of char*? Which project are you talking about? They're all on github so presumably they accept bug reports and pull requests.
Your code is impossible to read. &lt;code&gt; ... &lt;/code&gt; tags don't work here. Instead, indent every line of code with four spaces so that Reddit formats it properly as code.
Well, let's look at those warnings one by one: === &gt; lifespan.c: In function ‘main’: &gt; lifespan.c:60:2: warning: format ‘%c’ expects argument of type ‘char *’, &gt; but argument 2 has type ‘int’ [-Wformat=] &gt; scanf("%c", userInputchar); &gt; ^ What does this say? It says that the format `%c` requires an argument of type `char *` (i.e., pointer to `char`), but argument&amp;nbsp;2 has type `int` instead. Right? Do you see what is wrong with that line of code? === &gt; lifespan.c:67:20: warning: comparison between pointer and integer &gt; [enabled by default] &gt; if (userInputchar == "y") &gt; ^ This warning says that you are comparing a pointer with an integer. Remember that double quotes specify a string, and a string is an array of `char`, and when you use an array as a value it becomes a pointer to the first element of the array. So `"y"` is a string, and when you use it as a value (as you are doing here) you get a pointer to its first element, which is the character&amp;nbsp;`'y'`; this pointer has type `char *`, i.e., pointer to `char`. You are attempting to compare this *pointer* to the variable `userInputchar`, which has an integer type. This is almost certainly not what you intend to do, because comparing an integer value with a pointer value is almost always meaningless. If you mean the *character*&amp;nbsp;`'y'`, then you need to use single quotes, not double quotes. === &gt; lifespan.c:74:2: warning: format ‘%c’ expects argument of type ‘char *’, &gt; but argument 2 has type ‘int’ [-Wformat=] &gt; scanf("%c", userInputtwochar); &gt; ^ Same problem as the first warning. === &gt; lifespan.c:80:23: warning: comparison between pointer and integer &gt; [enabled by default] &gt; if (userInputtwochar == "y") &gt; ^ Same problem as the second warning.
Every specifier for `scanf` requires a corresponding additional argument, which needs to be a pointer of the appropriate type, indicating where in memory `scanf` should store the value it reads. For example, the `%d`&amp;nbsp;specifier requires you to provide a pointer to `int`, and the `%f`&amp;nbsp;specifier requires you to provide a pointer to `float`, and the `%c`&amp;nbsp;specifier requires you to provide a pointer to `char`. You have used the `%c`&amp;nbsp;specifier, but instead of providing a pointer to `char` as is required, you have provided an `int` (because a variable of type `char` is promoted to `int` when it is passed as an argument to a variadic function like `scanf`). Note that "`char`" is not the same type as "pointer to `char`." You need to give `scanf` *pointers* to variables, not the values of the variables themselves. If you want `scanf` to store the value it reads in the variable `userInputchar`, then you need to give `scanf` the *address* of `userInputchar` (not the *value* of `userInputchar`) so that `scanf` knows where in memory it should write its result. Use the `&amp;`&amp;nbsp;operator to get the address of a variable. You should be using `scanf` like this: scanf("%c", &amp;userInputchar);
&gt; The text editor is highly customizable with python, config files are in JSON format, as well as snippets which are amazing. The plugin community is fairly vibrant as well VIM or Sublime? 
cheers, I'll go through them :)
About the Anisotropy - and i will try to avoid an argument - its clear you understand the problem - we have just failed to agree on how it applies. What i meant is that UD uses and i quote "a search algorithm to select just one little point [voxel]for each pixel on the screen" which means that they will have aliasing when there is no particular voxel which is covering a pixel... This problem goes towards infinity on a surface as the camera becomes less orthogonal - and eventually a single row of pixels covers all the voxels of that surface. ( this applies as much to a rasterizer as it does to a raytracer as it does to UD ) Your correct about the block edge anti-aliasing, we do have the ability to early terminate our rays and return a covered area of the world which would allow for cheap block-level colour averaging... it doesn't magnify individual textures at all tho, so we'll probably only use that filtering for pixels of the scene which are rendering area of the world beyond some set distance away. By the way we have no form of hierarchical data structure - its flat box-soup sitting uncompressed in RAM. ( we tried hierarchies - KD OCT BVH and found they were all too slow to traverse in realtime ) Believe me when i tell you that i wish we were able to release demos - I'm certain they would run great on everyones PC ( the program has absolutely no requirements ) and kick up a storm of interesting questions ( certainly regarding instant world loading ) unfortunately knowing alot about assembly - we also know how trivial disassembling and reverse-engineering even the most obfusfated code can be. We intend to release the software, the source and the general idea - just as soon as we make sure thats not something we will come to regret. ( say if Mojang steals it, makes alot of love and forgets to mention us ) Its really quite a shame your writing style is so unsavory - you seem like you'de have alot to bring to a reasonable computer graphics discussion.
Oh - I thought that sublime was around $70 or something.... are there two versions of it? 
&gt; a license must be purchased for continued use there it is! 
You can use sublime text indefinitely for free... If you choose to pay to get a "registered" ST it's simply a nicety to the developer, doesn't change anything about the program. The guy asks for $70 because he works hard on it and deserves it to be honest, but it's free to use. You can download the latest build at: http://www.sublimetext.com/3
&gt;A text editor is one of the most important tools for a programmer This seems pretty apparent, and one of the reasons that VIM appealed, its established, no smoke with out fire etc etc :) Sublime looks nice, I've just downloaded it and had a quick play. I had a bit of a mare the other day trying to sort out my .vimrc and stuff, I tried installing colour's and stuff and somehow got some weird `^m` windows error and ended up with nothing :(
Yea, vim's a good choice. The only reason I don't like to use it very often is because I genuinely prefer a GUI editor. I feel like both St and vim don't get in the way of my editing like an IDE or over-complexity (I'm talking to you Emacs) would. Vim also has a high learning curve lol, so expect some burns while trying to learn.
I have no idea what I'm doing with anything anyway at the moment! Not sure if that makes it the best time to learn or the worst... hmm. 
Don't typedef your structs. typedef makes it more difficult to understand your code. Write your code for someone who wants to read it and not for the compiler. Also, don't cut corners. Also, if you have top-level string constants, declare them as const: const char *allRank = "..." also, it is common in C to use underscores instead of camel case. const char *all_rank Also, read [style(9)](http://www.openbsd.org/cgi-bin/man.cgi?query=style&amp;sektion=9) on how to format your source code.
C doesn't initialize your variables. You have to do that explicitly. Also, declaring a variable in a loop header is a C99 extension. Try to avoid it so your code can compile on an C89 compiler.
Uhh. Saving this for later.
This is disgustingly fantastic.
Some programmers I knew used to NtAllocateVirtualMemory() the null page so that their programs wouldn't crash when they dereferenced null pointers. They weren't very intelligent, to be honest.
Thanks I'll take a look a that I used typedef in who_drives because it allowed me to pass two structs to a function. I couldn't pass two structs to a funciton using just struct name{}
Is it best to not use c99 things?
&gt; for (int x; x &lt; 3; x++) { Thanks can't believe I didn't do at least a for(int x =0 &gt; in postgres_test.c:98-100, if sizeof(sql11) + sizeof(sql12) is greater than 256, you will overflow your buffer. Yeah I couldn't find a good way to input the size of a string. I couldn't get strlen to work for some reason
Those are awfully absolute demands for compliance with a particular style. While adherence to a style guide is a fine thing, you should actually choose *which* style guide to adhere to (and there are many!) depending on what projects you'd like to contribute to. I'd recommend doing what reads nicely to you on your own projects, but adhere to the conventions of whatever project you submit code to without making a fuss about it. When you receive style advice on your own code that's not intended to be submitted to any particular project, I'd recommend thinking about any reasoned advice given and whether or not it might be helpful to you, but ultimately making your own call. Remaining flexible about style is ultimately more useful in the C world than trying to adhere strictly to any particular trends or advice.
&gt; And now we’ve turned a relatively simple one-line call to atoi into twenty lines of code. If this bothers you, C may not be your language.
 malloc(atoi(...)); If you write code like this, C may not be your language either.
the strtol property of allowing "garbage" at the end is useful when parsing mixed integer/string input, like csv files. also that code can be made more compact char *endptr = NULL; errno = 0; long val = strtol(str, &amp;endptr, 10); if (errno || *endptr) puts("strol error");
For example, you have to write a 5k word paper for class. You write it in VIM. How many words have you written? Go to the command interface and type ":! wc %". The colon is the command prompt, in the example. Bingo bango, word count. You can write a list in VIM, highlight just part of it, and ":! sort %", and the highlighted text with be sorted alphabetically. Or you can use command line programs over a specific range of lines - ": 20,25 ! rot13", and lines 20 to 25 will have their characters rotated 13 characters down the alphabet, modulus (so if you rotate past z, you'll go to a). These are all commands you can use at the command prompt, and you're using them in VIM on whatever buffer you're working on. This means you can write any sort of program to perform any sort of mutation or filtering of it's input, and you can run your VIM buffer through it; you can think of it as a way of extending VIM. Why write a sort function into the VIM program when there's a perfectly good sort available on the command line? And just to speak on the terminology, because I didn't read the original context before writing this, VIM uses the term "buffer" to refer to what you're editing. When you open a file, a copy is read into RAM, and when you modify it, you're modifying what is in RAM. This is the buffer. The original is still on disk, unchanged. When you save your work, you're flushing the buffer to disk, overwriting the original.
On the other end of that spectrum, I recently got a fairly significant speedup from exchanging calls to `atoi()` with calls to my macros ATOI1, ATOI2, and ATOI4: #define ATOI1(s) ((int) (*(s) - '0')) #define ATOI2(s) (ATOI1(s) * 10 + ATOI1(s+1)) #define ATOI4(s) (ATOI2(s) * 100 + ATOI2(s+2)) This is all inside a date-parsing method called hundreds of millions of times per run. The change from a single `sscanf` to manual `atoi` calls gained us even more than this change does, of course - `sscanf`is pretty wasteful for something like this.
Sorry, I absolutely refuse to deal with a question in the form of an image.
If you're aware of some optimizer flags I am not, please share them.. I don't think that it's a likely optimization, even were I not using fragments inside a single string - certainly it's an impossible one in my case. I am parsing date information out of a fixed-format string like "2013-07-12T23:45:00Z"; I'm not testing the length of each fragment and then converting it, I'm testing that the format is exactly as expected (using a straightforward state machine) and then converting pieces of it. Or are you simply referring to a *sufficiently smart* compiler?
Ah, that was it. Thanks. It's been a while since my stats class.
Yep exactly. Especially if your code is required to pass some static analysis or bug testing software to reduce the entry points for hackers.
Are you taking into account your const bonus in your HP calculation? Also the description mentions that you should handle invalid cases of user input. What happens when a user inputs -1 as the level?
You have two different string literals; they are not stored at the same address, and so they are not equal because they compare as pointers. If you want to compare string values, you need to use strcmp().
This is correct. I would suggest strncmp or strlcmp (if available) however, for better safety in real-world use cases.
In addition to the other reply about comparing strings... If you have an array of just one element, the utility of the array is not used since it is meant to hold a collection of items (more than just one). You could then shorten your variable which holds "hello" to the following: char *myString = "hello"; or alternatively: char myArray[] = "hello"; Leaving out the size when you also initialize an array allows the compiler to compute the size on its own.
Thank you, so if I'm understanding fully. The first print works because printf is being sent to that address and reading anything it finds, and the comparison fails because the address of the variable and the literal string is different? 
For one your code needs to be in a function.
Also, use MyArray[0] = strdup("hello"); What you have is asking for a segmentation fault. I'm on Mr phone so I won't go into detail, but with pointers you have to allocate memory before you assign to it.
I'm on OS X (Apple LLVM version 5.0 (clang-500.2.76) It prints `helloHello` I wrapped it in a main(void) #include &lt;stdio.h&gt; int main(void) { char *myArray[1]; myArray[0] = "hello"; printf("%s\n", myArray[0]); //this works if (myArray[0] == "hello") { printf("Hello\n"); //this will not print } } I think it's generally unsafe to assume that the compiler is going to combine and assign the string literal to the same memory location. 
Yes. To expand, in C the == operator only compares two word-sized elements, it cannot be used to compare strings. In this case, it's comparing the *addresses* of two "hello" strings, one defined in line 3 and one defined in line 5. Both those addresses likely point to the static data segment.
Maybe it was compiled without optimization?
&gt;No, MyArray is an array for pointers to strings, not an array of characters. Whe does MyArray[0] = "hello"; all he does is set the MyArray[0] pointer to point to the address of a static "hello". From what I understand, and granted its been a bit, but if you do char *str = "blah"; You're fine, but if you do char *str; str = "blah"; You get a segmentation fault.
 char *str; str = "blah"; You get a segmentation fault. What? No you dont. That is perfectly legal.
&gt; Context: http://gyazo.com/3b5e9878a6fd235e45eb2e3e6d56ebf4 http://gyazo.com/2b439244c28e64d4320c273fb3617579 http://i.imgur.com/FguROec.png http://i.imgur.com/JWpphi7.png &gt; &gt; Question: http://i.gyazo.com/5a854aa3d6f797ce242b4374db03e85e.png &gt; &gt; http://i.gyazo.com/75ddda9e22ba67c54b8963faf5170a4e.png &gt; &gt; Code I have thusfar: http://pastebin.com/Gs8rfGs2 &gt; &gt; d y : a dice of Y sides (ie d6) &gt; &gt; x d y: X number of Y sided dice (ie: 3d6 = 3 x 6 sided dice) &gt; &gt; Hitdice: The type of dice rolled for hit-points or a Class/Profession. (ie: d4, d6, d8) &gt; &gt; Skill Structure: struct Skill { char name[20], char optional[20], char short_desc[250], int stat_affinity, int ranks, struct Skill *next_Skill;}; &gt; &gt; Class Structure: struct Class { char name[20]; int Hitdice, Str_Dice, Dex_Dice, Con_Dice, Int_Dice, Wis_Dice, Cha_Dice, Skill_Points; double BAB_Type; struct Class *next_Class;)}; &gt; &gt; Is my hitpoint formula correct? Does my code seem to satisfy the question requirements? Are my Hitdice and Class structures correct? If not, how would one do this? Something like: while(1) { bonus = input(what's the bnus?); if bonus &lt; 0 { continue } else { print('bonus is $BONUSE") } } If not can you show me how you would do it?
As was suggested by /u/Nimbal, I also suspect that the reason those two addresses are combined in one and allocated once since they're the same string (which might make the above code example actually work) is because this probably wasn't compiled with optimization. Bottom line: two strings having the same addresses is not a reliable means of comparison. Using `strcmp()` (or, for more security, `strlcmp()` or `strncmp()`) is the best way of comparing strings. In fact, I believe you should be able to just replace the comparison with a function call (`if (strcmp(myArray[0], "hello"))`)
No, but "blah" is actually stored in a page marked read only, so char* str; str="blah"; //Works *str='x'; // SEGFAULT since you can not write to str. 
Check fscanf()'s return value for error codes. Realize that recovering from scanf errors is very difficult. Read each line at a time with fgets() and then parse it into fields using sscanf() or strtok() or even strchr().
Wow, that doesn't look beginner friendly at all. So, there isn't easy way to do what I want? And also, how do I check if fscanf () returned error? 
Aside for some trivial compile errors (fajl, missing close brace before else), your program should display the first number correctly. Then fscanf() will fail because it tries to read a number when "Adam" is the next token in the file. To fix this, you should make sure the string and the last integer are read. Might as well read all three items in the loop body, for instance with fscanf(file, "%i %99s %i",&amp;number,str,&amp;anothernumber).
Yeah, I saw that error 'fajl'. It happened when I was translating variables from my language to English. I'll fix that. This '%99s' means that it will read only 99 characters and store it into a str string, right? And if I read the whole line with fscanf it will then go to a next line?
'%99s' means that scanf attempts to read a string that's up to 99 characters long. In general, you should avoid '%s' (without a number) because the string that is read could be longer than the amount of memory you allocated for your char array. Yes, fscanf will go to the next line automatically. It will skip all whitespace until it encounters the next token.
A token is a substring that has no whitespaces in it (no spaces, tabs, linebreaks). For instance, "4", "8", "Adam" and "32243" are tokens in your example file.
Strings are not beginner friendly in C.... You can check the return value of fscanf like this: int retval = fscanf(file, "%i", &amp;lineCounter); But you should really learn how return values and parameters work in general before you continue. Using fgets() is a much better way though (and from my perspective actually easier), because you don't have to rely on the file having a certain structure. If you only want to display every line of the file you can simply call fgets until you reach the end of the file, the [reference](http://www.cplusplus.com/reference/cstdio/fgets/) for fgets even has what I just described as an example. 
I would do it in a different way. But going with your code, inside the for loop, you should have 3 fscanf(), knowing that will be 3 elements in the line. You can create a string without allocating memory for it, but asking scanf to allocate the memory on the fly, using %ms instead of a simple %s, but you will have to free the string later on and don't forget to close the file before ending the program.
K&amp;R wrote the book in a ~~linux~~ unix environment. If you're completely starting out from scratch (like it sounds like you are), then you should either install some kind of linux (like Ubuntu) and do it from there, or find a basic C tutorial that's meant for Windows or Eclipse. 
I worked through K&amp;R, and it is going to be so much easier with Linux. You can use a virtual machine or boot from a USB. Eclipse is more of a java ide. It might work with c, but it is far from the best choice. Since you already have worked in eclipse, deploying to an environment with c can be tedious. C programs are dependent on the cpu architecture. If only your dad is using the programs, you can find out the cpu arch he has and use compiler flags to create the appropriate binary for him. If it going to need to be deployed to a number of environments, it can become difficult. This is the main drawback with c, and it is why it has fallen out of favor for desktop applications. 
You're right. Sorry, they tend to meld together in my head.
While I commend anyone who would like to do data analysis in C I would like to point out that if thats ALL you want to do maybe Python is better suited to your needs. That said: The first chapter of Zed Shaws "learn C the hard way" will tell you exactly what you need to do to set up a way to build exe:s from C. Free to read online! 
C11 was disappointing imho, i wanted more language features. I guess anonymous unions/structs and _Generic will have to do. They should have included some of the language extensions of GCC and (other compilers?). I acutaly like the plan9 extensions. and of course without address of labels, VMs in C would suck pretty bad ;)
If it isn't too long can you post here how would you do it? What do you mean by using 3 fscanf()? If I understood correctly here, the first fscanf() will read the first number in the line and then it will try to read the next word which is string and when it finds out that it isn't integer program will crash... I think I know what you are talking about allocating memory but I am not exactly sure how to implement it on the fly by using %ms. I think it should be used with malloc, and then the code for allocatin would be something like this: char str; str = (char *)malloc(sizeof(char)); Right?
If you want to get a string from fscanf, you should use "%s" instead of '%i", %i is meant to be used for integers, %s for strings. When I say that you should use 3 fscanf, you should use one for the first integer, the second for the string and the third for the last integer of the line. When you create a string, you would do something like this: char *str; str = calloc(X, sizeof(char)); //where X is the size of the memory you want; But when you are reading from a file, you don't know previously the amount of memory you will need to store the string, so instead of using %s for string, you can use %ms and you won't need to allocate memory for the string, the fscanf will do it for you. Ex: char *str; fscanf(file, "%ms", &amp;str); Now you will have a string called str using an amount of memory needed to handle the string fscanf got. But everytime you allocate memory, you have to free it later, so you will have to do free(str); before using str again. If you don't know already the basics of this kind of implementation, you should look for strings in C, pointers, calloc vs malloc, and %ms. Also give a look at fscanf documentation, specially at format specifiers. My implementation would be like [this](https://gist.github.com/forbidden404/02103c2f8815f76f4e04)
To be honest, I don't really know what I'm doing. I know I probably won't be using C when I graduate. It will more than likely be Python, Matlab, R or C++ depending on what direction I go. The main reason I'm trying to learn C is that I've read on many different forums that learning to code in C will be better in the long run and that other languages will be really easy to pick up. It sounds like C isn't a great option for creating simple programs to hand off to others so maybe I'll just save that for python and just continue through at least the K&amp;R book.
What happens if you remove the printf statement? I predict that you'll get the same output. I further predict that no matter what program you use, you'll get the same output. Another test: what happens when you put an invalid statement, like foo bar; ? Do you get a compilation error? (this is probing whether you're even compiling your code or the compiler is giving you the error and you're not clear that it's not running your code)
So, it's compiling, but there's some problem with executing it properly. What tutorial are you using? What commands to execute the program you compiled?
Fingers crossed for automatic Objective-C style include guards a la import
That command, ctr-F5, appears only to execute your already built program. That means you are not rebuilding the project. It looks like you want to hit F9 to build it, and then hit ctr-F5. Alternatively, you could go under **Compiler -&gt; Rebuild All**, and then go on and execute it. Otherwise, you are just running an old executable based on an old version of your source code. I might be wrong, as I don't use lcc, but it seems you are never going through the step of recompiling.
For even more fun, less clear output, you can use the uncommon comma operator! while( input = getchar(), input != EOF ) ...
Don't know why you got downvoted. I came back to thank you, as reading your comment helped lead me to come up with the comment I made above.
I also dislike the crap called Annex K (bounds checking interface) that Microsoft manage to introduce. It's such a badly-designed interface.
Function 1: return pow(side, 2); Function 2: Isn't one side of the square equal to the diameter of the circle?
That's not quite true. The `==` operator compares values of arithmetic types and compatible pointer types. The size of the values is not important. If you attempt to compare an array-typed value or a string literal, they will both decay to pointers to their first elements for the purpose of the equality test. So, you can't compare strings with `==` because you end up comparing the addresses of their first characters instead; you also can't compare struct types via `==`, and attempting to do so will just be an error. A further problem with comparing structs is that they may contain padding bytes, and these may be random depending on what memory they're allocated from, so a byte-by-byte comparison via memcmp() could find semantically identical structs to be non-equal. You can either do a field-by-field comparison, or you can manually clear all the bytes in your structs via memset() or calloc() if you're dynamically allocating them before writing their initial field values. If you use a loop so that the exact same string literal expression is used to initialize different variables, they will be guaranteed to compare the same. Since this example uses two different literal expressions, they are not guaranteed to compare the same (though they could at the discretion of the compiler). The string literals are guaranteed to be of static extent, and it is undefined behavior to attempt to mutate them.
Show what you've done so far.
But then how will OP get us to do his homework for him?
You'll probably fail the class if you listen to me. /* Compile with: cc -std=c99 hw.c -o hw */ #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define PI 3.14159265358979323846 double cal_area_circle( double w /* width of the square that the circle is circumscribed in. */) { /* The width of the square will be the same as the diameter of the circle. Area of a circile is pi * radius^2. */ double r = w/2.0; return r*r*PI; } double cal_area_square( double w /* width of square which will be same as height. */) { /* Area is w^2 or w*w */ return w * w; } int main(int argc, char *argv[]) { for (double w; (printf("Enter with of square: "), scanf("%lf",&amp;w)) == 1;) printf("The area of the square circumsribing the circle is %.03lf\n", cal_area_square(w) - cal_area_circle(w)); } 
I'm fairly new to C and have been using it for embedded proc(MSP430) related development. I think in some cases your suggestions may not be possible(global vars related to ints),however I found your section on avoiding switch statements interesting. I mention it because some example code for the proc I mentioned, particularly related to i2c logic uses switch/case fall through. I had wondered why they had done that as opposed to using if/else. Wondered if you had any thoughts on this.
Except that most of these library functions are very poorly designed. Some length parameters appear twice (sic) and the way to figure out if truncation happened is also very convoluted.
I don't really think that's needed.
The clang [modules](http://clang.llvm.org/docs/Modules.html) system is one thing I'd like to get implemented across the board and standardised.
Why not? Who wants to write their own include guards when you could just use import?
You would need to do something like this: struct user { char *name; int score; int gamesWon; }; void setGamesWon(struct user *player1, struct user *player2); The identifier between `struct` and the opening brace is called a `tag` and to refer to a struct type, you need to use the keyword `struct` followed by its tag. Struct tags are in their own namespace (along with enum and union tags), so a struct tag and a variable identifier can use the same name without conflict; e.g. `struct user *user` is valid (though possibly confusing to readers). Just for fun, here's a silly abuse of the various C namespaces: struct error { int error; }; int error(struct error value) { if (value.error != 0) { goto error; } return 0; error: return value.error; } 
`0123` has a leading zero, so it is an octal integer literal. `123` is a decimal integer literal. `1` is an integer literal, while `'1'` is a character literal. Perhaps unexpectedly, both of these have type `int`, but `1` has the `int` value&amp;nbsp;1, whereas `'1'` has the `int` value corresponding to the character&amp;nbsp;`'1'` in the character set that is being used (probably&amp;nbsp;49, which is the character code for the character&amp;nbsp;`'1'` in ASCII).
so how do you convert 0123 into 83
Learn about octal (base&amp;nbsp;8). http://www.purplemath.com/modules/numbbase3.htm If you're not familiar with using different number bases, you might want to start at the beginning of that: http://www.purplemath.com/modules/numbbase.htm
Worth noting that quite a long time ago octal was very common for representing binary numbers, but nowadays if you want to represent binary you'll use hex. So it's a hugely unfortunate carry over from those days that a leading zero represents octal. You mentioned three values, here they are in different representations (decimal, octal, hexadecimal, character): 123 = 0173 = 0x7b = '{' 83 = 0123 = 0x53 = 'S' 1 = 01 = 0x1 = '\001' 49 = 061 = 0x31 = '1'
http://www.reddit.com/r/learnprogramming/comments/26vqnu/ccharacter_constant_in_c/
Also worth noting that `'{'` does not necessarily have the value&amp;nbsp;`123`, nor does `'S'` necessarily have the value&amp;nbsp;`83`, nor does `'1'` necessarily have the value&amp;nbsp;`49`. These are all dependent on the character set in use.
thnx Helped me :)
hahaha! Of course, that's true ... except, I do have a caveat. Now if we're talking history, there's not argument, but if we're talking about the present ... can you name me an existing and actively used implementation of C where `'S'!=83` or `'1'!=49`? (I'm going to pass on `'{'` because I've used systems where 123 printed differently, but I don't think they run anymore.) It's an interesting issue, but I'm pretty sure that 7-bit ASCII rules in the space we're talking about.
thanks man You made it simple and easy for understanding 
Of course ASCII (and supersets like Unicode) are the most commonly used character sets today. I acknowledged that fact in [my earlier comment](http://www.reddit.com/r/C_Programming/comments/26vpat/some_help_about_c/chuws6z). Nevertheless, the C&amp;nbsp;language does not guarantee that `'S'` has the value&amp;nbsp;`83`, etc. It is important to understand what the C&amp;nbsp;language guarantees and what it does not. Assumptions about the behavior of&amp;nbsp;C that are not guaranteed by the standard are often sources of bugs.
What does the standard have to say about character sets and encodings? In particular, does the standard tell us how many bits in a `char` type? Also, does the standard offer an efficient way to write the following code: int char_to_int(char ch) { if ('0' &lt;= ch &amp;&amp; ch &lt;= '9') return ch - '0'; else return -1; } ? Making as few assumptions as possible I can write int char_to_int(char ch) { switch (ch) { case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; default: return -1; } } but I'd be unhappy if that was considered my best option.
I believe you were misinformed. Main function does return status to the process which started it. By skipping int at the beginning you change nothing, because according to the specification leaving out the return type, while not exactly reccomended, will still mean that main returns an integer. Any compiler which adheres to any standard of C will work correctly with main returning an int.
&gt; In particular, does the standard tell us how many bits in a char type? &gt; &gt; Yes, it's the value of CHAR_BIT in &lt;limits.h&gt;. No, that's how many bits are specified by that libc, the standard just gives them a lower limit and that it has to be smaller than the lower limit of the next smallest data type.
But the standard does specify that `CHAR_BIT` in `&lt;limits.h&gt;` must be the "number of bits for smallest object that is not a bit-field (byte)," and that "the `sizeof` operator yields the size (in bytes) of its operand," and that `sizeof(char) == 1`. Therefore the standard does require that the number of bits in a `char` type is the value of `CHAR_BIT` in `&lt;limits.h&gt;`. Now, the standard does not specify exactly what that value of `CHAR_BIT` must be, as you point out, but it is entirely correct to say that the number of bits in a `char` must be `CHAR_BIT`.
You didn't say that it wasn't a fixed number tho, which is a valid interpretation of your answer.
I think you meant to reply to maxnewb, but in the linked clang documentation you will discover that besides essentially providing "automatic include guards" the proposed module system simplifies a lot of things, as it allows * easier precompilation of headers, significantly speeding up compilation (it actually extends the precompiled header infrastructure already in place) * isolation of function declarations and type/macro definitions * tool diagnostics of unused or missing includes/imports * when implemented, automatic linking to libraries that I deem to be the most visible and valuable benefits.
0b for binary i guess
The interesting artifact here is that the C standard wording remains from a time before the word "byte" nearly-universally meant an 8-bit chunk of data. A C byte is not necessarily 8 bits; there are C compilers for platforms today where CHAR_BIT is 32 and thus a "byte" as far as the compiler is concerned is 32 bits wide. This is why IEEE standards documents use the unambiguous term "octet" to describe an 8-bit chunk of data rather than "byte".
Just to reinforce a point also made elsewhere, which will help with googling answers (as it has me), wherever a value is included directly in code, it is called a *literal*. For example, 5 is a signed integer literal, 5U is an unsigned integer literal, 'c' is a char literal, "foo" is a string literal. There are lots of numeric literals and sometimes the subtle differences between them is important.
If you have ever used a real module system, it is readily apparent that C's preprocessor-based textual inclusion hack is a very poor substitute. In my opinion, it's one of the most broken aspects of C.
What a cocktease. Not a single example of `strtonum`?
Yes. I wrote a test framework for work, it leverages TAP. Currently working on Synthetic Monitoring Framework.
What's the benefit over using assert(), at this level of simplicity? Assert additionally can give you a file/line reference when it fails.
Thanks man, that was on my to do list, how to dynamically allocate memory for char type. I just don't understand this: &gt;tr = calloc(X, sizeof(char)); //where X is the size of the memory you want; I see that you wrote that X is the size of the memory, but does it means that X is also the size of char? With your solution, I understand now what you meant by saying to use 3 fscanf functions. 
Calloc will allocate sizeof(char) times X, if you want to allocate a string with 50 chars, you will have to allocate (50, sizeof(char)). I'm on my phone, so it's quite hard to explain, but you should always sizeof(var type) when allocating memory for this type, so the compiler will allocate the right amount of memory used to store that variable.
First, adding file/line reference in failure message is trivial and in my opinion not really a point to consider. But at this level of simplicity, MinUnit *is* a test framework. If you use `assert()` you will need to build it yourself. This also lets you run a battery of tests without bailing early, for which the results can be processed later. But that's my opinion on the matter. I started using it, and when I feel ready, may graduate to a full-fledged test framework.
&gt; If you use assert() you will need to build it yourself. #include &lt;assert.h&gt; 
Agreed, and why I suggested assert(), since this framework seems to stop after the first failed test: #define mu_run_test(test) do { char *message = test(); tests_run++; \ if (message) return message; } while (0) All of this can be fixed of course, but at that point you've written a new test framework.
i see,i just thought it might work hence the error,thanks for the info, cheers ! 
You appear to be misinformed on two points. First, the "correct" signature for main can be one of `int main(void)`, `int main(int, char **)` or `int main(int, char **, char **)`. The main function also *does* have a caller -- the parent process' `exec` call. This may be seen as the return value of the program in your shell or as the return value of a child process. If you were writing Unix tools, then you'd realise the importance of main return codes and how they are more useful in shell scripts than writing errors to the console.
I don't think this is standardised, but yes - there is a [GCC extension](https://gcc.gnu.org/onlinedocs/gcc/Binary-constants.html) for binary literals. It's also common in C compilers specific to embedded applications.
Why does it have to have a GUI?
Currently, I ssh to a given machine, start (or rejoin) a screen session, and run a couple of scripts. I would just prefer to do a "ssh -AX machine run-gui" command. I think a GUI would also be easier to teach my replacement to use.
For some reason, I remembered X11 having some built-ins. Zenity looks like it could fit the bill, I'll check it out, thanks!
You might be thinking of the old Athena widgets.
Xdialog might be useful.
Yes, that's nice. Xdialog seems more flexible than zenity.
I don't know how firm the requirement for C is, but I've grown to really appreciate Python + PyQt. There's also basic Qt of course, if you're willing to go the C++ route.
C is not a firm requirement. C++, Python, Perl, unix shell would be fine too. I started looking at Qt, but I'm having problems installing some of the libraries on Ubuntu 12.04.
Seconding Qt. It's pretty great.
It doesn't. See the example on the website (although to prove it, you should reorder the test sequence).. 
You'll get more response if you fix your code's formatting like this: #include &lt;stdio.h&gt; int main() { ... } Just put a tab or four spaces before each line.
Thanks for pointing that out
So are A and B values these? Loop 1: A = 0, B = 0 Loop 2: A = 10, B = 0 Loop 3: A = 20, B = 10 Loop 4: A = 30, B = 20 ...
Yes, exactly. Assignment doesn't make the values equal forever, just at the moment the assignment is done. After assigning `a` to `b`, the next step is changing the value of `a`. `b` keeps a copy of the old value. So `a` is the current temperature to be printed and `b` is the previously printed one. When they straddle 98.6 degrees, add that in the middle. By doing it this way, you can change the step size on `a` and 98.6 will continue to be printed in the right place. And if you pick a step size that hits 98.6 exactly, the condition will never be true and it won't be printed a second time. The main thing I'd do to make it more C-like would be to put all the loop control inside a `for`, as in: `for (a = 0; a &lt;= 200; b = a, a += 10)`
 int main() { double d;//Variable to store value of diameter variable double v;//Variable to store value of Velocity double r, PI, area, volume; printf("Enter a value for diameter : ");//Prompts the user to enter diameter scanf("%lf", &amp;d);//Saves the value entered by user to d variable printf("Enter a value for velocity : ");//Prompts the user to enter velocity scanf("%lf", &amp;v);//Stores value to variable v r = d/2.0; // Calculates value of r PI = 3.14; //Constant PI area = PI*r*r; //Calculates area and store sin variable named area volume = area*v; //Calculates volume and stores in variable named volume printf("Volume of water flow is : %f\n" , volume);//Prints the value of volume variable system("PAUSE"); return 0;//Exit Would this be correct? Or by "algorithm" does he mean the pseudo-code?
&gt; Or by "algorithm" does he mean the pseudo-code? It doesn't matter whether you interpret that as "C code" or "pseudo-code". Choose one, give the answer and put in big letters at the top "a description of the algorithm in XXXX-code is:". Add a note to the bottom saying "I was unsure in this question if the algorithm was expected to be described in C or pseudo code. Can we discuss terminology at our next meeting?" Teachers are not magic infallible people and a student who notes where a question is unclear and makes a good attempt at the question after describing clearly how they resolved the unclear terminology is a far better student than one that tries to second guess me. Source: I'm a University teacher. 
You aren't initializing your variables which can get you into trouble in C. It's also best to declare your variable close to where you first use it so they are in the proper scope. At the top of your code, declare constants like: #define PI 3.14159 The value of PI will never change, so there's no reason to create a variable for it and risk it somehow getting modified. It can also be useful to use unsigned numbers for things involving quantities, volumes, or radius since they can never be negative numbers. But that's a preference unless you are going to do something with a potential negative value. Once you get it working, try to figure out how to make the volume and area calculations in separate functions which will make your code more readable and reusable. But, you'll learn that eventually in your class. Here's a skeleton with a complete main(), just write the code for each function and see how it works: #include &lt;stdio.h&gt; #define PI 3.14159 double calcArea(double diameter); // function that takes the diameter and returns the area double calcVolume(double area, double velocity); // function that takes the area and velocity and returns volume double getDiameter(void); double getVelocity(void); void displayOutput(double diameter, double velocity, double volume); int main(int argc, char **argv) { double diameter = getDiameter(); double velocity = getVelocity(); double area = calcArea(diameter); double volume = calcVolume(area, velocity); displayOutput(diameter, velocity, volume); return 0; } double calcArea(double diameter) { // Calculate the area from the diameter and the constant PI and return the result } double calcVolume(double area, double velocity) { // Calculate the volume from the area and velocity and return the result } double getDiameter(void) { // Ask the user for the diameter and return the result } double getVelocity(void) { // Ask the user for the velocity and return the result } void displayOutput(double diameter, double velocity, double volume) { // Print the final output }
That was really the point was as a learning exercise. I tried to write it out for him so he can see how it works and all he has to do is write the code for each one. I prefer writing functions for almost everything so my main() is clean and easy to understand. But, that has no effect on how the program functions and in this case is overkill, you're right. If simplicity was the goal rather than learning, this program would just be more like: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main(int argc, char **argv) { if(argc == 3) { double diameter = strtod(argv[1]); double velocity = strtod(argv[2]); double volume = (M_PI * pow(diameter / 2, 2) * velocity); printf(" d=%lf \n v=%lf \n volume=%lf \n", diameter, velocity, volume); return 0; } else { printf("\nInvalid input. Must enter diameter and velocity as arguments.\n") printf("\tEXAMPLE: %s [diameter value] [velocity value]\n", argv[0]); printf("\tEnter numerical values without the brackets.\n"); return 1; } } Something tells me this wouldn't help him much.
Just to add, anytime you see '=' in C, it means what he said. If you see '==' then it means what you were thinking.(equal to)
Ha, I've been downvoted without reply. Someone's apparently suffering from Stockholm Syndrome. Seriously, modularity via textual inclusion is the very definition of a nasty hack. We rightly eschew all sorts of other uses of the preprocessor as nasty hacks; why defend this one? Just because there's no reasonable alternative right now doesn't mean it's actually a *good* way to implement what you want. I'm also not saying we should necessarily be using the clang modules system; there are plenty of ideas out there to choose from. The idea of modules has been around in programming languages for quite a long time, and most languages have some sort of take on it.
I'm not sure either one helps me, It might just be because I don't have the textbook yet, but most of that is gibberish to me. I was thinking week 1 was going to be something simple like a hello world program or something. In the first example, should I know what is supposed to go in the "functions"? I just sent the Professor an email asking if there was a pre-req class I was supposed to take before this or not. In the meantime, I do appreciate your responses, I'm just not sure what to do with them.
No, you probably don't have to know all of that yet. You'll start with learning about variables, arrays, conditionals, loops etc. I suggest installing a compiler if you haven't yet so you can see what your programs actually do. [MinGW](http://sourceforge.net/projects/mingw/files/) works on windows, if you have linux you probably already have gcc installed. 
&gt; You aren't initializing your variables which can get you into trouble in C. And not using a compiler with checking enabled to flag this lack of initialization. That's the one simplest way to learn of lots of problems.
The same stuff you put in your main function. Just divided up for easier reading/modifying. Most of those functions should be only a couple lines of code at most.
If it somehow helps, here is a fully functioning program with no errors. You'll have to read through it and figure out what things are doing what so you can comment it yourself and explain how it works if necessary. You can use this to cheat, or you can use this as a good working example to learn how a basic C program with functions works. Up to you. You need to save this into a text file named something like homework.c and then compile it on your machine. If using a mac you would open the terminal, go to where the file is saved, and type: clang homework.c -o homework That will compile the program and save it as a executable program named homework. Then to run it you would type: ./homework Here is the code: #include &lt;stdio.h&gt; #include &lt;math.h&gt; double calcArea(double diameter); double calcVolume(double area, double velocity); double getDiameter(void); double getVelocity(void); void displayOutput(double diameter, double velocity, double volume); int main(int argc, char **argv) { double d = getDiameter(); double v = getVelocity(); double area = calcArea(d); double volume = calcVolume(area, v); displayOutput(d, v, volume); return 0; } double calcArea(double diameter) { return(M_PI * pow(diameter / 2, 2)); } double calcVolume(double area, double velocity) { return(area * velocity); } double getDiameter(void) { double diameter = 0; printf("Please enter the diameter: "); scanf("%lf", &amp;diameter); return(diameter); } double getVelocity(void) { double velocity = 0; printf("Please enter the velocity: "); scanf("%lf", &amp;velocity); return(velocity); } void displayOutput(double diameter, double velocity, double volume) { printf("\nv = %.4lf ft/sec", velocity); printf("\nd = %.4lf ft", diameter); printf("\nvolume = %.4lf ft^3\n", volume); } 
You don't really need a textbook, there are loads of resources on the internet. I highly recommend Zed Shaw's [Learn C the Hard Way](http://c.learncodethehardway.org/book/) and, on the dry side, the [GNU C Reference Manual](http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html)
This. Keys to not going insane while learning C: 1. Turn -Wall (gcc's flag for "all (most, really) warnings") on, or your compiler's equivalent. Fix all warnings, regardless of whether you think they are important. 2. Initialize *all* the things. 3. Practice doing weird stuff with pointers (once you learn about them) until you *really* understand them. They are not that hard, it just takes some practice and thinking to develop your intuition for how they work.
I would have to look a little longer to find the specific error, but I did have one tip--instead of traversing the entire board looking for a Connect 4 every time someone makes a move, it would be faster if you only checked each move to see if that resulted in a Connect 4, since the first Connect 4 wins the game and any winning Connect 4 must have been made in the last move. For example, if the last move made was player A at position [3][5], you could just check the zero-indexed row 4 and then check the column 6 (I forget which is the row and column, but you get the picture), then each of the diagonal possibilities, to see if there are four adjascent pieces. Just a thought.
This is correct. If you're trying to change the "end game" variable within the function, you would have to pass it in by reference.
oh, I thought because I put it in as a variable in the function it would change it, is that not the case or have I just done it wrong? I have fixed the problem now by taking *win_check* outside of *player_turn* and putting it into *main*, and setting it directly equal to *end_game*
You need to pass a pointer to end_game as your argument instead of just the value. Alternatively you could make end_game a global variable and then you wouldn't need to pass it as an argument at all. But learning how to properly pass pointers is good practice as code becomes more complex.
Nice, I'll have a go now. As the board is so small it's not such an issue but that is exactly the sort of efficiency I was after!
When you pass a variable into a function normally, it makes a copy of the variable, so any changes made to the variable within that function do not apply to the original variable. If you want the changes to be permanent, it must be passed by reference (meaning that the actual memory address of the variable is passed to the function).
Oh I see, I'm just putting the value '0' in. I have only ever used pointers with files, but will have a practice. Cheers!
If you go this route, I would also break that up into four separate functions. You did a good job breaking the rest of the program up a bit, but your win_check is a bit messy. I'd suggest four more functions - row_check, col_check, left_diag_check, right_diag_check, or something along those lines. It's easier to spot errors in your code if you break it up, as you can test each function individually to make sure it is working properly. 
In situations where functions operate on a group of closely-related values, I like to pack those together into a structure. In this case, I would package all the variables related to the state of the game together into a single structure, e.g.: struct game_state { char board[6][7]; char player_1; char player_2; int turn_count; int end_game; }; Then you can pass a pointer to a `struct game_state` to all of your functions that need to operate on the game state and not have to worry about changing their signatures if the form of the game state changes. Another good practice is to use named constants (via static const variables or #define macros) for things like board sizes or default value initializers, e.g. #define BOARD_X 6 #define BOARD_Y 7 enum players { PLAYER_1, PLAYER_2, PLAYER_COUNT // This is one greater than the highest player index, i.e. the size of the player array }; struct game_state { char board[BOARD_X][BOARD_Y]; char players[PLAYER_MAX]; int turn_count; int end_game; }; Now you can get the current player via: current_player = game.players[game.turn_count % PLAYER_MAX]; Or, if you were passed game as a pointer: current_player = game-&gt;players[game-&gt;turn_count % PLAYER_MAX]; 
&gt; Practice doing weird stuff with pointers And mapping out C's "attempts" to confuse you, e.g. void f(int a[]) really means void f(int* a).
http://gts.sourceforge.net/install.html Their site suggests that the easiest path is probably with Cygwin and gcc, if you need to build it yourself. Otherwise, you should be able to download the precompiled libraries for Windows and simply link to them with any C compiler. How you do that will depend on your compiler suite, and I'm afraid I don't have much information to offer about Windows linking.
Well, for starters it's a code generator and not a library, so no (run-time) dependencies. Then, from what I gather, gflags is C++ only so my usecase isn't even covered. 
Nope, yuck is restricted to GNU-style options which explicitly mandates that order for named arguments must not matter. Besides, if you want ImageMagick style options you're always free to read through argv[]! 
Looks pretty good, but a few things: 1. You may want to mention what this is license under so it can actually be used and forked. 2. Allow custom allocators (malloc/realloc/free) for those of us who are constrained on other platforms where std malloc is forbidden. Other than that, it looks pretty good. I definitely appreciate a library able to handle more complex command line options like this.
So is the entire program considered the algorithm? Or is just the code contained in Main considered the algorithm?
Specifically, an algorithm is just a series of well defined steps. For example, the instructions for making toast can be thought of as an algorithm. As such, any time you have a sequence of actions you carry out in your code you can consider it to be an algorithm. This definition becomes a little bit more specific as you get into the finer details, but for now this is an adequate definition. 
Neither. The algorithm is the idea. The algorithm is basically how to use the formulas you posted to get the output you want. Its not tied to any particular program language.
So when the instructions say "Write an algorithm" they really mean write a program?
It could mean either. Is it a course on C programming, or a course on algorithms? Algorithms can be done with simple calculus usually or pseudo code.
The course is "C Programming for Scientists and Engineers" - But we havent even discussed which editor we will be using. The first weeks reading was on the differences between hardware, software, and firmware, and how programs and operating systems interact within a computer. Thats why Im wondering if she even wants a program this week...
Well I don't know then. Any text editor is a C editor, but some like sublime text and notepad++ are better designed for it. Compiling is done in a terminal with GCC or clang. Other than that, Google is your friend.
First off, can you be a little more specific about the array? You are speaking about 3D arrays, but you only show a 2D one. Are we to assume that in your program it is actually a 2D one? Assuming this is the case, the solution is to use a while loop and to keep two integers describing the coordinates of the cell being edited. First thing first though, do you know how to use scanf? Are you able to write a program that will ask for 4 numbers and print them back? Could you give us the source for such a program (10 lines max)?
Hmm. Something called "motion.c" is usually not a function; in C it's called a 'translation unit' but it's just a fancy name for a file and whatever other files it includes as it's being compiled. Were you asked to create a separate file, or just a new function? Maybe you could tell us a bit about the program that you wrote so far. Is your code all in the `main` function now, or is it in multiple functions? Here are some things that might help you think about your problem: * Which index for your array represents rows, and which is columns? * For each direction, by how much will you have to change the index variables into your array to produce one "unit of motion" in that direction? * How will you decide from your input which direction is needed? * How will you decide from your input what the starting coordinates are? * How will you translate from the starting position and a unit of motion into the update procedure on the array for that unit of motion? * How will you produce multiple units of motion and array updates in the chosen direction? * How will you decide when to stop producing units of motion and array updates? * How will the code you have written so far and the new "motion" code communicate? Hopefully those questions will get you thinking in the right direction. 
Okay good. The second part is thus the actual motion function. As I said, you can express what you want to do as "while we are not touching the edge, something is happening to the array". You need to write down the algorithm before coding it in C. So, in english, how would you continue this: **while** *I am not at the edge*, nodeid will be used to ... And I will be moving toward ... * How do you say whether you are at the edge? * How do you express what you are actually doing? * How do you move? These three questions should lead you to a way to express your current position, how to modify it, how to use it, how to end the function.
Up until Visual Studio 2013, Microsoft's C compiler was ANSI only. It now supports some of C99; I'm not sure if they have plans to updated it further.
If you want to have your code run on every box out there, you better restrict yourself to ANSI. That's still valid, although C99 has been adopted by many vendors in the meanwhile.
I'm currently working in a code base that is built with a compiler from 1984 that doesn't implement the ANSI standard. Apparently there is currently work to move the code off of it to a more recent GCC, but I've already been bitten by code that didn't compile correctly because the old compiler did things slightly differently from what I'm sued to. So yeah, it's still good to be able to code to the old styles. If nothing else, even once the code is all on a more current compiler, so much of the code base is 20+ years old or based on code that old, it's good to understand why many of the things done are done the way they are. There is a lot of code I work with that is done in a very structured way that doesn't look modern, but had to be done that way back in the day.
So the answer is that, yes, some projects still restrict themselves to ANSI C, but in my experience, they're the exception at this point. Is this an architecture class? Later standards let the compiler do more work, abstracting the programmer a bit more from what's actually going on in the machine. My guess is that your professor's concern is that you really understand what happens under the covers, but he doesn't want to torture you with writing long assembly programs (or himself with having to read and grade them). ANSI C is a good compromise for that purpose.
Some of the existing products that have a long lifecycle probably need ANSI. As for newer products, there are a few somewhere in the embedded space but most new MCUs already come with C99 compilers. Your professor might have other reasons for enforcing ANSI.
In some cases companies will still be using old compilers (to guarantee compatibility) to maintain certain products and these might only support ANSI. Most new ones for embedded support C99 but it's not 100% coverage.
&gt; Is there any rational or reason to do that? Keeping you in a small bit of the sandbox until you've learned not to poo in it? Or, to put it another way, restricting the amount of rope you're going to hang yourself with?
You're missing a semi-colon after you declare int i = 0! -From a Beginner that always forget those too!
Delicious inline for loop iterator declarations.
I prefer declaring them up front with all the other variables, but the C99 shortcut is nice neverthless.
Thank you! I wasn't even looking up there!
It's not just a shortcut, it actually prevents variables from leaking out of your scope. So it makes your code a little safer as well.
Declaring all variables upfront is the *most* annoying ANSI-ism.
Yes.
Frustration is normal. C is a difficult language because it does not provide much abstraction. Keep fighting!
Do not feel bad if you're not able to solve the exercises in K&amp;R without looking at the solutions, because even for the seasoned developers they're still blood, sweat and tears, and tears, and tears (and this is an understatement). In short, some of them are insanely hard. Just keep at it and you'll get better, even if you just look up at the solutions and type them yourself to test them. You'll get better and you'll be just fine!
Thanks :) I will!!
I'll remember that :)! Thanks a lot :)!
By "ANSI" you're referring to only c89 or c90? Wikipedia says that ANSI adopted the c99 standard also.
When people refer to ANSI C, the usually mean ANSI X3.159-1989 aka C89. Here are some other names: * C as described in "The C Programming language, 1st edition" (Kernighan &amp; Ritchie): K&amp;R * ISO/IEC 9899:1990 * ISO/IEC 9899/AMD1:1995 is C95 * ISO/IEC 9899:199 is C99 * ISO/IEC 9899:2011 is C11
To effectively use C++, you should probably learn C first. Most beginner C++ projects are pretty much C anyway except some minor changes like how input/output is handled, etc. The loops, main function, etc are all the same. C is a good language to give people programs for. You just need to compile it. I would Google how to compile C on Windows (if that's your OS) or learn about GCC if you're on OS X or Linux (GCC is also on Windows afaik, but I don't know if that's the best choice. I haven't really used Windows for development).
You're fine. Programming isn't just knowing a language. It's problem solving skills. That mindset sometimes takes a while to get into. Just keep at it. If you're constantly getting stuck, maybe you could look at another book to have a different perspective on the same concept. Just keep at it. You'll get it eventually. :) I won't claim to be an expert, but you can PM me if you want more specific help.
Off the top of my head, there's [MISRA C](https://en.wikipedia.org/wiki/MISRA_C). There's also [CompCert C](http://compcert.inria.fr/doc/), which makes some guarantees about correctness of compiled output.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**MISRA C**](https://en.wikipedia.org/wiki/MISRA%20C): [](#sfw) --- &gt; &gt;__MISRA C__ is a software development standard for the [C](https://en.wikipedia.org/wiki/C_(programming_language\)) [programming language](https://en.wikipedia.org/wiki/Programming_language) developed by [MISRA](https://en.wikipedia.org/wiki/MISRA) (Motor Industry Software Reliability Association). Its aims are to facilitate code [safety](https://en.wikipedia.org/wiki/Safety), [portability](https://en.wikipedia.org/wiki/Portability) and reliability in the context of [embedded systems](https://en.wikipedia.org/wiki/Embedded_systems), specifically those systems programmed in [ISO C](https://en.wikipedia.org/wiki/ISO_C). There is also a set of guidelines for MISRA C++. &gt;MISRA has evolved as a widely accepted model for best practices by leading developers in sectors including aerospace, telecom, medical devices, defense, railway, and others. &gt;The first edition of the MISRA C standard, "Guidelines for the use of the C language in vehicle based software", was produced in 1998, and is officially known as *MISRA-C:1998*. &gt; --- ^Interesting: [^Maṇḍana ^Miśra](https://en.wikipedia.org/wiki/Ma%E1%B9%87%E1%B8%8Dana_Mi%C5%9Bra) ^| [^C ^\(programming ^language)](https://en.wikipedia.org/wiki/C_\(programming_language\)) ^| [^Motor ^Industry ^Software ^Reliability ^Association](https://en.wikipedia.org/wiki/Motor_Industry_Software_Reliability_Association) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ci0yhzp) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ci0yhzp)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Being stuck is part of a programmer's job description. I've been stuck at at a problem at work for about 2 months now and it sucks. But it you are not afraid of failing and throw youself at the problem eventually you will succeed. It's a good idea to seek help of others, just putting the problem into words often helps. So when you finally manage to crack your problem its the best feeling in the world. So keep it up! :)
There's Annex K (Bounds checking interface), a new part of C11. The design is really poor though, you will see when you try to use it.
Programming is learning how to think in a logical, structured way. It's realizing that computers aren't magic and are actually pretty dumb. Then you realize that their dumbness is what makes them useful. 1. It's normal to get frustrated. What helps me is to keep the problem in my head and then take some time away from it. I'm currently taking a hiatus from Exercise 5-17. It's a bitch, especially since some of the exercises aren't worded well. But it's extremely rewarding to solve them as I go. 2. If you keep getting stuck, it's a sign that you don't know something. If you work past that, it's proof that you're *learning something*. Programming is full of "Crap, I don't know what to do here...", tons of testing and brainstorming, and the "Aha!" moment, when you finally solve the problem. It's the high of problem-solving that makes programming so rewarding, imo. As for advice directly related to your exercise, think about the requirements: any number of spaces greater than 1 needs to turn into a single space. So what should you do after you come across one space? Should you perhaps keep a count of how many spaces you've had in a row? I'm sure you can figure it out. Keep at it!
i think these organisations use ada for critical systems.
Looks like I fixed it! I decided to use [column--] instead of [column-1] and it worked. 
I'd try to look at [GTK+](http://www.gtk.org/).
Microsoft is in the business of making a C++ compiler, the C compiler is there for other reasons, they aren't marketing Visual C/C++, just C++ part.
Highly recommend this! I'm bouncing between learn C for mac - k&amp;r and YouTube videos to get a rounded perspective / application on each subject. If I get stuck I check a few resources until it clicks! Hope that helps...
It's a common requirement to compile C code though, e.g. let's say you want to link to OpenSSL. 
Ahhh right, ISO C and ANSI C (at least years ago) were C90 and C89, one in the same. Will be sure to remember this.
He should really learn GTK+ 2.* though. The GNOME team has completely mishandled GTK3 and it's a mess of regressions. Every toolkit has issues, but I'd say Qt or Tk would be better for now until GTK2 gets a proper fork.
What is your OS? I'm guessing Mac OS X.
Well, I'm basically learning C as my first language to build a foundation upon. The long term goal is to build a solid foundation of programming to move to C++. I'm an avid fan of OS X, but I don't like the idea of learning Objective-C as my first language and being limited to OS X and iOS. I was attracted to learning C due to its broad utility. 
despite what some people like to say about learning higher level languages first you are taking the right approach. the main reason why people advocate those is because 50% of any given class will simply not have the skill or dedication to learn how to write a memory manager and learn pointers correctly. you will be a much stronger programmer if you start with c, then c++. probably the best c gui api atm is IUP from Tecgraf/PUC-Rio this is where Roberto Ierusalimschy co-inventor of lua is a professor. http://www.tecgraf.puc-rio.br/iup/ the code base is quite a nice example of oop in c. so after you learn how to use it you can study the code. 
You can try to use GTK+, but really, a GUI is better handled by C++. If you are starting to learn C it might be too much to tackle right now though. In C++ I prefer to work with Qt. Sensible design choices, very good library, cross platform. C is IMO a pain in the ass for GUI purposes.
Thanks a lot :) I did understand what I had to do,I had some problem with the syntax.My logic was correct :) 
Thanks for the reply :) I'm not one of those who doesn't understand stuff ,but currently I'm not also a part of the other group :/ So ...what now :O?
i would also get a second book. C Primer Plus 6th Edition by Stephen Prata 2013 K&amp;R was not intended for beginning programmers
Hey,thanks :) I will do that :) Thanks a lot :)!!
Thanks a lot :) So should I study from Primer first ?Or both ? :)
I'll second this recommendation. GUI systems are inherently object oriented. They benefit immensely from polymorphism, encapsulation, ... Doing GUI programming in a non-OO language means that you have to do much more work yourself. Take a look at how hideous the Gtk code examples are (Gtk is a C framework) compared to Qt or wxWidgets which are both C++ frameworks. Do yourself a favour and learn an OO language.
Them being written in C++ doesn't have anything to do with using them in other languages. Most languages have Qt bindings really.
Awesome, congrats!
I don't know why you were downvoted, if you wanted to write 2d or 3d games, [SDL](http://www.libsdl.org/) has a simple API. Although having to install SDL_TTF, SDL_image, and SDL_mixer in addition to SDL is a pain in the ass, also most SDL tutorials are written in C++ rather than C.
Thanks a lot :) I'll do that :)
Thanks :D!
Yes, in C99 you no longer have to declare all variables at the beginning of a block as long as they're declared before use. Note that in pre-C99 C, you could put variables at the beginning of *any* block, not just the block defining a function's body. You can even throw in a compound statement block in the middle of some other block if you wanted to scope some variables to just that section of code.
Most newer embedded architectures now use gcc, so you get reasonably recent versions of C. I understand PIC's C compiler is not exactly up-to-date or entirely conformant with any standard, though I have no experience with it myself. Just don't use PICs. :P The biggest reason I see open source projects eschewing C99 and later features is to remain compatible with Microsoft's C/C++ compiler, which heavily emphasizes the C++. Doing embedded work with mid-range microcontrollers like the ARM Cortex-M4 or so can be done with up-to-date tools. C99 has some pretty nice features that I really miss when I can't use them, but for school-level C programs it's not a huge difference.
A lot of really safety-critical code just isn't done in C. That's what the DoD funded Ada's design and development for, after all. It's actually a pretty nice lanugage, and doesn't seem as baroque as it once did now that the world is accustomed to Java. [Cyclone](http://cyclone.thelanguage.org/) was an attempt to make a safe language as close as possible to C, so programs could be easily ported. Its last release was in 2006, and it's probably usable, but I don't think it's being developed any more. I think it was a bit ahead of its time; a lot of its ideas have been incorporated into Rust now, though.
I don't think C is the best first language to learn to program with. It's got a lot of aspects that can cause frustration, even to people with moderate experience with it, so don't feel too bad about struggling. It's hard to say whether you'll "take" to programming, but it's completely normal to have to work at learning it and to struggle with mastering some of the incidental complexity that comes along with it.
yeah, but... who does that? :)
Thanks for pointing that out. I'm a big fan of Lua, but hadn't heard of IUP before. I don't agree that starting with C vs C++ makes any difference as to whether you'll be a "much stronger" programmer; so long as you learn the skills, it doesn't matter too much in which order. My first languages were BASIC, Logo, and Pascal. I learned C later just fine, and might not have even started if I had to learn C to do any programming at all.
Honestly, if you really want to do visual/graphics programming, I'd look elsewhere. Check out [Processing](http://www.processing.org/) for a language designed to create neat graphical effects and artwork. GUI programming is not one of C's strong points. It's best suited for server programs, number-crunching programs, and utility programs. You surely *can* write GUIs in C, but GUI programs usually aren't CPU-limited so you have to do a lot more work for not much benefit. It's great that you're learning C, but don't limit yourself to it just because you decided to start there. There are lots of programming languages worth learning and you'll find that many of them are easier to pick up and they'll also get easier to learn after the first couple.
I don't usually wrap for loops, but I do sometimes introduce blocks just to restrict the scope of variables to a semi-standalone portion of a function.
there is a surprising number of people who never learn. i guess thats my point. also if someone has the drive to learn bottom up on there own then they have a how does it work mentality. that gets you far in my oppinion. for those peope starting low breaks down a lot of mystery very quickly and builds a solid foundation. i think it should be encouraged when ever someone has the drive. 
Allow me to plug my toy GUI toolkit [ke2k](https://gitorious.org/ke2k-toolkit). It doesn't have much functionality but it's only 1.5k lines of code. I primarily wrote it as a "finger exercise". It requires SDL2, and only tested on linux. It might work on OSX as well. You can generate xcode3 project files with premake.
I'm really grateful I am enjoying C as much as I am. My pure curiousity has been a great intrinsic motivator to keep learnimg. Like everyone else, at some stage in the timeline I googled "Which language should I learn?" I believe what stuck out to me was something a Stack Exchange user said in regard to C. It was something to the effect of "Java will teach you how to program. C will teach you how computers work." And others chimed in commenting that C was closer to the theory of computing and such. Whether they're correct, who knows. But it made me want to start with C.
Like poets and novelists, great programmers have both written and read a lot of code. Always try to solve things on your own first, but *absolutely* look at other people's code and work to understand it. It teaches you new idioms and techniques, and it can even help you work with your own code. When you are learning a new language, reading and understanding code is *at least* equally important to writing it. You need both if you really want to build the skills.
I'm a fan of [IUP](http://www.tecgraf.puc-rio.br/iup/) myself.
C is definitely a great starting place. Keep in mind, though, that proper C++ design is not "C with classes", so when you start your C++ journey you'll want to learn the C++ way of doing things. You'll get cleaner, better-designed code as a result.
How long should I spend on C before my time becomes better spent learning C++? I've spent the last month or so really drilling in the fundamentals, functions, if/else, variable initializations &amp; data types and working with macro definitions, and just learning how the GCC compiler does its thing. The next huge concept is pointers, of which I've just started reading about this week. So far so good, but certainly challenging. How much C is needed to build a good foundation to move to C++?
C to C++ is sort of like algebra/trig to calculus. It builds up the foundation that will let you learn C++ easily without constantly being confused with the low-level parts of the language. Understanding pointers is a *must*, even though they're used directly far less in modern C++. They're tricky at first, but at some point they'll just *click* and then they'll be simple! One way to really wrap your head around pointers is with manual memory management via `malloc()` and `free()`. Allocate an integer! Free it! Allocate a struct! Allocate an array of structs! Use both pointer notation and array notation on the same pointer to memory! Experiment, and print out things like memory addresses (demonstrated in the post I link to below) to see what's going on. Not sure if this helps, but I have [a small writeup on pointers](http://www.reddit.com/r/C_Programming/comments/23itid/c_pointers_and_values_through_parameters/cgxher0) in a post I wrote in another thread. And when you dive into C++, start with the new C++11 standard. It's a much cleaner and modern version of the language. The Scott Meyers books ("Effective C++", "Effective STL", etc...) are a fantastic companion to whatever C++ learning materials you wind up using. The new versions covering the new standard aren't out yet, but as soon as they are, buy them!
Tip: If you wanna learn pointers without blowing your brains out, learn to use a debugger!
I can't imagine having to code without a debugger. :) I have fond memories from waaaaay back in the day writing full-screen VGA DOS programs -- I installed a secondary monochrome text-only video card and ran that to a separate monitor and ran the debugger on that so I could step through my program while watching the full-screen VGA output on the primary monitor. (This was possible because text-only video memory was mapped into a separate memory address space than the VGA graphics hardware so both could be used simultaneously). Ahh, the days of the 12MHz 80286, 1MB of RAM, 16-bit code, and a maximum of 256 colors at 320x200 (or 320x240 and other strange resolutions via Mode-X).
Cool story gramps :) But seriously pretty cool. I got a chance to play with a Motorola 68000 in school, but only assembly stuff, nothing with DOS or anything. It would've been nice to see how it all fits together. But yeah, just passing down my mistakes. They never told us to use a debugger in my C class and I was too lazy to learn it myself. I went through the whole semester without a debugger. When I finally learned it, it was a big "doh!" moment realizing how much time I would've saved.
I completely agree that people should be encouraged to learn how today's computers actually work, and that it should be introduced early. But it's really a separate topic from how *programs* work, and the job of translating from one to the other is properly a compiler's job these days. C is still too high-level to give a deep insight into how programs are really executed (though the concepts can be taught *along* with C, as it's fairly straightforward to translate C naively to assembly language, it still *hides* the details) and it just doesn't natively support many really important control abstractions (co-routines, exceptions, etc.). I strongly think that people ought to know how to write a compiler, even if it's not an industrial-strength one. This really removes the somewhat mystical nature of programming languages and reveals them for what they are: Tools for thinking about problems *closer to the domain of the problem* than the domain of the computer's language. When you have given yourself tools and the understanding enough to *build your own tools*, you have become a powerful programmer indeed.
fyi, `es_compare` is not a lexical ordering because it compares on size first. So `b &lt; abc`
&gt; He should really learn GTK+ 2.* though. I disagree strongly. &gt; The GNOME team has completely mishandled GTK3 and it's a mess of regressions. Such as? &gt; Every toolkit has issues, but I'd say Qt or Tk Qt is C++.
yeah I couldn't remember if it was c95 or 99 that did that and if there were other structure changes as well (I know single line slashes were a later addition, but I never remember when)
nah, the power of ada is in strict typing and excpetion handling imho. You could do the same in c/c++ ofcourse by using wrappers for everything but this is imho why pascal might be better than c (citing the famous otherwise). It's mandatory to define your types and ranges and exceptions/fallback. I love beinge able to define a type being integer 1..100; and have a runtime throw an exception when something fails. Sure in c or c++ this is just as easy but in ada it's part of the language and restricted in use everywhere. (try printing your type for example). 
I'm not sure why you said "nah, the power of ada is in strict typing and exception handling" when I didn't say anything that conflicts with that sentiment. The DoD funded the development of Ada because they had contractors using too many different languages for development of their safety-critical embedded systems, and they wanted to ensure that there was a language that met their requirements for safe, modular programming. Strict typing and exception handling were part of those requirements. If you are interested in the history of Ada's specification and development, the series of requirements documents that were developed can be found [here](http://www.iment.com/maida/computer/requirements/strawman.htm), which starts with the initial "strawman" document.
The algorith being used is this, http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes should help you understand better. As for the loop, I've added a few comments here http://ix.io/cSd but basically you're confusing a while loop with a do-while loop. In a do-while loop, loop is executed first, then condition is checked.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Sieve of Eratosthenes**](https://en.wikipedia.org/wiki/Sieve%20of%20Eratosthenes): [](#sfw) --- &gt; &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics), the __[sieve](https://en.wikipedia.org/wiki/Sieve_theory) of Eratosthenes__ ([Greek](https://en.wikipedia.org/wiki/Greek_language): κόσκινον Ἐρατοσθένους), one of a number of [prime number sieves](https://en.wikipedia.org/wiki/Generating_primes#Prime_sieves), is a simple, ancient [algorithm](https://en.wikipedia.org/wiki/Algorithm) for finding all [prime numbers](https://en.wikipedia.org/wiki/Prime_number) up to any given limit. It does so by iteratively marking as [composite](https://en.wikipedia.org/wiki/Composite_number) (i.e. not prime) the multiples of each prime, starting with the multiples of 2. &gt;The multiples of a given prime are generated as a sequence of numbers starting from that prime, with [constant difference between them](https://en.wikipedia.org/wiki/Arithmetic_progression) which is equal to that prime. This is the sieve's key distinction from using [trial division](https://en.wikipedia.org/wiki/Trial_division) to sequentially test each candidate number for divisibility by each prime. &gt;The sieve of Eratosthenes is one of the most efficient ways to find all of the smaller primes (below 10 million or so). It is named after [Eratosthenes of Cyrene](https://en.wikipedia.org/wiki/Eratosthenes), a [Greek mathematician](https://en.wikipedia.org/wiki/Greek_mathematics); although none of his works has survived, the sieve was described and attributed to Eratosthenes in the *[Introduction to Arithmetic](https://en.wikipedia.org/wiki/Introduction_to_Arithmetic)* by [Nicomachus](https://en.wikipedia.org/wiki/Nicomachus). &gt;==== &gt;[**Image from article**](https://i.imgur.com/bT7k4SZ.gif) [^(i)](https://commons.wikimedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif) --- ^Interesting: [^Sieve ^theory](https://en.wikipedia.org/wiki/Sieve_theory) ^| [^Prime ^number](https://en.wikipedia.org/wiki/Prime_number) ^| [^Sieve ^of ^Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin) ^| [^Eratosthenes](https://en.wikipedia.org/wiki/Eratosthenes) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ci2rdul) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ci2rdul)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It was only 10 months ago that I was in your very same position. Heck, I even used the same book and went through the same damn exercises! Even after taking an operating systems course in University(which was based on C) I was still very thrown off with a lot of the aspects of C. What is it that made me good at C? Well, as some others have said here it is dedication and perseverance. But also, I came accross a very good book that explains everything you need to know about C in a clear and concise manner. Best of luck, and keep at it! the book: http://www.amazon.com/Head-First-C-David-Griffiths-ebook/dp/B009166ZYE/ref=sr_1_1?ie=UTF8&amp;qid=1402291268&amp;sr=8-1&amp;keywords=head+first+C
Thank you!!!! This is helping me a LOT!!!!
~~Since you are after the next prime number I suggest you increment candidate, that is do `candidate++` instead of `candidate--`. You then have a logical flaw.~~ ~~The while loop does things in a strange order, if you move the incrementation by two after the for loop it might work better.~~ Disregard that, I didn't read all the comments you have written, code does not show up well on mobile! The logic in the code is sound for getting the **next** prime number. That is in your example with 6. // candidate == 6 if (candidate % 2 == 0) // candidate == 5, it's **less** that 6. So it cannot be the **next** prime number. candidate--; do { isPrime = true; // candidate == 7, **larger** that 6 so the first real candidate for the next primenumber. candidate += 2; // Can't remeber of the top of my head what's it called but there is a theorem that states, // that the smallest prime factor of x is less than the square root of x last = sqrt( candidate ); for ( i = 3; (i &lt;= last) &amp;&amp; isPrime; i += 2 ) { if ( (candidate % i) == 0 ) isPrime = false; } } while ( ! isPrime );
This is not the Sieve of Eratosthenes. It's trial division.
It has to be `--` *because* the `+= 2` happens before the prime test. If you swap to `++` and move `+= 2` after the prime test, you also need to do something to avoid testing the starting point.
I updated my reply, give it another read.
 char str[INET_ADDRSTRLEN]; unsigned short port; struct sockaddr *tmp_sa = (struct sockaddr *)&amp;(cnf-&gt;cl.contact[i].v4addr); switch((struct sockaddr *)tmp_sa-&gt;sa_family) { case AF_INET: inet_ntop(AF_INET, &amp;(((struct sockaddr_in *)tmp_sa)-&gt;sin_addr), str, INET_ADDRSTRLEN); port = ntohs((struct sockaddr_in *)tmp_sa)-&gt;sin_port); break; case AF_INET6: inet_ntop(AF_INET6, &amp;(((struct sockaddr_in6 *)tmp_sa)-&gt;sin6_addr), str, INET_ADDRSTRLEN); port = ntohs((struct sockaddr_in6 *)tmp_sa-&gt;sin6_port); break; printf("IP : %s port : %u\n", str, port); Should do it I think. 
thank you very much! I'll go ahead and test it right away! edit: I get a warning and an error file.c:28:11: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast] switch((struct sockaddr *)tmp_sa-&gt;sa_family) ^ file.c:28:11: error: switch quantity not an integer make: *** [file.o] Error 1 edit 2: I now replaced the switch case to get rid of the error, but get warning because of the casting and comparing: file.c:28:8: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast] if(((struct sockaddr *)tmp_sa-&gt;sa_family) == AF_INET) ^ file.c:28:46: warning: comparison between pointer and integer [enabled by default] if(((struct sockaddr *)tmp_sa-&gt;sa_family) == AF_INET) ^ file.c:32:13: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast] else if(((struct sockaddr *)tmp_sa-&gt;sa_family) == AF_INET6) ^ file.c:32:51: warning: comparison between pointer and integer [enabled by default] else if(((struct sockaddr *)tmp_sa-&gt;sa_family) == AF_INET6) edit 3: I ignored the warnings for now and it seems to work perfectly fine! But I'm still missing the Port.. 
I'm going to assume that you're using the Windows console, in which case you want to use this for buffering: http://msdn.microsoft.com/en-us/library/windows/desktop/ms682088(v=vs.85).aspx Here is a tutorial on how Win32 consoles work, and how to use them for graphics: http://www.benryves.com/tutorials/winconsole/
Thanks! Those links help a lot. There is always something more to learn with C programming.
The casting warning is because you're trying to cast sa_family to a type (struct sockaddr *): ((struct sockaddr *)tmp_sa-&gt;sa_family) What I think you actually want to do is cast tmp_sa to a struct sockaddr *. Fixed could be: 1. The tmp_sa is already defined as a struct sockaddr * so it's unnecessary to cast it. 2. Or make sure it casts tmp_sa before using any of the struct's variables: ((struct sockaddr *) tmp_sa)-&gt;sa_family As for port, I think the example of /u/studioidefix also included retrieving port. At least, that's the way I'm also familiar with port retrieval when dealing with socket programming in C.
ohboy! thanks for the casting help! and the port retrieval was either a ninja edit or it hit me on a blind spot! thank you very much! 
I would use getnameinfo() instead. Much cleaner than what you're trying.
I've got it working now, but will look into it for further improvements! Thank you for the suggestion!
With a quick glance, this looks pretty handy. Like /u/neutralinostar said, ``es_compare`` should be fixed (should be easy). I suggest something like (trying to keep your style): int sizecmp = es_sizecmp(str1.size, str2.size); size_t min_sz = min_size (str1.size, str2.size); int result = memcmp(str1.begin, str2.begin, min_sz); return result ? result : sizecmp; 
don't clear the screen. move the cursor to 0,0 and draw the new Image directly over the old one. that way you won't see any flickering. I figured that out writing [life](http://bitbucket.org/emg/life) a few years ago. edit: /u/1inchis25point4mm's answer is better than mine
Do you know what the equivalent of this would be for a Linux Command Line?
I feel really ignoranat asking this question but what do you mean by a "two-dimensional character string to produce a map"? Do you mean you have a two dimentional array of characters and you are using that to produce your map? If this is the case how are you getting the map(array of size (length?) by size (height?)) and the size of the console window to lineup 1 to 1?
I'm not sure exactly, but for something like this I would use a cross platform library, so that it will work on any platform: http://aa-project.sourceforge.net/aalib/
For me it would be this robot : https://www.youtube.com/watch?v=-CB0gJ_69uY We work in a team although almost all software running in the robot was written by me in pure C. You can find it here, but the code is quite a mess sadly : https://github.com/antoinealb/debra
WinImages f/x http://www.datapipe-blackbeltsystems.com/windows.html Everything later was done in c++. Although I have to admit, I never found most of the features in c++ to be very compelling. I was using the important stuff -- lightning fast classes and objects -- in c for years before c++ was a gleam in anyone's eye. 
Although it's not *my* project by any sane definition, I'd say the research OS ([Barrelfish](http://www.barrelfish.org)) I'm working on (my contribution today is on the order of ~20k lines of C, Haskell and domain-specific languages) is probably the project I'm most proud of. Honorable mention to my first slightly larger project: a music player daemon client in GNOME2 Panel Applet form (includes a stand-alone client for testing purposes, is not maintained anymore): http://github.com/simu/musicus-mpc
TIL Barrelfish hasn't been abandoned, do you know if Singularity was actually cancelled or not? I always thought that would be the basis f Microsoft's next OS for some dumb reason.
Thank you so much for this! Im still wrapping my head around thinking like this! 
Thanks, this comment helped me as well! I am new to editing windows console properties, but setting the cursor to 0,0 when redrawing the map and clearing the screen when in-game screen sizes change should remove nearly all flicker. 
http://www.gully.org/~mackys/gws/
I am using a two dimensional array. I have my character set to the middle of the screen and I display -x, +x, -y, +y amount of the map based on the character. In that way, I can adjust the array display to the same size as the console window. In any case, right now I am not making a game to release online or the sort. I am doing it to learn to code better and for fun. I didn't even realize screen flicker would be a problem until I starting clearing the screen rapidly with system("cls") 
I wrote a BitTorrent client for a Computer Networks class, all in C. I'm pretty proud because that was the first 'big' project I had done. All command line, just pass it a .torrent file and it will download it (including resuming partial downloads).
&gt;UART over IR Sweet Jesus. 
You have a brave name good sir
Yeah, I forgot about the port, added it like 10 min later. Glad you got it working !
Use an update flag so you aren't clearing or redrawing an identical buffer every frame, use the Win32 API over the stdio.h functions, support for escape sequences on Windows is kind of weak, if you wanted something more portable, look into curses (terminal library). The Win32 console API is ugly, but it is a complete solution and you can make pretty colored text and cells (!) and you'll have an easier time working with keyboard (and mouse) input.
I released [Macrofun](https://github.com/mcinglis/macrofun) a few weeks ago, which provides similar macros, but does not conform to standards. A commenter on the [submission](https://pay.reddit.com/r/programming/comments/260cb6/macrofun_standardsdefying_functionalprogramming/) to /r/programming pointed out the related [`P99_FOR` macro](http://p99.gforge.inria.fr/p99-html/group__preprocessor__for_gae3eb0e3a5216300874ed6cb9abc170ce.html#gae3eb0e3a5216300874ed6cb9abc170ce) of P99, which handles "variable" number of arguments while conforming to standards. Libpp's macros are implemented in a fashion similar to `P99_FOR`, but I think it's much cleaner. For example, `P99_FOR`'s handler macros are [defined within a 10,000 line header file](http://p99.gforge.inria.fr/p99-html/p99__generated_8h_source.html#l08297), and `P00_FOR_50` calls `P00_FOR_49`, so you're going to require as many preprocessor evaluations as arguments given. By contrast, `PP_MAP` is defined within a 300-line header file, and `PP_MAP_50` evaluates directly to the desired expression. You can also change the argument limit of Libpp's macros to your liking. Libpp isn't as powerful or general as P99, but I'm finding it much easier to use. Perhaps that's just because I wrote it, though. Feedback would be really appreciated.
It's a work in progress, but I'm proud of [tyler](https://bitbucket.org/cliff/tyler), which is a tile server for OpenStreetMap tiles. You can see screenshots of it here: http://imgur.com/a/CDnHp. The top image is rendered with leafletjs using standard OSM tiles, and the second image is rendered using tyler. Not pretty, and currently incomplete in the kinds of data it can render, but it does everything from parsing the XML data, storing it in a database, querying for specific kinds of nodes, rendering the data as png images, and serving them over FCGI using a URL scheme understood by standard mapping plugins. Still to do: * Handling lines and polygons (roads and buildings) * Making it pretty. There would be much more to make it a production-ready service, but that's not the goal. The goal was to use C for a project big enough to be interesting, but small enough to be manageable.
:)
I'm most proud of [LuaAutoC](https://github.com/orangeduck/LuaAutoC). It isn't my most popular project, but it was the first open source project of mine that was used by others. It was the also the first time that, after working on a project, I thought what I'd done was somewhat original, and might actually be useful for someone else.
A binary tree implementation for my data structures class. That was like 10 years ago. Haven't programmed in C ever since.
For stuff like PRODUCT, what's the point? Doesn't any given decent C compiler pre-compute static values like 4 * 20?
It's not really significant, but the program I wrote that used pthreads for a class. We did the first part in Java, then we had to translate it into C. It was pretty difficult because the only resource we had was the pthread documentation. Haven't done anything significant in C.
You're obviously not using the right libraries. Just `import ctypes` and a seg fault is just a few lines of code away `:^)`
I just realized that this is in c_programming. Either way the idea is similar, just syntax issues. Also, you should probably do this in cpp. Not having methods is going to be VERY shitty for continued development of this game. edit: also, by direction do you mean N/S/E/W or can it be N/NE/E/SE/S/SW/W/NW
I'm using Up, Down Left and Right. I'm actually trying to make this in C first, and I'll be learning C++ sometime next week. 
 struct player(init cond){ char direction; int playernum; int xpos; int ypos; } player myarray[25]; for(i=0;i&lt;25;i++){ player temp(init cond); myarray[i]=temp; } That's what it would look like in C. I am not 100% sure on the syntax, it has been a while since I wrote C. The primary difference you will encounter in this program between C and C++ is that you will have to write ALOOOOOT more code in C, as you cannot reference each player object with methods. C structs are just variables which hold more variables. a VERY simple object. edit: Creating random starting positions where the player does not spawn on top of another player will suck in C too. You will have to have two parallel arrays which store the x/y positions of each player, then when you are spawning more players you will have to check their x/y positions that get randomized to the two parallel arrays to make sure there are no double spawns. in short, C++ is the way to go.
&gt; The primary difference you will encounter in this program between C and C++ is that you will have to write ALOOOOOT more code in C, as you cannot reference each player object with methods. No, you just need to write the code differently. That doesn't mean you will have to write *more* code. &gt; Creating random starting positions where the player does not spawn on top of another player will suck in C too. You will have to have two parallel arrays which store the x/y positions of each player, then when you are spawning more players you will have to check their x/y positions that get randomized to the two parallel arrays to make sure there are no double spawns. in short, C++ is the way to go. 1. Why do you think this problem goes away with C++? The algorithm you are describing here would suck in C++ just as much as it would suck in&amp;nbsp;C. The problem is with the algorithm, not the language. 2. Anyway, this is the wrong way to do it. Just create an array of all positions, shuffle the array, and use the first 25&amp;nbsp;elements of the shuffled array as the starting positions.
Awesome. Did you put it on Github. I would really like if you could tell me how you made it or how did you begin. It sounds really interesting.
Writing an object oriented game in a language that does not supports objects will take ~1.5x as many lines at least, and probably be more of a headache for someone trying to learn a language. Nothing other than that.
you know that a method is simply a function that takes an implicit pointer parameter **this** right ? Since no inheritance and dynamic function resolution is needed there is little difference between C and C++ for this case.
`PRODUCT( 4, 20 )` will evaluate to `4 * 20`, not `80`. Yes, GCC and Clang do pre-compute those kinds of expressions. `PRODUCT` is just defined as an example usage of `PP_FOLDR`; it isn't actually provided by Libpp. `PRODUCT` itself is a bit contrived. There could be situations where it may come in handy, but I haven't ran into them myself. Suppose there are 10 magic floating-point numbers that are important to your program. The set's size could change, and the numbers themselves could change. Let's say your program wants to compute the product of those numbers, but you also want to provide a function for each magic number that multiplies a given number by that certain magic number. Each of those magic numbers has a name, and you want the functions to have that name. Now, a case could be made to implement this in a dynamic fashion. Implement a map data structure, and define these magic numbers as a mapping of strings (names) to doubles (values). Then, you provide a `calc( String name, double val )` function that looks up the name in the map to get the corresponding double, and returns the multiplication. The product of the magic numbers is just the product of the values of the mapping. While this approach has its benefit, there are three main problems I see. First: compile-time safety -- there's no way to check which names are valid at compile-time, so lookup errors occur at run-time. Second: mo code, mo problems -- you have to implement a map data structre. Third: performance -- I don't think compilers are smart enough to optimize out the map lookups (yet). So instead, with Libpp, you could do something like: #define MAGICS \ (foo, 5.3), (bar, 0.8743), (baz, 3), ... double const magics_product = PRODUCT_2( MAGICS ) // PRODUCT_2 would be implemented with PP_MAP_LISTS, to calculate // the product from the second element in each list. #define DEFINE_CALC_FUNC( NAME, MAGIC ) \ double calc_##NAME( String const name, double const val ) { \ return val * MAGIC; \ } PP_MAP_LISTS( DEFINE_CALC_FUNC, PP_SEP_NONE, MAGICS ) And have a similar approach with defining the prototypes in the header. This way, you add a (name, value) pair to `MAGICS`, and the product is updated and a function is defined automatically. It's all done at compile-time, the user's code is safer, and you don't need to get a mapping implementation. I'm intending to implement a `PP_ZIP` macro for Libpp, similar to that provided by Macrofun (my earlier project), so that things like the `PRODUCT_2` macro above aren't necessary. Edit: see [my reply](https://pay.reddit.com/r/programming/comments/27rutk/libpp_standardsconformant_functionalprogramming/ci3s44s) to a similar "why is this useful" comment in the /r/programming submission.
Cool! thanks for the detail explanation.
Last semester of college was the first time I ever used C. I've used Java, C++, C#, Python, and a slew of other languages, but this particular course required C, so I had to learn a few things. But my most complicated project thus far has been the "Evil Hangman" assignment which was our final assignment in my Computing II lab class. Basically, it's Hangman with a rudimentary "AI" that actively tries to make you lose. It stores words from a dictionary in an associative array according to the "pattern" of letters you've already guessed and picks the pattern with the most number of matches in the array. So say you have the pattern "-OO-", which could be "COOL", "GOOD" or any other number of words matching that pattern. If you then guess "C" thinking the word is "COOL", it will ignore that because there are words that still match the pattern "-OO-", such as "GOOD" that still match that pattern that don't contain C. Yes, it is a very evil program, and getting everything to work, getting rid of memory leaks, and making sure the professor's 48 individual unit tests (each one worth 1% of our final grade, of which I got 46) worked, was aggravating to say the least. I did get an A in the lab, though, so... I don't have the code up anywhere, but if anyone is really interested, I'll post it.
I would use a struct like so: typedef struct { int y ; int x ; int direction ; } player_t ; int main() { player_t players[25] ; for (int i=0 ; i&lt;25 ; i++) { players[i].direction = rand()%4 ; ... } }
What is the bit width of "parity"? What is is declared as? 
Note that 0x1111 is hex, not binary. So it isn't all ones binary, it is 0001000100010001...
I can't share it because future classes will probably have the same project and I'd get in trouble (plus I need to clean it up quite a bit first). Basically I just read through the [BitTorrent specification](https://wiki.theory.org/BitTorrentSpecification) and implemented that. The class started with creating a client socket to connect to a server and write to it, then moved on to creating a server socket that could respond to multiple connections. It wasn't multithreaded, I just used poll() (select() would have achieved the same thing) to manage connections. So once you were able to manage writing to and reading from sockets, the rest was just implementing the spec. 
This will only give the parity of th low order bit of all the nybbles in the 64-bit value. Unless I'm mistaken, the parity bit will land at position 60. Is this followed by a right shift by 60 by any chance?
That would be true if both x and 1 are one bit wide, but here they are in hexadecimal format, so every byte of x is anded with 00010001.
The and is bitwise, but the 0x1111 is not; its hex. (as above).
&gt; The primary difference you will encounter in this program between C and &gt;C++ is that you will have to write ALOOOOOT more code in C it depends on the program. and in this case, its more code to do it in c++ with a class. the character is simply a state container. which is essentialy the same in c and c++. 
I've pushed a new version with zipping macros, and updated the [`realistic` test file](https://github.com/mcinglis/libpp/blob/master/tests/realistic.in.c) ([output](https://github.com/mcinglis/libpp/blob/master/tests/realistic.out.c)) with an example of using `PP_ZIP2` and `PP_MAP_LISTS` to achieve a similar result as demonstrated above, but with the names and values in separate definitions, so they can be processed individually (e.g. to calculate the product of the values with just `PRODUCT`).
the op did not say he was writing an oop game. the player in this case does not require oop. if it did its not much work to add to a c program. and in most cases you really don't need it anyways. or you only need a cetain part like polymorphism and such. which is not an oop concept it's more general and available in c.
C Primer Plus 6th Edition by Stephen Prata 2013 
Will do that, Thanks.
Im gonna check it out. Thanks.
/u/maep has the correct answer. Out of context the line is meaningless. Here's the full code snippet that calculates the parity of a given word. &gt; unsigned long long v; // 64-bit word &gt; v ^= v &gt;&gt; 1; &gt; v ^= v &gt;&gt; 2; &gt; v = (v &amp; 0x1111111111111111UL) * 0x1111111111111111UL; &gt; return (v &gt;&gt; 60) &amp; 1; To avoid having to type so many ones and zeros, let's do the same function on a single byte. unsigned char v; // 8-bit word v ^= v &gt;&gt; 1; v ^= v &gt;&gt; 2; v = (v &amp; 0x11) * 0x11; return (v &gt;&gt; 4) &amp; 1; Let's take this line by line. v ^= v &gt;&gt; 2; (Edit: After typing this up I realized that I'd done the shifts out of order. I leave it to the reader to discover why this doesn't actually matter!) This takes every pair of bits in the byte and xors its neighboring pair with it. What's neat about this step (and actually all of them) is that bits throughout v are corrupted as we go. At each stage we're chasing the bits into smaller and smaller pockets within the word until we have just the one we care about. Assume that v had the value 0x5d when we started. This is 01011101 in binary. When we do the shift and xor, we do the following sum. 01011101 (v) ^ 010111 (v &gt;&gt; 2) 01001010 At this point we've cut the problem in half. If we X out the bits we no longer care about we have XX00XX10. Bit 0 (starting on the right) now contains the xor (parity) of the original value's bit 0 and 2. Likewise bit 1 has the parity of the original 1 and 3, 4 gets 4 and 6, 5 gets 5 and 7. v ^= v &gt;&gt; 1 Same trick again. We fold the remaining bits to get the parity of the original nybble. (XXX0XXX0). Now, in this one-byte example, there's no need for the next step because a byte is so small you'd never actually go to all this trouble, but for 64 bits it makes sense. (v &amp; 0x11) By now you've probably guessed that the bitwise &amp; is to isolate the bits we still care about. In binary, this is (v &amp; 00010001) That's taking all those "corrupted" locations that were X's before and making them explicitly zero. So now you have a value where the parity of each nybble is sitting in the low order of that nybble. What's the fastest way to combine nybbles? For a byte, you could do another shift, but there are 16 of them to deal with in the 64-bit case. This is where the multiply comes in. If you've never seen how binary multiplication takes place (shift-and-add), this might be a worthwhile thing to look up. Each 1 in the constant multiplier corresponds to a shifting of the value and an addition. The 1 at position 0 means "shift left by 0 and add". The 1 at position 4 means "shift left by 4 and add". And so on. Let's return to the 64-bit case because it's more illustrative, and assume that v is 0001000100010001000100010001000100010001000100010001000100010001 (i.e. the parity of every nybble of the original value of v was odd). The multiplication is equivalent to the following sum (in binary): 0001000100010001000100010001000100010001000100010001000100010001 (v &lt;&lt; 0) 000100010001000100010001000100010001000100010001000100010001 00010001000100010001000100010001000100010001000100010001 0001000100010001000100010001000100010001000100010001 000100010001000100010001000100010001000100010001 00010001000100010001000100010001000100010001 0001000100010001000100010001000100010001 000100010001000100010001000100010001 00010001000100010001000100010001 0001000100010001000100010001 000100010001000100010001 00010001000100010001 0001000100010001 000100010001 00010001 + 0001 (v &lt;&lt; 60) Notice what happens in the top (leftmost) nybble. It collects all of the remaining 16 bits! Note that we don't care about the sums that land in the other nybbles, they're corrupted just like the X'ed bits in the xor steps. This is also a good point to notice why you have to take time to zero out the corrupted bytes with the bitwise &amp;. If they hadn't been zero, the carryover from the additions could have corrupted the one bit we still care about. The maximum sum in any of these nybbles (specifically the second-to-last one) is 14. Because 14 takes up four bits worth of space, we had to clear out that many bits (with the two xor steps) before the multiplication could do its magic safely. return (v &gt;&gt; 60) &amp; 1 Now, because the low bit of any sum of bits is equal to the parity of those bits, all you have to do is isolate the low bit of the top nybble. This is why you shift right by 60 (to put the parity bit at position 0 instead of 60) then &amp; by 1 (clears out the extra bits that might have carried over into bits 61-63). Voila! EDITS: Soooo many typos.
Better Sieve (thanks GNU shar!): #!/bin/sh lock_dir=_fu if test "X$1" = "X-c" then keep_file='' else keep_file=true fi echo=echo shar_tty= shar_n= shar_c='\n' if test ! -d ${lock_dir} ; then : else ${echo} "lock directory ${lock_dir} exists" exit 1 fi if mkdir ${lock_dir} ; then : else ${echo} "failed to create ${lock_dir} lock directory" exit 1 fi ${echo} "x - extracting generator.c (text)" sed 's/^X//' &lt;&lt; 'SHAR_EOF' &gt; 'generator.c' &amp;&amp; X/* X generator.c X*/ X X#include &lt;stdio.h&gt; X#include &lt;stdlib.h&gt; X#include &lt;unistd.h&gt; X X X/* Generator process */ Xint main(int argc, char **argv) X{ X if(argc != 2) X { X fprintf(stderr, "Usage: generate max\n\n"); X exit(1); X } X int max = atoi(argv[1]); X X /* start one instance of sieve and enter the loop */ X int fd[2]; X if(pipe(fd)) X { X fprintf(stderr, "Bad pipe creation in generator.\n"); X exit(1); X } X pid_t child = fork(); X if(child &lt; 0 ) X { X fprintf(stderr, "generator: cannot fork()\n"); X exit(1); X } X else if(child) X { X close(fd[0]); X dup2(fd[1], 1); X close(fd[1]); X int n; X for(n = 2; n &lt;= max; ++n) X { X printf("%d ", n); X } X } X else X { X close(fd[1]); X dup2(fd[0], 0); X close(fd[0]); X execl("sieve", "sieve", 0); X fprintf(stderr, "execl failure\n"); X exit(1); X } X X return 0; X} SHAR_EOF : if test $? -ne 0 then ${echo} "restore of generator.c failed" fi ${echo} "x - extracting Makefile (text)" sed 's/^X//' &lt;&lt; 'SHAR_EOF' &gt; 'Makefile' &amp;&amp; Xall: sieve generator X Xsieve: X gcc sieve.c -o sieve -O2 X Xgenerator: X gcc generator.c -o generator -O2 X Xclean: X rm -f sieve generator SHAR_EOF : if test $? -ne 0 then ${echo} "restore of Makefile failed" fi ${echo} "x - extracting sieve.c (text)" sed 's/^X//' &lt;&lt; 'SHAR_EOF' &gt; 'sieve.c' &amp;&amp; X/* X sieve.c X*/ X#include &lt;stdio.h&gt; X#include &lt;stdlib.h&gt; X#include &lt;unistd.h&gt; X X/* sieve process */ Xint main() X{ X int n; X scanf("%d", &amp;n); X fprintf(stderr, "%d\n", n); X int started = 0; X int fd[2]; X if(pipe(fd)) X { X fprintf(stderr, "Bad pipe creation in sieve.\n"); X exit(1); X } X int p; X while(scanf("%d", &amp;p) != EOF) X { X if(p % n) X { X if(!started) X { X pid_t child = fork(); X if(child &lt; 0) X { X fprintf(stderr, "sieve: cannot fork()\n"); X exit(1); X } X else if(child) X { X /* redirect stdout to the pipe */ X close(fd[0]); X dup2(fd[1], 1); X close(fd[1]); X } X else X { X /* redirect stdin to come from the pipe */ X close(fd[1]); X dup2(fd[0], 0); X close(fd[0]); X execl("sieve", "sieve", 0); X fprintf(stderr, "execl failed.\n"); X } X started = 1; X } X printf("%d ", p); X } X } X X return 0; X} SHAR_EOF : if test $? -ne 0 then ${echo} "restore of sieve.c failed" fi if rm -fr ${lock_dir} then ${echo} "x - removed lock directory ${lock_dir}." else ${echo} "x - failed to remove lock directory ${lock_dir}." exit 1 fi exit 0 
To help immediately (although you REALLY need to read k&amp;r): #include &lt;stdio.h&gt; is a call to the C preprocessor. This is a program which runs before your compiler (but it's automatically called by it) which lets you do things like this and define macros. This has some problems which you'll see later (look up "header guard" in particular). #include says "find this file and just stick everything in it right here." The fact that it's between &lt;&gt; means "look for it just in the include path" where "stdio.h" would mean "look for it in the current directory, then look for it in the include path." On unix machines the include path is usually just /usr/include, but you can probably add more places to it using your compiler's -I flag. cc -I. makes #include &lt;stdio.h&gt; equivalent to #include "stdio.h". fflush simply flushes the buffer. When you write something out, it (usually) isn't immediately written, but it's "buffered" and stored for a later point. This is why if you print to stdout and don't append a "\n" to the string you don't actually see it until later. This is done for performance reasons, mainly. fflush forces it to write everything out instead of keeping it for later, usually because bad things would happen if your program were to, say, crash before the data is actually written. setbuf is just used to change the buffering mode. There are 3 settings: unbuffered, block buffered, and line buffered. Unbuffered means that there's no buffer, whatever you write immediately goes out to wherever you wrote it to. Line buffered is the version you're (probably) used to, where it flushes the buffer when it sees a newline(\n); it's the default for stdout. Block buffered is just "flush this out when the buffer reaches a certain size". 
Thanks! Will read the book. Just one question, whats a macro?
Do you have an iPad? Cause there are some good apps that can teach you everything you need to know about C, C++, etc
Yes i have one, can you name some of those apps please?
Just look for Wibit.net. These apps are from 2011 but the content is done well. Do you use a Windows computer or Mac?
A macro is a piece of text which the preprocessor replaces with another. you can do things like #define thing 4 and anywhere in the source code where you have "thing" it's turned into 4 before the compiler sees it. You can do it with functions too, so you can do something like #define print(string) printf("%s\n", string) and then the print "function" becomes an alias for printing a string with a newline appended to it.
Also note that in the 8-bit case, you could just do a single XOR combination, then do the sums: v ^= v &gt;&gt; 1; v &amp;= 0x55; // four two-bit parities v *= 0x55; // XOR all parities into bit 6 return v &gt;&gt; 6 &amp; 1; This is because the AND-multiply step breaks it up into separate chunks and adds all the lower parities to the upper ones. It's critical that no chunk overflow into the next, so a chunk of n bits must not have any more than 2^n -2 more bits added to it. Two-bit chunks can only have two more bits below them added. There are four chunks, so the next-to-top chunk will only have two chunks added, so will never generate a carry into the top chunk and disrupt it. No carry into the top chunk means that bit 6 is effectively just XORed with bits 4, 2, and 0. When you have 16 chunks, you need four bits per chunk, since 14 lower bits will be added into the next-to-last chunk, which works out to 64 bits, the original approach. 
[Don't use rand()%4 to get random numbers.] (http://c-faq.com/lib/randrange.html) It is probably not really important in that case, but getting good habits from the strart is worth it...
Although it is no substitute for K&amp;R, you can try the tutorials at [Learn C the Hard Way](http://c.learncodethehardway.org/book/). They are concise and easy to follow along. You should still come back to read K&amp;R as it is the definitive book on the subject.
Hey,thanks for the offer ,but I study better on my own :) Also , I started C Primer Plus :)
Well said :D!
Check the way you're scanning your integers in maybe? 
Bam! Thanks for the tip. All I needed to do was declare the result, remainder, and decimal variables AFTER scanning in the integers. 
Programming has an order. It is just "doing one thing after another". Watch this awesome programme: https://www.youtube.com/watch?v=OFUHjDhTIJg Your problem was that you wanted to do A before B but were doing B before A. &gt; All I needed to do was declare the result, remainder, and decimal variables AFTER scanning in the integers. A further tip: you will not meet a more pedantic bunch of people than programmers[0]. (With the possible exception of lawyers.) What you needed to do was to *compute* the result, remainder and decimal *values* and then *assign* them to the ``result``, ``remainder`` and ``decimal`` *variables* after reading in the integers. You were correct to _declare_ your variables at the top of the function but not to _assign_ them there. (This restriction is relaxed in later versions of C.) You will become *very* confused later on if you don't nip any conflation you have between declaring and assigning variables right in the bud. [0] In the pub the other night this was noted and someone repeated the oft-told joke about a programmer being asked by their significant other to "go out and buy a pint of milk and then, if they have any eggs, buy six." The traditional punch line is that the programmer returns with six pints of milk. When questioned, the programmer says "well, they had eggs." A programmer friend of mine then said: "but the programmer should've returned with seven pints." Becoming a programmer breaks you.
A good strategy is to always initialize your variables. Had you done this I believe the answer would've been a bit more clear to you: int a = 0; int b = 0; int result = a/b; float decimal = (float) a / (float) b; int remainder = a%b; At this point in your program it has already determined values for result, decimal, and remainder (assuming it hasn't crashed, which it probably has since we've attempted to divide by 0, three times). Now, assuming it didn't crash, if you read a new value in to your 'a' and 'b' variables, the value of 'result', 'decimal', and 'remainder' have not been altered. You previously said you moved your declarations (these are actually definitions, by definition) of 'remainder', 'decimal', and 'result' to after the scanf() call, but it may be more clear to initialize those variables to zero as well, before calculating what their value should be, like so: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int a = 0; int b = 1; int result = 0; float decimal = 0.0; int remainder = 0; /* Read in two integers */ printf("Please input two integers:\n"); if (2 != scanf("%d\n%d", &amp;a, &amp;b)) { printf("Failed to read two numbers.\n"); exit(-1); } /* Compute results */ result = (int) (a / b); decimal = (float) ((float) a/ (float) b); remainder = a % b; /* Print results */ printf("Your numbers were %d and %d\n", a, b); printf("Integer division: %d\n", result); printf("Remainder: %d\n", remainder); printf("Floating point: %.5f\n", decimal); return 0; } This makes it more understandable that you are reading the numbers in, performing some arithmetic on them, and printing out your results.
Excellent point. However, for anyone coming across this and thinking of implementing it (mine or /u/gblargg's), don't. The byte case is a good way to discuss the theory, but in practice, the bit twiddling for such a small word size might be inefficient and probably isn't worth the head scratching that will happen next time someone attempts to read your code. A lookup table is much cleaner, IMO. And if speed is your thing, you might want to see if your architecture and/or compiler supports a parity builtin which will use the fastest method automatically (maybe even doing it in hardware).
Thank you, I will keep this in mind for future projects.
Righto.
Oh ok, thanks
Ok, thanks a lot.
That was an incredible answer, thanks so much!
Then these apps will be perfect for you. 
Hi everyone! I wrote a quick struct defining a player. While I could make the rest of the players by doing the same thing 24 more times, is there a way I could make a for loop do that for me? Here's what the first player looks like: &gt;for (i=0;i&lt;PLAYERS;i++){ &gt; p1.direction=rdir; //random direction &gt; p1.alive=0; //0 means it is alive &gt; p1.xpos=r1; //random x and y pos &gt; p1.ypos=r2; &gt; p1.number=1; &gt; for (x=0;field[xpos][ypos]!=0;x++){ &gt; p1.xpos=r1; //random x and y pos &gt; p1.ypos=r2; &gt; }; 
&gt;Given a few days, the OS-maintained counter *will* overflow, Did you do any sanity checking before you just spewed this out? 64 bit signed integer's max is 2^63 -1. Let's assume that it's storing time measured in nanoseconds. (((2^63 -1)/10^9 )/86400)/365.25 = ~292.27 **years**
Yes, I did check on the counter and how fast it was climbing, but I missed a few zeros, so my answer is, "No, don't worry about it." 
You need to seed the random number generator. srand(time(NULL)); //#include &lt;time.h&gt; int r = rand(); Its not a true random result, but good enough for general purpose. 
That gives me an ever-decreasing value for z. How would I integrate your code into my old code?
z is not modified past the declaration in line: float z=x*x+y*y; Why would the value decrease, anyway part of learning how to program is to figure things out by 'fooling arround', you aren't really going to learn something from me giving you the result. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;time.h&gt; int main() { float x=2; float y=2; float z=x*x+y*y; int step=0; srand(time(NULL));//seed initially //int something = RAND_MAX ; while (z&gt;1.0) { x=(rand()/(RAND_MAX*2.0F))-1.0F; y=(rand()/(RAND_MAX*2.0F))-1.0F; step++; printf ("Your %dth set of random numbers is: x: %f y: %f z: %f\n\n", step, x, y, z); getchar(); } return 0; } Make sure that your order of operations are correct (in line y=rand()/RAND_MAX*2-1;) etc... It's not recommended to do operators with mixed types (float, int) when you are new to this. 
I worked out how to implement a zipping macro that can take an arbitrary number of lists, so I've released v2.0 that replaces `PP_ZIP2`, `PP_ZIP3`, etc with `PP_ZIP`. v2.0 also optimizes `PP_CONCAT`, which is used once by every recursive-ish macro, by removing `PP_CALL`, so it should be faster across the board too.
&gt; A further tip: you will not meet a more pedantic bunch of people than programmers. (With the possible exception of lawyers.) No, lawyers are chaotic, sloppy and incompetent in comparison to programmers. That's because their customers get the 'feedback'.
C does not have any built-in concepts of containers such as lists, so it does not have any list-based iteration statement either.
Not in C but there is inside the [linux kernel](http://www.makelinux.net/ldd3/chp-11-sect-5). There's a [userspace port](http://www.mcs.anl.gov/~kazutomo/list/list.h) of this that you could use.
If you're iterating over contents of an array, you'll need to have your loop iterate a number of times equal to the number of items in said array. sizeof() will only work if the size is already known at compile time, and isn't much use for dynamically-allocated arrays. Best bet in that case (as far as I can tell) is to keep count of whenever anything is added to whatever you're iterating over and use that in your for loop. There may also be some libraries to handle different kinds of data structures. I don't know of any offhand.
Not in C, no. It exists in C++11 though. If you want some syntactic sugar you could switch.
The way you reply looks like, I am talking to an Indian. 
http://c.learncodethehardway.org/book/
As a part of my stay-sober plan, I'd force myself to implement this as a loop and only change if the program was too slow *and* profiling shows that parity calculation is a bottleneck.
&gt; I'm trying to stick with ANSI C What you are attempting to do is to get specific behavior from the console. But ANSI&amp;nbsp;C has no concept of a console. All input and output is done via *streams*, which are abstract sequences of characters. The nearest that the C&amp;nbsp;standard comes to specifying console behavior is found in Section&amp;nbsp;5.2.2, "Character display semantics": &gt; The *active position* is that location on a display device where the next character output by the `fputc` or `fputwc` function would appear. The intent of writing a printable character (as defined by the `isprint` or `iswprint` function) to a display device is to display a graphic representation of that character at the active position and then advance the active position to the next position on the current line. The direction of writing is locale-specific. If the active position is at the final position of a line (if there is one), the behavior is unspecified. &gt; &gt; Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices as follows: &gt; &gt; * **\a** (*alert*) Produces an audible or visible alert. The active position shall not be changed. &gt; &gt; * **\b** (*backspace*) Moves the active position to the previous position on the current line. If the active position is at the initial position of a line, the behavior is unspecified. &gt; &gt; * **\f** (*form feed*) Moves the active position to the initial position at the start of the next logical page. &gt; &gt; * **\n** (*new line*) Moves the active position to the initial position of the next line. &gt; &gt; * **\r** (*carriage return*) Moves the active position to the initial position of the current line. &gt; &gt; * **\t** (*horizontal tab*) Moves the active position to the next horizontal tabulation position on the current line. If the active position is at or past the last defined horizontal tabulation position, the behavior is unspecified. &gt; &gt; * **\v** (*vertical tab*) Moves the active position to the initial position of the next vertical tabulation position. If the active position is at or past the last defined vertical tabulation position, the behavior is unspecified. If you want specific console behavior other than this, then you need to write code that is specific to the console you are using (or use a third-party library with such code that has already been written).
That makes a lot of sense. Unless you just read through the standard like a book, it's hard to stumble upon this stuff when you're not sure what to Google for. Thanks for the info!
/u/zifyoip has already covered why it's not possible to do this with ANSI C and the C standard library, but if you are using a console that supports vt100 emulation (most *NIX consoles do), there is a nice readline library that uses the minimum possible set of escape sequences that move the cursor to the position you want. Check out http://github.com/antirez/linenoise
Honestly, you should embrace curses. It's not all that complex and does *everything* you're trying to achieve.
Yeah, I'm just trying to get better acquainted with the language. I've been programming for 15yrs but I've only ever learned what I needed for whatever project I was working on... learning what the language can and can't do on its own is something I'm working through now by trying to skip libraries. I suppose curses or something is necessary in this case though. 
That looks interesting. Thanks!
Depends on what your y is, if it is a NULL terminated array of pointers, then you could do something like x=y; while(++x){ foo(*x); }//Someday someone will use memcopy for y, //that will be a miserable day and he deserves it. 
If this is just for you and for fun, set your terminal to vt100 emulation and just print the [correct codes] (http://www.termsys.demon.co.uk/vtansi.htm). Then printf( "%c[H", 27 ) would move cursor to home position, for instance.
Isn't xterm vt100? That printf statement just clears the screen.
how about this one ? http://www.extension.harvard.edu/courses/unixlinux-systems-programming they dont have free version of this ?
Weird. Using xterm on OSX, it does what it is supposed to do (move curson on top). Are you sure there isn't something additional, like a bash prompt that would clear from cursor to the end of the screen ? What happen if you put a sleep(10) ? Does the screen clears before or after ? 
Just a few zeroes? I wouldn't worry about your program crashing 292 years from now. There are already 128 bit microprocessors on the market. By the time that 64 bit integer gets around to overflowing (be it signed or unsigned), the days of 64 bit systems will be long gone.
Here is an example of a for loop in C: int a; int max = 20; for (a = 0; a &lt;= max; a++) { //Do something with a }
also need to declare a, b, and c
During all this evolution, had you ever done any profiling or had any problem with your earlier approaches? In general, use whatever meets your testable functional needs (static array or malloc()) and don't optimize further unless the program is actually performing below your requirements. Worrying about cache coherency where it doesn't matter will worsen your program.
I don't think that would even give you much of an improvement. You're seeing the light, but have not quite reached enlightenment yet, so to speak. An extra memory manager in memory means wasted I-cache that could be used to store the more important bits of your program.
Drat. I meant to write C99, but forgot the `int` s. Now fixed.
Since you specifically asked for feedback, your typedefs are confusing and I would say unnecessary. Makes the program harder to follow. Also, you're mixing naming conventions, as a rule of thumb do not use capitalization in C. I would say take a look at the [kernel coding guide](https://www.kernel.org/doc/Documentation/CodingStyle). This for (n--; n &gt; 0; n--) is bad style, the first argument should not generally modify anything in a for loop. As a side not, you are decrementing uints, I would put some safety checks in there. I assume you used uintN_t for portability ?
btw nice looking algorithm!
No, realloc is extremely resource heavy as it copies all data from the old location to the new location (despite what the name/manpage says, realloc does not just increase memory allocation in place). An array is a terrible way to manage memory, at the very least you should be using a linked list you can append to.
Back when I was first trying to learn C, I looked for decent-quality ebooks of K&amp;R. There wasn't one. I could have missed it, but I ended up buying a dead tree copy and it was well worth the $35 I paid. I have a feeling it will serve me for decades so long as the glued spine just holds together.
Depending on standard version and/or compiler, that should be: /* Do something with a */ Not all C compilers support C++ comment syntax.
Thanks for the link, that looks hugely helpful. I'm not sure where I got the typedef style from - there seems to be some disagreement in this [post](http://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c) but I'm in favor of explicit, so I'll update these. If I understand the difference, the struct should now be: struct point { uint8_t r, g, b; uint32_t center; uint32_t count; }; and I use that as: void kmeans_assign(struct point *points, uint64_t npoints, struct center *centers, uint32_t ncenters) I'll fix up the decrements in general. I used uintN_t because it seemed more readable than unsigned long long, and had the added benefit of portability (although to be completely honest, it wasn't my first priority)
Looks much better. If you truly want to annoy yourself, make a unified diff of your code against /dev/null &amp; run it through http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/scripts/checkpatch.pl
there are not many good resources on the net about making a memory manager. you either find very vague high level descriptions or extensive academic papers concerned with performance analysis etc. its important to realize that there are different types of managers built for different usage pattern. so you have to understand the usage patterns as much as the managers. and no one type is best for all usage. for a understandable tested block allocator i would take a look at obstack. there is documentation and you can get the source. that should be a good start. its design reflects its usage. which is generally a good design principle for allocators. [https://en.wikipedia.org/wiki/Obstack](https://en.wikipedia.org/wiki/Obstack)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Obstack**](https://en.wikipedia.org/wiki/Obstack): [](#sfw) --- &gt; &gt;In the [C programming language](https://en.wikipedia.org/wiki/C_(programming_language\)), __Obstack__ is a memory-management [GNU extension](https://en.wikipedia.org/wiki/GLibc#Functionality) to the [C standard library](https://en.wikipedia.org/wiki/C_standard_library). An "obstack" is a ["stack"](https://en.wikipedia.org/wiki/Stack_(data_structure\)) of ["objects"](https://en.wikipedia.org/wiki/Object_(computer_science\)) (data items) which is dynamically managed. It implements a [region-based memory management](https://en.wikipedia.org/wiki/Region-based_memory_management) scheme. &gt;Obstack code typically provides [C](https://en.wikipedia.org/wiki/C_(programming_language\)) [macros](https://en.wikipedia.org/wiki/Macro_(computer_science\)) which take care of [memory allocation](https://en.wikipedia.org/wiki/Memory_allocation) and management for the user. Basically, obstacks are used as a form of [memory management](https://en.wikipedia.org/wiki/Memory_management) which can be more efficient and less difficult to implement than [malloc](https://en.wikipedia.org/wiki/Malloc)/[free](https://en.wikipedia.org/wiki/Free_(programming\)) in several situations. For example, say one needs to set up a stack for handling data items whose number grows for a while and then reach a final form; such a stack could be defined in *obstack.h*. &gt; --- ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ci72oea) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ci72oea)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
i would focus 100% on your first point and 0% on you second point. normal readable code in c is going to be a big performance improvement by itself. in order to 'optimize' c code you really need to understand the language quite well and your compiler and what is happening at the assembly level. so focus on learning c and its proper usage. that should take you most of the way to fast stable code.
This advice is pretty bad. The linked list is NOT a fast data structure, so much so that in many use cases a dynamically growing array is way faster than a linked list, even if you have to reallocate everything multiple times. At the very least you should do profiling before making that decision in your own project.
&gt; In general, access is faster with an array, while re-sizing is faster with a linked list. Eh. Access is faster with an array in all cases, but if you're going to build up an ordered collection incrementally, the question is whether to do an allocation at every step (which can be very slow, even with a modern/advanced allocator) or whether to do a big allocation with a bunch of memory copying every once in a while. In my experience, doing fewer allocations with copying is just much faster than doing many allocations with no copying, though as I said, profiling will tell you where your bottlenecks are.
Fair enough, we're on the same page. I just didn't want to ignore the advantages of linked structures when the size and structure of your data isn't known until runtime. 
hence I said "at the very least". He's currently using an array, and the discussion was on how to grow it
No problem. I repeat, do this only if you really want to annoy yourself.
an alternative to what your doing is to allocate a pool of xyz objects. lets say 100 xyz. then in your allocation function you test how full the pool is if its full you make another pool of 100 xyz and link the old pool to the new pool. when you want to clean up delete the list of pools. a linked pool allocator.
No, I was merely trying to say realloc is a really bad approach to this, and pretty much anything else would be a better option (specifically because of how realloc behaves when it can't simply increases the already aligned area directly)
when you get stuck you need to try things. even if your not very sure what to do start putting code on the page. you could start with a char and see if it works. if not try an int etc. remember that a == b will return 1 if a is the same as b and zero if not. 
To clarify, `a` and `b` in this context must be variables of the same type.
no, not really. char a = 0x0f; int b = 0x0f; printf("%i\n", a == b); 
Have a look at this [website](http://www.iso-9899.info/) and get yourself a PDF of POSIX.1 2008 and the most recent C11 draft. Very handy documents.
I would suggest not throwing obscure programming mechanics in a post aimed towards a beginner learning the ropes. While technically correct, this only serves to confuse and complicate things.
Those if statements are dodgy. Use boolean and (&amp;&amp;) to compare two values at once. I.e. if ((x&gt;5) &amp;&amp; (x&lt;10))
your clarification is false. everybody makes mistakes no need to get defensive about it. variable assignment and operators are generally taught before even conditionals are introduced. they should be thoroughly understood by any beginning programmer. they should especially be understood by people giving clarifications about such things. 
You fon't actually need the parenthesis though. This is perfectly fine: 0 &lt; days &amp;&amp; days &lt; 6
Just thought it is worth mentioning.. There are three types of errors. Compilation errors, runtime errors, and logic errors. Whilst yours was error-free in the first and second types, it was not error free with regards to the third. You can read more here: http://msdn.microsoft.com/en-us/library/s9ek7a19(v=vs.90).aspx
You can still do that in C99. It's more useful in C++ in my experience though, because you can take advantage of destructors like this: int foo() { // blah blah blah { std::lock_guard lock(some_mutex); // play with locked thing } // lock goes out of scope, std::lock_guard::~lock_guard called // mutex automatically unlocked // blah blah blah }
I prefer the "declare everything at the top" feature of ANSI C.
They're highly opinionated and often wrong. They introduce and depend on a lot of the author's code. They are full of bad practices. /u/andrestv93 
&gt;Why would the value decrease, anyway part of learning how to program is to figure things out by 'fooling arround', you aren't really going to learn something from me giving you the result. Sort of. In my experience people don't learn from being told things, but they also don't learn properly purely from trying stuff out. Instead, they learn that the best method of debugging is making small changes (adding a `*`, removing a `*`, adding a `&amp;`, removing a `&amp;`, etc.) to the code until it compiles and then saying 'done!'. 
In which case I sincerely hope they know what a for loop is.
I see this too often, the confusion on &amp;/*. I blame the language design on not making it clear enough and using it for both declaration and accession. Weird on how such a small detail can confuse so many. 
[This article](http://blog.httrack.com/blog/2014/04/05/a-story-of-realloc-and-laziness/) claims that `realloc()` doesn't move the memory if your array is more than 128 kB. (Only applies to GNU/Linux)
I would disagree with the suggestion to initialize `a` and `b` where they are declared. Unless you can put something meaningful into them, leave them uninitialized (or better yet, declare them once you are about to get the value) so the compiler can warn about use-before-initialize.
I expect EOF is not in the range of unsigned char. That's the reason to choose int.
I agree with this. For a befinner it is beter to start learning the language then to venture into the forest och optimized C code.. Optimizing depends on compiler choice, architecture, alignment in memory and so on. It sure is funny to mess around with but it shouldn't be your first priority. Good luck learning C! It is an amazing language, and terrible at the same time.
for gcc EOF and WEOF are defined as type int with a value of -1. and the return type of getchar is int.
I didn't mean to imply that you can't introduce new blocks in C99, just that you *could* introduce new variables in places other than the beginning of a function before C99 by introducing a new block.
In which case you're almost certainly not using C. (Assuming it's still using 40 year old computers).
last point first i would go with vim. in the terminal or gui. vim has some nice features compared to vi. about projects. if you have not really dug into algorithms and data structures then i would make some projects implementing all the basics. make a double linked list, binary tree, table, ring etc. and try to make them with a nice interface so you can use them for other projects. a few others recursive descent math expression parser linked memory allocator with header nodes. both of these have a lot of info on the web and in most books in case you need help. pick up a few intermediate c books also [C Interfaces and Implementations by David R. Hanson](http://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413/ref=sr_1_1/180-6948566-9054032?s=books&amp;ie=UTF8&amp;qid=1402859575&amp;sr=1-1&amp;keywords=c+interface) 
make sure you have on your protective gloves and safety goggles. 
I've had to learn vi(m) for my job but unless your goal is to become good at vim it's probably more productive to use an IDE to accomplish your primary goal of writing a program. You don't mention if you are running on a Linux machine (I assume so). In that case I tend to use Kate or CodeLite as an editor and since I'm almost always cross-compiling for an embedded system I do the make from a terminal. I don't actually know how good CodeLite is when using it to the build. I really like Qt Creator for doing GUI projects, but Qt tends to be C++ so I'm mentioning it passing. AFA what to write, choose something you're interested in; that gives the impetus to actually get things done. I got good at writing Mac programs by writing fractal code, for example. 
I'm currently going through the [Build your own lisp](http://www.buildyourownlisp.com/) book and I think it is a really great way to get the hang of some C tricks!
That's just for adb.
try writing you own text encryption/decryption program. It's a fun way to send coded messages to each others. 
Check out the /r/dailyprogrammer and pick something to do in C.
I believe that a known value of 0 is pretty meaningful, rather than an unknown garbage value. I'm curious as to why you would prefer uninitialized variables, could you give more examples or expand on that?
I personally recommend these: https://github.com/karan/Projects. If you get stuck and want to see solutions, go here: https://github.com/karan/Projects-Solutions. When I get stuck, I like to look at solutions in something other than the language I'm working on see how it was done there. It gives you an idea without giving away the answer. 
yeap those foreach, for in, and such are basically syntactic sugar. PoppaBigMac with more knowledge in C you could basically almost do anything you like.
yeap agree, read the books. stackoverflow would be a great place to read q/a
I just took a look and have 1 comment (hehe, its a joke) I really would recomend adding more comments, as at first glance I really understood very little of it.
I recently started doing the same thing! I stated a github repo so I can write out all the problems and for other people to use, but it's been hard finding motivation. http://github.com/jjangsangy/the-c-programming-language.git I've already kinda set up a framework, so you could probably work off something similar.
I'm also going through the K&amp;R. To be honest, I didn't really start learning C until I started doing the K&amp;R exercises. I even have a [git repository](https://github.com/sporkbox/knr-exercises) for it! You could do the same. It'd be cool to have another person to learn C with, if you're interested in chatting about C as you learn it. I don't really have any other suggestions as I'm also in the beginner phase. I've gotten to chapter 5 in the K&amp;R, though, and I have to say this book has taught me more about programming than anything I did prior to buying and going through this book. It's not the end-all, be-all, but from what I can tell it's a great primer to the language and helps form a good foundation. For the record, I use `tmux` and `vim` as my workflow. I have `vim` in one tmux window to edit, and a shell in another window that I can use for whatever (make, direct compiler call, whatever). I've not built anything non-trivial yet, but it seems to be a decent workflow for me.
The main reason is it allows the compiler to give better warnings. In OP's example, his compiler should have warned that `a`&amp;`b` weren't initialized. I find the error message use_before_initialize_2.c:12:14: warning: variable 'a' is uninitialized when used here [-Wuninitialized] int result = a/b; much more helpful than Floating point exception (core dumped) especially because it isn't a floating point operation that is causing the exception. My reasoning is that 0 is just as much a garbage value as 2785934243, except that you have lied to the compiler and told it the value is actually a useful value. I would rewrite his program as #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int a; int b; printf ("Please input two numbers: \n"); scanf("%d \n%d", &amp;a, &amp;b); int result = a/b; float decimal = (float)a/(float)b; int remainder = a%b; printf("Your numbers were %d and %d.", a, b); printf(" The result of the integer division is %d", result); printf(" with a remainder of %d", remainder); printf(" and a floating-point result of %5f", decimal); printf(" to five decimal places.\n"); return 0; } If I make a mistake and write `scanf(%d %d",&amp;a,&amp;a);` the compiler will refuse my program since `b` isn't initialized. I don't have to test it to find the error. 
I completely don't get it. Why do you use 2J ? Moving the cursor on top is H (see my post). Changing 2J to H made your code work... 
Look at Beej's guide and try to implement a simple daytime server. From there you can go on to develop incrementally more difficult network servers.
If you have Xcode installed, then you have gcc (or rather clang masquerading as gcc, but the difference is probably not important to you at this point). Go to Applications &gt; Utilities &gt; Terminal to get a terminal window.
I'm taking Intro to C this summer and here are the assignments we've had so far: [Assignment 1](https://dl.dropboxusercontent.com/u/58372313/Assign1_MathQuiz.doc) [Assignment 2](https://dl.dropboxusercontent.com/u/58372313/Assign2_WordSearch.doc) [Assignment 3](https://dl.dropboxusercontent.com/u/58372313/Assign3_VirtualComp.doc)
Have you had a look at [cmacro: Lisp macros for C](https://github.com/eudoxia0/cmacro)?
Not until now. But it looks good after a brief look. This is one of the kind of responses I'm looking for. The other would be personal experience using this approach in concrete application.
I think C needs to obtain C++ style generics. This is one feature that I wish C had.
Using the preprocessor you can get some basic generic's going. I personally like the idea of C supporting generic's a bit better, but it's really very difficult to come-up with a good generic scheme for C that doesn't just turn it into C++ or break everything in the language.
While I still think you should always initialize your variables, I do see your point in using the -Wuninitialized flag along with not initializing variables. Thanks for the the example and explanation!
If you think that's tight just go find a schizophrenic and play a shitty beat to it. They basically all talk about lizard people, god, and do it in this exact same fashion. For a real metal experience, find a schizophrenic on meth. It ups the crazy to 11.
The good thing about C is that it's standard; I can take some standard-compliant code and just download, compile and run. Whenever you decide to add stuff on it makes things annoying; 10 years down the track someone downloads your code, but something in your M4 doesn't work with M4 version whatever is current in 10 years so they abandon it , etc... 
You could use C++ but just not use features you don't like. Ever since clang hit the scene, g++ suddenly got serious about standards-compliance, so it's not a minefield of compiler-bug-dodging like C++ was in the early 2000's or before. 
&gt; run-time cost of indirect calls (via function pointers) C has inline functions.
Not C, but: tail -n 3 file | tail -n 1 In Perl: my $n = 1; while (&lt;&gt;) { if ($n++ == 3) { print $_; exit 0; } } Finally in C: char buffer[128]; int n = 0; while (fgets(buffer, 128, stdin)) { if (n++ == 2) { fputs(buffer, stdout); exit(0); } } 
C isn't the best language for this but I'm working through /g/ programming challenge. And I made a name generator that has a list of hundreds of names and last named but it only selects the first line instead of randomly throughout the list.
* open the file * read one line at a time in a loop (e.g. using fgets() ) * Keep a counter for the current line number * When that counter is 3, print out the line, exit the loop. 
Just reiterating; the "file" is a linear sequence of bytes; and a "line" is just defined as text delimited by newline characters. So the *only* way to print the third line is to find where the second `'\n'` character is in the file, which entails reading the whole file and counting how many of these you have found. There are various ways to do this, e.g. `scanf` using a discard modifier, or `getchar`. 
you could use CodeLite 6.0 (or 5.0). Its a very nice IDE and you could still compile in the terminal.
No problem, happy to help. I think you are making the problem harder than it is. If you think about it, most of the rain is *already* on screen. You can use vt100 scoll function to scroll screen *down* and insert a new line on top, where you would display the topmost line of rain, as a string of spaces and zero.. Pseudocode: forever go to top of the sceen &lt;ESC&gt;[H scroll screen down &lt;ESC&gt;M print a brand line of rain done No need for array or any data structure, if your lines of rain are independants from each other... (beware it is &lt;ESC&gt;[H and &lt;ESC&gt;M, ie: printf("%c[H",27); printf("%cM",27); ) 
Well, the first thing I noticed: &gt; char **result; &gt; (*result) = malloc(list_size * sizeof(char *)); The variable `result` is uninitialized. In the second line, you are dereferencing `result`—you are attempting to store the pointer returned by `malloc` into the memory location whose address is stored in the variable `result`. But the variable `result` hasn't been initialized! So the second line is reading the value of an uninitialized variable, which gives you undefined behavior, which means you have absolutely no guarantees about the behavior of any part of your program. What you mean is likely char **result; result = malloc(...);
You're right that was a foolish mistake, thank you for that but i am still not able to free individual strings in the array with this cycle. Any idea what it could be? for(i = 0; i &lt; size; i++) free(result[i]); 
Okay, let me continue reading your code: &gt; while (list[i++]) &gt; list_size++; What do intend this to do? It isn't going to work as you expect when you pass the function the pointer `list` defined in `main` like this: &gt; char *list[] = {"tiritam", "martini", "raotiem", "tranin", "nitrmaa", "minitram", "amatra", "different", "atrantam", "rtaniam"}; The condition `list[i++]` will be true for all elements of that list, and then you read past the end of the array. After that you have undefined behavior. &gt; if (!(*result)) return (char **)EXIT_FAILURE; First, of course, you want to be testing `result`, not `*result`. But more importantly, this is a dangerous thing to do. The macro `EXIT_FAILURE` is defined to be a nonzero integer constant, and casting a nonzero integer constant to a pointer yields implementation-defined behavior. What you should be doing here is returning a null pointer, not the weird pointer `(char **)EXIT_FAILURE`. &gt; result[(*size)] = (char *)malloc(word_size * sizeof(char)); &gt; /* ... */ &gt; (*size)++; This is a weird thing to be doing. You are trusting that the caller of your function has initialized `*size` to&amp;nbsp;`0`. It would be clearer to use a local variable here instead of `*size`, and then assign to `*size` once at the end of your function. &gt; result[(*size)] = (char *)malloc(word_size * sizeof(char)); &gt; result[(*size)] = list[i]; The first line allocates an array of length `word_size`, and stores a pointer to that array in `result[*size]`. But then the second line immediately overwrites that pointer with the pointer `list[i]`! You lost the pointer that you got from `malloc`. The second line does not copy the *string*—it copies the *pointer*. That's why you can't `free` those things at the end: because they aren't pointers that you got from `malloc`. They are pointers to the constant strings in the array `list`. To copy a string, you need to use the `strcmp` function from `&lt;string.h&gt;`. Also, you are not allocating enough space for the string that you want to copy. You are allocating only `word_size` bytes. But a string of length `word_size` requires `word_size + 1` bytes. Don't forget the null character&amp;nbsp;`'\0'` at the end of the string!
Good post, but it uses api.twitter.com, which is the REST API, which I already know how to use. There, I open the connection, get the data, close the connection, parse the data. My problem relates more to what to do when there's a firehose of data pointed at you (so to speak). The connection is just open and more and more data comes through, I'm not even at the point where parsing the JSON is a problem!
looks like your result[(*size)] = ... is not right. when you assign to result[i], you give it the pointer to your char* string. not the string itself. result is just an array of pointers. ---- in function ---- char **listmaker(int num) { int i; char **list = (char**)malloc(sizeof(char*) * num); for (i = 0; i &lt; num; i++) { list[i] = (char*)malloc(sizeof(char) * sizeof("ABC")); memcpy(list[i], "ABC", sizeof("ABC")); } return list; } ---- in main ------ int i, num = 5; char **list = listmaker(num); for (i = 0; i &lt; num; i++) { printf("%s\n", list[i]); free(list[i]); } free(list); list = NULL; 
well yes, hopefully that part is obvious. unless your program writes ABC over and over again for no apparent reason. ;)
Well, sure, it's obvious that you don't want the `"ABC"` in there. But this will **not** work in OP's program to copy the string `list[i]` into `result[i]`: memcpy(result[i], list[i], sizeof(list[i])); And the fact that that code won't work is not necessarily obvious. What should be done is this: strcpy(result[i], list[i]);
op's question was about free() not the best way to copy strings. if someone wants code review they usually ask. otherwise it tends to be a waste of energy and go off topic. short and sweet works just fine. 
that's a fair point. op might have bigger problems then free to deal with. the original code makes no sense what so ever. and returning a pointer to a pointer is usually not necessary. 
&gt; returning a pointer to a pointer us usually not necessary. Well, it is if you want to return a two-dimensional array, as OP is doing. Although perhaps it would be cleaner to wrap it in a structure or something, and provide a clean-up function so that the caller isn't responsible for freeing everything directly.
Sir, i can't thank you enough. Really, thank you.
What exactly is causing you problems? Strictly speaking the problem and objective is no different then what you had before. You'll have to write your lexer/parser in a way that lets it handle incomplete data and is also reentrant. The basic idea would then be to just get the curl data via the callback, send that chunk over to your lexer/parser to handle, and then do it again when you get the next chunk of data. The reentrant feature of your lexer/parser would mean that it would be able to pick-up where it left off with the last chunk when it gets the next, so it basically just lexes and parses it in pieces but treats all the chunks together as one big piece of data. Also worth noting is that depending on your data format, it's possible you can break it up into smaller pieces that you know you'll get at once, block on reading until you receive it all and then lex/parse that as one piece of data. Ex. If Twitter just keeps sending you a new 'blah' object every 2 seconds, you can basically just always count on receiving a full 'blah' every time, so you read from the stream until you have the full 'blah' and then lex/parse it as it's own piece of data, and repeat for every 'blah' you get. I can't really imagine a situation with a stream of data where it isn't the case that you can break it up in to smaller pieces you can expect to get in one piece, so I would definitely think about this. For this I'd guess your base object would be a 'tweet', where you can pretty much expect to get tweets in one piece (Even if it requires multiple reads, it'll all be sent and received at basically the same time). So your reader would basically gather the memory from the stream until you have a full tweet, and then send that entire chunk over to your lexer/parser to handle. In that way, you can avoid a reentrant lexer/parser and avoid the incomplete data handling (You basically have the exact same thing you had before, just you keep the connection open to read new chunks from) Noting that, you'll be doing a bit more advanced usage of libcurl. If you can, you probably want to avoid the callback and instead find some type of 'async' type call which runs the connection in the background and then lets you get the currently received data via a function call. There are a few reasons for this, the main being that your current usage of curl blocks on the read so it's not extremely helpful if you're going to keep getting data and you also want to be doing stuff with it at the same time. IIRC curl can do it the same way but not block, but since the callback will be called in a separate thread you have to be careful when updating your data. If you can avoid the callback you can avoid lots of threading complications which would probably be worth it (If not, just look into mutex's as you want to use one to block reading-writing when your parsing more data). Looking at libcurl a bit closer, I'm guessing it expects your callback to return pretty quickly so if you do go the callback route, you probably want to allocate the memory into some global pool and then do the lexing/parsing in whatever other thread is handling your data (For the reason that you don't want to tie up curl while you lex/parse). Feel free to ask any questions, I'm not sure I explained all of my thinking extremely well.
Appreciate the info. I know nothing about vt100 so I'm gonna have to spend some time on this.
try using a circular buffer. http://en.wikipedia.org/wiki/Circular_buffer That way you can create two processes; one reads the data and places it on the memory buffer, the other reading it off the memory buffer and parsing the data. The trick is you can switch between the two fast enough that you are effectively running both at the same time. 
What course are these assignments for?
Correct, thanks.
I'm not really sure what to do. I'm not really sure how pointers apply in a situation like this. I'm also a little shaky on how to get information from the terminal into a linked list. 
Unfortunately, I'm still recovering economically from last semester. Thank you for the recommendation though. 
as lmlight77 noted your question is very broad. try to limit your question to a concrete example. otherwise there is not much to suggest but read some books on pointer etc. this one is free [Pointers and Memory](http://cslibrary.stanford.edu/102/) 
The easiest way to make a program faster is multithreading. I'm sure if you did that you'd get extra points. The way you described it this is how I see your project working right now: -Take in a file that contains a dictionary of correctly-spelled words. -apply a hash to each word, store it in the hash table (How are you dealing with collisions? How large is the hash table?) -Take in a file that contains several improperly spelled words as well as some that are properly spelled. SUGGESTIONS: -Take in every word, put it into a buffer, divide that buffer amongst multiple threads. Depending on how many threads you use it will make the program that much faster. Are you doing it in C? http://stackoverflow.com/questions/3908031/how-to-multithread-c-code There's a good example of multithreading. Essentially you should create a number of threads (10 for example), subdivide all of the work that you have, (all of the words), into 10 equally sized segments, and then pass each of these segments to a member function check_spelling(char**)
I built a cute little web server for applications developers. The main features are an extremely small memory footprint and reconfiguration for most settings without restarting the server. A simplistic templating system is included that allows HTML documents to embed content from external scripts. Although the server must be started as root if you want to bind to ports under 1024 (e.g. 80), when properly configured it will run as any unprivileged user. https://github.com/krakissi/kraknet Always more work to be done on it, but it was really a great learning experience for dealing with network I/O and threading. My most recent triumph was using mtrace to discover a leak that had been plaguing the server for a long time; I had never really solved a memory leak problem that way before, and it was really gratifying. It's feature-complete-enough that I use it for literally everything I write on the web, including [krakchat](https://chat.krakissi.net/).
you should not even think about threads or multithreading if your learning how to make a spell checker in a beginning c class. thats a class in itself and far more advanced the what op is up to. 
Look over your hash table code and try to look at it with cache friendliness in mind. In particular, consider how many pointer dereferences you are doing an try to eliminate them in favor of accessing contiguous blocks of memory. http://www.drdobbs.com/parallel/cache-friendly-code-solving-manycores-ne/240012736 http://www.cs.rochester.edu/users/faculty/sandhya/csc252/lectures/lecture-memopt.pdf I'd try doing everything in batch as much as possible. So the loop that reads the test word file should only load the test words in memory. Then you should have another loop that checks their hash value. This should be a more cache friendly way to do it. Maybe skip unnecessary function calls. For example, are you worrying about closing files or free() memory? If so, why?
It's a little hard to give specific advice without seeing some code, but the first thing you should do before (and after!) optimizing anything is to use a profiler to find the slow parts of your program. Then concentrate on optimizing those first. Which profiler to use somewhat depends on your build environment. If you use the gcc compiler, I recommend gprof. And the most important thing: Always check if the optimization you just implemented really did speed up your program (with full compiler optimization enabled). If not, undo it. You most likely just made the code less readable without gaining anything.
For simple speed, ensure your hash table is very large to reduce collisions. You could also look at other hash algorithms to produce better distribution and further reduce collisions. A hash table is very fast so the differences may be negligible. 
This is a good introduction to pointers and linked lists. http://cslibrary.stanford.edu/105/
From what you said, I think my problem is that I do not have a very deep understanding of how the whole process really works with libcurl. I find the documentation to be pretty spotty and cryptic. So, in one sense, I think what you say makes sense, in another, I'm at a loss to how to proceed. How can I learn better what libcurl does, I guess would be the next step.
libcurl in the general case is really a pretty simple library: Open a socket to the url, send a HTTP request, and then parse the response (In the process of parsing the response, hand the payload data off to the callback function so the program using libcurl can handle it). The callback is, in the simple case, a bit overkill, but it's in place so you can store the memory while libcurl is still receiving it. The problem is that libcurl is still single threaded, so when you have something like your current example, it'll call the callback again and again but it's still going to block your actual program from continuing (And your program expects that it'll be able to get all of the data in a short amount of time, which we know isn't true since stream.twtter.com isn't going to ever stop sending you stuff). It basically comes down to having to do two things at once in your program, which isn't impossible but complicates the situation. The obvious choice to do this is threading, in this case you'd just stick all of your curl stuff on a separate thread and let it run on it's own, and then when you receive some data from libcurl you pass it back to your main threaded which then parses it and displays it, etc. You could do this fairly easily using pthreads. The only thing I was noting is that libcurl probably offers some easier way of handling this on it's own, which would lift some of the burden off of you. I honestly just don't know though.
The difficulty is that '\*' doesn't mean the same thing in a variable declaration and as an operator. The declaration "int \*ftPtr" means "ftPtr is a pointer to an int", the operator '\*' in "*ftPtr = (int)feet" means "access the memory at the address stored inside ftPtr", ant the operator &amp; in "&amp;feet" means "get the address where feet is stored". I personally think it is bad design to have the same symbol mean very different thing, but I think the rationale was that when you declare "int a, \*c" (or separately) both "a" and "\*c" are of the type int.
Take a look at the [Bloom filter](http://en.wikipedia.org/wiki/Bloom_filter) data structure. It can do a really fast check, that is mostly accurate and uses very little memory. It does have a chance of a false positive, so you might need to do an actual hash table check afterwards to be certain. ninjaedit: Basically, it's a hash table without the values. You can put an entire dictionary in 512k with it, with a very very low probability of a false positive (Will consider a word to be properly spelled even if it isn't).
Not trying to be rude, just think the guys over at r/ObjectiveC/ would be able to answer this better
Thank you for the input I appreciate it.
Almost. You don't type the star when you use the variable. This is correct: int *myPointer = &amp;someInt; // declaration and assignment in one This is also correct: int *myPointer; // declaration, here you declare the type myPointer = &amp;someInt; // no star, here you assign a value to the pointer This is incorrect (but read below): int *myPointer; *myPointer = &amp;someInt; Actually the last statement will compile with warnings, but is probably not what you want. It takes the address of `someInt`, casts it to an int (because it's going to be stored through an int pointer), and assigns it to the int at the location stored in `myPointer`, which right now can be anything since the pointer has not been assigned yet. Forget you just read that. Don't sweat this pointer stuff, it's a question of writing some simple programs till it clicks.
The second one will compile with warnings, because you're taking an address (essentially a large int value) and assigning it to a regular int. Normally, to assign ints, you do: int myInt = someInt; // assign an int to an int, this is easy or int *myIntPointer = &amp;someInt; // make myIntPointer point to someInt or int someVar = *myIntPointer // get the value of whatever int is located at myIntPointer and store it to someVar
Thanks! But it's not always true that the star is the type and the ampersand is the action of taking the address. (And boo on my explaining skills.) Take this example: int a = 5; // a equals 5, easy int *p = &amp;a; // p is a pointer to a int b = *p; // we used the star!! What happen? What happen is that the star is also the action of *dereferencing* the pointer, or reading out the value of what the pointer points to. In the above case, `b = 5`, because the pointer was pointing to `a`.
I do know, from reading Twitter's documentation, that they mark each individual tweet by \r. That is, each tweet ends with an \r-char. I'm sure I can use this fact to simplify it somewhat?
Ok great I definitely get it now. Was thinking about it too much. Thanks again.
As I understand it (anyone who knows better, please correct me), ObjC is a superset of C, so in the process of learning ObjC, you can learn C at mostly the same time, as long as you make note of which language features are exclusive to ObjC. That said, most of your C learning should transfer to ObjC and probably most other C-likes. I'm going through the K&amp;R2 for my C foundation, which has helped me understand problems better and frame likely solutions.
That's perfect. Ignoring the threading stuff right now and just using what you have, basically what you can do is modify your callback to check if it received a \r, and if so take all the bytes read up to that point as a single chunk and send it to your parser/whatever to be processed. Basically, libcurl is just going to keep giving you the bytes that twitter is sending you via that callback (Calling it every time it receives something). Again, ignoring threading, in the callback you can basically just keep storing those bytes into some type of buffer (A malloced circular-buffer would work well if you know how to do one of those). Then, check the bytes you received for a \r byte. If you received a \r byte, you read everything from the beginning of the buffer to that \r byte into a separate buffer and send that new buffer to your parser. After the parser handles it, remove that chunk up to and including the \r from your original buffer and then keep going (Scanning again for a \r byte, and pulling the next chunk out, etc..). That's basically all you have to do. The threading comes in because you probably want your program to do something other then just wait for twitter to give your information and then immediately display it with no user interaction (Which is what the above idea does). You'll probably want one thread running libcurl that's collecting the data from twitter as it receives it, and another thread that does the parsing when it sees data was received in the first thread and also display the data/gui/etc. You want to put the parsing on a thread other then the libcurl thread mostly because libcurl probably expects it to return fairly quickly, stalling libcurl by parsing when the callback is run might cause things like connection time-outs (Though it's likely libcurl is written to avoid that type of thing anyway.)
You should use g++, not gcc to compile cpp code fwiw. Also, I'm not sure of your counterexample. Were you trying to show defined overflow ? Then you should have used unsigned int, not int. Plus this isn't overflow, this is a typecasting issue. Try the same code with printf("%ld\n", i*1000000000); fixes it for i&lt;5
Professor is grading based on efficiency, so the priorities are suspect.
The problem is not the output. It's that it loops forever despite the loop very clearly looking like it should go for only four iterations with no other changes to the i variable.
Actually, I'm pretty sure that's a problem with the -02. Gives compiles warnings for me, without the -O2 terminates after 3 iterations. 
I get no compiler warnings with g++ 4.8.2 with this command line: g++ -pedantic -Wall -Wextra ideone_dMrRKR.cpp Clang 3.3 also gives no warnings except for the lack of newline at the end of the file. So I'd be interested in seeing what warnings you're seeing. Yes. The OP clearly stated that -O2 makes the issue manifest in GCC. This is what happens when you play with undefined behavior. This may not even be considered a compiler/optimizer bug at least with regards to its compliance with the standard because it is undefined behavior in the standard. The op's point is that relying on undefined behavior like this can lead to bad results, even if it's fine in 99% of cases.
I think you miss the point. The point is that undefined behaviour can have unexpected effects. But yeah, I posted on the wrong language sub, derp.
Each link, as in a chain, is a node. That is, a linked list is a chain of nodes. Each node contains two items, an arrival time and a link to the next node, a pointer. The NULL value is used to signify the end of the chain. Your job is to keep the chain sorted in earliest node first. First define the node structure: struct node { struct node *link; int time; // the arrival time }; This forms the core of your data structure. Next, you need an "anchor" pointer, the pointer that starts your list: struct node *list = NULL; // you start the list out with NULL to signify the list is empty Armed with the above, you can define the add, get, and print list functions. Add event would take one argument, an "int time", the arrival time of the node to add. You start by "malloc" a struct node. You set its time to the function argument. Then you need to insert it into the list. The head of the list should be the earliest node. So you follow the links until you find a node that is later than the new node or until you run out of links: void add_event(int time) { struct node* node; struct node **last = &amp;list; struct node *next = list; // allocate new node node = (struct node*) malloc(sizeof(struct node)); if (!node) return; // or some kind of error response node-&gt;time = time; // now insert in ordered list; search for the first "younger" event (same or larger time) while (next != NULL) { if (next-&gt;time &gt;= node-&gt;time) { // recall node is a pointer to the new node node-&gt;link = next; // make the new node point at the next node *last = node; // this makes the last node's link point at the new node break; // all done } last = &amp;next-&gt;link; // advance "last" to the next node's link next = next-&gt;link; // advance to the next node on the list } if (next == NULL) { // uh oh, ran into the end of the list *last = node; node-&gt;link = NULL; } } The get function is even easier as the list is sorted. If list is NULL, return nil (-1) signifying no time. If not NULL, save a copy of what it is pointing to, then set list to list-&gt;link, then return the saved node (or the time in that node). Make sure something deallocates the "popped" node or you will have a memory leak. int get_nextevent() { struct node *next; int time; if (list == NULL) return -1; next = list; list = list-&gt;link; time = next-&gt;time; free(next); return time; } The print function simply walks the list a node at a time while printing time values. void print_eventlist() ( struct node* next; next = list; while (next) { printf("%d\n", next-&gt;time); next = next-&gt;link; } } This may not be exactly what was asked for, but it probably has the gist. Hope this helps. 
As someone who does not program in C++ (only in C), can anybody tell me why this loop does not terminate?
That's really cool! Thanks for sharing that!
I'd expect exactly the same behaviour in C. My guess is that the compiler has folded together the two expressions `i` and `i*1000000000` and has effectively translated the loop into: for (int i = 0; i &lt; 4*1000000000; i += 1000000000) printf("%d\n", i); Rats. That doesn't work ... except, I expect a further stage of optimisation has recognised that `4*1000000000` is an overflowing expression and so can be discarded, and the final generated code is maybe just: for (int i = 0; ; i += 1000000000) printf("%d\n", i); Alas, I can't quite reproduce the problem with my compiler (gcc 4.8.2). With -O2 or -O3 the generated assembler is equivalent to for (int i = 0; i != -294967296; i += 1000000000) printf("%d\n", i); Lovely example. I'll play with some other compilers, see what I get.
void called_func(int *i, int j)// takes an int pointer and int { *i=7; //the int that i points to is assigned 7 j=8; //this is a copy of the j from caller_func, won't affect the original value printf("%d,%d\n",i,j); // 7,8 i++; //the pointer i no longer points to caller_func i, *i=9 will be undefined } void caller_func() { int i,j; i=5; j=i; printf("%d,%d\n",i,j); // 5,5 called_func(&amp;i,j);// passes j and the address of the int i printf("%d,%d\n",i,j); // 7,5 return; } 
False. Integer overflow being undefined means that the result of an operation is undefined if it overflows an integer. The undefinedness does not escape the operation that causes an overflow; in this cases, i never overflows and thus the loop condition is well-defined. The optimization is not correct here.
&gt; in this case `i` never overflows Good point. Are you sure about the impact of the undefinedness, though? I'm a bit hazy about this, will try and find a relevant reference. Edit: So far I'm just finding references to "undefined behaviour" which sounds a bit broader in scope than you're suggesting. Edit: The best I've found is this: http://stackoverflow.com/questions/3679047/integer-overflow-in-c-standards-and-compilers where he quotes: &gt; If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined. I've not read the standard nor do I have a copy, but that's the basis of my argument above.
I think -Waggressive-loop-optimizations will give you the answers you need (that's the warning I got). Also, make sure you're using g++ &amp; not gcc. printf does not cause this non-terminating loop, only cout does.
Yes, that seems reasonable. Do you know of anything I can read to learn more about these concepts?
Once you invoke undefined behavior, your whole program is undefined, it's not "contained" to just the statement that did something bad.
I'm afraid I'm no longer interested in the vaguaries of C++, and as such this is actually off topic. However I'm still convinced at the moment that this is a legitimate C optimisation, so I'm disappointed that gcc won't do it for me. Are you saying that if you replace the `cout &lt;&lt;` stuff with `printf` that the non-termination goes away? If so that would be pretty interesting.
Interestingly with gcc `-Waggressive-loop-optimizations` produces no warning on this example ... but then it's not aggressively optimising it, alas.
Well it is undefined behaviour in both languages, signed integer overflow. So anything can happen, the compiler can optimize as if it's impossible for adding two positive numbers to generate a negative. 
How big is the file?
Less than a hundred words.
Just read the whole thing into memory and scan it for what you need.
It's already loaded into memory as a buffer.
char *strstr(const char *haystack, const char *needle) Create another pointer to where you found the first occurrence (plus one byte?) and search again from there.
It seems that [adding volatile to int i](http://ideone.com/bs2xVF) fixed the issue using the ideone.com C++ compiler. Makes you wonder what cout is doing with i to make the value carry over, but telling the compiler to keep reloading i fixed that. From playing around I also noticed that the overflow doesn't have to take place in cout in order to cause the error, but printf has none of these problems. 
If I understand correctly, loop through the buffer character by character until you reach the string you want to find and count the number of "new line" characters.
Bonsoir, since you bufferd all the file content. This is how i would do the search: char buffer[&lt;necesary size to hold the file content&gt;]; char *wordToFind = "something"; int numberOfLines = 0; int numberOfColumns = 0; char *position = NULL; char *line = NULL; line = strtok(buffer, "\n"); while(line != NULL){ ++numberOfLines; position = strstr(line, wordToFind); if(position != NULL){ numberOfColumns = line - position +1; //+1 because humans compts starting at 1. break; } line = strtok(NULL, "\n"); } if(position == NULL) printf("Word not found.\n"); else printf("Word found at line %d, column %d.\n", numberOfLines, numberOfColumns); The code uses strtok function to get a new line from the buffer at each iteration. I assume your code doesn't have a sequence of empty newlines, in which case you have to use a special fonction to count new line caracters. (read the manual of strtok for more explanation). Hope this helps you.
Thank you. But if the text is for example "some have gone and some remain" and the word to search is "go", the word is actually found at column 9, which is wrong.
C is not the issue, it's knowing what to do with it. I would pick up an algorithms and data structures book written using C as a basis.
Agreed, you might want to try [learn C the hard way](http://c.learncodethehardway.org/book/) if you think K&amp;R is too deep. I'm not saying it's the best, I just think it's good
Well that could be as simple as searching for for " go " instead of "go". The algorithm is correct, in you just need to the check that the prefix/postfix characters are a space or punctuation.
http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html
also, [The GNU C Library](http://www.gnu.org/software/libc/manual/html_node/index.html)
Let me just plug "The C Book" by Mike Banahan et al. It was good when it was in print and it's even better now because it is [freely available](http://publications.gbdirect.co.uk/c_book/). EDIT: Just now realized this book is mentioned in this subreddit's sidebar. Oops.
Seriously, I learned C quickly as a teen and I sucked, and then I picked up K&amp;R and learned it slowly, and now I suck less. It's not a big book (compared to a C++ one, anyway), and it's very well written. Link in the side bar.
Shamelss self-plug for [Build Your Own Lisp](http://www.buildyourownlisp.com/) if you want to learn in a way which is different to just reading a reference book.
Thank you, it works!
Would you like me to write a short example of that ? It'll take mea solid 5 minutes, and I'm always happy to help a stranger on the net...
[Head First C](http://www.amazon.com/Head-First-C-David-Griffiths/dp/1449399916) is the most digestible text I've read on the subject.
I'll give it a try and give you some feedback! 
[K&amp;R](http://www.amazon.com/C-Programming-Language-2nd-Edition/dp/0131103628) is the way to go!
Apologies that I abandoned this thread, real life caught up with me. I have really enjoyed seeing the code everyone has written and the projects they have made. The C project I am most proud of is (naturally) my first real C project. It is called howm and is a tiling window manager that behaves similarly to vim, the code is over here: www.github.com/harveyhunt/howm/tree/develop Critique of this code would be great- I am still learning and it is a little rough around the edges.
This is awesome, I am starting out doing the [Eudyptula challenge](http://eudyptula-challenge.org/) and this is really useful. Has this been mainlined into the kernel?
That robot is really impressive. How long did it take to write the code? Did your team build the robot themselves, or was it already designed?
I've used Steve Oualline's book Practical C Programming personally and it served me well.
Hey, thanks for the link to the Eudyptukla challenge I was looking for an excuse to write more C!
Reading and writing code.
Get a copy of the K&amp;R book, get Linux installed (if you don't already use it), and play with the examples in the book. Once you have a good idea of basic programming, or already have experience, pick a project and use the K&amp;R book as reference when you run in to problems and need to know how to go about doing things. Picking a project is the most important thing when it comes to learning a language, environment, or programming in general.
There is no standard C stack.
It is great, I am just starting the first challenge and am looking forward to writing more C code and stuff for the Kernel. My final aim is to update the buggy drivers for my laptop that are in the Kernel.
* A C compiler. * Blood. * Sweat. * Tears.
Yes there would, integer overflow causes UB . 
K&amp;R 2. 
You just can't punch an LCD monitor the way you could a sturdy CRT.
Avoid that book for learning C. It is commonly regarded as garbage by C programmers. Stick to K&amp;R or other books that stood the test of time.
Definitely agree here. It's a very concise book that will get you on the right path. It does assume some programming knowledge already, so other books might be better if C is your first language.
Compiled with gcc and the output looks like: 1 2 3 4 5 6 7 8 9 10 11 Not a Armstrong 12 Not a Armstrong 13 Not a Armstrong 14 Not a Armstrong ... up to 500 maybe your terminal doesn't keep a large history so you don't see the lines before 205 
Is there anyway to make my terminal keep a large history.By the way I used code block to compile my code.
You can redirect the output into a file and observe that file. What platform are you developping on? If you are on Linux, consider not using an IDE. An IDE makes it much more difficult to learn C.
I am using Microsoft Windows.
Then you have to find a way for your platform to redirect input and output. As far as I know, this should be possible. Either use fprintf with a file you opened explicitly before: FILE *outf = fopen("output.txt", "w"); if (outf == NULL) { perror("Cannot open output.txt for writing"); exit(EXIT_FAILURE); } /* ... */ fprintf(outf, "Not an Armstrong\n");
Please do all of us a favour and indent your code next time so it's readable. The code in your post is an unreadable mess. Here is your code indented: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main() { int x, x1, x2, x3, x4, y1, y2; printf("print all the numbers from 1 to 500 are \n"); for (x = 1; x &lt;= 500; x++) { printf("%d\t",x); if (x &lt;= 10 &amp;&amp; x &gt; 0) { if (pow(x, 3) == x) printf("An Armstrong number\n"); else printf("Not an Armstrong number\n"); } if (x &gt; 10 &amp;&amp; x &lt;= 100) { y1 = x / 10; y2 = x % 10; if (x == pow(y1, 3) + pow(y2, 3)) printf("The number is Armstrong\n"); else printf("Not an Armstrong\n"); } if (x &gt; 100 &amp;&amp; x &lt;= 500) { x1 = x / 100; x2 = x % 100; x3 = x2 / 10; x4 = x2 % 10; if (x == pow(x1, 3) + pow(x3, 3) + pow(x4, 3)) printf("An armstrong number\n"); else printf("Not an Armstrong number\n"); } } return 0; } Also, notice that your algorithm is incorrect. The definition of Armstrong number is: &gt; A number that is the sum of its own digits each raised to the power of the number of digits. You always raise the digits to the third power, which is incorrect. In the first two cases (i.e. 1–9, 10–99), you should raise the digits to the first / second power.
In windows, you can use the ~~pipe~~ redirect operator just like in a *nix platform. The syntax would be something along the lines of: armstrong.exe &gt; output.txt
Go to properties (little CMD icon in the top-left of the window) Click the Layout tab The first set of options on the right is your screen buffer. Raise it. I'm not sure of the max/mins, but I'd imagine 800 will get you your output.
Unless they are already familiar with Linux, this is kind of a silly bit of advice, yes you'll get more standard compliance on Linux (over Windows) I sincerely doubt he will be running into any oddities using say VC++ to compile Ansi C code.
I don't think it is silly advice at all especially if he is following the K&amp;R book which is written with a unix like environment in mind. Getting started in Linux is super easy as all the tools and libraries you need will be ready to go out of the box or a simple apt-get, or yum install, away.
This is the redirect operator. The pipe is |
I remember it because it sort of looks like a piece of drainpipe !
'500' is an integer, as is the voltage variable. When an integer is divided by an integer, the result is also an integer - since they can't store fractions, it is lost. This would work: i = (500.0f / voltage); Since it's now a float divided by an int, which results in a new float.
I believe that worked, does that look correct? Voltage: 100 ____________ Distance Power Loss ________ __________ 20 25.00 Distance Power Loss ________ __________ 30 37.50 Distance Power Loss ________ __________ 40 50.00 Distance Power Loss ________ __________ 50 62.50 Distance Power Loss ________ __________ 60 75.00 Distance Power Loss ________ __________ 70 87.50 Distance Power Loss ________ __________ 80 100.00 Distance Power Loss ________ __________ 90 112.50 Distance Power Loss ________ __________ 100 125.00 Voltage: 200 ____________ Distance Power Loss ________ __________ 20 6.25 Distance Power Loss ________ __________ 30 9.38 Distance Power Loss ________ __________ 40 12.50 Distance Power Loss ________ __________ 50 15.63 Distance Power Loss ________ __________ 60 18.75 Distance Power Loss ________ __________ 70 21.88 Distance Power Loss ________ __________ 80 25.00 Distance Power Loss ________ __________ 90 28.13 Distance Power Loss ________ __________ 100 31.25 
My original code was 500/voltage when he gave the hint. I added the 500.0 thinking that it would solve the issue by forcing a decimal to be used. I have no idea what you mean as far as kW vs W. How would I go about correcting that?
by converting it to 500.0 you indeed fixed the integer division problem since the operation is converted to double precision math. The formula you gave states i = watts/volts and the assignment says 500kW. E.g. for 500kW/200V at 10 miles it would be i=500000.0/200 == 2500.0 instead of 2.5 R = 0.05 * 10 == 0.5 i^2 * R == 2500 * 2500 * 0.5 == 3125000 ?
Ah, I see it now. I hadn't noticed that the formula called for watts, I was searching through my code for the word watts and thinking what is this guy going on about? Thank you for clearing that up, Do these results look correct now? Voltage: 100 ____________ Distance Power Loss ________ __________ 20 25000000.00 Distance Power Loss ________ __________ 30 37500000.00 Distance Power Loss ________ __________ 40 50000000.00 Distance Power Loss ________ __________ 50 62500000.00 Distance Power Loss ________ __________ 60 75000000.00 Distance Power Loss ________ __________ 70 87500000.00 Distance Power Loss ________ __________ 80 100000000.00 Distance Power Loss ________ __________ 90 112500000.00 Distance Power Loss ________ __________ 100 125000000.00 Voltage: 200 ____________ Distance Power Loss ________ __________ 20 6250000.00 Distance Power Loss ________ __________ 30 9375000.00 Distance Power Loss ________ __________ 40 12500000.00 Distance Power Loss ________ __________ 50 15625000.00 Distance Power Loss ________ __________ 60 18750000.00 Distance Power Loss ________ __________ 70 21875000.00 Distance Power Loss ________ __________ 80 25000000.00 Distance Power Loss ________ __________ 90 28125000.00 Distance Power Loss ________ __________ 100 31250000.00 Also.. why does the last output in each voltage move a space to the right?
well it sure doesn't look correct and one has to do with another. When reverting back to the original and using kW and kV things look better. I suggest you take a look at the units. The formula states watts/volts. If both are multiplied by 10^3 would that make a difference?
Implement a Scheme interpreter. This is the simplest way to learn a programming language. Chapter 4 of SICP (Abelson &amp; Sussman).
possible duplicate of http://stackoverflow.com/questions/24376050/clarification-on-c-programming-assignment
Yea that was me, I found my answer there.
The loop for (i = 0; i &lt; 10; i++) /* outer loop body */ executes its body 10&amp;nbsp;times. But the body of that loop is the following: for (j = 0; j &lt; 10; j++) k++; So that inner loop, which executes its body (that&amp;nbsp;is, `k++;`) 10&amp;nbsp;times, is itself executed 10&amp;nbsp;times, because it is the body of the outer loop.
 i,j,k=0; for(i=0;i&lt;10;i++) //Starting at i=0, while i is less than 10, incrementing i each time the nested segment is completed {for(j=0;j&lt;10;j++) //same as above for j {k++; } So what this is saying, for EACH value of i, 0-9, do the following: for EACH value of j, 0-9 increment k by 1. Therefore you are incrementing k 10 times for each value of i. Does this make sense? Godzilla answered the question that you posed correctly. 
When you have any loops or conditionals, they operate on the block or statement immediately following them. Thus your code can be rewritten using braces as follows: int i, j, k = 0; for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 10; j++) { k++; } } Let's add a printf after the k++ line to print out the current value of k. Without braces, your code would be: int i, j, k = 0; for (i = 0; i &lt; 10; i++) for (j = 0; j &lt; 10; j++) k++; printf("%d\n", k); This is equivalent to the following: int i, j, k = 0; for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 10; j++) { k++; } } printf("%d\n", k); However, if you had braces around the k++ and printf lines, the entire block would now be attached to the for(j ...) loop. This is one primary reason that I write all my code with braces (and indent properly), even for single line contents. The reason being that if for any reason, I need to add additional statements to the loop/conditional, there's no chance that I forget to add braces and introduce a bug. _/end plug for coding style_
Are you taking a test right now?
The answer is 63. Good luck on your test.
typeof is not plain c, it's a gnu extension. 
You don't have to use `malloc()` for structures, where did you get that idea? Structs work just like any other type, they can be declared with automatic lifetime: struct foo f; ...or dynamic lifetime: struct foo *f = malloc(sizeof(*f)); This is no different than integers or any other type. An integer with automatic lifetime is declared as: int i; ...while an integer with dynamic lifetime is declared and allocated as: int *i = malloc(sizeof(*i)); The choice of whether to use automatic lifetime or dynamic lifetime does not depend on the type. It's a choice that is made based on how long the variable needs to live. If it is to outlast its enclosing scope, then it must either be copied out when the flow of execution leaves that scope (typically by the `return` statement), or it must have dynamic lifetime. What you probably got hung up on is the fact that copying an integer from one scope to another is practically free, so that is the common choice made. If a structure contains a lot of data, then copying it can be costly, and so the other choice is made, to give it dynamic lifetime instead. But you could give an integer dynamic lifetime if you wanted to, and you could copy a struct if you wanted to. There's nothing preventing either of those. 
Thanks, very helpful, that is exactly what I was thinking.
Also are function-like macros standard C? I thought they were a gcc extension #define foo() ({1234;}) 
Looks pretty handy! The trick I've used in the past is to just spit out CSV and give it an XLS extension, because few users can tell the difference anyway. 
its a compound statement expressions, most compilers support it except vc++. 
You do need to write that if you want the int to outlive the function it was created in, just as with an object of any type: int* create( void ) { int* p = malloc( sizeof *p ); *p = 123; return p; } int main( void ) { int* p = create(); printf( "%d\n", *p ); free( p ); } 
people have been makeing classes and objects in c for 40 years. and oop was invented in the 1960. 
Is it standard C?
&gt; Is it true that learning C++ will basically teach you C? Not exactly. [Here's](http://www.durofy.com/10-major-differences-between-c-and-c/) an article that explains some major differences better than I can. Can you learn C++ and then inherently know about C programming? Well, to some extent, yes, but it will not make you *proficient* in C. 
No. C++ was my first language. I eventually had to learn C. This was actually difficult because most books (pre-mainstream Internet days) didn't talk about learning C if you knew C++; they all went the other direction. Additionally, the good paradigms in C are very different than the C++ approach. Many years later, I find C the more useful language of the two. I also worked on projects and people that had high portability requirements and a C background. I was young and foolish and didn't understand the C++ incompatibilities and complexities that would leak into everything and cause my associates pain. (Linking problems, subtle binary compatibility problems, subtle compiler and standard library compatibility problems, etc.) They didn't understand C++ at the time and assumed they were doing things wrong in their own C code. I realized in hindsight that all the problems were caused by my use of C++ and I forever regret making their lives so difficult. 
I generally wrap my C++ implementations in C APIs so they're reliably callable from almost anything. The wrapper also serves to keep the API more stable even when I change the implementation around.
its conformant to gnu99 which is a superset of iso c99. gcc, clang and intel support it. but it is not iso c99. 
that article is complete and utter nonsense.
That helps some of the problems, but you are still susceptible to binary compatibility problems, particularly if you build libraries for other people to use. For example, the C++ runtime and the C++ standard library and not necessarily compatible between different compilers or even the same compiler but different versions. These problems never go away. We had a ton of problems back then, but now we continue to see new manifestations of the same problems. Android is one of the worst because they ship 3-4 versions of the compiler and 3-4 versions of the C++ standard C++ library which leads to a 4x4 permutation of C++ libraries that are all potentially (and dangerously subtle) incompatibilities. If you are lucky, you crash. I haven't been so lucky, and seen much weirder stuff that is impossible to debug. If you parse their warnings/documentation enough, you can see they tell you to not dynamic link the C++ standard library because you can't intermix versions, but at the same time, they tell you to not statically link the C++ standard library because global variables in the C++ standard library implementations may cause problems. And it's not just Android. In the Apple world, we have gcc vs. clang, and two C++ standard libraries, libstdc++ and libc++. You can't intermix the two. And you can see in Microsoft Visual Studio, they put version numbers in the .dll file names. But this creates a different .dll hell problem, particularly when dealing with other people/libraries. And in the Microsoft world, people never upgrade so everybody is running a different version of Visual Studio. And then inline functions are pain because it is unclear whether the code was pulled from the header or from the library. C++ makes it particularly worse because basically templates and the STL inline everything. 
&gt; you are still susceptible to binary compatibility problems, particularly if you build libraries for other people to use. For example, the C++ runtime and the C++ standard library and not necessarily compatible between different compilers or even the same compiler but different versions. Ahhh. I only distribute source, and avoid the standard C++ library (the things I've written have little use for heavy C++, and compatibility was one reason I chose C++ 'lite'). C++'s expansion has only made me move away from it more since. Sounds like a mess with libraries. The main reason I've used C++ is the 'this' pointer. It's so tedious to do that in C: member functions must all have class-specific prefixes, and the caller must use this prefix and pass the 'this' pointer. Private is nice for enforcing what of the implementation nobody should depend on, to make changes less risky. Virtual is useful when things share an interface, and tedious to do in C with all the downcasting. And templates are nice for basic container classes.
By C++ standard lib, do you mean the "&lt;string&gt;","&lt;iostream&gt;",etc stuff? Do you just use the C stdlib? I've been trying to learn C++ as a C guy, and I am finding some of the C++ features useful, but I feel like I am doing it all wrong and am just writing C in C++ using a couple templates and not having to declare all my variables at the beginning of the current scope.
I don't blame the language. Hundreds of thousands - possibly even millions - of people have programmed in C and understand it perfectly fine. I blame people not paying attention when they were taught this sort of thing.
both gcc mingw w64 and clang run on windows and have full c11 support. unless the project demands vc++ there is no reason to use it. 
Very cool! This is written by the same guy that did the Perl xls and xlsx writers so I know it will be awesome.
I've never really looked into using another compiler from within the Visual Studio IDE (which would be very hard to give up), but it is possible with a makefile project, I believe? Can I debug the compiled code through the Visual Studio IDE as well? That would a preferable solution, as I'm not really writing Windows applications, just enough Win32 to create a window, handle event messages, and create an OpenGL context, so I wouldn't need anything like MFC support. Still I don't know if it is worth all the trouble over sticking with what I know, and that is c89. &gt;&gt;
yes, its worth it. it may take you a few days of fiddling but what you gain once your toolchain is setup is far more then what you have with vc++ and c89. * C11 + a huge number of libraries that compile with clang and gcc on windows but not vc++. * platform agnostic compiler target. in most cases your code can compile on any number of platforms that gcc/clang support, a huge win at this point. it also lets you abstract your system dependencies in one spot so any platform specific code is isolated from the rest. that improves the overall code base from my experience. * you can always keep your vc++ tool chain around and slowly build a new tool chain so its not to disruptive. * given you like vc++ you can take a look at QT Creator as a possible replacement. which would make your development completely platform independent. there has been a lot of work to integrate clang into visual studio. so it could be quite easy at this point to get up and running. [http://llvm.org/docs/GettingStartedVS.html](http://llvm.org/docs/GettingStartedVS.html) edit: and for OpenGL, i would take a look at GLFW. the project i am working on is also C/OpenGL. with GLFW i have one C project that compiles on window and linux with zero lines of code chage. the only difference is the compiler flags. i gave up fiddling with with winApi and xlib long ago because there is just to many well maintained cross platform GL windowing libraries now. it makes very little sense to reinvent that wheel at this point especially for a small team or a single developer. 
out of 10 points the only one that is correct is number 9... 
I've been using SDL for awhile, I will give GLFW a look, anything beats using the Win32 API directly ( :P ) and SDL has a lot in the library that I don't use (or want to dig through the source to see how easy it would be to remove unwanted functionality, like the 2D drawing API). To be honest, I don't know why I am doing things "the hard way" as opposed to using an engine like Unity3D to do these things for me, I guess knowing how things work is more interesting than just accepting that they do. Ugh, I feel like I have been desperately trying to play catch up since I gave up C as a hobby back in 2000, so much is different (!) and I am feeling pressured to make the switch to C++ but C++ is a huge beast to wrangle on your own. Thanks for replying to my random questions and thoughts!
it sounds like your in ok shape to me. the worst spot to be in now is sitting on a mount visual C++/DirectX code. unless your developing for pc and xbox exclusively getting a cross platform tool chain has been a big focus. android/linux/osx. and with SDL you have integration with Steam if your working on a game. GLFW is much slimmer then SDL but im not working on a game. SDL might be better for that. imo i would work on getting yourself set up with a better compiler and tool chain first. then at some point if you want you can look into C++. but with c++14 and c++18 coming down the pipe this is probably the worst possible time to look at C++ because the whole language is going through a metamorphosis. 
I recommend you to make friends with debugger, for example GDB. It right away tells you to pay attention to 25th line: Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7a93f79 in _IO_vfscanf () from /lib64/libc.so.6 (gdb) bt #0 0x00007ffff7a93f79 in _IO_vfscanf () from /lib64/libc.so.6 #1 0x00007ffff7aa2b04 in __isoc99_scanf () from /lib64/libc.so.6 #2 0x00000000004006a3 in askDouble (question=0x40080b "Enter another number: ") at test.c:25 #3 0x00000000004006fb in main (argc=1, argv=0x7fffffffe238) at test.c:33 What we have on this line: scanf("%lf", number); Ah, the second argument should be a pointer! Let's change that: scanf("%lf", &amp;number); Now it doesn't crash! Also, it would be a good practice to compile with -Wall -Wextra (or similar flags for your favourite compiler) to see all warnings from the compiler. This should help to get rid of possible bugs.
i have seen quite a few projects doing that. it looks like a solid framework. and you have luaJit also. once you get off of vc++ the world is much more c friendly. and c11 is much nicer then c89 imo. if you work on linux and cross compile for windows then everything is c and open source anyways which is quite nice imo.
I see. I had heard that MS compilers didn't support much of C99 until recently. C++ seems a good tradeoff for getting this. I stuck with Mac OS 9 (abandoned by Apple in 2000) until around 2009, and the compiler there didn't support C99 either, so for code I wrote for C99 I would compile it with C++ to be able to use // comments and declarations anywhere in a function. With discipline it was C99-compatible. I tend to avoid big tools and the latest of everything once I've figured out what I want. The constant change isn't worth the minor benefits when I've got something that meets my needs and I've established routine.
can you share your code? I'd like to see how you did it all :)
here is a stupid question but, is that game working in dos window?
Yes, it's a command-line program. Why?
Then you're past the initial level of learning C, and you * dynamically allocate the buffer you read into, with malloc() * check if the last character read is a newline * if not, you got a partial line - realloc() the buffer, call fgets() again and append the data to your buffer. Repeat until you got a full line, or give up because you're using too much memory. Alternatively, use the getline() function if it's available. 
What's so strange about playing games in a command-line utility? I'll PM you the code.
How can askText return a char and not a char *. Does it compile? And if you change it to char *, you will be returning a pointer to a local variable, which is a sure way to crash...
In which projects can we use this library? I mean when and why should we use this library?
The simplest use case would be when you have a project that needs to create a report in an Excel format. The advantage over CSV is that this library allows you to have formatting and multiple worksheets and hopefully other features in the future. I wrote this library and a Perl, Python and Lua version. The majority of users who write to me seem to be either involved in science or financial services but people use the modules for everything and anything. For example one person used the Perl version to create something called [roll charts](http://www.rollcharts.org) for motorcycle trips. 
Thx for the answer. Definitely will use it in my projects. Seems so versatile and useful.
What arguments are you passing?
 char string[] = "Hello\n"; char string2[] = "Nothing"; copy_string(string, string2); 
yeah changed it, thats not the problem though
Change char string2[] to const char string2[] or pass the string literal to the function instead.
None of that is working :\ thanks tho
For string copying, you need remember that C strings are arrays of chars terminated by a null character. However, people generally don't refer to the arrays directly. Rather, they keep pointers to the first character of the string. Through pointer arithmetic, you can reach the other characters. So you must go through the characters of the second string, whose first element is pointed by the pointer s2, and assign them to the elements (chars) of first string in the appropriated position. *s1 is the first character of the first string in your copy operation. *s2 is the first character of the second string in your copy operation. Simply doing *s1 = *s2 won't copy the strings. It'll just copy the first character of the string (if it's not empty; if it's, then it'll just copy the null character from the second one into the first one). Assuming the second string is 3 characters long: *s2 is the first char, *(s2+1) is the second, and *(s2+2) is the third. You can use subscript notation, which is more pleasant IMO: s2[0] is the first char, s2[1] the second, and s2[2] the third. The null character will be *(s2+3) or s2[3]. And remember that the null character is just 0. Different professors want different things. Maybe yours just wants you to use strcpy. Edit: Had lots of errors due lack of attention while writing.
strcpy not strcopy.
I know. In his/her original code, he/she was passing the arguments to a function named strcopy. I was wondering why.
In trying to implement this solution, the OP may have segmentation errors if his s2 string is longer than his s1 string, and from the sample he gave me, this appears to be true. The same limitations that apply to strcpy also apply to this solution: The strcpy() function copies the string pointed to by src, including the terminating null byte ('\0'), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy. Beware of buffer overruns! (See BUGS.) See http://man7.org/linux/man-pages/man3/strcpy.3.html for more info.
Don't just do OP's homework for him.
He can still to some mistakes if he just copies my function.....
&gt; However, people generally don't refer to the arrays directly. Rather, they keep pointers to the first character of the string. Through pointer arithmetic, you can reach the other characters. This is actually how all arrays in C work. The bare array name is a pointer to the first element in the array. These next two lines are equivalent: aryStuff[4] = 2; // The "array" way. *(aryStuff + 4) = 2; // The pointer way.
Different ways to learn, I guess - I guess I try to take advantage of all of them.
You should really do the exercises. How are you supposed to learn how to swim without entering the water?
k&amp;r code is a bit dense. it might be hard to get whats going on unless you can mess with the code and compile it. it can't hurt but your probably better off with a math book, notepad and a pencil. 
I have every intention of doing them but just not when I don't have access to a computer :/
You should check your docs because it is platform dependent, but it should be a type large enough to hold a memory address. Pointers are often of size size_t.
iso 9899 7.19 size_t which is the unsigned integer type of the result of the sizeof operator.
size_t is of type unsigned int. as defined by the 1SO standard. the number of bytes of an unsigned int is platform and compiler specific. only ptrdiff_t is guaranteed to be the size of a pointer.
Are you asking how to concatenate strings? Or do you really want to know if you can have a pointer to the \0? The pointer to the zero would be just char *string = whatever; char *zero = string+strlen(string); Provided the buffer that your string is stored in is large enough to store more characters, you can do whatever you want.
&gt; call fgets() again I don't understand this. If one of the arguments in fgets() is how much characters I want to copy to a string, and there is now way I can see that file, then how can I know that number?
if we make an empty string literal you get \0. a string literal is appended with a null terminator. so \0 is just a one byte character. editing a string literal is undefined behaviour. so we can put this idea down. /* \0 is == 0 but a unique ascii character */ char *duh = ""; printf("%i %i %i\n", *duh == '\0', *duh == '0', *duh == 0); you can put \0 anywhere you damn well please in a string. any function that opperates on null terminated strings will recognize \0 as the end of the string. if you want to see this in action take a look at string.h functions (ie) strtok() etc. /* four byte string with \0 terminator */ char *f = malloc(sizeof(char)*4); *(f+0) = 'a', *(f+1) = 'b', *(f+2) = 'c', *(f+3) = '\0'; printf("len %lu\n", strlen(f)); /* chop in two */ *(f+1) = '\0'; printf("len %lu len %lu\n", strlen(f), strlen((f+2))); /* merge them back */ *(f+1) = 'b'; printf("len %lu\n", strlen(f));
A pointer is just a number that we call an address. Every byte of memory has an address. So of course the '\0' at the end of a C string can be pointed out. The '\0' is just a single byte (a char) with a value of 0. (Not ASCII '0', which is 48, but actual 0, which we call nul, nil or '\0') The 0 at the end of a string is a sentinel. When you hit it, you know you're at the end of the string. Otherwise, you wouldn't have any way to know you reached the end, and you would read off the end of the string, and undefined behavior would happen. Some other languages store strings differently. They have an explicit size stored somewhere, so they don't need a sentinel at the end. struct string { int size; char *data; }; The nice thing is that strlen() now doesn't have to count the characters in the string, it just reads the size variable. But now the size variable is taking up extra space. And of course your existing functions won't work on it. 
You can thing of all of your programs memory as a giant array. But there's some gaps in it. So it might be better to thing of it as several arrays, one for global variables, one for local variables, and one for malloc(). Local variables live on the stack. Memory returned by malloc() is on the heap. Another way to think about it is graph paper. Each cell in your graph paper is a byte. You can write one character in each cell. The '\0' also takes up a cell. You can count cells until you get to the '\0', and call that it's address. Maybe the string starts on cell 23 and the 0 is on cell 42. If you tell someone to read the string at cell 23, they start reading, and they keep reading until they see the \0. If there is no \0, they keep reading. But you wrote down something unrelated in cell 43, and now they're very confused. But if you gave them a pointer (start at cell 23), and a length (and keep reading for 19 cells), then you wouldn't need \0 as a sentinel. But you can't erase the \0 and add on to the string, UNLESS you reserved some extra cells after the string ahead of time. If you didn't reverse those cells, then some other variables come right after it, and there's no room. So your only option is to copy it. You reverse space in C by: Using an array that's bigger than what you need. char foo[256]; Calling malloc() with a larger value than what you need: char *bar = malloc(256); If you allocated with malloc(), realloc() will move it for you, it needs to be moved. bar = realloc(bar, 512); Or you can use strcpy() or memcpy() to move it by hand. But of course you need something big enough to move it into.
unless you want to refute with a quote form the ISO spec then i don't have time for it. c is not made of unicorn farts and feels.
&gt; size_t is of type unsigned int. as defined by the 1SO standard. No. The ISO standard says: &gt; ... &gt; &gt; `size_t` &gt; &gt; which is the unsigned integer type of the result of the `sizeof` operator; ... That does not mean that `size_t` is a synonym for `unsigned int`. It could be a synonym for `unsigned long`, for example, or it could be a different unsigned integer type. === &gt; only ptrdiff_t is guaranteed to be the size of a pointer. Also not true. The ISO standard says: &gt; ... &gt; &gt; `ptrdiff_t` &gt; &gt; which is the signed integer type of the result of subtracting two pointers; ... There is nothing in the ISO standard that requires that a pointer itself must be the size of `ptrdiff_t`. The standard guarantees that "A pointer to `void` may be converted to or from a pointer to any incomplete or object type. A pointer to any incomplete or object type may be converted to a pointer to `void` and back again; the result shall compare equal to the original pointer." So the type `void *` is large enough to hold the value of any pointer. If you want an integer type that is large enough to hold the value of any pointer, you should use one of the (optional) types `intptr_t` (which "designates a signed integer type with the property that any valid pointer to `void` can be converted to this type, then converted back to pointer to `void`, and the result will compare equal to the original pointer") or `uintptr_t` (which "designates an unsigned integer type with the property that any valid pointer to `void` can be converted to this type, then converted back to pointer to `void`, and the result will compare equal to the original pointer"). These types are defined in `&lt;stdint.h&gt;`.
7.19 2 is the 'definition' of size_t. size_t is 'defined' as an unsigned integer. | There is nothing in the ISO standard that requires that a pointer itself must be the size of ptrdiff_t I hate to state the obvious but in order to take the difference of two pointers with ptrdiff_t, ptrdiff_t has to be, uh the size of a pointer. 
&gt; size_t is 'defined' as an unsigned integer. It is defined to be an unsigned integer type. That does not mean it is defined to be `unsigned int`. There are unsigned integer types other than `unsigned int`: for example, `unsigned long` and `unsigned short`. &gt; I hate to state the obvious but in order to take the difference of two pointers with ptrdiff_t, ptrdiff_t has to be, uh the size of a pointer. No, not true. Perhaps a certain system has 8&amp;nbsp;GB of memory, for example, so that 64-bit pointers are required to access it all, but the maximum allocatable size of any single object is 1&amp;nbsp;GB. Then `ptrdiff_t` can be a 32-bit integer type. Remember, subtracting two pointers that do not point to elements of the same object results in undefined behavior—there is no requirement in the standard that it must be possible to subtract two *arbitrary* pointers.
&gt; You should check your docs because it is platform dependent, but it should be a type large enough to hold a memory address. Pointers are often of size size_t. Don't assume this. There's intptr_t and uintptr_t (if you like unsigned better) for portably holding a pointer in an int.
Yes. I agree that `size_t` is an unsigned integer type. There is no argument there. But "unsigned integer type" does not specifically mean `unsigned int`. For example, `unsigned long` and `unsigned short` are also unsigned integer types. Therefore, the fact that `size_t` is an unsigned integer type does not mean that `size_t` is `unsigned int`.
It's actually not quite that. When you use the array for its value, you'll get a pointer to its first element. C provides with that convenience, but that's not the only way to use arrays. It's good to keep in mind that this is just __a language convenience__ that C gives you. char s[10]; char *p = s; // s is used for its value -- you'll then implicitly get a pointer to its first element. size_t siz = sizeof s; // s is not being used for its value char (*as)[10] = &amp;s; // s is not being used for its value. So you could refer to the array directly, and not just through pointers to the first element. The actual details of this are quite annoying, but whenever you do a subscripting operation, you use the array for its value, so you'll get the pointer. But you can keep the array around instead of just a pointer to its first element. In C, however, it's __so common__ that arrays are used for their values that it sometimes masks the other (also important) uses. And, just for the sake of it, a[b] is defined to be equivalent to *(a+b), which means __these all are the same thing__ (syntactically they're different, of course, but they mean the same): - a[b] - *(a+b) - b[a] - *(b+a) So, this is valid C: char s[10]; /* fill in s */ putchar(1[s]); They are both "the pointer way" in the sense that a[b] will use the array for its value, getting a pointer to the first element and doing pointer arithmetic on it. Of course, notation-wise a[b] seems more array-ish than *(a+b). Edit: Misread his response and re-wrote some parts accordingly.
&gt; no one said anythign about subtracting pointers of different type but you. I am not talking about subtracting pointers of *different types*. I am saying that subtracting two pointers that do not point to *elements of the same array object* leads to undefined behavior, even if those two pointers are the same type. From 6.5.6.9 of the C99 standard (emphasis added): &gt; When two pointers are subtracted, both shall point to elements of the same array object, or one past the last element of the array object; the result is the difference of the subscripts of the array elements. The size of the result is implementation-defined, and its type (a signed integer type) is `ptrdiff_t` defined in the `&lt;stddef.h&gt;` header. **If the result is not representable in an object of that type, the behavior is undefined.** In other words, if the expressions `P`&amp;nbsp;and&amp;nbsp;`Q` point to, respectively, the *i*-th and *j*-th elements of an array object, the expression `(P)-(Q)` has the value `i`−`j` provided the value fits in an object of type `ptrdiff_t`. Moreover, if the expression&amp;nbsp;`P` points either to an element of an array object or one past the last element of an array object, and the expression&amp;nbsp;`Q` points to the last element of the same array object, the expression `((Q)+1)-(P)` has the same value as `((Q)-(P))+1` and as `-((P)-((Q)+1))`, and has the value zero if the expression&amp;nbsp;`P` points one past the last element of the array object, even though the expression `(Q)+1` does not point to an element of the array object. And from K.2: &gt; **K.2 Undefined behavior** &gt; &gt; The behavior is undefined in the following circumstances: &gt; &gt; ... &gt; &gt; * Pointers that do not point into, or just beyond, the same array object are subtracted (6.5.6). === &gt; &gt; But "unsigned integer type" does not specifically mean unsigned int &gt; &gt; actuall that is exactly what it means. No, absolutely not! From 6.2.5 of the C99 standard: &gt; There are five *standard signed integer types*, designated as `signed char`, `short int`, `int`, `long int`, and `long long int`. (These and other types may be designated in several additional ways, as described in 6.7.2.) There may also be implementation-defined *extended signed integer types*. The standard and extended signed integer types are collectively called *signed integer types*. &gt; &gt; ... &gt; &gt; For each of the signed integer types, there is a corresponding (but different) *unsigned integer type* (designated with the keyword `unsigned`) that uses the same amount of storage (including sign information) and has the same alignment requirements. The type `_Bool` and the unsigned integer types that correspond to the standard signed integer types are the *standard unsigned integer types*. The unsigned integer types that correspond to the extended signed integer types are the *extended unsigned integer types*. So the phrase "unsigned integer type" does not include only the `unsigned int` type. It also includes the types `_Bool`, `unsigned char`, `unsigned short int`, `unsigned long int`, `unsigned long long int`, and any implementation-defined extended unsigned integer types. The fact that `size_t` is an unsigned integer type does **not** necessarily mean that it is a synonym for `unsigned int`. It could be *any* one of the unsigned integer types, and there are unsigned integer types other than `unsigned int`.
fscanf is probably one of the better c functions for reading a line or known data like that. Out of curiosity, can the name of spaces in it? If so, I'm not sure this code will work. On to your question! The simplest way to do that would be to read your line in to temporary variables, like so: #define MAX_NAME_LENGTH 255 int nbr, grade; char *name = (char*)malloc( MAX_NAME_LENGTH ); fscanf( file, "%i %s %i", &amp;nbr, name, &amp;grade ); structArr[i].nbr = nbr; structArr[i].name = name; structArr[i].grade = grade; BUT, that doesn't actually make your array as long as the string itself, it just dynamically allocates it. So you'll have to copy to string in to your struct. structArr[i].name = strndup( name, strnlen( name, 255 ) ); free( name ); That copies the name char* in to your structure (at most 255 bytes of it), and then frees your dynamically allocated name, so you don't leak memory. Be warned, I didn't compile any of this...
What I'm guessing happened is that there was an if statement inside of another if statement, which was itself in some kind of loop. The programmer wanted to skip over the rest of the outer if statement if the conditions for the inner if statement were true (I imagine this could have been done by putting the rest of the outer if's code inside an else for the inner if). When he put the break in, however, it skipped the rest of the loop that the if statements were in, instead of skipping the rest of the if statement. This loop was probably very important, and skipping over it would have removed some important functionality.
Silly code example (very poor one at that but what you gonna do?): while (thereIsCakeToEat) { if (!hasCutlery) { cutlery = lookForSpoon("small", &amp;kitchen); if (cutlery != null) { hasCutlery = true; break; // this will break out of entire while loop, break doesn't work on ifs } cutlery = lookForFork("small", &amp;ktichen); if (cutlery != null) { hasCutlery = true; }else { // there is no spoon or fork in the kitchen, perhaps some error handling should come in here... } } eatCake("bite", &amp;cutlery); } 
A break is essentially a goto just after the most inner loop/switch the break is in: for ( ;; ) { if ( ... ) { if ( ... ) { ... break; // goto expected; // what programmer thought // goto actual; // what actually happens } ... } expected: printf( "Never called\n" ); } actual: 
&gt; subtracting one pointer from another that gives you a resultant pointer The difference of two pointers is never another pointer. It is a signed integer type, not a pointer type. What you are saying is nonsense. &gt; that has nothing to do with the size of ptrdiff_t. which is the size of the implementation defined pointer. No, `ptrdiff_t` is the size necessary to hold the **difference** of two pointers, which is *not* a pointer type. &gt; that value is held in type ptrdiff_t. the resultant address of the pointer arithmetic. Again, the difference of two pointers is **not a pointer**. It is a signed integer. &gt; again the operative word is **different**. each type is distinct. and each unsigned type is distinct. Well, not *necessarily* distinct, but yes. Of course there are different unsigned integer types: `_Bool`, `unsigned char`, `unsigned short int`, `unsigned int`, `unsigned long int`, `unsigned long long int`, and the extended unsigned integer types. This is exactly my point. You seem to be claiming that there is only one unsigned integer type, namely, `unsigned int`. But that is false. There are *many* unsigned integer types. The types `_Bool`, `unsigned char`, `unsigned short int`, `unsigned int`, `unsigned long int`, `unsigned long long int`, and the extended unsigned integer types are **all** unsigned integer types according to the C&amp;nbsp;standard. The standard merely says that `size_t` is **an** unsigned integer type. It does not specify **which** unsigned integer type it is. It is *possible* that `size_t` is `unsigned int`, but it is **also** possible that `size_t` is `unsigned long`, for example, because `unsigned long` is also an unsigned integer type! &gt; therefore unsigned integer is not the same as signed integer nor the same as unsigned long and so on. No. The phrase "unsigned integer type," as used by the C&amp;nbsp;Standard, refers to a *class* of types: `_Bool`, `unsigned char`, `unsigned short int`, `unsigned int`, `unsigned long int`, `unsigned long long int`, and the extended unsigned integer types. That is the **definition** of the phrase "unsigned integer type" in the C&amp;nbsp;Standard. The phrase "unsigned integer type" has an explicit definition that includes more than just the type `unsigned int`. See 6.2.5 of the C99 standard. &gt; when the definition declares the type that is the type period, with no ambiguity. But the C&amp;nbsp;Standard does **not** specify that `size_t` is the same as `unsigned int`. What it says is that `size_t` is **an** unsigned integer type. There are many unsigned integer types: `_Bool`, `unsigned char`, `unsigned short int`, `unsigned int`, `unsigned long int`, `unsigned long long int`, and the extended unsigned integer types. The type `size_t` may be any of these types, because all of those types are unsigned integer types.
&gt; putchar(1[s]); Oh god, this is just...I would totally use this just to confuse and annoy other coders. Amazing. 
 int storeExamples(ExampleStruct **examples) { *examples = (ExampleStruct *)malloc(2 * sizeof(ExampleStruct)); createExample(&amp;(examples[0]), "gsdfbggks"); createExample(&amp;(examples[1]), "gsffghfddfbggks"); `examples[1]` is out of bounds. You're allocating an array of structures at `*examples`, aka `examples[0]`. `createExample` should take `ExampleStruct *`. If you want an array of pointers instead, you'll need an extra level of indirection here. (`ExampleStruct ***`)
I'm not too sure I understand correctly what you mean, sorry I'm dumb. If examples[1] is out of bounds, how come I'm able to display its content in the storeExamples function? Shouldn't it give me a segmentation fault if it was the case?
I forgot to add the program output: ./minimal Displaying data from storeExamples function: Title: "gsdfbggks" Title: "gsffghfddfbggks" Displaying data from main function: Title: "gsdfbggks" Title: "(null)"
You probably want to pass `&amp;(*examples)[0]` and `&amp;(*examples)[1]`. (or equivalently `*examples` and `*examples + 1`) Similarly, print from `(*examples)[0]` and `(*examples)[1]`. Segmentation faults happen at page granularity (at least 4KB); going one past the end of an array will only fault if that array happens to run up against the end of a page and the next page is marked to fault. It's pretty unlikely for this to happen by chance. More likely that you'll write into something unrelated or "harmlessly" into padding. In this case, `examples` will point to a chunk of the stack in main. There *will* be other things above it on the stack. Depending on how the compiler lays it out, you might be writing into `i` and `length` or the return address.
It's only called a hashtag if you're using twitter. If you try to say "hashtag-include" to refer to `#include`, someone will be dispatched to kill you in your sleep. The character `#` is called the pound sign only in the US. Outside of the US it's called the hash. 
Or octothorpe, or number sign, or sharp, or mesh... https://en.wikipedia.org/wiki/Number_sign#Other_names_in_English
If I understand correctly, I should change void createExample(ExampleStruct **example, char *title); to void createExample(ExampleStruct *example, char *title); and then change the call to createExample(*examples, "gsdfbggks"); createExample(*examples + 1, "gsffghfddfbggks"); I tried to adapt the code and uploaded the changes [here](http://pastebin.com/wXzjhLpX) but now I get a segmentation fault when trying to display the data in the storeExamples function. This is now my program output: Displaying data from storeExamples function: Title: "(null)" Segmentation fault
 example = malloc(sizeof(ExampleStruct)); This throws away the value of `example` that was passed in. Remove it, there's already a structure allocated. printf("Title: \"%s\"\n\n", (*examples[1]).title); This is still out of bounds. `[]` happens before `*`.
Wow I'm so stupid! Thank you! I changed it to printf("Title: \"%s\"\n", (*examples)[0].title); and everything works fine. Thank you dear C Master. Edit: And deleted the useless malloc in createExample.
NP, it can be difficult to keep track of multiple levels of indirection. &gt; the useless malloc in createExample It wasn't just useless; this meant that you weren't writing into the memory allocated in `storeExamples`. BTW, remember that C doesn't have a garbage collector. It all goes away when the process exits, but it's still a good idea to match every `malloc` with a `free`.
I actually cut the part where I free the memory and the rest of the program. Thank you very much for your help.
You call it an octothorpe.
You have the patience of a saint.
Characters **are** integers. Every character in the character set has a corresponding integer value, and in fact, as far as the computer is concerned, every character **is** its corresponding integer value. The `char` type in&amp;nbsp;C is an integer type: it is large enough to hold all of the integer values of the character set in use. Assuming the ASCII character set or a superset of it, the character&amp;nbsp;`'A'` is the integer&amp;nbsp;65, and the character&amp;nbsp;`'B'` is the integer&amp;nbsp;66, and the character&amp;nbsp;`'a'` is the integer&amp;nbsp;97, and the character&amp;nbsp;`'0'` is the integer&amp;nbsp;48, and the character&amp;nbsp;`'&amp;'` is the integer&amp;nbsp;38, etc.
Bang
a good way to get a handle on it is to take a look at the ascii chart and make the connection between the binary / deimal value and the character they represent. then try to do some simple code with characters as numbers and anticipate the results. ---- snip ---- int a = 'a'; printf("%i", a); printf("%c", 97); char b = a - 32; printf("%c", b); /* why does 97 - 32 = A ? */ ---- snip ---- [https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII)
Yep. At worst, it's a “hash” or “hashmark”. “Hashtag” does not refer to the character itself, but rather a string conforming to the pattern `^#[A-Za-z0-9]$`. The name comes from the fact such a string *starts* with the hash character.
oh, behave!
Excellent thanks 
Nah. Depends on where you live. In the US I have never heard the hash called anything but "pound", at least when referring to the character on the phone. In CS circles we call it a hash but in general it's often called a pound.
The (pseudo)code is here: http://users.csc.calpoly.edu/~jdalbey/SWE/Papers/att_collapse.html The intent was for a break statement to break out of a while loop, but the break statement was inside an if/else clause that was placed inside a case in a switch statement, so it broke out of the switch instead of the outer while loop. (it didn't really have anything to do with "breaking out of an if statement")
Lots of problems here. `s*` isn't valid syntax. It looks like maybe you were trying to write `*s`, which dereferences `s` and returns the `char` that it points to, but that's also bogus because you're trying to assign to `char_location` which has type `char *`, and you can't assign `char` to `char *`. If you want to assign one pointer to another, that's written `char_location = s;` without any dereferencing. But that's still wrong because you never use the value of `char_location` elsewhere. Further problems: - `s++` in the while condition will advance `s` forward one before you ever get a chance to inspect the character it was pointing to. That means you never check the first character of the string, causing something like `strchr("foo", 'f')` to fail. - You can't `return NULL` if the `if` condition is false, because that will exit the loop and terminate the function after only checking one character. - Fix your indentation. It's horrible. Each new block should have its own distinct indent level. It is crucial that you use sane indentation for the sake of anyone else trying to read the code. 
A case where 'goto' would have been useful, I love the 'goto' keyword and find it useful for jumping out of a block of code (like error handling!)
A hashtag is a tag denoted with a hash (#). A hash used on Twitter is still a hash (or variant thereof).
What happened to the message the compiler gave you to tell you why it wouldn't compile?
Okay thanks, that is helpful, I tried this code const char* my_strchr( const char *s, int c) { char* char_location; char* i; for (*i=s ; *i ; i++){ /*line 9*/ if(*i == 'c'){ *s = *i; /*line 11*/ break; } } return *s; /*line 17*/ } mystrchr.c:9: warning: assignment makes integer from pointer without a cast mystrchr.c:11: error: assignment of read-only location mystrchr.c:17: warning: return makes pointer from integer without a cast and I'm not sure how to fix these warnings. Any tips are appreciated. 
Still lots of things wrong. 1. `*i = s` is all kinds of wrong. The expression `*i` is the `char` that `i` is pointing to, but you never initialized `i`, so this is undefined behavior -- it's writing to some random memory location. Furthermore, `s` is a pointer to char, and you're trying to assign that to a char, which is what the warning is telling you. It makes no sense to do this. Again, to assign one pointer to another pointer, you want `i = s` without any dereferencing. 2. `*i == 'c'` is comparing the `char` that `i` points to to the literal character `'c'`, not the character in the variable `c`. 3. `*s = *i` is bogus. That's trying to assign the char pointed to by `i` to the char pointed to by `s`. But since you never modified `s`, it still points to the first char of the string. Moreover, `s` is a const pointer, which means you can't modify what it points to, which is the compilation error. 4. `return *s` is trying to return the thing that `s` points to (a `char` value), but the function is declared as returning a pointer to `char`, not a `char`, so this is all kinds of bogus, and is what the second warning is telling you. You need to return the null pointer if the loop didn't find anything. 
Thanks for this, but what if my name exceeds MAX_NAME_LENGTH there in malloc function..? Is there a way to get a string from a file, determine it's size and then make a struct.Arr[i].name whose size will be equal to the string?
Looks like you could use some help understanding pointers. Here's a basic rundown that will also point out some problems with your code. A pointer is a memory location. It is defined using the \* symbol and also dereferenced using the \* symbol. With your variables, you can imagine that the name implies the entire type. So with int c, c is of type int. With char \*s, s is of type char **pointer** Pointers are **typed**. Typed means that the address the the pointer points to must contain the type of variable specified by the pointer. So in your code, you have a function that declares a char pointer called s. The variable s doesn't hold a char. It holds a memory address. Whatever is in memory at that address should be of type char. I.e, when you dereference the pointer, you get the value of a char that is in memory at the address of the pointer. s is of type pointer. \*s (dereferencing s) is of type char. In your code, you have a char pointer called i. Your for loop tries to assign the variable s (a pointer) to a char, hence the first warning. I'll come back to the second warning. The third warning is because you specify the return type of the function to be a char pointer, but what you're trying to return is a char since you are dereferencing the pointer. The second warning is because you're trying to assign a value to a type you've marked as const. It's easy to mix up constant pointers. You can have: char * const a; or const char * a; The first means that the pointer is constant. The address can't change, but what's at that address can. This is probably what you want. The second means that the data being pointed to is constant, but the value of the pointer (the address) can change. 
I remmember when hashtags werent a part of twitter but actually a separate 3rd party site you had to go to that would search twitter for these tags so you could find relevant content quickly or view trends and you had to follow @hashtag for your posts to be indexed on the site (I dont know if it still exists now). Anyway a hash tag is basically a tag defined by a hash. It consists of two parts. A hash and the content of the tag. The hash only exists to denote that there is a tag that exists. Kind of like brackets would. So no in short. A hash tag is an entity that doesnt exist without a tag and doesnt exist without content. Edit: Such like MrDOS has explained.
The basic answer to what I think you're asking is no. The size of the name field in your student struct must always be a set length. Structures are similar to types like int, float, double, char, etc... and the compiler must know how large they are so it knows how much room to allocate for them. This is at compile time, not run time, so it will never be able to know the length of whatever names you might or might not put in there. That said, there are ways of doing things that could potentially do something like what you're asking, but I'll warn you ahead of time, it will require more work and more fuss. You're name variable would have to become: char *name; Note that name is now a char pointer. A pointer is just an address and the compiler knows how big pointers are, so we're still ok. But remember that this doesn't actually allocate any space for the string itself; just the pointer. The rest of your code will need to be more complicated to deal with this. You will need temporary space (either on the stack or on the heap) to store each name as you read it in. It would be easiest if you gave it some maximum allowable length, like 255 as /u/james41235 suggested. (If you don't even want this restriction, then things get even more complicated... I'll leave it as an exercise to the reader). Your loop would then read in the name (up to your max allowable length) into your temporary storage, calculate its actual length, use malloc to allocate that number of bytes (don't forget about the NULL terminator!), copy the string from your temporary storage to the malloc'd stoarage, then finally assign the name pointer of your struct [i] to point to the newly allocated storage. You will now have to remember to free up all that space when any student struct is no longer needed. Since the name strings are now of varying size, you will also have to be careful to never run past the end of your string, so there will probably be times when you'll need to re-check the length of the string to pass into your functions. **side note** please always use the *n* string functions for safety, eg. strncpy as opposed to strcpy, strndup instead of strdup, etc... especially when dealing with user-supplied data. **TLDR** So yes, you can dynamically allocate the length of each name string, but that memory will not reside in the structure itself, and it will take more book-keeping to keep things consistent and safe. 
Crunchbang if you're using the Debian fork. 
What a weird spelling of "nobody".
in NZ we call it a hash, and we would say "hash include"
As to *why* it takes an int: historical reasons :) To cut a long story short, before C standardization all integral types smaller than `int` actually get passed as `int`. Keeping the parameter as `int` after standardization avoids any size mismatches between old code and new code. 
&gt;In music, it's a sharp The sharp symbol is its own symbol separate from the pound sign (# vs ♯), although you're arguably correct since lazy people like me use it as a placeholder when transcribing music into notepad
In swedish it is sometimes called "brädgård", which means lumberyard.
&gt; lazy people like me use it as a placeholder Also Microsoft when they noticed that they invented a language whose name cannot be typed on a standard keyboard.
I'm TA in some Brazilian university. Recently a first-semester CS undegrad asked me what "hashtag define" does. The actual professor was in class with me. He had that "oh the kids nowadays" look, but the student was so upfront... I mean, it's Brazil. We don't use `#` to count numbers, like #1, #2, #3... When I was a kid, `#` was just a strange symbol in my parent's phone dial... and to these kids, it's just something twitter invented. A few weeks later I found myself trying to explain how C-strings and buffer overruns enable worms like ILOVEYOU to exist. Then I remembered these students were all 4 or 5 when that happened. Heck, the first time I heard the word "meme" it was a theory to explain how ideas spread. It never ceases to amaze me how fast we and our language get obsolete. PS: just out of curiosity, before twitter, a student in Brazil might have asked something in the lines "what does tic-tac-toe-define do?"
Fastest would probably be an indirection table (especially if the output range is sparse and the total population of the output range is small). That is, create a small map to convert a contiguous range into a non-contiguous one.
maybe reading the numbers into an array and using qsort will help? e: if it's about the sorting algorithm bubble sort might be easy to implement. https://en.wikipedia.org/wiki/Bubble_sort
Make 5 ints (buckets) and put each number you read in a bucket. So, if you read in 5 do numFives++ Then while (I++&lt;numFives) Printf(" %d" 5); On mobile, but I hope you get the idea.
this is way better if you only have the numbers 1-5.
This is the first part of my project. I eventually want the program to read from a datafile that has a list of all the games I own, listed like (gamename genre and then rating(1-5). I want to be able to sort the games by rating and genre. My instructor wants us to use loops and switch statements in the program. Any tips would be appreciated. 
I think that is the case here. He said all numbers are in range 1-5, so 5 buckets are needed
You can look into structs and store all information about it in there. So title etc. Later depending how you want to sort it you can write few comparison functions and use q sort to sort the array. 
First focus on correctness, then worry about efficiency (if that of the original correct solution was even a problem).
 /* compile with: cc -std=c99 15.c -o 15 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int n[6] = {0, 0, 0, 0, 0, 0}; for (int cur; (scanf("%d", &amp;cur) == 1) &amp;&amp; (cur != -1);) if ((cur &lt; 6) &amp;&amp; (cur &gt; 0)) n[cur]++; for (size_t i = 5; i &gt; 0; i--) for (size_t j = 0; j &lt; n[i]; j++) printf("%zd\n", i); exit(0); } 
yes i misread and i like to complicate things. I always wonder 'what if the numbers weren't from 1-5? What if the list of numbers was large? What if if it didn't fit into memory?' Small things tend to get way to large this way.
genre is the same as ints but it will probably use a string (or even a defined integer in an enum or #define). If a string and the options are equally low in difference from eachother the same thing goes but you'll need a string comparision. When things seem to much to code by hand take a look at qsort for sorting larger stuff. Also as said, take a look at structures to group your data, qsort is very flexible (since you have to provide a comparision function) and adapts to your needs. Also this is a preferred way to tell people that c++ templates are quicker then c, telling people why is a bonus. e: by the same as ints i mean you define genres as ints like action == 1, platform == 2, 3d == 3 etc. If you want to sort by title eventually you'll need to handle strings and be able to compare them (which is not as easy as it seems with qsort for example).
No. Consider s being int* and *s being 0. while (*s++); // will not enter the loop, but will increment s However... while (*s) s++; /// will not enter the loop and not increment s 
Let's try a though experiment: Assume s is an (int *) to some memory location that stores an array of integers. Particularly, this array: {0, 1, 2, 3} s is pointing to the start of the array, so *s evaluates to 0. What will the value of *s be after: while(*s++); ? What about after: while(*s) s++; ?
The first will be 3 and the second will be 0?
 while(*s++); *s will evaluate to 0 initially, so the program will not enter the while loop. Even though the while loop is never entered, the post-increment, ++ after *s, will still increment *s to point to 1 after it has been initially evaluated to 0. while(*s) s++; Since *s initially evaluates to 0, the loop won't be entered, so *s will never be incremented, hence still point to 0 afterwards.
There's no difference in the syntax. You'd do it the same way.
So like this? I keep getting bus error int main() { char* name = "Tommy"; char* fine = "gatee"; size_t num = 4; strncpy(name, fine, 4); name[4] = '\0'; printf("%s\n", name); return(0); } 
Don't forget to `free` the memory you've allocated with `malloc` when you are done with it.
This is exact pointer operation already. example[16] is the same as example+16
Cover price on the book is like $60 these days, it isn't a cheap book. I normally recommend C Primer Plus instead, as foundational as K&amp;R is 1) it gets recommended to beginners which is stupid because unless you are an experienced programmer you won't understand half of what they talk about 2) it's getting outdated 3) it's really expensive for how small it is.
&gt; if (*tailPtr != NULL) You probably want to test `tailPtr != NULL`, not `*tailPtr != NULL`, right?
You get the point. ;)
Looks like that worked, but for some reason my debugger is reporting a segfault at the following line: &gt;(*tailPtr)-&gt;nextPtr = newPtr; Obviously *tailPtr is not NULL, but then why is it segfaulting?
Read up on sprintf.
Thanks, Ill take a look at it! Edit: I figured it out. I had to use sprintf like you suggested. Thanks again!
For some reason: &gt;if (tailPtr != NULL) { &gt;(tailPtr)-&gt;nextPtr = newPtr; Is causing me to segfault at (tailPtr)-&gt;nextPtr = newPtr; I feel like I'm making a simple mistake here, but I can't seem to figure it out. 
 Here is the new code, char scorebar[79 + 1]; sprintf(scorebar, " ■ＳＣＯＲＥ：%4d ＴＯＰ ＳＣＯＲＥ：%4d ＴＩＭＥ：%2d ■\n", score, topscore, time); //Scorebar Bar height = 1; for(y = 0; y &lt; height; y++) { for(x = 1; x &lt; 79; x++) { GameDisplay[x + (WIDTH * (y + 1))].Char.UnicodeChar = (unsigned char)scorebar[x]; GameDisplay[x + (WIDTH * (y + 1))].Attributes = BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_INTENSITY; } }
What exactly is `ListNodePtr`? Is it a structure or a `typedef`? Double check lines 3 and 5 to make sure they make sense to you. You're initializing it to `NULL` (which leads me to think `ListNodePtr` is a `typedef` for a pointer), but then you're passing in the address of the two variables to `enqueue`. This effectively makes the parameter `enqueue` receives a pointer to a pointer. 
ListNodePtr is a typedef of a struct I have defined in my header. The struct looks like this: &gt;struct listNode { &gt; int ID; &gt; int atime; &gt; int cputime; &gt; struct listNode *nextPtr; // pointer to next node &gt;}; &gt;typedef struct listNode ListNode; // synonym for struct listNode &gt;typedef ListNode *ListNodePtr;
I figured you might be interested, but OP clarified in another comment that `ListNodePtr` is a typedef of a pointer type. His `enqueue` takes `tailPtr` as type of `ListNodePtr *tailPtr`, which is effectively a `struct ListNode **tailPtr`. So in his case, `(*tailPtr)-&gt;nextPtr` *does* make sense, since a dereferenced `tailPtr` is itself still a pointer. I can totally see what your intention was though.
However `write(2)` returns `ssize_t`, precisely so it can return -1 on failure. Arguably `sprintf` ought to return `size_t` ... after all, `snprintf` takes a `size_t` size argument, in which case `printf` "ought" to return `ssize_t`. Trying to make this mess completely consistent is a fool's errand, I think. History has taken us here, but it does make working with `-Wconversion` exquisitely excruciating at times. So, I think I agree with OP, but don't think it's worth spending much thought on.
Totally agree. Typedef'd pointers haunt me in my sleep. 
I have updated the pastebin link and the error codes so that they align. Where should I be defining the variables? I thought you only do so at the top of the program if they are global?
Those aren't variable declarations, they are just function declarations inside main(): int main( ) { float compute_stress (float stress, int p); float compute_strain (float strain); void output_results(float stress, float strain, int p); return 0; } Being declarations they cause no side-effects at run-time, so main here is just a no-op.
There's a chance that `sprintf()` could fail. For example, it might need to allocate temporary extra memory to perform correctly rounded floating point conversions, for example. (Most algorithms for correctly rounded conversions require parts of the computation to be performed using arbitrary precision/bignum math.) In most implementations, the whole family of functions all reuse the same code. They might create a type of psuedo `FILE *` which represents output to a fixed buffer so that `sprintf()` can call `fprintf()`, and so on. Anyway, my overall point here is that in most implementations it would probably be difficult or impossible to separate the code into a path where it's not possible to fail and return values are `size_t` (for use by `sprintf()` and `snprintf()`) and a path where it's possible to fail and have return values are `int`. 
I'm probably pretty similar to you in terms of skills and I'm working through Head First C bit by bit. I was skeptical about the cutesy format at first, but I'll be damned if it isn't totally effective for me. Very easy to digest without being dumbed down. I think it might be a bit rough for someone without any programming experience (especially if they also have no Linux experience), but it's great for someone with at least the basics under their belt in another language. 
The book starts off a pretty beginner level. The book was last published in 1997 and really needs updating, I think. I have it and usually end up referencing google way more than I do this book. TLDR: I don't remember any crazy math involved. The most complex programs involve card games and Fibonacci numbers, anything a smart high schooler could figure out.
I'm going to ignore your compiler output... Functions-- Functions are **named** sections of **code** that **take in arguments** and **return a value** to the caller. So, for any function, you need to specify the return type, the name of the function, the list of arguments, and the code body. When using functions, you will need: * Declaration of the function (not always, but it's best to just always do it) * The function * A caller to the function **All of these need to specify at least the return type, the name, and the arguments.** The declaration of the function is just a line that tells the compiler that this function with this name and these arguments exists somewhere, and it's ok to call it. Functions must be declared before they are called, and hence most people generally call this the forward declaration of functions, and they typically do so before the main() function or in header files that get included before main. It is sometimes possible to put the entire function before main and all other callers to that function, in which case the forward declaration isn't needed, but really... just don't. Always declare your functions. The function itself again needs to specify the return type, the name, and the arguments list. The arguments here are also named so that they can be referred to by the body of the function. The caller to the function will specify the function name and the **values** that you're passing into the function. The output of the function, what get's returned, is then effectively used in place of the function call. You will typically assign the return value of a function to a variable, or use it in the evaluation of another statement. When passing arguments to a function, you need to pass actual values, or variables that can be evaluated. Example time: /* Forward declaration of functions */ int foo(float x, int y); void bar(int x); char baz(void); /* Main */ int main (int argc, char **argv) { int some_number = 84; int ret = 0; float tau = 6.283; /* calling function foo */ ret = foo(tau, some_number); printf("second call to foo returned: %d\n", foo(3.14, 42)); printf("first call to foo returned: %d\n", ret); /* calling function bar */ bar(ret); /* calling function baz */ printf("This is my lucky %c\n", baz(); return 0; /* Main must also return an int */ } /* Function bodies */ int foo(float x, int y) { const float pi = 3.141592654; int my_value = 0; if (y * (int)x) &gt;= pi) return 42; /* Returns an int */ else my_value = y * 42; return my_value; /* Again, returns an int */ } void bar(int x) { printf("I got the number %d!\n", x); /* Note that because return type is void, no need to return anything */ } char baz(void) /* Since args list is void, it doesn't take any arguments */ { return (char)42; } Note that the call to printf is just another call to a function. The only difference is that this function was written for you already by whichever c library you're using. The reason the compiler doesn't complain is because you have a #include that declares it. 
I thought it was sometimes intentional to use a pointer to a pointer when traversing singly-linked lists, so you effectively always have a pointer to the previous element and the current one, for easy removal of the current one.
Sure, pointers to pointers are fine. But don't hide the pointer type behind a `typedef`.
 #include&lt;stdio.h&gt; #include &lt;math.h&gt; float compute_stress(float stress, float strain, int p ) { const float PI = 3.141593; float diam, area; printf("Enter diameter: \n"); scanf("%f", &amp;diam); area=(PI * (diam *diam ))/4; for(; p&lt;=100000000; p= p+100000) { stress /= p/area; } return stress; } float compute_strain(float stress) { const float e=30000000; float strain; strain = stress/e; return strain; } void output_results ( float stress, float strain, int p) { printf("Compression Load = %d lbs. Stress = %f Strain = %f", p, stress, strain); } int main( ) { int p = 3; float strain = compute_strain (2.0); float stress = compute_stress (1.0, strain, p); output_results(stress, strain, p); return 0; } So I'm not sure exactly what you're trying to do, but I made your code compile. The compute stress function doesn't really work, if you care to explain more about what it is doing, we can explain more. I'm wondering if you have done some matlab before and are expecting this code to produce an array or a vector of values? If so, you'll have to do quite a bit more to get the right result. C is a very simple language that cannot extrapolate very much about what you want to do, you have to make everything explicit.
But that's what `ssize_t` is for (though as I commented above, I think this is a bit silly!) I hadn't heard of floating point conversions requiring unpredictable amounts of memory, that sounds pretty scary and bad news to me. We're only talking about formatting conversions here -- do you have a reference for what you've said about using arbitrary precision? It would horrify me, to be honest, if so. 
&gt; But ssize_t is not part of ISO C, it's only POSIX. Ahhhh. End of conversation ;) Thanks very much for the links.
Yes. BUT, one is a "static" allocation while the other is "dynamic" (static meaning done at compile time while dynamic meaning done at run time while the program is running). Also, technically, you should have written: char *foo = (char *) malloc(sizeof(char [20])); You definitely should do the type cast, and probably this notation is clearer than multiplying by 20.
Nope, they are functionally very different. With the first declaration of `char test[20]`, you're utilizing automatic memory management. The memory (In this case, 20 `char` units, ~~*most* of the time~~ which is 20 bytes) will be allocated on the stack. This means at the end of the scope it's declared in, the memory is ~~destroyed~~ marked as free, and will be eventually overwritten by another stack frame. When you use `malloc`, you're allocating memory onto the heap, which is also called *dynamic memory allocation*. The key difference being that `malloc` memory isn't destroyed until you flag it as freed, using `free()`. This means heap memory can persist beyond the scope it's declared in, and you as the programmer can control when to let it go. Let me know if you have any other questions!
they are both runtime, do not confuse it with the real 'static' compile-time memory allocation, that requires a keyword `static`
The cast is a bad idea. It has no benefits, and it has some drawbacks. [More info](http://stackoverflow.com/a/605858/1505939) In C there are four storage durations: automatic, static, thread, dynamic. Sometimes people use "static" when they mean "anything except dynamic" however that seems like a worse idea than using the correct term, in this case "automatic". An automatic array has different lifetime to a static one. 
The type cast is actually not recommended. [No; you don't cast the result, since:](http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc) [You should never cast the return value of malloc(), in C](http://stackoverflow.com/questions/4993327/is-typecast-required-in-malloc)
Q1. This is a property of the shell you are using. (sh-style shells all have the same behaviour in this respect AFAIK). Q2. Newline is not EOF, so the loop exit condition is not triggered. The reason a newline appears to be special is because the default buffering mode for input streams is line-buffering: your code does not actually see any chars until the terminal receives a complete line. Then it sees the whole line at once. You can attempt turn this off with `setvbuf` (but it still may be that the shell or operating system line-buffers terminal input). Q3. Yes 
Thanks
They both allocate space for twenty characters, but the first has automatic lifetime (if written at function scope) or static lifetime (if written at global scope) whereas the latter has dynamic lifetime. Automatic lifetime means that the variable's life ends when execution leaves the scope in which it was declared. Static lifetime means its life extends for the entire duration of the program -- it's initialized before `main()` and torn down some time after `exit()` or a `return` from `main()`. Dynamic lifetime means that you must explicitly determine its lifetime by calling `free()` or a related function. Which one is best depends on what you're trying to do. Automatic lifetime is great if you only need the variable in the scope it was created. But remember that accessing an object whose lifetime has ended is undefined behavior, which in practice means Very Bad Things will happen. Static lifetime is convenient, but too much reliance on global variables leads to code that's hard to follow and hard to reason about, not to mention problems with re-entrancy and thread safety. Dynamic lifetime is very flexible and powerful, but the onus is on you to manage resources properly. If you neglect that duty, you might leak memory, or invoke a use-after-free condition, or a double-free condition, both of which are undefined behavior and cause Very Bad Things to happen. 
Regarding the "characters" issue, that is an ambiguous word. In this context they mean the number of elements in the string: for a narrow string, the number of `chars`; for a wide string the number of `wchar_t`s.
Welcome to TTY buffering. When you enter some characters then send `^D`, you aren't *actually* sending EOF - you are dumping the TTY buffer. The program on the other end receives all the characters you entered into the buffer before you pressed `^D`. EOF is a special condition that says the last read succeeded with 0 bytes. When you have nothing in the buffer and press `^D`, you are telling the TTY layer to dump the empty buffer which causes the underlying read to succeed with 0 bytes - and thus EOF. The other, and far more common, case where the TTY buffer is emptied is when you hit enter. The default mode for the TTY is *line buffering* (specifically, canonical line buffering mode, which is whatever the system finds to be a suitable default for entering text with some limited editing capabilities - ie., backspace). This means you can enter text, remove text, and eventually press enter to let the underlying application read what you typed. Once you hit enter, the buffer is dumped (including the line feed), and you have an empty buffer again, so now when you hit `^D` you are causing an empty, successful read again (and thus EOF). **e**: It also has absolutely nothing to do with your shell, which isn't even remotely involved in this process except that it returns the TTY to the default line buffering mode before executing your program (because it probably set it to a raw mode so it could do even fancier line editing of its own by receiving all key presses, including backspace).
Thanks alot! Edit: a lot ...
I can compile your version as well, but it seems the compute stress and compute strain are always 0.0000 regardless of the diameter input. The instructions I included are all the ones I received, but I believe it is supposed to give the stress and strain at each compression load from 10,000/100,000/200,000/300,000...../1,000,000 (based on the diameter input). Edit: I could be misreading your code as well, but it looks as though you are computing both stress and strain in a single function? It should be a function to compute stress, a function to compute strain, and a function to output those two at different loads of P. 
You are technically correct but it's very confusing to equal char to byte. Today everyone but language lawyers think of byte = 8 bits. I think it's better to explain char as the smallest unit of addressable memory.
But it's not, there are architectures on which the smallest addressable unit is a word.
Or declaration in global scope.
I'd just add that stack memory isn't "destroyed" when you leave the frame, it just waits to be overwritten by another stack frame. I guess malloc works in much the same way. I guess I have a problem with the word "destroyed" since it implies that something happens to the data stored in the memory.
Indeed, unless you're on POSIX, which requires CHAR_BIT == 8.
Interesting. So how do compilers deal with that? Fake 8 bit addressing with binary operations?
I'm pretty sure you just don't use POSIX on those platforms. Way better to break POSIX than to break C.
They both result in an allocation of the same size, but are different in several respects: 1. `test` has type "array of char" with a statically known size (within the scope of the variable) of 20. So, `sizeof test` is 20. 2. `foo` has type "pointer to char" and knows nothing statically about the location or size of the memory it points to. So, `sizeof foo` == `sizeof (void *)`. 3. If the declaration of `test` occurs within block scope, then it is an *automatic* allocation and the *extent* of the allocation ends with the scope. That is, it is undefined to access the memory after the dynamic execution leaves the scope in which it's defined. 4. If the declaration of `test` occurs at the file scope, then it is a static allocation; the compiler and linker will reserve space for it at compile time and it will always be at the same location in the store. The *extent* of this allocation is unlimited; it never becomes undefined to access it. 5. When you use `test` in a context that requires an address (i.e. what the value of a pointer variable always is), such as in a function call, pointer arithmetic, dereferencing via `*` or `[]`, its value *decays* to the address in the store of its first element. That is also the value that is returned by the address-of (`&amp;`) operator on `test`. 6. `foo` can be assigned a value such that it points at another valid allocation of memory, such as with `foo = test`. It is undefined for it to be assigned a value that is not `NULL` (i.e. `0`) or the location of a valid allocation or 1 element past the end of a valid allocation. It is undefined to dereference it at any time other than when it stores the address inside a valid allocation. 7. `test` can not be made to reference another allocated region of memory; it only ever refers to the memory the compiler assigns to it at compile time or which it is given by the compiler upon dynamic entry of the block scope it's defined in. 
The former is allocated linearly on the stack. The latter would allocate on the heap and take a bit more time, and must be freed manually later. An almost-equivalent would be alloca() instead of malloc(). It allocates on the stack as well, so that it's freed when the function exits. It's a compiler intrinsic, so it compiles to just a couple fast inline instructions. Some compilers handle it differently though, like the VC++ optimizer [might](http://stackoverflow.com/a/3410689/122118) inline a function with alloca, causing the memory to not be freed until the caller exits.
My bad, you are right. I don't very often see function declarations inside a function, so it didn't occur to me at all.
You can, it would involve reading each character until some delimiter and keeping a count, then malloc'ing that amount, rewinding your buffer, and reading it in to your buffer. If this is for a learning exercise, go for it. But I haven't come across a use case where that is really necessary. If I'm exceedingly worried about it, I make one really giant buffer to hold the string temporarily until I move it to smaller more permanent storage.
Can anyone else assist on this? I have missed the deadline to submit it correctly, but I would like to at least see what I was doing wrong. Somehow I still got a 92 on it, so I'm not sure if that means I was close? 
That would be very awkward. The standard doesn't allow a standard library function to reset `errno` to zero, only to set it to some nonzero value (C99 &amp;sect;7.5/3) which means the only way it can be reset is by the user code doing so prior to calling every library function. Otherwise, there's no way to tell if the function failed and set `errno` or if the function succeeded but `errno` happened to have some nonzero value from a previous function invocation. That's why the return value is used, and functions that can fail both return -1 and set `errno` to indicate the reason.
It becomes impossible to use it (or even its address) without invoking undefined behavior.
Well, lots of down votes for me. I disagree with you that they are both run time. The first is done by the compiler, and I would not call a compiler "run time."
&gt; My rule has always been to cast toward the result type so as to signify that you the programmer purposely change the type and didn't do so unintentionally. The problem with that is that it papers over diagnostics. By putting a cast there, you'll never get a warning about that conversion, ever, even if at some point in the future an API is changed that should render the conversion invalid. For example: void *get_foo(); // really returns a pointer to int int *foo = get_foo(); That's fine -- no warnings, because C allows an implicit conversion from `void *` to any other pointer type. But then suppose the API is changed so that now `get_foo()` returns something completely different, like pointer to some struct. If the line was: int *foo = (int *)get_foo(); ...then you'd never get a warning and instead you'd get silent crashes or other strange behavior because you forgot to update this one user of `get_foo()` when its API changed. Maybe this code is rarely called and this goes unnoticed for a long time. Anyway, the point is if it's written without the cast then you get a warning about incompatible pointer types as soon as you change the API and you can see all the places where you need to update the code. Maybe this is a contrived example, but the point is that warnings are very useful and using a cast disables them forever. 
The first is not done by the compiler. The compiler generates only instructions, which will init and manipulate the stack: push variables, move stack pointers and so on. In easy cases the compile may learn the actual layout of the stack frame for the function, but it is not true in general - the final layout and addresses will be known only when the function is called during the execution. Consider a function with branches(just an example to show the point): int foo(int param) { int a; if(param % 2) { int b = a; int c = a + b; printf("%d\n", c); } else { int d = a * 2; printf("%d\n", d); } } The actual stack layout will be formed, depending on the input parameter. Compile and check assembler code, if you do not believe. (-S flag for gcc). Everyone will call this a `runtime allocation`, even if you are not agree.
`char test[20];` is not in BSS - it's in stack (using that terminology - the C terms are "static" (without non-zero initializers) and "automatic" respectively. OP didn't actually specify whether it was at file scope (which would be BSS) or not, but "char *foo; foo = malloc..." is not valid at file scope either, so I assume both were intended to be at block scope. It's verging on 40 years since casting malloc was a good idea , it's pretty safe to give up on tailoring your code to pre-ANSI compilers now! 
Stack frames are optional. This function causes undefined behaviour by reading uninitialized variable (`a`). Also, the whole thing is easily optimized down to one line, and registers would be used instead of stack variables. Typically all of the automatic variables for the function will be allocated at the start of the function, by moving the stack pointer. In this case (if registers are not used and no optimization performed) it would still only need to allocate space for 3 ints, since `d` can be overlaid with `b`. 
This is one of the most important things that everyone else in here is missing: the array cannot be an lvalue, the variable storing the result of malloc can.
Note that the `malloc(x*sizeof(y))` idiom should be considered harmful due to the possibility of overflow. Check your arithmetic in situations like this. 
That's pretty crazy! Wonderful how C has so many different incarnations on such a wide variety of platforms. 
It was just a sample to show that stack layout may depend on a data, available only in the runtime. I can make any harder example to show this - with diferent types/etc, but did not want to overcomplicate the example. &gt; Typically all of the automatic variables for the function will be allocated at the start of the function, by moving the stack pointer. No, not always - variables, declared in conditional scope, will be pushed to stack only if this branch is executed(at least without optimizations, -O0). And as a said &gt; In easy cases the compiler may learn the actual layout of the stack frame for the function, but it is not true in general 
If you're new to programming, don't do this in C. C is not a My First Programming Language sort of tool. Choose whichever higher-level language seems to have the best resources *for you* and go with that. *Examples* of these languages are Python, Go and JavaScript (via Node.js).
The thing is that i'll need this script to run and check dozens of documents fast, atm there is like 200k documents and as far as i know c can do this really fast. I might got task larger than i can actually chew but it's that task that i was asked to do and i think that with challenges (even hard ones) valuable knowledge comes.
Tasks like this tend to be limited by I/O, so doing it in C probably won't give you a measurable speedup over e.g. Python or Bash.
&gt; The thing is that i'll need this script to run and check dozens of documents fast, atm there is like 200k documents and as far as i know c can do this really fast. Optimal C is probably faster than optimal Python but you will not write optimal C, you will write sub-optimal C because you don't have the experience. So, instead, using something like the nltk library with Python you might immediately get to say 20%-30% of the performance of optimal C and after some optimisation to within 50% but with "while program doesn't work copy and paste from Google"-style programming your C code will a) never work or b) if it does it'll have subtle bugs which will be triggered by 1000 of your 200k documents or c) if it is bug free it will run dog slow. Sorry, but that's the trade off point you're at. If your problem is so time critical that you can't suffer 50% the speed of optimal C, buy a second computer and do 100K documents on each.
I doubt whether 200k documents is possible at all. If you want to compare every document with every other document you have to do as much comparisons as there are different combinations of two documents. If my math is right for 200k documents you have to do around 2 * 10^10 comparisons. Please somebody correct me if I'm wrong.
&gt; Key of this, is that i need to make it to check each word and then calculate how many words are same between documents. Tried to Google that with no luck, best i could make is to show words and how many of them are in one and same document. Can you be a bit more specific about what you're trying to do? One interpretation of this is to output a list of all the words that appear in all the documents, and a count of how many documents each word appears in. Optionally, record which specific docs each word appears in. Another interpretation, suggested by /u/_joostb, is that you just want to figure out if all of the documents are the same. In which case comparing a quick hash might be the best call. In any case, I do not think C is the tool for this task, but before we can determine the correct tool, we need to nail down exactly what you are trying to do.
So i need to compare documents, comparison should work like this: takes each word of documents (let's say 2 documents in testing environment) and then it checks every word between these documents. After that diff between both documents must be calculated and outputted % of identical words.
So you basically want to make list of all the words in all the documents, with percentages of in how many of the documents these words appear?
I don't think C is your language then. If you wanted to compare each document to each other that is 2 loops: for (i=0; i &lt; numDocs; ++i) for (j=i+1; j &lt; numDocs; ++j) ..... Then you have to compare each word... I don't know how large are the files, but this is a lot of I/O work you can be possibly paging even while reading the same file. Loading this into memory and swapping out will slow down C (C makes a call to the system to load documents into memory. You can use aio, but then if you make too many requests you might run out of memory, depending on size of documents), so you might as well use BASH. Sed has some things you might want to use. If you would like to check if the files are identical it would make it a lot easier (You can use their checksum.) BTW if you are set on C, you can tokenize each document and make array with strings. Then sort both arrays (comparing 2 documents) and look at the words and their count. This should be in your nested loop so it will take long time. Let me know what you decide, I can point you to some BASH help, or if you stick with C, I can show you some memory management.
i'm sticking with C, and atm i'm trying to figure out how 2d array works. Basically i'm now rewriting code myself from scratch and trying to make it with double pointers and array. So far i hitted memory dump while trying to open and print second file contents (yes i'm doing this slow way, step by step to make sure i know where errors occurs and to learn)
You need to tell gcc in which directory to find the headers with the `-I` flag (upper case "i"). In your case, use this: `gcc -o main main.c -lImageMagick -lMagickWand -I/usr/include/ImageMagick`
Running your command, the response is another error: /usr/bin/ld: cannot find -lImageMagick collect2: error: ld returned 1 exit status Same when I change the order of the parameters to gcc -o main main.c -I/usr/include/ImageMagick -lImageMagick -lMagickWand PS: And to be sure: It's all there. ls -hal /usr/include/ImageMagick/ total 24K drwxr-xr-x 4 root root 4,0K Jul 3 19:22 . drwxr-xr-x 88 root root 12K Jul 3 19:22 .. drwxr-xr-x 2 root root 4,0K Jul 3 19:22 magick drwxr-xr-x 2 root root 4,0K Jul 3 19:22 wand 
Where are your libraries located? The files ImageMagick.so (or \*.a for static linking)? If they are not in a standard path like `/usr/lib`, you also need to add `-L/path/to/libs`. Not the full path to the files, mind you, just the containing directory.
I don't know what **ImgaeMagick.so** is. It does not exist on my computer, as **sudo updatedb; locate ImageMagick.so;** displays nothing. The libraries should all be there. ls -hal /usr/include/ImageMagick/ total 24K drwxr-xr-x 4 root root 4,0K Jul 3 19:22 . drwxr-xr-x 88 root root 12K Jul 3 19:22 .. drwxr-xr-x 2 root root 4,0K Jul 3 19:22 magick drwxr-xr-x 2 root root 4,0K Jul 3 19:22 wand PS: Same for **sudo updatedb; locate ImageMagick.a;**. Nothing. Is this a problem? 
How did you install ImageMagick?
I think it came with Ubuntu. Otherwise it must have been **sudo apt-get install imagemagick**. Today I only installed **sudo apt-get install libmagickwand-dev**. 
PS: Oh, that's interesting. For MagickWand the .so and .a files exist. /usr/lib/x86_64-linux-gnu/libMagickWand.so /usr/lib/x86_64-linux-gnu/libMagickWand.so.5 /usr/lib/x86_64-linux-gnu/libMagickWand.so.5.0.0 /usr/lib/x86_64-linux-gnu/libMagickWand.a Maybe I should reinstall imagemagick? 
PS: I also have libMagickCore.so and libMagickCore.a. Maybe those are for ImageMagick? $ ls -hal /usr/lib/x86_64-linux-gnu/*Magick* -rw-r--r-- 1 root root 4,4M Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickCore.a -rw-r--r-- 1 root root 1012 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickCore.la lrwxrwxrwx 1 root root 22 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickCore.so -&gt; libMagickCore.so.5.0.0 lrwxrwxrwx 1 root root 22 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickCore.so.5 -&gt; libMagickCore.so.5.0.0 -rw-r--r-- 1 root root 2,5M Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickCore.so.5.0.0 lrwxrwxrwx 1 root root 20 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagick++.so.5 -&gt; libMagick++.so.5.0.0 -rw-r--r-- 1 root root 417K Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagick++.so.5.0.0 -rw-r--r-- 1 root root 2,3M Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickWand.a -rw-r--r-- 1 root root 1012 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickWand.la lrwxrwxrwx 1 root root 22 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickWand.so -&gt; libMagickWand.so.5.0.0 lrwxrwxrwx 1 root root 22 Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickWand.so.5 -&gt; libMagickWand.so.5.0.0 -rw-r--r-- 1 root root 1,1M Mär 6 20:05 /usr/lib/x86_64-linux-gnu/libMagickWand.so.5.0.0 
I solved it now. The compile command must be **gcc -o main main.c -I/usr/include/ImageMagick -lMagickCore -lMagickWand** Thanks for the help, Nimbal. 
Note that `/usr/include/` only contains the *headers*, not the libraries themselves. The headers are kind of like tables of content for the compiler. The library files (\*.so or \*.a in Linux) are what contains the actual (compiled) code of the library. The library files should be located in `/usr/lib`, probably in a subdirectory. You can also use `dpkg-query -L imagemagick` to print a list of files installed with the imagemagick package, among them should be the .so or .a files. I dimly remember that I had to install `dpkg-query` last time I wanted to use it on a fresh Ubuntu install, but if you try the command and it's not installed, Ubuntu should tell you what package you need.
I solved it now. The compile command must be **gcc -o main main.c -I/usr/include/ImageMagick -lMagickCore -lMagickWand** Thanks for the help, Nimbal.
Glad to hear it!
Scanf and error recovery is hard. Read a line at a time and parse it instead. 
Future note: pkg-config is almost always the easiest way to determine library and package dependencies for your application. You should use it religiously. gcc -o main main.c \`pkg-config --cflags MagickWand\` \`pkg-config --libs MagickWand\`
scanf stops reading input when it hits a character it can't match. So when you're entering eg. &gt; 3 s 5 &gt; 4 2 6 scanf does the following: * read 3, match, store in pm * read s, not match, stop reading from stdin Your do-while continues executing since scanf only matched the first result. next iteration, scanf: * reads 5 from stdin (the 5 from the last line, 3 s 5) -&gt; pm * reads 4 from stdin (from the new line you entered) -&gt; pn * reads 2 from stdin -&gt; pq * since it has now matched its 3 ints specified by the format string it stops reading here You end up with 5 4 2 in pm pn pq, respectively. To avoid this I would suggest that you read line by line into a buffer using eg. fgets on stdin and then do sscanf on that. Sadly, there's no snscanf in C90 or C99 so it's a tricky to make it safe from buffer overflows. (Apparently, there's an optional sscanf_s in C11). You could also run getchar until you hit a '\n' *inside* the do-while to throw away all superfluous input from the line sscanf failed to parse. Like so: void dados (int* pm, int* pn, int* pq) { int tmp = 0; do { tmp = scanf("%d%d%d", pm, pn, pq); while(getchar() != '\n'){} } while ((tmp != 3 || *pm &lt;= 0 || *pn &lt;= 0 || *pq &lt;= 0 || *pq &gt; *(pm) * *(pn))); } 
I have all the books on C, third edition of ABC. ABC is my absolute favorite of all the C books out there. Its definitely an introductory book but if you're looking to learn C, you can't do any better IMO.
I forget if arrays work the same as how a pointer would... But I think.... Because the lines in the loop say "s++" what they are doing is increment ing the pointer to the first element of the string. Since strings are just character arrays, increment ing a pointer to a character array would increment where the variable points to in memory by 1 byte each time.
You are correct. Arrays are pointers, it's just a different way of doing pointer math. You use ptr[offset] instead of ptr+offset. Both ways still increment, in the case of chars, 1 byte per increment of the offset. In this case the code is doing: set char s[0] to char t[0], if result != \0 continue loop increment where s[0] points increment where t[0] points If you were wondering, there is no need for a return string or ptr here, since this method works on the char arrays as they exist in memory without creating a new duplicate. Also your option of incrementing the offset, would be just fine as well, provided you initialized i at 0.
Your version is incorrect because you increment i twice on every loop iteration. You end up skipping some chars and will run off the end of t if happen to skip over its terminating null. Also, both version are incorrect because you're testing for a terminating zero character instead of a Nul - i.e. '\0'. I assume that's just a typo. try: while ((s[i] = t[i])) != '\0') ++i; Consider this even terser version of the first - you might find it instructive: while ((*s++ = *t++) != '\0'); And this can still be shortened up, the != '\0' can be eliminated.
&gt; Arrays are pointers Well, no, they aren't. Arrays and pointers are two different things. What you have in this function are pointers, which (initially) point to the first elements of two arrays. &gt; You use ptr[offset] instead of ptr+offset. Actually `ptr[offset]` is equivalent to `*(ptr+offset)`, not just `ptr+offset`.
Also this version is faster, because a array access need a multiplication (i*sizeof(char)). 
Great question. This is the corner of the learning curve in C. Pointers are unsigned integers. Drum that into your brain - they are memory addresses, which are unsigned integers. I'll say it again: pointers are unsigned integers. The first implementation is incrementing the ~~pointers~~ unsigned integers `s` and `t` in the loop body. Hence s[0] = t[0] means something different on each iteration - index 0 in those arrays is changing each time `s` and `t` are incremented. When that function enters, `s` and `t` are *not* strings, in fact at no point ever in the execution of a C or C++ program are any character pointers strings. They are unsigned integers - because pointers are unsigned integers. The characters residing at the addresses pointed at by those pointers might be strings; but `s` and `t` are pointers, and thus they are unsigned integers. Pointers are unsigned integers. Got it? Good. :) Note that char s[], char t[] is a cute way to declare pointers in the argument list to `strcpy1()`. It's equivalent to char * s, char * t but only when declared as arguments to a function. If you were declaring ordinary variables, you would need to use the size subscript, e.g. char s[20]; char t[20]; or provide a constant initializer, e.g. char s[] = "Hello, world!"; char t[] = "This is a string literal."; Although `s` and `t` are (mechanically speaking) still pointers (which are unsigned integers), you would *not* be able to increment them or change them. It only works in your `strcpy1()` because they are function arguments. Now - the second loop you wrote wouldn't work. Assuming `i` is an integer that's initialized to 0 before the loop, it's getting incremented twice in the loop body. Also, s[i++]; t[i++]; doesn't do anything to `s` or `t`. It would probably warn you about that if it didn't fail to compile at all. If it did compile, it increments `i` *twice* - every other character would get copied instead of *every* character, and there's a 50/50 shot you'd miss the terminating `'\0'` and the program would crash. This would work: int i = 0; while (( s[i] = t[i]) != '\0' ) i++; Note that `i` only gets incremented once in the loop body, and it isn't trying to subscript `s` or `t`. The first function might be less confusing if it were written like while (( *s = *t) != '\0' ) { s++; t++; } and it would work just the same. For a pointer `s`, `s[0]` and `*s` mean the same thing. Similarly, `s[1]` and *(s + 1) mean the same thing. But it could even be while (( *s++ = *t++) != '\0' ) ; The character `s` points to is assigned the value that `t` points to. Then both `s` and `t` are incremented. (Note: now that I've repeated "pointers are unsigned integers" lots of times, remember that different computers use different size memory addresses; they are unsigned integers in the same way `unsigned char`, `unsigned int`, `unsigned long` and `unsigned long long` are all unsigned integers. Don't store memory addresses in regular integer variables, but *do* consider that no matter what you're pointing to - floats, structures, characters, or even void - whatever - all memory addresses are unsigned integers, mathematically.) **Edit:** One last thing: '0' == 48 and '\0' == 0 In both of your loop heads, you're comparing the result of the assignment to 48, which does *not* terminate strings. You can either use while (( s[0] = t[0]) != '\0' ) or while (( s[0] = t[0]) != 0 ) but *not* while (( s[0] = t[0]) != '0' ) The last line compares against the value of the ASCII character '0', which is 48.
Thanks for your time 
No problem, happy to help. Let me know if you'd like clarification or further explanation about anything.
&gt; Arrays are pointers, it's just a different way of doing pointer math. Arrays aren't pointers, though they can *convert* into one to the first element. In this case, strcpy1 isn't passed an array, because the function is actually declared to take two pointers. void f( int p [1234] ); is actually treated as void f( int* p );
&gt; Also this version is faster, because a array access need a multiplication (i*sizeof(char)). Multiplying by one is a no-op, and sizeof(char) is defined to always be 1. And if it weren't 1, modern compilers will optimize the code to move the multiplication out of the loop if it matters. Just say no to premature optimization and write what is clear.
Pointers are NOT unsigned integers. (If I say it 3 times does that make it true?) 
Hello, Sorry I just saw your comment. It took us about 3 years to program (with hobby schedules), but we have a contest per year so the code must be in a working (but not perfect condition) after a year. We designed every aspect of the robot : mechanics, electronics and software, everyone in the team has his own field of expertise.
I can imagine. :) It is cool how you (and the team) did it all yourself, I thought it might be a pre-made robot that you wrote some code for.
Yeah i know that but the thing i dont know is how to get it to run the file. Do i have to save the .c file to the same place as some other application? I have done some html projects for school and i have had to do that with media files; saving them all in the same folder as the source code. 
Care to explain what a C compiler would make of 0[s] (Where 0 is a zero in case of foncusion and s is an array (or pointer))
Are you doing this because you want to program, or just get a task done? If the latter, look into the 'rename' command, which may fit your needs perfectly. If the former, why use C when you could do this in a couple of lines of Perl?
Oh, I mainly just wanna program! I am sure there are a lot of different ways to do this, I just enjoy taking on these silly tasks via programming, could use all the practice I can get! But for sake of curiosity, is the rename command a linux command?
Heh. Ok. Ok. Just teasing you. Actually he is missing the horrid possibility of "near" and "far" segmented address space pointers. Anyhoo. I have come around to the attitude that I don't like pointers at all. They are basically unsigned integer like names for objects in a process wide global namespace. Implicit in the standard is each pointer should be associated with some arrayish or malloced subspace, but that is just standardese with little or no support at the compiler or libc level. So in C/C++ these days I'm favouring array plus index over bare pointer. But the more I see of them in action, the more I'm convinced Alexandrescu is really on to something better than both with [D ranges.](http://www.informit.com/articles/article.aspx?p=1407357)
 char *command = ("mv %c %dd",c,currentNumber); If you're trying to build a string to be used in a command try looking into the standard string library functions like strcat you can't actually use string format specifiers to build strings like that in C. system("ls | grep .gif &gt; list.txt"); Instead of writing the output of ls to a file a more simple solution might just be to have the program accept a list of file names as arguments so you could just pipe in the output of ls. So you could use it like this: ls *.gif | myProgram Also there are a couple of other things you could fix about your program. char *c = fgetc(inFile); This declares a pointer to a char and not actually a byte of memory so you're trying to assign a char to a pointer which would likely produce an error. while (c!=EOF) A more clear way to iterate through a file would be something like this. char c; while((c = fgetc(inFile) != EOF) //Line contining original file name c = fgetc(inFile); This does not get the next line of the program it instead gets the next char or byte. If you want to read a whole line use fgets. 
Nice, thanks for the tips!
I think you're looking at it a bit backwards. The standard gives the minimum guarantees for what pointers must be capable of. This is so that system A with segmented architecture, hardware address trap checking, etc. etc. , and system B with unprotected flat memory model, can both comply with the C standard without having to jump through hoops. In fact the C standard supports "fat pointers": each pointer can contain an address, plus the address and bounds of the object that it points to. So runtime bounds-checking can be implemented by compilers. Few compiler vendors actually seem to do this, so I guess there is not much customer demand for it. In C++ you don't need to use pointers at all. Unfortunately they have to exist for backwards compatibility.
 void strcpy(char *d, char *s) { while (*d++ = *s++); } 
This sounds like a homework question. We aren't just going to do your homework for you. What are your thoughts about the problem? What don't you understand? What do you have so far? Where are you stuck?
They form a 16-bit value. data[32] is the low byte. data[33] is the high byte.
If you work this out on paper it will be immediately obvious what is happening. Write out `0x1c` and `0x00` in binary, do the bitshift and bitwise OR manually, then convert the result back to hex. You'll see exactly what has happened.
&gt; But for sake of curiosity, is the rename command a linux command? It's actually a Perl script. Depending on your distro, it's usually a symbolic link in /usr/bin/ .
You could try writing a little program to calculate and show you the results.
Cool, thanks a lot. I will try that for now, I appreciate your help! 
I don't know that I've really been any help to you. I like doing what you are doing (programming something myself just because). Perhaps looking at the Perl script will give you a few clues to implement in your own program.
&gt; char q1[] = ""; This declares an array of `char` of length&amp;nbsp;1, because the initializer you have used is a string of length&amp;nbsp;0, so an array of length&amp;nbsp;1 is needed to hold that string (including the null character `'\0'` at the end). Because of this, the array&amp;nbsp;`q1` is only large enough to hold a string of length&amp;nbsp;0. It is not big enough to hold any longer string. If you attempt to write a longer string to the array&amp;nbsp;`q1`, then you will be writing past the end of the array, which is undefined behavior, which means you have no guarantees about the behavior of any part of your program. &gt; q1[0] = askChar("Enter your name: "); This (apparently) assigns a value to `q1[0]`, which is the first (and only) element of the array `q1`. I don't know what the `askChar` function does, because you posted code for `askDouble` instead of `askChar`, but let's suppose that this function returns the `char` value&amp;nbsp;`'B'`. Then this line assigns the value&amp;nbsp;`'B'` to `q1[0]`. And that is the only thing in the array&amp;nbsp;`q1`. There are no more elements of the array&amp;nbsp;`q1` past `q1[0]`, because `q1` is an array of length&amp;nbsp;1; the first and only element of that array is `q1[0]`. &gt; printf("%s \n", q1); But now there's a problem, because the `%s` specifier tells the `printf` function to keep reading elements of the `char` array that you pass it until it reads a null character `'\0'` marking the end of the string. Well, the first character of the array&amp;nbsp;`q1` is&amp;nbsp;`'B'`, so `printf` prints that. Then, because it hasn't read a null character yet, it will attempt to go on to the next element of the array; it will attempt to read `q1[1]`. But that element does not exist. At this point your program is attempting to read past the end of an array. This means your program has undefined behavior, which means you have no guarantees about the behavior of any part of your program. I am not sure what you are trying to accomplish in this program, but this is the reason that your program is not working correctly as written.
Thank you! I just replaced the function, which I noticed was the wrong one.
 #include &lt;stdio.h&gt; ... rename(oldname, newname);
but what %i stands for? aren't the %d and %i the same?
Also, You are making an array on the stack in function askChar. When returning compiler could override this with some other information later on and it still would be wrong.Luckily you are not making any other calls and your string is still there, however that is a bug. Use malloc to assign memory. Use free to return memory when you are done with it back to system.
**EDIT:** I just got it, except it breaks when adding spaces. Example: Beginning program... Enter your name: JohnHenryEden JohnHenryEden President-JohnHEden:C aleksandr$ ./name Beginning program... Enter your name: John Henry Eden John **EDIT 2** I just fixed the problem. This page http://stackoverflow.com/questions/1247989/how-do-you-allow-spaces-to-be-entered-using-scanf showed how to fix it. scanf("%**[\^\n]**s", text); **–––––––––––––––––––––––––––––––––––––––––––––––** Thanks, that seemed to help. I have changed it to this: **stdfn.h** char *askChar(char *question) { char *text = malloc(200*sizeof(char)); printf("%s", question); scanf("%s", text); //printf("The string is: %s \n", text); return text; } **name.c** #include &lt;stdio.h&gt; #include "lib/stdfn.h" #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char *q1 = malloc(200*sizeof(char)); printf("Beginning program...\n"); q1 = askChar("Enter your name: "); printf("%s \n", q1); } 
You don't have to malloc memory in main, because later you overwrite it with new pointer information. That is a memory leak. Now if you check out scanf you will notice that for argument %s it doesn't read in white spaces. If you would like to skip first white space do " %s" You could also look into some other functions, there are functions that can get an entire line, including spaces. Check out cplusplus.com and go to cstdio.h Change return statement to char* askChar and return text instead of return *text
Thank you for mentioning that. I just removed the malloc() in main().
&gt; You are making an array on the stack in function askChar. When returning compiler could override this with some other information later on and it still would be wrong. No, OP is returning the *value* `*text`, not a *pointer* to an array on the stack.
On one hand, I love that compilers are taking advantage of this kind of semantic information in programs in order to optimize better. On another, I worry that decades-old code has latent bugs around this that are only made manifest by recent compiler optimizations, ones which make minimal improvement to program functionality (because the programs aren't calculation-intensive). I'd rather have a minimal optimization mode used for most code and aggressive optimization like this only used for calculation-intensive code. I don't know how this could be achieved without acting to accommodate these latent bugs and let them live even longer.
&gt;&gt; One nightmare scenario is if the compiler inferred that the condition unlinked != NULL within the do is true for all defined values of unlinked, the only values that matter. Such a fact can be inferred with purely local reasoning &gt; It's actually the opposite: unlinked != NULL as the loop condition will only be false for defined values. You are right. This is an oversight in the post. So it would appear at first sight that the consequence of this undefined behavior, if it caused this optimization, would be a resource leak where only the first matching element of the linked list would be removed, instead of all of them. With any secondary consequence that the non-removal of elements after the first one might have too. (I need to investigate with the definition of the types and macros at hand.)
+1! Maybe, "How do I write to disk asynchronously" ?
http://stackoverflow.com/questions/1893490/difference-between-format-specifiers-i-and-d-in-printf
From what I can tell C89 has the same undefined behavior: &gt; 1.6 DEFINITIONS OF TERMS [...] * Undefined behavior --- behavior, upon use of a nonportable or erroneous program construct, of erroneous data, or of indeterminately-valued objects, for which the Standard imposes no requirements. Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). &gt; &gt; 3.1.2.4 Storage durations of objects [...] Storage for the object is no longer guaranteed to be reserved when execution of the block ends in any way. (Entering an enclosed block suspends but does not end execution of the enclosing block. Calling a function that returns suspends but does not end execution of the block containing the call.) The value of a pointer that referred to an object with automatic storage duration that is no longer guaranteed to be reserved is indeterminate. &gt; &gt; 4.10.3 Memory management functions [...] The value of a pointer that refers to freed space is indeterminate. 
I stand corrected and educated. Thank you for taking the trouble to look it up.
The shift in time is more from undefinedness in the standard to accommodate the variety of hardware, to undefinedness as an excuse for agressive optimization. Signed arithmetic overflow was already undefined in C89 because then it seemed important to include non-2's-complement architectures. In the late nineties compilers began to use it to optimize (e.g. int f(int x){ return x+1&gt;x; }), and they would compile function f to return 1; even if you knew that you had a two's complement computer. Similarly, accessing indeterminate memory (uninitialized variables and dangling pointers) used to be undefined because some architectures *could* have trap representations, but now it is just an excuse for considering that some executions paths are dead, even if you know that your computer does not have trap representations: http://blog.frama-c.com/index.php?post/2013/03/13/indeterminate-undefined
&gt; using the value of a dangling pointer in a way that most developers consider harmless, such as pointer arithmetics or as operand of a comparison. Seriously, most developers consider that usage "harmless"?? What the fuck do people think the compiler does, guess what you're trying to do?
The integer value zero is considered false, and any other integer is true. So `!conn` and `conn == 0` are equivalent. But they are not equivalent to `conn != true`. `true` is only available if you're using C99 and you've included `&lt;stdbool.h&gt;`, in which case it's defined to the integer constant 1. So this is really `conn != 1`, and hopefully it's obvious why that's not the same as the others: if `conn` is 2 for example, `!conn` is false but `conn != true` is true. You haven't specified what type `conn` is, so I'm assuming it's some kind of integer type other than `bool`, but who knows. Posts that consist of just a headline are virtually always too vague to be answered in full. 
I like head first C.
In a way it is rather surprising that the reference (i.e., the pointer's bit-pattern itself and not just its denotation) changes when passed by value, even if the function receiving it as a parameter has side-effects. I mean, it's logical (nothing says that C pointers must be represented as machine addresses, or that they will not change when the pointed-to contents do) but unexpected (in most architectures C pointers do represent machine addresses, and the address doesn't change when its contents do.)
Why would `true` be defined as `(1==1)`? The result of the comparison operators is either the integer 0 or the integer 1, so `(1==1)` is 1 and that would be entirely equivalent to just defining it as 1. 
There was no boolean type before C99, so all comparisons are defined to yield a value of 1 or 0 of type int. I don't know why they chose 1 for that, though.
Yes, the *result* of the operator == is internally represented as the integer 1 but if you evaluate the expression "1" it is an integer first and foremost whereas the expression (1==1) is a boolean expression of "true". It is purely semantics as internally its all the same but to me, externally, it makes a subtle but distinguishable difference. Edit: I also generally dislike using constants with a #define without specifying type. It can lead to assumptions on behalf of the compiler and the developer. Something like #define true ((int)1) would be less ambiguous (yes yes even through the default data type is int...its just good practice). Again I'm not saying its wrong, I am just curious as to what, if any, other options were considered for use in the header and what the decision process was.
See my response to Rhomboid here http://www.reddit.com/r/C_Programming/comments/2a4zjj/is_ifconn_the_same_as_ifconn_true_or_ifconn_0/cirqf4a
See my response to Rhomboid here http://www.reddit.com/r/C_Programming/comments/2a4zjj/is_ifconn_the_same_as_ifconn_true_or_ifconn_0/cirqf4a
This is why the boolean data type was eventually introduced, and in languages where it is native comparators usually return boolean data types. Functionally, it is all the same, but it makes the language line up a little more closely with the math. You have to remember that the math is incredibly useful, but ultimately in programming practical matters are more important than theoretical. '1 == 1' is a computation, so using that to symbolically mean 'true' would either add an extra comparison or force the redesign of the way the '==' operator works. C was designed to be as efficient as possible, and adding a couple extra cycles on something as commonly used as the '==' operator would be a poor design decision. And why change the way the operator works when you can just use the literal '1' and everybody understands exactly what that means? Is it less elegant? I guess that depends on your perspective. I would rather have something simple and direct.
Get the K&amp;R Book 2nd Edition, it's the C bible! ;)
&gt; whereas the expression (1==1) is a boolean expression of "true". It's kind of arbitrary, though: why not `('h'=='h')`? `!false` seems reasonable, but then you have the same issue with false. &gt; It is purely semantics as internally its all the same but to me, externally, it makes a subtle but distinguishable difference. I think this is just beyond the scope of standard header files. &gt; Something like #define true ((int)1) would be less ambiguous But it wouldn't work in the preprocessor. &gt; I am just curious as to what, if any, other options were considered for use in the header and what the decision process was. I don't know if that's recorded anywhere... you might have to ask someone who was there. But it would be interesting to know.
One is an example of good, clean code; the other two are not.
*s checks if its null (value where s is pointing, null evaluates to false(0)). If it isn't it increments s to next char over
So wouldn't it be more correct to write it like this? size_t strlen(const char *str) { const char *s = str; for (s ; *s; ++s) ; return (s - str); } 
Here it is rewritten a little more simply: size_t strlen2( const char* str ) { const char* end = str; while ( *end != '\0' ) end = end + 1; return end - str; } Pretty evidently if you do end=str, then end=end+n, end-str will equal n.
Perfect thanks! 
You could use anything that is a literal constant and the == operator, yes. Even 0==0. Once you have either false or true declared, use the inverse to define the other. Oh yea, WAY beyond scope of headers like this for sure. Why would it not work in the preprocessor?
C didn't have a boolean type until 1999. Also, `1` is already an int, `((int)1)` is a waste of typing. Before C99 it was common to have setups like: typedef int bool; enum { FALSE, TRUE }; 
Well, your `s;` in the for-loop is redundant. Can you explain why you think this is "more correct" than the original? gblargg's version is easier to read. 
So you don't actually use the `"%[^\n]"` in your code. BTW you misquoted it, there should not be an `s` on the end. Also you should limit the input to be `199` or less.
I'd argue it isn't a waste at all :) What if I have a macro that doesn't specify the storage qualifier, int is assumed and I bit shift it 20 bits to the left on different architectures? An arch with ints &gt; 16 bits would be ok but on some that it is 16 bits...not so good. It could be, depending on the compiler, automatically scaled up to long int which violates my assumption it will be an int or result in zero which violates my assumption as a programmer. I've seen it, its horrid to track down and makes you want to always either define it using const (const int true = 1) or with a cast in the macro so type is enforced (#define true ((int)1). Edit: I'm not suggesting that you would ever shift true around...just replace "true" with "myconst" or whatever.
Ah ok I see what you are saying. Using it in a preprocessor directive would not work. I haven't tried but yea I don't think that would work so well.
Eh? If `1 &lt;&lt; 20` is undefined then so is `((int)1) &lt;&lt; 20`. `1` is always an `int` . There is no such thing as "enforcing that `1` is an int" . 
I was talking about macros in general, not this specific case. Sorry, I made that ambiguous by then using the example in the following paragraph. Folks get in trouble a lot with loose typing so it can't hurt for the programmer to specify type. Default types are easier to get away with so it doesn't bite often. 
&gt; whereas the expression (1==1) is a boolean expression of "true" No, it's not. C99 &amp;sect;6.5.9/3, emphasis mine: &gt; The == (equal to) and != (not equal to) operators are analogous to the relational operators except for their lower precedence.^(90) Each of the operators yields 1 if the specified relation is true and 0 if it is false. **The result has type int.** For any pair of operands, exactly one of the relations is true. There is no semantic difference between `1` and `1==1`, they are both integer expressions according to the standard. 
Yea....that's what I said. Internally it's the same and it's semantic. 
I can answer a few of those. First, when considering how to split-up a program, I wouldn't say I'm extremely experienced but in general for smaller programs splitting it into libraries just adds extra unneeded complexity. One of the nice things about C though is that you can delay this choice for a fairly long time. In general, you want to setup your build system to compile your .c files into .o files, and then link them into your program at the end. Making a library is nothing more then linking those .o files into a .so or .dll or etc.. So while there are some touch-up things you'd want to do to make it a bit cleaner (Ex. only export the symbols you want people accessing), converting some code into an external library is fairly easy to do, relatively speaking. Because of that, assuming you design your code to be decently modular, it shouldn't be too painful to split code into a library if people think it would be useful. As far as licensing goes, the only real concern is the LGPL and GPL. Specifically, if you dynamic-link *or* static-link against a GPL library, then your program *has* to be GPL or GPL compatible. However, if you dynamic-link against a LGPL, then your program *doesn't* have to be LGPL or compatible. If you static-link against LGPL though, then it does have to be LGPL or compatible. Either way, if you make your program GPL or compatible, you can dynamic-link or static-link as much as you want and distribute the binaries, you just have to provide a copy of the GPL and where to find the sources for your code and the libraries. Of course, I'm not a lawyer, but honestly as long as you put in a decent effort in making it possible to find the sources, I wouldn't worry about it much. I wouldn't lose any sleep over it. Also worth noting, as far as distributing goes, it's different for every platform. On Windows, it's not too uncommon to just distribute bare DLL's with the EXE (Especially since Windows will look for the DLL's in the EXE's folder). On Linux this is very uncommon since by default the system won't find .so files just sitting in the same directory as the executable, and you don't want people directly installing .so or executables (Instead installing via a package manager). Distributing a binary on Linux is much easier if you just static link, or create packages for the relevant distros.
Thanks. I tried the space and *%10[0-9a-zA-Z ]s*, but they didn't work. I made sure that it had the *s* on the end.
The `s` there only matches the actual letter `s` in the input. Whether `0-9` etc. is supported is implementation-defined. 
OK, I misread that. I just removed it.
If you DO want to include the .so files directly, you just need to launch via a shell script that sets the LD_PRELOAD environment variable to include the path to your libraries, to add a bit more.
There is no semantic difference between `(1==1)` and `1`. They're the same thing. There's only a semantic difference if you're confused about how C works.
The value of the initialisation of the for loop (the first part inside the parentheses) is never used; it exists solely to side-effect.
Do things normally, but put the #include for the other header between the declarations and inline function definitions: // a.h #ifndef A_H #define A_H struct foo { int x; }; struct bar; static void f1( bar* ); #include "b.h" static inline void f1( bar* b ) { b-&gt;y = 123; } #endif // b.h #ifndef B_H #define B_H struct bar { int y; }; struct foo; static void f2( foo* ); #include "a.h" static inline void f2( foo* f ) { f-&gt;x = 456; } #endif 
Don't define things in header files, declare them in the header file and define them in a source file.
There are two commonly accepted ways: a) a "types" header, where the structs are defined. #ifndef TYPES_H #define TYPES_H typedef struct { int dummy; } DummyOne; typedef struct { DummyOne *left; DummyOne *right; } DummyNode; #endif /* TYPES_H */ The advantage is this method will Always Work (tm)*. The downside is that it puts you at a huge disadvantage on large projects, as changing the "types" header can cause all dependent files to be needlessly rebuilt. (This is especially excruciating on very large templated C++ projects). This can be mitigated with smaller "types" headers, e.g. if 3 structs have tight coupling, but the rest are mostly independent, just use a "types" header for those 3, and include the rest normally. b) including the headers in an order where circularity isn't an issue. (see gblargg's post). This way can break down quickly if the coupling between several objects is very tight. Notice, the real solution would be to loosen the coupling where possible. Sometimes this is unavoidable, but often with some extra planning and thought, it can be worked around. Then again, a lot of developers are just very lazy and that's why you tend to see a lot of huge types headers. Please note that the worst thing you can do is replace typed pointers with void pointers and cast - use this only as an absolute last resort. *: for most values of "always." I have seen this method fail, but only by someone thoroughly committed to writing the worst code known to man.
Semantics aka syntactical difference which is exactly what this is. Same meaning, different expression. Believe me I'm not confused :) &gt;According to Euzenat, semantics "provides the rules for interpreting the syntax which do not provide the meaning directly but constrains the possible interpretations of what is declared." http://en.m.wikipedia.org/wiki/Semantics
&gt; Semantics aka syntactical difference No, syntax and semantics have very little to do with each other. Again, there is no reason to define `true` to be `(1==1)`. That just evaluates to `1`. They are the exact same quantity. If you think they *aren't* the exact same quantity, then you're probably looking at the C language the wrong way.
Honestly C is possibly your worst choice for such an application. Python would be mine. Very easy to build a UI, very easy to play a song, and generally very quick way to organize this kind of data. Now, I don't really understand. What stops you from say, downloading the required video and playing them in VLC while organizing a playlist? I'm all for finding little projects to build a skillset, but this one will be extremely tedious and not very interesting data-wise, IMO. You will spend most of your time building the UI, you will either end up with something barely user-friendly or taking an extremely long time to develop, for a functionality that is already extremely easy to find elsewhere. However, if you reaaaaally want to do it, do it in Python. C is a pain in the ass for building a GUI. If you reaaaaally need to use C, use GTK+.
&gt; No, syntax and semantics have very little to do with each other. If you insist... But I don't think you are reading what I'm writing. I *know* they both evaluate to 1 and that is my point. I was curious as to why they chose to use the strict evaluation value instead of the actual input to generate the value (aka (1==1)). I'm not saying its wrong and never did. I just want to know if there is a real valid reason to use the current definition or if the alternate is sufficient. So far nobody has been able to assert that using (1==1) is wrong in any way. Since there are multiple ways of expressing the same thing, I simply was curious as to why the author chose one over the other. It may be as simple as "it doesn't matter".